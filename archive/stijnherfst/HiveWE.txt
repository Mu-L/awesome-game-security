Project Path: arc_stijnherfst_HiveWE_z_fnsawz

Source Tree:

```txt
arc_stijnherfst_HiveWE_z_fnsawz
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── README.md
├── Screenshots
│   ├── HiveWE.png
│   ├── ObjectEditor.png
│   ├── PathingEditing.png
│   └── TriggerEditor.png
├── data
│   ├── icons
│   │   ├── brush
│   │   │   ├── circle.png
│   │   │   ├── diamond.png
│   │   │   └── square.png
│   │   ├── buildable.png
│   │   ├── check.png
│   │   ├── doodad_palette
│   │   │   └── merge.png
│   │   ├── flyable.png
│   │   ├── model_editor
│   │   │   └── background.png
│   │   ├── object_editor
│   │   │   ├── background.png
│   │   │   └── search.png
│   │   ├── pathing_palette
│   │   │   ├── export.png
│   │   │   └── import.png
│   │   ├── ribbon
│   │   │   ├── VARIATION32X32.png
│   │   │   ├── WarIII32x32.ico
│   │   │   ├── brush32x32.png
│   │   │   ├── changeheight32x32.png
│   │   │   ├── click_helpers.png
│   │   │   ├── copy32x32.ico
│   │   │   ├── debug32x32.png
│   │   │   ├── description32x32.png
│   │   │   ├── doodads32x32.png
│   │   │   ├── exit32x32.ico
│   │   │   ├── height.png
│   │   │   ├── heightmap32x32.png
│   │   │   ├── importmanager32x32.png
│   │   │   ├── lighting32x32.png
│   │   │   ├── loading32x32.png
│   │   │   ├── lock.png
│   │   │   ├── minimap32x32.png
│   │   │   ├── model_editor.png
│   │   │   ├── new32x32.ico
│   │   │   ├── objecteditor32x32.png
│   │   │   ├── open32x32.png
│   │   │   ├── options32x32.png
│   │   │   ├── paste32x32.ico
│   │   │   ├── pathing32x32.png
│   │   │   ├── redo32x32.ico
│   │   │   ├── redo32x32.png
│   │   │   ├── reset32x32.png
│   │   │   ├── rock32x32.png
│   │   │   ├── save32x32.png
│   │   │   ├── saveas32x32.png
│   │   │   ├── scale32x32.png
│   │   │   ├── select32x32.png
│   │   │   ├── sizebounds32x32.png
│   │   │   ├── switch32x32.png
│   │   │   ├── test32x32.ico
│   │   │   ├── tileset.png
│   │   │   ├── tileset32x32.png
│   │   │   ├── triggereditor32x32.png
│   │   │   ├── undo32x32.ico
│   │   │   ├── undo32x32.png
│   │   │   ├── units32x32.png
│   │   │   ├── water32x32.png
│   │   │   └── wireframe32x32.png
│   │   ├── terrain
│   │   │   ├── boundary_place.png
│   │   │   ├── boundary_remove.png
│   │   │   ├── brush_lower.png
│   │   │   ├── brush_plateau.png
│   │   │   ├── brush_raise.png
│   │   │   ├── brush_ripple.png
│   │   │   ├── brush_smooth.png
│   │   │   ├── deep_water.png
│   │   │   ├── level.png
│   │   │   ├── lower1.png
│   │   │   ├── lower2.png
│   │   │   ├── raise1.png
│   │   │   ├── raise2.png
│   │   │   ├── ramp.png
│   │   │   └── shallow_water.png
│   │   ├── trigger_editor
│   │   │   ├── background.png
│   │   │   └── validate.png
│   │   └── walkable.png
│   ├── overrides
│   │   ├── Objects
│   │   │   └── InvalidObject
│   │   │       └── invalidobject.mdx
│   │   ├── ReplaceableTextures
│   │   │   └── WorldEditUI
│   │   │       ├── doodad-bridge.dds
│   │   │       ├── doodad-cinematic.dds
│   │   │       ├── doodad-cliff.dds
│   │   │       ├── doodad-destructible.dds
│   │   │       ├── doodad-environment.dds
│   │   │       ├── doodad-prop.dds
│   │   │       ├── doodad-structures.dds
│   │   │       └── doodad-water.dds
│   │   └── Units
│   │       ├── ItemMetaData.slk
│   │       └── UnitMetaData.slk
│   ├── shaders
│   │   ├── brush.frag
│   │   ├── brush.vert
│   │   ├── cliff.frag
│   │   ├── cliff.vert
│   │   ├── editable_mesh_hd.frag
│   │   ├── editable_mesh_hd.vert
│   │   ├── physics_debug.frag
│   │   ├── physics_debug.vert
│   │   ├── selection.frag
│   │   ├── selection.vert
│   │   ├── selection_circle.frag
│   │   ├── selection_circle.vert
│   │   ├── skinned_mesh_hd.frag
│   │   ├── skinned_mesh_hd.vert
│   │   ├── skinned_mesh_instance_color_coded.frag
│   │   ├── skinned_mesh_instance_color_coded.vert
│   │   ├── skinned_mesh_sd.frag
│   │   ├── skinned_mesh_sd.vert
│   │   ├── terrain.frag
│   │   ├── terrain.vert
│   │   ├── water.frag
│   │   └── water.vert
│   ├── test map
│   │   ├── conversation.json
│   │   ├── war3map.doo
│   │   ├── war3map.imp
│   │   ├── war3map.mmp
│   │   ├── war3map.shd
│   │   ├── war3map.w3b
│   │   ├── war3map.w3c
│   │   ├── war3map.w3e
│   │   ├── war3map.w3i
│   │   ├── war3map.w3r
│   │   ├── war3map.wct
│   │   ├── war3map.wpm
│   │   ├── war3map.wtg
│   │   ├── war3map.wts
│   │   ├── war3mapMap.blp
│   │   ├── war3mapSkin.w3a
│   │   ├── war3mapSkin.w3b
│   │   ├── war3mapSkin.w3d
│   │   ├── war3mapSkin.w3h
│   │   ├── war3mapSkin.w3q
│   │   ├── war3mapSkin.w3t
│   │   ├── war3mapSkin.w3u
│   │   └── war3mapUnits.doo
│   ├── themes
│   │   ├── Dark.qss
│   │   └── Light.qss
│   ├── tools
│   │   ├── bin
│   │   │   └── sfmpq.dll
│   │   ├── clijasshelper.exe
│   │   ├── jasshelper.conf
│   │   ├── pjass.exe
│   │   └── sfmpq.dll
│   └── warcraft
│       ├── CityCliffs.slk
│       ├── Cliffs.slk
│       ├── ability_insights.json
│       ├── generate_ability_insights.py
│       └── icon_tags.json
├── overlay-ports
│   ├── bullet3
│   │   ├── cmake-fix.patch
│   │   ├── portfile.cmake
│   │   ├── usage
│   │   └── vcpkg.json
│   ├── casclib
│   │   ├── portfile.cmake
│   │   └── vcpkg.json
│   ├── soil2
│   │   ├── portfile.cmake
│   │   ├── soil2Config.cmake.in
│   │   └── vcpkg.json
│   └── stormlib
│       ├── portfile.cmake
│       └── vcpkg.json
├── src
│   ├── CMakeLists.txt
│   ├── base
│   │   ├── binary_reader.ixx
│   │   ├── binary_writer.ixx
│   │   ├── camera.ixx
│   │   ├── doodad.ixx
│   │   ├── doodads.ixx
│   │   ├── doodads_undo.ixx
│   │   ├── game_cameras.ixx
│   │   ├── hierarchy.ixx
│   │   ├── imports.ixx
│   │   ├── map.ixx
│   │   ├── map_info.ixx
│   │   ├── pathing_map.ixx
│   │   ├── pathing_undo.ixx
│   │   ├── physics.ixx
│   │   ├── regions.ixx
│   │   ├── render_manager.ixx
│   │   ├── resource_manager.ixx
│   │   ├── shadow_map.ixx
│   │   ├── sounds.ixx
│   │   ├── terrain.ixx
│   │   ├── terrain_undo.ixx
│   │   ├── trigger_strings.ixx
│   │   ├── triggers
│   │   │   ├── gui.cpp
│   │   │   ├── map_script.cpp
│   │   │   └── triggers.ixx
│   │   ├── units.ixx
│   │   ├── units_undo.ixx
│   │   ├── window_handler.ixx
│   │   └── world_undo_manager.ixx
│   ├── brush
│   │   ├── brush.cpp
│   │   ├── brush.h
│   │   ├── doodad_brush.cpp
│   │   ├── doodad_brush.h
│   │   ├── pathing_brush.cpp
│   │   ├── pathing_brush.h
│   │   ├── terrain_brush.cpp
│   │   ├── terrain_brush.h
│   │   ├── unit_brush.cpp
│   │   └── unit_brush.h
│   ├── custom_widgets
│   │   ├── aspect_ratio_pixmap_label.h
│   │   ├── aspect_ratio_pixmap_label.ixx
│   │   ├── color_button.h
│   │   ├── color_button.ixx
│   │   ├── flow_layout.ixx
│   │   ├── qribbon.ixx
│   │   └── unit_selector.ixx
│   ├── file_formats
│   │   ├── blp.ixx
│   │   ├── casc.ixx
│   │   ├── ini.ixx
│   │   ├── json.ixx
│   │   ├── mdx
│   │   │   ├── mdl_reader.cpp
│   │   │   ├── mdl_writer.cpp
│   │   │   ├── mdx.ixx
│   │   │   ├── mdx_reader.cpp
│   │   │   ├── mdx_writer.cpp
│   │   │   ├── optimizer.cpp
│   │   │   ├── utilities.cpp
│   │   │   └── validator.cpp
│   │   ├── mpq.ixx
│   │   └── slk.ixx
│   ├── globals.ixx
│   ├── main.cpp
│   ├── main_window
│   │   ├── HiveWE.ico
│   │   ├── HiveWE.qrc
│   │   ├── HiveWE.rc
│   │   ├── HiveWE.ui
│   │   ├── glwidget.cpp
│   │   ├── glwidget.h
│   │   ├── hivewe.cpp
│   │   ├── hivewe.h
│   │   ├── main_ribbon.cpp
│   │   └── main_ribbon.h
│   ├── map_global.ixx
│   ├── menus
│   │   ├── doodad_palette.cpp
│   │   ├── doodad_palette.h
│   │   ├── doodad_palette.ui
│   │   ├── map_info_editor.cpp
│   │   ├── map_info_editor.h
│   │   ├── map_info_editor.ui
│   │   ├── minimap.cpp
│   │   ├── minimap.h
│   │   ├── minimap.ui
│   │   ├── palette.cpp
│   │   ├── palette.h
│   │   ├── pathing_palette.cpp
│   │   ├── pathing_palette.h
│   │   ├── pathing_palette.ui
│   │   ├── settings_editor.cpp
│   │   ├── settings_editor.h
│   │   ├── settings_editor.ui
│   │   ├── terrain_palette.cpp
│   │   ├── terrain_palette.h
│   │   ├── terrain_palette.ui
│   │   ├── tile_pather.cpp
│   │   ├── tile_pather.h
│   │   ├── tile_pather.ui
│   │   ├── tile_picker.cpp
│   │   ├── tile_picker.h
│   │   ├── tile_picker.ui
│   │   ├── tile_setter.cpp
│   │   ├── tile_setter.h
│   │   ├── tile_setter.ui
│   │   ├── unit_palette.cpp
│   │   ├── unit_palette.h
│   │   └── unit_palette.ui
│   ├── model_editor
│   │   ├── model_editor.cpp
│   │   ├── model_editor.h
│   │   ├── model_editor_camera.cpp
│   │   ├── model_editor_camera.h
│   │   ├── model_editor_glwidget.cpp
│   │   └── model_editor_glwidget.h
│   ├── models
│   │   ├── list
│   │   │   ├── ability_list_model.ixx
│   │   │   ├── base_list_model.ixx
│   │   │   ├── buff_list_model.ixx
│   │   │   ├── destructible_list_model.ixx
│   │   │   ├── doodad_list_model.ixx
│   │   │   ├── item_list_model.ixx
│   │   │   ├── unit_list_model.ixx
│   │   │   └── upgrade_list_model.ixx
│   │   ├── single_model.cpp
│   │   ├── single_model.h
│   │   ├── table_model.ixx
│   │   └── tree
│   │       ├── ability_tree_model.ixx
│   │       ├── base_tree_model.ixx
│   │       ├── buff_tree_model.ixx
│   │       ├── destructible_tree_model.ixx
│   │       ├── doodad_tree_model.ixx
│   │       ├── item_tree_model.ixx
│   │       ├── unit_tree_model.ixx
│   │       └── upgrade_tree_model.ixx
│   ├── object_editor
│   │   ├── ability_list_editor.ixx
│   │   ├── global_search.cpp
│   │   ├── global_search.h
│   │   ├── icon_view.cpp
│   │   ├── icon_view.h
│   │   ├── model_view.cpp
│   │   ├── model_view.h
│   │   ├── object_editor.cpp
│   │   ├── object_editor.h
│   │   ├── object_editor.ui
│   │   └── slk_conversions.ixx
│   ├── qt_imgui
│   │   ├── imgui_renderer.cpp
│   │   ├── imgui_renderer.h
│   │   ├── qt_imgui.cpp
│   │   └── qt_imgui.h
│   ├── resource.h
│   ├── resources
│   │   ├── cliff_mesh.ixx
│   │   ├── editable_mesh.ixx
│   │   ├── gpu_texture.ixx
│   │   ├── ground_texture.ixx
│   │   ├── pathing_texture.ixx
│   │   ├── qicon_resource.ixx
│   │   ├── shader.ixx
│   │   ├── skinned_mesh
│   │   │   ├── render_node.ixx
│   │   │   └── skeletal_model_instance.ixx
│   │   ├── skinned_mesh.ixx
│   │   └── texture.ixx
│   ├── test.ixx
│   ├── trigger_editor
│   │   ├── jass_editor.cpp
│   │   ├── jass_editor.h
│   │   ├── jass_tokenizer.cpp
│   │   ├── jass_tokenizer.h
│   │   ├── search_window.cpp
│   │   ├── search_window.h
│   │   ├── trigger_editor.cpp
│   │   ├── trigger_editor.h
│   │   ├── trigger_editor.ui
│   │   ├── trigger_explorer.cpp
│   │   ├── trigger_explorer.h
│   │   ├── trigger_model.cpp
│   │   ├── trigger_model.h
│   │   ├── variable_editor.cpp
│   │   ├── variable_editor.h
│   │   └── variable_editor.ui
│   ├── types.ixx
│   └── utilities
│       ├── math_operations.ixx
│       ├── modification_tables.ixx
│       ├── no_init_allocator.ixx
│       ├── opengl_utilities.ixx
│       ├── timer.ixx
│       ├── unordered_map.ixx
│       └── utilities.ixx
├── tabs.editorconfig
└── vcpkg.json

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.29)

# Hack because vcpkg doesn't allow you to just declare that you want to be static on all platforms
# Linux and MacOS are static by default
# if(WIN32)
#    SET(VCPKG_TARGET_TRIPLET "x64-windows-static")
# endif()

project (HiveWE CXX)

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_CXX_EXTENSIONS OFF)

find_package(Qt6 COMPONENTS Core Gui Widgets OpenGL OpenGLWidgets REQUIRED)
find_package(Bullet CONFIG REQUIRED)
find_package(glm CONFIG REQUIRED)
find_package(glad CONFIG REQUIRED)
find_package(soil2 CONFIG REQUIRED)
find_package(stormlib CONFIG REQUIRED)
find_package(BZip2 REQUIRED)
find_package(CascLib CONFIG REQUIRED)
find_package(JPEG REQUIRED)
find_package(qtadvanceddocking-qt6 CONFIG REQUIRED)
find_package(absl CONFIG REQUIRED)
find_package(TBB CONFIG REQUIRED)
find_package(libjpeg-turbo CONFIG REQUIRED)
find_package(imgui CONFIG REQUIRED)
find_package(outcome CONFIG REQUIRED)
find_package(unordered_dense CONFIG REQUIRED)
find_package(nlohmann_json CONFIG REQUIRED)
find_package(mimalloc CONFIG REQUIRED)
find_package(unofficial-qscintilla CONFIG REQUIRED)

qt_standard_project_setup()

add_executable(HiveWE 
	${QT_RESOURCES}
)

add_subdirectory(src)

target_include_directories(HiveWE PRIVATE 
	"src" 
	"src/base" 
	"src/brush" 
	"src/custom_widgets" 
	"src/file_formats" 
	"src/main_window" 
	"src/menus" 
	"src/models"
	"src/model_editor"
	"src/object_editor"
	"src/trigger_editor"
	"src/resources"
	"src/resources/skinned_mesh" 
	"src/utilities"

	${BULLET_INCLUDE_DIR}
)

target_link_libraries(HiveWE PUBLIC
	mimalloc
	Qt6::Gui
	Qt6::Widgets
	Qt6::OpenGL
	Qt6::OpenGLWidgets
	glm::glm
	glad::glad
	soil2::soil2
	StormLib::storm
	BZip2::BZip2
	libjpeg-turbo::jpeg
	absl::base
	libjpeg-turbo::turbojpeg
	ads::qtadvanceddocking-qt6
	TBB::tbb
	imgui::imgui
	outcome::hl
	unordered_dense::unordered_dense
	nlohmann_json::nlohmann_json
	unofficial::qscintilla::qscintilla
	${BULLET_LIBRARIES}
)

target_compile_options(HiveWE PRIVATE
	$<$<CXX_COMPILER_ID:MSVC>:/Zc:__cplusplus /MP /sdl /diagnostics:caret /permissive->
	$<$<CXX_COMPILER_ID:Clang>:-Wextra -Wpedantic -Werror -Wno-multichar>
	$<$<CXX_COMPILER_ID:GNU>:-Wall -Wextra -Wpedantic -Werror -Wno-multichar>
)

target_compile_definitions(HiveWE PRIVATE
	$<$<CXX_COMPILER_ID:MSVC>:UNICODE _UNICODE>
	$<$<CXX_COMPILER_ID:Clang>:TBB_SUPPRESS_DEPRECATED_MESSAGES>
	$<$<CXX_COMPILER_ID:GNU>:TBB_SUPPRESS_DEPRECATED_MESSAGES>
)

if(WIN32)
	target_link_libraries(HiveWE PUBLIC CascLib::casc)
else()
	target_link_libraries(HiveWE PUBLIC CascLib::casc_static)
endif()

target_compile_features(HiveWE PUBLIC cxx_std_23)

add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
	COMMAND ${CMAKE_COMMAND}
	-E create_symlink 
	"${PROJECT_SOURCE_DIR}/data"
	"$<TARGET_FILE_DIR:HiveWE>/data"
)

if (${CMAKE_BUILD_TYPE} STREQUAL "Debug")
	set(QT_VCPKG_PATH "${CMAKE_CURRENT_BINARY_DIR}/vcpkg_installed/x64-windows/debug")
else()
	set(QT_VCPKG_PATH "${CMAKE_CURRENT_BINARY_DIR}/vcpkg_installed/x64-windows")
endif()

file(COPY "${QT_VCPKG_PATH}/Qt6/plugins/platforms/" DESTINATION "${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE}/platforms")
file(COPY "${QT_VCPKG_PATH}/Qt6/plugins/styles/" DESTINATION "${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE}/styles")
file(COPY "${QT_VCPKG_PATH}/Qt6/plugins/imageformats/" DESTINATION "${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE}/imageformats")
```

`CMakePresets.json`:

```json
{
  "version": 3,
  "cmakeMinimumRequired": {
    "major": 3,
    "minor": 29,
    "patch": 0
  },
  "configurePresets": [
    {
      "name": "default",
      "hidden": true,
      "generator": "Visual Studio 17 2022",
      "binaryDir": "${sourceDir}/build/${presetName}",
      "toolchainFile": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake",
      "architecture": {
        "value": "x64",
        "strategy": "external"
      },

      "vendor": {
        "microsoft.com/VisualStudioSettings/CMake/1.0": {
          "hostOS": [ "Windows" ]
        }
      }
    },
    {
      "name": "debug",
      "inherits": "default",
      "displayName": "Debug",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug"
      }
    },
    {
      "name": "relwithdebinfo",
      "inherits": "default",
      "displayName": "RelWithDebInfo",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "RelWithDebInfo"
      }
    },
    {
      "name": "release",
      "inherits": "default",
      "displayName": "Release",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_INTERPROCEDURAL_OPTIMIZATION": "ON",
        "CMAKE_VISIBILITY_PRESET": "hidden",
        "CMAKE_VISIBILITY_INLINES_HIDDEN": "ON"
      }
    }
  ],
  "buildPresets": [
    {
      "name": "Debug",
      "configurePreset": "debug",
      "configuration": "Debug"
    },
    {
      "name": "RelWithDebInfo",
      "configurePreset": "relwithdebinfo",
      "configuration": "RelWithDebInfo"
    },
    {
      "name": "Release",
      "configurePreset": "release",
      "configuration": "Release"
    }
  ]
}
```

`LICENSE`:

```
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.
```

`README.md`:

```md
# HiveWE
HiveWE is a Warcraft III World Editor (WE) that focuses on speed and ease of use. 
It improves massively on the vanilla WE, especially for large maps where the regular World Editor is often too slow and clunky.
The aim is to be a lightweight tool that only does what it needs to and relegates other tasks to high-quality apps.

[Thread on the Hiveworkshop](https://www.hiveworkshop.com/threads/introducing-hivewe.303183/)

Some of the benefits over the vanilla WE:
- Faster loading
- Faster rendering
- Faster editing
- Modern UI/UX
- Edit the pathing map directly
- Edit global tile pathing
- Import heightmaps
- Improved editing palettes

## Features

- Edit the terrain
![HiveWE Screenshot](/Screenshots/HiveWE.png)
- Advanced Object Editor
![HiveWE Screenshot](/Screenshots/ObjectEditor.png)
- Directly edit the pathing map  
![Edit the Pathing Map](/Screenshots/PathingEditing.png)
- Edit global tile pathing  
![Edit global tile pathing](/Screenshots/GlobalPathingEditing.png)

## Download

See the [releases page](https://github.com/stijnherfst/HiveWE/releases) for binary downloads.

## Other Community Tools

Trigger editing: [WC3 Typescript](https://cipherxof.github.io/w3ts/)  
Model editing: [3DS Max Plugin](https://github.com/TaylorMouse/warcraft_III_reforged_tools)
or [Retera Model Studio](https://github.com/Retera/ReterasModelStudio)

## Build Instructions

0. Requires Visual Studio 17.14 or higher (C++20 modules)
1. Clone HiveWE somewhere 
`git clone https://github.com/stijnherfst/HiveWE.git`
2. Clone [vcpkg](https://github.com/microsoft/vcpkg) somewhere central (eg. "C:/")
`git clone https://github.com/Microsoft/vcpkg.git`
3. Run vcpkg/bootstrap-vcpkg.bat
4. Add a user environment variable to your system:
- `VCPKG_ROOT`: the location where vcpkg is installed (e.g. "C:\vcpkg")
5. Open Visual Studio as an **Administrator** and using the open folder button to open the HiveWE folder. (**Administrator required** for creating a symbolic link on Windows)
6. Dependencies will be automatically compiled, might take about 15-20 minutes (mostly due to Qt)

**Done**

If you run into any issues, then feel free to contact me at HiveWorkshop (eejin) or on Discord eejin#4240

## Potential Contributions

Want to help with the development of HiveWE? Below is a list of features that you could implement. You can try one of these or just add something else you feel like HiveWE should have. Any contributions are welcome!

- Being able to change forces/teams
- Changing map sizes/camera bound
- Ramp editing with the terrain palette
- Making HiveWE run faster
- An FDF frame editor
- Text colorizer
- Advanced terrain editing tools (e.g. flood fill, magic wand selection)
- Or any other functionality you think would be cool

If you have any questions, then don't be afraid to message me here, on the HiveWorkshop (eejin) or on Discord (eejin)
```

`data/overrides/Units/ItemMetaData.slk`:

```slk
ID;PWXL;N;E
B;Y43;X23;D0 0 42 22
C;Y1;X1;K"ID"
C;X2;K"field"
C;X3;K"slk"
C;X4;K"index"
C;X5;K"category"
C;X6;K"displayName"
C;X7;K"sort"
C;X8;K"type"
C;X9;K"changeFlags"
C;X10;K"importType"
C;X11;K"stringExt"
C;X12;K"caseSens"
C;X13;K"canBeEmpty"
C;X14;K"minVal"
C;X15;K"maxVal"
C;X16;K"forceNonNeg"
C;X17;K"useHero"
C;X18;K"useUnit"
C;X19;K"useBuilding"
C;X20;K"useItem"
C;X21;K"useSpecific"
C;X22;K"version"
C;X23;K"section"
C;Y2;X1;K"iabi"
C;X2;K"abilList"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_IABI"
C;X7;K"c6c00"
C;X8;K"abilityList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K4
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y3;X1;K"iarm"
C;X2;K"armor"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_IARM"
C;X7;K"c5b03"
C;X8;K"armorType"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y4;X1;K"icla"
C;X2;K"class"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ICLA"
C;X7;K"c1a03"
C;X8;K"itemClass"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y5;X1;K"iclb"
C;X2;K"colorB"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ICLB"
C;X7;K"c1a04"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y6;X1;K"iclg"
C;X2;K"colorG"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ICLG"
C;X7;K"c1a04"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y7;X1;K"iclr"
C;X2;K"colorR"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ICLR"
C;X7;K"c1a04"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y8;X1;K"icid"
C;X2;K"cooldownID"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ICID"
C;X7;K"c6c01"
C;X8;K"abilCode"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y9;X1;K"idrp"
C;X2;K"drop"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IDRP"
C;X7;K"c9a06"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y10;X1;K"idro"
C;X2;K"droppable"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IDRO"
C;X7;K"c9a05"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y11;X1;K"ifil"
C;X2;K"file"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_IFIL"
C;X7;K"c1a01"
C;X8;K"model"
C;X9;K"m"
C;X10;K"Model"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y12;X1;K"igol"
C;X2;K"goldcost"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IGOL"
C;X7;K"c2a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y13;X1;K"ihtp"
C;X2;K"HP"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IHTP"
C;X7;K"c3a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K500000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y14;X1;K"iicd"
C;X2;K"ignoreCD"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IICD"
C;X7;K"c5a000"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y15;X1;K"ilev"
C;X2;K"Level"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ILEV"
C;X7;K"c1a04"
C;X8;K"int"
C;X9;K"c"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K8
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y16;X1;K"ilum"
C;X2;K"lumbercost"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ILUM"
C;X7;K"c2a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y17;X1;K"imor"
C;X2;K"morph"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IMOR"
C;X7;K"c9a07"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y18;X1;K"ilvo"
C;X2;K"oldLevel"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ILVO"
C;X7;K"c1a04a"
C;X8;K"int"
C;X9;K"c"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y19;X1;K"iper"
C;X2;K"perishable"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IPER"
C;X7;K"c9a04"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y20;X1;K"iprn"
C;X2;K"pickRandom"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IPRN"
C;X7;K"c9a05"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y21;X1;K"ipow"
C;X2;K"powerup"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IPOW"
C;X7;K"c9a06"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y22;X1;K"ipri"
C;X2;K"prio"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IPRI"
C;X7;K"c4a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y23;X1;K"isca"
C;X2;K"scale"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ISCA"
C;X7;K"c1a03"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0.1
C;X15;K10
C;X16;K1
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y24;X1;K"issc"
C;X2;K"selSize"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ISSC"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K1
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y25;X1;K"isel"
C;X2;K"sellable"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISEL"
C;X7;K"c6c02"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y26;X1;K"ipaw"
C;X2;K"pawnable"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IPAW"
C;X7;K"c6c02a"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y27;X1;K"isto"
C;X2;K"stockMax"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISTO"
C;X7;K"c9a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y28;X1;K"istr"
C;X2;K"stockRegen"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISTR"
C;X7;K"c9a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y29;X1;K"isst"
C;X2;K"stockStart"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISST"
C;X7;K"c9a000"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y30;X1;K"isit"
C;X2;K"stockInitial"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISIT"
C;X7;K"c9a000"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K100
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y31;X1;K"iusa"
C;X2;K"usable"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IUSA"
C;X7;K"c9a03"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y32;X1;K"iuse"
C;X2;K"uses"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IUSE"
C;X7;K"c9a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y33;X1;K"ista"
C;X2;K"stackMax"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISTA"
C;X7;K"c9a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y34;X1;K"iico"
C;X2;K"Art"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_IICO"
C;X7;K"c1a02"
C;X8;K"icon"
C;X9;K"i"
C;X10;K"Image"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y35;X1;K"ides"
C;X2;K"Description"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_IDES"
C;X7;K"d0a05"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y36;X1;K"ubpx"
C;X2;K"Buttonpos"
C;X3;K"Profile"
C;X4;K0
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBPX"
C;X7;K"c2a03x"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y37;X1;K"ubpy"
C;X2;K"Buttonpos2"
C;X3;K"Profile"
C;X4;K0
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBPX"
C;X7;K"c2a03y"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y38;X1;K"ureq"
C;X2;K"Requires"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UREQ"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y39;X1;K"urqa"
C;X2;K"Requiresamount"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQA"
C;X7;K"c5a00a"
C;X8;K"intList"
C;X9;K"s"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y40;X1;K"uhot"
C;X2;K"Hotkey"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UHOT"
C;X7;K"d0a01"
C;X8;K"char"
C;X11;K1
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y41;X1;K"unam"
C;X2;K"Name"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UNAM"
C;X7;K"c1a00"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K0
C;X15;K"TTName"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y42;X1;K"utip"
C;X2;K"Tip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UTIP"
C;X7;K"d0a00"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y43;X1;K"utub"
C;X2;K"Ubertip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UTUB"
C;X7;K"d0a03"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTUber"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
E

```

`data/overrides/Units/UnitMetaData.slk`:

```slk
ID;PWXL;N;E
B;Y240;X23;D0 0 239 22
F;W2 2 18
C;Y1;X1;K"ID"
C;X2;K"field"
C;X3;K"slk"
C;X4;K"index"
C;X5;K"category"
C;X6;K"displayName"
C;X7;K"sort"
C;X8;K"type"
C;X9;K"changeFlags"
C;X10;K"importType"
C;X11;K"stringExt"
C;X12;K"caseSens"
C;X13;K"canBeEmpty"
C;X14;K"minVal"
C;X15;K"maxVal"
C;X16;K"forceNonNeg"
C;X17;K"useHero"
C;X18;K"useUnit"
C;X19;K"useBuilding"
C;X20;K"useItem"
C;X21;K"useSpecific"
C;X22;K"version"
C;X23;K"section"
C;Y2;X1;K"uani"
C;X2;K"animProps"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UANI"
C;X7;K"c1a010"
C;X8;K"stringList"
C;X11;K0
C;X12;K0
C;X13;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y3;X1;K"uico"
C;X2;K"Art"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UICO"
C;X7;K"c1a02"
C;X8;K"icon"
C;X9;K"i"
C;X10;K"Image"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y4;X1;K"uaap"
C;X2;K"Attachmentanimprops"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UAAP"
C;X7;K"c1a010a"
C;X8;K"stringList"
C;X11;K0
C;X12;K0
C;X13;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y5;X1;K"ualp"
C;X2;K"Attachmentlinkprops"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UALP"
C;X7;K"c1a010b"
C;X8;K"stringList"
C;X11;K0
C;X12;K0
C;X13;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y6;X1;K"uawt"
C;X2;K"Awakentip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UAWT"
C;X7;K"d0a02a"
C;X8;K"string"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y7;X1;K"ubpr"
C;X2;K"Boneprops"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBPR"
C;X7;K"c1a010c"
C;X8;K"stringList"
C;X11;K0
C;X12;K0
C;X13;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y8;X1;K"ubsl"
C;X2;K"BuildingSoundLabel"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_UBSL"
C;X7;K"d8b00"
C;X8;K"soundLabel"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y9;X1;K"ubui"
C;X2;K"Builds"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UBUI"
C;X7;K"c5a010"
C;X8;K"unitList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y10;X1;K"ubpx"
C;X2;K"Buttonpos"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBPX"
C;X7;K"c2a03x"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y11;X1;K"ubpy"
C;X2;K"Buttonpos2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBPX"
C;X7;K"c2a03y"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y12;X1;K"ucua"
C;X2;K"Casterupgradeart"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCUA"
C;X7;K"c6c03"
C;X8;K"icon"
C;X10;K"Image"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y13;X1;K"ucun"
C;X2;K"Casterupgradename"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UCUN"
C;X7;K"c6c01"
C;X8;K"stringList"
C;X11;K1
C;X12;K1
C;X13;K0
C;X15;K32
C;X16;K0
C;X17;K0
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y14;X1;K"ucut"
C;X2;K"Casterupgradetip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UCUT"
C;X7;K"c6c02"
C;X8;K"stringList"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K0
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y15;X1;K"udep"
C;X2;K"DependencyOr"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UDEP"
C;X7;K"c5a00a"
C;X8;K"unitList"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y16;X1;K"unsf"
C;X2;K"EditorSuffix"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UNSF"
C;X7;K"c1a000"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K50
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y17;X1;K"uhot"
C;X2;K"Hotkey"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UHOT"
C;X7;K"d0a01"
C;X8;K"char"
C;X11;K1
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y18;X1;K"ulfi"
C;X2;K"LoopingSoundFadeIn"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_ULFI"
C;X7;K"d8b03"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K1
C;X14;K0
C;X15;K12700
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y19;X1;K"ulfo"
C;X2;K"LoopingSoundFadeOut"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_ULFO"
C;X7;K"d8b04"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K1
C;X14;K0
C;X15;K12700
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y20;X1;K"umki"
C;X2;K"Makeitems"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UMKI"
C;X7;K"c5a05a"
C;X8;K"itemList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K12
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y21;X1;K"uma1"
C;X2;K"Missilearc"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UMA1"
C;X7;K"c6a06a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y22;X1;K"uma2"
C;X2;K"Missilearc2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UMA2"
C;X7;K"c6b06a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y23;X1;K"ua1m"
C;X2;K"Missileart"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1M"
C;X7;K"c6a05"
C;X8;K"model"
C;X10;K"Model"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y24;X1;K"ua2m"
C;X2;K"Missileart2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2M"
C;X7;K"c6b05"
C;X8;K"model"
C;X10;K"Model"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y25;X1;K"umh1"
C;X2;K"MissileHoming"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UMH1"
C;X7;K"c6a06b"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y26;X1;K"umh2"
C;X2;K"MissileHoming2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UMH2"
C;X7;K"c6b06b"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y27;X1;K"ua1z"
C;X2;K"Missilespeed"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1Z"
C;X7;K"c6a06"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y28;X1;K"ua2z"
C;X2;K"Missilespeed2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2Z"
C;X7;K"c6b06"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y29;X1;K"umsl"
C;X2;K"MovementSoundLabel"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_UMSL"
C;X7;K"d8b01"
C;X8;K"soundLabel"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y30;X1;K"unam"
C;X2;K"Name"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UNAM"
C;X7;K"c1a00"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K0
C;X15;K"TTName"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y31;X1;K"upro"
C;X2;K"Propernames"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UPRO"
C;X7;K"c1a001"
C;X8;K"stringList"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K0
C;X15;K32
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y32;X1;K"ursl"
C;X2;K"RandomSoundLabel"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_URSL"
C;X7;K"d8b02"
C;X8;K"soundLabel"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y33;X1;K"urqc"
C;X2;K"Requirescount"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQC"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K0
C;X13;K1
C;X15;K9
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y34;X1;K"ureq"
C;X2;K"Requires"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UREQ"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y35;X1;K"urq1"
C;X2;K"Requires1"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ1"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y36;X1;K"urq2"
C;X2;K"Requires2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ2"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y37;X1;K"urq3"
C;X2;K"Requires3"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ3"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y38;X1;K"urq4"
C;X2;K"Requires4"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ4"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y39;X1;K"urq5"
C;X2;K"Requires5"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ5"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y40;X1;K"urq6"
C;X2;K"Requires6"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ6"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y41;X1;K"urq7"
C;X2;K"Requires7"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ7"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y42;X1;K"urq8"
C;X2;K"Requires8"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ8"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y43;X1;K"urqa"
C;X2;K"Requiresamount"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQA"
C;X7;K"c5a00a"
C;X8;K"intList"
C;X9;K"s"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y44;X1;K"ures"
C;X2;K"Researches"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URES"
C;X7;K"c5a03"
C;X8;K"upgradeList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K0
C;Y45;X1;K"urev"
C;X2;K"Revive"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UREV"
C;X7;K"c5a000"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y46;X1;K"utpr"
C;X2;K"Revivetip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UTPR"
C;X7;K"d0a02"
C;X8;K"string"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y47;X1;K"ussi"
C;X2;K"ScoreScreenIcon"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USSI"
C;X7;K"c1a02a"
C;X8;K"icon"
C;X10;K"Image"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y48;X1;K"usei"
C;X2;K"Sellitems"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_USEI"
C;X7;K"c5a05"
C;X8;K"itemList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K12
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y49;X1;K"useu"
C;X2;K"Sellunits"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_USEU"
C;X7;K"c5a04"
C;X8;K"unitList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K12
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y50;X1;K"uspa"
C;X2;K"Specialart"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USPA"
C;X7;K"d9b00"
C;X8;K"modelList"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y51;X1;K"utaa"
C;X2;K"Targetart"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UTAA"
C;X7;K"d9b01"
C;X8;K"modelList"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y52;X1;K"utip"
C;X2;K"Tip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UTIP"
C;X7;K"d0a00"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y53;X1;K"utra"
C;X2;K"Trains"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UTRA"
C;X7;K"c5a01"
C;X8;K"unitList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K0
C;Y54;X1;K"urva"
C;X2;K"Reviveat"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URVA"
C;X7;K"c5a01"
C;X8;K"unitList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y55;X1;K"utub"
C;X2;K"Ubertip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UTUB"
C;X7;K"d0a03"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTUber"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y56;X1;K"uupt"
C;X2;K"Upgrade"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UUPT"
C;X7;K"c5a000"
C;X8;K"unitList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K12
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K0
C;Y57;X1;K"uabi"
C;X2;K"abilList"
C;X3;K"UnitAbilities"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_UABI"
C;X7;K"c6c00"
C;X8;K"abilityList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y58;X1;K"udaa"
C;X2;K"auto"
C;X3;K"UnitAbilities"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_UDAA"
C;X7;K"c6c01"
C;X8;K"abilCode"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y59;X1;K"uhab"
C;X2;K"heroAbilList"
C;X3;K"UnitAbilities"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_UHAB"
C;X7;K"c6c00"
C;X8;K"heroAbilityList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K5
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y60;X1;K"uagi"
C;X2;K"AGI"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UAGI"
C;X7;K"c3a05"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y61;X1;K"uagp"
C;X2;K"AGIplus"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UAGP"
C;X7;K"c3a06"
C;X8;K"unreal"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y62;X1;K"ubld"
C;X2;K"bldtm"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UBLD"
C;X7;K"c2a06"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K298
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y63;X1;K"ubdi"
C;X2;K"bountydice"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UBDI"
C;X7;K"c8a08"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y64;X1;K"ubba"
C;X2;K"bountyplus"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UBBA"
C;X7;K"c8a07"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y65;X1;K"ubsi"
C;X2;K"bountysides"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UBSI"
C;X7;K"c8a09"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y66;X1;K"ulbd"
C;X2;K"lumberbountydice"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULBD"
C;X7;K"c8a10"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y67;X1;K"ulba"
C;X2;K"lumberbountyplus"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULBA"
C;X7;K"c8a11"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y68;X1;K"ulbs"
C;X2;K"lumberbountysides"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULBS"
C;X7;K"c8a12"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y69;X1;K"ucol"
C;X2;K"collision"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UCOL"
C;X7;K"c1a07"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1024
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y70;X1;K"udef"
C;X2;K"def"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDEF"
C;X7;K"c5b00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y71;X1;K"udty"
C;X2;K"defType"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDTY"
C;X7;K"c5b02"
C;X8;K"defenseType"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y72;X1;K"udup"
C;X2;K"defUp"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDUP"
C;X7;K"c5b01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y73;X1;K"ufma"
C;X2;K"fmade"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UFMA"
C;X7;K"c2a030"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K300
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y74;X1;K"ufoo"
C;X2;K"fused"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UFOO"
C;X7;K"c2a03"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K300
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y75;X1;K"ugol"
C;X2;K"goldcost"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UGOL"
C;X7;K"c2a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y76;X1;K"ugor"
C;X2;K"goldRep"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UGOR"
C;X7;K"c2a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y77;X1;K"uhpm"
C;X2;K"HP"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHPM"
C;X7;K"c4a00"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K500000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y78;X1;K"uint"
C;X2;K"INT"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UINT"
C;X7;K"c3a03"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y79;X1;K"uinp"
C;X2;K"INTplus"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UINP"
C;X7;K"c3a04"
C;X8;K"unreal"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y80;X1;K"ubdg"
C;X2;K"isbldg"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UBDG"
C;X7;K"c1a001a"
C;X8;K"bool"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y81;X1;K"ulev"
C;X2;K"level"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULEV"
C;X7;K"c8a04"
C;X8;K"int"
C;X9;K"c"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y82;X1;K"ulum"
C;X2;K"lumbercost"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULUM"
C;X7;K"c2a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y83;X1;K"ulur"
C;X2;K"lumberRep"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULUR"
C;X7;K"c2a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y84;X1;K"umpi"
C;X2;K"mana0"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UMPI"
C;X7;K"c4a05"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y85;X1;K"umpm"
C;X2;K"manaN"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UMPM"
C;X7;K"c4a03"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y86;X1;K"umas"
C;X2;K"maxSpd"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMAS"
C;X7;K"c7a03b"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K522
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y87;X1;K"umis"
C;X2;K"minSpd"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMIS"
C;X7;K"c7a03a"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K522
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y88;X1;K"unbr"
C;X2;K"nbrandom"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UNBR"
C;X7;K"c1c00"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y89;X1;K"usin"
C;X2;K"nsight"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USIN"
C;X7;K"c8a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1800
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y90;X1;K"upap"
C;X2;K"preventPlace"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UPAP"
C;X7;K"c1a09a"
C;X8;K"pathingListPrevent"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y91;X1;K"upra"
C;X2;K"Primary"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UPRA"
C;X7;K"c3a00"
C;X8;K"attributeType"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y92;X1;K"uhpr"
C;X2;K"regenHP"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHPR"
C;X7;K"c4a01"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y93;X1;K"umpr"
C;X2;K"regenMana"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UMPR"
C;X7;K"c4a04"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y94;X1;K"uhrt"
C;X2;K"regenType"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHRT"
C;X7;K"c4a02"
C;X8;K"regenType"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y95;X1;K"urtm"
C;X2;K"reptm"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_URTM"
C;X7;K"c2a07"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y96;X1;K"urpo"
C;X2;K"repulse"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_URPO"
C;X7;K"d7b00"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K1
C;Y97;X1;K"urpg"
C;X2;K"repulseGroup"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_URPG"
C;X7;K"d7b02"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K1024
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K1
C;Y98;X1;K"urpp"
C;X2;K"repulseParam"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_URPP"
C;X7;K"d7b01"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K4
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K1
C;Y99;X1;K"urpr"
C;X2;K"repulsePrio"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_URPR"
C;X7;K"d7b03"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K1
C;Y100;X1;K"upar"
C;X2;K"requirePlace"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UPAR"
C;X7;K"c1a09b"
C;X8;K"pathingListRequire"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y101;X1;K"usid"
C;X2;K"sight"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USID"
C;X7;K"c8a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1800
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y102;X1;K"umvs"
C;X2;K"spd"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMVS"
C;X7;K"c7a03"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K522
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y103;X1;K"usma"
C;X2;K"stockMax"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USMA"
C;X7;K"c9a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K32
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y104;X1;K"usrg"
C;X2;K"stockRegen"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USRG"
C;X7;K"c9a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y105;X1;K"usst"
C;X2;K"stockStart"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USST"
C;X7;K"c9a000"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y106;X1;K"usit"
C;X2;K"stockInitial"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USIT"
C;X7;K"c9a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K32
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y107;X1;K"ustr"
C;X2;K"STR"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USTR"
C;X7;K"c3a01"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y108;X1;K"ustp"
C;X2;K"STRplus"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USTP"
C;X7;K"c3a02"
C;X8;K"unreal"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y109;X1;K"util"
C;X2;K"tilesets"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UTIL"
C;X7;K"c1a06c"
C;X8;K"tilesetList"
C;X9;K"c"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y110;X1;K"utyp"
C;X2;K"type"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UTYP"
C;X7;K"c2a04"
C;X8;K"unitClass"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y111;X1;K"upgr"
C;X2;K"upgrades"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UPGR"
C;X7;K"c5a02"
C;X8;K"upgradeList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y112;X1;K"uabr"
C;X2;K"buffRadius"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UABR"
C;X7;K"d4b01"
C;X8;K"unreal"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K24
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y113;X1;K"uabt"
C;X2;K"buffType"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UABT"
C;X7;K"d4b00"
C;X8;K"aiBuffer"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y114;X1;K"ucbo"
C;X2;K"canBuildOn"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UCBO"
C;X7;K"c7a07"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y115;X1;K"ufle"
C;X2;K"canFlee"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UFLE"
C;X7;K"c8a031"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y116;X1;K"usle"
C;X2;K"canSleep"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USLE"
C;X7;K"c8a030"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y117;X1;K"ucar"
C;X2;K"cargoSize"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UCAR"
C;X7;K"c8a03"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K8
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y118;X1;K"udtm"
C;X2;K"death"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UDTM"
C;X7;K"c1b10"
C;X8;K"unreal"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0.1
C;X15;K20
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y119;X1;K"udea"
C;X2;K"deathType"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDEA"
C;X7;K"c1b09"
C;X8;K"deathType"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y120;X1;K"ulos"
C;X2;K"fatLOS"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ULOS"
C;X7;K"d3b00"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y121;X1;K"ufor"
C;X2;K"formation"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UFOR"
C;X7;K"c7a05"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K9
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y122;X1;K"uibo"
C;X2;K"isBuildOn"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UIBO"
C;X7;K"c7a06"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y123;X1;K"umvf"
C;X2;K"moveFloor"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMVF"
C;X7;K"c7a02a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y124;X1;K"umvh"
C;X2;K"moveHeight"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMVH"
C;X7;K"c7a02"
C;X8;K"unreal"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y125;X1;K"umvt"
C;X2;K"movetp"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMVT"
C;X7;K"c7a01"
C;X8;K"moveType"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y126;X1;K"upru"
C;X2;K"nameCount"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UPRU"
C;X7;K"c1a001a"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y127;X1;K"uori"
C;X2;K"orientInterp"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UORI"
C;X7;K"c7a04b"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K8
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y128;X1;K"upat"
C;X2;K"pathTex"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UPAT"
C;X7;K"c1a09"
C;X8;K"pathingTexture"
C;X9;K"m"
C;X10;K"Image"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K0
C;Y129;X1;K"upoi"
C;X2;K"points"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UPOI"
C;X7;K"c8a05"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y130;X1;K"upri"
C;X2;K"prio"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UPRI"
C;X7;K"c8a06"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y131;X1;K"uprw"
C;X2;K"propWin"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UPRW"
C;X7;K"c7a04a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K180
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y132;X1;K"urac"
C;X2;K"race"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_URAC"
C;X7;K"c1a001"
C;X8;K"unitRace"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y133;X1;K"upaw"
C;X2;K"requireWaterRadius"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UPAW"
C;X7;K"c1a09c"
C;X8;K"unreal"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y134;X1;K"utar"
C;X2;K"targType"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UTAR"
C;X7;K"c7a00"
C;X8;K"targetList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y135;X1;K"umvr"
C;X2;K"turnRate"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMVR"
C;X7;K"c7a04"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0.1
C;X15;K3
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y136;X1;K"uarm"
C;X2;K"armor"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UARM"
C;X7;K"c5b03"
C;X8;K"armorType"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y137;X1;K"uble"
C;X2;K"blend"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBLE"
C;X7;K"c7a04c"
C;X8;K"real"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y138;X1;K"uclb"
C;X2;K"blue"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCLB"
C;X7;K"c1a06"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y139;X1;K"ushb"
C;X2;K"buildingShadow"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHB"
C;X7;K"c1a10a"
C;X8;K"shadowTexture"
C;X9;K"m"
C;X10;K"Image"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y140;X1;K"ucam"
C;X2;K"campaign"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UCAM"
C;X7;K"c1a06f"
C;X8;K"bool"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y141;X1;K"utcc"
C;X2;K"customTeamColor"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UTCC"
C;X7;K"c1a06b"
C;X8;K"bool"
C;X9;K"s"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y142;X1;K"udro"
C;X2;K"dropItems"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UDRO"
C;X7;K"c1a06g"
C;X8;K"bool"
C;X9;K"s"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y143;X1;K"uept"
C;X2;K"elevPts"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UEPT"
C;X7;K"d5c00"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K4
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y144;X1;K"uerd"
C;X2;K"elevRad"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UERD"
C;X7;K"d5c01"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y145;X1;K"umdl"
C;X2;K"file"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UMDL"
C;X7;K"c1a01"
C;X8;K"model"
C;X9;K"m"
C;X10;K"Model"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y146;X1;K"uver"
C;X2;K"fileVerFlags"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UVER"
C;X7;K"c1a01a"
C;X8;K"versionFlags"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K3
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y147;X1;K"ufrd"
C;X2;K"fogRad"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UFRD"
C;X7;K"d5c02"
C;X8;K"real"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y148;X1;K"uclg"
C;X2;K"green"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCLG"
C;X7;K"c1a05"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y149;X1;K"uhos"
C;X2;K"hostilePal"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UHOS"
C;X7;K"c8a10"
C;X8;K"bool"
C;X9;K"c"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y150;X1;K"uine"
C;X2;K"inEditor"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UINE"
C;X7;K"c1a06d0"
C;X8;K"bool"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y151;X1;K"umxp"
C;X2;K"maxPitch"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UMXP"
C;X7;K"d5b00"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K180
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y152;X1;K"umxr"
C;X2;K"maxRoll"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UMXR"
C;X7;K"d5b01"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K180
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y153;X1;K"usca"
C;X2;K"modelScale"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USCA"
C;X7;K"c1a03"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0.1
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y154;X1;K"unbm"
C;X2;K"nbmmIcon"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UNBM"
C;X7;K"c1c01"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y155;X1;K"uhhb"
C;X2;K"hideHeroBar"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHHB"
C;X7;K"c1c01"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y156;X1;K"uhhm"
C;X2;K"hideHeroMinimap"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHHM"
C;X7;K"c1c01"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y157;X1;K"uhhd"
C;X2;K"hideHeroDeathMsg"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHHD"
C;X7;K"c1c01"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y158;X1;K"uhom"
C;X2;K"hideOnMinimap"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHOM"
C;X7;K"c1c01"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y159;X1;K"uocc"
C;X2;K"occH"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UOCC"
C;X7;K"d6c03"
C;X8;K"unreal"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y160;X1;K"uclr"
C;X2;K"red"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCLR"
C;X7;K"c1a04"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y161;X1;K"urun"
C;X2;K"run"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_URUN"
C;X7;K"d6c01"
C;X8;K"real"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y162;X1;K"ussc"
C;X2;K"scale"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USSC"
C;X7;K"c1a08"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0.1
C;X15;K20
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y163;X1;K"uscb"
C;X2;K"scaleBull"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USCB"
C;X7;K"c1a08a"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y164;X1;K"usew"
C;X2;K"selCircOnWater"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USEW"
C;X7;K"c1a12"
C;X8;K"bool"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y165;X1;K"uslz"
C;X2;K"selZ"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USLZ"
C;X7;K"d6c02"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y166;X1;K"ushh"
C;X2;K"shadowH"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHH"
C;X7;K"c1a11b"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y167;X1;K"ushr"
C;X2;K"shadowOnWater"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHR"
C;X7;K"c1a11e"
C;X8;K"bool"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y168;X1;K"ushw"
C;X2;K"shadowW"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHW"
C;X7;K"c1a11a"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y169;X1;K"ushx"
C;X2;K"shadowX"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHX"
C;X7;K"c1a11c"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y170;X1;K"ushy"
C;X2;K"shadowY"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHY"
C;X7;K"c1a11d"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y171;X1;K"uspe"
C;X2;K"special"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_USPE"
C;X7;K"c1a06e"
C;X8;K"bool"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y172;X1;K"utco"
C;X2;K"teamColor"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UTCO"
C;X7;K"c1a06a"
C;X8;K"teamColor"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y173;X1;K"utss"
C;X2;K"tilesetSpecific"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UTSS"
C;X7;K"c1a06d"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y174;X1;K"uubs"
C;X2;K"uberSplat"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UUBS"
C;X7;K"c1a10"
C;X8;K"uberSplat"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y175;X1;K"ushu"
C;X2;K"unitShadow"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHU"
C;X7;K"c1a11"
C;X8;K"shadowImage"
C;X9;K"m"
C;X10;K"Image"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y176;X1;K"usnd"
C;X2;K"unitSound"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_USND"
C;X7;K"c1a10"
C;X8;K"unitSound"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y177;X1;K"uuch"
C;X2;K"useClickHelper"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UUCH"
C;X7;K"c1c02"
C;X8;K"bool"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y178;X1;K"uwal"
C;X2;K"walk"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UWAL"
C;X7;K"d6c00"
C;X8;K"real"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y179;X1;K"uacq"
C;X2;K"acquire"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UACQ"
C;X7;K"c8a00"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y180;X1;K"ua1t"
C;X2;K"atkType1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1T"
C;X7;K"c6a03"
C;X8;K"attackType"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y181;X1;K"ua2t"
C;X2;K"atkType2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2T"
C;X7;K"c6b03"
C;X8;K"attackType"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y182;X1;K"ubs1"
C;X2;K"backSw1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UBS1"
C;X7;K"c6a08a"
C;X8;K"unreal"
C;X11;K3
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y183;X1;K"ubs2"
C;X2;K"backSw2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UBS2"
C;X7;K"c6b08a"
C;X8;K"unreal"
C;X11;K3
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y184;X1;K"ucbs"
C;X2;K"castbsw"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCBS"
C;X7;K"d2b01"
C;X8;K"unreal"
C;X11;K3
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y185;X1;K"ucpt"
C;X2;K"castpt"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCPT"
C;X7;K"d2b00"
C;X8;K"unreal"
C;X11;K3
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y186;X1;K"ua1c"
C;X2;K"cool1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1C"
C;X7;K"c6a08"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y187;X1;K"ua2c"
C;X2;K"cool2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2C"
C;X7;K"c6b08"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y188;X1;K"udl1"
C;X2;K"damageLoss1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDL1"
C;X7;K"c6a12a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y189;X1;K"udl2"
C;X2;K"damageLoss2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDL2"
C;X7;K"c6b12a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y190;X1;K"ua1d"
C;X2;K"dice1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1D"
C;X7;K"c6a071"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y191;X1;K"ua2d"
C;X2;K"dice2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2D"
C;X7;K"c6b071"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y192;X1;K"ua1b"
C;X2;K"dmgplus1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1B"
C;X7;K"c6a070"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K500000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y193;X1;K"ua2b"
C;X2;K"dmgplus2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2B"
C;X7;K"c6b070"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K500000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y194;X1;K"udp1"
C;X2;K"dmgpt1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDP1"
C;X7;K"c6a08"
C;X8;K"unreal"
C;X11;K3
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y195;X1;K"udp2"
C;X2;K"dmgpt2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDP2"
C;X7;K"c6b08"
C;X8;K"unreal"
C;X11;K3
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y196;X1;K"udu1"
C;X2;K"dmgUp1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDU1"
C;X7;K"c6a073"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y197;X1;K"udu2"
C;X2;K"dmgUp2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDU2"
C;X7;K"c6b073"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y198;X1;K"ua1f"
C;X2;K"Farea1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1F"
C;X7;K"c6a09"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y199;X1;K"ua2f"
C;X2;K"Farea2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2F"
C;X7;K"c6b09"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y200;X1;K"ua1h"
C;X2;K"Harea1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1H"
C;X7;K"c6a10"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y201;X1;K"ua2h"
C;X2;K"Harea2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2H"
C;X7;K"c6b10"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y202;X1;K"uhd1"
C;X2;K"Hfact1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UHD1"
C;X7;K"c6a10a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y203;X1;K"uhd2"
C;X2;K"Hfact2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UHD2"
C;X7;K"c6b10a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y204;X1;K"uisz"
C;X2;K"impactSwimZ"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UISZ"
C;X7;K"c5a04a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y205;X1;K"uimz"
C;X2;K"impactZ"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UIMZ"
C;X7;K"c5a04"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y206;X1;K"ulsz"
C;X2;K"launchSwimZ"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ULSZ"
C;X7;K"c5a03d"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y207;X1;K"ulpx"
C;X2;K"launchX"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ULPX"
C;X7;K"c5a03a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y208;X1;K"ulpy"
C;X2;K"launchY"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ULPY"
C;X7;K"c5a03b"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y209;X1;K"ulpz"
C;X2;K"launchZ"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ULPZ"
C;X7;K"c5a03c"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y210;X1;K"uamn"
C;X2;K"minRange"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UAMN"
C;X7;K"c6a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y211;X1;K"ua1q"
C;X2;K"Qarea1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1Q"
C;X7;K"c6a11"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y212;X1;K"ua2q"
C;X2;K"Qarea2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2Q"
C;X7;K"c6b11"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y213;X1;K"uqd1"
C;X2;K"Qfact1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UQD1"
C;X7;K"c6a11a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y214;X1;K"uqd2"
C;X2;K"Qfact2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UQD2"
C;X7;K"c6b11a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y215;X1;K"ua1r"
C;X2;K"rangeN1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1R"
C;X7;K"c6a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y216;X1;K"ua2r"
C;X2;K"rangeN2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2R"
C;X7;K"c6b02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y217;X1;K"urb1"
C;X2;K"RngBuff1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_URB1"
C;X7;K"c6a02a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K2000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y218;X1;K"urb2"
C;X2;K"RngBuff2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_URB2"
C;X7;K"c6b02a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K2000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y219;X1;K"uwu1"
C;X2;K"showUI1"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UWU1"
C;X7;K"c6a01a"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y220;X1;K"uwu2"
C;X2;K"showUI2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UWU2"
C;X7;K"c6b01a"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y221;X1;K"ua1s"
C;X2;K"sides1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1S"
C;X7;K"c6a072"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y222;X1;K"ua2s"
C;X2;K"sides2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2S"
C;X7;K"c6b072"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y223;X1;K"usd1"
C;X2;K"spillDist1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_USD1"
C;X7;K"c6a12b"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y224;X1;K"usd2"
C;X2;K"spillDist2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_USD2"
C;X7;K"c6b12b"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y225;X1;K"usr1"
C;X2;K"spillRadius1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_USR1"
C;X7;K"c6a12c"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y226;X1;K"usr2"
C;X2;K"spillRadius2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_USR2"
C;X7;K"c6b12c"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y227;X1;K"ua1p"
C;X2;K"splashTargs1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1P"
C;X7;K"c6a12"
C;X8;K"targetList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y228;X1;K"ua2p"
C;X2;K"splashTargs2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2P"
C;X7;K"c6b12"
C;X8;K"targetList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y229;X1;K"utc1"
C;X2;K"targCount1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UTC1"
C;X7;K"c6a7a"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y230;X1;K"utc2"
C;X2;K"targCount2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UTC2"
C;X7;K"c6b7a"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y231;X1;K"ua1g"
C;X2;K"targs1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1G"
C;X7;K"c6a07"
C;X8;K"targetList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y232;X1;K"ua2g"
C;X2;K"targs2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2G"
C;X7;K"c6b07"
C;X8;K"targetList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y233;X1;K"uaen"
C;X2;K"weapsOn"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UAEN"
C;X7;K"c6a01"
C;X8;K"attackBits"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y234;X1;K"ua1w"
C;X2;K"weapTp1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1W"
C;X7;K"c6a04"
C;X8;K"weaponType"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y235;X1;K"ua2w"
C;X2;K"weapTp2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2W"
C;X7;K"c6b04"
C;X8;K"weaponType"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y236;X1;K"ucs1"
C;X2;K"weapType1"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UCS1"
C;X7;K"c6a04a"
C;X8;K"combatSound"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y237;X1;K"ucs2"
C;X2;K"weapType2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UCS2"
C;X7;K"c6b04a"
C;X8;K"combatSound"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y238;X1;K"uabs"
C;X2;K"abilSkinList"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_UABS"
C;X7;K"c6c00"
C;X8;K"abilitySkinList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y239;X1;K"uhas"
C;X2;K"heroAbilSkinList"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_UHAS"
C;X7;K"c6c00"
C;X8;K"abilitySkinList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y240;X1;K"ides"
C;X2;K"Description"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_IDES"
C;X7;K"d0a05"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
E

```

`data/shaders/brush.frag`:

```frag
#version 450 core

layout (binding = 1) uniform sampler2D brush;

in vec2 UV;

out vec4 color;

void main() {
	if (UV.x < 0.f || UV.y < 0.f || UV.x > 1.f || UV.y > 1.f) {
		color = vec4(0, 0, 0, 0);
	} else {
		color = texture(brush, UV);
	}
}
```

`data/shaders/brush.vert`:

```vert
#version 450 core

layout (location = 0) in vec2 vPosition;

layout (location = 1) uniform mat4 MVP;
layout (location = 2) uniform vec2 offset;
layout (location = 3) uniform vec2 uv_offset;
layout (location = 4) uniform int cells;

layout (binding = 0) uniform sampler2D height_texture;
layout (binding = 1) uniform sampler2D brush;

out vec2 UV;

void main() {
	vec2 size_brush = textureSize(brush, 0) / 4.f;

	vec2 local_pos = vec2(gl_InstanceID % cells, gl_InstanceID / cells);
	vec2 pos = offset + vPosition + local_pos;

	vec4 height = texture(height_texture, (pos + 1) / textureSize(height_texture, 0));

	gl_Position = MVP * vec4(pos, height.r, 1);

	UV = (vPosition + local_pos - uv_offset * 0.25f ) / size_brush;
}
```

`data/shaders/cliff.frag`:

```frag
#version 450 core

layout (binding = 0) uniform sampler2DArray cliff_textures;
layout (binding = 2) uniform usampler2D pathing_map_static;
layout (binding = 3) uniform sampler2D brush;

layout (location = 1) uniform bool show_pathing_map_static;
layout (location = 2) uniform bool show_lighting;
layout (location = 3) uniform vec3 light_direction;
layout (location = 4) uniform vec2 brush_position;
layout (location = 5) uniform bool render_brush;

layout (location = 0) in vec3 UV;
layout (location = 1) in vec3 Normal;
layout (location = 2) in vec2 pathing_map_uv;
layout (location = 3) in vec2 world_position;

out vec4 color;

void main() {
	color = texture(cliff_textures, UV);

	if (show_lighting) {
		color.rgb *= (dot(-light_direction, Normal) + 1.f) * 0.5f;
	}

	uvec4 byte = texelFetch(pathing_map_static, ivec2(pathing_map_uv), 0);
	if (show_pathing_map_static) {
		uint final = byte.r;

		vec3 pathing_static_color = vec3((final & 2) >> 1, (final & 4) >> 2, (final & 8) >> 3);
		color.rgb = (final & 0xE) > 0 ? color.rgb * 0.75f + pathing_static_color * 0.5f : color.rgb;
	}

	if (render_brush) {
		ivec2 brush_texture_size = textureSize(brush, 0);

		vec2 extra_offset = vec2(0.0f);
		if (brush_texture_size.x % 4 != 0) {
			extra_offset.x = 0.25f;
		}
		if (brush_texture_size.y % 4 != 0) {
			extra_offset.y = 0.25f;
		}

		vec2 brush_uv = ((brush_position - world_position) * 4.f) / vec2(brush_texture_size) + 0.5;

		vec4 brush_color = texture(brush, brush_uv);

		if (brush_uv.x >= 0.f && brush_uv.y >= 0.f && brush_uv.x <= 1.f && brush_uv.y <= 1.f) {
			color.rgb = mix(color.rgb, brush_color.rgb, brush_color.a);
		}
	} 
}
```

`data/shaders/cliff.vert`:

```vert
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;
layout (location = 3) in vec4 vOffset;

layout (location = 0) uniform mat4 VP;
layout (location = 7) uniform ivec2 map_size;

layout(std430, binding = 0) buffer layoutName1 {
    float cliff_levels[];
};

layout (location = 0) out vec3 UV;
layout (location = 1) out vec3 Normal;
layout (location = 2) out vec2 pathing_map_uv;
layout (location = 3) out vec2 world_position;

void main() {
	// WC3 cliff meshes seem to be rotated by 90 degrees so we unrotate
	const vec3 rotated_world_position = vec3(vPosition.y, -vPosition.x, vPosition.z) / 128.f + vOffset.xyz;

	const ivec2 height_pos = ivec2(rotated_world_position.xy);
	const float height = cliff_levels[height_pos.y * map_size.x + height_pos.x];

	const ivec3 off = ivec3(1, 1, 0);

	const float hL = cliff_levels[height_pos.y * map_size.x + max(height_pos.x - 1, 0)];
	const float hR = cliff_levels[height_pos.y * map_size.x + min(height_pos.x + 1, map_size.x)];
	const float hD = cliff_levels[max(height_pos.y - 1, 0) * map_size.x + height_pos.x];
	const float hU = cliff_levels[min(height_pos.y + 1, map_size.y) * map_size.x + height_pos.x];
	const vec3 terrain_normal = normalize(vec3(hL - hR, hD - hU, 2.0));

	gl_Position = VP * vec4(rotated_world_position.xy, rotated_world_position.z + height, 1);

	pathing_map_uv = rotated_world_position.xy * 4;
	UV = vec3(vUV, vOffset.a);

	const vec3 rotated_normal = vec3(vNormal.y, -vNormal.x, vNormal.z);
	Normal = normalize(vec3(rotated_normal.xy + terrain_normal.xy, rotated_normal.z * terrain_normal.z));
	world_position = rotated_world_position.xy;
}
```

`data/shaders/editable_mesh_hd.frag`:

```frag
#version 450 core

layout (binding = 0) uniform sampler2D diffuse;

layout (location = 1) uniform float alpha_test;
layout (location = 2) uniform bool show_lighting;
layout (location = 3) uniform vec3 light_direction;
layout (location = 10) uniform bool is_team_color;

in vec2 UV;
in vec3 Normal;
in vec4 vertexColor;
in vec3 team_color;

out vec4 color;

void main() {
	if (is_team_color) {
		color = vec4(team_color * texture(diffuse, UV).r, 1.f) * vertexColor;
	} else {
		color = texture(diffuse, UV) * vertexColor;
	}

	if (show_lighting) {
		float contribution = (dot(Normal, -light_direction) + 1.f) * 0.5f;
		color.rgb *= clamp(contribution, 0.f, 1.f);
	}

	if (vertexColor.a == 0.0 || color.a < alpha_test) {
		discard;
	}
}
```

`data/shaders/editable_mesh_hd.vert`:

```vert
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;
layout (location = 3) in vec4 vTangent;
layout (location = 4) in uvec2 vSkin;

layout (location = 0) uniform mat4 MVP;
layout (location = 4) uniform mat4 model;
layout (location = 6) uniform int bone_count;
layout (location = 8) uniform vec4 layer_color;
layout (location = 9) uniform int team_color_index;
layout (location = 11) uniform mat4 bones[217]; // Thats a lotta boners. max 200 because the shader compiler issues an error when going higher

out vec2 UV;
out vec3 Normal;
out vec4 vertexColor;
out vec3 team_color;

const vec3 team_colors[28] = {
	vec3(1.000, 0.012, 0.012),
	vec3(0.000, 0.259, 1.000),
	vec3(0.106, 0.906, 0.729),
	vec3(0.333, 0.000, 0.506),
	vec3(0.996, 0.988, 0.000),
	vec3(0.996, 0.537, 0.051),
	vec3(0.129, 0.749, 0.000),
	vec3(0.894, 0.361, 0.686),
	vec3(0.576, 0.584, 0.588),
	vec3(0.494, 0.749, 0.945),
	vec3(0.063, 0.384, 0.278),
	vec3(0.310, 0.169, 0.020),
	vec3(0.612, 0.000, 0.000),
	vec3(0.000, 0.000, 0.765),
	vec3(0.000, 0.922, 1.000),
	vec3(0.741, 0.000, 1.000),
	vec3(0.925, 0.808, 0.529),
	vec3(0.969, 0.647, 0.545),
	vec3(0.749, 1.000, 0.506),
	vec3(0.859, 0.722, 0.922),
	vec3(0.310, 0.314, 0.333),
	vec3(0.925, 0.941, 1.000),
	vec3(0.000, 0.471, 0.118),
	vec3(0.647, 0.435, 0.204),
	vec3(0.180, 0.176, 0.180),
	vec3(0.180, 0.176, 0.180),
	vec3(0.180, 0.176, 0.180),
	vec3(0.180, 0.176, 0.180),
};

void main() {
	const mat4 b0 = bones[int(vSkin.x & 0x000000FFu)];
	const mat4 b1 = bones[int(vSkin.x & 0x0000FF00u) >> 8];
	const mat4 b2 = bones[int(vSkin.x & 0x00FF0000u) >> 16];
	const mat4 b3 = bones[int(vSkin.x & 0xFF000000u) >> 24];
	const float w0 = (vSkin.y & 0x000000FFu) / 255.f;
	const float w1 = ((vSkin.y & 0x0000FF00u) >> 8) / 255.f;
	const float w2 = ((vSkin.y & 0x00FF0000u) >> 16) / 255.f;
	const float w3 = ((vSkin.y & 0xFF000000u) >> 24) / 255.f;
	const mat4 skinMatrix = model * (b0 * w0 + b1 * w1 + b2 * w2 + b3 * w3);
	
	gl_Position = MVP * skinMatrix * vec4(vPosition, 1.f);

	UV = vUV;
	Normal = vNormal;
	vertexColor = layer_color;
	team_color = team_colors[team_color_index];
}
```

`data/shaders/physics_debug.frag`:

```frag
#version 450 core

out vec4 color;

void main() {
	color = vec4(0, 1, 0, 1);
}
```

`data/shaders/physics_debug.vert`:

```vert
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) uniform mat4 MVP;

void main() {
	gl_Position = MVP * vec4(vPosition, 1);
}
```

`data/shaders/selection.frag`:

```frag
#version 450 core

out vec4 color;

void main() {
	color = vec4(0, 1, 0, 1);
}
```

`data/shaders/selection.vert`:

```vert
#version 450 core

layout (location = 0) in vec2 vPosition;
layout (location = 1) uniform mat4 MVP;

void main() {
	gl_Position = MVP * vec4(vPosition, 0, 1);
}
```

`data/shaders/selection_circle.frag`:

```frag
#version 450 core

out vec4 color;

in vec2 uv;

void main() {
	float R = 1.0; 
	float R2 = 0.93; 
	float dist = sqrt(dot(uv * 2.f - 1.f, uv * 2.f - 1.f));
	if (dist >= R || dist <= R2)
	{ discard; } 
	color = vec4(0, 1, 0, 0.75);
}
```

`data/shaders/selection_circle.vert`:

```vert
#version 450 core

layout (location = 0) in vec2 vPosition;
layout (location = 1) uniform mat4 MVP;

out vec2 uv;

void main() {
	uv = vPosition;
	gl_Position = MVP * vec4(vPosition, 0, 1);
}
```

`data/shaders/skinned_mesh_hd.frag`:

```frag
#version 450 core

layout (binding = 0) uniform sampler2D albedo;
layout (binding = 1) uniform sampler2D normal;
layout (binding = 2) uniform sampler2D orm;
layout (binding = 3) uniform sampler2D emissive;
layout (binding = 4) uniform sampler2D teamColor;
layout (binding = 5) uniform sampler2D environment;

layout (location = 1) uniform float alpha_test;
layout (location = 2) uniform bool show_lighting;
layout (location = 3) uniform vec3 light_direction;
layout (location = 10) uniform bool is_team_color;

in vec2 UV;
in vec3 tangent_light_direction;
in vec4 vertexColor;
in vec3 team_color;

out vec4 color;

void main() {
	color = texture(albedo, UV) * vertexColor;
	
	if (show_lighting) {
		vec3 emissive_texel = texture(emissive, UV).rgb;
		vec4 orm_texel = texture(orm, UV);
		vec3 tc_texel = texture(teamColor, UV).rgb;
		color.rgb = (color.rgb * (1 - orm_texel.w) + color.rgb * tc_texel.r * team_color * orm_texel.w);

		// normal is a 2 channel normal map so we have to deduce the 3rd value
		vec2 normal_texel = texture(normal, UV).xy * 2.0 - 1.0;
		vec3 normal = vec3(normal_texel, sqrt(1.0 - dot(normal_texel, normal_texel)));

		float lambert = clamp(dot(normal, -tangent_light_direction), 0.f, 1.f);
		color.rgb *= clamp(lambert + 0.1, 0.f, 1.f);
		color.rgb += emissive_texel;
	}


	if (color.a < alpha_test) {
		discard;
	}
}
```

`data/shaders/skinned_mesh_hd.vert`:

```vert
#version 450 core

layout (location = 0) uniform mat4 VP;
layout (location = 3) uniform vec3 light_direction;
layout (location = 4) uniform int layer_skip_count;
layout (location = 5) uniform int layer_index;
layout (location = 6) uniform uint bone_count;
layout (location = 7) uniform int instanceID;

layout(std430, binding = 0) buffer layoutName {
    vec4 layer_colors[];
};

layout(std430, binding = 1) buffer layoutName1 {
    uint uvs[];
};

layout(std430, binding = 2) buffer layoutName2 {
    uvec2 vertices[];
};

layout(std430, binding = 3) buffer layoutName3 {
	vec4 tangents[];
};

layout(std430, binding = 4) buffer layoutName4 {
	uint normals[];
};

layout(std430, binding = 5) buffer layoutName5 {
    mat4 instance_matrices[];
};

layout(std430, binding = 6) buffer layoutName6 {
	uvec2 skins[];
};

layout(std430, binding = 7) buffer layoutName7 {
	mat4 bone_matrices[];
};

layout(std430, binding = 8) buffer layoutName8 {
	uint team_color_indexes[];
};

out vec2 UV;
out vec3 tangent_light_direction;
out vec4 vertexColor;
out vec3 team_color;

const vec3 team_colors[28] = {
	vec3(1.000, 0.012, 0.012),
	vec3(0.000, 0.259, 1.000),
	vec3(0.106, 0.906, 0.729),
	vec3(0.333, 0.000, 0.506),
	vec3(0.996, 0.988, 0.000),
	vec3(0.996, 0.537, 0.051),
	vec3(0.129, 0.749, 0.000),
	vec3(0.894, 0.361, 0.686),
	vec3(0.576, 0.584, 0.588),
	vec3(0.494, 0.749, 0.945),
	vec3(0.063, 0.384, 0.278),
	vec3(0.310, 0.169, 0.020),
	vec3(0.612, 0.000, 0.000),
	vec3(0.000, 0.000, 0.765),
	vec3(0.000, 0.922, 1.000),
	vec3(0.741, 0.000, 1.000),
	vec3(0.925, 0.808, 0.529),
	vec3(0.969, 0.647, 0.545),
	vec3(0.749, 1.000, 0.506),
	vec3(0.859, 0.722, 0.922),
	vec3(0.310, 0.314, 0.333),
	vec3(0.925, 0.941, 1.000),
	vec3(0.000, 0.471, 0.118),
	vec3(0.647, 0.435, 0.204),
	vec3(0.180, 0.176, 0.180),
	vec3(0.180, 0.176, 0.180),
	vec3(0.180, 0.176, 0.180),
	vec3(0.180, 0.176, 0.180),
};

vec2 sign_not_zero(vec2 v) {
	return vec2((v.x >= 0.f) ? +1.f : -1.f, (v.y >= 0.f) ? +1.f : -1.f);
}

vec3 oct_to_float32x3(vec2 e) {
	vec3 v = vec3(e.xy, 1.f - abs(e.x) - abs(e.y));
	if (v.z < 0.f) {
		v.xy = (1.f - abs(v.yx)) * sign_not_zero(v.xy);
	}
	return normalize(v);
}

/// Needs to match the textent that it was packed with
vec3 unpack_uvec2_to_vec3(const uvec2 v, const float extent) {
	const uint x = v.y >> 11;
	const uint y = ((v.y & 0x7FFu) << 10) + (v.x >> 22);
	const uint z = v.x & 0x3FFFFFu;

	const float xf = (float(x) / float(1u << 21) * 2.f - 1.f) * extent;
	const float yf = (float(y) / float(1u << 21) * 2.f - 1.f) * extent;
	const float zf = (float(z) / float(1u << 22) * 2.f - 1.f) * extent;

	return vec3(xf, yf, zf);
}

mat4 fetchMatrix(int instance_id, uint bone_index) {
	return bone_matrices[instance_id * bone_count + bone_index];
}

void main() {
	// In instanced draws we set instanceID to -1 so we always pick gl_InstanceID
	// In non-instanced draws gl_InstanceID will be 0
	const int instance_id = max(instanceID, gl_InstanceID);

	const mat4 b0 = fetchMatrix(instance_id, uint(skins[gl_VertexID].x & 0x000000FF));
	const mat4 b1 = fetchMatrix(instance_id, uint(skins[gl_VertexID].x & 0x0000FF00) >> 8);
	const mat4 b2 = fetchMatrix(instance_id, uint(skins[gl_VertexID].x & 0x00FF0000) >> 16);
	const mat4 b3 = fetchMatrix(instance_id, uint(skins[gl_VertexID].x & 0xFF000000) >> 24);
	const float w0 = (skins[gl_VertexID].y & 0x000000FF) / 255.f;
	const float w1 = ((skins[gl_VertexID].y & 0x0000FF00) >> 8) / 255.f;
	const float w2 = ((skins[gl_VertexID].y & 0x00FF0000) >> 16) / 255.f;
	const float w3 = ((skins[gl_VertexID].y & 0xFF000000) >> 24) / 255.f;
	const mat4 skin_matrix = b0 * w0 + b1 * w1 + b2 * w2 + b3 * w3;

	const vec3 vertex = unpack_uvec2_to_vec3(vertices[gl_VertexID], 8192.f);

	gl_Position = VP * instance_matrices[instance_id] * skin_matrix * vec4(vertex, 1.f);

	vec3 normal = oct_to_float32x3(unpackSnorm2x16(normals[gl_VertexID]));

	mat3 model = mat3(instance_matrices[instance_id] * skin_matrix);
	vec3 T = normalize(model * tangents[gl_VertexID].xyz);
	vec3 N = normalize(model * normal);
	vec3 B = cross(N, T) * tangents[gl_VertexID].w; // to fix handedness
	mat3 TBN = transpose(mat3(T, B, N));

	UV = unpackSnorm2x16(uvs[gl_VertexID]) * 8.f - 1.f;
	tangent_light_direction = normalize(TBN * light_direction);
	vertexColor = layer_colors[instance_id * layer_skip_count + layer_index];
	team_color = team_colors[team_color_indexes[instance_id]];
}
```

`data/shaders/skinned_mesh_instance_color_coded.frag`:

```frag
#version 450 core

layout (location = 1) uniform float alpha_test;

out vec4 color;

layout (location = 7) uniform int color_id;

void main() {
	color = vec4((color_id & 0xFF) / 255.f, ((color_id & 0xFF00) >> 8) / 255.f, ((color_id & 0xFF0000) >> 16) / 255.f, 1.f);
}
```

`data/shaders/skinned_mesh_instance_color_coded.vert`:

```vert
#version 450 core

layout (location = 0) uniform mat4 MVP;

layout(std430, binding = 0) buffer layoutName {
    mat4 bones[];
};

layout(std430, binding = 1) buffer layoutName1 {
    uvec2 vertices[];
};

layout(std430, binding = 2) buffer layoutName6 {
    uvec2 skins[];
};

vec3 unpack_uvec2_to_vec3(const uvec2 v, const float extent) {
	const uint x = v.y >> 11;
	const uint y = ((v.y & 0x7FFu) << 10) + (v.x >> 22);
	const uint z = v.x & 0x3FFFFFu;

	const float xf = (float(x) / float(1u << 21) * 2.f - 1.f) * extent;
	const float yf = (float(y) / float(1u << 21) * 2.f - 1.f) * extent;
	const float zf = (float(z) / float(1u << 22) * 2.f - 1.f) * extent;

	return vec3(xf, yf, zf);
}

void main() {
	const mat4 b0 = bones[int(skins[gl_VertexID].x & 0x000000FF)];
	const mat4 b1 = bones[int(skins[gl_VertexID].x & 0x0000FF00) >> 8];
	const mat4 b2 = bones[int(skins[gl_VertexID].x & 0x00FF0000) >> 16];
	const mat4 b3 = bones[int(skins[gl_VertexID].x & 0xFF000000) >> 24];
	const float w0 = (skins[gl_VertexID].y & 0x000000FF) / 255.f;
	const float w1 = ((skins[gl_VertexID].y & 0x0000FF00) >> 8) / 255.f;
	const float w2 = ((skins[gl_VertexID].y & 0x00FF0000) >> 16) / 255.f;
	const float w3 = ((skins[gl_VertexID].y & 0xFF000000) >> 24) / 255.f;
	
	vec2 xy = unpackSnorm2x16(vertices[gl_VertexID].x) * 1024.f;
	vec2 zw = unpackSnorm2x16(vertices[gl_VertexID].y) * 1024.f;

	vec4 position = vec4(unpack_uvec2_to_vec3(vertices[gl_VertexID], 8192.f), 1.f);
	position = b0 * position * w0 + b1 * position * w1 + b2 * position * w2 + b3 * position * w3;
	position.w = 1.f;

	gl_Position = MVP * position;

}
```

`data/shaders/skinned_mesh_sd.frag`:

```frag
#version 450 core

layout (binding = 0) uniform sampler2D diffuse;

layout (location = 1) uniform float alpha_test;
layout (location = 2) uniform bool show_lighting;
layout (location = 3) uniform vec3 light_direction;
layout (location = 10) uniform bool is_team_color;

in vec2 UV;
in vec3 Normal;
in vec4 vertexColor;
in vec3 team_color;

out vec4 color;

void main() {
	if (is_team_color) {
		color = vec4(team_color * texture(diffuse, UV).r, 1.f) * vertexColor;
	} else {
		color = texture(diffuse, UV) * vertexColor;
	}

	if (show_lighting) {
		float contribution = (dot(Normal, -light_direction) + 1.f) * 0.5f;
		color.rgb *= clamp(contribution, 0.f, 1.f);
	}

	if (vertexColor.a == 0.0 || color.a < alpha_test) {
		discard;
	}
}
```

`data/shaders/skinned_mesh_sd.vert`:

```vert
#version 450 core

layout (location = 0) uniform mat4 VP;
layout (location = 4) uniform int layer_skip_count;
layout (location = 5) uniform int layer_index;
layout (location = 6) uniform uint bone_count;
layout (location = 7) uniform int instanceID;

layout(std430, binding = 0) buffer layoutName {
    vec4 layer_colors[];
};

layout(std430, binding = 1) buffer layoutName1 {
    uint uvs[];
};

layout(std430, binding = 2) buffer layoutName2 {
    uvec2 vertices[];
};

layout(std430, binding = 4) buffer layoutName4 {
    uint normals[];
};

layout(std430, binding = 5) buffer layoutName5 {
    mat4 instance_matrices[];
};

layout(std430, binding = 6) buffer layoutName6 {
	uvec2 skins[];
};

layout(std430, binding = 7) buffer layoutName7 {
	mat4 bone_matrices[];
};

layout(std430, binding = 8) buffer layoutName8 {
	uint team_color_indexes[];
};

out vec2 UV;
out vec3 Normal;
out vec4 vertexColor;
out vec3 team_color;

const vec3 team_colors[28] = {
	vec3(1.000, 0.012, 0.012),
	vec3(0.000, 0.259, 1.000),
	vec3(0.106, 0.906, 0.729),
	vec3(0.333, 0.000, 0.506),
	vec3(0.996, 0.988, 0.000),
	vec3(0.996, 0.537, 0.051),
	vec3(0.129, 0.749, 0.000),
	vec3(0.894, 0.361, 0.686),
	vec3(0.576, 0.584, 0.588),
	vec3(0.494, 0.749, 0.945),
	vec3(0.063, 0.384, 0.278),
	vec3(0.310, 0.169, 0.020),
	vec3(0.612, 0.000, 0.000),
	vec3(0.000, 0.000, 0.765),
	vec3(0.000, 0.922, 1.000),
	vec3(0.741, 0.000, 1.000),
	vec3(0.925, 0.808, 0.529),
	vec3(0.969, 0.647, 0.545),
	vec3(0.749, 1.000, 0.506),
	vec3(0.859, 0.722, 0.922),
	vec3(0.310, 0.314, 0.333),
	vec3(0.925, 0.941, 1.000),
	vec3(0.000, 0.471, 0.118),
	vec3(0.647, 0.435, 0.204),
	vec3(0.180, 0.176, 0.180),
	vec3(0.180, 0.176, 0.180),
	vec3(0.180, 0.176, 0.180),
	vec3(0.180, 0.176, 0.180),
};

vec2 sign_not_zero(vec2 v) {
	return vec2((v.x >= 0.f) ? +1.f : -1.f, (v.y >= 0.f) ? +1.f : -1.f);
}

vec3 oct_to_float32x3(vec2 e) {
	vec3 v = vec3(e.xy, 1.f - abs(e.x) - abs(e.y));
	if (v.z < 0.f) {
		v.xy = (1.f - abs(v.yx)) * sign_not_zero(v.xy);
	}
	return normalize(v);
}

/// Needs to match the textent that it was packed with
vec3 unpack_uvec2_to_vec3(const uvec2 v, const float extent) {
	const uint x = v.y >> 11;
	const uint y = ((v.y & 0x7FFu) << 10) + (v.x >> 22);
	const uint z = v.x & 0x3FFFFFu;

	const float xf = (float(x) / float(1u << 21) * 2.f - 1.f) * extent;
	const float yf = (float(y) / float(1u << 21) * 2.f - 1.f) * extent;
	const float zf = (float(z) / float(1u << 22) * 2.f - 1.f) * extent;

	return vec3(xf, yf, zf);
}

mat4 fetchMatrix(int instance_id, uint bone_index) {
	return bone_matrices[instance_id * bone_count + bone_index];
}

void main() {
	// In instanced draws we set instanceID to -1 so we always pick gl_InstanceID
	// In non-instanced draws gl_InstanceID will be 0
	const int instance_id = max(instanceID, gl_InstanceID);

	const mat4 b0 = fetchMatrix(instance_id, uint(skins[gl_VertexID].x & 0x000000FF));
	const mat4 b1 = fetchMatrix(instance_id, uint(skins[gl_VertexID].x & 0x0000FF00) >> 8);
	const mat4 b2 = fetchMatrix(instance_id, uint(skins[gl_VertexID].x & 0x00FF0000) >> 16);
	const mat4 b3 = fetchMatrix(instance_id, uint(skins[gl_VertexID].x & 0xFF000000) >> 24);
	const float w0 = (skins[gl_VertexID].y & 0x000000FF) / 255.f;
	const float w1 = ((skins[gl_VertexID].y & 0x0000FF00) >> 8) / 255.f;
	const float w2 = ((skins[gl_VertexID].y & 0x00FF0000) >> 16) / 255.f;
	const float w3 = ((skins[gl_VertexID].y & 0xFF000000) >> 24) / 255.f;
	const mat4 skin_matrix = b0 * w0 + b1 * w1 + b2 * w2 + b3 * w3;

	const vec3 vertex = unpack_uvec2_to_vec3(vertices[gl_VertexID], 8192.f);

	gl_Position = VP * instance_matrices[instance_id] * skin_matrix * vec4(vertex, 1.f);

	UV = unpackSnorm2x16(uvs[gl_VertexID]) * 8.f - 1.f;
	Normal = oct_to_float32x3(unpackSnorm2x16(normals[gl_VertexID]));
	vertexColor = layer_colors[instance_id * layer_skip_count + layer_index];
	team_color = team_colors[team_color_indexes[instance_id]];
}
```

`data/shaders/terrain.frag`:

```frag
#version 450 core

#extension GL_ARB_bindless_texture : require

layout (location = 2) uniform bool show_pathing_map;
layout (location = 3) uniform bool show_lighting;
layout (location = 4) uniform vec3 light_direction;
layout (location = 5) uniform vec2 brush_position;
layout (location = 6) uniform bool render_brush;

layout (binding = 17) uniform usampler2D pathing_map_static;
layout (binding = 18) uniform usampler2D pathing_map_dynamic;
layout (binding = 19) uniform sampler2D brush;

layout (location = 0) in vec2 UV;
layout (location = 1) in flat uvec4 texture_indices;
layout (location = 2) in vec2 pathing_map_uv;
layout (location = 3) in vec3 normal;
layout (location = 4) in vec2 world_position;

layout (location = 0) out vec4 color;

layout(std430, binding = 4) buffer TextureHandles {
	sampler2DArray textures[];
};

vec4 get_fragment(uint id, vec3 uv) {
	if (id == 0xFFFFu) {
		return vec4(0, 0, 0, 0);
	} else {
		return texture(textures[id], uv).rgba;
	}
}

void main() {
	color = get_fragment(texture_indices.a & 0xFFFFu, vec3(UV, texture_indices.a >> 16));
	color = mix(get_fragment(texture_indices.b & 0xFFFFu, vec3(UV, texture_indices.b >> 16)), color, color.a);
	color = mix(get_fragment(texture_indices.g & 0xFFFFu, vec3(UV, texture_indices.g >> 16)), color, color.a);
	color = mix(get_fragment(texture_indices.r & 0xFFFFu, vec3(UV, texture_indices.r >> 16)), color, color.a);

	if (show_lighting) {
		float contribution = (dot(-light_direction, normal) + 1.f) * 0.5f;

		color.rgb *= clamp(contribution, 0.f, 1.f);
	}

	uint byte_static = texelFetch(pathing_map_static, ivec2(pathing_map_uv), 0).r;
	uint byte_dynamic = texelFetch(pathing_map_dynamic, ivec2(pathing_map_uv), 0).r;
	if (show_pathing_map) {
		uint final = byte_static.r | byte_dynamic.r;

		vec3 pathing_color = vec3((final & 2u) >> 1, (final & 4u) >> 2, (final & 8u) >> 3);
		color.rgb = (final & 0xEu) > 0 ? mix(color.rgb, pathing_color, 0.50) : color.rgb;
	}

	if (render_brush) {
		ivec2 brush_texture_size = textureSize(brush, 0);

		vec2 brush_uv = ((brush_position - world_position) * 4.f) / vec2(brush_texture_size) + 0.5;

		vec4 brush_color = texture(brush, brush_uv);

		if (brush_uv.x >= 0.f && brush_uv.y >= 0.f && brush_uv.x <= 1.f && brush_uv.y <= 1.f) {
			color.rgb = mix(color.rgb, brush_color.rgb, brush_color.a);
		}
	} 
}
```

`data/shaders/terrain.vert`:

```vert
#version 450 core

layout (location = 1) uniform mat4 MVP;

layout (binding = 1) uniform sampler2D height_cliff_texture;

layout (location = 0) out vec2 UV;
layout (location = 1) out flat uvec4 texture_indices;
layout (location = 2) out vec2 pathing_map_uv;
layout (location = 3) out vec3 normal;
layout (location = 4) out vec2 world_position;

layout (location = 7) uniform ivec2 map_size;

const vec2[6] position = vec2[6](
	vec2(1, 1),
	vec2(0, 1),
	vec2(0, 0),
	vec2(0, 0),
	vec2(1, 0),
	vec2(1, 1)
);

layout(std430, binding = 0) buffer layoutName {
    float clif_levels[];
};

layout(std430, binding = 1) buffer layoutName1 {
    float ground_heights[];
};

layout(std430, binding = 2) buffer layoutName2 {
    uvec4 terrain_texture_list[];
};

layout(std430, binding = 3) buffer layoutName3 {
    uint terrain_exists[];
};


void main() { 
	const ivec2 pos = ivec2(gl_InstanceID % (map_size.x - 1), gl_InstanceID / (map_size.x - 1));

	vec2 vPosition = position[gl_VertexID];
	const ivec2 height_pos = ivec2(vPosition + pos);
	const float height = clif_levels[height_pos.y * map_size.x + height_pos.x];

	const ivec3 offset = ivec3(1, 1, 0);
	const float hL = ground_heights[height_pos.y * map_size.x + max(height_pos.x - 1, 0)];
	const float hR = ground_heights[height_pos.y * map_size.x + min(height_pos.x + 1, map_size.x)];
	const float hD = ground_heights[max(height_pos.y - 1, 0) * map_size.x + height_pos.x];
	const float hU = ground_heights[min(height_pos.y + 1, map_size.y) * map_size.x + height_pos.x];
	normal = normalize(vec3(hL - hR, hD - hU, 2.0));

	UV = vec2(vPosition.x, 1 - vPosition.y);
	texture_indices = terrain_texture_list[pos.y * (map_size.x - 1) + pos.x];
	pathing_map_uv = (vPosition + pos) * 4;	

	const ivec2 pos2 = ivec2(gl_InstanceID % map_size.x, gl_InstanceID / map_size.x);
	const bool is_ground = terrain_exists[pos2.y * map_size.x + pos2.x] > 0u;

	gl_Position = is_ground ? MVP * vec4(vPosition + pos, height, 1) : vec4(2.0, 0.0, 0.0, 1.0);
	world_position = vPosition + pos;
}
```

`data/shaders/water.frag`:

```frag
#version 450 core

layout (binding = 0) uniform sampler2DArray water_textures;

layout (location = 6) uniform int current_texture;

in vec2 UV;
in vec4 Color;

out vec4 outColor;

void main() {
	outColor = texture(water_textures, vec3(UV, current_texture)) * Color;
}
```

`data/shaders/water.vert`:

```vert
#version 450 core

layout (location = 0) uniform mat4 MVP;
layout (location = 1) uniform vec4 shallow_color_min;
layout (location = 2) uniform vec4 shallow_color_max;
layout (location = 3) uniform vec4 deep_color_min;
layout (location = 4) uniform vec4 deep_color_max;
layout (location = 5) uniform float water_offset;
layout (location = 7) uniform ivec2 map_size;

out vec2 UV;
out vec4 Color;

const float min_depth = 10.f / 128.f;
const float deeplevel = 64.f / 128.f;
const float maxdepth = 72.f / 128.f;

const vec2[6] position = vec2[6](
	vec2(1, 1),
	vec2(0, 1),
	vec2(0, 0),
	vec2(0, 0),
	vec2(1, 0),
	vec2(1, 1)
);

layout(std430, binding = 0) buffer layoutName {
    float cliff_levels[];
};

layout(std430, binding = 1) buffer layoutName2 {
    float water_heights[];
};

layout(std430, binding = 2) buffer layoutName3 {
	uint water_exists[];
};

void main() { 
	// Position of the quad's bottom left vertex
	ivec2 quad_pos = ivec2(gl_InstanceID % map_size.x, gl_InstanceID / map_size.x);
	
	bool is_water = water_exists[quad_pos.y * map_size.x + quad_pos.x] > 0u
				 || water_exists[quad_pos.y * map_size.x + quad_pos.x + 1] > 0u
				 || water_exists[(quad_pos.y + 1) * map_size.x + quad_pos.x] > 0u
				 || water_exists[(quad_pos.y + 1) * map_size.x + quad_pos.x + 1] > 0u;

	UV = vec2(position[gl_VertexID].x, 1.f - position[gl_VertexID].y);

	ivec2 height_pos = ivec2(position[gl_VertexID]) + quad_pos;
	const float water_height = water_heights[height_pos.y * map_size.x + height_pos.x] + water_offset;
	const float ground_height = cliff_levels[height_pos.y * map_size.x + height_pos.x];

	float value = clamp(water_height - ground_height, 0.f, 1.f);
	if (value <= deeplevel) {
		value = max(0.f, value - min_depth) / (deeplevel - min_depth);
		Color = shallow_color_min * (1.f - value) + shallow_color_max * value;
	} else {
		value = clamp(value - deeplevel, 0.f, maxdepth - deeplevel) / (maxdepth - deeplevel);
		Color = deep_color_min * (1.f - value) + deep_color_max * value;
	}
	
	gl_Position = is_water ? MVP * vec4(position[gl_VertexID] + quad_pos, water_height, 1) : vec4(2.0, 0.0, 0.0, 1.0);
 }
```

`data/test map/conversation.json`:

```json
{
    "stringTablePath": "war3map.wts",
    "conversation": {}
}
```

`data/test map/war3map.wts`:

```wts
STRING 1
{
Player 1
}

STRING 2
{
Force 1
}


```

`data/themes/Dark.qss`:

```qss
/* http://doc.qt.io/qt-5/stylesheet-syntax.html */
/* http://doc.qt.io/qt-5/stylesheet-customizing.html */

/******************************************************/
/* QRibbon */

QRibbon {
	max-height: 121px;
}

QRibbon QWidget {
	font: 8pt "Segoe UI";
	color: white;
}

QWidget#centralWidget {
	background-color: rgb(53, 53, 53);
}

QRibbon::pane {
	border-top: 1px solid rgb(38, 38, 38);
	border-bottom: 1px solid rgb(38, 38, 38);
	margin-top: -1;
	margin-bottom: -0;
}

QRibbon QTabBar::tab { 
	height: 23px;
	background-color: rgb(53, 53, 53);
	border: 1px solid rgb(53, 53, 53);
	border-bottom-width: 0px;

	padding-top: -1px;
	padding-left: 14px;
	padding-right: 14px;
	margin-right: 1px;
}

QRibbon QTabBar::tab::hover {
	background-color: rgb(77, 77, 77);
	border-color: rgb(38, 38, 38);
	height: 23px;
}

QRibbon QTabBar::tab::selected {
	background-color: rgb(67, 67, 67);
	border-color: rgb(38, 38, 38);
	padding-bottom: 2px;
}

/******************************************************/
.QRibbonFileButton {
	border: 1px solid transparent;
	background-color: rgb(38, 109, 132);
	height: 24px;
	color: white;
	padding-left: 14px;
	padding-right: 13px;
	qproperty-popupMode: InstantPopup;
}

QRibbonFileButton::hover {
	background-color: rgb(41, 140, 225);
}

QRibbonFileButton::pressed {
	background-color: rgb(18, 104, 179);
}

QRibbonFileButton::menu-indicator { 
	image: none; 
} 

/******************************************************/
/* QRibbonMenu */


QRibbonMenu {
	background-color: rgb(53, 53, 53);
	border: 1px solid rgb(38, 38, 38);
}

QRibbonMenu QToolButton {
	padding-left: 3px;
	padding-right: 2px;
	qproperty-iconSize: 30px 30px;
	background-color: rgb(53, 53, 53);
	border: 1px solid transparent;
	height: 44px;
	width: 216px;
	color: white;
}

QRibbonMenu QToolButton::hover {
	background-color: rgb(85, 85, 85);
	border: 1px solid transparent;
}

QRibbonMenu QToolButton::pressed {
	background-color: rgb(100, 100, 100);
	border: 1px solid transparent;
}

QRibbonMenu QFrame {
	qproperty-frameShape: HLine;
	margin-left: 5;
	margin-right: 5;
	border: none;
	background-color: rgb(38, 38, 38);
	max-height: 1px;
}

/******************************************************/
/* QRibbonTab */
QRibbonTab {
	background-color: rgb(67, 67, 67);
}

QRibbonTab QFrame#seperator {
	border: none;
	max-width: 1px;
	background-color: rgb(38, 38, 38);
	qproperty-frameShape: VLine;
}

/******************************************************/
/* QRibbonContainer */
QRibbonContainer {
	border: 1px solid rgb(38, 38, 38);
	background-color: rgb(42, 42, 42);
}

/******************************************************/
/* QRibbonButton */
QRibbonButton {
	border: 1px solid transparent;
	padding-left: 3px;
	padding-right: 2px;
	qproperty-iconSize: 30px 30px;
	qproperty-toolButtonStyle: ToolButtonTextUnderIcon;
}

QRibbonButton::hover {
	background-color: rgb(85, 85, 85);
}

QRibbonButton::pressed {
	background-color: rgb(100, 100, 100);
}

QRibbonButton::checked {
	background-color: rgb(100, 100, 100);
}

QRibbonButton::checked:hover {
	border: 1px solid rgb(120, 120, 120);
}

QRibbon QLineEdit {
	height: 21px;
	max-width: 50px;
	border: 1px solid rgb(100, 100, 100);
}

QRibbon QLineEdit::hover {
	background-color: rgb(75, 75, 75);
}

QRibbon QLineEdit::focus {
	border: 1px solid rgb(100, 150, 255);
}

QRibbon QLineEdit::disabled {
	background-color: rgb(67, 67, 67);
}

QRibbonButton::menu-indicator {
    top: -3;
}

QRibbonButton QMenu {
	border: 1px solid rgb(100, 100, 100);
}

QRibbonButton QMenu::item {
	height: 28px;
	padding-left: 30px;
    padding-right: 30px;
    margin: 1px;
}

QRibbonButton QMenu::item:selected {
	background-color: rgb(85, 85, 85);
}

QSmallRibbonButton {
	height: 23;
	max-height: 23;
	qproperty-iconSize: 16px 16px;
	qproperty-toolButtonStyle: ToolButtonTextBesideIcon;
}

/******************************************************/
/* Docking */

ads--CDockWidgetTab {
    background: palette(window);
    border-style: solid;
    border-width: 0px 0 0;
    padding: 0;
    qproperty-iconSize: 23px;
}

ads--CDockWidgetTab[activeTab="true"] {
    background: palette(highlight);
    border-color: palette(highlight);
}

ads--CDockWidgetTab[focused="true"]>#tabCloseButton:hover {
	background: rgba(255, 255, 255, 48);
}

ads--CDockWidgetTab[focused="true"]>#tabCloseButton:pressed {
	background: rgba(255, 255, 255, 92);
}

ads--CDockAreaTitleBar {
	background: transparent;
	border-bottom: 2px solid transparent;
	padding-bottom: 0px;
}

ads--CDockAreaWidget[focused="true"] ads--CDockAreaTitleBar {
	background: transparent;
	border-bottom: 2px solid palette(highlight);
	padding-bottom: 0px;
}

QScrollArea#dockWidgetScrollArea {
    padding: 0px;
    border: none;
}

#tabCloseButton {
	margin-top: 2px;
	background: none;
	border: none;
	padding: 0px -2px;
}

#tabCloseButton::hover {
	border: 1px solid rgba(0, 0, 0, 32);
	background: rgba(64, 64, 64, 255);
}

#tabCloseButton::pressed {
	border: 1px solid rgb(98, 162, 228);
	background: rgba(128, 128, 128, 255);
}


/******************************************************/
/* General */

QPushButton {
	border: 1px solid transparent;
}

QPushButton::hover {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(85, 85, 85);
}

QPushButton::pressed {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

QPushButton::checked {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

QDialogButtonBox QPushButton {
	border: 1px solid rgb(100, 100, 100);
	padding: 5;
}

JassEditor QFrame {
	background-color: palette(window);
}

QTableView::indicator {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(60, 60, 60);
}

QTableView::indicator:hover {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(85, 85, 85);
}

QTableView::indicator:pressed {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

QTableView::indicator:checked{
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
	image: url("data/icons/check.png");
}

/******************************************************/
/* Object Editor */

ObjectEditor QLineEdit {
	background-color: rgb(66, 66, 66);
}

IconButton {
	border: 1px solid transparent;
	padding-left: 3px;
	padding-right: 2px;
}

IconButton::hover {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(85, 85, 85);
}

IconButton::pressed {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

IconButton::checked {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

GlobalSearchWidget {
    border: 1px solid rgb(100, 100, 100);
}

GlobalSearchWidget QLineEdit {
    background-color: rgb(53, 53, 53);
    border: 1px solid rgb(100, 100, 100);
	padding: 5px;
	padding-left: 5px;
	padding-right: 10px;
}

GlobalSearchWidget QListView {
    background-color: rgb(53, 53, 53);
    border: 0px
}
```

`data/themes/Light.qss`:

```qss
/* http://doc.qt.io/qt-5/stylesheet-syntax.html */
/* http://doc.qt.io/qt-5/stylesheet-customizing.html */

/******************************************************/
/* QRibbon */

QRibbon {
	max-height: 121px;
}

QRibbon QWidget {
	font: 8pt "Segoe UI";
	color: black;
}

QWidget#centralWidget {
	background-color: white;
}

QRibbon::pane {
	border-top: 1px solid rgb(218, 219, 220);
	border-bottom: 1px solid rgb(218, 219, 220);
	margin-top: -1;
	margin-bottom: -0;
}

QRibbon QTabBar::tab { 
	height: 22px;
	background-color: rgb(255, 255, 255);
	border: 1px solid white;
	border-bottom-width: 0px;

	padding-top: -1px;
	padding-left: 14px;
	padding-right: 14px;
	margin-right: 1px;
}

QRibbon QTabBar::tab::hover {
	background-color: rgb(253, 253, 255);
	border-color: rgb(235, 236, 236);
	height: 23px;
}

QRibbon QTabBar::tab::selected {
	background-color: rgb(245, 246, 247);
	border-color: rgb(218, 219, 220);
	padding-bottom: 2px;
}

/******************************************************/
.QRibbonFileButton {
	border: 1px solid transparent;
	background-color: rgb(25, 121, 202);
	height: 23px;
	color: white;
	padding-left: 14px;
	padding-right: 13px;
	qproperty-popupMode: InstantPopup;
}

QRibbonFileButton::hover {
	background-color: rgb(41, 140, 225);
}

QRibbonFileButton::pressed {
	background-color: rgb(18, 104, 179);
}

QRibbonFileButton::menu-indicator { 
	image: none; 
} 

/******************************************************/
/* QRibbonMenu */
QRibbonMenu {
	color: black;
	background-color: rgb(251, 252, 253);
	border: 1px solid rgb(132, 146, 166);
}

QRibbonMenu QToolButton {
	border: 1px solid transparent;
	background-color: rgb(251, 252, 253);
	height: 44px;
	width: 216px;
	color: black;
}

QRibbonMenu QToolButton::hover {
	border-color: rgb(168, 210, 253);
	background-color: rgb(237, 244, 252);
}

QRibbonMenu QFrame#verticalSeperator {
	border: none;
	max-width: 0px;
	background-color: gray;
	border-left: 1px solid rgb(220, 221, 222);
	border-right: 1px solid rgb(254, 254, 255);
	qproperty-frameShape: VLine;
}

QRibbonMenu QFrame#horizontalSeperator {
	border: none;
	background-color: rgb(220, 221, 222);
	max-height: 1px;
	margin-left: 44px;
	qproperty-frameShape: HLine;
}

/******************************************************/
/* QRibbonTab */
QRibbonTab {
	background-color: rgb(245, 246, 247);
}

QRibbonTab QFrame#seperator {
	border: none;
	max-width: 1px;
	background-color: rgb(226, 227, 228);
	qproperty-frameShape: VLine;
}

/******************************************************/
/* QRibbonContainer */
QRibbonContainer {
	border: 1px solid rgb(219, 220, 221);
	background-color: rgb(250, 251, 252);
}

/******************************************************/
/* QRibbonButton */
QRibbonButton {
	border: 1px solid transparent;
	padding-left: 3px;
	padding-right: 2px;
	qproperty-iconSize: 30px 30px;
	qproperty-toolButtonStyle: ToolButtonTextUnderIcon;
}

QRibbonButton::hover {
	background-color: rgb(232, 239, 247);
}

QRibbonButton::pressed {
	background-color: rgb(201, 224, 247);
}

QRibbonButton::checked {
	background-color: rgb(201, 224, 247);
}

QRibbonButton::checked:hover {
	border: 1px solid rgb(120, 120, 120);
}

QRibbon QLineEdit {
	height: 21px;
	max-width: 50px;
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(255, 255, 255);
	color: rgb(0, 0, 0);
}

QRibbon QLineEdit::hover {
	/*background-color: rgb(75, 75, 75);*/
}

QRibbon QLineEdit::focus {
	/*border: 1px solid rgb(100, 150, 255);*/
}

QRibbon QLineEdit::disabled {
	/*background-color: rgb(67, 67, 67);*/
}

QRibbonButton::menu-indicator {
    top: -3;
}

QRibbonButton QMenu {
	/*border: 1px solid rgb(100, 100, 100);*/
}

QRibbonButton QMenu::item {
	height: 28px;
	padding-left: 30px;
    padding-right: 30px;
    margin: 1px;
}

QRibbonButton QMenu::item:selected {
	background-color: rgb(85, 85, 85);
}

QSmallRibbonButton {
	height: 23;
	max-height: 23;
	qproperty-iconSize: 16px 16px;
	qproperty-toolButtonStyle: ToolButtonTextBesideIcon;
}

/******************************************************/
/* Docking */

ads--CDockWidgetTab {
    background: palette(window);
    border-style: solid;
    border-width: 0px 0 0;
    padding: 0 0px;

}

ads--CDockWidgetTab[activeTab="true"] {
    background: palette(highlight);
    border-color: palette(highlight);
}

ads--CDockWidgetTab[focused="true"]>#tabCloseButton:hover {
	background: rgba(255, 255, 255, 48);
}

ads--CDockWidgetTab[focused="true"]>#tabCloseButton:pressed {
	background: rgba(255, 255, 255, 92);
}

ads--CDockAreaTitleBar {
	background: transparent;
	border-bottom: 2px solid transparent;
	padding-bottom: 0px;
}

ads--CDockAreaWidget[focused="true"] ads--CDockAreaTitleBar {
	background: transparent;
	border-bottom: 2px solid palette(highlight);
	padding-bottom: 0px;
}

QScrollArea#dockWidgetScrollArea {
    padding: 0px;
    border: none;
}

#tabCloseButton {
	margin-top: 2px;
	background: none;
	border: none;
	padding: 0px -2px;
}

#tabCloseButton:hover {
	border: 1px solid rgb(164, 206, 249);
	background-color: rgb(232, 239, 247);
}

#tabCloseButton:pressed {
	border: 1px solid rgb(98, 162, 228);
	background-color: rgb(201, 224, 247);
}


/******************************************************/
/* General */

QPushButton {
	border: 1px solid transparent;
}

QPushButton::hover {
	border: 1px solid rgb(164, 206, 249);
	background-color: rgb(232, 239, 247);
}

QPushButton::pressed {
	border: 1px solid rgb(98, 162, 228);
	background-color: rgb(201, 224, 247);
}

QPushButton::checked {
	border: 1px solid rgb(98, 162, 228);
	background-color: rgb(201, 224, 247);
}

QDialogButtonBox QPushButton {
	border: 1px solid rgb(100, 100, 100);
	padding: 5;
}

JassEditor QFrame {
	background-color: palette(window);
}

QTableView::indicator {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(60, 60, 60);
}

QTableView::indicator:hover {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(85, 85, 85);
}

QTableView::indicator:pressed {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

QTableView::indicator:checked{
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
	image: url("data/icons/check.png");
}

/******************************************************/
/* Object Editor */

ObjectEditor QLineEdit {
	background-color: rgb(66, 66, 66);
}

IconButton {
	border: 1px solid transparent;
	padding-left: 3px;
	padding-right: 2px;
}

IconButton::hover {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(85, 85, 85);
}

IconButton::pressed {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

IconButton::checked {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}
```

`data/tools/jasshelper.conf`:

```conf
[lookupfolders]
// Just type the folders where //! import would look for if relative paths where used, include the final \
// embed them in quotes
// example: "c:\"
// The order determines priority:
".\jass\"

[jasscompiler]
//this is to specify what compiler to use, normally pjass.exe, you may also want to use JassParserCLI.exe ...
"pjass.exe"
//the following line specifies the way the jass syntax checker's arguments are used ...
"$COMMONJ $BLIZZARDJ $WAR3MAPJ"

[externaltools]
// this is for //! external NAME args the syntax is "NAME","executable path"
// example:
//"OBJMERGE","c:\kool.exe"

//To enable automatic .evaluate of methods that are called from above their declaration
// add a line containing: [automethodevaluate]
//this is enabled by default, to disable it
// add a line containing: [forcemethodevaluate]
//To disable the "implicit this" feature that was added in 0.A.0.0
// add a line containing: [noimplicitthis]

```

`data/warcraft/CityCliffs.slk`:

```slk
ID;PWXL;N;E
B;Y65;X2;
C;Y1;X1;K"cliffID"
C;X2;K"variations"
C;Y2;X1;K"AAAB"
C;X2;K2
C;Y3;X1;K"AAAC"
C;X2;K1
C;Y4;X1;K"AABA"
C;X2;K1
C;Y5;X1;K"AABB"
C;X2;K3
C;Y6;X1;K"AABC"
C;X2;K0
C;Y7;X1;K"AACA"
C;X2;K1
C;Y8;X1;K"AACB"
C;X2;K0
C;Y9;X1;K"AACC"
C;X2;K3
C;Y10;X1;K"ABAA"
C;X2;K1
C;Y11;X1;K"ABAB"
C;X2;K2
C;Y12;X1;K"ABAC"
C;X2;K0
C;Y13;X1;K"ABBA"
C;X2;K3
C;Y14;X1;K"ABBB"
C;X2;K0
C;Y15;X1;K"ABBC"
C;X2;K0
C;Y16;X1;K"ABCA"
C;X2;K0
C;Y17;X1;K"ABCB"
C;X2;K0
C;Y18;X1;K"ABCC"
C;X2;K0
C;Y19;X1;K"ACAA"
C;X2;K1
C;Y20;X1;K"ACAB"
C;X2;K0
C;Y21;X1;K"ACAC"
C;X2;K2
C;Y22;X1;K"ACBA"
C;X2;K0
C;Y23;X1;K"ACBB"
C;X2;K0
C;Y24;X1;K"ACBC"
C;X2;K0
C;Y25;X1;K"ACCA"
C;X2;K3
C;Y26;X1;K"ACCB"
C;X2;K0
C;Y27;X1;K"ACCC"
C;X2;K1
C;Y28;X1;K"BAAA"
C;X2;K1
C;Y29;X1;K"BAAB"
C;X2;K3
C;Y30;X1;K"BAAC"
C;X2;K0
C;Y31;X1;K"BABA"
C;X2;K2
C;Y32;X1;K"BABB"
C;X2;K0
C;Y33;X1;K"BABC"
C;X2;K0
C;Y34;X1;K"BACA"
C;X2;K0
C;Y35;X1;K"BACB"
C;X2;K0
C;Y36;X1;K"BACC"
C;X2;K0
C;Y37;X1;K"BBAA"
C;X2;K3
C;Y38;X1;K"BBAB"
C;X2;K1
C;Y39;X1;K"BBAC"
C;X2;K0
C;Y40;X1;K"BBBA"
C;X2;K1
C;Y41;X1;K"BBCA"
C;X2;K0
C;Y42;X1;K"BCAA"
C;X2;K0
C;Y43;X1;K"BCAB"
C;X2;K0
C;Y44;X1;K"BCAC"
C;X2;K0
C;Y45;X1;K"BCBA"
C;X2;K0
C;Y46;X1;K"BCCA"
C;X2;K0
C;Y47;X1;K"CAAA"
C;X2;K1
C;Y48;X1;K"CAAB"
C;X2;K0
C;Y49;X1;K"CAAC"
C;X2;K3
C;Y50;X1;K"CABA"
C;X2;K0
C;Y51;X1;K"CABB"
C;X2;K0
C;Y52;X1;K"CABC"
C;X2;K0
C;Y53;X1;K"CACA"
C;X2;K2
C;Y54;X1;K"CACB"
C;X2;K0
C;Y55;X1;K"CACC"
C;X2;K1
C;Y56;X1;K"CBAA"
C;X2;K0
C;Y57;X1;K"CBAB"
C;X2;K0
C;Y58;X1;K"CBAC"
C;X2;K0
C;Y59;X1;K"CBBA"
C;X2;K0
C;Y60;X1;K"CBCA"
C;X2;K0
C;Y61;X1;K"CCAA"
C;X2;K3
C;Y62;X1;K"CCAB"
C;X2;K0
C;Y63;X1;K"CCAC"
C;X2;K1
C;Y64;X1;K"CCBA"
C;X2;K0
C;Y65;X1;K"CCCA"
C;X2;K1
E

```

`data/warcraft/Cliffs.slk`:

```slk
ID;PWXL;N;E
B;Y65;X2;
C;Y1;X1;K"cliffID"
C;X2;K"variations"
C;Y2;X1;K"AAAB"
C;X2;K1
C;Y3;X1;K"AAAC"
C;X2;K1
C;Y4;X1;K"AABA"
C;X2;K1
C;Y5;X1;K"AABB"
C;X2;K2
C;Y6;X1;K"AABC"
C;X2;K0
C;Y7;X1;K"AACA"
C;X2;K1
C;Y8;X1;K"AACB"
C;X2;K0
C;Y9;X1;K"AACC"
C;X2;K1
C;Y10;X1;K"ABAA"
C;X2;K1
C;Y11;X1;K"ABAB"
C;X2;K1
C;Y12;X1;K"ABAC"
C;X2;K0
C;Y13;X1;K"ABBA"
C;X2;K2
C;Y14;X1;K"ABBB"
C;X2;K1
C;Y15;X1;K"ABBC"
C;X2;K0
C;Y16;X1;K"ABCA"
C;X2;K0
C;Y17;X1;K"ABCB"
C;X2;K0
C;Y18;X1;K"ABCC"
C;X2;K0
C;Y19;X1;K"ACAA"
C;X2;K1
C;Y20;X1;K"ACAB"
C;X2;K0
C;Y21;X1;K"ACAC"
C;X2;K1
C;Y22;X1;K"ACBA"
C;X2;K0
C;Y23;X1;K"ACBB"
C;X2;K0
C;Y24;X1;K"ACBC"
C;X2;K0
C;Y25;X1;K"ACCA"
C;X2;K1
C;Y26;X1;K"ACCB"
C;X2;K0
C;Y27;X1;K"ACCC"
C;X2;K1
C;Y28;X1;K"BAAA"
C;X2;K1
C;Y29;X1;K"BAAB"
C;X2;K1
C;Y30;X1;K"BAAC"
C;X2;K0
C;Y31;X1;K"BABA"
C;X2;K1
C;Y32;X1;K"BABB"
C;X2;K1
C;Y33;X1;K"BABC"
C;X2;K0
C;Y34;X1;K"BACA"
C;X2;K0
C;Y35;X1;K"BACB"
C;X2;K0
C;Y36;X1;K"BACC"
C;X2;K0
C;Y37;X1;K"BBAA"
C;X2;K1
C;Y38;X1;K"BBAB"
C;X2;K1
C;Y39;X1;K"BBAC"
C;X2;K0
C;Y40;X1;K"BBBA"
C;X2;K1
C;Y41;X1;K"BBCA"
C;X2;K0
C;Y42;X1;K"BCAA"
C;X2;K0
C;Y43;X1;K"BCAB"
C;X2;K0
C;Y44;X1;K"BCAC"
C;X2;K0
C;Y45;X1;K"BCBA"
C;X2;K0
C;Y46;X1;K"BCCA"
C;X2;K0
C;Y47;X1;K"CAAA"
C;X2;K1
C;Y48;X1;K"CAAB"
C;X2;K0
C;Y49;X1;K"CAAC"
C;X2;K1
C;Y50;X1;K"CABA"
C;X2;K0
C;Y51;X1;K"CABB"
C;X2;K0
C;Y52;X1;K"CABC"
C;X2;K0
C;Y53;X1;K"CACA"
C;X2;K1
C;Y54;X1;K"CACB"
C;X2;K0
C;Y55;X1;K"CACC"
C;X2;K1
C;Y56;X1;K"CBAA"
C;X2;K0
C;Y57;X1;K"CBAB"
C;X2;K0
C;Y58;X1;K"CBAC"
C;X2;K0
C;Y59;X1;K"CBBA"
C;X2;K0
C;Y60;X1;K"CBCA"
C;X2;K0
C;Y61;X1;K"CCAA"
C;X2;K1
C;Y62;X1;K"CCAB"
C;X2;K0
C;Y63;X1;K"CCAC"
C;X2;K1
C;Y64;X1;K"CCBA"
C;X2;K0
C;Y65;X1;K"CCCA"
C;X2;K1
E

```

`data/warcraft/ability_insights.json`:

```json
{
    "Amls": {
        "name": "Aerial Shackles",
        "tags": [
            "Damage Over Time",
            "Suppressed"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Triggered immediately if allies are nearby. Casts if the caster is under attack.\n* “Stats - Duration”\n   * Negative value still stuns briefly, interrupt channeling.\n* “Damage per second”\n   * At values below 0.0 the number appears to be converted to a positive number and deal damage regardless.\n* The enemy gets suppressed and cannot do anything for the duration (basically stun effect). Unit’s last order will be queued until the debuff expires.\n* Stackable: No, one unit can be affected by one shackles only. If a unit is ordered to cast Aerial Shackles on another unit, but that another unit gets shackled beforehand, the ordered unit will stop its action.\n* Bugs: Whenever caster dies at the same moment as Shackles are being applied (let's say, the target has channeled some damage ability towards the caster, and interrupting him instantly caused ability to deal damage), the link won't be ever removed and leave visual glitchy lightning for whole game until both units are removed.(DracoL1ch)\n* Affect structures and allies. Adhered to Targets Allowed.\n   * If cast on self, this ability lasts indefinitely until the caster dies. The visual lightning glitch mentioned above happens as well.\n* Deals magic type damage"
    },
    "Aroc": {
        "name": "Barrage",
        "tags": [
            "Multi Attack Target"
        ],
        "notes": "Can be repurposed as a multi attack ability, Just make sure to change “Targets Allowed”",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Damage Per Target” and “Maximum Total Damage”[a][b] don't do anything. Probably deprecated in favor of using the attacks actual damage.\n* Maximum Number of Targets below 0 means no extra missiles.\n* By default it always causes the unit to shoot 3 projectiles, but if you put Max Targets to 1 and Max Damage to 2, Barrage will only affect 2 units (including primary target). (DracoL1ch)\n* If you set values of “Damage Per Target” and “Maximum Number of Targets” to 0, and “Maximum Total Damage” to X:\n   * If X = 0, then the ability targets all enemies in its range except for the unit’s primary target. (Prometheus3375)\n   * If X > 0, then the ability launches at most X additional projectiles (X + 1 including the projectile to the unit's primary target). (Prometheus3375)\n* Area of Effect actually dictates the maximum range the missiles can target enemies.\n   * No missiles if negative or 0.\n* Critical Strike Proc prevents barrage usage\n* The secondary attack deal normal type damage\n* If the unit attack has a weapon sound it will only play for the primary target, the other ones stay silent\n* Critical hit doesn’t seem to work with barrage .\n* Does not work with critical strike. If critical strike procs the unit cannot attack multiple units. Prioritize Critical Strike damage on target.  (1.31.1.12173)"
    },
    "Amil": {
        "name": "Call to Arms (both)",
        "tags": [
            "Morph"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* The TownHall version only dictates the range from which to search peasants.\n   * It’s defined in “Area of Effect”.\n   * Effectively it just causes all nearby peasants in range to cast “Call to arms”.\n* Setting the duration to 0 on the peasant version causes the militia to last forever.\n   * Setting the duration below 0 causes all the militia to last forever, except the “militia” bar is empty instead. only a visual difference.\n   * Setting the duration to 0.01 causes the unit to switch between militia and peasant faster than the rendered can actually detect (so it’s instant pretty much).\n   * Anything above 0.10 would work as you expect.\n* Changing the changed unit type of militia to peasant effectively just makes them change into themselves.\n   * The peasant cannot use Repair/Build/Gather while in militia form regardless though.\n   * Other workers cannot use them either.\n   * If the other unit does not have the same Call To Arms ability as the peasant, the game crashes when the duration runs out.\n   * “Normal Form Unit” Does not appear to actually matter, but keep it proper anyway.\n* Uses a limited pathfinder to instantly determine if a Peasant can reach a Town Hall. If the pathfinder fails, the Peasant will be unaffected. (Duckfarter)\n* If you spawn a militia outside peasant conversion, then remove the ability through trigger it will crash the game when the militia is killed (1.36)\n   * Need to be tested with regular peasant conversion"
    },
    "Aclf": {
        "name": "Cloud",
        "tags": [
            "AOE Supportive",
            "AOE Disabling",
            "Buff Stackable"
        ],
        "notes": "By setting Targets Allowed to either Friend or Enemy it can be used as either an AOE enemy debuff, or AOE friendly buff. Or vice versa :^)",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "Casting by AI: Spams any defensive building (ranged and/or melee), usually when attacking towns\n* Cloud is probably the most versatile AOE channel ability\n* Targets - Allowed  “Not Self” does not function properly on this ability.\n* “Attack Speed Modifier” and “Movement Speed Modifier”\n   * At any value over 0.0 the speed increases by that amount (i.e. at 1.0 the attacks are twice as fast), this includes the animation.\n   * At any value below 0.0 the speed decreases by that amount (i.e. at -.5 the attacks should be twice as slow) includes the animation.\n* Attacks Prevented turns off all kinds of the defined attack types, i.e. “Melee” would be melee attacks from footmen and ”Ranged” would be ranged attacks from archers and \"Special\" disables attacks that only have \"Tree\", \"Debris\" or \"Wall\" in the \"Combat - Attack x - Targets Allowed\" field; e.g. most workers have an invisible second attack that can only target trees (It’s based on the AttackType of the unit). (Selaya)\n* Does not disable innate abilities, such as Shadow Meld. Newly added abilities also get disabled.\n   * Spells refer to the casting of spells, effectively it’s an AOE channeled “silence”.\n      * WARNING! if this AOE silence hits the caster and the caster is a valid target, the effect will disappear but the caster will have the “Cloud” Buff forever while being silenced. (Confirmed removable with triggers)\n      * The forever buff above cannot be removed by dispelling magic but also gets removed if the unit dies.\n      * Not even another unit throwing the same buff on that unit will remove the effect, they are effectively soft locked to the effects of the ability.\n      * This does not occur if another dragon rider throws the cloud ability on the channeling dragon rider, only if they hit themselves.\n* Chance To Miss is essentially just a value between 0.0 and 1.0 where all units affected by the cloud (not units outside) get a chance to miss on their attacks.\n   * A 0.40 chance to miss would be a 40% chance to miss.\n   * Values below 0 does not appear to do anything.\n   * Values above 1 works as if they were 1.0.\n   * The effect appears to stack with evasion (with slight diminishing returns) .\n* Buff Stackable Clouds can stack on top of each other, all they need to do is reference different “Stats - buff” for it to work. An easy way to do this is to simply make a copy of the “Cloud” buff and set your new Cloud Abilities “Stats - Buffs” to that new Cloud Buff which will effectively display both the buffs on the target character and also stacking the values.  (Confirmed stackable.)\n* If you do not change the Cloud buff differently, the unit will only get affected by the first Cloud which has the debuff on it. Until it no longer gets affected by such Cloud, it will begin check and can get affected by other clouds."
    },
    "Acmg": {
        "name": "Control magic",
        "tags": [
            "TODO"
        ],
        "notes": "A different version of Charm",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "(Notes below by RoyGBV)\n* “Data - Charge for Current Life” doesn’t do anything.\n* “Data - Mana per Summoned Hitpoint” controls the mana spent by the caster upon casting this ability.\n   * This ability calculates the total manacost by the following:\n      * (current HP of the target summoned unit) * “Data - Mana per Summoned Hitpoint”\n   * The ability cannot be cast when the above formula returns a real value that is greater than your current mana.\n      * Despite this, the ability still allows you to select targets when you have enough mana to actually click on the ability icon itself (specified in “Stats - Mana Cost”), even if you can’t actually target anything since the “Not Enough Mana” message pops up (by default in War3, its 25).\n* “Data - Maximum Creep Level” works similarly to that of Charm, it controls what levels of units can be cast by this ability.\n* The two duration fields, “Hero” and “Normal” don’t do anything.\n   * Upon cast, this ability resets the expiration timers of summoned units, if they had one.\n* This ability is hard-coded to be only cast on enemy summons, the “Stats - Targets Allowed” field only concerns what kinds of summons these are, be it units, wards, or even buildings.\n* Just like Charm, this ability removes all debuffs, including Doom, on the target upon cast."
    },
    "Adef": {
        "name": "Defend / -Magic Defense",
        "tags": [
            "Percent Damage Taken Decrease",
            "Percent Damage Taken Increase",
            "Percent Damage Increase",
            "Percent Damage Decrease"
        ],
        "notes": "Ironically it’s very flexible for defend, but that’s because it was also made for spell breakers to have a magic defense.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "[Percent Magic Taken Decrease] [Percent Magic Taken Increase] [Movespeed Increase] [Magic Immunity]\nCasting by AI: Activated in the same manner as Divine Shield, but only if the caster is being attacked by a unit with Piercing damage or Magic damage (If ability is set to shield against Magic damage as well).\n* “Data - Attack Speed Factor”\n   * Values above 0 decrease attack speed by specified percent(1=100%). (Prometheus3375)\n   * Values below 0 increase attack speed by specified percent(1=100%). (Prometheus3375)\n* “Data - Movement speed factor”\n   * Values above 0 decrease movement speed by specified percent(1=100%). (Prometheus3375)\n   * Values below 0 increase movement speed by specified percent(1=100%). (Prometheus3375)\n   * The resulting movement speed of the unit is capped by the unit minimum movement speed constant (150)\n* Chance to Deflect is the percentage chance to deflect either Magic or Piercing entirely.\n   * Clamped between 0.0 and 1.0.\n* Damage Dealt is the percentage that dictates the damage given to the unit.\n   * i.e. 2.0 would give the footman double damage.\n   * Negative values are rounded back to 0, no heal.\n* Damage Taken is the percentage damage Taken.\n   * Negative values are rounded back to 0, no heal.\n   * 2.0 is double damage taken.\n* Deflect damage taken (Piercing)(Spells) is the damage taken if the deflect goes through\n   * Note: Whilst named “deflect” it may be more accurate to describe it as “reflect” since this is when the missile gets reflected back at the attacker.\n   * If you set both to 0 you can reflect both piercing and magic attacks with the “defend” ability. Requires setting the gameplay constant “DefendDeflection” to true for any reflecting to occur.\n   * Negative values are clamped to 0.\n   * 2.0 would be double damage.\n* Magic damage reduction is identical to “Damage Taken” but for magic."
    },
    "Adis": {
        "name": "Dispel Magic",
        "tags": [
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Summoned Unit Damage\n* Deals magic type damage.\n* “Data - Summoned Unit Damage”\n   * Negative value heals instead.\n   * Does not damage or heal allied summons in anyway."
    },
    "Afbk": {
        "name": "Feedback",
        "tags": [
            "TODO"
        ],
        "notes": "It appears that the Damage ratio only dictates how the mana drained is converted to damage. But any total damage less than 0 gets rounded up to 0.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Max mana drained”\n   * Positive values drain target’s mana\n      * If the damage ratio is below 0.0 the target will not heal.\n   * Negative values restore target’s mana\n      * If the damage ratio is above 0.0 it will not heal the target.\n      * If the damage ratio is below 0.0 the target will take damage while restoring mana.\n* “Summoned Damage”\n   * Negative values will not heal the summoned unit.\n* Affect buildings with Targets Allowed."
    },
    "Aflk": {
        "name": "Flak Cannons",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "*  It's a passive ability that works kind of like a mix of Pulverize and the Splash Attack on the “Combat 1(or 2)” section of a unit, in that it uses flat values to deal damage, but its fields are reminiscent of the one found in Combat.\n* Deals physical damage (normal damage type) and uses your attack type for the splash effect.\n* Seems to only work if the attack type is instant\n* This ability works with Instant and Normal attack type (patch 1.30.4)"
    },
    "Afla": {
        "name": "Flare",
        "tags": [
            "Vision",
            "Dummy Ability"
        ],
        "notes": "Text",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Flare count dictates how many times the skill can be used.\n   * The default setting at 0 is unlimited\n   * Setting negative will instead do so that every time the skill is used, it will keep decreasing (i.e. -1 => -2) and etc. every time it’s cast. Effectively making a “Times ability has been cast” counter.\n      * The Counter of this ability is similar to that of Sentinel. In addition if you level up this ability with the new level has non-negative count while the current count is negative it does not update to the new count.\n* Setting the Area of Effect to 0 causes it to give no vision. Effectively making it a dummy ability.\n   * Negative values causes it to be treated as 0.\n* Effect delay is the time it takes until the flare vision actually starts.\n   * Setting to a negative value treats it as 0.\n   * The unit cannot move while this Delay is active, so setting it high will cause the unit to just stand around looking dumb until the flare comes down. That effect cannot be canceled by moving/attacking/etc.. only if a silence/stun comes in.\n   * Unlike “Casting time” however, the “shooting” animation plays when you start casting the ability. Playing the animation before the wait duration.\n   * The ability won’t go on cooldown until the flare is actually “fired”.\n* If your unit has a string under Required Animation Names, using flare as a dummy ability will remove the string.\n* With True Sight this ability is similar to Far Sight. The flare animation is visible to enemies."
    },
    "Agyb": {
        "name": "Flying Machine Bombs",
        "tags": [
            "TODO"
        ],
        "notes": "Doesn't do anything, it’s all handled by the Upgrade. Dummy ability for display.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Null"
    },
    "Afsh": {
        "name": "Fragmentation Shards",
        "tags": [
            "TODO"
        ],
        "notes": "Similar to Flak Cannons, but only works on units with Unarmored and Medium armor types.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Ranged splash attack that’s an ability.\n* Negative AOE is considered as zero.\n* This passive ability will only work on Artillery attack type. (Have not tested on Artillery (line) attack type. (Patch 1.30.4))"
    },
    "Ahea": {
        "name": "Heal",
        "tags": [
            "Healing",
            "Autocast"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Used when caster or any nearby allies take significant/any/moderate damage.\n* Cannot be cast on units with full life.\n* Setting Hit Points Gained to negative causes negative healing.\n   * The \"Healer\" won't get kill credit for units killed with negative healing.\n   * Ignores spell resistance/immunity.\n* Disables auto attacking while autocast is enabled and target is in range.\n   * Note : can re-enable auto attack by removing the ability and add it back (1.36)\n   * So if the heal has a very long reload time, the unit won’t attack during this, which is annoying\n* When toggling on autocasting, the unit will attempt the unit with the lowest % health in range and will keep healing until full.\n   * Stopping the unit or giving another order will cause the unit to reset this behavior.\n   * If the priest is idle it will also toggle between targets occasionally."
    },
    "Ainf": {
        "name": "Inner Fire",
        "tags": [
            "Healing Over Time",
            "Flat Armor Decrease",
            "Flat Armor Increase",
            "Percent Damage Increase",
            "Percent Damage Decrease",
            "Autocast"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed randomly? May be a preference for high level units (e.g. Frost Wyrm or Tauren).\n* Damage increase dictates the damage percentage\n   * Only affects base damage, damage bonuses from items or other abilities/auras are not included.\n   * Anything above 0 gives more damage\n   * Anything below 0 removes damage\n      * -1.0 is the lowest it can normally go. (Not tested with items such as “Claws of attack +12”, might stack with that).\n      * It cannot go below the units base damage, so the unit is still dealing randomized “Dice” damage.\n      * Example: a unit with 30-59 damage is gonna get a -30 damage debuff at maximum.\n* Defense increase changes armor\n   * Works as you expect both positively and negatively.\n* Life Regen Rate.\n   * Causes the unit to receive a healing over time of the specified amount per second. Does not modify unit life regeneration, for example standard undead units will still receive this healing over time when not on blight. Values less than 0 are not damage but instead are negative healing over time. Does not reward any kill credit for deaths it causes.\n      * Basically Life regen rate works like Unholy Aura, in that it only adds a percentage value to your health regeneration. (RoyGBV)"
    },
    "Aivs": {
        "name": "Invisibility",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Occasionally casts on retreating friendly heroes with moderate to low health\n* Transition Time dictates fade time, how long the hero will start visually becoming transparent before being invisible."
    },
    "Adts": {
        "name": "Magic Sentry",
        "tags": [
            "TODO"
        ],
        "notes": "Building (Unit) version of True Sight",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* ^ look at Notes"
    },
    "Apxf": {
        "name": "Phoenix Fire",
        "tags": [
            "Damage Over Time",
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* This ability continuously fires Phoenix Fires into nearby valid units. The fire stops attacking a unit as soon as the unit has buff.\n* Affected units cannot die from damage over time buff. It has a minimum health of 1. Which is similar to Envenomed Spears without having to attack.\n* Damage Per Second is the amount of damage that unit takes per second.\n   * Applied every second.\n   * Values greater than or equal to 0 will deal damage.\n   * Values below 0 will be healed. As the value is negative the amount will be removed from current life and no kill credit given.\n* Initial Damage is the damage the unit takes when the projectile hits.\n   * All values, even negative, will cause damage as normal.[c][d]\n* The time between taking damage is dictated by the buff applied. Which is dictated by how long it lasts by “Stats - Duration”.\n* “Stats - Duration” decides whether phoenix fire will target the applicable enemy units or not. Testing showed that with a slow enough projectile speed or fast enough cooldown or large enough “Stats - Area of Effect” or a combination of these, it will cause phoenix fire to target and fire multiple phoenix fire at the target and they all dealt the correct amount of damage despite the buff being in effect. (Patch 1.30.4)\n* Impact Damage might trigger several times against the same target if your “Art - Missile speed” or “Stats - Cooldown” is too low.\n   * You can get around this by increasing either or both of those.\n   * It appears to be because the buff is not applied until the missile actually “hits”.\n* Display buff icon on the affected units.\n* Can't affect the Source itself.        (Krotos)\n* \"Stats - Cooldown\" uses only 1. Level.\n* The phoenix missile dealing Unknown damage type to place the debuff, the burning over time dealing Fire damage type."
    },
    "Aphx": {
        "name": "Phoenix Morphing",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* If used to convert a hero temporarily to a normal unit upon death, reverts the hero to level 1   (Confirmed)\n* Works like an instant Bear Form that does not display on the UI and take effect as soon as the caster dies.\n* Works on Heroes as you would hope (Khyrberos)\n* Can be used to change units from one unit to another if the alternative unit has a different phoenix morphing ability. (Yeti)"
    },
    "Aply": {
        "name": "Polymorph",
        "tags": [
            "Morph"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Disables most of default passive abilities (f.i. Evasion, Damage block, Critical Strike (despite the critter being unable to attack...))\n* Unit Levels are ignored, if the Maximum Creep Level is set to 0 or below.\n* Can't Target Summoned Units.\n* Kills Illusions on cast.\n* Negative duration leads to an empty expiration Time in the UI.\n* Human version of Hex."
    },
    "AHta": {
        "name": "Reveal",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Works similarly to Goblin Lab’s Reveal, except no gold cost, on a longer cooldown and only used by Arcane Towers."
    },
    "Aslo": {
        "name": "Slow",
        "tags": [
            "Movespeed Increase",
            "Movespeed Decrease",
            "Attackspeed Increase",
            "Attackspeed Decrease",
            "Autocast"
        ],
        "notes": "Easy and versatile, can easily be a buff spell.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed randomly? May be a preference for high level units (e.g. Frost Wyrm or Tauren) Casted when a friendly unit takes damage(source: Azure tower defense hawkriders slow spell)\n* “Attack Speed Factor” and “Movement Speed Factor”\n   * Anything above 0 slows the attack speed.\n   * Anything below 0 increases the attack speed."
    },
    "Asps": {
        "name": "Spell Steal",
        "tags": [
            "TODO",
            "Autocast"
        ],
        "notes": "Below notes aside, this works just like Abolish Magic",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "*  Targeting an enemy unit causes all of its positive buffs to fling as a projectile to your nearest ally (prioritizes allies who don't have a stolen positive buff).\n   * If there are no allied units in the area or if everyone has a stolen positive buff, it will transfer to you instead (dispels the enemy if you also have a stolen buff).\n* Targeting an allied unit does the opposite thing listed above, gathering all negative debuffs and flinging it as a projectile to the nearest enemy, prioritizing those who don't have a stolen negative debuff.\nIf there are no enemy units in the area or if every enemy has a stolen positive buff, it will simply dispel the ally instead.\n* Uses the “Area of Effect” field for the range of buff transfers. (RoyGBV)\n* Can be cast by units with Locust, but they cannot receive buffs(if no other recipients are in range it will dispel instead). (KitsuneTailsPrower)\n* Which allied units can receive the stolen buff appears to be hard coded. (KitsuneTailsPrower)\n* Invulnerable and Magic Immune units cannot receive the buff. (KitsuneTailsPrower)\n\n\n        -Sphere\n* Each time an attack is made or a spell is cast, one of the caster’s attachments will vanish. By default, these use the Blood Mage’s “ball” art. The attachments don’t have to all have the same art. (EternalOne)\n* Each time an attack is made or a spell is cast, a missile will be fired at the target (or target point.) This happens even if there isn’t normally a projectile art involved. This is why only the Blood Mage has a ball fly towards the target of his Flame Strike. As a side note, this doesn’t have to be the same art as the attachments. (EternalOne)\n* The cooldown dictates how long it takes for the lost attachments to reappear. (EternalOne)\n* Can be used simply to add art to any figure, although requiring the model to have whatever attachment points are used. (Yeti)"
    },
    "Asth": {
        "name": "Storm Hammers",
        "tags": [
            "Dummy Ability"
        ],
        "notes": "Doesn't do anything, it’s all handled by the Upgrade.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": ""
    },
    "Ahsb": {
        "name": "Sundering Blades",
        "tags": [
            "TODO",
            "Percent Damage Increase",
            "Flat Damage Increase",
            "Flat Damage Decrease",
            "Percent Damage Decrease",
            "Stackable"
        ],
        "notes": "An ability that makes the unit do more damage to armor types. Warcraft3 V1.31+",
        "latest_tested_version": "1.31.1.12164",
        "raw_text": "* Bonus Damage (Percent) is computed before Bonus Damage (Flat)\n* Bonus Damage (Flat)\n   * Values above 0 cause more damage.\n   * Values below 0 cause less damage\n* Bonus Damage (Percent)\n   * Values above 0 cause more damage\n   * Values below 0 cause less damage\n* Defense Type Affected\n* Stacking Sundering Blades:\n   * Starts with the Last Added and iterates all the way up to the first.\n* Computes Bonus Damage (Percent) & Bonus Damage (Flat) of one Sundering Blade then swaps to the next. The result of the previous is the base for the new\n* Ignores allowed Targets of the ability\n* Red floating text from Critical Strike doesn’t show bonuses from this ability, but the actual damage dealt does stack if a unit has both this ability and critical strike (Somen00b).\n* Data - Defense Type Affected cannot be copy-pasted from one level to another.\n* Transformation skills disable all visual effects on model weapons, but not animations that need to be generated on to other units.\n* AI units with this ability tends to focus against medium armor (Unverified)"
    },
    "AHav": {
        "name": "Avatar",
        "tags": [
            "Flat Armor Decrease",
            "Flat Armor Increase",
            "Flat Damage Decrease",
            "Flat Damage Increase",
            "Flat Health Decrease",
            "Flat Health Increase"
        ],
        "notes": "The only negative part seems to be that you can’t disable the magic immunity.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Damage, Defense and Health bonuses operate the same way.\n   * Anything above 0 increases the stat.\n   * Anything below 0 decreases the stat.\n* Setting the health to a negative value causes the MK to die.\n   * Upon reviving the MK’s life value will be in underflow, essentially making him invulnerable for the rest of avatars duration.\n   * Once the Avatar duration runs out his health gets turned back to normal.\n      * This includes if the duration runs out while he is dead.\n   * Check “item permanent life gain” for more info.\n* Magic Damage Reduction does nothing as he gets magic immunity regardless.\n* If you cast Avatar just as Metamorphosis’s duration runs out so that the hero is still increasing in size, and only the alternate form has the Avatar Ability, the hero’s model will become invisible. (Didn’t test what if anything reverts this) . (KitsuneTailsPrower)"
    },
    "AHbn": {
        "name": "Banish",
        "tags": [
            "Unique"
        ],
        "notes": "A very “in engine” ability, hard to manipulate because of it.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Trigger when in cast range, has a preference for summoned units.\n* Removing “Banish” as a buff from the ability does not prevent the unit from going Ethereal.\n* Both enemy and friendly units take more damage when ethereal.\n* The amount of extra damage taken is based on a Gameplay Constant.\n* Deals Unknown type damage (does not actually deal damage)"
    },
    "AHbh": {
        "name": "Bash / -Critical Strike",
        "tags": [
            "Flat Damage Increase",
            "Percent Damage Increase",
            "Percent Damage Decrease"
        ],
        "notes": "While very very similar they do have some weird interactions with each other.",
        "latest_tested_version": "1.36",
        "raw_text": "* Warcraft 3 is very funny about Critical Strike and by default it will handle a 4.99% chance Critical Strike as 0%. A few years ago this bug was fixed, but you have to enable the fix. In your map go to Scenario / Map Options and enable Use Accurate Probability for calculations![e] (emperor_d3st)\n* Damage Multiplier dictates how much the damage is amplified.\n   * At -1.00 no damage is dealt.\n      * Damage value is not displayed.\n   * Below 0 no damage is dealt.\n      * Damage value is displayed as 0.\n   * At 0 full damage is dealt.\n      * No damage value text is displayed (on melee units only, shown for ranged attacks tho).\n   * At 0.01-0.99 only 1%-99% of the total damage is dealt\n      * Damage value is displayed.\n   * At 1.00 full damage is dealt\n      * Damage value is simply displayed as the damage being dealt.\n   * Anything above 1 increase the damage\n      * Damage value is displayed.\n* Damage bonus dictates how much flat damage is added.\n   * This damage is independent of Damage Multiplier, the damage multiplier damage is only based on the units normal damage.\n   * Setting it to a value so that Damage bonus is less than the unit’s maximum damage causes either the unit to be slightly healed… or slightly damaged.  (Confirmed)\n   * -> is blocked/modified by spell immunity/resistance.\n   * Flat bonus damage is force damage but get blocked and modified by spell immunity/resistance.\n* Use Pseudo-random Distribution, which means the initial attacks after proc does not equal to the proc chance, but much lower and afterwards attack might exceed proc chance but never has 100% chance.\n* Modifiable proc chance.\n* The “Stats - Buffs” value is actually applied to the enemy unit on successful Critical/Bash.\n   * The amount of time the buff is applied is dictated by “Stats - Duration”.\n* If a unit has both Bash and Critical Strike and they trigger together on the same attack.\n   * Both the damage values show up as text (if applicable).\n   * Both the buffs are applied (if you add a buff to Critical strike).\n   * Only the highest damage from Damage Multiplier value is actually applied to the enemy unit.(Only the highest critical actually counts).\n   * Damage Bonus appears to stack somehow, at 100/100 the damage ended up at 250 damage instead. (Needs more testing!).\n* Chance to miss and Chance to Evade dictates evade chance for attacks. (Confirmed. Literally another Drunken Brawler with different order string)[f]\n* Chance to miss/chance to evade Values range from 0.0 to 1.0 with 1.0 being 100% evasion chance. (KitsuneTailsPrower)\n* Plays \"Caster art\" effect whenever evasion happens (You must set the chance to miss / chance to evade above 0.0) (KitsuneTailsPrower)\n* Bash deals force type damage on successful Bash attack\n* Deal Force damage type on proc.\n* Never miss only applies to successful critical strikes/bashes NOT to all attacks. (KitsuneTailsPrower)\n* Data - Area of Effect doesn’t change anything : the bash doesn’t become AoE"
    },
    "AHbz": {
        "name": "Blizzard",
        "tags": [
            "Healing",
            "Damage Over Time",
            "Stackable"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "Casting by AI: Will cast if there are at least 2 to 3 units in a group.\n* \"Value - Cast Time\" is the interval between waves.\n   * Setting this value to 0.01 or below triggers only 1 Wave and an Unit can only be affected one time by Blizzard Waves using this specific \"Blizzard (Caster)\" Buff until lost again, which won't happen under normal circumstances, DpS buff will still be applied..\n   * Setting this value to 0.02 or above causes it to trigger correctly.\n   * Has a Hardcoded damage delay (ca. 0.9 seconds) to fit the default Blizzard Shard falling.\n* \"Value - Buff\" Defines Dps Buff and Stackability\n   * DpS Buff and Wave-damage Buff are Independent.\n   * Blizzard's DpS Buff does stack with Unique \"Blizzard\" Buffs\n   * DPS Buff is not applied, if the Wave-Damage is exactly 0.\n   * Blizzard's Wave-damage does stack with Unique \"Blizzard (Caster)\" Buffs.\n   * Without any \"Blizzard (Caster)\" Buff, Wave-damage stacks always.\n   * \"Blizzard (Caster)\" Buff is not shown in the UI.\n* \"Value - Duration Hero/Unit\" Defines the duration of the DpS Buff on Hero/Unit\n   * Buff Duration of 0 will apply no DpS buff and no DpS damage.\n* If multiple Blizzards with the same Buff affect one target, the one with the  highest damage wins.\n* \"Data - Damage\" Defines Wave-Damage\n   * Heals with Damage equal to 0 or below and does not trigger Damage-Events in that Case.\n   * spell immunity blocks the healing; Even making the spell ultimate does not change this.\n   * Deals magical spell-damage with Damage above 0.\n* \"Value - Max Damage\" Defines the maximum Damage of one Wave\n   * At 0 a Wave can deal Unlimited Damage.\n   * Above 0 Damage will be split equally to all affected targets, if a Wave would deal too much damage.\n   * Below 0, Changes it into an AoE Healing Spell, regardless of the default damage.\n   * Positive Wave-damage allows to split the Healing equal, if healing exceeds max damage (Healing).\n   * Negative Wave-damage ignores the max damage cap.\n* \"Data - Building Reduction\":\n   * Blizzard gave it the wrong Name. It's a simple Multiplier.\n   * Setting it to 0 -> No damage/Healing to buildings. Still trigger damage event.\n   * Setting it between 0 and 1 -> buildings take reduced damage/Healing.\n   * Setting it above 1 -> buildings take additional Damage/Healing.\n   * Setting it to a negative Number reverts healing to damage for buildingsFor example 1.0 heal by 100% damage, 1.5 heal by 150% damage.\n   * Does only work on the Wave-Damage.\n* \"Data - Damage a second\" Defines Buff DpS\n   * Deals magical Spell Damage.\n   * First hit is instantly applied at Wave Impact.\n   * With DpS below 0 it reduces HP with additional ca. 66% bonus-damage, without Triggering Damage-Events. Ignores Spell Resistance, but Spell Immunity blocks it.\n* Deals cold type damage"
    },
    "AHab": {
        "name": "Brilliance Aura",
        "tags": [
            "Mana Drain",
            "Mana Regen",
            "AOE Supportive",
            "AOE Disabling"
        ],
        "notes": "Can use “Targets Allowed” to redirect the buff.",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* “Data - Mana Regeneration”\n   * “Percent bonus” can be applied to add/drain from max mana instead, and functions correctly.\n      * If a hero learns/levels Brilliance Aura with a percent bonus while carrying an item that gives bonus mana the new regeneration rate will be based on its current total mana, if the item is removed the regeneration rate does not decrease.\n      * Vice-versa too, if it learns/levels Brilliance Aura and afterwards picks up an item that gives bonus mana its regeneration rate will stay the same.\n   * Remember that 1.00 equals to 100%, and 0.01 equals to 1%, if you're going to use percentage-based values.\n   * Anything above 0 causes the unit to regenerate mana.\n   * Anything below 0 causes the unit to lose mana.\n   * Level up temporarily removes buff from units before placing new buff."
    },
    "AHad": {
        "name": "Devotion Aura",
        "tags": [
            "Flat Armor Decrease",
            "Flat Armor Increase",
            "AOE Supportive",
            "AOE Disabling"
        ],
        "notes": "Can use “Targets Allowed” to redirect the buff.",
        "latest_tested_version": "1.36",
        "raw_text": "* “Data - Armor bonus”\n   * If using Flat values (Non Percent)\n      * Anything above 0 adds armor.\n      * Anything below 0 removes armor.\n   * If using percent instead.\n      * Anything above 0 adds armor? The amount added is not what you expect.\n      * Anything below 0 removes armor? The amount removed is not what you expect.\n      * Only uses the amount from “Combat - Defense Base”, meaning that armor given by items and from agility points are NOT taken into account (0.0 is 0%, 1.0 is 100%). (RoyGBV)\n      * Similar to Brilliance Aura, if you level up ability there is a slight delay after removing the old aura on units before the new aura is applied."
    },
    "AHds": {
        "name": "Divine Shield",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Casts when attacked, often just before the caster is dealt damage or hit by a non-friendly spell to avoid taking any damage. The health of the unit isn't a factor for its casting.\n* Becomes invulnerable and Immune to Magic.\n* Does not break currently Actions.\n* Has unlimited Duration with \"Value - Duration\"  = 0 or below.\n* On Cast:\n   * Dispels magical based Buffs, even if they are marked as Ultimate.\n   * Dispels Buffs which can't target invulnerable Units.\n* Ultimative/Physically Spells containing “invulnerable” in targets can place buffs on Units protected by Divine Shield, Except Stuns (Stormbolt, Firebolt etc).\n* Is cancelled by “Monsoon” and “Starfall”  (Confirmed, including Stampede)\n   * All invulnerability abilities are canceled by channeling abilities, except the Scroll of Town Portal item.\n* However if the channeling ability is not originally a channeling ability, such as ability “Channel” with Follow through time higher than 0, does not cancel invulnerability.\n* Does not interrupt ongoing channeling ability. So you must cast Monsoon, Starfall or Stampede first.\n* Disable this ability from casting again. Similar to Doom behavior. Also prevent any new ability of the same kind from casting.\n* Losing this ability or buff removes the invulnerability instantly ."
    },
    "AHfs": {
        "name": "Flame Strike",
        "tags": [
            "Healing",
            "Damage Over Time",
            "Healing Over Time",
            "Stackable"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Triggered by having 2 clustered enemy units in area of effect. (Nudl)\n* “Data - Damage Dealt”\n   * Damage values below 0 heals the target.\n   * The building reduction is applied to both healing and damage.\n* Damage Interval is the tickrate between damage.\n   * Setting this value to 0.01 or below causes it to only trigger once.\n   * Setting this value to 0.02 or above causes it to trigger correctly.\n   * Setting this value to 0.02 causes manslaughter.\n* The “Stats - Effects” Actually dictates flames that are left on the ground.\n   * Even without an Effect, the damage will still be Dealt. The source is just invisible.\n* “Stats - Duration - Hero” Dictates how long the “Full” damage will be dealt.\n* “Stats - Duration - Normal” Dictates how long the “Half” damage will be dealt.\n* Removing the “Flame Strike” from “Stats - Buffs” causes a cute little “Tool Tip Missing”.\n* A Unit can be affected by multiple Flamestrikes with different \"Flamestrike\" Buffs at the same time.\n* Even though this ability applies damage over time, it only damages trees once. If trees are regrown while the spell is still active, it will not apply damage to them again.\n* Adhere to Targets Allowed.\n* Deals fire type damage"
    },
    "AHhb": {
        "name": "Holy Light",
        "tags": [
            "Healing"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spam on any nearby Undead units or friendly non-Undead units, prefers heroes. /Death Coil is same function as Holy Light but with opposite targets. It's been noticed while doing some Tank/Spank boss fights that if the hero is taken a LOT more damage then the heal, the healer or himself(if he has this spell) he STOPS casting it\n* “Amount Healed/Damaged\"\n   * Setting this to below 0 reverses the effect (Deal full damage to allies and heal enemies for half damage).\n* Damage Targets are: Units with the Class “Undead” or Units of the Race “Demon”.\n   * This behavior is hard-coded\n* Deals divine type damage (also deals unknown damage)\n* Does not respect Art - Special modifications on custom abilities (tested on 2.0.1)"
    },
    "AHmt": {
        "name": "Mass Teleport",
        "tags": [],
        "notes": "You could technically use this to “Copy paste” unit templates… should you use “false”",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Casting Delay”\n   * Negative values or zero is an instant cast.\n* Setting “Data - Number of Units Teleported” to -1 turns it into unlimited units teleport.\n   * Other negative values are treated as positive values.\n   * Setting it to zero causes only the Archmage to be teleported.\n* Use teleport clustering defines how the units are teleported.\n   * At true all the units will be “clustered” around the point of arrival.\n   * At false all units will be in the same spread as they were before the teleport, relative to the archmage.\n* When teleporting to the target unit, the teleport position for the caster will be at the same cliff level as the targeted unit.[g]\n* If the target unit is in a terrain with not sufficient pathable space for all units for landing, sometimes an error message “A unit could not be teleported” will be displayed and some units are left behind. Or sometimes the teleportation brings no unit at all with no error message. In narrow terrain, even with Teleport Clustering set to False the units will still be clustered.\n   * When only some units are teleported, prioritize units with smaller collision sizes so that teleportation can transport most number of units in alloted space, taking into account the collision size of the target unit.\n* If the target unit is within the teleportation range of the caster unit, the target unit simply repositions itself depending on Teleport Clustering.\n* Can target self only once while it does not have a cast time and effect. Cannot target enemies.\n* Interrupt channeling, any ongoing abilities of transported units will be canceled.\n* If the target unit becomes hidden for the duration, the transportation is canceled. Transformation does not cancel this ability.\n* Disjoint projectiles.\n* By default, the target unit is silenced with attack and move ability disabled but can be reenabled with triggers. If the target unit moves, the animation remains in the original position and when finishes transporting, all units will be moved to the target unit’s current position.\n* Silence and Doom interrupt channeling, but does not affect the target unit.\n* Affect allies with Spell Immunity."
    },
    "AHpx": {
        "name": "Phoenix",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Area below 0 summons behind the summoner"
    },
    "AHre": {
        "name": "Resurrection",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Cast if there are friendly dead units nearby. AI will not cast if the caster has Locust\n* Is \"Amount of Revived Units\" below 1 no Unit is Revived, but the Spell is only used if there are corpses around.\n* Can't Revive Heroes.\n   * Still true even when the Hero has “Combat - Death Type” set to “Can raise, Doesn’t decay”.\n* Can Revive Units from any Player if wanted, they won't change their owner.\n* Triggers the \"Summons an Unit\"-Event for each Unit revived.\n* The Units keep their HandleId and trigger added Abilities, but triggerly added Inventory (and maybe some other abilities) will disappear. (Prometheus3375)\n* Resurrection does prefer units with higher Levels.\n*  After sorting by the highest level, the units closest to the caster are revived. (Somen00b)\n* Appears to have no upper limit on the number of corpses that can be revived (tested with 999 corpses and all were revived) (KitsuneTailsPrower)"
    },
    "AHdr": {
        "name": "Siphon Mana",
        "tags": [
            "Mana Drain",
            "Mana Regen",
            "Healing",
            "Healing Over Time"
        ],
        "notes": "Succ! Slurp, and other non sexual and sexual slurping noises.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Mana/Hit Points Drained”  defines how many points are transferred every “Draw Interval(seconds)”.\n   * Anything above 0 causes the caster to gain mana/health and the target to lose mana/health.\n   * Anything below 0 causes the caster to lose mana/health and the target to gain mana/health.\n* If you set any field in Bonus Mana Decay, Bonus Mana Factor, Mana Points Drained, Mana Transfered Per Second, Drain Interval to 0, it will cause a bug that you cannot target enemy and ally even if you set Targets Allowed field properly. If you want to use it for visual effect of Dummy units without using Lightning, set all these fields to 0.01, it will not cause any noticeable effect on the unit other than the visual effect. (1.31.1.12173) (Akaiharuki)\n* Requires a gameplay constant to be changed to allow mana transfer, otherwise it can only steal/give the mana.\n   * When set to True with appropriate Targets Allowed field settings, allows you to transfer mana to allies, and still drains mana from enemies. (You can’t give mana to enemies this way). This behavior appears to be hard-coded.\n   * In Gameplay Constants - Drain Transfers Life/Mana may by default appear with Value: True with black color. But you have to set it to True again with the field turns purple to take effect on allies. (1.31.1.12173) (Akaiharuki)\n* Deals Unknown type damage"
    },
    "AHtb": {
        "name": "Storm Bolt",
        "tags": [
            "TODO"
        ],
        "notes": "Literally just a simple point-and-click stun that uses a projectile.",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "Casting by AI: Spammed at every cool down, has preference to target heroes.\n* Can target allied units if modified.\n* Setting damage to negative values heals the target upon projectile impact.\n* Deals sonic type damage (also deals unknown type damage)\n* Set stun duration to 0 or a negative value causes permanent stun.\n* Always stun regardless of duration."
    },
    "AHwe": {
        "name": "Summon Water Elemental",
        "tags": [
            "Summon"
        ],
        "notes": "Its free real estate!",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Casts when caster or nearby allies are engaging enemies.\n* Area is the distance between the summoned and summoner in the facing direction.\n   *  One can use a value below 0 to summon behind the caster[h]\n* When an unit has multiple versions of this ability, it uses all of them at the same time.\n   * This also respects cast times, Manacosts, cooldowns of each.\n   * The unit will start channel all the abilities. When the cast time of one finished it will use it and trigger the Effect-Event\n* Only works correctly when cast time of the first triggering summon + unit backwing time contains all cast times\n* This is a “stackable” summon, meaning that successive casts will not destroy/kill previous summoned units."
    },
    "AHtc": {
        "name": "Thunder Clap",
        "tags": [
            "Movespeed Increase",
            "Movespeed Decrease",
            "Attackspeed Increase",
            "Attackspeed Decrease"
        ],
        "notes": "Sadly you cannot apply any of the above tags to allies. It’s hardcoded to only hit enemies",
        "latest_tested_version": "1.28.5.7680.",
        "raw_text": "Casting by AI: Will cast if there are 2 to 3 units around the caster. May not be used if air units are present (despite being allowed to hit them to).\n* This debuff cannot be dispelled by Purges.\n* “Attack/Movement Speed Reduction” defines how much those are reduced.\n   * Setting this to any value above 0 causes the unit to attack/move slower.\n   * Setting this to any value below 0 causes the unit to attack/move faster.\n* Deals sonic type damage\n\n\n@Orc:"
    },
    "Aast": {
        "name": "Ancestral Spirit",
        "tags": [
            "TODO"
        ],
        "notes": "Only works on Taurens",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Seems to be hardcoded to only work on units with the “Tauren” tag under the ”Stats - Unit Classification” checklist. (RoyGBV)\n* “Stats - Cast Range” determines the seek range (more like AOE) of the Spiritwalker to cast this ability. If there are no Tauren corpses nearby, the ability is not cast. Setting the value to 0 requires the caster to literally be on top of the corpse, while setting it to higher values allows the caster to revive Tauren corpses from a distance. (RoyGBV)"
    },
    "Abtl": {
        "name": "Battle Stations",
        "tags": [
            "Unique"
        ],
        "notes": "Disable shortcut key, hide the ability. Transports that can only transport certain units. Profit?",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Allowed Unit Type” Defines what unit is allowed inside the transport.\n   * No other units can be picked up other than the defined unit.\n* Causes the Number of [Transport Size] closest units of  [Allowed Unit Type] within the [Area of Effect] radius to try and enter the transport.\n* Increases the attack speed of the Transporting Unit (i.e. Orc Burrow) by 100% for each unit in cargo.\n* Enabling enemy targeting in combination with the ‘Devour - Cargo’ ability allows you to draw in enemy workers (Kino)\n   * Changing the targets allowed to include enemies on the standard Cargo Hold ability does nothing\n* Having multiple levels with different ‘Data - Allowed Unit Type’ allows the loading of different unit types.\n* Setting ‘Data - Allowed Unit Type’ field to empty does not work (Kino)\n* Uses a limited pathfinder to instantly determine if a Peon can reach the Burrow. If the pathfinder fails, the Peon will be unaffected. (Duckfarter)"
    },
    "Absk": {
        "name": "Berserk",
        "tags": [
            "Attackspeed Increase",
            "Attackspeed Decrease",
            "Movespeed Increase",
            "Movespeed Decrease",
            "Percent Damage Taken Increase",
            "Transient"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Used in combat, will not cast if outnumbered.\n* Doesn't interrupt unit's orders on activation, allowed to use even while channeling.\n* “Attack Speed Increase” s/e\n   * Anything above 0 increases attack speed.\n   * Anything below 0 decreases attack speed.\n* “Movement Speed Increase” s/e\n   * Anything above 0 increases movement speed\n   * Anything below 0 decreases movement speed\n   * Capped by the minimum unit movement speed value (150)\n   * Putting -1 doesn’t make the unit perfectly immobile if the constant is set to 0\n* “Damage Taken Increase” s/e.\n   * Anything above 0 increases damage taken (percentage)\n   * 0 has no effect\n   * Anything below 0\n      * Becomes immune to Attacks\n      * Converts taken spelldamage to healing.\n      * heal by damage * (1 + taken multiplier); -1 -> 2 x healing. -2 -> 3 x healing\n      * Other Sources of Spell resistance reduce the healing.."
    },
    "Ablo": {
        "name": "Bloodlust",
        "tags": [
            "Attackspeed Increase",
            "Attackspeed Decrease",
            "Movespeed Increase",
            "Movespeed Decrease",
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Doesn't stack with itself, regardless of buff id. Causes permanent visual model's size bugs when 2+ Bloodlusts with different model scale are mixed.\n* “Attack Speed increase” increases attack speed\n   * Anything above 0 increases attack speed.\n   * Anything below 0 decreases attack speed.\n* “Movement speed increase” Increases movement speed.\n   * Anything above 0 increases movement speed\n   * Anything below 0 decreases movement speed.\n* “Scaling Factor” Is the size increase of the unit.\n   * Setting it to 0 cause no size change.\n   * Anything above 0 causes the unit to “grow”.\n   * Anything between -0.01 and -0.99 causes the unit to shrink\n   * At -1.00 the unit is technically not visible anymore.\n   * Anything below -1.00 causes the unit to “Invert” upon itself, effectively turning it inside out.\n      * Ground units will be put “underground” with their feet occasionally sticking out.\n      * Ground units will leave a footprint trail similar to that of siege.\n      * Air units will just turn inside out.\n   * Any value below 0 causes the units selection circle to mess up.\n      * Any unit who has the “Bloodlust” ability will also experience this, even when they are not buffed."
    },
    "Abof": {
        "name": "Burning Oil",
        "tags": [
            "Damage Over Time"
        ],
        "notes": "Effectively it’s just a flamestrike that occurs “on attack” instead… and also does not heal.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Damage Dealt is the values that define the damage\n   * Any damage above 0 deals damage.\n   * Any damage below 0 gets converted back into a positive number, still dealing damage.\n   * The building reduction only works above 0, below 0 it gets rounded back up to 0.\n* Damage Interval is the tickrate between damage.\n   * Setting this value below or at 0 causes it to devastatingly kill anything it hits. by triggering several times every 0.01 seconds.\n   * Setting this value above 0 functions correctly\n* The “Stats - Effects” Actually dictates flames that are left on the ground.\n   * Even without an Effect, the damage will still be Dealt. The source is just invisible.\n* “Stats - Duration - Hero” Dictates how long the “Full” damage will be dealt. (how long the full-damage fire lasts on the ground)\n* “Stats - Duration - Normal” Dictates how long the “Half” damage will be dealt. (how long the half-damage fire lasts on the ground)\n* Doesn’t work if the unit weapon type is “Normal”, “Instant” or “NONE”. (Uyarrr)\n* Deals enhanced type damage"
    },
    "Acpf": {
        "name": "Corporeal Form",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Null"
    },
    "Adev": {
        "name": "Devour",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "Casting by AI: Spammed on anything that can be targeted, may prefer units with higher levels.\n* Noms down a unit, placing it in cargo space.\n   * The ability cannot be cast if the amount of units inside the cargo space is above 0.\n* Grant a 520.507 AoE flying vision (furthest result got with precise test with 0.01 error) over the devouring unit until its devoured unit dies. The vision has both black mask and fog of war.\n* Provide True Sight vision over the devouring unit, even if the devouring unit turns locust with invisibility which normally cannot be detected through True Sight.\n   * “Duration - Hero” and “Duration - Normal” don’t appear to do anything.\n* Setting a unit’s race to Demon grants them immunity to being devoured\n* Cannot be cast on allies, self, buildings with any Target Allowed configuration. It still displays the effect and animation but nothing happens. Can be cast on heroes.\n* Disjoint projectiles onto the target.\n* Dealing Unknown damage type on cast. Dealing Acid damage type while in the cargo."
    },
    "Adcn": {
        "name": "Disenchant",
        "tags": [
            "TODO"
        ],
        "notes": "Basically just re-skinned Dispel Magic",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Not much to see here\n* Deals magic type damage to summons"
    },
    "Aens": {
        "name": "Ensnare",
        "tags": [
            ""
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Brings an air unit to the ground, snaring it in the process.\n* Will ignore magic immunity depending on the “Gameplay - Ensnare Checks Magic Immunity” Gameplay constant.\n* Cannot target units with speed 0. Otherwise it will display error message “Must target a moveable unit”. Hence it cannot target basic buildings.\n* “Data - Melee attack range”\n   * Setting this allows for you to change the attack range of units. (Tal0n)\n   * Only works with certain units, reasons why currently unknown. (Tal0n)[i][j][k]\n* Deal Unknown damage type."
    },
    "Aven": {
        "name": "Envenomed Spears",
        "tags": [
            "Damage Over Time",
            "Attackspeed Decrease",
            "Attackspeed Increase",
            "Movespeed Decrease",
            "Movespeed Increase",
            "Stackable"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* The “Damage Per Second” defines the damage taken per second.\n   * Negative values get converted to positive ones, still doing damage. Doing twice the damage before reduction.\n* “Attack Speed Factor” and “Move Speed Factor” reduce the AS or MS of the target unit.\n   * Values above 0 decreases speed.\n   * Values below 0 increases speed.\n   * Good for dummy spell reduces speed on attack.\n* Stacking Type Defines what values stack with each other.\n   * The values are Damage, Movement, Attack Rate and Kill Unit.\n   * The same units attack does not stack against the same target, you must have several units to apply more than 1 stack.\n   * Different versions of Envenomed Spears stack against the same unit with their own values  (Confirmed)\n   * If a unit has multiple Envenomed Spears only one is used.\n   * Without \"Kill Unit\"-Flag, Hit points don't get reduced below 1.0..\n   * This Ability applies 2 independent Buffs. If any Flag except \"Kill Unit\" is set the second is used.\n   * A unit can suffer both Buffs at the same time, each buff deals its own damage-Instance.\n      * If the unit has magic resistance, the magic resistance will reduce damage from each damage instance.\n   * The damage source is overwritten each time the Buff is applied again.\n* Ethereal Units are unaffected by this Ability.\n* AI:\n   * Causes autoattack to prioritize units who are not affected by poison yet.\n* Deals poison type damage\n* When being hit by this ability for the first time, the target also takes Unknown damage type that places the debuff."
    },
    "Aetf": {
        "name": "Ethereal Form",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Null"
    },
    "Ahwd": {
        "name": "Healing Ward / -Sentry Ward",
        "tags": [
            "Summon"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Making the healing ward ability summon no unit will crash the game. ( Abovegame )\n* The above is probably the same as most other Summon abilities. For obvious reasons.\n* Healing Ward doesn’t technically have an AOE, but it will always show a 500 AOE circle when you’re casting it. The same is true for abilities based on it. (EternalOne)"
    },
    "Aoar": {
        "name": "Healing Ward Aura",
        "tags": [
            "Healing",
            "Healing Over Time",
            "Damage Over Time",
            "AOE Supportive",
            "AOE Disabling"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Hit Points Regenerated refers to the Flat or Percentage based healing.\n   * Have a value below 0.0 causes the unit to start taking damage.\n      * The unit will only start taking damage if it’s health is NOT full.\n   * Anything above 0.0 cause healing.\n   * The visual only shows on units that are missing health (Doomshep)"
    },
    "Alsh": {
        "name": "Lightning Shield",
        "tags": [
            "Healing",
            "Healing Over Time",
            "Damage Over Time"
        ],
        "notes": "No, this does not work as a temporary “Immolation” buff",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Deals damage per second to everyone around target.\n   * Setting to a value below 0.0 causes healing.\n   * Any value above 0.0 causes damage.\n* The ability “Stats - Targets Allowed” defines which targets you can cast lightning Shield on. One can not change the targets taking damage.\n* The damage source of Lightning Shield is the buffed unit.\n   * Except when it comes to experience, then it's the casting unit.\n* Killing neutral Hostile units with this ability doesn’t appear to grant the kill gold bounty and experience bounty. (RoyGBV)\n* Deals lightning type damage"
    },
    "Aliq": {
        "name": "Liquid Fire",
        "tags": [
            "Damage Over Time",
            "Attackspeed Decrease",
            "Attackspeed Increase",
            "Movespeed Decrease",
            "Movespeed Increase"
        ],
        "notes": "Text",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* “Attack Speed Reduction” and “Move Speed Reduction”\n   * Values above 0 decreases speed\n   * Values above 1 will apply max movespeed reduction\n   * Values below 0 increase speed.\n* “Extra Damage Per Second”\n   * Setting the value negative causes it to get converted to a positive number instead.\n      * While you can set the field to a negative value in the editor, that display is purely cosmetic and in reality acts as a positive number in-game\n* Spell makes proper use of “Targets Allowed” removing “Structure” causes it to be applied to anything attacked.\n* As of 1.35.0, units with the liquid fire buff can now be repaired, but their repair rate is slowed by 75%.\n* Deals fire type damage\n* Can only be applied by ranged units\n   * To be more precise, it only works for Missile and Missile (splash)\n   * And it may also only check for attack 1 (need to be tested further)"
    },
    "Apak": {
        "name": "Unit Inventory",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Inventory for units.\n                           * If the ability is removed, all items will drop on the ground.\n                           * If can use Item is active and non-hero obtain stat items, the game will crash (Daffa)"
    },
    "Asal": {
        "name": "Pillage",
        "tags": [],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680,",
        "raw_text": "* Accumulation Step dictates how many hits needed to get the Resources from the target.\n   * Anything above 0 acts normal.\n   * Setting to 0 or below causes warcraft 3 to enter an infinite loop, effectively freezing the game.\n* Salvage Cost Ratio seems to control the ratio of damage to resources using the building's resource costs.\n   * More information on how this is calculated would be appreciated.(notes below are by RoyGBV)\n   * This shares the same data fields as Unsummon Building (which I wrote a ton of details about), but is instead appended to the attacking unit, and still allows the building being attacked to be interacted with and repaired.\n   * Just like Unsummon Building, “Data - Salvage Cost Ratio” refers to the total percentage of the building’s gold and lumber cost to be returned upon its destruction, and not per attack.\n   * “Data - Accumulation Step” has some differences from its equivalent in Unsummon Building\n      * Instead of ticking resources every 1 second, it instead ticks when the HP lost by the building is equal to the value set.\n         * HP lost refers to the damage dealt by attacking units with the Pillage ability, after reductions and amplifications by armor type.\n      * Setting this value to be greater than 1 also causes the resources gained to become divisible by the value you set, causing resources gained to be sometimes less than the percentage set in “Salvage Cost Ratio”, which is why it's best to leave it at 1, as all numbers are divisible by 1.\n         * Setting it to zero causes the game to freeze, you’re dividing by zero\n      * The amount of resources gained per tick uses this formula: [(Building’s max HP) / (Accumulation Step)] set upon building construction completion and does not adapt, (all remainders are ignored).\n         * This means that if the building takes damage (or gets repaired) from other units without Pillage, you lose (or gain) some of the resources.\n      * For example, a unit’ attack deals 100 Chaos Damage on a Building with 1000HP that cost 500G and 300L to build, assuming that you set Accumulation Step to 1, and Salvage Cost Ratio to 0.50, you should gain 25G and 15L per attack.\n         * Sometimes though, due to decimal rounding calculations, resources gained will be a point more or less than the supposed percentage amount, it becomes more prevalent when many units are attacking (eg: instead of 250G, it becomes 249G).\n   * Calculation of resources is the same for as long as units with Pillage are the ones attacking, regardless of unit count, unit type, unit damage, and even damage type. (assuming you set Accumulation Value to 1, otherwise it's not smooth sailing)\n      * This means that Pillage DOES NOT stack, and that you should not put multiple units with Pillage to attack a single building, instead try to spread them out to attack other buildings to maximize resources gained.\n   * This ability doesn’t seem to work on buildings (or units) with exactly or more than 10,000 HP for some reason.(needs more testing) EDIT: It actually works, it’s just that the resource calculation is so small that the resources gained often ends up getting rounded down.\n   * Pillage does not gain resources from buildings under construction, or have not yet finished building.\n      * When a building is upgrading itself (eg: Town Halls), it uses the gold and lumber cost of the building of the base Town Hall, as the upgrade has not yet finished. If Town Hall upgrades have finished, it uses the gold and lumber cost of that instead.\n   * Works with ranged units, with the resource gained upon projectile impact provided that it doesn’t miss.\n      * Similarly, resources are gained after successful projectile impact, and after all damage reductions and amplifications have been calculated.\n      * Attack modifier abilities such as Searing Arrows or even Critical Strike do not count in resource calculations.\n      * Siege units that deal splash damage do not gain resources when using the Attack Ground command to deal damage. It must be a direct attack on said structure.\n      * Ranged units that deal splash damage do not gain resources on the units hit by the splash damage, only the primary target grants resources.\n      * Same thing applies for Missile (Bounce) and Artillery (Line) attack type units, as well as units with Cleaving Attack ability, only the primary target gains resources.\n   * Adheres to Targets Allowed, allowing you to gain resources when attacking enemy units. Does not work on allied/friendly units and buildings.\n      * When attacking units, and even buildings, their researchable upgrades and abilities (some of them) are also taken into account in cost calculation. However, they only seem to take the first tier of weapon/armor upgrades on units that have any tier of them.\n(needs more testing)"
    },
    "Awar": {
        "name": "Pulverize",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* This passive can play a sound! Sound - Effect Sound will play on the effect trigger.\n   * Deals enhanced type damage\n   * Data - Damage Dealt dictates how much damage is dealt around the caster unit. Adheres to positive and negative values: Positive values deal damage, negative ones restore hit points.\n   * Data - Chance to Stomp range from 0.000 to 100.000 with 100.00 being the ability always casting.\n   * Stats - Targets allowed adheres to tags\n   * Ability can be made into a simple ‘on attack, AOE lifesteal’ with proper targets allowed tags set. I might also heal enemy entities, but need the ‘Enemy’ target tag to work."
    },
    "Aprg": {
        "name": "Purge",
        "tags": [
            "Suppressed",
            "Movespeed Decrease"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - xxxx Pause Duration” dictates how long the unit is suppressed, or rather “paused” from taking any action.\n   * Negative value does nothing.\n   * Movement Update Frequency supposedly changes the factor of which the unit is slowed.\n   * A value below 0 appears to do nothing.\n   * Can be cast on trees with Sentinel (owl) to dispel it.\n   * The dispeled tree can be cast Sentinel on again.\n   * The dispeled tree cannot be cast Purge again as long as there’s no owl.\n   * Deals magic type damage to summons"
    },
    "Arbr": {
        "name": "Reinforced Burrows Upgrade",
        "tags": [
            "Dummy Ability"
        ],
        "notes": "Doesn't do anything, it’s all handled by the Upgrade",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* The one thing that this ability does is add the metal blocks to the four sides of Burrows and Watch Towers once the upgrade is in effect. Upgrades can’t add attached effects, after all. (EternalOne)"
    },
    "Aeye": {
        "name": "Sentry Ward",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Targeted Summon Skill.\n   *  Sentry Ward always turns the unit it summons invisible for the spell’s duration. (EternalOne)\n   * For a non-invisible version use serpent ward\n   * For a AoE circle target use Healing Ward"
    },
    "Aspi": {
        "name": "Spiked Barricades",
        "tags": [
            "TODO"
        ],
        "notes": "Spiked Carapace for buildings, but deals flat damage instead",
        "latest_tested_version": "1.36.1.20719",
        "raw_text": "* This ability is needed in order for a unit that uses the spiked barricades research to actually return any damage.\n   * The amount of reflected damage is set through the Spiked Barricades research.\n   * Research effect Spiked Barricades sets an absolute amount\n   * Research effect Spiked Barricades (%) sets a factor multiplied with the received damage\n   * This received damage refers to the damage amount dealt by the damage source before any reductions\n   * The damage is reflected before the unit with Spiked Barricades (called caster here) effectively takes damage from the damage event that triggered Spiked Barricades\n   * The event order is: caster is about to take damage, target is about to take damage, target takes damage, caster takes damage\n   * Deals spell attack type damage, meaning magic immune units receive no reflection damage\n   * Deals defensive type damage"
    },
    "Aspl": {
        "name": "Spirit Link",
        "tags": [
            "Percent Damage Taken Increase",
            "Percent Damage Taken Decrease"
        ],
        "notes": "Next generation trolling, no pun intended.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Casts on friendly units that are engaged\n   * “Distributed Damage Factor” is the % of the damage redirected to other units.\n   * At 1 and above no damage is distributed.\n   * At 0 approx 100% is distributed to other targets.(including self)\n   * At any value below 0, all units linked are gonna start taking more damage.\n   * The damage sharing ignores distance and whenever they are actually “linked” from the same skill cast.\n   * In reality you can have 2 Spirit walkers on the opposite sides of the map casting the buff, and the damage will still be distributed between all units whom are “Spirit Linked”.\n   * The link also works towards allied units with the buff.\n   * So technically in a melee game you can apply the buff to your allies peasants and then run a few tanky suicidal units into the enemy base.\n   * Does not share the “unit takes damage” with enemies. But if you throw the buff at an enemy they will get their own sided buff.\n\n\n   * You can reverse the spell to deal more damage to linked enemy units by having a dummy (owned by target enemy unit) cast the spell. However this change for whatever reason is known to desync as of 1.31.1 (Nudl)\n   * Deals spirit link type damage"
    },
    "Asta": {
        "name": "Stasis Trap",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Targeted Summon Skill.\n   * Summon will turn invisible at the end of Data - Activation Delay (Khyrberos, 1.26.0.6401)\n   * Data - Stun Duration: Unit stun duration.\n   * Stats - Duration - Hero: Hero stun duration.  (TGleds)\n   * Setting stun duration to 0 makes it infinite, to avoid this put 0.01\n   * Data - Detonation Radius: Determines the AoE range of the Stun…  But also the size of the AoE targeting image for the Casting Unit (Khyrberos, 1.26.0.6401)\n   * Data - Detection Radius:  Determines how close a target needs to get to the summoned unit before it will ‘detonate’ (IF it has already been ‘primed’) (Khyrberos, 1.26.0.6401)\n   * Data - Activation Delay:  Determines the amount of time before the summoned unit A) turns invisible & B) becomes ‘primed’ (able to ‘trigger’ on a target in its Detonation Radius, turning visible momentarily, dying, and creating the AoE stun). (Khyrberos, 1.26.0.6401)\n   * At X > 1, it takes X seconds to do this.\n   * At X =< 0, it is summoned immediately ‘primed’ (invisible & able to ‘trigger’)\n   * Stats - Duration - Normal: Timed life of the summoned ward.\n   * Modifying the normal duration through BlzSetAbilityRealLevelField will prevent Stasis Trap from stunning.\n   * Setting it to 0 will remove the timed life"
    },
    "Auco": {
        "name": "Unstable Concoction",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Data - Full Damage Amount\n   * Negative Value heals instead.\n   * Data - Move Speed Bonus\n   * Add to base movement speed, not current movement speed.\n   * Negative Value reduces speed.\n   * At some point when this value exceeds the current movement speed of the unit, it will become an instant cast without a projectile.\n   * This ability hides the caster with conditions similar to Storm, Earth and Fire. It casts a projectile having the model of the casting unit, then turn the caster into a hidden state with unremoveable invulnerability. The caster can be given back moveability.  As long as the projectile didn’t hit the target the caster is not killed.\n   * If the target dies, the projectile keeps moving towards the target’s dying position. If the target revives while the projectile keeps moving it still follows the target.\n   * If this ability is cast multiple times, the caster is only truly killed when all of the projectiles land. And the invulnerability is removed thereafter.\n   * After impacting, the dying location of the caster is set to the impacting point.\n   * If you change the Targets Allowed to include friendlies, you can still cast this ability on them, but the caster won’t die when you do. They’ll just go flying at the target and then stop. (EternalOne)\n   * I did some tests on 1.32.10, changing targets allowed to Allied, Friend, Ground makes the unit explode an ally and itself. Tested on ground units.  In 1.31.1.12173 does nothing when cast on self.\n   * The caster does not always die. If the target unit is invulnerable or hidden upon impacting the caster will takes the projectile places instantly.\n   * Deals normal type damage to all enemies upon impact. Deals unknown damage type upon casting that kills the caster."
    },
    "Aakb": {
        "name": "War Drums",
        "tags": [
            "Percent Damage Increase",
            "Percent Damage Decrease",
            "Flat Damage Decrease",
            "Flat Damage Increase",
            "AOE Supportive",
            "AOE Disabling"
        ],
        "notes": "I wonder if you can buff stack it?",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Item Version of Command Aura\n   * “Attack Damage Increase changes damage values.\n   * Negative values decrease damage aura.\n   * Positive values increase damage aura.\n   * Adheres to “Stats - Targets Allowed” so it’s possible to direct the aura at (for example) Enemies only.\n   * It stacks with Command Aura.\n   * Multiple War Drums fully stack. However it’s very buggy. If two units with the same ability with different Increase value comes close it will stack up indefinitely under the same buff.\n   * Always change unit’s animation to channeling animation."
    },
    "AOvd": {
        "name": "Big Bad Voodoo",
        "tags": [
            "Unique"
        ],
        "notes": "Mostly hardcoded.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Adheres to “Stats - Targets Allowed” so it’s possible to direct the aura at (for example) Enemies only.\n   * Also grants magic immunity to target units as any positive buffs (e.g. bloodlust) will be removed.\n   * If cast by a building, the building must either have a non-zero movement speed or a high collision size (needs more testing)"
    },
    "AOww": {
        "name": "Bladestorm",
        "tags": [
            "Healing",
            "Healing Over Time",
            "Damage Over Time",
            "Magic Immunity"
        ],
        "notes": "Mostly hardcoded.",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "Casting by AI: Used at random, appears to use immediately if many enemies nearby.\n   * Adheres to “Stats - Targets Allowed” so it’s possible to direct the damage at (for example) Allies only. Never affect self.\n   * Negative damage values Heal instead.\n   * Can't disable magic immunity.\n   * AI units seem to use it randomly, will use it immediately if enemies close enough\n   * The buff prevents multiple Bladestorm affecting the same target. Removing the buff does nothing to the caster and still prevent multiple Bladestorm damage.\n   * Even when there’s no buff or effect, Bladestorm still prevents you from casting other abilities for its duration.\n   * Casting this ability again refresh the duration. Losing the ability instantly stops the effect.\n   * , except against magic immune units. The caster will attack magic immune units as usual, (Strikest)\n   * Play unit’s spin animation. If the unit does not have a spin animation then no animation is displayed. During the effect cause all damage to non-magic immune units from caster’s attack (both ranged and melee units) deal no damage.\n   * Deals enhanced type damage\n   * Disables evasion and possibly other passive abilities while the unit is spinning. It can be re-enabled via triggers via the unsilenceable ability trick See:.https://www.hiveworkshop.com/threads/blzunithideability-and-blzunitdisableability-dont-work.312477/post-3325089"
    },
    "AOcl": {
        "name": "Chain Lightning / -Healing Wave",
        "tags": [
            "Healing",
            "Multi Attack Target"
        ],
        "notes": "They are pretty much the same.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Triggered by having 3 clustered enemy units in cast range (CL)  ignoring disabled units.. Cast whenever available\n   * Effectively check per each bounce valid nearby units which have not been healed yet around the unit receiving the heal. If a healing wave or lightning chain is already bouncing between units in an area and another unit entering that area, the unit is affected as well.\n   * Damage Reduction per target. defines how much damage/healing is lost per bounce\n   * Negative values increase Damage/Healing instead.\n   * The only difference between the abilities is that Chain Lightning WILL NOT bounce to allies.\n   * And vice versa for Healing Wave\n   * Data - Number of Targets Hit\n   * Any value less than 1  will bounce at least one instead.\n   * Jumps every 0.25 seconds. Travel at the same time regardless of distance.\n   * Chain Lightning jumps to the nearest visible enemy not affected yet.\n   * Healing wave prefers allies with the least hit points over distance. Which means with proper positioning some units will get healed earlier than others.\n   * Chain Lightning always prioritize shorter distance regardless of valid enemies’ health.\n   * While the lightning is bouncing, the caster can not cast the same chain-ability.\n   * Deals lightning type damage"
    },
    "AOeq": {
        "name": "Earthquake",
        "tags": [
            "TODO"
        ],
        "notes": "AOE channeled slow, the ground wobbling effect seems to be hardcoded",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Null\n   * Deals universal type damage"
    },
    "AOae": {
        "name": "Endurance Aura",
        "tags": [
            "Attackspeed Decrease",
            "Attackspeed Increase",
            "Movespeed Decrease",
            "Movespeed Increase",
            "AOE Supportive",
            "AOE Disabling"
        ],
        "notes": "I called my test version “Fat Aura”",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Attack Speed Increase” and “Movement Speed Increase”\n   * Values above 0 increases speed.\n   * Values below 0 decreases speed."
    },
    "AOfs": {
        "name": "Far Sight",
        "tags": [
            "Vision",
            "Dummy Ability"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: N/A\n   * Provides vision in an area, or no vision if area set to 0.\n   * Enemies cannot see that you cast this ability on them. (RoyGBV)\n   * Hardcoded True Sight"
    },
    "AOsf": {
        "name": "Feral Spirit",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.34.0.19632",
        "raw_text": "* Standard Summon Skill\n   * Recasting Feral Spirit with still living summons of that spell, will unsummon them.\n   * When an unit has multiple versions of this ability, it uses all of them at the same time.\n   * Feral Spirit summons will despawn if their summoner is removed from the game, even if their expiration timer is not finished\n   * Unsummons when the Ability is lost.\n   * So it is a bad idea to give this ability to a consumable item, since the item is lost and thus the ability at the last charge\n   * “Stats - Area of Effect” (Kino)\n   * The distance at which the summons are created ahead of the caster\n   * Negative numbers cause the summons to be created behind the caster"
    },
    "AOhx": {
        "name": "Hex",
        "tags": [
            "Morph"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "Casting by AI: Spammed on non-heroes, may target a lone hero.\n   * Setting the “Stats - Duration” to -1 causes it to last forever\n   * Casting “Dispel Magic” makes the unit go back to normal.\n   * The better Polymorph\n   * Always disable most non-aura passives.\n   * Depend on Target - Allowed, you can hex structures and disable its passive.\n   * If hex is casted on a unit which is already being hexed, the unit will take the newer hex regardless of duration.\n   * If the hex unit casts an ability that gives transformation such as Blade Storm, Bear Form, Metamorphosis will result in a permanent stuck.\n   * Can cast abilities if enabled.\n   * Dealing Unknown damage type at the end of the duration for allies and at the starting and expiring duration for enemies.."
    },
    "AOmi": {
        "name": "Mirror Image",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Cast if the caster is attacked a certain number of times. Used immediately if the caster is about to be hit by a spell.\n   * “Data - Damage Dealt”\n   * Below 0 it does not heal the target it hits.\n   * Attacking an illusion will not redraw aggro, you can attack one to detect whether it’s an illusion or not (Nudl).\n   * Unsummons the Illusions when the Ability is lost.\n   * This includes disabling or removing the ability through triggers. The illusions stay if the ability is simply hidden. Disabling abilities like Hex does not affect the summoned illusions.\n   * Death does not unsummon illusions.\n   * “Data - Damage taken”\n   * Below 0 it does not appear to take damage at all.\n   * “Data - Number of Images” (Kino)\n   * If set to 0, the caster will still turn invulnerable and be displaced\n   * If set to number higher than 10, it always creates 9 illusions instead and the caster will vanish with permanent pause and invulnerability after some casts. You can still see that the hero is still controllable but there is no model. You can unhide the caster but cannot remove the invulnerability. So you have to find another way to create more than 10 illusions. (1.31.1.12173)\n   * “Stats - Cast Range” (Kino)\n   * Affects the distance the caster and illusions are displaced\n   * The invulnerability window is affected by cast range/missile speed\n   * Reveals higher ground while casting if standing near a cliff\n   * Provides flying vision around the caster for the duration of the Split Time\n   * When creating a New Custom Ability that’s based off of Mirror Image, the illusions spawned by the ability will no longer level up when the caster levels up. This behavior seems to be strictly reserved for the original spell only.\n   * Form a circle and shoot the caster to a random position.\n   * The mirror images deal normal type damage"
    },
    "AOre": {
        "name": "Reincarnation",
        "tags": [
            "Unique"
        ],
        "notes": "Not much to say about it, it revives the unit like an Ankh.",
        "latest_tested_version": "1.31.1",
        "raw_text": "* Doesn't trigger when the unit is hidden (ShowUnit (u,false) )\n   * This includes units in cargo holds (Kino)\n   * Doesn't trigger when the unit dies on unpathable terrain\n   * “Data - Reincarnation Delay”\n   * Negative value is treated as 0.\n   * “Data - Mana Cost”\n   * If the unit dies with insufficient mana it will not reincarnate.\n   * “Data - Reincarnation Delay”\n   * Values below 0 causes the unit to reincarnate instantly.\n   * If this ability is removed then added again, the ability is reloaded\n   * If this ability is lost while reincarnating the unit still revives. As it goes on cooldown right after the unit dies.\n   * Multiple instances of this ability fully stack.\n   * If a unit has this ability and Ankh item with matching conditions to revive, all hero reincarnating abilities will be used first until no valid abilities remain.\n   * If a unit has more than one of this ability, the ability learned the last will go on cooldown first, leaving other abilities of the same kind unaffected.\n   * If the unit is somehow revived during the reincarnation delay, they will enter a weird state that their health bar and selection is removed until unhidden again and they can still take damage but cannot die from damage.\n   * During the delay the unit is in the state of dying. But does not run triggers using unit dies. Use Unit’s health event instead."
    },
    "AOsw": {
        "name": "Serpent Ward",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Plants near enemies every cool down.\n   * Instant targeted Summon Ability\n   * Alternative to sentry ward (no invisibility) and Healing ward (no visible AoE, just point)"
    },
    "AOsh": {
        "name": "Shockwave",
        "tags": [
            "Healing"
        ],
        "notes": "The look on his face when he thought I would throw the healing wave his way.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Triggered by having 3 clustered enemy units in cast range. (Nudl)\n        Casting by AI: AI casts Carrion Swarm way more often when compared to the shockwave. (Uyarrr).\n   * Ground deformation performed locally, causing the Z axis to differ between players.\n   * Ground deformation cannot be toggled off, use Carrion Swarm instead if you don't like the lag.\n   * Despite the settings, can never target allies or spell immune units.\n   * If you remove the buff (by trigger/code) Shockwave from units hit, they can take another damage pulse from the same shockwave. That way a shockwave deals up to 10 times the amount of damage (as set in Object Editor) per second as long units are in the shockwaves aoe.\n   * “Data - Damage”\n   * Negative values heal.\n   * “Data - Distance”\n   * Negative values cause the entire skillshot to fly backwards instead.\n   * Deals sonic type damage\n   * For an alternative without terrain deformation, seek Breath of Frost or Carrion Swarm.\n   * Deal damage in a line."
    },
    "AOls": {
        "name": "Voodoo Spirits",
        "tags": [
            "Copy"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* This is a copy of the undead Crypt Lord ultimate “Locust”"
    },
    "AOws": {
        "name": "War Stomp",
        "tags": [
            "AOE Disabling",
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Will cast if there are 2 to 3 units around the caster. May not be used if air units are present (despite being allowed to hit them to).\n   * Stuns targets around the unit for “Stats - Duration”\n   * “Stats - Damage”\n   * Negative values does Heal.\n   * Adheres to “Targets Allowed”, allowing it to stun (for example) only mechanical units.\n   * The neutral versions have additional fields allowing you to modify the terrain deformation… I don’t think they work though.\n   * Can not be dispelled.\n   * Can't affect Buildings even with changed “Targets Allowed”. The default Unit versions and their clones can.\n   * Display only terrain deformation if cast by dummy.\n   * Minimise use since terrain deformations cause memory leaks and sync instability.\n   * Deals sonic type damage"
    },
    "AOwk": {
        "name": "Wind Walk",
        "tags": [
            "Movespeed Decrease",
            "Movespeed Increase",
            "Dummy Ability"
        ],
        "notes": "Can be used to make a Dummy on click ability by modifying the TT and duration due to not interrupting orders/having any cast.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Used when the AI-controlled units are near death\n   * “Data - Backstab Damage”\n   * Setting it to 0 negates the extra damage (but still shows that (zero) damage in a floating red numeral ) (Khyrberos)\n   * Negative values do not heal the target.\n   * They do however reduce the total damage dealt.\n   * Backstab damage won't happen unless the hero *is* invisible when he attacks (so negating it through the above methods results in no bonus damage) (Khyrberos)\n   * “Data - Backstab”\n   * Ignore Evasion\n   * “Data - Movement Speed Increase”\n   * Negative values do slow the character down.\n   * “Data - Transition Time” (Khyrberos)\n   * Setting the TT to HIGHER than the duration:  results in the hero never truly becoming invisible.  HOWEVER, he still sorta fades out (kinda see it bad in the Portrait; shows through himself a bit) unless you set TT to the max (~300). (Khyrberos)\n   * Setting the TT to 0 results in: no Invisibility!  &, seemingly (for low durations) no Fading! (Khyrberos)\n   * Does not appear to conflict with current orders; You can make a Move/Attack order & then cast WW en route & he'll do it. (Khyrberos)\n   * Uses alternate order queue, doesn't interrupt unit in any way, even if he is channeling something.\n   * On the other hand, windwalk order does interrupt everything if issued via triggers.\n   * Animation Names does not seem to work. (Khyrberos)\n   * WW still cannot path over un-pathable terrain.\n   * Starting right after cast, WW allows you to path through units as if they are walkable. And issue move order will ignore them as obstacles to calculate the shortest path. (1.31.1.12173)\n   * WW sets units to use item pathing. In old versions items will block them. In new versions only WW uses this, items use no pathing.\n   * Except that might be a bug and is changed again.\n   * We truly do not know.\n   * A ranged attack fired before using windwalk will not end the windwalk or trigger a critical. (Templarfreak)\n   * A slow moving projectile attack that is performed from inside a previous windwalk won't end the current windwalk (but will apply backstab damage from the previous windwalk.) (Templarfreak)\n\n\n\n\n\n@Undead:"
    },
    "Aabs": {
        "name": "Absorb Mana",
        "tags": [
            "Unused"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* This is a generic and plain ability, only thing worthy of note is that in the game, it drains all of the target unit’s mana, since its Max Mana Absorbed values are set to 99999 in Object Editor by default. There is also a Max Life Absorbed field set to 0 by default, setting it to a positive value does the same thing as the mana component itself, but  it's on HP. (RoyGBV)\n   * Using negative values flips the effect over, instead causing the target unit to gain mana upon cast, and when the projectile arrives, you lose mana, and it also alerts your unit red as if an enemy spell was cast onto it. (RoyGBV)"
    },
    "Aam2": {
        "name": "Anti Magic Shell (Magic Resistance)",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* The current Anti-magic Shell seems to be derived from the old one, except the Shield Life is set to zero, meaning that if you altered the Shield Life on the “newer” one, it will work exactly like the old one. (RoyGBV)\n   * “Data - Shield Life”\n   * A positive number causes the shield to only be able to withstand magic until the shield runs out of health.\n   * A negative number causes it to break the first time it’s hit.\n   * It still appears to deal damage.\n   * (The following is testing by Nichilus on v1.32.10, found here (https://www.hiveworkshop.com/threads/anti-magic-shell.325038/#post-3499894)):  “I played a bit with the anti-magic shell ability to see what it can do. So far, these are mine findings:”)\n   * Magic Reduction - does absolutely nothing.\n   * Tried both values as % fraction (0.0-1.0) and full numbers (0-100).\n   * Tried casting the spell on ally, neutral, enemy. In all cases there was no reduction to both Spell damage types and Magic damage types.\n   * The only thing I did not try is various damage types when damaging via triggers\n   * Mana Loss\n   * The target of the ability loses mana to the amount set here\n   * Shield Life\n   * If 0, then the target becomes invulnerable to magic attacks and spells.\n   * But if attacking unit's attack type is \"Spells\", it can still target unit shielded by anti-magic shield and damage it\n   * If greater than 0, then the unit can be targeted by magic attacks and spells and will absorb damage up to the amount set here\n   * Summoned Unit damage\n   * If targeted unit is summoned and is allied or neutral, then it does nothing\n   * If targeted unit is summoned and is enemy, it deals damage set in in this field\n   * Now if you use the shift+click trick to allow any value to set here, there is some interesting stuff going on\n   * Negative \"Mana Loss\"\n   * replenishes mana to the target\n   * Negative \"Shield Life\"\n   * places the shield (buff) on the target\n   * the next time the target takes damage, it also takes bonus damage equal to \"Shield Life\"\n   * e.g. \"Shield Life\" is set to -100 and the shielded unit takes 20 damage - it will actually take 120 damage."
    },
    "Aabr": {
        "name": "Aura of Blight",
        "tags": [
            "Unused"
        ],
        "notes": "It was originally designed for the Obsidian Statue, then they switched it to having the Replenish/Replenish Mana, but in the end they switched it to have Essence of Blight and Spirit Touch. (EternalOne)",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Provides the same kind of healing as fountain of health, being either flat healing or percentage based healing, not related to blight.\n   * Undeads that are standing on blight will stop getting the healing effect.\n   * Data - Amount of hit points gained.\n   * Positive values will provide health per second.\n   * Negative values will drain health per second\n   * If the unit is at maximum health, health will be neither regenerated or drained (even if negative)."
    },
    "Abgs": {
        "name": "Blight Growth Large / Blight Growth Small",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Expansion Amount”\n   * Appears to be the rate at which the Blight spreads after the building finishes.\n   * Is called twice per second, so it is the expansion per 0.5 seconds (to be verified)"
    },
    "Abgm": {
        "name": "Blighted Gold Mine Ability",
        "tags": [
            ""
        ],
        "notes": "This is the ability which dictates the amount of Gold that Acolytes can harvest, *not* “Gather (Acolyte Gold)” (the ability on the Acolyte) as with the other factions. // Also, I refer to “Acolytes” throughout, but know that it works with any unit given the ability “Gather (Acolyte Gold)” (or a custom ability based on the same).",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Units with this ability are created with a special minimap icon and will keep it even if they lose the ability or morph. The icon can be accessed from game interface and is player colored unlike something like a neutral building icon.\n   * “Data - Max Number Of Miners”\n   * A negative value crashes the game.\n   * Increases/Decreases the max amount of miners needed to work at full efficiency.\n   * Pre-placing a building with even a modified “Blighted Gold Mine Ability” on the map seemed to result in a normal Haunted Gold Mine automatically replacing it upon testing.\n   * “Data - Gold per Interval”\n   * Dictates the amount of Gold that each Acolyte can harvest per interval (“Data - Interval Duration”)\n   * Negative values add gold to the Gold Mine per tick (without removing it from the player?)\n   * Zero results in a ‘dummy’ ability (no gold gained/lost)\n   * Positive values remove gold from the Gold Mine (at the cap of 99999, instantly empties & thus unsummons the Gold Mine)\n   * “Data - Interval Duration”\n   * Dictates how frequently Acolytes can gather the prescribed amount of Gold (“Data - Gold per Interval”)\n   * Caps at 300\n   * “Data - Max Number Of Miners”\n   * Determines the number of potential miners a given Haunted Gold Mine can sustain (to work at full efficiency).\n   * Caps at 8 (shift-clicking 9+ does not add more slots, visually or functionally)\n   * Negative values crash the game (tested -1)\n   * Zero results in no visible slots, and no functional slots (error message of “this mine cannot support any more acolytes” even though it’s empty).  Possibly a way to “lock out” a Gold Mine?\n   * Positive values add ‘slots’ (depicted by the glowing runic SFX ring (“Art - Effect”)) to the Haunted Gold Mine, arranged evenly & automatically based on the number of them.  One (1) is placed at the very top/north of the mine; 3 are arranged in a triangle; etc.\n   * “Data - Radius of Mining Ring”\n   * Determines the distance at which the glowing runic SFX rings (“Art - Effect”) are placed relative to the center of the Haunted Gold Mine\n   * 200 is the default & seems to just clear the Mine visually;100 puts the Acolyte inside the mine"
    },
    "Abur": {
        "name": "Burrow",
        "tags": [
            "Morph"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Morphs a crypt fiend into another unit, and applies “burrow invisibility” to it."
    },
    "Acan": {
        "name": "Cannibalize",
        "tags": [
            "Heal Over Time",
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Triggered when a unit is injured, around 50% HP or less.\n   * “Data - Hit Points Per Second”\n   * Negative values deal damage instead.\n   * “Data - Max Hit Points”\n   * Corpse Search Range\n   * Destroys the corpse when finished or canceled"
    },
    "Agyd": {
        "name": "Create Corpse",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Causes the unit to generate Corpses, these corpses can spawn anywhere and moving the unit away does not “unlink” previous corpses.\n   * Changing duration doesn’t affect anything.\n   * Setting Maximum number of units to a high value will crash the game (1.32.6)\n   * Setting Maximum number of units to a negative value also crashes the game. (1.31.1.12173)\n   * Removing this ability does not unlink previous corpses."
    },
    "Acri": {
        "name": "Cripple",
        "tags": [
            "Attackspeed Decrease",
            "Attackspeed Increase",
            "Movespeed Decrease",
            "Movespeed Increase",
            "Percent Damage Increase"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "[Percent Damage Decrease]\nCasting by AI: Confirmed to work, but specifications unknown.\n   * ”Data - Attack Speed Reduction”, ”Data - Damage Reduction” and ”Data - Movement Speed Reduction”\n   * Negative values provide positive buffs instead.\n   * Doesn't stack with itself, regardless of buff id."
    },
    "Acrs": {
        "name": "Curse",
        "tags": [
            "Unique",
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed on engaged enemy units\n   * Setting “Chance to miss” negative does not increase your chance to hit the enemy.\n   * Doesn't stack with itself, regardless of buff id."
    },
    "Aave": {
        "name": "Destroyer Form",
        "tags": [
            "Morph"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "*  Undead version of Bear Form"
    },
    "Advm": {
        "name": "Devour Magic",
        "tags": [
            "Healing",
            "Mana Regen"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Life Per Buff” “Life Per Unit” “Mana Per Buff” “Mana Per Unit”\n   * Negative values do not make the unit lose health/mana.\n   * Deals magic type damage to summons"
    },
    "Amed": {
        "name": "Drop Corpse",
        "tags": [
            ""
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Drops all corpses in cargo."
    },
    "Arpl": {
        "name": "Essence[n] of Blight",
        "tags": [
            "Healing",
            "Autocast"
        ],
        "notes": "I swear i am helping!",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Hit Points Gained”\n   * Any value below 0 causes damage instead.\n   * Does not cast it on a unit having the specified buff\n   * But if the target has the specified buff added by the caster, can target it again\n   * “Duration”\n   * Infinite duration when set to 0\n   * The caster do not turn to face the target, even when there’s only one target available\n   * Cannot get the targeted unit in spell event trigger\n   * Can be manually casted even if there’s no available targets, very useful for auto trigger based spells (set min health to infinite)\n   * Will consume the base mana cost\n   * Spend a flat amount no matter the number of targeted units (it doesn’t multiply for each)"
    },
    "Aexh": {
        "name": "Exhume Corpses",
        "tags": [
            ""
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Generates corpses inside a Meat Wagon\n   * Triggers an ability being cast event every time.\n   * Setting the Cooldown to 0 can result in a strange error which can crash the game, after some undetermined length of time. (Khyrberos, error found by Wazzz) [citation needed]\n   * Is the only known passive ability to be able to use a Cooldown (Wazzz)\n   * Disabled by Doom. During doom it does not display the cooldown and generate corpse while the actual cooldown still runs on the back ground.\n   * (nchp1903) Tests were carried in 1.31 for the points below:\n   * “Triggers an ability being cast event every time.”: Only happens when the unit has Cargo Hold (Meat Wagon), or an ability based on it, even if Cargo Capacity, Cast Range, Area of Effect are set to 0, Targets Allowed is set to “None”, and disabled by trigger.\n   * Even if the fields are set to exactly the same, Cargo Hold (Goblin Zeppelin) won’t work with Exhume Corpses. May work with other Cargo Holds.\n   * Exhume Corpses itself will also work normally if the Maximum Number of Corpses is 0. and Unit Type is null.\n   * If a Mana Cost is set, Exhume Corpses won’t be cast if there’s insufficient mana.\n   * “Is the only known passive ability to be able to use a Cooldown.”: The cooldown will have a wheel, similar to active abilities. However, after the Cooldown is over, it will then wait for Duration - Normal before casting.\n   * When there are two Exhume Corpses abilities on the same unit, they will work with each other, but their interactions with Duration - Normal and Cooldown needs further testing. Just use Cooldown and ignore Duration - Normal if you want them to be separate abilities with separate cooldowns.\n   * If you want them to cast one after another, set Duration - Normal and Cooldown of both abilities to the same number like 1 or 2. Needs testing with 0 or 0.01 or negative numbers.\n   * Cooldown with 0.01 work smoothly, just remember to remove Cargo Hold right after it goes on cooldown. (1.31.1.12173)"
    },
    "Afrz": {
        "name": "Freezing Breath",
        "tags": [
            "Suppressed"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Targets Allowed” can be changed to affect non buildings too.\n   * Does not work with melee units unless attack type is changed to “missile”"
    },
    "Afra": {
        "name": "Frost Attack",
        "tags": [
            ""
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed at every cool down\n   * Hard coded freezing attack.\n   * The only ability which applies its effect in AoE when having splash attack. (DracoL1ch)\n   * Uses default frost effect, means slow doesn't stack with other sources of frost (Frost Nova, Frost Armor). [Unless I mistaken it with Frost Breath, idk) (DracoL1ch)"
    },
    "Afrb": {
        "name": "Frost Breath",
        "tags": [
            ""
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* The frost wyrms slow. The slow strength and Buff both can be modified in gameplay constants. (Tuomas Perkinen)"
    },
    "Amel": {
        "name": "Get Corpse",
        "tags": [
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Picks up nearby Corpse into the Meat Wagon."
    },
    "Agho": {
        "name": "Ghost",
        "tags": [
            "Vision",
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Appears to turn the unit invisible.\n   * Unlike Permanent Invisibility, Ghost allows the unit to go through other units that also have Ghost.\n   * The SetUnitPathing Native can remove this behavior.\n   * Amphibious Pathing can not walk through ghosts.\n   * Can make the unit immune to Morph.\n   * Can be set so that the unit “cannot block buildings”.\n   * This allows for you to place/build buildings on that unit.\n   * A unit with Ghost will stay invisible even while attacking/casting. This is distinct from Permanent Invisibility, which has the unit become visible again while doing those things. (EternalOne)\n   * This difference is due to Duration - Normal field.\n   * If set to a positive number, the unit will take that long to re-enter invisibility after attacking/casting.\n   * If set to 0, the unit will remain invisible permanently\n   * If set to a negative number, the unit will never be invisible.\n   * This, paired with Auto-Acquire Attack Target = False, can be made into a Hold Fire button for Dummies. Inconsistent for normal units, because they will still attack back if provoked."
    },
    "Aloc": {
        "name": "Locust",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Unit can no longer be selected by players, has no health bar and is invulnerable.\n   * Locust ability, once added, can't be removed without repercussions.\n   * Commonly used to mask “dummy units” casting spells behind the scenes.\n   * Cannot be enumerated via GroupEnumUnitsInRange/Rect. As a result the locust unit is unaffected by aura based abilities, such as Devotion Aura or enemy’s True Sight.\n   * To remove Locust from a unit, first assign to a variable, then use hide and unhide. It only removes the inselectability. You have to remove invulnerability in addition. This way it will fire any triggers that uses “unit enters region”. The inselectability of this ability is inherited from the UnselectAble (Alea) below."
    },
    "Afak": {
        "name": "Orb of Annihilation",
        "tags": [
            "Flat Damage Decrease",
            "Flat Damage Increase"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Damage Bonus”\n   * Negative values causes the unit to lose damage instead.\n   * Does not seem to fire an “ability being used” event for triggering purposes when used.\n   * The bonus damage is the same type as the attack (For example, the Destroyer deals magic damage with its attack, so the damage from Orb of Annihilation is also magic type.)\n   * The ability will not be fired if the target is magic immune, dealing only the normal attacks damage.\n   * The splash damage and splash radius of Orb of Annihilation only works IF the Weapon Type of the unit itself is Missile - Splash. Target of the splash damage adheres to the unit’s Area of Effect Targets. (nchp1903)\n   * Missile Art doesn’t appear if the attack is melee."
    },
    "Apos": {
        "name": "Possession",
        "tags": [
            "Unique"
        ],
        "notes": "This is the (better?) suicide version of Unstable Concoction for Undead",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Sacrifice unit to take control of another unit.\n   * Adheres to “Targets Allowed”, so you can change what it can possess.\n   * Affect enemy structures.\n   * Can never target allied units.\n   * When channel time is complete, it kills the banshee and sends a projectile flying towards the target unit.\n   * Possession takes effect when the projectile lands.\n   * This projectile can be disjointed, wasting the ability.\n   * “Data - Damage Amplification” is for the caster.\n   * Values higher than 1 increase damage taken.\n   * Value equal to 0 or less does no damage nor heal.\n   * “Data - Target is Magic Immune”, “Target is Invulnerable” applies respective effect on the target.\n        This prevents other interventions.\n   * Cannot cast on the unit under affected by possession and unit with possession projectile flying towards them.[o][p][q]\n   * If the target dies while Possession is still channeled and decay completed, game will crash [1.26]. (DracoL1ch)\n   * Similar to Unstable Concoction, the unit is simply hidden but its UI still remains. It can be unhidden and become vulnerable but cannot move.\n   * If the unit has reincarnation and is unhidden it will not not die while still possessing enemies.\n   * The caster does not always die. If the target is hidden upon impacting the projectile disappears or the projectile is disjointed, the caster regains its selection and position while the target does not change owner.\n   * The owner is determined upon finishing cast. If the caster changes owner when the projectile is travelling, the target will always take the owner of the caster before ownership changes.\n   * If the target changes owner to the same as the caster or others, always change to the owner of the caster at the time of casting, keep the possession buff until impact and kill the caster.\n   * If the target begins changing owner while affected by some abilities such as Cyclone or Divine Shield immediately removes such effects and change owner..\n\n\nDeal Unknown damage type at both casting and impacting."
    },
    "Aatp": {
        "name": "Prioritize",
        "tags": [
            "Unique",
            "TODO"
        ],
        "notes": "Allows you to give units custom targeting priorities.",
        "latest_tested_version": "1.32.10.18067",
        "raw_text": "* Data - AOE Damage\n   * Unknown currently, speculated to make the unit consider splash damage.\n   * The targeting of the unit when this ability is toggled is entirely based on Targets Allowed."
    },
    "Arai": {
        "name": "Raise Dead",
        "tags": [
            "Summon",
            "Autocast"
        ],
        "notes": "Probably the only 2 leveled unit ability in the base game.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Hardcoded to only work on corpses.\n   * To make it not check unit cap, set the unit type for limit check to a bullshit ID other than the summoned units\n   * A non-autocast version exists as an item ability.\n   * A nearby unit with corpse storage will drop one and use it as a target\n   * It might replace the wagon instead, due to a bug\n   * Precise behaviour needs further tests"
    },
    "Arpb": {
        "name": "Replenish",
        "tags": [
            "Unused",
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* An old combination of Essence of Blight and Spirit Touch from an early prototype of the Obsidian Statue. (EternalOne)\n   * Can’t target a unit which has either full life or full mana"
    },
    "Arpm": {
        "name": "Spirit Touch",
        "tags": [
            "Mana Regen",
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Mana Points Drained”\n   * Negative values do not drain the unit's mana."
    },
    "Asac": {
        "name": "Sacrifice",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* There does not appear to be any options to change.\n   * When a unit finishes sacrificing, a “Unit Dies” event is fired for the sacrificed unit that lists the sacrificing structure as the killer, immediately followed by a “Unit finishes training” event for the resulting Shade. These can be used with triggers to, say, replace the unit that appears when different kinds of units are sacrificed. (EternalOne)"
    },
    "Aspa": {
        "name": "Spider Attack",
        "tags": [
            "TODO"
        ],
        "notes": "Causes the attack of the carrier of this ability to create a spiderling attachment, which will create after a duration a missile leading back to the attacker",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Spider capacity doesn’t have any impact (values from -100 to 100 were tried)\n   * Changing the duration changes the time between the impact of the missile and its return\n   * Changing “Missile” art will change the main attack, but not the returning missile\n   * Unfortunately, it locks the missile speed\n   * The lingering Nerubian attack on the target cannot be edited, it seems to be hardcoded[r]\n   * Will be overridden by orb effects\n   * Doesn’t work with melee attacks\n   * The missile returning has a height of 0, thus follows the terrain relief"
    },
    "Astn": {
        "name": "Stone Form",
        "tags": [
            "Morph",
            "Healing Over Time",
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Life Regeneration Rate”\n   * Setting negative makes it do damage instead."
    },
    "Auhf": {
        "name": "Unholy Frenzy",
        "tags": [
            "Attackspeed Increase",
            "Attackspeed Decrease",
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.30.2",
        "raw_text": "* Units killed by this spell does not drop bounty. (Nudl)\n   * “Data - Attack Speed Bonus.\n   * Negative values slows instead.\n   * “Data - Damage Per Second”\n   * Negative values gets converted to positive instead, dealing damage regardless.\n   * Deals death type damage"
    },
    "Auns": {
        "name": "Unsummon Building[s]",
        "tags": [
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Works kinda like Doom for buildings.\n   * Upon cast, it prevents further interactions with the building, and prevents it from being repaired.\n   * “Data - Accumulation Step” is the speed at which it gets destroyed. (RoyGBV)\n   * This can actually be interpreted as “Damage Per Second”.\n   * Damage is dealt in 1-second ticks, starting immediately after cast. (hard-coded)\n   * A value of zero causes the game to freeze. (you are dividing by zero)\n   * “Salvage Cost Ratio”autocast\n   * Percentage of the building’s Gold and Lumber Cost to be distributed evenly over “time”, 0.0 gives none, 1.0 gives back all your resources spent.\n   * This “time” is actually calculated by [(Building’s max HP) / (Data - Accumulation Step)], to be distributed over 1-second ticks.\n   * Resources to be gained per tick is set upon cast, and does not adapt, meaning if the building takes damage (or gets healed) from other sources while unsummoning, you will overall lose (or gain) some of the resources.\n   * Values below 0 get rounded up to 0.\n   * “Duration - Hero” and “Duration - Normal” does nothing, this ability is hardcoded to last forever.\n   * Deals demolition type damage"
    },
    "Aweb": {
        "name": "Web",
        "tags": [
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Brings an air unit to the ground, snaring it in the process.\n   * Unlike Ensnare, it’s autocast.\n   * There is an item version of this with no autocast, as items have issues with it.\n   * “Data - Melee attack range”\n   * Setting this allows for you to change the attack range of units. (Tal0n)\n   * Only works with melee units, reasons why are only melee units can be affected (Tal0n)"
    },
    "AUan": {
        "name": "Animate Dead",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Effectively just make copies(corpses) of 6 dead units on the ground, summoning them as Invulnerable with timed life.\n   * Works like Resurrection, except the units “revived” have the “Animate Dead” expiration timer type.\n   * Animated units have no abilities, they are removed (passive and active).\n                However you can give them items, passive abilities. If they die with items on, they will drop items at the place of death.\n   * Behave similar to units with “Animate Dead” expiration timer type added. (1.31.1.12173)\n   * Can be set to make animated units be invulnerable, or inherit the upgrades from their original owners.\n   * Picks random units around the Area of Effect, prioritizing higher-level units."
    },
    "AUcb": {
        "name": "Carrion Beetles",
        "tags": [
            "Summon",
            "Autocast"
        ],
        "notes": "I am the 5th beatle.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed at every cool down if nearby corpses are available; but only in combat.\n   * Heroic ability of “Raise Dead”.\n   * Except there is a maximum amount of them out at the same time.\n   * And they don't have a duration (0)"
    },
    "AUcs": {
        "name": "Carrion Swarm",
        "tags": [
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Triggered by having 3 clustered enemy units in cast range. (Nudl)\n   * “Data - Damage”\n   * Negative values does heal.\n   * “Data - Distance”\n   * Negative values cause the entire skillshot to fly backwards instead.\n   * “Art - Special” can’t be changed in custom versions. All carrion swarms use the field from the base spell.\n   * When using Crushing Wave as base spell instead of Carrion Swarm, you might run into issues when casting the spell from a dummy unit. Spell can go on CD but not fire if cast simultaneously by multiple dummies or if chaincast from 1 dummy.\nTLDR: Use Carrion Swarm, not Crushing Wave if you can.\n   * Deals sonic type damage"
    },
    "AUdr": {
        "name": "Dark Ritual",
        "tags": [
            "Mana Regen",
            "Mana Drain",
            "Healing"
        ],
        "notes": "Would make for an excellent Dummy ability… if it didn’t slaughter the unit targeted.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Never.\n      * “Life Converted To Mana”\n      * Negative values cause the Lich to lose mana instead.\n      * “Life Converted To Life”\n      * Negative values cause the Lich to lose health instead.\n      * Hardcoded to only work with units having the “Undead” tag under Unit Classification.\n      * Does not trigger a damage event."
    },
    "AUdd": {
        "name": "Death And Decay",
        "tags": [
            "Healing",
            "Healing Over Time",
            "Damage Over Time"
        ],
        "notes": "This is my favorite healing spell.",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "Casting by AI: Spammed at every cool down.\n      * “Max Life Drained Per Second”\n      * Negative Values cause the units to heal instead.\n      * Healing on buildings still suffers a penalty.\n      * Can change Buff and Effect for visual.\n      * Destroying trees is hardcoded (Thank god).\n      * Does strictly adhere to “Targets Allowed” allowing for damage/healing on allied/enemy units only.\n      * Can configure to make it affect air or ground or structures or allies or enemies only.\n      * Deals universal type damage"
    },
    "AUdc": {
        "name": "Death Coil",
        "tags": [
            "Healing"
        ],
        "notes": "Opposite of Holy Light damage/Heal wise.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spam on any nearby Undead units or friendly non-Undead units, prefers heroes. /Death Coil is same function as Holy Light but with opposite targets. It's been noticed while doing some Tank/Spank boss fights that if the hero is taken a LOT more damage then the heal, the healer or himself(if he has this spell) he STOPS casting it.\n      * Can’t target enemy Undead units. A good alternative missile spell is Acid Bomb, just set duration to 0.02.  (Nudl)\n      * “Amount Healed/Damaged\"\n      * Setting this to below 0 reverses the effect (Deal full damage to allies and heal enemies for half damage).\n      * Deals death type damage (also deals Unknown type damage)"
    },
    "AUdp": {
        "name": "Death Pact",
        "tags": [
            "Mana Regen",
            "Mana Drain",
            "Healing",
            "Copy"
        ],
        "notes": "My version truly was a death pact, where both parties lost their lives.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Doesn’t work.\n      * The same as “Dark Ritual” except it has another order string. Go up 3 abilities for more information.\n      * Does not trigger a damage event."
    },
    "AUfu": {
        "name": "Frost Armor",
        "tags": [
            "Flat Armor Increase",
            "Flat Armor Decrease",
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: used first on units that takes damage from enemy, and can to follow to whole group if necessary (Daffa)\n      * “Data - Armor Bonus”\n      * Negative values remove armor instead.\n      * “Data - Armor Duration”\n      * Negative values cause it to last seemingly forever.\n      * Frost Armor from lich can’t be stolen with Spell Steal. However, Frost Armor from the neutral list can."
    },
    "AUfn": {
        "name": "Frost Nova",
        "tags": [
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Area of Effect damage” and “Data - Specific Target Damage”\n      * Negative values causes the unit to heal.\n      * “Stats - Buffs”\n      * Works as intended, with the visual effect.\n      * The Slow is dependant on the gameplay constants “Spells - Frost Attack/Movement Speed Reduction”\n      * Deals cold type damage (also deals Unknown type damage to the primary target of the spell)[t]"
    },
    "AUim": {
        "name": "Impale",
        "tags": [
            "Suppressed",
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Triggered by having 3 clustered enemy units in cast range.\n      * This ability is channeling. Interrupting cast animation prevents further spikes from popping up.\n      * Technically identical to Cyclone's mechanic - turns target invulnerable, removes all attached special effects from it, effectively hide the unit. (DracoL1ch)\n      * Cannot be applied onto units under Ensnare or similar effect (Cyclone's rules). (DracoL1ch)\n      * “Data - Air Time”\n      * Negative values gets rounded back to 0.\n      * Values above 0 does not make the unit fly “slower” through the air, it only changes the invulnerability.\n      * The stun does not kick into effect until after the invulnerability runs out.\n      * The unit is stuck in a suppressed state where they cannot do anything.\n      * If a unit is stunned when paused, it keeps the invulnerability.\n      * “Data - Damage Dealt”\n      * Negative values cause healing.\n      * “Data - Wave Distance”\n      * Negative values causes the spikes to go in the opposite direction\n      * “Data - Wave Time”\n      * Negative values makes no spikes appear.\n      * Units stunned by Impale are Immune to Impale\n      * Deals force type damage\n      * All hit units are dealt Unknown type damage when the stun wears off."
    },
    "AUin": {
        "name": "Inferno",
        "tags": [
            "Summon",
            "Healing"
        ],
        "notes": "My beautiful inferno skill, summoning a frog and dealing 1000 healing. Truly Majestic!",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Damage”\n      * At negative values it does heal.\n      * “Data - Duration”\n      * At negative values it appears to last forever.\n      * Setting this field to a smaller value than Impact Delay causes the spell to not stun or deal any damage\n      * “Data - Impact Delay”\n      * Higher values does not make the meteor come down slower. It only makes it so that the spawning takes longer for the infernal.\n      * It adheres to “Targets Allowed” allowing for heals targeted for your team.\n      * “Stats - Duration”\n      * Actually dictates the stun duration.\n      * If set to 0, the target is stunned indefinitely\n      * You may set to 0.01 to imitate a null duration, but the target would still interrupt its channeling abilities\n      * Empty summon slots cause nothing to be summoned.\n      * Destroys all trees in the AoE, disregarding the damage\n      * Appears to remove “Locust” ability from summoned unit (at least in 1.31)\n      * Deals force type damage"
    },
    "AUls": {
        "name": "Locust Swarm",
        "tags": [
            "Summon",
            "Healing",
            "Healing Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Always causes the caster to enter Alternate state and removes it when ability ends. (DracoL1ch)\n      * This is important if your hero has imported models which have alternate state which might cause unwanted behavior such as Raven or Illidan. Casually there is no problem with most units.\n      * “Data - Damage Return Factor”\n      * Negative values does not damage the Crypt Lord.\n      * “Data - Damage Return Threshold”\n      * Setting this value to zero or less causes the locusts to float in place behind the unit and do nothing.\n      * This field check if the damage dealt surpassed a threshold. Since it is 0, it is always true and the locust stick around you.\n      * “Data - Max Swarm Units Per Target”\n      * At negative values (or 0) they just won't target anyone and fly around aimlessly.\n      * “Data - Number of Swarm Units”\n      * There appears to be a hard coded upper limit.\n      * “Data - Swarm Unit Type”\n      * Here’s an interesting fact. Units that do not have the “Locust” ability will be summoned normally and will function like a normal unit.\n      * If the unit does not have any attacks (i.e. Shade) they won’t attack and will just fly around.\n      * “Stats - Area of Effect”\n      * This thing dictates how far away the locust can fly from the Crypt Lord. Can really be used for some A E S T H E T I C S.\n      * Casting the spell with locusts remaining alive (requires ability cooldown set shorter than Duration - Normal field value) destroys all active locusts and spawns new ones at the position of the casting unit. This does not trigger a “unit dies” event for the locust units that are destroyed.\n      * If your summoned unit has locust but having no movement speed, casting this ability will freeze the game immediately.\n      * Units spawned from Locust and then remove their Locust still behave random order that the ability initially gives if you don’t issue another order to them. At the end, all units are issued interruptable order to return to the caster, effectively remove them if distance is met.\n      * You can summon buildings from Locust Swarm, as long as they don’t have Locust ability. And they won’t behave as expected.\n      * All mobile units that do not return to the caster after a while will instantly kill themselves. (Akaiharuki)\n      * Damage dealt from this ability is attributed to the locusts themselves, not the caster."
    },
    "AUsl": {
        "name": "Sleep",
        "tags": [
            "Suppressed"
        ],
        "notes": "Add Stun Duration, add friendly targeting…Add “Freezing breath” buff...remove “stats - duration” and voila! You have a supportive stasis spell!",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Cast while in combat, seems to prefer non heroes.\n      * “Data - Stun Duration”\n      * This is the stun duration of which the unit is Invulnerable.\n      * Adheres to “Targets Allowed”.\n      * If cast through a dummy with the Event “A unit starts the effect of an ability”, the triggering spell will be repeatedly cast if it’s cooldown is shorter than the duration of the sleep if no other order is being given.. Example: Unit casts Channel (Instant no target) -> Trigger dummy to sleep Unit, unit wakes up and if Channel is off cooldown, will begin casting again, thus triggering dummy to sleep unit again.\n      * Deals “unknown” type damage (doesn’t actually deal damage)"
    },
    "AUts": {
        "name": "Spiked Carapace",
        "tags": [
            "Flat Armor Decrease",
            "Flat Armor Increase",
            "Percent Damage Taken Decrease",
            "Percent Damage Taken Increase"
        ],
        "notes": "Damage Factor and Returned Damage Factor only works against melee enemies.",
        "latest_tested_version": "1.36",
        "raw_text": "* Defense bonus changes flat bonus armor, works as intended with both negative/positive values.\n      * Multiple abilities stack independently and fully. (DracoL1ch)\n      * Received Damage Factor changes how much damage is received (It's calculated after armor.)\n• Reducing received damage does not equal to the attacker receiving less damage upon damage return. (StormKnight)\n         * Does nothing below 0.0, just makes the damage 0 and does not heal the unit.\n         * Above 1.0 the unit takes increased damage instead(still calculated after armor).\n\n\n         * Returned Damage Factor changes how much damage is returned to the enemy\n         * Below 0.0 it does not heal the attacker, only nullifies damage.\n         *                                                   *     Above 1.0 the enemy takes more damage than you. This damage does not stack with Received Damage Factor damage.\n                                                 *     Always deals a minimum of 1 damage regardless of enemy damage dealt or returned damage factor.\n            * The reflected damage factor refers to the received damage before any reductions\n            * The damage is reflected before the unit with Spiked Carapace (called caster here) effectively takes damage from the damage event that triggered Spiked Carapace\n            * The event order is: caster is about to take damage, target is about to take damage, target takes damage, caster takes damage\n            * Deals spell attack type damage, meaning magic immune units receive no reflection damage\n            * Deals defensive type damage\n            * Changes the attacker’s original attacktype to ATTACK_TYPE_NORMAL; damagetype to DAMAGE_TYPE_DEFENSIVE and weapontype to WEAPON_TYPE_UNKNOWN also strips it off normal auto attack flags.\n            *"
    },
    "AUau": {
        "name": "Unholy Aura",
        "tags": [
            "Healing Over Time",
            "Damage Over Time",
            "Movespeed Decrease",
            "Movespeed Increase",
            "AOE Supportive",
            "AOE Disabling"
        ],
        "notes": "If you remove “Self” and replace “Friend” with “Enemy” and then make it slow/drain life, you have actually made arthas from HotS.",
        "latest_tested_version": "1.36",
        "raw_text": "* “Data - Life Regeneration Increase”\n               * Negative values cause units to take damage instead.\n               * “Data - Movement Speed increase”\n               * Negative values cause the unit to be slowed.\n               * Adheres to “Targets Allowed”.\n               * “Data - Percent Bonus”\n               * If you set this to True, you can create an aura that gives a certain percentage of Movement Speed and/or Max HP % Regen / Sec (emperor_d3st)"
    },
    "AUav": {
        "name": "Vampiric Aura",
        "tags": [
            "AOE Supportive",
            "AOE Disabling",
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Attack Damage Stolen”\n               * Negative values cause damage similar to Thorns Aura.\n               * Hardcoded to only work on melee attacks.\n               * Units with both a Melee and Ranged attack will only get the lifesteal on melee attacks (Like Gargoyles).\n\n\n@Night Elf:"
    },
    "Aadm": {
        "name": "Abolish Magic",
        "tags": [
            "Mana Regen",
            "Mana Drain",
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Summoned unit damage”\n               * Negative values do not heal.\n               * “Data - Mana Loss”\n               * Negative values cause the target to gain mana.\n               * Can be cast on trees with Sentinel (owl) to dispel it.\n               * But is not automatically cast on trees with enemy owls.\n               * Deals magic type damage to summons"
    },
    "Abrf": {
        "name": "Bear Form",
        "tags": [
            "Morph"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* While transforming, unit cannot be hexed or cycloned. (DracoL1ch)\n               * While transforming, unit CAN be silenced, which effectively cancels morph time and allows to act immediately in the new form. (DracoL1ch)\n               * If morph has channeling time, killing the caster while he is backmorphing will cause him to become permanently stunned (obviously affects heroes only). (DracoL1ch)\n               * Using triggers to add and then immediately remove the ability, one can cause an instant transformation. This does have some strange side effects however, such as when this trick is performed, a spell targeting a point loses its X & Y coordinates. Save the point in a variable before transforming.\n               * In order to make the transformation happen, one must change “Normal Form Unit” to the desired new form, and have “Alternate Form Unit” be the original form in which you start as.\nCredit goes to Lordshinjo for posting about this initially on the Hive forums (link to post)"
    },
    "Acor": {
        "name": "Corrosive Breath",
        "tags": [
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Damage Per Second”\n                  * Negative values do not appear to cause healing.\n                  * It appears it’s hard coded to only work against structures."
    },
    "Acyc": {
        "name": "Cyclone",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Turns target invulnerable, removes all attached special effects from it, effectively hide the unit. (DracoL1ch)\n                  * It also hides the unit if you use any other model in the Cyclone and Cyclone (extra) other than the default Cyclone Model (RoyGBV)\n                  * By default it uses the “Sprite First Ref” attachment point to decide where on the parent model the model will be attached.\n                  * If gameplay constant \"Cyclone hides unit\" toggled, unit will be hidden completely instead of using Tornado fx. (DracoL1ch)\n                  * Cannot be applied onto units under Ensnare, Entangle or similar effect. (DracoL1ch)\n                  * Cannot be applied onto flying units. (DracoL1ch)\n                  * Cycloned Units perform the stun order.\n                  * Therefore you can still issue order like move or smart, but since order is only received when the target is not disabled, no triggers using move/smart order will run.\n                  * Cannot be cast on building, to which it displays the error message “Cannot cyclone this unit”.\n                  * If you want to see the effect on a building, change model file of a normal unit, it will spin the building model file normally.\n                  * The unit is continuously applied invulnerability. This invulnerability cannot be removed.\n                  * If the target unit has Transformation ability like Metamorphosis, Avatar,... their remaining duration will halt during cyclone."
    },
    "Adtn": {
        "name": "Detonate",
        "tags": [
            "Mana Drain",
            "Mana Regen"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Damage to Summoned Units”\n                  * Negative values do not heal.\n                  * “Data - Mana Loss”\n                  * Negative values cause mana gain.\n                  * Kills the unit, very good.\n                  * Deals magic type damage to summons"
    },
    "Adec": {
        "name": "Dismount",
        "tags": [
            "Morph"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Null"
    },
    "Aeat": {
        "name": "Eat Tree",
        "tags": [
            "Healing Over Time",
            "Damage Over Time"
        ],
        "notes": "Infamous dota technique passed down through generations.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Spell stops working if you do the following: eat tree > cancel order and move close to target tree > eat tree (same tree). It’s now impossible to eat that tree until you move roughly 90 units away. It might seem like a bug, but it’s probably a melee mechanic so that you can block Ancients from eating trees. (Nudl)\n                  * “Data - Hit Points Gained”\n                  * Negative values cause damage instead.\n                  * “Data - Rip Delay”\n                  * Negative values treated as 0.\n                  * The amount of time it takes before the tree is removed from the map.\n                  * Setting targets to include units causes the caster to use the ability when right-clicking valid targets (Kino, any version before 1.32)\n                  * Does not kill target unit\n                  * Good base for a dummy ‘interact/conversation’ ability\n                  * Can be configured to target units or items (1.36.1.20719):\n                  * The unit or item won’t be destroyed\n                  * The caster will not be healed"
    },
    "Aegr": {
        "name": "Elune’s Grace",
        "tags": [
            "Percent Damage Decrease",
            "Percent Damage Increase",
            "Percent Damage Taken Increase",
            "Percent Damage Taken Decrease"
        ],
        "notes": "Null",
        "latest_tested_version": "1.36",
        "raw_text": "* \"Art - Caster\" is displayed when this elune's grace affects taken damage\n                  * “Data - Chance to Deflect”\n                  * Requires the Gameplay constant DefendDeflection = 1\n                  * 0 to 100, with 100 deflecting every affected Attack\n                  * Deflects any ranged attack that is (Pierce, Magic or Spell), but not missiles from Abilities (Barrage)\n                  * Deflected attacks apply Buff placers onto the source of the attack\n                  * The bounce/ deal aoe /line damage from the Attacker\n                  * Seemingly doesn’t work on the first time the unit is attacked, even with 100.0 chance. (KitsuneTailsPrower)\n                  * Plays Art - Caster effect when deflecting. (KitsuneTailsPrower)\n\n\n                  * “Data - Deflect Damage Taken (Piercing)”\n                  * Multiplies the taken damage when an (Piercing) Attack is deflected\n                  * Stacks with “Data - Damage Taken”, 0.8 and 0.9 = 0.72\n                  * Won’t deflect with a Value equal to 1.0\n                  * Values below 0 cause no damage.\n                  * Values above 1 cause more damage.\n                  * “Data - Deflect Damage Taken (Spells)”\n                  * “Data - Deflect Damage Taken (Piercing)” against Magic & Spell Attacks\n                  * Does not affect Spellcasts\n                  * “Data - Damage Dealt”\n                  * Values below 0 cause no damage.\n                  * Values above 1 cause more damage.\n                  * Affects own AutoAttack, regardless of attacktype.\n                  * Stacks with other Elune Graces. 20 x 5 x 10 = 1000\n                  * Affects the current attack when added by triggers in an unit is attacked event.\n                  * Does not show up on the UI, unless the unit also has Trueshot Aura buff active on them (emperor_d3st)\n                  * “Data - Damage Taken”\n                  * Values below 0 cause no damage to be taken.\n                  * Only adds defense versus Piercing. (Prometheus3375)\n                  * In case of multiple Elune’s Grace abilities the lowest value seems to apply (emperor_d3st)\n                  * “Data - Magic Damage Reduction”\n                  * Values below 0 cause the unit to be healed instead when it would receive Spell dmg. (emperor_d3st)\n                  * Only adds defense versus Spells and Magic Attacks (Priest/Shaman...).\n                  * In case of multiple Elune’s Grace abilities the lowest value seems to apply (emperor_d3st)\n                  * “Data - Attack Speed Factor” & “Data - Movement Speed Factor” appear to both be deprecated (no change in movement speed/attack rate with either positive or negative values) (Khyrberos, 1.36)"
    },
    "Aent": {
        "name": "Entangle Gold Mine",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Null"
    },
    "Aegm": {
        "name": "Entangled Gold Mine Ability",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Units with this ability are created with a special minimap icon and will keep it even if they lose the ability or morph. The icon can be accessed from game interface and is player colored unlike something like a neutral building icon.\n                  * If a unit with a gold gathering ability based on acolyte attempts to gather from an entangled gold mine it will crash the game"
    },
    "Aetl": {
        "name": "Ethereal",
        "tags": [
            "Unique"
        ],
        "notes": "Has the epic ToolTipMissing Icon",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Ability version of Ethereal unit classification.\n                  * Add it to any unit will turn it into ethereal as long as it has the ability. Is not disabled by Doom.\n                  * The attack button is disabled but can re-enabled, effectively allows the etheral unit attack other units even being an ethereal while still prevent units without magic attack from attacking.\n                  * Dying does not lose the effect, and the attack button is only disabled once.\n                  * This is a more handy ethereal ability of Banish, as it does not require a dummy to cast and does not interrupt unit’s animation.\n                  * Disallow to cast several physical-only abilities and Channel which has \"Physical\" option's flag enabled. (DracoL1ch)\n                  * Physical-only example: Ensnare, Suicide.\n                  * Doesn't disjoint any projectiles, physical ones will not deal it's effect on impact. (DracoL1ch)"
    },
    "Afae": {
        "name": "Faerie Fire",
        "tags": [
            "Flat Armor Decrease",
            "Flat Armor Increase",
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed randomly on enemy units.\n                  * “Data - Defense Reduction”\n                  * Acts as expected both with both positive and negative values.\n                  * Doesn't stack with itself, latest placed overrides the buff, but effect may become incorrect (takes bigger armor bonus always).\n                  * Shares unit's vision with the caster's owner.\n                  * Render unit visible when he is invisible.\n                  * (nchp1903) Faerie Fire Is a good base for triggered autocast abilities, because it will automatically cast on viable targets in range, even if Duration is set to 0.01 and Defense Reduction to 0.\n                  * Another good contender is Curse. (KitsuneTailsPrower)\n                  * However, Both Curse and Faerie Fire will only auto cast on targets that can attack."
    },
    "Assk": {
        "name": "Hardened Skin",
        "tags": [
            "Flat Damage Taken Decrease",
            "Flat Damage Taken Increase"
        ],
        "notes": "( ͡° ͜ʖ ͡°)",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* When multiple abilities based on this are obtained, they're being evaluated in reverse order of obtaining (latest triggers first). As soon as any of those pass through the “Chance to Reduce Damage”, all other blocks are completely ignored.\n                  * “Data - Ignored damage”\n                  * Negative values causes the unit to take this amount of extra damage every hit.\n                  * Subtract/add damage taken before any armor reduction is calculated.\n                  * “Data - Minimum damage”\n                  * Negative values are treated as 0.\n                  * A value of 0 allows for the unit to not take any damage if the ignored damage is reduced to equal or below 0.\n                  * Damage instances smaller than the minimum damage may get bumped up to the minimum. Needs more testing.\n                  * Doesn’t happen for normal damage\n                  * “Stats - Cooldown” and “Stats - Mana Cost” fields nonfunctional.\n                  * Plays Art - Caster effect when blocking damage (Somen00b)"
    },
    "Alit": {
        "name": "Lightning Attack",
        "tags": [
            "TODO"
        ],
        "notes": "Aesthetics",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Visual effect overrides most of other on-attack effects, like Vampiric. (DracoL1ch)\n                  * Visual effect becomes broken if Critical strike or Bash happens on the same attack. (DracoL1ch)\n                  * Lightning Attack can change projectile fields and add a beam/lightning type to the attack of a unit while in-game even. (Wonder Wiz)\n                  * “Data - Graphic duration” sets the time the lightning appears at the damage point (FlameofChange)\n                  * “Data - Graphic delay” looks like it doesn’t have any effect, even with high values (or I missed something) (FlameofChange)\n                  * “Art - Missile arc” As the ability replaces the attack with an instant one, doesn’t have any effect\n                  * “Art - Missile speed” Defines the equivalent damage delay like if it launched a projectile (FlameofChange)\n                  * If you feel like the damage has a too high delay compared to the VFX, increase this value (FlameofChange)\n                  * Uses the unit projectile launch X/Y/Z as intended\n                  * TODO : check if it respects level, requirements, how it stacks\n                  * Doesn’t show in the UI"
    },
    "Amfl": {
        "name": "Mana Flare",
        "tags": [
            "Mana Drain"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Damage Cooldown”\n                  * This is actually the armor modifier, adds armor or removes it.\n                  * “Data - Damage per Mana point”\n                  * Negative values do not cause mana regeneration.\n                  * Deals lightning type damage"
    },
    "Amgl": {
        "name": "Moon Glaive",
        "tags": [
            "Dummy Ability"
        ],
        "notes": "Doesn't do anything, it’s all handled by the Upgrade",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "*"
    },
    "Aco2": {
        "name": "Mount Hippogryph",
        "tags": [
            "Morph"
        ],
        "notes": "Null",
        "latest_tested_version": "1.32.7",
        "raw_text": "*  Removes buffs and effects from the unit, same as dismount."
    },
    "Apsh": {
        "name": "Phase Shift",
        "tags": [
            "TODO",
            "Autocast"
        ],
        "notes": "I think the Data fields are deprecated",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Works just fine on Heroes (Khyrberos, 1.26.0.6401)\n                  * Phase Shift works by ‘hiding’ the Shifting unit…  But they are technically just invisible, so this ability can be ‘countered’ with detection (Khyrberos, 1.26.0.6401)\n                  * Seems like the Data fields (“Data - Attack Speed Reduction (%)” & “Data - Movement Speed Reduction (%)”) are indeed deprecated (no apparent effect) (Khyrberos, 1.26.0.6401)\n                  * “Art-Special” plays at the beginning (when the ability is initially activated), while the “Art-Special” of the Buff assigned to it plays at the *end* (when the unit ‘phases back in’) (Khyrberos, 1.26.0.6401)\n                  * Stats - Duration 0  does not cause the unity to shift infinitely."
    },
    "Aco3": {
        "name": "Pick Up Archer",
        "tags": [
            "Morph"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Null"
    },
    "Arej": {
        "name": "Rejuvenation",
        "tags": [
            "Healing Over Time",
            "Damage Over Time",
            "Healing",
            "Mana Drain",
            "Mana Regen"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Used when caster or any nearby allies take significant/any/moderate damage.\n                  * “Data Hit/Mana Points Gained”\n                  * Negative values causes losses in said value.\n                  * Setting both hit/mana value to 0 causes the ability to not be castable on anything.\n                  * AI will not heal a unit below a certain percentage of the hit point gained (still need more testing for exact values)\n                  * Stats - Duration 0 does not cause it to last indefinitely."
    },
    "Ambt": {
        "name": "Replenish Mana and Life",
        "tags": [
            "Healing",
            "Mana Regen",
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data Hit/Mana Points Gained”\n                  * 0 or negative values causes it to stop working entirely.\n                  * Replenish mana special effect is hardcoded into the spell. (Nudl)\n                  * Can be used to make a mana based copy of Priest’s Healing ability by setting Mana Gained to -1, Water Height -1 and triggering so that target is given mana.  (Nudl)"
    },
    "Arsk": {
        "name": "Resistant Skin",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1",
        "raw_text": "* Practically a hardcoded Tenacity.\n                  * Reduce durations of spells to the “hero” duration.\n                  * Also makes it so the unit cannot be targeted by spells that cannot target heroes. Does not make the unit targetable by spells that can ONLY target heroes.  (SonGuhun)"
    },
    "Aroa": {
        "name": "Roar",
        "tags": [
            "Percent Damage Increase",
            "Percent Damage Decrease",
            "Flat Armor Increase",
            "Flat Armor Decrease",
            "Damage Over Time",
            "Healing Over Time",
            "Healing"
        ],
        "notes": "Rawr XD",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Used when engaging enemies.\n                  * “Data - Damage/Defense Increase”\n                  * Negative values causes loss in damage/armor\n                  * “Data - Life/mana Regen”\n                  * Negative values causes loss in life/mana.\n                  * Adheres to Targets Allowed.\n                  * The field Max Units actually means this ability is only castable if the number of valid targets in Targets Allowed around area of effect is higher than that. Which means if you want it to be castable on empty ground, always set to 0. Otherwise it will never cast.\n                  * AI Usage: Refuses to cast it if its damage increase (%) is 0. (Uyarrr)"
    },
    "Aesn": {
        "name": "Sentinel",
        "tags": [
            "Vision"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31",
        "raw_text": "* “Data - In Flight Sight Radius”\n                  * This determines the sight range of the owl while it is flying to the tree.\n                  * Unlike unit sight ranges, this can exceed 1800.\n                  * “Data - Number of Owls”\n                  * Negative values cause it to count up by -1 every time it’s cast and display on the ability button.\n                  * 0 causes unlimited uses.\n                  * Costs 1 use per cast if set otherwise. Can perish the ability.\n                  * Cannot be cast on trees that are already occupied by a Sentinel owl or that currently have a Sentinel owl flying to them.\n                  * The Sentinel owl on a tree can be dispelled by various means.\n                  * Area of effect dispels like Detonation, Disenchant, Item Dispel (Wand of Negation), …\n                  * Directly targeted dispels like Purge, Abolish Magic\n                  * Bug: Those dispel abilities can already be cast on the tree when the owl is still in transit, the ability will be successfully cast but without an effective dispel of the owl, the owl in transit is unaffected.\n                  * The owl is also removed when the tree takes damage or is killed.\n                  * Cannot be cast on a tree that is already occupied by an owl or that has an owl in transit.\n                  * Owls will still mount and show on hidden destructibles.\n                  * Bug: When the owl would mount the destructible but the destructible is dead, the owl will vanish but the tree will still be marked as occupied by an owl (unlike when the tree is killed while the owl is mounted to it), i.e., when resurrecting the destructible, Sentinel cannot be cast on it again and the tree can be targeted by directly targeted dispel abilities without effectively removing an owl or the occupation buff.\n                  * “Data - buff” Doesn’t do anything\n                  * “Data - Effect doesn’t do anything. The owl still appears even if you change the Missile or remove the Effect.\n                  * Strongly adhere to Target Allowed:\n                  * If set to Tree and Vulnerable only, cannot target invulnerable trees.\n                  * If set to Tree and other choices, can be cast to tree only.\n                  * Inherit targetability of Repair: can be targeted on bridge, building with both Structure and Bridge ticked.\n                  * This adherence is similar to Channel ability, except that it cannot target ground. Which means you can target tree and a unit simultaneously, similar to Channel’s target point and unit.\n                  * Can target items.\n                  * One of a few abilities that can target trees without requiring triggers. To remove the owl, set the Number of Owls to 0.\n\n\n\n\n-Shadow Meld:[u][v]\n                  * The user become invisible after a duration if inactive\n                  * Instantly breaks the invisibility when moving, attacking or using an ability\n                  * The “Akama” version makes the unit stop auto acquiring enemies.²²\n                  * “Data - Permanent Cloak”\n                  * False (default) : works only at night (like Night Elves), disabling the ability at night even without other requirements²\n                  * True : works at any time\n                  * Doesn’t make the unit permanently invisible\n                  * So it is not possible to make it work at day only"
    },
    "Aspo": {
        "name": "Slow Poison",
        "tags": [
            "Attackspeed Increase",
            "Attackspeed Decrease",
            "Movespeed Increase",
            "Movespeed Decrease",
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Attack/movement speed factor”\n                  * Negative values causes unit to speed up instead.\n                  * “Data - Damage per second”\n                  * Negative values gets rounded back to positive, causing damage.\n                  * “Data - Stacking Type”\n                  * See “Envenomed Spears” for more information.\n                  * Deals slow poison type damage\n                  * “Data - Area of Effect” Doesn’t work\n                  * Only apply poison if the attack type is either normal or missile, doesn’t work with splash"
    },
    "Amim": {
        "name": "Spell Immunity",
        "tags": [
            "Magic Immunity"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1",
        "raw_text": "* Magic Immunity can be bypassed by converting an ability to an ultimate (assuming the Gameplay - Magic Immunes Resist Ultimates constant is set to False. This can be done by converting an ability to a Hero ability and setting the field Stats - Required Level to 6. After setting the field, the ability can once again be made a non-hero ability. (SonGuhun)\n                  * “Data - Magic Damage Factor”\n                  * Flat dmg block vs AttackTypeMagic (requires Game constant MagicImmunesResistDamage=0)\n                  * Anything above 0 reduces taken dmg.\n                  * Anything below 0 increases taken dmg. Stacks 100Atk - (30Block + 60Block) = 10\n                  * Changes dmg before armor does"
    },
    "Avng": {
        "name": "Spirit of Vengeance",
        "tags": [
            "Summon",
            "Copy",
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Copy of “Carrion Beetles” except non heroic.  A summon which requires a nearby corpse. //Copy of Carrion Beetles? So the summons die if the summoner perishes?"
    },
    "Arav": {
        "name": "Storm Crow Form",
        "tags": [
            "Morph",
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Adding this ability to a unit will make it possible to change the elevation of the unit even if the unit cannot “fly”.\n                  * The unit does not need to have the ability, it only needs to have had it. AKA you can add/remove it using triggers, and things will still work.\n                  * If the alternate form is a ground unit, collision will behave like air unit (pushes other ground morphed units) but with no movement stacking"
    },
    "Atau": {
        "name": "Taunt",
        "tags": [
            "TODO"
        ],
        "notes": "The one thing i’m good at doing against other players.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Does not lock them to attacking the unit, so a player with good micro can easily just ignore it.\n                  * Upon casting, it issues a single attack order to 10 randomly chosen closest enemy units in an AOE.\n                  * “Data - Prefer Hostiles”, which houses the number of units to be chosen, is hard-coded to be at 10.\n                  * Cannot input a number greater than 1.\n                  * “Data - Cast Range” and “Data - Duration” fields do nothing. (RoyGBV)\n                  * Units require movement speed above 0 for this ability to function.  (Nudl)"
    },
    "Ault": {
        "name": "Ultravision",
        "tags": [
            "Vision"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Hard-coded to set the units “Night vision” to the unit’s “Day vision”."
    },
    "Aimp": {
        "name": "Vorpal Blades",
        "tags": [
            "Dummy Ability"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Does nothing, this is handled by the upgrade itself."
    },
    "Agra": {
        "name": "War Club",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Allows for changing the allowed attacks for a unit, but only by consuming a tree.\n                  * Changing targets to enable unit targeting causes the game to crash on cast (Kino, 1.30++)\n                  * Can be configured to target units and items (1.36.1.20719) but won’t work properly there:\n                  * The unit or item is not destroyed\n                  * The attack indexes won’t be disabled/enabled\n                  * The animation tag will still be added to the caster\n                  * There won’t be a replacing texture, so a potential replaceable texture in the caster like the mountain giant has with the club will be black\n                  * The ability counts the number of attacks based on how many units received the damage. (tested on patch 1.30.4)\n                  * Test: The ability allowed 15 attacks. The altered attack had a splash effect (tested on missile splash and artillery).\n                  * The unit attacked a group of units (5 units). The ability’s effect ended after only 3 attacks. It matters not if the damaged units are friendly or hostile.\n                  * Test against Hardened Skin (block 300 dmg and no minimum dmg): After 15 attacks, the ability effects end.\n                  * Test against 100% evasion: After 15 attacks, the ability effects remain."
    },
    "AEbl": {
        "name": "Blink",
        "tags": [
            "Unit Move",
            "Visible Target Only"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Teleport short distance, Also known as “Flash” by ignorant league players\n                  * Using Blink will disjoint most homing missiles currently homing onto the blinking unit.\n                  * Can’t be used into unexplored areas, there’s a fairly complicated set of rules for this. This behavior is hard-coded for Warden in the campaign.\n                  * Duration - Normal works like Channel’s “Follow Through Time”\n                  * Cannot be used if the casting unit’s move ability is disabled. An error message saying “Caster’s movement has been disabled” will be shown."
    },
    "AEer": {
        "name": "Entangling Roots",
        "tags": [
            "Damage Per Second",
            "Suppress"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1",
        "raw_text": "* Can’t use change air height of target unit, avoid using against air units or “air” type spells. (Nudl)\n                  * Makes the target unable to attack, move and use abilities[w][x]\n                  * Can be used as a sort of pause\n                  * Can still rotate\n                  * “Data - Damage Per Second”\n                  * Negative values just causes the unit to take more damage than it’s supposed to.\n                  * Deals plant type damage"
    },
    "AEev": {
        "name": "Evasion",
        "tags": [
            "Passive"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* When a unit has multiple Evasion-based abilities, only the one with the highest chance takes effect (used for calculations).\n                  * Plays \"Caster art\" effect whenever evasion happens. (DracoL1ch)\n                  * “Data - Chance to Evade”\n                  * Negative values does nothing.\n                  * Values above 1 counts as 1.\n                  * Use pseudo random distribution."
    },
    "AEfk": {
        "name": "Fan of Knives",
        "tags": [
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spams randomly if 2 to 3 enemies around, occasionally also uses on single targets if attacked.\n                  * “Data - Damage Per Target”\n                  * Negative values causes healing.\n                  * Does not damage ethereal units\n                  * Does not use cast point, the effect happens immediately. The entire animation can be freely canceled.\n                  * Deals enhanced type damage"
    },
    "AEfn": {
        "name": "Force of Nature",
        "tags": [
            "Summon"
        ],
        "notes": "Forces innocent trees to fight for you, screw the trees.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Don’t set the area of effect to 999999"
    },
    "AEim": {
        "name": "Immolation",
        "tags": [
            "Damage Over Time",
            "Healing Over Time",
            "Healing",
            "Mana Drain",
            "Mana Regen"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Activates only if Immolation deals damage and there are viable targets present; it may favor use after losing hitpoints.\n                  * “Data - Damage per Interval”\n                  * Negative values cause negative damage.\n                  * “Data - Mana drained per second”\n                  * Negative values cause mana regen instead.\n                  * “Stats - Duration”\n                  * Dictates the interval between the triggering ticks.\n                  * Adheres to “Targets Allowed”.\n                  * Deals fire type damage"
    },
    "AEmb": {
        "name": "Mana Burn",
        "tags": [
            "Healing",
            "Mana Drain",
            "Mana Regen"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed on anything with mana.\n                  * “Data - Max Mana Drained”\n                  * Negative values cause the unit to both heal and get mana back.\n                  * Deals magic type damage"
    },
    "AEme": {
        "name": "Metamorphosis",
        "tags": [
            "Morph",
            "Flat Health Decrease",
            "Flat Health Increase"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Alternate Form Hit Point Bonus”\n                  * See “Avatar” (not the movie, the ability).\n                  * Stats - Duration - Normal\n                  * This actually dictates how long it takes for the unit to transform into the other unit (and possibly back)."
    },
    "AEst": {
        "name": "Scout",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* It’s a flat out summon\n                  * Last according to duration."
    },
    "AHfa": {
        "name": "Searing Arrows",
        "tags": [
            "Flat Damage Increase",
            "Flat Damage Decrease"
        ],
        "notes": "Boring really",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Uses it whenever the CD is off.\n                  * “Data - Damage bonus”\n                  * Negative values causes it to subtract from the total damage dealt.\n                  * It is possible to allow “self” as a target, causing the unit to attack itself.\n                  * Using it manually will not draw aggro, use search engine for “orb walking” for more info.\n                  * If the range of this ability is higher than the caster’s attack range, you can still manually cast it on a target outside of the normal attack range… but the attack will always register as a miss. (EternalOne)"
    },
    "AEsh": {
        "name": "Shadow Strike",
        "tags": [
            "Healing",
            "Healing Over Time",
            "Damage Over Time",
            "Attackspeed Increase",
            "Attackspeed Decrease",
            "Movespeed Increase",
            "Movespeed Decrease"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed at every cool down unless victim is already afflicted with Shadow Strike (may prefer target that has less than 100% of his health. Never studied to determine the threshold, but a user has never seen it used on a 100% target)\n                  * “Data - Attack/Movement Speed factor”\n                  * Negative values cause it to increase instead.\n                  * “Data - Decaying damage” and “Data - Initial Damage”\n                  * Negative values cause healing.\n                  * “Data - Decaying Power”\n                  *  has to have the same sign as the slow.\n                  * +Slow and +Decaying Power -> slowed also regain over time.\n                  * -Speed and -Decaying Power -> speed up speedUp increases over time. (I encountered a bug where the units speed dropped to its minimum after the spell ended)\n                  * “Data - Duration”\n                  * A 0 second duration makes the duration infinite.\n                  * Tick Rate is determined by the Casting Time field.\n                  * Setting this to 0 will cause an infinite loop, crashing the game.\n                  * Adheres to Targets Allowed.\n                  * Initial damage is of type slow poison, periodic damage is of type shadow strike"
    },
    "AEsf": {
        "name": "Starfall",
        "tags": [
            "Healing",
            "Healing Over Time",
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Used when there are 2+ enemy units near the caster.\n                  * “Data - Damage Dealt”\n                  * Negative values cause healing.\n                  * Deals universal type damage\n                  * Needs vision to hit units (KitsuneTailsPrower)"
    },
    "AEah": {
        "name": "Thorns Aura",
        "tags": [
            "AOE Supportive"
        ],
        "notes": "Null",
        "latest_tested_version": "1.36",
        "raw_text": "* “Data - Damage is Percent Received”\n                  * Possible to choose between flat and % damage. (emperor_d3st)\n                  * Flat damage set to 0.000 still seems to do 1 damage to attackers, at least when set with the Field functions. (emperor_d3st)\n                  * Reflect damage is considered either Spell or Magic damage, and is influenced by magic damage reduction abilities. If the enemy has negative magic damage taken, Reflect will heal them. (emperor_d3st)\n                  * “Data - Damage Dealt to Attackers”\n                  * Negative values do not cause healing.\n                  * The reflected damage factor refers to the received damage before any reductions\n                  * The damage is reflected before the unit with Thorns Aura buff (called caster here) effectively takes damage from the damage that triggered Thorns Aura\n                  * The event order is: caster is about to take damage, target is about to take damage, target takes damage, caster takes damage\n                  * Deals spell attack type damage, meaning magic immune units receive no reflection damage\n                  * Deals plant type damage"
    },
    "AEtq": {
        "name": "Tranquility",
        "tags": [
            "Healing",
            "Healing Over Time",
            "Damage Over Time",
            "Stackable",
            "Buff Stackable"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Life Healed”\n                  * Negative values cause damage instead.\n                  * If another buff or a custom buff is used it stacks with itself. (Khyrberos)\n                  * If 2 tranquilities with different healing are cast at once, it’s gonna apply the effects of the first tranquility being cast.\n                  * If the first tranquility is canceled but the second if still going it’s still gonna apply the effects of the first Tranquility instead of switching to the second Tranquility."
    },
    "AEar": {
        "name": "Trueshot Aura",
        "tags": [
            "AOE Supportive",
            "AOE Disabling",
            "Percent Damage Increase",
            "Percent Damage Decrease"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Damage Bonus”\n                  * Negative values cause all ranged units to lose damage instead.\n                  * Adheres to Targets Allowed"
    },
    "AEsv": {
        "name": "Vengeance",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* It summons shit that summons more shit.\n\n\n@Neutral Hostile:"
    },
    "ACmo": {
        "name": "Monsoon",
        "tags": [
            "Healing",
            "Healing Over Time",
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Acts like Starfall.\n                  * Instead of being channeled on the caster it’s instead channeled where the ability is targeted.\n                  * Deals universal type damageAs of 1.31+ the monsoon buff is no longer hardcoded."
    },
    "ACbf": {
        "name": "Breath of Frost",
        "tags": [
            "Copy",
            "Damage Over Time",
            "Healing Over Time??"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Is similar to Pandaren Brewmaster’s “Breath of Fire”, except it has a field for/applies a  Damage Over Time! (Khyrberos)\n                  * Comes with its own buff, icon, & SFX. (Khyrberos)\n                  * Unlike Breath of Fire, this does not need the Drunken Haze buff to deal DPS to enemies.\n                  * Initial damage is of type sonic, periodic damage is of type fire"
    },
    "AHca": {
        "name": "Cold Arrows",
        "tags": [
            "Copy",
            "Movespeed Increase",
            "Movespeed Decrease",
            "Attackspeed Increase",
            "Attackspeed Decrease"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Has priority over Searing Arrows in the case the hero/unit has both spells.\n                  * Very similar to Venomous Spears.\n                  * Flat damage boost instead of DOT\n                  * It is possible to allow “self” as a target, causing the unit to attack itself.\n                  * Periodic damage is of type cold"
    },
    "ACac": {
        "name": "Command Aura",
        "tags": [
            "AOE Supportive",
            "AOE Disabling",
            "Percent Damage Increase",
            "Percent Damage Decrease"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* It’s exactly like War Drums, with its own icon and buff.\n                  * It stacks with War Drums."
    },
    "Afod": {
        "name": "Finger of Death",
        "tags": [
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Tendency to target furthest away, but still within range. Used whenever off cooldown.\n                  * “Data - Damage”\n                  * Negative values cause healing.\n                  * Killing things with finger of death causes them to explode.\n                  * Deals magic type damage"
    },
    "ACfb": {
        "name": "Firebolt / -Frost Bolt",
        "tags": [
            "Copy"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed at every cool down, has preference to target heroes.\n                  * It’s actually Storm Bolt.\n                  * It has a separate order string from normal Thunderbolt. You can give a unit both Firebolt and Storm Bolt, and they won’t mess each other up. (EternalOne)\n                  * Deals fire type damage"
    },
    "Afzy": {
        "name": "Frenzy",
        "tags": [
            "Copy",
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* It’s a self cast version of Bloodlust.\n                  * In triggers it will trigger as a “Spell without a target” event.\n                  * Stacks with Bloodlust (?) (Yes, Confirmed) (Rairus)\n                  * Does not apply size changes (“Scaling Value” field deprecated. Very sad.) (Khyrberos)\n                  * The buff cannot be stolen with Spell Steal."
    },
    "ACtb": {
        "name": "Hurl Boulder",
        "tags": [
            "Copy"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed at every cool down, has preference to target heroes.\n                  * It’s actually Storm Bolt.\n                  * It has a separate order string from normal Storm Bolt.\n                  * Deals sonic type damage"
    },
    "Asds": {
        "name": "Kaboom!",
        "tags": [
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Explodes on Death”\n                  * If set to true, then the caster explodes on death as if it was killed by finger of death.\n                  * “Data - Damage Amount”\n                  * Negative values does not cause healing\n                  * Deals normal type damage"
    },
    "ACnr": {
        "name": "Life Regeneration Aura",
        "tags": [
            "Healing",
            "Healing Over Time",
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.36",
        "raw_text": "* Unlike most auras this does not put a buff on the buff UI (emperor_d3st)\n                  * “Data - Percentage”\n                  * When set to True it will heal a percentage of the unit’s max HP instead. A value of 0.01 is 1% healed per second. (emperor_d3st)\n                  * “Data - Amount of Hit Points”\n                  * Negative values cause damage.\n                  * If the unit has full health it won’t start taking damage until it’s decreased."
    },
    "SCva": {
        "name": "Life Steal",
        "tags": [
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.36",
        "raw_text": "* “Data - Life Stolen Per Attack”\n                  * Negative values cause damage instead.\n                  * Heals the X% of the final damage dealt.\n                  * Always hidden in the UI. (Except Hero Level Up menu)\n                  * Changes the art of the projectile of the unit if it has a ranged attack"
    },
    "ANmr": {
        "name": "Mind Rot",
        "tags": [
            "Mana Drain",
            "Mana Regen"
        ],
        "notes": "Should have an anime picture as its icon",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Mana Drained per Second”\n                  * Negative values cause the target to regenerate mana instead.\n                  * The Buff is lost when the unit's Mana drops to 0.1 or lower."
    },
    "ANre": {
        "name": "Mana Regeneration",
        "tags": [
            "Mana Regen"
        ],
        "notes": "Null",
        "latest_tested_version": "1.36",
        "raw_text": "* Unlike most auras this does not put a buff on the buff UI (emperor_d3st)\n                  * Will give a default one showing mana regen\n                  * Can be replaced by any buff, changing effectively the visuals\n                  * “Data - Percentage”\n                  * When set to True it will heal a percentage of the unit’s max Mana instead. A value of 0.01 is 1% recovered per second. (emperor_d3st)\n                  * “Data - Amount Regenerated”\n                  * Negative values cause unit to start losing mana instead. (emperor_d3st)"
    },
    "ANpa": {
        "name": "Parasite",
        "tags": [
            "Summon",
            "Damage Over time",
            "Attackspeed Increase",
            "Attackspeed Decrease",
            "Movespeed Increase",
            "Movespeed Decrease",
            "Autocast"
        ],
        "notes": "This single target ability at its default stage, when cast, deals damage over time and spawns a unit upon its victims death. Can not be Dispelled",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI:  Always cast on the furthest target inside the range\n                  * Functions like a unit-, autocastable- version of “Doom”.\n                  * Like Doom, the debuff cannot be dispelled.\n                  * However, unlike Doom, this does not silence the target enemy unit, nor forbid it to use items.\n                  * Creates a unit when a unit dies.\n                  * The summoner of the unit appears as the unit who dies (In triggers).\n                  * Periodic damage is of type poison\n                  * ”Data - Attack Speed Factor”, ”Data - Damage Per Second”, ”Data - Movement Speed Factor”, *Data - Summoned unit Count*,\n*Data - Summoned unit Duration*, *Data - Unit Type*\n                     * Negative values provide positive buffs instead.\n• Unlike all auto cast buff abilities that are only automatically applied when units engage in combat, the unit with this ability;\nwill cast it on any unit that its targets allowed permits upon sight, from allies to enemies to whatever.\n• Personal note: I think it's quite advantageous for this ability to not obey what other similar single target buff abilities do."
    },
    "ANak": {
        "name": "Quill Spray",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Basically a copy of the Undead Destroyer's “Orb of Annihilation”."
    },
    "Ache": {
        "name": "Ray of Disruption",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Summoned Unit Damage”\n                        * Negative values do not heal.\n                        * Adheres to “Targets Allowed\n                        * Deals magic type damage to summons"
    },
    "Andt": {
        "name": "Reveal",
        "tags": [
            "Copy",
            "Vision"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Gold/lumber cost”\n                        * Negative values cause resource gain.\n                        * “Data - mana cost” doesn’t show mana cost in UI nor using it (2.0.1)\n                        * Otherwise it functions like “Far Sight” except it won’t interrupt orders. (Wonder Wiz)\n                        * Triggers don’t notice this spell being cast. You can however detect it by catching the order, as the effect is instant."
    },
    "Asla": {
        "name": "Sleep Always",
        "tags": [
            ""
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Allow On Any Player Slot”\n                        * Not only for neutral players.\n                        * “Data - Sleep Once”\n                        * If false the unit will go back to sleep after getting out of combat.\n                        * If true the unit will not go back to sleep."
    },
    "Aspy": {
        "name": "Spawn Hydra",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Spawns units upon death. (Doom summoning version for self)\n                        * Counts as summoned units, and thus takes extra damage from dispel abilities.\n                        * Spawned units spawn with no abilities regardless of what they have in the Object Editor.(Not the case in 1.31.)\n                        * Stat - Buff works similarly to that of other summon abilities. Duration - Normal is used to determine the Timed Life of the summoned units.\n                        * By default the ability Spawn Hydra Hatchling appears Unknown in the unit Hydra. This is due to a typo which adds a space between two abilities code. Since Ability code must be a four digit type and having no space in between, you can Shift Click the ability field and remove the space to display the real ability name.\n                        * Reincarnation still spawns units.\n                        * Spawned units are counted as summons.\n                        * If the unit having this ability dies while in Soul Theft no units are spawned.\n                        * Hardcoded to only spawn up to 10 units maximum.\n                        * Similar to Doom, if Number of Units is set to a negative value, the game crashes."
    },
    "Asb1": {
        "name": "Spy",
        "tags": [
            ""
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Deprecated\n\n\n-Submerge:[y][z][aa]\n                        * It’s “Burrow” but only works on water."
    },
    "ANab": {
        "name": "Acid Bomb",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Used on clusters of enemies.\n                        * Applies Attack Speed/Move Speed penalties on a target and nearby targets.\n                        * Attack speed and Move speed are actually bonuses, positive values cause them to gain speed. (Uyarrr)\n                        * Applies armor buff / debuff to target.\n                        * Positive values remove armor.\n                        * Negative values add armor\n                        * Applies Damage Over Time to the same targets.\n                        * You would think it’s dispellable, but it’s not.\n                        * Does not appear to stack with itself using separate buffs contrary to rumors. (Unless there is some other way, provide clear instructions.)\n                        * If you set the Area of Effect to 0 it will still hit the primary target. (KitsuneTailsPrower)\n                        * Periodic damage is of type shadow strike (first interval is directly after impact without delay)\n                        * Can be used as a non-stun projectile dummy ability to simulate a projectile\n                        * Can successfully target allies if specified\n                        * Negative damage values are set to its absolute value\n                        * To make it heal, use Bribe Damage Engine, detect if spell damage comes from an ally caster with this ability, then revert the damage\n                        * Setting duration to 0 makes it infinite\n                        * Set it to 0.01 to simulate an instant duration\n                        * Set Damage Interval to the same to prevent multiple ticks.\n                        * Doesn’t show a casting range circle."
    },
    "Aamk": {
        "name": "Attribute Bonus",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Negative values to the bonuses cause the hero to lose attributes instead.\n                        * Fully affected by triggers which increase/decrease level of ability.\n                        * Change the ability slot properly will hide the ability.\n                        * Ignores Techtree Dependencies (PauloHPBender)"
    },
    "ANbr": {
        "name": "Battle Roar",
        "tags": [
            "Copy",
            "Unused",
            "Flat Damage Increase",
            "Flat Damage Decrease",
            "Flat Armor Increase",
            "Flat Armor Decrease",
            "Healing Over Time"
        ],
        "notes": "Judging by the 4 levels it was very likely intended for the rexxar campaign.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Used when engaging enemies.\n                        * It’s a copy of Roar, except it has a separate order string and buff.\n                        * Stacks with “Roar”\n                        * Unlike roar, it provides a flat damage increase."
    },
    "ANba": {
        "name": "Black Arrow",
        "tags": [
            "Summon",
            "Flat Damage Increase"
        ],
        "notes": "Need to be tested if different buffs stacks or not",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Used when the target is dying.\n                        * “Data - Damage Bonus”\n                        * Negative values do not cause healing.\n                        * Basically searing arrows but applying a parasite like effect\n                        * It is possible to allow “self” as a target, causing the unit to attack itself.\n                        * If the magic immune target dies before the attacker has finished to fire, it will count as a Black Arrow usage for the projectile but won’t spawn a unit\n                        * Putting this on a melee unit gives it the ability to place the Black Arrow buff on enemies even without having to toggle on (_dtnmang_)"
    },
    "ANbf": {
        "name": "Breath of Fire",
        "tags": [
            "Healing",
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Triggered by having 3 clustered enemy units in cast range. (Nudl)\n                        * “Data - Damage”\n                        * Negative values cause damage.\n                        * “Data - Damage Per Second”\n                        * Negative values do not cause healing.\n                        * If the unit is affected by Drunken Haze it deals bonus damage.\n                        * If you want the bonus damage per second to not require Drunken Haze buff, use the Breath of Frost instead.\n                        * Initial damage is of type sonic, periodic damage is of type fire (first interval is directly after impact without delay)"
    },
    "ANcl": {
        "name": "Channel",
        "tags": [
            "Dummy Ability",
            "Stackable",
            "Buff Stackable"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Considered the ultimate mapping / trigger ability.\n                        * Has a variety of “targeting” modes, also has the ability to change the GUI strings. Making it stack with itself. (Use different order strings for multiple Channel-based abilities to prevent conflicts)\n                        * Abilities can be marked as \"Hidden\" to prevent them showing up, but they will still be there and can be called by triggers.\n                        * By default has no actual effect except uses user’s mana and causes them to channel one specific animation for a follow through time duration (Daffa)\n                        * When Channel is configured to target units, you can still target destructibles with it, but the Follow Through Time will be ignored and the casting unit’s cast backswing time will be referenced instead.\n                        * Setting the OrderID to a type which is not the same as its target type (e.g. Order ID is Shockwave, but the ability is set to “No Target”) will cause ALL  abilities using that OrderID to be uncastable by triggers or AI (but still castable by players). As such, always use an OrderID that matches the target type. (Lord Damage)\n                        * Setting channeling duration to 0 makes it infinite\n                        * You can make a channeling ability by setting the follow through time to 99999 and make some triggers properly.\n                        * Can target invulnerable units, but set Targets Allowed only does not work, you need to set additional targets like the unit type and Vulnerable.\n                        * “Data - Target type”\n                        * Can’t be copy-pasted from one field to another\n                        * “Data - Options”\n                        * Can’t be copy-pasted from one field to another\n                        * Visible : shown into the UI\n                        * Targeting image : shows an AoE circle with a radius of “Stats - Area of Effect” and previewing targeted units through “Stats - Targets allowed”\n                        * Physical spell :  Cause the ability to affect units that are affected by physical attacks. Meaning ethereal units and invulnerable units are unaffected.\n                        * Universal spell :  Affect all kinds of units without invulnerability. Which means it can penetrate magic immune units without having to set level 6.\n                        * Unique cast : When a group of units having this ability available is ordered to cast it, only one of them will do it. This is useful to make an ability either simultaneous for all casters or just a precise one by one cast ; by default it is simultaneous\n                        * With proper Targets Allowed configuration and triggers, you can make the ability target combined target types such as enemy heroes and ally units only, or enemy structures and invulnerable allies only. As well as trees.\n                        * Cannot change icon with BlzSetAbilityStringLevelField (i.e. works for Devotion aura)"
    },
    "ANch": {
        "name": "Charm",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed on anything that can be targeted; will not target things that can't attack (Though may target workers making buildings that attack)\n                        * Take control over the targeted unit.\n                        * Maximum creep level at or below 0 causes it to ignore level.\n                        * Has maximum level data field. (Nudl)\n                        * Adheres to targets allowed, allowing for stealing of heroes.\n                        * If allowed to target heroes, using Charm on enemy Heroes causes their interface icon to disappear on the enemy player’s side and instead transfer it to your side.\n                        * Charmed heroes act like normal heroes, and their interface icons cannot be removed.\n                        * Maximum creep level is only adhered to by units under ‘Neutral Hostile’ unit group. (Daffa)[ab]\n                        * Other notes: (RoyGBV)\n                        * Using Charm on summoned units with an expiration timer does not alter it.\n                        * Charmed units do use food values (except on summoned units), and can exceed over your current food limits, meaning that you don’t need to “Build more Farms” to use Charm.\n                        * Casting it on player-owned units does not inherit upgrades.\n                        * However, if you used Charm on a worker unit, and used it to build structures that do research upgrades, then units that you Charmed on will have abilities or upgraded damage/armor based on your upgrades researched, as if you trained those units yourself.\n                        * This means that technically (and is possible in-game with a ton of resource management), you can have control over all the other 3 races."
    },
    "ANcr": {
        "name": "Chemical Rage",
        "tags": [
            "Morph"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Contrary to all the stats showing up, the bonuses are actually inside the morphed alchemist.\n(It literally says “Info Panel Only” beside the attack and movement speed bonus fields)"
    },
    "ANca": {
        "name": "Cleaving Attack",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Distributed Damage Factor” can be set above 1.0, causing secondary targets to take more damage than the primary one. This does not increase the damage against the primary target in any way. (RoyGBV)\n                        * This cleave ignores armor.[ac][ad][ae] (tal0n)\n                        * The armor ignoring portion is only against secondary targets, the primary target still takes reduced damage.\n                        * The ability stacks with itself in both item and ability form. (tal0n)\n                        * For some reason, if the “Targets Allowed” field of Level 1 is set to “None”, other levels will have no targets allowed in-game, regardless of what has been set for them (Spacebuns).\n                        * The AOE is offset by the radius of the AOE in the attacking direction.\n                        * Secondary damage is of type enhanced"
    },
    "ANcs": {
        "name": "Cluster Rockets",
        "tags": [
            "Damage Over Time",
            "AOE Disable",
            "Healing Over Time",
            "Healing"
        ],
        "notes": "Does damage different from visual",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Deals force type damage\n                        * Without any modifications this ability is a channeling ability. Interrupt channeling or cast another one while all rockets are not released will cancel the remaining rockets.\n                        * The channeling expires automatically when all rockets landed.\n                        * “Data - Building damage Factor”\n                        * Values higher than 1.00 increase damage by percent.\n                        * Values lower than 0.00 restore health instead.\n                        * “Data - Damage Amount”\n                        * Dictate damage per interval\n                        * “Data - “Area of Effect”\n                        * This field determines the Area of Effect which includes points into which rockets are launched.\n                        * Set to a non-positive number will cause no effect to any unit at all.\n                        * “Data - “Effect Duration”\n                        * Dictates the overall duration of the ability. If this duration is too short, not all rockets are launched.\n                        * An effect duration of 0 still gives out rockets.\n                        * Any negative duration will give out up to 10 rockets in total.\n                        * “Data - “Damage Interval”\n                        * The duration in which a certain number of missiles are launched.\n                        * Fires random missiles in the area (just aesthetic)\n                        * Set this area to 0 with 1 projectile to use it as a visual missile to location\n                        * “Data - Missile count”\n                        * Doesn’t change the missile frequency, they seem to fire every 0.1 ish seconds\n                        * If set to a non-positive number, the caster will keep channeling while no rockets are launched.\n                        * “Data - Stats duration\n                        * Dictates how long the stun lasts.\n                        * Setting to 0 does not stun at all. Does not interrupt channeling ability. (Good for ability that makes remote stun)\n                        * Setting to any negative value stun indefinitely.\n                        * “Stats- Targets Allowed”\n                        * Adhere to targets allowed. Base ability does not affect air units at all, but can be changed to affect and stun air units.\n                        * Negative values cause healing.\n                        * “Data - Effect duration”\n                        * How long the damage loop will take effect\n                        * Doesn’t change the missile frequency !\n\n\n                        *"
    },
    "ANdp": {
        "name": "Dark Portal",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Uses whenever is available.\n                        * Spawns a number between Maximum-minimum amount of Units defined.\n                        * If the minimum is greater than the maximum, it will crash the game-(to be verified) (FlameofChange)\n                        * The units are random from the array.\n                        * The units are still treated as Summoned, and they don’t cost any food. (EternalOne)\n                        * Duration (unit) delays the summoning once casted\n                        * Doesn’t spawn anything if used as a item ability effect (FlameofChange)"
    },
    "ANde": {
        "name": "Demolish",
        "tags": [
            "Percent Damage Increase",
            "Percent Damage Decrease"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Damage Multiplier”\n                        * Negative values do not cause anything to happen.\n                        * Demolish can critically strike and stacks with itself and any other critical strike ability (Wonder Wiz)\n                        * Adheres to “targets allowed”. (tal0n)"
    },
    "ANdo": {
        "name": "Doom",
        "tags": [
            "Summon",
            "Damage Over Time"
        ],
        "notes": "Complete shutdown of a unit if no trigger intervenes",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Causes the unit to take damage until it dies.[af][ag]Silences the target, blocking inventory, forbidding to even drop/pickup items as well as purchasing items. It can still get items from allies.\n                        * Also disable unit’s ability to learn or return to ability panel. As well as disables function to toggle off abilities toggled on.\n                        * Any new items or abilities received during Doom is immediately disabled.\n                        * Disables most of default passive abilities via \"silenced\" flag. It affects all kinds of Critical strike, Bash, Evasion and some others passive  (Confirmed).\n                        * Set Number of unit summoned to negative value cause game to crash.\n                        * Since it uses “silenced” flag, one can specify some abilities to be castable during Doom through triggers.\n                        * “Data - Damage Per Second”\n                        * Negative values do not cause healing. It does twice as damage before reduction.\n                        * Changing “Data - Buff’ does nothing other than display. If the number of summoned units is positive, the summoned units will always get summoned if the target dies even if the target is hidden.\n                        * The “undispellable buff” in tooltip means that buff will not lose if the target gets dispelled or turns invulnerable. The buff can still be removed through triggers. If the target is hidden it will reappear with the buff and the buff still elapses time as long as the buff does not expires.\n                        * Can also target items but does nothing.\n                        * The caster is the summoning unit when the summoned units are summoned.\n                        * Does not disable various Passive Aura, such as Brilliance Aura, Devotion Aura, Command Aura.\n                        * For unknown reason units affected by Doom cannot be targeted by Devour.\n                        * Deals universal type damage"
    },
    "ANdb": {
        "name": "Drunken Brawler",
        "tags": [
            "Percent Damage Increase",
            "Percent Damage Decrease",
            "Flat Damage Increase",
            "Flat Damage Decrease",
            "Copy"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Effectively it’s a copy of both “Critical Strike”, and “Evasion”"
    },
    "ANdh": {
        "name": "Drunken Haze",
        "tags": [
            "Attackspeed Increase",
            "Attackspeed Decrease",
            "Movespeed Increase",
            "Movespeed Decrease",
            "AOE Disable"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* AOE Curse and AOE buffing/debuffing.\n                        * Fully affect allies and building when set Targets Allowed properly."
    },
    "ANeg": {
        "name": "Engineering Upgrade",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Replaces abilities with abilities.\n                        * The ability replaced is the first one in the array.\n                        * The ability they are replaced into is the 2nd one in the array.\n                        * Cannot be obtained by non-heroes as it instantly causes game to crash. (Works on units turned into heroes)\n                        * No longer crashes in 1.31+\n                        * Since 1.27a patch and higher leaving \"Upgrade\" fields empty (for instance when buffing less than 4 abilities) may cause crashes when there are bear-form abilities on the hero. This bug doesn't exists in 1.26 or lower. Could be patched silently in newest patches already. (DracoL1ch)\n                        * \"Buff\" has nothing to do with effect and it's never ever visible ingame.\n                        * Has a lot of weird side effects.\n                        * Shared cooldowns on the spellbook stop working (abilities cool down on their own) when the spellbook is upgraded with this ability.\n                        * Except when added through Hero Skill learning, item acquiring or trigger effects, this ability ignores Techtree Dependencies. (Paulo HP Bender)\n                        * Entirely replaces unlearned or new abilities. Already learned or existing abilities only inherit the Data from the replaced ability, Data1 = Data1 and so on. (Duckfarter)\n                        * “Data - Damage bonus”\n                        * Negative value removes damage as intended, but do not heal the target due to negative damage\n                        * The value is in real, so it makes a clever way to have a decimal precise value instead of an integer (if you really need that precision)\n                        * The value is shown in the UI as a green/red text, but decimal values are rounded to integer\n                        * Needs further testing to see if the decimal value is used as is, or rounded anyway\n                        * “Data - Move speed bonus”\n                        * Negative values works as intended, however they are capped by the minimum movement speed constant (150) in the advanced tab\n                        * Putting -1.00 does not make the unit perfectly immobile, as it still advances very slowly (Divided by 10 ? By 100 ?)\n                        * Can be used to have an instant % based slowness on a unit instead of using a self targetting aura (which has a delay), however changing the minimum speed constant might propagate game design concerns on the whole maps as units may be too slow if stacking enough effects.\n                        * Needs further testing to compute the exact result\n                        * Needs further testing about how it stacks with itself"
    },
    "ANfl": {
        "name": "Forked Lightning",
        "tags": [
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Spammed on enemy heroes and/or clusters of 2+ enemy units.\n                        * ”Data - Damage per target”\n                        * Negative values cause healing instead.\n                        * Deals lightning type damage\n                        * Setting missile art, missile speed, missile arc, homing doesn’t show nor change anything"
    },
    "ANfa": {
        "name": "Frost Arrows",
        "tags": [
            "Copy",
            "Movespeed Increase",
            "Movespeed Decrease",
            "Attackspeed Increase",
            "Attackspeed Decrease"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Very similar to Venomous Spears.\n                        * Flat damage boost instead of DOT\n                        * Periodic damage is of type cold"
    },
    "ANhs": {
        "name": "Healing Spray",
        "tags": [
            "Copy"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Copy of Cluster rockets\n                        * “Damage amount” has been reversed, having negative numbers will cause damage. (Ville Toivonen)\n                        * If enemies are part of targets allowed, they will be stunned. (Ville Toivonen)\n                        * Deals universal type damage if “Damage amount” is negative\n                        * If the buff id is not exactly the healing spray ‘BNhs’ it won’t affect any target (2.0) (Needs further tests)\n                        * Even if it’s a copy of ‘BNhs’ it won’t work"
    },
    "ANht": {
        "name": "Howl of Terror",
        "tags": [
            "Copy",
            "Percent Damage Increase",
            "Percent Damage Decrease",
            "Flat Armor Increase",
            "Flat Armor Decrease",
            "Damage Over Time",
            "Healing Over Time",
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Used when engaging enemies.\n                        * All fields do the opposite of Roar despite having the same name as the Roar fields (i.e. Positive value in “Defence Increase” reduces armour)"
    },
    "ANia": {
        "name": "Incinerate",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* The “Arrow” version is the one in use in melee games.\n                        * Killing a unit with the incinerate buff causes it to explode and leave no corpse (like Finger of Death), and deal damage based on what was set in the damage fields.\n                        * Deals fire type damage to secondary targets when the primary target explodes"
    },
    "ANdr": {
        "name": "Life Drain",
        "tags": [
            "Copy"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31",
        "raw_text": "* Copy of Siphon Mana.\n                        * (nchp1903) From 1.31 onwards, Life Drain (but not Life Drain (Neutral Hostile)) will come with the field “Use Black Arrow Effect”:\n                        * Only applicable to Black Arrows, Black Arrows (Neutral Hostile) and abilities based on them. Doesn’t work on Item Attack Black Arrow Bonus or Item Black Arrow.\n                        * For every Drain Interval, Life Drain it will apply the buff of the Black Arrow ability to the target as a negative buff.\n                        * The Duration of the buff depends on the Duration - Normal of Black Arrow. Same with the buff level, type of summoned unit, and summoned unit duration.\n                        * Even if Black Arrows’ Targets Allowed is set to None, the buff can still be applied. This makes Hidden Black Arrows+Life Drain a good way to make a channeled spell that can also apply a debuff, without too much triggering like Channel.\n                        * Deals magic type damage\n\n\n-[ah]Mana Shield:[ai]\n                        * “Data - Damage Absorbed”\n                        * Only works on values between 0-1\n                        * Dictates how much damage goes through the shield.\n                        * Armor is ignored when mana shield is on. (Wonder Wiz)\n                        * Adheres the “Duration - Unit” field as forced duration. (Remixer)"
    },
    "ANsy": {
        "name": "Pocket Factory",
        "tags": [
            "Summon"
        ],
        "notes": "This ability is perfect for a projectile-based summon unit spell.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Creates units every X amount of seconds.\n                        * If the “Factory” dies the spawning stops.\n                        * Spawned units will die if they walk outside the leash range.\n                        * The Buff name is the name of displaying UI on the factory unit.\n                        * The Factory unit doesn’t actually summon units, the “Factory” ability below does that. (RoyGBV)"
    },
    "ANfy": {
        "name": "Factory",
        "tags": [
            "Summon",
            "Unique",
            "Unused"
        ],
        "notes": "Creates units passively similar to the Factory in Pocket Factory ability.",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Creates units every X amount of seconds.\n                        * Spawned units will die, if they walk outside the leash range.\n                        * The leash range is calculated based on current position of the factory unit. Which means if the factory unit is mobile and goes out of range itself cause the spawn units to die.\n                        * The leash range only kills the spawned unit once. If the spawned unit has Reincarnation it will respawned the unit as well as removing the expiration timer. The respawned spawned unit is thereafter ignored by leash range.\n                        * The leash range lasts permanently and is assigned to each spawned unit if they hadn’t been killed yet. It means if the factory dies before the spawned units, the spawned units moving passing the leash range still get killed.\n                        * Factory units are “selectively un-selectable”; they will be ignored in drag selection, if non-factories are in the same drag selection. This keeps even after losing that ability again.\n                        * Dead Factory Units will continue to spawn units until they are removed from the game, actively or decayed, or the corpse lost the ability.\n                        * NOTE: Summoned units are removed from the game once their timer expires.\n                        * Units spawned by the Factory ability which are intended to produce Food do *not* provide Food (Khyrberos, 1.32.2)\n                        * If the factory unit’s position is in a terrain that is unpathable by the spawned units (Such as water), the spawned units will not spawn even if there’s valid terrain nearby. It resumes spawning when the factory unit’s position is in a terrain that is pathable by the spawned units."
    },
    "AEpa": {
        "name": "Poison Arrows",
        "tags": [
            "TODO",
            "Autocast"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Arrow”-type autocast ability that deals damage over time.\n                        * Periodic damage is of type Poison\n                        * Can be enabled in parallel of another auto ability (need test cases) (2.0)"
    },
    "ANrc": {
        "name": "Rain of Chaos",
        "tags": [
            "Summon",
            "AOE Disabling"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Summons a given number of units at random points in a target region. It will stun units near the summon points. By default, the ability functions like 2-4 casts of Infernal in a target region.\n                        * Rain of Chaos has an odd response to summon abilities it’s based on. It works well with some and fails with others.[aj]\n                        * Does not damage or stun if the summoned unit on the set Inferno ability is either Invulnerable, or has the “Locust” ability. (RoyGBV)\n                        * Deals force type damage"
    },
    "ANrf": {
        "name": "Rain of Fire",
        "tags": [
            "Copy"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Will cast if there are at least 2 to 3 units in a group.\n                        * Similar to Blizzard: calls down damage in waves and causes damage of time.\n                        * Distinct order string from Blizzard.\n                        * Deals fire type damage\n                        * Damage over time only applies if primary damage is greater than 0."
    },
    "ANrg": {
        "name": "Robo-Goblin",
        "tags": [
            "Morph",
            "Flat Armor Increase",
            "Flat Armor Decrease"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Morphs into a unit and provide armor/strength.\n                        * “Data Strength/Defense Bonus”\n                        * Negative values cause negative stat bonuses.\n                        * “Duration - Hero”\n                        * Actually functions like a timed life like Avatar where once the time runs out the unit will turn to the Data - Normal Form Unit again.\n                        * The Duration starts once the Duration - Normal time has run out, e.g. setting Hero duration to 10 and Normal duration to 5 will cause the unit to be in the Normal Form Unit for 5 seconds after the ability is activated (and cooldown started) before it will change to the Alternate Form Unit for 10 seconds. It will then spend another 5 seconds to transition back to the Normal Form Unit, in total taking 20 seconds.\n                        * Despite that the ability will switch to the “Turn Off” form with its tooltip and Icon - Turn Off. Even after the unit has turned back to the Normal Form Unit it remains the Turn Off ability. Activating it now will again turn the unit into the Alternate Form Unit, though. To circumvent this visual bug set the Turn Off data to the Normal data."
    },
    "ANsi": {
        "name": "Silence",
        "tags": [
            "AOE Supportive",
            "AOE Disabling"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Appears to spam on anything that has mana. [May target all units if it reduces the damage dealt of those targeted - needs confirmation.] Preference for units with at least 75 mana as well as player units and non-heroes over heroes.\n                        * This is like “Cloud” except it’s not a channel.\n                        * Same notes from the “Data - xxx” field in Cloud apply.\n                        * ACsi and presumably abilities based on it can be dispelled by Abolish Magic but ANsi and presumably abilities based on it cannot. Both can be dispelled by the “Dispel Magic” spell."
    },
    "ANso": {
        "name": "Soul Burn",
        "tags": [
            "Attackspeed Increase",
            "Attackspeed Decrease",
            "Movespeed Increase",
            "Movespeed Decrease",
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Casting by AI: Has none or only used on heroes, need confirmation. (Nudl)\n                        * Single target debuff.\n                        * “Data - Damage Penalty“ is the percentage of damage reduced. (0.0 is 0%, 1.0 is 100%)\n                        * “Data - Damage Period” is the amount of time before the next damage tick is dealt. (eg: 0.25 causes it to deal 4 damage ticks every second)\n                        * “Data - Attack Speed Reduction” and “Data - Movement Speed Reduction” works as expected, as well as setting it to negative values. (RoyGBV)\n                        * Deals fire type damage\n                        * Hard coded to also Silence the target. (Hive_Parasite)"
    },
    "ANsl": {
        "name": "Soul Preservation",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Targets a specific configurable unit-type.\n                        * Target becomes invulnerable, fades away for the duration, is hidden and dies."
    },
    "ACs8": {
        "name": "Spirit Beast",
        "tags": [
            "Copy"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Actually Spirit Wolf."
    },
    "ANst": {
        "name": "Stampede",
        "tags": [
            "Damage Over Time"
        ],
        "notes": "Uther party?",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* It’s a stampede, will heal if damage is set negative.\n                        * One thing to note is that if you use other default units as the missile/projectile, they will just stand idly and not perform their walking animation as they travel. This is because the stampede lizard’s running animation is labeled as “Stand”. (RoyGBV)\n                        * This is only for visuals and does not affect the ability’s performance. (RoyGBV)\n                        * \"Area of effect\" both determines the length of the line the units/projectiles will emerge from, and how far they will travel before vanishing.\n                        * \"Range\" determines how far away the caster can start the stampede, NOT how far it can hit.\n                        * Deals universal type damage"
    },
    "ANef": {
        "name": "Storm, Earth and Fire",
        "tags": [
            "Morph"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Morphs 1 unit into an array of other units.\n                        * If all the units die the hero dies.\n                        * Hides casting unit from the map.\n                        * Redirects any kind of selection from that unit onto summons.\n                        * When all summons are killed, caster performs suicide (no killer known, no matter the way summons die).\n                        * Channel ability - interrupting caster anyhow will cancel it's effect completely, ending it prematurely.\n                        * As being hidden, cannot access to items nor affect allies through auras.\n                        * If more than three units is summoned, a dummy projectile of Earth will be fired for each additional unit.\n                        * Projectile speed changes the time taken until the unit is summoned. Indeed the projectile trajectory is a parabola to the destination.\n                        * Can summon buildings, some structures initially behave like casting illusion on structures and instantly become fully functional when an enemy comes within range. Does not display expiration timer on buildings.\n                        * Nothing happens if number of summoned units is 0. Waste cooldown and mana cost.\n                        * For unknown reasons, summoning a unit with Locust ability will instantly remove the inselectability and retain the invulnerability.\n                        * A unit turning into a locust during the summoning still disappears normally when expiration timer ends. This is due to expiration timer.\n                        * All summons will disappear and the caster will reappear when Duration expires, even if all expiration timer are paused.\n                        * Can unhide the caster, its invulnerability and pause cannot be removed.\n                        * The caster always reappears at the unit under owning player’s current selection. If no units are selectable at the time of reappearing, a random unit will be selected. Locust units can still be selected through clicking on the icon of the caster, but their selection gets removed immediately.\n                        * All summons form a circle, each divides the parameter equally. (Akaiharuki)\n                        * When the ability is used as an item ability and the summons are all killed, the caster will enter a “undead” state, where its untargetable (Clanzion)\n                        * The unit can attack others\n                        * The unit will actually die if there are no units nearby and its death time has been reached.\n                        * If there are no units nearby, the unit will play its death animation.\n                        * The unit can be referenced and affected by some triggers(mostly visual)"
    },
    "ANsg": {
        "name": "Summon Bear",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Summons a unit, can only ever be 1 unit.\n                        * Any subsequent summons will remove previous ones.\n                        * Above statement is untrue, you can summon multiple bears. The claim likely refers to ‘Summon Misha’ which uses Feral Spirit as a base (Kino, tested 1.30++)"
    },
    "ANsw": {
        "name": "Summon Hawk / -Summon Quillbeast",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Summons a unit for duration."
    },
    "ANlm": {
        "name": "Summon Lava Spawn",
        "tags": [
            "Summon"
        ],
        "notes": "Very cool summon spell tbh.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Generation Count” (Notes below by RoyGBV)\n                        * Effectively it’s how many times they can split before they stop splitting, minus one.\n                        * If you set this value to more than 3, then the lava spawn summoned by splitting, including the original one, will have their textures invisible once they split for the 4th time and beyond.\n                        * “Data - Life Duration Split Bonus”\n                        * When splitting this is how much* bonus extra time they gain.\n                        * “Data - Max Hitpoint Factor”\n                        * Upon successfully splitting, their hit points are restored by [maxHP * the set number]\n(by default, its 0.50, meaning that it restores their HP by 50% of their max HP upon splitting)\n                        * “Data - Split Attack Count”\n                        * How many attacks it takes to split.\n                        * “Data - Split Delay”\n                        * The time it takes before they split after reaching the attacks.\n                        * ”Stats - Targets Allowed”\n                        * This is actually the list of valid targets needed to add in their attacks-to-split count.\n                        * Attacks need to actually land in order to count toward the split count, meaning attacks that Miss do not count.\n                        * Attacking friendly, allied, or your own units doesn’t work, only enemies."
    },
    "ANto": {
        "name": "Tornado",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* A channeled summon.\n                        * Selectable for its owner, unselectable for enemies.\n                        * This ability seems to have some form of “Leash Range”, where it's instantly killed if it exceeds that range.\n                        * Not sure about how much is the distance of this “Leash Range”, but it is definitely not  “Data - Cast Range”. (RoyGBV)\n                        * Leash range is actually determined by “Wander (Tornado)” ability, not the Tornado ability.\n                        * Stats - Duration 0  does not last indefinitely"
    },
    "ANtm": {
        "name": "Transmute",
        "tags": [
            "Special"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Kills a target (defined in Targets Allowed) and gives the gold/lumber back to the owner of the casting unit\n                        * Unfortunately, it does not return Lumber (Khyrberos)\n                        * Returns lumber in 1.36+ (Jaccouille)\n                        * Returns 100% of the target unit’s gold cost, which is reduced when you are in Low or High Upkeep. (RoyGBV)\n                        * Cannot target allies, even when set in “Stats - Targets Allowed”. (RoyGBV)"
    },
    "ANvc": {
        "name": "Volcano",
        "tags": [
            "Special"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1",
        "raw_text": "* “Data Field - Destructible ID” does not function properly yet, select any unit will result in a crash on cast.\n         To change the destructible type, change the Model file of the desired destructible to the same path of Volcano destructible.\n                        * This is the only ability that can generate destructibles in-game. (Wonder Wiz)\n                        * Deals normal and unknown type damage"
    },
    "ANwm": {
        "name": "Watery Minion",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Summons units.\n\n\n@Neutral Passive:"
    },
    "Atdg": {
        "name": "Building Damage Aura",
        "tags": [
            "Special"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Damage Per Second”, “Data - Medium Damage Per Second”, “Data - Small Damage Per Second”\n                        * Negative values does not cause healing\n                        * Used by the Tornado unit from the “Tornado” ability. (RoyGBV)\n                        * Deals force type damage\n                        * Multiple units don’t stack damage with the same ability (KitsuneTailsPrower)[ak]"
    },
    "Aasl": {
        "name": "Slow Aura",
        "tags": [
            "Movespeed Increase",
            "Movespeed Decrease",
            "Attackspeed Increase",
            "Attackspeed Decrease"
        ],
        "notes": "Has no icon by default therefore useful for various spell effects which need a buff",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Attack Speed factor”, “Data - Movement Speed Factor”\n                        * Positive values increase speed.\n                        * Negative values decrease speed.\n                        * Used by the Tornado unit from the “Tornado” ability. (RoyGBV)"
    },
    "Ahnl": {
        "name": "Summoning Ritual",
        "tags": [
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Its basically a Roar ability, meant for dummy ability use in campaign (StormKnight)"
    },
    "Atsp": {
        "name": "Tornado Spin",
        "tags": [
            "TODO"
        ],
        "notes": "Passive, aura-like version of cyclone",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Data - Air Time\n                        * Doesn’t seem to do anything, duration is instead controlled by “Duration - Hero” and “Duration - Normal”. (RoyGBV)\n                        * Data - Minimum Hit Interval\n                        * Number of seconds it takes to cyclone another nearby unit. (RoyGBV)"
    },
    "Atwa": {
        "name": "Tornado Wander",
        "tags": [
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* When put on creeps, the AI will move the unit towards enemies even if they don’t have attack enabled. (Nudl)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@Special:"
    },
    "Adda": {
        "name": "AOE damage upon death",
        "tags": [
            ""
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Full Damage Amount”, “Data - Partial Damage Amount”\n                        * Negative values does not cause healing.\n                        * Deals normal type damage"
    },
    "Aatk": {
        "name": "Attack",
        "tags": [
            "TODO"
        ],
        "notes": "The most used and ignored ability",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Major info\n                        * Units must have this ability to be able to perform attacks.\n                        * Can be removed with call UnitRemoveAbility(<unit variable>, ‘Aatk’). This also removes all Damage and Attack button UI, For unknown reasons, removing this way cannot retrieve the ability through call UnitAddAbility(<unit variable>, ‘Aatk’)\n                        * Can disable attacks by using call BlzUnitDisableAbility(<unit variable>, 'Aatk', true, false) then call BlzUnitDisableAbility(<unit variable>, 'Aatk', false, false). This does not remove the Damage and Attack button, still effectively temporarily disarm the unit.\n                        * However successive disable of this ability causes it to be unable to be re-enabled.\n                        * A unit with no attacks enabled having this ability disabled. Cannot be added or enabled through triggers. If the unit picks up Orbs that enable Attack Index the unit can attack again with no attack damage UI.\n                        * Can be “disabled/re-enabled” by adding/removing one of the “Cargo Hold” (e.g. the Zeppelin one) to the unit via triggers"
    },
    "Abds": {
        "name": "Blight Dispel Large / -Blight Dispel Small",
        "tags": [
            "Copy"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Copy of Blight Growth Large"
    },
    "Abdt": {
        "name": "Burrow Detection",
        "tags": [
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Seems to be a deprecated version of True Sight on a Flying unit.\n[this may explain the incomplete “ (Fliers” editor suffix, but who knows]\n\n\n        -Cargo Hold (Goblin Zeppelin/Ships)\n                        * As its name says, this ability is used for the storage component of transport units. (Notes below by RoyGBV)\n                        * Entering 0 in “Data - Cargo Capacity” causes the “Load/Unload” ability icons to disappear, and cannot load any units in.\n                        * Cannot enter numbers higher than 8.\n                        * However, the capacity for Ships is hardcoded to be at 10.\n                        * When loading in a unit with “Unit - Transported Size” value of more than 1, it places greyed out interface icons of the unit next to it.\n                        * Units with a Transported Size value of 0 cannot be loaded in.\n                        * Cannot Load units with the Doom debuff. Units with the Parasite debuff can be loaded in, but they will die inside the transport and the spawned unit will pop up outside the transport.\n                        * “Stats - Area of Effect” is more like an unloading radius, which when filled with units on its AOE, causes the transport to stop unloading.\n                        * Setting this to low values causes the transport to be unable to fully drop down units, as the target point would be filled with units early on, capping out its AOE.\n                        * Setting this to high values eliminates the problem altogether.\n                        * Do note that Area of Effect is still taken into account when the transport dies on pathable ground, and that it will instantly kill the other units in the transport if the AOE is full.\n                        * Negative AOE values are treated as positive values.\n                        * “Stats - Cast Range” is used for the actual loading-in of units.\n                        * This does not bother with Unload, it’s a separate ability.\n                        * “Duration - Hero” does nothing.\n                        * “Duration - Normal” refers to the unloading time intervals per unit.\n                        * Loading in a unit disjoints projectiles similar to Blink, but does not prevent buffs from healing or damaging them\n\n\n-Cargo Hold Death\n[Ability and Descriptions added by RoyGBV]\n                        * Casts some form of Purge (with no dispel) on all dropped units when a transport dies on pathable ground.\n                        * This “Purge” uses a speed factor of 10 to slow both attack and movement speed.\n                        * The debuff cannot be dispelled.\n                        * By default the buff is Dizziness ‘Bchd’, but can be replaced by any buff you want\n                        * “Data - Summoned Unit Damage” does nothing.\n                        * “Stats - Mana Cost” does nothing either."
    },
    "Agld": {
        "name": "Gold Mine Ability",
        "tags": [
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Unit with this ability will be shown with a gold mine indicator on the map. The minimap icon stays even if they morph or lose the ability."
    },
    "Ahar": {
        "name": "Harvest",
        "tags": [
            "Special"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Allows for gathering of resources from trees or goldmines.\n                        * The event (Targeting an object “harvest”) triggers upon resource return, not upon entering a gold mine.\n                        * “Data - Gold Capacity”\n                        * Negative values are treated as 0.\n                        * “Data - Lumber Capacity”\n                        * Negative values are treated as 0.\n                        * “Data - Damage to Tree”\n                        * Negative values are treated as “kinda” 0.\n                        * Trees can still be harvested but they will never be chopped down and the worker will never get more than 0 lumber.\n                        * Wood harvest is hard coded to be unable to have a lower cooldown than the base one."
    },
    "Aher": {
        "name": "Hero",
        "tags": [
            "Unique"
        ],
        "notes": "The second most used and ignored ability",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Major info\n                        * Primarily for leveling up graphic.\n                        * All hero units are given this ability.\n                        * The hero ability specifies the level up effect of heroes in its caster art field. You'll need a customized AbilityData.slk file in order to get this ability displayed in the editor. Simply set the useInEditor flag to 1 in that file.\n                        * Removing this ability through call UnitRemoveAbility(<unit variable>, ‘Aher’) will result in a crash.\n                        * Adding this ability to non-hero units does nothing. It does not change Target Types and spells targeting heroes only do not work on them still.\n                        * Can be used to check if an ability is a hero ability or not. (Refer to ability Item (aite) below)"
    },
    "AInv": {
        "name": "Inventory",
        "tags": [
            "Special"
        ],
        "notes": "Text",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* “Data - Item capacity”\n                        * Values above 6 will clamp back to 6.\n                        * Values below 0 will clamp back to 0.\n                        * A value of 0 will allow for the unit to pick up tomes and powerups, but not items.\n                        * One can give one hero multiple inventory skills to carry and use more than 6 items. But only one Inventory is visible.\n                        * These additional Inventories have no UI.\n                        * Trigger Item API ignores this additional inventories\n                        * When the Hero gets revived, paused, reincarnated, ... Then only the main inventory takes all the items again. To counter that one needs to re-add the inventory skills. One of the inventory skills can not be removed, but still can be added allowing the hero to carry more and more items, when done.\n                        * “Data - Can Use Items” also dictates if it's allowed to pick up runes and tomes.\n                        * Units that pick up tomes that modify hero stats will crash if the unit is not a hero, or a “heroic” creature.\n                        * When given to a rooting unit, if the unit uproots, it will still benefit from items in its inventory, but will be unable to pick up more items.\n                        * Disable this ability prevent picking up, dropping, using items. Allies can still give items. Do not affect passive."
    },
    "Avul": {
        "name": "Invulnerable",
        "tags": [
            "Special"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Makes a unit invulnerable.\n        -Item\n                        * Can be added through custom script, but adding and removing does not affect units or items in anyway.\n                        * Can be used to check if an ability is item ability or hero ability on cast."
    },
    "Aloa": {
        "name": "Load (Goblin Zeppelin/Ships)",
        "tags": [
            "Special"
        ],
        "notes": "Text",
        "latest_tested_version": "1.31.1",
        "raw_text": "* Loads the target into a transport\n                        * “Stats - Cast Range ”(Kino)\n                        * Affects loading unit and loaded unit behaviour. Actual loading range is affected by the ‘Stats - Cast Range’ of ‘Cargo Hold’ ability.)\n                        * If transporting unit is immobile, this field affects how far away units can be ordered to board the transport via-right-click  (ie. Causes Orc Burrow behaviour)\n                        * If the transporting unit is mobile, it will attempt to load the target from the ‘Cast Range’ value. If this value exceeds loading range, this causes nothing to happen.\n                        * Stats - Cast Time, Area of Effect, Targets, Duration - These fields do not appear to have an effect. (Kino)"
    },
    "Amov": {
        "name": "Move",
        "tags": [
            "Unique"
        ],
        "notes": "You cannot play without it",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Units must have this ability to be able to move.\n                        * When unit’s movement speed is set to 0 in Object Editor, the move button will be removed. Units cannot be issued ground move order.\n                        * This ability is linked with Patrol, Hold Position. If Move is removed, those are removed as well (literally because these abilities are a combination of Move ability and other orders.)\n                        * Can be removed with call UnitRemoveAbility(<unit variable>, ‘Amov’). This also permanently removes that unit’s Patrol, Defend, Hold Position button on the UI. For unknown reasons, removing this way cannot retrieve the ability through call UnitAddAbility(<unit variable>, ‘Amov’) and disable it likewise cannot be retrieved.\n                        * A unit affected by slow reduces its speed to 0 does not remove this ability.\n                        * Units without this ability can still cast spells, attack if the enemy is within attack range. It does not need to turn to attack or cast ability. (Ideal for dummy)\n                        * Without locust, if a unit is triggered to move through Unit - Move instantly to a point, it will always turn collision for the unit on as this order periodically check the pathability of the location."
    },
    "Amin": {
        "name": "Mine - exploding",
        "tags": [
            "Special"
        ],
        "notes": "You know that suicide bomber in class? This is him.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Activation Delay”\n                        * Values below 0 are treated as 0, exploding immediately.\n                        * “Data - Invisibility Transition Time”\n                        * Values below 0 causes it to never turn invisible.\n                        * “Stats - Targets Allowed”\n                        * Giving it air doesn’t enable air unit detection & activation."
    },
    "ANpi": {
        "name": "Permanent Immolation",
        "tags": [
            "Copy"
        ],
        "notes": "The accurate description of a person asking for #rant back.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Copy of Immolation\n                        * Does not have a turn on/off button, always active.\n                        * Having multiple levels does not work. Regular Immolation doesn’t switch to higher level values until it’s deactivated and reactivated, and since Permanent Immolation can’t be deactivated and reactivated, it always uses its level 1 values. (EternalOne)\n                        * Since 1.35+, it’s possible to change an ability's real values, which makes it possible to make a multi-leveled Permanent Immolation, even though it will always use level 1’s (0’s in triggers) values. (PauloHPBender)\n                        * Since Set Ability’s Level Array Field does not function properly yet, if you want this ability to be a multi-level with different damage, mana cost, range, make multiple of it then adds and removes accordingly.\n                        * Deals fire type damage\n                        * Damage stacks (Needs verification)[al]"
    },
    "Apiv": {
        "name": "Permanent Invisibility",
        "tags": [
            "Special"
        ],
        "notes": "Text",
        "latest_tested_version": "1.36.1.20719",
        "raw_text": "* Makes the unit invisible always, except for a moment after attacking/casting.\n                        * Setting Duration to 0 causes the unit to always stay invisible, even when attacking/casting.\n                        * Seems to ignore techtree requirements"
    },
    "AIsi": {
        "name": "Item Sight Range Bonus",
        "tags": [
            "Vision"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Only use level 1 data.\n                           * Doesn’t seem to go further than 1969.75.\n                           * “Data - Sight Range Bonus”\n                           * Negative values cause the unit to get less vision range. (Confirmed)\n                           * There are some delay before the new vision is applied.\n                           * Doom does not disable this ability."
    },
    "Apmf": {
        "name": "Phoenix Fire(flyer)",
        "tags": [
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Unused version of the Permanent Immolation ability, presumably for the Phoenix unit. (RoyGBV)\n                        * Deals fire type damage\n                        * Cannot be limited by tech (will be unlocked even with requirements)"
    },
    "Apoi": {
        "name": "Poison Sting",
        "tags": [
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* A non-slowing, damage only poison attack that stacks with itself.\n                        * The projectile it uses (“Abilities\\Weapons\\PoisonSting\\PoisonStingMissile.mdl”) seems to be glitched. (RoyGBV)\n                        * Deals poison type damage"
    },
    "ARal": {
        "name": "Rally",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Allows for you to set the rally point of a unit/building.\n                        * Automatically given to anything that trains units. You can remove the ability from the building to make it disappear."
    },
    "Argl": {
        "name": "Return Gold / Return Lumber",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Allows for this unit/building to receive Gold/Lumber from workers\n                        * The three abilities are basically the same, with just the Data - Accepts gold/lumber to change\n                        * If the unit/building can return gold, it cannot be built too close to a unit having a goldmine ability\n                        * There’s no field to check/set the amount (or I am blind)\n                        * To make a unit/building able to be constructed in any goldmine distance, remove the ability on its data, then add it through trigger when finished\n                        * The unit/building cannot return the ressources if not finished building\n                        * Hidden\n                        * If a unit can gather and return resources to itself, it will instantly return when full\n                        * TODO : Check if it respects level data, requirements, art fields, if ancient with return gold can root next to a goldmine"
    },
    "Arng": {
        "name": "Revenge",
        "tags": [
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Deprecated???\n                        * The fields of this ability are used when a critter explodes from spam-clicking, thus determining the special effects.\n                        * The ability is not implicitly added to the critter, however, it does not show up in BlzGetUnitAbilityByIndex calls.\n                        * When this ability is added to a unit, the unit can be issued the order “revenge”/852241 (immediate) to self-destruct with\nthe defined special effects.\n                        * Since this ability does not appear in Index call, you cannot remove this ability through call UnitRemoveAbilityBJ( 'AUan', yourUnitId)"
    },
    "Arev": {
        "name": "Revive Hero",
        "tags": [
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* :shrug:\n                           * Enables instant hero buyback, used by Neutral Tavern in the base game (Kino)"
    },
    "Aneu": {
        "name": "Select Hero / Select Unit",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Shop selection for selecting Heroes with inventories\n                           * Allows anyone with vision to command the unit to use abilities and items, but not (directly) movement or attacking."
    },
    "Asid": {
        "name": "Sell Items / Sell Units",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Shop selection for units without inventories\n                           * Enables adding Items/Units to the shop (by trigger)"
    },
    "Apit": {
        "name": "Shop Purchase Item",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Effect that plays when item is purchased\n                           * Gives Gold/Lumber for items"
    },
    "Aall": {
        "name": "Shop Sharing",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Allow shop to share with allies?\n                           * Same as Select Unit except only works for allies.\n                           * Also exposes abilities to allies (e.g. if given to a town hall, your allies could cast call to arms for you)\n                           * If given to heroes, this ability allows players to learn new skills for them (great for computer controlled heroes). (PauloHPBender)"
    },
    "Adro": {
        "name": "Unload",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Used with “Load”.\n                           * Can be used with Devour to “regurgitate” units (Kino)"
    },
    "Awan": {
        "name": "Wander (Neutral)",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Causes this unit to wander around without purpose\n                           * Issues “move” command. The unit will be unable to acquire targets to attack while moving.\n                           * Move a random distance with random angle every 7 seconds. This distance length is considered for neutral units.\n                           * May run into enemy units.\n                           * Adjusting cooldown or duration has no discernible effect\n                           * If an enemy of this unit attacks a nearby friendly unit, all units with Wander will run away if they don’t have an attack\n                           * You can test it by placing neutral hostile deers and attack one of them\n                           * I discovered while working on Age of Humanity, attacking deers (Neutral Hostile) causes all nearby deers to run away to the opposite direction\n        Order unit to run away if the attack was within 600 AoE.\n        It takes a short delay to reactivate this order so a unit can be attacked multiple times before this ability is activated again."
    },
    "Awrp": {
        "name": "Waygate / -Waygate Ability",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* A waygate can go inside itself (It's a one way trip though)\n                           * Setting the “Teleport Area Height/Width” changes how far the unit needs to be from the waygate before they can enter.\n                           * For example setting it to 1150/1150 will make it possible for units to enter the waygate while being as far away as a mortar teams attack range.\n                           * This does not change the destination size, the destination is always at the center of a region / Location."
    },
    "AIbl": {
        "name": "Build Tiny X",
        "tags": [
            "Unique",
            "Summon"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Stats - Duration - Normal”\n                           * The time it takes to build the unit/structure.\n                           * Build Tiny X:\n                           * Order id = 852619\n                           * Works with ‘Unit finishes construction’ event (Kino)\n                           * When triggered, constructed structure will be the same as triggering unit\n                           * If multiple units are selected but not all having this ability, it will not appear in the UI (1.36)"
    },
    "AIlu": {
        "name": "Bundle of Lumber",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Lumber Given”\n                           * Negative numbers drain lumber instead."
    },
    "AIct": {
        "name": "Change Time of Day",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Sets the time of day for a duration.\n                           * Artificial “Night” and “Day” are colored purple or orange depending on the time. (Nudl)\n                           * Hour values are inputted in 24-hour format, meaning that a value of 15 causes the time to be 3:00pm. (RoyGBV)"
    },
    "AIgo": {
        "name": "Chest of Gold",
        "tags": [
            "Unique"
        ],
        "notes": "What is a pirate without some booty?",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Gold Given”\n                           * Negative numbers drain gold instead."
    },
    "AUds": {
        "name": "Dark Summoning",
        "tags": [
            "Summon"
        ],
        "notes": "Seems mostly hardcoded?",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Major info\n                           * With the flag set (true) Units will cluster to the casters position, With false units landing positions are relative equal to the caster as they were compared to the target point.\n                           * Only teleports own units, regardless of allowed target field."
    },
    "AItb": {
        "name": "Dust of Appearance",
        "tags": [
            "Vision"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Shows all invisible/burrowed units around this unit for a duration\n                           * It’s buff (“Detected”, Bdet) can’t be changed; the original will always be applied (PauloHPBender) (tested at version 2.02)"
    },
    "AIgf": {
        "name": "Glyph of Fortification",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Instantly research an upgrade for you.\n                           * Provided that buildings (or units) have this upgrade listed in the “Techtree - Upgrades Used” field.\n                           * Has 2 versions, one can be edited, one can not.\n                           * The first version is Glyph of Fortification (code Algf), which gives you bonus armor (defined in Combat - Defense Upgrade Bonus), and bonus hit points (defined in the Glyph of Fortification upgrade). (RoyGBV)\n                           * The second version, oddly enough, is also called Glyph of Fortification (code Algu), but instead is a 2-level ability that first grants Glyph of Ultravision (defined in Glyph of Ultravision), and then Ultravision (Night Elf ability). (RoyGBV)"
    },
    "AIxm": {
        "name": "Item Agility Gain / -Item Intelligence Gain / -Item Strength Gain",
        "tags": [
            "Unique"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Causes the Hero to gain attributes permanently.\n                           * Negative values causes them to lose attributes.\n                           * Is not affected by triggers which increases/decreases level of this ability.\n                           * If you wish to modify stat gained through increase/decrease level, use Attribute Bonus instead."
    },
    "AIha": {
        "name": "Item Area Heal / -Mana Regain",
        "tags": [
            "Healing"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Used by the Scroll kinds of items, except Town Portal. (RoyGBV)"
    },
    "AIdm": {
        "name": "Item Area tree / -wall damage",
        "tags": [
            "Unused"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Deprecated ability, supposed to separately give Land Mines the ability to destroy trees and destructibles in an AOE, but is now handled by the “Targets Allowed” in the “AOE Damage upon Death (Goblin Mine)” of Land Mines instead. (RoyGBV)"
    },
    "AId1": {
        "name": "Item Armor Bonus",
        "tags": [
            "Stackable",
            "Flat Armor Increase",
            "Flat Armor Decrease"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Gives this unit + Armor or - Armor"
    },
    "AIdf": {
        "name": "Item Attack Black Arrow Bonus",
        "tags": [
            "ORB",
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Stats - Enabled Attack Index”\n                           * Enables this attack on this unit when the ability/item is present.\n                           * “Art - Missile Art”\n                           * Overrides units normal basic attack model"
    },
    "AIcb": {
        "name": "Item Attack Corruption Bonus",
        "tags": [
            "ORB",
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Stats - Enabled Attack Index”\n                           * Enables this attack on this unit when the ability/item is present.\n                           * “Art - Missile Art”\n                           * Overrides units normal basic attack model\n                           * Cannot be limited by tech (will be unlocked even with requirements)"
    },
    "AIfb": {
        "name": "Item Attack Fire Bonus",
        "tags": [
            "ORB",
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Stats - Enabled Attack Index”\n                           * Enables this attack on this unit when the ability/item is present.\n                           * “Art - Missile Art”\n                           * Overrides units normal basic attack model\n                           * Deals universal type damage to secondary targets"
    },
    "AIob": {
        "name": "Item Attack Frost Bonus",
        "tags": [
            "ORB",
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Stats - Enabled Attack Index”\n                           * Enables this attack on this unit when the ability/item is present.\n                           * “Art - Missile Art”\n                           * Overrides units normal basic attack model"
    },
    "AIlb": {
        "name": "Item Attack Lightning Bonus",
        "tags": [
            "ORB",
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Stats - Enabled Attack Index”\n                           * Enables this attack on this unit when the ability/item is present.\n                           * “Art - Missile Art”\n                           * Overrides units normal basic attack model\n                           * If a unit has this ability or an item with this ability and the unit exceeds 99% bonus HP, it will die immediately upon creation\n                           * Does not proc on passively acquired targets. Targets must be manually attacked.\n\n\n-Item Attack Lightning Bonus (new):[am]\n                           * “Data - Effect Ability”\n                           * Selecting a unit targetable ability in this field will trigger the selected ability on attack (the target must be manually selected, auto attacks will not trigger this effect)\n                           * i.e. changing it to “chain lightning” will trigger chain lighting on attack whenever the “chance to hit” procs.\n                           * The selected spell must be a unit targetable spell, like chain lightning or shockwave. Spells like Inferno or War Stomp won’t trigger.\n                           * The unit must have enough mana to cast the spell and if the spell costs mana, that mana will be used to cast the spell\n                           * The triggered spell will go on cooldown and won’t trigger for the time it is on cooldown\n                           * The selected spell will appear in the unit’s ability selection but grayed out (as in: it’s DISBTN icon is displayed) (You can hide the ability via X:0 Y:-11 and it will still trigger on hit)"
    },
    "AIpb": {
        "name": "Item Attack Poison Bonus",
        "tags": [
            "ORB",
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Stats - Enabled Attack Index”\n                           * Enables this attack on this unit when the ability/item is present.\n                           * “Art - Missile Art”\n                           * Overrides units normal basic attack model"
    },
    "AIzb": {
        "name": "Item Freeze Damage Bonus",
        "tags": [
            "ORB",
            "TODO"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Stats - Enabled Attack Index”\n                           * Enables this attack on this unit when the ability/item is present.\n                           * “Art - Missile Art”\n                           * Overrides units normal basic attack model\nWhen given to a hero unit, this ability turns hit enemies blue as if affected by a cold effect, and freezes them permanently in place, they stop moving entirely. A buff with the Sammy icon and “tool tip missing” is also added to the hit unit."
    },
    "AIsx": {
        "name": "Item Attack Speed Bonus",
        "tags": [
            "Attackspeed Increase",
            "Attackspeed Decrease",
            "Stackable"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Attack Speed Increase”\n                           * Negative values slow attack speed instead."
    },
    "AIfl": {
        "name": "Item Capture The Flag",
        "tags": [],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Totally cosmetic."
    },
    "AIdc": {
        "name": "Item Chain Dispel",
        "tags": [],
        "notes": "Item version of Ray of disruption",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Dispels units with a bouncing wave?\n                           * This ability summons a projectile that bounces between units, dispelling each one.\n                           * The projectile has no delay between bounces, unlike Chain Lightning or Healing Wave."
    },
    "AIco": {
        "name": "Item Command",
        "tags": [
            "Copy"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Copy of the Dark Ranger ultimate “Charm”."
    },
    "AItg": {
        "name": "Item Damage Bonus",
        "tags": [
            "Flat Damage Increase",
            "Flat Damage Decrease",
            "Stackable"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Attack Bonus”\n                           * Negative values cause a unit to lose damage instead.\n                           * Damage can never be lower than minimum unit damage.\n                           * Scaleable levels through triggers"
    },
    "AIdi": {
        "name": "Item Dispel",
        "tags": [],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Priest “Dispel”\n                           * Deals magic type damage\n\n\n-Item Doom Guard Summon / -Item Felhound Summon / -Item Furbolg Summon / -Item Ice Revenant Summon / -Item Red Drake Summon /"
    },
    "AIfd": {
        "name": "Item Rock Golem Summon / -Item Skeleton Summon / -Item Ursa Warrior Summon / -Summon Headhunter",
        "tags": [
            "Summon"
        ],
        "notes": "Text",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Summons up to 2 different kinds of units of selectable amounts each."
    },
    "AIem": {
        "name": "Item Experience Gain",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Experience Earned”\n                           * Negative values causes the hero to lose experience… (But not levels)\n                           * Cannot be used if at full level, regardless."
    },
    "AIh1": {
        "name": "Item Healing",
        "tags": [
            "Healing"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Null"
    },
    "AIs1": {
        "name": "Item Hero Stat Bonus",
        "tags": [
            "Unique",
            "Stackable"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Gives or removes stats from the hero for as long as the ability/item is attached.\n                           * Changing ability level doesn’t change the stats"
    },
    "AIil": {
        "name": "Item Illusions",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* The only way to create illusion of something other than the caster.\n                           * Creates “Copies” of targeted unit.\n                           * Casting 2 illusions on the same unit at the same moment will result in a crash. (1.32.7) (ZiHeLL)\n                           * Unable to reproduce, this might only occur in very specific circumstances, it was false or have been fixed. (somen00b)\n                           * Attacking an illusion will not redraw aggro, you can attack one to detect whether it’s an illusion or not (Nudl).\n                           * “Data - Damage Dealt”\n                           * Negative values does not cause healing.\n                           * “Data - Damage Received Multiplier”\n                           * Negative values does not heal.\n                           * Illusions deal normal type damage\n                           * You can cast to a building if set the Target Allowed properly.\n                           * Illusions from building is affected by Damage Dealt and Damage Received Multiplier and spawn away based on Area of Effect as if it was a normal unit. Visually, the building carries the Ground Texture as it dies and does not have a default blued tint color like normal illusions and always appear in the state of constructing. But as soon as it notices an enemy nearby, its model will change to the original target and it fully functionally attacks."
    },
    "AIcf": {
        "name": "Item Immolation",
        "tags": [
            "Copy"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Permanent Immolation Copy.\n                           * Deals fire type damage.\n                           * Stack with Hero ability Immolation."
    },
    "AIlm": {
        "name": "Item level gain",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Does not work if it is a hero ability.\n                           * Without modification retain the current expirence of unit.\n                           * Setting to a negative value causes the hero to lose experience, but not to level down. (Confirmed)\n                           * However the first time picking it up will increase level by 1.\n                           * All negative values are treated as 0.\n                           * Setting to a high value that goes beyond the hero max level will not make the hero go beyond max level.\n                           * The highest value can be entered without force clicking is set at Gamplay - Constant\n                           * At max level cannot pick up any kind of item that has Item level gain ability.\n                           * Setting to 0 still causes the hero to gain a level and lose all XP..."
    },
    "AIlf": {
        "name": "Item Life Bonus",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Max Life Gained”\n                           * Negative values loses health instead.\n                           * Going below 0 health causes flow issues, check “item permanent life gain”\n                           * Using levels with this ability does not work, it always uses level 1’s stats. , Also tested in 1.36, same problem"
    },
    "Arel": {
        "name": "Item Life Regeneration",
        "tags": [
            "Healing Over Time"
        ],
        "notes": "Cannot be leveled, always provides level 1 bonus only, no matter what (1.26a, DracoL1ch), Also tested in 1.36, same problem",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Hit Points Regenerated Per Second”\n                           * Negative values cause damage instead.\n                           * Use self targeting Unholy aura instead, as it would be more precise & working as intended"
    },
    "AIva": {
        "name": "Item Life Steal",
        "tags": [
            "Healing"
        ],
        "notes": "Self harm",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Causes these units' attacks to make them regain health.\n                           * Does not appear to work against buildings.\n                           * “Data - Life Stolen Per Attack”\n                           * Negative values cause this unit to take damage instead.\n                           * Ignores “Invulnerable”"
    },
    "AImb": {
        "name": "Item Mana Bonus",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Max Mana Gained”\n                           * Negative values loses mana instead.\n                           * Going below 0 mana causes unexpected behavior.\n                           * Using levels with this ability does not work, it always uses level 1’s stats."
    },
    "AIrm": {
        "name": "Item Mana Regeneration",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Mana Regeneration Bonus”\n                           * Negative values cause unit to start losing mana instead."
    },
    "AIms": {
        "name": "Item Move Speed Bonus",
        "tags": [
            "Movespeed Increase"
        ],
        "notes": "Null",
        "latest_tested_version": "2.0",
        "raw_text": "* Gives a unit more movement speed.\n                           * All negative values clamped to 0. (ZiHeLL)"
    },
    "AIaa": {
        "name": "Item Permanent Damage Gain",
        "tags": [
            "Dummy Ability",
            "Flat Damage Increase",
            "Flat Damage Decrease"
        ],
        "notes": "Nullgoblin",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Causes the unit to gain damage, or lose it. Permanently.\n                           * Setting it to 0 will cause nothing to happen. Good for dummy item pickup ability."
    },
    "AImh": {
        "name": "Item Permanent Life Gain",
        "tags": [
            "Dummy Ability",
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Setting to a negative value causes the hero to lose health. After reaching 0 health the hero dies.\n                           * If you then revive the hero (using triggers or altar), the heroes health will be underflowed to an unsigned 32 bit number.\n                           * At first it will have over 4000000000 health (int max). And will keep decreasing.\n                           * Health does not work as intended at this high level, causing invulnerability.\n                           * Increasing the health back up past the threshold makes it return to normal health. (StormKnight)\n                           * Setting it to 0 will cause nothing to happen. Good for dummy item pickup ability."
    },
    "AIpm": {
        "name": "Item Place Goblin Land Mine",
        "tags": [
            "Summon"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Null\n                           * Impossible to add expiration time, even after setting duration and buff."
    },
    "AIrc": {
        "name": "Item Reincarnation",
        "tags": [
            "Copy"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Item version of Reincarnation.\n                           * Doesn’t work if added to the unit ability list, either from object editor and triggers"
    },
    "AIrv": {
        "name": "Item Reveal Entire Map",
        "tags": [
            "Vision"
        ],
        "notes": "Bullshit",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Reveals the entire map for 5 seconds. This is bullshit.\n                           * Set duration to a non-positive cause some cast channeling but no vision is given.\n                           * Literally the global version of True Sight and it can detect invisible units globally.\n                           * Similar to True Sight cannot detect invisible locust units.\n                           * The casting effect is visible to all players."
    },
    "Asou": {
        "name": "Item Soul Possession / -Item Soul Theft",
        "tags": [
            "Unique"
        ],
        "notes": "This is probably one of the more interesting abilities.",
        "latest_tested_version": "1.31.1.12173",
        "raw_text": "* Captures a Hero that won't be freed until the carrying unit dies. (Literally the best Devour version)\n                           * The number of animation indicates number of captured units.\n                           * The target is hidden and can be unhidden but it will quickly deselect selections.\n                           * The buff does nothing, if it is removed the captured unit still gets released.\n                           * If the caster dies on a terrain type that is unpathable by the captured unit, the captured unit will die instantly with no killer.\n                           * Adheres to Targets Allowed, which causes some interesting things to happen: (Notes below by RoyGBV)\n                           * Casting this on Buildings causes them to disappear like you would with a normal cast of this ability.[an]\n                           * When the carrying unit dies, the Buildings will appear exactly at their death location, even on non-pathable or unbuildable ground such as deep water and the sides of cliffs. Multiple buildings being freed can stack on top of each other in a single location.\n                           * When capturing an Undead building, the blight will stay on where it originally was, and can now be dispelled or cleared..\n                           * If the carrying unit dies and the Undead building is freed somewhere far away from where it once was, the blight is created at its original location, and can still be dispelled or cleared out. Blight is never created on the building’s new location.\n                           * The following will happen when Soul Theft is cast on a building construction in progress:\n                           * Humans: All workers, including the primary one from which the build order came, will simply stop as if the building was canceled. They will need to be manually ordered to continue construction again once the building is freed.\n                           * Undead: The construction progress continues while being captured. When completed, Blight is not created until it is freed, and when freed, the blight will be created in its original location, which can be dispelled or cleared.\n                           * Orc: Construction progress continues while being captured. When completed, the Peon pops back up on the building’s original location, whether the building is freed or not.\n                           * Night Elf: Same as Orcs.\n                           * Buildings going through upgrades (Town Halls) will still continue upgrading while captured.\n                           * Unit training progresses will be paused on capture and resume once freed.\n                           * Though Human Town Halls can’t use Call to Arms on all peasants, individual peasants can still use their own Call to Arms ability. They will walk to the Town Hall’s original location as if it was there.\nIf the Town Hall is freed, they will walk to the new location instead.\n                              * Casting Soul Theft on a Pocket Factory summoned by the ability causes the building to disappear, but still have Clockwerks summoned normally. This is because the Factory building itself doesn’t actually summon units, but only serves as a condition check to stop summoning units once it dies.\n                              * When the carrying unit dies in a location farther than the Leash Range set in the Pocket Factory ability, all previously summoned Clockwerks die, and new ones will spawn in the new location.\n                              * Casting this on your Town Hall causes workers who are gathering resources to act like it's there and return resources on an invisible spot.\n                              * Works on Lumber Drop-off buildings as well (eg: Lumber Mill, Graveyard and War Mill)\n                              * When the carrying unit dies, the Town Hall reappears on that unit’s death location, and workers will immediately update their AI to start walking to that new updated location to return their gathered resources. Works the same for Lumber Drop-off buildings.\n                              * When cast on a Gold Mine, causes Human and Orc workers to simply continue mining from an invisible source. When the carrying unit dies, .\n                              * the AI of Peasants and Orcs will update, and they will now start walking to the new location to harvest gold.\n                              * For Night Elves, casting this on an Entangled Gold Mine causes it to disappear along with the wisps, and prevents you from gaining any gold. When the carrying unit dies, the Entangled Gold Mine appears at the unit’s death location and acts normally again, letting you gain gold.\n                              * For Undead, casting this on a Haunted Gold Mine causes it to disappear, and while the Acolytes will still mine and play their animation, you won’t gain any gold. When the Haunted Gold Mine is freed, the Acolytes will stop playing their animation and the white pentagonal effect on the ground disappears. You will need to select and order them to harvest gold from the new locationCasting this on enemy Heroes causes them to disappear, but their interface icons are still present and you will be revealed to their team, almost as if you cast Devour on that Hero. Same thing happens to non-Hero units.\n                              * Similar to Devour, you are revealed with True Sight even if being a locust with invulnerability.\n                              * Unlike Devour, the revealing sight radius is much larger (720 to all right angles and 656.195 to all diagonal)\n                              * Casting this on yourself (provided that “Self” was included in Targets Allowed), causes you to disappear, but still have your interface icons on if you were a Hero. However, since the captured unit is only freed when the capturing unit dies, you are never freed, also selecting yourself permanently freezes the game.\n                              * Casting this on a Transport Ship or units with Float movement will cause them to be stuck and unable to move on terrain unpathable to them.\n                              * Can be cast to but does nothing when cast on items. (End of notes by RoyGBV)[ao]\n                              * Since the captured unit is simply hidden and added ward ability, effects that summon units when the captured unit dies such as Doom will summon units at the position of the captured unit at the time of casting.\n                              * The captured unit will not get affected by any aura or Pick every unit in Group query.\n                              * Interactions with Reincarnation:\n                              * If the caster dies and begins reviving, the captured unit is released.\n                              * If the captured unit dies with reincarnation available and is still captured and hidden, the buff persists on the caster and the captured unit does not revive.\n                              * If the captured unit dies with reincarnation available and is still captured and not hidden, the buff persists on the caster and the captured unit revives.\n                              * If the target unit has Morph ability on death like when capturing a Phoenix, the Phoenix will not perform that ability and will perish.\n                              * Interactions with more than 2 units:\n                              * Cast multiple times by the same caster on the same unit does nothing. Only that captured unit gets released.\n                              * Cast on multiple units will release all captured units upon the caster dying.\n                              * If the same unit is captured multiple times by different casters, the captured unit simply reappears at each caster’s death location\n                              * If a unit (the first unit) who captures a unit (the second unit), which had previously captured a unit (the third unit) in it then when the first unit dies will release the second unit, the same goes to the second unit when the second unit dies.\n                              * If in this chain capturing the second unit somehow dies, the third unit will reappear at the location of the first unit.\n                              * The death animation of the captured unit only plays when the caster dies.\n                              * If a unit (the first unit) captures a unit (the second unit), then another unit  (the third) captures the second unit, then the first unit captures the third unit. If the first unit dies both the second unit and the third unit reappears but the second unit is paused with ward type. Only after the second unit dies it reappears again next to the third unit and resumes its animation.\n                              * If casting this ability on a unit under Possession (the animation is flying towards it), the unit will not be possessed, the possession casting unit will not die, When the Soul Theft caster dies the captured unit is released with permanent Possession. The same thing happens when the Soul Theft caster dies before the animation reaches.\n                              * If a unit casts Soul Theft on a unit, that unit cannot be cast Devour ability on, to which it display message: Unable to target unit in a buliding or transport.\n                              * If a unit cast Devour on a unit, then a unit casts Soul Theft on devouring unit. The devouring process and killing from devour occurs normally. If the devouring unit dies, it will appear next to the caster who casts Soul Theft.\n                              * If the Devouring unit dies to an ability that summons unit like Doom while under Soul Theft, no unit is summoned regardless of number.\n                              * Casting Soul Theft on a summoned unit does not pause its expiration timer, it will still continue ticking down and will still expire as usual.\n                              * Does not interrupt morphing animations, and the unit will finish morphing and start ticking its morph timer (if it has one) while being captured.\n                              * “Duration - Hero” and “Duration - Normal” don’t do anything. This ability is hard-coded to last indefinitely until the carrying unit dies or until the captured victim dies."
    },
    "AIda": {
        "name": "Item Temporary Area Armor Bonus",
        "tags": [
            "Healing",
            "Flat Armor Increase",
            "Flat Armor Decrease"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Susceptible to Abolish Magic, Dispel Magic, Devour Magic, and Spell Steal (theyugiohcardforger)\n                              * “Data - Defense bonus” “Data - Hit Points Gained” “Data - Mana Points Gained”\n                              * Negative values cause loss of said abilities."
    },
    "AIv1": {
        "name": "Item Temporary Invisibility",
        "tags": [
            "Vision"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Makes unit invisible for duration"
    },
    "AIvu": {
        "name": "Item Temporary Invulnerability",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Makes unit Invulnerable for duration\n                              * Many channeling spells like staff of teleportation or starfall will dispel this. Use divine shield if you want the same effect without this behavior.\n                              * Seems to not be castable if the ability is hidden through triggers\n                              * If you want it to be cast and hidden, unhide it first then order it before hiding it again"
    },
    "AIsp": {
        "name": "Item Temporary Speed Bonus",
        "tags": [
            "Movespeed Increase",
            "Movespeed Decrease"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Move Speed Increase”\n                              * Negative values causes slowdown."
    },
    "AItp": {
        "name": "Item Town Portal",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Causes the unit to become invulnerable and teleport to a town hall.\n                              * Double clicking this item in the inventory causes you to quickly town portal to your highest tier town hall."
    },
    "Amec": {
        "name": "Mechanical Critter",
        "tags": [
            "Unique"
        ],
        "notes": "I never really was on your side",
        "latest_tested_version": "1.29.2.9231",
        "raw_text": "* Creates a random Critter that will be ignored by enemies unless they specifically attack it.\n                              * Morphing doesn’t remove its effects\n                              * The unit is not shown on the minimap.\n                              * Mechanical critter doesn’t get auto targeted by enemies but they will fight it if it attacks them. If it loses aggro (such as by attacking its allied unit) enemies will go back to happily ignoring it.\n                              * Despite not being controllable, you can cast mass teleport to it."
    },
    "AImo": {
        "name": "Monster Lure",
        "tags": [
            "TODO"
        ],
        "notes": "I am totally unsure wtf this is, is it an item for some campaign? Did i miss something?",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "*  This basically functions like Taunt, except they don’t attack the lure since the ability is hardcoded to always summon the lure to belong to the player “Neutral Passive.”\n                              * “Stats - Targets Allowed” doesn’t seem to work. (RoyGBV)"
    },
    "AIpz": {
        "name": "Penguin Squeek",
        "tags": [
            "Alright Then"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Just a healing potion that has a custom sound effect."
    },
    "APh1": {
        "name": "Powerup Area Healing",
        "tags": [
            "Healing"
        ],
        "notes": "I need healing",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Hit Points Gained”\n                              * Negative values cause damage instead."
    },
    "AIri": {
        "name": "Random Item",
        "tags": [
            "TODO"
        ],
        "notes": "Thinking",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Replaces an item with a random ‘Replenishment potion’-based item of appropriate level.\n                              * transforms into items that have the morph-value enabled"
    },
    "AInd": {
        "name": "Reanimation",
        "tags": [
            "TODO"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Copy of Dark Knight’s Animate Dead, but only uses one corpse."
    },
    "AIrb": {
        "name": "Rebirth",
        "tags": [
            "Summon?"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Revives the unit that it was dropped by and taken control by the player.\n                              * Uses the unit’s food cost, but does not inherit upgrades.\n                              * When the rebirthed unit dies, it poofs out and leaves no corpse."
    },
    "Aspb": {
        "name": "Spell Book",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.29.2.9231",
        "raw_text": "* Allows the user to open up a new menu in their unit to use abilities.\n                              * Supposedly stackable with different orderids.\n                              * The original way to hide abilities before the new coordinate hiding.\n                              * Changing the orderid to a build ability transforms the spellbook to a build menu.\n                              * Shows the buildings that unit can already build in its building list\n                              * Spells indicated in OE will replace the button position of a building.\n                              * Hiding the build ability through triggers will remove the building list from the spellbook too\n                              * Hiding the button through Leandrotp’s method or (0, -11) is the only way to prevent it.\n                              * The build ability hidden this way still allows units to build the buildings if triggered to do so.\n                              * Using the same orderId for two spell book abilities fuses the contents of both into the same menu.\n                              * If a unit has this ability or an item with this ability and the unit exceeds 99% bonus HP, it will die immediately upon creation"
    },
    "AIsr": {
        "name": "Spell Damage Reduction",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Decrease spell damage taken by a %.\n                              * If damage reduction field is set to a negative value it will increase spell damage taken instead. Use it for custom magic resistance amplification or reduction aura (1.31.1.12173)\n                              * Fully stackable.\n                              * Can break elune grace skills obtained by the unit\n                              * Not stackable in 1.36: Tested with 2 copies of the ability set to 0.5 and 0.49 respectively and with both at 0.5 and the reduction was only 50% (KitsuneTailsPrower)\n                              * Only the most recently acquired ability is considered, i.e., if the unit first receives a Spell Damage Reduction ability with 75% reduction and later another one with 50% reduction, the reduction will effectively be 50% then (Water)"
    },
    "AImx": {
        "name": "Spell Immunity",
        "tags": [
            "Magic Immunity"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Magic Damage Factor”\n                              * Flat dmg block vs AttackTypeMagic (requires Game constant MagicImmunesResistDamage=0)\n                              * Anything above 0 reduces taken dmg.\n                              * Anything below 0 increases taken dmg."
    },
    "ANss": {
        "name": "Spell Shield",
        "tags": [
            "Magic Immunity"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Blocks 1 spell and then requires a cooldown.\n                              * If used as an ability, it can be actively used. This can be pretty dangerous when a secondary effect is placed with triggers to this ability (Daffa)\n                              * It will not trigger a normal spell block if you actively use it and it is on cooldown.\n                              * Seems to not work correctly with upgrades and tech requirements: Will trigger even if tech is not researched and won’t level up from upgrades. (KitsuneTailsPrower)\n                              * Giving this ability a mana cost will cause the ability to consume mana when it is activated. If the mana cost is more than the unit’s current mana, the spell shield still block spell but the ability will not go into cooldown, effectively creating an infinite spell shield. (Patch 1.30.4)"
    },
    "ANpr": {
        "name": "Staff of Preservation",
        "tags": [
            "Unique"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Teleports targeted unit to highest tier townhall, or another factory if not applicable"
    },
    "ANsa": {
        "name": "Staff of Sanctuary",
        "tags": [
            "Unique",
            "Healing",
            "Healing Over Time",
            "Damage Over Time"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Unit/Hero regeneration delay is the time it takes until they start healing.\n                              * At negative it’s treated as 0.\n                              * Hit points per second is how much it heals a second.\n                              * At negative values it does damage your unit until it dies.\n                              * Unless it gets fully healed from another source and the effect is broken.\n                              * Magic Damage Reduction does not in fact appear to do anything at all, the units appears “spell immune”."
    },
    "AImt": {
        "name": "Staff of Teleportation",
        "tags": [
            "Copy"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* This is a copy of the archmage ultimate."
    },
    "Aste": {
        "name": "Steal",
        "tags": [
            "Healing Over Time"
        ],
        "notes": "Steals health or mana from a target.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Used by the item Wand of Mana Stealing.\n                              * Seems to function like Dark Ritual, but seems to not always work as intended."
    },
    "Aret": {
        "name": "Tome of Retraining",
        "tags": [
            "Unique"
        ],
        "notes": "Very underrated item tbh.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Unlearns all spells and allow for you to pick new ones."
    },
    "AIpv": {
        "name": "Vampiric Potion",
        "tags": [
            "Healing",
            "Flat Damage Increase",
            "Flat Damage Decrease"
        ],
        "notes": "Null",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* “Data - Life Steal Amount”\n                              * Negative values causes unit to take damage instead.\n                              * Ignores invulnerable status.\n                              * “Data - Damage Bonus”\n                              * Negative values causes damage loss."
    },
    "Ashs": {
        "name": "Wand Of Shadowsight",
        "tags": [
            "Vision"
        ],
        "notes": "Text",
        "latest_tested_version": "1.32.10.18820",
        "raw_text": "* A copy of Faerie Fire, except it doesn’t reduce armor, and its duration is permanent. It Can be dispelled though. (RoyGBV)\n                              * Doesn’t appear to have an order string in the ability editor, but it actually does. The order string is “shadowsight” with order number 852570 (EternalOne)"
    },
    "Sca1": {
        "name": "Chaos / -Berserker Upgrade",
        "tags": [
            "Morph"
        ],
        "notes": "This is the ultimate Morph Ability tbh. Simple and quick and good for triggers, has some glaring issues tho.",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "* Morphs unit into another unit once the techtree requirements have been met.\n                              * Basically it is a permanent Metamorphosis that does not require casting\n                              * If a chaos ability is available on a building, won’t cast it as long as the building is training/researching/upgrading\n                              * Cases to test\n                              * When the caster is paused\n                              * When the caster is hidden\n                              * When the caster is stunned\n                              * The new unit update its attack damage which is calculated by merging damage of both units.\n                              * If the hero has an ability that gives permanent health it causes the hero to gain immense amounts of health. Eventually overflowing.\n                              * Heroes that are Chaos keep their spot in the hero list, along with any control group they are in.\n                              * Units also keep their control group.\n                              * The hero keeps their current attributes.\n                              * The hero keeps their current Str/Agi/Int per level.\n                              * Other Hero related information will also be kept (like Hero abilities/XP/Level) and will not be overwritten by heroic abilities from the other hero.\n                              * Normal abilities will be overwritten by the normal abilities on the new hero.\n                              * If any item or aura buff obtained (i.e. providing bonus armor), it's effect may become part of the unit forever, which heavily limits usage of this ability in common. Interaction depends on the base ability which is the source of the bonus.\n                              * The instance API and Skin system might be a better choice in 1.32+ instead of this ability.\n                              * However changing skin is limited through what the triggers can change on a unit, for example setting a unit weapon range is bugged\n                              * Setting a unit skin removes permanently its shadow, even if you set it to the original skin (2.0)\n                              * Increases the RAM usage of the unit since it is duplicated and replaced at every morph\n                              * Can cause very rare desync when there’s multiple morphs in the same map. It desync once and works fine for the rest of the game (like a thanos snap)\n                              * When the unit has multiple valid chaos abilities, the last one in the list will be used\n                              * Beware of infinite loop or it will lag a lot"
    },
    "AIf2": {
        "name": "Item Attack Heal Reduction Bonus",
        "tags": [
            "Orb",
            "Buff Unstackable",
            "Healing",
            "Flat Damage Increase"
        ],
        "notes": "This reduces healing effects from most hit point regeneration sources.",
        "latest_tested_version": "1.31.1.12164",
        "raw_text": "* Multiple copies of the ability do not appear to stack. More testing is needed.\n                              * The most recent buff applied by a copy of this ability takes precedence.\n                              * “Data - Healing Multiplier”\n                              * Values higher than 1.00 will amplify healing effects.\n                              * This may cause a visual bug where the buff will not show up.\n                              * You may experience no effect and even new Orb of Fire item does not appear when put on ground. Go to Map Options > Game Data Set: Melee (Lastest Patch) as new items such as Orb of Fire and Orb of Lightning is updated but does not appear on Default data set of 1.31 version.\n                              * Values lower than 1.00 will reduce healing effects.\n                              * Values lower than or equal to 0 will be treated as 0.01."
    },
    "Alea": {
        "name": "UnselectAble (Internal name: CAbilityLeash)",
        "tags": [
            "Unique"
        ],
        "notes": "Need to be defined in units/abilitydata.slk",
        "latest_tested_version": "Unknown",
        "raw_text": "* Makes an Unit unselectable but targetable.\n                              * returns \"attack\" to abi Gained Position when aoe away.\n                              * Hide & Unhide -> Selectable but still returns on aoe distance.\n                              * Remove Abi unit Hide & unit Unhide unit is normal again.[ap] (Aloc ability inherit this property)\n\n\n\n\n @Template:"
    },
    "xxxx": {
        "name": "Ability name",
        "tags": [],
        "notes": "",
        "latest_tested_version": "1.28.5.7680",
        "raw_text": "Abolish Magic susceptible: Y / N / N/A\nDispel susceptible: Y / N / N/A\nDevour Magic susceptible: Y / N / N/A\nSpell Steal susceptible: Y / N / N/A\n                              * Major info\n                              * Additional info same topic\n                              * Notes regarding that part of the information.\n                              * Major info 2"
    }
}
```

`data/warcraft/generate_ability_insights.py`:

```py
import argparse
import json
import re

def parse_abilities(input_file, output_file):
    with open(input_file, 'r', encoding='utf-8') as f:
        text = f.read()

    abilities = {}
    blocks = re.split(r'^\s*-(.+?):\s*$', text, flags=re.MULTILINE)
    
    for i in range(1, len(blocks), 2):
        name = blocks[i].strip()
        block = blocks[i+1]

        rawcode_match = re.search(r'RawCode:\s*(\S+)', block)
        if not rawcode_match:
            continue
        rawcode = rawcode_match.group(1)

        tags_line = re.search(r'Tags:\s*(.*)', block)
        if tags_line:
            tags = re.findall(r'\[(.*?)\]', tags_line.group(1))
            tags = [t.strip() for t in tags]
        else:
            tags = []

        notes_match = re.search(r'Notes:\s*(.*)', block)
        notes = notes_match.group(1).strip() if notes_match else ""

        version_match = re.search(r'Latest tested version:\s*(\S+)', block)
        version = version_match.group(1) if version_match else ""

        raw_text_lines = []
        for line in block.splitlines():
            if not (line.strip().startswith("Tags:") or 
                    line.strip().startswith("Notes:") or 
                    line.strip().startswith("RawCode:") or 
                    line.strip().startswith("Latest tested version:")):
                raw_text_lines.append(line.rstrip())
        raw_text = "\n".join(raw_text_lines).strip()

        abilities[rawcode] = {
            "name": name,
            "tags": tags,
            "notes": notes,
            "latest_tested_version": version,
            "raw_text": raw_text
        }

    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(abilities, f, indent=4, ensure_ascii=False)

# Used to generate the ability_insights.json from the Ability Insight document
# https://docs.google.com/document/d/1z17FTnhyfVL87tJgLmwWks3Low6TuQ0tjfKHXBELWpo/edit?tab=t.0
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Convert ability text file to JSON.")
    parser.add_argument("input_file", help="Path to input text file")
    parser.add_argument("output_file", help="Path to output JSON file")
    args = parser.parse_args()

    parse_abilities(args.input_file, args.output_file)

```

`data/warcraft/icon_tags.json`:

```json
[
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackdragonroost",
        "tags": [
            "Black Dragon Roost",
            "Nether Dragon Roost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzedragon",
        "tags": [
            "Bronze Drake",
            "Bronze Dragon",
            "Bronze Dragon Whelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofdeathon",
        "tags": [
            "Orb of Annihilation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrollofregeneration",
        "tags": [
            "scrollofregeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndiablocar",
        "tags": [
            "Diablo Cart"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpywitch",
        "tags": [
            "Harpy Windwitch",
            "Harpy Storm-hag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbeastmaster",
        "tags": [
            "Beastmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishhealthon",
        "tags": [
            "Essence of Blight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnroguewizard",
        "tags": [
            "roguewizard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherodemonhunter",
        "tags": [
            "Demon Hunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwareagle",
        "tags": [
            "Spirit Hawk",
            "Thunder Hawk",
            "Summon Hawk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollhut1",
        "tags": [
            "icetrollhut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorboflightning",
        "tags": [
            "Orb of Lightning",
            "Melee Lightning Damage Bonus",
            "Item Attack Lightning Bonus (new)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelvenguardtower",
        "tags": [
            "Earth-Fury Tower",
            "High Elven Guard Tower",
            "Sky-Fury Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaosgrunt",
        "tags": [
            "Fel Orc Grunt"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnmarkoffire",
        "tags": [
            "Phoenix"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthoriummelee",
        "tags": [
            "Frostguard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenvenomedspear",
        "tags": [
            "Poison"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulbloodgill",
        "tags": [
            "Mur'gul Marauder",
            "Mur'gul Blood-Gill"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnriderlesshorse",
        "tags": [
            "Pack Horse",
            "Riderless Horse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkobold",
        "tags": [
            "Kobold Tunneler",
            "Kobold Taskmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstoneform",
        "tags": [
            "Stone Form Gargoyle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrazorback",
        "tags": [
            "Quillboar",
            "Spirit Pig",
            "Quillboar Hunter",
            "Razormane Brute",
            "Razormane Scout",
            "Feral Spirit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnaltarofdepths",
        "tags": [
            "Altar of the Depths"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsatyr",
        "tags": [
            "Satyr Soulstealer",
            "Satyr Hellcaller"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseal",
        "tags": [
            "Seal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaoswarlord",
        "tags": [
            "Mathog",
            "Orc Warchief"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelvenfarm",
        "tags": [
            "High Elven Farm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmechanicalcritter",
        "tags": [
            "Mechanical Critter"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnbash",
        "tags": [
            "Bash",
            "Maul"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollshaman",
        "tags": [
            "Ice Troll High Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodmage2",
        "tags": [
            "Blood Mage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngiantskeletonwarrior",
        "tags": [
            "giantskeletonwarrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwitchdoctoradept",
        "tags": [
            "Scepter of the Sea"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnammodump",
        "tags": [
            "Goblin Laboratory"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpenguin",
        "tags": [
            "Penguin",
            "Clockwork Penguin",
            "Penguin Squeek"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumandestroyer",
        "tags": [
            "Human Frigate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadshrine",
        "tags": [
            "Shrine",
            "Phat Lewt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngenericcreepbuilding",
        "tags": [
            "Ice Troll Hut",
            "Gnoll Hut",
            "Mur'gul Hut",
            "Centaur Tent",
            "Murloc Hut",
            "Harpy Nest",
            "Furbolg Hut",
            "Forest Troll Hut"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostmourne",
        "tags": [
            "Frostmourne Pedestal",
            "Life Steal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngenerichumanbuilding",
        "tags": [
            "City Building",
            "Infected Granary",
            "Grain Warehouse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfootman",
        "tags": [
            "Footman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodlust",
        "tags": [
            "Frenzy",
            "Bloodlust"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncancel",
        "tags": [
            "cancel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnetherdragonroost",
        "tags": [
            "netherdragonroost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanlumberupgrade2",
        "tags": [
            "humanlumberupgrade2"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnresistantskin",
        "tags": [
            "Resistant Skin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarblack",
        "tags": [
            "Tuskarr Chieftain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcwarlockhermit",
        "tags": [
            "orcwarlockhermit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinzeppelin",
        "tags": [
            "Zeppelin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndoomguard",
        "tags": [
            "Doom Guard",
            "Demonic Figurine",
            "Item Doom Guard Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndemolisher",
        "tags": [
            "Demolisher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletonarcher",
        "tags": [
            "Burning Archer",
            "Skeleton Archer",
            "Skeletal Marksman"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnthornshield",
        "tags": [
            "Spiked Shell",
            "Spiked Carapace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntreant",
        "tags": [
            "Ancient Protector"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndirewolf",
        "tags": [
            "Dire Wolf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbandit",
        "tags": [
            "Bandit",
            "Rogue",
            "Enforcer",
            "Jailor Kassan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesservoidwalker",
        "tags": [
            "lesservoidwalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedvial",
        "tags": [
            "enchantedvial"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmannoroth",
        "tags": [
            "Pit Lord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthornshield",
        "tags": [
            "Spiked Carapace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanitearmor",
        "tags": [
            "Arcanite Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshandris",
        "tags": [
            "Shandris"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspinycrab",
        "tags": [
            "Crab"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealoff",
        "tags": [
            "healoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnetherdragon",
        "tags": [
            "Nether Dragon",
            "Nether Dragon Hatchling",
            "Nether Drake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmetamorphosis",
        "tags": [
            "Demon Hunter",
            "Metamorphosis"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaunburrow",
        "tags": [
            "nagaunburrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthecaptain",
        "tags": [
            "Master Swordsman",
            "Captain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnberserkfortrolls",
        "tags": [
            "Berserk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillage",
        "tags": [
            "Night Elf Fishing Village"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaelemental",
        "tags": [
            "Sea Elemental",
            "Reef Elemental",
            "Summon Sea Elemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackdrake",
        "tags": [
            "blackdrake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhauntedmine",
        "tags": [
            "hauntedmine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderlizardsalamander",
        "tags": [
            "Salamander",
            "Salamander Lord",
            "Salamander Hatchling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbanditmage",
        "tags": [
            "Chaplain",
            "Dark Wizard",
            "Apprentice Wizard",
            "Rogue Wizard",
            "Renegade Wizard",
            "Blood Wizard",
            "Emissary",
            "Hydromancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgultidewarrior",
        "tags": [
            "Watery Minion",
            "Mur'gul Cliffrunner",
            "Mur'gul Tidewarrior",
            "Mur'gul Reaver"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagekid",
        "tags": [
            "villagekid"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfelguard",
        "tags": [
            "Bloodfiend",
            "Felguard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnoneheadedogremagi",
        "tags": [
            "oneheadedogremagi"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnecropolis",
        "tags": [
            "Necropolis"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmammoth",
        "tags": [
            "Icetusk Mammoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelvenfarm3",
        "tags": [
            "elvenfarm3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadshipyard",
        "tags": [
            "Undead Shipyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbearden",
        "tags": [
            "Barrow Den"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedtreeofeternity",
        "tags": [
            "corruptedtreeofeternity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolg",
        "tags": [
            "Polar Furbolg",
            "Polar Furbolg Champion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntreeofeternity",
        "tags": [
            "Tree of Eternity",
            "Corrupted Tree of Eternity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcmeleeuptwo",
        "tags": [
            "orcmeleeuptwo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavatar",
        "tags": [
            "Avatar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgpanda",
        "tags": [
            "Primal Pandaren"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadcaptureflag",
        "tags": [
            "Undead Flag",
            "Item Capture The Flag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritofvengeance",
        "tags": [
            "Avatar of Vengeance"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndefend",
        "tags": [
            "Defend",
            "Defend",
            "Passive Defense"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbluedragonspawn",
        "tags": [
            "Blue Dragonspawn Meddler",
            "Blue Dragonspawn Warrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagasummoner",
        "tags": [
            "Summoner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagnataur",
        "tags": [
            "Magnataur Warrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnregenerationaura",
        "tags": [
            "Aura of Blight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghostofkelthuzad",
        "tags": [
            "Kel'Thuzad"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnhardenedskin",
        "tags": [
            "Hardened Skin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodelflieutenant",
        "tags": [
            "bloodelflieutenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherofarseer",
        "tags": [
            "Far Seer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflyingsheep",
        "tags": [
            "flyingsheep"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngargoyle",
        "tags": [
            "Gargoyle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnapdragon",
        "tags": [
            "Submerged Snap Dragon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktrolltrapper",
        "tags": [
            "Dark Troll Warlord",
            "Dark Troll Trapper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsludgecreature",
        "tags": [
            "Sludge Monstrosity",
            "Sludge Flinger",
            "Sludge Minion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianziggurat",
        "tags": [
            "Nerubian Ziggurat"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbundleofgift",
        "tags": [
            "bundleofgift"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndestroyer",
        "tags": [
            "Destroyer",
            "Destroyer Form "
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrizzlybear",
        "tags": [
            "Misha",
            "Spirit Bear",
            "Raging Bear",
            "Summon Bear",
            "Summon Misha"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollwarden",
        "tags": [
            "Gnoll Warden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnessenceofaszune",
        "tags": [
            "essenceofaszune"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsentryward",
        "tags": [
            "Watcher Ward",
            "Sentry Ward",
            "Sentry Wards",
            "Rune of the Watcher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlichversion2",
        "tags": [
            "Lich"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnloaddwarf",
        "tags": [
            "loaddwarf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjunglebeast",
        "tags": [
            "Jungle Stalker",
            "Elder Jungle Stalker",
            "Enraged Jungle Stalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktroll",
        "tags": [
            "Dark Troll Berserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanadrain",
        "tags": [
            "Siphon Mana"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstormbrewmaster",
        "tags": [
            "Storm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunbrokenrager",
        "tags": [
            "unbrokenrager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphaseshift",
        "tags": [
            "Phase Shift"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvolcanus",
        "tags": [
            "volcanus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfallenpriest",
        "tags": [
            "fallenpriest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfelboar",
        "tags": [
            "Fel Boar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletalartifact",
        "tags": [
            "skeletalartifact"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherodeathknight",
        "tags": [
            "Death Knight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncoralbed",
        "tags": [
            "Coral Bed"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmindstaff",
        "tags": [
            "mindstaff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaosblademaster",
        "tags": [
            "Blademaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncastle",
        "tags": [
            "Castle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagerkid",
        "tags": [
            "Child"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwisphealon",
        "tags": [
            "Renew"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwateryminion",
        "tags": [
            "wateryminion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfarm",
        "tags": [
            "Farm",
            "Tiny Farm",
            "Build Tiny Farm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherobloodelfprince",
        "tags": [
            "Blood Mage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrocktower",
        "tags": [
            "Boulder Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancientofwonders",
        "tags": [
            "Ancient of Wonders"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollking",
        "tags": [
            "Gnoll Overseer",
            "Snarlmane the Bloodgorger",
            "Gnoll Warlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnupgrademoonglaive",
        "tags": [
            "upgrademoonglaive"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnabomination",
        "tags": [
            "Abomination"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnglacier",
        "tags": [
            "Frost Nova"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwaterelementallv3",
        "tags": [
            "waterelementallv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkeep",
        "tags": [
            "Keep"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreddragondevour",
        "tags": [
            "Devour"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntombofrelics",
        "tags": [
            "Tomb of Relics"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgshaman",
        "tags": [
            "Furbolg Elder Shaman",
            "Furbolg Shaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnusedsoulgem",
        "tags": [
            "Orb of Kil'jaeden",
            "Celestial Orb of Souls",
            "Soul Theft",
            "Item Soul Possession"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngryphonaviary",
        "tags": [
            "Gryphon Aviary"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollbeserker",
        "tags": [
            "Ice Troll Berserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhornofcenarius",
        "tags": [
            "Horn of Cenarius Pedestal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagerkid2",
        "tags": [
            "Child"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillboarhunter",
        "tags": [
            "quillboarhunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoldmine",
        "tags": [
            "Haunted Gold Mine",
            "Entangled Gold Mine",
            "Entangle Gold Mine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntransmute",
        "tags": [
            "Scepter of Avarice",
            "Transmute",
            "Item Transmute"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbanditlord",
        "tags": [
            "Bandit Lord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwalkerethereal",
        "tags": [
            "spiritwalkerethereal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarbrown",
        "tags": [
            "Tuskarr Healer",
            "Tuskarr Warrior",
            "Tuskarr Sorcerer",
            "Tuskarr Fighter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttroll",
        "tags": [
            "Forest Troll",
            "Forest Troll Warlord",
            "Forest Troll Berserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnabsorbmagic",
        "tags": [
            "Absorb Mana"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrexxar",
        "tags": [
            "Beastmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhuntress",
        "tags": [
            "Sentry",
            "Naisha",
            "Huntress"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstarwand",
        "tags": [
            "Wand of Lightning Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshrineofaszhara",
        "tags": [
            "Shrine of Azshara"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanbarracks",
        "tags": [
            "Barracks",
            "Tiny Barracks",
            "Build Tiny Barracks"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbluedemoness",
        "tags": [
            "Vile Tormentor",
            "Queen of Suffering",
            "Maiden of Pain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonroost",
        "tags": [
            "Bronze Dragon Roost",
            "Red Dragon Roost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndruidofthetalon",
        "tags": [
            "Druid of the Talon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadowhunter",
        "tags": [
            "Shadow Hunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagamyrmidonroyalguard",
        "tags": [
            "Naga Royal Guard",
            "Submerged Naga Royal Guard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletonwarrior",
        "tags": [
            "Giant Skeleton Warrior",
            "Greater Dark Minion",
            "Lesser Dark Minion",
            "Skeletal Minion",
            "Item Skeleton Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwisp",
        "tags": [
            "Wisp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnperiapt",
        "tags": [
            "Periapt of Vitality"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnziggurat",
        "tags": [
            "Ziggurat"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnecromancer",
        "tags": [
            "Necromancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwalloffire",
        "tags": [
            "Flame Strike",
            "Burning Oil"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheropaladin",
        "tags": [
            "Paladin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealingwave",
        "tags": [
            "Healing Wave"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhermitcrab",
        "tags": [
            "Hermit Crab"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsatyrshadowdancer",
        "tags": [
            "satyrshadowdancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfbattlecruiser",
        "tags": [
            "Night Elf Battleship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingassassin",
        "tags": [
            "avengingassassin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroarchmage",
        "tags": [
            "Archmage",
            "High Elf Archmage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnaltarofdarkness",
        "tags": [
            "Altar of Darkness"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheromountainking",
        "tags": [
            "Mountain King"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillbeast",
        "tags": [
            "Quilbeast",
            "Raging Quilbeast",
            "Dire Quilbeast",
            "Berserk Quilbeast",
            "Summon Quilbeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagetower",
        "tags": [
            "High Elven Barracks"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwandskull",
        "tags": [
            "Staff of Reanimation",
            "Wand of Negation",
            "Item Dispel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncagedillidan",
        "tags": [
            "Prison Wagon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslaughterhouse",
        "tags": [
            "Slaughterhouse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriest",
        "tags": [
            "Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntreeoflife",
        "tags": [
            "Tree of Life"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntotemofmight",
        "tags": [
            "totemofmight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletalorcgrunt",
        "tags": [
            "Skeletal Orc Grunt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbookofsummoning",
        "tags": [
            "Book of Summoning Pedestal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndryaddispelmagicoff",
        "tags": [
            "dryaddispelmagicoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanbattleship",
        "tags": [
            "Human Battleship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnraider",
        "tags": [
            "Raider",
            "Nazgrel",
            "Slave Master"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndrum",
        "tags": [
            "Warsong Battle Drums",
            "War Drums"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionbluesmall",
        "tags": [
            "Potion of Mana",
            "Item Mana Regain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulshadowcaster",
        "tags": [
            "Mur'gul Shadowcaster",
            "Mur'gul Snarecaster",
            "Watery Minion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndalaranmutant",
        "tags": [
            "Dalaran Mutant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingwatcheron",
        "tags": [
            "Spirit of Vengeance"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchenstormstout",
        "tags": [
            "chenstormstout"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendragonspawnsorcerer",
        "tags": [
            "greendragonspawnsorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngranitegolem",
        "tags": [
            "granitegolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeeplordrevenant",
        "tags": [
            "Deeplord Revenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnship",
        "tags": [
            "Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiderblack",
        "tags": [
            "Black Spider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmisha",
        "tags": [
            "misha"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsatyrtrickster",
        "tags": [
            "Satyr Trickster",
            "Satyr Shadowdancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarmorgolem",
        "tags": [
            "Battle Golem",
            "Siege Golem",
            "War Golem",
            "Bladebane Armor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbasicstruct",
        "tags": [
            "Build (Naga)",
            "Build (Orc)",
            "Build (Neutral)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeathcoil",
        "tags": [
            "Death Coil"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnacolyte",
        "tags": [
            "Acolyte",
            "Deceiver",
            "Heretic",
            "Fallen Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarachnathid",
        "tags": [
            "Barbed Arachnathid",
            "Burrowed Barbed Arachnathid",
            "Arachnathid Earth-borer "
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnduneworm",
        "tags": [
            "Dune Worm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnowlscoutlv3",
        "tags": [
            "owlscoutlv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostwyrm",
        "tags": [
            "Sapphiron",
            "Frost Wyrm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbanshee",
        "tags": [
            "Banshee"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnaltarofelders",
        "tags": [
            "Altar of Elders"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaursorcerer",
        "tags": [
            "centaursorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmaidenofpain",
        "tags": [
            "maidenofpain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarachnathidpurple",
        "tags": [
            "Overlord Arachnathid"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreenhydra",
        "tags": [
            "Ancient Hydra",
            "Hydra Hatchling",
            "Elder Hydra"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsleep",
        "tags": [
            "Sleep (Stun)",
            "Soul Preservation",
            "Sleep (Pause)",
            "Dark Conversion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnevilillidan",
        "tags": [
            "Demon Hunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnplaguecloud",
        "tags": [
            "Disease"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolgshaman",
        "tags": [
            "Polar Furbolg Elder Shaman",
            "Polar Furbolg Shaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfemaleelfvillager",
        "tags": [
            "High Elf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfernalcannon",
        "tags": [
            "Infernal Machine",
            "Infernal Contraption"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndryad",
        "tags": [
            "Dryad"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmountaingiant",
        "tags": [
            "Mountain Giant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherotaurenchieftain",
        "tags": [
            "Tauren Chieftain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshaman",
        "tags": [
            "Shaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnaturesblessings",
        "tags": [
            "naturesblessings"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwaygate",
        "tags": [
            "Way Gate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomebrown",
        "tags": [
            "Tome of Experience",
            "Item Experience Gain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlionhorn",
        "tags": [
            "The Lion Horn of Stormwind"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicytreasurebox",
        "tags": [
            "Icy Treasure Box"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntheblackarrowonoff",
        "tags": [
            "Black Arrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsasquatchancient",
        "tags": [
            "sasquatchancient"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnalbatross",
        "tags": [
            "Albatross"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrifleman",
        "tags": [
            "Rifleman",
            "Marine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpig",
        "tags": [
            "Pig"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwargolem",
        "tags": [
            "wargolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostbear",
        "tags": [
            "Polar Bear",
            "Giant Polar Bear"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjuggernaut",
        "tags": [
            "Orc Juggernaught"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurkhan",
        "tags": [
            "Centaur Sorcerer",
            "Centaur Khan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrost",
        "tags": [
            "Slowed"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnentanglingroots",
        "tags": [
            "Entangling Roots"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedmoonarmor",
        "tags": [
            "improvedmoonarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpeasant",
        "tags": [
            "Peasant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellbreaker",
        "tags": [
            "High King",
            "Blood Elf Lieutenant",
            "Spellbreaker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsheep",
        "tags": [
            "Flying Sheep"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwyvern",
        "tags": [
            "Wind Rider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelfvillager",
        "tags": [
            "Worker",
            "Runner",
            "High Elf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngem",
        "tags": [
            "Gem Fragment",
            "Gem of True Seeing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinlandmine",
        "tags": [
            "Goblin Land Mine",
            "Goblin Land Mines",
            "Item Area tree/wall damage",
            "Item Place Goblin Land Mine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforge",
        "tags": [
            "War Mill"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwindwalkon",
        "tags": [
            "Wind Walk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishhealth",
        "tags": [
            "Essence of Blight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishmanaon",
        "tags": [
            "Spirit Touch",
            "Replenish Mana"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtntrueshot",
        "tags": [
            "Trueshot Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnracoon",
        "tags": [
            "Raccoon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseawitch",
        "tags": [
            "Naga Siren"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofdeath",
        "tags": [
            "orbofdeath"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadowstrike",
        "tags": [
            "Shadow Strike"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpowergenerator",
        "tags": [
            "Power Generator"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkoboldgeomancer",
        "tags": [
            "Kobold Geomancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjunkgolem",
        "tags": [
            "Goblin Blaster",
            "Shredder"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderlizard",
        "tags": [
            "Thunder Lizard",
            "Lightning Lizard",
            "Storm Wyrm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnglaivethrower",
        "tags": [
            "Glaive Thrower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubian",
        "tags": [
            "Nerubian Warrior",
            "Spiderling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntaunt",
        "tags": [
            "Taunt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackdragonwhelp",
        "tags": [
            "blackdragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderbloombulb",
        "tags": [
            "thunderbloombulb"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfortress",
        "tags": [
            "Fortress"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpoisonarrow",
        "tags": [
            "poisonarrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseigeenginewithmissles",
        "tags": [
            "Siege Engine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmeatwagon",
        "tags": [
            "Meat Wagon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbarrel",
        "tags": [
            "Keg of Ale",
            "Keg of Thunderwater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndemoness",
        "tags": [
            "Succubus",
            "Vile Temptress"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnsunderingblades",
        "tags": [
            "Sundering Blades"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnflakcannons",
        "tags": [
            "Flak Cannons"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavataron",
        "tags": [
            "Avatar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroalchemist",
        "tags": [
            "Alchemist"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroblademaster",
        "tags": [
            "Blademaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmonsterlure",
        "tags": [
            "Monster Lure",
            "Shimmerglaze Roast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwendigo",
        "tags": [
            "Wendigo",
            "Wendigo Shaman",
            "Ancient Wendigo",
            "Elder Wendigo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnacidbomb",
        "tags": [
            "Acid Bomb"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntentacle",
        "tags": [
            "Tentacle",
            "Spawn Tentacle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlocnightcrawler",
        "tags": [
            "Murloc Nightcrawler",
            "Murloc Sorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslow",
        "tags": [
            "Slow",
            "Item Slow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancientofthemoon",
        "tags": [
            "Ancient of Wind"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphatlewt",
        "tags": [
            "phatlewt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedfrosttower",
        "tags": [
            "Advanced Cold Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagicvault",
        "tags": [
            "Magic Vault"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndoom",
        "tags": [
            "Doom"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgtracker",
        "tags": [
            "Furbolg Tracker",
            "Idol of the Wild",
            "Item Furbolg Tracker Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserinvisibility",
        "tags": [
            "Potion of Invisibility",
            "Item Temporary Invisibility"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcishtransport",
        "tags": [
            "Orc Transport Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwindwalkoff",
        "tags": [
            "windwalkoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishmanaoff",
        "tags": [
            "replenishmanaoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblacksmith",
        "tags": [
            "Blacksmith",
            "Tiny Blacksmith",
            "Build Tiny Blacksmith"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrolltrapper",
        "tags": [
            "Forest Troll Trapper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwaterelementallv2",
        "tags": [
            "waterelementallv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnzergling",
        "tags": [
            "Zergling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnaturetouchgrow",
        "tags": [
            "Ironwood Branch",
            "Vine of Purification"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\pasbtnengineeringupgrade",
        "tags": [
            "Engineering Upgrade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntome",
        "tags": [
            "Tome of Intelligence",
            "Tome of Agility",
            "Tome of Strength +2",
            "Tome of Agility +2",
            "Tome of Intelligence +2",
            "Item Agility Gain",
            "Item Strength Gain",
            "Item Intelligence Gain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmercenarycamp",
        "tags": [
            "Mercenary Camp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaplain",
        "tags": [
            "chaplain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrolloftownportal",
        "tags": [
            "Scroll of Healing",
            "Powerup Area Healing ",
            "Item Area Healing",
            "Powerup Area Healing Lesser",
            "Powerup Area Healing Greater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaoskotobeast",
        "tags": [
            "Fel Orc Kodo Beast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnowlscoutlv2",
        "tags": [
            "owlscoutlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpyqueen",
        "tags": [
            "Harpy Queen"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaweaponup3",
        "tags": [
            "nagaweaponup3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarksummoning",
        "tags": [
            "Diamond of Summoning",
            "Dark Summoning"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseigeengine",
        "tags": [
            "Siege Engine",
            "War Wagon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolghut1",
        "tags": [
            "furbolghut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadbattleship",
        "tags": [
            "Undead Battleship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmove",
        "tags": [
            "move"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedenergytower",
        "tags": [
            "Advanced Energy Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgalslave",
        "tags": [
            "Mur'gul Slave"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofdarkness",
        "tags": [
            "Shadow Orb +2",
            "Orb of Darkness",
            "Shadow Orb +5",
            "Shadow Orb Fragment",
            "Shadow Orb +4",
            "Shadow Orb +1",
            "Shadow Orb +3",
            "Shadow Orb +9",
            "Shadow Orb +7",
            "Shadow Orb +8",
            "Shadow Orb +6",
            "Shadow Orb +10",
            "Item Attack Black Arrow Bonus",
            "Shadow Orb Ability"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlocplaguebearer",
        "tags": [
            "murlocplaguebearer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollwarlord",
        "tags": [
            "foresttrollwarlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnogremagi",
        "tags": [
            "Ogre Magi"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnfeedback",
        "tags": [
            "Feedback"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreincarnation",
        "tags": [
            "Item Reincarnation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchimaeraroost",
        "tags": [
            "Chimaera Roost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanwatchtower",
        "tags": [
            "Scout Tower",
            "Ivory Tower",
            "Build Tiny Scout Tower "
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntransport",
        "tags": [
            "Transport Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmaskofdeath",
        "tags": [
            "Mask of Death",
            "Item Life Steal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumantransport",
        "tags": [
            "Human Transport Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkgreen",
        "tags": [
            "Makrura Deepseer",
            "Makrura Tidecaller"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthrall",
        "tags": [
            "Far Seer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsylvanuswindrunner",
        "tags": [
            "Ranger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkblue",
        "tags": [
            "Makrura Tidal Lord"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnpoisonsting",
        "tags": [
            "Poison Sting"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspider",
        "tags": [
            "Giant Spider",
            "Spiderling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmarkoffire",
        "tags": [
            "Phoenix",
            "Phoenix Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplay-speedup",
        "tags": [
            "replay-speedup"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscout",
        "tags": [
            "Owl Scout"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntichondrius",
        "tags": [
            "Dreadlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntaurenhut",
        "tags": [
            "Tauren Tent"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntaurentotem",
        "tags": [
            "Tauren Totem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaweaponup1",
        "tags": [
            "nagaweaponup1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletonmage",
        "tags": [
            "Skeletal Mage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrockgolem",
        "tags": [
            "Moss Covered Granite Golem",
            "Rock Golem",
            "Mud Golem",
            "Guardian Golem",
            "Defender Golem",
            "Stone Token",
            "Item Rock Golem Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionofdivinity",
        "tags": [
            "Potion of Divinity",
            "Item Temporary Invulnerability",
            "Item Divine Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbattleroar",
        "tags": [
            "Roar",
            "Battle Roar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheal",
        "tags": [
            "Heal",
            "Mana Regeneration",
            "Life Regeneration Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsupportbeam",
        "tags": [
            "Support Column"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunbroken",
        "tags": [
            "Unbroken Darkhunter",
            "Unbroken Darkweaver",
            "Unbroken Rager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncryptfiend",
        "tags": [
            "Crypt Fiend",
            "Burrowed Crypt Fiend"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntimberwolf",
        "tags": [
            "Giant Wolf",
            "Giant Frost Wolf",
            "Dire Frost Wolf",
            "Timber Wolf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwirtsotherleg",
        "tags": [
            "Wirt's Other Leg"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrunt",
        "tags": [
            "Gar'thok",
            "Grunt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstag",
        "tags": [
            "Stag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnboneyard",
        "tags": [
            "Boneyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpeon",
        "tags": [
            "Peon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblizzard",
        "tags": [
            "Blizzard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguardtower",
        "tags": [
            "Guard Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanesanctum",
        "tags": [
            "Arcane Sanctum"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvoodoolounge",
        "tags": [
            "Voodoo Lounge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntrollbatrider",
        "tags": [
            "Batrider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanarcanetower",
        "tags": [
            "Arcane Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpitlord",
        "tags": [
            "Pit Lord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbluemagnataur",
        "tags": [
            "Magnataur Destroyer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncyclone",
        "tags": [
            "Cyclone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrobogoblin",
        "tags": [
            "Robo-Goblin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodelfworker",
        "tags": [
            "bloodelfworker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnent",
        "tags": [
            "Treant",
            "Force of Nature"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnowlbear",
        "tags": [
            "Wildkin",
            "Enraged Wildkin",
            "Berserk Wildkin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkred",
        "tags": [
            "Summoned Prawn",
            "Makrura Prawn",
            "Makrura Pooldweller",
            "Makrura Snapper",
            "Summon Prawns"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcher",
        "tags": [
            "Archer",
            "Dismount"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwalker",
        "tags": [
            "Spirit Walker",
            "Baine",
            "Corporeal Form"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriestmaster",
        "tags": [
            "priestmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbrilliance",
        "tags": [
            "Mindstaff",
            "Brilliance Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncheese",
        "tags": [
            "Cheese"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghost",
        "tags": [
            "Wraith",
            "Sylvanas Windrunner",
            "Ghost",
            "Sea Witch"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollshadowpriest",
        "tags": [
            "Ice Troll Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwellspring",
        "tags": [
            "wellspring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolg",
        "tags": [
            "Furbolg",
            "Furbolg Champion",
            "Item Blue Dragonspawn Overseer Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaihut",
        "tags": [
            "Draenei Barracks",
            "Draenei Hut",
            "Seer's Den"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorccaptureflag",
        "tags": [
            "Orc Flag",
            "Item Capture The Flag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguldan",
        "tags": [
            "Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcdestroyer",
        "tags": [
            "Orc Frigate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzedrake",
        "tags": [
            "bronzedrake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagroththedefender",
        "tags": [
            "magroththedefender"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaur",
        "tags": [
            "Centaur Drudge",
            "Centaur Outrunner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneattree",
        "tags": [
            "Eat Tree"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfelguardblue",
        "tags": [
            "Overlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsludgeflinger",
        "tags": [
            "sludgeflinger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpurplefelhound",
        "tags": [
            "Fel Beast",
            "Fel Ravager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofvenom",
        "tags": [
            "Orb of Venom",
            "Item Attack Poison Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntower",
        "tags": [
            "tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmishalv3",
        "tags": [
            "mishalv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrevenant",
        "tags": [
            "Fire Revenant",
            "Lich King",
            "Frost Revenant",
            "Revenant of the Seas",
            "Revenant of the Depths",
            "Revenant of the Tides",
            "Ice Revenant",
            "Death Revenant",
            "Lightning Revenant",
            "Crown of the Deathlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncreaturecarapace",
        "tags": [
            "creaturecarapace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspidercrab",
        "tags": [
            "Spider Crab Limbripper",
            "Spider Crab Shorecrawler",
            "Spider Crab Behemoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfirebolt",
        "tags": [
            "Firebolt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsludgemontrosity",
        "tags": [
            "sludgemontrosity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncage",
        "tags": [
            "Wind Rider Cage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwandofshadowsight",
        "tags": [
            "Wand of Shadowsight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthickfur",
        "tags": [
            "thickfur"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnazuredragon",
        "tags": [
            "Blue Dragon",
            "Blue Drake",
            "Sapphiron",
            "Blue Dragon Whelp",
            "Blue Drake Egg"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedgemstoneobelisk",
        "tags": [
            "enchantedgemstoneobelisk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscroll",
        "tags": [
            "Scroll of Protection",
            "Item Temporary Area Armor Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsirenmaster",
        "tags": [
            "sirenmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedent",
        "tags": [
            "Plague Treant",
            "Corrupted Treant",
            "Poison Treant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpy",
        "tags": [
            "Harpy Scout",
            "Harpy Rogue"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrabtree",
        "tags": [
            "War Club"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnzombie",
        "tags": [
            "Zombie"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrosttower",
        "tags": [
            "Nerubian Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpurpledragonspawn",
        "tags": [
            "Blue Dragonspawn Overseer",
            "Engraved Scale"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneredarwarlockpurple",
        "tags": [
            "Eredar Diabolist",
            "Eredar Sorcerer",
            "Eredar Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedunholyarmor",
        "tags": [
            "improvedunholyarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktrollshadowpriest",
        "tags": [
            "Dark Troll Shadow Priest",
            "Dark Troll High Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanlumbermill",
        "tags": [
            "Lumber Mill",
            "Tiny Lumber Mill",
            "Build Tiny Lumber Mill"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunsummonbuilding",
        "tags": [
            "Unsummon",
            "Unsummon Building"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnearthbrewmaster",
        "tags": [
            "Earth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinsapper",
        "tags": [
            "Engineer Gazlowe",
            "Sapper"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnflyingmachinetruesight",
        "tags": [
            "True Sight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarkwizard",
        "tags": [
            "darkwizard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranai",
        "tags": [
            "Draenei Stalker",
            "Draenei Guardian",
            "Draenei Laborer",
            "Draenei Vindicator",
            "Draenei Darkslayer",
            "Draenei Protector",
            "Draenei Watcher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcwarlockred",
        "tags": [
            "Drak'thul"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostarmoron",
        "tags": [
            "Frost Armor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfaeriedragon",
        "tags": [
            "Faerie Dragon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvarimathras",
        "tags": [
            "varimathras"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlordnicholasbuzan",
        "tags": [
            "lordnicholasbuzan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwandofcyclone",
        "tags": [
            "Wand of the Wind"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflyingmachine",
        "tags": [
            "Flying Machine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackdragon",
        "tags": [
            "Black Dragon",
            "Searinox",
            "Black Dragon Whelp",
            "Black Drake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagerman1",
        "tags": [
            "Villager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnportal",
        "tags": [
            "Zone Indicator",
            "Portal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionofvampirism",
        "tags": [
            "Vampiric Potion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderlizardvizier",
        "tags": [
            "Salamander",
            "Salamander Vizier"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseersden",
        "tags": [
            "seersden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhighelvenarcher",
        "tags": [
            "Archer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderlizardegg",
        "tags": [
            "Thunder Phoenix Egg",
            "Thunder Lizard Egg"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaburrow",
        "tags": [
            "Submerge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianqueen",
        "tags": [
            "Nerubian Webspinner",
            "Nerubian Queen"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmarine",
        "tags": [
            "Terran Marine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwispsplode",
        "tags": [
            "Detonate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpigfarm",
        "tags": [
            "Pig Farm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspidergreen",
        "tags": [
            "Forest Spider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionpurple",
        "tags": [
            "potionpurple"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnplagueent",
        "tags": [
            "plagueent"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnzigguratupgrade",
        "tags": [
            "Spirit Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarnomad",
        "tags": [
            "tuskaarnomad"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagnataurbrown",
        "tags": [
            "Magnataur Reaver"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherodreadlord",
        "tags": [
            "Dreadlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaoswolfrider",
        "tags": [
            "Fel Orc Raider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreathall",
        "tags": [
            "Great Hall",
            "Tiny Great Hall"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadtransport",
        "tags": [
            "Undead Transport Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedunholystrength",
        "tags": [
            "Runed Gauntlets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedtreeoflife",
        "tags": [
            "Corrupted Tree of Life"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpocketfactory",
        "tags": [
            "Pocket Factory"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcaniteranged",
        "tags": [
            "arcaniteranged"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntreeofages",
        "tags": [
            "Tree of Ages",
            "Corrupted Tree of Ages"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkeeperofthegrove",
        "tags": [
            "Keeper of the Grove",
            "Demigod"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsunkey",
        "tags": [
            "Sun Key"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollshadowpriest",
        "tags": [
            "Forest Troll Shadow Priest",
            "Forest Troll High Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreddragon",
        "tags": [
            "Red Dragon Whelp",
            "Red Drake",
            "Red Drake Egg",
            "Item Blue Drake Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabs",
        "tags": [
            "Carrion Beetle",
            "Burrowed Carrion Beetle",
            "Carrion Beetles"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncurseon",
        "tags": [
            "Curse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunstableconcoction",
        "tags": [
            "Unstable Concoction"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsamuro",
        "tags": [
            "samuro"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhallofthedead",
        "tags": [
            "Halls of the Dead"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnplaguecloud",
        "tags": [
            "Disease Cloud"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcwarlock",
        "tags": [
            "Stormreaver Warlock",
            "Stormreaver Necrolyte",
            "Stormreaver Apprentice",
            "Stormreaver Hermit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaturtlegreen",
        "tags": [
            "Gargantuan Sea Turtle",
            "Giant Sea Turtle",
            "Sea Turtle Hatchling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskink",
        "tags": [
            "Skink"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbluedragonroost",
        "tags": [
            "Blue Dragon Roost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendrake",
        "tags": [
            "greendrake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncop",
        "tags": [
            "Circle of Power"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvulture",
        "tags": [
            "Vulture"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngryphonrider",
        "tags": [
            "Gryphon Rider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpandarenbrewmaster",
        "tags": [
            "Brewmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmalfurionwithoutstag",
        "tags": [
            "Keeper of the Grove"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodelfpeasant",
        "tags": [
            "Blood Elf Engineer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiderblue",
        "tags": [
            "Spitting Spider",
            "Brood Mother"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndruidoftheclaw",
        "tags": [
            "Druid of the Claw"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedancientprotector",
        "tags": [
            "Corrupted Ancient Protector"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedmoonwell",
        "tags": [
            "Corrupted Moon Well"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagerman",
        "tags": [
            "Villager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancestralspirit",
        "tags": [
            "Ancestral Spirit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaturtlered",
        "tags": [
            "Dragon Turtle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntrollburrow",
        "tags": [
            "Burrow",
            "Fel Burrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnentrapmentward",
        "tags": [
            "Shamanic Totem",
            "Totem of Might",
            "Item Purge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedrocktower",
        "tags": [
            "Advanced Boulder Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncritterchicken",
        "tags": [
            "Chicken"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhuntershall",
        "tags": [
            "Hunter's Hall"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnglyph",
        "tags": [
            "Glyph of Omniscience",
            "Glyph of Purification",
            "Glyph of Ultravision",
            "Sacred Relic",
            "Glyph of Fortification"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflametower",
        "tags": [
            "Flame Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnoll",
        "tags": [
            "Gnoll Brute"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflare",
        "tags": [
            "Flare Gun"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfernalstone",
        "tags": [
            "Inferno Stone",
            "Rain of Chaos"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagamyrmidon",
        "tags": [
            "Submerged Naga Myrmidon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplay-loop",
        "tags": [
            "replay-loop"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenragedjunglebeast",
        "tags": [
            "enragedjunglebeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchimaera",
        "tags": [
            "Chimaera"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninnerfire",
        "tags": [
            "Inner Fire"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtndrum",
        "tags": [
            "War Drums"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnaisha",
        "tags": [
            "naisha"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunholyaura",
        "tags": [
            "Helm of Battlethirst",
            "Unholy Aura"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnscout",
        "tags": [
            "True Sight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbeastiary",
        "tags": [
            "Beastiary"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncrypt",
        "tags": [
            "Crypt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenergytower",
        "tags": [
            "Energy Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrollofprotection",
        "tags": [
            "Scroll of Mana",
            "Note to Jaina Proudmoore",
            "Item Area Mana Regain",
            "Rune Area Mana Regain",
            "Rune Area Mana Regain Greater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarmoredoge",
        "tags": [
            "Stonemaul Warchief"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncloakofflames",
        "tags": [
            "Cloak of Flames",
            "Item Immolation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmishalv4",
        "tags": [
            "mishalv4"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndwarfcar",
        "tags": [
            "Dwarf Cart"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealingward",
        "tags": [
            "Healing Ward",
            "Healing Wards",
            "Healing Ward Aura",
            "Regeneration Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncirclet",
        "tags": [
            "Circlet of Nobility",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvoidwalker",
        "tags": [
            "Lesser Voidwalker",
            "Greater Voidwalker",
            "Elder Voidwalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfarsight",
        "tags": [
            "Far Sight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnladyvashj",
        "tags": [
            "ladyvashj"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarkportal",
        "tags": [
            "Dimensional Gate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnravenform",
        "tags": [
            "Medivh",
            "Druid of the Talon",
            "Storm Crow Form"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarachnathidgreen",
        "tags": [
            "Crystal Arachnathid",
            "Warrior Arachnathid"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnfragmentationbombs",
        "tags": [
            "Fragmentation Shards"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnecklace",
        "tags": [
            "Necklace of Spell Immunity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntent3",
        "tags": [
            "tent3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrazormanechief",
        "tags": [
            "Razormane Medicine Man",
            "Razormane Chieftain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwhirlwind",
        "tags": [
            "Bladestorm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackmammoth",
        "tags": [
            "Dire Mammoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritlodge",
        "tags": [
            "Spirit Lodge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofnegation",
        "tags": [
            "Staff of Negation",
            "Item Dispel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfirebrewmaster",
        "tags": [
            "Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimpale",
        "tags": [
            "Impale"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnazuredragonwhelp",
        "tags": [
            "azuredragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsoulburn",
        "tags": [
            "Soul Burn"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvanceddeathtower",
        "tags": [
            "Advanced Death Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwandofmanasteal",
        "tags": [
            "Wand of Mana Stealing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnetherdrake",
        "tags": [
            "netherdrake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrollofhaste",
        "tags": [
            "Scroll of Speed",
            "Scroll of Haste",
            "Rune of Speed"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhalahkthelifebringer",
        "tags": [
            "halahkthelifebringer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnaltarofstorms",
        "tags": [
            "Altar of Storms"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgelder",
        "tags": [
            "Furbolg Ursa Warrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorctower",
        "tags": [
            "Watch Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunholyfrenzy",
        "tags": [
            "Unholy Frenzy",
            "Incite Unholy Frenzy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnantonidas",
        "tags": [
            "antonidas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbansheeranger",
        "tags": [
            "Dark Ranger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbanish",
        "tags": [
            "Banish"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsunderingblades",
        "tags": [
            "sunderingblades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbash",
        "tags": [
            "bash"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhippogriffrider",
        "tags": [
            "Hippogryph Rider",
            "Mount Hippogryph",
            "Pick up Archer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwandofneutralization",
        "tags": [
            "Wand of Neutralization",
            "Ray of Disruption",
            "Item Chain Dispel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrolloftheunholylegion",
        "tags": [
            "scrolloftheunholylegion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnamulet",
        "tags": [
            "Amulet of Recall",
            "Item Recall"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletalorcchampion",
        "tags": [
            "Skeletal Orc Champion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghostmage",
        "tags": [
            "Ghostly Archmage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcbattlestandard",
        "tags": [
            "Battle Standard",
            "Item Orcish Battle Standard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfountainoflife",
        "tags": [
            "Fountain of Mana",
            "Fountain of Health",
            "Fountain of Power"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillboar",
        "tags": [
            "quillboar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninnerfireon",
        "tags": [
            "Inner Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntauren",
        "tags": [
            "Tauren"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorpseexplode",
        "tags": [
            "Finger of Death",
            "Finger of Pain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsorceressmaster",
        "tags": [
            "Drek'thar's Spellbook",
            "Gerard's Lost Ledger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaidemolisher",
        "tags": [
            "dranaidemolisher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwarden2",
        "tags": [
            "Warden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbanditspearthrower",
        "tags": [
            "Brigand",
            "Assassin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhelmofbattlethirst",
        "tags": [
            "helmofbattlethirst"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmassteleport",
        "tags": [
            "Mass Teleport"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendragonspawn",
        "tags": [
            "Blue Dragonspawn Apprentice",
            "Blue Dragonspawn Sorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwarstomp",
        "tags": [
            "War Stomp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngarithos",
        "tags": [
            "Dark Knight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmilitia",
        "tags": [
            "Militia"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjaina",
        "tags": [
            "Archmage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnglexchange",
        "tags": [
            "glexchange"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranailaborer",
        "tags": [
            "dranailaborer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfleshgolem",
        "tags": [
            "Flesh Golem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntyrande",
        "tags": [
            "tyrande"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurion",
        "tags": [
            "Keeper of the Grove"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsacrificialpit",
        "tags": [
            "Sacrificial Pit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfrunner",
        "tags": [
            "Night Elf Runner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnanasteriansunstrider",
        "tags": [
            "anasteriansunstrider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspawninggrounds",
        "tags": [
            "Spawning Grounds"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolgelder",
        "tags": [
            "Polar Furbolg Ursa Warrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeathrevenant",
        "tags": [
            "deathrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserclaritypotion",
        "tags": [
            "Lesser Clarity Potion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwyvernrider",
        "tags": [
            "Wind Rider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrolluber",
        "tags": [
            "Scroll of Town Portal",
            "Item Town Portal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherowarden",
        "tags": [
            "Warden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaosgrom",
        "tags": [
            "Blademaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnantimagicshell",
        "tags": [
            "Anti-magic Shell",
            "Summoning Ritual"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeathtower",
        "tags": [
            "Death Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnresistmagic",
        "tags": [
            "resistmagic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaargold",
        "tags": [
            "Tuskarr Trapper",
            "Tuskarr Spearman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlavaspawn",
        "tags": [
            "Lava Spawn",
            "Summon Lava Spawn"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsummonwaterelemental",
        "tags": [
            "Enraged Elemental",
            "Water Elemental",
            "Berserk Elemental",
            "Summon Water Elemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntemp",
        "tags": [
            "Sammy!",
            "Kobold Shoveler",
            "Mind Rot",
            "Ethereal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedflametower",
        "tags": [
            "Advanced Flame Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriestessofthemoon",
        "tags": [
            "Priestess of the Moon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspidersilkbroach",
        "tags": [
            "Spider Silk Broach"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhex",
        "tags": [
            "Frog",
            "Hex"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendragon",
        "tags": [
            "Green Drake",
            "Green Dragon Whelp",
            "Tharifas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillbeastlv2",
        "tags": [
            "quillbeastlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurloc",
        "tags": [
            "Murloc Tiderunner",
            "Murloc Huntsman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetroll",
        "tags": [
            "Ice Troll Trapper",
            "Ice Troll Warlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntempleofthedamned",
        "tags": [
            "Temple of the Damned"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancestralstaff",
        "tags": [
            "ancestralstaff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntempleoftides",
        "tags": [
            "Temple of Tides"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnazgrel",
        "tags": [
            "nazgrel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetuskmammoth",
        "tags": [
            "icetuskmammoth"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnskeletonmage",
        "tags": [
            "Skeletal Mastery"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfemaleelfvillage",
        "tags": [
            "femaleelfvillage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollarcher",
        "tags": [
            "Gnoll Assassin",
            "Gnoll Poacher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagicalsentry",
        "tags": [
            "magicalsentry"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbarracks",
        "tags": [
            "Barracks"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfernal",
        "tags": [
            "Infernal",
            "Inferno"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnakama",
        "tags": [
            "akama"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaseawitch",
        "tags": [
            "Sea Witch"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhelmutpurple",
        "tags": [
            "Crown of Kings +5",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaospeon",
        "tags": [
            "Fel Peon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillspray",
        "tags": [
            "Quill Spray"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaiakama",
        "tags": [
            "Elder Sage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmirrorimage",
        "tags": [
            "Mirror Image"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaoswarlockgreen",
        "tags": [
            "Orc Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarthas",
        "tags": [
            "Paladin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfelhound",
        "tags": [
            "Spirit Beast",
            "Lesser Spirit Beast",
            "Fel Stalker",
            "Greater Spirit Beast",
            "Spiked Collar",
            "Item Fel Stalker Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnuproot",
        "tags": [
            "uproot"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinshipyard",
        "tags": [
            "Goblin Shipyard",
            "Orc Shipyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforgottenone",
        "tags": [
            "Forgotten One"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedbows",
        "tags": [
            "improvedbows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnholybolt",
        "tags": [
            "Holy Light"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherocryptlord",
        "tags": [
            "Crypt Lord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnraisedeadon",
        "tags": [
            "Raise Dead"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsearingblade",
        "tags": [
            "searingblade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulreaver",
        "tags": [
            "murgulreaver"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaimage",
        "tags": [
            "Draenei Harbinger",
            "Draenei Disciple",
            "Draenei Seer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblood&ghostkey",
        "tags": [
            "Magic Key Chain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplay-pause",
        "tags": [
            "replay-pause"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnogrelord",
        "tags": [
            "Ogre Lord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadairbarge",
        "tags": [
            "Sky Barge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstasistrap",
        "tags": [
            "Stasis Trap"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonhawk",
        "tags": [
            "Dragonhawk Rider",
            "Dragon Hawk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagerwoman",
        "tags": [
            "Villager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedgemstone",
        "tags": [
            "Enchanted Gemstone Obelisk",
            "Thunderlizard Diamond"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagiclariet",
        "tags": [
            "Aerial Shackles"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndalaranreject",
        "tags": [
            "Dalaran Reject"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedancientofwar",
        "tags": [
            "Corrupted Ancient of War"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaichiefhut",
        "tags": [
            "Draenei Haven",
            "Draenei Chieftain's Hut"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurarcher",
        "tags": [
            "Centaur Archer",
            "Centaur Impaler"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnstormhammer",
        "tags": [
            "Storm Hammers"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntalisman",
        "tags": [
            "Talisman of Evasion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolgtracker",
        "tags": [
            "Polar Furbolg Tracker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedstrengthofthewild",
        "tags": [
            "advancedstrengthofthewild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheadhunterberserker",
        "tags": [
            "Berserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadowwolflv3",
        "tags": [
            "shadowwolflv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpurge",
        "tags": [
            "Purge",
            "Item Purge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlocflesheater",
        "tags": [
            "Murloc Flesheater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsasquatch",
        "tags": [
            "Sasquatch Oracle",
            "Ancient Sasquatch"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnglove",
        "tags": [
            "Gloves of Haste",
            "Item Attack Speed Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntinycastle",
        "tags": [
            "Tiny Castle",
            "Build Tiny Castle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelftransport",
        "tags": [
            "Night Elf Transport Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurimpaler",
        "tags": [
            "centaurimpaler"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnclockwerkgoblin",
        "tags": [
            "Clockwerk Goblin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbearform",
        "tags": [
            "Druid of the Claw",
            "Bear Form"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmarksmanship",
        "tags": [
            "Marksmanship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbattleship",
        "tags": [
            "battleship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndemongate",
        "tags": [
            "Demon Gate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfacelessone",
        "tags": [
            "Faceless One Terror",
            "Faceless One Deathbringer",
            "Faceless One Trickster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletonminion",
        "tags": [
            "skeletonminion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmarketplace",
        "tags": [
            "Fruit Stand"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianspiderlord",
        "tags": [
            "Nerubian Spider Lord",
            "Nerubian Seer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncatapult",
        "tags": [
            "Draenei Demolisher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfernalflamecannon",
        "tags": [
            "Infernal Juggernaut"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplay-play",
        "tags": [
            "replay-play"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfdestroyer",
        "tags": [
            "Night Elf Frigate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseagiant",
        "tags": [
            "Sea Giant",
            "Sea Giant Behemoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndaggerofescape",
        "tags": [
            "Kelen's Dagger of Escape",
            "Assassin's Blade",
            "Slow Poison"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstronghold",
        "tags": [
            "Stronghold"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrejuvenation",
        "tags": [
            "Rejuvenation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncryptfiendunburrow",
        "tags": [
            "cryptfiendunburrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwolf",
        "tags": [
            "Dog",
            "Guard Dog"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspy",
        "tags": [
            "Mogrin's Report"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmortarteam",
        "tags": [
            "Mortar Team"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzebowl",
        "tags": [
            "bronzebowl"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhydralisk",
        "tags": [
            "Hydralisk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghoul",
        "tags": [
            "Ghoul"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollhut1",
        "tags": [
            "gnollhut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncannontower",
        "tags": [
            "Cannon Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnowowl",
        "tags": [
            "Snowy Owl"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnknight",
        "tags": [
            "Knight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncoldarrowson",
        "tags": [
            "Frost Arrows",
            "Cold Arrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnobsidianstatue",
        "tags": [
            "Obsidian Statue"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnoneheadedogre",
        "tags": [
            "Stonemaul Ogre",
            "Stonemaul Magi"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanitearchitecture",
        "tags": [
            "arcanitearchitecture"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarkminion",
        "tags": [
            "darkminion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancientoftheearth",
        "tags": [
            "Ancient of War"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpickupitem",
        "tags": [
            "pickupitem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfountainoflifeblood",
        "tags": [
            "Fountain of Blood"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngloveofspellmastery",
        "tags": [
            "gloveofspellmastery"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnengineeringupgrade",
        "tags": [
            "Engineering Upgrade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseagiantgreen",
        "tags": [
            "Sea Giant Hunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpocketfactorylv3",
        "tags": [
            "pocketfactorylv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnclawsofattack",
        "tags": [
            "Claws of Attack +9",
            "Claws of Attack +6",
            "Claws of Attack +3",
            "Claws of Attack +15",
            "Claws of Attack +12",
            "Item Damage Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnresstone",
        "tags": [
            "Resurrection Stone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletalorc",
        "tags": [
            "Skeletal Orc"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntidalguardian",
        "tags": [
            "Tidal Guardian"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfountainoflifedefiled",
        "tags": [
            "Defiled Fountain of Life"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnroot",
        "tags": [
            "Root"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroavatarofflame",
        "tags": [
            "Firelord"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnscatterrockets",
        "tags": [
            "Barrage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnevasion",
        "tags": [
            "Evasion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncoldtower",
        "tags": [
            "Cold Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunloadpeon",
        "tags": [
            "unloadpeon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnworkshop",
        "tags": [
            "Workshop"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnswordsman_v1",
        "tags": [
            "swordsman_v1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwitchdoctor",
        "tags": [
            "Vol'jin",
            "Witch Doctor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsorceress",
        "tags": [
            "Sorceress"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanshipyard",
        "tags": [
            "Human Shipyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotiongreensmall",
        "tags": [
            "Potion of Healing",
            "Item Healing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsorceressadept",
        "tags": [
            "sorceressadept"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollhut2",
        "tags": [
            "gnollhut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicecrownobelisk",
        "tags": [
            "Icecrown Obelisk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterinvulneralbility",
        "tags": [
            "Potion of Invulnerability",
            "Item Temporary Invulnerability"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadcar",
        "tags": [
            "Undead Cart"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingwatcher",
        "tags": [
            "Spirit of Vengeance"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbox",
        "tags": [
            "box"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbreathoffire",
        "tags": [
            "Breath of Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncritterrabbit",
        "tags": [
            "Rabbit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanual3",
        "tags": [
            "Tome of Greater Experience",
            "Item Experience Gain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstasistrapskill",
        "tags": [
            "stasistrapskill"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancientoflore",
        "tags": [
            "Ancient of Lore"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnyoudirtyrat!",
        "tags": [
            "Rat"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlocmutant",
        "tags": [
            "Murloc Mutant",
            "Murloc Plaguebearer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnserpentward",
        "tags": [
            "Serpent Ward"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofsilence",
        "tags": [
            "Staff of Silence",
            "Item Silence"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntavern",
        "tags": [
            "Tavern"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwolf",
        "tags": [
            "Spirit Wolf",
            "Shadow Wolf",
            "Dire Wolf",
            "Feral Spirit",
            "Summon Headhunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherotinker",
        "tags": [
            "Tinker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostbolt",
        "tags": [
            "Frost Bolt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmedivh",
        "tags": [
            "Medivh"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnriderlesskodo",
        "tags": [
            "Kodo Beast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcaneobservatory",
        "tags": [
            "Arcane Observatory"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorccar",
        "tags": [
            "Orc Cart"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscepterofhealing",
        "tags": [
            "scepterofhealing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfaeriefireoff",
        "tags": [
            "faeriefireoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntownhall",
        "tags": [
            "Town Hall",
            "Build Tiny Great Hall"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncleavingattack",
        "tags": [
            "cleavingattack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodelfprince",
        "tags": [
            "bloodelfprince"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkelthuzad",
        "tags": [
            "Kel'Thuzad"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjanggo",
        "tags": [
            "Ancient Janggo of Endurance"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwindserpent",
        "tags": [
            "Couatl"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlocustswarm",
        "tags": [
            "Locust",
            "Voodoo Spirits",
            "Locust Swarm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplay-speeddown",
        "tags": [
            "replay-speeddown"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnstatup",
        "tags": [
            "Attribute Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkiljaedin",
        "tags": [
            "Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpurplefelravager",
        "tags": [
            "purplefelravager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfshipyard",
        "tags": [
            "Night Elf Shipyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellsteal",
        "tags": [
            "Gloves of Spell Mastery",
            "Control Magic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritpig",
        "tags": [
            "spiritpig"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackmarket",
        "tags": [
            "Marketplace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserrejuvpotion",
        "tags": [
            "Lesser Replenishment Potion",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmoonwell",
        "tags": [
            "Moon Well"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngathergold",
        "tags": [
            "Rusty Mining Pick",
            "Harvest",
            "Gather"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmantleofintelligence",
        "tags": [
            "Mantle of Intelligence +3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrune",
        "tags": [
            "Rune of Rebirth",
            "Rune of the Watcher",
            "Rune of Lesser Resurrection",
            "Rune of Lesser Healing",
            "Rune of Greater Mana",
            "Rune of Speed",
            "Rune of Mana",
            "Rune of Dispel Magic",
            "Rune of Restoration",
            "Rune of Greater Resurrection",
            "Rune of Healing",
            "Rune of Spirit Link",
            "Rune of Greater Healing",
            "Rune of Shielding",
            "Reborn",
            "Powerup Dispel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnload",
        "tags": [
            "Load Wisp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwatcherward",
        "tags": [
            "watcherward"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjailorkassan",
        "tags": [
            "jailorkassan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeaddestroyer",
        "tags": [
            "Undead Frigate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheadhunter",
        "tags": [
            "Headhunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnassassin",
        "tags": [
            "Warden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwyvern",
        "tags": [
            "Spirit Wind Rider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhippogriff",
        "tags": [
            "Hippogryph"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofslowness",
        "tags": [
            "Orb of Slow",
            "Item Attack Slow Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanarechargeon",
        "tags": [
            "Replenish Mana and Life"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostguard",
        "tags": [
            "frostguard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkeeperghostblue",
        "tags": [
            "Keeper of the Grove"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanevault",
        "tags": [
            "Arcane Vault"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnamuletofthewild",
        "tags": [
            "Amulet of the Wild",
            "Item Ursa Warrior Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmerchant",
        "tags": [
            "Goblin Merchant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngraveyard",
        "tags": [
            "Graveyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnaltarofkings",
        "tags": [
            "Altar of Kings",
            "Tiny Altar of Kings",
            "Build Tiny Altar of Kings"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbroodmother",
        "tags": [
            "broodmother"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphoenixegg",
        "tags": [
            "Phoenix Egg"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshade",
        "tags": [
            "Shade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncriticalstrike",
        "tags": [
            "criticalstrike"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanashield",
        "tags": [
            "manashield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhellscream",
        "tags": [
            "Blademaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarchimonde",
        "tags": [
            "Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackcitadel",
        "tags": [
            "Black Citadel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscepterofmastery",
        "tags": [
            "Scepter of Mastery",
            "Item Command"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkotobeast",
        "tags": [
            "Kodo Beast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselectherooff",
        "tags": [
            "selectherooff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrokhan",
        "tags": [
            "rokhan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnogre",
        "tags": [
            "Ogre Mauler",
            "Ogre Warrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwirtsleg",
        "tags": [
            "Wirt's Leg"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndalaranguardtower",
        "tags": [
            "Dalaran Guard Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendragonroost",
        "tags": [
            "Green Dragon Roost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnleatherupgradeone",
        "tags": [
            "leatherupgradeone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaiwatcher",
        "tags": [
            "dranaiwatcher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntornado",
        "tags": [
            "Tornado",
            "Tornado Spin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstrengthofthemoon",
        "tags": [
            "strengthofthemoon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodelfsupplywagon",
        "tags": [
            "Wagon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaoswarlock",
        "tags": [
            "Fel Orc Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngiantfrostwolf",
        "tags": [
            "giantfrostwolf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsasquatchshaman",
        "tags": [
            "Elder Sasquatch"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhoodofcunning",
        "tags": [
            "Hood of Cunning"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterrejuvpotion",
        "tags": [
            "Greater Replenishment Potion",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanarmorupthree",
        "tags": [
            "Shield of Honor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanual",
        "tags": [
            "Manual of Health",
            "Item Permanent Life Gain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsalamanderlord",
        "tags": [
            "salamanderlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmedivhravenform",
        "tags": [
            "medivhravenform"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellshieldamulet",
        "tags": [
            "Amulet of Spell Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofstrength",
        "tags": [
            "tomeofstrength"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnentanglemine",
        "tags": [
            "entanglemine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbookofthedead",
        "tags": [
            "Book of the Dead"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnthickfur",
        "tags": [
            "Resistant Skin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedspikedbarricades",
        "tags": [
            "advancedspikedbarricades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshamanmaster",
        "tags": [
            "Shaman Claws"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcmeleeupone",
        "tags": [
            "Sturdy War Axe"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchestofgold",
        "tags": [
            "Gold Coins",
            "Chest of Gold"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtndwarvenlongrifle",
        "tags": [
            "Long Rifles"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstone",
        "tags": [
            "Talisman of the Wild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguldanskull",
        "tags": [
            "Skull of Gul'dan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnboots",
        "tags": [
            "Boots of Quel'Thalas +6",
            "Speed Bonus",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterrejuvscroll",
        "tags": [
            "Greater Scroll of Replenishment ",
            "Rejuvenation",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofsanctuary",
        "tags": [
            "Staff of Sanctuary"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriestadept",
        "tags": [
            "Scepter of Healing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnecromancermaster",
        "tags": [
            "Grimoire of Souls"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhighelvenarcher_v1",
        "tags": [
            "highelvenarcher_v1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsobimask",
        "tags": [
            "Sobi Mask",
            "Item Mana Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodkey",
        "tags": [
            "Blood Key"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngmexchange",
        "tags": [
            "gmexchange"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsacrificialskull",
        "tags": [
            "Sacrificial Skull",
            "Blight Placement"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsilence",
        "tags": [
            "Silence"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbreathoffrost",
        "tags": [
            "Breath of Frost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninn",
        "tags": [
            "inn"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhornofdoom",
        "tags": [
            "Legion Doom-Horn"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorclumberupgradetwo",
        "tags": [
            "orclumberupgradetwo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringjadefalcon",
        "tags": [
            "Ring of the Archmagi",
            "Jade Ring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnazzyscrollpurple",
        "tags": [
            "Scroll of Animate Dead"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnperiapt1",
        "tags": [
            "Khadgar's Gem of Health",
            "Item Life Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpatrol",
        "tags": [
            "patrol"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmoonkey",
        "tags": [
            "Moon Key"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnurnofkelthuzad",
        "tags": [
            "Urn of King Terenas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncrystalball",
        "tags": [
            "Crystal Ball",
            "Item Area Detection"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbelt",
        "tags": [
            "Belt of Giant Strength +6",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbonechimes",
        "tags": [
            "Scourge Bone Chimes"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterinvisibility",
        "tags": [
            "Potion of Greater Invisibility",
            "Item Temporary Invisibility"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnresurrection",
        "tags": [
            "Greater Rune Resurrection",
            "Item Resurrection",
            "Lesser Rune Resurrection"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsteelarmor",
        "tags": [
            "steelarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntelescope",
        "tags": [
            "Goblin Night Scope",
            "Item Sight Range Bonus",
            "Ultravision"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomered",
        "tags": [
            "Tome of Power",
            "Tome of Knowledge",
            "Item Permanent Damage Gain",
            "Item Attack Damage Gain",
            "Item Int/Agi/Str gain",
            "Item Level Gain",
            "Item Permanent Life Gain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancienthydra",
        "tags": [
            "ancienthydra"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnexhumecorpses",
        "tags": [
            "Exhume Corpses"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaidarkslayer",
        "tags": [
            "dranaidarkslayer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btniceshard",
        "tags": [
            "Ice Shard",
            "Item Ice Revenant Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionred",
        "tags": [
            "Potion of Speed",
            "Item Temporary Speed Bonus",
            "Item Heal/Mana Regain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnberserk",
        "tags": [
            "berserk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvialfull",
        "tags": [
            "Full Vial",
            "Enchanted Vial"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntheblackarrow",
        "tags": [
            "Black Arrow",
            "Dark Minion",
            "Item Black Arrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealingsalve",
        "tags": [
            "Healing Salve",
            "Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcmeleeupthree",
        "tags": [
            "Serathil"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrodofnecromancy",
        "tags": [
            "Rod of Necromancy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserinvulneralbility",
        "tags": [
            "Potion of Lesser Invulnerability",
            "Item Temporary Invulnerability"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrimward",
        "tags": [
            "Skull Shield",
            "Frost Wyrm Skull Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringlionhead",
        "tags": [
            "Lion's Ring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorboffire",
        "tags": [
            "Orb of Fire",
            "Heal Reduction",
            "Item Attack Heal Reduction Bonus",
            "Item Attack Fire Bonus",
            "Melee Fire Damage Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanitemelee",
        "tags": [
            "Searing Blade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedtreeofages",
        "tags": [
            "corruptedtreeofages"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofcorruption",
        "tags": [
            "Skeletal Artifact",
            "Orb of Corruption",
            "Item Attack Corruption Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhornoffog",
        "tags": [
            "Horn of the Clouds"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwateryminioncaster",
        "tags": [
            "wateryminioncaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnalleriaflute",
        "tags": [
            "Alleria's Flute of Accuracy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionofrestoration",
        "tags": [
            "Potion of Restoration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotiongreen",
        "tags": [
            "Potion of Greater Healing",
            "Item Healing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofretraining",
        "tags": [
            "Tome of Retraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringpurple",
        "tags": [
            "Bracer of Agility",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstun",
        "tags": [
            "Stunned"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringgreen",
        "tags": [
            "Ring of Protection +5",
            "Ring of Protection +4",
            "Ring of Protection +1",
            "Ring of Protection +2",
            "Ring of Protection +3",
            "Item Armor Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btn3m1",
        "tags": [
            "Mooncrystal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanaflareoff",
        "tags": [
            "Thunderbloom Bulb"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbarkskinoff",
        "tags": [
            "barkskinoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfcaptureflag",
        "tags": [
            "Night Elf Flag",
            "Item Capture The Flag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurtent2",
        "tags": [
            "centaurtent2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btn3m2",
        "tags": [
            "Partial Key of the Three Moons"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntrueshot",
        "tags": [
            "Trueshot Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphaseshifton",
        "tags": [
            "Phase Shift"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnliquidfire",
        "tags": [
            "liquidfire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrunedbracers",
        "tags": [
            "Runed Bracers",
            "Spell Damage Reduction"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndust",
        "tags": [
            "Druid Pouch"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndustofappearance",
        "tags": [
            "Dust of Appearance",
            "Detected"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnregenerate",
        "tags": [
            "regenerate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedunholystrength",
        "tags": [
            "Firehand Gauntlets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstrenghtofthewild",
        "tags": [
            "strenghtofthewild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndrekthar",
        "tags": [
            "drekthar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringskull",
        "tags": [
            "Ring of Regeneration",
            "Item Life Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealthstone",
        "tags": [
            "Health Stone",
            "Item Life Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnacorn",
        "tags": [
            "Seed of Expulsion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheartofaszune",
        "tags": [
            "Heart of Aszune",
            "Essence of Aszune",
            "Least Healing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostwolf",
        "tags": [
            "frostwolf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmoonstone",
        "tags": [
            "Moonstone",
            "Change Time of Day"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngauntletsofogrepower",
        "tags": [
            "Gauntlets of Ogre Strength +3",
            "Item Attack Speed Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorboffrost",
        "tags": [
            "Orb of Frost",
            "Melee Cold Damage Bonus",
            "Item Attack Frost Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnankh",
        "tags": [
            "Ankh of Reincarnation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnregeneration",
        "tags": [
            "regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrejuvpotion",
        "tags": [
            "Replenishment Potion",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarmoredogre",
        "tags": [
            "armoredogre"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbrigand",
        "tags": [
            "brigand"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserdarkminion",
        "tags": [
            "lesserdarkminion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnazzypotion",
        "tags": [
            "Anti-magic Potion",
            "Item Anti-Magic Shell"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnazzyscroll",
        "tags": [
            "Scroll of Resurrection"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvialempty",
        "tags": [
            "Empty Vial"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionofclarity",
        "tags": [
            "Clarity Potion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrollofregenerationgreen",
        "tags": [
            "Scroll of Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabson",
        "tags": [
            "Carrion Beetles"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncage2",
        "tags": [
            "cage2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstop",
        "tags": [
            "stop"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringvioletspider",
        "tags": [
            "Spider Ring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwitchdoctormaster",
        "tags": [
            "Ancestral Staff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnclayfigurine",
        "tags": [
            "Ancient Figurine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaartrapper",
        "tags": [
            "tuskaartrapper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhelmofvalor",
        "tags": [
            "Helm of Valor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btn_ringjadefalcon",
        "tags": [
            "_ringjadefalcon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncloak",
        "tags": [
            "Cloak of Shadows",
            "Shadow Meld (Item)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwendigoelder",
        "tags": [
            "wendigoelder"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnelunesblessing",
        "tags": [
            "Elune's Grace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselectheroon",
        "tags": [
            "Secret Level Powerup",
            "Shop Sharing",
            "Allied Bldg.",
            "Select Hero",
            "Select Unit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpackbeast",
        "tags": [
            "Unit Inventory",
            "Pack Mule"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrobeofthemagi",
        "tags": [
            "Robe of the Magi +6",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionofomniscience",
        "tags": [
            "Potion of Omniscience",
            "Item Reveal Entire Map"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnecromanceradept",
        "tags": [
            "Tome of Sacrifices"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghostkey",
        "tags": [
            "Ghost Key"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbundleoflumber",
        "tags": [
            "Bundle of Lumber"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnfirerocks",
        "tags": [
            "Burning Oil"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnliquidfire",
        "tags": [
            "Liquid Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpipeofinsight",
        "tags": [
            "Khadgar's Pipe of Insight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanetower",
        "tags": [
            "arcanetower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsacrificialdagger",
        "tags": [
            "Ritual Dagger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkelthuzadcin",
        "tags": [
            "kelthuzadcin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslippersofagility",
        "tags": [
            "Slippers of Agility +3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadowpact",
        "tags": [
            "Voodoo Doll",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritlink",
        "tags": [
            "Spirit Link"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionbluebig",
        "tags": [
            "Potion of Greater Mana",
            "Item Mana Regain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbootsofspeed",
        "tags": [
            "Boots of Speed",
            "Item Move Speed Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanastone",
        "tags": [
            "Mana Stone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolymorph",
        "tags": [
            "Polymorph"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnazzyscrollgreen",
        "tags": [
            "Scroll of the Beast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btn3m3",
        "tags": [
            "Key of Three Moons"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaibarracks",
        "tags": [
            "dranaibarracks"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrollofhealing",
        "tags": [
            "Scroll of Restoration",
            "Item Area Heal/Mana Regain",
            "Rune Area Heal/Mana Regain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshimmerweed",
        "tags": [
            "Shimmerweed"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserrejuvscroll",
        "tags": [
            "Lesser Scroll of Replenishment ",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodluston",
        "tags": [
            "Frenzy",
            "Bloodlust"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnminorrejuvpotion",
        "tags": [
            "Minor Replenishment Potion",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthoriumarmor",
        "tags": [
            "Enchanted Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellbookbls",
        "tags": [
            "Spell Book"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnparasite",
        "tags": [
            "Parasite"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlightningshield",
        "tags": [
            "Shield of the Deathlord",
            "Lightning Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofpreservation",
        "tags": [
            "Staff of Preservation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbansheeadept",
        "tags": [
            "Arcane Scroll"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumancaptureflag",
        "tags": [
            "Human Flag",
            "Item Capture The Flag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpendantofenergy",
        "tags": [
            "Pendant of Energy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndisenchant",
        "tags": [
            "Disenchant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmedalionofcourage",
        "tags": [
            "Medallion of Courage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsoulgem",
        "tags": [
            "Soul Gem",
            "Item Soul Theft"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofteleportation",
        "tags": [
            "Staff of Teleportation"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnimmolation",
        "tags": [
            "Permanent Immolation",
            "Phoenix Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderlizarddiamond",
        "tags": [
            "thunderlizarddiamond"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwand",
        "tags": [
            "Wand of Illusion",
            "Item Illusions"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsentry",
        "tags": [
            "sentry"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphilosophersstone",
        "tags": [
            "Bloodfeather's Heart",
            "Random Item"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhammer",
        "tags": [
            "Maul of Strength",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwalkeradepttraining",
        "tags": [
            "Killmaim"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoldring",
        "tags": [
            "Ring of Superiority",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspirithawk",
        "tags": [
            "spirithawk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbansheemaster",
        "tags": [
            "Scroll of the Unholy Legion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpendantofmana",
        "tags": [
            "Pendant of Mana"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellstealoff",
        "tags": [
            "spellstealoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheartofsearinox",
        "tags": [
            "The Heart of Searinox"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnenvenomedspear",
        "tags": [
            "Envenomed Spears",
            "Envenomed Weapons"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndizzy",
        "tags": [
            "Dizziness",
            "Dark Portal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrepairon",
        "tags": [
            "Repair",
            "Restore"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfreezingbreath",
        "tags": [
            "Freezing Breath"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncommand",
        "tags": [
            "Endurance Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrobogoblinoff",
        "tags": [
            "robogoblinoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaihut2",
        "tags": [
            "dranaihut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreturngoods",
        "tags": [
            "Charge Gold and Lumber"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorrosivebreath",
        "tags": [
            "Corrosive Breath"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngolemthunderclap",
        "tags": [
            "Slam"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnslowpoison",
        "tags": [
            "Slow Poison"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofagility",
        "tags": [
            "tomeofagility"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanaflare",
        "tags": [
            "Mana Flare"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbarkskin",
        "tags": [
            "Barkskin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbigbadvoodoospell",
        "tags": [
            "Big Bad Voodoo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealingspray",
        "tags": [
            "Healing Spray"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishmana",
        "tags": [
            "Spirit Touch",
            "Replenish"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostarmor",
        "tags": [
            "Frost Armor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnensnare",
        "tags": [
            "Ensnare",
            "Ensnare (General)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnclusterrockets",
        "tags": [
            "Cluster Rockets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslowon",
        "tags": [
            "Slow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvampiricaura",
        "tags": [
            "Vampiric Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguardiangolem",
        "tags": [
            "guardiangolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnanimatedead",
        "tags": [
            "Animate Dead",
            "Item Animate Dead"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstampede",
        "tags": [
            "Stampede"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollberserker",
        "tags": [
            "foresttrollberserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslowpoison",
        "tags": [
            "Slow Poison"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfire",
        "tags": [
            "Rain of Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndocmastertraining",
        "tags": [
            "docmastertraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncoldarrows",
        "tags": [
            "Cold Arrows"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnwellspring",
        "tags": [
            "Well Spring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninvisibility",
        "tags": [
            "Invisibility"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselfdestruct",
        "tags": [
            "selfdestruct"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpandataunt",
        "tags": [
            "Taunt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnincinerate",
        "tags": [
            "Incinerate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhydrawarstomp",
        "tags": [
            "War Stomp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsapphironundead",
        "tags": [
            "sapphironundead"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstrongdrink",
        "tags": [
            "Drunken Haze"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncurse",
        "tags": [
            "Curse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvolcano",
        "tags": [
            "Volcano"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndevour",
        "tags": [
            "Devour"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthorns",
        "tags": [
            "Thorns Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncontrolmagic",
        "tags": [
            "Control Magic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncloudoffog",
        "tags": [
            "Cloud",
            "Cloud of Fog"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndevotion",
        "tags": [
            "Devotion Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpossession",
        "tags": [
            "Possession"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnneutralmanashield",
        "tags": [
            "Mana Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnweb",
        "tags": [
            "Web"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncannibalize",
        "tags": [
            "Cannibalize"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncalltoarms",
        "tags": [
            "Militia",
            "Call to Arms",
            "Call To Arms"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndivineintervention",
        "tags": [
            "Divine Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnetherealformon",
        "tags": [
            "Ethereal Form"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedstrengthofthewild",
        "tags": [
            "improvedstrengthofthewild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchemicalrage",
        "tags": [
            "Chemical Rage"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtncriticalstrike",
        "tags": [
            "Critical Strike"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderclap",
        "tags": [
            "Thunder Clap"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnearthquake",
        "tags": [
            "Earthquake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhowlofterror",
        "tags": [
            "Howl of Terror"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeathanddecay",
        "tags": [
            "Death and Decay",
            "Death And Decay"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninvulnerable",
        "tags": [
            "Invulnerable"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbattlestations",
        "tags": [
            "Battle Stations"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncripple",
        "tags": [
            "Cripple"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavataroff",
        "tags": [
            "avataroff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfaeriefire",
        "tags": [
            "Faerie Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwarden",
        "tags": [
            "warden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstormearth&fire",
        "tags": [
            "Pandaren Elemental",
            "Storm",
            "Earth",
            "And Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseagiantbehemoth",
        "tags": [
            "seagiantbehemoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimmolationon",
        "tags": [
            "Immolation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntaurenchieftain",
        "tags": [
            "taurenchieftain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodfiend",
        "tags": [
            "bloodfiend"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlifedrain",
        "tags": [
            "Life Drain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncrushingwave",
        "tags": [
            "Crushing Wave"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsearingarrowson",
        "tags": [
            "Searing Arrows",
            "Poison Arrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfbuild",
        "tags": [
            "Build (Night Elf)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseagiantwarstomp",
        "tags": [
            "War Stomp"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnanimalwartraining",
        "tags": [
            "Animal War Training"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnapprenticewizard",
        "tags": [
            "apprenticewizard"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtndemolish",
        "tags": [
            "Demolish"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnbrilliance",
        "tags": [
            "Brilliance Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstormwyrm",
        "tags": [
            "stormwyrm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanaburn",
        "tags": [
            "Mana Burn"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherofemaledeathknight",
        "tags": [
            "herofemaledeathknight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndwarvenlongrifle",
        "tags": [
            "dwarvenlongrifle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncryptfiendburrow",
        "tags": [
            "Burrow"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtndrunkendodge",
        "tags": [
            "Drunken Brawler"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionswarm",
        "tags": [
            "Carrion Swarm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfragmentationbombs",
        "tags": [
            "fragmentationbombs"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnvampiricaura",
        "tags": [
            "Vampiric Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstrengthofthewild",
        "tags": [
            "strengthofthewild"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtncleavingattack",
        "tags": [
            "Cleaving Attack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellstealon",
        "tags": [
            "Spell Steal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadloadon",
        "tags": [
            "Get Corpse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsell",
        "tags": [
            "Sell Items"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunload",
        "tags": [
            "Unload",
            "Unload Instant"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtncommand",
        "tags": [
            "Endurance Aura"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnupgrademoonglaive",
        "tags": [
            "Moon Glaive"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmoonarmor",
        "tags": [
            "moonarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrallypoint",
        "tags": [
            "Rally"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnevasion",
        "tags": [
            "Evasion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnazuredrake",
        "tags": [
            "azuredrake"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtndevotion",
        "tags": [
            "Devotion Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfaeriefireon",
        "tags": [
            "Faerie Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblink",
        "tags": [
            "Blink (Item Version)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentauroutrunner",
        "tags": [
            "centauroutrunner"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnsmash",
        "tags": [
            "Pulverize,Pulverize"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntranquility",
        "tags": [
            "Tranquility"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeathpact",
        "tags": [
            "Death Pact",
            "Channel"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtncorrosivebreath",
        "tags": [
            "Corrosive Breath"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnregenerationaura",
        "tags": [
            "Aura of Blight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmonsoon",
        "tags": [
            "Forked Lightning",
            "Monsoon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnambush",
        "tags": [
            "Shadow Meld"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnreincarnation",
        "tags": [
            "Reincarnation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndryaddispelmagicon",
        "tags": [
            "Abolish Magic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreveal",
        "tags": [
            "Reveal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsacredrelic",
        "tags": [
            "sacredrelic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshockwave",
        "tags": [
            "Shockwave"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnincinerateon",
        "tags": [
            "Incinerate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrazorbackbrute",
        "tags": [
            "razorbackbrute"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselfdestructon",
        "tags": [
            "Kaboom!"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngolemstormbolt",
        "tags": [
            "Hurl Boulder"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtngenericspellimmunity",
        "tags": [
            "Spell Immunity",
            "Spell Immunity"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnmagicimmunity",
        "tags": [
            "Spell Immunity"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnthorns",
        "tags": [
            "Thorns Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninnerfireoff",
        "tags": [
            "innerfireoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwebon",
        "tags": [
            "Web",
            "Item Web"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncharm",
        "tags": [
            "Charm"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnhumanartilleryupone",
        "tags": [
            "Flying Machine Bombs"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealon",
        "tags": [
            "Item Healing"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnshadetruesight",
        "tags": [
            "True Sight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnresistantskin",
        "tags": [
            "resistantskin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsentinel",
        "tags": [
            "Sentinel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnraisedead",
        "tags": [
            "Raise Dead (Item)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagekid2",
        "tags": [
            "villagekid2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndevourmagic",
        "tags": [
            "Devour Magic"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnfreezingbreath",
        "tags": [
            "Freezing Breath"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscourgebuild",
        "tags": [
            "Build (Undead)"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnseagiantpulverize",
        "tags": [
            "Pulverize"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchainlightning",
        "tags": [
            "Chain Lightning"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhire",
        "tags": [
            "Sell Units"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforceofnature",
        "tags": [
            "forceofnature"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsacrifice",
        "tags": [
            "Sacrifice"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfanofknives",
        "tags": [
            "Fan of Knives"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnfrost",
        "tags": [
            "Frost Attack"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnimprovedbows",
        "tags": [
            "Improved Bows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstormbolt",
        "tags": [
            "Storm Bolt"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnhumanlumberupgrade1",
        "tags": [
            "Improved Lumber Harvesting,Improved Lumber Harvesting,Advanced Lumber Harvesting"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnregenerate",
        "tags": [
            "Troll Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnparasiteon",
        "tags": [
            "Parasite"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnincinerate",
        "tags": [
            "Incinerate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbacktowork",
        "tags": [
            "Stand Down"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnreinforcedburrows",
        "tags": [
            "Reinforced Defenses"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriestv0",
        "tags": [
            "priestv0"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstarfall",
        "tags": [
            "Starfall"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmalfurion",
        "tags": [
            "malfurion"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnheadhunterberserker",
        "tags": [
            "Berserker Upgrade"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnmagicalsentry",
        "tags": [
            "Magic Sentry"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrimoireofsouls",
        "tags": [
            "grimoireofsouls"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarkritual",
        "tags": [
            "Dark Ritual"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndispelmagic",
        "tags": [
            "Dispel Magic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadunload",
        "tags": [
            "Drop Corpse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnazgalor",
        "tags": [
            "azgalor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfectedgranary",
        "tags": [
            "infectedgranary"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndirefrostwolf",
        "tags": [
            "direfrostwolf"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnberserk",
        "tags": [
            "Brute Strength"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtngnollcommandaura",
        "tags": [
            "Command Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimpalingbolt",
        "tags": [
            "impalingbolt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbearblink",
        "tags": [
            "Blink"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnunholyaura",
        "tags": [
            "Unholy Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthundersalamandervizier",
        "tags": [
            "thundersalamandervizier"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanbuild",
        "tags": [
            "Build (Human)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellbreakermagicdefend",
        "tags": [
            "Magic Defense"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaturtlegreengiant",
        "tags": [
            "seaturtlegreengiant"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnghoulfrenzy",
        "tags": [
            "Ghoul Frenzy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsiegegolem",
        "tags": [
            "siegegolem"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnshade",
        "tags": [
            "Shade"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnspikedbarricades",
        "tags": [
            "Spiked Barricades,Spiked Barricades,Improved Spiked Barricades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfireforthecannon",
        "tags": [
            "Breath of Fire"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnpillage",
        "tags": [
            "Pillage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedcreatureattack",
        "tags": [
            "advancedcreatureattack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedcreaturecarapace",
        "tags": [
            "advancedcreaturecarapace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedmoonarmor",
        "tags": [
            "advancedmoonarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedreinforcedhides",
        "tags": [
            "advancedreinforcedhides"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedstrengthofthemoon",
        "tags": [
            "advancedstrengthofthemoon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaturtlegreengargantuan",
        "tags": [
            "seaturtlegreengargantuan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedunholyarmor",
        "tags": [
            "advancedunholyarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurtent1",
        "tags": [
            "centaurtent1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvstruct",
        "tags": [
            "advstruct"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnanimalwartraining",
        "tags": [
            "animalwartraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnanubarak",
        "tags": [
            "anubarak"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntent2",
        "tags": [
            "tent2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarachnathidearthborer",
        "tags": [
            "arachnathidearthborer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanescroll",
        "tags": [
            "arcanescroll"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarthasevil",
        "tags": [
            "arthasevil"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnauraofdarkness",
        "tags": [
            "auraofdarkness"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarthasfrost",
        "tags": [
            "arthasfrost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneredarwarlock",
        "tags": [
            "eredarwarlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnassassinsblade",
        "tags": [
            "assassinsblade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktrollwarlord",
        "tags": [
            "darktrollwarlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnattack",
        "tags": [
            "attack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnattackground",
        "tags": [
            "attackground"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingassassinoff",
        "tags": [
            "avengingassassinoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingassassinon",
        "tags": [
            "avengingassassinon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingwatcheroff",
        "tags": [
            "avengingwatcheroff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnballista",
        "tags": [
            "ballista"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselfdestructoff",
        "tags": [
            "selfdestructoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbalnazzar",
        "tags": [
            "balnazzar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbarkskinon",
        "tags": [
            "barkskinon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnillidan",
        "tags": [
            "illidan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnberserkelemental",
        "tags": [
            "berserkelemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncurseoff",
        "tags": [
            "curseoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmuradinbronzebeard",
        "tags": [
            "muradinbronzebeard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnberserkwildkin",
        "tags": [
            "berserkwildkin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbladebanearmor",
        "tags": [
            "bladebanearmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodlustoff",
        "tags": [
            "bloodlustoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulhut2",
        "tags": [
            "murgulhut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzebowlfull",
        "tags": [
            "bronzebowlfull"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzedragonroost",
        "tags": [
            "bronzedragonroost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndagrentheorcslayer",
        "tags": [
            "dagrentheorcslayer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzedragonwhelp",
        "tags": [
            "bronzedragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillageruined",
        "tags": [
            "nightelffishingvillageruined"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncagedlllidan",
        "tags": [
            "cagedlllidan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnburningarcher",
        "tags": [
            "burningarcher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncage1",
        "tags": [
            "cage1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncage3",
        "tags": [
            "cage3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncairnebloodhoof",
        "tags": [
            "cairnebloodhoof"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabslv1",
        "tags": [
            "carrionscarabslv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabslv2",
        "tags": [
            "carrionscarabslv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabslv3",
        "tags": [
            "carrionscarabslv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabsoff",
        "tags": [
            "carrionscarabsoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncenarius",
        "tags": [
            "cenarius"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmantle",
        "tags": [
            "mantle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncenariusnightmare",
        "tags": [
            "cenariusnightmare"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurtent3",
        "tags": [
            "centaurtent3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchime",
        "tags": [
            "chime"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncoldarrowsoff",
        "tags": [
            "coldarrowsoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillsprayoff",
        "tags": [
            "quillsprayoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngemfragment",
        "tags": [
            "gemfragment"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncrate",
        "tags": [
            "crate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsasquatchoracle",
        "tags": [
            "sasquatchoracle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncreatureattack",
        "tags": [
            "creatureattack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndalvengyr",
        "tags": [
            "dalvengyr"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktrollberserker",
        "tags": [
            "darktrollberserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcshipyard",
        "tags": [
            "orcshipyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneldervoidwalker",
        "tags": [
            "eldervoidwalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktrollhighpriest",
        "tags": [
            "darktrollhighpriest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelunesblessing",
        "tags": [
            "elunesblessing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeceiver",
        "tags": [
            "deceiver"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndefendergolem",
        "tags": [
            "defendergolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndefendstop",
        "tags": [
            "defendstop"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndemolish",
        "tags": [
            "demolish"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndenofwonders",
        "tags": [
            "denofwonders"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndepthsrevenant",
        "tags": [
            "depthsrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndetheroc",
        "tags": [
            "detheroc"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndirewolflv2",
        "tags": [
            "direwolflv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndivineshieldoff",
        "tags": [
            "divineshieldoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillbeastlv4",
        "tags": [
            "quillbeastlv4"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndocadepttraining",
        "tags": [
            "docadepttraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndotadepttraining",
        "tags": [
            "dotadepttraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndotmastertraining",
        "tags": [
            "dotmastertraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedcrows",
        "tags": [
            "enchantedcrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonhawkrider",
        "tags": [
            "dragonhawkrider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaarmorup3",
        "tags": [
            "nagaarmorup3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonhawkriderv0",
        "tags": [
            "dragonhawkriderv0"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaarmorup2",
        "tags": [
            "nagaarmorup2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonhawkriderv1",
        "tags": [
            "dragonhawkriderv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonspawnoverseer",
        "tags": [
            "dragonspawnoverseer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonturtlered",
        "tags": [
            "dragonturtlered"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndrain",
        "tags": [
            "drain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaiharbinger",
        "tags": [
            "dranaiharbinger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaihaven",
        "tags": [
            "dranaihaven"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaiprotocter",
        "tags": [
            "dranaiprotocter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaiseer",
        "tags": [
            "dranaiseer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmeatapult",
        "tags": [
            "meatapult"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaistalker",
        "tags": [
            "dranaistalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaivindicator",
        "tags": [
            "dranaivindicator"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndrektharsspellbook",
        "tags": [
            "drektharsspellbook"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsorceressv1",
        "tags": [
            "sorceressv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndrunkendodge",
        "tags": [
            "drunkendodge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmishalv2",
        "tags": [
            "mishalv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndryaddispelmagic",
        "tags": [
            "dryaddispelmagic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnearthfurytower",
        "tags": [
            "earthfurytower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelderhydra",
        "tags": [
            "elderhydra"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelderjunglebeast",
        "tags": [
            "elderjunglebeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelvenfarm2",
        "tags": [
            "elvenfarm2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnemissary",
        "tags": [
            "emissary"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkoboldtunneler",
        "tags": [
            "koboldtunneler"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedbear",
        "tags": [
            "enchantedbear"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedbears",
        "tags": [
            "enchantedbears"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenforcer",
        "tags": [
            "enforcer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmudgolem",
        "tags": [
            "mudgolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanmissileuptwo",
        "tags": [
            "humanmissileuptwo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnengineergazlowe",
        "tags": [
            "engineergazlowe"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenragedelemental",
        "tags": [
            "enragedelemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserspiritbeast",
        "tags": [
            "lesserspiritbeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenragedwildkin",
        "tags": [
            "enragedwildkin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnholdposition",
        "tags": [
            "holdposition"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneredarred",
        "tags": [
            "eredarred"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlightninglizard",
        "tags": [
            "lightninglizard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneredarsorcerer",
        "tags": [
            "eredarsorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneredarwarloc",
        "tags": [
            "eredarwarloc"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnexhumecorpses",
        "tags": [
            "exhumecorpses"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreatervoidwalker",
        "tags": [
            "greatervoidwalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnexpandedview",
        "tags": [
            "expandedview"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreddragonroost",
        "tags": [
            "reddragonroost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfacelessonedeathbringer",
        "tags": [
            "facelessonedeathbringer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlochut3",
        "tags": [
            "murlochut3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfacelessoneterror",
        "tags": [
            "facelessoneterror"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskullshield",
        "tags": [
            "skullshield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfallenkingarthas",
        "tags": [
            "fallenkingarthas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfeedback",
        "tags": [
            "feedback"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollwarlord",
        "tags": [
            "icetrollwarlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfeltrollburrow",
        "tags": [
            "feltrollburrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfemalemetamorphosis",
        "tags": [
            "femalemetamorphosis"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfiregauntlet",
        "tags": [
            "firegauntlet"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfiregauntlets",
        "tags": [
            "firegauntlets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulsnarecaster",
        "tags": [
            "murgulsnarecaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfirerevenant",
        "tags": [
            "firerevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfirerocks",
        "tags": [
            "firerocks"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflakcannons",
        "tags": [
            "flakcannons"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpackhorse",
        "tags": [
            "packhorse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflamingarrows",
        "tags": [
            "flamingarrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollhut1",
        "tags": [
            "foresttrollhut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflaregun",
        "tags": [
            "flaregun"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflute",
        "tags": [
            "flute"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollhighpriest",
        "tags": [
            "foresttrollhighpriest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollhut2",
        "tags": [
            "foresttrollhut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfountainofmana",
        "tags": [
            "fountainofmana"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedmining",
        "tags": [
            "improvedmining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfountainofpower",
        "tags": [
            "fountainofpower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostarmoroff",
        "tags": [
            "frostarmoroff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnaturesblessing",
        "tags": [
            "naturesblessing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostrevenant",
        "tags": [
            "frostrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgchampion",
        "tags": [
            "furbolgchampion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgeldershaman",
        "tags": [
            "furbolgeldershaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolghut2",
        "tags": [
            "furbolghut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngarthok",
        "tags": [
            "garthok"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnholywater",
        "tags": [
            "holywater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngenerichumanbuilding1",
        "tags": [
            "generichumanbuilding1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngenericspellimmunity",
        "tags": [
            "genericspellimmunity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngerardslostledger",
        "tags": [
            "gerardslostledger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghoulfrenzy",
        "tags": [
            "ghoulfrenzy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkegofthunderwater",
        "tags": [
            "kegofthunderwater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngiantfrostbear",
        "tags": [
            "giantfrostbear"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrallypoint",
        "tags": [
            "rallypoint"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngiantspider",
        "tags": [
            "giantspider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngiantwolf",
        "tags": [
            "giantwolf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollassassin",
        "tags": [
            "gnollassassin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollbrute",
        "tags": [
            "gnollbrute"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollcommandaura",
        "tags": [
            "gnollcommandaura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlavaspawnlv2",
        "tags": [
            "lavaspawnlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinmerchant",
        "tags": [
            "goblinmerchant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntent1",
        "tags": [
            "tent1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpyrogue",
        "tags": [
            "harpyrogue"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinshredder",
        "tags": [
            "goblinshredder"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrainwarehouse",
        "tags": [
            "grainwarehouse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulcliffrunner",
        "tags": [
            "murgulcliffrunner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterdarkminion",
        "tags": [
            "greaterdarkminion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterspiritbeast",
        "tags": [
            "greaterspiritbeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendragonwhelp",
        "tags": [
            "greendragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguarddog",
        "tags": [
            "guarddog"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguardianward",
        "tags": [
            "guardianward"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngyrocopter",
        "tags": [
            "gyrocopter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhardenedskin",
        "tags": [
            "hardenedskin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpynest1",
        "tags": [
            "harpynest1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaturtlegreenhatchling",
        "tags": [
            "seaturtlegreenhatchling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpynest2",
        "tags": [
            "harpynest2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpystormhag",
        "tags": [
            "harpystormhag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsalamanderhatchling",
        "tags": [
            "salamanderhatchling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheretic",
        "tags": [
            "heretic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroalchemistlv1",
        "tags": [
            "heroalchemistlv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroalchemistlv2",
        "tags": [
            "heroalchemistlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroalchemistlv3",
        "tags": [
            "heroalchemistlv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnogremauler",
        "tags": [
            "ogremauler"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherofemaledemonhunter",
        "tags": [
            "herofemaledemonhunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshamanclaws",
        "tags": [
            "shamanclaws"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherolich",
        "tags": [
            "herolich"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheromoonpriestess",
        "tags": [
            "heromoonpriestess"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhighelfarchmage",
        "tags": [
            "highelfarchmage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhighelfrunner",
        "tags": [
            "highelfrunner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhornofcenariuspedestal",
        "tags": [
            "hornofcenariuspedestal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanarmorupone",
        "tags": [
            "humanarmorupone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanarmoruptwo",
        "tags": [
            "humanarmoruptwo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanartilleryupone",
        "tags": [
            "humanartilleryupone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpoisonent",
        "tags": [
            "poisonent"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanlumberupgrade1",
        "tags": [
            "humanlumberupgrade1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanmissileupone",
        "tags": [
            "humanmissileupone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellbreakermagicundefend",
        "tags": [
            "spellbreakermagicundefend"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanmissileupthree",
        "tags": [
            "humanmissileupthree"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhydra",
        "tags": [
            "hydra"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhydromancer",
        "tags": [
            "hydromancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicerevenant",
        "tags": [
            "icerevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollberserker",
        "tags": [
            "icetrollberserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollhut2",
        "tags": [
            "icetrollhut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrolltrapper",
        "tags": [
            "icetrolltrapper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnillidandemonform",
        "tags": [
            "illidandemonform"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnillidanprisonwagon",
        "tags": [
            "illidanprisonwagon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwendigoshaman",
        "tags": [
            "wendigoshaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkredsnapper",
        "tags": [
            "lobstrokkredsnapper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimbuedmasonry",
        "tags": [
            "imbuedmasonry"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimmolationoff",
        "tags": [
            "immolationoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedcreatureattack",
        "tags": [
            "improvedcreatureattack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedcreaturecarapace",
        "tags": [
            "improvedcreaturecarapace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedreinforcedhides",
        "tags": [
            "improvedreinforcedhides"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedspikedbarricades",
        "tags": [
            "improvedspikedbarricades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedstrenghtofthewild",
        "tags": [
            "improvedstrenghtofthewild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedstrengthofthemoon",
        "tags": [
            "improvedstrengthofthemoon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnincinerateoff",
        "tags": [
            "incinerateoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfernalmachine",
        "tags": [
            "infernalmachine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrallypointundead",
        "tags": [
            "rallypointundead"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjainanote",
        "tags": [
            "jainanote"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthornyshieldoff",
        "tags": [
            "thornyshieldoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjainasea",
        "tags": [
            "jainasea"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwalkermastertraining",
        "tags": [
            "spiritwalkermastertraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjennalladeemspring",
        "tags": [
            "jennalladeemspring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkillmaim",
        "tags": [
            "killmaim"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkoboldtaskmaster",
        "tags": [
            "koboldtaskmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlament",
        "tags": [
            "lament"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlamp",
        "tags": [
            "lamp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlavaspawnlv3",
        "tags": [
            "lavaspawnlv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnleatherupgradethree",
        "tags": [
            "leatherupgradethree"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspidercrabbehemoth",
        "tags": [
            "spidercrabbehemoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnleatherupgradetwo",
        "tags": [
            "leatherupgradetwo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlgexchange",
        "tags": [
            "lgexchange"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlichkingcin",
        "tags": [
            "lichkingcin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlightningrevenant",
        "tags": [
            "lightningrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnloadpeon",
        "tags": [
            "loadpeon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkdeepseer",
        "tags": [
            "lobstrokkdeepseer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkredpooldweller",
        "tags": [
            "lobstrokkredpooldweller"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagicimmunity",
        "tags": [
            "magicimmunity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagtheridon",
        "tags": [
            "magtheridon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmalganis",
        "tags": [
            "malganis"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnproudmoore",
        "tags": [
            "proudmoore"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanarecharge",
        "tags": [
            "manarecharge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanarechargeoff",
        "tags": [
            "manarechargeoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanual2",
        "tags": [
            "manual2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmathog",
        "tags": [
            "mathog"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmgexchange",
        "tags": [
            "mgexchange"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmishalv1",
        "tags": [
            "mishalv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmogrinsreport",
        "tags": [
            "mogrinsreport"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmossgolem",
        "tags": [
            "mossgolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulhut1",
        "tags": [
            "murgulhut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulmarauder",
        "tags": [
            "murgulmarauder"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlochuntsman",
        "tags": [
            "murlochuntsman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlochut1",
        "tags": [
            "murlochut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlochut2",
        "tags": [
            "murlochut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarbrownhealer",
        "tags": [
            "tuskaarbrownhealer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaarmorup1",
        "tags": [
            "nagaarmorup1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarsorcerer",
        "tags": [
            "tuskaarsorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaweaponup2",
        "tags": [
            "nagaweaponup2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianseer",
        "tags": [
            "nerubianseer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianwarrior",
        "tags": [
            "nerubianwarrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianwebspinner",
        "tags": [
            "nerubianwebspinner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnetherdragonwhelp",
        "tags": [
            "netherdragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnneutralmanashieldoff",
        "tags": [
            "neutralmanashieldoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingboat",
        "tags": [
            "nightelffishingboat"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillagecrested",
        "tags": [
            "nightelffishingvillagecrested"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshamanadept",
        "tags": [
            "shamanadept"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillagecrestedruined",
        "tags": [
            "nightelffishingvillagecrestedruined"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillagetwostory",
        "tags": [
            "nightelffishingvillagetwostory"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillagetwostoryruined",
        "tags": [
            "nightelffishingvillagetwostoryruined"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorb",
        "tags": [
            "orb"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofdeathoff",
        "tags": [
            "orbofdeathoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofkiljaeden",
        "tags": [
            "orbofkiljaeden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcrallypoint",
        "tags": [
            "orcrallypoint"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcwarlockapprentice",
        "tags": [
            "orcwarlockapprentice"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcwarlocknecrolyte",
        "tags": [
            "orcwarlocknecrolyte"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnotherbarrel",
        "tags": [
            "otherbarrel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnowlscoutlv1",
        "tags": [
            "owlscoutlv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpebble",
        "tags": [
            "pebble"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnparasiteoff",
        "tags": [
            "parasiteoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphaseshiftoff",
        "tags": [
            "phaseshiftoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphoenix",
        "tags": [
            "phoenix"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpillage",
        "tags": [
            "pillage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpocketfactorylv2",
        "tags": [
            "pocketfactorylv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpoisonsting",
        "tags": [
            "poisonsting"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolgchampion",
        "tags": [
            "polarfurbolgchampion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolgeldershaman",
        "tags": [
            "polarfurbolgeldershaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionblue",
        "tags": [
            "potionblue"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunholyarmor",
        "tags": [
            "unholyarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriestv1",
        "tags": [
            "priestv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnqueenofsuffering",
        "tags": [
            "queenofsuffering"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillbeastgod",
        "tags": [
            "quillbeastgod"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillbeastlv3",
        "tags": [
            "quillbeastlv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnragingbear",
        "tags": [
            "ragingbear"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnraisedeadoff",
        "tags": [
            "raisedeadoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrallypointnightelf",
        "tags": [
            "rallypointnightelf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrazormanemedicineman",
        "tags": [
            "razormanemedicineman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreddragonwhelp",
        "tags": [
            "reddragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreddrake",
        "tags": [
            "reddrake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreefelemental",
        "tags": [
            "reefelemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreinforcedburrows",
        "tags": [
            "reinforcedburrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreinforcedhides",
        "tags": [
            "reinforcedhides"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrejuvenationpotion",
        "tags": [
            "rejuvenationpotion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrenegadewizard",
        "tags": [
            "renegadewizard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofintelligence",
        "tags": [
            "tomeofintelligence"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrepair",
        "tags": [
            "repair"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrepairoff",
        "tags": [
            "repairoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishhealthoff",
        "tags": [
            "replenishhealthoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringjadefalcon (2)",
        "tags": [
            "ringjadefalcon (2)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringofthearchmagi",
        "tags": [
            "ringofthearchmagi"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrobogoblinon",
        "tags": [
            "robogoblinon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrogue",
        "tags": [
            "rogue"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrunedgauntlets",
        "tags": [
            "runedgauntlets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrustyminingpick",
        "tags": [
            "rustyminingpick"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsapphironliving",
        "tags": [
            "sapphironliving"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsatyrhellcaller",
        "tags": [
            "satyrhellcaller"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsatyrsoulstealer",
        "tags": [
            "satyrsoulstealer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscatterrockets",
        "tags": [
            "scatterrockets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscepterofthesea",
        "tags": [
            "scepterofthesea"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscouttower",
        "tags": [
            "scouttower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseagiantpulverize",
        "tags": [
            "seagiantpulverize"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsearingarrows",
        "tags": [
            "searingarrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsearingarrowsoff",
        "tags": [
            "searingarrowsoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsearinox",
        "tags": [
            "searinox"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseasrevenant",
        "tags": [
            "seasrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselectunit",
        "tags": [
            "selectunit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnserathil",
        "tags": [
            "serathil"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnserpentwardlv2",
        "tags": [
            "serpentwardlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnserpentwardlv3",
        "tags": [
            "serpentwardlv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnserpentwardlv4",
        "tags": [
            "serpentwardlv4"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadowmeld",
        "tags": [
            "shadowmeld"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadoworbfragment",
        "tags": [
            "shadoworbfragment"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshieldofdeathlord",
        "tags": [
            "shieldofdeathlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshieldofhonor",
        "tags": [
            "shieldofhonor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshimmerglazeroast",
        "tags": [
            "shimmerglazeroast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsiegeengine",
        "tags": [
            "siegeengine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsiegeenginewithmissiles",
        "tags": [
            "siegeenginewithmissiles"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsirenadept",
        "tags": [
            "sirenadept"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsirgregoryedmunson",
        "tags": [
            "sirgregoryedmunson"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletallongevity",
        "tags": [
            "skeletallongevity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletalmarskman",
        "tags": [
            "skeletalmarskman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskillz",
        "tags": [
            "skillz"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskyfurytower",
        "tags": [
            "skyfurytower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslowoff",
        "tags": [
            "slowoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsmash",
        "tags": [
            "smash"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnarlmanethebloodgorger",
        "tags": [
            "snarlmanethebloodgorger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsorceressv0",
        "tags": [
            "sorceressv0"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsoul",
        "tags": [
            "soul"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspidercrablimbripper",
        "tags": [
            "spidercrablimbripper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiderling",
        "tags": [
            "spiderling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspikedbarricades",
        "tags": [
            "spikedbarricades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritbear",
        "tags": [
            "spiritbear"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritbeast",
        "tags": [
            "spiritbeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofpreservation2",
        "tags": [
            "staffofpreservation2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofpurification",
        "tags": [
            "staffofpurification"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofreanimation",
        "tags": [
            "staffofreanimation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstatup",
        "tags": [
            "statup"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsteelmelee",
        "tags": [
            "steelmelee"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsteelranged",
        "tags": [
            "steelranged"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstonearchitecture",
        "tags": [
            "stonearchitecture"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstormhammer",
        "tags": [
            "stormhammer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsturdywaraxe",
        "tags": [
            "sturdywaraxe"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnswordsman",
        "tags": [
            "swordsman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsylvanas",
        "tags": [
            "sylvanas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsylvanasghost",
        "tags": [
            "sylvanasghost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntamehippogriff",
        "tags": [
            "tamehippogriff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwateryminionlv2",
        "tags": [
            "wateryminionlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntaurenhut2",
        "tags": [
            "taurenhut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthaloriendawnseeker",
        "tags": [
            "thaloriendawnseeker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntharifas",
        "tags": [
            "tharifas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthievesguild",
        "tags": [
            "thievesguild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthoriumranged",
        "tags": [
            "thoriumranged"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthrallchampion",
        "tags": [
            "thrallchampion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderhawk",
        "tags": [
            "thunderhawk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntidesrevenant",
        "tags": [
            "tidesrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofpower",
        "tags": [
            "tomeofpower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofsacrifices",
        "tags": [
            "tomeofsacrifices"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntranqulity",
        "tags": [
            "tranqulity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarwarrior",
        "tags": [
            "tuskaarwarrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnultravision",
        "tags": [
            "ultravision"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunbrokendarkweaver",
        "tags": [
            "unbrokendarkweaver"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadload",
        "tags": [
            "undeadload"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadloadoff",
        "tags": [
            "undeadloadoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunholystrength",
        "tags": [
            "unholystrength"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunloaddwarf",
        "tags": [
            "unloaddwarf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnupgraderegenerationaura",
        "tags": [
            "upgraderegenerationaura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnuther",
        "tags": [
            "uther"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvengeanceincarnate",
        "tags": [
            "vengeanceincarnate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnviletemptress",
        "tags": [
            "viletemptress"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvoljin",
        "tags": [
            "voljin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvorpalblades",
        "tags": [
            "vorpalblades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwarriorarachnathid",
        "tags": [
            "warriorarachnathid"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwaterelemental",
        "tags": [
            "waterelemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnweboff",
        "tags": [
            "weboff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwendigoancient",
        "tags": [
            "wendigoancient"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwisphealoff",
        "tags": [
            "wisphealoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwraith",
        "tags": [
            "wraith"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnzombiefemale",
        "tags": [
            "zombiefemale"
        ]
    }
]

```

`overlay-ports/bullet3/cmake-fix.patch`:

```patch
diff --git a/BulletConfig.cmake.in b/BulletConfig.cmake.in
index f5dc7bd..50b3d67 100644
--- a/BulletConfig.cmake.in
+++ b/BulletConfig.cmake.in
@@ -13,13 +13,23 @@
 #  BULLET_LIBRARY_DIRS       - List of directories containing Bullet' libraries
 #  BULLET_ROOT_DIR           - The base directory of Bullet
 #  BULLET_VERSION_STRING     - A human-readable string containing the version
-
+@PACKAGE_INIT@
 set ( BULLET_FOUND 1 )
-set ( BULLET_USE_FILE     "@BULLET_USE_FILE@" )
+set_and_check ( BULLET_USE_FILE     "@PACKAGE_BULLET_CONFIG_CMAKE_PATH@/UseBullet.cmake" )
 set ( BULLET_DEFINITIONS  "@BULLET_DEFINITIONS@" )
-set ( BULLET_INCLUDE_DIR  "@INCLUDE_INSTALL_DIR@" )
-set ( BULLET_INCLUDE_DIRS "@INCLUDE_INSTALL_DIR@" )
+set_and_check ( BULLET_INCLUDE_DIR  "@PACKAGE_INCLUDE_INSTALL_DIR@" )
+set_and_check ( BULLET_INCLUDE_DIRS "@PACKAGE_INCLUDE_INSTALL_DIR@" )
 set ( BULLET_LIBRARIES    "@BULLET_LIBRARIES@" )
-set ( BULLET_LIBRARY_DIRS "@LIB_DESTINATION@" )
-set ( BULLET_ROOT_DIR     "@CMAKE_INSTALL_PREFIX@" )
-set ( BULLET_VERSION_STRING "@BULLET_VERSION@" )
\ No newline at end of file
+set_and_check ( BULLET_LIBRARY_DIRS "@PACKAGE_LIB_DESTINATION@" )
+set_and_check ( BULLET_ROOT_DIR     "@PACKAGE_CMAKE_INSTALL_PREFIX@" )
+set ( BULLET_VERSION_STRING "@BULLET_VERSION@" )
+# Load targets
+if(NOT TARGET Bullet3Common)
+  #
+  include("@PACKAGE_BULLET_CONFIG_CMAKE_PATH@/LinearMathTargets.cmake")
+  file(GLOB CONFIG_FILES "@PACKAGE_BULLET_CONFIG_CMAKE_PATH@/*Targets.cmake")
+  foreach(f IN LISTS CONFIG_FILES)
+    include(${f})
+  endforeach()
+  set(_DIR)
+endif()
diff --git a/CMakeLists.txt b/CMakeLists.txt
index a695b71..f98cf4d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,4 +1,4 @@
-cmake_minimum_required(VERSION 2.4.3)
+cmake_minimum_required(VERSION 3.5)
 set(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS true)
 cmake_policy(SET CMP0017 NEW)
 #this line has to appear before 'PROJECT' in order to be able to disable incremental linking
@@ -489,24 +489,33 @@ IF (BUILD_UNIT_TESTS)
 	SUBDIRS(test)
 ENDIF()
 
-set (BULLET_CONFIG_CMAKE_PATH lib${LIB_SUFFIX}/cmake/bullet )
+include(CMakePackageConfigHelpers)
+write_basic_package_version_file(
+	"${CMAKE_CURRENT_BINARY_DIR}/BulletConfigVersion.cmake"
+	VERSION ${BULLET_VERSION}
+	COMPATIBILITY AnyNewerVersion
+)
+
+set (BULLET_CONFIG_CMAKE_PATH share/bullet )
 list (APPEND BULLET_DEFINITIONS ${BULLET_DOUBLE_DEF})
-list (APPEND BULLET_LIBRARIES LinearMath)
 list (APPEND BULLET_LIBRARIES Bullet3Common)
 list (APPEND BULLET_LIBRARIES BulletInverseDynamics)
-list (APPEND BULLET_LIBRARIES BulletCollision)
 list (APPEND BULLET_LIBRARIES BulletDynamics)
+list (APPEND BULLET_LIBRARIES BulletCollision)
 list (APPEND BULLET_LIBRARIES BulletSoftBody)
-set (BULLET_USE_FILE ${BULLET_CONFIG_CMAKE_PATH}/UseBullet.cmake)
-configure_file 	( ${CMAKE_CURRENT_SOURCE_DIR}/BulletConfig.cmake.in
-					${CMAKE_CURRENT_BINARY_DIR}/BulletConfig.cmake
-					@ONLY ESCAPE_QUOTES
-				)
+list (APPEND BULLET_LIBRARIES LinearMath)
+configure_package_config_file(
+	${CMAKE_CURRENT_SOURCE_DIR}/BulletConfig.cmake.in
+	${CMAKE_CURRENT_BINARY_DIR}/BulletConfig.cmake
+	PATH_VARS INCLUDE_INSTALL_DIR LIB_DESTINATION CMAKE_INSTALL_PREFIX BULLET_CONFIG_CMAKE_PATH
+	INSTALL_DESTINATION ${BULLET_CONFIG_CMAKE_PATH}
+)
 OPTION(INSTALL_CMAKE_FILES "Install generated CMake files" ON)
 
 IF (INSTALL_CMAKE_FILES)
 	install ( FILES ${CMAKE_CURRENT_SOURCE_DIR}/UseBullet.cmake
 		${CMAKE_CURRENT_BINARY_DIR}/BulletConfig.cmake
+		${CMAKE_CURRENT_BINARY_DIR}/BulletConfigVersion.cmake
 		DESTINATION ${BULLET_CONFIG_CMAKE_PATH}
 	)
 ENDIF (INSTALL_CMAKE_FILES)
diff --git a/Extras/BulletRobotics/CMakeLists.txt b/Extras/BulletRobotics/CMakeLists.txt
index d2ab423..dabb504 100644
--- a/Extras/BulletRobotics/CMakeLists.txt
+++ b/Extras/BulletRobotics/CMakeLists.txt
@@ -282,7 +282,7 @@ SET_TARGET_PROPERTIES(BulletRobotics PROPERTIES VERSION ${BULLET_VERSION})
 SET_TARGET_PROPERTIES(BulletRobotics PROPERTIES SOVERSION ${BULLET_VERSION})
 
 IF (BUILD_SHARED_LIBS)
-	TARGET_LINK_LIBRARIES(BulletRobotics BulletInverseDynamicsUtils BulletWorldImporter BulletFileLoader BulletSoftBody BulletDynamics BulletCollision BulletInverseDynamics LinearMath Bullet3Common)
+	TARGET_LINK_LIBRARIES(BulletRobotics PUBLIC BulletInverseDynamicsUtils BulletWorldImporter BulletFileLoader BulletSoftBody BulletDynamics BulletCollision BulletInverseDynamics LinearMath Bullet3Common)
 ENDIF (BUILD_SHARED_LIBS)
 
   
diff --git a/Extras/BulletRoboticsGUI/CMakeLists.txt b/Extras/BulletRoboticsGUI/CMakeLists.txt
index 57ab97f..27b9992 100644
--- a/Extras/BulletRoboticsGUI/CMakeLists.txt
+++ b/Extras/BulletRoboticsGUI/CMakeLists.txt
@@ -166,7 +166,7 @@ SET_TARGET_PROPERTIES(BulletRoboticsGUI PROPERTIES VERSION ${BULLET_VERSION})
 SET_TARGET_PROPERTIES(BulletRoboticsGUI PROPERTIES SOVERSION ${BULLET_VERSION})
 
 IF (BUILD_SHARED_LIBS)
-	TARGET_LINK_LIBRARIES(BulletRoboticsGUI  BulletExampleBrowserLib BulletRobotics  BulletInverseDynamicsUtils BulletWorldImporter BulletFileLoader BulletSoftBody BulletDynamics BulletCollision BulletInverseDynamics LinearMath Bullet3Common)
+	TARGET_LINK_LIBRARIES(BulletRoboticsGUI PUBLIC BulletExampleBrowserLib BulletRobotics  BulletInverseDynamicsUtils BulletWorldImporter BulletFileLoader BulletSoftBody BulletDynamics BulletCollision BulletInverseDynamics LinearMath Bullet3Common)
 ENDIF (BUILD_SHARED_LIBS)
 
   
diff --git a/Extras/ConvexDecomposition/CMakeLists.txt b/Extras/ConvexDecomposition/CMakeLists.txt
index 132a336..62babb0 100644
--- a/Extras/ConvexDecomposition/CMakeLists.txt
+++ b/Extras/ConvexDecomposition/CMakeLists.txt
@@ -39,7 +39,7 @@ SET_TARGET_PROPERTIES(ConvexDecomposition PROPERTIES VERSION ${BULLET_VERSION})
 SET_TARGET_PROPERTIES(ConvexDecomposition PROPERTIES SOVERSION ${BULLET_VERSION})
 
 IF (BUILD_SHARED_LIBS)
-  TARGET_LINK_LIBRARIES(ConvexDecomposition BulletCollision LinearMath)
+  TARGET_LINK_LIBRARIES(ConvexDecomposition PUBLIC BulletCollision LinearMath)
 ENDIF (BUILD_SHARED_LIBS)
 
 IF (INSTALL_EXTRA_LIBS)
diff --git a/Extras/InverseDynamics/CMakeLists.txt b/Extras/InverseDynamics/CMakeLists.txt
index 22e953a..59b733d 100644
--- a/Extras/InverseDynamics/CMakeLists.txt
+++ b/Extras/InverseDynamics/CMakeLists.txt
@@ -22,7 +22,7 @@ SET_TARGET_PROPERTIES(BulletInverseDynamicsUtils PROPERTIES VERSION ${BULLET_VER
 SET_TARGET_PROPERTIES(BulletInverseDynamicsUtils PROPERTIES SOVERSION ${BULLET_VERSION})
 
 IF (BUILD_SHARED_LIBS)
-	TARGET_LINK_LIBRARIES(BulletInverseDynamicsUtils BulletInverseDynamics BulletDynamics BulletCollision Bullet3Common LinearMath)
+	TARGET_LINK_LIBRARIES(BulletInverseDynamicsUtils PUBLIC BulletInverseDynamics BulletDynamics BulletCollision Bullet3Common LinearMath)
 ENDIF (BUILD_SHARED_LIBS)
 
 IF (INSTALL_EXTRA_LIBS)
diff --git a/Extras/Serialize/BulletFileLoader/CMakeLists.txt b/Extras/Serialize/BulletFileLoader/CMakeLists.txt
index 9b5dce7..2f30385 100644
--- a/Extras/Serialize/BulletFileLoader/CMakeLists.txt
+++ b/Extras/Serialize/BulletFileLoader/CMakeLists.txt
@@ -21,7 +21,7 @@ btBulletFile.h
 ADD_LIBRARY(BulletFileLoader ${BulletFileLoader_SRCS} ${BulletFileLoader_HDRS})
 
 IF (BUILD_SHARED_LIBS)
-	TARGET_LINK_LIBRARIES(BulletFileLoader LinearMath)
+	TARGET_LINK_LIBRARIES(BulletFileLoader PUBLIC LinearMath)
 ENDIF (BUILD_SHARED_LIBS)
 
 SET_TARGET_PROPERTIES(BulletFileLoader PROPERTIES VERSION ${BULLET_VERSION})
diff --git a/Extras/Serialize/BulletWorldImporter/CMakeLists.txt b/Extras/Serialize/BulletWorldImporter/CMakeLists.txt
index b56b39a..1684651 100644
--- a/Extras/Serialize/BulletWorldImporter/CMakeLists.txt
+++ b/Extras/Serialize/BulletWorldImporter/CMakeLists.txt
@@ -16,7 +16,7 @@ SET_TARGET_PROPERTIES(BulletWorldImporter PROPERTIES VERSION ${BULLET_VERSION})
 SET_TARGET_PROPERTIES(BulletWorldImporter PROPERTIES SOVERSION ${BULLET_VERSION})
 
 IF (BUILD_SHARED_LIBS)
-	TARGET_LINK_LIBRARIES(BulletWorldImporter BulletDynamics BulletCollision BulletFileLoader LinearMath)
+	TARGET_LINK_LIBRARIES(BulletWorldImporter PUBLIC BulletDynamics BulletCollision BulletFileLoader LinearMath)
 ENDIF (BUILD_SHARED_LIBS)
 
 IF (INSTALL_EXTRA_LIBS)
diff --git a/Extras/Serialize/BulletXmlWorldImporter/CMakeLists.txt b/Extras/Serialize/BulletXmlWorldImporter/CMakeLists.txt
index 9fd125e..889c30e 100644
--- a/Extras/Serialize/BulletXmlWorldImporter/CMakeLists.txt
+++ b/Extras/Serialize/BulletXmlWorldImporter/CMakeLists.txt
@@ -18,7 +18,7 @@ SET_TARGET_PROPERTIES(BulletXmlWorldImporter  PROPERTIES VERSION ${BULLET_VERSIO
 SET_TARGET_PROPERTIES(BulletXmlWorldImporter PROPERTIES SOVERSION ${BULLET_VERSION})
 
 IF (BUILD_SHARED_LIBS)
-	TARGET_LINK_LIBRARIES(BulletXmlWorldImporter BulletWorldImporter BulletDynamics BulletCollision BulletFileLoader LinearMath)
+	TARGET_LINK_LIBRARIES(BulletXmlWorldImporter PUBLIC BulletWorldImporter BulletDynamics BulletCollision BulletFileLoader LinearMath)
 ENDIF (BUILD_SHARED_LIBS)
 
 IF (INSTALL_EXTRA_LIBS)
diff --git a/src/Bullet3Collision/CMakeLists.txt b/src/Bullet3Collision/CMakeLists.txt
index 130095c..661a461 100644
--- a/src/Bullet3Collision/CMakeLists.txt
+++ b/src/Bullet3Collision/CMakeLists.txt
@@ -69,9 +69,10 @@ IF (INSTALL_LIBS)
 		#FILES_MATCHING requires CMake 2.6
 		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS Bullet3Collision DESTINATION .)
+				INSTALL(TARGETS Bullet3Collision EXPORT Bullet3CollisionTargets DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 				INSTALL(TARGETS Bullet3Collision
+					EXPORT Bullet3CollisionTargets
 					RUNTIME DESTINATION bin
 					LIBRARY DESTINATION lib${LIB_SUFFIX}
 					ARCHIVE DESTINATION lib${LIB_SUFFIX})
@@ -89,5 +90,7 @@ DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h"  PATTERN
 			#SET_PROPERTY(SOURCE ${Bullet3CollisionBroadPhase_HDRS} PROPERTY MACOSX_PACKAGE_LOCATION Headers/BroadPhaseCollision)
 
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+		INSTALL(EXPORT Bullet3CollisionTargets
+			DESTINATION ${BULLET_CONFIG_CMAKE_PATH})
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 ENDIF (INSTALL_LIBS)
diff --git a/src/Bullet3Common/CMakeLists.txt b/src/Bullet3Common/CMakeLists.txt
index e899e67..e990b16 100644
--- a/src/Bullet3Common/CMakeLists.txt
+++ b/src/Bullet3Common/CMakeLists.txt
@@ -37,15 +37,17 @@ SET(Bullet3Common_HDRS
 ADD_LIBRARY(Bullet3Common ${Bullet3Common_SRCS} ${Bullet3Common_HDRS})
 SET_TARGET_PROPERTIES(Bullet3Common PROPERTIES VERSION ${BULLET_VERSION})
 SET_TARGET_PROPERTIES(Bullet3Common PROPERTIES SOVERSION ${BULLET_VERSION})
+TARGET_INCLUDE_DIRECTORIES(Bullet3Common INTERFACE $<INSTALL_INTERFACE:include/bullet>)
 
 IF (INSTALL_LIBS)
 	IF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 		#FILES_MATCHING requires CMake 2.6
 		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS Bullet3Common DESTINATION .)
+				INSTALL(TARGETS Bullet3Common EXPORT Bullet3CommonTargets DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 				INSTALL(TARGETS Bullet3Common
+					EXPORT Bullet3CommonTargets
 					RUNTIME DESTINATION bin
 					LIBRARY DESTINATION lib${LIB_SUFFIX}
 					ARCHIVE DESTINATION lib${LIB_SUFFIX})
@@ -59,5 +61,7 @@ DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h"  PATTERN
 			SET_TARGET_PROPERTIES(Bullet3Common PROPERTIES FRAMEWORK true)
 			SET_TARGET_PROPERTIES(Bullet3Common PROPERTIES PUBLIC_HEADER "${Bullet3Common_HDRS}")
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+		INSTALL(EXPORT Bullet3CommonTargets
+			DESTINATION ${BULLET_CONFIG_CMAKE_PATH})
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 ENDIF (INSTALL_LIBS)
diff --git a/src/Bullet3Dynamics/CMakeLists.txt b/src/Bullet3Dynamics/CMakeLists.txt
index 94c120d..e83503a 100644
--- a/src/Bullet3Dynamics/CMakeLists.txt
+++ b/src/Bullet3Dynamics/CMakeLists.txt
@@ -41,9 +41,10 @@ IF (INSTALL_LIBS)
 		#FILES_MATCHING requires CMake 2.6
 		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS Bullet3Dynamics DESTINATION .)
+				INSTALL(TARGETS Bullet3Dynamics EXPORT Bullet3DynamicsTargets DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 				INSTALL(TARGETS Bullet3Dynamics
+					EXPORT Bullet3DynamicsTargets
 					RUNTIME DESTINATION bin
 					LIBRARY DESTINATION lib${LIB_SUFFIX}
 					ARCHIVE DESTINATION lib${LIB_SUFFIX})
@@ -57,5 +58,7 @@ DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h"  PATTERN
 			SET_TARGET_PROPERTIES(Bullet3Dynamics PROPERTIES FRAMEWORK true)
 			SET_TARGET_PROPERTIES(Bullet3Dynamics PROPERTIES PUBLIC_HEADER "${Bullet3Dynamics_HDRS}")
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+		INSTALL(EXPORT Bullet3DynamicsTargets
+			DESTINATION ${BULLET_CONFIG_CMAKE_PATH})
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 ENDIF (INSTALL_LIBS)
diff --git a/src/Bullet3Geometry/CMakeLists.txt b/src/Bullet3Geometry/CMakeLists.txt
index 8206872..e605d79 100644
--- a/src/Bullet3Geometry/CMakeLists.txt
+++ b/src/Bullet3Geometry/CMakeLists.txt
@@ -27,9 +27,12 @@ IF (INSTALL_LIBS)
 		#FILES_MATCHING requires CMake 2.6
 		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS Bullet3Geometry DESTINATION .)
+							INSTALL(TARGETS Bullet3Geometry
+								EXPORT Bullet3GeometryTargets
+								DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 				INSTALL(TARGETS Bullet3Geometry
+					EXPORT Bullet3GeometryTargets
 					RUNTIME DESTINATION bin
 					LIBRARY DESTINATION lib${LIB_SUFFIX}
 					ARCHIVE DESTINATION lib${LIB_SUFFIX})
@@ -43,5 +46,8 @@ DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h"  PATTERN
 			SET_TARGET_PROPERTIES(Bullet3Geometry PROPERTIES FRAMEWORK true)
 			SET_TARGET_PROPERTIES(Bullet3Geometry PROPERTIES PUBLIC_HEADER "${Bullet3Geometry_HDRS}")
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+
+		INSTALL(EXPORT Bullet3GeometryTargets
+			DESTINATION ${BULLET_CONFIG_CMAKE_PATH})
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 ENDIF (INSTALL_LIBS)
diff --git a/src/Bullet3OpenCL/CMakeLists.txt b/src/Bullet3OpenCL/CMakeLists.txt
index 1da58d4..c1b21df 100644
--- a/src/Bullet3OpenCL/CMakeLists.txt
+++ b/src/Bullet3OpenCL/CMakeLists.txt
@@ -44,7 +44,7 @@ ADD_LIBRARY(Bullet3OpenCL_clew ${Bullet3OpenCL_clew_SRCS} ${Bullet3OpenCL_clew_H
 SET_TARGET_PROPERTIES(Bullet3OpenCL_clew PROPERTIES VERSION ${BULLET_VERSION})
 SET_TARGET_PROPERTIES(Bullet3OpenCL_clew PROPERTIES SOVERSION ${BULLET_VERSION})
 IF (BUILD_SHARED_LIBS)
-  TARGET_LINK_LIBRARIES(Bullet3OpenCL_clew LinearMath Bullet3Dynamics ${CMAKE_DL_LIBS})
+  TARGET_LINK_LIBRARIES(Bullet3OpenCL_clew PUBLIC LinearMath Bullet3Dynamics ${CMAKE_DL_LIBS})
 ENDIF (BUILD_SHARED_LIBS)
 
 
@@ -53,9 +53,13 @@ IF (INSTALL_LIBS)
 		#INSTALL of other files requires CMake 2.6
 		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS Bullet3OpenCL_clew DESTINATION .)
+				INSTALL(TARGETS BulletDynamics
+					EXPORT Bullet3OpenCLTargets
+					DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS Bullet3OpenCL_clew RUNTIME DESTINATION bin
+				INSTALL(TARGETS Bullet3OpenCL_clew
+								EXPORT Bullet3OpenCLTargets
+								RUNTIME DESTINATION bin
 								LIBRARY DESTINATION lib${LIB_SUFFIX}
 								ARCHIVE DESTINATION lib${LIB_SUFFIX})
 				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
@@ -73,5 +77,8 @@ DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h" PATTERN ".svn" E
 			SET_PROPERTY(SOURCE ${BroadphaseCollision_HDRS} PROPERTY MACOSX_PACKAGE_LOCATION Headers/BroadphaseCollision)
 
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+
+		INSTALL(EXPORT Bullet3OpenCLTargets
+			DESTINATION ${BULLET_CONFIG_CMAKE_PATH})
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 ENDIF (INSTALL_LIBS)
diff --git a/src/Bullet3Serialize/Bullet2FileLoader/CMakeLists.txt b/src/Bullet3Serialize/Bullet2FileLoader/CMakeLists.txt
index 1255766..67112b4 100644
--- a/src/Bullet3Serialize/Bullet2FileLoader/CMakeLists.txt
+++ b/src/Bullet3Serialize/Bullet2FileLoader/CMakeLists.txt
@@ -35,9 +35,12 @@ IF (INSTALL_LIBS)
 		#FILES_MATCHING requires CMake 2.6
 		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS Bullet2FileLoader DESTINATION .)
+				INSTALL(TARGETS Bullet2FileLoader
+					EXPORT Bullet2FileLoaderTargets
+					DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 				INSTALL(TARGETS Bullet2FileLoader
+					EXPORT Bullet2FileLoaderTargets
 					RUNTIME DESTINATION bin
 					LIBRARY DESTINATION lib${LIB_SUFFIX}
 					ARCHIVE DESTINATION lib${LIB_SUFFIX})
@@ -51,5 +54,8 @@ DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h"  PATTERN
 			SET_TARGET_PROPERTIES(Bullet2FileLoader PROPERTIES FRAMEWORK true)
 			SET_TARGET_PROPERTIES(Bullet2FileLoader PROPERTIES PUBLIC_HEADER "${Bullet2FileLoader_HDRS}")
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+
+		INSTALL(EXPORT Bullet2FileLoaderTargets
+			DESTINATION ${BULLET_CONFIG_CMAKE_PATH})
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 ENDIF (INSTALL_LIBS)
diff --git a/src/BulletCollision/CMakeLists.txt b/src/BulletCollision/CMakeLists.txt
index f5d7255..d857637 100644
--- a/src/BulletCollision/CMakeLists.txt
+++ b/src/BulletCollision/CMakeLists.txt
@@ -257,7 +257,7 @@ ADD_LIBRARY(BulletCollision ${BulletCollision_SRCS} ${BulletCollision_HDRS})
 SET_TARGET_PROPERTIES(BulletCollision PROPERTIES VERSION ${BULLET_VERSION})
 SET_TARGET_PROPERTIES(BulletCollision PROPERTIES SOVERSION ${BULLET_VERSION})
 IF (BUILD_SHARED_LIBS)
-  TARGET_LINK_LIBRARIES(BulletCollision LinearMath)
+  TARGET_LINK_LIBRARIES(BulletCollision PUBLIC LinearMath)
 ENDIF (BUILD_SHARED_LIBS)
 
 
@@ -266,9 +266,13 @@ IF (INSTALL_LIBS)
 		#INSTALL of other files requires CMake 2.6
 		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS BulletCollision DESTINATION .)
+				INSTALL(TARGETS BulletCollision
+					EXPORT BulletCollisionTargets
+					DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS BulletCollision RUNTIME DESTINATION bin
+				INSTALL(TARGETS BulletCollision 
+								EXPORT BulletCollisionTargets
+								RUNTIME DESTINATION bin
 								LIBRARY DESTINATION lib${LIB_SUFFIX}
 								ARCHIVE DESTINATION lib${LIB_SUFFIX})
 				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
@@ -290,5 +294,8 @@ DESTINATION ${INCLUDE_INSTALL_DIR}/BulletCollision)
 			SET_PROPERTY(SOURCE ${NarrowPhaseCollision_HDRS} PROPERTY MACOSX_PACKAGE_LOCATION Headers/NarrowPhaseCollision)
 
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+
+		INSTALL(EXPORT BulletCollisionTargets
+			DESTINATION ${BULLET_CONFIG_CMAKE_PATH})
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 ENDIF (INSTALL_LIBS)
diff --git a/src/BulletDynamics/CMakeLists.txt b/src/BulletDynamics/CMakeLists.txt
index 3332440..d1a1147 100644
--- a/src/BulletDynamics/CMakeLists.txt
+++ b/src/BulletDynamics/CMakeLists.txt
@@ -140,16 +140,21 @@ ADD_LIBRARY(BulletDynamics ${BulletDynamics_SRCS} ${BulletDynamics_HDRS})
 SET_TARGET_PROPERTIES(BulletDynamics PROPERTIES VERSION ${BULLET_VERSION})
 SET_TARGET_PROPERTIES(BulletDynamics PROPERTIES SOVERSION ${BULLET_VERSION})
 IF (BUILD_SHARED_LIBS)
-	TARGET_LINK_LIBRARIES(BulletDynamics BulletCollision LinearMath)
+	TARGET_LINK_LIBRARIES(BulletDynamics PUBLIC BulletCollision)
 ENDIF (BUILD_SHARED_LIBS)
+TARGET_LINK_LIBRARIES(BulletDynamics PUBLIC LinearMath)
 
 IF (INSTALL_LIBS)
 	IF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS BulletDynamics DESTINATION .)
+				INSTALL(TARGETS BulletDynamics
+					EXPORT BulletDynamicsTargets
+					DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS BulletDynamics RUNTIME DESTINATION bin
+				INSTALL(TARGETS BulletDynamics
+								EXPORT BulletDynamicsTargets 
+								RUNTIME DESTINATION bin
 								LIBRARY DESTINATION lib${LIB_SUFFIX}
 								ARCHIVE DESTINATION lib${LIB_SUFFIX})
 				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
@@ -171,5 +176,8 @@ DESTINATION ${INCLUDE_INSTALL_DIR}/BulletDynamics)
 			SET_PROPERTY(SOURCE ${Featherstone_HDRS} PROPERTY MACOSX_PACKAGE_LOCATION Headers/Featherstone)
 			SET_PROPERTY(SOURCE ${MLCPSolvers_HDRS} PROPERTY MACOSX_PACKAGE_LOCATION Headers/MLCPSolvers)
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+
+		INSTALL(EXPORT BulletDynamicsTargets
+			DESTINATION ${BULLET_CONFIG_CMAKE_PATH})
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 ENDIF (INSTALL_LIBS)
diff --git a/src/BulletInverseDynamics/CMakeLists.txt b/src/BulletInverseDynamics/CMakeLists.txt
index 3331c27..d4fad26 100644
--- a/src/BulletInverseDynamics/CMakeLists.txt
+++ b/src/BulletInverseDynamics/CMakeLists.txt
@@ -33,7 +33,7 @@ ADD_LIBRARY(BulletInverseDynamics ${BulletInverseDynamics_SRCS} ${BulletInverseD
 SET_TARGET_PROPERTIES(BulletInverseDynamics PROPERTIES VERSION ${BULLET_VERSION})
 SET_TARGET_PROPERTIES(BulletInverseDynamics PROPERTIES SOVERSION ${BULLET_VERSION})
 IF (BUILD_SHARED_LIBS)
-  TARGET_LINK_LIBRARIES(BulletInverseDynamics Bullet3Common LinearMath)
+  TARGET_LINK_LIBRARIES(BulletInverseDynamics PUBLIC Bullet3Common LinearMath)
 ENDIF (BUILD_SHARED_LIBS)
 
 
@@ -42,9 +42,13 @@ IF (INSTALL_LIBS)
 		#INSTALL of other files requires CMake 2.6
 		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS BulletInverseDynamics DESTINATION .)
+				INSTALL(TARGETS BulletInverseDynamics
+					EXPORT BulletInverseDynamicsTargets
+					DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS BulletInverseDynamics RUNTIME DESTINATION bin
+				INSTALL(TARGETS BulletInverseDynamics 
+								EXPORT BulletInverseDynamicsTargets
+								RUNTIME DESTINATION bin
 								LIBRARY DESTINATION lib${LIB_SUFFIX}
 								ARCHIVE DESTINATION lib${LIB_SUFFIX})
 				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
@@ -62,5 +66,8 @@ DESTINATION ${INCLUDE_INSTALL_DIR}/BulletInverseDynamics)
 			SET_PROPERTY(SOURCE ${BulletInverseDynamicsDetails_HDRS} PROPERTY MACOSX_PACKAGE_LOCATION Headers/details)
 
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+
+		INSTALL(EXPORT BulletInverseDynamicsTargets
+			DESTINATION ${BULLET_CONFIG_CMAKE_PATH})
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 ENDIF (INSTALL_LIBS)
diff --git a/src/BulletSoftBody/CMakeLists.txt b/src/BulletSoftBody/CMakeLists.txt
index 9452768..5068a30 100644
--- a/src/BulletSoftBody/CMakeLists.txt
+++ b/src/BulletSoftBody/CMakeLists.txt
@@ -78,9 +78,13 @@ IF (INSTALL_LIBS)
 	IF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS BulletSoftBody DESTINATION .)
+				INSTALL(TARGETS BulletSoftBody
+					EXPORT BulletSoftBodyTargets
+					DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-			INSTALL(TARGETS BulletSoftBody RUNTIME DESTINATION bin
+			INSTALL(TARGETS BulletSoftBody 
+							EXPORT BulletSoftBodyTargets
+							RUNTIME DESTINATION bin
 							LIBRARY DESTINATION lib${LIB_SUFFIX}
 							ARCHIVE DESTINATION lib${LIB_SUFFIX})
 				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
@@ -93,5 +97,8 @@ DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h"  PATTERN
 			SET_TARGET_PROPERTIES(BulletSoftBody PROPERTIES FRAMEWORK true)
 			SET_TARGET_PROPERTIES(BulletSoftBody PROPERTIES PUBLIC_HEADER "${BulletSoftBody_HDRS}")
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+
+		INSTALL(EXPORT BulletSoftBodyTargets
+			DESTINATION ${BULLET_CONFIG_CMAKE_PATH})
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 ENDIF (INSTALL_LIBS)
diff --git a/src/LinearMath/CMakeLists.txt b/src/LinearMath/CMakeLists.txt
index a0532c7..ecf06b3 100644
--- a/src/LinearMath/CMakeLists.txt
+++ b/src/LinearMath/CMakeLists.txt
@@ -63,9 +63,10 @@ IF (INSTALL_LIBS)
 		#FILES_MATCHING requires CMake 2.6
 		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
-				INSTALL(TARGETS LinearMath DESTINATION .)
+				INSTALL(TARGETS LinearMath EXPORT LinearMathTargets DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 				INSTALL(TARGETS LinearMath
+					EXPORT LinearMathTargets
 					RUNTIME DESTINATION bin
 					LIBRARY DESTINATION lib${LIB_SUFFIX}
 					ARCHIVE DESTINATION lib${LIB_SUFFIX})
@@ -79,5 +80,7 @@ DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h"  PATTERN
 			SET_TARGET_PROPERTIES(LinearMath PROPERTIES FRAMEWORK true)
 			SET_TARGET_PROPERTIES(LinearMath PROPERTIES PUBLIC_HEADER "${LinearMath_HDRS}")
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
+		INSTALL(EXPORT LinearMathTargets
+			DESTINATION ${BULLET_CONFIG_CMAKE_PATH})
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
 ENDIF (INSTALL_LIBS)

```

`overlay-ports/bullet3/portfile.cmake`:

```cmake
vcpkg_check_linkage(ONLY_STATIC_LIBRARY)

vcpkg_from_github(
    OUT_SOURCE_PATH SOURCE_PATH
    REPO bulletphysics/bullet3
    REF "${VERSION}"
    SHA512 7086e5fcf69635801bb311261173cb8d173b712ca1bd78be03df48fad884674e85512861190e45a1a62d5627aaad65cde08c175c44a3be9afa410d3dfd5358d4
    HEAD_REF master
    PATCHES
        cmake-fix.patch
)

vcpkg_check_features(OUT_FEATURE_OPTIONS FEATURE_OPTIONS
    FEATURES
        multithreading       BULLET2_MULTITHREADING
        double-precision     USE_DOUBLE_PRECISION
        extras               BUILD_EXTRAS
    INVERTED_FEATURES
        rtti                 USE_MSVC_DISABLE_RTTI
)

vcpkg_cmake_configure(
    SOURCE_PATH "${SOURCE_PATH}"
    OPTIONS
        -DUSE_MSVC_RUNTIME_LIBRARY_DLL=ON
        -DBUILD_CPU_DEMOS=OFF
        -DBUILD_BULLET2_DEMOS=OFF
        -DBUILD_OPENGL3_DEMOS=OFF
        -DBUILD_BULLET3=OFF
        -DBUILD_BULLET_ROBOTICS_GUI_EXTRA=OFF
        -DBUILD_BULLET_ROBOTICS_EXTRA=OFF
        -DBUILD_GIMPACTUTILS_EXTRA=OFF        
        -DBUILD_UNIT_TESTS=OFF        
        -DINSTALL_LIBS=ON
        -DCMAKE_POLICY_DEFAULT_CMP0057=NEW
        ${FEATURE_OPTIONS}
)

vcpkg_cmake_install()
vcpkg_copy_pdbs()

vcpkg_cmake_config_fixup(PACKAGE_NAME bullet CONFIG_PATH share/bullet)

vcpkg_fixup_pkgconfig()

file(REMOVE_RECURSE "${CURRENT_PACKAGES_DIR}/debug/share")
file(REMOVE_RECURSE "${CURRENT_PACKAGES_DIR}/debug/include")
file(REMOVE_RECURSE "${CURRENT_PACKAGES_DIR}/include/bullet/BulletInverseDynamics/details")

file(INSTALL "${CMAKE_CURRENT_LIST_DIR}/usage" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}")
vcpkg_install_copyright(FILE_LIST "${SOURCE_PATH}/LICENSE.txt")

```

`overlay-ports/bullet3/usage`:

```
Bullet3 provides CMake targets:

    find_package(Bullet CONFIG REQUIRED)
    target_link_libraries(main PRIVATE ${BULLET_LIBRARIES})

```

`overlay-ports/bullet3/vcpkg.json`:

```json
{
  "name": "bullet3",
  "version": "3.25",
  "port-version": 3,
  "description": "Bullet Physics is a professional collision detection, rigid body, and soft body dynamics library",
  "homepage": "https://github.com/bulletphysics/bullet3",
  "license": "Zlib",
  "dependencies": [
    {
      "name": "vcpkg-cmake",
      "host": true
    },
    {
      "name": "vcpkg-cmake-config",
      "host": true
    }
  ],
  "features": {
    "double-precision": {
      "description": "Use float64 doubles for bullet3"
    },
    "extras": {
      "description": "Build the extras"
    },
    "multithreading": {
      "description": "Multithreading functionality for bullet3"
    },
    "rtti": {
      "description": "Enable RTTI on windows"
    }
  }
}

```

`overlay-ports/casclib/portfile.cmake`:

```cmake
vcpkg_from_github(
    OUT_SOURCE_PATH SOURCE_PATH
    REPO ladislav-zezula/CascLib
    REF 1623348517352ff0d6364d47533c0d7f118b46e1
    SHA512 1b6dd77a399ff21a278d1ac68efa1417f2a9472b241401d3f6cb8f01ea702b32b4296012bb71ae62a932f9b0fa2b6d3035befe6f3ba0d567e85ac747c503b07c
    HEAD_REF master
)

string(COMPARE EQUAL "${VCPKG_LIBRARY_LINKAGE}" "dynamic" CASC_BUILD_SHARED_LIB)
string(COMPARE EQUAL "${VCPKG_LIBRARY_LINKAGE}" "static" CASC_BUILD_STATIC_LIB)

set(CASC_UNICODE OFF)

if(VCPKG_TARGET_IS_WINDOWS)
    message(STATUS "This version of CascLib is built in ASCII mode. To switch to UNICODE version, create an overlay port of this with CASC_UNICODE set to ON.")
    message(STATUS "This recipe is at ${CMAKE_CURRENT_LIST_DIR}")
    message(STATUS "See the overlay ports documentation at https://github.com/microsoft/vcpkg/blob/master/docs/specifications/ports-overlay.md")
endif()

vcpkg_cmake_configure(
    SOURCE_PATH "${SOURCE_PATH}"
    OPTIONS
        -DCMAKE_REQUIRE_FIND_PACKAGE_ZLIB=ON
        -DCASC_BUILD_SHARED_LIB=${CASC_BUILD_SHARED_LIB}
        -DCASC_BUILD_STATIC_LIB=${CASC_BUILD_STATIC_LIB}
        -DCASC_UNICODE=1
)

vcpkg_cmake_install()
vcpkg_copy_pdbs()

vcpkg_cmake_config_fixup(CONFIG_PATH lib/cmake/CascLib)

file(REMOVE_RECURSE "${CURRENT_PACKAGES_DIR}/debug/include")

file(INSTALL "${SOURCE_PATH}/LICENSE" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}" RENAME copyright)

```

`overlay-ports/casclib/vcpkg.json`:

```json
{
  "name": "casclib",
  "version-date": "2024-06-05",
  "description": "An open-source implementation of library for reading CASC storage from Blizzard games since 2014",
  "homepage": "http://www.zezula.net/en/casc/casclib.html",
  "dependencies": [
    {
      "name": "vcpkg-cmake",
      "host": true
    },
    {
      "name": "vcpkg-cmake-config",
      "host": true
    },
    "zlib"
  ]
}

```

`overlay-ports/soil2/portfile.cmake`:

```cmake
vcpkg_check_linkage(ONLY_STATIC_LIBRARY)
vcpkg_minimum_required(VERSION 2022-11-10)

vcpkg_from_github(
    OUT_SOURCE_PATH SOURCE_PATH
    REPO stijnherfst/SOIL2
    REF 32c62e15b61f599ea33d89ec904b618d217a1979
    SHA512 2d4df42f0f0412bd8c12d9b046be0cc2ebbe18af51096eec78c2c99e07e28ebd3fbab7ffe8d68095f91fdb2b9bcf7fb2fe42da2db0c761bc0cb9d21a22601362
    HEAD_REF master
)

vcpkg_cmake_configure(
    SOURCE_PATH "${SOURCE_PATH}"
    OPTIONS_DEBUG
        -DSOIL2_SKIP_HEADERS=ON
)

vcpkg_cmake_install()

vcpkg_copy_pdbs()
vcpkg_cmake_config_fixup()

vcpkg_install_copyright(FILE_LIST "${SOURCE_PATH}/LICENSE")
```

`overlay-ports/soil2/soil2Config.cmake.in`:

```in
# - Config file for the soil2 package
# It defines the following variables
#  SOIL2_INCLUDE_DIRS - include directories for SOIL2
#  SOIL2_LIBRARIES    - libraries to link against

# Load targets
get_filename_component(SOIL2_CMAKE_DIR "${CMAKE_CURRENT_LIST_FILE}" PATH)
include("${SOIL2_CMAKE_DIR}/soil2Targets.cmake")

# Set properties
get_target_property(SOIL2_INCLUDE_DIRS soil2 INTERFACE_INCLUDE_DIRECTORIES)
set(SOIL2_LIBRARIES soil2)
mark_as_advanced(SOIL2_INCLUDE_DIRS SOIL2_LIBRARIES)

```

`overlay-ports/soil2/vcpkg.json`:

```json
{
  "name": "soil2",
  "version": "1.3.0",
  "description": "Simple OpenGL Image Library 2",
  "homepage": "https://github.com/SpartanJ/SOIL2",
  "license": "MIT-0",
  "dependencies": [
    {
      "name": "vcpkg-cmake",
      "host": true
    },
    {
      "name": "vcpkg-cmake-config",
      "host": true
    }
  ]
}

```

`overlay-ports/stormlib/portfile.cmake`:

```cmake
vcpkg_from_github(
    OUT_SOURCE_PATH SOURCE_PATH
    REPO ladislav-zezula/StormLib
    REF b41cda40f9c3fbdb802cf63e739425cd805eecaa
    SHA512 bf65dfaba48194efcd777a5700961fb524afadad1fb63041c10d61b454a36d2067c551af61ce936478d199000e7c1bb4d3bd56a3794002b6646e4b9e18d4d4cd
    HEAD_REF master
)

vcpkg_cmake_configure(
    SOURCE_PATH "${SOURCE_PATH}"
    OPTIONS
        -DSTORM_UNICODE=ON
)

vcpkg_cmake_install()
vcpkg_cmake_config_fixup(PACKAGE_NAME StormLib)
vcpkg_copy_pdbs()


file(INSTALL "${SOURCE_PATH}/LICENSE" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}" RENAME copyright)
file(REMOVE_RECURSE "${CURRENT_PACKAGES_DIR}/debug/include")
file(REMOVE_RECURSE "${CURRENT_PACKAGES_DIR}/debug/share")

```

`overlay-ports/stormlib/vcpkg.json`:

```json
{
  "name": "stormlib",
  "version": "9.30",
  "description": "StormLib is a library for opening and manipulating Blizzard MPQ files",
  "dependencies": [
    "bzip2",
    {
      "name": "vcpkg-cmake",
      "host": true
    },
    {
      "name": "vcpkg-cmake-config",
      "host": true
    },
    "zlib"
  ]
}

```

`src/CMakeLists.txt`:

```txt
target_sources(HiveWE PUBLIC FILE_SET yeet TYPE CXX_MODULES FILES
	"types.ixx"
	"map_global.ixx"
	"globals.ixx"

	"base/map.ixx"
	"base/binary_reader.ixx"
	"base/doodad.ixx"
	"base/doodads.ixx"
	"base/binary_writer.ixx"
	"base/hierarchy.ixx"
	"base/render_manager.ixx"
	"base/game_cameras.ixx"
	"base/imports.ixx"
	"base/map_info.ixx"
	"base/pathing_map.ixx"
	"base/regions.ixx"
	"base/camera.ixx"
	"base/world_undo_manager.ixx"
	"base/window_handler.ixx"
	"base/resource_manager.ixx"
	"base/shadow_map.ixx"
	"base/sounds.ixx"
	"base/trigger_strings.ixx"
	"base/physics.ixx"
	"base/terrain_undo.ixx"
	"base/units_undo.ixx"
	"base/pathing_undo.ixx"
	"base/doodads_undo.ixx"
	"base/units.ixx"
	"base/terrain.ixx"

	"base/triggers/triggers.ixx"
	"base/triggers/gui.cpp"
	"base/triggers/map_script.cpp"

	"file_formats/blp.ixx"
	"file_formats/casc.ixx"
	"file_formats/ini.ixx"
	"file_formats/json.ixx"
	"file_formats/mdx/mdx.ixx"

	"file_formats/mpq.ixx"
	"file_formats/slk.ixx"

	"resources/cliff_mesh.ixx"
	"resources/gpu_texture.ixx"
	"resources/ground_texture.ixx"
	"resources/shader.ixx"

	"resources/texture.ixx"
	"resources/pathing_texture.ixx"
	"resources/qicon_resource.ixx"
	"resources/editable_mesh.ixx"
	"resources/skinned_mesh/render_node.ixx"
	"resources/skinned_mesh/skeletal_model_instance.ixx" 
	"resources/skinned_mesh.ixx" 

	"models/tree/ability_tree_model.ixx"
	"models/tree/base_tree_model.ixx"
	"models/tree/buff_tree_model.ixx"
	"models/tree/destructible_tree_model.ixx"
	"models/tree/doodad_tree_model.ixx"
	"models/tree/item_tree_model.ixx"
	"models/tree/unit_tree_model.ixx"
	"models/tree/upgrade_tree_model.ixx"

	"models/list/ability_list_model.ixx"
	"models/list/base_list_model.ixx"
	"models/list/destructible_list_model.ixx"
	"models/list/doodad_list_model.ixx"
	"models/list/item_list_model.ixx"
	"models/list/unit_list_model.ixx"
	"models/list/upgrade_list_model.ixx"
	"models/list/buff_list_model.ixx"

	"models/table_model.ixx"

	"object_editor/slk_conversions.ixx"

	"custom_widgets/aspect_ratio_pixmap_label.ixx"
	"custom_widgets/color_button.ixx"

	"custom_widgets/qribbon.ixx"
	"custom_widgets/unit_selector.ixx"
	"custom_widgets/flow_layout.ixx"

	"utilities/timer.ixx"
	"utilities/utilities.ixx"
	"utilities/opengl_utilities.ixx"
	"utilities/modification_tables.ixx" 
	"utilities/unordered_map.ixx"

	"utilities/no_init_allocator.ixx"
	"utilities/math_operations.ixx"
	
	"test.ixx"
	"object_editor/ability_list_editor.ixx"
)

target_sources(HiveWE PRIVATE
	"main.cpp"

	"main_window/hivewe.rc"
	"main_window/hivewe.cpp"	
	"main_window/glwidget.cpp"
	"main_window/main_ribbon.cpp"

	"brush/brush.cpp"
	"brush/doodad_brush.cpp"
	"brush/pathing_brush.cpp"
	"brush/terrain_brush.cpp"
	"brush/unit_brush.cpp"
	
	"file_formats/mdx/mdl_reader.cpp"
	"file_formats/mdx/mdl_writer.cpp"
	"file_formats/mdx/mdx_reader.cpp"
	"file_formats/mdx/mdx_writer.cpp"
	"file_formats/mdx/optimizer.cpp"
	"file_formats/mdx/utilities.cpp"
	"file_formats/mdx/validator.cpp"


	"menus/doodad_palette.cpp"
	"menus/map_info_editor.cpp"
	"menus/minimap.cpp"
	"menus/palette.cpp"
	"menus/pathing_palette.cpp"
	"menus/settings_editor.cpp"
	"menus/terrain_palette.cpp"
	"menus/unit_palette.cpp"
	"menus/tile_pather.cpp"
	"menus/tile_picker.cpp"
	"menus/tile_setter.cpp"

	"models/single_model.cpp"
	
	"custom_widgets/aspect_ratio_pixmap_label.h"
	"custom_widgets/color_button.h"

	"trigger_editor/trigger_editor.cpp"
	"trigger_editor/search_window.cpp"
	"trigger_editor/jass_editor.cpp"
	"trigger_editor/jass_tokenizer.cpp"
	"trigger_editor/trigger_explorer.cpp"
	"trigger_editor/variable_editor.cpp"
	"trigger_editor/trigger_model.cpp"

	"model_editor/model_editor_camera.cpp"
	"model_editor/model_editor.cpp"
	"model_editor/model_editor_glwidget.cpp"

	"object_editor/icon_view.cpp"
	"object_editor/model_view.cpp"
	"object_editor/object_editor.cpp"
	"object_editor/global_search.cpp"

	"qt_imgui/imgui_renderer.cpp"
	"qt_imgui/qt_imgui.cpp"

	
 )
```

`src/base/binary_reader.ixx`:

```ixx
export module BinaryReader;

import std;
import types;
import no_init_allocator;

export class BinaryReader {
  public:
	std::vector<u8, default_init_allocator<u8>> buffer;
	unsigned long long int position = 0;

	explicit BinaryReader(std::vector<u8, default_init_allocator<u8>> buffer)
		: buffer(std::move(buffer)) {
	}

	template <typename T>
	[[nodiscard]] T read() {
		static_assert(std::is_trivial_v<T>, "T must be of trivial type.");

		if (position + sizeof(T) > buffer.size()) {
			throw std::out_of_range("Trying to read out of range of buffer");
		}

		T result;
		std::memcpy(&result, &buffer[position], sizeof(T));

		position += sizeof(T);
		return result;
	}

	[[nodiscard]] std::string read_string(const size_t size) {
		if (position + size > buffer.size()) {
			throw std::out_of_range("Trying to read out of range of buffer");
		}

		std::string result;
		result.resize(size);
		std::memcpy(result.data(), &buffer[position], size);

		if (const size_t pos = result.find_first_of('\0', 0); pos != std::string::npos) {
			result.resize(pos);
		}

		position += size;
		return result;
	}

	[[nodiscard]] std::string read_c_string() {
		const std::string string(reinterpret_cast<char*>(buffer.data() + position));
		position += string.size() + 1;

		if (position > buffer.size()) {
			throw std::out_of_range("Trying to read out of range of buffer");
		}

		return string;
	}

	template <typename T>
	[[nodiscard]] std::vector<T> read_vector(const size_t size) {
		static_assert(std::is_trivial_v<T>, "T must be of trivial type.");

		if (position + sizeof(T) * size > buffer.size()) {
			throw std::out_of_range("Trying to read out of range of buffer");
		}
		std::vector<T> result(reinterpret_cast<T*>(&buffer[position]), reinterpret_cast<T*>(&buffer[position]) + size);
		position += sizeof(T) * size;
		return result;
	}

	[[nodiscard]] long long remaining() const {
		return buffer.size() - position;
	}

	void advance(const size_t amount) {
		if (position + amount > buffer.size()) {
			throw std::out_of_range("Trying to advance past the end of the buffer");
		}
		position += amount;
	}

	void advance_c_string() {
		position += std::string(reinterpret_cast<char*>(buffer.data() + position)).size() + 1;

		if (position > buffer.size()) {
			throw std::out_of_range("Trying to read out of range of buffer");
		}
	}
};
```

`src/base/binary_writer.ixx`:

```ixx
export module BinaryWriter;

import std;
import types;

export class BinaryWriter {
  public:
	std::vector<u8> buffer;

	template <typename T = void, typename U>
	void write(U value) {
		static_assert(std::is_standard_layout_v<U>, "U must be of standard layout.");

		if constexpr (not std::is_void_v<T>) {
			static_assert(std::is_standard_layout_v<T>, "T must be of standard layout.");

			T temp = static_cast<T>(value);
			buffer.resize(buffer.size() + sizeof(T));
			std::memcpy(buffer.data() + buffer.size() - sizeof(T), &temp, sizeof(T));
		} else {
			U temp = value;
			buffer.resize(buffer.size() + sizeof(U));
			std::memcpy(buffer.data() + buffer.size() - sizeof(U), &temp, sizeof(U));
		}
	}

	/// Writes the string to the buffer (null terminated if the input string is null terminated)
	/// ToDo string_view?
	void write_string(const std::string& string) {
		buffer.resize(buffer.size() + string.size());
		std::copy(string.begin(), string.end(), buffer.end() - string.size());
	}

	/// Writes a null terminated string to the buffer
	/// ToDo string_view?
	void write_c_string(const std::string& string) {
		if (!string.empty() && string.back() == '\0') {
			buffer.resize(buffer.size() + string.size());
			std::copy(string.begin(), string.end(), buffer.end() - string.size());
		} else {
			buffer.resize(buffer.size() + string.size() + 1);
			std::copy(string.begin(), string.end(), buffer.end() - string.size() - 1);
			buffer[buffer.size() - 1] = '\0';
		}
	}

	/// Writes a null terminated string to the buffer with padding
	/// ToDo string_view?
	void write_c_string_padded(const std::string& string, int final_size) {
		buffer.resize(buffer.size() + final_size);
		std::copy(string.begin(), string.end(), buffer.end() - final_size);

		// std::vector::resize will memset to 0 so adding a \0 terminator is not required
	}

	/// Copies the contents of the array to the buffer, has special code for std::string
	template <typename T>
	void write_vector(const std::vector<T>& vector) {
		if constexpr (std::is_same_v<T, std::string>) {
			for (const auto& i : vector) {
				buffer.insert(buffer.end(), i.begin(), i.end());
			}
		} else {
			static_assert(std::is_standard_layout<T>::value, "T must be of standard layout or std::string.");
			buffer.resize(buffer.size() + vector.size() * sizeof(T));
			// std::copy(vector.begin(), vector.end(), buffer.end() - vector.size() * sizeof(T));
			std::memcpy(buffer.data() + buffer.size() - vector.size() * sizeof(T), vector.data(), vector.size() * sizeof(T));
		}
	}
};
```

`src/base/camera.ixx`:

```ixx
module;

#include <QWheelEvent>

export module Camera;

import std;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;
import <glm/gtc/quaternion.hpp>;

export class InputHandler {
  public:
	glm::vec2 mouse;
	glm::vec2 previous_mouse;

	glm::vec3 mouse_world;
	glm::vec3 previous_mouse_world;

	glm::vec3 drag_start;

	std::unordered_set<int> keys_pressed;

	bool key_pressed(const Qt::Key key) const {
		return keys_pressed.contains(key);
	}

	void mouse_move_event(const QMouseEvent* event) {
		previous_mouse = mouse;
		mouse = {event->pos().x(), event->pos().y()};
	}
};

export inline InputHandler input_handler;

export struct Camera {
	glm::vec3 position = {0, 0, 0};

	float distance = 20.f;

	glm::vec3 direction = {0, 1, 0};
	glm::vec3 X = {1, 0, 0};
	glm::vec3 Y = {0, 1, 0};
	glm::vec3 up = {0, 0, 1};
	glm::vec3 forward = {0, 1, 0};

	float fov = 70.f;
	float aspect_ratio = 16.f / 9.f;
	float draw_distance_close = 0.05f;
	float draw_distance_far = 2000.f;
	float fov_rad = (glm::pi<double>() / 180.f) * static_cast<double>(fov); // Need radians
	float tan_height = 2.f * glm::tan(fov_rad * 0.5f);

	glm::mat4 projection = glm::perspective(fov, aspect_ratio, draw_distance_close, draw_distance_far);
	glm::mat4 view = glm::lookAt(position - direction * distance, position, up);
	glm::mat4 view_inverse;
	glm::mat4 projection_view;

	float horizontal_angle = 0.f;
	float vertical_angle = -0.977f;

	struct Plane {
		glm::vec3 normal;
		float d;
	};

	Plane frustrum_planes[6];

	void extract_frustrum_planes() {
		const auto vp = projection_view;

		// Left
		frustrum_planes[0].normal = glm::vec3(vp[0][3] + vp[0][0], vp[1][3] + vp[1][0], vp[2][3] + vp[2][0]);
		frustrum_planes[0].d = vp[3][3] + vp[3][0];

		// Right
		frustrum_planes[1].normal = glm::vec3(vp[0][3] - vp[0][0], vp[1][3] - vp[1][0], vp[2][3] - vp[2][0]);
		frustrum_planes[1].d = vp[3][3] - vp[3][0];

		// Bottom
		frustrum_planes[2].normal = glm::vec3(vp[0][3] + vp[0][1], vp[1][3] + vp[1][1], vp[2][3] + vp[2][1]);
		frustrum_planes[2].d = vp[3][3] + vp[3][1];

		// Top
		frustrum_planes[3].normal = glm::vec3(vp[0][3] - vp[0][1], vp[1][3] - vp[1][1], vp[2][3] - vp[2][1]);
		frustrum_planes[3].d = vp[3][3] - vp[3][1];

		// Near
		frustrum_planes[4].normal = glm::vec3(vp[0][3] + vp[0][2], vp[1][3] + vp[1][2], vp[2][3] + vp[2][2]);
		frustrum_planes[4].d = vp[3][3] + vp[3][2];

		// Far
		frustrum_planes[5].normal = glm::vec3(vp[0][3] - vp[0][2], vp[1][3] - vp[1][2], vp[2][3] - vp[2][2]);
		frustrum_planes[5].d = vp[3][3] - vp[3][2];

		for (auto& p : frustrum_planes) {
			const float inv_len = 1.0f / glm::length(p.normal);
			p.normal *= inv_len;
			p.d *= inv_len;
		}
	}

	bool inside_frustrum(const glm::vec3& min, const glm::vec3& max) const {
		for (const auto& p : frustrum_planes) {
			glm::vec3 positive = min;
			if (p.normal.x >= 0) {
				positive.x = max.x;
			}
			if (p.normal.y >= 0) {
				positive.y = max.y;
			}
			if (p.normal.z >= 0) {
				positive.z = max.z;
			}

			if (glm::dot(p.normal, positive) + p.d < 0) {
				return false;
			}
		}
		return true;
	}

	bool inside_frustrum_transform(const glm::vec3& min, const glm::vec3& max, const glm::mat4& matrix) const {
		const glm::vec3 center = (min + max) * 0.5f;
		const glm::vec3 extents = (max - min) * 0.5f;

		const glm::vec3 new_center = glm::vec3(matrix * glm::vec4(center, 1.0f));

		const glm::mat3 rot_scale = glm::mat3(matrix);
		const glm::mat3 absolute_rotation_scale = glm::mat3(glm::abs(rot_scale[0]), glm::abs(rot_scale[1]), glm::abs(rot_scale[2]));

		const glm::vec3 new_extents = absolute_rotation_scale * extents;
		const glm::vec3 new_min = new_center - new_extents;
		const glm::vec3 new_max = new_center + new_extents;

		for (const auto& p : frustrum_planes) {
			glm::vec3 positive = new_min;
			if (p.normal.x >= 0) {
				positive.x = new_max.x;
			}
			if (p.normal.y >= 0) {
				positive.y = new_max.y;
			}
			if (p.normal.z >= 0) {
				positive.z = new_max.z;
			}

			if (glm::dot(p.normal, positive) + p.d < 0) {
				return false;
			}
		}
		return true;
	}

	void update(const double delta) {
		direction = glm::vec3(
			std::cos(vertical_angle) * std::sin(horizontal_angle),
			std::cos(vertical_angle) * std::cos(horizontal_angle),
			std::sin(vertical_angle)
		);

		direction = glm::normalize(direction);
		// Calculate axis directions for camera as referential point:
		X = glm::normalize(glm::cross(direction, up));
		Y = glm::normalize(glm::cross(X, direction));

		// The vector that is perpendicular to the up vector, thus points forward
		forward = glm::cross(X, up);

		if (input_handler.key_pressed(Qt::Key_Left)) {
			position += -X * 40.f * static_cast<float>(delta) * (distance / 30.f);
		} else if (input_handler.key_pressed(Qt::Key_Right)) {
			position += X * 40.f * static_cast<float>(delta) * (distance / 30.f);
		}

		if (input_handler.key_pressed(Qt::Key_Up)) {
			position += -forward * 40.f * static_cast<float>(delta) * (distance / 30.f);
		} else if (input_handler.key_pressed(Qt::Key_Down)) {
			position += forward * 40.f * static_cast<float>(delta) * (distance / 30.f);
		}

		projection = glm::perspective(fov, aspect_ratio, draw_distance_close, draw_distance_far);
		view = glm::lookAt(position - direction * distance, position, up);
		view_inverse = glm::inverse(view);
		projection_view = projection * view;

		extract_frustrum_planes();
	}

	void mouse_move_event(QMouseEvent* event) {
		glm::vec2 diff = input_handler.mouse - input_handler.previous_mouse;

		if (event->buttons() == Qt::RightButton && event->modifiers() & Qt::ControlModifier) {
			horizontal_angle += diff.x * 0.0025f;
			vertical_angle -= diff.y * 0.0025f;
			vertical_angle = std::max(-glm::pi<float>() / 2.f + 0.001f, std::min(vertical_angle, glm::pi<float>() / 2.f - 0.001f));
			update(0.0);
		} else if (event->buttons() == Qt::RightButton) {
			position += X * (-diff.x * 0.025f * (distance / 30.f));
			position += forward * (-diff.y * 0.025f * (distance / 30.f));
			update(0.0);
		}
	}

	void mouse_scroll_event(const QWheelEvent* event) {
		distance = std::clamp(distance * std::pow(0.999f, static_cast<float>(event->angleDelta().y())), 0.001f, 1000.f);
		update(0.0);
	}

	void mouse_press_event(QMouseEvent* event) {}

	void mouse_release_event(QMouseEvent* event) {}

	void reset() {
		distance = 20.f;
		horizontal_angle = 0.0f;
		vertical_angle = -0.977f;
		update(0.0);
	}
};

export inline Camera camera;

```

`src/base/doodad.ixx`:

```ixx
module;

#include <QRectF>

export module Doodad;

import std;
import SkinnedMesh;
import PathingTexture;
import SkeletalModelInstance;
import Terrain;
import SLK;
import Globals;
import ResourceManager;
import Utilities;
import <glm/glm.hpp>;
import <glm/gtc/quaternion.hpp>;

export struct Doodad {
	static inline int auto_increment;

	std::string id;
	std::string skin_id;
	int variation = 0;
	glm::vec3 position = glm::vec3(0.f);
	glm::vec3 scale = glm::vec3(1.f);
	float angle = 0.f;

	enum class State {
		invisible_non_solid,
		visible_non_solid,
		visible_solid
	};
	State state = State::visible_solid;
	int life = 100;

	int item_table_pointer = -1;
	std::vector<ItemSet> item_sets;

	int creation_number;

	// Auxiliary data
	SkeletalModelInstance skeleton;
	std::shared_ptr<SkinnedMesh> mesh;
	std::shared_ptr<PathingTexture> pathing;
	glm::vec3 color = glm::vec3(1.f);

	void init(const std::string_view id, const std::shared_ptr<SkinnedMesh> mesh, const Terrain& terrain) {
		this->id = id;
		this->skin_id = id;
		this->mesh = mesh;

		skeleton = SkeletalModelInstance(mesh->mdx);
		// Get pathing map
		const bool is_doodad = doodads_slk.row_headers.contains(id);
		const slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;

		pathing.reset();
		const auto path = slk.data<std::string_view>("pathtex", id);
		const auto trimmed_path = trimmed(path);
		if (!trimmed_path.empty() && trimmed_path != "none" && trimmed_path != "_") {
			try {
				pathing = resource_manager.load<PathingTexture>(trimmed_path);
			} catch (const std::exception& e) {
				std::println("Error load pathing texture for doodad with ID: {} and error {}", id, e.what());
			}
		}

		update(terrain);
	}

	void update(const Terrain& terrain) {
		float base_scale = 1.f;
		float max_roll;
		float max_pitch;
		if (doodads_slk.row_headers.contains(id)) {
			color.r = doodads_slk.data<float>("vertr" + std::to_string(variation + 1), id) / 255.f;
			color.g = doodads_slk.data<float>("vertg" + std::to_string(variation + 1), id) / 255.f;
			color.b = doodads_slk.data<float>("vertb" + std::to_string(variation + 1), id) / 255.f;
			max_roll = doodads_slk.data<float>("maxroll", id);
			max_pitch = doodads_slk.data<float>("maxpitch", id);
			base_scale = doodads_slk.data<float>("defscale", id);
		} else {
			color.r = destructibles_slk.data<float>("colorr", id) / 255.f;
			color.g = destructibles_slk.data<float>("colorg", id) / 255.f;
			color.b = destructibles_slk.data<float>("colorb", id) / 255.f;
			max_roll = destructibles_slk.data<float>("maxroll", id);
			max_pitch = destructibles_slk.data<float>("maxpitch", id);
		}

		glm::quat rotation = glm::angleAxis(angle, glm::vec3(0, 0, 1));

		constexpr float SAMPLE_RADIUS = 32.f / 128.f;

		// A negative value is a way for the user to set a specific (positive) value
		// A positive value indicates to follow the terrain
		float pitch = 0.f;
		if (max_pitch < 0.f) {
			pitch = max_pitch;
		} else if (max_pitch > 0.f) {
			const float forward_x = position.x + (SAMPLE_RADIUS * std::cos(angle));
			const float forward_y = position.y + (SAMPLE_RADIUS * std::sin(angle));
			const float backward_x = position.x - (SAMPLE_RADIUS * std::cos(angle));
			const float backward_y = position.y - (SAMPLE_RADIUS * std::sin(angle));

			const float height1 = terrain.interpolated_height(backward_x, backward_y, false);
			const float height2 = terrain.interpolated_height(forward_x, forward_y, false);

			pitch = std::clamp(std::atan2(height2 - height1, SAMPLE_RADIUS * 2.f), -pitch, pitch);
		}
		rotation *= glm::angleAxis(-pitch, glm::vec3(0, 1, 0));

		// A negative value is a way for the user to set a specific (positive) value
		// A positive value indicates to follow the terrain
		float roll = 0.f;
		if (max_roll < 0.f) {
			roll = -max_roll;
		} else if (max_roll > 0.f) {
			const float left_of_angle = angle + (3.1415926535 / 2.0);
			const float forward_x = position.x + (SAMPLE_RADIUS * std::cos(left_of_angle));
			const float forward_y = position.y + (SAMPLE_RADIUS * std::sin(left_of_angle));
			const float backward_x = position.x - (SAMPLE_RADIUS * std::cos(left_of_angle));
			const float backward_y = position.y - (SAMPLE_RADIUS * std::sin(left_of_angle));

			const float height1 = terrain.interpolated_height(backward_x, backward_y, false);
			const float height2 = terrain.interpolated_height(forward_x, forward_y, false);

			roll = std::clamp(atan2(height2 - height1, SAMPLE_RADIUS * 2.f), -roll, roll);
		}
		rotation *= glm::angleAxis(roll, glm::vec3(1, 0, 0));

		skeleton.update_location(position, rotation, (base_scale * scale) / 128.f);
	}

	[[nodiscard]] QRect get_pathing_bounding_box() const {
		if (!pathing) {
			return {};
		}

		const int rotation = glm::degrees(angle);
		const int rotated_width = rotation % 180 ? pathing->width : pathing->height;
		const int rotated_height = rotation % 180 ? pathing->height : pathing->width;
		const int x = position.x * 4 - rotated_width / 2;
		const int y = position.y * 4 - rotated_height / 2;
		return QRect{x, y, rotated_width, rotated_height};
	}

	static glm::vec2 acceptable_position(
		const glm::vec2 position,
		const std::shared_ptr<PathingTexture>& pathing,
		const float angle,
		const bool force_grid_aligned = false
	) {
		if (!pathing) {
			if (force_grid_aligned) {
				return glm::round(position * 2.f) * 0.5f;
			} else {
				return position;
			}
		}

		const int rotation = glm::degrees(angle);
		const int rotated_width = rotation % 180 ? pathing->width : pathing->height;
		const int rotated_height = rotation % 180 ? pathing->height : pathing->width;

		glm::vec2 extra_offset(0.0f);
		if (rotated_width % 4 != 0) {
			extra_offset.x = 0.25f;
		}

		if (rotated_height % 4 != 0) {
			extra_offset.y = 0.25f;
		}

		return glm::round((position + extra_offset) * 2.f) * 0.5f - extra_offset;
	}

	static float acceptable_angle(
		const std::string_view id,
		const std::shared_ptr<PathingTexture>& pathing,
		const float current_angle,
		const float target_angle
	) {
		float fixed_rotation = 0.0;
		if (doodads_slk.row_headers.contains(id)) {
			fixed_rotation = doodads_slk.data<float>("fixedrot", id);
		} else {
			fixed_rotation = destructibles_slk.data<float>("fixedrot", id);
		}

		// Negative values indicate free rotation, positive is a fixed angle
		if (fixed_rotation >= 0.0) {
			return glm::radians(fixed_rotation);
		}

		if (pathing) {
			if (pathing->width == pathing->height && pathing->homogeneous) {
				return target_angle;
			} else {
				return (static_cast<int>((target_angle + glm::pi<float>() * 0.25f) / (glm::pi<float>() * 0.5f)) % 4) * glm::pi<float>()
					* 0.5f;
			}
		} else {
			return target_angle;
		}
	}
};

export struct SpecialDoodad {
	std::string id;
	int variation;
	glm::vec3 position;
	glm::vec3 old_position;

	// Auxiliary data
	glm::mat4 matrix = glm::mat4(1.f);
	SkeletalModelInstance skeleton;
	std::shared_ptr<SkinnedMesh> mesh;
	std::shared_ptr<PathingTexture> pathing;
};
```

`src/base/doodads.ixx`:

```ixx
module;

#include <QRectF>

export module Doodads;

import std;
import std.compat;
import Terrain;
import Doodad;
import BinaryReader;
import BinaryWriter;
import Hierarchy;
import ResourceManager;
import SkinnedMesh;
import SkeletalModelInstance;
import PathingTexture;
import Utilities;
import Globals;
import MapInfo;
import UnorderedMap;
import SLK;
import PathingMap;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;

namespace fs = std::filesystem;

// So we can make a generic that either accepts Doodad or Doodad*
template<class T>
concept DoodadLike = std::derived_from<std::remove_pointer_t<T>, Doodad>;

const Doodad& as_doodad(const Doodad* t) {
	return *t;
}

const Doodad& as_doodad(const Doodad& t) {
	return t;
}

/// A class for that contains doodad and takes care of loading/saving war3map.doo files
export class Doodads {
	hive::unordered_map<std::string, std::shared_ptr<SkinnedMesh>> id_to_mesh;

	static constexpr int write_version = 8;
	static constexpr int write_subversion = 11;
	static constexpr int write_special_version = 0;

  public:
	std::vector<SpecialDoodad> special_doodads;
	std::vector<Doodad> doodads;

	bool load(const Terrain& terrain, const MapInfo& info) {
		BinaryReader reader = hierarchy.map_file_read("war3map.doo").value();

		const std::string magic_number = reader.read_string(4);
		if (magic_number != "W3do") {
			std::println("Invalid war3map.doo file: Magic number is not W3do");
			return false;
		}
		const uint32_t version = reader.read<uint32_t>();
		if (version != 7 && version != 8) {
			std::println("Unknown war3map.doo version: {} Attempting to load but may crash\nPlease send this map to eejin\n", version);
		}

		// Subversion
		const uint32_t subversion = reader.read<uint32_t>();
		// ToDO check subversion

		Doodad::auto_increment = 0;
		doodads.resize(reader.read<uint32_t>());
		for (auto&& i : doodads) {
			i.id = reader.read_string(4);
			i.variation = reader.read<uint32_t>();
			i.position = (reader.read<glm::vec3>() - glm::vec3(terrain.offset, 0)) / 128.f;
			i.angle = reader.read<float>();
			i.scale = reader.read<glm::vec3>();

			if (info.game_version_major * 100 + info.game_version_minor >= 132) {
				i.skin_id = reader.read_string(4);
			} else {
				i.skin_id = i.id;
			}

			i.state = static_cast<Doodad::State>(reader.read<uint8_t>());
			i.life = reader.read<uint8_t>();

			if (version >= 8) {
				i.item_table_pointer = reader.read<int32_t>();
				i.item_sets.resize(reader.read<uint32_t>());
				for (auto&& j : i.item_sets) {
					j.items.resize(reader.read<uint32_t>());
					for (auto& [chance, id] : j.items) {
						id = reader.read_string(4);
						chance = reader.read<uint32_t>();
					}
				}
			}

			i.creation_number = reader.read<uint32_t>();
			Doodad::auto_increment = std::max(Doodad::auto_increment, i.creation_number);
		}

		// Terrain Doodads
		const int special_format_version = reader.read<uint32_t>();

		special_doodads.resize(reader.read<uint32_t>());
		for (auto&& i : special_doodads) {
			i.id = reader.read_string(4);
			i.variation = reader.read<uint32_t>();
			i.position = glm::ivec3(reader.read<glm::ivec2>(), 0);
			i.old_position = i.position;
		}

		return true;
	}

	void save(const Terrain& terrain) const {
		BinaryWriter writer;
		writer.write_string("W3do");
		writer.write<uint32_t>(write_version);
		writer.write<uint32_t>(write_subversion);

		writer.write<uint32_t>(doodads.size());
		for (auto&& i : doodads) {
			writer.write_string(i.id);
			writer.write<uint32_t>(i.variation);
			writer.write<glm::vec3>(i.position * 128.f + glm::vec3(terrain.offset, 0));
			writer.write<float>(i.angle);
			writer.write<glm::vec3>(i.scale);

			writer.write_string(i.skin_id);

			writer.write<uint8_t>(static_cast<int>(i.state));
			writer.write<uint8_t>(i.life);

			writer.write<int32_t>(i.item_table_pointer);
			writer.write<uint32_t>(i.item_sets.size());
			for (auto&& j : i.item_sets) {
				writer.write<uint32_t>(j.items.size());
				for (const auto& [chance, id] : j.items) {
					writer.write_string(id);
					writer.write<uint32_t>(chance);
				}
			}

			writer.write<uint32_t>(i.creation_number);
		}

		writer.write<uint32_t>(write_special_version);

		writer.write<uint32_t>(special_doodads.size());
		for (auto&& i : special_doodads) {
			writer.write_string(i.id);
			writer.write<uint32_t>(i.variation);
			writer.write<glm::ivec2>(glm::ivec2(i.old_position.x, i.old_position.y));
		}

		hierarchy.map_file_write("war3map.doo", writer.buffer);
	}

	void create(Terrain& terrain, PathingMap& pathing_map) {
		for (auto&& i : doodads) {
			i.init(i.id, get_mesh(i.id, i.variation), terrain);
		}

		for (auto&& i : special_doodads) {
			i.mesh = get_mesh(i.id, i.variation);
			i.skeleton = SkeletalModelInstance(i.mesh->mdx);
			const std::string_view pathing_texture_path = doodads_slk.data<std::string_view>("pathtex", i.id);
			if (hierarchy.file_exists(pathing_texture_path)) {
				i.pathing = resource_manager.load<PathingTexture>(pathing_texture_path);
				i.position += glm::vec3(glm::vec2(i.pathing->width / 8.f, i.pathing->height / 8.f), 0.f);
			}

			i.position.z = terrain.interpolated_height(i.position.x, i.position.y, true);

			float rotation = doodads_slk.data<int>("fixedrot", i.id) / 360.f * 2.f * glm::pi<float>();
			i.matrix = glm::translate(i.matrix, i.position);
			i.matrix = glm::scale(i.matrix, {1.f / 128.f, 1.f / 128.f, 1.f / 128.f});
			i.matrix = glm::rotate(i.matrix, rotation, glm::vec3(0, 0, 1));
		}

		// Blit doodad pathing
		for (const auto& i : doodads) {
			if (!i.pathing) {
				continue;
			}

			pathing_map.blit_pathing_texture(i.position, glm::degrees(i.angle) + 90, i.pathing);
		}
		pathing_map.upload_dynamic_pathing();

		// Update terrain exists
		update_special_doodad_pathing(QRect(0, 0, terrain.width, terrain.height), terrain);
	}

	// Will assign a creation number
	Doodad& add_doodad(const std::string& id, const int variation, const glm::vec3 position, const Terrain& terrain) {
		Doodad doodad;
		doodad.id = id;
		doodad.skin_id = id;
		doodad.variation = variation;
		doodad.mesh = get_mesh(id, variation);
		doodad.position = position;
		doodad.scale = {1, 1, 1};
		doodad.angle = 0;
		doodad.creation_number = ++Doodad::auto_increment;
		doodad.skeleton = SkeletalModelInstance(doodad.mesh->mdx);

		const bool is_doodad = doodads_slk.row_headers.contains(id);
		const slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;
		const std::string_view pathing_texture_path = slk.data<std::string_view>("pathtex", id);

		if (hierarchy.file_exists(pathing_texture_path)) {
			doodad.pathing = resource_manager.load<PathingTexture>(pathing_texture_path);
		}

		doodad.update(terrain);

		doodads.push_back(doodad);
		return doodads.back();
	}

	// You will have to manually set a creation number and valid skin ID
	Doodad& add_doodad(const Doodad& doodad) {
		doodads.push_back(doodad);
		return doodads.back();
	}

	void remove_doodad(Doodad* doodad) {
		const auto iterator = doodads.begin() + std::distance(doodads.data(), doodad);
		doodads.erase(iterator);
	}

	void remove_doodads(const std::unordered_set<Doodad*>& list) {
		std::erase_if(doodads, [&](Doodad& doodad) {
			return list.contains(&doodad);
		});
	}

	std::vector<Doodad*> query_area(const QRectF& area) {
		std::vector<Doodad*> result;

		for (auto&& i : doodads) {
			if (area.contains(i.position.x, i.position.y)) {
				result.push_back(&i);
			}
		}
		return result;
	}

	/// Returns an AABB in pathing map tiles (4x4 per whole tile) surrounding the doodads accounting for their pathing maps
	template<class Container>
		requires DoodadLike<typename Container::value_type>
	QRect get_pathing_bounding_box(const Container& doodads) const {
		QRect pathing_area;
		for (const auto& i : doodads) {
			pathing_area |= as_doodad(i).get_pathing_bounding_box();
		}
		return pathing_area;
	}

	template<class Container>
		requires DoodadLike<typename Container::value_type>
	void update_doodad_pathing(const Container& doodads, PathingMap& pathing_map) {
		const QRect update_pathing_area = get_pathing_bounding_box(doodads);
		update_doodad_pathing(update_pathing_area, pathing_map);
	}

	/// The input area should be in pathing map tiles.
	void update_doodad_pathing(const QRect& area, PathingMap& pathing_map) {
		pathing_map.dynamic_clear_area(area);

		const QRectF doodad_area = QRect(area.left() / 4.f, area.top() / 4.f, area.width() / 4.f, area.height() / 4.f);
		// Arbitrarily extend it to find doodads that blit into the space we just cleared
		// Will break if there is a doodad with a pathing map bigger than this
		const QRectF new_area = doodad_area.adjusted(-8, -8, 8, 8);
		const auto doodads_to_blit = query_area(new_area);
		for (const auto& i : doodads_to_blit) {
			if (!i->pathing) {
				continue;
			}
			pathing_map.blit_pathing_texture(i->position, glm::degrees(i->angle) + 90, i->pathing);
		}
		pathing_map.upload_dynamic_pathing();
	}

	/// The input area should be in whole tile fractions (of 128 WC3 units).
	void update_special_doodad_pathing(const QRectF& area, Terrain& terrain) const {
		QRectF new_area = area.adjusted(-6.f, -6.f, 6.f, 6.f);
		new_area = new_area.intersected({0, 0, static_cast<float>(terrain.width), static_cast<float>(terrain.height)});

		for (int i = new_area.left(); i < new_area.right(); i++) {
			for (int j = new_area.top(); j < new_area.bottom(); j++) {
				terrain.corners[i][j].special_doodad = false;
			}
		}

		new_area = area.adjusted(-6, -6, 6, 6);

		for (const auto& i : special_doodads) {
			if (!new_area.contains(i.position.x, i.position.y)) {
				continue;
			}

			if (!i.pathing) {
				continue;
			}

			for (int j = 0; j < i.pathing->width / 4; j++) {
				for (int k = 0; k < i.pathing->height / 4; k++) {
					const int x = i.position.x - i.pathing->width / 8.f + j;
					const int y = i.position.y - i.pathing->height / 8.f + k;

					if (x < 0 || y < 0 || x >= terrain.width || y >= terrain.height) {
						continue;
					}

					terrain.corners[x][y].special_doodad = true;
				}
			}
		}

		terrain.update_ground_exists(area.toRect());
	}

	void process_doodad_field_change(const std::string& id, const std::string& field, const Terrain& terrain) {
		context->makeCurrent();

		if (field == "file" || field == "numvar") {
			// id_to_mesh requires a variation too so we will just have to check a bunch of them
			// ToDo just use the numvar field from the SLKs
			for (int i = 0; i < 20; i++) {
				id_to_mesh.erase(id + std::to_string(i));
			}
			for (auto& i : doodads) {
				if (i.id == id) {
					i.mesh = get_mesh(id, i.variation);
					i.skeleton = SkeletalModelInstance(i.mesh->mdx);
					i.update(terrain);
				}
			}
		}

		if (field == "maxroll" || field == "maxpitch" || field.starts_with("vert")) {
			for (auto& i : doodads) {
				if (i.id == id) {
					i.update(terrain);
				}
			}
		}

		if (field == "pathtex") {
			const std::string_view pathing_texture_path = doodads_slk.data<std::string_view>("pathtex", id);

			if (hierarchy.file_exists(pathing_texture_path)) {
				const auto new_pathing_texture = resource_manager.load<PathingTexture>(pathing_texture_path);
				for (auto& i : doodads) {
					if (i.id == id) {
						i.pathing = new_pathing_texture;
					}
				}
			} else {
				return;
			}
		}
	}

	void process_destructible_field_change(const std::string& id, const std::string& field, const Terrain& terrain) {
		context->makeCurrent();

		if (field == "file" || field == "numvar") {
			// id_to_mesh requires a variation too so we will just have to check a bunch of them
			// ToDo just use the numvar field from the SLKs
			for (int i = 0; i < 20; i++) {
				id_to_mesh.erase(id + std::to_string(i));
			}
			for (auto& i : doodads) {
				if (i.id == id) {
					i.mesh = get_mesh(id, i.variation);
					i.skeleton = SkeletalModelInstance(i.mesh->mdx);
					i.update(terrain);
					i.skeleton.update(0.016f);
				}
			}
		}

		if (field == "maxroll" || field == "maxpitch" || field.starts_with("color")) {
			for (auto& i : doodads) {
				if (i.id == id) {
					i.update(terrain);
				}
			}
		}

		if (field == "pathtex") {
			const std::string_view pathing_texture_path = destructibles_slk.data<std::string_view>("pathtex", id);

			if (hierarchy.file_exists(pathing_texture_path)) {
				const auto new_pathing_texture = resource_manager.load<PathingTexture>(pathing_texture_path);
				for (auto& i : doodads) {
					if (i.id == id) {
						i.pathing = new_pathing_texture;
					}
				}
			} else {
				return;
			}
		}
	}

	std::shared_ptr<SkinnedMesh> get_mesh(std::string id, const int variation) {
		std::string full_id = id + std::to_string(variation);
		if (id_to_mesh.contains(full_id)) {
			return id_to_mesh[full_id];
		}

		fs::path mesh_path;
		std::string variations;
		std::string replaceable_id;
		fs::path texture_name;

		if (doodads_slk.row_headers.contains(id)) {
			// Is doodad
			mesh_path = doodads_slk.data("file", id);
			variations = doodads_slk.data("numvar", id);
		} else {
			mesh_path = destructibles_slk.data("file", id);
			variations = destructibles_slk.data("numvar", id);

			replaceable_id = destructibles_slk.data("texid", id);
			texture_name = destructibles_slk.data("texfile", id);
			texture_name.replace_extension("");
		}

		const std::string stem = mesh_path.stem().string();
		mesh_path.replace_filename(stem + (variations == "1" ? "" : std::to_string(variation)));
		mesh_path.replace_extension(".mdx");

		// Use base model when variation doesn't exist
		if (!hierarchy.file_exists(mesh_path)) {
			mesh_path.remove_filename() /= stem + ".mdx";
		}

		mesh_path = fs::path(string_replaced(mesh_path.string(), "\\", "/"));

		// Mesh doesn't exist at all
		if (!hierarchy.file_exists(mesh_path)) {
			std::println("Invalid model file for {} with file path: {}", id, mesh_path.string());
			id_to_mesh.emplace(full_id, resource_manager.load<SkinnedMesh>("Objects/Invalidmodel/Invalidmodel.mdx", "", std::nullopt));
			return id_to_mesh[full_id];
		}

		if (is_number(replaceable_id) && texture_name != "_") {
			id_to_mesh.emplace(
				full_id,
				resource_manager.load<SkinnedMesh>(
					mesh_path,
					texture_name.string(),
					std::make_optional(std::make_pair(std::stoi(replaceable_id), texture_name.replace_extension("").string()))
				)
			);
		} else {
			id_to_mesh.emplace(full_id, resource_manager.load<SkinnedMesh>(mesh_path, "", std::nullopt));
		}

		return id_to_mesh[full_id];
	}
};

```

`src/base/doodads_undo.ixx`:

```ixx
module;

#include <QRectF>

export module DoodadsUndo;

import std;
import Doodad;
import WorldUndoManager;

// Undo/redo structures
export class DoodadAddAction final : public WorldCommand {
public:
	std::vector<Doodad> doodads;

	void undo(WorldEditContext& ctx) override {
		ctx.doodads.doodads.resize(ctx.doodads.doodads.size() - doodads.size());
		ctx.doodads.update_doodad_pathing(doodads, ctx.pathing_map);
	}

	void redo(WorldEditContext& ctx) override {
		ctx.doodads.doodads.insert(ctx.doodads.doodads.end(), doodads.begin(), doodads.end());
		ctx.doodads.update_doodad_pathing(doodads, ctx.pathing_map);
	}
};

export class DoodadDeleteAction final : public WorldCommand {
public:
	std::vector<Doodad> doodads;

	void undo(WorldEditContext& ctx) override {
		if (ctx.brush) {
			ctx.brush->clear_selection();
		}

		ctx.doodads.doodads.insert(ctx.doodads.doodads.end(), doodads.begin(), doodads.end());
		ctx.doodads.update_doodad_pathing(doodads, ctx.pathing_map);
	}

	void redo(WorldEditContext& ctx) override {
		if (ctx.brush) {
			ctx.brush->clear_selection();
		}

		ctx.doodads.doodads.resize(ctx.doodads.doodads.size() - doodads.size());
		ctx.doodads.update_doodad_pathing(doodads, ctx.pathing_map);
	}
};

export class DoodadStateAction final : public WorldCommand {
public:
	std::vector<Doodad> old_doodads;
	std::vector<Doodad> new_doodads;

	void undo(WorldEditContext& ctx) override {
		QRect pathing_area;
		for (const auto& i : old_doodads) {
			for (auto& j : ctx.doodads.doodads) {
				if (i.creation_number == j.creation_number) {
					pathing_area |= i.get_pathing_bounding_box();
					pathing_area |= j.get_pathing_bounding_box();
					j = i;
				}
			}
		}
		ctx.doodads.update_doodad_pathing(pathing_area, ctx.pathing_map);
	}

	void redo(WorldEditContext& ctx) override {
		QRect pathing_area;
		for (const auto& i : new_doodads) {
			for (auto& j : ctx.doodads.doodads) {
				if (i.creation_number == j.creation_number) {
					pathing_area |= i.get_pathing_bounding_box();
					pathing_area |= j.get_pathing_bounding_box();
					j = i;
				}
			}
		}
		ctx.doodads.update_doodad_pathing(pathing_area, ctx.pathing_map);
	}
};

```

`src/base/game_cameras.ixx`:

```ixx
export module GameCameras;

import std;
import types;
import BinaryReader;
import Hierarchy;

export struct GameCamera {
	float target_x;
	float target_y;
	float z_offset;
	float rotation;
	float angle_of_attack;
	float distance;
	float roll;
	float fov;
	float far_z;
	float near_z;
	float local_roll;
	float local_pitch;
	float local_yaw;
	std::string name;
};

export class GameCameras {
  public:
	std::vector<GameCamera> cameras;

	void load(int game_version_major, int game_version_minor) {
		BinaryReader reader = hierarchy.map_file_read("war3map.w3c").value();

		int version = reader.read<u32>();
		if (version != 0) {
			std::cout << "Unknown war3map.w3c version: " << version << " Attempting to load but may crash\n";
		}

		cameras.resize(reader.read<u32>());
		for (auto& i : cameras) {
			i.target_x = reader.read<float>();
			i.target_y = reader.read<float>();
			i.z_offset = reader.read<float>();
			i.rotation = reader.read<float>();
			i.angle_of_attack = reader.read<float>();
			i.distance = reader.read<float>();
			i.roll = reader.read<float>();
			i.fov = reader.read<float>();
			i.far_z = reader.read<float>();
			i.near_z = reader.read<float>();

			if (game_version_major * 100 + game_version_minor >= 131) {
				i.local_pitch = reader.read<float>();
				i.local_yaw = reader.read<float>();
				i.local_roll = reader.read<float>();
			}
			i.name = reader.read_c_string();
		}
	}

	void save() {
	}
};
```

`src/base/hierarchy.ixx`:

```ixx
module;

#include <QSettings>

export module Hierarchy;

import std;
import types;
import JSON;
import BinaryReader;
import CASC;
import no_init_allocator;
import Utilities;

using namespace std::literals::string_literals;
namespace fs = std::filesystem;

export class Hierarchy {
  public:
	char tileset = 'L';
	std::string locale = "enus";
	casc::CASC game_data;
	json::JSON aliases;

	fs::path map_directory;
	fs::path warcraft_directory;
	fs::path root_directory;

	bool ptr = false;
	bool hd = true;
	bool teen = false;
	bool local_files = true;

	Hierarchy() {
		QSettings war3reg("HKEY_CURRENT_USER\\Software\\Blizzard Entertainment\\Warcraft III", QSettings::NativeFormat);
		local_files = war3reg.value("Allow Local Files", 0).toInt() != 0;
	}

	bool open_casc(const fs::path& directory) {
		QSettings settings;
		ptr = settings.value("flavour", "Retail").toString() == "PTR";
		hd = settings.value("hd", "False").toString() == "True";
		teen = settings.value("teen", "False").toString() == "True";

		warcraft_directory = directory;

		bool open = game_data.open(warcraft_directory / (ptr ? ":w3t" : ":w3"));
		root_directory = warcraft_directory / (ptr ? "_ptr_" : "_retail_");

		if (open) {
			aliases.load(open_file("filealiases.json").value());
		}
		return open;
	}

	[[nodiscard]]
	auto open_file(const fs::path& path) const -> std::expected<BinaryReader, std::string> {
		const std::string path_str = path.string();

		using Candidate = std::function<std::expected<BinaryReader, std::string>()>;

		const std::vector<Candidate> candidates {
			[&] {
				return read_file("data/overrides" / path);
			},
			[&] {
				return local_files ? read_file(root_directory / path) : std::unexpected("skip");
			},
			[&] {
				return (hd && teen) ? map_file_read("_hd.w3mod:_teen.w3mod:" + path_str) : std::unexpected("skip");
			},
			[&] {
				return hd ? map_file_read("_hd.w3mod:" + path_str) : std::unexpected("skip");
			},
			[&] {
				return map_file_read(path);
			},
			[&] {
				return hd ? game_data.open_file(std::format("war3.w3mod:_hd.w3mod:_tilesets/{}.w3mod:{}", tileset, path_str))
						  : std::unexpected("skip");
			},
			[&] {
				return (hd && teen) ? game_data.open_file("war3.w3mod:_hd.w3mod:_teen.w3mod:"s + path_str) : std::unexpected("skip");
			},
			[&] {
				return hd ? game_data.open_file("war3.w3mod:_hd.w3mod:"s + path_str) : std::unexpected("skip");
			},
			[&] {
				return game_data.open_file(std::format("war3.w3mod:_tilesets/{}.w3mod:{}", tileset, path_str));
			},
			[&] {
				return game_data.open_file(std::format("war3.w3mod:_locales/{}.w3mod:{}", locale, path_str));
			},
			[&] {
				return teen ? game_data.open_file("war3.w3mod:_teen.w3mod:"s + path_str) : std::unexpected("skip");
			},
			[&] {
				return game_data.open_file("war3.w3mod:"s + path_str);
			},
			[&] {
				return game_data.open_file("war3.w3mod:_deprecated.w3mod:"s + path_str);
			},
			[&] {
				return aliases.exists(path_str) ? open_file(aliases.alias(path_str)) : std::unexpected("skip");
			},
		};

		for (const auto& candidate : candidates) {
			if (const auto res = candidate(); res) {
				return res;
			}
		}

		return std::unexpected(path_str + " could not be found in the hierarchy");
	}

	bool file_exists(const fs::path& path) const {
		if (path.empty()) {
			return false;
		}

		const auto path_str = path.string();

		return fs::exists("data/overrides" / path) || (local_files && fs::exists(root_directory / path))
			|| (hd && teen && map_file_exists("_hd.w3mod:_teen.w3mod:" + path_str))
			|| (hd && map_file_exists("_hd.w3mod:" + path_str)) || map_file_exists(path)
			|| (hd && game_data.file_exists("war3.w3mod:_hd.w3mod:_tilesets/"s + tileset + ".w3mod:"s + path_str))
			|| (hd && teen && game_data.file_exists("war3.w3mod:_hd.w3mod:_teen.w3mod:"s + path_str))
			|| (hd && game_data.file_exists("war3.w3mod:_hd.w3mod:"s + path_str))
			|| game_data.file_exists("war3.w3mod:_tilesets/"s + tileset + ".w3mod:"s + path_str)
			|| game_data.file_exists(std::format("war3.w3mod:_locales/{}.w3mod:{}", locale, path_str))
			|| (teen && game_data.file_exists("war3.w3mod:_teen.w3mod:"s + path_str))
			|| game_data.file_exists("war3.w3mod:"s + path_str)
			|| game_data.file_exists("war3.w3mod:_deprecated.w3mod:"s + path_str)
			|| (aliases.exists(path_str) ? file_exists(aliases.alias(path_str)) : false);
	}

	[[nodiscard]]
	auto map_file_read(const fs::path& path) const -> std::expected<BinaryReader, std::string> {
		return read_file(map_directory / path);
	}

	/// source somewhere on disk, destination relative to the map
	void map_file_add(const fs::path& source, const fs::path& destination) const {
		fs::copy_file(source, map_directory / destination, fs::copy_options::overwrite_existing);
	}

	void map_file_write(const fs::path& path, const std::vector<u8>& data) const {
		std::ofstream outfile(map_directory / path, std::ios::binary);

		if (!outfile) {
			throw std::runtime_error("Error writing file " + path.string());
		}

		outfile.write(reinterpret_cast<char const*>(data.data()), data.size());
	}

	void map_file_remove(const fs::path& path) const {
		fs::remove(map_directory / path);
	}

	bool map_file_exists(const fs::path& path) const {
		return fs::exists(map_directory / path);
	}

	void map_file_rename(const fs::path& original, const fs::path& renamed) const {
		fs::rename(map_directory / original, map_directory / renamed);
	}
};

export inline Hierarchy hierarchy;

```

`src/base/imports.ixx`:

```ixx
export module Imports;

import std;
import types;
import BinaryWriter;
import Hierarchy;

namespace fs = std::filesystem;

// HiveWE does not use the war3map.imp file at all, but the old WE does
// That's why we write the file at save time
export class Imports {
  public:

	std::unordered_set<std::string> blacklist = {
		"conversation.json",
		"war3mapUnits.doo",
		"war3map.doo",
		"war3map.imp",
		"war3map.j",
		"war3map.mmp",
		"war3map.shd",
		"war3map.w3a",
		"war3map.w3b",
		"war3map.w3c",
		"war3map.w3d",
		"war3map.w3e",
		"war3map.w3h",
		"war3map.w3i",
		"war3map.w3q",
		"war3map.w3r",
		"war3map.w3t",
		"war3map.w3u",
		"war3map.wct",
		"war3map.wpm",
		"war3map.wtg",
		"war3map.wts",
		"war3map.w3s",
		"war3mapMap.blp",
		"war3mapExtra.txt",
		"war3mapMisc.txt",
		"war3mapSkin.txt"
	};

	/// Requires the filesystem_path for the map to make the saved paths lexically relative
	void save(fs::path filesystem_path) const {
		BinaryWriter writer;

		writer.write<u32>(1);

		int count = 0;
		for (const auto& i : fs::recursive_directory_iterator(filesystem_path)) {
			if (i.is_regular_file()) {
				std::string file_name = i.path().filename().string();
				if (blacklist.contains(file_name)) {
					continue;
				}
				count++;
			}
		}
		writer.write<u32>(count);

		for (const auto& i : fs::recursive_directory_iterator(filesystem_path)) {
			if (i.is_regular_file()) {
				std::string path = i.path().lexically_relative(filesystem_path).string();
				std::string file_name = i.path().filename().string();
				if (blacklist.contains(file_name)) {
					continue;
				}

				writer.write<u8>(13);
				writer.write_c_string(path);
			}
		}

		hierarchy.map_file_write("war3map.imp", writer.buffer);
	}
};
```

`src/base/map.ixx`:

```ixx
module;

#include <QMessageBox>

export module Map;

import std;
import types;
import MDX;
import SLK;
import INI;
import GameCameras;
import Imports;
import MapInfo;
import Doodad;
import Sounds;
import Regions;
import WorldUndoManager;
import TriggerStrings;
import PathingMap;
import Physics;
import Hierarchy;
import Camera;
import Timer;
import Physics;
import ModificationTables;
import RenderManager;
import TableModel;
import Globals;
import Units;
import Doodads;
import Triggers;
import Terrain;
import "brush.h";
import <glad/glad.h>;
import <bullet/btBulletDynamicsCommon.h>;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;

namespace fs = std::filesystem;
using namespace std::literals::string_literals;

export class Map: public QObject {
	Q_OBJECT

  public:
	bool loaded = false;

	TriggerStrings trigger_strings;
	Triggers triggers;
	MapInfo info;
	Terrain terrain;
	PathingMap pathing_map;
	Imports imports;
	Doodads doodads;
	Units units;
	Regions regions;
	GameCameras cameras;
	Sounds sounds;
	// ShadowMap shadow_map;

	WorldUndoManager world_undo;
	Brush* brush = nullptr;
	Physics physics;

	bool enforce_water_height_limits = true;

	bool render_doodads = true;
	bool render_units = true;
	bool render_pathing = false;
	bool render_brush = true;
	bool render_lighting = true;
	bool render_water = true;
	bool render_click_helpers = true;
	bool render_wireframe = false;
	bool render_debug = false;

	glm::vec3 light_direction = glm::normalize(glm::vec3(1.f, 1.f, -3.f));

	fs::path filesystem_path;
	std::string name;

	RenderManager render_manager;

	void load(const fs::path& path) {
		Timer timer;

		hierarchy.map_directory = path;
		filesystem_path = fs::absolute(path) / "";
		name = (*--(--filesystem_path.end())).string();

		// ToDo So for the game data files we should actually load from _balance/custom_v0.w3mod/Units, _balance/custom_v1.w3mod/Units, _balance/melee_v0.w3mod/units or /Units depending on the Game Data set and Game Data Versions
		// Maybe just ignore RoC so we only need to choose between _balance/custom_v1.w3mod/Units and /Units
		// Maybe just force everyone to suck it up and use /Units

		// Units
		units_slk = slk::SLK("Units/UnitData.slk");
		// By making some changes to unitmetadata.slk and unitdata.slk we can avoid the 1->2->2 mapping for SLK->OE->W3U files. We have to add some columns for this though
		units_slk.add_column("missilearc2");
		units_slk.add_column("missileart2");
		units_slk.add_column("missilespeed2");
		units_slk.add_column("buttonpos2");

		units_meta_slk = slk::SLK("Units/UnitMetaData.slk");
		units_meta_slk.substitute(world_edit_strings, "WorldEditStrings");
		units_meta_slk.build_meta_map();

		unit_editor_data = ini::INI("UI/UnitEditorData.txt");
		unit_editor_data.substitute(world_edit_strings, "WorldEditStrings");
		// Have to substitute twice since some of the keys refer to other keys in the same file
		unit_editor_data.substitute(world_edit_strings, "WorldEditStrings");

		units_slk.merge(ini::INI("Units/UnitSkin.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/UnitWeaponsFunc.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/UnitWeaponsSkin.txt"), units_meta_slk);

		units_slk.merge(slk::SLK("Units/UnitBalance.slk"));
		units_slk.merge(slk::SLK("Units/unitUI.slk"));
		units_slk.merge(slk::SLK("Units/UnitWeapons.slk"));
		units_slk.merge(slk::SLK("Units/UnitAbilities.slk"));

		units_slk.merge(ini::INI("Units/HumanUnitFunc.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/OrcUnitFunc.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/UndeadUnitFunc.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/NightElfUnitFunc.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/NeutralUnitFunc.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/CampaignUnitFunc.txt"), units_meta_slk);

		units_slk.merge(ini::INI("Units/HumanUnitStrings.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/OrcUnitStrings.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/UndeadUnitStrings.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/NightElfUnitStrings.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/NeutralUnitStrings.txt"), units_meta_slk);
		units_slk.merge(ini::INI("Units/CampaignUnitStrings.txt"), units_meta_slk);

		abilities_slk = slk::SLK("Units/AbilityData.slk");
		abilities_meta_slk = slk::SLK("Units/AbilityMetaData.slk");
		abilities_meta_slk.substitute(world_edit_strings, "WorldEditStrings");

		// Patch the SLKs
		abilities_slk.add_column("buttonpos2");
		abilities_slk.add_column("unbuttonpos2");
		abilities_slk.add_column("researchbuttonpos2");
		abilities_meta_slk.set_shadow_data("field", "abpy", "buttonpos2");
		abilities_meta_slk.set_shadow_data("field", "auby", "unbuttonpos2");
		abilities_meta_slk.set_shadow_data("field", "arpy", "researchbuttonpos2");
		abilities_meta_slk.build_meta_map();

		abilities_slk.merge(ini::INI("Units/AbilitySkin.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/AbilitySkinStrings.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/HumanAbilityFunc.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/OrcAbilityFunc.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/UndeadAbilityFunc.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/NightElfAbilityFunc.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/NeutralAbilityFunc.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/ItemAbilityFunc.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/CommonAbilityFunc.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/CampaignAbilityFunc.txt"), abilities_meta_slk);

		abilities_slk.merge(ini::INI("Units/HumanAbilityStrings.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/OrcAbilityStrings.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/UndeadAbilityStrings.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/NightElfAbilityStrings.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/NeutralAbilityStrings.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/ItemAbilityStrings.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/CommonAbilityStrings.txt"), abilities_meta_slk);
		abilities_slk.merge(ini::INI("Units/CampaignAbilityStrings.txt"), abilities_meta_slk);

		// Items
		items_slk = slk::SLK("Units/ItemData.slk");
		items_meta_slk = slk::SLK("Units/ItemMetaData.slk");
		items_meta_slk.substitute(world_edit_strings, "WorldEditStrings");
		items_meta_slk.build_meta_map();

		items_slk.merge(ini::INI("Units/ItemSkin.txt"), items_meta_slk);
		items_slk.merge(ini::INI("Units/ItemFunc.txt"), items_meta_slk);
		items_slk.merge(ini::INI("Units/ItemStrings.txt"), items_meta_slk);

		// Doodads
		doodads_slk = slk::SLK("Doodads/Doodads.slk");
		doodads_meta_slk = slk::SLK("Doodads/DoodadMetaData.slk");
		doodads_meta_slk.substitute(world_edit_strings, "WorldEditStrings");
		doodads_meta_slk.build_meta_map();

		doodads_slk.merge(ini::INI("Doodads/DoodadSkins.txt"), doodads_meta_slk);
		doodads_slk.substitute(world_edit_strings, "WorldEditStrings");
		doodads_slk.substitute(world_edit_game_strings, "WorldEditStrings");

		// Sometimes fields are empty or "-" which denotes empty aka the value 0.0
		for (auto& [key, fields] : doodads_slk.base_data) {
			if (auto found = fields.find("maxpitch"); found != fields.end()) {
				if (found->second.empty() || found->second == "-") {
					found->second = "0";
				}
			} else {
				fields["maxpitch"] = "0";
			}
			if (auto found = fields.find("maxroll"); found != fields.end()) {
				if (found->second.empty() || found->second == "-") {
					found->second = "0";
				}
			} else {
				fields["maxroll"] = "0";
			}
		}

		// Destructables
		destructibles_slk = slk::SLK("Units/DestructableData.slk");
		destructibles_slk.substitute(world_edit_strings, "WorldEditStrings");

		destructibles_meta_slk = slk::SLK("Units/DestructableMetaData.slk");
		destructibles_meta_slk.substitute(world_edit_strings, "WorldEditStrings");
		destructibles_meta_slk.build_meta_map();

		destructibles_slk.merge(ini::INI("Units/DestructableSkin.txt"), destructibles_meta_slk);
		destructibles_slk.substitute(world_edit_strings, "WorldEditStrings");
		destructibles_slk.substitute(world_edit_game_strings, "WorldEditStrings");

		// Sometimes fields are empty or "-" which denotes empty aka the value 0.0
		for (auto& [key, fields] : destructibles_slk.base_data) {
			if (auto found = fields.find("maxpitch"); found != fields.end()) {
				if (found->second.empty() || found->second == "-") {
					found->second = "0";
				}
			} else {
				fields["maxpitch"] = "0";
			}
			if (auto found = fields.find("maxroll"); found != fields.end()) {
				if (found->second.empty() || found->second == "-") {
					found->second = "0";
				}
			} else {
				fields["maxroll"] = "0";
			}
		}

		upgrade_slk = slk::SLK("Units/UpgradeData.slk");
		upgrade_meta_slk = slk::SLK("Units/UpgradeMetaData.slk");
		upgrade_meta_slk.substitute(world_edit_strings, "WorldEditStrings");

		// Patch the SLKs
		upgrade_slk.add_column("buttonpos2");
		upgrade_meta_slk.set_shadow_data("field", "gbpy", "buttonpos2");
		upgrade_meta_slk.build_meta_map();

		upgrade_slk.merge(ini::INI("Units/AbilitySkin.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/UpgradeSkin.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/HumanUpgradeFunc.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/OrcUpgradeFunc.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/UndeadUpgradeFunc.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/NightElfUpgradeFunc.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/NeutralUpgradeFunc.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/CampaignUpgradeFunc.txt"), upgrade_meta_slk);

		upgrade_slk.merge(ini::INI("Units/CampaignUpgradeStrings.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/HumanUpgradeStrings.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/NeutralUpgradeStrings.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/NightElfUpgradeStrings.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/OrcUpgradeStrings.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/UndeadUpgradeStrings.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/UpgradeSkinStrings.txt"), upgrade_meta_slk);
		upgrade_slk.merge(ini::INI("Units/CampaignUpgradeFunc.txt"), upgrade_meta_slk);

		buff_slk = slk::SLK("Units/AbilityBuffData.slk");
		buff_meta_slk = slk::SLK("Units/AbilityBuffMetaData.slk");
		buff_meta_slk.substitute(world_edit_strings, "WorldEditStrings");
		buff_meta_slk.build_meta_map();

		buff_slk.merge(ini::INI("Units/AbilitySkin.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/AbilitySkinStrings.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/HumanAbilityFunc.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/OrcAbilityFunc.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/UndeadAbilityFunc.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/NightElfAbilityFunc.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/NeutralAbilityFunc.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/ItemAbilityFunc.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/CommonAbilityFunc.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/CampaignAbilityFunc.txt"), buff_meta_slk);

		buff_slk.merge(ini::INI("Units/HumanAbilityStrings.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/OrcAbilityStrings.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/UndeadAbilityStrings.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/NightElfAbilityStrings.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/NeutralAbilityStrings.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/ItemAbilityStrings.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/CommonAbilityStrings.txt"), buff_meta_slk);
		buff_slk.merge(ini::INI("Units/CampaignAbilityStrings.txt"), buff_meta_slk);

		units_table = new TableModel(&units_slk, &units_meta_slk, &trigger_strings);
		items_table = new TableModel(&items_slk, &items_meta_slk, &trigger_strings);
		abilities_table = new TableModel(&abilities_slk, &abilities_meta_slk, &trigger_strings);
		doodads_table = new TableModel(&doodads_slk, &doodads_meta_slk, &trigger_strings);
		destructibles_table = new TableModel(&destructibles_slk, &destructibles_meta_slk, &trigger_strings);
		upgrade_table = new TableModel(&upgrade_slk, &upgrade_meta_slk, &trigger_strings);
		buff_table = new TableModel(&buff_slk, &buff_meta_slk, &trigger_strings);

		std::println("\nSLK loading:\t {:>5}ms", timer.elapsed_ms());
		timer.reset();

		// Trigger strings
		if (hierarchy.map_file_exists("war3map.wts")) {
			trigger_strings.load();
		}

		// Triggers (GUI and JASS)
		if (hierarchy.map_file_exists("war3map.wtg")) {
			triggers.load();

			// Custom text triggers (JASS)
			if (hierarchy.map_file_exists("war3map.wct")) {
				triggers.load_scripts();
			}
		}

		std::println("Trigger loading: {:>5}ms", timer.elapsed_ms());
		timer.reset();

		info.load();
		terrain.load(physics);

		std::println("Terrain loading: {:>5}ms", timer.elapsed_ms());
		timer.reset();

		// Pathing Map
		if (hierarchy.map_file_exists("war3map.wpm")) {
			pathing_map.load(terrain.width, terrain.height);
		} else {
			pathing_map.resize(terrain.width * 4, terrain.height * 4);
		}

		std::println("Pathing loading: {:>5}ms", timer.elapsed_ms());
		timer.reset();

		// Doodads
		if (hierarchy.map_file_exists("war3map.w3d")) {
			load_modification_file("war3map.w3d", doodads_slk, doodads_meta_slk, true);
		}

		if (hierarchy.map_file_exists("war3mapSkin.w3d")) {
			load_modification_file("war3mapSkin.w3d", doodads_slk, doodads_meta_slk, true);
		}

		if (hierarchy.map_file_exists("war3map.w3b")) {
			load_modification_file("war3map.w3b", destructibles_slk, destructibles_meta_slk, false);
		}

		if (hierarchy.map_file_exists("war3mapSkin.w3b")) {
			load_modification_file("war3mapSkin.w3b", destructibles_slk, destructibles_meta_slk, false);
		}

		doodads.load(terrain, info);
		doodads.create(terrain, pathing_map);

		std::println("Doodad loading:\t {:>5}ms", timer.elapsed_ms());
		timer.reset();

		if (hierarchy.map_file_exists("war3map.w3u")) {
			load_modification_file("war3map.w3u", units_slk, units_meta_slk, false);
		}

		if (hierarchy.map_file_exists("war3mapSkin.w3u")) {
			load_modification_file("war3mapSkin.w3u", units_slk, units_meta_slk, false);
		}

		if (hierarchy.map_file_exists("war3map.w3t")) {
			load_modification_file("war3map.w3t", items_slk, items_meta_slk, false);
		}

		if (hierarchy.map_file_exists("war3mapSkin.w3t")) {
			load_modification_file("war3mapSkin.w3t", items_slk, items_meta_slk, false);
		}

		// Units/Items
		if (hierarchy.map_file_exists("war3mapUnits.doo")) {
			units.load(terrain, info);
			units.create();
		}

		std::println("Unit loading:\t {:>5}ms", timer.elapsed_ms());
		timer.reset();

		// Abilities
		if (hierarchy.map_file_exists("war3map.w3a")) {
			load_modification_file("war3map.w3a", abilities_slk, abilities_meta_slk, true);
		}

		if (hierarchy.map_file_exists("war3mapSkin.w3a")) {
			load_modification_file("war3mapSkin.w3a", abilities_slk, abilities_meta_slk, true);
		}

		// Buffs
		if (hierarchy.map_file_exists("war3map.w3h")) {
			load_modification_file("war3map.w3h", buff_slk, buff_meta_slk, false);
		}

		if (hierarchy.map_file_exists("war3mapSkin.w3h")) {
			load_modification_file("war3mapSkin.w3h", buff_slk, buff_meta_slk, false);
		}

		// Upgrades
		if (hierarchy.map_file_exists("war3map.w3q")) {
			load_modification_file("war3map.w3q", upgrade_slk, upgrade_meta_slk, true);
		}

		if (hierarchy.map_file_exists("war3mapSkin.w3q")) {
			load_modification_file("war3mapSkin.w3q", upgrade_slk, upgrade_meta_slk, true);
		}

		// Regions
		if (hierarchy.map_file_exists("war3map.w3r")) {
			regions.load();
		}

		// Cameras
		if (hierarchy.map_file_exists("war3map.w3c")) {
			cameras.load(info.game_version_major, info.game_version_minor);
		}

		// Sounds
		if (hierarchy.map_file_exists("war3map.w3s")) {
			sounds.load();
		}

		std::println("Misc loading:\t {:>5}ms", timer.elapsed_ms());
		timer.reset();

		// Center camera
		camera.position = glm::vec3(terrain.width / 2, terrain.height / 2, 0);
		camera.position.z = terrain.interpolated_height(camera.position.x, camera.position.y, true);

		loaded = true;

		connect(
			units_table,
			&TableModel::dataChanged,
			[&](const QModelIndex& top_left, const QModelIndex& top_right, const QVector<int>& roles) {
				const std::string& id = units_slk.index_to_row.at(top_left.row());
				const std::string& field = units_slk.index_to_column.at(top_left.column());
				units.process_unit_field_change(id, field);
			}
		);

		connect(units_table, &TableModel::rowsAboutToBeRemoved, [&](const QModelIndex& parent, int first, int last) {
			for (size_t i = first; i <= last; i++) {
				const std::string& id = units_slk.index_to_row.at(i);
				std::erase_if(units.units, [&](Unit& unit) {
					return unit.id == id;
				});

				if (brush) {
					brush->unselect_id(id);
				}
			}
		});

		connect(
			items_table,
			&TableModel::dataChanged,
			[&](const QModelIndex& top_left, const QModelIndex& top_right, const QVector<int>& roles) {
				const std::string& id = items_slk.index_to_row.at(top_left.row());
				const std::string& field = items_slk.index_to_column.at(top_left.column());
				units.process_item_field_change(id, field);
			}
		);

		connect(items_table, &TableModel::rowsAboutToBeRemoved, [&](const QModelIndex& parent, int first, int last) {
			for (size_t i = first; i <= last; i++) {
				const std::string& id = items_slk.index_to_row.at(i);
				std::erase_if(units.items, [&](Unit& item) {
					return item.id == id;
				});
			}
		});

		connect(
			doodads_table,
			&TableModel::dataChanged,
			[&](const QModelIndex& top_left, const QModelIndex& top_right, const QVector<int>& roles) {
				const std::string& id = doodads_slk.index_to_row.at(top_left.row());
				const std::string& field = doodads_slk.index_to_column.at(top_left.column());
				doodads.process_doodad_field_change(id, field, terrain);
			}
		);

		connect(doodads_table, &TableModel::rowsAboutToBeRemoved, [&](const QModelIndex& parent, int first, int last) {
			for (size_t i = first; i <= last; i++) {
				const std::string& id = doodads_slk.index_to_row.at(i);
				std::erase_if(doodads.doodads, [&](Doodad& doodad) {
					return doodad.id == id;
				});

				if (brush) {
					brush->unselect_id(id);
				}
			}
		});

		connect(
			destructibles_table,
			&TableModel::dataChanged,
			[&](const QModelIndex& top_left, const QModelIndex& top_right, const QVector<int>& roles) {
				const std::string& id = destructibles_slk.index_to_row.at(top_left.row());
				const std::string& field = destructibles_slk.index_to_column.at(top_left.column());
				doodads.process_destructible_field_change(id, field, terrain);
			}
		);

		connect(destructibles_table, &TableModel::rowsAboutToBeRemoved, [&](const QModelIndex& parent, int first, int last) {
			for (size_t i = first; i <= last; i++) {
				const std::string& id = destructibles_slk.index_to_row.at(i);
				std::erase_if(doodads.doodads, [&](Doodad& destructable) {
					return destructable.id == id;
				});

				if (brush) {
					brush->unselect_id(id);
				}
			}
		});
	}

	bool save(const fs::path& path) {
		Timer timer;
		if (!fs::equivalent(path, filesystem_path)) {
			try {
				fs::copy(filesystem_path, fs::absolute(path), fs::copy_options::recursive);
			} catch (fs::filesystem_error& e) {
				QMessageBox msgbox;
				msgbox.setText(e.what());
				msgbox.exec();
				return false;
			}
			filesystem_path = fs::absolute(path) / "";
			name = (*--(--filesystem_path.end())).string();
		}

		pathing_map.save();
		terrain.save();

		save_modification_file("war3map.w3d", doodads_slk, doodads_meta_slk, true, false);
		save_modification_file("war3mapSkin.w3d", doodads_slk, doodads_meta_slk, true, true);
		save_modification_file("war3map.w3b", destructibles_slk, destructibles_meta_slk, false, false);
		save_modification_file("war3mapSkin.w3b", destructibles_slk, destructibles_meta_slk, false, true);
		doodads.save(terrain);

		save_modification_file("war3map.w3u", units_slk, units_meta_slk, false, false);
		save_modification_file("war3mapSkin.w3u", units_slk, units_meta_slk, false, true);
		save_modification_file("war3map.w3t", items_slk, items_meta_slk, false, false);
		save_modification_file("war3mapSkin.w3t", items_slk, items_meta_slk, false, true);
		units.save(terrain);

		save_modification_file("war3map.w3a", abilities_slk, abilities_meta_slk, true, false);
		save_modification_file("war3mapSkin.w3a", abilities_slk, abilities_meta_slk, true, true);

		save_modification_file("war3map.w3h", buff_slk, buff_meta_slk, false, false);
		save_modification_file("war3mapSkin.w3h", buff_slk, buff_meta_slk, false, true);
		save_modification_file("war3map.w3q", upgrade_slk, upgrade_meta_slk, true, false);
		save_modification_file("war3mapSkin.w3q", upgrade_slk, upgrade_meta_slk, true, true);

		info.save(terrain.tileset);
		trigger_strings.save();
		triggers.save();
		triggers.save_scripts();
		ScriptMode mode = ScriptMode::jass;
		if (info.lua) {
			mode = ScriptMode::lua;
		}

		const auto result = triggers.generate_map_script(terrain, units, doodads, info, sounds, regions, cameras, mode);
		if (!result.has_value()) {
			QMessageBox::information(
				nullptr,
				"vJass output",
				"There were compilation errors:\n" + QString::fromStdString(result.error()),
				QMessageBox::StandardButton::Ok
			);
		}

		imports.save(filesystem_path);

		std::println("Saving took: {:>5}ms", timer.elapsed_ms());

		return true;
	}

	void update(double delta, int width, int height) {
		if (!loaded) {
			return;
		}

		camera.position.z = terrain.interpolated_height(camera.position.x, camera.position.y, true);
		camera.update(delta);

		// Update current water texture index
		terrain.current_texture += std::max(0.0, terrain.animation_rate * delta);
		if (terrain.current_texture >= terrain.water_textures_nr) {
			terrain.current_texture = 0;
		}

		/*auto current_time = std::chrono::steady_clock::now().time_since_epoch();
		auto seconds = std::chrono::duration_cast<std::chrono::milliseconds>(current_time).count() / 1000.f;
		light_direction = glm::normalize(glm::vec3(std::cos(seconds), std::sin(seconds), -2.f));*/

		// Map mouse coordinates to world coordinates
		if (input_handler.mouse != input_handler.previous_mouse) {
			glm::vec3 window = {input_handler.mouse.x, height - input_handler.mouse.y, 1.f};
			glm::vec3 pos = glm::unProject(window, camera.view, camera.projection, glm::vec4(0, 0, width, height));
			glm::vec3 origin = camera.position - camera.direction * camera.distance;
			glm::vec3 direction = glm::normalize(pos - origin);
			glm::vec3 toto = origin + direction * 2000.f;

			btVector3 from(origin.x, origin.y, origin.z);
			btVector3 to(toto.x, toto.y, toto.z);

			btCollisionWorld::ClosestRayResultCallback res(from, to);
			res.m_collisionFilterGroup = 32;
			res.m_collisionFilterMask = 32;
			physics.dynamicsWorld->rayTest(from, to, res);

			if (res.hasHit()) {
				auto& hit = res.m_hitPointWorld;
				input_handler.previous_mouse_world = input_handler.mouse_world;
				input_handler.mouse_world = glm::vec3(hit.x(), hit.y(), hit.z());
			}
		}

		// Animate units
		std::for_each(std::execution::par_unseq, units.units.begin(), units.units.end(), [&](Unit& i) {
			if (i.id == "sloc") {
				return;
			} // ToDo handle starting locations

			mdx::Extent& extent = i.mesh->mdx->sequences[i.skeleton.sequence_index].extent;
			if (!camera.inside_frustrum_transform(extent.minimum, extent.maximum, i.skeleton.matrix)) {
				return;
			}

			i.skeleton.update(delta);
		});

		// Animate items
		for (auto& i : units.items) {
			i.skeleton.update(delta);
		}

		// Animate doodads
		std::for_each(std::execution::par_unseq, doodads.doodads.begin(), doodads.doodads.end(), [&](Doodad& i) {
			mdx::Extent& extent = i.mesh->mdx->sequences[i.skeleton.sequence_index].extent;
			if (!camera.inside_frustrum_transform(extent.minimum, extent.maximum, i.skeleton.matrix)) {
				return;
			}

			i.skeleton.update(delta);
		});
	}

	void render() {
		// While switching maps it may happen that render is called before loading has finished.
		if (!loaded) {
			return;
		}

		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glPolygonMode(GL_FRONT_AND_BACK, render_wireframe ? GL_LINE : GL_FILL);

		terrain.render_ground(render_pathing, render_lighting, light_direction, brush, pathing_map);

		if (render_doodads) {
			for (const auto& i : doodads.doodads) {
				render_manager.queue_render(*i.mesh, i.skeleton, i.color, 0);
				if (render_click_helpers) {
					const bool is_doodad = doodads_slk.row_headers.contains(i.id);
					const slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;
					if (slk.data<bool>("useclickhelper", i.id)) {
						render_manager.queue_click_helper(i.skeleton.matrix);
					}
				}
			}
			for (const auto& i : doodads.special_doodads) {
				render_manager.queue_render(*i.mesh, i.skeleton, glm::vec3(1.f), 0);
			}
		}

		if (render_units) {
			for (auto& i : units.units) {
				if (i.id == "sloc") {
					continue;
				} // ToDo handle starting locations

				render_manager.queue_render(*i.mesh, i.skeleton, i.color, i.player);
			}
			for (auto& i : units.items) {
				render_manager.queue_render(*i.mesh, i.skeleton, i.color, i.player);
			}
		}

		if (render_brush && brush) {
			brush->render();
		}

		render_manager.render(render_lighting, render_click_helpers, light_direction);
		if (render_water) {
			terrain.render_water();
		}

		// physics.dynamicsWorld->debugDrawWorld();
		// physics.draw->render();
	}

	void resize(size_t width, size_t height) {
		terrain.resize(width, height);
		pathing_map.resize(width * 4, height * 4);
	}

	std::string get_unique_id(bool first_uppercase) {
		std::random_device rd;
		std::mt19937 mt(rd());
		std::uniform_int_distribution<int> dist(0, 25);
		again:

		std::string id =
			""s + char((first_uppercase ? 'A' : 'a') + dist(mt)) + char('a' + dist(mt)) + char('a' + dist(mt)) + char('a' + dist(mt));

		if (units_slk.row_headers.contains(id) || items_slk.row_headers.contains(id) || abilities_slk.row_headers.contains(id)
			|| doodads_slk.row_headers.contains(id) || destructibles_slk.row_headers.contains(id) || upgrade_slk.row_headers.contains(id)
			|| buff_slk.row_headers.contains(id)) {
			std::print("Generated an existing ID: {} what're the odds\n", id);
			goto again;
		}

		return id;
	}
};

#include "map.moc"

```

`src/base/map_info.ixx`:

```ixx
export module MapInfo;

import std;
import types;
import BinaryReader;
import BinaryWriter;
import Hierarchy;
import Utilities;
import <glm/glm.hpp>;

export enum class PlayerType {
	human,
	computer,
	neutral,
	rescuable
};

export enum class PlayerRace {
	selectable,
	human,
	orc,
	undead,
	night_elf
};

struct PlayerData {
	int internal_number;
	PlayerType type;
	PlayerRace race;
	int fixed_start_position;
	std::string name;
	glm::vec2 starting_position;
	uint32_t ally_low_priorities_flags;
	uint32_t ally_high_priorities_flags;
	uint32_t enemy_low_priorities_flags = 0;
	uint32_t enemy_high_priorities_flags = 0;
};

struct ForceData {
	bool allied;
	bool allied_victory;
	bool share_vision;
	bool share_unit_control;
	bool share_advanced_unit_control;
	int player_masks;
	std::string name;
};

struct UpgradeAvailability {
	int player_flags;
	std::string id;
	int level;
	int availability;
};

struct TechAvailability {
	int player_flags;
	std::string id;
};

struct RandomUnitLine {
	int chance;
	std::vector<std::string> ids;
};

struct RandomUnitTable {
	int creation_number;
	std::string name;
	std::vector<int> positions;
	std::vector<RandomUnitLine> lines;
};

struct RandomItemTable {
	int creation_number;
	std::string name;
	std::vector<ItemSet> item_sets;
};

export class MapInfo {
  public:
	int map_version;
	int editor_version;
	int game_version_major;
	int game_version_minor;
	int game_version_patch;
	int game_version_build;
	std::string name;
	std::string author;
	std::string description;
	std::string suggested_players;

	glm::vec2 camera_left_bottom;
	glm::vec2 camera_right_top;
	glm::vec2 camera_left_top;
	glm::vec2 camera_right_bottom;

	glm::ivec4 camera_complements;

	int playable_width;
	int playable_height;

	int all_flags;
	bool hide_minimap_preview;
	bool modif_ally_priorities;
	bool melee_map;
	bool unknown;
	bool masked_area_partially_visible;
	bool fixed_player_settings;
	bool custom_forces;
	bool custom_techtree;
	bool custom_abilities;
	bool custom_upgrades;
	bool unknown2;
	bool cliff_shore_waves;
	bool rolling_shore_waves;
	bool unknown3;
	bool unknown4;
	bool item_classification;
	bool water_tinting;
	bool accurate_probability_for_calculations;
	bool custom_ability_skins;
	bool disable_deny_icon;
	bool force_default_zoom;
	bool force_max_zoom;
	bool force_min_zoom;

	int loading_screen_number;
	std::string loading_screen_model;
	std::string loading_screen_text;
	std::string loading_screen_title;
	std::string loading_screen_subtitle;

	int game_data_set;

	std::string prologue_screen_model;
	std::string prologue_text;
	std::string prologue_title;
	std::string prologue_subtitle;

	int fog_style;
	float fog_start_z_height;
	float fog_end_z_height;
	float fog_density;
	glm::u8vec4 fog_color;

	int weather_id;
	std::string custom_sound_environment;
	char custom_light_tileset;
	glm::u8vec4 water_color;

	bool lua;
	uint32_t supported_modes;
	uint32_t game_data_version;

	uint32_t default_cam_distance;
	uint32_t max_cam_distance;
	uint32_t min_cam_distance;

	std::vector<PlayerData> players;
	std::vector<ForceData> forces;
	std::vector<UpgradeAvailability> available_upgrades;
	std::vector<TechAvailability> available_tech;
	std::vector<RandomUnitTable> random_unit_tables;
	std::vector<RandomItemTable> random_item_tables;

	static constexpr int write_version = 33;
	static constexpr int write_editor_version = 6116;
	static constexpr int write_game_version_major = 2;
	static constexpr int write_game_version_minor = 0;
	static constexpr int write_game_version_patch = 3;
	static constexpr int write_game_version_build = 22978;

	void load() {
		BinaryReader reader = hierarchy.map_file_read("war3map.w3i").value();

		const int version = reader.read<uint32_t>();

		if (version != 33 && version != 32 && version != 31 && version != 28 && version != 25 && version != 18 && version != 15) {
			std::cout << "Unknown war3map.w3i version\n";
		}

		if (version >= 18) {
			map_version = reader.read<uint32_t>();
			editor_version = reader.read<uint32_t>();

			if (version >= 28) {
				game_version_major = reader.read<uint32_t>();
				game_version_minor = reader.read<uint32_t>();
				game_version_patch = reader.read<uint32_t>();
				game_version_build = reader.read<uint32_t>();
			}
		}
		name = reader.read_c_string();
		author = reader.read_c_string();
		description = reader.read_c_string();
		suggested_players = reader.read_c_string();

		camera_left_bottom = reader.read<glm::vec2>();
		camera_right_top = reader.read<glm::vec2>();
		camera_left_top = reader.read<glm::vec2>();
		camera_right_bottom = reader.read<glm::vec2>();

		camera_complements = reader.read<glm::ivec4>();

		playable_width = reader.read<uint32_t>();
		playable_height = reader.read<uint32_t>();

		const int flags = reader.read<uint32_t>();
		hide_minimap_preview = flags & 0x0001;
		modif_ally_priorities = flags & 0x0002;
		melee_map = flags & 0x0004;
		unknown = flags & 0x0008; // playable map size was large
		masked_area_partially_visible = flags & 0x0010;
		fixed_player_settings = flags & 0x0020;
		custom_forces = flags & 0x0040;
		custom_techtree = flags & 0x0080;
		custom_abilities = flags & 0x0100;
		custom_upgrades = flags & 0x0200;
		unknown2 = flags & 0x0400; // has properties menu been opened
		cliff_shore_waves = flags & 0x0800;
		rolling_shore_waves = flags & 0x1000;
		unknown3 = flags & 0x2000; // has terrain fog
		unknown4 = flags & 0x4000; // requires expansion
		item_classification = flags & 0x8000;
		water_tinting = flags & 0x10000;
		accurate_probability_for_calculations = flags & 0x20000;
		custom_ability_skins = flags & 0x40000;
		disable_deny_icon = flags & 0x80000;
		force_default_zoom = flags & 0x100000;
		force_max_zoom = flags & 0x200000;
		force_min_zoom = flags & 0x400000;

		// Tileset
		reader.advance(1);

		if (version >= 25) { // TFT
			loading_screen_number = reader.read<uint32_t>();
			loading_screen_model = reader.read_c_string();
			loading_screen_text = reader.read_c_string();
			loading_screen_title = reader.read_c_string();
			loading_screen_subtitle = reader.read_c_string();

			game_data_set = reader.read<uint32_t>();

			prologue_screen_model = reader.read_c_string();
			prologue_text = reader.read_c_string();
			prologue_title = reader.read_c_string();
			prologue_subtitle = reader.read_c_string();

			fog_style = reader.read<uint32_t>();
			fog_start_z_height = reader.read<float>();
			fog_end_z_height = reader.read<float>();
			fog_density = reader.read<float>();
			fog_color = reader.read<glm::u8vec4>();

			weather_id = reader.read<uint32_t>();
			custom_sound_environment = reader.read_c_string();
			custom_light_tileset = reader.read<uint8_t>();
			water_color = reader.read<glm::u8vec4>();

			if (version >= 28) {
				lua = reader.read<uint32_t>() == 1;
			}

			if (version >= 31) {
				supported_modes = reader.read<uint32_t>();
				game_data_version = reader.read<uint32_t>();
			}
			if (version >= 32) {
				default_cam_distance = reader.read<uint32_t>();
				max_cam_distance = reader.read<uint32_t>();
				if (version >= 33) {
					min_cam_distance = reader.read<uint32_t>();
				}
			}
		} else if (version == 18) { // RoC
			loading_screen_number = reader.read<uint32_t>();
			loading_screen_text = reader.read_c_string();
			loading_screen_title = reader.read_c_string();
			loading_screen_subtitle = reader.read_c_string();

			// game_data_set = reader.read<uint32_t>();
			reader.advance(4); // ToDo RoC map loading screen number

			prologue_text = reader.read_c_string();
			prologue_title = reader.read_c_string();
			prologue_subtitle = reader.read_c_string();
		} else {
			reader.advance(1); // unknown, loading screen number but only 1 digit?
			loading_screen_text = reader.read_c_string();
			loading_screen_title = reader.read_c_string();
			loading_screen_subtitle = reader.read_c_string();
			reader.advance(4); // prologue stuff?
		}

		players.resize(reader.read<uint32_t>());
		for (auto&& i : players) {
			i.internal_number = reader.read<uint32_t>();
			i.type = static_cast<PlayerType>(reader.read<uint32_t>() - 1);
			i.race = static_cast<PlayerRace>(reader.read<uint32_t>());
			i.fixed_start_position = reader.read<uint32_t>();
			i.name = reader.read_c_string();
			i.starting_position = reader.read<glm::vec2>();
			i.ally_low_priorities_flags = reader.read<uint32_t>();
			i.ally_high_priorities_flags = reader.read<uint32_t>();
			if (version >= 31) {
				i.enemy_low_priorities_flags = reader.read<uint32_t>();
				i.enemy_high_priorities_flags = reader.read<uint32_t>();
			}
		}

		forces.resize(reader.read<uint32_t>());
		for (auto&& i : forces) {
			const uint32_t force_flags = reader.read<uint32_t>();
			i.allied = force_flags & 0b00000001;
			i.allied_victory = force_flags & 0b00000010;
			i.share_vision = force_flags & 0b00001000;
			i.share_unit_control = force_flags & 0b00010000;
			i.share_advanced_unit_control = force_flags & 0b00100000;

			i.player_masks = reader.read<uint32_t>();
			i.name = reader.read_c_string();
		}

		if (reader.remaining() < 4) {
			return;
		}

		available_upgrades.resize(reader.read<uint32_t>());
		for (auto&& i : available_upgrades) {
			i.player_flags = reader.read<uint32_t>();
			i.id = reader.read_string(4);
			i.level = reader.read<uint32_t>();
			i.availability = reader.read<uint32_t>();
		}

		if (reader.remaining() < 4) {
			return;
		}

		available_tech.resize(reader.read<uint32_t>());
		for (auto&& i : available_tech) {
			i.player_flags = reader.read<uint32_t>();
			i.id = reader.read_string(4);
		}

		if (reader.remaining() < 4) {
			return;
		}

		random_unit_tables.resize(reader.read<uint32_t>());
		for (auto&& i : random_unit_tables) {
			i.creation_number = reader.read<uint32_t>();
			i.name = reader.read_c_string();
			i.positions = reader.read_vector<int>(reader.read<uint32_t>());

			i.lines.resize(reader.read<uint32_t>());
			for (auto&& j : i.lines) {
				j.chance = reader.read<uint32_t>();
				for (size_t k = 0; k < i.positions.size(); k++) {
					j.ids.push_back(reader.read_string(4));
				}
			}
		}

		if (reader.remaining() < 4) {
			return;
		}

		if (version >= 25) {
			random_item_tables.resize(reader.read<uint32_t>());
			for (auto&& i : random_item_tables) {
				i.creation_number = reader.read<uint32_t>();
				i.name = reader.read_c_string();
				i.item_sets.resize(reader.read<uint32_t>());
				for (auto&& j : i.item_sets) {
					j.items.resize(reader.read<uint32_t>());
					for (auto&& [chance, id] : j.items) {
						chance = reader.read<uint32_t>();
						id = reader.read_string(4);
					}
				}
			}
		}
	}

	void save(char tileset) const {
		BinaryWriter writer;

		writer.write(write_version);
		writer.write(map_version);
		writer.write(write_editor_version);
		writer.write(write_game_version_major);
		writer.write(write_game_version_minor);
		writer.write(write_game_version_patch);
		writer.write(write_game_version_build);
		writer.write_c_string(name);
		writer.write_c_string(author);
		writer.write_c_string(description);
		writer.write_c_string(suggested_players);

		writer.write(camera_left_bottom);
		writer.write(camera_right_top);
		writer.write(camera_left_top);
		writer.write(camera_right_bottom);

		writer.write(camera_complements);

		writer.write(playable_width);
		writer.write(playable_height);

		const int flags = hide_minimap_preview * 0x0001 
						| modif_ally_priorities * 0x0002
						| melee_map * 0x0004
						| unknown * 0x0008
						| masked_area_partially_visible * 0x0010
						| fixed_player_settings * 0x0020
						| custom_forces * 0x0040
						| custom_techtree * 0x0080
						| custom_abilities * 0x0100
						| custom_upgrades * 0x0200
						| unknown2 * 0x0400
						| cliff_shore_waves * 0x0800
						| rolling_shore_waves * 0x1000
						| unknown3 * 0x2000
						| unknown4 * 0x4000
						| item_classification * 0x8000
						| water_tinting * 0x10000
						| accurate_probability_for_calculations * 0x20000
						| custom_ability_skins * 0x40000
						| disable_deny_icon * 0x80000	
						| force_default_zoom * 0x100000
						| force_max_zoom * 0x200000
						| force_min_zoom * 0x400000;

		writer.write(flags);

		writer.write(tileset);

		writer.write(loading_screen_number);
		writer.write_c_string(loading_screen_model);
		writer.write_c_string(loading_screen_text);
		writer.write_c_string(loading_screen_title);
		writer.write_c_string(loading_screen_subtitle);

		writer.write(game_data_set);

		writer.write_c_string(prologue_screen_model);
		writer.write_c_string(prologue_text);
		writer.write_c_string(prologue_title);
		writer.write_c_string(prologue_subtitle);

		writer.write(fog_style);
		writer.write(fog_start_z_height);
		writer.write(fog_end_z_height);
		writer.write(fog_density);
		writer.write(fog_color);

		writer.write(weather_id);
		writer.write_c_string(custom_sound_environment);
		writer.write(custom_light_tileset);
		writer.write(water_color);

		writer.write((uint32_t)lua);

		writer.write(supported_modes);
		writer.write(game_data_version);

		writer.write(default_cam_distance);
		writer.write(max_cam_distance);
		writer.write(min_cam_distance);

		writer.write<uint32_t>(players.size());
		for (const auto& i : players) {
			writer.write(i.internal_number);
			writer.write(static_cast<int>(i.type) + 1);
			writer.write(static_cast<int>(i.race));
			writer.write(i.fixed_start_position);
			writer.write_c_string(i.name);
			writer.write(i.starting_position);
			writer.write(i.ally_low_priorities_flags);
			writer.write(i.ally_high_priorities_flags);
			writer.write(i.enemy_low_priorities_flags);
			writer.write(i.enemy_high_priorities_flags);
		}

		writer.write<uint32_t>(forces.size());
		for (const auto& i : forces) {
			const uint32_t force_flags = i.allied * 0b00000001 | i.allied_victory * 0b00000010 | i.share_vision * 0b00000100 | i.share_unit_control * 0b00010000 | i.share_advanced_unit_control * 0b00100000;
			writer.write(force_flags);

			writer.write(i.player_masks);
			writer.write_c_string(i.name);
		}

		writer.write<uint32_t>(available_upgrades.size());
		for (const auto& i : available_upgrades) {
			writer.write(i.player_flags);
			writer.write_string(i.id);
			writer.write(i.level);
			writer.write(i.availability);
		}

		writer.write<uint32_t>(available_tech.size());
		for (const auto& i : available_tech) {
			writer.write(i.player_flags);
			writer.write_string(i.id);
		}

		writer.write<uint32_t>(random_unit_tables.size());
		for (const auto& i : random_unit_tables) {
			writer.write(i.creation_number);
			writer.write_c_string(i.name);
			writer.write_vector(i.positions);

			writer.write<uint32_t>(i.lines.size());
			for (const auto& j : i.lines) {
				writer.write(j.chance);
				writer.write_vector(j.ids);
			}
		}

		writer.write<uint32_t>(random_item_tables.size());
		for (const auto& i : random_item_tables) {
			writer.write(i.creation_number);
			writer.write_c_string(i.name);

			writer.write<uint32_t>(i.item_sets.size());
			for (const auto& j : i.item_sets) {
				writer.write<uint32_t>(j.items.size());
				for (const auto& [chance, id] : j.items) {
					writer.write(chance);
					writer.write_string(id);
				}
			}
		}

		hierarchy.map_file_write("war3map.w3i", writer.buffer);
	}
};
```

`src/base/pathing_map.ixx`:

```ixx
module;

#include <QRect>
#include <glad/glad.h>

export module PathingMap;

import std;
import BinaryReader;
import BinaryWriter;
import PathingTexture;
import OpenGLUtilities;
import Hierarchy;
import <glm/glm.hpp>;

export class PathingMap {
	static constexpr int write_version = 0;

  public:
	int width;
	int height;

	enum Flags {
		unwalkable = 0b00000010,
		unflyable = 0b00000100,
		unbuildable = 0b00001000,
	};

	GLuint texture_static;
	GLuint texture_dynamic;
	std::vector<uint8_t> pathing_cells_static;
	std::vector<uint8_t> pathing_cells_dynamic;

	bool load(size_t terrain_width, size_t terrain_height) {
		BinaryReader reader = hierarchy.map_file_read("war3map.wpm").value();
		const std::string magic_number = reader.read_string(4);
		if (magic_number != "MP3W") {
			std::print("Invalid war3map.wpm magic number, expected MP3W but got {}", magic_number);
			return false;
		}

		const int version = reader.read<uint32_t>();
		if (version != 0) {
			std::print("Unknown war3map.wpm version, expected 0 but got {}. Attempting to load, but may crash.\n", version);
		}

		width = reader.read<uint32_t>();
		height = reader.read<uint32_t>();

		if (width == 0 || height == 0) {
			resize(terrain_width * 4, terrain_height * 4);
			return true;
		}

		pathing_cells_static = reader.read_vector<uint8_t>(width * height);
		pathing_cells_dynamic.resize(width * height);

		glCreateTextures(GL_TEXTURE_2D, 1, &texture_static);
		glTextureStorage2D(texture_static, 1, GL_R8UI, width, height);
		glTextureSubImage2D(texture_static, 0, 0, 0, width, height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, pathing_cells_static.data());
		glTextureParameteri(texture_static, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTextureParameteri(texture_static, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTextureParameteri(texture_static, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTextureParameteri(texture_static, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

		glCreateTextures(GL_TEXTURE_2D, 1, &texture_dynamic);
		glTextureStorage2D(texture_dynamic, 1, GL_R8UI, width, height);
		constexpr uint8_t clear_color = 0;
		glClearTexImage(texture_dynamic, 0, GL_RED_INTEGER, GL_UNSIGNED_BYTE, &clear_color);
		glTextureParameteri(texture_dynamic, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTextureParameteri(texture_dynamic, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTextureParameteri(texture_dynamic, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTextureParameteri(texture_dynamic, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

		return true;
	}

	void save() const {
		BinaryWriter writer;
		writer.write_string("MP3W");
		writer.write<uint32_t>(write_version);
		writer.write<uint32_t>(width);
		writer.write<uint32_t>(height);
		writer.write_vector<uint8_t>(pathing_cells_static);

		hierarchy.map_file_write("war3map.wpm", writer.buffer);
	}

	/// Converts the 3-byte RGB array to the pathing map
	/// data.size() should be width * height * 3
	bool from_rgb(const std::span<uint8_t> data) {
		if (data.size() != pathing_cells_static.size() * 3) {
			return false;
		}

		for (size_t i = 0; i < data.size(); i += 3) {
			pathing_cells_static[i / 3] =
				(data[i] > 250) * Flags::unwalkable + (data[i + 1] > 250) * Flags::unflyable + (data[i + 2] > 250) * Flags::unbuildable;
		}

		upload_static_pathing();

		return true;
	}

	/// Converts the internal data (a bitflag array) to a 3-byte RGB array
	[[nodiscard]]
	std::vector<uint8_t> to_rgb() const {
		std::vector<uint8_t> data;
		data.reserve(width * height);

		for (const auto cell : pathing_cells_static) {
			data.push_back(cell & unwalkable ? 255 : 0);
			data.push_back(cell & unflyable ? 255 : 0);
			data.push_back(cell & unbuildable ? 255 : 0);
		}

		return data;
	}

	/// Clears an area with zeroes.
	/// Expects input in pathing tiles.
	void dynamic_clear_area(const QRect& area) {
		const QRect t = area.intersected({0, 0, width, height});
		// +1 because of a Qt quirk of .bottom() and .right()
		for (int j = t.top(); j < t.bottom() + 1; j++) {
			for (int i = t.left(); i < t.right() + 1; i++) {
				pathing_cells_dynamic[j * width + i] = 0;
			}
		}
	}

	/// Checks for every cell on the supplied pathing_texture where (pathing_texture & mask == true) whether (existing_pathing & mask == true) and if so returns false
	/// Expects position in whole grid tiles
	/// Rotation in multiples of 90
	[[nodiscard]] bool is_area_free(const glm::vec2 position, const int rotation, const std::shared_ptr<PathingTexture>& pathing_texture, const uint8_t mask) const {
		const int div_w = (rotation % 180) ? pathing_texture->height : pathing_texture->width;
		const int div_h = (rotation % 180) ? pathing_texture->width : pathing_texture->height;
		for (int j = 0; j < pathing_texture->height; j++) {
			for (int i = 0; i < pathing_texture->width; i++) {
				int x = i;
				int y = j;

				switch (rotation) {
					case 90:
						x = pathing_texture->height - 1 - j;
						y = i;
						break;
					case 180:
						x = pathing_texture->width - 1 - i;
						y = pathing_texture->height - 1 - j;
						break;
					case 270:
						x = j;
						y = pathing_texture->width - 1 - i;
						break;
				}

				// Width and height for centering change if rotation is not divisible by 180
				const int xx = position.x * 4 + x - div_w / 2;
				const int yy = position.y * 4 + y - div_h / 2;

				if (xx < 0 || xx > width - 1 || yy < 0 || yy > height - 1) {
					continue;
				}

				const unsigned int index = ((pathing_texture->height - 1 - j) * pathing_texture->width + i) * pathing_texture->channels;

				const uint8_t pathing_texture_mask = (pathing_texture->data[index] > 250) * Flags::unwalkable
					| (pathing_texture->data[index + 1] > 250) * Flags::unflyable
					| (pathing_texture->data[index + 2] > 250) * Flags::unbuildable;

				if (pathing_texture_mask & mask && pathing_cells_dynamic[yy * width + xx] && mask) {
					return false;
				}
			}
		}
		return true;
	}

	/// Returns whether all cells in the radius around position do not match (pathing & mask == true)
	/// Expects position in whole grid tiles
	bool is_area_free(const glm::vec2 position, const float radius, const uint8_t mask) const {
		const glm::vec2 minimum = glm::max((position - glm::vec2(radius)) * 4.f, glm::vec2(0.0f));
		const glm::vec2 maximum = glm::min((position + glm::vec2(radius)) * 4.f, glm::vec2(width, height));

		for (int y = minimum.y; y < maximum.y; y++) {
			for (int x = minimum.x; x < maximum.x; x++) {
				if (pathing_cells_dynamic[y * width + x] & mask) {
					return false;
				}
			}
		}
		return true;
	}

	/// Blits a pathing texture to the specified location on the pathing map. Manually call update_dynamic() afterwards to upload the changes to the GPU
	/// Expects position in whole grid tiles and draws the texture centered around this position
	/// Rotation in multiples of 90
	/// Blits the texture upside down as OpenGL uses the bottom-left as 0,0
	void blit_pathing_texture(const glm::vec2 position, const int rotation, const std::shared_ptr<PathingTexture>& pathing_texture) {
		const int div_w = (rotation % 180) ? pathing_texture->height : pathing_texture->width;
		const int div_h = (rotation % 180) ? pathing_texture->width : pathing_texture->height;
		for (int j = 0; j < pathing_texture->height; j++) {
			for (int i = 0; i < pathing_texture->width; i++) {
				int x = i;
				int y = j;

				switch (rotation) {
					case 90:
						x = pathing_texture->height - 1 - j;
						y = i;
						break;
					case 180:
						x = pathing_texture->width - 1 - i;
						y = pathing_texture->height - 1 - j;
						break;
					case 270:
						x = j;
						y = pathing_texture->width - 1 - i;
						break;
				}

				// Width and height for centering change if rotation is not divisible by 180
				const int xx = position.x * 4 + x - div_w / 2;
				const int yy = position.y * 4 + y - div_h / 2;

				if (xx < 0 || xx > width - 1 || yy < 0 || yy > height - 1) {
					continue;
				}

				const unsigned int index = ((pathing_texture->height - 1 - j) * pathing_texture->width + i) * pathing_texture->channels;

				uint8_t bytes = (pathing_texture->data[index] > 250) * Flags::unwalkable
					| (pathing_texture->data[index + 1] > 250) * Flags::unflyable
					| (pathing_texture->data[index + 2] > 250) * Flags::unbuildable;

				pathing_cells_dynamic[yy * width + xx] |= bytes;
			}
		}
	}

	void upload_static_pathing() {
		glTextureSubImage2D(texture_static, 0, 0, 0, width, height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, pathing_cells_static.data());
	}

	void upload_dynamic_pathing() {
		glTextureSubImage2D(texture_dynamic, 0, 0, 0, width, height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, pathing_cells_dynamic.data());
	}

	void resize(size_t new_width, size_t new_height) {
		width = new_width;
		height = new_height;

		pathing_cells_static.resize(width * height);
		pathing_cells_dynamic.resize(width * height);

		glDeleteTextures(1, &texture_static);
		glCreateTextures(GL_TEXTURE_2D, 1, &texture_static);
		glTextureStorage2D(texture_static, 1, GL_R8UI, width, height);
		glTextureSubImage2D(texture_static, 0, 0, 0, width, height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, pathing_cells_static.data());
		glTextureParameteri(texture_static, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTextureParameteri(texture_static, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTextureParameteri(texture_static, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTextureParameteri(texture_static, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

		glDeleteTextures(1, &texture_dynamic);
		glCreateTextures(GL_TEXTURE_2D, 1, &texture_dynamic);
		glTextureStorage2D(texture_dynamic, 1, GL_R8UI, width, height);
		const uint8_t clear_color = 0;
		glClearTexImage(texture_dynamic, 0, GL_RED_INTEGER, GL_UNSIGNED_BYTE, &clear_color);
		glTextureParameteri(texture_dynamic, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTextureParameteri(texture_dynamic, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTextureParameteri(texture_dynamic, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTextureParameteri(texture_dynamic, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	}
};

```

`src/base/pathing_undo.ixx`:

```ixx
module;

#include <QRect>

export module PathingUndo;

import std;
import WorldUndoManager;
import PathingMap;

export class PathingMapAction : public WorldCommand {
public:
	QRect area;
	std::vector<uint8_t> old_pathing;
	std::vector<uint8_t> new_pathing;

	void undo(WorldEditContext& ctx) override {
		for (int j = area.top(); j <= area.bottom(); j++) {
			for (int i = area.left(); i <= area.right(); i++) {
				ctx.pathing_map.pathing_cells_static[j * ctx.pathing_map.width + i] = old_pathing[(j - area.top()) * area.width() + i - area.left()];
			}
		}
		ctx.pathing_map.upload_static_pathing();
	}

	void redo(WorldEditContext& ctx) override {
		for (int j = area.top(); j <= area.bottom(); j++) {
			for (int i = area.left(); i <= area.right(); i++) {
				ctx.pathing_map.pathing_cells_static[j * ctx.pathing_map.width + i] = new_pathing[(j - area.top()) * area.width() + i - area.left()];
			}
		}
		ctx.pathing_map.upload_static_pathing();
	}
};
```

`src/base/physics.ixx`:

```ixx
export module Physics;

import std;
import Shader;
import Camera;
import ResourceManager;
import <glad/glad.h>;
import <bullet/btBulletDynamicsCommon.h>;

class PhysicsDebugDraw : public btIDebugDraw {
	std::shared_ptr<Shader> shader;
	GLuint vertex_buffer;

  public:
	std::vector<float> debug_vertices;

	explicit PhysicsDebugDraw()	: btIDebugDraw() {
		glCreateBuffers(1, &vertex_buffer);
		shader = resource_manager.load<Shader>({ "data/shaders/physics_debug.vert", "data/shaders/physics_debug.frag" });
	}

	void drawLine(const btVector3& from, const btVector3& to, const btVector3& color) {
		debug_vertices.push_back(from.x());
		debug_vertices.push_back(from.y());
		debug_vertices.push_back(from.z());
		debug_vertices.push_back(to.x());
		debug_vertices.push_back(to.y());
		debug_vertices.push_back(to.z());
	}

	void drawContactPoint(const btVector3& PointOnB, const btVector3& normalOnB, btScalar distance, int lifeTime, const btVector3& color) {
	}

	void reportErrorWarning(const char* warningString) {
	}

	void draw3dText(const btVector3& location, const char* textString) {
	}

	void setDebugMode(int debugMode) {
	}

	int getDebugMode() const {
		return DBG_DrawWireframe;
	}

	void clearLines() {
		debug_vertices.clear();
	}

	void render() {
		glNamedBufferData(vertex_buffer, debug_vertices.size() * sizeof(float), debug_vertices.data(), GL_STATIC_DRAW);

		shader->use();
		// glDisable(GL_DEPTH_TEST);

		glUniformMatrix4fv(1, 1, GL_FALSE, &camera.projection_view[0][0]);

		glEnableVertexAttribArray(0);
		glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

		glDrawArrays(GL_LINES, 0, debug_vertices.size());

		glDisableVertexAttribArray(0);
		glEnable(GL_DEPTH_TEST);
	}
};

export struct Physics {
	float gravity = -9.81f;

	btBroadphaseInterface* broadphase;
	btDefaultCollisionConfiguration* collisionConfiguration;
	btCollisionDispatcher* dispatcher;
	btSequentialImpulseConstraintSolver* solver;
	btDiscreteDynamicsWorld* dynamicsWorld;

	PhysicsDebugDraw* draw;

	explicit Physics() {
		broadphase = new btDbvtBroadphase();
		collisionConfiguration = new btDefaultCollisionConfiguration();
		dispatcher = new btCollisionDispatcher(collisionConfiguration);
		solver = new btSequentialImpulseConstraintSolver;
		dynamicsWorld = new btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
		dynamicsWorld->setGravity(btVector3(0, 0, gravity));

		draw = new PhysicsDebugDraw;
		draw->setDebugMode(draw->getDebugMode() | btIDebugDraw::DBG_DrawAabb);
		dynamicsWorld->setDebugDrawer(draw);
	}

	~Physics() {
		delete dynamicsWorld;
		delete solver;
		delete dispatcher;
		delete collisionConfiguration;
		delete broadphase;
		delete draw;
	}
};
```

`src/base/regions.ixx`:

```ixx
export module Regions;

import std;
import BinaryReader;
import Hierarchy;
import <glm/glm.hpp>;

struct Region {
	float left;
	float right;
	float top;
	float bottom;
	std::string name;
	int creation_number;
	std::string weather_id;
	std::string ambient_id;
	glm::vec3 color;
};

export class Regions {
	static constexpr int write_version = 5;

  public:
	std::vector<Region> regions;

	bool load() {
		BinaryReader reader = hierarchy.map_file_read("war3map.w3r").value();

		const int version = reader.read<uint32_t>();
		if (version != 5) {
			std::cout << "Unknown Regions file version. Attempting to load, but may crash.";
		}

		regions.resize(reader.read<uint32_t>());
		for (auto& i : regions) {
			i.left = reader.read<float>();
			i.bottom = reader.read<float>();
			i.right = reader.read<float>();
			i.top = reader.read<float>();
			i.name = reader.read_c_string();
			i.creation_number = reader.read<int>();
			i.weather_id = reader.read_string(4);
			i.ambient_id = reader.read_c_string();
			i.color = reader.read<glm::u8vec3>();
			reader.advance(1); // padding?
		}

		return true;
	}

	void save() const {
		//	BinaryWriter writer;
		// writer.write_string("MP3W");
		// writer.write<uint32_t>(write_version);
		// writer.write<uint32_t>(width);
		// writer.write<uint32_t>(height);
		// writer.write_vector<uint8_t>(pathing_cells_static);

		//	hierarchy.map_file_write("war3map.wpr", writer.buffer);
	}
};
```

`src/base/render_manager.ixx`:

```ixx
module;

#include <glad/glad.h>

export module RenderManager;

import std;
import types;
import SkinnedMesh;
import Shader;
import SkeletalModelInstance;
import ResourceManager;
import Timer;
import MDX;
import Camera;
import Utilities;
import Globals;
import Units;
import SLK;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;
import <glm/gtc/quaternion.hpp>;
import Doodads;

export class RenderManager {
  public:
	struct SkinnedInstance {
		SkinnedMesh* mesh;
		uint32_t instance_id;
		float distance;
	};

	std::shared_ptr<Shader> skinned_mesh_shader_sd;
	std::shared_ptr<Shader> skinned_mesh_shader_hd;
	std::shared_ptr<Shader> colored_skinned_shader;

	std::vector<SkinnedMesh*> skinned_meshes;
	std::vector<SkinnedInstance> skinned_transparent_instances;

	std::shared_ptr<SkinnedMesh> click_helper;
	std::vector<SkeletalModelInstance> click_helper_instances;

	GLuint color_buffer;
	GLuint depth_buffer;
	GLuint color_picking_framebuffer;

	int window_width;
	int window_height;

	RenderManager() {
		skinned_mesh_shader_sd = resource_manager.load<Shader>({"data/shaders/skinned_mesh_sd.vert", "data/shaders/skinned_mesh_sd.frag"});
		skinned_mesh_shader_hd = resource_manager.load<Shader>({"data/shaders/skinned_mesh_hd.vert", "data/shaders/skinned_mesh_hd.frag"});
		colored_skinned_shader = resource_manager.load<Shader>(
			{"data/shaders/skinned_mesh_instance_color_coded.vert", "data/shaders/skinned_mesh_instance_color_coded.frag"}
		);

		click_helper = resource_manager.load<SkinnedMesh>("Objects/InvalidObject/InvalidObject.mdx", "", std::nullopt);

		glCreateFramebuffers(1, &color_picking_framebuffer);

		glCreateRenderbuffers(1, &color_buffer);
		glNamedRenderbufferStorage(color_buffer, GL_RGBA8, 800, 600);
		glNamedFramebufferRenderbuffer(color_picking_framebuffer, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, color_buffer);

		glCreateRenderbuffers(1, &depth_buffer);
		glNamedRenderbufferStorage(depth_buffer, GL_DEPTH24_STENCIL8, 800, 600);
		glNamedFramebufferRenderbuffer(color_picking_framebuffer, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depth_buffer);

		if (glCheckNamedFramebufferStatus(color_picking_framebuffer, GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
			std::println("ERROR::FRAMEBUFFER:: Framebuffer is not complete!\n");
		}
	}

	~RenderManager() {
		glDeleteRenderbuffers(1, &color_buffer);
		glDeleteRenderbuffers(1, &depth_buffer);
		glDeleteFramebuffers(1, &color_picking_framebuffer);
	}

	void
	queue_render(SkinnedMesh& skinned_mesh, const SkeletalModelInstance& skeleton, const glm::vec3 color, const uint32_t team_color_index) {
		const mdx::Extent& extent = skinned_mesh.mdx->sequences[skeleton.sequence_index].extent;

		if (!camera.inside_frustrum_transform(extent.minimum, extent.maximum, skeleton.matrix)) {
			return;
		}

		skinned_mesh.render_jobs.push_back(skeleton.matrix);
		skinned_mesh.render_colors.push_back(color);
		skinned_mesh.render_team_color_indexes.push_back(team_color_index);
		skinned_mesh.skeletons.push_back(&skeleton);

		// Register for opaque drawing
		if (skinned_mesh.render_jobs.size() == 1) {
			skinned_meshes.push_back(&skinned_mesh);
		}

		// Register for transparent drawing
		// If the mesh contains transparent parts then those need to be sorted and drawn on top/after all the opaque parts
		if (!skinned_mesh.has_mesh) {
			return;
		}

		if (skinned_mesh.has_transparent_layers) {
			skinned_transparent_instances.push_back(
				RenderManager::SkinnedInstance {
					.mesh = &skinned_mesh,
					.instance_id = static_cast<uint32_t>(skinned_mesh.render_jobs.size() - 1),
					.distance = glm::distance(camera.position - camera.direction * camera.distance, glm::vec3(skeleton.matrix[3])),
				}
			);
		}
	}

	// Renders a click helper (little purple checkered box), kinda inefficient but couldn't be bothered writing a whole new rendering path
	void queue_click_helper(const glm::mat4& model) {
		auto a = SkeletalModelInstance(click_helper->mdx);
		a.matrix = model;
		a.update(0.016f);
		click_helper_instances.push_back(a);
	}

	void render(const bool render_lighting, const bool render_click_helpers, const glm::vec3 light_direction) {
		GLint old_vao;
		glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &old_vao);

		if (render_click_helpers) {
			for (const auto& i : click_helper_instances) {
				queue_render(*click_helper, i, glm::vec3(1.f), 0);
			}
		}

		for (const auto& i : skinned_meshes) {
			i->upload_render_data();
		}

		// Render opaque meshes
		// These don't have to be sorted and can thus be drawn instanced (one draw call per type of mesh)
		skinned_mesh_shader_sd->use();
		glUniformMatrix4fv(0, 1, false, &camera.projection_view[0][0]);
		glUniform3fv(3, 1, &light_direction.x);
		glBlendFunc(GL_ONE, GL_ZERO);

		for (const auto& i : skinned_meshes) {
			i->render_opaque(false, render_lighting);
		}

		skinned_mesh_shader_hd->use();
		glUniformMatrix4fv(0, 1, false, &camera.projection_view[0][0]);
		glUniform3fv(3, 1, &light_direction.x);

		for (const auto& i : skinned_meshes) {
			i->render_opaque(true, render_lighting);
		}

		// Render transparent meshes
		std::ranges::sort(skinned_transparent_instances, [](auto& left, auto& right) {
			return left.distance > right.distance;
		});
		glEnable(GL_BLEND);
		glDepthMask(false);

		skinned_mesh_shader_sd->use();
		glUniformMatrix4fv(0, 1, false, &camera.projection_view[0][0]);
		glUniform1f(1, -1.0f);
		glUniform3fv(3, 1, &light_direction.x);

		for (const auto& i : skinned_transparent_instances) {
			i.mesh->render_transparent(i.instance_id, false, render_lighting);
		}

		skinned_mesh_shader_hd->use();
		glUniformMatrix4fv(0, 1, false, &camera.projection_view[0][0]);
		glUniform1f(1, -1.0f);
		glUniform3fv(3, 1, &light_direction.x);

		for (const auto& i : skinned_transparent_instances) {
			i.mesh->render_transparent(i.instance_id, true, render_lighting);
		}

		glBindVertexArray(old_vao);
		glDepthMask(true);

		for (const auto& i : skinned_meshes) {
			i->clear_render_data();
		}

		click_helper_instances.clear();
		skinned_meshes.clear();
		skinned_transparent_instances.clear();
	}

	void resize_framebuffers(const int width, const int height) {
		glNamedRenderbufferStorage(color_buffer, GL_RGBA8, width, height);
		glNamedRenderbufferStorage(depth_buffer, GL_DEPTH24_STENCIL8, width, height);
		window_width = width;
		window_height = height;
	}

	/// Requires the OpenGL context to be active/current.
	/// Returns the unit ID of the unit that is currently under the mouse coordinates.
	/// Renders the meshes currently inside the view frustrum coded by unit ID and then reads the pixel under the mouse coordinates
	[[nodiscard]]
	std::optional<size_t> pick_unit_id_under_mouse(const Units& units, const glm::vec2 mouse_position) const {
		GLint old_fbo;
		glGetIntegerv(GL_FRAMEBUFFER_BINDING, &old_fbo);
		GLint old_vao;
		glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &old_vao);

		glBindFramebuffer(GL_FRAMEBUFFER, color_picking_framebuffer);

		glClearColor(0, 0, 0, 1);
		glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
		glViewport(0, 0, window_width, window_height);

		glDepthMask(true);
		glDisable(GL_BLEND);

		colored_skinned_shader->use();
		for (size_t i = 0; i < units.units.size(); i++) {
			const Unit& unit = units.units[i];
			if (unit.id == "sloc") {
				continue;
			} // ToDo handle starting locations

			const mdx::Extent& extent = unit.mesh->mdx->sequences[unit.skeleton.sequence_index].extent;
			if (camera.inside_frustrum_transform(extent.minimum, extent.maximum, unit.skeleton.matrix)) {
				unit.mesh->render_color_coded(unit.skeleton, i + 1);
			}
		}

		glm::u8vec4 color;
		glReadPixels(mouse_position.x, window_height - mouse_position.y, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, &color);

		glBindFramebuffer(GL_FRAMEBUFFER, old_fbo);
		glBindVertexArray(old_vao);
		glEnable(GL_BLEND);

		const int index = color.r + (color.g << 8) + (color.b << 16);
		if (index != 0) {
			return {index - 1};
		} else {
			return {};
		}
	}

	/// Requires the OpenGL context to be active/current.
	/// Returns the doodad ID of the doodad that is currently under the mouse coordinates.
	/// Renders the meshes currently inside the view frustrum coded by unit ID and then reads the pixel under the mouse coordinates
	[[nodiscard]]
	std::optional<size_t> pick_doodad_id_under_mouse(const Doodads& doodads, const glm::vec2 mouse_position) const {
		GLint old_fbo;
		glGetIntegerv(GL_FRAMEBUFFER_BINDING, &old_fbo);
		GLint old_vao;
		glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &old_vao);

		glBindFramebuffer(GL_FRAMEBUFFER, color_picking_framebuffer);

		glClearColor(0, 0, 0, 1);
		glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
		glViewport(0, 0, window_width, window_height);

		glDepthMask(true);
		glDisable(GL_BLEND);

		glm::vec3 window = {input_handler.mouse.x, window_height - input_handler.mouse.y, 1.f};
		glm::vec3 pos = glm::unProject(window, camera.view, camera.projection, glm::vec4(0, 0, window_width, window_height));
		glm::vec3 ray_origin = camera.position - camera.direction * camera.distance;
		glm::vec3 ray_direction = glm::normalize(pos - ray_origin);

		colored_skinned_shader->use();
		for (size_t i = 0; i < doodads.doodads.size(); i++) {
			const Doodad& doodad = doodads.doodads[i];

			const mdx::Extent& extent = doodad.mesh->mdx->sequences[doodad.skeleton.sequence_index].extent;
			glm::vec3 local_min = extent.minimum;
			glm::vec3 local_max = extent.maximum;

			const bool is_doodad = doodads_slk.row_headers.contains(doodad.id);
			const slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;
			bool use_click_helper = slk.data<bool>("useclickhelper", doodad.id);
			if (use_click_helper) {
				local_min = glm::min(local_min, click_helper->mdx->extent.minimum);
				local_max = glm::max(local_max, click_helper->mdx->extent.maximum);
			}

			glm::vec3 min;
			glm::vec3 max;
			// From local space to world space
			transform_aabb_non_uniform(local_min, local_max, min, max, doodad.skeleton.matrix);

			if (intersect_aabb(min, max, ray_origin, ray_direction)) {
				doodad.mesh->render_color_coded(doodad.skeleton, i + 1);

				if (use_click_helper) {
					auto a = SkeletalModelInstance(click_helper->mdx);
					a.matrix = doodad.skeleton.matrix;
					a.update(0.016f);
					click_helper->render_color_coded(a, i + 1);
				}
			}
		}

		glm::u8vec4 color;
		glReadPixels(mouse_position.x, window_height - mouse_position.y, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, &color);

		glBindFramebuffer(GL_FRAMEBUFFER, old_fbo);
		glBindVertexArray(old_vao);
		glEnable(GL_BLEND);

		const int index = color.r + (color.g << 8) + (color.b << 16);
		if (index != 0) {
			return {index - 1};
		} else {
			return {};
		}
	}
};

```

`src/base/resource_manager.ixx`:

```ixx
export module ResourceManager;

import std;
import UnorderedMap;

namespace fs = std::filesystem;

export class Resource {
  public:
	virtual ~Resource() = default;
};

export class ResourceManager {
  public:
	/// Loads and caches a resource in memory until no longer referenced.
	/// Whether two load paths lead to different cached instances is determined by the path, T::name and custom_identifier
	/// Any additional arguments are passed to your type its constructor
	template <typename T, typename... Args>
	std::shared_ptr<T> load(const fs::path& path, const std::string& custom_identifier = "", Args... args) {
		static_assert(std::is_base_of_v<Resource, T>, "T must inherit from Resource");
		const std::string resource = path.string() + T::name + custom_identifier;

		auto res = resources[resource].lock();
		if (!res) {
			resources[resource] = res = std::make_shared<T>(path, args...);
		}

		return std::dynamic_pointer_cast<T>(res);
	}

	template <typename T>
	std::shared_ptr<T> load(const std::initializer_list<fs::path> paths) {
		static_assert(std::is_base_of_v<Resource, T>, "T must inherit from Resource");

		std::string resource;
		for (const auto& path : paths) {
			resource += path.string();
		}
		resource += T::name;

		auto res = resources[resource].lock();
		if (!res) {
			resources[resource] = res = std::make_shared<T>(paths);
		}

		return std::dynamic_pointer_cast<T>(res);
	}

  private:
	hive::unordered_map<std::string, std::weak_ptr<Resource>> resources;
};

export inline ResourceManager resource_manager;
```

`src/base/shadow_map.ixx`:

```ixx
export module ShadowMap;

import std;
import types;
import Hierarchy;
import BinaryReader;
import <glad/glad.h>;

export class ShadowMap {
	size_t width;
	size_t height;

	GLuint texture;
	std::vector<u8> cells;

	bool load(BinaryReader& reader, size_t terrain_width, size_t terrain_height) {
		width = terrain_width * 4;
		height = terrain_height * 4;

		cells = reader.read_vector<u8>(width * height);

		glCreateTextures(GL_TEXTURE_2D, 1, &texture);
		glTextureStorage2D(texture, 1, GL_R8UI, width, height);
		glTextureSubImage2D(texture, 0, 0, 0, width, height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, cells.data());
		glTextureParameteri(texture, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTextureParameteri(texture, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTextureParameteri(texture, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTextureParameteri(texture, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

		return true;
	}

	void save() const {
		hierarchy.map_file_write("war3map.shd", cells);
	}

	void resize(size_t width, size_t height) {
	
	}
};
```

`src/base/sounds.ixx`:

```ixx
export module Sounds;

import std;
import types;
import BinaryReader;
import Hierarchy;

struct Sound {
	std::string name;
	std::string file;
	std::string eax_effect;
	// int flags;
	bool looping;
	bool is_3d;
	bool stop_out_of_range;
	bool music;

	int fade_in_rate;
	int fade_out_rate;
	int volume;
	float pitch;
	float pitch_variance;
	int priority;
	int channel;
	float min_distance;
	float max_distance;
	float distance_cutoff;
	float cone_inside;
	float cone_outside;
	int cone_outside_volume;
	float cone_orientation_x;
	float cone_orientation_y;
	float cone_orientation_z;
};

export class Sounds {
  public:
	std::vector<Sound> sounds;

	void load() {
		BinaryReader reader = hierarchy.map_file_read("war3map.w3s").value();

		int version = reader.read<u32>();
		if (version != 1 && version != 2 && version != 3) {
			std::cout << "Unknown war3map.w3s version: " << version << " Attempting to load but may crash\n";
		}

		sounds.resize(reader.read<u32>());
		for (auto& i : sounds) {
			i.name = reader.read_c_string();
			i.file = reader.read_c_string();
			i.eax_effect = reader.read_c_string();
			u32 flags = reader.read<u32>();
			i.looping = flags & 0b00000001;
			i.is_3d = flags & 0b00000010;
			i.stop_out_of_range = flags & 0b00000100;
			i.music = flags & 0b00001000;

			i.fade_in_rate = reader.read<u32>();
			i.fade_out_rate = reader.read<u32>();
			i.volume = reader.read<u32>();
			i.pitch = reader.read<float>();
			i.pitch_variance = reader.read<float>();
			i.priority = reader.read<u32>();
			i.channel = reader.read<u32>();
			i.min_distance = reader.read<float>();
			i.max_distance = reader.read<float>();
			i.distance_cutoff = reader.read<float>();
			i.cone_inside = reader.read<float>();
			i.cone_outside = reader.read<float>();
			i.cone_outside_volume = reader.read<u32>();
			i.cone_orientation_x = reader.read<float>();
			i.cone_orientation_y = reader.read<float>();
			i.cone_orientation_z = reader.read<float>();

			if (version >= 2) {
				reader.advance_c_string();
				reader.advance_c_string();
				reader.advance_c_string();
				reader.advance(4); // int
				reader.advance_c_string();
				reader.advance(4); // int
				reader.advance_c_string();
				reader.advance(4); // int

				reader.advance_c_string();
				reader.advance_c_string();
				reader.advance_c_string();
				reader.advance_c_string();
				if (version >= 3) {
					reader.advance(4); // int
				}
			}
		}
	}

	void save() const {
	}
};
```

`src/base/terrain.ixx`:

```ixx
module;

#include <QObject>
#include <QRect>

#include <brush.h>

export module Terrain;

import std;
import GroundTexture;
import Texture;
import BinaryReader;
import BinaryWriter;
import CliffMesh;
import Shader;
import SLK;
import Physics;
import PathingMap;
import Hierarchy;
import ResourceManager;
import Globals;
import Camera;
import UnorderedMap;
import "glad/glad.h";
import "glm/glm.hpp";
import "glm/gtc/matrix_transform.hpp";
import "glm/gtc/quaternion.hpp";
import "bullet/BulletCollision/CollisionShapes/btHeightfieldTerrainShape.h";
import "btBulletDynamicsCommon.h";

using namespace std::literals::string_literals;

export struct Corner {
	bool map_edge;

	int ground_texture;

	float height;
	float water_height;
	bool ramp;
	bool blight;
	bool water;
	bool boundary;
	bool cliff = false;
	bool romp = false;
	bool special_doodad = false;

	int ground_variation;
	int cliff_variation;

	int cliff_texture;
	int layer_height;

    float final_ground_height() const {
        return height + layer_height - 2.0;
    }

    float final_water_height(const float water_offset) const {
        return water_height + water_offset;
    }
};

export struct TilePathingg {
	bool unwalkable = false;
	bool unflyable = false;
	bool unbuildable = false;

	uint8_t mask() const {
		uint8_t mask = 0;
		mask |= unwalkable ? 0b00000010 : 0;
		mask |= unflyable ? 0b00000100 : 0;
		mask |= unbuildable ? 0b00001000 : 0;
		return mask;
	}
};

export class Terrain : public QObject {
	Q_OBJECT

	static constexpr int write_version = 12;

	// Sequential versions for GPU uploading
	std::vector<float> ground_heights;
	std::vector<float> final_ground_heights;
	std::vector<glm::uvec4> ground_texture_list;
	std::vector<GLuint64> ground_texture_handles;
	std::vector<std::uint32_t> ground_exists_data;

	std::vector<float> water_heights;
	std::vector<uint32_t> water_exists_data;

	btHeightfieldTerrainShape* collision_shape;
	btRigidBody* collision_body;
public:
	char tileset;
	std::vector<std::string> tileset_ids;
	std::vector<std::string> cliffset_ids;

	int width;
	int height;
	glm::vec2 offset;

	// Ground
	std::shared_ptr<Shader> ground_shader;
	hive::unordered_map<std::string, int> ground_texture_to_id;
	std::vector<std::shared_ptr<GroundTexture>> ground_textures;
	hive::unordered_map<std::string, TilePathingg> pathing_options;

	// GPU buffers
	GLuint ground_height_buffer;
	GLuint cliff_level_buffer;
	GLuint water_height_buffer;
	GLuint ground_texture_handle_buffer;
	GLuint ground_texture_data_buffer;
	GLuint ground_exists_buffer;
	GLuint water_exists_buffer;

	std::vector<std::vector<Corner>> corners;
	// For undo/redo operations
	std::vector<std::vector<Corner>> old_corners;

	int variation_size = 64;
	int blight_texture;

	slk::SLK terrain_slk;
	slk::SLK cliff_slk;

	// Cliffs
	std::vector<glm::ivec3> cliffs;
	std::map<std::string, int> path_to_cliff;
	std::map<std::string, int> cliff_variations;
	std::vector<int> cliff_to_ground_texture;

	std::shared_ptr<Shader> cliff_shader;
	std::vector<std::shared_ptr<CliffMesh>> cliff_meshes;
	std::vector<std::shared_ptr<Texture>> cliff_textures;

	GLuint cliff_texture_array;

	int cliff_texture_size = 256;

	// Water
	float min_depth = 10.f / 128.f;
	float deeplevel = 64.f / 128.f;
	float maxdepth = 72.f / 128.f;

	glm::vec4 shallow_color_min;
	glm::vec4 shallow_color_max;
	glm::vec4 deep_color_min;
	glm::vec4 deep_color_max;

	float water_offset;
	int water_textures_nr;
	int animation_rate;

	std::shared_ptr<Shader> water_shader;

	float current_texture = 1.f;
	GLuint water_texture_array;

	~Terrain() {
        glDeleteTextures(1, &cliff_texture_array);
        glDeleteTextures(1, &water_texture_array);

        glDeleteBuffers(1, &ground_height_buffer);
        glDeleteBuffers(1, &cliff_level_buffer);
        glDeleteBuffers(1, &water_height_buffer);
        glDeleteBuffers(1, &ground_texture_data_buffer);
        glDeleteBuffers(1, &ground_exists_buffer);
        glDeleteBuffers(1, &water_exists_buffer);

        //map->physics.dynamicsWorld->removeRigidBody(collision_body);
        //delete collision_body;
        //delete collision_shape;
    }

    bool load(Physics& physics) {
        BinaryReader reader = hierarchy.map_file_read("war3map.w3e").value();

        const std::string magic_number = reader.read_string(4);
        if (magic_number != "W3E!") {
            std::cout << "Invalid war3map.w3e file: Magic number is not W3E!" << std::endl;
            return false;
        }

        const uint32_t version = reader.read<uint32_t>();

        tileset = reader.read<char>();
        reader.advance(4); // Custom tileset

        const uint32_t tileset_textures = reader.read<uint32_t>();
        for (size_t i = 0; i < tileset_textures; i++) {
            tileset_ids.push_back(reader.read_string(4));
        }

        const int cliffset_textures = reader.read<uint32_t>();
        for (int i = 0; i < cliffset_textures; i++) {
            cliffset_ids.push_back(reader.read_string(4));
        }

        width = reader.read<uint32_t>();
        height = reader.read<uint32_t>();

        offset = reader.read<glm::vec2>();

        // Parse all tilepoints
        corners.resize(width, std::vector<Corner>(height));
        for (int j = 0; j < height; j++) {
            for (int i = 0; i < width; i++) {
                Corner& corner = corners[i][j];

                corners[i][j].height = (reader.read<uint16_t>() - 8192.f) / 512.f;

                const uint16_t water_and_edge = reader.read<uint16_t>();
                corners[i][j].water_height = ((water_and_edge & 0x3FFF) - 8192.f) / 512.f;
                corner.map_edge = water_and_edge & 0x4000;

                if (version >= 12 ) {
                    const uint16_t texture_and_flags = reader.read<uint16_t>();
                    corner.ground_texture = texture_and_flags & 0b00'0000'0011'1111;

                    corner.ramp = texture_and_flags & 0b00'0100'0000;
                    corner.blight = texture_and_flags & 0b00'1000'0000;
                    corner.water = texture_and_flags & 0b01'0000'0000;
                    corner.boundary = texture_and_flags & 0b10'0000'0000;
                } else {
                    const uint8_t texture_and_flags = reader.read<uint8_t>();
                    corner.ground_texture = texture_and_flags & 0b0000'1111;

                    corner.ramp = texture_and_flags & 0b0001'0000;
                    corner.blight = texture_and_flags & 0b0010'0000;
                    corner.water = texture_and_flags & 0b0100'0000;
                    corner.boundary = texture_and_flags & 0b1000'0000;
                }

                const uint8_t variation = reader.read<uint8_t>();
                corner.ground_variation = variation & 0b0001'1111;
                corner.cliff_variation = (variation & 0b1110'0000) >> 5;

                const uint8_t misc = reader.read<uint8_t>();
                corner.cliff_texture = (misc & 0b1111'0000) >> 4;
                corner.layer_height = misc & 0b0000'1111;
            }
        }

        create(physics);

        return true;
    }

    void create(const Physics& physics) {
        // Determine if cliff
        for (int i = 0; i < width - 1; i++) {
            for (int j = 0; j < height - 1; j++) {
                Corner& bottom_left = corners[i][j];
                Corner& bottom_right = corners[i + 1][j];
                Corner& top_left = corners[i][j + 1];
                Corner& top_right = corners[i + 1][j + 1];

                bottom_left.cliff = bottom_left.layer_height != bottom_right.layer_height
                    || bottom_left.layer_height != top_left.layer_height
                    || bottom_left.layer_height != top_right.layer_height;
            }
        }
        // Done parsing

        hierarchy.tileset = tileset;

        terrain_slk.load("TerrainArt/Terrain.slk");
        cliff_slk.load("TerrainArt/CliffTypes.slk");
        const slk::SLK water_slk("TerrainArt/Water.slk");

        // Water Textures and Colours

        water_offset = water_slk.data<float>("height", tileset + "Sha"s);
        water_textures_nr = water_slk.data<int>("numtex", tileset + "Sha"s);
        animation_rate = water_slk.data<int>("texrate", tileset + "Sha"s);

        int red = water_slk.data<int>("smin_r", tileset + "Sha"s);
        int green = water_slk.data<int>("smin_g", tileset + "Sha"s);
        int blue = water_slk.data<int>("smin_b", tileset + "Sha"s);
        int alpha = water_slk.data<int>("smin_a", tileset + "Sha"s);

        shallow_color_min = { red, green, blue, alpha };
        shallow_color_min /= 255.f;

        red = water_slk.data<int>("smax_r", tileset + "Sha"s);
        green = water_slk.data<int>("smax_g", tileset + "Sha"s);
        blue = water_slk.data<int>("smax_b", tileset + "Sha"s);
        alpha = water_slk.data<int>("smax_a", tileset + "Sha"s);

        shallow_color_max = { red, green, blue, alpha };
        shallow_color_max /= 255.f;

        red = water_slk.data<int>("dmin_r", tileset + "Sha"s);
        green = water_slk.data<int>("dmin_g", tileset + "Sha"s);
        blue = water_slk.data<int>("dmin_b", tileset + "Sha"s);
        alpha = water_slk.data<int>("dmin_a", tileset + "Sha"s);

        deep_color_min = { red, green, blue, alpha };
        deep_color_min /= 255.f;

        red = water_slk.data<int>("dmax_r", tileset + "Sha"s);
        green = water_slk.data<int>("dmax_g", tileset + "Sha"s);
        blue = water_slk.data<int>("dmax_b", tileset + "Sha"s);
        alpha = water_slk.data<int>("dmax_a", tileset + "Sha"s);

        deep_color_max = { red, green, blue, alpha };
        deep_color_max /= 255.f;

        // Cliff Meshes
        slk::SLK cliffs_variation_slk("data/warcraft/Cliffs.slk", true);
        for (size_t i = 0; i < cliffs_variation_slk.rows(); i++) {
            for (int j = 0; j < cliffs_variation_slk.data<int>("variations", i) + 1; j++) {
                std::string file_name = "Doodads/Terrain/Cliffs/Cliffs" + cliffs_variation_slk.index_to_row.at(i) + std::to_string(j) + ".mdx";
                cliff_meshes.push_back(resource_manager.load<CliffMesh>(file_name));
                path_to_cliff.emplace(cliffs_variation_slk.index_to_row.at(i) + std::to_string(j), static_cast<int>(cliff_meshes.size()) - 1);
            }
            cliff_variations.emplace(cliffs_variation_slk.index_to_row.at(i), cliffs_variation_slk.data<int>("variations", i));
        }

        // Ground textures
        for (const auto& tile_id : tileset_ids) {
            ground_textures.push_back(resource_manager.load<GroundTexture>(terrain_slk.data("dir", tile_id) + "/" + terrain_slk.data("file", tile_id)));
            ground_texture_to_id.emplace(tile_id, static_cast<int>(ground_textures.size() - 1));
        	ground_texture_handles.push_back(ground_textures.back()->bindless_handle);
        }
        blight_texture = static_cast<int>(ground_textures.size());
        ground_texture_to_id.emplace("blight", blight_texture);
        ground_textures.push_back(resource_manager.load<GroundTexture>(world_edit_data.data("TileSets", std::string(1, tileset), 1)));
		ground_texture_handles.push_back(ground_textures.back()->bindless_handle);

        // Cliff Textures
        for (const auto& cliff_id : cliffset_ids) {
            cliff_textures.push_back(resource_manager.load<Texture>(cliff_slk.data("texdir", cliff_id) + "/" + cliff_slk.data("texfile", cliff_id)));
            cliff_texture_size = std::max(cliff_texture_size, cliff_textures.back()->width);
            cliff_to_ground_texture.push_back(ground_texture_to_id[cliff_slk.data<std::string_view>("groundtile", cliff_id)]);
        }

        // prepare GPU buffers
        ground_heights.resize(width * height);
        final_ground_heights.resize(width * height);
        ground_texture_list.resize((width - 1) * (height - 1));
        ground_exists_data.resize(width * height);
        water_heights.resize(width * height);
        water_exists_data.resize(width * height);

        // Ground
        glCreateBuffers(1, &ground_height_buffer);
        glNamedBufferStorage(ground_height_buffer, width * height * sizeof(float), nullptr, GL_DYNAMIC_STORAGE_BIT);
        glCreateBuffers(1, &cliff_level_buffer);
        glNamedBufferStorage(cliff_level_buffer, width * height * sizeof(float), nullptr, GL_DYNAMIC_STORAGE_BIT);
        glCreateBuffers(1, &ground_texture_data_buffer);
        glNamedBufferStorage(ground_texture_data_buffer, (width - 1) * (height - 1) * sizeof(glm::uvec4), nullptr, GL_DYNAMIC_STORAGE_BIT);
		glCreateBuffers(1, &ground_texture_handle_buffer);
		glNamedBufferStorage(ground_texture_handle_buffer, ground_texture_handles.size() * sizeof(GLuint64), ground_texture_handles.data(), GL_DYNAMIC_STORAGE_BIT);
        glCreateBuffers(1, &ground_exists_buffer);
        glNamedBufferStorage(ground_exists_buffer, width * height * sizeof(uint32_t), nullptr, GL_DYNAMIC_STORAGE_BIT);

        // Cliff
        glCreateTextures(GL_TEXTURE_2D_ARRAY, 1, &cliff_texture_array);
        glTextureStorage3D(cliff_texture_array, log2(cliff_texture_size) + 1, GL_RGBA8, cliff_texture_size, cliff_texture_size, cliff_textures.size());
        glTextureParameteri(cliff_texture_array, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
        int sub = 0;
        for (const auto& i : cliff_textures) {
            glTextureSubImage3D(cliff_texture_array, 0, 0, 0, sub, i->width, i->height, 1, i->channels == 4 ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, i->data.data());
            sub += 1;
        }
        glGenerateTextureMipmap(cliff_texture_array);

        // Water
        glCreateBuffers(1, &water_height_buffer);
        glNamedBufferStorage(water_height_buffer, width * height * sizeof(float), nullptr, GL_DYNAMIC_STORAGE_BIT);
        glCreateBuffers(1, &water_exists_buffer);
        glNamedBufferStorage(water_exists_buffer, width * height * sizeof(uint32_t), nullptr, GL_DYNAMIC_STORAGE_BIT);

        // Water textures
        glCreateTextures(GL_TEXTURE_2D_ARRAY, 1, &water_texture_array);
        glTextureStorage3D(water_texture_array, std::log(128) + 1, GL_RGBA8, 128, 128, water_textures_nr);
        glTextureParameteri(water_texture_array, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTextureParameteri(water_texture_array, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        const std::string_view file_name = water_slk.data<std::string_view>("texfile", tileset + "Sha"s);
        for (int i = 0; i < water_textures_nr; i++) {
	        // Hack to force loading of SD water textures till I implement a water shader
        	const auto hd = hierarchy.hd;
        	hierarchy.hd = false;
        	const auto texture = resource_manager.load<Texture>(std::format("{}{:02}", file_name, i));
        	hierarchy.hd = hd;

            if (texture->width != 128 || texture->height != 128) {
                std::cout << "Odd water texture size detected of " << texture->width << " wide and " << texture->height << " high\n";
            }
            glTextureSubImage3D(water_texture_array, 0, 0, 0, i, texture->width, texture->height, 1, texture->channels == 4 ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, texture->data.data());
        }
        glGenerateTextureMipmap(water_texture_array);

        ground_shader = resource_manager.load<Shader>({ "data/shaders/terrain.vert", "data/shaders/terrain.frag" });
        cliff_shader = resource_manager.load<Shader>({ "data/shaders/cliff.vert", "data/shaders/cliff.frag" });
        water_shader = resource_manager.load<Shader>({ "data/shaders/water.vert", "data/shaders/water.frag" });

        collision_shape = new btHeightfieldTerrainShape(width, height, final_ground_heights.data(), 0, -16.f, 16.f, 2 /*z*/, PHY_FLOAT, false);
        collision_body = new btRigidBody(0, new btDefaultMotionState(), collision_shape);
        collision_body->getWorldTransform().setOrigin(btVector3(width / 2.f - 0.5f, height / 2.f - 0.5f, 0.f)); // Bullet centers the collision mesh automatically, we need to decenter it
        collision_body->setCollisionFlags(collision_body->getCollisionFlags() | btCollisionObject::CF_STATIC_OBJECT);
        physics.dynamicsWorld->addRigidBody(collision_body, 32, 32);

        update_ground_textures({ 0, 0, width - 1, height - 1 });
        update_ground_heights({ 0, 0, width - 1, height - 1 });
        update_cliff_meshes({ 0, 0, width - 1, height - 1 });
        update_water({ 0, 0, width - 1, height - 1 });

        emit minimap_changed(minimap_image());
    }

    void save() const {
        BinaryWriter writer;
        writer.write_string("W3E!");
        writer.write(write_version);
        writer.write(tileset);
        writer.write(1);
        writer.write<uint32_t>(tileset_ids.size());
        writer.write_vector(tileset_ids);
        writer.write<uint32_t>(cliffset_ids.size());
        writer.write_vector(cliffset_ids);
        writer.write(width);
        writer.write(height);
        writer.write(offset);

        for (int j = 0; j < height; j++) {
            for (int i = 0; i < width; i++) {
                const Corner& corner = corners[i][j];

                writer.write<uint16_t>(corner.height * 512.f + 8192.f);

                uint16_t water_and_edge = corner.water_height * 512.f + 8192.f;
                water_and_edge += corner.map_edge << 14;
                writer.write(water_and_edge);

                uint16_t texture_and_flags = corner.ground_texture;
                texture_and_flags |= corner.ramp << 6;

                texture_and_flags |= corner.blight << 7;
                texture_and_flags |= corner.water << 8;
                texture_and_flags |= corner.boundary << 9;
                writer.write(texture_and_flags);

                uint8_t variation = corner.ground_variation;
                variation += corner.cliff_variation << 5;
                writer.write(variation);

                uint8_t misc = corner.cliff_texture << 4;
                misc += corner.layer_height;
                writer.write(misc);
            }
        }

        hierarchy.map_file_write("war3map.w3e", writer.buffer);
    }

    void render_ground(bool render_pathing, bool render_lighting, glm::vec3 light_direction, Brush* brush, PathingMap& pathing_map) const {
        // Render tiles
        ground_shader->use();

        glDisable(GL_BLEND);
        glEnable(GL_CULL_FACE);

        glUniformMatrix4fv(1, 1, GL_FALSE, &camera.projection_view[0][0]);
        glUniform1i(2, render_pathing);
        glUniform1i(3, render_lighting);
        glUniform3fv(4, 1, &light_direction.x);
        glUniform2i(7, width, height);

        if (brush) {
            glUniform2fv(5, 1, &brush->get_position()[0]);
        }

        glBindTextureUnit(17, pathing_map.texture_static);
        glBindTextureUnit(18, pathing_map.texture_dynamic);

        glUniform1i(6, brush && brush->get_mode() != Brush::Mode::selection);
        if (brush) {
            glBindTextureUnit(19, brush->brush_texture);
        }

        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, cliff_level_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, ground_height_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, ground_texture_data_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, ground_exists_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 4, ground_texture_handle_buffer);

        // Use gl_VertexID in the shader to determine square position
        glDrawArraysInstanced(GL_TRIANGLES, 0, 6, (width - 1) * (height - 1));

        glEnable(GL_BLEND);

        // Render cliffs
        for (const auto& i : cliffs) {
            const Corner& bottom_left = corners[i.x][i.y];
            const Corner& bottom_right = corners[i.x + 1][i.y];
            const Corner& top_left = corners[i.x][i.y + 1];
            const Corner& top_right = corners[i.x + 1][i.y + 1];

            if (bottom_left.special_doodad) {
                continue;
            }

            const float min = std::min({ bottom_left.layer_height,	bottom_right.layer_height,
                                        top_left.layer_height,		top_right.layer_height });

            cliff_meshes[i.z]->render_queue({ i.x, i.y, min - 2, bottom_left.cliff_texture });
        }

        cliff_shader->use();

        glUniformMatrix4fv(0, 1, GL_FALSE, &camera.projection_view[0][0]);
        glUniform1i(1, render_pathing);
        glUniform1i(2, render_lighting);
        glUniform3fv(3, 1, &light_direction.x);
        if (brush) {
            glUniform2fv(4, 1, &brush->get_position()[0]);
        }
        glUniform1i(5, brush && brush->get_mode() != Brush::Mode::selection);

        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, ground_height_buffer);

        glBindTextureUnit(0, cliff_texture_array);
        glBindTextureUnit(2, pathing_map.texture_static);

        glUniform2i(7, width, height);

        if (brush) {
            glBindTextureUnit(3, brush->brush_texture);
        }
        for (const auto& i : cliff_meshes) {
            i->render();
        }
    }

    void render_water() const {
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glDepthMask(false);

        water_shader->use();

        glUniformMatrix4fv(0, 1, GL_FALSE, &camera.projection_view[0][0]);
        glUniform4fv(1, 1, &shallow_color_min[0]);
        glUniform4fv(2, 1, &shallow_color_max[0]);
        glUniform4fv(3, 1, &deep_color_min[0]);
        glUniform4fv(4, 1, &deep_color_max[0]);
        glUniform1f(5, water_offset);
        glUniform1i(6, current_texture);
        glUniform2i(7, width, height);

        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, cliff_level_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, water_height_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, water_exists_buffer);

        glBindTextureUnit(0, water_texture_array);

        // Use gl_VertexID in the shader to determine square position
        glDrawArraysInstanced(GL_TRIANGLES, 0, 6, (width - 1) * (height - 1));

        glDepthMask(true);
    }

    void change_tileset(const std::vector<std::string>& new_tileset_ids, std::vector<int> new_to_old) {
        tileset_ids = new_tileset_ids;

        // Blight
        new_to_old.push_back(new_tileset_ids.size());

        // Map old ids to the new ids
        for (auto& i : corners) {
            for (auto& j : i) {
                j.ground_texture = new_to_old[j.ground_texture];
            }
        }

        // Reload tile textures
        ground_textures.clear();	// ToDo Clear them after loading new ones?
        ground_texture_to_id.clear();
		ground_texture_handles.clear();

        for (const auto& tile_id : tileset_ids) {
            ground_textures.push_back(resource_manager.load<GroundTexture>(terrain_slk.data("dir", tile_id) + "/" + terrain_slk.data("file", tile_id) + (hierarchy.hd ? "_diffuse.dds" : ".dds")));
            ground_texture_to_id.emplace(tile_id, static_cast<int>(ground_textures.size() - 1));
        	ground_texture_handles.push_back(ground_textures.back()->bindless_handle);
        }
        blight_texture = static_cast<int>(ground_textures.size());
        ground_texture_to_id.emplace("blight", blight_texture);
        ground_textures.push_back(resource_manager.load<GroundTexture>(world_edit_data.data("TileSets", std::string(1, tileset), 1) + (hierarchy.hd ? "_diffuse.dds" : ".dds")));
		ground_texture_handles.push_back(ground_textures.back()->bindless_handle);

		glNamedBufferStorage(ground_texture_handle_buffer, ground_texture_handles.size() * sizeof(GLuint64), ground_texture_handles.data(), GL_DYNAMIC_STORAGE_BIT);

        cliff_to_ground_texture.clear();
        for (const auto& cliff_id : cliffset_ids) {
            cliff_to_ground_texture.push_back(ground_texture_to_id[cliff_slk.data("groundtile", cliff_id)]);
        }

        update_ground_textures({ 0, 0, width, height });
    }

    /// The texture of the tilepoint which is influenced by its surroundings. nearby cliff/ramp > blight > regular texture
    [[nodiscard]] int real_tile_texture(const int x, const int y) const {
        for (int i = -1; i < 1; i++) {
            for (int j = -1; j < 1; j++) {
                if (x + i >= 0 && x + i < width && y + j >= 0 && y + j < height) {
                    if (corners[x + i][y + j].cliff) {
                        if (x + i < width - 1 && y + j < height - 1) {
                            const Corner& bottom_left = corners[x + i][y + j];
                            const Corner& bottom_right = corners[x + i + 1][y + j];
                            const Corner& top_left = corners[x + i][y + j + 1];
                            const Corner& top_right = corners[x + i + 1][y + j + 1];

                            if (bottom_left.ramp && top_left.ramp && bottom_right.ramp && top_right.ramp && !bottom_left.romp && !bottom_right.romp && !top_left.romp && !top_right.romp) {
                                goto out_of_loop;
                            }
                        }
                    }

                    if (corners[x + i][y + j].romp || corners[x + i][y + j].cliff) {
                        int texture = corners[x + i][y + j].cliff_texture;
                        // Number 15 seems to be something
                        if (texture == 15) {
                            texture -= 14;
                        }

                        return cliff_to_ground_texture[texture];
                    }
                }
            }
        }
    out_of_loop:

        if (corners[x][y].blight) {
            return blight_texture;
        }

        return corners[x][y].ground_texture;
    }

    /// The subtexture of a groundtexture to use.
    int get_tile_variation(const int ground_texture, const int variation) const {
        if (ground_textures[ground_texture]->extended) {
            if (variation <= 15) {
                return 16 + variation;
            } else if (variation == 16) {
                return 15;
            } else {
                return 0;
            }
        } else {
            if (variation == 0) {
                return 0;
            } else {
                return 15;
            }
        }
    }

    /// The 4 ground textures of the tilepoint. The first 16 bits are which texture array to use and the next 16 bits are which subtexture to use
    glm::uvec4 get_texture_variations(const int x, const int y) const {
        const int bottom_left = real_tile_texture(x, y);
        const int bottom_right = real_tile_texture(x + 1, y);
        const int top_left = real_tile_texture(x, y + 1);
        const int top_right = real_tile_texture(x + 1, y + 1);

        std::set<int> set({ bottom_left, bottom_right, top_left, top_right });
        glm::uvec4 tiles(0xFFFF); // 0xFFFF is a transparent black pixel in the fragment shader
        int component = 1;

        tiles.x = *set.begin() + (get_tile_variation(*set.begin(), corners[x][y].ground_variation) << 16);
        set.erase(set.begin());

        std::bitset<4> index;
        for (auto&& texture : set) {
            index[0] = bottom_right == texture;
            index[1] = bottom_left == texture;
            index[2] = top_right == texture;
            index[3] = top_left == texture;

            tiles[component++] = texture + (index.to_ulong() << 16);
        }
        return tiles;
    }

    /// Returns the height at x,y by bilinear interpolation
    /// Set water_too to true to also take the water height into account
    float interpolated_height(float x, float y, bool water_too) const {
        x = std::clamp(x, 0.f, width - 1.01f);
        y = std::clamp(y, 0.f, height - 1.01f);


        float p1 = corners[x][y].final_ground_height();
        float p2 = corners[std::ceil(x)][y].final_ground_height();

        float p3 = corners[x][std::ceil(y)].final_ground_height();
        float p4 = corners[std::ceil(x)][std::ceil(y)].final_ground_height();

        if (water_too && corners[x][y].water) {
            p1 = std::max(p1, corners[x][y].final_water_height(water_offset));
        }

        if (water_too && corners[std::ceil(x)][y].water) {
            p2 = std::max(p2, corners[std::ceil(x)][y].final_water_height(water_offset));
        }

        if (water_too && corners[x][std::ceil(y)].water) {
            p3 = std::max(p3, corners[x][std::ceil(y)].final_water_height(water_offset));
        }

        if (water_too && corners[std::ceil(x)][std::ceil(y)].water) {
            p4 = std::max(p4, corners[std::ceil(x)][std::ceil(y)].final_water_height(water_offset));
        }

        float xx = glm::mix(p1, p2, x - floor(x));
        float yy = glm::mix(p3, p4, x - floor(x));
        return glm::mix(xx, yy, y - floor(y));
    }

    // Returns the y gradient in radians
    float gradient_y(float x, float y) const {
        x = std::clamp(x, 0.f, width - 1.01f);
        y = std::clamp(y, 0.f, height - 1.01f);

        float bottom_left = corners[x][y].final_ground_height(); // Is it bottom left?
        float bottom_right = corners[x + 1.f][y].final_ground_height();
        float top_left = corners[x][y + 1.f].final_ground_height();
        float top_right = corners[x + 1.f][y + 1.f].final_ground_height();

        float bottom = glm::mix(bottom_left, bottom_right, x - glm::floor(x));
        float top = glm::mix(top_left, top_right, x - glm::floor(x));

        return std::atan(bottom - top);
    }

    bool is_corner_ramp_entrance(int x, int y) {
        if (x == width || y == height) {
            return false;
        }

        Corner& bottom_left = corners[x][y];
        Corner& bottom_right = corners[x + 1][y];
        Corner& top_left = corners[x][y + 1];
        Corner& top_right = corners[x + 1][y + 1];

        return bottom_left.ramp && top_left.ramp && bottom_right.ramp && top_right.ramp && !(bottom_left.layer_height == top_right.layer_height && top_left.layer_height == bottom_right.layer_height);
    }

    /// Constructs a minimap image with tile, cliff, and water colors. Other objects such as doodads will not be added here
    Texture minimap_image() {
        Texture new_minimap_image;

        new_minimap_image.width = width;
        new_minimap_image.height = height;
        new_minimap_image.channels = 4;
        new_minimap_image.data.resize(width * height * 4);

        for (int j = 0; j < height; j++) {
            for (int i = 0; i < width; i++) {
                glm::vec4 color;

                if (corners[i][j].cliff || (i > 0 && corners[i - 1][j].cliff) || (j > 0 && corners[i][j - 1].cliff) || (i > 0 && j > 0 && corners[i - 1][j - 1].cliff)) {
                    color = glm::vec4(128.f, 128.f, 128.f, 255.f);
                } else {
                    color = ground_textures[real_tile_texture(i, j)]->minimap_color;
                }

                if (corners[i][j].water && corners[i][j].final_water_height(water_offset) > corners[i][j].final_ground_height()) {
                    if (corners[i][j].final_water_height(water_offset) - corners[i][j].final_ground_height() > 0.5f) {
                        color *= 0.5625f;
                        color += glm::vec4(0, 0, 80, 112);
                    } else {
                        color *= 0.75f;
                        color += glm::vec4(0, 0, 48, 64);
                    }
                }

                int index = (height - 1 - j) * (width * 4) + i * 4;
                new_minimap_image.data[index + 0] = color.r;
                new_minimap_image.data[index + 1] = color.g;
                new_minimap_image.data[index + 2] = color.b;
                new_minimap_image.data[index + 3] = color.a;

            }
        }

        return new_minimap_image;
    }

    void upload_ground_heights() const {
        glNamedBufferSubData(ground_height_buffer, 0, ground_heights.size() * sizeof(float), ground_heights.data());
    }

    void upload_corner_heights() const {
        glNamedBufferSubData(cliff_level_buffer, 0, final_ground_heights.size() * sizeof(float), final_ground_heights.data());
    }

    void upload_ground_texture() const {
        glNamedBufferSubData(ground_texture_data_buffer, 0, ground_texture_list.size() * sizeof(glm::uvec4), ground_texture_list.data());
    }

    void upload_ground_exists() const {
        glNamedBufferSubData(ground_exists_buffer, 0, ground_exists_data.size() * sizeof(uint32_t), ground_exists_data.data());
    }

    void upload_water_exists() const {
        glNamedBufferSubData(water_exists_buffer, 0, water_exists_data.size() * sizeof(uint32_t), water_exists_data.data());
    }

    void upload_water_heights() const {
        glNamedBufferSubData(water_height_buffer, 0, water_heights.size() * sizeof(float), water_heights.data());
    }

    void update_ground_heights(const QRect& area) {
        for (int j = area.y(); j < area.y() + area.height(); j++) {
            for (int i = area.x(); i < area.x() + area.width(); i++) {
                ground_heights[j * width + i] = corners[i][j].height; // todo 15.998???

                float ramp_height = 0.f;
                // Check if in one of the configurations the bottom_left is a ramp
                for (int x_offset = -1; x_offset <= 0; x_offset++) {
                    for (int y_offset = -1; y_offset <= 0; y_offset++) {
                        if (i + x_offset >= 0 && i + x_offset < width - 1 && j + y_offset >= 0 && j + y_offset < height - 1) {
                            const Corner& bottom_left = corners[i + x_offset][j + y_offset];
                            const Corner& bottom_right = corners[i + 1 + x_offset][j + y_offset];
                            const Corner& top_left = corners[i + x_offset][j + 1 + y_offset];
                            const Corner& top_right = corners[i + 1 + x_offset][j + 1 + y_offset];

                            const int base = std::min({ bottom_left.layer_height, bottom_right.layer_height, top_left.layer_height, top_right.layer_height });
                            if (corners[i][j].layer_height != base) {
                                continue;
                            }

                            if (is_corner_ramp_entrance(i + x_offset, j + y_offset)) {
                                ramp_height = 0.5f;
                                goto exit_loop;
                            }
                        }
                    }
                }
            exit_loop:

                final_ground_heights[j * width + i] = corners[i][j].final_ground_height() + ramp_height;
            }
        }

        upload_ground_heights();
        upload_corner_heights();
    }

    /// Updates the ground texture variation information and uploads it to the GPU
    void update_ground_textures(const QRect& area) {
        const QRect update_area = area.adjusted(-1, -1, 1, 1).intersected({ 0, 0, width - 1, height - 1 });

        for (int j = update_area.top(); j <= update_area.bottom(); j++) {
            for (int i = update_area.left(); i <= update_area.right(); i++) {
                ground_texture_list[j * (width - 1) + i] = get_texture_variations(i, j);
            }
        }

        upload_ground_texture();
    }

    void update_ground_exists(const QRect& area) {
        QRect update_area = area.adjusted(-1, -1, 1, 1).intersected({ 0, 0, width - 1, height - 1 });

        for (int j = update_area.top(); j <= update_area.bottom(); j++) {
            for (int i = update_area.left(); i <= update_area.right(); i++) {
                ground_exists_data[j * (width - 1) + i] = !(((corners[i][j].cliff || corners[i][j].romp) && !is_corner_ramp_entrance(i, j)) || corners[i][j].special_doodad);
            }
        }

        upload_ground_exists();
    }

    /// Updates and uploads the water data for the GPU
    void update_water(const QRect& area) {
        for (int i = area.x(); i < area.x() + area.width(); i++) {
            for (int j = area.y(); j < area.y() + area.height(); j++) {
                water_exists_data[j * width + i] = corners[i][j].water;
                water_heights[j * width + i] = corners[i][j].water_height;
            }
        }
        upload_water_exists();
        upload_water_heights();
    }

    /// ToDo clean
    /// Function is a bit of a mess
    /// Updates the cliff and ramp meshes for an area
    void update_cliff_meshes(const QRect& area) {
        // Remove all existing cliff meshes in area
        for (size_t i = cliffs.size(); i-- > 0;) {
            glm::ivec3& pos = cliffs[i];
            if (area.contains(pos.x, pos.y)) {
                cliffs.erase(cliffs.begin() + i);
            }
        }

        for (int i = area.x(); i < area.right(); i++) {
            for (int j = area.y(); j < area.bottom(); j++) {
                corners[i][j].romp = false;
            }
        }

        QRect ramp_area = area.adjusted(-2, -2, 2, 2).intersected({ 0, 0, width, height });

        // Add new cliff meshes
        for (int i = ramp_area.x(); i < ramp_area.right(); i++) {
            for (int j = ramp_area.y(); j < ramp_area.bottom(); j++) {
                Corner& bottom_left = corners[i][j];
                Corner& bottom_right = corners[i + 1][j];
                Corner& top_left = corners[i][j + 1];
                Corner& top_right = corners[i + 1][j + 1];

                // Vertical ramps
                if (j < height - 2) {
                    const Corner& top_top_left = corners[i][j + 2];
                    const Corner& top_top_right = corners[i + 1][j + 2];
                    const int ae = std::min(bottom_left.layer_height, top_top_left.layer_height);
                    const int cf = std::min(bottom_right.layer_height, top_top_right.layer_height);

                    if (top_left.layer_height == ae && top_right.layer_height == cf) {
                        int base = std::min(ae, cf);
                        if (bottom_left.ramp == top_left.ramp
                            && bottom_left.ramp == top_top_left.ramp
                            && bottom_right.ramp == top_right.ramp
                            && bottom_right.ramp == top_top_right.ramp
                            && bottom_left.ramp != bottom_right.ramp) {

                            std::string file_name = ""s
                                + char((top_top_left.ramp ? 'L' : 'A') + (top_top_left.layer_height - base) * (top_top_left.ramp ? -4 : 1))
                                + char((top_top_right.ramp ? 'L' : 'A') + (top_top_right.layer_height - base) * (top_top_right.ramp ? -4 : 1))
                                + char((bottom_right.ramp ? 'L' : 'A') + (bottom_right.layer_height - base) * (bottom_right.ramp ? -4 : 1))
                                + char((bottom_left.ramp ? 'L' : 'A') + (bottom_left.layer_height - base) * (bottom_left.ramp ? -4 : 1));

                            file_name = "doodads/terrain/clifftrans/clifftrans" + file_name + "0.mdx";
                            if (hierarchy.file_exists(file_name)) {
                                if (!path_to_cliff.contains(file_name)) {
                                    cliff_meshes.push_back(resource_manager.load<CliffMesh>(file_name));
                                    path_to_cliff.emplace(file_name, static_cast<int>(cliff_meshes.size()) - 1);
                                }

                                cliffs.emplace_back(i, j, path_to_cliff[file_name]);
                                bottom_left.romp = true;
                                top_left.romp = true;

                                continue;
                            }
                        }
                    }
                }

                // Horizontal ramps
                if (i < width - 2) {
                    const Corner& bottom_right_right = corners[i + 2][j];
                    const Corner& top_right_right = corners[i + 2][j + 1];
                    const int ae = std::min(bottom_left.layer_height, bottom_right_right.layer_height);
                    const int bf = std::min(top_left.layer_height, top_right_right.layer_height);

                    if (bottom_right.layer_height == ae && top_right.layer_height == bf) {
                        int base = std::min(ae, bf);
                        if (bottom_left.ramp == bottom_right.ramp
                            && bottom_left.ramp == bottom_right_right.ramp
                            && top_left.ramp == top_right.ramp
                            && top_left.ramp == top_right_right.ramp
                            && bottom_left.ramp != top_left.ramp) {

                            std::string file_name = ""s
                                + char((top_left.ramp ? 'L' : 'A') + (top_left.layer_height - base) * (top_left.ramp ? -4 : 1))
                                + char((top_right_right.ramp ? 'L' : 'A') + (top_right_right.layer_height - base) * (top_right_right.ramp ? -4 : 1))
                                + char((bottom_right_right.ramp ? 'L' : 'A') + (bottom_right_right.layer_height - base) * (bottom_right_right.ramp ? -4 : 1))
                                + char((bottom_left.ramp ? 'L' : 'A') + (bottom_left.layer_height - base) * (bottom_left.ramp ? -4 : 1));

                            file_name = "doodads/terrain/clifftrans/clifftrans" + file_name + "0.mdx";
                            if (hierarchy.file_exists(file_name)) {
                                if (!path_to_cliff.contains(file_name)) {
                                    cliff_meshes.push_back(resource_manager.load<CliffMesh>(file_name));
                                    path_to_cliff.emplace(file_name, static_cast<int>(cliff_meshes.size()) - 1);
                                }

                                cliffs.emplace_back(i, j, path_to_cliff[file_name]);
                                bottom_left.romp = true;
                                bottom_right.romp = true;

                                continue;
                            }
                        }
                    }
                }

                if (!bottom_left.cliff || bottom_left.romp) {
                    continue;
                }

                if (is_corner_ramp_entrance(i, j)) {
                    continue;
                }

                const int base = std::min({bottom_left.layer_height, bottom_right.layer_height, top_left.layer_height, top_right.layer_height});

                // Cliff model path
                std::string file_name = ""s
                    + char('A' + top_left.layer_height - base)
                    + char('A' + top_right.layer_height - base)
                    + char('A' + bottom_right.layer_height - base)
                    + char('A' + bottom_left.layer_height - base);

                if (file_name == "AAAA") {
                    continue;
                }

                // Clamp to within max variations
                file_name += std::to_string(std::clamp(bottom_left.cliff_variation, 0, cliff_variations[file_name]));

                cliffs.emplace_back(i, j, path_to_cliff[file_name]);
            }
        }

        update_ground_exists(ramp_area);
    }

    void resize(size_t new_width, size_t new_height) {
        //glDeleteTextures(1, &ground_height);
        //glDeleteTextures(1, &ground_texture_data);
        //glDeleteTextures(1, &ground_exists);

        //glDeleteTextures(1, &water_exists);
        //glDeleteTextures(1, &water_height);

        //width = new_width;
        //height = new_height;

        //auto t = corners[0][0];
        //corners.clear();
        //corners.resize(width, std::vector<Corner>(height, t));

        //ground_heights.resize(width * height);
        //ground_corner_heights.resize(width * height);
        //ground_texture_list.resize((width - 1) * (height - 1));
        //ground_exists_data.resize(width * height);

        //water_heights.resize(width * height);
        //water_exists_data.resize(width * height);

        //for (int i = 0; i < width; i++) {
        //	for (int j = 0; j < height; j++) {
        //		ground_corner_heights[j * width + i] = corners[i][j].final_ground_height();
        //		water_exists_data[j * width + i] = corners[i][j].water;
        //		ground_heights[j * width + i] = corners[i][j].height;
        //		water_heights[j * width + i] = corners[i][j].water_height;
        //	}
        //}

        //for (int i = 0; i < width - 1; i++) {
        //	for (int j = 0; j < height - 1; j++) {
        //		Corner& bottom_left = corners[i][j];
        //		Corner& bottom_right = corners[i + 1][j];
        //		Corner& top_left = corners[i][j + 1];
        //		Corner& top_right = corners[i + 1][j + 1];

        //		bottom_left.cliff = bottom_left.layer_height != bottom_right.layer_height || bottom_left.layer_height != top_left.layer_height || bottom_left.layer_height != top_right.layer_height;
        //	}
        //}

        //glCreateTextures(GL_TEXTURE_2D, 1, &ground_height);
        //glTextureStorage2D(ground_height, 1, GL_R16F, width, height);
        //glTextureSubImage2D(ground_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, ground_heights.data());
        //glTextureParameteri(ground_height, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        //glTextureParameteri(ground_height, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        //glCreateTextures(GL_TEXTURE_2D, 1, &ground_corner_height);
        //glTextureStorage2D(ground_corner_height, 1, GL_R16F, width, height);
        //glTextureSubImage2D(ground_corner_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, ground_corner_heights.data());
        //glTextureParameteri(ground_corner_height, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        //glTextureParameteri(ground_corner_height, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        //glCreateTextures(GL_TEXTURE_2D, 1, &ground_texture_data);
        //glTextureStorage2D(ground_texture_data, 1, GL_RGBA16UI, width - 1, height - 1);
        //glTextureParameteri(ground_texture_data, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        //glTextureParameteri(ground_texture_data, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

        //glCreateTextures(GL_TEXTURE_2D, 1, &ground_exists);
        //glTextureStorage2D(ground_exists, 1, GL_R8, width, height);

        //// Water
        //glCreateTextures(GL_TEXTURE_2D, 1, &water_height);
        //glTextureStorage2D(water_height, 1, GL_R16F, width, height);
        //glTextureSubImage2D(water_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, water_heights.data());

        //glCreateTextures(GL_TEXTURE_2D, 1, &water_exists);
        //glTextureStorage2D(water_exists, 1, GL_R8, width, height);
        //glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        //glTextureSubImage2D(water_exists, 0, 0, 0, width, height, GL_RED, GL_UNSIGNED_BYTE, water_exists_data.data());
        //glPixelStorei(GL_UNPACK_ALIGNMENT, 4);

        //update_cliff_meshes({ 0, 0, width - 1, height - 1 });
        //update_ground_textures({ 0, 0, width - 1, height - 1 });
        //update_ground_heights({ 0, 0, width - 1, height - 1 });

        //map->physics.dynamicsWorld->removeRigidBody(collision_body);
        //delete collision_body;
        //delete collision_shape;

        //collision_shape = new btHeightfieldTerrainShape(width, height, ground_corner_heights.data(), 0, -16.f, 16.f, 2 /*z*/, PHY_FLOAT, false);
        //if (collision_shape == nullptr) {
        //	std::cout << "Error creating Bullet collision shape\n";
        //}
        //collision_body = new btRigidBody(0, new btDefaultMotionState(), collision_shape);
        //collision_body->getWorldTransform().setOrigin(btVector3(width / 2.f - 0.5f, height / 2.f - 0.5f, 0.f)); // Bullet centers the collision mesh automatically, we need to decenter it and place it under the player
        //collision_body->setCollisionFlags(collision_body->getCollisionFlags() | btCollisionObject::CF_STATIC_OBJECT);
        //map->physics.dynamicsWorld->addRigidBody(collision_body, 32, 32);
    }

    void update_minimap() {
        emit minimap_changed(minimap_image());
    }

signals:
	void minimap_changed(Texture minimap);
};

#include "terrain.moc"
```

`src/base/terrain_undo.ixx`:

```ixx
module;

#include <QRect>

export module TerrainUndo;

import std;
import Terrain;
import Units;
import WorldUndoManager;

export enum class TerrainUndoType {
	texture,
	height,
	cliff,
	water
};

export class TerrainGenericAction final : public WorldCommand {
public:
	QRect area;
	std::vector<Corner> old_corners;
	std::vector<Corner> new_corners;
	TerrainUndoType undo_type;

	void undo(WorldEditContext& ctx) override {
		for (int j = area.top(); j <= area.bottom(); j++) {
			for (int i = area.left(); i <= area.right(); i++) {
				ctx.terrain.corners[i][j] = old_corners[(j - area.top()) * area.width() + i - area.left()];
			}
		}

		if (undo_type == TerrainUndoType::height) {
			ctx.terrain.update_ground_heights(area);
		}

		if (undo_type == TerrainUndoType::texture) {
			ctx.terrain.update_ground_textures(area);
		}

		if (undo_type == TerrainUndoType::cliff) {
			ctx.terrain.update_ground_heights(area);
			ctx.terrain.update_cliff_meshes(area);
			ctx.terrain.update_ground_textures(area);
			ctx.terrain.update_water(area);
		}

		ctx.terrain.update_minimap();
		ctx.units.update_area(area, ctx.terrain);
	}

	void redo(WorldEditContext& ctx) override {
		for (int j = area.top(); j <= area.bottom(); j++) {
			for (int i = area.left(); i <= area.right(); i++) {
				ctx.terrain.corners[i][j] = new_corners[(j - area.top()) * area.width() + i - area.left()];
			}
		}

		if (undo_type == TerrainUndoType::height) {
			ctx.terrain.update_ground_heights(area);
		}

		if (undo_type == TerrainUndoType::texture) {
			ctx.terrain.update_ground_textures(area);
		}

		if (undo_type == TerrainUndoType::cliff) {
			ctx.terrain.update_ground_heights(area);
			ctx.terrain.update_cliff_meshes(area);
			ctx.terrain.update_ground_textures(area);
			ctx.terrain.update_water(area);
		}

		ctx.terrain.update_minimap();
		ctx.units.update_area(area, ctx.terrain);
	}
};
```

`src/base/trigger_strings.ixx`:

```ixx
export module TriggerStrings;

import std;
import types;
import BinaryReader;
import BinaryWriter;
import Hierarchy;

export class TriggerStrings {
	std::map<std::string, std::string> strings; // ToDo change back to unordered_map?

	size_t next_id;

  public:
	void load() {
		BinaryReader reader = hierarchy.map_file_read("war3map.wts").value();

		std::stringstream file;
		file.write(reinterpret_cast<char*>(reader.buffer.data()), reader.buffer.size());

		std::string key;
		std::string line;
		while (std::getline(file, line)) {
			if (line.empty() || line.substr(0, 2) == "//") {
				continue;
			}
			if (line.back() == '\r') {
				line.pop_back();
			}

			if (line.empty()) {
				continue;
			}

			line.erase(std::remove_if(line.begin(), line.end(), [](char c) { return c == '\r'; }), line.end());

			if (line.front() == '{') {
				std::string value;
				bool first = true;
				while (std::getline(file, line) && !line.empty() && line.front() != '}') {
					if (line.back() == '\r') {
						line.pop_back();
					}
					value += (first ? "" : "\n") + line;
					first = false;
				}
				strings.emplace(key, value);
			} else {
				size_t found = line.find(' ') + 1;
				next_id = std::max(next_id, found);
				int padsize = std::max(0, 3 - ((int)line.size() - (int)found));
				key = "TRIGSTR_" + std::string(padsize, '0') + line.substr(found);
			}
		}
	}

	void save() const {
		BinaryWriter writer;

		writer.write<u8>(0xEF);
		writer.write<u8>(0xBB);
		writer.write<u8>(0xBF);

		std::stringstream file;
		for (auto&& [key, value] : strings) {
			auto found = key.find('_') + 1;
			std::string final_key = "STRING " + key.substr(found);

			// Remove leading zeroes
			while (final_key.front() == '0') {
				final_key.erase(final_key.begin());
			}

			std::string final_value = value;
			// Insert carriage returns
			auto it = final_value.begin();
			while (it != final_value.end()) {
				if (*it == '\n') {
					it = final_value.insert(it, '\r');
					it++;
				}
				it++;
			}

			writer.write_string(final_key);
			writer.write_string("\r\n{\r\n");
			writer.write_string(final_value);
			writer.write_string("\r\n}\r\n\r\n");
		}

		hierarchy.map_file_write("war3map.wts", writer.buffer);
	}

	std::string_view string(const std::string_view key) const {
		const auto found = strings.find(std::string(key));

		if (found == strings.end()) {
			return {};
		}

		return found->second;
	}

	/// If the key exists then the correspending string in the trigger string file is set
	/// If the key does not exist AND the key empty AND the value is not empty then a string reference is created and assigned to the key variable
	void set_string(std::string& key, const std::string& value) {
		if (key.rfind("TRIGSTR_", 0) != 0) {
			if (key.empty() && !value.empty()) {
				const int padsize = std::max(0, 2 - static_cast<int>(std::log10(next_id)));
				key = "TRIGSTR_" + std::string(padsize, '0') + std::to_string(++next_id);
				strings[key] = value;
				std::cout << "Creating key: " << key << "  " << value << "\n";

				return;
			}
			std::cout << "Invalid TRIGSTR set: " << key << " " << value << "\n";
			return;
		}

		strings[key] = value;
	}
};
```

`src/base/triggers/gui.cpp`:

```cpp
module Triggers;

import std;

std::string Triggers::get_type(const std::string_view function_name, const size_t parameter) const {
	std::string type;

	if (trigger_data.key_exists("TriggerActions", function_name)) {
		type = trigger_data.data("TriggerActions", function_name, 1 + parameter);
	} else if (trigger_data.key_exists("TriggerCalls", function_name)) {
		type = trigger_data.data("TriggerCalls", function_name, 3 + parameter);
	} else if (trigger_data.key_exists("TriggerEvents", function_name)) {
		type = trigger_data.data("TriggerEvents", function_name, 1 + parameter);
	} else if (trigger_data.key_exists("TriggerConditions", function_name)) {
		type = trigger_data.data("TriggerConditions", function_name, 1 + parameter);
	}
	return type;
}

std::string generate_function_name(const std::string& trigger_name) {
	static size_t counter = 0;
	return "Trig_" + trigger_name + "_HiveWE" + std::to_string(counter++);
}

std::string Triggers::resolve_parameter(
	const TriggerParameter& parameter,
	const std::string& trigger_name,
	MapScriptWriter& pre_actions,
	const std::string& type,
	ScriptMode mode,
	bool add_call = false
) const {
	switch (parameter.type) {
		case TriggerParameter::Type::invalid:
			std::print("Invalid parameter type\n");
			return "";
		case TriggerParameter::Type::preset: {
			const std::string preset_type = trigger_data.data("TriggerParams", parameter.value, 1);

			if (get_base_type(preset_type, trigger_data) == "string") {
				return string_replaced(trigger_data.data("TriggerParams", parameter.value, 2), "`", "\"");
			}

			if (preset_type == "timedlifebuffcode" // ToDo this seems like a hack?
				|| type == "abilcode" || type == "buffcode" || type == "destructablecode" || type == "itemcode" || type == "ordercode"
				|| type == "techcode" || type == "unitcode" || type == "heroskillcode" || type == "weathereffectcode"
				|| type == "timedlifebuffcode" || type == "doodadcode" || type == "timedlifebuffcode" || type == "terraintype") {
				MapScriptWriter writer(mode);
				// We strip the ''
				const auto stripped = string_replaced(trigger_data.data("TriggerParams", parameter.value, 2), "'", "");
				return writer.four_cc(stripped);
			}

			return trigger_data.data("TriggerParams", parameter.value, 2);
		}
		case TriggerParameter::Type::function:
			if (parameter.has_sub_parameter) {
				return convert_eca_to_script(parameter.sub_parameter, pre_actions, trigger_name, mode, add_call);
			} else {
				return parameter.value + "()";
			}
		case TriggerParameter::Type::variable: {
			std::string output = parameter.value;

			if (!output.starts_with("gg_")) {
				output = "udg_" + output;
			}

			if (parameter.is_array) {
				output += "[" + resolve_parameter(parameter.parameters[0], trigger_name, pre_actions, "integer", mode) + "]";
			}
			return output;
		}
		case TriggerParameter::Type::string:
			if (get_base_type(type, trigger_data) == "string") {
				return "\"" + string_replaced(parameter.value, "\\", "\\\\") + "\"";
			} else if (type == "abilcode" // ToDo this seems like a hack?
					   || type == "buffcode" || type == "destructablecode" || type == "itemcode" || type == "ordercode"
					   || type == "techcode" || type == "unitcode" || type == "heroskillcode" || type == "weathereffectcode"
					   || type == "timedlifebuffcode" || type == "doodadcode" || type == "timedlifebuffcode" || type == "terraintype") {
				MapScriptWriter writer(mode);
				return writer.four_cc(parameter.value);
			} else {
				return parameter.value;
			}
	}
	std::print("Unable to resolve parameter for trigger: {} and parameter value {}\n", trigger_name, parameter.value);
	return "";
}

std::string Triggers::convert_eca_to_script(
	const ECA& eca,
	MapScriptWriter& pre_actions,
	const std::string& trigger_name,
	ScriptMode mode,
	bool add_call
) const {
	if (!eca.enabled) {
		return "";
	}

	if (eca.name == "IfThenElse") {
		const std::string function_name = generate_function_name(trigger_name);

		pre_actions.function(
			function_name,
			[&] {
				pre_actions.write_ln(
					"return ",
					resolve_parameter(eca.parameters[0], trigger_name, pre_actions, get_type(eca.name, 0), mode)
				);
			},
			"takes nothing returns boolean"
		);

		MapScriptWriter writer(mode);

		writer.if_else_statement(
			function_name + "()",
			[&] {
				writer.write_ln(resolve_parameter(eca.parameters[1], trigger_name, pre_actions, get_type(eca.name, 1), mode, true));
			},
			[&] {
				writer.write_ln(resolve_parameter(eca.parameters[2], trigger_name, pre_actions, get_type(eca.name, 2), mode, true));
			}
		);

		return writer.script;
	}

	if (eca.name == "IfThenElseMultiple") {
		const std::string function_name = generate_function_name(trigger_name);

		std::vector<std::string> conditions;
		for (const auto& i : eca.ecas) {
			if (i.type != ECA::Type::condition) {
				continue;
			}
			conditions.push_back(convert_eca_to_script(i, pre_actions, trigger_name, mode, false));
		}

		pre_actions.function(
			function_name,
			[&] {
				for (const auto& i : conditions) {
					pre_actions.if_statement(std::format("not ({})", i), [&] {
						pre_actions.write_ln("return false");
					});
				}

				pre_actions.write_ln("return true");
			},
			"takes nothing returns boolean"
		);

		MapScriptWriter writer(mode);

		writer.if_else_statement(
			function_name + "()",
			[&] {
				for (const auto& i : eca.ecas) {
					if (i.type != ECA::Type::action) {
						continue;
					}

					if (i.group == 1) {
						writer.write_ln(convert_eca_to_script(i, pre_actions, trigger_name, mode, true));
					}
				}
			},
			[&] {
				for (const auto& i : eca.ecas) {
					if (i.type != ECA::Type::action) {
						continue;
					}

					// TODO, I suspect group 0 is the if, group 1 is the then and group 2 is the else
					if (i.group != 1) {
						writer.write_ln(convert_eca_to_script(i, pre_actions, trigger_name, mode, true));
					}
				}
			}
		);

		return writer.script;
	}

	if (eca.name.starts_with("ForLoopA") || eca.name.starts_with("ForLoopB")) {
		const std::string loop_index = eca.name.starts_with("ForLoopA") ? "bj_forLoopAIndex" : "bj_forLoopBIndex";
		const std::string loop_index_end = eca.name.starts_with("ForLoopA") ? "bj_forLoopAIndexEnd" : "bj_forLoopBIndexEnd";

		const auto start_at = resolve_parameter(eca.parameters[0], trigger_name, pre_actions, get_type(eca.name, 0), mode);
		const auto exit_when = resolve_parameter(eca.parameters[1], trigger_name, pre_actions, get_type(eca.name, 1), mode);

		MapScriptWriter writer(mode);

		writer.set_variable(loop_index, start_at);
		// Have to set this as somebody might have used the variable inside
		writer.set_variable(loop_index_end, exit_when);

		writer.while_statement(std::format("{} <= {}", loop_index, loop_index_end), [&] {
			if (eca.name.ends_with("Multiple")) {
				for (const auto& i : eca.ecas) {
					writer.write_ln(convert_eca_to_script(i, pre_actions, trigger_name, mode, true));
				}
			} else {
				writer.write_ln(resolve_parameter(eca.parameters[2], trigger_name, pre_actions, get_type(eca.name, 2), mode, true));
			}

			writer.set_variable(loop_index, loop_index + " + 1");
		});

		return writer.script;
	}

	if (eca.name == "ForLoopVarMultiple" || eca.name == "ForLoopVar") {
		const auto variable = resolve_parameter(eca.parameters[0], trigger_name, pre_actions, "integer", mode);
		const auto start_at = resolve_parameter(eca.parameters[1], trigger_name, pre_actions, get_type(eca.name, 1), mode);
		const auto exit_when = resolve_parameter(eca.parameters[2], trigger_name, pre_actions, get_type(eca.name, 2), mode);

		MapScriptWriter writer(mode);
		writer.set_variable(variable, start_at);
		writer.while_statement(std::format("{} <= {}", variable, exit_when), [&] {
			if (eca.name == "ForLoopVarMultiple") {
				for (const auto& i : eca.ecas) {
					writer.write_ln(convert_eca_to_script(i, pre_actions, trigger_name, mode, true));
				}
			} else {
				writer.write_ln(resolve_parameter(eca.parameters[3], trigger_name, pre_actions, get_type(eca.name, 3), mode, true));
			}

			writer.set_variable(variable, variable + " + 1");
		});

		return writer.script;
	}

	if (eca.name == "AndMultiple" || eca.name == "OrMultiple") {
		const std::string function_name = generate_function_name(trigger_name);

		std::vector<std::string> conditions;
		for (const auto& i : eca.ecas) {
			conditions.push_back(convert_eca_to_script(i, pre_actions, trigger_name, mode, false));
		}

		pre_actions.function(
			function_name,
			[&] {
				if (eca.name == "AndMultiple") {
					for (const auto& i : conditions) {
						pre_actions.if_statement(std::format("not({})", i), [&] {
							pre_actions.write_ln("return false");
						});
					}

					pre_actions.write_ln("return true");
				} else {
					for (const auto& i : conditions) {
						pre_actions.if_statement(i, [&] {
							pre_actions.write_ln("return true");
						});
					}

					pre_actions.write_ln("return false");
				}
			},
			"takes nothing returns boolean"
		);

		return function_name + "()";
	}

	if (eca.name == "SetVariable") {
		const std::string& type = std::ranges::find_if(variables, [&](const TriggerVariable& var) {
									  return var.name == eca.parameters[0].value;
								  })->type;
		const std::string first = resolve_parameter(eca.parameters[0], trigger_name, pre_actions, "", mode);
		const std::string second = resolve_parameter(eca.parameters[1], trigger_name, pre_actions, type, mode);

		MapScriptWriter writer(mode);
		writer.set_variable(first, second);
		return writer.script;
	}

	if (eca.name == "CommentString") {
		if (mode == ScriptMode::jass) {
			return "//" + resolve_parameter(eca.parameters[0], trigger_name, pre_actions, "", mode);
		} else {
			return "--" + resolve_parameter(eca.parameters[0], trigger_name, pre_actions, "", mode);
		}
	}

	if (eca.name == "CustomScriptCode") {
		return resolve_parameter(eca.parameters[0], trigger_name, pre_actions, "", mode);
	}

	std::vector<std::string> resolved_parameters;
	for (size_t i = 0; i < eca.parameters.size(); ++i) {
		resolved_parameters.push_back(resolve_parameter(eca.parameters[i], trigger_name, pre_actions, get_type(eca.name, i), mode));
	}

	// Handle remaining multiples
	if (eca.name.ends_with("Multiple")) {
		const std::string script_name = trigger_data.data("TriggerActions", "_" + eca.name + "_ScriptName");

		const std::string function_name = generate_function_name(trigger_name);

		std::vector<std::string> ecas;
		for (const auto& i : eca.ecas) {
			ecas.push_back(convert_eca_to_script(i, pre_actions, trigger_name, mode, true));
		}

		pre_actions.function(function_name, [&] {
			for (const auto& i : ecas) {
				pre_actions.write_ln(i);
			}
		});

		MapScriptWriter writer(mode);

		if (eca.name == "EnumDestructablesInCircleBJMultiple") {
			writer.call(script_name, resolved_parameters[0], resolved_parameters[1], "function " + function_name);
		} else {
			writer.call(script_name, resolved_parameters[0], "function " + function_name);
		}

		return writer.script;
	}

	if (eca.name == "WaitForCondition") {
		MapScriptWriter writer(mode);
		writer.while_statement(std::format("not ({})", resolved_parameters[0]), [&] {
			writer.call("TriggerSleepAction", std::format("RMaxBJ(bj_WAIT_FOR_COND_MIN_INTERVAL, {})", resolved_parameters[1]));
		});

		return writer.script;
	}

	if (eca.name.starts_with("OperatorCompare") || eca.name == "OperatorInt" || eca.name == "OperatorReal") {
		auto result_operator = resolved_parameters[1];
		if (result_operator == "!=" && mode == ScriptMode::lua) {
			result_operator = "~=";
		}

		return std::format("{} {} {}", resolved_parameters[0], result_operator, resolved_parameters[2]);
	}

	if (eca.name == "OperatorString") {
		if (mode == ScriptMode::jass) {
			return std::format("({} + {})", resolved_parameters[0], resolved_parameters[1]);
		} else {
			return std::format("({} .. {})", resolved_parameters[0], resolved_parameters[1]);
		}
	}

	if (eca.name == "AddTriggerEvent") {
		return (add_call && mode == ScriptMode::jass ? "call " : "")
			+ resolved_parameters[1].insert(resolved_parameters[1].find_first_of('(') + 1, resolved_parameters[0] + ", ");
	}

	std::string output;
	for (size_t k = 0; k < eca.parameters.size(); k++) {
		const std::string type = get_type(eca.name, k);
		if (type == "boolexpr") {
			const std::string function_name = generate_function_name(trigger_name);

			pre_actions.function(
				function_name,
				[&] {
					pre_actions.write_ln("return ", resolved_parameters[k]);
				},
				"takes nothing returns boolean"
			);
			if (mode == ScriptMode::jass) {
				output += "Condition(function " + function_name + ")";
			} else {
				output += function_name;
			}
		} else if (type == "boolcall") {
			const std::string function_name = generate_function_name(trigger_name);

			pre_actions.function(
				function_name,
				[&] {
					pre_actions.write_ln("return ", resolved_parameters[k]);
				},
				"takes nothing returns boolean"
			);
			output += function_name + "()";
		} else if (type == "code") {
			const std::string function_name = generate_function_name(trigger_name);

			const auto code = resolve_parameter(eca.parameters[k], trigger_name, pre_actions, get_type(eca.name, k), mode, true);
			pre_actions.function(function_name, [&] {
				pre_actions.write_ln(code);
			});
			if (mode == ScriptMode::jass) {
				output += "function " + function_name;
			} else {
				output += function_name;
			}
		} else {
			output += resolved_parameters[k];
		}

		if (k < eca.parameters.size() - 1) {
			output += ", ";
		}
	}

	const std::string script_name = trigger_data.data("TriggerActions", "_" + eca.name + "_ScriptName");
	return (add_call && mode == ScriptMode::jass ? "call " : "") + (script_name.empty() ? eca.name : script_name) + "(" + output + ")";
}

std::string Triggers::convert_gui_to_jass(const Trigger& trigger, std::vector<std::string>& map_initializations, ScriptMode mode) const {
	std::string trigger_name = trigger.name;
	trim(trigger_name);
	std::ranges::replace(trigger_name, ' ', '_');

	const std::string trigger_variable_name = "gg_trg_" + trigger_name;
	const std::string trigger_action_name = "Trig_" + trigger_name + "_Actions";
	const std::string trigger_conditions_name = "Trig_" + trigger_name + "_Conditions";

	MapScriptWriter events(mode);
	MapScriptWriter conditions(mode);

	MapScriptWriter actions(mode);
	MapScriptWriter pre_actions(mode);

	for (const auto& i : trigger.ecas) {
		if (!i.enabled) {
			continue;
		}

		switch (i.type) {
			case ECA::Type::event: {
				if (i.name == "MapInitializationEvent") {
					map_initializations.push_back(trigger_variable_name);
					continue;
				}

				std::string arguments;

				for (size_t k = 0; k < i.parameters.size(); k++) {
					const auto& p = i.parameters[k];

					if (get_type(i.name, k) == "VarAsString_Real") {
						arguments += "\"" + resolve_parameter(p, trigger_name, pre_actions, get_type(i.name, k), mode) + "\"";
					} else {
						arguments += resolve_parameter(p, trigger_name, pre_actions, get_type(i.name, k), mode);
					}

					if (k < i.parameters.size() - 1) {
						arguments += ", ";
					}
				}

				events.call(i.name, trigger_variable_name, arguments);

				break;
			}
			case ECA::Type::condition:
				conditions.if_statement(std::format("not ({})", convert_eca_to_script(i, pre_actions, trigger_name, mode, false)), [&] {
					conditions.write_ln("return false");
				});
				break;
			case ECA::Type::action:
				actions.write_ln(convert_eca_to_script(i, pre_actions, trigger_name, mode, true));
				break;
		}
	}

	MapScriptWriter final_trigger(mode);

	final_trigger.merge(pre_actions);

	if (!conditions.is_empty()) {
		final_trigger.function(
			trigger_conditions_name,
			[&] {
				final_trigger.merge(conditions);
				final_trigger.write_ln("return true");
			},
			"takes nothing returns boolean"
		);
	}

	final_trigger.function(trigger_action_name, [&] {
		final_trigger.merge(actions);
	});

	final_trigger.function("InitTrig_" + trigger_name, [&] {
		final_trigger.set_variable(trigger_variable_name, "CreateTrigger()");
		final_trigger.merge(events);

		if (!conditions.is_empty()) {
			if (mode == ScriptMode::jass) {
				final_trigger.call("TriggerAddCondition", trigger_variable_name, "Condition( function " + trigger_conditions_name + ")");
			} else {
				final_trigger.call("TriggerAddCondition", trigger_variable_name, "Condition(" + trigger_conditions_name + ")");
			}
		}
		if (!trigger.initially_on) {
			final_trigger.call("DisableTrigger", trigger_variable_name);
		}

		if (mode == ScriptMode::jass) {
			final_trigger.call("TriggerAddAction", trigger_variable_name, "function " + trigger_action_name);
		} else {
			final_trigger.call("TriggerAddAction", trigger_variable_name, trigger_action_name);
		}
	});

	return final_trigger.script;
}
```

`src/base/triggers/map_script.cpp`:

```cpp
module;

#include <QDir>
#include <QProcess>

module Triggers;

import std;
import INI;
namespace fs = std::filesystem;

void generate_global_variables(
	MapScriptWriter& script,
	std::unordered_map<std::string, std::string>& unit_variables,
	std::unordered_map<std::string, std::string>& destructable_variables,
	const std::vector<Trigger>& triggers,
	const std::vector<TriggerVariable>& variables,
	const ini::INI& trigger_data,
	const Regions& regions,
	const GameCameras& cameras,
	const Sounds& sounds
) {
	if (script.mode == ScriptMode::jass) {
		script.write_ln("globals");
	}

	if (script.mode == ScriptMode::jass) {
		for (const auto& variable : variables) {
			const std::string base_type = trigger_data.data("TriggerTypes", variable.type, 4);
			const std::string type = base_type.empty() ? variable.type : base_type;
			if (variable.is_array) {
				script.write_ln(std::format("{} array udg_{}", type, variable.name));
			} else {
				std::string default_value = trigger_data.data("TriggerTypeDefaults", type);

				if (default_value.empty()) { // handle?
					default_value = "null";
				}

				script.global(type, "udg_" + variable.name, default_value);
			}
		}
	} else {
		for (const auto& variable : variables) {
			if (variable.is_array) {
				script.global(variable.type, "udg_" + variable.name, "__jarray(\"\")");
			} else {
				script.global(variable.type, "udg_" + variable.name, script.null());
			}
		}
	}

	for (const auto& i : regions.regions) {
		std::string region_name = i.name;
		trim(region_name);
		std::replace(region_name.begin(), region_name.end(), ' ', '_');
		script.global("rect", "gg_rct_" + region_name, script.null());
	}

	for (const auto& i : cameras.cameras) {
		std::string camera_name = i.name;
		trim(camera_name);
		std::replace(camera_name.begin(), camera_name.end(), ' ', '_');
		script.global("camerasetup", "gg_cam_" + camera_name, script.null());
	}

	for (const auto& i : sounds.sounds) {
		std::string sound_name = i.name;
		trim(sound_name);
		std::replace(sound_name.begin(), sound_name.end(), ' ', '_');

		if (i.music) {
			// Music files are stored as just a file path string
			script.global("string", sound_name, "\"\"");
		} else {
			script.global("sound", sound_name, script.null());
		}
	}

	for (const auto& i : triggers) {
		if (i.is_comment || !i.is_enabled) {
			continue;
		}

		std::string trigger_name = i.name;
		trim(trigger_name);
		std::ranges::replace(trigger_name, ' ', '_');
		script.global("trigger", "gg_trg_" + trigger_name, script.null());
	}

	for (const auto& [creation_number, type] : unit_variables) {
		script.global("unit", "gg_unit_" + type + "_" + creation_number, script.null());
	}

	for (const auto& [creation_number, type] : destructable_variables) {
		script.global("destructable", "gg_dest_" + type + "_" + creation_number, script.null());
	}

	if (script.mode == ScriptMode::jass) {
		script.write_ln("endglobals");
	}
}

void generate_init_global_variables(MapScriptWriter& script, const std::vector<TriggerVariable>& variables, const ini::INI& trigger_data) {
	script.function("InitGlobals", [&]() {
		script.local("integer", "i", "0");

		for (const auto& variable : variables) {
			const std::string base_type = trigger_data.data("TriggerTypes", variable.type, 4);
			const std::string type = base_type.empty() ? variable.type : base_type;
			const std::string default_value = trigger_data.data("TriggerTypeDefaults", type);

			if (!variable.is_initialized && default_value.empty()) {
				continue;
			}

			std::string value;
			if (variable.is_initialized) {
				const std::string converted_value = trigger_data.data("TriggerParams", variable.initial_value, 2);

				if (converted_value.empty()) {
					if (type == "string") {
						value = "\"" + variable.initial_value + "\"";
					} else {
						value = variable.initial_value;
					}
				} else {
					value = converted_value;
				}
			} else {
				if (type == "string") {
					value = "\"\"";
				} else {
					value = default_value;
				}
			}

			if (variable.is_array) {
				script.forloop(0, variable.array_size, "i", [&] {
					script.set_variable("udg_" + variable.name + "[i]", value);
				});
			} else {
				script.set_variable("udg_" + variable.name, value);
			}
		}
	});
}

void generate_units(
	MapScriptWriter& script,
	const std::unordered_map<std::string, std::string>& unit_variables,
	const Terrain& terrain,
	const Units& units
) {
	script.function("CreateAllUnits", [&]() {
		script.local("unit", "u", script.null());
		script.local("integer", "unitID", "0");
		script.local("trigger", "t", script.null());
		script.local("real", "life", "0");

		for (const auto& i : units.units) {
			if (i.id == "sloc") {
				continue;
			}

			std::string unit_reference = "u";
			if (unit_variables.contains(std::format("{:0>4}", i.creation_number))) {
				unit_reference = std::format("gg_unit_{}_{:0>4}", i.id, i.creation_number);
			}

			script.set_variable(
				unit_reference,
				std::format(
					"BlzCreateUnitWithSkin(Player({}), {}, {:.4f}, {:.4f}, {:.4f}, {})",
					i.player,
					script.four_cc(i.id),
					i.position.x * 128.f + terrain.offset.x,
					i.position.y * 128.f + terrain.offset.y,
					glm::degrees(i.angle),
					script.four_cc(i.skin_id)
				)
			);

			if (i.health != -1) {
				script.set_variable("life", std::format("GetUnitState({}, {})", unit_reference, "UNIT_STATE_LIFE"));
				script.call("SetUnitState", unit_reference, "UNIT_STATE_LIFE", std::to_string(i.health / 100.f) + " * life");
			}

			if (i.mana != -1) {
				script.call("SetUnitState", unit_reference, "UNIT_STATE_MANA", i.mana);
			}
			if (i.level != 1) {
				script.call("SetHeroLevel", unit_reference, i.level, "false");
			}

			if (i.strength != 0) {
				script.call("SetHeroStr", unit_reference, i.strength, "true");
			}

			if (i.agility != 0) {
				script.call("SetHeroAgi", unit_reference, i.agility, "true");
			}

			if (i.intelligence != 0) {
				script.call("SetHeroInt", unit_reference, i.intelligence, "true");
			}

			float range;
			if (i.target_acquisition != -1.f) {
				if (i.target_acquisition == -2.f) {
					range = 200.f;
				} else {
					range = i.target_acquisition;
				}
				script.call("SetUnitAcquireRange", unit_reference, range);
			}

			for (const auto& j : i.abilities) {
				for (size_t k = 0; k < std::get<2>(j); k++) {
					script.call("SelectHeroSkill", unit_reference, script.four_cc(std::get<0>(j)));
				}

				if (std::get<1>(j)) {
					std::string_view order_on = abilities_slk.data<std::string_view>("orderon", std::get<0>(j));
					if (order_on.empty()) {
						order_on = abilities_slk.data<std::string_view>("order", std::get<0>(j));
					}
					script.call("IssueImmediateOrder", unit_reference, "\"" + order_on + "\"");

				} else {
					std::string_view order_off = abilities_slk.data<std::string_view>("orderoff", std::get<0>(j));
					if (!order_off.empty()) {
						script.call("IssueImmediateOrder", unit_reference, "\"" + order_off + "\"");
					}
				}
			}

			for (const auto& j : i.items) {
				script.call("UnitAddItemToSlotById", unit_reference, script.four_cc(j.second), j.first);
			}

			if (i.item_sets.size()) {
				script.set_variable("t", "CreateTrigger()");
				script.call("TriggerRegisterUnitEvent", "t", unit_reference, "EVENT_UNIT_DEATH");
				script.call("TriggerRegisterUnitEvent", "t", unit_reference, "EVENT_UNIT_CHANGE_OWNER");

				if (script.mode == ScriptMode::jass) {
					script.call("TriggerAddAction", "t", "function UnitItemDrops_" + std::to_string(i.creation_number));
				} else {
					script.call("TriggerAddAction", "t", "UnitItemDrops_" + std::to_string(i.creation_number));
				}
			}
		}
	});
}

void generate_items(MapScriptWriter& script, const Terrain& terrain, const Units& units) {
	script.function("CreateAllItems", [&]() {
		for (const auto& i : units.items) {
			script.call(
				"BlzCreateItemWithSkin",
				script.four_cc(i.id),
				i.position.x * 128.f + terrain.offset.x,
				i.position.y * 128.f + terrain.offset.y,
				script.four_cc(i.id)
			);
		}
	});
}

void generate_destructables(
	MapScriptWriter& script,
	const std::unordered_map<std::string, std::string>& destructable_variables,
	const Terrain& terrain,
	const Doodads& doodads
) {
	script.function("CreateAllDestructables", [&]() {
		script.local("destructable", "d", script.null());
		script.local("trigger", "t", script.null());
		script.local("real", "life", "0");

		for (const auto& i : doodads.doodads) {
			std::string id = "d";

			if (destructable_variables.contains(std::to_string(i.creation_number))) {
				id = "gg_dest_" + i.id + "_" + std::to_string(i.creation_number);
			}

			if (id == "d" && i.item_sets.empty() && i.item_table_pointer == -1) {
				continue;
			}

			script.set_variable(
				id,
				std::format(
					"BlzCreateDestructableZWithSkin({}, {:.4f}, {:.4f}, {:.4f}, {}, {}, {}, {})",
					script.four_cc(i.id),
					i.position.x * 128.f + terrain.offset.x,
					i.position.y * 128.f + terrain.offset.y,
					i.position.z * 128.f,
					glm::degrees(i.angle),
					i.scale.x,
					i.variation,
					script.four_cc(i.skin_id)
				)
			);

			if (i.life != 100) {
				script.set_variable("life", "GetDestructableLife(" + id + ")");
				script.call("SetDestructableLife", id, std::to_string(i.life / 100.f) + " * life");
			}

			if (!i.item_sets.empty()) {
				script.set_variable("t", "CreateTrigger()");
				script.call("TriggerRegisterDeathEvent", "t", id);
				if (script.mode == ScriptMode::jass) {
					script.call("TriggerAddAction", "t", "function SaveDyingWidget");
				} else {
					script.call("TriggerAddAction", "t", "SaveDyingWidget");
				}
				if (script.mode == ScriptMode::jass) {
					script.call("TriggerAddAction", "t", "function DoodadItemDrops_" + std::to_string(i.creation_number));
				} else {
					script.call("TriggerAddAction", "t", "DoodadItemDrops_" + std::to_string(i.creation_number));
				}
			} else if (i.item_table_pointer != -1) {
				script.set_variable("t", "CreateTrigger()");
				script.call("TriggerRegisterDeathEvent", "t", id);
				if (script.mode == ScriptMode::jass) {
					script.call("TriggerAddAction", "t", "function SaveDyingWidget");
					script.call("TriggerAddAction", "t", "function ItemTable_" + std::to_string(i.item_table_pointer));
				} else {
					script.call("TriggerAddAction", "t", "SaveDyingWidget");
					script.call("TriggerAddAction", "t", "ItemTable_" + std::to_string(i.item_table_pointer));
				}
			}
		}
	});
}

void generate_regions(MapScriptWriter& script, const Regions& regions) {
	script.function("CreateRegions", [&]() {
		script.local("weathereffect", "we", script.null());
		for (const auto& i : regions.regions) {
			std::string region_name = "gg_rct_" + i.name;
			trim(region_name);
			std::ranges::replace(region_name, ' ', '_');

			script.set_variable(
				region_name,
				std::format(
					"Rect({}, {}, {}, {})",
					std::min(i.left, i.right),
					std::min(i.bottom, i.top),
					std::max(i.left, i.right),
					std::max(i.bottom, i.top)
				)
			);

			if (!i.weather_id.empty()) {
				script.set_variable("we", std::format("AddWeatherEffect({}, {})", region_name, script.four_cc(i.weather_id)));
				script.call("EnableWeatherEffect", "we", true);
			}
		}
	});
}

void generate_cameras(MapScriptWriter& script, const GameCameras& cameras) {
	script.function("CreateCameras", [&]() {
		for (const auto& i : cameras.cameras) {
			std::string camera_name = "gg_cam_" + i.name;
			trim(camera_name);
			std::ranges::replace(camera_name, ' ', '_');

			script.set_variable(camera_name, "CreateCameraSetup()");
			script.call("CameraSetupSetField", camera_name, "CAMERA_FIELD_ZOFFSET", i.z_offset, 0.0);
			script.call("CameraSetupSetField", camera_name, "CAMERA_FIELD_ROTATION", i.rotation, 0.0);
			script.call("CameraSetupSetField", camera_name, "CAMERA_FIELD_ANGLE_OF_ATTACK", i.angle_of_attack, 0.0);
			script.call("CameraSetupSetField", camera_name, "CAMERA_FIELD_TARGET_DISTANCE", i.distance, 0.0);
			script.call("CameraSetupSetField", camera_name, "CAMERA_FIELD_ROLL", i.roll, 0.0);
			script.call("CameraSetupSetField", camera_name, "CAMERA_FIELD_FIELD_OF_VIEW", i.fov, 0.0);
			script.call("CameraSetupSetField", camera_name, "CAMERA_FIELD_FARZ", i.far_z, 0.0);
			script.call("CameraSetupSetField", camera_name, "CAMERA_FIELD_NEARZ", i.near_z, 0.0);
			script.call("CameraSetupSetField", camera_name, "CAMERA_FIELD_LOCAL_PITCH", i.local_pitch, 0.0);
			script.call("CameraSetupSetField", camera_name, "CAMERA_FIELD_LOCAL_YAW", i.local_yaw, 0.0);
			script.call("CameraSetupSetField", camera_name, "CAMERA_FIELD_LOCAL_ROLL", i.local_roll, 0.0);
			script.call("CameraSetupSetDestPosition", camera_name, i.target_x, i.target_y, 0.0);
		}
	});
}

// Todo, missing fields, soundduration also wrong
void generate_sounds(MapScriptWriter& script, const Sounds& sounds) {
	script.function("InitSounds", [&]() {
		for (const auto& i : sounds.sounds) {
			std::string sound_name = i.name;
			trim(sound_name);
			std::ranges::replace(sound_name, ' ', '_');

			if (i.music) {
				// I suppose music files can't be muted?
				script.set_variable(sound_name, "\"" + string_replaced(i.file, "\\", "\\\\") + "\"");
			} else {
				script.set_variable(
					sound_name,
					std::format(
						"CreateSound(\"{}\", {}, {}, {}, {}, {}, \"{}\")",
						string_replaced(i.file, "\\", "\\\\"),
						i.looping ? "true" : "false",
						i.is_3d ? "true" : "false",
						i.stop_out_of_range ? "true" : "false",
						i.fade_in_rate,
						i.fade_out_rate,
						string_replaced(i.eax_effect, "\\", "\\\\")
					)
				);

				// TODO how to determine duration. Load the file?
				script.call("SetSoundDuration", sound_name, i.fade_in_rate);
				script.call("SetSoundChannel", sound_name, i.channel);
				script.call("SetSoundVolume", sound_name, i.volume);
				script.call("SetSoundPitch", sound_name, i.pitch);
			}
		}
	});
}

void generate_trigger_initialization(
	MapScriptWriter& script,
	const std::vector<std::string>& initialization_triggers,
	const std::vector<Trigger>& triggers
) {
	script.function("InitCustomTriggers", [&]() {
		for (const auto& i : triggers) {
			if (i.is_comment || !i.is_enabled) {
				continue;
			}
			std::string trigger_name = i.name;
			trim(trigger_name);
			std::replace(trigger_name.begin(), trigger_name.end(), ' ', '_');

			script.call("InitTrig_" + trigger_name);
		}
	});

	script.function("RunInitializationTriggers", [&]() {
		for (const auto& i : initialization_triggers) {
			script.call("ConditionalTriggerExecute", i);
		}
	});
}

void generate_players(MapScriptWriter& script, const MapInfo& map_info) {
	script.function("InitCustomPlayerSlots", [&]() {
		const std::vector<std::string> players =
			{"MAP_CONTROL_USER", "MAP_CONTROL_COMPUTER", "MAP_CONTROL_NEUTRAL", "MAP_CONTROL_RESCUABLE"};
		const std::vector<std::string> races =
			{"RACE_PREF_RANDOM", "RACE_PREF_HUMAN", "RACE_PREF_ORC", "RACE_PREF_UNDEAD", "RACE_PREF_NIGHTELF"};

		size_t index = 0;
		for (const auto& i : map_info.players) {
			std::string player = "Player(" + std::to_string(i.internal_number) + ")";

			script.call("SetPlayerStartLocation", player, index);
			if (i.fixed_start_position || i.race == PlayerRace::selectable) {
				script.call("ForcePlayerStartLocation", player, index);
			}

			script.call("SetPlayerColor", player, "ConvertPlayerColor(" + std::to_string(i.internal_number) + ")");
			script.call("SetPlayerRacePreference", player, races[static_cast<int>(i.race)]);
			script.call("SetPlayerRaceSelectable", player, true);
			script.call("SetPlayerController", player, players[static_cast<int>(i.type)]);

			if (i.type == PlayerType::rescuable) {
				for (const auto& j : map_info.players) {
					if (j.type == PlayerType::human) {
						script.call(
							"SetPlayerAlliance",
							player,
							"Player(" + std::to_string(j.internal_number) + ")",
							"ALLIANCE_RESCUABLE",
							true
						);
					}
				}
			}

			script.write("\n");
			index++;
		}
	});
}

static void write_item_table_entry(MapScriptWriter& script, int chance, const std::string& id) {
	if (id.empty()) {
		script.call("RandomDistAddItem", -1, chance);
	} else if (id[0] == 'Y' && id[2] == 'I' && ((id[1] >= 'i' && id[1] <= 'o') || id[1] == 'Y')) { // Random items

		std::string item_type;
		switch (id[1]) {
			case 'i':
				item_type = "PERMANENT";
				break;
			case 'j':
				item_type = "CHARGED";
				break;
			case 'k':
				item_type = "POWERUP";
				break;
			case 'l':
				item_type = "ARTIFACT";
				break;
			case 'm':
				item_type = "PURCHASABLE";
				break;
			case 'n':
				item_type = "CAMPAIGN";
				break;
			case 'o':
				item_type = "MISCELLANEOUS";
				break;
			case 'Y':
				item_type = "ANY";
				break;
			default:
				std::println("Error: unknown random item type {}", id[1]);
		}

		const std::string random_item =
			std::format("ChooseRandomItemEx(ITEM_TYPE_{}, {})", item_type, (id[3] == '/') ? "-1" : std::string(1, id[3]));
		script.call("RandomDistAddItem", random_item, chance);
	} else {
		script.call("RandomDistAddItem", script.four_cc(id), chance);
	}
}

template<typename T>
void generate_item_tables(MapScriptWriter& script, const std::string& table_name_prefix, const std::vector<T>& table_holders) {
	for (const auto& i : table_holders) {
		if (i.item_sets.empty()) {
			continue;
		}

		script.function(table_name_prefix + std::to_string(i.creation_number), [&]() {
			script.local("widget", "trigWidget", script.null());
			script.local("unit", "trigUnit", script.null());
			script.local("integer", "itemID", "0");
			script.local("boolean", "canDrop", "true");

			script.set_variable("trigWidget", "bj_lastDyingWidget");

			script.if_statement("trigWidget == " + script.null(), [&] {
				script.set_variable("trigUnit", "GetTriggerUnit()");
			});

			script.if_statement("not(trigUnit == " + script.null() + ")", [&]() {
				script.set_variable("canDrop", "not IsUnitHidden(trigUnit)");
				script.if_statement("canDrop and not(GetChangingUnit() == " + script.null() + ")", [&]() {
					script.set_variable("canDrop", "(GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))");
				});
			});

			script.if_statement("canDrop", [&]() {
				for (const auto& j : i.item_sets) {
					script.call("RandomDistReset");
					for (const auto& [chance, id] : j.items) {
						write_item_table_entry(script, chance, id);
					}
					script.set_variable("itemID", "RandomDistChoose()");
					script.if_statement("not(trigUnit == " + script.null() + ")", [&]() {
						script.call("UnitDropItem", "trigUnit", "itemID"); // Todo fourcc?
					});
					script.if_statement("trigUnit == " + script.null(), [&]() {
						script.call("WidgetDropItem", "trigWidget", "itemID"); // Todo fourcc?
					});
				}
			});

			script.set_variable("bj_lastDyingWidget", script.null());
			script.call("DestroyTrigger", "GetTriggeringTrigger()");
		});
	}
}

void generate_custom_teams(MapScriptWriter& script, const MapInfo& map_info) {
	script.function("InitCustomTeams", [&]() {
		int current_force = 0;
		for (const auto& i : map_info.forces) {
			for (const auto& j : map_info.players) {
				if (i.player_masks & (1 << j.internal_number)) {
					script.call("SetPlayerTeam", "Player(" + std::to_string(j.internal_number) + ")", current_force);

					if (i.allied_victory) {
						script
							.call("SetPlayerState", "Player(" + std::to_string(j.internal_number) + ")", "PLAYER_STATE_ALLIED_VICTORY", 1);
					}
				}
			}

			for (const auto& j : map_info.players) {
				if (i.player_masks & (1 << j.internal_number)) {
					for (const auto& k : map_info.players) {
						if (i.player_masks & (1 << k.internal_number) && j.internal_number != k.internal_number) {
							if (i.allied) {
								script.call(
									"SetPlayerAllianceStateAllyBJ",
									"Player(" + std::to_string(j.internal_number) + ")",
									"Player(" + std::to_string(k.internal_number) + ")",
									true
								);
							}
							if (i.share_vision) {
								script.call(
									"SetPlayerAllianceStateVisionBJ",
									"Player(" + std::to_string(j.internal_number) + ")",
									"Player(" + std::to_string(k.internal_number) + ")",
									true
								);
							}
							if (i.share_unit_control) {
								script.call(
									"SetPlayerAllianceStateControlBJ",
									"Player(" + std::to_string(j.internal_number) + ")",
									"Player(" + std::to_string(k.internal_number) + ")",
									true
								);
							}
							if (i.share_advanced_unit_control) {
								script.call(
									"SetPlayerAllianceStateFullControlBJ",
									"Player(" + std::to_string(j.internal_number) + ")",
									"Player(" + std::to_string(k.internal_number) + ")",
									true
								);
							}
						}
					}
				}
			}
			current_force++;
		}
	});
}

void generate_ally_priorities(MapScriptWriter& script, const MapInfo& map_info) {
	script.function("InitAllyPriorities", [&]() {
		std::unordered_map<int, int> player_to_startloc;

		int current_player = 0;
		for (const auto& i : map_info.players) {
			player_to_startloc[i.internal_number] = current_player;
			current_player++;
		}

		current_player = 0;
		for (const auto& i : map_info.players) {
			size_t count = 0;
			for (const auto& j : map_info.players) {
				if (i.ally_low_priorities_flags & (1 << j.internal_number) && i.internal_number != j.internal_number) {
					count++;
				} else if (i.ally_high_priorities_flags & (1 << j.internal_number) && i.internal_number != j.internal_number) {
					count++;
				}
			}

			script.call("SetStartLocPrioCount", current_player, count);

			size_t current_index = 0;
			for (const auto& j : map_info.players) {
				if (i.ally_low_priorities_flags & (1 << j.internal_number) && i.internal_number != j.internal_number) {
					script
						.call("SetStartLocPrio", current_player, current_index, player_to_startloc[j.internal_number], "MAP_LOC_PRIO_LOW");
					current_index++;
				} else if (i.ally_high_priorities_flags & (1 << j.internal_number) && i.internal_number != j.internal_number) {
					script
						.call("SetStartLocPrio", current_player, current_index, player_to_startloc[j.internal_number], "MAP_LOC_PRIO_HIGH");
					current_index++;
				}
			}

			current_player++;
		}
	});
}

void generate_main(MapScriptWriter& script, const Terrain& terrain, const MapInfo& map_info) {
	script.function("main", [&]() {
		script.call(
			"SetCameraBounds",
			std::to_string(map_info.camera_left_bottom.x - 512.f) + " + GetCameraMargin(CAMERA_MARGIN_LEFT)",
			std::to_string(map_info.camera_left_bottom.y - 256.f) + " + GetCameraMargin(CAMERA_MARGIN_BOTTOM)",

			std::to_string(map_info.camera_right_top.x + 512.f) + " - GetCameraMargin(CAMERA_MARGIN_RIGHT)",
			std::to_string(map_info.camera_right_top.y + 256.f) + " - GetCameraMargin(CAMERA_MARGIN_TOP)",

			std::to_string(map_info.camera_left_top.x - 512.f) + " + GetCameraMargin(CAMERA_MARGIN_LEFT)",
			std::to_string(map_info.camera_left_top.y + 256.f) + " - GetCameraMargin(CAMERA_MARGIN_TOP)",

			std::to_string(map_info.camera_right_bottom.x + 512.f) + " - GetCameraMargin(CAMERA_MARGIN_RIGHT)",
			std::to_string(map_info.camera_right_bottom.y - 256.f) + " + GetCameraMargin(CAMERA_MARGIN_BOTTOM)"
		);

		const std::string terrain_lights = string_replaced(world_edit_data.data("TerrainLights", ""s + terrain.tileset), "\\", "/");
		const std::string unit_lights = string_replaced(world_edit_data.data("TerrainLights", ""s + terrain.tileset), "\\", "/");
		script.call("SetDayNightModels", "\"" + terrain_lights + "\"", "\"" + unit_lights + "\"");

		const std::string sound_environment = string_replaced(world_edit_data.data("SoundEnvironment", ""s + terrain.tileset), "\\", "/");
		script.call("NewSoundEnvironment", "\"" + sound_environment + "\"");

		const std::string ambient_day = string_replaced(world_edit_data.data("DayAmbience", ""s + terrain.tileset), "\\", "/");
		script.call("SetAmbientDaySound", "\"" + ambient_day + "\"");

		const std::string ambient_night = string_replaced(world_edit_data.data("NightAmbience", ""s + terrain.tileset), "\\", "/");
		script.call("SetAmbientNightSound", "\"" + ambient_night + "\"");

		script.call("SetMapMusic", "\"Music\"", true, 0);
		script.call("InitSounds");
		script.call("CreateRegions");
		script.call("CreateCameras");
		script.call("CreateAllDestructables");
		script.call("CreateAllItems");
		script.call("CreateAllUnits");
		script.call("InitBlizzard");
		script.call("InitGlobals");
		script.call("InitCustomTriggers");
		script.call("RunInitializationTriggers");
	});
}

void generate_map_configuration(MapScriptWriter& script, const Terrain& terrain, const Units& units, const MapInfo& map_info) {
	script.function("config", [&]() {
		script.call("SetMapName", "\"" + map_info.name + "\"");
		script.call("SetMapDescription", "\"" + map_info.description + "\"");
		script.call("SetPlayers", map_info.players.size());
		script.call("SetTeams", map_info.forces.size());
		script.call("SetGamePlacement", "MAP_PLACEMENT_USE_MAP_SETTINGS");

		script.write("\n");

		for (const auto& i : units.units) {
			if (i.id == "sloc") {
				script.call(
					"DefineStartLocation",
					i.player,
					i.position.x * 128.f + terrain.offset.x,
					i.position.y * 128.f + terrain.offset.y
				);
			}
		}

		script.write("\n");

		script.call("InitCustomPlayerSlots");
		if (map_info.custom_forces) {
			script.call("InitCustomTeams");
		} else {
			for (const auto& i : map_info.players) {
				script.call("SetPlayerSlotAvailable", "Player(" + std::to_string(i.internal_number) + ")", "MAP_CONTROL_USER");
			}

			script.call("InitGenericPlayerSlots");
		}
		script.call("InitAllyPriorities");
	});
}

/// Returns compile output which could contain errors or general information
std::expected<void, std::string> Triggers::generate_map_script(
	const Terrain& terrain,
	const Units& units,
	const Doodads& doodads,
	const MapInfo& map_info,
	const Sounds& sounds,
	const Regions& regions,
	const GameCameras& cameras,
	ScriptMode mode
) {
	std::unordered_map<std::string, std::string> unit_variables; // creation_number, unit_id
	std::unordered_map<std::string, std::string> destructable_variables; // creation_number, destructable_id
	std::vector<std::string> initialization_triggers;

	std::string trigger_script;
	for (const auto& i : triggers) {
		if (i.is_comment || !i.is_enabled) {
			continue;
		}
		if (!i.custom_text.empty()) {
			trigger_script += i.custom_text + "\n";
		} else {
			trigger_script += convert_gui_to_jass(i, initialization_triggers, mode);
		}
	}

	// Search the trigger script for global unit/destructible definitions
	size_t pos = trigger_script.find("gg_unit", 0);
	while (pos != std::string::npos) {
		std::string type = trigger_script.substr(pos + 8, 4);
		std::string creation_number = trigger_script.substr(pos + 13, 4);
		unit_variables[creation_number] = type;
		pos = trigger_script.find("gg_unit", pos + 17);
	}

	pos = trigger_script.find("gg_dest", 0);
	while (pos != std::string::npos) {
		std::string type = trigger_script.substr(pos + 8, 4);
		std::string creation_number = trigger_script.substr(pos + 13, trigger_script.find_first_not_of("0123456789", pos + 13) - pos - 13);
		destructable_variables[creation_number] = type;
		pos = trigger_script.find("gg_dest", pos + 17);
	}

	MapScriptWriter script_writer(mode);

	generate_global_variables(
		script_writer,
		unit_variables,
		destructable_variables,
		triggers,
		variables,
		trigger_data,
		regions,
		cameras,
		sounds
	);
	generate_init_global_variables(script_writer, variables, trigger_data);
	generate_item_tables(script_writer, "ItemTable_", map_info.random_item_tables);
	generate_item_tables(script_writer, "UnitItemDrops_", units.units);
	generate_item_tables(script_writer, "DoodadItemDrops_", doodads.doodads);
	generate_sounds(script_writer, sounds);

	generate_destructables(script_writer, destructable_variables, terrain, doodads);
	generate_items(script_writer, terrain, units);
	generate_units(script_writer, unit_variables, terrain, units);
	generate_regions(script_writer, regions);
	generate_cameras(script_writer, cameras);

	script_writer.write_ln(global_jass);

	script_writer.write(trigger_script);

	generate_trigger_initialization(script_writer, initialization_triggers, triggers);
	generate_players(script_writer, map_info);
	generate_custom_teams(script_writer, map_info);
	generate_ally_priorities(script_writer, map_info);
	generate_main(script_writer, terrain, map_info);
	generate_map_configuration(script_writer, terrain, units, map_info);

	fs::path path = QDir::tempPath().toStdString() + "/input.lua";
	std::ofstream output(path, std::ios::binary);
	output.write((char*)script_writer.script.data(), script_writer.script.size());
	output.close();

	if (mode == ScriptMode::jass) {
		QProcess* proc = new QProcess();
		proc->setWorkingDirectory("data/tools");
		proc->start(
			"data/tools/clijasshelper.exe",
			{"--scriptonly", "common.j", "blizzard.j", QString::fromStdString(path.string()), "war3map.j"}
		);
		proc->waitForFinished();
		const QString result = proc->readAllStandardOutput();

		if (result.contains("Compile error")) {
			return std::unexpected(result.mid(result.indexOf("Compile error")).toStdString());
		} else if (result.contains("compile errors")) {
			return std::unexpected(result.mid(result.indexOf("compile errors.")).toStdString());
		} else {
			hierarchy.map_file_add("data/tools/war3map.j", "war3map.j");
		}
	} else {
		hierarchy.map_file_add(path, "war3map.lua");
	}

	return {};
}
```

`src/base/triggers/triggers.ixx`:

```ixx
export module Triggers;

import std;
import Hierarchy;
import Utilities;
import Globals;
import <glm/glm.hpp>;
import Units;
import Doodads;
import Regions;
import GameCameras;
import Sounds;
import Terrain;
import MapInfo;
import BinaryReader;
import BinaryWriter;
import INI;

namespace fs = std::filesystem;
using namespace std::literals::string_literals;

export enum class ScriptMode {
	lua,
	jass
};

/// A minimal utility wrapper around a std::string that manages newlines, indentation and closing braces
struct MapScriptWriter {
	std::string script;
	size_t current_indentation = 0;

	ScriptMode mode;

	explicit MapScriptWriter(ScriptMode mode = ScriptMode::lua) : mode(mode) {}

	bool is_empty() {
		return script.empty();
	}

	void merge(const MapScriptWriter& writer) {
		script += writer.script;
	}

	void raw_write_to_log(const std::string_view users_fmt, std::format_args&& args) {
		std::vformat_to(std::back_inserter(script), users_fmt, args);
	}

	constexpr void local(std::string_view type, std::string_view name, std::string_view value) {
		for (size_t i = 0; i < current_indentation; i++) {
			script += '\t';
		}

		if (mode == ScriptMode::lua) {
			std::format_to(std::back_inserter(script), "local {} = {}\n", name, value);
		} else {
			std::format_to(std::back_inserter(script), "local {} {} = {}\n", type, name, value);
		}
	}

	constexpr void global(std::string_view type, std::string_view name, std::string_view value) {
		for (size_t i = 0; i < current_indentation; i++) {
			script += '\t';
		}

		if (mode == ScriptMode::lua) {
			std::format_to(std::back_inserter(script), "{} = {}\n", name, value);
		} else {
			std::format_to(std::back_inserter(script), "{} {} = {}\n", type, name, value);
		}
	}

	constexpr void set_variable(std::string_view name, std::string_view value) {
		for (size_t i = 0; i < current_indentation; i++) {
			script += '\t';
		}

		if (mode == ScriptMode::lua) {
			std::format_to(std::back_inserter(script), "{} = {}\n", name, value);
		} else {
			std::format_to(std::back_inserter(script), "set {} = {}\n", name, value);
		}
	}

	template<typename... Args>
	constexpr void inline_call(std::string_view name, Args&&... args) {
		std::string work = "{}(";

		for (size_t i = 0; i < sizeof...(args); i++) {
			work += "{}";
			if (i < sizeof...(args) - 1) {
				work += ", ";
			}
		}
		work += ")";
		// Reduce binary code size by having only one instantiation
		raw_write_to_log(work, std::make_format_args(name, args...));
	}

	template<typename... Args>
	constexpr void call(std::string_view name, Args&&... args) {
		std::string work;

		if (mode == ScriptMode::jass) {
			work = "call {}(";
		} else {
			work = "{}(";
		}

		for (size_t i = 0; i < sizeof...(args); i++) {
			work += "{}";
			if (i < sizeof...(args) - 1) {
				work += ", ";
			}
		}
		work += ")\n";

		for (size_t i = 0; i < current_indentation; i++) {
			script += '\t';
		}
		// Reduce binary code size by having only one instantiation
		raw_write_to_log(work, std::make_format_args(name, args...));
	}

	void write(const std::string_view string) {
		for (size_t i = 0; i < current_indentation; i++) {
			script += '\t';
		}

		script += string;
	}

	constexpr void write_ln(const std::string_view string) {
		for (size_t i = 0; i < current_indentation; i++) {
			script += '\t';
		}
		script += string;
		script += '\n';
	}

	template<typename... Args>
	constexpr void write_ln(Args&&... args) {
		std::string work = std::string(current_indentation, '\t');
		for (size_t i = 0; i < sizeof...(args); i++) {
			work += "{}";
		}
		work.push_back('\n');

		// Reduce binary code size by having only one instantiation
		raw_write_to_log(work, std::make_format_args(args...));
	}

	template<typename T>
	constexpr void forloop(size_t start, size_t end, const std::string_view variable, T callback) {
		if (mode == ScriptMode::jass) {
			set_variable(variable, std::to_string(start));
			write_ln("loop");
			current_indentation += 1;
			for (size_t i = 0; i < current_indentation; i++) {
				script += '\t';
			}
			std::format_to(std::back_inserter(script), "exitwhen {} > {}\n", variable, end);
		} else {
			for (size_t i = 0; i < current_indentation; i++) {
				script += '\t';
			}
			std::format_to(std::back_inserter(script), "for i={},{} do\n", start, end);
			current_indentation += 1;
		}

		callback();
		current_indentation -= 1;

		if (mode == ScriptMode::jass) {
			for (size_t i = 0; i < current_indentation; i++) {
				script += '\t';
			}
			std::format_to(std::back_inserter(script), "set {} = {} + 1\n", variable, variable);
			write_ln("endloop");
		} else {
			write_ln("end");
		}

	}

	template<typename T>
	void function(std::string_view name, T callback, const std::string_view return_type = "takes nothing returns nothing") {
		for (size_t i = 0; i < current_indentation; i++) {
			script += '\t';
		}

		if (mode == ScriptMode::lua) {
			std::format_to(std::back_inserter(script), "function {}()\n", name);
		} else {
			std::format_to(std::back_inserter(script), "function {} {}\n", name, return_type);
		}

		current_indentation += 1;
		callback();
		current_indentation -= 1;

		if (mode == ScriptMode::lua) {
			write("end\n\n");
		} else {
			write("endfunction\n\n");
		}
	}

	template<typename T>
	void while_statement(std::string_view condition, T callback) {
		if (mode == ScriptMode::jass) {
			write_ln("loop");
		} else {
			for (size_t i = 0; i < current_indentation; i++) {
				script += '\t';
			}

			std::format_to(std::back_inserter(script), "while ({}) do\n", condition);
		}

		current_indentation += 1;

		if (mode == ScriptMode::jass) {
			for (size_t i = 0; i < current_indentation; i++) {
				script += '\t';
			}
			std::format_to(std::back_inserter(script), "exitwhen (not ({}))\n", condition);
		}

		callback();
		current_indentation -= 1;

		if (mode == ScriptMode::jass) {
			write_ln("endloop");
		} else {
			write_ln("end");
		}
	}

	template<typename T>
	void if_statement(std::string_view condition, T callback) {
		for (size_t i = 0; i < current_indentation; i++) {
			script += '\t';
		}

		std::format_to(std::back_inserter(script), "if ({}) then\n", condition);

		current_indentation += 1;
		callback();
		current_indentation -= 1;

		if (mode == ScriptMode::lua) {
			write_ln("end");
		} else {
			write_ln("endif");
		}
	}

	template<typename T1, typename T2>
	void if_else_statement(std::string_view condition, T1 if_callback, T2 else_callback) {
		for (size_t i = 0; i < current_indentation; i++) {
			script += '\t';
		}

		std::format_to(std::back_inserter(script), "if ({}) then\n", condition);

		current_indentation += 1;
		if_callback();
		current_indentation -= 1;

		write("else\n");

		current_indentation += 1;
		else_callback();
		current_indentation -= 1;

		if (mode == ScriptMode::lua) {
			write_ln("end");
		} else {
			write_ln("endif");
		}
	}

	template<typename T>
	void global_variable(std::string_view name, T value) {
		for (size_t i = 0; i < current_indentation; i++) {
			script += '\t';
		}
		std::format_to(std::back_inserter(script), "udg_{} = {}", name, value);
	}

	/// The ID should not be quoted
	std::string four_cc(std::string_view id) {
		if (mode == ScriptMode::lua) {
			return std::format("FourCC(\"{}\")", id);
		} else {
			return std::format("'{}'", id);
		}
	}

	std::string null() {
		if (mode == ScriptMode::lua) {
			return "nil";
		} else {
			return "null";
		}
	}
};

export enum class Classifier {
	map = 1,
	library = 2,
	category = 4,
	gui = 8,
	comment = 16,
	script = 32,
	variable = 64
};

export struct TriggerCategory {
	Classifier classifier;
	int id;
	std::string name;
	bool open_state = true;
	bool is_comment = false;
	int parent_id;
};

export struct TriggerParameter;

export struct ECA {
	enum class Type {
		event,
		condition,
		action,
		call
	};

	Type type;
	int group;
	std::string name;
	bool enabled;
	std::vector<TriggerParameter> parameters;
	std::vector<ECA> ecas;
};

export struct TriggerParameter {
	enum class Type {
		invalid = -1,
		preset,
		variable,
		function,
		string
	};
	Type type;
	int unknown;
	/// Unused when has_sub_parameter is true, sometimes contains garbage
	std::string value;
	bool has_sub_parameter;
	ECA sub_parameter;
	/// Only used when Type::function and has_sub_parameter=true
	// TriggerSubParameter sub_parameter;
	/// Only used when Type::variable
	bool is_array = false;
	/// Only used when Type::variable and is_array=true
	std::vector<TriggerParameter> parameters;
};

export struct Trigger {
	Classifier classifier;
	int id;
	int parent_id = 0;
	std::string name;
	std::string description;
	std::string custom_text;
	bool is_comment = false;
	bool is_enabled = true;
	bool is_script = false;
	bool initially_on = true;
	bool run_on_initialization = false;
	std::vector<ECA> ecas;

	static inline int next_id = 0;
};

export struct TriggerVariable {
	std::string name;
	std::string type;
	uint32_t unknown;
	bool is_array;
	int array_size = 0;
	bool is_initialized;
	std::string initial_value;
	int id;
	int parent_id;
};

std::string get_base_type(const std::string& type, const ini::INI& trigger_data) {
	std::string base_type = trigger_data.data("TriggerTypes", type, 4);

	if (base_type.empty()) {
		return type;
	}

	return base_type;
}

export class Triggers {
	std::unordered_map<std::string, int> argument_counts;

	static constexpr int write_version = 0x80000004;
	static constexpr int write_sub_version = 7;
	static constexpr int write_string_version = 1;

	int unknown1 = 0;
	int unknown2 = 0;
	int trig_def_ver = 2;

  public:
	ini::INI trigger_strings;
	ini::INI trigger_data;

	std::string global_jass_comment;
	std::string global_jass;

	std::vector<TriggerCategory> categories;
	std::vector<TriggerVariable> variables;
	std::vector<Trigger> triggers;

  private:
	std::string get_type(const std::string_view function_name, size_t parameter) const;

	std::string
	convert_gui_to_jass(const Trigger& trigger, std::vector<std::string>& map_initializations, ScriptMode mode) const;

	std::string resolve_parameter(
		const TriggerParameter& parameter,
		const std::string& trigger_name,
		MapScriptWriter& pre_actions,
		const std::string& type,
		ScriptMode mode,
		bool add_call
	) const;

	std::string convert_eca_to_script(
		const ECA& eca,
		MapScriptWriter& pre_actions,
		const std::string& trigger_name,
		ScriptMode mode,
		bool add_call
	) const;

	void parse_parameter_structure(BinaryReader& reader, TriggerParameter& parameter, uint32_t version) {
		parameter.type = static_cast<TriggerParameter::Type>(reader.read<uint32_t>());
		parameter.value = reader.read_c_string();
		parameter.has_sub_parameter = reader.read<uint32_t>();
		if (parameter.has_sub_parameter) {
			parameter.sub_parameter.type = static_cast<ECA::Type>(reader.read<uint32_t>());
			parameter.sub_parameter.group = 0;
			parameter.sub_parameter.name = reader.read_c_string();
			parameter.sub_parameter.enabled = true;
			const bool has_parameters = reader.read<uint32_t>();
			if (has_parameters) {
				parameter.sub_parameter.parameters.resize(argument_counts[parameter.sub_parameter.name]);
				for (auto&& i : parameter.sub_parameter.parameters) {
					parse_parameter_structure(reader, i, version);
				}
			}
		}
		if (version == 4) {
			if (parameter.type == TriggerParameter::Type::function) {
				reader.advance(4); // Unknown always 0
			} else {
				parameter.is_array = reader.read<uint32_t>();
			}
		} else {
			if (parameter.has_sub_parameter) {
				parameter.unknown = reader.read<uint32_t>(); // Unknown always 0
			}
			parameter.is_array = reader.read<uint32_t>();
		}
		if (parameter.is_array) {
			parameter.parameters.resize(1);
			parse_parameter_structure(reader, parameter.parameters.front(), version);
		}
	}

	void parse_eca_structure(BinaryReader& reader, ECA& eca, bool is_child, uint32_t version) {
		eca.type = static_cast<ECA::Type>(reader.read<uint32_t>());
		if (is_child) {
			eca.group = reader.read<uint32_t>();
		}
		eca.name = reader.read_c_string();
		eca.enabled = reader.read<uint32_t>();
		eca.parameters.resize(argument_counts[eca.name]);
		for (auto&& i : eca.parameters) {
			parse_parameter_structure(reader, i, version);
		}
		if (version == 7) {
			eca.ecas.resize(reader.read<uint32_t>());
			for (auto&& i : eca.ecas) {
				parse_eca_structure(reader, i, true, version);
			}
		}
	}

	void print_parameter_structure(BinaryWriter& writer, const TriggerParameter& parameter) const {
		writer.write<uint32_t>(static_cast<int>(parameter.type));
		writer.write_c_string(parameter.value);
		writer.write<uint32_t>(parameter.has_sub_parameter);

		if (parameter.has_sub_parameter) {
			writer.write<uint32_t>(static_cast<int>(parameter.sub_parameter.type));
			writer.write_c_string(parameter.sub_parameter.name);
			writer.write<uint32_t>(!parameter.sub_parameter.parameters.empty());
			for (const auto& i : parameter.sub_parameter.parameters) {
				print_parameter_structure(writer, i);
			}

			writer.write<uint32_t>(parameter.unknown);
		}
		writer.write<uint32_t>(parameter.is_array);
		if (parameter.is_array) {
			print_parameter_structure(writer, parameter.parameters.front());
		}
	}

	void print_eca_structure(BinaryWriter& writer, const ECA& eca, bool is_child) const {
		writer.write<uint32_t>(static_cast<int>(eca.type));
		if (is_child) {
			writer.write<uint32_t>(eca.group);
		}

		writer.write_c_string(eca.name);
		writer.write<uint32_t>(eca.enabled);
		for (const auto& i : eca.parameters) {
			print_parameter_structure(writer, i);
		}

		writer.write<uint32_t>(eca.ecas.size());
		for (const auto& i : eca.ecas) {
			print_eca_structure(writer, i, true);
		}
	}

  public:
	void load() {
		BinaryReader reader = hierarchy.map_file_read("war3map.wtg").value();

		trigger_strings.load("UI/TriggerStrings.txt");
		trigger_data.load("UI/TriggerData.txt");
		trigger_data.substitute(world_edit_strings, "WorldEditStrings");

		// Manual fixes
		trigger_data.set_whole_data("TriggerTypeDefaults", "string", "\"\"");

		for (auto&& section : {"TriggerActions"s, "TriggerEvents"s, "TriggerConditions"s, "TriggerCalls"s}) {
			for (const auto& [key, value] : trigger_data.section(section)) {
				if (key.front() == '_') {
					continue;
				}

				int arguments = 0;
				for (const auto& j : value) {
					arguments += !j.empty() && !is_number(j) && j != "nothing";
				}

				if (section == "TriggerCalls") {
					--arguments;
				}

				argument_counts[key] = arguments;
			}
		}

		Trigger::next_id = 0;

		const std::string magic_number = reader.read_string(4);
		if (magic_number != "WTG!") {
			std::println("Unknown magic number for war3map.wtg {}", magic_number);
			return;
		}

		const uint32_t version = reader.read<uint32_t>();
		if (version == 0x80000004)
			load_version_31(reader, version);
		else if (version == 4 || version == 7)
			load_version_pre31(reader, version);
		else {
			std::println("Unknown WTG format! Trying 1.31 loader");
			load_version_31(reader, version);
		}
	}

	void load_version_31(BinaryReader& reader, uint32_t version) {
		uint32_t sub_version = reader.read<uint32_t>();
		if (sub_version != 7 && sub_version != 4) {
			std::print("Unknown 1.31 WTG subformat! Trying anyway.\n");
		}

		reader.advance(4); // map_count
		reader.advance(4 * reader.read<uint32_t>()); // map ids of deleted maps

		reader.advance(4); // library_count
		reader.advance(4 * reader.read<uint32_t>()); // library ids of deleted libraries

		reader.advance(4); // category_count
		reader.advance(4 * reader.read<uint32_t>()); // category ids of deleted categories

		reader.advance(4); // trigger_count
		reader.advance(4 * reader.read<uint32_t>()); // trigger ids of deleted triggers

		reader.advance(4); // comment_count
		reader.advance(4 * reader.read<uint32_t>()); // comment ids of deleted comments

		reader.advance(4); // script_count
		reader.advance(4 * reader.read<uint32_t>()); // script ids of deleted scripts

		reader.advance(4); // variable_count
		reader.advance(4 * reader.read<uint32_t>()); // variable ids of deleted variables

		unknown1 = reader.read<uint32_t>();
		unknown2 = reader.read<uint32_t>();
		trig_def_ver = reader.read<uint32_t>();

		uint32_t variable_count = reader.read<uint32_t>();
		for (uint32_t i = 0; i < variable_count; i++) {
			TriggerVariable variable;
			variable.name = reader.read_c_string();
			variable.type = reader.read_c_string();
			variable.unknown = reader.read<uint32_t>();
			variable.is_array = reader.read<uint32_t>();
			if (sub_version == 7) {
				variable.array_size = reader.read<uint32_t>();
			}
			variable.is_initialized = reader.read<uint32_t>();
			variable.initial_value = reader.read_c_string();
			variable.id = reader.read<uint32_t>();
			variable.parent_id = reader.read<uint32_t>();
			variables.push_back(variable);

			Trigger::next_id = std::max(Trigger::next_id, variable.id + 1);
		}

		uint32_t element_count = reader.read<uint32_t>();

		for (uint32_t i = 0; i < element_count; i++) {
			Classifier classifier = static_cast<Classifier>(reader.read<uint32_t>());
			switch (classifier) {
				case Classifier::map:
				case Classifier::library:
				case Classifier::category: {
					TriggerCategory cat;
					cat.classifier = classifier;
					cat.id = reader.read<uint32_t>();
					cat.name = reader.read_c_string();
					if (sub_version == 7) {
						cat.is_comment = reader.read<uint32_t>();
					}
					cat.open_state = reader.read<uint32_t>();
					cat.parent_id = reader.read<uint32_t>();
					categories.push_back(cat);

					Trigger::next_id = std::max(Trigger::next_id, cat.id + 1);
					break;
				}
				case Classifier::gui:
				case Classifier::comment:
				case Classifier::script: {
					Trigger trigger;
					trigger.classifier = classifier;
					trigger.name = reader.read_c_string();
					trigger.description = reader.read_c_string();
					if (sub_version == 7) {
						trigger.is_comment = reader.read<uint32_t>();
					}
					trigger.id = reader.read<uint32_t>();
					trigger.is_enabled = reader.read<uint32_t>();
					trigger.is_script = reader.read<uint32_t>();
					trigger.initially_on = !reader.read<uint32_t>();
					trigger.run_on_initialization = reader.read<uint32_t>();
					trigger.parent_id = reader.read<uint32_t>();
					trigger.ecas.resize(reader.read<uint32_t>());
					for (auto& j : trigger.ecas) {
						parse_eca_structure(reader, j, false, sub_version);
					}

					triggers.push_back(trigger);

					Trigger::next_id = std::max(Trigger::next_id, trigger.id + 1);
					break;
				}
				case Classifier::variable: {
					reader.advance(4); // id
					reader.advance_c_string(); // name
					reader.advance(4); // parentid
					break;
				}
			}
		}
	}

	void load_version_pre31(BinaryReader& reader, uint32_t version) {
		std::print("Importing pre-1.31 trigger format\n");

		categories.resize(reader.read<uint32_t>());
		for (auto& i : categories) {
			i.classifier = Classifier::category;
			i.id = reader.read<uint32_t>();
			i.name = reader.read_c_string();
			i.parent_id = 0;
			if (version == 7) {
				i.is_comment = reader.read<uint32_t>();
			}

			Trigger::next_id = std::max(Trigger::next_id, i.id + 1);
			if (i.id == 0) {
				i.id = -2;
			}
		}

		reader.advance(4); // dunno

		int variable_category = Trigger::next_id++;
		categories.insert(categories.begin(), {Classifier::map, 0, "Map Header", true, false, -1});
		categories.insert(categories.begin(), {Classifier::category, variable_category, "Variables", true, false, 0});

		variables.resize(reader.read<uint32_t>());
		for (auto& i : variables) {
			i.name = reader.read_c_string();
			i.type = reader.read_c_string();
			i.unknown = reader.read<uint32_t>();
			i.id = Trigger::next_id++;

			i.is_array = reader.read<uint32_t>();
			if (version == 7) {
				i.array_size = reader.read<uint32_t>();
			}
			i.is_initialized = reader.read<uint32_t>();
			i.initial_value = reader.read_c_string();
			i.parent_id = variable_category;
		}

		triggers.resize(reader.read<uint32_t>());
		for (auto& i : triggers) {
			i.name = reader.read_c_string();
			i.description = reader.read_c_string();
			if (version == 7) {
				i.is_comment = reader.read<uint32_t>();
			}
			i.is_enabled = reader.read<uint32_t>();
			i.is_script = reader.read<uint32_t>();
			i.initially_on = !reader.read<uint32_t>();
			i.run_on_initialization = reader.read<uint32_t>();

			i.id = Trigger::next_id++;

			if (i.run_on_initialization && i.is_script) {
				i.classifier = Classifier::gui;
			} else if (i.is_comment) {
				i.classifier = Classifier::comment;
			} else if (i.is_script) {
				i.classifier = Classifier::script;
			} else {
				i.classifier = Classifier::gui;
			}

			i.parent_id = reader.read<uint32_t>();
			if (i.parent_id == 0) {
				i.parent_id = -2;
			}
			i.ecas.resize(reader.read<uint32_t>());
			for (auto& j : i.ecas) {
				parse_eca_structure(reader, j, false, version);
			}
		}
	}

	/// Can be Jass or Lua depending on the map
	void load_scripts() {
		BinaryReader reader = hierarchy.map_file_read("war3map.wct").value();

		const uint32_t version = reader.read<uint32_t>();
		if (version != 0x80000004) {
			if (version == 1 || version == 0) {
				if (version == 1) {
					global_jass_comment = reader.read_c_string();
					global_jass = reader.read_string(reader.read<uint32_t>());
				}
				reader.advance(4);
				for (auto&& i : triggers) {
					const uint32_t size = reader.read<uint32_t>();
					if (size > 0) {
						i.custom_text = reader.read_string(size);
					}
				}
				return;
			} else {
				std::print("Probably invalid WCT format\n");
			}
		}

		const int sub_version = reader.read<uint32_t>();
		if (sub_version != 1 && sub_version != 0) {
			std::print("Unknown WCT 1.31 subformat\n");
		}

		if (sub_version == 1) {
			global_jass_comment = reader.read_c_string();
			int size = reader.read<uint32_t>();
			if (size > 0) {
				global_jass = reader.read_string(size);
			}
		}

		for (auto& i : triggers) {
			if (!i.is_comment) {
				int size = reader.read<uint32_t>();
				if (size > 0) {
					i.custom_text = reader.read_string(size);
				}
			}
		}
	}

	void save() const {
		BinaryWriter writer;
		writer.write_string("WTG!");
		writer.write<uint32_t>(write_version);
		writer.write<uint32_t>(write_sub_version);

		writer.write<uint32_t>(0);
		writer.write<uint32_t>(0);

		writer.write<uint32_t>(0);
		writer.write<uint32_t>(0);

		writer.write<uint32_t>(0);
		writer.write<uint32_t>(0);

		writer.write<uint32_t>(0);
		writer.write<uint32_t>(0);

		writer.write<uint32_t>(0);
		writer.write<uint32_t>(0);

		writer.write<uint32_t>(0);
		writer.write<uint32_t>(0);

		writer.write<uint32_t>(0);
		writer.write<uint32_t>(0);

		writer.write<uint32_t>(unknown1);
		writer.write<uint32_t>(unknown2);
		writer.write<uint32_t>(trig_def_ver);
		writer.write<uint32_t>(variables.size());

		for (const auto& i : variables) {
			writer.write_c_string(i.name);
			writer.write_c_string(i.type);
			writer.write<uint32_t>(i.unknown);
			writer.write<uint32_t>(i.is_array);
			writer.write<uint32_t>(i.array_size);
			writer.write<uint32_t>(i.is_initialized);
			writer.write_c_string(i.initial_value);
			writer.write<uint32_t>(i.id);
			writer.write<uint32_t>(i.parent_id);
		}

		writer.write<uint32_t>(categories.size() + triggers.size() + variables.size());

		for (const auto& i : categories) {
			writer.write<uint32_t>(static_cast<int>(i.classifier));
			writer.write<uint32_t>(i.id);
			writer.write_c_string(i.name);
			writer.write<uint32_t>(i.is_comment);
			writer.write<uint32_t>(i.open_state);
			writer.write<uint32_t>(i.parent_id);
		}

		for (const auto& i : triggers) {
			writer.write<uint32_t>(static_cast<int>(i.classifier));
			writer.write_c_string(i.name);
			writer.write_c_string(i.description);

			writer.write<uint32_t>(i.is_comment);
			writer.write<uint32_t>(i.id);
			writer.write<uint32_t>(i.is_enabled);
			writer.write<uint32_t>(i.is_script);
			writer.write<uint32_t>(!i.initially_on);
			writer.write<uint32_t>(i.run_on_initialization);
			writer.write<uint32_t>(i.parent_id);
			writer.write<uint32_t>(i.ecas.size());
			for (const auto& eca : i.ecas) {
				print_eca_structure(writer, eca, false);
			}
		}

		for (const auto& i : variables) {
			writer.write<uint32_t>(static_cast<int>(Classifier::variable));
			writer.write<uint32_t>(i.id);
			writer.write_c_string(i.name);
			writer.write<uint32_t>(i.parent_id);
		}

		hierarchy.map_file_write("war3map.wtg", writer.buffer);
	}

	/// Can be jass or lua depending on the map
	void save_scripts() const {
		BinaryWriter writer;

		writer.write<uint32_t>(write_version);
		writer.write<uint32_t>(1);

		writer.write_c_string(global_jass_comment);
		if (global_jass.empty()) {
			writer.write<uint32_t>(0);
		} else {
			writer.write<uint32_t>(global_jass.size() + (global_jass.back() == '\0' ? 0 : 1));
			writer.write_c_string(global_jass);
		}

		// Custom text (jass/lua) needs to be saved in the order they appear in the hierarchy
		for (const auto& j : categories) {
			for (const auto& i : triggers) {
				if (i.parent_id == j.id) {
					if (!i.is_comment) {
						if (i.custom_text.size() == 0) {
							writer.write<uint32_t>(0);
						} else {
							writer.write<uint32_t>(i.custom_text.size() + (i.custom_text.back() == '\0' ? 0 : 1));
							writer.write_c_string(i.custom_text);
						}
					}
				}
			}
		}

		hierarchy.map_file_write("war3map.wct", writer.buffer);
	}

	/// Returns compile output which could contain errors or general information
	std::expected<void, std::string> generate_map_script(
		const Terrain& terrain,
		const Units& units,
		const Doodads& doodads,
		const MapInfo& map_info,
		const Sounds& sounds,
		const Regions& regions,
		const GameCameras& cameras,
		ScriptMode mode
	);
};
```

`src/base/units.ixx`:

```ixx
module;

#include <QRect>

export module Units;

import std;
import Utilities;
import SkinnedMesh;
import SkeletalModelInstance;
import MapInfo;
import BinaryReader;
import BinaryWriter;
import ResourceManager;
import Hierarchy;
import Globals;
import Terrain;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;

namespace fs = std::filesystem;

export struct Unit {
	static inline int auto_increment;

	std::string id;
	int variation = 0;
	glm::vec3 position;
	float angle;
	glm::vec3 scale;

	std::string skin_id;

	uint8_t flags = 2;
	int player = 0;

	uint8_t unknown1 = 0;
	uint8_t unknown2 = 0;
	int health = -1;
	int mana = -1;

	int item_table_pointer = 0xFFFF;
	std::vector<ItemSet> item_sets;

	int gold = 12500;
	float target_acquisition = -1;

	int level = 1;
	int strength = 0;
	int agility = 0;
	int intelligence = 0;

	// Slot, ID
	std::vector<std::pair<uint32_t, std::string>> items;

	// ID, autocast, ability level
	std::vector<std::tuple<std::string, uint32_t, uint32_t>> abilities;

	int random_type = 0;
	std::vector<uint8_t> random;

	int custom_color = -1;
	int waygate = -1;
	int creation_number;

	SkeletalModelInstance skeleton;
	std::shared_ptr<SkinnedMesh> mesh;
	glm::vec3 color;

	Unit() {
		creation_number = ++auto_increment;
	}

	void update() {
		float model_scale = 0.f;
		float move_height = 0.f;
		if (items_slk.row_headers.contains(id)) {
			model_scale = items_slk.data<float>("scale", id) / 128.f;
			color.r = items_slk.data<float>("colorr", id) / 255.f;
			color.g = items_slk.data<float>("colorg", id) / 255.f;
			color.b = items_slk.data<float>("colorb", id) / 255.f;
		} else {
			model_scale = units_slk.data<float>("modelscale", id) / 128.f;
			move_height = units_slk.data<float>("moveheight", id) / 128.f;
			color.r = units_slk.data<float>("red", id) / 255.f;
			color.g = units_slk.data<float>("green", id) / 255.f;
			color.b = units_slk.data<float>("blue", id) / 255.f;
		}

		const glm::vec3 final_position = position + glm::vec3(0.f, 0.f, move_height);
		const glm::vec3 final_scale = glm::vec3(model_scale);

		skeleton.update_location(final_position, angle, final_scale);
	}
};

export class Units {
	std::unordered_map<std::string, std::shared_ptr<SkinnedMesh>> id_to_mesh;

	static constexpr int write_version = 8;
	static constexpr int write_subversion = 11;

	//static constexpr int mod_table_write_version = 2;
public:
	std::vector<Unit> units;
	std::vector<Unit> items;

	void load(const Terrain& terrain, const MapInfo& info) {
		BinaryReader reader = hierarchy.map_file_read("war3mapUnits.doo").value();

		const std::string magic_number = reader.read_string(4);
		if (magic_number != "W3do") {
			std::cout << "Invalid war3mapUnits.w3e file: Magic number is not W3do\n";
		}
		const uint32_t version = reader.read<uint32_t>();
		if (version != 7 && version != 8) {
			std::cout << "Unknown war3mapUnits.doo version: " << version << " Attempting to load but may crash\nPlease send this map to eejin\n";
		}

		// Subversion
		const int subversion = reader.read<uint32_t>();
		if (subversion != 9 && subversion != 11) {
			std::cout << "Unknown war3mapUnits.doo subversion: " << subversion << " Attempting to load but may crash\nPlease send this map to eejin\n";
		}

		const int unit_count = reader.read<uint32_t>();
		for (int k = 0; k < unit_count; k++) {
			Unit i;
			i.id = reader.read_string(4);
			i.variation = reader.read<uint32_t>();
			i.position = (reader.read<glm::vec3>() - glm::vec3(terrain.offset, 0)) / 128.f;
			i.angle = reader.read<float>();
			i.scale = reader.read<glm::vec3>() / 128.f;

			if (info.game_version_major * 100 + info.game_version_minor >= 132) {
				i.skin_id = reader.read_string(4);
			} else {
				i.skin_id = i.id;
			}

			i.flags = reader.read<uint8_t>();

			i.player = reader.read<uint32_t>();
			if (i.player > 11 && info.editor_version < 6060) {
				i.player += 12;
			}

			i.unknown1 = reader.read<uint8_t>();
			i.unknown2 = reader.read<uint8_t>();

			i.health = reader.read<uint32_t>();
			i.mana = reader.read<uint32_t>();

			if (subversion >= 11) {
				i.item_table_pointer = reader.read<uint32_t>();
			}

			i.item_sets.resize(reader.read<uint32_t>());
			for (auto&& j : i.item_sets) {
				j.items.resize(reader.read<uint32_t>());
				for (auto&&[chance, id] : j.items) {
					id = reader.read_string(4);
					chance = reader.read<uint32_t>();
				}
			}

			i.gold = reader.read<uint32_t>();
			i.target_acquisition = reader.read<float>();

			i.level = reader.read<uint32_t>();

			if (subversion >= 11) {
				i.strength = reader.read<uint32_t>();
				i.agility = reader.read<uint32_t>();
				i.intelligence = reader.read<uint32_t>();
			}

			i.items.resize(reader.read<uint32_t>());
			for (auto&& [slot, id] : i.items) {
				slot = reader.read<uint32_t>();
				id = reader.read_string(4);
			}

			i.abilities.resize(reader.read<uint32_t>());
			for (auto&&[id, autocast, level] : i.abilities) {
				id = reader.read_string(4);
				autocast = reader.read<uint32_t>();
				level =  reader.read<uint32_t>();
			}

			i.random_type = reader.read<uint32_t>();
			switch (i.random_type) {
				case 0:
					i.random = reader.read_vector<uint8_t>(4);
					break;
				case 1:
					i.random = reader.read_vector<uint8_t>(8);
					break;
				case 2:
					i.random = reader.read_vector<uint8_t>(reader.read<uint32_t>() * 8);
					break;
			}

			i.custom_color = reader.read<uint32_t>();
			i.waygate = reader.read<uint32_t>();
			i.creation_number = reader.read<uint32_t>();

			// Either a unit or an item
			if (units_slk.row_headers.contains(i.id) || i.id == "sloc" || i.id == "uDNR" || i.id == "bDNR") {
				units.push_back(i);
			} else {
				items.push_back(i);
			}

			Unit::auto_increment = std::max(Unit::auto_increment, i.creation_number);
		}
	}

	void save(const Terrain& terrain) const {
		BinaryWriter writer;

		writer.write_string("W3do");
		writer.write<uint32_t>(write_version);
		writer.write<uint32_t>(write_subversion);

		writer.write<uint32_t>(units.size() + items.size());

		auto write_units = [&](const std::vector<Unit>& to_write) {
			for (auto&& i : to_write) {
				writer.write_string(i.id);
				writer.write<uint32_t>(i.variation);
				writer.write<glm::vec3>(i.position * 128.f + glm::vec3(terrain.offset, 0));
				writer.write<float>(i.angle);
				writer.write<glm::vec3>(i.scale * 128.f);

				writer.write_string(i.skin_id);

				writer.write<uint8_t>(i.flags);

				writer.write<uint32_t>(i.player);

				writer.write<uint8_t>(i.unknown1);
				writer.write<uint8_t>(i.unknown2);

				writer.write<uint32_t>(i.health);
				writer.write<uint32_t>(i.mana);

				writer.write<uint32_t>(i.item_table_pointer);

				writer.write<uint32_t>(i.item_sets.size());
				for (auto&& j : i.item_sets) {
					writer.write<uint32_t>(j.items.size());
					for (auto&&[chance, id] : j.items) {
						writer.write_string(id);
						writer.write<uint32_t>(chance);
					}
				}

				writer.write<uint32_t>(i.gold);
				writer.write<float>(i.target_acquisition);
				writer.write<uint32_t>(i.level);
				writer.write<uint32_t>(i.strength);
				writer.write<uint32_t>(i.agility);
				writer.write<uint32_t>(i.intelligence);


				writer.write<uint32_t>(i.items.size());
				for (auto&&[slot, id] : i.items) {
					writer.write<uint32_t>(slot);
					writer.write_string(id);
				}

				writer.write<uint32_t>(i.abilities.size());
				for (auto&&[id, autocast, level] : i.abilities) {
					writer.write_string(id);
					writer.write<uint32_t>(autocast);
					writer.write<uint32_t>(level);
				}

				writer.write<uint32_t>(i.random_type);
				writer.write_vector(i.random);

				writer.write<uint32_t>(i.custom_color);
				writer.write<uint32_t>(i.waygate);
				writer.write<uint32_t>(i.creation_number);
			}
		};

		write_units(units);
		write_units(items);

		hierarchy.map_file_write("war3mapUnits.doo", writer.buffer);
	}

	void update_area(const QRect& area, const Terrain& terrain) {
		for (auto&& i : query_area(area)) {
			i->position.z = terrain.interpolated_height(i->position.x, i->position.y, true);
			i->update();
		}
	}

	void create() {
		for (auto& i : units) {
			// ToDo handle starting location
			if (i.id == "sloc") {
				continue;
			}

			i.mesh = get_mesh(i.id);
			i.skeleton = SkeletalModelInstance(i.mesh->mdx);
			i.update();
		}

		for (auto& i : items) {
			i.mesh = get_mesh(i.id);
			i.skeleton = SkeletalModelInstance(i.mesh->mdx);
			i.update();
		}
	}

	// Will assign a unique creation number
	Unit& add_unit(std::string id, glm::vec3 position) {
		// ToDo change this once SkeletalModelInstance doesn't use pointers anymore
		units.push_back(Unit());
		Unit& unit = units.back();
		unit.id = id;
		unit.skin_id = id;
		unit.mesh = get_mesh(id);
		unit.position = position;
		unit.scale = glm::vec3(1.f);
		unit.angle = 0.f;
		unit.random = { 1, 0, 0, 0 };
		unit.creation_number = ++Unit::auto_increment;
		unit.skeleton = SkeletalModelInstance(unit.mesh->mdx);
		unit.update();

		return units.back();
	}

	// Assumes you will set a unique creation number yourself
	Unit& add_unit(Unit unit) {
		units.push_back(unit);
		return units.back();
	}

	void remove_unit(Unit* unit) {
		auto iterator = units.begin() + std::distance(units.data(), unit);
		units.erase(iterator);
	}

	[[nodiscard]] std::vector<Unit*> query_area(const QRectF& area) {
		std::vector<Unit*> result;

		for (auto& i : units) {
			if (area.contains(i.position.x, i.position.y) && i.id != "sloc") {
				result.push_back(&i);
			}
		}
		return result;
	}

	void remove_units(const std::unordered_set<Unit*>& list) {
		std::erase_if(units, [&](Unit& unit) {
			return list.contains(&unit);
		});
	}

	void process_unit_field_change(const std::string& id, const std::string& field) {
		if (field == "file") {
			id_to_mesh.erase(id);
			for (auto& i : units) {
				if (i.id == id) {
					i.mesh = get_mesh(id);
					i.skeleton = SkeletalModelInstance(i.mesh->mdx);
					i.update();
				}
			}
		}
		if (field == "modelscale" || field == "moveheight" || field == "red" || field == "green" || field == "blue") {
			for (auto& i : units) {
				if (i.id == id) {
					i.update();
				}
			}
		}

		if (field == "colorr" || field == "colorg" || field == "colorb" || field == "scale") {
			for (auto& i : items) {
				if (i.id == id) {
					i.update();
				}
			}
		}
	}

	void process_item_field_change(const std::string& id, const std::string& field) {
		if (field == "colorr" || field == "colorg" || field == "colorb" || field == "scale") {
			for (auto& i : items) {
				if (i.id == id) {
					i.update();
				}
			}
		}
	}

	std::shared_ptr<SkinnedMesh> get_mesh(const std::string& id) {
		if (const auto found = id_to_mesh.find(id); found != id_to_mesh.end()) {
			return found->second;
		}

		fs::path mesh_path = units_slk.data<std::string_view>("file", id);
		if (mesh_path.empty()) {
			mesh_path = items_slk.data<std::string_view>("file", id);
		}
		mesh_path.replace_extension(".mdx");

		mesh_path = fs::path(string_replaced(mesh_path.string(), "\\", "/"));

		// Mesh doesn't exist at all
		if (!hierarchy.file_exists(mesh_path)) {
			std::println("Missing model file for {} With file path: {}", id, mesh_path.string());
			id_to_mesh.emplace(id, resource_manager.load<SkinnedMesh>("Objects/Invalidmodel/Invalidmodel.mdx", "", std::nullopt));
			return id_to_mesh[id];
		}

		id_to_mesh.emplace(id, resource_manager.load<SkinnedMesh>(mesh_path, "", std::nullopt));

		return id_to_mesh[id];
	}
};
```

`src/base/units_undo.ixx`:

```ixx
export module UnitsUndo;

import std;
import Units;
import WorldUndoManager;

// Undo/redo structures
export class UnitAddAction final : public WorldCommand {
public:
	std::vector<Unit> units;

	void undo(WorldEditContext& ctx) override {
		ctx.units.units.resize(ctx.units.units.size() - units.size());
	}

	void redo(WorldEditContext& ctx) override {
		ctx.units.units.insert(ctx.units.units.end(), units.begin(), units.end());
	}
};

export class UnitDeleteAction final : public WorldCommand {
public:
	std::vector<Unit> units;

	void undo(WorldEditContext& ctx) override {
		if (ctx.brush) {
			ctx.brush->clear_selection();
		}

		ctx.units.units.insert(ctx.units.units.end(), units.begin(), units.end());
	}

	void redo(WorldEditContext& ctx) override {
		if (ctx.brush) {
			ctx.brush->clear_selection();
		}

		ctx.units.units.resize(ctx.units.units.size() - units.size());
	}
};

export class UnitStateAction final : public WorldCommand {
public:
	std::vector<Unit> old_units;
	std::vector<Unit> new_units;

	void undo(WorldEditContext& ctx) override {
		for (auto& i : old_units) {
			for (auto& j : ctx.units.units) {
				if (i.creation_number == j.creation_number) {
					j = i;
				}
			}
		}
	}

	void redo(WorldEditContext& ctx) override {
		for (auto& i : new_units) {
			for (auto& j : ctx.units.units) {
				if (i.creation_number == j.creation_number) {
					j = i;
				}
			}
		}
	}
};







```

`src/base/window_handler.ixx`:

```ixx
module;

#include <QWidget>

export module WindowHandler;

import std;

export class WindowHandler : public QObject {
	Q_OBJECT
	std::vector<std::pair<std::string, QWidget*>> windows;

  public:

	/// Creates a window of type T if one doesn't exist yet. Otherwise it raises to the foreground and activates the window.
	template <typename T>
	T* create_or_raise(QWidget* parent, bool& created) {
		const auto found = std::find_if(windows.begin(), windows.end(), [&](const auto& item) { return item.first == typeid(T).name(); });
		if (found != windows.end()) {
			T* window = dynamic_cast<T*>(found->second);
			window->raise();
			window->activateWindow();
			created = false;
			return window;
		} else {
			T* window = new T(parent);
			windows.emplace_back(typeid(T).name(), dynamic_cast<QWidget*>(window));
			connect(window, &T::destroyed, [this, window] {
				const auto found = std::find_if(windows.begin(), windows.end(), [&](const auto& item) { return item.second == window; });
				windows.erase(found);
			});
			created = true;
			return window;
		}
	}

	void close_all() {
		for (const auto& [name, window] : windows) {
			window->close();
		}
	}
};

export inline WindowHandler window_handler;

#include "window_handler.moc"
```

`src/base/world_undo_manager.ixx`:

```ixx
export module WorldUndoManager;

import std;
import PathingMap;
import Units;
import Doodads;
import Terrain;
import "brush/brush.h";

/// So we don't have to pass a global variable around
export struct WorldEditContext {
	Terrain& terrain;
	Units& units;
	Doodads& doodads;
	Brush* brush;
	PathingMap& pathing_map;
};

/// Describes a change in the world. E.g., changing the terrain, adding a unit in the OE, placing some doodads.
export class WorldCommand {
  public:
	virtual void undo(WorldEditContext& ctx) = 0;
	virtual void redo(WorldEditContext& ctx) = 0;

	virtual ~WorldCommand() = default;
};

export class WorldUndoManager {
	std::vector<std::vector<std::unique_ptr<WorldCommand>>> undo_actions;
	std::vector<std::vector<std::unique_ptr<WorldCommand>>> redo_actions;

  public:
	void undo(WorldEditContext& ctx) {
		if (undo_actions.empty()) {
			return;
		}

		auto& actions = undo_actions.back();
		for (const auto& i : actions) {
			i->undo(ctx);
		}

		redo_actions.push_back(std::move(actions));
		undo_actions.pop_back();
	}

	void redo(WorldEditContext& ctx) {
		if (redo_actions.empty()) {
			return;
		}

		auto& actions = redo_actions.back();
		for (const auto& i : actions) {
			i->redo(ctx);
		}

		undo_actions.push_back(std::move(actions));
		redo_actions.pop_back();
	}

	void new_undo_group() {
		undo_actions.push_back({});
	}

	void add_undo_action(std::unique_ptr<WorldCommand> action) {
		if (undo_actions.empty()) {
			return;
		}

		undo_actions.back().push_back(std::move(action));
		redo_actions.clear();
	};
};




```

`src/brush/brush.cpp`:

```cpp
#include "brush.h"

import std;
import Camera;
import OpenGLUtilities;
import ResourceManager;
import Globals;
import <glad/glad.h>;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;

Brush::Brush() {
	set_size(size);

	selection_shader = resource_manager.load<Shader>({"data/shaders/selection.vert", "data/shaders/selection.frag"});
	selection_circle_shader = resource_manager.load<Shader>({"data/shaders/selection_circle.vert", "data/shaders/selection_circle.frag"});
	brush_shader = resource_manager.load<Shader>({"data/shaders/brush.vert", "data/shaders/brush.frag"});
}

glm::vec2 Brush::get_position() const {
	const bool even_width = size.x % (2 * static_cast<size_t>(size_granularity)) == 0;
	const bool even_height = size.y % (2 * static_cast<size_t>(size_granularity)) == 0;

	glm::vec2 even = glm::floor(glm::vec2(input_handler.mouse_world) * position_granularity + 0.5f) / position_granularity;
	glm::vec2 uneven = glm::floor(glm::vec2(input_handler.mouse_world) * position_granularity) / position_granularity + (1.f / position_granularity / 2.f);

	if (center_on_tile_corner) {
		std::swap(even, uneven);
	}

	glm::vec2 result;
	if (even_width) {
		result.x = even.x;
	} else {
		result.x = uneven.x;
	}

	if (even_height) {
		result.y = even.y;
	} else {
		result.y = uneven.y;
	}

	return result;
}

void Brush::set_size(const glm::ivec2 new_size) {
	size = glm::clamp(new_size * size_granularity, 1, 999);
	set_shape(shape);
}

void Brush::set_shape(const Shape new_shape) {
	context->makeCurrent();
	std::vector<glm::u8vec4> brush(size.x * size.y, {0, 0, 0, 0});

	shape = new_shape;

	for (int i = 0; i < size.x; i++) {
		for (int j = 0; j < size.y; j++) {
			if (contains(glm::ivec2(i, j) / size_granularity)) {
				brush[j * size.x + i] = brush_color;
			} else {
				brush[j * size.x + i] = {0, 0, 0, 0};
			}
		}
	}

	glDeleteTextures(1, &brush_texture);
	glCreateTextures(GL_TEXTURE_2D, 1, &brush_texture);
	glTextureParameteri(brush_texture, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTextureParameteri(brush_texture, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTextureParameteri(brush_texture, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTextureParameteri(brush_texture, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	glTextureStorage2D(brush_texture, 1, GL_RGBA8, size.x, size.y);
	glTextureSubImage2D(brush_texture, 0, 0, 0, size.x, size.y, GL_RGBA, GL_UNSIGNED_BYTE, brush.data());
}

/// Whether the brush shape contains the point, Arguments in brush coordinates
bool Brush::contains(const glm::ivec2 pos) const {
	switch (shape) {
		case Shape::square:
			return true;
		case Shape::circle: {
			const int half_size = (size.x / 2) / size_granularity;
			const int distance = (pos.x - half_size) * (pos.x - half_size) + (pos.y - half_size) * (pos.y - half_size);
			return distance <= half_size * half_size;
		}
		case Shape::diamond:
			const int half_size = (size.x / 2) / size_granularity;
			return std::abs(pos.x - half_size) + std::abs(pos.y - half_size) <= half_size;
	}
	return true;
}

void Brush::increase_size(const int new_size) {
	set_size(size / size_granularity + new_size);
}

void Brush::decrease_size(const int new_size) {
	set_size(size / size_granularity - new_size);
}

void Brush::switch_mode() {
	if (mode != Mode::placement && mode != Mode::selection) {
		mode = return_mode;
	}
	mode = (mode == Mode::placement) ? Mode::selection : Mode::placement;

	clear_selection();
	selection_started = false;
}

void Brush::key_press_event(QKeyEvent* event) {
	switch (event->key()) {
		case Qt::Key_Escape:
			clear_selection();
			break;
		case Qt::Key_Equal:
			increase_size(2);
			break;
		case Qt::Key_Minus:
			decrease_size(2);
			break;
		case Qt::Key_Delete:
			delete_selection();
			break;
		case Qt::Key_X:
			if (event->modifiers() & Qt::ControlModifier) {
				cut_selection();
			}
			break;
		case Qt::Key_C:
			if (event->modifiers() & Qt::ControlModifier) {
				copy_selection();
			}
			break;
		case Qt::Key_V:
			if (event->modifiers() & Qt::ControlModifier) {
				return_mode = mode;
				mode = Mode::pasting;
			}
			break;
	}
}

void Brush::mouse_move_event(QMouseEvent* event, double frame_delta) {
	if (event->buttons() == Qt::LeftButton) {
		if (mode == Mode::placement && (can_place() || event->modifiers() & Qt::ShiftModifier)) {
			apply(frame_delta);
		}
	}
}

void Brush::mouse_press_event(QMouseEvent* event, double frame_delta) {
	if (event->button() != Qt::LeftButton) {
		return;
	}

	if (!event->modifiers()) {
		clear_selection();
	}

	if (mode == Mode::selection && !(event->modifiers() & Qt::ControlModifier)) {
		if (!selection_started) {
			selection_started = true;
			selection_start = input_handler.mouse_world;
		}
	} else if (mode == Mode::placement) {
		// Check if eligible for placement
		if (event->button() == Qt::LeftButton) {
			apply_begin();
			if (can_place() || event->modifiers() & Qt::ShiftModifier) {
				apply(0.5);
			}
		}
	} else if (mode == Mode::pasting && (can_place() || event->modifiers() & Qt::ShiftModifier)) {
		clear_selection();
		place_clipboard();
		mode = Mode::selection;
	}
}

void Brush::mouse_release_event(QMouseEvent* event) {
	if (mode == Mode::selection) {
		selection_started = false;
	} else if (mode == Mode::placement) {
		if (event->button() == Qt::LeftButton) {
			apply_end();
		}
	}
}

void Brush::render() {
	if (mode == Mode::selection) {
		render_selector();
	}
	if (mode == Mode::placement) {
		render_brush();
	}
	if (mode == Mode::pasting) {
		render_clipboard();
	}
	render_selection();
}

void Brush::render_selector() const {
	if (selection_started) {
		glDisable(GL_DEPTH_TEST);

		selection_shader->use();

		glm::mat4 model(1.f);
		model = glm::translate(model, selection_start);
		model = glm::scale(model, glm::vec3(glm::vec2(input_handler.mouse_world), 1.f) - glm::vec3(glm::vec2(selection_start), 1.f));
		model = camera.projection_view * model;
		glUniformMatrix4fv(1, 1, GL_FALSE, &model[0][0]);

		glEnableVertexAttribArray(0);
		glBindBuffer(GL_ARRAY_BUFFER, shapes.vertex_buffer);
		glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

		glDrawArrays(GL_LINE_LOOP, 0, 4);

		glDisableVertexAttribArray(0);
		glEnable(GL_DEPTH_TEST);
	}
}

void Brush::render_brush() {}

```

`src/brush/brush.h`:

```h
#pragma once

#include <QMouseEvent>
#include <QKeyEvent>

#include <glad/glad.h>
#include <glm/glm.hpp>

#include <memory>
#include <string_view>

import Shader;

class Brush : public QObject {
	Q_OBJECT

public:
	enum class Shape {
		square,
		circle,
		diamond
	};

	enum class Mode {
		placement,
		selection,
		pasting
	};


	GLuint brush_texture;

	Brush();

	virtual glm::vec2 get_position() const;
	virtual void set_size(glm::ivec2 size);
	virtual void set_shape(Shape shape);
	virtual void increase_size(int size);
	virtual void decrease_size(int size);
	virtual bool contains(glm::ivec2 pos) const;

	virtual void switch_mode();
	Mode get_mode() {
		return mode;
	}

	virtual void key_press_event(QKeyEvent* event);
	virtual void key_release_event(QKeyEvent* event) {}
	virtual void mouse_move_event(QMouseEvent* event, double frame_delta);
	virtual void mouse_press_event(QMouseEvent* event, double frame_delta);
	virtual void mouse_release_event(QMouseEvent* event);

	virtual void delete_selection() {};
	virtual void copy_selection() {};
	virtual void cut_selection() {};
	virtual void clear_selection() {};
	virtual void place_clipboard() {};

	virtual void clear_clipboard() {};
	
	void render();
	virtual void render_selector() const;
	virtual void render_selection() const {};
	virtual void render_clipboard() {}
	virtual void render_brush();

	virtual bool can_place() {
		return true;
	};
	virtual void apply_begin() {};
	virtual void apply(double frame_delta) = 0;
	virtual void apply_end() {};

protected:
	Shape shape = Shape::circle;
	Mode mode = Mode::placement;
	Mode return_mode = Mode::placement;

	/// The color used to render the brush which currently mimics the WC3 default
	glm::u8vec4 brush_color = { 0, 255, 0, 128 };

	/// How many quarter tiles fit into one size unit for this brush. Terrain brush is 4, pathing brush is 1.
	int size_granularity = 1;
	/// The granularity of the grid that the position will be snapped to. There will be 1 / position_granularity cells in a tile
	float position_granularity = 1.f;
	/// Whether the brush will be offset to center on a corner of the grid lattice rather than on a grid tile
	bool center_on_tile_corner = false;
	/// Size in 1/4ths of a tile (corresponding to the pathing map tile size which is the smallest)
	glm::ivec2 size = glm::ivec2(1);

	bool selection_started = false;
	glm::vec3 selection_start;

	std::shared_ptr<Shader> selection_shader;
	std::shared_ptr<Shader> selection_circle_shader;
	std::shared_ptr<Shader> brush_shader;

public slots:
	virtual void unselect_id(std::string_view id) {
	}

signals:
	void selection_changed();
};
```

`src/brush/doodad_brush.cpp`:

```cpp
#include "doodad_brush.h"

#include <QKeyEvent>

import std;
import Hierarchy;
import SLK;
import Texture;
import Doodad;
import WorldUndoManager;
import Camera;
import OpenGLUtilities;
import ResourceManager;
import PathingMap;
import SkinnedMesh;
import SkeletalModelInstance;
import Globals;
import MapGlobal;
import <glad/glad.h>;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;
import <glm/gtc/quaternion.hpp>;

DoodadBrush::DoodadBrush() : Brush() {
	position_granularity = 2.f;
	size_granularity = 2;
	center_on_tile_corner = false;

	click_helper = resource_manager.load<SkinnedMesh>("Objects/InvalidObject/InvalidObject.mdx", "", std::nullopt);
	click_helper_skeleton = SkeletalModelInstance(click_helper->mdx);
}

/// Gets a random variation from the possible_variation list
int DoodadBrush::get_random_variation() {
	if (possible_variations.size() == 0) {
		return 0;
	}

	std::mt19937 rng;
	rng.seed(std::random_device()());
	std::uniform_int_distribution<std::mt19937::result_type> dist(0, possible_variations.size() - 1);

	auto it = possible_variations.begin();
	std::advance(it, dist(rng));
	return *it;
}

glm::vec2 DoodadBrush::get_position() const {
	return Doodad::acceptable_position(glm::vec2(input_handler.mouse_world), doodad.pathing, doodad.angle);
}

void DoodadBrush::set_shape(const Shape new_shape) {
	context->makeCurrent();
	shape = new_shape;

	glDeleteTextures(1, &brush_texture);
	glCreateTextures(GL_TEXTURE_2D, 1, &brush_texture);
	glTextureParameteri(brush_texture, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTextureParameteri(brush_texture, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTextureParameteri(brush_texture, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTextureParameteri(brush_texture, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	if (doodad.pathing) {
		// 270 instead of 90 because OpenGL upside down shenanigans
		const int32_t rotation = static_cast<int>(glm::degrees(doodad.angle)) + 270;

		const int div_w = (rotation % 180) ? doodad.pathing->height : doodad.pathing->width;
		const int div_h = (rotation % 180) ? doodad.pathing->width : doodad.pathing->height;

		std::vector<glm::u8vec4> brush(div_w * div_h, {0, 0, 0, 0});

		for (int i = 0; i < doodad.pathing->width; i++) {
			for (int j = 0; j < doodad.pathing->height; j++) {
				int x = i;
				int y = j;

				switch (rotation % 360) {
					case 90:
						x = doodad.pathing->height - 1 - j;
						y = i;
						break;
					case 180:
						x = doodad.pathing->width - 1 - i;
						y = doodad.pathing->height - 1 - j;
						break;
					case 270:
						x = j;
						y = doodad.pathing->width - 1 - i;
						break;
				}

				const int in = ((doodad.pathing->height - 1 - j) * doodad.pathing->width + i) * doodad.pathing->channels;

				// Have to check for > 250 because sometimes the pathing textures are not properly thresholded
				const glm::u8vec4 color = {
					doodad.pathing->data[in] > 250 ? 255 : 0,
					doodad.pathing->data[in + 1] > 250 ? 255 : 0,
					doodad.pathing->data[in + 2] > 250 ? 255 : 0,
					128
				};

				if (color.r || color.g || color.b) {
					brush[y * div_w + x] = color;
				}
			}
		}
		glTextureStorage2D(brush_texture, 1, GL_RGBA8, div_w, div_h);
		glTextureSubImage2D(brush_texture, 0, 0, 0, div_w, div_h, GL_RGBA, GL_UNSIGNED_BYTE, brush.data());
	} else {
		const std::vector<glm::u8vec4> brush(size.x * size.y, {0, 0, 0, 0});
		glTextureStorage2D(brush_texture, 1, GL_RGBA8, size.x, size.y);
		glTextureSubImage2D(brush_texture, 0, 0, 0, size.x, size.y, GL_RGBA, GL_UNSIGNED_BYTE, brush.data());
	}
}

void DoodadBrush::key_press_event(QKeyEvent* event) {
	if (event->modifiers() & Qt::KeypadModifier) {
		if (action == Action::none) {
			start_action(Action::move);
		}

		const bool left = event->key() == Qt::Key_1 || event->key() == Qt::Key_4 || event->key() == Qt::Key_7;
		const bool right = event->key() == Qt::Key_3 || event->key() == Qt::Key_6 || event->key() == Qt::Key_9;
		const bool down = event->key() == Qt::Key_7 || event->key() == Qt::Key_8 || event->key() == Qt::Key_9;
		const bool up = event->key() == Qt::Key_1 || event->key() == Qt::Key_2 || event->key() == Qt::Key_3;

		bool free_movement = true;
		for (const auto& i : selections) {
			free_movement = free_movement && !i->pathing;
		}

		float x_displacement;
		float y_displacement;
		if (free_movement) {
			x_displacement = -0.25f * left + 0.25f * right;
			y_displacement = -0.25f * up + 0.25f * down;
		} else {
			x_displacement = -0.5f * left + 0.5f * right;
			y_displacement = -0.5f * up + 0.5f * down;
		}

		const QRect pre_action_area = map->doodads.get_pathing_bounding_box(selections);
		for (const auto& i : selections) {
			i->position.x += x_displacement;
			i->position.y += y_displacement;
			if (!lock_doodad_z) {
				i->position.z = map->terrain.interpolated_height(i->position.x, i->position.y, true);
			}
			i->update(map->terrain);
		}
		emit position_changed();

		map->doodads.update_doodad_pathing(pre_action_area, map->pathing_map);
	}

	if (event->modifiers() & Qt::ControlModifier) {
		switch (event->key()) {
			case Qt::Key_A:
				selections.clear();
				selections.reserve(map->doodads.doodads.size());
				for (auto& i : map->doodads.doodads) {
					selections.emplace(&i);
				}

				emit selection_changed();
				break;
			case Qt::Key_PageUp:
				if (action == Action::none) {
					start_action(Action::move);
				}
				for (const auto& i : selections) {
					i->position.z += 0.1f;
					i->update(map->terrain);
				}
				emit position_changed();
				break;
			case Qt::Key_PageDown:
				if (action == Action::none) {
					start_action(Action::move);
				}
				for (const auto& i : selections) {
					i->position.z -= 0.1f;
					i->update(map->terrain);
				}
				emit position_changed();
				break;
			default:
				Brush::key_press_event(event);
		}
	} else {
		switch (event->key()) {
			case Qt::Key_PageUp:
				if (action == Action::none) {
					start_action(Action::move);
				}
				for (const auto& i : selections) {
					i->scale.z += 0.1f;
					i->update(map->terrain);
				}
				emit scale_changed();
				break;
			case Qt::Key_PageDown:
				if (action == Action::none) {
					start_action(Action::move);
				}
				for (const auto& i : selections) {
					i->scale.z -= 0.1f;
					i->update(map->terrain);
				}
				emit scale_changed();
				break;
			default:
				Brush::key_press_event(event);
		}
	}
}

void DoodadBrush::key_release_event(QKeyEvent* event) {
	if (event->isAutoRepeat()) {
		return;
	}

	if (action == Action::move) {
		end_action();
	}
}

void DoodadBrush::mouse_press_event(QMouseEvent* event, double frame_delta) {
	// The mouse.y check is needed as sometimes it is negative for unknown reasons
	if (event->button() == Qt::LeftButton && input_handler.mouse.y > 0.f) {
		if (mode == Mode::selection) {
			if (event->modifiers() & Qt::KeyboardModifier::ShiftModifier) {
				auto id = map->render_manager.pick_doodad_id_under_mouse(map->doodads, input_handler.mouse);
				if (id) {
					if (selections.contains(&map->doodads.doodads[id.value()])) {
						selections.erase(&map->doodads.doodads[id.value()]);
					} else {
						selections.emplace(&map->doodads.doodads[id.value()]);
					}
					return;
				}
			}

			if (!event->modifiers()) {
				auto id = map->render_manager.pick_doodad_id_under_mouse(map->doodads, input_handler.mouse);
				if (id) {
					Doodad& doodad = map->doodads.doodads[id.value()];

					drag_start = input_handler.mouse_world;
					dragging = true;

					// If the current index is already in a selection then we want to drag the entire group
					if (std::ranges::find(selections, &doodad) != selections.end()) {
						drag_offsets.clear();
						for (const auto& i : selections) {
							drag_offsets.push_back(input_handler.mouse_world - i->position);
						}
					} else {
						selections = {&doodad};
						drag_offsets = {input_handler.mouse_world - doodad.position};
						emit selection_changed();
					}
					return;
				}
			}
		}
	}
	if (event->button() == Qt::MiddleButton && input_handler.mouse.y > 0.f) {
		auto id = map->render_manager.pick_doodad_id_under_mouse(map->doodads, input_handler.mouse);

		if (id) {
			Doodad& doodad = map->doodads.doodads[id.value()];
			emit request_doodad_select(doodad.id);
		}
	}
	Brush::mouse_press_event(event, frame_delta);
}

void DoodadBrush::mouse_move_event(QMouseEvent* event, double frame_delta) {
	Brush::mouse_move_event(event, frame_delta);

	if (event->buttons() == Qt::LeftButton) {
		if (mode == Mode::selection) {
			if (dragging) {
				if (action == Action::none) {
					start_action(Action::drag);
				}

				bool free_movement = true;
				for (const auto& i : selections) {
					free_movement = free_movement && !i->pathing;
				}

				glm::vec3 offset;
				if (free_movement) {
					offset = input_handler.mouse_world - drag_start;
				} else {
					offset = glm::round((input_handler.mouse_world) * 2.f + 0.5f) / 2.f - 0.25f;
					offset -= glm::round((drag_start) * 2.f + 0.5f) / 2.f - 0.25f;
				}
				offset.z = 0;

				if (!free_movement && offset.x == 0.f && offset.y == 0.f) {
					return;
				}
				drag_start = input_handler.mouse_world;

				const QRect pre_action_area = map->doodads.get_pathing_bounding_box(selections);
				for (const auto& doodad : selections) {
					doodad->position += offset;
					if (!lock_doodad_z) {
						doodad->position.z = map->terrain.interpolated_height(doodad->position.x, doodad->position.y, true);
					}
					doodad->update(map->terrain);
				}
				emit position_changed();
				map->doodads.update_doodad_pathing(pre_action_area, map->pathing_map);
			} else if (event->modifiers() & Qt::ControlModifier) {
				if (action == Action::none) {
					start_action(Action::rotate);
				}

				const QRect pre_action_area = map->doodads.get_pathing_bounding_box(selections);
				for (auto&& i : selections) {
					float target_rotation =
						std::atan2(input_handler.mouse_world.y - i->position.y, input_handler.mouse_world.x - i->position.x);
					if (target_rotation < 0) {
						target_rotation += 2.f * glm::pi<float>();
					}

					i->angle = Doodad::acceptable_angle(i->id, i->pathing, i->angle, target_rotation);
					i->position = glm::vec3(Doodad::acceptable_position(i->position, i->pathing, i->angle), i->position.z);
					i->update(map->terrain);
				}
				emit angle_changed();
				map->doodads.update_doodad_pathing(pre_action_area, map->pathing_map);
			} else if (mode == Mode::selection && selection_started) {
				const glm::vec3 size = input_handler.mouse_world - selection_start;

				auto query = map->doodads.query_area({selection_start.x, selection_start.y, size.x, size.y});
				if (event->modifiers() & Qt::KeyboardModifier::ShiftModifier) {
					selections.insert(query.begin(), query.end());
				} else if (event->modifiers() & Qt::KeyboardModifier::AltModifier) {
					for (const auto& i : query) {
						selections.erase(i);
					}
				} else {
					selections.clear();
					selections.insert(query.begin(), query.end());
				}

				emit selection_changed();
			}
		}
	}
}

void DoodadBrush::mouse_release_event(QMouseEvent* event) {
	dragging = false;

	if (event->button() == Qt::LeftButton) {
		if (action == Action::drag || action == Action::rotate) {
			end_action();
		}
	}

	Brush::mouse_release_event(event);
}

void DoodadBrush::delete_selection() {
	if (!selections.size()) {
		return;
	}

	// Undo/redo
	auto action = std::make_unique<DoodadDeleteAction>();
	map->world_undo.new_undo_group();
	map->world_undo.add_undo_action(std::move(action));

	const QRect pre_action_area = map->doodads.get_pathing_bounding_box(selections);
	map->doodads.remove_doodads(selections);
	map->doodads.update_doodad_pathing(pre_action_area, map->pathing_map);

	selections.clear();
	emit selection_changed();
}

void DoodadBrush::copy_selection() {
	clipboard.clear();

	// Mouse position is average location
	clipboard_force_grid_aligned = false;
	glm::vec3 average_position = {};
	for (const auto& i : selections) {
		if (i->pathing) {
			clipboard_force_grid_aligned = true;
		}
		clipboard.push_back(*i);
		average_position += i->position;
	}
	clipboard_mouse_offset = average_position / static_cast<float>(clipboard.size());
}

void DoodadBrush::cut_selection() {
	copy_selection();
	// Delete selection will add to the undo/redo tree
	delete_selection();
}

void DoodadBrush::clear_selection() {
	selections.clear();
	emit selection_changed();
}

void DoodadBrush::place_clipboard() {
	apply_begin();
	for (const auto& i : clipboard) {
		Doodad& new_doodad = map->doodads.add_doodad(i);
		new_doodad.creation_number = ++Doodad::auto_increment;

		glm::vec3 final_position = glm::vec3(
			Doodad::acceptable_position(
				glm::vec2(input_handler.mouse_world) + glm::vec2(i.position) - clipboard_mouse_offset,
				i.pathing,
				i.angle
			),
			i.position.z
		);
		if (!lock_doodad_z) {
			final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y, true);
		}

		new_doodad.position = final_position;
		new_doodad.update(map->terrain);
		doodad_undo->doodads.push_back(new_doodad);

		if (new_doodad.pathing) {
			map->pathing_map.blit_pathing_texture(new_doodad.position, glm::degrees(new_doodad.angle) + 90, new_doodad.pathing);
		}
	}
	map->pathing_map.upload_dynamic_pathing();
	apply_end();
}

void DoodadBrush::apply_begin() {
	doodad_undo = std::make_unique<DoodadAddAction>();
}

void DoodadBrush::apply(double frame_delta) {
	if (doodad.id == "") {
		return;
	}

	doodad.creation_number = ++Doodad::auto_increment;
	map->doodads.add_doodad(doodad);

	doodad_undo->doodads.push_back(doodad);

	if (doodad.pathing) {
		map->pathing_map.blit_pathing_texture(doodad.position, glm::degrees(doodad.angle) + 90, doodad.pathing);
		map->pathing_map.upload_dynamic_pathing();
	}

	if (random_rotation) {
		set_random_rotation();
		set_shape(shape);
	}

	if (random_variation) {
		set_random_variation();
	}

	if (random_scale) {
		std::random_device rd;
		std::mt19937 gen(rd());

		const bool is_doodad = doodads_slk.row_headers.contains(doodad.id);
		const slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;

		const float min_scale = slk.data<float>("minscale", doodad.id);
		const float max_scale = slk.data<float>("maxscale", doodad.id);
		std::uniform_real_distribution dist(min_scale, max_scale);
		doodad.scale = glm::vec3(dist(gen));
	}
}

void DoodadBrush::apply_end() {
	if (doodad_undo->doodads.empty()) {
		return;
	}
	map->world_undo.new_undo_group();
	map->world_undo.add_undo_action(std::move(doodad_undo));
}

void DoodadBrush::render_brush() {
	if (doodad.pathing) {
		Brush::render_brush();
	}

	if (!doodad.mesh) {
		return;
	}

	glm::vec3 final_position = glm::vec3(Doodad::acceptable_position(input_handler.mouse_world, doodad.pathing, doodad.angle), 0.f);
	final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y, false);

	doodad.position = final_position;
	doodad.update(map->terrain);
	doodad.skeleton.update(0.016f);
	map->render_manager.queue_render(*doodad.mesh, doodad.skeleton, doodad.color, 0);

	const bool is_doodad = doodads_slk.row_headers.contains(doodad.id);
	const slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;
	const bool use_click_helper = slk.data<bool>("useclickhelper", doodad.id);
	if (use_click_helper) {
		click_helper_skeleton.matrix = doodad.skeleton.matrix;
		click_helper_skeleton.update(0.016f);
		map->render_manager.queue_render(*click_helper, click_helper_skeleton, glm::vec3(1.f), 0);
	}
}

// Quads are drawn and then in the fragment shader fragments are discarded to form a circle
void DoodadBrush::render_selection() const {
	glDisable(GL_DEPTH_TEST);
	selection_circle_shader->use();
	glEnableVertexAttribArray(0);

	for (const auto& i : selections) {
		float selection_scale = 1.f;
		if (i->mesh->mdx->sequences.empty()) {
			selection_scale = i->mesh->mdx->extent.bounds_radius / 128.f;
		} else {
			selection_scale = i->mesh->mdx->sequences[i->skeleton.sequence_index].extent.bounds_radius / 128.f;
		}

		const bool is_doodad = doodads_slk.row_headers.contains(i->id);
		const slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;
		const bool use_click_helper = slk.data<bool>("useclickhelper", i->id);

		if (use_click_helper) {
			selection_scale = std::max(selection_scale, click_helper->mdx->extent.bounds_radius / 128.f);
		}
		if (selection_scale < 0.1f) { // Todo hack, what is the correct approach?
			selection_scale = i->mesh->mdx->extent.bounds_radius / 128.f;
		}

		glm::mat4 model(1.f);
		model = glm::translate(model, i->position - glm::vec3(selection_scale * 0.5f, selection_scale * 0.5f, 0.f));
		model = glm::scale(model, glm::vec3(selection_scale));

		model = camera.projection_view * model;
		glUniformMatrix4fv(1, 1, GL_FALSE, &model[0][0]);

		glBindBuffer(GL_ARRAY_BUFFER, shapes.vertex_buffer);
		glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, shapes.index_buffer);
		glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
	}

	glDisableVertexAttribArray(0);
	glEnable(GL_DEPTH_TEST);
}

void DoodadBrush::render_clipboard() {
	for (auto& i : clipboard) {
		glm::vec3 final_position = glm::vec3(
			Doodad::acceptable_position(
				glm::vec2(input_handler.mouse_world) + glm::vec2(i.position) - clipboard_mouse_offset,
				i.pathing,
				i.angle,
				clipboard_force_grid_aligned
			),
			i.position.z
		);

		if (!lock_doodad_z) {
			final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y, true);
		}

		const auto previous_position = i.position;
		i.position = final_position;
		i.update(map->terrain);
		i.skeleton.update(0.016f);
		i.position = previous_position;

		map->render_manager.queue_render(*i.mesh, i.skeleton, glm::vec3(1.f), 0);
	}
}

bool DoodadBrush::can_place() {
	if (!doodad.pathing) {
		return true;
	}

	return map->pathing_map.is_area_free(
		doodad.position,
		glm::degrees(doodad.angle) + 90,
		doodad.pathing,
		PathingMap::Flags::unwalkable | PathingMap::Flags::unflyable | PathingMap::Flags::unbuildable
	);
}

void DoodadBrush::set_random_variation() {
	variation = get_random_variation();
	context->makeCurrent();
	doodad.init(doodad.id, map->doodads.get_mesh(doodad.id, variation), map->terrain);
}

void DoodadBrush::set_random_rotation() {
	std::random_device rd;
	std::mt19937 gen(rd());

	std::uniform_real_distribution dist(0.f, glm::pi<float>() * 2.f);
	const float target_rotation = dist(gen);
	doodad.angle = Doodad::acceptable_angle(doodad.id, doodad.pathing, target_rotation, target_rotation);
	doodad.update(map->terrain);
}

void DoodadBrush::add_variation(int variation) {
	possible_variations.insert(variation);
}

void DoodadBrush::erase_variation(int variation) {
	possible_variations.erase(variation);
	if (this->variation == variation) {
		this->variation = get_random_variation();
	}
}

void DoodadBrush::set_doodad(const std::string& id) {
	context->makeCurrent();

	const bool is_doodad = doodads_slk.row_headers.contains(id);
	const slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;

	possible_variations.clear();
	int variation_count = slk.data<int>("numvar", id);
	for (int i = 0; i < variation_count; i++) {
		possible_variations.insert(i);
	}
	variation = get_random_variation();

	doodad.init(id, map->doodads.get_mesh(id, variation), map->terrain);

	// It might be initially incorrect because another doodad.angle is not reset in init()
	doodad.angle = Doodad::acceptable_angle(doodad.id, doodad.pathing, doodad.angle, doodad.angle);
	if (random_rotation) {
		set_random_rotation();
	}

	// Same as above for the scale
	const float min_scale = slk.data<float>("minscale", doodad.id);
	const float max_scale = slk.data<float>("maxscale", doodad.id);
	doodad.scale = glm::clamp(doodad.scale, min_scale, max_scale);
	if (random_scale) {
		std::random_device rd;
		std::mt19937 gen(rd());
		std::uniform_real_distribution dist(min_scale, max_scale);
		doodad.scale = glm::vec3(dist(gen));
	}

	if (doodad.pathing) {
		const QRect aabb = doodad.get_pathing_bounding_box();
		set_size(glm::ivec2(aabb.width() / size_granularity, aabb.height() / size_granularity));
	}
	set_shape(shape);
}

void DoodadBrush::start_action(const Action new_action) {
	action = new_action;
	map->world_undo.new_undo_group();
	doodad_state_undo = std::make_unique<DoodadStateAction>();
	for (const auto& i : selections) {
		doodad_state_undo->old_doodads.push_back(*i);
	}
}

void DoodadBrush::end_action() {
	for (const auto& i : selections) {
		doodad_state_undo->new_doodads.push_back(*i);
	}
	map->world_undo.add_undo_action(std::move(doodad_state_undo));
	action = Action::none;
}

void DoodadBrush::set_selection_angle(const float angle) {
	start_action(Action::rotate);
	for (auto& i : selections) {
		i->angle = Doodad::acceptable_angle(i->id, i->pathing, i->angle, angle);
		i->position = glm::vec3(Doodad::acceptable_position(i->position, i->pathing, i->angle), i->position.z);
		i->update(map->terrain);
	}
	map->doodads.update_doodad_pathing(selections, map->pathing_map);
	end_action();
}

void DoodadBrush::set_selection_absolute_height(const float height) {
	start_action(Action::move);
	for (auto& i : selections) {
		i->position.z = height;
		i->update(map->terrain);
	}
	end_action();
}

void DoodadBrush::set_selection_relative_height(const float height) {
	start_action(Action::move);
	for (auto& i : selections) {
		i->position.z = map->terrain.interpolated_height(i->position.x, i->position.y, true) + height;
		i->update(map->terrain);
	}
	end_action();
}

void DoodadBrush::set_selection_scale_component(const int component, const float scale) {
	start_action(Action::scale);
	for (auto& i : selections) {
		bool is_doodad = doodads_slk.row_headers.contains(i->id);
		slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;

		float min_scale = slk.data<float>("minscale", i->id);
		float max_scale = slk.data<float>("maxscale", i->id);

		if (!is_doodad) {
			i->scale = glm::vec3(std::clamp(scale, min_scale, max_scale));
		} else {
			i->scale[component] = std::clamp(scale, min_scale, max_scale);
		}
		i->update(map->terrain);
	}
	end_action();
}

void DoodadBrush::unselect_id(const std::string_view id) {
	if (doodad.id == id) {
		set_doodad("ATtr");
	}
}

```

`src/brush/doodad_brush.h`:

```h
#pragma once

#include <QObject>

#include <set>
#include <unordered_set>
#include <string>
#include <vector>
#include <memory>
#include "brush.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

import PathingTexture;
import DoodadsUndo;
import Doodad;
import SkinnedMesh;
import SkeletalModelInstance;

class DoodadBrush : public Brush {
	Q_OBJECT

	std::set<int> possible_variations = { 0 };
	int get_random_variation();

	int variation = 0;

	Doodad doodad;
	std::shared_ptr<SkinnedMesh> click_helper;
	SkeletalModelInstance click_helper_skeleton;

  public:
	Doodad::State state = Doodad::State::visible_solid;

	bool random_variation = true;
	bool random_scale = true;
	bool random_rotation = true;

	bool select_doodads = true;
	bool select_destructibles = true;

	bool lock_doodad_z = false;

	std::unique_ptr<DoodadAddAction> doodad_undo;
	std::unique_ptr<DoodadStateAction> doodad_state_undo;

	std::unordered_set<Doodad*> selections;

	glm::vec2 clipboard_mouse_offset;
	std::vector<Doodad> clipboard;
	bool clipboard_force_grid_aligned = false;

	bool dragging = false;
	bool dragged = false;
	glm::vec3 drag_start;
	std::vector<glm::vec2> drag_offsets;

	enum class Action {
		none,
		drag,
		move,
		rotate,
		scale
	};

	Action action = Action::none;

	DoodadBrush();

	glm::vec2 get_position() const override;

	void set_shape(const Shape new_shape) override;

	void key_press_event(QKeyEvent* event) override;
	void key_release_event(QKeyEvent* event) override;
	void mouse_press_event(QMouseEvent* event, double frame_delta) override;
	void mouse_move_event(QMouseEvent* event, double frame_delta) override;
	void mouse_release_event(QMouseEvent* event) override;

	void delete_selection() override;
	void copy_selection() override;
	void cut_selection() override;
	void clear_selection() override;
	void place_clipboard() override;

	void apply_begin() override;
	void apply(double frame_delta) override;
	void apply_end() override;
	void render_brush() override;
	void render_selection() const override;
	void render_clipboard() override;

	bool can_place() override;

	void set_random_rotation();
	void set_random_variation();
	void add_variation(int variation);
	void erase_variation(int variation);

	void set_doodad(const std::string& id);

	void start_action(Action new_action);
	void end_action();

public slots:
	// Angle in radians
	void set_selection_angle(float angle);
	void set_selection_absolute_height(float height);
	void set_selection_relative_height(float height);
	void set_selection_scale_component(int component, float scale);

	void unselect_id(std::string_view id) override;

signals:
	void angle_changed();
	void scale_changed();
	void position_changed();
	void request_doodad_select(std::string id);
};
```

`src/brush/pathing_brush.cpp`:

```cpp
#include "pathing_brush.h"

#include <QRect>

import std;
import <glm/glm.hpp>;
import MapGlobal;
import PathingUndo;
import Camera;

PathingBrush::PathingBrush() : Brush() {
	position_granularity = 4.f;
	size_granularity = 1;
	center_on_tile_corner = false;
}

void PathingBrush::apply_begin() {
	const glm::ivec2 pos = glm::vec2(input_handler.mouse_world) * 4.f - size.x / 2.f + 0.5f;
	const int x = pos.x;
	const int y = pos.y;

	applied_area = QRect(x, y, size.x, size.y).intersected({ 0, 0, map->pathing_map.width, map->pathing_map.height });

	map->world_undo.new_undo_group();
	old_pathing_cells_static = map->pathing_map.pathing_cells_static;
}

void PathingBrush::apply(double frame_delta) {
	const glm::ivec2 pos = glm::vec2(input_handler.mouse_world) * 4.f - size.x / 2.f + 0.5f;
	const QRect area = QRect(pos.x, pos.y, size.x, size.y).intersected({ 0, 0, map->pathing_map.width, map->pathing_map.height });
	
	if (area.width() <= 0 || area.height() <= 0) {
		return;
	}

	const int offset = area.y() * map->pathing_map.width + area.x();

	for (int i = 0; i < area.width(); i++) {
		for (int j = 0; j < area.height(); j++) {
			if (!contains(glm::ivec2(i - std::min(pos.x, 0), j - std::min(pos.y, 0)))) {
				continue;
			}

			const int index = offset + j * map->pathing_map.width + i;
			switch (operation) {
				case Operation::replace:
					map->pathing_map.pathing_cells_static[index] &= ~0b00001110;
					map->pathing_map.pathing_cells_static[index] |= brush_mask;
					break;
				case Operation::add:
					map->pathing_map.pathing_cells_static[index] |= brush_mask;
					break;
				case Operation::remove:
					map->pathing_map.pathing_cells_static[index] &= ~brush_mask;
					break;
			}
		}
	}

	applied_area = applied_area.united(area);

	map->pathing_map.upload_static_pathing();
}

void PathingBrush::apply_end() {
	add_pathing_undo(applied_area);
}

void PathingBrush::add_pathing_undo(const QRect& area) {
	auto undo_action = std::make_unique<PathingMapAction>();

	undo_action->area = area;
	const auto width = map->pathing_map.width;

	// Copy old corners
	undo_action->old_pathing.reserve(area.width() * area.height());
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			undo_action->old_pathing.push_back(old_pathing_cells_static[j * width + i]);
		}
	}

	// Copy new corners
	undo_action->new_pathing.reserve(area.width() * area.height());
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			undo_action->new_pathing.push_back(map->pathing_map.pathing_cells_static[j * width + i]);
		}
	}

	map->world_undo.add_undo_action(std::move(undo_action));
}
```

`src/brush/pathing_brush.h`:

```h
#pragma once

#include <QRect>

#include <cstdint>
#include <vector>

#include "brush.h"

class PathingBrush : public Brush {
public:
	enum class Operation {
		replace,
		add,
		remove
	};

	uint8_t brush_mask = 0b00000000;

	Operation operation = Operation::replace;

	QRect applied_area;

	PathingBrush();

	void apply_begin() override;
	void apply(double frame_delta) override;
	void apply_end() override;

	void add_pathing_undo(const QRect& area);

private:
	std::vector<uint8_t> old_pathing_cells_static;
};
```

`src/brush/terrain_brush.cpp`:

```cpp
#include "terrain_brush.h"

import std;
import MapGlobal;
import Terrain;
import DoodadsUndo;
import PathingUndo;
import TerrainUndo;
import Camera;

TerrainBrush::TerrainBrush() : Brush() {
	position_granularity = 1.f;
	size_granularity = 4;
	center_on_tile_corner = true;

	set_size(size);
}

void TerrainBrush::mouse_press_event(QMouseEvent* event, double frame_delta) {
	//if (event->button() == Qt::LeftButton && mode == Mode::selection && !event->modifiers() && input_handler.mouse.y > 0.f) {
		/*auto id = map->render_manager.pick_unit_id_under_mouse(map->units, input_handler.mouse);
		if (id) {
			Unit& unit = map->units.units[id.value()];
			selections = { &unit };
			dragging = true;
			drag_x_offset = input_handler.mouse_world.x - unit.position.x;
			drag_y_offset = input_handler.mouse_world.y - unit.position.y;
			return;
		}*/
	//}

	Brush::mouse_press_event(event, frame_delta);
}

void TerrainBrush::mouse_move_event(QMouseEvent* event, double frame_delta) {
	Brush::mouse_move_event(event, frame_delta);

	/*if (event->buttons() == Qt::LeftButton) {
		if (mode == Mode::selection) {
			if (dragging) {
				if (!dragged) {
					dragged = true;
					map->terrain_undo.new_undo_group();
					unit_state_undo = std::make_unique<UnitStateAction>();
					for (const auto& i : selections) {
						unit_state_undo->old_units.push_back(*i);
					}
				}
				for (auto& i : selections) {
					i->position.x = input_handler.mouse_world.x - drag_x_offset;
					i->position.y = input_handler.mouse_world.y - drag_y_offset;
					i->position.z = map->terrain.interpolated_height(i->position.x, i->position.y);
					i->update();
				}
			} else if (event->modifiers() & Qt::ControlModifier) {
				for (auto&& i : selections) {
					float target_rotation = std::atan2(input_handler.mouse_world.y - i->position.y, input_handler.mouse_world.x - i->position.x);
					if (target_rotation < 0) {
						target_rotation = (glm::pi<float>() + target_rotation) + glm::pi<float>();
					}

					i->angle = target_rotation;
					i->update();
				}
			} else if (selection_started) {
				const glm::vec2 size = glm::vec2(input_handler.mouse_world) - selection_start;
				selections = map->units.query_area({ selection_start.x, selection_start.y, size.x, size.y });
			}
		}
	}*/
}

void TerrainBrush::mouse_release_event(QMouseEvent* event) {
	//dragging = false;
	//if (dragged) {
	//	dragged = false;
	//	for (const auto& i : selections) {
	//		unit_state_undo->new_units.push_back(*i);
	//	}
	//	map->terrain_undo.add_undo_action(std::move(unit_state_undo));
	//}

	Brush::mouse_release_event(event);
}

// Make this an iterative function instead to avoid stack overflows
void TerrainBrush::check_nearby(const int begx, const int begy, const int i, const int j, QRect& area) const {
	QRect bounds = QRect(i - 1, j - 1, 3, 3).intersected({ 0, 0, map->terrain.width, map->terrain.height });

	for (int k = bounds.x(); k <= bounds.right(); k++) {
		for (int l = bounds.y(); l <= bounds.bottom(); l++) {
			if (k == 0 && l == 0) {
				continue;
			}

			int difference = map->terrain.corners[i][j].layer_height - map->terrain.corners[k][l].layer_height;
			if (std::abs(difference) > 2 && !contains(glm::ivec2(begx + (k - i), begy + (l - k)))) {
				map->terrain.corners[k][l].layer_height = map->terrain.corners[i][j].layer_height - std::clamp(difference, -2, 2);
				map->terrain.corners[k][l].ramp = false;

				area.setX(std::min(area.x(), k - 1));
				area.setY(std::min(area.y(), l - 1));
				area.setRight(std::max(area.right(), k));
				area.setBottom(std::max(area.bottom(), l));

				check_nearby(begx, begy, k, l, area);
			}
		}
	}
};

void TerrainBrush::apply_begin() {
	int width = map->terrain.width;
	int height = map->terrain.height;
	const auto& corners = map->terrain.corners;

	const glm::vec2 position = get_position();
	const int x = position.x + 1;
	const int y = position.y + 1;
	const QRect area = QRect(x, y, size.x / 4.f, size.y / 4.f).intersected({ 0, 0, width, height });
	const int center_x = area.x() + area.width() * 0.5f;
	const int center_y = area.y() + area.height() * 0.5f;
	
	// Setup for undo/redo
	map->world_undo.new_undo_group();
	old_corners = map->terrain.corners;
	old_pathing_cells_static = map->pathing_map.pathing_cells_static;
	texture_height_area = area;
	cliff_area = area;

	if (apply_height) {
		deformation_height = corners[center_x][center_y].height;
	}

	if (apply_cliff) {
		layer_height = corners[center_x][center_y].layer_height;
		switch (cliff_operation_type) {
			case cliff_operation::shallow_water:
				if (!corners[center_x][center_y].water) {
					layer_height -= 1;
				} else if (corners[center_x][center_y].final_water_height(map->terrain.water_offset) > corners[center_x][center_y].final_ground_height() + 1) {
					layer_height += 1;
				}
				break;
			case cliff_operation::lower1:
				layer_height -= 1;
				break;
			case cliff_operation::lower2:
				layer_height -= 2;
				break;
			case cliff_operation::deep_water:
				if (!corners[center_x][center_y].water) {
					layer_height -= 2;
				} else if (corners[center_x][center_y].final_water_height(map->terrain.water_offset) < corners[center_x][center_y].final_ground_height() + 1) {
					layer_height -= 1;
				}
				break;
			case cliff_operation::raise1:
				layer_height += 1;
				break;
			case cliff_operation::raise2:
				layer_height += 2;
				break;
			case cliff_operation::ramp:
				break;
			case cliff_operation::level:
				break;
		}
		layer_height = std::clamp(layer_height, 0, 15);
	}
}

void TerrainBrush::apply(double frame_delta) {
	int width = map->terrain.width;
	int height = map->terrain.height;
	auto& corners = map->terrain.corners;

	const glm::ivec2 pos = glm::vec2(input_handler.mouse_world) - size.x / 4.f / 2.f + 1.f;

	const glm::vec2 position = get_position();
	QRect area = QRect(pos.x, pos.y, size.x / 4.f, size.y / 4.f).intersected({ 0, 0, width, height });

	if (area.width() <= 0 || area.height() <= 0) {
		return;
	}

	if (apply_texture) {
		const int id = map->terrain.ground_texture_to_id[tile_id];

		// Update textures
		for (int i = area.x(); i < area.x() + area.width(); i++) {
			for (int j = area.y(); j < area.y() + area.height(); j++) {
				if (!contains(glm::ivec2(i - area.x(), j - area.y()) - glm::min(glm::ivec2(position) + 1, 0))) {
					continue;
				}

				bool cliff_near = false;
				for (int k = -1; k < 1; k++) {
					for (int l = -1; l < 1; l++) {
						if (i + k >= 0 && i + k <= width && j + l >= 0 && j + l <= height) {
							cliff_near = cliff_near || corners[i + k][j + l].cliff;
						}
					}
				}

				if (id == map->terrain.blight_texture) {
					// Blight shouldn't be set when there is a cliff near
					if (cliff_near) {
						continue;
					}

					corners[i][j].blight = true;
				} else {
					corners[i][j].blight = false;
					corners[i][j].ground_texture = id;
					corners[i][j].ground_variation = get_random_variation();
				}
			}
		}

		map->terrain.update_ground_textures(area);
		texture_height_area = texture_height_area.united(area);
	}

	if (apply_height) {
		std::vector<std::vector<float>> heights(area.width(), std::vector<float>(area.height()));

		for (int i = area.x(); i < area.x() + area.width(); i++) {
			for (int j = area.y(); j < area.y() + area.height(); j++) {
				float new_height = corners[i][j].height;
				heights[i - area.x()][j - area.y()] = new_height;

				if (!contains(glm::ivec2(i - area.x(), j - area.y()) - glm::min(glm::ivec2(position) + 1, 0))) {
					continue;
				}
				const int center_x = area.x() + area.width() * 0.5f;
				const int center_y = area.y() + area.height() * 0.5f;

				switch (deformation_type) {
					case deformation::raise: {
						auto distance = std::sqrt(std::pow(center_x - i, 2) + std::pow(center_y - j, 2));
						new_height += std::max(0.0, 1 - distance / size.x * std::sqrt(2)) * frame_delta;
						break;
					}
					case deformation::lower: {
						auto distance = std::sqrt(std::pow(center_x - i, 2) + std::pow(center_y - j, 2));
						new_height -= std::max(0.0, 1 - distance / size.x * std::sqrt(2)) * frame_delta;
						break;
					}
					case deformation::plateau: {
						new_height = deformation_height;
						break;
					}
					case deformation::ripple:
						break;
					case deformation::smooth: {
						float accumulate = 0;

						QRect acum_area = QRect(i - 1, j - 1, 3, 3).intersected({0, 0, width, height});

						for (int k = acum_area.x(); k < acum_area.right() + 1; k++) {
							for (int l = acum_area.y(); l < acum_area.bottom() + 1; l++) {
								if ((k < i || l < j) && k <= i && 
									// The checks below are required because the code is just wrong (area is too small so we cant convolute a cell from at the edges of the area)
									k - area.x() >= 0 && l - area.y() >= 0 && k < area.right() + 1 && l < area.bottom() + 1) {
									accumulate += heights[k - area.x()][l - area.y()];
								} else {
									accumulate += corners[k][l].height;
								}
							}
						}
						accumulate -= new_height;
						new_height = 0.8 * new_height + 0.2 * (accumulate / (acum_area.width() * acum_area.height() - 1));
						break;
					}
				}

				corners[i][j].height = std::clamp(new_height, -16.f, 15.98f); // ToDo why 15.98?
			}
		}

		map->terrain.update_ground_heights(area);

		texture_height_area = texture_height_area.united(area);
	}

	QRect updated_area = QRect(pos.x - 1, pos.y - 1, size.x / 4.f + 1, size.y / 4.f + 1).intersected({ 0, 0, width - 1, height - 1 });

	if (apply_cliff) {
		
		//if (cliff_operation_type == cliff_operation::ramp) {
		//	const int center_x = area.x() + area.width() * 0.5f;
		//	const int center_y = area.y() + area.height() * 0.5f;

		//	glm::vec2 p = glm::vec2(input_handler.mouse_world) - get_position();

		//	int cliff_count = corners[center_x][center_y].cliff + corners[center_x - 1][center_y].cliff + corners[center_x][center_y - 1].cliff + corners[center_x - 1][center_y - 1].cliff;

		//	// Cliff count 1 and 4 are nothing

		//	if (cliff_count == 2 ) {
		//		corners[center_x][center_y].ramp = true;

		//		// possibly place a new ramp
		//	} else if (cliff_count == 3) {
		//		// Target for whole rampification
		//	}

		//	std::cout << cliff_count << "\n";

		//	if (corners[center_x - (p.x < 1)][center_y - (p.y < 1)].cliff) {
		//	//	corners[center_x][center_y].ramp = true;
		//	//	std::cout << "Ramp set\n";
		//	}

		//	//if (corners[center_x][center_y].cliff) {
		//	//	corners[i][j].ramp = true;
		//	//}
		//} else {
			for (int i = area.x(); i < area.x() + area.width(); i++) {
				for (int j = area.y(); j < area.y() + area.height(); j++) {
					if (!contains(glm::ivec2(i - area.x(), j - area.y()) - glm::min(glm::ivec2(position) + 1, 0))) {
						continue;
					}
					corners[i][j].ramp = false;
					corners[i][j].layer_height = layer_height;

					switch (cliff_operation_type) {
						case cliff_operation::lower1:
						case cliff_operation::lower2:
						case cliff_operation::level:
						case cliff_operation::raise1:
						case cliff_operation::raise2:
							if (corners[i][j].water) {
								if (enforce_water_height_limits && corners[i][j].final_water_height(map->terrain.water_offset) < corners[i][j].final_ground_height()) {
									corners[i][j].water = false;
								}
							}
							break;
						case cliff_operation::shallow_water:
							corners[i][j].water = true;
							corners[i][j].water_height = corners[i][j].layer_height - 1;
							break;
						case cliff_operation::deep_water:
							corners[i][j].water = true;
							corners[i][j].water_height = corners[i][j].layer_height;
							break;
						case cliff_operation::ramp:
							break;
					}

					check_nearby(pos.x, pos.y, i, j, updated_area);
				}
			}
		//}

		// Bounds check
		updated_area = updated_area.intersected({ 0, 0, width - 1, height - 1 });

		// Determine if cliff
		for (int i = updated_area.x(); i <= updated_area.right(); i++) {
			for (int j = updated_area.y(); j <= updated_area.bottom(); j++) {
				Corner& bottom_left = map->terrain.corners[i][j];
				Corner& bottom_right = map->terrain.corners[i + 1][j];
				Corner& top_left = map->terrain.corners[i][j + 1];
				Corner& top_right = map->terrain.corners[i + 1][j + 1];

				bottom_left.cliff = bottom_left.layer_height != bottom_right.layer_height
					|| bottom_left.layer_height != top_left.layer_height
					|| bottom_left.layer_height != top_right.layer_height;

				if (cliff_operation_type != cliff_operation::ramp) {
					bottom_left.cliff_texture = cliff_id;
				}
			}
		}

		QRect tile_area = updated_area.adjusted(-1, -1, 1, 1).intersected({ 0, 0, width - 1, height - 1 });

		map->terrain.update_cliff_meshes(tile_area);
		map->terrain.update_ground_textures(updated_area);
		map->terrain.update_ground_heights(updated_area.adjusted(0, 0, 1, 1));
		map->terrain.update_water(tile_area.adjusted(0, 0, 1, 1));

		cliff_area = cliff_area.united(updated_area);

		if (cliff_operation_type == cliff_operation::shallow_water || cliff_operation_type == cliff_operation::deep_water) {
			map->terrain.upload_water_heights();
		}
	}

	// Apply pathing
	for (int i = updated_area.x(); i <= updated_area.right(); i++) {
		for (int j = updated_area.y(); j <= updated_area.bottom(); j++) {
			Corner& bottom_left = map->terrain.corners[i][j];

			for (int k = 0; k < 4; k++) {
				for (int l = 0; l < 4; l++) {
					map->pathing_map.pathing_cells_static[(j * 4 + l) * map->pathing_map.width + i * 4 + k] &= ~0b01001110;

					uint8_t mask = 0;
					if ((bottom_left.cliff || bottom_left.romp) && !map->terrain.is_corner_ramp_entrance(i, j) && apply_cliff_pathing) {
						mask = 0b00001010;
					} 
					
					if (!bottom_left.cliff || (bottom_left.ramp && !bottom_left.romp)) {
						Corner& corner = map->terrain.corners[i + k / 2][j + l / 2];
						if (apply_tile_pathing) {
							const int id = corner.ground_texture;
							mask |= map->terrain.pathing_options[map->terrain.tileset_ids[id]].mask();
						}

						if (corner.water && apply_water_pathing) {
							mask |= 0b01000000;
							if (corner.final_water_height(map->terrain.water_offset) > corner.final_ground_height() + 0.40) {
								mask |= 0b00001010;
							} else if (corner.final_water_height(map->terrain.water_offset) > corner.final_ground_height()) {
								mask |= 0b00001000;
							}
						}
					}
					map->pathing_map.pathing_cells_static[(j * 4 + l) * map->pathing_map.width + i * 4 + k] |= mask;
				}
			}
		}
	}

	map->pathing_map.upload_static_pathing();

	if (apply_height || apply_cliff) {
		if (change_doodad_heights) {
			for (auto&& i : map->doodads.doodads) {
				if (area.contains(i.position.x, i.position.y)) {
					if (std::find_if(pre_change_doodads.begin(), pre_change_doodads.end(), [i](const Doodad& doodad) { return doodad.creation_number == i.creation_number; }) == pre_change_doodads.end()) {
						pre_change_doodads.push_back(i);
					}
					i.position.z = map->terrain.interpolated_height(i.position.x, i.position.y, true);
					i.update(map->terrain);
					post_change_doodads[i.creation_number] = i;
				}
			}
		}
		map->units.update_area(updated_area, map->terrain);
	}
}

void TerrainBrush::apply_end() {
	if (apply_texture) {
		add_terrain_undo(texture_height_area, TerrainUndoType::texture);
	}

	if (apply_height) {
		add_terrain_undo(texture_height_area, TerrainUndoType::height);
	}

	if (apply_cliff) {
		QRect cliff_areaa = cliff_area.adjusted(0, 0, 1, 1).intersected({ 0, 0, map->terrain.width, map->terrain.height });
		add_terrain_undo(cliff_areaa, TerrainUndoType::cliff);
	}

	if (change_doodad_heights) {
		auto undo = std::make_unique<DoodadStateAction>();
		undo->old_doodads = pre_change_doodads;
		for (const auto& [id, doodad] : post_change_doodads) {
			undo->new_doodads.push_back(doodad);
		}
		pre_change_doodads.clear();
		post_change_doodads.clear();
		map->world_undo.add_undo_action(std::move(undo));
	}

	QRect pathing_area = QRect(cliff_area.x() * 4, cliff_area.y() * 4, cliff_area.width() * 4, cliff_area.height() * 4).adjusted(-2, -2, 2, 2).intersected({ 0, 0, map->pathing_map.width, map->pathing_map.height });
	add_pathing_undo(pathing_area);

	map->terrain.update_minimap();
}

int TerrainBrush::get_random_variation() const {
	std::random_device rd;
	std::mt19937 e2(rd());
	std::uniform_int_distribution<> dist(0, 570);

	int nr = dist(e2) - 1;

	for (auto&&[variation, chance] : variation_chances) {
		if (nr < chance) {
			return variation;
		}
		nr -= chance;
	}
	assert("Didn't hit the list of tile variations");
	return 0;
}

/// Adds the undo to the current undo group
void TerrainBrush::add_terrain_undo(const QRect& area, TerrainUndoType type) {
	auto undo_action = std::make_unique<TerrainGenericAction>();

	undo_action->area = area;
	undo_action->undo_type = type;

	// Copy old corners
	undo_action->old_corners.reserve(area.width() * area.height());
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			undo_action->old_corners.push_back(old_corners[i][j]);
		}
	}

	// Copy new corners
	undo_action->new_corners.reserve(area.width() * area.height());
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			undo_action->new_corners.push_back(map->terrain.corners[i][j]);
		}
	}

	map->world_undo.add_undo_action(std::move(undo_action));
}

void TerrainBrush::add_pathing_undo(const QRect& area) {
	auto undo_action = std::make_unique<PathingMapAction>();

	undo_action->area = area;
	const auto width = map->pathing_map.width;

	// Copy old corners
	undo_action->old_pathing.reserve(area.width() * area.height());
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			undo_action->old_pathing.push_back(old_pathing_cells_static[j * width + i]);
		}
	}

	// Copy new corners
	undo_action->new_pathing.reserve(area.width() * area.height());
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			undo_action->new_pathing.push_back(map->pathing_map.pathing_cells_static[j * width + i]);
		}
	}

	map->world_undo.add_undo_action(std::move(undo_action));
}
```

`src/brush/terrain_brush.h`:

```h
#pragma once

#include <string>
#include <map>
#include <vector>

#include "brush.h"

import Doodad;
import Terrain;
import TerrainUndo;

class TerrainBrush : public Brush {
public:
	bool apply_texture = false;
	bool apply_height = false;
	bool apply_cliff = false;
	bool apply_tile_pathing = true;
	bool apply_cliff_pathing = true;
	bool apply_water_pathing = true;

	bool enforce_water_height_limits = true;
	bool change_doodad_heights = true;
	bool relative_cliff_heights = false;

	std::string tile_id;

	enum class deformation {
		raise,
		lower,
		plateau,
		ripple,
		smooth
	};
	deformation deformation_type = deformation::plateau;

	int cliff_id = 0;

	enum class cliff_operation {
		lower2,
		lower1,
		level,
		raise1,
		raise2,
		deep_water,
		shallow_water,
		ramp
	};
	cliff_operation cliff_operation_type = cliff_operation::level;

	bool dragging = false;
	bool dragged = false;

	TerrainBrush();

	void mouse_release_event(QMouseEvent* event) override;
	void mouse_press_event(QMouseEvent* event, double frame_delta) override;
	void mouse_move_event(QMouseEvent* event, double frame_delta) override;

	void check_nearby(int begx, int begy, int i, int j, QRect& area) const;

	void apply_begin() override;
	void apply(double frame_delta) override;
	void apply_end() override;

	int get_random_variation() const;

	void add_terrain_undo(const QRect& area, TerrainUndoType type);
	void add_pathing_undo(const QRect& area);

private:
	// Total sum 570
	const std::tuple<int, int> variation_chances[18] = {
		{ 0, 85 },
		{ 16, 85 },
		{ 0, 85 },
		{ 1, 10 },
		{ 2, 4 },
		{ 3, 1 },
		{ 4, 85 },
		{ 5, 10 },
		{ 6, 4 },
		{ 7, 1 },
		{ 8, 85 },
		{ 9, 10 },
		{ 10, 4 },
		{ 11, 1 },
		{ 12, 85 },
		{ 13, 10 },
		{ 14, 4 },
		{ 15, 1 }
	};

	int layer_height = 0;
	float deformation_height = 0.f;

	QRect texture_height_area;
	QRect cliff_area;
	std::vector<Doodad> pre_change_doodads;
	std::map<int, Doodad> post_change_doodads;

	std::vector<std::vector<Corner>> old_corners;
	std::vector<uint8_t> old_pathing_cells_static;
};
```

`src/brush/unit_brush.cpp`:

```cpp
#include "unit_brush.h"

#include <QKeyEvent>

import std;
import Hierarchy;
import Texture;
import WorldUndoManager;
import Camera;
import OpenGLUtilities;
import RenderManager;
import Globals;
import PathingMap;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;

import MapGlobal;

UnitBrush::UnitBrush() : Brush() {}

void UnitBrush::set_shape(const Shape new_shape) {}

void UnitBrush::key_press_event(QKeyEvent* event) {
	if (event->modifiers() & Qt::KeypadModifier) {
		if (!event->isAutoRepeat()) {
			map->world_undo.new_undo_group();
			unit_state_undo = std::make_unique<UnitStateAction>();
			for (const auto& i : selections) {
				unit_state_undo->old_units.push_back(*i);
			}
		}

		bool left = event->key() == Qt::Key_1 || event->key() == Qt::Key_4 || event->key() == Qt::Key_7;
		bool right = event->key() == Qt::Key_3 || event->key() == Qt::Key_6 || event->key() == Qt::Key_9;
		bool down = event->key() == Qt::Key_7 || event->key() == Qt::Key_8 || event->key() == Qt::Key_9;
		bool up = event->key() == Qt::Key_1 || event->key() == Qt::Key_2 || event->key() == Qt::Key_3;

		float x_displacement = -0.25f * left + 0.25f * right;
		float y_displacement = -0.25f * up + 0.25f * down;

		for (const auto& i : selections) {
			i->position.x += x_displacement;
			i->position.y += y_displacement;
			i->update();
		}
	}

	if (event->modifiers() & Qt::ControlModifier) {
		switch (event->key()) {
			case Qt::Key_A:
				selections.clear();
				selections.reserve(map->units.units.size());
				for (auto& i : map->units.units) {
					if (i.id == "sloc") {
						continue;
					}
					selections.emplace(&i);
				}
				emit selection_changed();
				break;
			default:
				Brush::key_press_event(event);
		}
	} else {
		Brush::key_press_event(event);
	}
}

void UnitBrush::key_release_event(QKeyEvent* event) {
	if (!event->isAutoRepeat()) {
		if (unit_state_undo) {
			for (const auto& i : selections) {
				unit_state_undo->new_units.push_back(*i);
			}
			map->world_undo.add_undo_action(std::move(unit_state_undo));
		}
	}
}

void UnitBrush::mouse_press_event(QMouseEvent* event, double frame_delta) {
	// The mouse.y check is needed as sometimes it is negative for unknown reasons
	if (event->button() == Qt::LeftButton && input_handler.mouse.y > 0.f) {
		if (mode == Mode::selection) {
			if (event->modifiers() & Qt::KeyboardModifier::ShiftModifier) {
				auto id = map->render_manager.pick_unit_id_under_mouse(map->units, input_handler.mouse);
				if (id) {
					if (selections.contains(&map->units.units[id.value()])) {
						selections.erase(&map->units.units[id.value()]);
					} else {
						selections.emplace(&map->units.units[id.value()]);
					}
					return;
				}
			}

			if (!event->modifiers()) {
				auto id = map->render_manager.pick_unit_id_under_mouse(map->units, input_handler.mouse);
				if (id) {
					Unit& unit = map->units.units[id.value()];

					drag_start = input_handler.mouse_world;
					dragging = true;

					// If the current index is already in a selection then we want to drag the entire group
					if (std::find(selections.begin(), selections.end(), &unit) != selections.end()) {
						drag_offsets.clear();
						for (const auto& i : selections) {
							drag_offsets.push_back(input_handler.mouse_world - i->position);
						}
					} else {
						selections = {&unit};
						drag_offsets = {input_handler.mouse_world - unit.position};
						emit selection_changed();
					}
					return;
				}
			}
		}
	}

	Brush::mouse_press_event(event, frame_delta);
}

void UnitBrush::mouse_move_event(QMouseEvent* event, double frame_delta) {
	Brush::mouse_move_event(event, frame_delta);

	if (event->buttons() == Qt::LeftButton) {
		if (mode == Mode::selection) {
			if (dragging) {
				if (!dragged) {
					dragged = true;
					map->world_undo.new_undo_group();
					unit_state_undo = std::make_unique<UnitStateAction>();
					for (const auto& i : selections) {
						unit_state_undo->old_units.push_back(*i);
					}
				}

				glm::vec3 offset = input_handler.mouse_world - drag_start;
				offset.z = 0;

				drag_start = input_handler.mouse_world;

				for (const auto& unit : selections) {
					unit->position += offset;
					unit->position.z = map->terrain.interpolated_height(unit->position.x, unit->position.y, true);
					unit->update();
				}
			} else if (event->modifiers() & Qt::ControlModifier) {
				for (auto&& i : selections) {
					float target_rotation =
						std::atan2(input_handler.mouse_world.y - i->position.y, input_handler.mouse_world.x - i->position.x);
					if (target_rotation < 0) {
						target_rotation = (glm::pi<float>() + target_rotation) + glm::pi<float>();
					}

					i->angle = target_rotation;
					i->update();
				}
			} else if (selection_started) {
				const glm::vec3 size = input_handler.mouse_world - selection_start;

				auto query = map->units.query_area({selection_start.x, selection_start.y, size.x, size.y});
				if (event->modifiers() & Qt::KeyboardModifier::ShiftModifier) {
					selections.insert(query.begin(), query.end());
				} else if (event->modifiers() & Qt::KeyboardModifier::AltModifier) {
					for (const auto& i : query) {
						selections.erase(i);
					}
				} else {
					selections.clear();
					selections.insert(query.begin(), query.end());
				}

				//selections = map->units.query_area({ selection_start.x, selection_start.y, size.x, size.y });
				emit selection_changed();
			}
		}
	}
}

void UnitBrush::mouse_release_event(QMouseEvent* event) {
	dragging = false;
	if (dragged) {
		dragged = false;
		for (const auto& i : selections) {
			unit_state_undo->new_units.push_back(*i);
		}
		map->world_undo.add_undo_action(std::move(unit_state_undo));
	}

	Brush::mouse_release_event(event);
}

void UnitBrush::delete_selection() {
	if (!selections.size()) {
		return;
	}

	// Undo/redo
	map->world_undo.new_undo_group();
	auto action = std::make_unique<UnitDeleteAction>();
	for (const auto& i : selections) {
		action->units.push_back(*i);
	}
	map->world_undo.add_undo_action(std::move(action));
	map->units.remove_units(selections);

	selections.clear();
	emit selection_changed();
}

void UnitBrush::copy_selection() {
	clipboard.clear();

	// Mouse position is average location
	clipboard_free_placement = true;
	glm::vec3 average_position = {};
	for (const auto& i : selections) {
		clipboard.push_back(*i);
		average_position += i->position;
	}
	clipboard_mouse_offset = average_position / static_cast<float>(clipboard.size());
}

void UnitBrush::cut_selection() {
	copy_selection();
	// Delete selection will add to the undo/redo tree
	delete_selection();
}

void UnitBrush::clear_selection() {
	selections.clear();
	emit selection_changed();
}

void UnitBrush::place_clipboard() {
	apply_begin();
	for (const auto& i : clipboard) {
		Unit& new_unit = map->units.add_unit(i);
		new_unit.creation_number = ++Unit::auto_increment;
		glm::vec3 final_position = glm::vec3(glm::vec2(input_handler.mouse_world + i.position) - clipboard_mouse_offset, 0);

		final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y, true);

		new_unit.position = final_position;
		new_unit.update();
		unit_undo->units.push_back(new_unit);
	}
	apply_end();
}

void UnitBrush::apply_begin() {
	map->world_undo.new_undo_group();
	unit_undo = std::make_unique<UnitAddAction>();
}

void UnitBrush::apply(double frame_delta) {
	if (id.empty()) {
		return;
	}

	glm::vec3 final_position = input_handler.mouse_world;
	final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y, true);

	Unit& new_unit = map->units.add_unit(id, final_position);
	new_unit.angle = rotation;
	new_unit.update();
	new_unit.player = player_id;

	unit_undo->units.push_back(new_unit);

	if (random_rotation) {
		set_random_rotation();
	}
}

void UnitBrush::apply_end() {
	map->world_undo.add_undo_action(std::move(unit_undo));
}

void UnitBrush::render_brush() {
	const float model_scale = units_slk.data<float>("modelscale", id);
	const float move_height = units_slk.data<float>("moveheight", id);

	glm::vec3 final_position = input_handler.mouse_world;
	final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y, true) + move_height / 128.f;
	const glm::vec3 final_scale = glm::vec3(model_scale / 128.f);

	if (mesh) {
		skeleton.update_location(final_position, glm::angleAxis(rotation, glm::vec3(0, 0, 1)), final_scale);
		skeleton.update(0.016f);
		map->render_manager.queue_render(*mesh, skeleton, glm::vec3(1.f), 0);
	}
}

void UnitBrush::render_selection() const {
	glDisable(GL_DEPTH_TEST);
	selection_circle_shader->use();
	glEnableVertexAttribArray(0);

	for (const auto& i : selections) {
		const float selection_scale = i->mesh->mdx->sequences[i->skeleton.sequence_index].extent.bounds_radius / 128.f;

		glm::mat4 model(1.f);
		model = glm::translate(model, i->position - glm::vec3(selection_scale * 0.5f, selection_scale * 0.5f, 0.f));
		model = glm::scale(model, glm::vec3(selection_scale));

		model = camera.projection_view * model;
		glUniformMatrix4fv(1, 1, GL_FALSE, &model[0][0]);

		glBindBuffer(GL_ARRAY_BUFFER, shapes.vertex_buffer);
		glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, shapes.index_buffer);
		glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
	}

	glDisableVertexAttribArray(0);
	glEnable(GL_DEPTH_TEST);
}

void UnitBrush::render_clipboard() {
	for (auto& i : clipboard) {
		const float model_scale = units_slk.data<float>("modelscale", i.id);
		const float move_height = units_slk.data<float>("moveheight", i.id);

		glm::vec3 final_position = glm::vec3(glm::vec2(input_handler.mouse_world + i.position) - clipboard_mouse_offset, 0);
		final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y, true) + move_height / 128.f;

		const glm::vec3 final_scale = glm::vec3(model_scale / 128.f);

		i.skeleton.update_location(final_position, glm::angleAxis(i.angle, glm::vec3(0, 0, 1)), final_scale);
		i.skeleton.update(0.016f);
		map->render_manager.queue_render(*i.mesh, i.skeleton, glm::vec3(1.f), 0);
	}
}

bool UnitBrush::can_place() {
	const float radius = units_slk.data<float>("collision", id) / 128.f;
	const glm::vec2 position = input_handler.mouse_world;

	for (const auto& i : map->units.units) {
		const float other_radius = units_slk.data<float>("collision", i.id) / 128.f;

		if (glm::distance(position, glm::vec2(i.position)) < radius + other_radius) {
			return false;
		}
	}

	return map->pathing_map.is_area_free(position, radius, PathingMap::Flags::unwalkable);
}

void UnitBrush::set_random_rotation() {
	std::random_device rd;
	std::mt19937 gen(rd());

	std::uniform_real_distribution dist(0.f, glm::pi<float>() * 2.f);
	rotation = dist(gen);
}

void UnitBrush::set_unit(const std::string& id) {
	context->makeCurrent();
	this->id = id;
	mesh = map->units.get_mesh(id);
	skeleton = SkeletalModelInstance(mesh->mdx);
}

void UnitBrush::unselect_id(const std::string_view id) {
	if (this->id == id) {
		set_unit("hfoo");
	}
}

```

`src/brush/unit_brush.h`:

```h
#pragma once

#include <set>
#include <vector>
#include <unordered_set>

#include <QKeyEvent>
#include <QMouseEvent>

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

import Units;
#include "brush.h"

import SkinnedMesh;
import PathingTexture;
import UnitsUndo;
import SkeletalModelInstance;

class UnitBrush : public Brush {
	std::string id;

	std::shared_ptr<SkinnedMesh> mesh;
	SkeletalModelInstance skeleton;

  public:
	float rotation = 0.f;
	bool random_rotation = true;

	int player_id = 0;

	std::unique_ptr<UnitAddAction> unit_undo;
	std::unique_ptr<UnitStateAction> unit_state_undo;

	std::unordered_set<Unit*> selections;
	glm::vec2 clipboard_mouse_offset;
	bool clipboard_free_placement = false;
	std::vector<Unit> clipboard;

	bool dragging = false;
	bool dragged = false;
	glm::vec3 drag_start;
	std::vector<glm::vec2> drag_offsets;

	UnitBrush();

	void set_shape(const Shape new_shape) override;

	void key_press_event(QKeyEvent* event) override;
	void key_release_event(QKeyEvent* event) override;
	void mouse_release_event(QMouseEvent* event) override;
	void mouse_press_event(QMouseEvent* event, double frame_delta) override;
	void mouse_move_event(QMouseEvent* event, double frame_delta) override;

	void delete_selection() override;
	void copy_selection() override;
	void cut_selection() override;
	void clear_selection() override;
	void place_clipboard() override;

	void apply_begin() override;
	void apply(double frame_delta) override;
	void apply_end() override;
	void render_brush() override;
	void render_selection() const override;
	void render_clipboard() override;

	bool can_place() override;

	void set_random_rotation();
	void set_unit(const std::string& id);

	void unselect_id(std::string_view id) override;
};
```

`src/custom_widgets/aspect_ratio_pixmap_label.h`:

```h
#pragma once

// Just for Qt moc to have the declaration
import AspectRatioPixmapLabel;
```

`src/custom_widgets/aspect_ratio_pixmap_label.ixx`:

```ixx
module;

#include <QLabel>
#include <QPainter>
#include <QPixmap>

export module AspectRatioPixmapLabel;

export class AspectRatioPixmapLabel : public QLabel {
	Q_OBJECT

	QPixmap pixmap;

	QPixmap get_scaled_pixmap(bool grid_lines) {
		QPixmap new_pixmap(width(), height());

		QPainter painter(&new_pixmap);
		painter.fillRect(0, 0, width(), height(), Qt::black);

		QPixmap scaled_pixmap = pixmap.scaled(width(), height(), Qt::KeepAspectRatio);
		horizontal_border = (width() - scaled_pixmap.width()) / 2.f;
		vertical_border = (height() - scaled_pixmap.height()) / 2.f;

		painter.drawPixmap(horizontal_border, vertical_border, scaled_pixmap);

		/*if (grid_lines) {
			auto tt = new_pixmap.width();
			auto ttt = pixmap.width();

			const int horizontal_spacing = new_pixmap.width() / pixmap.width();
			const int vertical_spacing = new_pixmap.height() / pixmap.height();

			if (horizontal_spacing > 2) {
				for (int i = 1; i < pixmap.width(); i++) {
					painter.drawLine(i * horizontal_spacing, 0, i * horizontal_spacing, new_pixmap.height());
				}
			}

			if (vertical_spacing > 2) {
				for (int j = 1; j < pixmap.height(); j++) {
					painter.drawLine(0, vertical_spacing * j, new_pixmap.width(), vertical_spacing * j);
				}
			}
			painter.end();
		}*/

		return new_pixmap;
	}

  public:
	AspectRatioPixmapLabel() {
		setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
	}
	using QLabel::QLabel;

	int horizontal_border;
	int vertical_border;

  public slots:
	void setPixmap(const QPixmap& p) {
		pixmap = p;

		if (pixmap.isNull()) {
			return;
		}

		QLabel::setPixmap(get_scaled_pixmap(false));
	}

	void resizeEvent(QResizeEvent* e) override {
		if (pixmap.isNull()) {
			return;
		}

		QLabel::setPixmap(get_scaled_pixmap(false));
	}
};

#include "aspect_ratio_pixmap_label.moc"
```

`src/custom_widgets/color_button.h`:

```h
#pragma once

// Just for Qt moc to have the declaration
import ColorButton;
```

`src/custom_widgets/color_button.ixx`:

```ixx
module;

#include <QPushButton>
#include <QColorDialog>
#include <QColor>

export module ColorButton;

import <glm/glm.hpp>;

export class ColorButton : public QPushButton {
	Q_OBJECT
  public:
	explicit ColorButton(QWidget* parent)
		: QPushButton(parent) {
		connect(this, &QPushButton::clicked, this, &ColorButton::changeColor);
	}

	void setColor(const QColor& new_color) {
		color = new_color;

		int delta = color.red() * 0.299 + color.green() * 0.587 + color.blue() * 0.114;
		QColor text_color = QColor((255 - delta < 105) ? Qt::black : Qt::white);

		setStyleSheet("border-color: " + color.name() + "; " + QString("background-color: ") + color.name() + "; color: " + text_color.name());
	}

	const QColor& getColor() {
		return color;
	}

	glm::vec4 get_glm_color() const {
		return { color.red(), color.green(), color.blue(), color.alpha() };
	}

  public slots:
	void changeColor() {
		QColor newColor = QColorDialog::getColor(color, parentWidget());
		if (newColor != color) {
			setColor(newColor);
		}
	}

  private:
	QColor color;
};

#include "color_button.moc"
```

`src/custom_widgets/flow_layout.ixx`:

```ixx
module;

#include <QLayout>
#include <QLayoutItem>
#include <QStyle>
#include <QWidget>

export module FlowLayout;

// FlowLayout is a gridlike layout that will adjust the position of the items according to screen width
export class FlowLayout : public QLayout {
  public:

	explicit FlowLayout(QWidget* parent, int margin = -1, int h_spacing = -1, int v_spacing = -1)
		: QLayout(parent), h_space(h_spacing), v_space(v_spacing) {
		setContentsMargins(margin, margin, margin, margin);
	}

	explicit FlowLayout(int margin = -1, int h_spacing = -1, int v_spacing = -1)
		: h_space(h_spacing), v_space(v_spacing) {
		setContentsMargins(margin, margin, margin, margin);
	}

	~FlowLayout() {
		QLayoutItem* item;
		while ((item = FlowLayout::takeAt(0)))
			delete item;
	}

	void addItem(QLayoutItem* item) {
		item_list.append(item);
	}

	void insert_widget(const int index, QWidget* widget) {
		addWidget(widget);
		item_list.move(indexOf(widget), index);
	}

	void move_widget(const int index, QWidget* widget) {
		if (index >= 0 && index < count()) {
			item_list.move(indexOf(widget), index);
			update();
		}
	}

	int horizontal_spacing() const {
		return spacing();
		// if (h_space >= 0) {
		//	return h_space;
		// } else {
		//	return smart_spacing(QStyle::PM_LayoutHorizontalSpacing);
		// }
	}

	int vertical_spacing() const {
		if (v_space >= 0) {
			return v_space;
		} else {
			return smart_spacing(QStyle::PM_LayoutVerticalSpacing);
		}
	}

	int count() const {
		return item_list.size();
	}

	QLayoutItem* itemAt(const int index) const {
		return item_list.value(index);
	}

	QLayoutItem* takeAt(const int index) {
		if (index >= 0 && index < item_list.size())
			return item_list.takeAt(index);
		else
			return nullptr;
	}

	Qt::Orientations expandingDirections() const {
		return Qt::Orientations();
	}

	bool hasHeightForWidth() const {
		return true;
	}

	// int heightForWidth(const int width) const {
	//	const int height = do_layout(QRect(0, 0, width, 0), true);
	//	return height;
	// }

	int heightForWidth(const int width) const {
		const int height = do_layout(QRect(0, 0, width, 0), true, nullptr); // jpo38: set added parameter to NULL here
		return height;
	}

	// void setGeometry(const QRect &rect) {
	//	QLayout::setGeometry(rect);
	//	do_layout(rect, false);
	// }

	void setGeometry(const QRect& rect) {
		QLayout::setGeometry(rect);

		const QSize oldSize = min_size;
		do_layout(rect, false, &min_size);
		if (oldSize != min_size) {
			// force layout to consider new minimum size!
			invalidate();
		}
	}

	QSize sizeHint() const {
		return minimumSize();
	}

	// QSize minimumSize() const {
	//	QSize size;
	//	for (auto&& item : item_list) {
	//		size = size.expandedTo(item->minimumSize());
	//	}
	//
	//	size += QSize(2 * margin(), 2 * margin());
	//	return size;
	// }

	QSize minimumSize() const {
		return min_size;
	}

	QList<QLayoutItem*> items() const {
		return item_list;
	}

	void clear() {
		for (auto&& i : item_list) {
			i->widget()->deleteLater();
			delete i;
		}
		item_list.clear();
	}

	// int do_layout(const QRect &rect, const bool test_only) const {
	//	int left, top, right, bottom;
	//	getContentsMargins(&left, &top, &right, &bottom);
	//	QRect effectiveRect = rect.adjusted(+left, +top, -right, -bottom);
	//	int x = effectiveRect.x();
	//	int y = effectiveRect.y();
	//	int lineHeight = 0;
	//
	//	for (auto&& item : item_list) {
	//		QWidget *wid = item->widget();
	//		int spaceX = horizontal_spacing();
	//		if (spaceX == -1)
	//			spaceX = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal);
	//		int spaceY = vertical_spacing();
	//		if (spaceY == -1)
	//			spaceY = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Vertical);
	//		int nextX = x + item->sizeHint().width() + spaceX;
	//		if (nextX - spaceX > effectiveRect.right() && lineHeight > 0) {
	//			x = effectiveRect.x();
	//			y = y + lineHeight + spaceY;
	//			nextX = x + item->sizeHint().width() + spaceX;
	//			lineHeight = 0;
	//		}
	//
	//		if (!test_only)
	//			item->setGeometry(QRect(QPoint(x, y), item->sizeHint()));
	//
	//		x = nextX;
	//		lineHeight = qMax(lineHeight, item->sizeHint().height());
	//	}
	//	return y + lineHeight - rect.y() + bottom;
	// }

	int do_layout(const QRect& rect, const bool test_only, QSize* p_min_size) const {
		int left, top, right, bottom;
		getContentsMargins(&left, &top, &right, &bottom);
		QRect effective_rect = rect.adjusted(+left, +top, -right, -bottom);
		int x = effective_rect.x();
		int y = effective_rect.y();
		int line_height = 0;

		// jpo38: store max X
		int max_x = 0;

		for (auto&& item : item_list) {
			QWidget* wid = item->widget();
			int space_x = horizontal_spacing();
			if (space_x == -1)
				space_x = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal);
			int space_y = vertical_spacing();
			if (space_y == -1)
				space_y = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Vertical);
			int next_x = x + item->sizeHint().width() + space_x;
			if (next_x - space_x > effective_rect.right() && line_height > 0) {
				x = effective_rect.x();
				y = y + line_height + space_y;
				next_x = x + item->sizeHint().width() + space_x;
				line_height = 0;
			}

			if (!test_only)
				item->setGeometry(QRect(QPoint(x, y), item->sizeHint()));

			// jpo38: update max X based on current position
			max_x = qMax(max_x, x + item->sizeHint().width() - rect.x() + left);

			x = next_x;
			line_height = qMax(line_height, item->sizeHint().height());
		}

		// jpo38: save height/width as max height/xidth in p_min_size is specified
		const int height = y + line_height - rect.y() + bottom;
		if (p_min_size) {
			p_min_size->setHeight(height);
			p_min_size->setWidth(max_x);
		}
		return height;
	}

	int smart_spacing(const QStyle::PixelMetric pm) const {
		QObject* parent = this->parent();
		if (!parent) {
			return -1;
		} else if (parent->isWidgetType()) {
			QWidget* pw = dynamic_cast<QWidget*>(parent);
			return pw->style()->pixelMetric(pm, nullptr, pw);
		} else {
			return dynamic_cast<QLayout*>(parent)->spacing();
		}
	}

	QSize min_size;
	QList<QLayoutItem*> item_list;
	int h_space;
	int v_space;
};
```

`src/custom_widgets/qribbon.ixx`:

```ixx
module;

#include <QShortcut>
#include <QToolButton>
#include <QGridLayout>
#include <QBoxLayout>
#include <QLabel>
#include <QMenu>
#include <QStyleOption>
#include <QPainter>
#include <QPushButton>
#include <QKeySequence>

export module QRibbon;

import std;

export class QRibbonButton : public QToolButton {
	Q_OBJECT

  public:
	QRibbonButton(QWidget* parent = nullptr)
		: QToolButton(parent) {
		setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Expanding);
	}

	~QRibbonButton() {
		for (auto&& i : shortcuts) {
			i->setParent(nullptr);
			delete i;
		}
	}

	std::vector<QShortcut*> shortcuts;

	void setShortCut(const QKeySequence sequence, const std::vector<QWidget*>& attach_to) {
		for (auto&& i : attach_to) {
			shortcuts.push_back(new QShortcut(sequence, i));
			connect(shortcuts.back(), &QShortcut::activated, this, &QToolButton::click);
			connect(shortcuts.back(), &QShortcut::activatedAmbiguously, []() { printf("kut2\n"); });
		}
	}

	void disableShortcuts() {
		for (auto&& i : shortcuts) {
			i->setEnabled(false);
		}
	}

	void enableShortcuts() {
		for (auto&& i : shortcuts) {
			i->setEnabled(true);
		}
	}

	void disconnectShortcuts() {
		// for (auto&& i : shortcuts) {
		//	delete i;
		//	shortcuts.clear();
		// }
	}
};

export class QSmallRibbonButton : public QRibbonButton {
	Q_OBJECT

  public:
	using QRibbonButton::QRibbonButton;

	// QSmallRibbonButton(QWidget* parent = nullptr);
	//~QSmallRibbonButton();
};

export class QRibbonContainer : public QFrame {
	Q_OBJECT

	QGridLayout* layout = new QGridLayout;

  public:
	explicit QRibbonContainer(QWidget* parent = nullptr)
		: QFrame(parent) {
		setLayout(layout);
		setAutoFillBackground(true);

		layout->setContentsMargins(0, 0, 0, 0);
		layout->setSpacing(0);
	}

	void addWidget(QWidget* widget, int row, int column) {
		layout->addWidget(widget, row, column);
	}

	void clear() {
		QLayoutItem* item;
		while ((item = layout->takeAt(0))) {
			if (item->widget()) {
				delete item->widget();
			}
			delete item;
		}
	}
};

export class QRibbonSection : public QWidget {
	Q_OBJECT

  public:
	QLabel* section_text = new QLabel;
	QVBoxLayout* section_inner = new QVBoxLayout;
	QHBoxLayout* section_outer = new QHBoxLayout;

	explicit QRibbonSection(QWidget* parent = nullptr)
		: QWidget(parent) {
		setLayout(section_inner);

		section_inner->setContentsMargins(0, 0, 0, 0);
		section_inner->setSpacing(5);
		section_inner->setContentsMargins(0, 0, 0, 0);

		section_outer->setContentsMargins(0, 0, 0, 0);
		section_outer->setSpacing(0);
		section_outer->setContentsMargins(0, 0, 0, 0);

		layout()->setContentsMargins(0, 0, 0, 0);
		setContentsMargins(0, 0, 0, 0);

		section_inner->addLayout(section_outer);
		section_inner->addWidget(section_text);

		section_text->setAlignment(Qt::AlignBottom | Qt::AlignmentFlag::AlignHCenter);
	}

	void addWidget(QWidget* widget) {
		section_outer->addWidget(widget);
	}

	void addLayout(QLayout* layout) {
		section_outer->addLayout(layout);
	}

	void addSpacing(int spacing) {
		section_outer->addSpacing(spacing);
	}

	void setText(const QString& text) {
		section_text->setText(text);
	}
};

export class QRibbonTab : public QWidget {
	Q_OBJECT

  public:
	QHBoxLayout* sections = new QHBoxLayout(this);

	explicit QRibbonTab(QWidget* parent = nullptr)
		: QWidget(parent) {
		setContentsMargins(0, 0, 0, 0);
		sections->addStretch(1);
		layout()->setContentsMargins(6, 4, 5, 3);
	}

	void disableShortcuts() {
	}

	void enableShortcuts() {
	}

	void paintEvent(QPaintEvent* event) override {
		QStyleOption opt;
		opt.initFrom(this);
		QPainter p(this);
		style()->drawPrimitive(QStyle::PE_Widget, &opt, &p, this);

		QWidget::paintEvent(event);
	}

	void addSection(QLayout* layout) {
		sections->insertLayout(0, layout);
	}

	void addSection(QRibbonSection* section) {
		QFrame* line = new QFrame();
		line->setObjectName("seperator");

		int count = sections->count();
		sections->insertWidget(count - 1, section);
		sections->insertWidget(count, line);
	}

	void addSpacer(QSpacerItem* spacer) {
		QFrame* line = new QFrame();
		line->setObjectName("seperator");

		int count = sections->count();
		sections->insertSpacerItem(count - 1, spacer);
		sections->insertWidget(count, line);
	}
};

export class QRibbonMenu : public QMenu {
	Q_OBJECT
  public:
	QHBoxLayout* base = new QHBoxLayout;
	QVBoxLayout* actions = new QVBoxLayout;
	QVBoxLayout* frequent_places = new QVBoxLayout;

	explicit QRibbonMenu(QWidget* parent = nullptr)
		: QMenu(parent) {
		base->setContentsMargins(1, 1, 1, 1);
		base->setSpacing(0);
		actions->setContentsMargins(0, 0, 0, 0);

		// QFrame* line = new QFrame();
		// line->setObjectName("verticalSeperator");

		base->addLayout(actions);
		// base->addWidget(line);
		// base->addLayout(frequent_places);

		setLayout(base);

		// frequent_places->setContentsMargins(0, 0, 0, 0);

		// QLabel* label = new QLabel("Recent Maps");
		// label->setStyleSheet(R"(
		//	QLabel {
		//		background-color: rgb(246, 247, 248);
		//
		//	}
		//)");

		// frequent_places->addWidget(label);

		// for (int i = 0; i < 5; i++) {
		//	QLabel* labell = new QLabel("test");
		//	labell->setStyleSheet(R"(
		//		QLabel::hover {
		//			background-color: rgb(233, 240, 248);
		//			border: 1px solid rgb(165, 207, 249);
		//
		//		}
		//	)");
		//	frequent_places->addWidget(labell);
		// }
		// frequent_places->addStretch(1);
	}

	// bool eventFilter(QObject *obj, QEvent *event);
};

export class QRibbonFileButton : public QToolButton {
	Q_OBJECT
  public:
	QRibbonMenu* menu = new QRibbonMenu;
	explicit QRibbonFileButton(QWidget* parent = nullptr)
		: QToolButton(parent) {
		setText("File");
		setMenu(menu);
	}
};

export class QRibbon : public QTabWidget {
	Q_OBJECT

	QRibbonFileButton* file = new QRibbonFileButton;

  public:
	explicit QRibbon(QWidget* parent = nullptr)
		: QTabWidget(parent) {
		setCornerWidget(file, Qt::TopLeftCorner);
	}

	void addMenuItem(QAbstractButton* widget) {
		file->menu->actions->addWidget(widget);
		connect(widget, &QAbstractButton::clicked, [&]() { file->menu->close(); });
	}

	void addMenuSeperator() {
		QFrame* line = new QFrame();
		line->setObjectName("horizontalSeperator");
		file->menu->actions->addWidget(line);
	}

	~QRibbon() {
	}
};

#include "qribbon.moc"
```

`src/custom_widgets/unit_selector.ixx`:

```ixx
module;

#include <QListView>
#include <QComboBox>
#include <QLineEdit>
#include <QVBoxLayout>
#include <QSortFilterProxyModel>

export module UnitSelector;

import std;
import Globals;
import UnitListModel;
import TableModel;

export class UnitSelector : public QWidget {
	Q_OBJECT

  public:
	explicit UnitSelector(QWidget* parent = nullptr)
		: QWidget(parent) {
		list_model = new UnitListModel(this);
		list_model->setSourceModel(units_table);

		filter_model = new UnitListFilter(this);
		filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
		filter_model->setSourceModel(list_model);
		filter_model->sort(0, Qt::AscendingOrder);
		filter_model->setFilterRace("human");

		race = new QComboBox(this);
		search = new QLineEdit(this);
		units = new QListView(this);

		search->setPlaceholderText("Search");
		search->setClearButtonEnabled(true);

		units->setUniformItemSizes(true);
		units->setIconSize(QSize(24, 24));
		units->setModel(filter_model);

		QVBoxLayout* layout = new QVBoxLayout;
		layout->setContentsMargins(0, 0, 0, 0);
		layout->addWidget(race);
		layout->addWidget(search);
		layout->addWidget(units);
		setLayout(layout);

		for (const auto& [key, value] : unit_editor_data.section("unitRace")) {
			if (key == "Sort" || key == "NumValues") {
				continue;
			}
			race->addItem(QString::fromStdString(value[1]), QString::fromStdString(value[0]));
		}

		connect(race, QOverload<int>::of(&QComboBox::currentIndexChanged), [&]() {
			filter_model->setFilterRace(race->currentData().toString());
		});

		connect(search, &QLineEdit::textEdited, filter_model, &QSortFilterProxyModel::setFilterFixedString);
		connect(search, &QLineEdit::returnPressed, [&]() {
			units->setCurrentIndex(units->model()->index(0, 0));
			units->setFocus();
		});

		connect(units, &QListView::clicked, [&](const QModelIndex& index) {
			const int row = filter_model->mapToSource(index).row();
			emit unitSelected(units_slk.index_to_row.at(row));
		});
		connect(units, &QListView::activated, [&](const QModelIndex& index) {
			const int row = filter_model->mapToSource(index).row();
			emit unitSelected(units_slk.index_to_row.at(row));
		});
	}

	UnitListModel* list_model;
	UnitListFilter* filter_model;

	QComboBox* race;
	QLineEdit* search;
	QListView* units;

  public slots:
	void forceSelection() {
		if (units->selectionModel()->selectedRows().isEmpty()) {
			return;
		}
		QModelIndex index = units->selectionModel()->selectedRows().front();
		if (!index.isValid()) {
			return;
		}
		const int row = filter_model->mapToSource(index).row();
		emit unitSelected(units_slk.index_to_row.at(row));
	}

  signals:
	void unitSelected(std::string id);
};

#include "unit_selector.moc"
```

`src/file_formats/blp.ixx`:

```ixx
export module BLP;

import std;
import types;
import BinaryReader;
import <turbojpeg.h>;

namespace blp {
	export u8* load(BinaryReader& reader, int& width, int& height, int& channels) {
		const std::string magic_number = reader.read_string(4);
		if (magic_number != "BLP1") {
			std::print("Wrong magic number, should be BLP1, is {}\n", magic_number);
			return nullptr;
		}

		int content_type = reader.read<u32>();
		int alpha_bits = reader.read<u32>();

		width = reader.read<u32>();
		height = reader.read<u32>();
		channels = 4;

		// extra and has_mipmaps
		reader.advance(8);

		u8* data = new u8[width * height * 4];

		auto mipmap_offsets = reader.read_vector<u32>(16);
		auto mipmap_sizes = reader.read_vector<u32>(16);

		if (content_type == 0) { // jpeg
			tjhandle handle = tjInitDecompress();
			const u32 header_size = reader.read<u32>();
			auto header_position = reader.buffer.begin() + reader.position;

			// Move header in front of content
			std::copy(header_position, header_position + header_size, reader.buffer.begin() + mipmap_offsets[0] - header_size);
			header_position = reader.buffer.begin() + mipmap_offsets[0] - header_size;

			const int success = tjDecompress2(handle, reader.buffer.data() + mipmap_offsets[0] - header_size, header_size + mipmap_sizes[0], data, width, 0, height, TJPF_CMYK, 0); // Actually BGRA

			if (success == -1) {
				std::print("Error loading JPEG data from BLP {}\n", tjGetErrorStr());
			}
			tjDestroy(handle);
		} else if (content_type == 1) { // direct
			auto header = reader.read_vector<u32>(256);

			// There might be fake mipmaps or the first mipmap could start within the 256 bytes of the colour header
			// Thus we cannot rely purely on advancing the position by mipmap sizes alone
			reader.position = mipmap_offsets[0];
			auto rgb = reader.read_vector<u8>(width * height);

			if (alpha_bits == 0) {
				for (size_t j = 0; j < rgb.size(); j++) {
					// + (255 << 24) because the header alpha value is always 0 so we add 255
					reinterpret_cast<u32*>(data)[j] = header[rgb[j]] + (255 << 24);
				}
			} else {
				auto alpha = reader.read_vector<u8>((width * height * alpha_bits + 7) / 8);

				for (size_t j = 0; j < rgb.size(); j++) {
					reinterpret_cast<u32*>(data)[j] = header[rgb[j]];
					switch (alpha_bits) {
						case 8:
							data[j * 4 + 3] = alpha[j];
							break;
						case 4: {
							u8 byte = alpha[j / 2];
							data[j * 4 + 3] = j % 2 ? byte >> 4 : byte & 0b00001111;
							break;
						}
						case 1:
							data[j * 4 + 3] = alpha[j / 8] & (1 << (j % 8));
							break;
					}
				}
			}
		}

		// Data is BGR(A) instead of RGB(A). While GPUs can natively load BGRA some of the code would have to deal with both RGBA and BGRA which is a pita
		for (int i = 0; i < width * height; i++) {
			std::swap(data[i * channels], data[i * channels + 2]);
		}

		return data;
	}
} // namespace blp
```

`src/file_formats/casc.ixx`:

```ixx
export module CASC;

import std;
import types;
import no_init_allocator;
import BinaryReader;
import <CascLib.h>;

namespace fs = std::filesystem;

// A thin wrapper around CascLib https://github.com/ladislav-zezula/CascLib
namespace casc {
	export class CASC {
	  public:
		HANDLE handle = nullptr;

		CASC() = default;

		explicit CASC(const fs::path& path) {
			open(path);
		}

		~CASC() {
			close();
		}

		CASC(CASC&& move)
		noexcept {
			handle = move.handle;
			move.handle = nullptr;
		}
		CASC(const CASC&) = default;
		CASC& operator=(const CASC&) = delete;
		CASC& operator=(CASC&& move) noexcept {
			handle = move.handle;
			move.handle = nullptr;
			return *this;
		}

		bool open(const fs::path& path) {
			if (handle != nullptr)
				close();
			const bool opened = CascOpenStorage(path.c_str(), CASC_LOCALE_ALL, &handle);
			if (!opened) {
				std::print("Error opening {} with error: {}\n", path.string(), GetCascError());
			}
			return opened;
		}

		void close() {
			CascCloseStorage(handle);
			handle = nullptr;
		}

		[[nodiscard]] std::expected<BinaryReader, std::string> open_file(const fs::path& path) const {
			HANDLE file_handle = nullptr;
			const bool opened = CascOpenFile(handle, path.string().c_str(), 0, CASC_OPEN_BY_NAME, &file_handle);
			if (!opened) {
				return std::unexpected(std::format("Error opening {} with error: {}\n", path.string(), GetCascError()));
			}

			const u32 size = CascGetFileSize(file_handle, nullptr);
			std::vector<u8, default_init_allocator<u8>> buffer(size);

			#ifdef _MSC_VER
			unsigned long bytes_read;
			#else
			unsigned bytes_read;
			#endif
			const bool success = CascReadFile(file_handle, buffer.data(), size, &bytes_read);
			if (!success) {
				return std::unexpected(std::format("Error failed to read file: {}\n", GetCascError()));
			}
			return BinaryReader(buffer);
		}

		bool file_exists(const fs::path& path) const {
			HANDLE file_handle = nullptr;
			return CascOpenFile(handle, path.string().c_str(), 0, CASC_OPEN_BY_NAME, &file_handle);
		}
	};
} // namespace casc
```

`src/file_formats/ini.ixx`:

```ixx
export module INI;

import std;
import Utilities;
import Hierarchy;
import no_init_allocator;
import <absl/strings/str_split.h>;
import UnorderedMap;

namespace fs = std::filesystem;

namespace ini {
	export class INI {
	  public:
		/// header to items to list of values to value
		hive::unordered_map<std::string, hive::unordered_map<std::string, std::vector<std::string>>> ini_data;

		INI() = default;
		explicit INI(const fs::path& path, bool local = false) {
			load(path, local);
		}

		void load(const fs::path& path, bool local = false) {
			std::vector<uint8_t, default_init_allocator<uint8_t>> buffer;
			if (local) {
				std::ifstream stream(path, std::ios::binary);
				buffer = std::vector<uint8_t, default_init_allocator<uint8_t>>(std::istreambuf_iterator<char>(stream), std::istreambuf_iterator<char>());
			} else {
				buffer = hierarchy.open_file(path).value().buffer;
			}
			std::string_view view(reinterpret_cast<char*>(buffer.data()), buffer.size());

			// Strip byte order marking
			if (view.starts_with(std::string{ static_cast<char>(0xEF), static_cast<char>(0xBB), static_cast<char>(0xBF) })) {
				view.remove_prefix(3);
			}

			std::string_view current_section;

			while (!view.empty()) {
				size_t eol = view.find('\n');
				if (eol == std::string_view::npos) {
					eol = view.size() - 1;
				}

				if (view.starts_with("//") || view.starts_with(';') || view.starts_with('\n') || view.starts_with('\r')) {
					view.remove_prefix(eol + 1);
					continue;
				}

				if (view.front() == '[') {
					current_section = view.substr(1, view.find(']') - 1);
				} else {
					const size_t found = view.find_first_of('=');
					if (found == std::string_view::npos) {
						view.remove_prefix(eol + 1);
						continue;
					}

					const std::string_view key = view.substr(0, found);
					const std::string_view value = view.substr(found + 1, view.find_first_of("\r\n") - 1 - found);

					if (key.empty() || value.empty()) {
						view.remove_prefix(eol + 1);
						continue;
					}

					const auto parts = split_string_escaped(value);

					// Sometimes there are duplicate keys and only the first seen value has to be retained.
					// E.g. the destructable LTt0 in destructableskin.txt has multiple minScale/maxScale
					if (auto found = ini_data.find(current_section); found != ini_data.end()) {
						if (!found->second.contains(key)) {
							found->second[key] = parts;
						}
					} else {
						ini_data[current_section][key] = parts;
					}
				}
				view.remove_prefix(eol + 1);
			}
		}

		/// Replaces all values (not keys) which match one of the keys in substitution INI
		void substitute(const INI& ini, const std::string_view section) {
			for (auto&& [section_key, section_value] : ini_data) {
				for (auto&& [key, value] : section_value) {
					for (auto&& part : value) {
						const std::string_view we_string = ini.data<std::string_view>(section, part);
						if (!we_string.empty()) {
							part = we_string;
						}
					}
				}
			}
		}

		[[nodiscard]] const hive::unordered_map<std::string, std::vector<std::string>>& section(const std::string_view section) const {
			if (auto found = ini_data.find(section); found != ini_data.end()) {
				return found->second;
			} else {
				throw std::runtime_error("section not found");
			}
		}

		/// Sets the data of a whole key
		void set_whole_data(const std::string_view section, const std::string_view key, std::string value) {
			ini_data[section][key] = { std::move(value) };
		}

		std::vector<std::string> whole_data(const std::string_view section, const std::string_view key) {
			return ini_data[section][key];
		}

		[[nodiscard]] bool key_exists(const std::string_view section, const std::string_view key) const {
			return ini_data.contains(section) && ini_data.at(section).contains(key);
		}

		[[nodiscard]] bool section_exists(const std::string_view section) const {
			return ini_data.contains(section);
		}

		/// To access key data where the value of the key is comma seperated
		template <typename T = std::string>
		[[nodiscard]] T data(const std::string_view section, const std::string_view key, const size_t argument = 0) const {
			const auto sec = ini_data.find(section);
			if (sec == ini_data.end()) {
				throw std::runtime_error("section not found");
			}
			const auto value = sec->second.find(key);
			if (value == sec->second.end()) {
				// Returning an empty value is kind of cursed
				return T{};
				// throw std::runtime_error("key not found");
			}

			if (argument >= value->second.size()) {
				// Returning an empty value is kind of cursed
				return T{};
				// throw std::runtime_error("section argument out of bounds");
			}

			if constexpr (std::is_same_v<T, std::string_view>) {
				return value->second[argument];
			} else if constexpr (std::is_same_v<T, std::string>) {
				return value->second[argument];
			} else if constexpr (std::is_same_v<T, int>) {
				return std::stoi(value->second[argument]);
			} else if constexpr (std::is_same_v<T, float>) {
				return std::stof(value->second[argument]);
			} else  {
				static_assert(false, "Type not supported. Convert yourself or add conversion here if it makes sense");
			}
		}
	};
} // namespace ini
```

`src/file_formats/json.ixx`:

```ixx
export module JSON;

import std;
import types;
import BinaryReader;
import Utilities;

namespace fs = std::filesystem;

namespace json {
	export class JSON {
	  public:
		std::map<std::string, std::string> json_data;
		
		JSON() = default;

		explicit JSON(const BinaryReader& reader) {
			load(reader);
		}

		void load(const BinaryReader& reader) {
			json_data.clear();
			std::stringstream file;
			file.write(reinterpret_cast<const char*>(reader.buffer.data()), reader.buffer.size());

			size_t end1;
			std::string line;
			if (std::getline(file, line)) {
				if (line.front() == '[') {
					while (std::getline(file, line) && line.back() != '}') {
						// Normaly json files use ; for comments, but Blizzard uses //
						if (line.substr(0, 2) == "//" || line.empty() || line.front() == ';') {
							continue;
						}
						for (size_t i = 0; i < line.length(); i++) {
							if (line.at(i) == '/') {
								line.replace(i, 1, "\\");
							}
						}
						if (line.substr(0, 12) == "    {\"src\":\"") {
							end1 = line.find('\"', 13);
							std::string key = line.substr(12, end1 - 12);
							std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c) { return std::tolower(c); });
							// If the segment already exists
							if (json_data.contains(key)) {
								continue;
							}
							json_data[key] = line.substr(end1 + 11, line.find('\"', end1 + 12) - end1 - 11);
						}
					}
					if (line.substr(0, 12) == "    {\"src\":\"") {
						end1 = line.find('\"', 13);
						const std::string key = line.substr(12, end1 - 12);
						// If the segment already exists
						if (json_data.contains(key)) {
						} else {
							json_data[key] = line.substr(end1 + 11, line.find('\"', end1 + 12) - end1 - 11);
						}
					}
				} else {
					std::cout << "Malformed Alias JSON\n";
				}
			}
		}

		bool exists(const std::string& file) const {
			std::string file_lower_case = file;
			std::transform(file_lower_case.begin(), file_lower_case.end(), file_lower_case.begin(), [](unsigned char c) { return std::tolower(c); });
			std::transform(file_lower_case.begin(), file_lower_case.end(), file_lower_case.begin(),
							[](char c) {if (c == '/')return '\\'; return c; });
			if (json_data.contains(file_lower_case)) {
				return true;
			}
			return false;
		}

		std::string alias(const std::string& file) const {
			std::string file_lower_case = file;
			std::transform(file_lower_case.begin(), file_lower_case.end(), file_lower_case.begin(), [](unsigned char c) { return std::tolower(c); });
			std::transform(file_lower_case.begin(), file_lower_case.end(), file_lower_case.begin(),
							[](char c) {if (c == '/')return '\\'; return c; });
			return json_data.at(file_lower_case);
		}
	};
} // namespace json
```

`src/file_formats/mdx/mdl_reader.cpp`:

```cpp
module MDX;

import std;
import std.compat;
import <glm/glm.hpp>;
import <outcome/outcome.hpp>;
import <outcome/try.hpp>;

namespace outcome = OUTCOME_V2_NAMESPACE;
using OUTCOME_V2_NAMESPACE::failure;
using OUTCOME_V2_NAMESPACE::result;

// Experimental implementation (i.e. garbage code)
// Rewrite when pattern matching is added to C++
// Rewrite when ? operator is added to C++

namespace mdx {
#define TRY(r)                                \
	{                                         \
		if (auto optional = r; optional) {    \
			return failure(optional.value()); \
		}                                     \
	}

	struct MDLReader {
		std::vector<std::string_view> tokens;
		size_t position = 0;

		void advance() {
			position += 1;
		}

		result<std::string_view, std::string> consume() {
			if (position >= tokens.size()) [[unlikely]] {
				return failure("Expected a token but reached the end of the file");
			}
			auto token = tokens[position];
			position += 1;
			return outcome::success(token);
		}

		std::string_view current() {
			return tokens[position];
		}

		result<std::string_view, std::string> peek() {
			if (position >= tokens.size()) [[unlikely]] {
				return failure("Expected a token but reached the end of the file");
			}
			return outcome::success(tokens[position]);
		}

		std::optional<std::string> consume(std::string_view token) {
			if (position >= tokens.size()) [[unlikely]] {
				return std::format("Expected \"{}\", but reached the end of the file", token);
			}
			if (tokens[position] != token) [[unlikely]] {
				return std::format("Expected \"{}\" but got \"{}\"", token, tokens[position]);
			}
			position += 1;
			return std::nullopt;
		}

		result<int64_t, std::string> consume_integer() {
			if (position >= tokens.size()) [[unlikely]] {
				return std::format("Expected an integer, but reached the end of the file");
			}

			int64_t integer;
			std::from_chars(tokens[position].data(), tokens[position].data() + tokens[position].size(), integer); // ToDo handle parsing error
			position += 1;
			return outcome::success(integer);
		}

		result<float, std::string> consume_float() {
			if (position >= tokens.size()) [[unlikely]] {
				return std::format("Expected an integer, but reached the end of the file");
			}

			float number;
			std::from_chars(tokens[position].data(), tokens[position].data() + tokens[position].size(), number); // ToDo handle parsing error
			position += 1;
			return outcome::success(number);
		}

		result<glm::vec2, std::string> consume_vec2() {
			TRY(consume("{"));
			glm::vec2 vec;
			OUTCOME_TRY(vec.x, consume_float());
			TRY(consume(","));
			OUTCOME_TRY(vec.y, consume_float());
			TRY(consume("}"));
			return vec;
		}

		result<glm::vec3, std::string> consume_vec3() {
			TRY(consume("{"));
			glm::vec3 vec;
			OUTCOME_TRY(vec.x, consume_float());
			TRY(consume(","));
			OUTCOME_TRY(vec.y, consume_float());
			TRY(consume(","));
			OUTCOME_TRY(vec.z, consume_float());
			TRY(consume("}"));
			return vec;
		}

		result<glm::vec4, std::string> consume_vec4() {
			TRY(consume("{"));
			glm::vec4 vec;
			OUTCOME_TRY(vec.x, consume_float());
			TRY(consume(","));
			OUTCOME_TRY(vec.y, consume_float());
			TRY(consume(","));
			OUTCOME_TRY(vec.z, consume_float());
			TRY(consume(","));
			OUTCOME_TRY(vec.w, consume_float());
			TRY(consume("}"));
			return vec;
		}

		result<std::string_view, std::string> consume_quoted_string() {
			const auto token = current();
			if (position >= tokens.size()) [[unlikely]] {
				return failure(std::format("Expected quoted string (e.g. \"SomeName\"), but reached the end of the file"));
			}

			if (token.size() < 3 || token.front() != '\"' || token.back() != '\"') [[unlikely]] {
				return failure(std::format("The name should be surrounded in quotes \"likethis\" and at least one character long, but is \"{}\"", token));
			}

			position += 1;
			return outcome::success(token.substr(1, token.size() - 2)); // Get rid of quotes
		}
	};

	outcome::result<void, std::string> parse_version_chunk(MDLReader& reader, MDX& mdx) {
		TRY(reader.consume("Version"));
		TRY(reader.consume("{"));
		TRY(reader.consume("FormatVersion"));

		OUTCOME_TRY(mdx.version, reader.consume_integer());
		if (mdx.version != 800 || mdx.version != 900 || mdx.version != 1000) [[unlikely]] {
			return std::format("Invalid version {}, expected 800, 900, 1000", mdx.version);
		}

		TRY(reader.consume(","));
		TRY(reader.consume("}"));
		return outcome::success();
	}

	outcome::result<void, std::string> parse_model_chunk(MDLReader& reader, MDX& mdx) {
		TRY(reader.consume("Model"));

		OUTCOME_TRY(mdx.name, reader.consume_quoted_string());

		TRY(reader.consume("{"));

		while (true) {
			OUTCOME_TRY(auto token, reader.consume());
			if (token == "}") {
				break;
			}

			if (token == "BlendTime") {
				OUTCOME_TRY(mdx.blend_time, reader.consume_integer());
			}

			if (token == "MinimumExtent") {
				OUTCOME_TRY(mdx.extent.minimum, reader.consume_vec3());
			}

			if (token == "MaximumExtent") {
				OUTCOME_TRY(mdx.extent.minimum, reader.consume_vec3());
			}

			if (token == "BoundsRadius") {
				OUTCOME_TRY(mdx.extent.bounds_radius, reader.consume_float());
			}
			TRY(reader.consume(","));
		}

		return outcome::success();
	}

	outcome::result<void, std::string> parse_sequences_chunk(MDLReader& reader, MDX& mdx) {
		TRY(reader.consume("Sequences"));

		OUTCOME_TRY(auto sequence_count, reader.consume_integer());

		TRY(reader.consume("{"));

		for (size_t i = 0; i < sequence_count; i++) {
			TRY(reader.consume("Anim"));
			OUTCOME_TRY(auto name, reader.consume_quoted_string());
			TRY(reader.consume("{"));

			Sequence sequence;
			while (true) {
				OUTCOME_TRY(auto token, reader.consume());
				if (token == "}") {
					break;
				}

				if (token == "NonLooping") {
					sequence.flags |= Sequence::non_looping;
				}

				if (token == "MinimumExtent") {
					OUTCOME_TRY(sequence.extent.minimum, reader.consume_vec3());
				}

				if (token == "MaximumExtent") {
					OUTCOME_TRY(sequence.extent.maximum, reader.consume_vec3());
				}

				if (token == "BoundsRadius") {
					OUTCOME_TRY(sequence.extent.bounds_radius, reader.consume_float());
				}
				TRY(reader.consume(","));
			}
			mdx.sequences.push_back(sequence);
		}

		return outcome::success();
	}

	outcome::result<void, std::string> parse_global_sequences(MDLReader& reader, MDX& mdx) {
		TRY(reader.consume("GlobalSequences"));
		OUTCOME_TRY(auto global_sequence_count, reader.consume_integer());
		TRY(reader.consume("{"));

		
		for (size_t i = 0; i < global_sequence_count; i++) {
			TRY(reader.consume("Duration"));
			
			uint32_t duration;
			OUTCOME_TRY(duration, reader.consume_integer());
			mdx.global_sequences.push_back(duration);
		}

		return outcome::success();
	}

	outcome::result<void, std::string> parse_textures(MDLReader& reader, MDX& mdx) {
		TRY(reader.consume("Textures"));
		OUTCOME_TRY(auto texture_count, reader.consume_integer());
		TRY(reader.consume("{"));

		for (size_t i = 0; i < texture_count; i++) {
			TRY(reader.consume("Bitmap"));
			TRY(reader.consume("{"));

			Texture texture;
			while (true) {
				OUTCOME_TRY(auto token, reader.consume());
				if (token == "}") {
					break;
				}

				if (token == "Image") {
					OUTCOME_TRY(texture.file_name, reader.consume_quoted_string());
				}

				if (token == "ReplaceableId") {
					OUTCOME_TRY(texture.replaceable_id, reader.consume_integer());
				}
				TRY(reader.consume(","));
			}
			mdx.textures.push_back(texture);
		}

		return outcome::success();
	}

	outcome::result<void, std::string> parse_materials(MDLReader& reader, MDX& mdx) {
		TRY(reader.consume("Materials"));
		OUTCOME_TRY(auto material_count, reader.consume_integer());
		TRY(reader.consume("{"));

		for (size_t i = 0; i < material_count; i++) {
			TRY(reader.consume("Material"));
			TRY(reader.consume("{"));

			Material material;
			while (true) {
				OUTCOME_TRY(auto token, reader.consume());
				if (token == "}") {
					break;
				}

				if (token == "Shader") {
					OUTCOME_TRY(auto yeet, reader.consume_quoted_string());
				}

				if (token == "Layer") {
					TRY(reader.consume("{"));
					Layer layer;
					while (true) {
						OUTCOME_TRY(auto token, reader.consume());
						if (token == "}") {
							break;
						}

						if (token == "FilterMode") {
							OUTCOME_TRY(auto mode, reader.consume_quoted_string());
							if (mode == "Additive") {
								layer.blend_mode = 3;
							}
						}

						if (token == "Unshaded") {
							layer.shading_flags |= Layer::ShadingFlags::unshaded;
						}

						if (token == "Unfogged") {
							layer.shading_flags |= Layer::ShadingFlags::unfogged;
						}

						if (token == "static") {
							OUTCOME_TRY(auto token, reader.consume());
							if (token == "TextureID") {
								OUTCOME_TRY(layer.texture_animation_id, reader.consume_integer());
							}
							if (token == "Alpha") {
								OUTCOME_TRY(layer.alpha, reader.consume_float());
							}
						}
						TRY(reader.consume(","));
					}
					material.layers.push_back(layer);
				}
				TRY(reader.consume(","));
			}
			mdx.materials.push_back(material);
		}

		return outcome::success();
	}

	outcome::result<void, std::string> parse_geoset(MDLReader& reader, MDX& mdx) {
		TRY(reader.consume("Geoset"));
		TRY(reader.consume("{"));

		Geoset geoset;

		TRY(reader.consume("Vertices"));
		OUTCOME_TRY(auto vertex_count, reader.consume_integer());
		TRY(reader.consume("{"));

		for (size_t i = 0; i < vertex_count; i++) {
			OUTCOME_TRY(auto vertex, reader.consume_vec3());
			TRY(reader.consume(","));
			geoset.vertices.push_back(vertex);
		}
		TRY(reader.consume("}"));

		TRY(reader.consume("Normals"));
		OUTCOME_TRY(auto normal_count, reader.consume_integer());
		TRY(reader.consume("{"));

		for (size_t i = 0; i < normal_count; i++) {
			OUTCOME_TRY(auto normal, reader.consume_vec3());
			TRY(reader.consume(","));
			geoset.normals.push_back(normal);
		}
		TRY(reader.consume("}"));

		OUTCOME_TRY(auto is_tangents, reader.peek());
		if (is_tangents == "Tangents") {
			TRY(reader.consume("Tangents"));
			OUTCOME_TRY(auto tangent_count, reader.consume_integer());
			TRY(reader.consume("{"));

			for (size_t i = 0; i < tangent_count; i++) {
				OUTCOME_TRY(auto tangent, reader.consume_vec4());
				geoset.tangents.push_back(tangent);
				TRY(reader.consume(","));
			}
			TRY(reader.consume("}"));
		}

		TRY(reader.consume("TVertices"));
		OUTCOME_TRY(auto uv_count, reader.consume_integer());
		TRY(reader.consume("{"));

		std::vector<glm::vec2> uvs;
		for (size_t i = 0; i < uv_count; i++) {
			OUTCOME_TRY(auto uv, reader.consume_vec2());
			uvs.push_back(uv);
			TRY(reader.consume(","));
		}
		geoset.uv_sets.push_back(uvs);
		TRY(reader.consume("}"));

		OUTCOME_TRY(auto is_skin_weights, reader.peek());
		if (is_skin_weights == "SkinWeights") {
			TRY(reader.consume("SkinWeights"));
			OUTCOME_TRY(auto skin_count, reader.consume_integer());
			TRY(reader.consume("{"));

			for (size_t i = 0; i < skin_count * 8; i++) {
				OUTCOME_TRY(auto weight, reader.consume_integer());
				geoset.skin.push_back(weight);
				TRY(reader.consume(","));
			}
			TRY(reader.consume("}"));
		}

		TRY(reader.consume("VertexGroup"));
		TRY(reader.consume("{"));

		for (size_t i = 0; i < uv_count; i++) {
			OUTCOME_TRY(auto vertex_group, reader.consume_integer());
			geoset.vertex_groups.push_back(vertex_group);
			TRY(reader.consume(","));
		}

		TRY(reader.consume("}"));

		TRY(reader.consume("Faces"));
		OUTCOME_TRY(auto face_count, reader.consume_integer());
		assert(face_count == 1); // I don't even know if you can have multiple

		OUTCOME_TRY(auto index_count, reader.consume_integer());
		TRY(reader.consume("{"));

		for (size_t i = 0; i < face_count; i++) {
			TRY(reader.consume("Triangles")); // We only support triangles
			TRY(reader.consume("{"));

			for (size_t j = 0; j < index_count; j++) {
				OUTCOME_TRY(auto index, reader.consume_integer());
				geoset.faces.push_back(index);
				if (i < face_count - 1) {
					TRY(reader.consume(","));
				}
			}

			TRY(reader.consume("}"));
		}
		TRY(reader.consume("}"));

		TRY(reader.consume("Groups"));
		OUTCOME_TRY(auto group_count, reader.consume_integer());
		OUTCOME_TRY(auto dunno, reader.consume_integer());
		TRY(reader.consume("{"));

		for (size_t i = 0; i < group_count; i++) {
			TRY(reader.consume("Matrices"));
			TRY(reader.consume("{"));

			OUTCOME_TRY(auto matrix, reader.consume_integer());
			geoset.matrix_groups.push_back(matrix); // ?

			TRY(reader.consume("}"));
		}
		TRY(reader.consume("}"));

		//TRY(reader.consume("MinimumExtent"));
		//OUTCOME_TRY(geoset.extent.minimum, reader.consume_vec3());
		//TRY(reader.consume(","));
		//TRY(reader.consume("MaximumExtent"));
		//OUTCOME_TRY(geoset.extent.maximum, reader.consume_vec3());
		//TRY(reader.consume(","));
		//TRY(reader.consume("BoundsRadius"));
		//OUTCOME_TRY(geoset.extent.bounds_radius, reader.consume_float());
		//TRY(reader.consume(","));

		TRY(reader.consume("MaterialID"));
		OUTCOME_TRY(geoset.material_id, reader.consume_integer());
		TRY(reader.consume(","));

		TRY(reader.consume("SelectionGroup"));
		OUTCOME_TRY(geoset.selection_group, reader.consume_integer());
		TRY(reader.consume(","));

		TRY(reader.consume("LevelOfDetail"));
		OUTCOME_TRY(geoset.lod, reader.consume_integer());
		TRY(reader.consume(","));

		TRY(reader.consume("Name"));
		OUTCOME_TRY(geoset.lod_name, reader.consume_quoted_string());
		TRY(reader.consume(","));

		mdx.geosets.push_back(geoset);

		return outcome::success();
	}

	outcome::result<void, std::string> parse_geoset_anim(MDLReader& reader, MDX& mdx) {
		TRY(reader.consume("GeosetAnim"));
		TRY(reader.consume("{"));

		TRY(reader.consume("Alpha"));
		OUTCOME_TRY(auto alpha_count, reader.consume_integer());

		for (size_t i = 0; i < alpha_count; i++) {
			TRY(reader.consume("Bitmap"));
			TRY(reader.consume("{"));

			Texture texture;
			while (true) {
				OUTCOME_TRY(auto token, reader.consume());
				if (token == "}") {
					break;
				}

				if (token == "Image") {
					OUTCOME_TRY(texture.file_name, reader.consume_quoted_string());
				}

				if (token == "ReplaceableId") {
					OUTCOME_TRY(texture.replaceable_id, reader.consume_integer());
				}
				TRY(reader.consume(","));
			}
			mdx.textures.push_back(texture);
		}

		return outcome::success();
	}

	result<MDX, std::string> MDX::from_mdl(std::string_view mdl) {
		MDLReader reader;

		// Tokenize
		while (mdl.size() > 1) {
			size_t pos = mdl.find_first_of(" \t\r\n,");

			if (mdl[0] == '"') {
				pos = mdl.find_first_of('\"', 1) + 1;
			}
			reader.tokens.emplace_back(mdl.substr(0, pos));

			std::println("{}", mdl.substr(0, pos));

			pos = mdl.find_first_not_of(" \t\r\n,", pos);
			if (pos == std::string::npos) {
				break;
			}
			mdl.remove_prefix(pos);
		}

		MDX mdx;
		OUTCOME_TRY(parse_version_chunk(reader, mdx));

		while (!reader.tokens.empty()) {
			if (reader.current() == "Model") {
				OUTCOME_TRY(parse_model_chunk(reader, mdx));
			}

			if (reader.current() == "Sequences") {
				OUTCOME_TRY(parse_sequences_chunk(reader, mdx));
			}

			if (reader.current() == "GlobalSequences") {
				OUTCOME_TRY(parse_global_sequences(reader, mdx));
			}

			if (reader.current() == "Textures") {
				OUTCOME_TRY(parse_textures(reader, mdx));
			}

			if (reader.current() == "Material") {
				OUTCOME_TRY(parse_materials(reader, mdx));
			}

			if (reader.current() == "Geoset") {
				OUTCOME_TRY(parse_geoset(reader, mdx));
			}

			if (reader.current() == "GeosetAnim") {
				OUTCOME_TRY(parse_geoset_anim(reader, mdx));
			}

			return failure(std::format("Error reading token {}, expected a chunk type (Version/Model/Textures/etc). Make sure to match the casing", reader.current()));
		}

		return mdx;
	}
} // namespace mdx
```

`src/file_formats/mdx/mdl_writer.cpp`:

```cpp
module MDX;

import std;
import Timer;
import <nlohmann/json.hpp>;
using json = nlohmann::json;
import <glm/glm.hpp>;

namespace mdx {
	/// A minimal utility wrapper around an std::string that manages newlines, indentation and closing braces
	struct MDLWriter {
		std::string mdl;
		size_t current_indentation = 0;

		template <typename... Args>
		void write_line(std::format_string<Args...> fmt, Args&&... args) {
			for (size_t i = 0; i < current_indentation; i++) {
				mdl += '\t';
			}
			mdl += std::vformat(fmt.get(), std::make_format_args(args...));
			mdl += '\n';
		}

		template <typename T>
		void write_track(const TrackHeader<T>& track_header, std::string name, T static_value) {
			if (track_header.tracks.empty()) {
				if constexpr (std::is_same_v<T, glm::vec2>) {
					write_line("static {} {{ {}, {} }},", name, static_value.x, static_value.y);
				} else if constexpr (std::is_same_v<T, glm::vec3>) {
					write_line("static {} {{ {}, {}, {} }},", name, static_value.x, static_value.y, static_value.z);
				} else if constexpr (std::is_same_v<T, glm::quat>) {
					write_line("static {} {{ {}, {}, {}, {} }},", name, static_value.x, static_value.y, static_value.z, static_value.w);
				} else {
					write_line("static {} {},", name, static_value);
				}
			} else {
				start_group(name, [&]() {
					switch (track_header.interpolation_type) {
						case InterpolationType::none:
							write_line("DontInterp,");
							break;
						case InterpolationType::linear:
							write_line("Linear,");
							break;
						case InterpolationType::hermite:
							write_line("Hermite,");
							break;
						case InterpolationType::bezier:
							write_line("Bezier,");
							break;
					}

					write_line("GlobalSeqId {},", track_header.global_sequence_ID);

					for (const auto& track : track_header.tracks) {
						if constexpr (std::is_same_v<T, glm::vec2>) {
							write_line("{}: {{ {}, {} }},", track.frame, track.value.x, track.value.y);
						} else if constexpr (std::is_same_v<T, glm::vec3>) {
							write_line("{}: {{ {}, {}, {} }},", track.frame, track.value.x, track.value.y, track.value.z);
						} else if constexpr (std::is_same_v<T, glm::quat>) {
							write_line("{}: {{ {}, {}, {}, {} }},", track.frame, track.value.x, track.value.y, track.value.z, track.value.w);
						} else {
							write_line("{}: {},", track.frame, track.value);
						}

						if (track_header.interpolation_type == InterpolationType::hermite || track_header.interpolation_type == InterpolationType::bezier) {
							if constexpr (std::is_same_v<T, glm::vec2>) {
								write_line("InTan {{ {}, {} }},", track.inTan.x, track.inTan.y);
								write_line("OutTan {{ {}, {} }},", track.outTan.x, track.outTan.y);
							} else if constexpr (std::is_same_v<T, glm::vec3>) {
								write_line("InTan {{ {}, {}, {} }},", track.inTan.x, track.inTan.y, track.inTan.z);
								write_line("OutTan {{ {}, {}, {} }},", track.outTan.x, track.outTan.y, track.outTan.z);
							} else if constexpr (std::is_same_v<T, glm::quat>) {
								write_line("InTan {{ {}, {}, {}, {} }},", track.inTan.x, track.inTan.y, track.inTan.z, track.inTan.w);
								write_line("OutTan {{ {}, {}, {}, {} }},", track.outTan.x, track.outTan.y, track.outTan.z, track.outTan.w);
							} else {
								write_line("InTan {},", track.inTan);
								write_line("OutTan {},", track.outTan);
							}
						}
					}
				});
			}
		}

		void write_node(const Node& node) {
			write_line("ObjectId {},", node.id);
			write_line("Parent {},", node.parent_id);

			if (node.flags & Node::Flags::billboarded) {
				write_line("Billboarded,");
			}

			if (node.flags & Node::Flags::unfogged) {
				write_line("Unfogged,");
			}

			if (node.flags & Node::Flags::line_emitter) {
				write_line("LineEmitter,");
			}

			if (node.flags & Node::Flags::unshaded) {
				write_line("Unshaded,");
			}

			if (node.flags & Node::Flags::model_space) {
				write_line("ModelSpace,");
			}

			write_track(node.KGRT, "Rotation", glm::quat(0.f, 0.f, 0.f, 0.f));
			write_track(node.KGTR, "Translation", glm::vec3(0.0));
			write_track(node.KGSC, "Scale", glm::vec3(1.0));
		}

		template <typename T>
		void start_group(std::string name, T callback) {
			for (size_t i = 0; i < current_indentation; i++) {
				mdl += '\t';
			}
			mdl += name + " {\n";
			current_indentation += 1;
			callback();
			current_indentation -= 1;
			for (size_t i = 0; i < current_indentation; i++) {
				mdl += '\t';
			}
			mdl += "}\n";
		}
	};

	std::string MDX::to_mdl() {
		json j;
		j["Version"]["FormatVersion"] = 1000;
		
		j["Model"]["BlendTime"] = blend_time;
		j["Model"]["MinimumExtent"] = {
			extent.minimum.x,
			extent.minimum.y,
			extent.minimum.z,
		};
		j["Model"]["MaximumExtent"] = {
			extent.maximum.x,
			extent.maximum.y,
			extent.maximum.z,
		};

		j["Sequences"] = json::array();
		for (const auto& i : sequences) {
			json sequence;
			sequence["Interval"] = { i.start_frame, i.end_frame };
			sequence["Movespeed"] = i.movespeed;
			sequence["SyncPoint"] = i.sync_point;
			sequence["NonLooping"] = i.flags & Sequence::Flags::non_looping;
			sequence["Rarity"] = i.rarity;
			sequence["MinimumExtent"] = {
				i.extent.minimum.x,
				i.extent.minimum.y,
				i.extent.minimum.z,
			};
			sequence["MaximumExtent"] = {
				i.extent.maximum.x,
				i.extent.maximum.y,
				i.extent.maximum.z,
			};
			sequence["BoundRadius"] = i.extent.bounds_radius;
			j["Sequences"].push_back(sequence);
		}

		std::ofstream file("C:/Users/User/Desktop/MDX.json");
		file << j;
		file.close();

		Timer timer;
		MDLWriter mdl;

		mdl.start_group("Version", [&]() {
			mdl.write_line("FormatVersion 1000,");
		});

		mdl.start_group(std::format("Model \"{}\"", name), [&]() {
			mdl.write_line("BlendTime {},", blend_time);
			mdl.write_line("MinimumExtent {{ {}, {}, {} }},", extent.minimum.x, extent.minimum.y, extent.minimum.z);
			mdl.write_line("MaximumExtent {{ {}, {}, {} }},", extent.maximum.x, extent.maximum.y, extent.maximum.z);
		});

		mdl.start_group(std::format("Sequences {}", sequences.size()), [&]() {
			for (const auto& i : sequences) {
				mdl.start_group(std::format("Anim \"{}\"", i.name), [&]() {
					mdl.write_line("Interval {{ {}, {} }},", i.start_frame, i.end_frame);
					mdl.write_line("Movespeed {},", i.movespeed);
					mdl.write_line("SyncPoint {},", i.sync_point);

					if (i.flags & Sequence::Flags::non_looping) {
						mdl.write_line("NonLooping,");
					}

					mdl.write_line("Rarity {},", i.rarity);
					mdl.write_line("MinimumExtent {{ {}, {}, {}, }},", i.extent.minimum.x, i.extent.minimum.y, i.extent.minimum.z);
					mdl.write_line("MinimumExtent {{ {}, {}, {}, }},", i.extent.maximum.x, i.extent.maximum.y, i.extent.maximum.z);
					mdl.write_line("BoundRadius {},", i.extent.bounds_radius);
				});
			}
		});

		mdl.start_group(std::format("GlobalSequences {}", global_sequences.size()), [&]() {
			for (const auto& i : global_sequences) {
				mdl.write_line("Duration {},", i);
			}
		});

		mdl.start_group(std::format("Textures {}", textures.size()), [&]() {
			for (const auto& i : textures) {
				mdl.start_group("Bitmap", [&]() {
					mdl.write_line("Image \"{}\",", i.file_name.string());
					mdl.write_line("ReplaceableId {},", i.replaceable_id);
					if (i.flags & Texture::Flags::wrap_width) {
						mdl.write_line("WrapWidth");
					}
					if (i.flags & Texture::Flags::wrap_height) {
						mdl.write_line("WrapHeight");
					}
				});
			}
		});

		mdl.start_group(std::format("Materials {}", materials.size()), [&]() {
			for (const auto& material : materials) {
				mdl.start_group("Material", [&]() {
					if (material.layers[0].hd) {
						mdl.write_line("Shader \"Shader_HD_DefaultUnit\",");
						const auto& layer = material.layers[0];
						for (int i = 0; i < 6; i++) {
							switch (layer.blend_mode) {
								case 0:
									mdl.write_line("FilterMode None");
									break;
								case 1:
									mdl.write_line("FilterMode Transparent");
									break;
								case 2:
									mdl.write_line("FilterMode Blend");
									break;
								case 3:
									mdl.write_line("FilterMode Additive");
									break;
								case 4:
									mdl.write_line("FilterMode AddAlpha");
									break;
								case 5:
									mdl.write_line("FilterMode Modulate");
									break;
								case 6:
									mdl.write_line("FilterMode Modulate2x");
									break;
							}

							if (layer.shading_flags & Layer::ShadingFlags::unshaded) {
								mdl.write_line("Unshaded");
							}

							if (layer.shading_flags & Layer::ShadingFlags::unfogged) {
								mdl.write_line("Unfogged");
							}

							if (layer.shading_flags & Layer::ShadingFlags::no_depth_test) {
								mdl.write_line("NoDepthTest");
							}

							if (layer.shading_flags & Layer::ShadingFlags::no_depth_set) {
								mdl.write_line("NoDepthSet");
							}

							mdl.write_track(layer.textures.at(i).KMTF, "TextureID", layer.textures.at(i).id);
							mdl.write_track(layer.KMTA, "Alpha", layer.alpha);
							mdl.write_track(layer.KMTE, "EmissiveGain", layer.emissive_gain);
							mdl.write_track(layer.KFC3, "FresnelColor", layer.fresnel_color);
							mdl.write_track(layer.KFCA, "FresnelAlpha", layer.fresnel_opacity);
							mdl.write_track(layer.KFTC, "FresnelTeamColor", layer.fresnel_team_color);
						}
					} else {
						mdl.write_line("Shader \"\",");

						for (const auto& layer : material.layers) {
							mdl.start_group("Layer", [&]() {
								switch (layer.blend_mode) {
									case 0:
										mdl.write_line("FilterMode None");
										break;
									case 1:
										mdl.write_line("FilterMode Transparent");
										break;
									case 2:
										mdl.write_line("FilterMode Blend");
										break;
									case 3:
										mdl.write_line("FilterMode Additive");
										break;
									case 4:
										mdl.write_line("FilterMode AddAlpha");
										break;
									case 5:
										mdl.write_line("FilterMode Modulate");
										break;
									case 6:
										mdl.write_line("FilterMode Modulate2x");
										break;
								}

								if (layer.shading_flags & Layer::ShadingFlags::unshaded) {
									mdl.write_line("Unshaded");
								}

								if (layer.shading_flags & Layer::ShadingFlags::unfogged) {
									mdl.write_line("Unfogged");
								}

								if (layer.shading_flags & Layer::ShadingFlags::no_depth_test) {
									mdl.write_line("NoDepthTest");
								}

								if (layer.shading_flags & Layer::ShadingFlags::no_depth_set) {
									mdl.write_line("NoDepthSet");
								}

								mdl.write_track(layer.textures.at(0).KMTF, "TextureID", layer.textures.at(0).id);
								mdl.write_track(layer.KMTA, "Alpha", layer.alpha);
								mdl.write_track(layer.KMTE, "EmissiveGain", layer.emissive_gain);
								mdl.write_track(layer.KFC3, "FresnelColor", layer.fresnel_color);
								mdl.write_track(layer.KFCA, "FresnelAlpha", layer.fresnel_opacity);
								mdl.write_track(layer.KFTC, "FresnelTeamColor", layer.fresnel_team_color);
							});
						}
					}
				});
			}
		});

		for (const auto& geoset : geosets) {
			mdl.start_group("Geoset", [&]() {
				mdl.start_group(std::format("Vertices {}", geoset.vertices.size()), [&]() {
					for (const auto& vertex : geoset.vertices) {
						mdl.write_line("{{ {}, {}, {} }},", vertex.x, vertex.y, vertex.z);
					}
				});

				mdl.start_group(std::format("Normals {}", geoset.normals.size()), [&]() {
					for (const auto& normal : geoset.normals) {
						mdl.write_line("{{ {}, {}, {} }},", normal.x, normal.y, normal.z);
					}
				});

				for (const auto& i : geoset.uv_sets) {
					mdl.start_group(std::format("TVertices {}", i.size()), [&]() {
						for (const auto& uv : i) {
							mdl.write_line("{{ {}, {} }},", uv.x, uv.y);
						}
					});
				}

				mdl.start_group(std::format("Tangents {}", geoset.tangents.size()), [&]() {
					for (const auto& tangent : geoset.tangents) {
						mdl.write_line("{{ {}, {}, {}, {} }},", tangent.x, tangent.y, tangent.z, tangent.w);
					}
				});

				mdl.start_group(std::format("SkinWeights {}", geoset.skin.size() / 8), [&]() {
					for (size_t i = 0; i < geoset.skin.size() / 8; i++) {
						mdl.write_line("{}, {}, {}, {}, {}, {}, {}, {},",
												   geoset.skin[i * 8],
												   geoset.skin[i * 8 + 1],
												   geoset.skin[i * 8 + 2],
												   geoset.skin[i * 8 + 3],
												   geoset.skin[i * 8 + 4],
												   geoset.skin[i * 8 + 5],
												   geoset.skin[i * 8 + 6],
												   geoset.skin[i * 8 + 7]);
					}
				});

				mdl.start_group(std::format("Faces {}", geoset.faces.size()), [&]() {
					mdl.start_group("Triangles", [&]() { // Y'all mfs gonna be having triangles, I ain't in the quad business
						std::string triangles;
						for (const auto& face : geoset.faces) {
							triangles += std::format("{}, ", face);
						}

						mdl.write_line("{{ {} }}", triangles);
					});
				});

				mdl.write_line("MinimumExtent {{ {}, {}, {} }},", geoset.extent.minimum.x, geoset.extent.minimum.z, geoset.extent.minimum.z);
				mdl.write_line("MaximumExtent {{ {}, {}, {} }},", geoset.extent.maximum.x, geoset.extent.maximum.z, geoset.extent.maximum.z);
				mdl.write_line("BoundsRadius {},", geoset.extent.bounds_radius);

				for (const auto& i : geoset.sequence_extents) {
					mdl.start_group("Anim", [&]() {
						mdl.write_line("MinimumExtent {{ {}, {}, {} }},", i.minimum.x, i.minimum.z, i.minimum.z);
						mdl.write_line("MaximumExtent {{ {}, {}, {} }},", i.maximum.x, i.maximum.z, i.maximum.z);
						mdl.write_line("BoundsRadius {},", i.bounds_radius);
					});
				}

				mdl.write_line("MaterialID {},", geoset.material_id);
				mdl.write_line("SelectionGroup {},", geoset.selection_group);
				mdl.write_line("LevelOfDetail 0,");
				mdl.write_line("Name {},", geoset.lod_name);
			});
		}

		for (const auto& geoset_anim : animations) {
			mdl.start_group("GeosetAnim", [&]() {
				mdl.write_track(geoset_anim.KGAO, "Alpha", geoset_anim.alpha);
				mdl.write_track(geoset_anim.KGAC, "Color", geoset_anim.color);
				mdl.write_line("GeosetId {}", geoset_anim.geoset_id);
			});
		}

		for (const auto& bone : bones) {
			mdl.start_group(std::format("Bone \"{}\"", bone.node.name), [&]() {
				mdl.write_line("GeosetId {},", bone.geoset_id); // The MDL has "Multiple" as value for some reason
				mdl.write_line("GeosetAnimId {},", bone.geoset_animation_id); // And this one has "None"

				mdl.write_node(bone.node);
			});
		}

		for (const auto& help_bone : help_bones) {
			mdl.start_group(std::format("Helper \"{}\"", help_bone.name), [&]() {
				mdl.write_node(help_bone);
			});
		}

		for (const auto& attachment : attachments) {
			mdl.start_group(std::format("Helper \"{}\"", attachment.node.name), [&]() {
				mdl.write_node(attachment.node);
				mdl.write_line("AttachmentID {},", attachment.attachment_id);
				mdl.write_track(attachment.KATV, "Visibility", 0.f); // dunno
			});
		}

		mdl.start_group(std::format("PivotPoints \"{}\"", pivots.size()), [&]() {
			for (const auto& pivot : pivots) {
				mdl.write_line("{{ {}, {}, {} }},", pivot.x, pivot.y, pivot.z);
			}
		});

		for (const auto& emitter : emitters2) {
			mdl.start_group(std::format("ParticleEmitter2 \"{}\"", emitter.node.name), [&]() {
				mdl.write_node(emitter.node);

				mdl.write_track(emitter.KP2S, "Speed", emitter.speed);
				mdl.write_track(emitter.KP2R, "Variation", emitter.variation);
				mdl.write_track(emitter.KP2L, "Latitude", emitter.latitude);
				mdl.write_track(emitter.KP2G, "Gravity", emitter.gravity);
				if (emitter.squirt) {
					mdl.write_line("Squirt,");
				}
				mdl.write_track(emitter.KP2V, "Visibility", 0.f); // ToDo static value
				mdl.write_line("Lifespan {},", emitter.life_span);
				mdl.write_track(emitter.KP2E, "EmissionRate", emitter.emission_rate);
				mdl.write_track(emitter.KP2W, "Width", emitter.width);
				mdl.write_track(emitter.KP2N, "Length", emitter.length);

				switch (emitter.filter_mode) {
					case 0:
						mdl.write_line("Blend");
						break;
					case 1:
						mdl.write_line("Additive");
						break;
					case 2:
						mdl.write_line("Modulate");
						break;
					case 3:
						mdl.write_line("Modulate2x");
						break;
					case 4:
						mdl.write_line("AlphaKey");
						break;
				}

				mdl.write_line("Rows {},", emitter.rows);
				mdl.write_line("Columns {},", emitter.columns);

				if (emitter.head_or_tail == 0) {
					mdl.write_line("Head,");
				} else if (emitter.head_or_tail == 0) {
					mdl.write_line("Tail,");
				} else {
					mdl.write_line("Both,");
				}

				mdl.write_line("TailLength {},", emitter.tail_length);
				mdl.write_line("Time {},", emitter.time_middle);

				mdl.start_group("SegmentColor", [&]() {
					mdl.write_line("Color {{ {}, {}, {}  }},", emitter.start_segment_color.x, emitter.start_segment_color.y, emitter.start_segment_color.z);
					mdl.write_line("Color {{ {}, {}, {}  }},", emitter.middle_segment_color.x, emitter.middle_segment_color.y, emitter.middle_segment_color.z);
					mdl.write_line("Color {{ {}, {}, {}  }},", emitter.end_segment_color.x, emitter.end_segment_color.y, emitter.end_segment_color.z);
				});

				mdl.write_line("Alpha {{ {}, {}, {}  }},", emitter.segment_alphas.x, emitter.segment_alphas.y, emitter.segment_alphas.z);
				mdl.write_line("ParticleScaling {{ {}, {}, {}  }},", emitter.segment_scaling.x, emitter.segment_scaling.y, emitter.segment_scaling.z);
				mdl.write_line("LifeSpanUVAnim {{ {}, {}, {}  }},", emitter.head_intervals.x, emitter.head_intervals.y, emitter.head_intervals.z);
				mdl.write_line("DecayUVAnim {{ {}, {}, {}  }},", emitter.head_decay_intervals.x, emitter.head_decay_intervals.y, emitter.head_decay_intervals.z);
				mdl.write_line("TailUVAnim {{ {}, {}, {}  }},", emitter.tail_intervals.x, emitter.tail_intervals.y, emitter.tail_intervals.z);
				mdl.write_line("TailDecayUVAnim {{ {}, {}, {}  }},", emitter.tail_decay_intervals.x, emitter.tail_decay_intervals.y, emitter.tail_decay_intervals.z);

				mdl.write_line("TextureID {},", emitter.texture_id);
				mdl.write_line("PriorityPlane {},", emitter.priority_plane);
			});
		}

		for (const auto& event_object : event_objects) {
			mdl.start_group(std::format("EventObject \"{}\"", event_object.node.name), [&]() {
				mdl.write_node(event_object.node);

				mdl.start_group(std::format("EventTrack {}", event_object.times.size()), [&]() {
					for (const auto& track : event_object.times) {
						mdl.write_line("{},", track);
					}
				});
			});
		}

		for (const auto& collision_shape : collision_shapes) {
			mdl.start_group(std::format("CollisionShape \"{}\"", collision_shape.node.name), [&]() {
				mdl.write_node(collision_shape.node);

				switch (collision_shape.type) {
					case CollisionShape::Shape::Box:
						mdl.write_line("Cube,");
						mdl.start_group("Vertices 2", [&]() {
							mdl.write_line("{{ {}, {}, {}  }},", collision_shape.vertices[0].x, collision_shape.vertices[0].y, collision_shape.vertices[0].z);
							mdl.write_line("{{ {}, {}, {}  }},", collision_shape.vertices[1].x, collision_shape.vertices[1].y, collision_shape.vertices[1].z);
						});
						break;
					case CollisionShape::Shape::Plane:
						mdl.write_line("Plane,");
						mdl.start_group("Vertices 2", [&]() {
							mdl.write_line("{{ {}, {}, {}  }},", collision_shape.vertices[0].x, collision_shape.vertices[0].y, collision_shape.vertices[0].z);
							mdl.write_line("{{ {}, {}, {}  }},", collision_shape.vertices[1].x, collision_shape.vertices[1].y, collision_shape.vertices[1].z);
						});
						break;
					case CollisionShape::Shape::Sphere:
						mdl.write_line("Sphere,");
						mdl.start_group("Vertices 1", [&]() {
							mdl.write_line("{{ {}, {}, {}  }},", collision_shape.vertices[0].x, collision_shape.vertices[0].y, collision_shape.vertices[0].z);
						});
						mdl.write_line("BoundsRadius {},", collision_shape.radius);
						break;
					case CollisionShape::Shape::Cylinder:
						mdl.write_line("Cylinder,");
						mdl.start_group("Vertices 2", [&]() {
							mdl.write_line("{{ {}, {}, {}  }},", collision_shape.vertices[0].x, collision_shape.vertices[0].y, collision_shape.vertices[0].z);
							mdl.write_line("{{ {}, {}, {}  }},", collision_shape.vertices[1].x, collision_shape.vertices[1].y, collision_shape.vertices[1].z);
						});
						mdl.write_line("BoundsRadius {},", collision_shape.radius);
						break;
				}
			});
		}
		std::println("Elapsed {}ms", timer.elapsed_ms());
		return mdl.mdl;
	}
} // namespace mdx
```

`src/file_formats/mdx/mdx.ixx`:

```ixx
export module MDX;

import std;
import BinaryReader;
import BinaryWriter;
import Timer;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;
import <glm/gtc/quaternion.hpp>;
import <outcome/outcome.hpp>;

namespace fs = std::filesystem;
using OUTCOME_V2_NAMESPACE::failure;
using OUTCOME_V2_NAMESPACE::result;

namespace mdx {
	export extern const std::unordered_map<int, std::string> replaceable_id_to_texture{
		{ 1, "ReplaceableTextures/TeamColor/TeamColor00" },
		{ 2, "ReplaceableTextures/TeamGlow/TeamGlow00" },
		{ 11, "ReplaceableTextures/Cliff/Cliff0" },
		{ 31, "ReplaceableTextures/LordaeronTree/LordaeronFallTree" },
		{ 32, "ReplaceableTextures/AshenvaleTree/AshenTree" },
		{ 33, "ReplaceableTextures/BarrensTree/BarrensTree" },
		{ 34, "ReplaceableTextures/NorthrendTree/NorthTree" },
		{ 35, "ReplaceableTextures/Mushroom/MushroomTree" },
		{ 36, "ReplaceableTextures/RuinsTree/RuinsTree" },
		{ 37, "ReplaceableTextures/OutlandMushroomTree/MushroomTree" }
	};

	enum class TrackTag {
		KMTF = 'FTMK',
		KMTA = 'ATMK',
		KTAT = 'TATK',
		KTAR = 'RATK',
		KTAS = 'SATK',
		KGAO = 'OAGK',
		KGAC = 'CAGK',
		KLAS = 'SALK',
		KLAE = 'EALK',
		KLAC = 'CALK',
		KLAI = 'IALK',
		KLBI = 'IBLK',
		KLBC = 'CBLK',
		KLAV = 'VALK',
		KATV = 'VTAK',
		KPEE = 'EEPK',
		KPEG = 'GEPK',
		KPLN = 'NLPK',
		KPLT = 'TLPK',
		KPEL = 'LEPK',
		KPES = 'SEPK',
		KPEV = 'VEPK',
		KP2S = 'S2PK',
		KP2R = 'R2PK',
		KP2L = 'L2PK',
		KP2G = 'G2PK',
		KP2E = 'E2PK',
		KP2N = 'N2PK',
		KP2W = 'W2PK',
		KP2V = 'V2PK',
		KRHA = 'AHRK',
		KRHB = 'BHRK',
		KRAL = 'LARK',
		KRCO = 'OCRK',
		KRTX = 'XTRK',
		KRVS = 'SVRK',
		KCTR = 'RTCK',
		KTTR = 'RTTK',
		KCRL = 'LRCK',
		KGTR = 'RTGK',
		KGRT = 'TRGK',
		KGSC = 'CSGK',
		KFC3 = '3CFK',
		KFCA = 'ACFK',
		KFTC = 'CTFK',
		KMTE = 'ETMK'
	};

	enum class ChunkTag {
		VERS = 'SREV',
		GEOS = 'SOEG',
		MTLS = 'SLTM',
		SEQS = 'SQES',
		GLBS = 'SBLG',
		GEOA = 'AOEG',
		BONE = 'ENOB',
		TEXS = 'SXET',
		LITE = 'ETIL',
		HELP = 'PLEH',
		ATCH = 'HCTA',
		PIVT = 'TVIP',
		PREM = 'MERP',
		PRE2 = '2ERP',
		RIBB = 'BBIR',
		EVTS = 'STVE',
		CLID = 'DILC',
		CORN = 'NROC',
		SNDS = 'SDNS',
		TXAN = 'NAXT',
		BPOS = 'SOPB',
		FAFX = 'XFAF',
		MODL = 'LDOM',
		CAMS = 'SMAC'
	};

	export template <typename T>
	struct Track {
		int32_t frame;
		T value;
		T inTan;
		T outTan;

		bool operator==(const Track&) const = default;
	};

	export enum class InterpolationType {
		none = 0,
		linear = 1,
		hermite = 2,
		bezier = 3,
	};

	export template <typename T>
	struct TrackHeader {
		InterpolationType interpolation_type = InterpolationType::none;
		int32_t global_sequence_ID = -1;
		std::vector<Track<T>> tracks;

		int id = -1; // Used to track each individual track for animation purposes

		TrackHeader() = default;
		explicit TrackHeader(BinaryReader& reader, int track_id) {
			const uint32_t tracks_count = reader.read<uint32_t>();
			interpolation_type = static_cast<InterpolationType>(reader.read<int32_t>());
			global_sequence_ID = reader.read<int32_t>();
			id = track_id;

			tracks.reserve(tracks_count);
			for (size_t i = 0; i < tracks_count; i++) {
				Track<T> track;
				track.frame = reader.read<int32_t>();
				track.value = reader.read<T>();
				if (interpolation_type == InterpolationType::bezier || interpolation_type == InterpolationType::hermite) {
					track.inTan = reader.read<T>();
					track.outTan = reader.read<T>();
				}
				tracks.push_back(track);
			}
		}

		void save(TrackTag tag, BinaryWriter& writer) const {
			if (tracks.empty()) {
				return;
			}

			writer.write<uint32_t>(static_cast<uint32_t>(tag));
			writer.write<uint32_t>(tracks.size());
			writer.write<uint32_t>(interpolation_type);
			writer.write<uint32_t>(global_sequence_ID);

			for (const auto& i : tracks) {
				writer.write<uint32_t>(i.frame);
				writer.write<T>(i.value);
				if (interpolation_type == InterpolationType::bezier || interpolation_type == InterpolationType::hermite) {
					writer.write<T>(i.inTan);
					writer.write<T>(i.outTan);
				}
			}
		}

		bool operator==(const TrackHeader&) const = default;
	};

	export struct LayerTexture {
		uint32_t id;
		TrackHeader<uint32_t> KMTF;

		bool operator==(const LayerTexture&) const = default;
	};

	export struct Layer {
		uint32_t blend_mode;
		uint32_t shading_flags;
		uint32_t texture_animation_id;
		uint32_t coord_id;
		float alpha;

		float emissive_gain;
		glm::vec3 fresnel_color;
		float fresnel_opacity;
		float fresnel_team_color;

		bool hd;

		std::vector<LayerTexture> textures;

		TrackHeader<float> KMTA;
		TrackHeader<float> KMTE;
		TrackHeader<glm::vec3> KFC3;
		TrackHeader<float> KFCA;
		TrackHeader<float> KFTC;

		enum ShadingFlags {
			unshaded = 1,
			sphere_environment_map = 2,
			unknown1 = 4,
			unknown2 = 8,
			two_sided = 16,
			unfogged = 32,
			no_depth_test = 64,
			no_depth_set = 128
		};

		bool operator==(const Layer&) const = default;
	};

	export struct Node {
		Node() = default;
		explicit Node(BinaryReader& reader, int& unique_tracks) {
			const size_t reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			name = reader.read_string(80);
			id = reader.read<uint32_t>();
			parent_id = reader.read<uint32_t>();
			flags = reader.read<uint32_t>();

			while (reader.position < reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KGTR) {
					KGTR = TrackHeader<glm::vec3>(reader, unique_tracks++);
				} else if (tag == TrackTag::KGRT) {
					KGRT = TrackHeader<glm::quat>(reader, unique_tracks++);
				} else if (tag == TrackTag::KGSC) {
					KGSC = TrackHeader<glm::vec3>(reader, unique_tracks++);
				} else {
					std::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
		}

		void save(BinaryWriter& writer) const {
			// Write temporary zero, remember location
			size_t inclusive_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write_c_string_padded(name, 80);
			writer.write<uint32_t>(id);
			writer.write<uint32_t>(parent_id);
			writer.write<uint32_t>(flags);

			KGTR.save(TrackTag::KGTR, writer);
			KGRT.save(TrackTag::KGRT, writer);
			KGSC.save(TrackTag::KGSC, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index);
			std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
		}

		std::string name;
		int id;
		int parent_id;
		int flags;

		TrackHeader<glm::vec3> KGTR;
		TrackHeader<glm::quat> KGRT;
		TrackHeader<glm::vec3> KGSC;

		enum Flags {
			dont_inherit_translation = 0x1,
			dont_inherit_rotation = 0x2,
			dont_inherit_scaling = 0x4,
			billboarded = 0x8,
			billboarded_lock_x = 0x10,
			billboarded_lock_y = 0x20,
			billboarded_lock_z = 0x40,
			camera_anchored = 0x80,
			bone = 0x100,
			light = 0x200,
			object = 0x400,
			attachment = 0x800,
			emitter = 0x1000,
			collision_shape = 0x2000,
			ribbon_emitter = 0x4000,
			// if_particle_emitter : emitter_uses_mdl,
			unshaded = 0x8000,
			// if_particle_emitter : emitter_uses_tga,
			sort_primitives_far_z = 0x10000,
			line_emitter = 0x20000,
			unfogged = 0x40000,
			model_space = 0x80000,
			xy_quad = 0x100000
		};
	};

	export struct Extent {
		float bounds_radius;
		glm::vec3 minimum;
		glm::vec3 maximum;

		Extent() = default;
		explicit Extent(BinaryReader& reader) {
			bounds_radius = reader.read<float>();
			minimum = reader.read<glm::vec3>();
			maximum = reader.read<glm::vec3>();
		}

		void save(BinaryWriter& writer) const {
			writer.write<float>(bounds_radius);
			writer.write<glm::vec3>(minimum);
			writer.write<glm::vec3>(maximum);
		}
	};

	export struct Sequence {
		std::string name;
		uint32_t start_frame;
		uint32_t end_frame;
		float movespeed;
		uint32_t flags;
		float rarity;
		uint32_t sync_point;
		Extent extent;

		enum Flags {
			looping,
			non_looping
		};
	};

	export struct Geoset {
		std::vector<glm::vec3> vertices;
		std::vector<glm::vec3> normals;
		std::vector<uint32_t> face_type_groups;
		std::vector<uint32_t> face_groups;
		std::vector<uint16_t> faces;
		std::vector<uint8_t> vertex_groups;
		std::vector<uint32_t> matrix_groups;
		std::vector<uint32_t> matrix_indices;

		uint32_t material_id;
		uint32_t selection_group;
		uint32_t selection_flags;
	    /// LODs are unused by the WC3 engine afaik
		uint32_t lod;
		std::string lod_name;
	    /// The extent of this geoset not accounting for animations (?)
		Extent extent;

		/// One per sequence?
		std::vector<Extent> sequence_extents;

		std::vector<glm::vec4> tangents;
		/// vertices.size() * 4 bone indices, each a byte, 4 weights, each a byte
		std::vector<uint8_t> skin;
		/// We only support one uv set
		std::vector<std::vector<glm::vec2>> uv_sets;
	};

	export struct GeosetAnimation {
		float alpha;
		uint32_t flags;
		glm::vec3 color; // BGR, not RGB
		uint32_t geoset_id;

		TrackHeader<float> KGAO;
		TrackHeader<glm::vec3> KGAC;
	};

	export struct Texture {
		uint32_t replaceable_id;
		fs::path file_name;
		uint32_t flags;

		enum Flags {
			wrap_width = 1,
			wrap_height
		};

		bool operator==(const Texture&) const = default;
	};

	export struct Material {
		uint32_t priority_plane;
		uint32_t flags;
		std::vector<Layer> layers;

		bool operator==(const Material&) const = default;
	};

	struct Bone {
		Node node;
		int32_t geoset_id;
		int32_t geoset_animation_id;
	};

	struct Light {
		Node node;
		int type;
		int attenuation_start;
		int attenuation_end;
		glm::vec3 color;
		float intensity;
		glm::vec3 ambient_color;
		float ambient_intensity;
		float shadow_intensity;

		TrackHeader<uint32_t> KLAS;
		TrackHeader<uint32_t> KLAE;
		TrackHeader<glm::vec3> KLAC;
		TrackHeader<float> KLAI;
		TrackHeader<float> KLBI;
		TrackHeader<glm::vec3> KLBC;
		TrackHeader<float> KLAV;
	};

	struct Attachment {
		Node node;
		std::string path; // Reference to Undead, NE, or Naga birth anim
		int reserved;	  // ToDo mine meaning of reserved from Game.dll, likely strlen
		int attachment_id;

		TrackHeader<float> KATV;
	};

	// Dragon/bird death bone emitter; usually emit MDLs based
	// on "path" string, but has a setting to emit TGAs from
	// path also (In practice EmitterUsesTGA setting is almost
	// never used, in favor of ParticleEmitter2).
	struct ParticleEmitter1 {
		Node node;
		float emission_rate;
		float gravity;
		float longitude;
		float latitude;
		std::string path;
		int reserved; // ToDo mine meaning, same as Attachment's reserved?
		float life_span;
		float speed;

		TrackHeader<float> KPEE;
		TrackHeader<float> KPEG;
		TrackHeader<float> KPLN;
		TrackHeader<float> KPLT;
		TrackHeader<float> KPEL;
		TrackHeader<float> KPES;
		TrackHeader<float> KPEV;
	};

	/*
	ParticleEmitter2: Texture only advanced "v2" emitter (99.9% of use cases)

	The "Tail" mode emits elongated particles, and the "Head"
	mode emits perfect square shapes. If you think about
	something like frost armor's damage that looks like a "strike,"
	this is a tail particle. The Wisp is another example. Disenchant
	is another.
	This can also be used where all elongated particles are going
	the same direction (based on latitude settings), such as the
	vertical lines in the yellow "heal" spell effect.

	The "Head" mode would be used for the snowflakes in frost armor's
	damage. It is also used in the water spray from the base of the
	Water Elemental. We say in comments we want to support the bubble geyser.
	That is a "Head" mode particle emitting a bubble
	texture, and a second one with XYQuad setting (flat, not facing camera) emitting the
	ripples above the water.

	There is also a "Both" mode that will emit both head and tail (when head_or_tail=2).

	--
	Each ParticleEmitter2 is a rectangular area specified by length and width that
	can be hand drawn in 3DS max, but many of them choose to forgo use of the rectangle,
	make it very small, and then use latitude settings to emit outward in all directions
	randomly, effectively making a point emitter (like NE Wisp).
	I seem to recall that variation is the random speed variation (when zero,
	all particles would move with equal speed, modified downward by gravity setting
	as an acceleration ).
	*/
	struct ParticleEmitter2 {
		Node node;
		float speed;
		float variation;
		float latitude;
		float gravity;
		float life_span;
		float emission_rate;
		float length;
		float width;
		uint32_t filter_mode;
		uint32_t rows; // for Textures\Clouds8x8 files
		uint32_t columns;
		uint32_t head_or_tail;
		float tail_length;
		float time_middle;

		glm::vec3 start_segment_color;
		glm::vec3 middle_segment_color;
		glm::vec3 end_segment_color;
		glm::u8vec3 segment_alphas;
		glm::vec3 segment_scaling;
		glm::uvec3 head_intervals;
		glm::uvec3 head_decay_intervals;
		glm::uvec3 tail_intervals;
		glm::uvec3 tail_decay_intervals;
		uint32_t texture_id;
		uint32_t squirt;
		uint32_t priority_plane;
		uint32_t replaceable_id; // for Wisp team color particles

		TrackHeader<float> KP2S;
		TrackHeader<float> KP2R;
		TrackHeader<float> KP2L;
		TrackHeader<float> KP2G;
		TrackHeader<float> KP2E;
		TrackHeader<float> KP2N;
		TrackHeader<float> KP2W;
		TrackHeader<float> KP2V;
	};

	struct RibbonEmitter {
		Node node;
		float height_above;
		float height_below;
		float alpha;
		glm::vec3 color;
		float life_span;
		uint32_t texture_slot;
		uint32_t emission_rate;
		uint32_t rows;
		uint32_t columns;
		uint32_t material_id; // note: not a texture id, avoids need for filtermode field like PE2
		float gravity;

		TrackHeader<float> KRHA;
		TrackHeader<float> KRHB;
		TrackHeader<float> KRAL;
		TrackHeader<glm::vec3> KRCO;
		TrackHeader<uint32_t> KRTX;
		TrackHeader<float> KRVS;
	};

	/*
	 EventObjects:
	 The type of sound or spawned effect is determined by node name
	 and SLK table lookup. The default World Editor ignores EventObjects
	 entirely, so they are only viewable in game. Even when you activate
	 the GEM setting in the Terrain Editor and listen for unit death sounds
	 when deleting them, the World Editor plays the sound file from the soundset
	 information despite the game playing the sound file from the EventObject.

	 Every EventObject's name is typically 8 characters. It usually starts with:
		SPN to spawn a model file from "Splats\SpawnData.slk"
		   - Example: illidan footprints, blood particle emitters
		SPLT to spawn a ground texture from "Splats\SplatData.slk"
			 - Example: blood ground texture on unit death
		FPT to spawn a footprint also from "Splats\SplatData.slk"
		   - It is possible that FPT animates differently,
			 such as only shows on certain terrain?? (ToDo research if needed)
		   - Some FPT entries make situational sounds, such as spiders walking on metallic
			 tiles (icecrown tileset bricks/runes) if memory serves? (ToDo research if needed)
		UBR to spawn a temporary uber splat from "Splats\UberSplatData.slk"
		   - Example: Several buildings, when they die, use an UBR tag to create a crater
			   style ground texture. Flamestrike also uses this style of model tag
			 to spawn its ground texture.
		SND to play a sound from "UI\SoundInfo\AnimLookups.slk" (unit death and spell sounds)

	 The 4 last characters of the 8-character name will be the 4-digit rawcode
	 SLK table lookup key within the particular table being used.
	 RoC Beta had 5-digit rawcodes present in the UberSplatData.slk
	 that I did not research. They were probably just a different way
	 to store terrain information; I do not know if they were used in any
	 model files. The uber splat table is also used by the World Editor
	 for building Ground Textures, so it is possible that the World Editor
	 accepts the five letter codes and this allowed Blizzard to test the
	 different per-tileset variations of the entries.

	 For 3-letter table names, like FPT, the 4th character is often "x" or "y",
	 presumably a redundant indicator for left or right, although both
	 flipped versions of most footprint textures exist and are loaded with
	 separate table entries.

	 Tags like "SNDxPOOP" might exist for an SLK table entry we do not have that is only
	 found in custom environments. Although modern maps cannot easily override
	 these tables, old MPQ mods on historic versions of the game exist with
	 fan created table entries. For example, in the TToR Mod, when you
	 kill a Balrog it makes a very loud custom noise that is embedded into
	 the model via a custom EventObject. So we must allow invalid entries without crashing.
	 If the "times" vector is empty, then War3 does not load the model, and we can consider
	 it invalid.
	*/
	struct EventObject {
		Node node;
		int global_sequence_id; // signed, -1 to specify "none"
		std::vector<uint32_t> times;
	};

	/*
	I was pretty sure that in the old days, not having a CollisionShape meant that
	a unit was not able to be selected in-game. However, at some point,
	I think they patched it so that it usually always works. Might've been
	the 2009 patch cycle, could have been TFT.

	So at this point I've seen some models that didn't have collision shapes that
	worked fine, but we need to parse them for rendering since they are legal
	nodes and could technically be a parent of another node.

	(They are used for ray intersection bounding cues, not for in-game "collision")
	(World editor doesn't use them and uses MODL/GEOS for selection and bounding cues, which
	is also why you don't ever have a doodad model that cant be clicked on in WE,
	even though some doodad models can't be clicked on easily in-game)

	Voidwalker's attack animation animates his CollisionShape to float outside
	of his center and DracoL1ch said that for DotA at some point he had to
	replace the Voidwalker model because of user complaints where the Voidwalker
	model had "invincibility frames" effectively, where it could not be attacked,
	because the CollisionShape had floated away.
	*/
	struct CollisionShape {
		enum class Shape {
			Box = 0,	 // 2 verts
			Plane = 1,	 // 2 verts
			Sphere = 2,	 // 1 verts
			Cylinder = 3 // 2 vert
		};

		Node node;
		Shape type;
		glm::vec3 vertices[2]; // sometimes only 1 is used
		float radius;		   // used for sphere/cylinder
	};

	struct FaceFX {
		std::string name;
		fs::path path;
	};

	struct CornEmitter {
		Node node;
		std::vector<uint8_t> data; // Just store it so we can save it again
	};

	struct Camera {
		std::vector<uint8_t> data; // Just store it so we can save it again
	};

	struct TextureAnimation {
		std::vector<uint8_t> data; // Just store it so we can save it again
	};

	export class MDX {
	public:
		int unique_tracks = 0;

		static constexpr uint32_t LATEST_MDX_VERSION = 1200;

		uint32_t version = LATEST_MDX_VERSION;
		std::string name;
		std::string animation_filename;
		Extent extent;
		uint32_t blend_time;

		std::string face_target;
		std::string face_path;

		std::vector<Geoset> geosets;
		std::vector<Sequence> sequences;
		std::vector<uint32_t> global_sequences;
		std::vector<GeosetAnimation> animations;
		std::vector<Bone> bones;
		std::vector<Material> materials;
		std::vector<Texture> textures;
		std::vector<Light> lights;
		std::vector<Node> help_bones;
		std::vector<Attachment> attachments;
		std::vector<glm::vec3> pivots;
		std::vector<ParticleEmitter1> emitters1;
		std::vector<ParticleEmitter2> emitters2;
		std::vector<RibbonEmitter> ribbons;
		std::vector<EventObject> event_objects;
		std::vector<CollisionShape> collision_shapes;
		std::vector<CornEmitter> corn_emitters;
		std::vector<FaceFX> facefxes;
		std::vector<Camera> cameras;
		std::vector<float> bind_poses;
		std::vector<TextureAnimation> texture_animations;

	private:
		void load(BinaryReader& reader);

	public:
		MDX() = default;

		explicit MDX(BinaryReader& reader) {
			load(reader);
		}

		[[nodiscard]] BinaryWriter save() const;

		std::string to_mdl();
		static result<MDX, std::string> from_mdl(std::string_view mdl);

		void validate();

		void merge_with(const MDX& mdx, const glm::mat4& transform);

		static std::vector<glm::u8vec4> matrix_groups_as_skin_weights(const Geoset& geoset);

		struct OptimizationStats {
			size_t materials_removed = 0;
			size_t textures_removed = 0;

			size_t constant_tracks = 0;
			size_t constant_tracks_removed = 0;
			size_t linear_tracks = 0;
			size_t linear_tracks_removed = 0;
			size_t hermite_tracks = 0;
			size_t hermite_tracks_removed = 0;
			size_t bezier_tracks = 0;
			size_t bezier_tracks_removed = 0;
		};

		OptimizationStats optimize(float max_error);
		MDX& deduplicate_textures();
		MDX& deduplicate_materials();
		MDX& deduplicate_geosets();

		MDX& calculate_extents();

		template<std::invocable<Node&> Func>
		void for_each_node(const Func F) {
			for (auto& i : bones) {
				F(i.node);
			}

			for (auto& i : lights) {
				F(i.node);
			}

			for (auto& i : help_bones) {
				F(i);
			}

			for (auto& i : attachments) {
				F(i.node);
			}

			for (auto& i : emitters1) {
				F(i.node);
			}

			for (auto& i : emitters2) {
				F(i.node);
			}

			for (auto& i : ribbons) {
				F(i.node);
			}

			for (auto& i : event_objects) {
				F(i.node);
			}

			for (auto& i : collision_shapes) {
				F(i.node);
			}

			for (auto& i : corn_emitters) {
				F(i.node);
			}
		}

		template<typename Func>
		requires std::invocable<Func, TrackHeader<float>&>
		and std::invocable<Func, TrackHeader<uint32_t>&>
		and std::invocable<Func, TrackHeader<glm::vec3>&>
		and std::invocable<Func, TrackHeader<glm::quat>&>
		void for_each_track(const Func F) {
			for_each_node([&](Node& node) {
				F(node.KGRT);
				F(node.KGTR);
				F(node.KGSC);
			});

			for (auto& i : animations) {
				F(i.KGAC);
				F(i.KGAO);
			}

			for (auto& i : attachments) {
				F(i.KATV);
			}

			for (auto& i : emitters1) {
				F(i.KPEE);
				F(i.KPEG);
			}

			for (auto& i : emitters2) {
				F(i.KP2E);
				F(i.KP2G);
				F(i.KP2R);
				F(i.KP2W);
				F(i.KP2N);
			}

			for (auto& i : materials) {
				for (auto& j : i.layers) {
					F(j.KMTA);
					F(j.KMTE);
					F(j.KFC3);
					F(j.KFCA);
					F(j.KFTC);
					for (auto& k : j.textures) {
						F(k.KMTF);
					}
				}
			}

			for (auto& i : lights) {
				F(i.KLAS);
				F(i.KLAE);
				F(i.KLAC);
				F(i.KLAI);
				F(i.KLBI);
				F(i.KLBC);
				F(i.KLAV);
			}

			for (auto& i : ribbons) {
				F(i.KRHA);
				F(i.KRHB);
				F(i.KRAL);
				F(i.KRCO);
				F(i.KRTX);
				F(i.KRVS);
			}
		}
	};
} // namespace mdx

// All our hashes
// C++ really needs a derive macro for this
template <typename T>
void hash_combine(std::size_t& seed, const T& v) {
	seed ^= std::hash<T>{}(v) + 0x9e3779b97f4a7c15ULL + (seed<<6) + (seed>>2);
}

template <typename T>
struct hash_vector {
	std::size_t operator()(const std::vector<T>& vec) const {
		std::size_t h = 0;
		for (const auto& item : vec)
			hash_combine(h, item);  // assumes std::hash<T> is defined
		return h;
	}
};

namespace std {
	template <>
	struct hash<glm::vec3> {
		std::size_t operator()(const glm::vec3& v) const {
			std::size_t h = 0;
			hash_combine(h, v.x);
			hash_combine(h, v.y);
			hash_combine(h, v.z);
			return h;
		}
	};

	template <typename T>
	struct std::hash<mdx::Track<T>> {
		std::size_t operator()(const mdx::Track<T>& t) const {
			std::size_t h = 0;
			hash_combine(h, t.frame);
			hash_combine(h, t.value);
			hash_combine(h, t.inTan);
			hash_combine(h, t.outTan);
			return h;
		}
	};

	template <typename T>
	struct std::hash<mdx::TrackHeader<T>> {
		std::size_t operator()(const mdx::TrackHeader<T>& th) const {
			std::size_t h = 0;
			hash_combine(h, static_cast<int>(th.interpolation_type));
			hash_combine(h, th.global_sequence_ID);
			for (const auto& track : th.tracks)
				hash_combine(h, track);
			return h;
		}
	};

	template <>
	struct hash<mdx::LayerTexture> {
		std::size_t operator()(const mdx::LayerTexture& lt) const {
			std::size_t h = 0;
			hash_combine(h, lt.id);
			hash_combine(h, lt.KMTF);
			return h;
		}
	};


	template <>
	struct hash<mdx::Layer> {
		std::size_t operator()(const mdx::Layer& l) const {
			std::size_t h = 0;
			hash_combine(h, l.blend_mode);
			hash_combine(h, l.shading_flags);
			hash_combine(h, l.texture_animation_id);
			hash_combine(h, l.coord_id);
			hash_combine(h, l.alpha);
			hash_combine(h, l.emissive_gain);
			hash_combine(h, l.fresnel_color);
			hash_combine(h, l.fresnel_opacity);
			hash_combine(h, l.fresnel_team_color);
			hash_combine(h, l.hd);
			for (const auto& texture : l.textures) {
				hash_combine(h, texture);
			}
			hash_combine(h, l.KMTA);
			hash_combine(h, l.KMTE);
			hash_combine(h, l.KFC3);
			hash_combine(h, l.KFCA);
			hash_combine(h, l.KFTC);
			return h;
		}
	};

	// template<typename T>
	// struct hash<std::vector<T>> {
	// 	std::size_t operator()(const std::vector<T>& vec) const {
	// 		std::size_t h = 0;
	// 		for (const auto& item : vec)
	// 			hash_combine(h, item);  // assumes std::hash<T> exists
	// 		return h;
	// 	}
	// };


	template<>
	struct std::hash<mdx::Material>
	{
		std::size_t operator()(const mdx::Material& s) const noexcept
		{
			std::size_t h1 = std::hash<uint32_t>{}(s.priority_plane);
			std::size_t h2 = std::hash<uint32_t>{}(s.flags);
			std::size_t h3 = hash_vector<mdx::Layer>{}(s.layers);

			// std::size_t h3 = std::hash<std::vector<mdx::Layer>>{}(s.layers);
			return h1 ^ (h2 << 1) ^(h3 << 1); // or use boost::hash_combine
		}
	};

	template<>
	struct std::hash<mdx::Texture>
	{
		std::size_t operator()(const mdx::Texture& s) const noexcept
		{
			std::size_t h1 = std::hash<fs::path>{}(s.file_name);
			std::size_t h2 = std::hash<uint32_t>{}(s.flags);
			std::size_t h3 = std::hash<uint32_t>{}(s.replaceable_id);
			return h1 ^ (h2 << 1) ^(h3 << 1); // or use boost::hash_combine
		}
	};
}
```

`src/file_formats/mdx/mdx_reader.cpp`:

```cpp
module MDX;

import std;
import BinaryReader;
import <glm/glm.hpp>;

namespace mdx {
	void read_GEOS(BinaryReader& reader, MDX& mdx) {
		const uint32_t size = reader.read<uint32_t>();
		uint32_t total_size = 0;

		while (total_size < size) {
			total_size += reader.read<uint32_t>();

			Geoset geoset;
			reader.advance(4); // VRTX
			const uint32_t vertex_count = reader.read<uint32_t>();
			geoset.vertices = reader.read_vector<glm::vec3>(vertex_count);

			reader.advance(4); // NRMS
			const uint32_t normal_count = reader.read<uint32_t>();
			geoset.normals = reader.read_vector<glm::vec3>(normal_count);

			reader.advance(4); // PTYP
			const uint32_t face_type_groups_count = reader.read<uint32_t>();
			geoset.face_type_groups = reader.read_vector<uint32_t>(face_type_groups_count);

			reader.advance(4); // PCNT
			const uint32_t face_groups_count = reader.read<uint32_t>();
			geoset.face_groups = reader.read_vector<uint32_t>(face_groups_count);

			reader.advance(4); // PVTX
			const uint32_t faces_count = reader.read<uint32_t>();
			geoset.faces = reader.read_vector<uint16_t>(faces_count);

			reader.advance(4); // GNDX
			const uint32_t vertex_groups_count = reader.read<uint32_t>();
			geoset.vertex_groups = reader.read_vector<uint8_t>(vertex_groups_count);

			reader.advance(4); // MTGC
			const uint32_t matrix_group_count = reader.read<uint32_t>();
			geoset.matrix_groups = reader.read_vector<uint32_t>(matrix_group_count);

			reader.advance(4); // MATS
			const uint32_t matrix_indices_count = reader.read<uint32_t>();
			geoset.matrix_indices = reader.read_vector<uint32_t>(matrix_indices_count);

			geoset.material_id = reader.read<uint32_t>();
			geoset.selection_group = reader.read<uint32_t>();
			geoset.selection_flags = reader.read<uint32_t>();

			if (mdx.version > 800) {
				geoset.lod = reader.read<uint32_t>();
				geoset.lod_name = reader.read_string(80); // lod name
			} else {
				geoset.lod = 0;
			}

			geoset.extent = Extent(reader);
			const uint32_t extents_count = reader.read<uint32_t>();
			for (size_t i = 0; i < extents_count; i++) {
				geoset.sequence_extents.emplace_back(Extent(reader));
			}

			std::string tag = reader.read_string(4);

			if (tag == "TANG") {
				uint32_t structure_count = reader.read<uint32_t>();
				geoset.tangents = reader.read_vector<glm::vec4>(structure_count);
				tag = reader.read_string(4); // Maybe SKIN, maybe UVAS
			}

			if (tag == "SKIN") {
				uint32_t skin_count = reader.read<uint32_t>();
				geoset.skin = reader.read_vector<uint8_t>(skin_count);
				reader.advance(4); // UVAS
			}

			const uint32_t texture_coordinate_sets_count = reader.read<uint32_t>();
			for (size_t i = 0; i < texture_coordinate_sets_count; i++) {
				reader.advance(4); // UVBS
				const uint32_t texture_coordinates_count = reader.read<uint32_t>();
				geoset.uv_sets.push_back(reader.read_vector<glm::vec2>(texture_coordinates_count));
			}

			mdx.geosets.push_back(std::move(geoset));
		}
	}

	// Transform from the old version format to our new v1100 based internal representation
	void read_MTLS_texs_pre_v1100(BinaryReader& reader, bool is_hd, uint32_t version, Material& material, int& unique_tracks) {
		reader.advance(4);
		const uint32_t layers_count = reader.read<uint32_t>();

		// These older versions encoded HD materials by having a layer for each PBR material
		// We combine these into the new format
		if (is_hd) {
			Layer layer;
			layer.hd = is_hd;

			for (size_t i = 0; i < layers_count; i++) {
				const size_t reader_pos = reader.position;
				const uint32_t size = reader.read<uint32_t>();

				// Only the first layer's properties matter
				if (i > 0) {
					reader.advance(8);
					LayerTexture layer_texture;
					layer_texture.id = reader.read<uint32_t>();
					layer.textures.push_back(layer_texture);

					reader.advance(size - 16);
					continue;
				}

				layer.blend_mode = reader.read<uint32_t>();
				layer.shading_flags = reader.read<uint32_t>();
				LayerTexture layer_texture;
				layer_texture.id = reader.read<uint32_t>();
				layer.texture_animation_id = reader.read<uint32_t>();
				layer.coord_id = reader.read<uint32_t>();
				layer.alpha = reader.read<float>();

				layer.emissive_gain = reader.read<float>();
				layer.fresnel_color = reader.read<glm::vec3>();
				layer.fresnel_opacity = reader.read<float>();
				layer.fresnel_team_color = reader.read<float>();

				while (reader.position < reader_pos + size) {
					TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
					if (tag == TrackTag::KMTF) {
						layer_texture.KMTF = TrackHeader<uint32_t>(reader, unique_tracks++);
					} else if (tag == TrackTag::KMTA) {
						layer.KMTA = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KMTE) {
						layer.KMTE = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFC3) {
						layer.KFC3 = TrackHeader<glm::vec3>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFCA) {
						layer.KFCA = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFTC) {
						layer.KFTC = TrackHeader<float>(reader, unique_tracks++);
					} else {
						std::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
					}
				}

				layer.textures.push_back(layer_texture);
			}

			material.layers.push_back(std::move(layer));
		} else {
			for (size_t i = 0; i < layers_count; i++) {
				const size_t reader_pos = reader.position;
				const uint32_t size = reader.read<uint32_t>();
				Layer layer;
				layer.hd = is_hd;
				layer.blend_mode = reader.read<uint32_t>();
				layer.shading_flags = reader.read<uint32_t>();

				LayerTexture layer_texture;
				layer_texture.id = reader.read<uint32_t>();
				layer.textures.push_back(layer_texture);

				layer.texture_animation_id = reader.read<uint32_t>();
				layer.coord_id = reader.read<uint32_t>();
				layer.alpha = reader.read<float>();

				if (version > 800) {
					layer.emissive_gain = reader.read<float>();
					layer.fresnel_color = reader.read<glm::vec3>();
					layer.fresnel_opacity = reader.read<float>();
					layer.fresnel_team_color = reader.read<float>();
				}

				while (reader.position < reader_pos + size) {
					TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
					if (tag == TrackTag::KMTF) {
						layer_texture.KMTF = TrackHeader<uint32_t>(reader, unique_tracks++);
					} else if (tag == TrackTag::KMTA) {
						layer.KMTA = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KMTE) {
						layer.KMTE = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFC3) {
						layer.KFC3 = TrackHeader<glm::vec3>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFCA) {
						layer.KFCA = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFTC) {
						layer.KFTC = TrackHeader<float>(reader, unique_tracks++);
					} else {
						std::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
					}
				}

				material.layers.push_back(std::move(layer));
			}
		}
	}

	void read_MTLS_texs_post_v1100(BinaryReader& reader, Material& material, int& unique_tracks) {
		reader.advance(4);
		const uint32_t layers_count = reader.read<uint32_t>();
		for (size_t i = 0; i < layers_count; i++) {
			const size_t reader_pos = reader.position;
			Layer layer;
			const uint32_t size = reader.read<uint32_t>();
			layer.blend_mode = reader.read<uint32_t>();
			layer.shading_flags = reader.read<uint32_t>();
			reader.advance(4); // skip texture_id
			layer.texture_animation_id = reader.read<uint32_t>();
			layer.coord_id = reader.read<uint32_t>();
			layer.alpha = reader.read<float>();

			layer.emissive_gain = reader.read<float>();
			layer.fresnel_color = reader.read<glm::vec3>();
			layer.fresnel_opacity = reader.read<float>();
			layer.fresnel_team_color = reader.read<float>();

			layer.hd = reader.read<uint32_t>();
			uint32_t texs = reader.read<uint32_t>();
			for (size_t j = 0; j < texs; j++) {
				LayerTexture layer_texture;
				layer_texture.id = reader.read<uint32_t>();
				uint32_t slot = reader.read<uint32_t>(); // always a garbage value?

				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KMTF) {
					layer_texture.KMTF = TrackHeader<uint32_t>(reader, unique_tracks++);
				} else {
					reader.advance(-4);
				}
				layer.textures.push_back(layer_texture);
			}

			while (reader.position < reader_pos + size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KMTA) {
					layer.KMTA = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KMTE) {
					layer.KMTE = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KFC3) {
					layer.KFC3 = TrackHeader<glm::vec3>(reader, unique_tracks++);
				} else if (tag == TrackTag::KFCA) {
					layer.KFCA = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KFTC) {
					layer.KFTC = TrackHeader<float>(reader, unique_tracks++);
				} else {
					std::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}

			material.layers.push_back(std::move(layer));
		}
	}

	void read_MTLS(BinaryReader& reader, MDX& mdx) {
		const uint32_t size = reader.read<uint32_t>();
		uint32_t total_size = 0;

		while (total_size < size) {
			total_size += reader.read<uint32_t>();

			Material material;
			material.priority_plane = reader.read<uint32_t>();
			material.flags = reader.read<uint32_t>();

			if (mdx.version < 1100) {
				bool is_hd = false;
				if (mdx.version == 900 || mdx.version == 1000) {
					is_hd = !reader.read_string(80).empty();
				}
				read_MTLS_texs_pre_v1100(reader, is_hd, mdx.version, material, mdx.unique_tracks);
			} else {
				read_MTLS_texs_post_v1100(reader, material, mdx.unique_tracks);
			}

			mdx.materials.push_back(std::move(material));
		}
	}

	void read_SEQS(BinaryReader& reader, MDX& mdx) {
		const uint32_t size = reader.read<uint32_t>();
		for (size_t i = 0; i < size / 132; i++) {
			mdx.sequences.push_back(Sequence {
				.name = reader.read_string(80),
				.start_frame = reader.read<uint32_t>(),
				.end_frame = reader.read<uint32_t>(),
				.movespeed = reader.read<float>(),
				.flags = reader.read<uint32_t>(),
				.rarity = reader.read<float>(),
				.sync_point = reader.read<uint32_t>(),
				.extent = Extent(reader),
			});
		}
	}

	void read_GEOA(BinaryReader& reader, MDX& mdx) {
		uint32_t remaining_size = reader.read<uint32_t>();

		while (remaining_size > 0) {
			const size_t reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			remaining_size -= inclusive_size;

			GeosetAnimation animation;
			animation.alpha = reader.read<float>();
			animation.flags = reader.read<uint32_t>();
			animation.color = reader.read<glm::vec3>();
			animation.geoset_id = reader.read<uint32_t>();

			while (reader.position < reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KGAO) {
					animation.KGAO = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KGAC) {
					animation.KGAC = TrackHeader<glm::vec3>(reader, mdx.unique_tracks++);
				} else {
					std::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}

			mdx.animations.push_back(std::move(animation));
		}
	}

	void read_BONE(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			mdx.bones.push_back(Bone { 
				.node = Node(reader, mdx.unique_tracks),
				.geoset_id = reader.read<int32_t>(),
				.geoset_animation_id = reader.read<int32_t>(),
			});
		}
	}

	void read_TEXS(BinaryReader& reader, MDX& mdx) {
		const uint32_t size = reader.read<uint32_t>();
		for (size_t i = 0; i < size / 268; i++) {
			mdx.textures.push_back(Texture{
				.replaceable_id = reader.read<uint32_t>(),
				.file_name = reader.read_string(260),
				.flags = reader.read<uint32_t>(),
			});
		}
	}

	void read_GLBS(BinaryReader& reader, MDX& mdx) {
		const uint32_t size = reader.read<uint32_t>();
		mdx.global_sequences = reader.read_vector<uint32_t>(size / 4);
	}

	void read_LITE(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			Light light;
			const size_t node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			light.node = Node(reader, mdx.unique_tracks);
			light.type = reader.read<uint32_t>();
			light.attenuation_start = reader.read<float>();
			light.attenuation_end = reader.read<float>();
			light.color = reader.read<glm::vec3>();
			light.intensity = reader.read<float>();
			light.ambient_color = reader.read<glm::vec3>();
			light.ambient_intensity = reader.read<float>();
			if (mdx.version >= 1200) {
			 light.shadow_intensity = reader.read<float>();
			}
			else {
				light.shadow_intensity = 0.4f;
			}

			while (reader.position < node_reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KLAS) {
					light.KLAS = TrackHeader<uint32_t>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KLAE) {
					light.KLAE = TrackHeader<uint32_t>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KLAC) {
					light.KLAC = TrackHeader<glm::vec3>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KLAI) {
					light.KLAI = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KLBI) {
					light.KLBI = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KLBC) {
					light.KLBC = TrackHeader<glm::vec3>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KLAV) {
					light.KLAV = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else {
					std::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
			mdx.lights.push_back(std::move(light));
		}
	}

	void read_HELP(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();
		while (reader.position < reader_pos + size) {
			mdx.help_bones.push_back(Node(reader, mdx.unique_tracks));
		}
	}

	void read_ATCH(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			Attachment attachment;
			const int node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			attachment.node = Node(reader, mdx.unique_tracks);
			attachment.path = reader.read_string(256);
			attachment.reserved = reader.read<uint32_t>();
			attachment.attachment_id = reader.read<uint32_t>();
			while (reader.position < node_reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				attachment.KATV = TrackHeader<float>(reader, mdx.unique_tracks++);
				if (tag != TrackTag::KATV) {
					std::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
			mdx.attachments.push_back(std::move(attachment));
		}
	}

	void read_PIVT(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		mdx.pivots = reader.read_vector<glm::vec3>(size / 12);
	}

	void read_PREM(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			ParticleEmitter1 emitter;
			const int node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			emitter.node = Node(reader, mdx.unique_tracks);
			emitter.emission_rate = reader.read<float>();
			emitter.gravity = reader.read<float>();
			emitter.longitude = reader.read<float>();
			emitter.latitude = reader.read<float>();
			emitter.path = reader.read_string(256);
			emitter.reserved = reader.read<uint32_t>();
			emitter.life_span = reader.read<float>();
			emitter.speed = reader.read<float>();
			while (reader.position < node_reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KPEE) {
					emitter.KPEE = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KPEG) {
					emitter.KPEG = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KPLN) {
					emitter.KPLN = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KPLT) {
					emitter.KPLT = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KPEL) {
					emitter.KPEL = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KPES) {
					emitter.KPES = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KPEV) {
					emitter.KPEV = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else {
					std::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
			mdx.emitters1.push_back(std::move(emitter));
		}
	}

	void read_PRE2(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			ParticleEmitter2 emitter2;
			const int node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			emitter2.node = Node(reader, mdx.unique_tracks);

			emitter2.speed = reader.read<float>();
			emitter2.variation = reader.read<float>();
			emitter2.latitude = reader.read<float>();
			emitter2.gravity = reader.read<float>();
			emitter2.life_span = reader.read<float>();
			emitter2.emission_rate = reader.read<float>();
			emitter2.length = reader.read<float>();
			emitter2.width = reader.read<float>();
			emitter2.filter_mode = reader.read<uint32_t>();
			emitter2.rows = reader.read<uint32_t>();
			emitter2.columns = reader.read<uint32_t>();
			emitter2.head_or_tail = reader.read<uint32_t>();
			emitter2.tail_length = reader.read<float>();
			emitter2.time_middle = reader.read<float>();

			emitter2.start_segment_color = reader.read<glm::vec3>();
			emitter2.middle_segment_color = reader.read<glm::vec3>();
			emitter2.end_segment_color = reader.read<glm::vec3>();

			emitter2.segment_alphas = reader.read<glm::u8vec3>();
			emitter2.segment_scaling = reader.read<glm::vec3>();
			emitter2.head_intervals = reader.read<glm::uvec3>();
			emitter2.head_decay_intervals = reader.read<glm::uvec3>();
			emitter2.tail_intervals = reader.read<glm::uvec3>();
			emitter2.tail_decay_intervals = reader.read<glm::uvec3>();

			emitter2.texture_id = reader.read<uint32_t>();
			emitter2.squirt = reader.read<uint32_t>();
			emitter2.priority_plane = reader.read<uint32_t>();
			emitter2.replaceable_id = reader.read<uint32_t>();

			while (reader.position < node_reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KP2S) {
					emitter2.KP2S = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KP2R) {
					emitter2.KP2R = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KP2L) {
					emitter2.KP2L = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KP2G) {
					emitter2.KP2G = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KP2E) {
					emitter2.KP2E = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KP2N) {
					emitter2.KP2N = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KP2W) {
					emitter2.KP2W = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KP2V) {
					emitter2.KP2V = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else {
					std::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
			mdx.emitters2.push_back(std::move(emitter2));
		}
	}

	void read_RIBB(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			RibbonEmitter emitter;
			const int node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			emitter.node = Node(reader, mdx.unique_tracks);
			emitter.height_above = reader.read<float>();
			emitter.height_below = reader.read<float>();
			emitter.alpha = reader.read<float>();
			emitter.color = reader.read<glm::vec3>();
			emitter.life_span = reader.read<float>();
			emitter.texture_slot = reader.read<uint32_t>();
			emitter.emission_rate = reader.read<uint32_t>();
			emitter.rows = reader.read<uint32_t>();
			emitter.columns = reader.read<uint32_t>();
			emitter.material_id = reader.read<uint32_t>();
			emitter.gravity = reader.read<float>();
			while (reader.position < node_reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KRHA) {
					emitter.KRHA = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KRHB) {
					emitter.KRHB = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KRAL) {
					emitter.KRAL = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KRCO) {
					emitter.KRCO = TrackHeader<glm::vec3>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KRTX) {
					emitter.KRTX = TrackHeader<uint32_t>(reader, mdx.unique_tracks++);
				} else if (tag == TrackTag::KRVS) {
					emitter.KRVS = TrackHeader<float>(reader, mdx.unique_tracks++);
				} else {
					std::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
			mdx.ribbons.push_back(std::move(emitter));
		}
	}

	void read_EVTS(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			EventObject evt;
			evt.node = Node(reader, mdx.unique_tracks);
			reader.advance(4); // read KEVT
			uint32_t count = reader.read<uint32_t>();
			evt.global_sequence_id = reader.read<int32_t>(); // signed
			evt.times = reader.read_vector<uint32_t>(count);
			mdx.event_objects.push_back(std::move(evt));
		}
	}

	void read_CLID(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			CollisionShape shape;
			shape.node = Node(reader, mdx.unique_tracks);
			shape.type = static_cast<CollisionShape::Shape>(reader.read<uint32_t>());

			for (int i = 0; i < 3; i++) {
				if (reader.remaining() <= 0) {
					shape.vertices[0][i] = 0.f;
				} else {
					shape.vertices[0][i] = reader.read<float>();
				}
			}

			if (shape.type != CollisionShape::Shape::Sphere) {
				for (int i = 0; i < 3; i++) {
					if (reader.remaining() <= 0) {
						shape.vertices[1][i] = 0.f;
					} else {
						shape.vertices[1][i] = reader.read<float>();
					}
				}
			}

			if (shape.type == CollisionShape::Shape::Sphere || shape.type == CollisionShape::Shape::Cylinder) {
				if (reader.remaining() > 0) {
					shape.radius = reader.read<float>();
				} else {
					shape.radius = 0.f;
				}
			}
			mdx.collision_shapes.push_back(std::move(shape));
		}
	}

	void read_CORN(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			CornEmitter emitter;
			const int node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			emitter.node = Node(reader, mdx.unique_tracks);
			emitter.data = reader.read_vector<uint8_t>(inclusive_size - (reader.position - node_reader_pos));
			mdx.corn_emitters.push_back(std::move(emitter));
		}
	}

	void read_CAMS(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			Camera camera;
			const uint32_t inclusive_size = reader.read<uint32_t>();

			camera.data = reader.read_vector<uint8_t>(inclusive_size - 4);
			mdx.cameras.push_back(std::move(camera));
		}
	}

	void read_BPOS(BinaryReader& reader, MDX& mdx) {
		const uint32_t size = reader.read<uint32_t>();
		mdx.bind_poses = reader.read_vector<float>(reader.read<uint32_t>() * 12);
	}

	void read_TXAN(BinaryReader& reader, MDX& mdx) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			TextureAnimation animation;
			const uint32_t inclusive_size = reader.read<uint32_t>();

			animation.data = reader.read_vector<uint8_t>(inclusive_size - 4);
			mdx.texture_animations.push_back(std::move(animation));
		}
	}

	void read_FAFX(BinaryReader& reader, MDX& mdx) {
		const uint32_t size = reader.read<uint32_t>();
		for (size_t i = 0; i < size / 340; i++) {
			FaceFX facefx;
			facefx.name = reader.read_string(80);
			facefx.path = reader.read_string(260);
			mdx.facefxes.push_back(std::move(facefx));
		}
	}

	void MDX::load(BinaryReader& reader) {
		const std::string magic_number = reader.read_string(4);
		if (magic_number != "MDLX") {
			std::print("Incorrect file magic number, expected MDLX but got {}\n", magic_number);
			return;
		}

		while (reader.remaining() > 0) {
			uint32_t header = reader.read<uint32_t>();

			switch (static_cast<ChunkTag>(header)) {
				case ChunkTag::VERS:
					reader.advance(4);
					version = reader.read<uint32_t>();
					break;
				case ChunkTag::MODL:
					reader.advance(4);
					name = reader.read_string(80);
					animation_filename = reader.read_string(260);
					extent = Extent(reader);
					blend_time = reader.read<uint32_t>();
					break;
				case ChunkTag::GEOS:
					read_GEOS(reader, *this);
					break;
				case ChunkTag::MTLS:
					read_MTLS(reader, *this);
					break;
				case ChunkTag::SEQS:
					read_SEQS(reader, *this);
					break;
				case ChunkTag::GLBS:
					read_GLBS(reader, *this);
					break;
				case ChunkTag::GEOA:
					read_GEOA(reader, *this);
					break;
				case ChunkTag::BONE:
					read_BONE(reader, *this);
					break;
				case ChunkTag::TEXS:
					read_TEXS(reader, *this);
					break;
				case ChunkTag::LITE:
					read_LITE(reader, *this);
					break;
				case ChunkTag::HELP:
					read_HELP(reader, *this);
					break;
				case ChunkTag::ATCH:
					read_ATCH(reader, *this);
					break;
				case ChunkTag::PIVT:
					read_PIVT(reader, *this);
					break;
				case ChunkTag::PREM:
					read_PREM(reader, *this);
					break;
				case ChunkTag::PRE2:
					read_PRE2(reader, *this);
					break;
				case ChunkTag::RIBB:
					read_RIBB(reader, *this);
					break;
				case ChunkTag::EVTS:
					read_EVTS(reader, *this);
					break;
				case ChunkTag::CLID:
					read_CLID(reader, *this);
					break;
				case ChunkTag::CORN:
					read_CORN(reader, *this);
					break;
				case ChunkTag::FAFX:
					read_FAFX(reader, *this);
					break;
				case ChunkTag::CAMS:
					read_CAMS(reader, *this);
					break;
				case ChunkTag::BPOS:
					read_BPOS(reader, *this);
					break;
				case ChunkTag::TXAN:
					read_TXAN(reader, *this);
					break;
				default:
					reader.advance(reader.read<uint32_t>());
			}
		}

		validate();
	}
}
```

`src/file_formats/mdx/mdx_writer.cpp`:

```cpp
module MDX;

import std;
import <glm/glm.hpp>;

namespace fs = std::filesystem;

namespace mdx {
	void write_GEOS(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.geosets.empty()) {
			return;
		}

		writer.write(ChunkTag::GEOS);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& geoset : mdx.geosets) {
			// Write temporary zero, remember location
			const size_t geoset_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write_string("VRTX");
			writer.write<uint32_t>(geoset.vertices.size());
			writer.write_vector(geoset.vertices);

			writer.write_string("NRMS");
			writer.write<uint32_t>(geoset.normals.size());
			writer.write_vector(geoset.normals);

			writer.write_string("PTYP");
			writer.write<uint32_t>(geoset.face_type_groups.size());
			writer.write_vector(geoset.face_type_groups);

			writer.write_string("PCNT");
			writer.write<uint32_t>(geoset.face_groups.size());
			writer.write_vector(geoset.face_groups);

			writer.write_string("PVTX");
			writer.write<uint32_t>(geoset.faces.size());
			writer.write_vector(geoset.faces);

			writer.write_string("GNDX");
			writer.write<uint32_t>(geoset.vertex_groups.size());
			writer.write_vector(geoset.vertex_groups);

			writer.write_string("MTGC");
			writer.write<uint32_t>(geoset.matrix_groups.size());
			writer.write_vector(geoset.matrix_groups);

			writer.write_string("MATS");
			writer.write<uint32_t>(geoset.matrix_indices.size());
			writer.write_vector(geoset.matrix_indices);

			writer.write<uint32_t>(geoset.material_id);
			writer.write<uint32_t>(geoset.selection_group);
			writer.write<uint32_t>(geoset.selection_flags);

			writer.write<uint32_t>(geoset.lod);
			writer.write_c_string_padded(geoset.lod_name, 80);

			geoset.extent.save(writer);
			writer.write<uint32_t>(geoset.sequence_extents.size());
			for (const auto& extent : geoset.sequence_extents) {
				extent.save(writer);
			}

			if (geoset.tangents.size()) {
				writer.write_string("TANG");
				writer.write<uint32_t>(geoset.tangents.size());
				writer.write_vector(geoset.tangents);
			}

			if (geoset.skin.size()) {
				writer.write_string("SKIN");
				writer.write<uint32_t>(geoset.skin.size());
				writer.write_vector(geoset.skin);
			}

			writer.write_string("UVAS");
			writer.write<uint32_t>(geoset.uv_sets.size());
			for (const auto& set : geoset.uv_sets) {
				writer.write_string("UVBS");
				writer.write<uint32_t>(set.size());
				writer.write_vector(set);
			}
			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - geoset_index);
			std::memcpy(writer.buffer.data() + geoset_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_MTLS(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.materials.empty()) {
			return;
		}

		writer.write(ChunkTag::MTLS);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& material : mdx.materials) {
			// Write temporary zero, remember location
			const size_t material_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write<uint32_t>(material.priority_plane);
			writer.write<uint32_t>(material.flags);
			writer.write_string("LAYS");
			writer.write<uint32_t>(material.layers.size());

			for (const auto& layer : material.layers) {
				// Write temporary zero, remember location
				const size_t layer_index = writer.buffer.size();
				writer.write<uint32_t>(0);

				writer.write<uint32_t>(layer.blend_mode);
				writer.write<uint32_t>(layer.shading_flags);
				writer.write<uint32_t>(0); // texture_id irrelevant when writing V1100
				writer.write<uint32_t>(layer.texture_animation_id);
				writer.write<uint32_t>(layer.coord_id);
				writer.write<float>(layer.alpha);

				writer.write<float>(layer.emissive_gain);
				writer.write<glm::vec3>(layer.fresnel_color);
				writer.write<float>(layer.fresnel_opacity);
				writer.write<float>(layer.fresnel_team_color);

				writer.write<uint32_t>(layer.hd);
				writer.write<uint32_t>(layer.textures.size());

				for (size_t i = 0; i < layer.textures.size(); i++) {
					writer.write<uint32_t>(layer.textures[i].id);
					writer.write<uint32_t>(i);
					layer.textures[i].KMTF.save(TrackTag::KMTF, writer);
				}

				layer.KMTA.save(TrackTag::KMTA, writer);
				layer.KMTE.save(TrackTag::KMTE, writer);
				layer.KFC3.save(TrackTag::KFC3, writer);
				layer.KFCA.save(TrackTag::KFCA, writer);
				layer.KFTC.save(TrackTag::KFTC, writer);

				const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - layer_index);
				std::memcpy(writer.buffer.data() + layer_index, &temporary, 4);
			}
			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - material_index);
			std::memcpy(writer.buffer.data() + material_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_SEQS(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.sequences.empty()) {
			return;
		}

		writer.write(ChunkTag::SEQS);
		writer.write<uint32_t>(mdx.sequences.size() * 132);
		for (const auto& i : mdx.sequences) {
			writer.write_c_string_padded(i.name, 80);
			writer.write<uint32_t>(i.start_frame);
			writer.write<uint32_t>(i.end_frame);
			writer.write<float>(i.movespeed);
			writer.write<uint32_t>(i.flags);
			writer.write<float>(i.rarity);
			writer.write<uint32_t>(i.sync_point);
			i.extent.save(writer);
		}
	}

	void write_GLBS(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.global_sequences.empty()) {
			return;
		}

		writer.write(ChunkTag::GLBS);
		writer.write<uint32_t>(mdx.global_sequences.size() * 4);
		writer.write_vector(mdx.global_sequences);
	}

	void write_GEOA(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.animations.empty()) {
			return;
		}

		writer.write(ChunkTag::GEOA);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& geoset_animation : mdx.animations) {
			// Write temporary zero, remember location
			const size_t geoset_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write<float>(geoset_animation.alpha);
			writer.write<uint32_t>(geoset_animation.flags);
			writer.write<glm::vec3>(geoset_animation.color);
			writer.write<uint32_t>(geoset_animation.geoset_id);

			geoset_animation.KGAO.save(TrackTag::KGAO, writer);
			geoset_animation.KGAC.save(TrackTag::KGAC, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - geoset_index);
			std::memcpy(writer.buffer.data() + geoset_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_BONE(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.bones.empty()) {
			return;
		}

		writer.write(ChunkTag::BONE);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& bone : mdx.bones) {
			bone.node.save(writer);
			writer.write<int32_t>(bone.geoset_id);
			writer.write<int32_t>(bone.geoset_animation_id);
		}
		const uint32_t temporary = writer.buffer.size() - inclusive_index - 4;
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_TEXS(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.textures.empty()) {
			return;
		}

		writer.write(ChunkTag::TEXS);
		writer.write<uint32_t>(mdx.textures.size() * 268);
		for (const auto& texture : mdx.textures) {
			writer.write<uint32_t>(texture.replaceable_id);
			writer.write_c_string_padded(texture.file_name.string(), 260);
			writer.write<uint32_t>(texture.flags);
		}
	}

	void write_LITE(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.lights.empty()) {
			return;
		}

		writer.write(ChunkTag::LITE);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& light : mdx.lights) {
			// Write temporary zero, remember location
			const size_t light_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			light.node.save(writer);
			writer.write<uint32_t>(light.type);
			writer.write<float>(light.attenuation_start);
			writer.write<float>(light.attenuation_end);
			writer.write<glm::vec3>(light.color);
			writer.write<float>(light.intensity);
			writer.write<glm::vec3>(light.ambient_color);
			writer.write<float>(light.ambient_intensity);
			writer.write<float>(light.shadow_intensity);

			light.KLAS.save(TrackTag::KLAS, writer);
			light.KLAE.save(TrackTag::KLAE, writer);
			light.KLAC.save(TrackTag::KLAC, writer);
			light.KLAI.save(TrackTag::KLAI, writer);
			light.KLBI.save(TrackTag::KLBI, writer);
			light.KLBC.save(TrackTag::KLBC, writer);
			light.KLAV.save(TrackTag::KLAV, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - light_index);
			std::memcpy(writer.buffer.data() + light_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_HELP(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.help_bones.empty()) {
			return;
		}

		writer.write(ChunkTag::HELP);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& help_bone : mdx.help_bones) {
			help_bone.save(writer);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_ATCH(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.attachments.empty()) {
			return;
		}

		writer.write(ChunkTag::ATCH);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& attachment : mdx.attachments) {
			// Write temporary zero, remember location
			const size_t attachment_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			attachment.node.save(writer);
			writer.write_c_string_padded(attachment.path, 256);
			writer.write<uint32_t>(attachment.reserved);
			writer.write<uint32_t>(attachment.attachment_id);

			attachment.KATV.save(TrackTag::KATV, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - attachment_index);
			std::memcpy(writer.buffer.data() + attachment_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_PIVT(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.pivots.empty()) {
			return;
		}

		writer.write(ChunkTag::PIVT);
		writer.write<uint32_t>(mdx.pivots.size() * 12);
		for (const auto& pivot : mdx.pivots) {
			writer.write<glm::vec3>(pivot);
		}
	}

	void write_PREM(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.emitters1.empty()) {
			return;
		}

		writer.write(ChunkTag::PREM);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& emitter : mdx.emitters1) {
			// Write temporary zero, remember location
			const size_t emitter_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			emitter.node.save(writer);
			writer.write<float>(emitter.emission_rate);
			writer.write<float>(emitter.gravity);
			writer.write<float>(emitter.longitude);
			writer.write<float>(emitter.latitude);
			writer.write_c_string_padded(emitter.path, 260);
			writer.write<uint32_t>(emitter.reserved);
			writer.write<float>(emitter.life_span);
			writer.write<float>(emitter.speed);

			emitter.KPEE.save(TrackTag::KPEE, writer);
			emitter.KPEG.save(TrackTag::KPEG, writer);
			emitter.KPLN.save(TrackTag::KPLN, writer);
			emitter.KPLT.save(TrackTag::KPLT, writer);
			emitter.KPEL.save(TrackTag::KPEL, writer);
			emitter.KPES.save(TrackTag::KPES, writer);
			emitter.KPEV.save(TrackTag::KPEV, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - emitter_index);
			std::memcpy(writer.buffer.data() + emitter_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_PRE2(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.emitters2.empty()) {
			return;
		}

		writer.write(ChunkTag::PRE2);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& emitter : mdx.emitters2) {
			// Write temporary zero, remember location
			const size_t emitter_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			emitter.node.save(writer);
			writer.write<float>(emitter.speed);
			writer.write<float>(emitter.variation);
			writer.write<float>(emitter.latitude);
			writer.write<float>(emitter.gravity);
			writer.write<float>(emitter.life_span);
			writer.write<float>(emitter.emission_rate);
			writer.write<float>(emitter.length);
			writer.write<float>(emitter.width);
			writer.write<uint32_t>(emitter.filter_mode);
			writer.write<uint32_t>(emitter.rows);
			writer.write<uint32_t>(emitter.columns);
			writer.write<uint32_t>(emitter.head_or_tail);
			writer.write<float>(emitter.tail_length);
			writer.write<float>(emitter.time_middle);

			writer.write<glm::vec3>(emitter.start_segment_color);
			writer.write<glm::vec3>(emitter.middle_segment_color);
			writer.write<glm::vec3>(emitter.end_segment_color);

			writer.write<glm::u8vec3>(emitter.segment_alphas);
			writer.write<glm::vec3>(emitter.segment_scaling);
			writer.write<glm::uvec3>(emitter.head_intervals);
			writer.write<glm::uvec3>(emitter.head_decay_intervals);
			writer.write<glm::uvec3>(emitter.tail_intervals);
			writer.write<glm::uvec3>(emitter.tail_decay_intervals);

			writer.write<uint32_t>(emitter.texture_id);
			writer.write<uint32_t>(emitter.squirt);
			writer.write<uint32_t>(emitter.priority_plane);
			writer.write<uint32_t>(emitter.replaceable_id);

			emitter.KP2R.save(TrackTag::KP2R, writer);
			emitter.KP2L.save(TrackTag::KP2L, writer);
			emitter.KP2G.save(TrackTag::KP2G, writer);
			emitter.KP2E.save(TrackTag::KP2E, writer);
			emitter.KP2N.save(TrackTag::KP2N, writer);
			emitter.KP2W.save(TrackTag::KP2W, writer);
			emitter.KP2V.save(TrackTag::KP2V, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - emitter_index);
			std::memcpy(writer.buffer.data() + emitter_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_RIBB(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.ribbons.empty()) {
			return;
		}

		writer.write(ChunkTag::RIBB);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& ribbon : mdx.ribbons) {
			// Write temporary zero, remember location
			const size_t ribbon_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			ribbon.node.save(writer);
			writer.write<float>(ribbon.height_above);
			writer.write<float>(ribbon.height_below);
			writer.write<float>(ribbon.alpha);
			writer.write<glm::vec3>(ribbon.color);
			writer.write<float>(ribbon.life_span);
			writer.write<uint32_t>(ribbon.texture_slot);
			writer.write<uint32_t>(ribbon.emission_rate);
			writer.write<uint32_t>(ribbon.rows);
			writer.write<uint32_t>(ribbon.columns);
			writer.write<uint32_t>(ribbon.material_id);
			writer.write<float>(ribbon.gravity);

			ribbon.KRHA.save(TrackTag::KRHA, writer);
			ribbon.KRHB.save(TrackTag::KRHB, writer);
			ribbon.KRAL.save(TrackTag::KRAL, writer);
			ribbon.KRCO.save(TrackTag::KRCO, writer);
			ribbon.KRTX.save(TrackTag::KRTX, writer);
			ribbon.KRVS.save(TrackTag::KRVS, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - ribbon_index);
			std::memcpy(writer.buffer.data() + ribbon_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_EVTS(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.event_objects.empty()) {
			return;
		}

		writer.write(ChunkTag::EVTS);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& event_object : mdx.event_objects) {
			event_object.node.save(writer);
			writer.write_string("KEVT");
			writer.write<uint32_t>(event_object.times.size());
			writer.write<int32_t>(event_object.global_sequence_id);
			writer.write_vector(event_object.times);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_CLID(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.collision_shapes.empty()) {
			return;
		}

		writer.write(ChunkTag::CLID);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& shape : mdx.collision_shapes) {
			shape.node.save(writer);
			writer.write<uint32_t>(static_cast<uint32_t>(shape.type));

			if (shape.type == CollisionShape::Shape::Sphere) {
				writer.write<glm::vec3>(shape.vertices[0]);
			} else {
				writer.write<glm::vec3>(shape.vertices[0]);
				writer.write<glm::vec3>(shape.vertices[1]);
			}
			if (shape.type == CollisionShape::Shape::Sphere || shape.type == CollisionShape::Shape::Cylinder) {
				writer.write<float>(shape.radius);
			}
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_CORN(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.corn_emitters.empty()) {
			return;
		}

		writer.write(ChunkTag::CORN);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& corn : mdx.corn_emitters) {
			// Write temporary zero, remember location
			const size_t corn_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			corn.node.save(writer);
			writer.write_vector(corn.data);

			const uint32_t temporary = writer.buffer.size() - corn_index;
			std::memcpy(writer.buffer.data() + corn_index, &temporary, 4);
		}
		const uint32_t temporary = writer.buffer.size() - inclusive_index - 4;
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_CAMS(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.cameras.empty()) {
			return;
		}

		writer.write(ChunkTag::CAMS);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& camera : mdx.cameras) {
			// Write temporary zero, remember location
			const size_t camera_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write_vector(camera.data);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - camera_index);
			std::memcpy(writer.buffer.data() + camera_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_BPOS(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.bind_poses.empty()) {
			return;
		}

		writer.write(ChunkTag::BPOS);
		writer.write<uint32_t>(4 + mdx.bind_poses.size() * 4);
		writer.write<uint32_t>(mdx.bind_poses.size() / 12);
		writer.write_vector(mdx.bind_poses);
	}

	void write_TXAN(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.texture_animations.empty()) {
			return;
		}

		writer.write(ChunkTag::TXAN);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& texture_animation : mdx.texture_animations) {
			// Write temporary zero, remember location
			const size_t texture_animation_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write_vector(texture_animation.data);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - texture_animation_index);
			std::memcpy(writer.buffer.data() + texture_animation_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void write_FAFX(BinaryWriter& writer, const MDX& mdx) {
		if (mdx.facefxes.empty()) {
			return;
		}

		writer.write(ChunkTag::FAFX);
		writer.write<uint32_t>(mdx.facefxes.size() * 340);
		for (const auto& facefx : mdx.facefxes) {
			writer.write_c_string_padded(facefx.name, 80);
			writer.write_c_string_padded(facefx.path.string(), 260);
		}
	}

	BinaryWriter MDX::save() const {
		BinaryWriter writer;
		writer.write_string("MDLX");
		writer.write(ChunkTag::VERS);
		writer.write<uint32_t>(4);
		writer.write<uint32_t>(LATEST_MDX_VERSION);

		writer.write(ChunkTag::MODL);
		writer.write<uint32_t>(372);
		writer.write_c_string_padded(name, 80);
		writer.write_c_string_padded(animation_filename, 260);
		extent.save(writer);
		writer.write<uint32_t>(blend_time);

		write_SEQS(writer, *this);
		write_MTLS(writer, *this);
		write_TEXS(writer, *this);
		write_GEOS(writer, *this);
		write_GEOA(writer, *this);
		write_BONE(writer, *this);
		write_GLBS(writer, *this);
		write_LITE(writer, *this);
		write_HELP(writer, *this);
		write_ATCH(writer, *this);
		write_PIVT(writer, *this);
		write_PREM(writer, *this);
		write_PRE2(writer, *this);
		write_RIBB(writer, *this);
		write_CAMS(writer, *this);
		write_EVTS(writer, *this);
		write_CLID(writer, *this);
		write_CORN(writer, *this);
		write_FAFX(writer, *this);
		write_BPOS(writer, *this);
		write_TXAN(writer, *this);

		return writer;
	}
}
```

`src/file_formats/mdx/optimizer.cpp`:

```cpp
module;

#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/norm.hpp>

module MDX;

import std;
import types;
import MathOperations;
import <glm/glm.hpp>;
import <glm/gtc/quaternion.hpp>;

namespace mdx {
	void remove_unused_materials(MDX& mdx) {
		if (mdx.geosets.empty()) {
			return;
		}

		std::set<u32> used_materials;
		for (const auto& geoset : mdx.geosets) {
			used_materials.emplace(geoset.material_id);
		}

		std::vector<u32> mapping(mdx.materials.size(), 0);
		size_t current_slot = 0;
		for (const auto& i : used_materials) {
			mapping[i] = current_slot++;
		}

		for (auto& geoset : mdx.geosets) {
			geoset.material_id = mapping[geoset.material_id];
		}

		size_t write = 0;
		for (size_t read = 0; read < mdx.materials.size(); ++read) {
			if (used_materials.contains(read)) {
				mdx.materials[write++] = mdx.materials[read];
			}
		}
		mdx.materials.resize(write);
	}

	/// Removes textures that aren't referenced by any MDX materials
	/// ToDo also check if textures are used by other MDX chunks
	void remove_unused_textures(MDX& mdx) {
		if (mdx.textures.empty()) {
			return;
		}

		std::set<u32> used_textures;
		for (const auto& material : mdx.materials) {
			for (const auto& layer : material.layers) {
				for (const auto& texture : layer.textures) {
					used_textures.emplace(texture.id);
				}
			}
		}

		std::vector<u32> mapping(mdx.textures.size(), 0);
		size_t current_slot = 0;
		for (const auto& i : used_textures) {
			mapping[i] = current_slot++;
		}

		for (auto& material : mdx.materials) {
			for (auto& layer : material.layers) {
				for (auto& texture : layer.textures) {
					texture.id = mapping[texture.id];
				}
			}
		}

		size_t write = 0;
		for (size_t read = 0; read < mdx.textures.size(); ++read) {
			if (used_textures.contains(read)) {
				mdx.textures[write++] = mdx.textures[read];
			}
		}
		mdx.textures.resize(write);
	}

	/// Deduplicate materials and geosets before this for best results
	MDX& MDX::deduplicate_textures() {
		std::unordered_map<Texture, size_t> texture_map;
		std::vector<u32> mapping;

		for (const auto& texture : textures) {
			const auto& [elem, inserted] = texture_map.emplace(texture, mapping.size());
			mapping.push_back(elem->second);
		}

		for (auto& material : materials) {
			for (auto& layer : material.layers) {
				for (auto& texture : layer.textures) {
					texture.id = mapping[texture.id];
				}
			}
		}

		textures.clear();
		for (const auto& [key, value] : texture_map) {
			textures.push_back(key);
		}
		return *this;
	}

	/// Call after deduplicate_textures for best results
	/// as the texture IDs will be deduplicated so fewer differences
	/// Material IDs will be sequential, from zero, without gaps after this
	MDX& MDX::deduplicate_materials() {
		std::unordered_map<Material, size_t> material_map;
		std::vector<u32> mapping;

		for (const auto& material : materials) {
			const auto& [elem, inserted] = material_map.emplace(material, mapping.size());
			mapping.push_back(elem->second);
		}

		for (auto& geoset : geosets) {
			geoset.material_id = mapping[geoset.material_id];
		}

		materials.clear();
		for (const auto& [key, value] : material_map) {
			materials.push_back(key);
		}
		return *this;
	}

	/// Call after deduplicate_materials() for best results.
	/// Does not guarantee correct results if the model has any kind of animation
	/// as it merges geosets purely based on matching material IDs.
	/// Requires material IDs to be sequential, from zero, without gaps.
	/// Requires recalculating extents after.
	MDX& MDX::deduplicate_geosets() {
		std::ranges::sort(geosets, [](const auto& a, const auto& b) {
			return a.material_id < b.material_id;
		});

		size_t i = 0;
		while (i < geosets.size()) {
			const size_t index = geosets[i].material_id;

			if (i == index) {
				i += 1;
				continue;
			}

			geosets[index].vertices.append_range(geosets[i].vertices);
			geosets[index].normals.append_range(geosets[i].normals);
			geosets[index].face_type_groups.append_range(geosets[i].face_type_groups);
			// Just use triangles
			// geosets[current_material].face_groups.append_range(geosets[i].face_groups);
			geosets[index].faces.append_range(geosets[i].faces);
			// The following three lines are likely wrong but w/e, you should use skin anyway
			geosets[index].vertex_groups.append_range(geosets[i].vertex_groups);
			geosets[index].matrix_groups.append_range(geosets[i].matrix_groups);
			geosets[index].matrix_indices.append_range(geosets[i].matrix_indices);

			// We told the user to recalculate extents after
			// geosets[index].extents.append_range(geosets[i].extents);

			geosets[index].tangents.append_range(geosets[i].tangents);
			geosets[index].skin.append_range(geosets[i].skin);

			// By the lord, please don't use multiple uv sets
			assert(geosets[index].uv_sets.size() == geosets[i].uv_sets.size());

			for (size_t j = 0; j < geosets[i].uv_sets.size(); j++) {
				geosets[index].uv_sets[j].append_range(geosets[i].uv_sets[j]);
			}

			geosets.erase(geosets.begin() + i);
		}

		return *this;
	}

	/// Removes tracks that are not inside a sequence start<->end frame
	template <typename T>
	void remove_tracks_outside_sequences(TrackHeader<T>& header, std::vector<Sequence>& sequences) {
		if (sequences.empty()) {
			return;
		}

		size_t write_index = 0;
		size_t current_sequence = 0;

		for (size_t i = 0; i < header.tracks.size(); i++) {
			const auto& current = header.tracks[i];

			if (current.frame > sequences[current_sequence].end_frame) {
				current_sequence += 1;
				if (current_sequence >= sequences.size()) {
					return;
				}
			}

			if (current.frame < sequences[current_sequence].start_frame) {
				continue;
			}

			header.tracks[write_index++] = current;
		}
	}

	/// Reduces the number of keyframes in a track by decimating the curve
	/// Uses the Douglas–Peucker algorithm
	/// Assumes all tracks are contained in a sequence
	template <typename T>
	void reduce_track(TrackHeader<T>& header, std::vector<Sequence>& sequences, float max_error_sq) {
		if (sequences.empty()) {
			return;
		}

		if (header.tracks.size() <= 2) {
			return;
		}

		size_t write_index = 1; // Always keep the first keyframe
		size_t anchor_index = 0;

		size_t current_sequence = 0;
		for (size_t i = 1; i < header.tracks.size() - 1; i++) {
			const auto& anchor = header.tracks[anchor_index];
			const auto& current = header.tracks[i];
			const auto& next = header.tracks[i + 1];

			if (next.frame > sequences[current_sequence].end_frame) {
				current_sequence += 1;
				// Write the end keyframe of the sequence
				header.tracks[write_index++] = current;
				// Write the start keyframe of the next sequence
				header.tracks[write_index++] = next;
				anchor_index = i + 1;
				// We increase loop counter i by 2
				i += 1;
				continue;
			}

			const auto total_span = static_cast<float>(next.frame - anchor.frame);
			const auto current_span = static_cast<float>(current.frame - anchor.frame);

			// Avoid division by zero
			const float t = (total_span > 0.0f) ? current_span / total_span : 0.0f;

			const auto interpolated = interpolate(anchor.value, anchor.outTan, anchor.inTan, next.value, t, static_cast<int>(header.interpolation_type));

			float error_sq;
			if constexpr (std::is_same_v<T, uint32_t>) {
				error_sq = current.value - interpolated;
			} else {
				error_sq = glm::length(current.value - interpolated);
			}

			if (error_sq > max_error_sq) {
				header.tracks[write_index++] = current;
				anchor_index = i;
			}
		}

		// Always keep the last keyframe
		header.tracks[write_index++] = header.tracks.back();
		header.tracks.resize(write_index);
	}

	// ToDo! be aware of global sequences

	MDX::OptimizationStats MDX::optimize(float max_error) {
		OptimizationStats stats;

		const size_t material_count = materials.size();
		remove_unused_materials(*this);
		stats.materials_removed += material_count - materials.size();

		const size_t texture_count = textures.size();
		remove_unused_textures(*this);
		stats.textures_removed += texture_count - textures.size();

		if (sequences.empty()) {
			return stats;
		}

		for_each_track([&, max_error]<typename T>(TrackHeader<T>& header) {
			const auto track_size = header.tracks.size();

			remove_tracks_outside_sequences(header, sequences);
			reduce_track(header, sequences, max_error);

			if (header.interpolation_type == InterpolationType::none) {
				stats.constant_tracks += track_size;
				stats.constant_tracks_removed += track_size - header.tracks.size();
			} if (header.interpolation_type == InterpolationType::linear) {
				stats.linear_tracks += track_size;
				stats.linear_tracks_removed += track_size - header.tracks.size();
			} else if (header.interpolation_type == InterpolationType::hermite) {
				stats.hermite_tracks += track_size;
				stats.hermite_tracks_removed += track_size - header.tracks.size();
			} else if (header.interpolation_type == InterpolationType::bezier) {
				stats.bezier_tracks += track_size;
				stats.bezier_tracks_removed += track_size - header.tracks.size();
			}
		});

		return stats;
	}
}
```

`src/file_formats/mdx/utilities.cpp`:

```cpp
module MDX;

import std;
import "glm/glm.hpp";

namespace mdx {
	/// Will not retain sequences and bones because there is no straightforward way to merge them
	void MDX::merge_with(const MDX& mdx, const glm::mat4& transform) {
		MDX new_mdx = mdx;
		for (auto& geoset : new_mdx.geosets) {
			geoset.material_id += materials.size();

			geoset.matrix_groups.clear();
			geoset.matrix_indices.clear();
			geoset.vertex_groups.clear();

			geoset.sequence_extents.resize(1);

			for (auto& vertex : geoset.vertices) {
				vertex = transform * glm::vec4(vertex, 1.f);
			}
			for (auto& normal : geoset.normals) {
				normal = glm::normalize(normal * glm::mat3(transform));
			}

			// Zero skin weights because we will have only 1 bone
			geoset.skin = std::vector<std::uint8_t>(geoset.vertices.size() * 8, 0);
			// Set the contribution of the first bone to 255
			for (size_t i = 0; i < geoset.skin.size(); i += 8) {
				geoset.skin[i + 4] = 255;
			}
		}

		for (auto& material : new_mdx.materials) {
			for (auto& layer : material.layers) {
				layer.texture_animation_id = 0;
				layer.texture_animation_id += texture_animations.size();
				for (auto& texture : layer.textures) {
					texture.id += textures.size();
				}
			}
		}

		// for (auto & emitter : new_mdx.emitters2) {
		// 	emitter.texture_id += textures.size();
		// }
		//
		// for (auto & ribbon : new_mdx.ribbons) {
		// 	ribbon.material_id += materials.size();
		// }

		geosets.append_range(new_mdx.geosets);
		// sequences.append_range(new_mdx.sequences);
		// global_sequences.append_range(new_mdx.global_sequences);
		animations.append_range(new_mdx.animations);
		// bones.append_range(new_mdx.bones);
		materials.append_range(new_mdx.materials);
		textures.append_range(new_mdx.textures);
		// lights.append_range(new_mdx.lights);
		// help_bones.append_range(new_mdx.help_bones);
		// attachments.append_range(new_mdx.attachments);
		// pivots.append_range(new_mdx.pivots);
		// emitters1.append_range(new_mdx.emitters1);
		// emitters2.append_range(new_mdx.emitters2);
		// ribbons.append_range(new_mdx.ribbons);
		// event_objects.append_range(new_mdx.event_objects);
		// collision_shapes.append_range(new_mdx.collision_shapes);
		// corn_emitters.append_range(new_mdx.corn_emitters);
		// facefxes.append_range(new_mdx.facefxes);
		// cameras.append_range(new_mdx.cameras);
		// bind_poses.append_range(new_mdx.bind_poses);
		// texture_animations.append_range(new_mdx.texture_animations);

		// Just to be sure
		validate();
	}

	/// Technically SD supports infinite bones per vertex, but we limit it to 4 like HD does.
	/// This could cause graphical inconsistencies with the game, but after more than 4 bones the contribution per bone is low enough that we don't care
	std::vector<glm::u8vec4> MDX::matrix_groups_as_skin_weights(const Geoset& geoset) {
		std::vector<glm::u8vec4> groups;
		groups.reserve(geoset.matrix_groups.size());
		std::vector<glm::u8vec4> weights;
		weights.reserve(geoset.matrix_groups.size());

		size_t bone_offset = 0;
		for (const auto& group_size : geoset.matrix_groups) {
			const int bone_count = std::min(group_size, 4u);
			glm::uvec4 indices(0);
			glm::uvec4 weightss(0);

			const int weight = 255 / bone_count;
			for (size_t j = 0; j < bone_count; j++) {
				indices[j] = geoset.matrix_indices[bone_offset + j];
				weightss[j] = weight;
			}
			weightss[0] += 255 % bone_count;

			groups.push_back(indices);
			weights.push_back(weightss);
			bone_offset += group_size;
		}

		std::vector<glm::u8vec4> skin_weights;
		skin_weights.reserve(groups.size() * 2);
		for (const auto& vertex_group : geoset.vertex_groups) {
			skin_weights.push_back(groups[vertex_group]);
			skin_weights.push_back(weights[vertex_group]);
		}

		return skin_weights;
	}

	MDX& MDX::calculate_extents() {
		for (auto& geoset : geosets) {
			geoset.extent.minimum = glm::vec3(std::numeric_limits<float>::max());
			geoset.extent.maximum = glm::vec3(std::numeric_limits<float>::lowest());
			for (const auto& i : geoset.vertices) {
				geoset.extent.minimum = glm::min(geoset.extent.minimum, i);
				geoset.extent.maximum = glm::max(geoset.extent.maximum, i);
			}

			geoset.extent.bounds_radius =
				std::max(glm::distance(glm::vec3(0.0), geoset.extent.minimum), glm::distance(glm::vec3(0.0), geoset.extent.maximum));

			for (auto& extent : geoset.sequence_extents) {
				// Wrong because we should capture the min/max of the entire animation but that's kind of a pain to implement
				extent = geoset.extent;
			}

			extent.minimum = glm::min(extent.minimum, geoset.extent.minimum);
			extent.maximum = glm::max(extent.maximum, geoset.extent.maximum);
			extent.bounds_radius = std::max(extent.bounds_radius, geoset.extent.bounds_radius);
		}

		for (auto& sequence : sequences) {
			// Wrong because we should capture the min/max of the entire animation but that's kind of a pain to implement
			sequence.extent = extent;
		}

		return *this;
	}
} // namespace mdx
```

`src/file_formats/mdx/validator.cpp`:

```cpp
module;

module MDX;

import std;

namespace mdx {
	void MDX::validate() {
		// Remove geoset animations that reference non-existing geosets
		for (size_t i = animations.size(); i-- > 0;) {
			if (animations[i].geoset_id >= geosets.size()) {
				animations.erase(animations.begin() + i);
			}
		}

		size_t node_count = bones.size() +
							lights.size() +
							help_bones.size() +
							attachments.size() +
							emitters1.size() +
							emitters2.size() +
							ribbons.size() +
							event_objects.size() +
							collision_shapes.size() +
							corn_emitters.size();

		// If there are no bones we have to add one to prevent crashing and stuff.
		if (bones.empty()) {
			Bone bone{};
			bone.node.parent_id = -1;
			bone.node.id = node_count++;
			bones.push_back(bone);
		}

		// ———————————No sequences?———————————
		// ⣞⢽⢪⢣⢣⢣⢫⡺⡵⣝⡮⣗⢷⢽⢽⢽⣮⡷⡽⣜⣜⢮⢺⣜⢷⢽⢝⡽⣝
		//⠸⡸⠜⠕⠕⠁⢁⢇⢏⢽⢺⣪⡳⡝⣎⣏⢯⢞⡿⣟⣷⣳⢯⡷⣽⢽⢯⣳⣫⠇
		//⠀⠀⢀⢀⢄⢬⢪⡪⡎⣆⡈⠚⠜⠕⠇⠗⠝⢕⢯⢫⣞⣯⣿⣻⡽⣏⢗⣗⠏⠀
		//⠀⠪⡪⡪⣪⢪⢺⢸⢢⢓⢆⢤⢀⠀⠀⠀⠀⠈⢊⢞⡾⣿⡯⣏⢮⠷⠁⠀⠀
		//⠀⠀⠀⠈⠊⠆⡃⠕⢕⢇⢇⢇⢇⢇⢏⢎⢎⢆⢄⠀⢑⣽⣿⢝⠲⠉⠀⠀⠀⠀
		//⠀⠀⠀⠀⠀⡿⠂⠠⠀⡇⢇⠕⢈⣀⠀⠁⠡⠣⡣⡫⣂⣿⠯⢪⠰⠂⠀⠀⠀⠀
		//⠀⠀⠀⠀⡦⡙⡂⢀⢤⢣⠣⡈⣾⡃⠠⠄⠀⡄⢱⣌⣶⢏⢊⠂⠀⠀⠀⠀⠀⠀
		//⠀⠀⠀⠀⢝⡲⣜⡮⡏⢎⢌⢂⠙⠢⠐⢀⢘⢵⣽⣿⡿⠁⠁⠀⠀⠀⠀⠀⠀⠀
		//⠀⠀⠀⠀⠨⣺⡺⡕⡕⡱⡑⡆⡕⡅⡕⡜⡼⢽⡻⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
		//⠀⠀⠀⠀⣼⣳⣫⣾⣵⣗⡵⡱⡡⢣⢑⢕⢜⢕⡝⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
		//⠀⠀⠀⣴⣿⣾⣿⣿⣿⡿⡽⡑⢌⠪⡢⡣⣣⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
		//⠀⠀⠀⡟⡾⣿⢿⢿⢵⣽⣾⣼⣘⢸⢸⣞⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
		//⠀⠀⠀⠀⠁⠇⠡⠩⡫⢿⣝⡻⡮⣒⢽⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
		//————————————————————————————————————
		if (sequences.empty()) {
			sequences.push_back(Sequence {
				.name = "stand",
				.start_frame = 0,
				.end_frame = 0,
				.movespeed = 0.f,
				.flags = Sequence::Flags::looping,
				.rarity = 0.f,
				.sync_point = 0,
				.extent = extent
			});
		}

		// Sometimes (for doodads mostly) the sequence extents are empty (0.0) which messes with culling
		for (auto& i : sequences) {
			if (i.extent.minimum == glm::vec3(0.f) && i.extent.maximum == glm::vec3(0.f)) {
				i.extent = extent;
			}
		}

		// We rely on sortedness for MDX optimization
		std::ranges::sort(sequences, [](const auto& a, const auto& b) {
			return a.start_frame < b.start_frame;
		});

		// Ensure that the pivot buffer is big enough
		pivots.resize(node_count, {});

		// Compact node IDs
		std::vector<int> IDs;
		IDs.reserve(node_count);
		for_each_node([&](mdx::Node& node) {
			if (node.id < 0) {
				std::println("Error: MDX {} node \"{}\" has invalid ID {}", name, node.name, node.id);
				return;
			}
			IDs.push_back(node.id);
		});

		const int max_id = *std::max_element(IDs.begin(), IDs.end());
		std::vector<int> remapping(max_id + 1);
		for (size_t i = 0; i < IDs.size(); i++) {
			remapping[IDs[i]] = i;
		}

		for_each_node([&](mdx::Node& node) {
			if (node.id == -1) {
				std::println("Error: Invalid node \"{}\" with ID -1", node.name);
				return;
			}
			node.id = remapping[node.id];
			if (node.parent_id != -1) {
				node.parent_id = remapping[node.parent_id];
			}
		});

		for (auto& i : geosets) {
			if (i.uv_sets.empty()) {
				std::println("Error: No UV sets in model");
				return;
			}

			if (!i.vertex_groups.empty() && !i.skin.empty()) {
				std::println("Error: Both vertex_groups and skin weights are set");
				return;
			}

			bool same = i.vertices.size() == i.uv_sets.front().size() && i.vertices.size() == i.normals.size();
			if (i.vertex_groups.size() > 0) {
				same = same && i.vertices.size() == i.vertex_groups.size();

				if (!same) {
					std::println("One or more of these are inequal.\nvertices: {}\nuv_sets: {}\nnormals: {}\nvertex_groups: {}", i.vertices.size(), i.uv_sets.front().size(), i.normals.size(), i.vertex_groups.size());
					return;
				}
			} else {
				same = same && i.vertices.size() == i.skin.size() / 8;

				if (!same) {
					std::println("One or more of these are inequal.\nvertices: {}\nuv_sets: {}\nnormals: {}\nskin weights: {}", i.vertices.size(), i.uv_sets.front().size(), i.normals.size(), i.skin.size() / 8);
					return;
				}
			}

			for (const auto& set : i.uv_sets) {
				if (set.empty()) {
					std::println("Error: Empty UV set");
					return;
				}
			}
		}

		// Fix vertex groups that reference non existent matrix groups
		for (auto& i : geosets) {
			// RMS seems to output -1 here sometimes ;(
			if (i.lod == std::numeric_limits<uint32_t>::max()) {
				i.lod = 0;
			}
			for (auto& j : i.vertex_groups) {
				// If no matrix groups exist, we insert one
				if (i.matrix_groups.empty()) {
					i.matrix_groups.push_back(1);
					i.matrix_indices.push_back(0);
				}
				// Don't reference non-existing ones!
				if (j >= i.matrix_groups.size()) {
					j = std::min<uint8_t>(j, i.matrix_groups.size() - 1);
				}
			}
		}
	}
} // namespace mdx
```

`src/file_formats/mpq.ixx`:

```ixx
module;

#define __STORMLIB_NO_STATIC_LINK__
#include "StormLib.h";

export module MPQ;

import std;

namespace fs = std::filesystem;

// A thin wrapper around StormLib https://github.com/ladislav-zezula/StormLib
namespace mpq {
	export class File {
	  public:
		HANDLE handle = nullptr;

		File() = default;
		~File() {
			close();
		}
		File(File&& move) noexcept {
			handle = move.handle;
			move.handle = nullptr;
		}
		File(const File&) = default;
		File& operator=(const File&) = default;
		File& operator=(File&& move) noexcept {
			handle = move.handle;
			move.handle = nullptr;
			return *this;
		}

		std::vector<std::uint8_t> read() const {
			const std::uint32_t size = SFileGetFileSize(handle, nullptr);
			if (size == 0) {
				return {};
			}

			std::vector<std::uint8_t> buffer(size);

#ifdef _MSC_VER
			unsigned long bytes_read;
#else
			unsigned int bytes_read;
#endif
			const bool success = SFileReadFile(handle, buffer.data(), size, &bytes_read, nullptr);
			if (!success) {
				throw std::runtime_error("Failed to read file: " + std::to_string(GetLastError()));
			}
			return buffer;
		}

		/// An implementation using optional. Use this for all reads?
		std::optional<std::vector<std::uint8_t>> read2() const {
			const std::uint32_t size = SFileGetFileSize(handle, nullptr);
			if (size == 0) {
				return {};
			}

			std::vector<std::uint8_t> buffer(size);

#ifdef _MSC_VER
			unsigned long bytes_read;
#else
			unsigned int bytes_read;
#endif
			const bool success = SFileReadFile(handle, buffer.data(), size, &bytes_read, nullptr);
			if (!success) {
				std::cout << "Failed to read file: " << GetLastError() << std::endl;
			}
			return buffer;
		}

		size_t size() const {
			return SFileGetFileSize(handle, nullptr);
		}

		void close() const {
			SFileCloseFile(handle);
		}
	};

	export class MPQ {
	  public:
		HANDLE handle = nullptr;

		MPQ() = default;

		explicit MPQ(const fs::path& path, const unsigned long flags = 0) {
			open(path, flags);
		}

		~MPQ() {
			close();
		}
		MPQ(MPQ&& move)
		noexcept {
			handle = move.handle;
			move.handle = nullptr;
		}
		MPQ(const MPQ&) = default;
		MPQ& operator=(const MPQ&) = delete;
		MPQ& operator=(MPQ&& move) noexcept {
			handle = move.handle;
			move.handle = nullptr;
			return *this;
		}

		bool open(const fs::path& path, const unsigned long flags = 0) {
			return SFileOpenArchive(path.c_str(), 0, flags, &handle);
		}

		void close() {
			SFileCloseArchive(handle);
			handle = nullptr;
		}

		bool compact() {
			return SFileCompactArchive(handle, nullptr, false);
		}

		bool unpack(const fs::path& path) {
			SFILE_FIND_DATA file_data;
			HANDLE find_handle = SFileFindFirstFile(handle, "*", &file_data, nullptr);
			fs::create_directories((path / file_data.cFileName).parent_path());
			SFileExtractFile(handle, file_data.cFileName, (path / file_data.cFileName).c_str(), SFILE_OPEN_FROM_MPQ);

			while (SFileFindNextFile(find_handle, &file_data)) {
				fs::create_directories((path / file_data.cFileName).parent_path());
				SFileExtractFile(handle, file_data.cFileName, (path / file_data.cFileName).c_str(), SFILE_OPEN_FROM_MPQ);
			}
			SFileFindClose(find_handle);

			// Delete unneeded files
			fs::remove(path / "(listfile)");
			fs::remove(path / "(attributes)");
			fs::remove(path / "(war3map.imp)");
			return true;
		}

		File file_open(const fs::path& path) const {
			File file;
#ifdef WIN32
			const bool opened = SFileOpenFileEx(handle, fs::weakly_canonical(path).string().c_str(), 0, &file.handle);
#else
			const bool opened = SFileOpenFileEx(handle, path.string().c_str(), 0, &file.handle);
#endif
			if (!opened) {
				throw std::runtime_error("Failed to read file " + path.string() + " with error: " + std::to_string(GetLastError()));
			}
			return file;
		}

		void file_write(const fs::path& path, const std::vector<std::uint8_t>& data) const {
			HANDLE out_handle;
			bool success = SFileCreateFile(handle, path.string().c_str(), 0, static_cast<DWORD>(data.size()), 0, MPQ_FILE_COMPRESS | MPQ_FILE_REPLACEEXISTING, &out_handle);
			if (!success) {
				std::cout << GetLastError() << " " << path << "\n";
			}

			success = SFileWriteFile(out_handle, data.data(), static_cast<DWORD>(data.size()), MPQ_COMPRESSION_ZLIB);
			if (!success) {
				std::cout << "Writing to file failed: " << GetLastError() << " " << path << "\n";
			}

			success = SFileFinishFile(out_handle);
			if (!success) {
				std::cout << "Finishing write failed: " << GetLastError() << " " << path << "\n";
			}
		}

		void file_remove(const fs::path& path) const {
			SFileRemoveFile(handle, path.string().c_str(), 0);
		}

		bool file_exists(const fs::path& path) const {
#ifdef WIN32
			return SFileHasFile(handle, fs::weakly_canonical(path).string().c_str());
#else
			return SFileHasFile(handle, path.string().c_str());
#endif
		}

		void file_add(const fs::path& path, const fs::path& new_path) const {
#ifdef _MSC_VER
			bool success = SFileAddFileEx(handle, path.wstring().c_str(), new_path.string().c_str(), MPQ_FILE_COMPRESS | MPQ_FILE_REPLACEEXISTING, MPQ_COMPRESSION_ZLIB, MPQ_COMPRESSION_ZLIB);
#else
			bool success = SFileAddFileEx(handle, path.string().c_str(), new_path.string().c_str(), MPQ_FILE_COMPRESS | MPQ_FILE_REPLACEEXISTING, MPQ_COMPRESSION_ZLIB, MPQ_COMPRESSION_ZLIB);
#endif
			if (!success) {
				std::cout << "Error adding file: " << GetLastError() << "\n";
			}
		}
	};
} // namespace mpq
```

`src/file_formats/slk.ixx`:

```ixx
export module SLK;

import std;
import Hierarchy;
import no_init_allocator;
import BinaryReader;
import Utilities;
import INI;
import UnorderedMap;
import "absl/strings/str_split.h";
import "absl/strings/str_join.h";

namespace fs = std::filesystem;

using namespace std::string_literals;

namespace slk {
	export class SLK {
		/// column_header should be lowercase
		[[nodiscard]]
		std::optional<std::string_view> data_single_asset_type(std::string_view column_header, std::string_view row_header) const {
			assert(to_lowercase_copy(column_header) == column_header);

			// Shadow data
			if (const auto found_row = shadow_data.find(row_header); found_row != shadow_data.end()) {
				if (const auto found_column = found_row->second.find(column_header); found_column != found_row->second.end()) {
					return found_column->second;
				}
			}

			// Base data
			if (const auto found_row = base_data.find(row_header); found_row != base_data.end()) {
				if (const auto found_column = found_row->second.find(column_header); found_column != found_row->second.end()) {
					return found_column->second;
				}
			}

			return {};
		}

	  public:
		hive::unordered_map<size_t, std::string> index_to_row;
		hive::unordered_map<size_t, std::string> index_to_column;
		hive::unordered_map<std::string, size_t> row_headers;
		hive::unordered_map<std::string, size_t> column_headers;
		hive::unordered_map<std::string, hive::unordered_map<std::string, std::string>> base_data;
		hive::unordered_map<std::string, hive::unordered_map<std::string, std::string>> shadow_data;

		// The following map is only used in meta SLKs and maps the field (+unit/ability ID) to a meta ID
		hive::unordered_map<std::string, std::string> meta_map;

		SLK() = default;

		explicit SLK(const fs::path& path, const bool local = false) {
			load(path, local);
		}

		void load(const fs::path& path, const bool local = false) {
			std::vector<uint8_t, default_init_allocator<uint8_t>> buffer;
			if (local) {
				std::ifstream stream(path, std::ios::binary);
				buffer = std::vector<uint8_t, default_init_allocator<uint8_t>>(
					std::istreambuf_iterator<char>(stream),
					std::istreambuf_iterator<char>()
				);
			} else {
				buffer = hierarchy.open_file(path).value().buffer;
			}

			std::string_view view(reinterpret_cast<char*>(buffer.data()), buffer.size());

			if (!view.starts_with("ID")) {
				std::print("Invalid SLK file, does not contain \"ID\" as first record\n");
				return;
			}

			const auto parse_integer = [&]() {
				size_t value;
				size_t separator = view.find(';');
				std::from_chars(&view[1], &view[separator], value);
				view.remove_prefix(separator + 1);
				return value;
			};

			// Skip first ID line
			view.remove_prefix(view.find('\n') + 1);

			size_t column = 0;
			size_t row = 0;

			while (view.size()) {
				switch (view.front()) {
					case 'C':
						view.remove_prefix(2);

						if (view.front() == 'X') {
							column = parse_integer() - 1;

							if (view.front() == 'Y') {
								row = parse_integer() - 1;
							}
						} else {
							row = parse_integer() - 1;

							if (view.front() == 'X') {
								column = parse_integer() - 1;
							}
						}

						if (row == 0 && column == 0) {
							view.remove_prefix(view.find('\n') + 1);
							break;
						}

						view.remove_prefix(1);

						{
							std::string data;
							if (view.front() == '\"') {
								data = view.substr(1, view.find('"', 1) - 1);
							} else {
								data = view.substr(0, view.find_first_of("\r\n"));
							}

							if (data == "-" || data == "_") {
								data = "";
							}

							if (column == 0) {
								// -1 as 0,0 is unitid/doodadid etc.
								row_headers.emplace(data, row - 1);
								index_to_row.emplace(row - 1, data);
							} else if (row == 0) {
								// If it is a column header, we need to lowercase it as column headers are case-insensitive
								to_lowercase(data);
								// -1 as 0,0 is unitid/doodadid etc.
								column_headers.emplace(data, column - 1);
								index_to_column.emplace(column - 1, data);
							} else {
								base_data[index_to_row[row - 1]][index_to_column[column - 1]] = data;
							}

							view.remove_prefix(view.find('\n') + 1);
						}
						break;
					case 'F':
						if (view.front() == 'X') {
							column = parse_integer() - 1;

							if (view.front() == 'Y') {
								row = parse_integer() - 1;
							}
						} else {
							row = parse_integer() - 1;

							if (view.front() == 'X') {
								column = parse_integer() - 1;
							}
						}
						view.remove_prefix(view.find('\n') + 1);
						break;
					default:
						view.remove_prefix(view.find_first_of('\n') + 1);
				}
			}

			// Remove empty rows (might contain data but don't have a row header)

			size_t i = 0;
			while (i < index_to_row.size()) {
				if (index_to_row.at(i).empty()) {
					for (size_t j = index_to_row.size() - 1; j > i; j--) {
						if (!index_to_row.at(j).empty()) {
							index_to_row[i] = index_to_row.at(j);
							row_headers.at(index_to_row.at(i)) = i;
							index_to_row.erase(j);
							break;
						}
					}
				}
				i += 1;
			}
			row_headers.erase("");
		}

		void build_meta_map() {
			// Check if we are a meta_slk
			if (!column_headers.contains("field")) {
				return;
			}

			for (const auto& [header, row] : row_headers) {
				std::string field = to_lowercase_copy(data<std::string_view>("field", header));

				const int repeat = data<int>("data", header);
				if (repeat > 0) {
					field += 'a' + (repeat - 1);
				}
				if (column_headers.contains("usespecific")) {
					std::vector<std::string> parts = absl::StrSplit(data<std::string_view>("usespecific", header), ",", absl::SkipEmpty());
					if (!parts.empty()) {
						for (const auto& i : parts) {
							meta_map.emplace(field + i, header);
						}
					} else {
						meta_map.emplace(field, header);
					}
				} else {
					meta_map.emplace(field, header);
				}
			}
		}

		/// To map a field in a data SLK (race, pathTex, moveSpeed, etc.) to the field ID in the meta SLK.
		/// The ID of the unit/doodad/ability needs to be supplied as some fields can only be resolved that way (useSpecific for abilities).
		[[nodiscard]]
		std::optional<std::string_view> field_to_meta_id(const SLK& meta_slk, const std::string_view field_name, const std::string_view id) const {
			// First check raw field name. They can sometimes have numbers already (effect1, mod2, etc.)
			if (const auto found_field = meta_slk.meta_map.find(field_name); found_field != meta_slk.meta_map.end()) {
				return found_field->second;
			}

			// Then strip the number as it then probably is just a variation number (e.g. name1 and name2 for different upgrade levels)
			const std::string_view stripped_field_name = field_name.substr(0, field_name.find_first_of("0123456789"));
			if (const auto found_field = meta_slk.meta_map.find(stripped_field_name); found_field != meta_slk.meta_map.end()) {
				return found_field->second;
			}

			// Only abilities should get here as they're the only ones that have multiple field names mapping to the same field ID
			std::string_view base_id = id;
			if (const auto found_base_id = data_single_asset_type("oldid", id); found_base_id) {
				base_id = found_base_id.value();
			}

			// Abilities can also alias another existing ability, so we have to check both the base ID and alias
			// Sometimes only the base ID is used in `useSpecific` and sometimes only the alias.

			// Safety: Only abilities should enter this block and they all have an alias
			const auto alias = data_single_asset_type("code", id).value();
			const auto found_alias = meta_slk.meta_map.find(std::string(stripped_field_name).append(alias));
			if (found_alias != meta_slk.meta_map.end()) {
				return found_alias->second;
			}

			const auto found = meta_slk.meta_map.find(std::string(stripped_field_name).append(base_id));
			if (found != meta_slk.meta_map.end()) {
				return found->second;
			}

			return {};
		}

		// column_header should be lowercase
		template<typename T = std::string>
		T data(const std::string_view column_header, const std::string_view row_header) const {
			static_assert(
				std::is_same_v<T, std::string_view> || std::is_same_v<T, std::string> || std::is_floating_point_v<T>
					|| std::is_integral_v<T>,
				"Type not supported. Convert yourself or add conversion here if it makes sense"
			);
			assert(to_lowercase_copy(column_header) == column_header);

			auto data = data_single_asset_type(column_header, row_header);
			if (!data) {
				if (hierarchy.hd) {
					data = data_single_asset_type(std::string(column_header) + ":hd", row_header);
				} else {
					data = data_single_asset_type(std::string(column_header) + ":sd", row_header);
				}
			}

			if (!data) {
				return T();
			}

			if constexpr (std::is_same<T, std::string_view>()) {
				return *data;
			} else if constexpr (std::is_same<T, std::string>()) {
				return std::string(*data);
			} else if constexpr (std::is_same<T, bool>()) {
				int output;
				std::from_chars(data->data(), data->data() + data->size(), output);
				return output != 0;
			} else if constexpr (std::is_floating_point_v<T> || std::is_integral_v<T>) {
				T output;
				std::from_chars(data->data(), data->data() + data->size(), output);
				return output;
			}

			throw;
		}

		// Gets the data by first checking the shadow table and then checking the base table
		// Does :sd and :hd tag resolution too
		// column_header should be lowercase
		// If you have both an integer row index and the string row name then use the overload that takes string_view as it will do a index->name conversion internally
		template<typename T = std::string>
		T data(const std::string_view column_header, size_t row) const {
			if (row >= index_to_row.size()) {
				throw;
			}

			return data<T>(column_header, index_to_row.at(row));
		}

		// Gets the data by first checking the shadow table and then checking the base table
		template<typename T = std::string>
		T data(size_t column, size_t row) const {
			if (row >= index_to_row.size()) {
				throw;
			}

			if (column >= index_to_column.size()) {
				throw;
			}

			return data<T>(index_to_column.at(column), index_to_row.at(row));
		}

		// Merges the base data of the files
		// Shadow data is not merged
		// Any unknown columns are appended
		void merge(const slk::SLK& slk) {
			for (const auto& [header, index] : slk.column_headers) {
				if (!column_headers.contains(header)) {
					add_column(header);
				}
			}

			for (const auto& [id, properties] : slk.base_data) {
				if (!base_data.contains(id)) {
					continue;
				}
				base_data[id].insert(properties.begin(), properties.end());
			}
		}

		/// Merges the data of the files. INI sections are matched to row keys, and INI keys are matched to column keys.
		/// If an unknown section key is encountered, then that section is skipped.
		/// If an unknown column key is encountered, then the column is added

		size_t non_matches = 0;

		void merge(const ini::INI& ini, const SLK& meta_slk) {
			for (const auto& [section_key, section_value] : ini.ini_data) {
				auto found_section = base_data.find(section_key);
				if (found_section == base_data.end()) {
					continue;
				}

				auto& [key, section] = *found_section;

				for (const auto& [key, value] : section_value) {
					const std::string key_lower = to_lowercase_copy(key);

					if (!column_headers.contains(key_lower)) {
						add_column(key_lower);
					}

					// By making some changes to unitmetadata.slk and unitdata.slk we can avoid the 1->2->2 mapping for SLK->OE->W3U files.
					// This means we have to manually split these into the correct column
					if (value.size() > 1
						&& (key_lower == "missilearc" || key_lower == "missileart" || key_lower == "missilehoming"
							|| key_lower == "missilespeed" || key_lower == "buttonpos" || key_lower == "unbuttonpos"
							|| key_lower == "researchbuttonpos")
						&& column_headers.contains(key_lower + "2")) {
						section[key_lower] = value[0];
						section[key_lower + "2"] = value[1];
						continue;
					}

					const std::string key_lower_stripped = key_lower.substr(0, key_lower.find_first_of(':'));

					std::string id;
					if (auto found = meta_slk.meta_map.find(key_lower_stripped); found != meta_slk.meta_map.end()) {
						id = found->second;
					} else if (auto found = meta_slk.meta_map.find(key_lower_stripped + section_key); found != meta_slk.meta_map.end()) {
						id = found->second;
					} else {
						const size_t nr_position = key_lower_stripped.find_first_of("0123456789");
						const std::string without_numbers = key_lower_stripped.substr(0, nr_position);

						if (auto found = meta_slk.meta_map.find(without_numbers); found != meta_slk.meta_map.end()) {
							id = found->second;
						} else {
							continue;
						}
					}

					const int repeat = meta_slk.data<int>("repeat", id);
					if (repeat > 0 && !(meta_slk.column_headers.contains("appendindex") && meta_slk.data<int>("appendindex", id) > 0)) {
						for (size_t i = 0; i < value.size(); i++) {
							const std::string new_key = std::format("{}{}", key_lower, i + 1);
							if (!column_headers.contains(new_key)) {
								add_column(new_key);
							}
							section[new_key] = value[i];
						}
					} else {
						if (meta_slk.data<std::string_view>("type", id).ends_with("List")) {
							section[key_lower] = absl::StrJoin(value, ",");
						} else {
							section[key_lower] = value[0];
						}
					}
				}
			}
		}

		/// Substitutes the data of the slk with data from the INI based on a certain section key.
		/// The keys of the section are matched with all the cells in the table and if they match will replace the value
		void substitute(const ini::INI& ini, const std::string_view section) {
			assert(ini.section_exists(section));

			for (auto& [id, properties] : base_data) {
				for (auto& [prop_id, prop_value] : properties) {
					std::string_view data = ini.data<std::string_view>(section, prop_value);
					if (!data.empty()) {
						prop_value = std::string(data);
					}
				}
			}
		}

		/// Copies the row with header row_header to a new line with the new header as new_row_header
		void copy_row(const std::string_view row_header, std::string_view new_row_header, bool copy_shadow_data) {
			assert(base_data.contains(row_header));
			assert(!base_data.contains(new_row_header));

			// Get a weird allocation error if not done via a temporary 19/06/2021
			const auto t = base_data.at(row_header);
			base_data[new_row_header] = t;

			if (copy_shadow_data && shadow_data.contains(row_header)) {
				// Get a weird allocation error if not done via a temporary 19/06/2021
				const auto tt = shadow_data.at(row_header);
				shadow_data[new_row_header] = tt;
			}

			size_t index = row_headers.size();
			row_headers.emplace(new_row_header, index);
			index_to_row[index] = new_row_header;

			// Only set/change oldid if the row didn't have one (which means it is a default unit/item/...)
			if (!shadow_data[new_row_header].contains("oldid")) {
				shadow_data[new_row_header]["oldid"] = row_header;
			}
		}

		void remove_row(const std::string_view row_header) {
			assert(base_data.contains(row_header));

			base_data.erase(row_header);
			shadow_data.erase(row_header);

			const size_t index = row_headers.at(row_header);
			if (index == rows() - 1) {
				index_to_row.erase(index);
				row_headers.erase(row_header);
			} else {
				// Swap with a element from the end to avoid having to change all indices
				const std::string replacement_id = index_to_row.at(rows() - 1);
				index_to_row[index] = replacement_id;
				row_headers[replacement_id] = index;
				index_to_row.erase(rows() - 1);

				row_headers.erase(row_header);
			}
		}

		/// Adds a (virtual) column
		/// Since SLK2 is only a key/pair store it emulates being table like and thus this call is very cheap memory/cpu wise
		/// column_header must be lowercase
		void add_column(const std::string_view column_header) {
			assert(to_lowercase_copy(column_header) == column_header);

			size_t index = column_headers.size();
			column_headers.emplace(column_header, index);
			index_to_column[index] = column_header;
		}

		// column_header should be lowercase
		void set_shadow_data(const std::string_view column_header, const std::string_view row_header, std::string data) {
			assert(to_lowercase_copy(column_header) == column_header);

			if (!column_headers.contains(column_header)) {
				add_column(column_header);
			}

			if (base_data.contains(row_header) && base_data.at(row_header).contains(column_header)) {
				if (base_data.at(row_header).at(column_header) == data) {
					if (shadow_data.contains(row_header)) {
						shadow_data.at(row_header).erase(column_header);
						if (shadow_data.at(row_header).empty()) {
							shadow_data.erase(row_header);
						}
					}
					return;
				}
			}

			shadow_data[row_header][column_header] = data;
		}

		void set_shadow_data(const int column, const int row, std::string data) {
			set_shadow_data(index_to_column.at(column), index_to_row.at(row), data);
		}

		size_t rows() const {
			return row_headers.size();
		}

		size_t columns() const {
			return column_headers.size();
		}
	};
} // namespace slk

```

`src/globals.ixx`:

```ixx
module;

#include "main_window/glwidget.h"

export module Globals;

import INI;
import SLK;

export inline ini::INI world_edit_strings;
export inline ini::INI world_edit_game_strings;
export inline ini::INI world_edit_data;

export inline slk::SLK units_slk;
export inline slk::SLK units_meta_slk;
export inline ini::INI unit_editor_data;

export inline slk::SLK items_slk;
export inline slk::SLK items_meta_slk;

export inline slk::SLK abilities_slk;
export inline slk::SLK abilities_meta_slk;

export inline slk::SLK doodads_slk;
export inline slk::SLK doodads_meta_slk;

export inline slk::SLK destructibles_slk;
export inline slk::SLK destructibles_meta_slk;

export inline slk::SLK upgrade_slk;
export inline slk::SLK upgrade_meta_slk;

export inline slk::SLK buff_slk;
export inline slk::SLK buff_meta_slk;

export inline GLWidget* context;
```

`src/main.cpp`:

```cpp
#define MI_MALLOC_OVERRIDE
#include <mimalloc.h>

#define QT_NO_OPENGL

#include <QApplication>
#include <QCoreApplication>
#include <QFile>
#include <QFont>
#include <QPalette>
#include <QSurfaceFormat>
#include <QSettings>
#include <QStyleFactory>

#include "main_window/hivewe.h"
#include "DockManager.h"

#ifdef WIN32
// To force HiveWE to run on the discrete GPU if available
extern "C" {
__declspec(dllexport) int AmdPowerXpressRequestHighPerformance = 1;
__declspec(dllexport) unsigned long NvOptimusEnablement = 1;
}
#endif

int main(int argc, char* argv[]) {
	QSurfaceFormat format;
	format.setDepthBufferSize(24);
	format.setStencilBufferSize(8);
	format.setVersion(4, 5);
	format.setProfile(QSurfaceFormat::CoreProfile);
	format.setOption(QSurfaceFormat::DebugContext);
	format.setSwapInterval(1);
	//format.setColorSpace(QSurfaceFormat::sRGBColorSpace);
	QSurfaceFormat::setDefaultFormat(format);

	QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts);
	QCoreApplication::setOrganizationName("HiveWE");
	QCoreApplication::setApplicationName("HiveWE");

	QLocale::setDefault(QLocale("en_US"));

	// Create a dark palette
	// For some magically unknown reason Qt draws Qt::white text as black, so we use QColor(255, 254, 255) instead
	QPalette darkPalette;
	darkPalette.setColor(QPalette::Window, QColor(53, 53, 53));
	darkPalette.setColor(QPalette::WindowText, QColor(255, 254, 255));
	darkPalette.setColor(QPalette::Disabled, QPalette::WindowText, QColor(127, 127, 127));
	darkPalette.setColor(QPalette::Base, QColor(42, 42, 42));
	darkPalette.setColor(QPalette::AlternateBase, QColor(66, 66, 66));
	darkPalette.setColor(QPalette::ToolTipBase, QColor(66, 66, 66));
	darkPalette.setColor(QPalette::ToolTipText, QColor(255, 254, 255));
	darkPalette.setColor(QPalette::Text, QColor(255, 254, 255));
	darkPalette.setColor(QPalette::PlaceholderText, Qt::gray);
	darkPalette.setColor(QPalette::Disabled, QPalette::Text, QColor(127, 127, 127));
	darkPalette.setColor(QPalette::Dark, QColor(35, 35, 35));
	darkPalette.setColor(QPalette::Shadow, QColor(20, 20, 20));
	darkPalette.setColor(QPalette::Button, QColor(53, 53, 53));
	darkPalette.setColor(QPalette::ButtonText, QColor(255, 254, 255));
	darkPalette.setColor(QPalette::Disabled, QPalette::ButtonText, QColor(127, 127, 127));
	darkPalette.setColor(QPalette::BrightText, Qt::red);
	darkPalette.setColor(QPalette::Link, QColor(42, 130, 218));
	darkPalette.setColor(QPalette::Highlight, QColor(42, 130, 218));
	darkPalette.setColor(QPalette::Disabled, QPalette::Highlight, QColor(80, 80, 80));
	darkPalette.setColor(QPalette::HighlightedText, QColor(255, 254, 255));
	darkPalette.setColor(QPalette::Disabled, QPalette::HighlightedText, QColor(127, 127, 127));

	QApplication::setPalette(darkPalette);
	QApplication::setStyle("Fusion");

	QApplication a(argc, argv);

	ads::CDockManager::setConfigFlag(ads::CDockManager::FocusHighlighting);
	ads::CDockManager::setConfigFlag(ads::CDockManager::AllTabsHaveCloseButton);
	ads::CDockManager::setConfigFlag(ads::CDockManager::DockAreaDynamicTabsMenuButtonVisibility);
	ads::CDockManager::setConfigFlag(ads::CDockManager::OpaqueSplitterResize);
	ads::CDockManager::setConfigFlag(ads::CDockManager::MiddleMouseButtonClosesTab);

	const QSettings settings;
	QFile file("data/themes/" + settings.value("theme", "Dark").toString() + ".qss");
	if (!file.open(QIODevice::ReadOnly)) {
		qWarning() << "Error: Reading theme failed:" << file.error() << ": " << file.errorString();
		return -1;
	}

	a.setStyleSheet(QLatin1String(file.readAll()));

	HiveWE w;
	return QApplication::exec();
}

```

`src/main_window/HiveWE.qrc`:

```qrc
<RCC>
    <qresource prefix="HiveWE">
    </qresource>
</RCC>
```

`src/main_window/HiveWE.rc`:

```rc
IDI_ICON1               ICON    DISCARDABLE     "HiveWE.ico"
```

`src/main_window/HiveWE.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>HiveWEClass</class>
 <widget class="QMainWindow" name="HiveWEClass">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>600</width>
    <height>400</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>HiveWE 0.10</string>
  </property>
  <widget class="QWidget" name="centralWidget">
   <layout class="QVBoxLayout" name="verticalLayout">
    <property name="spacing">
     <number>0</number>
    </property>
    <property name="leftMargin">
     <number>0</number>
    </property>
    <property name="topMargin">
     <number>0</number>
    </property>
    <property name="rightMargin">
     <number>0</number>
    </property>
    <property name="bottomMargin">
     <number>0</number>
    </property>
    <item>
     <widget class="MainRibbon" name="ribbon"/>
    </item>
    <item>
     <widget class="GLWidget" name="widget" native="true">
      <property name="minimumSize">
       <size>
        <width>200</width>
        <height>200</height>
       </size>
      </property>
      <property name="autoFillBackground">
       <bool>false</bool>
      </property>
     </widget>
    </item>
   </layout>
  </widget>
  <action name="actionConvert_Blockers_to_Pathmap">
   <property name="text">
    <string>Convert Blockers to Pathing Map</string>
   </property>
  </action>
  <action name="actionOpen">
   <property name="text">
    <string>Open Map...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+O</string>
   </property>
  </action>
  <action name="actionConvert_Tile_Type_to_PathMap">
   <property name="text">
    <string>Convert Tile Type to Pathing Map</string>
   </property>
  </action>
  <action name="actionPathing_Palette">
   <property name="text">
    <string>Pathing</string>
   </property>
  </action>
  <action name="actionSave">
   <property name="text">
    <string>Save Map</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+S</string>
   </property>
  </action>
  <action name="actionTest_Map">
   <property name="text">
    <string>Test Map</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+T</string>
   </property>
  </action>
  <action name="actionSave_As">
   <property name="text">
    <string>Save Map As...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+S</string>
   </property>
  </action>
  <action name="actionDoodads">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Doodads</string>
   </property>
   <property name="shortcut">
    <string>D</string>
   </property>
  </action>
  <action name="actionPathing">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Pathing</string>
   </property>
   <property name="shortcut">
    <string>P</string>
   </property>
  </action>
  <action name="actionBrush">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Brush</string>
   </property>
  </action>
  <action name="actionTileSetter">
   <property name="text">
    <string>Modify Tileset...</string>
   </property>
  </action>
  <action name="actionTileReplace">
   <property name="text">
    <string>Replace Tile...</string>
   </property>
  </action>
  <action name="actionUnits">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Units</string>
   </property>
   <property name="shortcut">
    <string>U</string>
   </property>
   <property name="shortcutVisibleInContextMenu">
    <bool>false</bool>
   </property>
  </action>
  <action name="actionChangeTilePathing">
   <property name="text">
    <string>Change Tile Pathing...</string>
   </property>
  </action>
  <action name="actionChangeCliffPathing">
   <property name="text">
    <string>Change Cliff Pathing...</string>
   </property>
  </action>
  <action name="actionBirds_Eye">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Bird's-eye</string>
   </property>
   <property name="toolTip">
    <string>Bird's-eye</string>
   </property>
  </action>
  <action name="actionFirst_Person">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>First-person</string>
   </property>
  </action>
  <action name="actionTerrain_Palette">
   <property name="text">
    <string>Terrain</string>
   </property>
  </action>
  <action name="actionFrame_Times">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Frame Times</string>
   </property>
   <property name="shortcut">
    <string>F3</string>
   </property>
  </action>
  <action name="actionImport_Manager">
   <property name="text">
    <string>Import Manager</string>
   </property>
  </action>
  <action name="actionSwitch_Camera">
   <property name="text">
    <string>Switch Camera</string>
   </property>
   <property name="shortcut">
    <string>F1</string>
   </property>
  </action>
  <action name="actionLighting">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Lighting</string>
   </property>
   <property name="shortcut">
    <string>L</string>
   </property>
  </action>
  <action name="actionWireframe">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Wireframe</string>
   </property>
   <property name="shortcut">
    <string>T</string>
   </property>
  </action>
  <action name="actionReset_Camera">
   <property name="text">
    <string>Reset Camera</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+C</string>
   </property>
  </action>
  <action name="actionTrigger_Editor">
   <property name="text">
    <string>Trigger Editor</string>
   </property>
  </action>
  <action name="actionDescription">
   <property name="text">
    <string>Description...</string>
   </property>
  </action>
  <action name="actionSize_and_Camera_Bounds">
   <property name="text">
    <string>Size and Camera Bounds...</string>
   </property>
  </action>
  <action name="actionLoading_Screen">
   <property name="text">
    <string>Loading Screen...</string>
   </property>
  </action>
  <action name="actionPreferences">
   <property name="text">
    <string>Preferences...</string>
   </property>
  </action>
  <action name="actionOptions">
   <property name="text">
    <string>Options...</string>
   </property>
  </action>
  <action name="actionDoodads_Palette">
   <property name="text">
    <string>Doodads</string>
   </property>
  </action>
  <action name="actionEnforce_Water_Height_Limit">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Enforce Water Height Limits</string>
   </property>
  </action>
  <action name="actionSwitch_Warcraft">
   <property name="text">
    <string>Switch Warcraft folder</string>
   </property>
  </action>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <customwidgets>
  <customwidget>
   <class>GLWidget</class>
   <extends>QWidget</extends>
   <header>glwidget.h</header>
   <container>1</container>
  </customwidget>
  <customwidget>
   <class>MainRibbon</class>
   <extends>QTabWidget</extends>
   <header>main_ribbon.h</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <resources>
  <include location="HiveWE.qrc"/>
 </resources>
 <connections/>
</ui>

```

`src/main_window/glwidget.cpp`:

```cpp
#include "glwidget.h"

#include <QTimer>
#include <QPainter>

import std;
import OpenGLUtilities;
import Camera;
import MapGlobal;
import <glad/glad.h>;

void APIENTRY gl_debug_output(const GLenum source, const GLenum type, const GLuint id, const GLenum severity, const GLsizei, const GLchar *message, void *) {
	// Skip buffer info messages, framebuffer info messages, texture usage state warning, redundant state change buffer
	if (id == 131185 // ?
		|| id == 131169 // ?
		|| id == 131204 // ?
		|| id == 8 // ?
		|| id == 131218) // Unexplainable performance warnings
	{
		return;
	}

	std::println("---------------");
	std::println("Debug message ({})", message);

	switch (source) {
		case GL_DEBUG_SOURCE_API:             std::println("Source: API"); break;
		case GL_DEBUG_SOURCE_WINDOW_SYSTEM:   std::println("Source: Window System"); break;
		case GL_DEBUG_SOURCE_SHADER_COMPILER: std::println("Source: Shader Compiler"); break;
		case GL_DEBUG_SOURCE_THIRD_PARTY:     std::println("Source: Third Party"); break;
		case GL_DEBUG_SOURCE_APPLICATION:     std::println("Source: Application"); break;
		case GL_DEBUG_SOURCE_OTHER:           std::println("Source: Other"); break;
		default: break;
	}

	switch (type) {
		case GL_DEBUG_TYPE_ERROR:               std::println("Type: Error"); break;
		case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::println("Type: Deprecated Behaviour"); break;
		case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:  std::println("Type: Undefined Behaviour"); break;
		case GL_DEBUG_TYPE_PORTABILITY:         std::println("Type: Portability"); break;
		case GL_DEBUG_TYPE_PERFORMANCE:         std::println("Type: Performance"); break;
		case GL_DEBUG_TYPE_MARKER:              std::println("Type: Marker"); break;
		case GL_DEBUG_TYPE_PUSH_GROUP:          std::println("Type: Push Group"); break;
		case GL_DEBUG_TYPE_POP_GROUP:           std::println("Type: Pop Group"); break;
		case GL_DEBUG_TYPE_OTHER:               std::println("Type: Other"); break;
		default: break;
	}

	switch (severity) {
		case GL_DEBUG_SEVERITY_HIGH:         std::println("Severity: high"); break;
		case GL_DEBUG_SEVERITY_MEDIUM:       std::println("Severity: medium"); break;
		case GL_DEBUG_SEVERITY_LOW:          std::println("Severity: low"); break;
		case GL_DEBUG_SEVERITY_NOTIFICATION: std::println("Severity: notification"); break;
		default: break;
	}
}

GLWidget::GLWidget(QWidget* parent) : QOpenGLWidget(parent) {
	setMouseTracking(true);
	setFocus();
	setFocusPolicy(Qt::WheelFocus);

	connect(this, &QOpenGLWidget::frameSwapped, [&]() { update(); });
}

void GLWidget::initializeGL() {
	if (!gladLoadGL()) {
		std::println("Something went wrong initializing GLAD");
		exit(-1);
	}
	std::println("OpenGL {}.{}", GLVersion.major, GLVersion.minor);
	
	glEnable(GL_DEBUG_OUTPUT);
	glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
	glDebugMessageCallback(reinterpret_cast<GLDEBUGPROC>(gl_debug_output), nullptr);
	glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_NOTIFICATION, 0, nullptr, false);
	glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_LOW, 0, nullptr, true);
	glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_MEDIUM, 0, nullptr, true);
	glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_HIGH, 0, nullptr, true);

	glEnable(GL_DEPTH_TEST);
	glEnable(GL_CULL_FACE);
	glDepthFunc(GL_LEQUAL);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	glClearColor(0, 0, 0, 1);

	glGenVertexArrays(1, &vao);
	glBindVertexArray(vao);

	int extension_count;
	glGetIntegerv(GL_NUM_EXTENSIONS, &extension_count);
	
	shapes.init();
}

void GLWidget::resizeGL(const int w, const int h) {
	glViewport(0, 0, w, h);

	delta = elapsed_timer.nsecsElapsed() / 1'000'000'000.0;
	camera.aspect_ratio = static_cast<double>(w) / h;

	if (!map || !map->loaded) {
		return;
	}
	camera.update(delta);
	map->render_manager.resize_framebuffers(w, h);
}

void GLWidget::paintGL() {
	delta = elapsed_timer.nsecsElapsed() / 1'000'000'000.0;
	elapsed_timer.start();

	if (!map) {
		return;
	}

	map->update(delta, width(), height());

	//glEnable(GL_FRAMEBUFFER_SRGB);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(true);
	glClearColor(0.f, 0.f, 0.f, 1.f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glBindVertexArray(vao);
	map->render();

	glBindVertexArray(0);

	if (map->render_debug) {
		QPainter p(this);
		p.setPen(QColor(Qt::GlobalColor::white));
		p.setFont(QFont("Arial", 10, 100, false));

		// Rendering time
		static std::vector<double> frametimes;
		frametimes.push_back(delta);
		if (frametimes.size() > 60) {
			frametimes.erase(frametimes.begin());
		}
		float average_frametime = std::accumulate(frametimes.begin(), frametimes.end(), 0.f) / frametimes.size();
		p.drawText(10, 20, QString::fromStdString(std::format("Total time: {:.2f}ms", average_frametime * 1000.0)));

		// General info
		p.drawText(300, 20, QString::fromStdString(std::format("Mouse World Position X:{:.4f} Y:{:.4f} Z:{:.4f}", input_handler.mouse_world.x, input_handler.mouse_world.y, input_handler.mouse_world.z)));
		p.drawText(300, 35, QString::fromStdString(std::format("Camera Position X:{:.4f} Y:{:.4f} Z:{:.4f}", camera.position.x, camera.position.y, camera.position.z)));
		if (map->brush) {
			p.drawText(300, 50, QString::fromStdString(std::format("Brush Grid Position X:{:.4f} Y:{:.4f}", map->brush->get_position().x, map->brush->get_position().y)));
		}

		p.drawText(300, 65, QString::fromStdString(std::format("Camera Horizontal Angle: {:.4f}", camera.horizontal_angle)));
		p.drawText(300, 80, QString::fromStdString(std::format("Camera Vertical Angle: {:.4f}", camera.vertical_angle)));

		p.end();

		// Set changed state back
		glEnable(GL_DEPTH_TEST);
		glDepthFunc(GL_LEQUAL);
		glEnable(GL_BLEND);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	}
}

void GLWidget::keyPressEvent(QKeyEvent* event) {
	if (!map) {
		return;
	}

	input_handler.keys_pressed.emplace(event->key());

	if (map->brush) {
		map->brush->key_press_event(event);
	}
	QOpenGLWidget::keyPressEvent(event);
}

void GLWidget::keyReleaseEvent(QKeyEvent* event) {
	if (!map) {
		return;
	}

	input_handler.keys_pressed.erase(event->key());

	if (map->brush) {
		map->brush->key_release_event(event);
	}
	QOpenGLWidget::keyReleaseEvent(event);
}

void GLWidget::mouseMoveEvent(QMouseEvent* event) {
	if (!map) {
		return;
	}

	input_handler.mouse_move_event(event);
	camera.mouse_move_event(event);

	if (map->brush) {
		map->brush->mouse_move_event(event, delta);
	}
}

void GLWidget::mousePressEvent(QMouseEvent* event) {

	if (!map) {
		return;
	}

	camera.mouse_press_event(event);
	if (map->brush) {
		makeCurrent();
		map->brush->mouse_press_event(event, delta);
	}
}

void GLWidget::mouseReleaseEvent(QMouseEvent* event) {
	if (!map) {
		return;

	}
	camera.mouse_release_event(event);
	if (map->brush) {
		map->brush->mouse_release_event(event);
	}
}

void GLWidget::wheelEvent(QWheelEvent* event) {
	if (!map) {
		return;
	}

	camera.mouse_scroll_event(event);
}
```

`src/main_window/glwidget.h`:

```h
#pragma once

#define QT_NO_OPENGL
import <glad/glad.h>;
#include <QOpenGLWidget>
#include <QElapsedTimer>

class GLWidget : public QOpenGLWidget {
	Q_OBJECT

public:
	QElapsedTimer elapsed_timer;
	GLuint vao;

	double delta = 0.0;

	explicit GLWidget(QWidget* parent);
	~GLWidget() = default;

	void initializeGL() override;
	void resizeGL(int w, int h) override;
	void paintGL() override;

	void keyPressEvent(QKeyEvent* event) override;
	void keyReleaseEvent(QKeyEvent* event) override;
	void mouseMoveEvent(QMouseEvent* event) override;
	void mousePressEvent(QMouseEvent* event) override;
	void mouseReleaseEvent(QMouseEvent* event) override;
	void wheelEvent(QWheelEvent* event) override;
};
```

`src/main_window/hivewe.cpp`:

```cpp
#include "HiveWE.h"
#define __STORMLIB_NO_STATIC_LINK__
#include "StormLib.h"

import std;
import Hierarchy;
import BinaryReader;
import MPQ;
import OpenGLUtilities;
import Camera;
import Globals;
import Map;
import <soil2/SOIL2.h>;
import MapGlobal;
import WorldUndoManager;
import "pathing_palette.h";
import "object_editor/object_editor.h";
import "model_editor/model_editor.h";
import "tile_setter.h";
import "map_info_editor.h";
import "terrain_palette.h";
import "settings_editor.h";
import "tile_pather.h";
import "palette.h";
import "terrain_palette.h";
import "doodad_palette.h";
import "unit_palette.h";
import "object_editor/icon_view.h";
#include "trigger_editor.h"
#include "QMessageBox"
#include "QProcess"

namespace fs = std::filesystem;

HiveWE::HiveWE(QWidget* parent)
	: QMainWindow(parent) {
	setAutoFillBackground(true);

	// Buggy as of Qt 6.9.1. Likely requires 6.9.2 or later
	// setWindowFlag(Qt::ExpandedClientAreaHint, true);
	// setWindowFlag(Qt::NoTitleBarBackgroundHint, true);
	// setAttribute(Qt::WA_LayoutOnEntireRect, true);

	fs::path directory = find_warcraft_directory();

	QSettings settings;
	while (!hierarchy.open_casc(directory)) {
		directory = QFileDialog::getExistingDirectory(this, "Select Warcraft Directory", "/home", QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks).toStdWString();
		if (directory == "") {
			exit(EXIT_SUCCESS);
		}
	}
	settings.setValue("warcraftDirectory", QString::fromStdString(directory.string()));

	// Place common.j and blizzard.j in the data folder. Required by JassHelper
	BinaryReader common = hierarchy.open_file("scripts/common.j").value();
	std::ofstream output("data/tools/common.j");
	output.write(reinterpret_cast<char*>(common.buffer.data()), common.buffer.size());
	BinaryReader blizzard = hierarchy.open_file("scripts/blizzard.j").value();
	std::ofstream output2("data/tools/blizzard.j");
	output2.write(reinterpret_cast<char*>(blizzard.buffer.data()), blizzard.buffer.size());

	ui.setupUi(this);
	context = ui.widget;
	restore_window_state();

	world_edit_strings.load("UI/WorldEditStrings.txt");
	world_edit_game_strings.load("UI/WorldEditGameStrings.txt");
	world_edit_data.load("UI/WorldEditData.txt");

	world_edit_data.substitute(world_edit_game_strings, "WorldEditStrings");
	world_edit_data.substitute(world_edit_strings, "WorldEditStrings");

	connect(ui.ribbon->undo, &QPushButton::clicked, [&]() {
		// ToDo: temporary, undoing should still allow a selection to persist
		if (map->brush) {
			map->brush->clear_selection();
		}

		auto context = WorldEditContext {
			.terrain = map->terrain,
			.units = map->units,
			.doodads = map->doodads,
			.brush = map->brush,
			.pathing_map = map->pathing_map,
		};

		map->world_undo.undo(context);
	});
	connect(ui.ribbon->redo, &QPushButton::clicked, [&]() {
		// ToDo: temporary, undoing should still allow a selection to persist
		if (map->brush) {
			map->brush->clear_selection();
		}

		auto context = WorldEditContext {
			.terrain = map->terrain,
			.units = map->units,
			.doodads = map->doodads,
			.brush = map->brush,
			.pathing_map = map->pathing_map,
		};

		map->world_undo.redo(context);
	});

	connect(new QShortcut(Qt::CTRL | Qt::Key_Z, this), &QShortcut::activated, ui.ribbon->undo, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_Y, this), &QShortcut::activated, ui.ribbon->redo, &QPushButton::click);

	connect(ui.ribbon->units_visible, &QPushButton::toggled, [](bool checked) { map->render_units = checked; });
	connect(ui.ribbon->doodads_visible, &QPushButton::toggled, [](bool checked) { map->render_doodads = checked; });
	connect(ui.ribbon->pathing_visible, &QPushButton::toggled, [](bool checked) { map->render_pathing = checked; });
	connect(ui.ribbon->brush_visible, &QPushButton::toggled, [](bool checked) { map->render_brush = checked; });
	connect(ui.ribbon->lighting_visible, &QPushButton::toggled, [](bool checked) { map->render_lighting = checked; });
	connect(ui.ribbon->water_visible, &QPushButton::toggled, [](bool checked) { map->render_water = checked; });
	connect(ui.ribbon->click_helpers_visible, &QPushButton::toggled, [](bool checked) { map->render_click_helpers = checked; });
	connect(ui.ribbon->wireframe_visible, &QPushButton::toggled, [](bool checked) { map->render_wireframe = checked; });
	connect(ui.ribbon->debug_visible, &QPushButton::toggled, [](bool checked) { map->render_debug = checked; });
	connect(ui.ribbon->minimap_visible, &QPushButton::toggled, [&](bool checked) { (checked) ? minimap->show() : minimap->hide(); });

	connect(new QShortcut(Qt::CTRL | Qt::Key_U, this), &QShortcut::activated, ui.ribbon->units_visible, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_D, this), &QShortcut::activated, ui.ribbon->doodads_visible, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_P, this), &QShortcut::activated, ui.ribbon->pathing_visible, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_L, this), &QShortcut::activated, ui.ribbon->lighting_visible, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_W, this), &QShortcut::activated, ui.ribbon->water_visible, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_I, this), &QShortcut::activated, ui.ribbon->click_helpers_visible, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_T, this), &QShortcut::activated, ui.ribbon->wireframe_visible, &QPushButton::click);
	connect(new QShortcut(Qt::Key_F3, this), &QShortcut::activated, ui.ribbon->debug_visible, &QPushButton::click);

	// Reload theme
	connect(new QShortcut(Qt::Key_F5, this), &QShortcut::activated, [&]() {
		QSettings settings;
		QFile file("data/themes/" + settings.value("theme").toString() + ".qss");
		file.open(QFile::ReadOnly);
		QString StyleSheet = QLatin1String(file.readAll());

		qApp->setStyleSheet(StyleSheet);
	});

	connect(ui.ribbon->reset_camera, &QPushButton::clicked, [&]() { camera.reset(); });
	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::SHIFT | Qt::Key_C), this), &QShortcut::activated, ui.ribbon->reset_camera, &QPushButton::click);

	connect(ui.ribbon->import_heightmap, &QPushButton::clicked, this, &HiveWE::import_heightmap);

	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_O), this, nullptr, nullptr, Qt::ApplicationShortcut), &QShortcut::activated, ui.ribbon->open_map_folder, &QPushButton::click);
	// connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_I), this, nullptr, nullptr, Qt::ApplicationShortcut), &QShortcut::activated, ui.ribbon->open_map_mpq, &QPushButton::click);
	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_S), this, nullptr, nullptr, Qt::ApplicationShortcut), &QShortcut::activated, ui.ribbon->save_map, &QPushButton::click);
	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::SHIFT | Qt::Key_S), this, nullptr, nullptr, Qt::ApplicationShortcut), &QShortcut::activated, ui.ribbon->save_map_as, &QPushButton::click);

	// connect(ui.ribbon->new_map, &QAction::triggered, this, &HiveWE::load);
	connect(ui.ribbon->open_map_folder, &QPushButton::clicked, this, &HiveWE::load_folder);
	connect(ui.ribbon->open_map_mpq, &QPushButton::clicked, this, &HiveWE::load_mpq);
	connect(ui.ribbon->save_map, &QPushButton::clicked, this, &HiveWE::save);
	connect(ui.ribbon->save_map_as, &QPushButton::clicked, this, &HiveWE::save_as);
	connect(ui.ribbon->export_mpq, &QPushButton::clicked, this, &HiveWE::export_mpq);
	connect(ui.ribbon->test_map, &QPushButton::clicked, this, &HiveWE::play_test);
	connect(ui.ribbon->settings, &QPushButton::clicked, [&]() { new SettingsEditor(this); });
	connect(ui.ribbon->switch_warcraft, &QPushButton::clicked, this, &HiveWE::switch_warcraft);
	connect(ui.ribbon->exit, &QPushButton::clicked, [&]() { QApplication::exit(); });

	connect(ui.ribbon->change_tileset, &QRibbonButton::clicked, [this]() { new TileSetter(this); });
	connect(ui.ribbon->change_tile_pathing, &QRibbonButton::clicked, [this]() { new TilePather(this); });

	connect(ui.ribbon->map_description, &QRibbonButton::clicked, [&]() { (new MapInfoEditor(this))->ui.tabs->setCurrentIndex(0); });
	connect(ui.ribbon->map_loading_screen, &QRibbonButton::clicked, [&]() { (new MapInfoEditor(this))->ui.tabs->setCurrentIndex(1); });
	connect(ui.ribbon->map_options, &QRibbonButton::clicked, [&]() { (new MapInfoEditor(this))->ui.tabs->setCurrentIndex(2); });
	// connect(ui, &QAction::triggered, [&]() { (new MapInfoEditor(this))->ui.tabs->setCurrentIndex(3); });

	connect(new QShortcut(QKeySequence(Qt::Key_T), this, nullptr, nullptr, Qt::WindowShortcut), &QShortcut::activated, [&]() {
		open_palette<TerrainPalette>();
	});

	connect(ui.ribbon->terrain_palette, &QRibbonButton::clicked, [this]() {
		open_palette<TerrainPalette>();
	});

	connect(new QShortcut(QKeySequence(Qt::Key_D), this, nullptr, nullptr, Qt::WindowShortcut), &QShortcut::activated, [&]() {
		open_palette<DoodadPalette>();
	});
	connect(ui.ribbon->doodad_palette, &QRibbonButton::clicked, [this]() {
		open_palette<DoodadPalette>();
	});

	connect(new QShortcut(QKeySequence(Qt::Key_U), this, nullptr, nullptr, Qt::WindowShortcut), &QShortcut::activated, [&]() {
		open_palette<UnitPalette>();
	});

	connect(ui.ribbon->unit_palette, &QRibbonButton::clicked, [this]() {
		open_palette<UnitPalette>();
	});

	connect(new QShortcut(QKeySequence(Qt::Key_P), this, nullptr, nullptr, Qt::WindowShortcut), &QShortcut::activated, [&]() {
		ui.ribbon->pathing_visible->setChecked(true);
		open_palette<PathingPalette>();
	});

	connect(ui.ribbon->pathing_palette, &QRibbonButton::clicked, [this]() {
		ui.ribbon->pathing_visible->setChecked(true);
		open_palette<PathingPalette>();
	});

	setAutoFillBackground(true);

	connect(ui.ribbon->trigger_editor, &QRibbonButton::clicked, [this]() {
		bool created = false;
		auto editor = window_handler.create_or_raise<TriggerEditor>(nullptr, created);
		connect(this, &HiveWE::saving_initiated, editor, &TriggerEditor::save_changes, Qt::UniqueConnection);
	});

	connect(ui.ribbon->object_editor, &QRibbonButton::clicked, [this]() {
		bool created = false;
		window_handler.create_or_raise<ObjectEditor>(nullptr, created);
	});

	connect(ui.ribbon->model_editor, &QRibbonButton::clicked, [this]() {
		bool created = false;
		window_handler.create_or_raise<ModelEditor>(nullptr, created);
	});

	minimap->setParent(ui.widget);
	minimap->move(10, 10);
	minimap->show();

	connect(minimap, &Minimap::clicked, [](QPointF location) { camera.position = { location.x() * map->terrain.width, (1.0 - location.y()) * map->terrain.height, camera.position.z }; });
	ui.widget->makeCurrent();
	map = new Map();
	connect(&map->terrain, &Terrain::minimap_changed, minimap, &Minimap::set_minimap);

	ui.widget->makeCurrent();
	map->load("data/test map/");
	// map->load("C:/Users/User/Desktop/MCFC.w3x");
	map->render_manager.resize_framebuffers(ui.widget->width(), ui.widget->height());
}

void HiveWE::load_folder() {
	QSettings settings;

	QString folder_name = QFileDialog::getExistingDirectory(this, "Open Map Directory",
															settings.value("openDirectory", QDir::current().path()).toString(),
															QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);

	if (folder_name == "") {
		return;
	}

	settings.setValue("openDirectory", folder_name);

	fs::path directory = folder_name.toStdString();

	if (!fs::exists(directory / "war3map.w3i")) {
		QMessageBox::information(this, "Opening map failed", "Opening the map failed. Select a map that is saved in folder mode or use the Open Map (MPQ) option");
		return;
	}

	QMessageBox* loading_box = new QMessageBox(QMessageBox::Icon::Information, "Loading Map", "Loading " + QString::fromStdString(directory.filename().string()));
	loading_box->show();

	window_handler.close_all();
	ui.widget->makeCurrent();
	delete map;
	map = new Map();

	connect(&map->terrain, &Terrain::minimap_changed, minimap, &Minimap::set_minimap);

	map->load(directory);

	loading_box->close();
	delete loading_box;

	map->render_manager.resize_framebuffers(ui.widget->width(), ui.widget->height());
	setWindowTitle("HiveWE 0.10 - " + QString::fromStdString(map->filesystem_path.string()));
}

/// Load MPQ will extract all files from the archive in a user specified location
void HiveWE::load_mpq() {
	QSettings settings;

	// Choose an MPQ
	QString file_name = QFileDialog::getOpenFileName(this, "Open File",
													 settings.value("openDirectory", QDir::current().path()).toString(),
													 "Warcraft III Scenario (*.w3m *.w3x)");

	if (file_name.isEmpty()) {
		return;
	}

	settings.setValue("openDirectory", file_name);

	fs::path mpq_path = file_name.toStdWString();

	mpq::MPQ mpq;
	bool opened = mpq.open(mpq_path);
	if (!opened) {
		const auto message = std::format("Opening the map archive failed. It might be opened in another program.\nError Code {}", GetLastError());
		QMessageBox::critical(this, "Opening map failed", QString::fromStdString(message));
		return;
	}

	fs::path unpack_location = QFileDialog::getExistingDirectory(
								   this, "Choose Unpacking Location",
								   settings.value("openDirectory", QDir::current().path()).toString(),
								   QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks)
								   .toStdString();

	if (unpack_location.empty()) {
		return;
	}

	fs::path final_directory = unpack_location / mpq_path.stem();

	try {
		fs::create_directory(final_directory);
	} catch (std::filesystem::filesystem_error& e) {
		QMessageBox::critical(this, "Error creating directory", "Failed to create the directory to unpack into with error:\n" + QString::fromStdString(e.what()), QMessageBox::StandardButton::Ok, QMessageBox::StandardButton::Ok);
		return;
	}

	bool unpacked = mpq.unpack(final_directory);
	if (!unpacked) {
		QMessageBox::critical(this, "Unpacking failed", "There was an error unpacking the archive.");
		std::println("{}", GetLastError());
		return;
	}

	// Load map
	window_handler.close_all();
	delete map;
	map = new Map();

	connect(&map->terrain, &Terrain::minimap_changed, minimap, &Minimap::set_minimap);

	ui.widget->makeCurrent();
	map->load(final_directory);
	map->render_manager.resize_framebuffers(ui.widget->width(), ui.widget->height());
	setWindowTitle("HiveWE 0.10 - " + QString::fromStdString(map->filesystem_path.string()));
}

void HiveWE::save() {
	emit saving_initiated();
	map->save(map->filesystem_path);
};

void HiveWE::save_as() {
	QSettings settings;
	const QString directory = settings.value("openDirectory", QDir::current().path()).toString() + "/" + QString::fromStdString(map->name);

	fs::path file_name = QFileDialog::getExistingDirectory(this, "Choose Save Location",
														   settings.value("openDirectory", QDir::current().path()).toString(),
														   QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks)
							 .toStdString();

	if (file_name.empty()) {
		return;
	}

	emit saving_initiated();
	if (fs::exists(file_name) && fs::equivalent(file_name, map->filesystem_path)) {
		map->save(map->filesystem_path);
	} else {
		fs::create_directories(file_name / map->name);

		hierarchy.map_directory = file_name / map->name;
		map->save(file_name / map->name);
	}

	setWindowTitle("HiveWE 0.10 - " + QString::fromStdString(map->filesystem_path.string()));
}

void HiveWE::export_mpq() {
	QSettings settings;
	const QString directory = settings.value("openDirectory", QDir::current().path()).toString() + "/" + QString::fromStdString(map->filesystem_path.filename().string());
	std::wstring file_name = QFileDialog::getSaveFileName(this, "Export Map to MPQ", directory, "Warcraft III Scenario (*.w3x)").toStdWString();

	if (file_name.empty()) {
		return;
	}

	fs::remove(file_name);

	emit saving_initiated();
	map->save(map->filesystem_path);

	uint64_t file_count = std::distance(fs::recursive_directory_iterator{ map->filesystem_path }, {});

	HANDLE handle;
	bool open = SFileCreateArchive(file_name.c_str(), MPQ_CREATE_LISTFILE | MPQ_CREATE_ATTRIBUTES, file_count, &handle);
	if (!open) {
		QMessageBox::critical(this, "Exporting failed", "There was an error creating the archive.");
		std::println("{}", GetLastError());
		return;
	}

	for (const auto& entry : fs::recursive_directory_iterator(map->filesystem_path)) {
		if (entry.is_regular_file()) {
			bool success = SFileAddFileEx(handle, entry.path().c_str(), entry.path().lexically_relative(map->filesystem_path).string().c_str(), MPQ_FILE_COMPRESS, MPQ_COMPRESSION_ZLIB, MPQ_COMPRESSION_NEXT_SAME);
			if (!success) {
				std::println("Error {} adding file {}", GetLastError(), entry.path().string());
			}
		}
	}
	SFileCompactArchive(handle, nullptr, false);
	SFileCloseArchive(handle);
}

void HiveWE::play_test() {
	emit saving_initiated();
	if (!map->save(map->filesystem_path)) {
		return;
	}
	QProcess* warcraft = new QProcess;
	const QString warcraft_path = QString::fromStdString(fs::canonical(hierarchy.root_directory / "x86_64" / "Warcraft III.exe").string());
	QStringList arguments;
	arguments << "-launch"
			  << "-loadfile" << QString::fromStdString(fs::canonical(map->filesystem_path).string());

	QSettings settings;
	if (settings.value("testArgs").toString() != "")
		arguments << settings.value("testArgs").toString().split(' ');

	warcraft->start(warcraft_path, arguments);
}

void HiveWE::closeEvent(QCloseEvent* event) {
	int choice = QMessageBox::question(this, "Do you want to quit?", "Are you sure you want to quit?", QMessageBox::Yes | QMessageBox::No, QMessageBox::No);

	if (choice == QMessageBox::Yes) {
		QApplication::closeAllWindows();
		event->accept();
	} else {
		event->ignore();
	}
}

void HiveWE::resizeEvent(QResizeEvent* event) {
	QMainWindow::resizeEvent(event);
	QTimer::singleShot(0, [&] { save_window_state(); });
}

void HiveWE::moveEvent(QMoveEvent* event) {
	QMainWindow::moveEvent(event);
	QTimer::singleShot(0, [&] { save_window_state(); });
}

void HiveWE::switch_warcraft() {
	QSettings settings;
	fs::path directory;
	do {
		directory = QFileDialog::getExistingDirectory(this, "Select Warcraft Directory", "/home", QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks).toStdWString();
		if (directory == "") {
			directory = settings.value("warcraftDirectory").toString().toStdString();
		}
	} while (!hierarchy.open_casc(directory));

	if (directory != hierarchy.warcraft_directory) {
		settings.setValue("warcraftDirectory", QString::fromStdString(directory.string()));
	}
}

// ToDo move to terrain class?
void HiveWE::import_heightmap() {
	QMessageBox::information(this, "Heightmap information", "Will read the red channel and map this onto the range -16 to +16");
	QSettings settings;
	const QString directory = settings.value("openDirectory", QDir::current().path()).toString() + "/" + QString::fromStdString(map->filesystem_path.filename().string());

	QString file_name = QFileDialog::getOpenFileName(this, "Open Heightmap Image", directory);

	if (file_name == "") {
		return;
	}

	int width;
	int height;
	int channels;
	uint8_t* image_data = SOIL_load_image(file_name.toStdString().c_str(), &width, &height, &channels, SOIL_LOAD_AUTO);

	if (width != map->terrain.width || height != map->terrain.height) {
		QMessageBox::warning(this, "Incorrect Image Size", QString("Image Size: %1x%2 does not match terrain size: %3x%4").arg(QString::number(width), QString::number(height), QString::number(map->terrain.width), QString::number(map->terrain.height)));
		return;
	}

	for (int j = 0; j < height; j++) {
		for (int i = 0; i < width; i++) {
			map->terrain.corners[i][j].height = (image_data[((height - 1 - j) * width + i) * channels] - 128.f) / 8.f;
		}
	}

	map->terrain.update_ground_heights({ 0, 0, width, height });
	delete image_data;
}

void HiveWE::save_window_state() {
	QSettings settings;

	if (!isMaximized()) {
		settings.setValue("MainWindow/geometry", saveGeometry());
	}

	settings.setValue("MainWindow/maximized", isMaximized());
	settings.setValue("MainWindow/windowState", saveState());
}

void HiveWE::restore_window_state() {
	QSettings settings;

	if (settings.contains("MainWindow/windowState")) {
		restoreGeometry(settings.value("MainWindow/geometry").toByteArray());
		restoreState(settings.value("MainWindow/windowState").toByteArray());
		if (settings.value("MainWindow/maximized").toBool()) {
			showMaximized();
		} else {
			showNormal();
		}
	} else {
		showMaximized();
	}
}

void HiveWE::set_current_custom_tab(QRibbonTab* tab, QString name) {
	if (current_custom_tab == tab) {
		return;
	}

	if (current_custom_tab != nullptr) {
		emit palette_changed(tab);
	}

	remove_custom_tab();
	current_custom_tab = tab;
	ui.ribbon->addTab(tab, name);
	ui.ribbon->setCurrentIndex(ui.ribbon->count() - 1);
}

void HiveWE::remove_custom_tab() {
	for (int i = 0; i < ui.ribbon->count(); i++) {
		if (ui.ribbon->widget(i) == current_custom_tab) {
			ui.ribbon->removeTab(i);
			current_custom_tab = nullptr;
			return;
		}
	}
}
```

`src/main_window/hivewe.h`:

```h
#pragma once

#include <QMainWindow>
#include <QFileDialog>
#include <QSettings>
#include <QObject>
#include <QTimer>
#include <QGridLayout>
#include <QLabel>
#include <QMenu>
#include <QPainter>
#include <QKeyEvent>

#include "ui_HiveWE.h"
#include "global_search.h"

import QRibbon;
import WindowHandler;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;
import <glm/gtc/quaternion.hpp>;
import "palette.h";
import "minimap.h";

class HiveWE : public QMainWindow {
	Q_OBJECT

public:
	explicit HiveWE(QWidget* parent = nullptr);

	void load_folder();
	void load_mpq();
	void save();
	void save_as();
	void export_mpq();
	void play_test();

private:
	Ui::HiveWEClass ui;
	QRibbonTab* current_custom_tab = nullptr;
	Minimap* minimap = new Minimap(this);

	QElapsedTimer double_shift_timer;

	void keyPressEvent(QKeyEvent* event) override {
		if (event->key() == Qt::Key_Shift && !event->isAutoRepeat()) {
			if (double_shift_timer.isValid() && double_shift_timer.elapsed() < 400) {

				GlobalSearchWidget search_widget = new GlobalSearchWidget(this);
				double_shift_timer.invalidate();
			} else {
				double_shift_timer.start();
			}
		}
		QMainWindow::keyPressEvent(event);
	}

	void closeEvent(QCloseEvent* event) override;
	void resizeEvent(QResizeEvent* event) override;
	void moveEvent(QMoveEvent* event) override;

	void switch_warcraft();
	void import_heightmap();
	void save_window_state();
	void restore_window_state();

	/// Adds the tab to the ribbon and sets the current index to this tab
	void set_current_custom_tab(QRibbonTab* tab, QString name);
	void remove_custom_tab();

	template <typename T>
	void open_palette() {
		bool created = false;
		auto palette = window_handler.create_or_raise<T>(this, created);
		if (created) {
			palette->move(this->x() + this->width() - palette->width() - 10, this->y() + 160);
			connect(palette, &T::ribbon_tab_requested, this, &HiveWE::set_current_custom_tab);
			connect(this, &HiveWE::palette_changed, palette, &Palette::deactivate);
			connect(palette, &T::finished, [&]() {
				remove_custom_tab();
			});
		}
	}

signals:
	void tileset_changed();
	void palette_changed(QRibbonTab* tab);

	void saving_initiated();
};
```

`src/main_window/main_ribbon.cpp`:

```cpp
#include "main_ribbon.h"

MainRibbon::MainRibbon(QWidget* parent) : QRibbon(parent) {
	// Home
	QRibbonTab* home_tab = new QRibbonTab;

	// Undo/Redo History
	QRibbonSection* history_section = new QRibbonSection;
	history_section->setText("History");

	undo->setIcon(QIcon("data/icons/ribbon/undo32x32.png"));
	undo->setText("Undo");
	history_section->addWidget(undo);

	redo->setIcon(QIcon("data/icons/ribbon/redo32x32.png"));
	redo->setText("Redo");
	history_section->addWidget(redo);

	QRibbonSection* editor_section = new QRibbonSection;
	editor_section->setText("Editor/Viewer");

	trigger_editor->setIcon(QIcon("Data/Icons/Ribbon/triggereditor32x32.png"));
	trigger_editor->setText("Trigger\nEditor");
	editor_section->addWidget(trigger_editor);

	object_editor->setIcon(QIcon("data/icons/ribbon/objecteditor32x32.png"));
	object_editor->setText("Object\nEditor");
	editor_section->addWidget(object_editor);

	model_editor->setIcon(QIcon("data/icons/ribbon/model_editor.png"));
	model_editor->setText("Model\nEditor");
	editor_section->addWidget(model_editor);

	QRibbonSection* palette_section = new QRibbonSection;
	palette_section->setText("Palette");

	terrain_palette->setIcon(QIcon("data/icons/ribbon/heightmap32x32.png"));
	terrain_palette->setText("Terrain");
	palette_section->addWidget(terrain_palette);

	doodad_palette->setIcon(QIcon("data/icons/ribbon/doodads32x32.png"));
	doodad_palette->setText("Doodads");
	palette_section->addWidget(doodad_palette);

	unit_palette->setIcon(QIcon("data/icons/ribbon/units32x32.png"));
	unit_palette->setText("Units");
	palette_section->addWidget(unit_palette);

	pathing_palette->setIcon(QIcon("data/icons/ribbon/pathing32x32.png"));
	pathing_palette->setText("Pathing");
	palette_section->addWidget(pathing_palette);



	//view_history->setIcon(QIcon("data/icons/ribbon/description32x32.png"));
	//view_history->setText("View\nHistory");
	//view_history->setEnabled(false);
	//history_section->addWidget(view_history);

	/*copy->setIcon(QIcon("data/icons/ribbon/copy32x32.ico"));
	copy->setText("Copy");
	home_section->addWidget(copy);

	paste->setIcon(QIcon("data/icons/ribbon/paste32x32.ico"));
	paste->setText("Paste");
	home_section->addWidget(paste);

	QVBoxLayout* lay = new QVBoxLayout;
	QToolButton* but = new QToolButton;
	QToolButton* butt = new QToolButton;
	QToolButton* buttt = new QToolButton;

	but->setIcon(QIcon("data/icons/ribbon/paste32x32.ico"));
	but->setIconSize({ 16, 16 });
	but->setText("Cut");
	but->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);*/

	//lay->addWidget(but);
	//lay->addWidget(butt);
	//lay->addWidget(buttt);

	//history_section->addLayout(lay);
	home_tab->addSection(history_section);
	home_tab->addSection(editor_section);
	home_tab->addSection(palette_section);

	// View
	QRibbonTab* view_tab = new QRibbonTab;

	// Visible section
	QRibbonSection* visible_section = new QRibbonSection;
	visible_section->setText("Visible");
	view_tab->addSection(visible_section);
	
	units_visible->setIcon(QIcon("data/icons/ribbon/units32x32.png"));
	units_visible->setText("Units");
	units_visible->setCheckable(true);
	units_visible->setChecked(true);
	visible_section->addWidget(units_visible);

	doodads_visible->setIcon(QIcon("data/icons/ribbon/doodads32x32.png"));
	doodads_visible->setText("Doodads");
	doodads_visible->setCheckable(true);
	doodads_visible->setChecked(true);
	visible_section->addWidget(doodads_visible);

	pathing_visible->setIcon(QIcon("data/icons/ribbon/pathing32x32.png"));
	pathing_visible->setText("Pathing");
	pathing_visible->setCheckable(true);
	visible_section->addWidget(pathing_visible);
	
	brush_visible->setIcon(QIcon("data/icons/ribbon/brush32x32.png"));
	brush_visible->setText("Brush");
	brush_visible->setCheckable(true);
	brush_visible->setChecked(true);
	visible_section->addWidget(brush_visible);

	lighting_visible->setIcon(QIcon("data/icons/ribbon/lighting32x32.png"));
	lighting_visible->setText("Lighting");
	lighting_visible->setCheckable(true);
	lighting_visible->setChecked(true);
	visible_section->addWidget(lighting_visible);

	water_visible->setIcon(QIcon("data/icons/ribbon/water32x32.png"));
	water_visible->setText("Water");
	water_visible->setCheckable(true);
	water_visible->setChecked(true);
	visible_section->addWidget(water_visible);

	click_helpers_visible->setIcon(QIcon("data/icons/ribbon/click_helpers.png"));
	click_helpers_visible->setText("Click\nHelpers");
	click_helpers_visible->setCheckable(true);
	click_helpers_visible->setChecked(true);
	visible_section->addWidget(click_helpers_visible);

	wireframe_visible->setIcon(QIcon("data/icons/ribbon/wireframe32x32.png"));
	wireframe_visible->setText("Wireframe");
	wireframe_visible->setCheckable(true);
	visible_section->addWidget(wireframe_visible);

	debug_visible->setIcon(QIcon("data/icons/ribbon/debug32x32.png"));
	debug_visible->setText("Debug");
	debug_visible->setCheckable(true);
	visible_section->addWidget(debug_visible);

	minimap_visible->setIcon(QIcon("data/icons/ribbon/minimap32x32.png"));
	minimap_visible->setText("Minimap");
	minimap_visible->setCheckable(true);
	minimap_visible->setChecked(true);
	visible_section->addWidget(minimap_visible);
	// Camera section
	QRibbonSection* camera_section = new QRibbonSection;
	camera_section->setText("Camera");
	view_tab->addSection(camera_section);

	reset_camera->setIcon(QIcon("data/icons/ribbon/reset32x32.png"));
	reset_camera->setText("Reset");
	camera_section->addWidget(reset_camera);

	// Menu actions
	new_map->setText("New Map");
	new_map->setIcon(QIcon("data/icons/ribbon/new32x32.ico"));
	new_map->setIconSize({ 32, 32 });
	new_map->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	new_map->setDisabled(true);
	addMenuItem(new_map);

	open_map_folder->setText("Open Map (Folder)");
	open_map_folder->setIcon(QIcon("data/icons/ribbon/open32x32.png"));
	open_map_folder->setIconSize({ 32, 32 });
	open_map_folder->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(open_map_folder);

	open_map_mpq->setText("Open Map (MPQ)");
	open_map_mpq->setIcon(QIcon("data/icons/ribbon/open32x32.png"));
	open_map_mpq->setIconSize({ 32, 32 });
	open_map_mpq->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(open_map_mpq);

	save_map->setText("Save Map");
	save_map->setIcon(QIcon("data/icons/ribbon/save32x32.png"));
	save_map->setIconSize({ 32, 32 });
	save_map->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(save_map);

	save_map_as->setText("Save Map as");
	save_map_as->setIcon(QIcon("data/icons/ribbon/saveas32x32.png"));
	save_map_as->setIconSize({ 32, 32 });
	save_map_as->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(save_map_as);

	export_mpq->setText("Export MPQ");
	export_mpq->setIcon(QIcon("data/icons/ribbon/saveas32x32.png"));
	export_mpq->setIconSize({ 32, 32 });
	export_mpq->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(export_mpq);

	test_map->setText("Test Map");
	test_map->setIcon(QIcon("data/icons/ribbon/test32x32.ico"));
	test_map->setIconSize({ 32, 32 });
	test_map->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(test_map);

	settings->setText("Settings");
	settings->setIcon(QIcon("data/icons/ribbon/options32x32.png"));
	settings->setIconSize({ 32, 32 });
	settings->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(settings);

	addMenuSeperator();

	exit->setText("Exit");
	exit->setIcon(QIcon("data/icons/ribbon/exit32x32.ico"));
	exit->setIconSize({ 32, 32 });
	exit->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(exit);

	// Map tab
	QRibbonTab* map_tab = new QRibbonTab;

	QRibbonSection* map_section = new QRibbonSection;

	map_description->setIcon(QIcon("data/icons/ribbon/description32x32.png"));
	map_description->setText("Description");
	map_section->addWidget(map_description);

	map_loading_screen->setIcon(QIcon("data/icons/ribbon/loading32x32.png"));
	map_loading_screen->setText("Loading\nScreen");
	map_section->addWidget(map_loading_screen);

	map_options->setIcon(QIcon("data/icons/ribbon/options32x32.png"));
	map_options->setText("Options");
	map_section->addWidget(map_options);

	//map_size_camera_bounds->setIcon(QIcon("data/icons/ribbon/sizebounds32x32.png"));
	//map_size_camera_bounds->setText("Size&&Camera\nBounds");
	//map_section->addWidget(map_size_camera_bounds);

	map_tab->addSection(map_section);

	// Tools tab
	QRibbonTab* tools_tab = new QRibbonTab;

	// Import
	QRibbonSection* import_section = new QRibbonSection;
	import_section->setText("Import");

	import_heightmap->setIcon(QIcon("data/icons/ribbon/heightmap32x32.png"));
	import_heightmap->setText("Import\nHeightmap");
	import_section->addWidget(import_heightmap);

	tools_tab->addSection(import_section);

	// Tileset
	QRibbonSection* tileset_section = new QRibbonSection;
	tileset_section->setText("Tileset");

	change_tileset->setIcon(QIcon("data/icons/ribbon/tileset.png"));
	change_tileset->setText("Change\nTileset");
	tileset_section->addWidget(change_tileset);

	change_tile_pathing->setIcon(QIcon("data/icons/ribbon/tileset32x32.png"));
	change_tile_pathing->setText("Change Tile\nPathing");
	tileset_section->addWidget(change_tile_pathing);

	tools_tab->addSection(tileset_section);

	QRibbonSection* game_section = new QRibbonSection;
	game_section->setText("Game");

	switch_warcraft->setIcon(QIcon("data/icons/ribbon/WarIII32x32.ico"));
	switch_warcraft->setText("Change\n Game folder");
	game_section->addWidget(switch_warcraft);

	tools_tab->addSection(game_section);

	addTab(home_tab, "Home");
	addTab(view_tab, "View");
	addTab(map_tab, "Map");
	addTab(tools_tab, "Tools");

}

MainRibbon::~MainRibbon() {
}
```

`src/main_window/main_ribbon.h`:

```h
#pragma once

import QRibbon;

#include <QObject>
#include <QToolButton>

class MainRibbon : public QRibbon {
	Q_OBJECT

public:
	QRibbonButton* undo = new QRibbonButton;
	QRibbonButton* redo = new QRibbonButton;
	QRibbonButton* view_history = new QRibbonButton;


	QRibbonButton* copy = new QRibbonButton;
	QRibbonButton* paste = new QRibbonButton;

	QRibbonButton* units_visible = new QRibbonButton;
	QRibbonButton* doodads_visible = new QRibbonButton;
	QRibbonButton* pathing_visible = new QRibbonButton;
	QRibbonButton* brush_visible = new QRibbonButton;
	QRibbonButton* lighting_visible = new QRibbonButton;
	QRibbonButton* water_visible = new QRibbonButton;
	QRibbonButton* click_helpers_visible = new QRibbonButton;
	QRibbonButton* wireframe_visible = new QRibbonButton;
	QRibbonButton* debug_visible = new QRibbonButton;
	QRibbonButton* minimap_visible = new QRibbonButton;

	QRibbonButton* reset_camera = new QRibbonButton;

	QRibbonButton* map_description = new QRibbonButton;
	QRibbonButton* map_loading_screen = new QRibbonButton;
	QRibbonButton* map_options = new QRibbonButton;
	QRibbonButton* map_size_camera_bounds = new QRibbonButton;

	QRibbonButton* import_heightmap = new QRibbonButton;
	QRibbonButton* change_tileset = new QRibbonButton;
	QRibbonButton* change_tile_pathing = new QRibbonButton;
	QRibbonButton* switch_warcraft = new QRibbonButton;

	QRibbonButton* trigger_editor = new QRibbonButton;
	QRibbonButton* object_editor = new QRibbonButton;
	QRibbonButton* model_editor = new QRibbonButton;

	QRibbonButton* terrain_palette = new QRibbonButton;
	QRibbonButton* doodad_palette = new QRibbonButton;
	QRibbonButton* unit_palette = new QRibbonButton;
	QRibbonButton* pathing_palette = new QRibbonButton;

	QToolButton* new_map = new QToolButton;
	QToolButton* open_map_mpq = new QToolButton;
	QToolButton* open_map_folder = new QToolButton;

	QToolButton* save_map = new QToolButton;
	QToolButton* save_map_as = new QToolButton;
	QToolButton* export_mpq = new QToolButton;

	QToolButton* test_map = new QToolButton;
	QToolButton* settings = new QToolButton;
	QToolButton* exit = new QToolButton;

	MainRibbon(QWidget* parent);
	~MainRibbon();
};

```

`src/map_global.ixx`:

```ixx
export module MapGlobal;

import Map;

export inline Map* map = nullptr;
```

`src/menus/doodad_palette.cpp`:

```cpp
#include "doodad_palette.h"

#include <QRadioButton>
#include <QCheckBox>
#include <QFormLayout>
#include <QDoubleValidator>
#include <QComboBox>
#include <QListView>
#include <QToolButton>
#include <QShortcut>
#include <QFileDialog>
#include <QSettings>
#include <QFrame>
#include <QGridLayout>
#include <QBoxLayout>
#include <QLabel>
#include <QMenu>
#include <QTabWidget>
#include <QStyle>
#include <QStyleOption>
#include <QPainter>
#include <QMap>
#include <QScrollArea>
#include <QPushButton>
#include <QKeySequence>
#include <QTimer>

#include "brush.h"

#include <object_editor/object_editor.h>

#include <QDesktopServices>
#include <QStandardPaths>
#include <qurl.h>

import std;
import TableModel;
import QRibbon;
import Doodad;
import MapGlobal;
import Globals;
import WindowHandler;
import SLK;
import MDX;
import BinaryWriter;
import BinaryReader;
import Hierarchy;

namespace fs = std::filesystem;

DoodadPalette::DoodadPalette(QWidget* parent) : Palette(parent) {
	ui.setupUi(this);
	setAttribute(Qt::WA_DeleteOnClose);
	show();

	map->brush = &brush;

	ui.tileset->addItem("All Tilesets", '*');
	for (auto&& [key, value] : world_edit_data.section("TileSets")) {
		ui.tileset->addItem(QString::fromStdString(value.front()), key.front());
	}

	for (auto&& [key, value] : world_edit_data.section("DoodadCategories")) {
		ui.type->addItem(QString::fromStdString(value.front()), QString::fromStdString(key));
	}

	for (auto&& [key, value] : world_edit_data.section("DestructibleCategories")) {
		ui.type->addItem(QString::fromStdString(value.front()), QString::fromStdString(key));
	}

	doodad_list_model = new DoodadListModel(this);
	doodad_list_model->setSourceModel(doodads_table);

	destructable_list_model = new DestructableListModel(this);
	destructable_list_model->setSourceModel(destructibles_table);

	doodad_filter_model = new DoodadListFilter(this);
	doodad_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	doodad_filter_model->setSourceModel(doodad_list_model);
	doodad_filter_model->sort(0, Qt::AscendingOrder);
	doodad_filter_model->setFilterTileset('*');

	destructable_filter_model = new DestructableListFilter(this);
	destructable_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	destructable_filter_model->setSourceModel(destructable_list_model);
	destructable_filter_model->sort(0, Qt::AscendingOrder);
	destructable_filter_model->setFilterTileset('*');

	concat_table = new QConcatenateTablesProxyModel(this);
	concat_table->addSourceModel(destructable_filter_model);
	concat_table->addSourceModel(doodad_filter_model);

	ui.doodads->setModel(concat_table);

	QRibbonSection* selection_section = new QRibbonSection;
	selection_section->setText("Selection");

	selection_mode->setText("Selection\nMode");
	selection_mode->setIcon(QIcon("data/icons/ribbon/select32x32.png"));
	selection_mode->setCheckable(true);
	selection_section->addWidget(selection_mode);

	// selections_button->setText("View\nSelections");
	// selections_button->setIcon(QIcon("data/icons/ribbon/description32x32.png.png"));
	// selection_section->addWidget(selections_button);

	// QVBoxLayout* selection_choices_layout = new QVBoxLayout;
	// QCheckBox* select_destructibles = new QCheckBox("Destructibles");
	// select_destructibles->setChecked(true);
	// QCheckBox* select_doodads = new QCheckBox("Doodads");
	// select_doodads->setChecked(true);

	// selection_choices_layout->addWidget(select_destructibles);
	// selection_choices_layout->addWidget(select_doodads);

	// selection_section->addLayout(selection_choices_layout);

	find_this = new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), this, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);
	find_parent = new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), parent, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);

	change_mode_this = new QShortcut(Qt::Key_Space, this, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);
	change_mode_parent = new QShortcut(Qt::Key_Space, parent, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);

	QRibbonSection* placement_section = new QRibbonSection;
	placement_section->setText("Placement");

	QRibbonButton* random_rotation = new QRibbonButton;
	random_rotation->setText("Random\nRotation");
	random_rotation->setToolTip("Placed doodads will get a random rotation as long as their properties allow it");
	random_rotation->setIcon(QIcon("data/icons/ribbon/reset32x32.png"));
	random_rotation->setCheckable(true);
	random_rotation->setChecked(true);
	placement_section->addWidget(random_rotation);

	QRibbonButton* random_scale = new QRibbonButton;
	random_scale->setText("Random\nScale");
	random_scale->setToolTip("Placed doodads will get a random scale each time between their minScale and maxScale");
	random_scale->setIcon(QIcon("data/icons/ribbon/scale32x32.png"));
	random_scale->setCheckable(true);
	random_scale->setChecked(true);
	placement_section->addWidget(random_scale);

	QRibbonButton* lock_height = new QRibbonButton;
	lock_height->setText("Lock\nHeight");
	lock_height->setToolTip("Locks the absolute height of selected doodads when moved");
	lock_height->setIcon(QIcon("data/icons/ribbon/lock.png"));
	lock_height->setCheckable(true);
	placement_section->addWidget(lock_height);

	QRibbonSection* variation_section = new QRibbonSection;
	variation_section->setText("Variations");

	QRibbonButton* random_variation = new QRibbonButton;
	random_variation->setText("Random\nVariation");
	random_variation->setToolTip("Placed doodads will get a random variation. You can control which ones on the right ->");
	random_variation->setIcon(QIcon("data/icons/ribbon/variation32x32.png"));
	random_variation->setCheckable(true);
	random_variation->setChecked(true);
	variation_section->addWidget(random_variation);
	variation_section->addWidget(variations);

	QRibbonSection* flags_section = new QRibbonSection;
	flags_section->setText("Flags");

	QVBoxLayout* visibility_flags_layout = new QVBoxLayout;

	QRadioButton* invisible_non_solid = new QRadioButton;
	invisible_non_solid->setText("Invisible non solid");
	invisible_non_solid->setToolTip("Invisible and can units walk through");

	QRadioButton* visible_non_solid = new QRadioButton;
	visible_non_solid->setText("Visible non solid");
	visible_non_solid->setToolTip("Visible but units can walk through");

	QRadioButton* visible_solid = new QRadioButton;
	visible_solid->setText("Visible solid");
	visible_solid->setToolTip("Visible and units cannot walk through");
	visible_solid->setChecked(true);

	visibility_flags_layout->addWidget(invisible_non_solid);
	visibility_flags_layout->addWidget(visible_non_solid);
	visibility_flags_layout->addWidget(visible_solid);

	visibility_flags_layout->setSpacing(6);
	flags_section->addLayout(visibility_flags_layout);

	current_selection_section = new QRibbonSection;
	current_selection_section->setText("Current Selection");
	current_selection_section->setEnabled(false);

	QFormLayout* scaling_layout = new QFormLayout;
	scaling_layout->setSpacing(1);
	scaling_layout->setHorizontalSpacing(5);

	scaling_layout->addRow("x scale:", x_scale);
	scaling_layout->addRow("y scale:", y_scale);
	scaling_layout->addRow("z scale:", z_scale);

	QVBoxLayout* rotation_layout = new QVBoxLayout;

	QRibbonButton* degrees0 = new QRibbonButton;
	QRibbonButton* degrees90 = new QRibbonButton;
	QRibbonButton* degrees180 = new QRibbonButton;
	QRibbonButton* degrees270 = new QRibbonButton;

	degrees0->setSizePolicy(QSizePolicy::Policy::Expanding, QSizePolicy::Policy::Expanding);
	degrees90->setSizePolicy(QSizePolicy::Policy::Expanding, QSizePolicy::Policy::Expanding);
	degrees180->setSizePolicy(QSizePolicy::Policy::Expanding, QSizePolicy::Policy::Expanding);
	degrees270->setSizePolicy(QSizePolicy::Policy::Expanding, QSizePolicy::Policy::Expanding);

	degrees0->setText("0");
	degrees90->setText("90");
	degrees180->setText("180");
	degrees270->setText("270");

	QGridLayout* degrees_layout = new QGridLayout;
	degrees_layout->addWidget(degrees0, 0, 0);
	degrees_layout->addWidget(degrees90, 1, 0);
	degrees_layout->addWidget(degrees180, 0, 1);
	degrees_layout->addWidget(degrees270, 1, 1);

	QHBoxLayout* rotation_sub = new QHBoxLayout;
	rotation_sub->addWidget(new QLabel("Angle:"));
	rotation_sub->addSpacing(5);
	rotation_sub->addWidget(rotation);
	rotation_layout->addLayout(rotation_sub);
	rotation_layout->addLayout(degrees_layout);

	QRibbonButton* average_z = new QRibbonButton;
	average_z->setText("Group\nHeight  ");
	average_z->setIcon(QIcon("data/icons/ribbon/height.png"));
	average_z->addAction(group_height_minimum);
	average_z->addAction(group_height_average);
	average_z->addAction(group_height_maximum);
	average_z->setPopupMode(QToolButton::ToolButtonPopupMode::InstantPopup);

	QFormLayout* height_layout = new QFormLayout;
	height_layout->setSpacing(1);
	height_layout->setHorizontalSpacing(5);

	height_layout->addRow("Absolute Height:", absolute_height);
	height_layout->addRow("Relative Height:", relative_height);

	QSmallRibbonButton* edit_in_oe = new QSmallRibbonButton;
	edit_in_oe->setText("Edit in OE");
	edit_in_oe->setIcon(QIcon("data/icons/ribbon/objecteditor32x32.png"));

	QSmallRibbonButton* select_in_palette = new QSmallRibbonButton;
	select_in_palette->setText("Select in Palette");
	select_in_palette->setToolTip("Or click the doodad with middle mouse button");
	select_in_palette->setIcon(QIcon("data/icons/ribbon/doodads32x32.png"));

	QVBoxLayout* info_layout = new QVBoxLayout;
	info_layout->addWidget(selection_name);
	info_layout->addWidget(edit_in_oe);
	info_layout->addWidget(select_in_palette);

	QSmallRibbonButton* merge_selection = new QSmallRibbonButton;
	merge_selection->setText("Merge MDXs");
	merge_selection->setToolTip("Will merge all the selected doodad/destructables into a single MDX");
	merge_selection->setIcon(QIcon("data/icons/doodad_palette/merge.png"));

	current_selection_section->addLayout(scaling_layout);
	current_selection_section->addSpacing(5);
	current_selection_section->addLayout(rotation_layout);
	current_selection_section->addSpacing(5);
	current_selection_section->addLayout(height_layout);
	current_selection_section->addWidget(average_z);
	current_selection_section->addSpacing(5);
	current_selection_section->addLayout(info_layout);
	current_selection_section->addSpacing(5);
	current_selection_section->addWidget(merge_selection);

	ribbon_tab->addSection(selection_section);
	ribbon_tab->addSection(placement_section);
	ribbon_tab->addSection(variation_section);
	ribbon_tab->addSection(flags_section);
	ribbon_tab->addSection(current_selection_section);

	connect(selection_mode, &QRibbonButton::toggled, [&]() {
		brush.switch_mode();
	});
	connect(random_rotation, &QRibbonButton::toggled, [&](bool checked) {
		brush.random_rotation = checked;
	});
	connect(random_scale, &QRibbonButton::toggled, [&](bool checked) {
		brush.random_scale = checked;
	});
	connect(random_variation, &QRibbonButton::toggled, [&](bool checked) {
		brush.random_variation = checked;
	});
	connect(lock_height, &QRibbonButton::toggled, [&](bool checked) {
		brush.lock_doodad_z = checked;
	});

	connect(invisible_non_solid, &QRadioButton::clicked, [&]() {
		brush.state = Doodad::State::invisible_non_solid;
	});
	connect(visible_non_solid, &QRadioButton::clicked, [&]() {
		brush.state = Doodad::State::visible_non_solid;
	});
	connect(visible_solid, &QRadioButton::clicked, [&]() {
		brush.state = Doodad::State::visible_solid;
	});

	connect(ui.type, QOverload<int>::of(&QComboBox::currentIndexChanged), [&](int index) {
		// Possible Qt bug. Try swapping the two lines below and see if it crashes when selecting a tree and then swapping to a doodad category
		destructable_filter_model->setFilterCategory(ui.type->currentData().toString());
		doodad_filter_model->setFilterCategory(ui.type->currentData().toString());
	});

	connect(ui.tileset, QOverload<int>::of(&QComboBox::currentIndexChanged), [&](int index) {
		destructable_filter_model->setFilterTileset(ui.tileset->currentData().toChar().toLatin1());
		doodad_filter_model->setFilterTileset(ui.tileset->currentData().toChar().toLatin1());
	});

	connect(find_this, &QShortcut::activated, [&]() {
		ui.search->activateWindow();
		ui.search->setFocus();
		ui.search->selectAll();
	});

	connect(find_parent, &QShortcut::activated, [&]() {
		ui.search->activateWindow();
		ui.search->setFocus();
		ui.search->selectAll();
	});

	connect(change_mode_this, &QShortcut::activated, [&]() {
		selection_mode->click();
	});

	connect(change_mode_parent, &QShortcut::activated, [&]() {
		selection_mode->click();
	});

	connect(ui.search, &QLineEdit::textEdited, doodad_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(ui.search, &QLineEdit::textEdited, destructable_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(ui.search, &QLineEdit::returnPressed, [&]() {
		ui.doodads->setCurrentIndex(ui.doodads->model()->index(0, 0));
		selection_changed(ui.doodads->model()->index(0, 0));
		ui.doodads->setFocus();
	});

	connect(ui.doodads, &QListView::clicked, this, &DoodadPalette::selection_changed);
	connect(ui.doodads, &QListView::activated, this, &DoodadPalette::selection_changed);

	connect(&brush, &DoodadBrush::selection_changed, this, &DoodadPalette::update_selection_info);
	connect(&brush, &DoodadBrush::angle_changed, this, &DoodadPalette::update_selection_info);
	connect(&brush, &DoodadBrush::scale_changed, this, &DoodadPalette::update_selection_info);
	connect(&brush, &DoodadBrush::position_changed, this, &DoodadPalette::update_selection_info);
	connect(&brush, &DoodadBrush::request_doodad_select, this, &DoodadPalette::select_id_in_palette);

	connect(x_scale, &QLineEdit::textEdited, [&](const QString& text) {
		update_scale_change(0, text);
	});
	connect(y_scale, &QLineEdit::textEdited, [&](const QString& text) {
		update_scale_change(1, text);
	});
	connect(z_scale, &QLineEdit::textEdited, [&](const QString& text) {
		update_scale_change(2, text);
	});
	connect(x_scale, &QLineEdit::editingFinished, [&]() {
		update_scale_finish(0);
	});
	connect(y_scale, &QLineEdit::editingFinished, [&]() {
		update_scale_finish(1);
	});
	connect(z_scale, &QLineEdit::editingFinished, [&]() {
		update_scale_finish(2);
	});

	connect(rotation, &QLineEdit::textEdited, this, &DoodadPalette::update_rotation_change);
	connect(absolute_height, &QLineEdit::textEdited, this, &DoodadPalette::update_absolute_change);
	connect(relative_height, &QLineEdit::textEdited, this, &DoodadPalette::update_relative_change);

	connect(degrees0, &QRibbonButton::clicked, [&]() {
		set_selection_rotation(0.f);
	});
	connect(degrees90, &QRibbonButton::clicked, [&]() {
		set_selection_rotation(90.f);
	});
	connect(degrees180, &QRibbonButton::clicked, [&]() {
		set_selection_rotation(180.f);
	});
	connect(degrees270, &QRibbonButton::clicked, [&]() {
		set_selection_rotation(270.f);
	});

	connect(group_height_minimum, &QAction::triggered, this, &DoodadPalette::set_group_height_minimum);
	connect(group_height_average, &QAction::triggered, this, &DoodadPalette::set_group_height_average);
	connect(group_height_maximum, &QAction::triggered, this, &DoodadPalette::set_group_height_maximum);

	connect(edit_in_oe, &QSmallRibbonButton::clicked, [&]() {
		bool created;
		auto editor = window_handler.create_or_raise<ObjectEditor>(nullptr, created);
		const Doodad* doodad = *brush.selections.begin();
		if (destructibles_slk.row_headers.contains(doodad->id)) {
			editor->select_id(ObjectEditor::Category::destructible, doodad->id);
		} else {
			editor->select_id(ObjectEditor::Category::doodad, doodad->id);
		}
	});

	connect(select_in_palette, &QSmallRibbonButton::clicked, [&]() {
		const Doodad* doodad = *brush.selections.begin();
		select_id_in_palette(doodad->id);
	});

	connect(merge_selection, &QSmallRibbonButton::clicked, [&]() {
		if (brush.selections.empty()) {
			return;
		}

		QSettings settings;

		const fs::path file_name = QFileDialog::getSaveFileName(
									   this,
									   "Choose Save Location",
									   settings.value("openDirectory").toString(),
									   "Warcraft III Model (*.mdx)"
		)
									   .toStdString();

		if (file_name.empty()) {
			return;
		}

		mdx::MDX base;

		glm::vec3 midpoint = glm::vec3(0.f);
		for (const auto& doodad : brush.selections) {
			midpoint += doodad->position;
		}
		midpoint /= brush.selections.size();

		for (const auto& doodad : brush.selections) {
			const glm::mat4 centered = glm::translate(glm::mat4(1.0f), -midpoint) * doodad->skeleton.matrix;
			const glm::mat4 final = glm::scale(glm::mat4(1.0f), glm::vec3(128.0f)) * centered;
			base.merge_with(*doodad->mesh->mdx, final);
		}
		base.deduplicate_textures().deduplicate_materials().deduplicate_geosets().calculate_extents();

		auto writer = base.save();
		std::ofstream outfile(file_name, std::ios::binary | std::ios::out);

		if (!outfile) {
			throw std::runtime_error("Error writing merged file ");
		}

		outfile.write(reinterpret_cast<char const*>(writer.buffer.data()), writer.buffer.size());
	});

	// Default to Trees/Destructibles
	ui.type->setCurrentIndex(ui.type->count() - 3);
	ui.tileset->setCurrentIndex(0);

	ui.search->setFocus();
	ui.search->selectAll();
	ui.search->setClearButtonEnabled(true);

	ui.doodads->setCurrentIndex(ui.doodads->model()->index(0, 0));
	selection_changed(ui.doodads->model()->index(0, 0));
}

DoodadPalette::~DoodadPalette() {
	map->brush = nullptr;
	delete change_mode_parent;
	delete change_mode_this;
}

bool DoodadPalette::event(QEvent* e) {
	if (e->type() == QEvent::Close) {
		// Remove shortcut from parent
		find_this->setEnabled(false);
		find_parent->setEnabled(false);
		change_mode_this->setEnabled(false);
		change_mode_parent->setEnabled(false);
		ribbon_tab->setParent(nullptr);
		delete ribbon_tab;
	} else if (e->type() == QEvent::WindowActivate) {
		find_this->setEnabled(true);
		find_parent->setEnabled(true);
		change_mode_this->setEnabled(true);
		change_mode_parent->setEnabled(true);
		map->brush = &brush;
		emit ribbon_tab_requested(ribbon_tab, "Doodad Palette");
	}

	return QWidget::event(e);
}

void DoodadPalette::selection_changed(const QModelIndex& index) {
	std::string id;

	const auto model = concat_table->mapToSource(index).model();
	if (model == destructable_filter_model) {
		const int row = destructable_filter_model->mapToSource(concat_table->mapToSource(index)).row();
		id = destructibles_slk.index_to_row.at(row);
	} else if (model == doodad_filter_model) {
		const int row = doodad_filter_model->mapToSource(concat_table->mapToSource(index)).row();
		id = doodads_slk.index_to_row.at(row);
	}

	brush.set_doodad(id);
	selection_mode->setChecked(false);

	bool is_doodad = doodads_slk.row_headers.contains(id);
	slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;

	variations->clear();

	int variation_count = slk.data<int>("numvar", id);
	for (int i = 0; i < variation_count; i++) {
		QRibbonButton* toggle = new QRibbonButton;
		toggle->setCheckable(true);
		toggle->setChecked(true);
		toggle->setText(QString::number(i));
		variations->addWidget(toggle, i % 3, i / 3);
		connect(toggle, &QRibbonButton::toggled, [&](bool checked) {
			if (checked) {
				brush.add_variation(i);
			} else {
				brush.erase_variation(i);
			}
		});
	}
}

void DoodadPalette::select_id_in_palette(std::string id) {
	ui.search->clear();

	if (destructibles_slk.row_headers.contains(id)) {
		const auto category = destructibles_slk.data<std::string_view>("category", id);
		ui.type->setCurrentIndex(ui.type->findData(QString::fromUtf8(category)));
		const auto index =
			destructable_filter_model->mapFromSource(destructable_list_model->mapFromSource(destructibles_table->rowIDToIndex(id)));
		const auto finally = concat_table->mapFromSource(index);
		ui.doodads->setCurrentIndex(finally);
		selection_changed(finally);
	} else {
		const auto category = doodads_slk.data<std::string_view>("category", id);
		ui.type->setCurrentIndex(ui.type->findData(QString::fromUtf8(category)));
		const auto index = doodad_filter_model->mapFromSource(doodad_list_model->mapFromSource(doodads_table->rowIDToIndex(id)));
		const auto finally = concat_table->mapFromSource(index);
		ui.doodads->setCurrentIndex(finally);
		selection_changed(finally);
	}
}

void DoodadPalette::deactivate(QRibbonTab* tab) {
	if (tab != ribbon_tab) {
		brush.clear_selection();
		selection_mode->disableShortcuts();
		find_this->setEnabled(false);
		find_parent->setEnabled(false);
		change_mode_this->setEnabled(false);
		change_mode_parent->setEnabled(false);
	}
}

QString toString(const float num) {
	QString str = QString::number(num, 'f', 3);
	str.remove(QRegularExpression("\\.?0+$"));
	return str;
}

void DoodadPalette::update_selection_info() {
	if (brush.selections.empty()) {
		if (current_selection_section->isEnabled()) {
			current_selection_section->setEnabled(false);
		}
		selection_name->setText("");
	} else {
		if (!current_selection_section->isEnabled()) {
			current_selection_section->setEnabled(true);
		}
		const Doodad& doodad = **brush.selections.begin();

		const float first_relative_height =
			doodad.position.z - map->terrain.interpolated_height(doodad.position.x, doodad.position.y, true);
		bool same_object = true;
		bool same_x = true;
		bool same_y = true;
		bool same_z = true;
		bool same_angle = true;
		bool same_absolute_height = true;
		bool same_relative_height = true;
		for (const auto& i : brush.selections) {
			const float other_relative_height = i->position.z - map->terrain.interpolated_height(i->position.x, i->position.y, true);

			same_object = same_object && i->id == doodad.id;
			same_x = same_x && i->scale.x == doodad.scale.x;
			same_y = same_y && i->scale.y == doodad.scale.y;
			same_z = same_z && i->scale.z == doodad.scale.z;
			same_angle = same_angle && i->angle == doodad.angle;
			same_absolute_height = same_absolute_height && std::abs(i->position.z - doodad.position.z) < 0.001f;
			same_relative_height = same_relative_height && std::abs(other_relative_height - first_relative_height) < 0.001f;
		}

		x_scale->setText(same_x ? QString::number(doodad.scale.x) : "Various");
		y_scale->setText(same_y ? QString::number(doodad.scale.y) : "Various");
		z_scale->setText(same_z ? QString::number(doodad.scale.z) : "Various");

		if (same_angle) {
			const auto text = rotation->text();
			if (text.isEmpty() || text == "Various" || text.toFloat() != glm::degrees(doodad.angle)) {
				rotation->setText(toString(glm::degrees(doodad.angle)));
			}
		} else {
			rotation->setText("Various");
		}

		if (same_absolute_height) {
			const auto text = absolute_height->text();
			if (text.isEmpty() || text == "Various" || text.toFloat() != doodad.position.z) {
				absolute_height->setText(toString(doodad.position.z));
			}
		} else {
			absolute_height->setText("Various");
		}

		if (same_relative_height) {
			const auto text = relative_height->text();
			if (text.isEmpty() || text == "Various" || text.toFloat() != first_relative_height) {
				relative_height->setText(toString(first_relative_height));
			}
		} else {
			relative_height->setText("Various");
		}

		// Set the name
		if (same_object) {
			if (doodads_slk.row_headers.contains(doodad.id)) {
				const auto name = doodads_table->data(doodad.id, "name").toString();
				selection_name->setText(name);
			} else {
				const auto name = destructibles_table->data(doodad.id, "name").toString();
				selection_name->setText(name);
			}
		} else {
			selection_name->setText("Various");
		}
	}
}

void DoodadPalette::update_scale_change(int component, const QString& text) {
	brush.set_selection_scale_component(component, text.toFloat());
}

void DoodadPalette::update_scale_finish(int component) {
	update_selection_info();
}

void DoodadPalette::update_rotation_change(const QString& text) {
	brush.set_selection_angle(glm::radians(text.toFloat()));
	update_selection_info();
}

void DoodadPalette::update_absolute_change(const QString& text) {
	brush.set_selection_absolute_height(text.toFloat());
	update_selection_info();
}

void DoodadPalette::update_relative_change(const QString& text) {
	brush.set_selection_relative_height(text.toFloat());
	update_selection_info();
}

void DoodadPalette::set_group_height_minimum() {
	float minimum = std::numeric_limits<float>::max();
	for (auto& i : brush.selections) {
		minimum = std::min(minimum, i->position.z);
	}

	brush.set_selection_absolute_height(minimum);
}

void DoodadPalette::set_group_height_average() {
	float average = 0.f;
	for (auto& i : brush.selections) {
		average += i->position.z;
	}
	brush.set_selection_absolute_height(average / brush.selections.size());
}

void DoodadPalette::set_group_height_maximum() {
	float maximum = std::numeric_limits<float>::min();
	for (auto& i : brush.selections) {
		maximum = std::max(maximum, i->position.z);
	}

	brush.set_selection_absolute_height(maximum);
}

// new_rotation in degrees
void DoodadPalette::set_selection_rotation(float new_rotation) {
	brush.set_selection_angle(glm::radians(new_rotation));
	update_selection_info();
}

```

`src/menus/doodad_palette.h`:

```h
#pragma once

#include "ui_doodad_palette.h"

#include <QLineEdit>
#include <QRadioButton>
#include <QCheckBox>
#include <QFormLayout>
#include <QDoubleValidator>
#include <QComboBox>
#include <QListView>
#include <QToolButton>
#include <QShortcut>
#include <QFrame>
#include <QGridLayout>
#include <QBoxLayout>
#include <QLabel>
#include <QMenu>
#include <QTabWidget>
#include <QStyle>
#include <QStyleOption>
#include <QPainter>
#include <QMap>
#include <QScrollArea>
#include <QPushButton>
#include <QKeySequence>
#include <QTimer>

#include "doodad_brush.h"
#include "palette.h"

#include <QConcatenateTablesProxyModel>

#include <string>

import QRibbon;
import AspectRatioPixmapLabel;
import DestructibleListModel;
import DoodadListModel;

///	Only allows inputting doubles and automatically selects the text on focus
class DoubleInput : public QLineEdit {
	void focusInEvent(QFocusEvent* event) override {
		QLineEdit::focusInEvent(event);
		QTimer::singleShot(0, this, &QLineEdit::selectAll);
	}

public:
	DoubleInput() {
		setValidator(new QDoubleValidator(this));
	}
};

class DoodadPalette : public Palette {
	Q_OBJECT

public:
	DoodadPalette(QWidget* parent = nullptr);
	~DoodadPalette();

private:
	bool event(QEvent *e) override;

	void selection_changed(const QModelIndex& index);
	void select_id_in_palette(std::string id);

	Ui::DoodadPalette ui;

	DoodadBrush brush;
	DoodadListModel* doodad_list_model;
	DoodadListFilter* doodad_filter_model;
	DestructableListModel* destructable_list_model;
	DestructableListFilter* destructable_filter_model;
	QConcatenateTablesProxyModel* concat_table;

	QRibbonTab* ribbon_tab = new QRibbonTab;
	QRibbonButton* selection_mode = new QRibbonButton;
	QRibbonButton* selections_button = new QRibbonButton;

	QRibbonContainer* variations = new QRibbonContainer;

	QRibbonSection* current_selection_section = new QRibbonSection;
	DoubleInput* x_scale = new DoubleInput;
	DoubleInput* y_scale = new DoubleInput;
	DoubleInput* z_scale = new DoubleInput;
	DoubleInput* rotation = new DoubleInput;

	DoubleInput* absolute_height = new DoubleInput;
	DoubleInput* relative_height = new DoubleInput;

	QAction* group_height_minimum = new QAction("Minimum");
	QAction* group_height_average = new QAction("Average");
	QAction* group_height_maximum = new QAction("Maximum");

	QLabel* selection_name = new QLabel;

	QShortcut* find_this;
	QShortcut* find_parent;
	QShortcut* change_mode_this;
	QShortcut* change_mode_parent;


public slots:
	void deactivate(QRibbonTab* tab) override;
	void update_selection_info();
	void update_scale_change(int component, const QString& text);
	void update_scale_finish(int component);
	void update_rotation_change(const QString& text);
	void update_absolute_change(const QString& text);
	void update_relative_change(const QString& text);
	void set_group_height_minimum();
	void set_group_height_average();
	void set_group_height_maximum();
	void set_selection_rotation(float rotation);
};
```

`src/menus/doodad_palette.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DoodadPalette</class>
 <widget class="QDialog" name="DoodadPalette">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>244</width>
    <height>560</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Doodad Palette</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QComboBox" name="tileset">
     <property name="maxVisibleItems">
      <number>20</number>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QComboBox" name="type"/>
   </item>
   <item>
    <widget class="QLineEdit" name="search">
     <property name="placeholderText">
      <string>Search</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QListView" name="doodads"/>
   </item>
   <item>
    <widget class="QGroupBox" name="brushGroupBox">
     <property name="enabled">
      <bool>true</bool>
     </property>
     <property name="maximumSize">
      <size>
       <width>16777215</width>
       <height>0</height>
      </size>
     </property>
     <property name="title">
      <string>Brush</string>
     </property>
     <property name="flat">
      <bool>true</bool>
     </property>
     <property name="checkable">
      <bool>false</bool>
     </property>
     <layout class="QVBoxLayout" name="verticalLayout_4">
      <property name="leftMargin">
       <number>0</number>
      </property>
      <property name="topMargin">
       <number>9</number>
      </property>
      <property name="rightMargin">
       <number>0</number>
      </property>
      <property name="bottomMargin">
       <number>0</number>
      </property>
      <item>
       <layout class="QHBoxLayout" name="horizontalLayout_2">
        <item>
         <widget class="QPushButton" name="brushSize1">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="baseSize">
           <size>
            <width>0</width>
            <height>0</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 1x1.</string>
          </property>
          <property name="text">
           <string>1</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
          <property name="checked">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushSize3">
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 3x3.</string>
          </property>
          <property name="text">
           <string>2</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushSize5">
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 5x5.</string>
          </property>
          <property name="text">
           <string>3</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushSize7">
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 9x9.</string>
          </property>
          <property name="text">
           <string>5</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushSize9">
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 15x15.</string>
          </property>
          <property name="text">
           <string>8</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushSize11">
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 21x21.</string>
          </property>
          <property name="text">
           <string>11</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
       </layout>
      </item>
      <item>
       <layout class="QHBoxLayout" name="horizontalLayout_4">
        <item>
         <widget class="QSpinBox" name="brushSize">
          <property name="toolTip">
           <string>The current brush size</string>
          </property>
          <property name="readOnly">
           <bool>true</bool>
          </property>
          <property name="buttonSymbols">
           <enum>QAbstractSpinBox::NoButtons</enum>
          </property>
          <property name="minimum">
           <number>1</number>
          </property>
          <property name="maximum">
           <number>241</number>
          </property>
          <property name="singleStep">
           <number>2</number>
          </property>
          <property name="value">
           <number>1</number>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QSlider" name="brushSizeSlider">
          <property name="toolTip">
           <string>Sets the brush size.</string>
          </property>
          <property name="minimum">
           <number>1</number>
          </property>
          <property name="maximum">
           <number>128</number>
          </property>
          <property name="singleStep">
           <number>1</number>
          </property>
          <property name="orientation">
           <enum>Qt::Horizontal</enum>
          </property>
          <property name="invertedAppearance">
           <bool>false</bool>
          </property>
          <property name="invertedControls">
           <bool>false</bool>
          </property>
          <property name="tickPosition">
           <enum>QSlider::TicksBelow</enum>
          </property>
          <property name="tickInterval">
           <number>0</number>
          </property>
         </widget>
        </item>
       </layout>
      </item>
      <item>
       <widget class="QLabel" name="label">
        <property name="text">
         <string>Shape</string>
        </property>
       </widget>
      </item>
      <item>
       <layout class="QHBoxLayout" name="brushShapeLayout">
        <item>
         <widget class="QPushButton" name="brushShapeCircle">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="toolTip">
           <string>Circular brush shape</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>data/Icons/Brush/circle.png</normaloff>data/Icons/Brush/circle.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
          <property name="checked">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushShapeSquare">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="toolTip">
           <string>Square brush shape</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>data/Icons/Brush/square.png</normaloff>data/Icons/Brush/square.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushShapeDiamond">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="toolTip">
           <string>Diamond brush shape</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>data/Icons/Brush/diamond.png</normaloff>data/Icons/Brush/diamond.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <spacer name="horizontalSpacer_3">
          <property name="orientation">
           <enum>Qt::Horizontal</enum>
          </property>
          <property name="sizeHint" stdset="0">
           <size>
            <width>40</width>
            <height>20</height>
           </size>
          </property>
         </spacer>
        </item>
       </layout>
      </item>
     </layout>
    </widget>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>

```

`src/menus/map_info_editor.cpp`:

```cpp
#include "map_info_editor.h"

import std;
import SLK;
import Utilities;
import MapGlobal;
import Globals;

namespace fs = std::filesystem;

MapInfoEditor::MapInfoEditor(QWidget *parent) : QDialog(parent) {
	ui.setupUi(this);
	setAttribute(Qt::WA_DeleteOnClose);

	// Description Tab
	ui.name->setText(QString::fromUtf8(map->trigger_strings.string(map->info.name)));
	ui.suggestedPlayers->setText(QString::fromUtf8(map->trigger_strings.string(map->info.suggested_players)));
	ui.description->setPlainText(QString::fromUtf8(map->trigger_strings.string(map->info.description)));
	ui.author->setText(QString::fromUtf8(map->trigger_strings.string(map->info.author)));

	ui.mapVersion->setText(QString::number(map->info.map_version));
	ui.editorVersion->setText(QString::number(map->info.editor_version));

	// Loading Screen Tab
	for (auto&&[key, value] : world_edit_data.section("LoadingScreens")) {
		if (key == "NumScreens") {
			continue;
		}
		ui.campaignLoadingScreen->addItem(QString::fromStdString(value[1]));
	}

	for (const auto& entry : fs::recursive_directory_iterator(map->filesystem_path)) {
		if (entry.is_directory()) {
			continue;
		}
		if (to_lowercase_copy(entry.path().extension().string()) == ".mdx") {
			ui.importedLoadingScreen->addItem(QString::fromStdString(entry.path().lexically_relative(map->filesystem_path).string()));
		}
	}

	for (auto&&[key, value] : world_edit_data.section("LoadingScreens")) {
		if (key == "NumScreens") {
			continue;
		}
		ui.campaignLoadingScreen->addItem(QString::fromStdString(value[1]));
	}

	if (map->info.loading_screen_model.empty() && map->info.loading_screen_number == -1) {
		ui.useDefaultLoadingScreen->setChecked(true);
	} else if (!map->info.loading_screen_model.empty() && map->info.loading_screen_number == -1) {
		ui.useImportedLoadingScreen->setChecked(true);
		ui.importedLoadingScreen->setCurrentText(QString::fromStdString(map->info.loading_screen_model));
	} else {
		ui.useCampaignLoadingScreen->setChecked(true);
		ui.campaignLoadingScreen->setCurrentIndex(map->info.loading_screen_number);
	}

	ui.loadingScreenTitle->setText(QString::fromUtf8(map->trigger_strings.string(map->info.loading_screen_title)));
	ui.loadingScreenSubtitle->setText(QString::fromUtf8(map->trigger_strings.string(map->info.loading_screen_subtitle)));
	ui.loadingScreenText->setPlainText(QString::fromUtf8(map->trigger_strings.string(map->info.loading_screen_text)));

	// Options Tab
	ui.meleeMap->setChecked(map->info.melee_map);
	ui.hideMinimapPreview->setChecked(map->info.hide_minimap_preview);
	ui.maskedPartiallyVisible->setChecked(map->info.masked_area_partially_visible);
	ui.cliffWaves->setChecked(map->info.cliff_shore_waves);
	ui.rollingShoreWaves->setChecked(map->info.rolling_shore_waves);

	ui.terrainFogBox->setChecked(map->info.fog_style != 0);
	ui.fogStyle->setCurrentIndex(map->info.fog_style);
	ui.fogZStart->setValue(map->info.fog_start_z_height);
	ui.fogZEnd->setValue(map->info.fog_end_z_height);
	ui.fogDensity->setValue(map->info.fog_density);
	ui.fogColor->setColor(QColor(map->info.fog_color.r, map->info.fog_color.g, map->info.fog_color.b));

	ui.waterTinting->setChecked(map->info.water_tinting);
	ui.waterColor->setColor(QColor(map->info.water_color.r, map->info.water_color.g, map->info.water_color.b));

	ui.globalWeather->setChecked(map->info.weather_id != 0);

	// Global Weather
	slk::SLK weather_slk("TerrainArt/Weather.slk");
	weather_slk.substitute(world_edit_strings, "WorldEditStrings");

	ui.globalWeather->setChecked(map->info.weather_id != 0);
	for (size_t i = 1; i < weather_slk.rows(); i++) {
		ui.globalWeatherCombo->addItem(QString::fromUtf8(weather_slk.data<std::string_view>("name", i)), QString::fromUtf8(weather_slk.data<std::string_view>("effectid", i)));
	}
	std::string weather_id = { reinterpret_cast<char*>(&map->info.weather_id), 4 };
	ui.globalWeatherCombo->setCurrentText(QString::fromUtf8(weather_slk.data<std::string_view>("name", weather_id)));

	// Custom Sound
	slk::SLK environment_sounds_slk("UI/SoundInfo/EnvironmentSounds.slk");
	environment_sounds_slk.substitute(world_edit_strings, "WorldEditStrings");

	ui.customSound->setChecked(!map->info.custom_sound_environment.empty());
	for (size_t i = 1; i < environment_sounds_slk.rows(); i++) {
		ui.customSoundCombo->addItem(QString::fromUtf8(environment_sounds_slk.data<std::string_view>("displaytext", i)), QString::fromUtf8(environment_sounds_slk.data<std::string_view>("environmenttype", i)));
	}
	ui.customSoundCombo->setCurrentText(QString::fromUtf8(environment_sounds_slk.data<std::string_view>("displaytext", map->info.custom_sound_environment)));

	// Custom Lighting
	for (auto&& [key, value] : world_edit_data.section("TileSets")) {
		ui.customLightingCombo->addItem(QString::fromStdString(value[0]), key.front());

		if (key == std::string(&map->info.custom_light_tileset, 1)) {
			ui.customLightingCombo->setCurrentIndex(ui.customLightingCombo->count() - 1);
		}
	}
	ui.customLighting->setChecked(map->info.custom_light_tileset != 0);

	ui.itemClassification->setChecked(map->info.item_classification);
	ui.gameDataSet->setCurrentIndex(map->info.game_data_set);


	connect(ui.buttonBox, &QDialogButtonBox::accepted, [&]() {
		save();
		emit accept();
		close();
	});

	connect(ui.buttonBox, &QDialogButtonBox::rejected, [&]() {
		emit reject();
		close();
	});

	show();
}

void MapInfoEditor::save() const {
	// Description Tab
	map->trigger_strings.set_string(map->info.name, ui.name->text().toStdString());
	map->trigger_strings.set_string(map->info.author, ui.author->text().toStdString());
	map->trigger_strings.set_string(map->info.description, ui.description->toPlainText().toStdString());
	map->trigger_strings.set_string(map->info.suggested_players, ui.suggestedPlayers->text().toStdString());

	if (ui.useDefaultLoadingScreen->isChecked()) {
		map->info.loading_screen_model = "";
		map->info.loading_screen_number = -1;
	} else if (ui.useImportedLoadingScreen->isChecked()) {
		map->info.loading_screen_model = ui.importedLoadingScreen->currentText().toStdString();
		map->info.loading_screen_number = -1;
	} else {
		map->info.loading_screen_model = "";
		map->info.loading_screen_number = ui.campaignLoadingScreen->currentIndex();
	}

	map->trigger_strings.set_string(map->info.loading_screen_text, ui.loadingScreenText->toPlainText().toStdString());
	map->trigger_strings.set_string(map->info.loading_screen_title, ui.loadingScreenTitle->text().toStdString());
	map->trigger_strings.set_string(map->info.loading_screen_subtitle, ui.loadingScreenSubtitle->text().toStdString());

	map->info.game_data_set = ui.gameDataSet->currentIndex();

	// Prologue?

	// Options Tab
	map->info.melee_map = ui.meleeMap->isChecked();
	map->info.hide_minimap_preview = ui.hideMinimapPreview->isChecked();
	map->info.masked_area_partially_visible = ui.maskedPartiallyVisible->isChecked();
	map->info.cliff_shore_waves = ui.cliffWaves->isChecked();
	map->info.rolling_shore_waves = ui.rollingShoreWaves->isChecked();
	map->info.item_classification = ui.itemClassification->isChecked();

	map->info.fog_style = ui.fogStyle->currentIndex();
	map->info.fog_start_z_height = ui.fogZStart->value();
	map->info.fog_end_z_height = ui.fogZEnd->value();
	map->info.fog_density = ui.fogDensity->value();
	map->info.fog_color = ui.fogColor->get_glm_color();

	// Global Weather
	if (ui.globalWeather->isChecked()) {
		map->info.weather_id = *reinterpret_cast<int*>(ui.globalWeatherCombo->currentData().toString().toStdString().data());
	} else {
		map->info.weather_id = 0;
	}

	// Custom Sound
	if (ui.customSound->isChecked()) {
		map->info.custom_sound_environment = ui.customSoundCombo->currentData().toString().toStdString();
	} else {
		map->info.custom_sound_environment = "";
	}

	// Custom Lighting
	if (!ui.customLighting->isChecked()) {
		map->info.custom_light_tileset = 0;
	} else {
		map->info.custom_light_tileset = ui.customLightingCombo->currentData().toChar().toLatin1();
	}

	map->info.water_tinting = ui.waterTinting->isChecked();
	map->info.water_color = ui.waterColor->get_glm_color();
}
```

`src/menus/map_info_editor.h`:

```h
#pragma once

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

#include "ui_map_info_editor.h"

class MapInfoEditor : public QDialog {
	Q_OBJECT

public:
	MapInfoEditor(QWidget* parent = nullptr);

	Ui::MapInfoEditor ui;

	void save() const;
};
```

`src/menus/map_info_editor.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MapInfoEditor</class>
 <widget class="QDialog" name="MapInfoEditor">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>376</width>
    <height>527</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MapInfoEditor</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_5">
   <item>
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QTabWidget" name="tabs">
       <property name="currentIndex">
        <number>2</number>
       </property>
       <property name="usesScrollButtons">
        <bool>false</bool>
       </property>
       <widget class="QWidget" name="tab">
        <attribute name="title">
         <string>Description</string>
        </attribute>
        <layout class="QVBoxLayout" name="verticalLayout_2">
         <item>
          <widget class="QLabel" name="label">
           <property name="text">
            <string>Name:</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLineEdit" name="name"/>
         </item>
         <item>
          <widget class="QLabel" name="label_2">
           <property name="text">
            <string>Suggested Players:</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLineEdit" name="suggestedPlayers"/>
         </item>
         <item>
          <widget class="QLabel" name="label_3">
           <property name="text">
            <string>Description</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPlainTextEdit" name="description"/>
         </item>
         <item>
          <widget class="QLabel" name="label_4">
           <property name="text">
            <string>Author</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLineEdit" name="author"/>
         </item>
         <item>
          <layout class="QHBoxLayout" name="horizontalLayout">
           <item>
            <widget class="QLabel" name="label_5">
             <property name="text">
              <string>Map Version:</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QLabel" name="mapVersion">
             <property name="text">
              <string/>
             </property>
            </widget>
           </item>
           <item>
            <spacer name="horizontalSpacer">
             <property name="orientation">
              <enum>Qt::Horizontal</enum>
             </property>
             <property name="sizeHint" stdset="0">
              <size>
               <width>40</width>
               <height>20</height>
              </size>
             </property>
            </spacer>
           </item>
           <item>
            <widget class="QLabel" name="label_6">
             <property name="text">
              <string>Editor Version:</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QLabel" name="editorVersion">
             <property name="text">
              <string/>
             </property>
            </widget>
           </item>
          </layout>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="tab_4">
        <attribute name="title">
         <string>Loading Screen</string>
        </attribute>
        <layout class="QVBoxLayout" name="verticalLayout_4">
         <item>
          <widget class="QLabel" name="label_7">
           <property name="text">
            <string>Loading Screen Graphic</string>
           </property>
          </widget>
         </item>
         <item>
          <layout class="QFormLayout" name="formLayout_3">
           <item row="0" column="0">
            <widget class="QRadioButton" name="useDefaultLoadingScreen">
             <property name="text">
              <string>Use Default Screen</string>
             </property>
             <attribute name="buttonGroup">
              <string notr="true">loadingScreenGraphicGroup</string>
             </attribute>
            </widget>
           </item>
           <item row="1" column="0">
            <widget class="QRadioButton" name="useCampaignLoadingScreen">
             <property name="text">
              <string>Use Campaign Screen</string>
             </property>
             <attribute name="buttonGroup">
              <string notr="true">loadingScreenGraphicGroup</string>
             </attribute>
            </widget>
           </item>
           <item row="2" column="0">
            <widget class="QRadioButton" name="useImportedLoadingScreen">
             <property name="text">
              <string>Use Imported File</string>
             </property>
             <attribute name="buttonGroup">
              <string notr="true">loadingScreenGraphicGroup</string>
             </attribute>
            </widget>
           </item>
           <item row="1" column="1">
            <widget class="QComboBox" name="campaignLoadingScreen">
             <property name="enabled">
              <bool>false</bool>
             </property>
             <property name="maxVisibleItems">
              <number>20</number>
             </property>
            </widget>
           </item>
           <item row="2" column="1">
            <widget class="QComboBox" name="importedLoadingScreen">
             <property name="enabled">
              <bool>false</bool>
             </property>
             <property name="maxVisibleItems">
              <number>20</number>
             </property>
            </widget>
           </item>
          </layout>
         </item>
         <item>
          <widget class="QLabel" name="label_14">
           <property name="text">
            <string>Loading Screen Title</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLineEdit" name="loadingScreenTitle"/>
         </item>
         <item>
          <widget class="QLabel" name="label_15">
           <property name="text">
            <string>Loading Screen Subtitle</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLineEdit" name="loadingScreenSubtitle"/>
         </item>
         <item>
          <widget class="QLabel" name="label_16">
           <property name="text">
            <string>Loading Screen Text</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPlainTextEdit" name="loadingScreenText"/>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="tab_2">
        <attribute name="title">
         <string>Options</string>
        </attribute>
        <layout class="QVBoxLayout" name="verticalLayout_3">
         <item>
          <widget class="QCheckBox" name="meleeMap">
           <property name="text">
            <string>Melee Map</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="hideMinimapPreview">
           <property name="text">
            <string>Hide minimap in preview screens</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="maskedPartiallyVisible">
           <property name="text">
            <string>Masked areas are partially visible</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="cliffWaves">
           <property name="text">
            <string>Show water waves on cliff shores</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="rollingShoreWaves">
           <property name="text">
            <string>Show water waves on rolling shores</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="itemClassification">
           <property name="text">
            <string>Use item classification system</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QGroupBox" name="terrainFogBox">
           <property name="title">
            <string>Use Terrain Fog</string>
           </property>
           <property name="checkable">
            <bool>true</bool>
           </property>
           <layout class="QFormLayout" name="formLayout">
            <item row="0" column="0">
             <widget class="QLabel" name="label_8">
              <property name="text">
               <string>Style</string>
              </property>
             </widget>
            </item>
            <item row="0" column="1">
             <widget class="QComboBox" name="fogStyle">
              <item>
               <property name="text">
                <string>Linear</string>
               </property>
              </item>
              <item>
               <property name="text">
                <string>Exponential 1</string>
               </property>
              </item>
              <item>
               <property name="text">
                <string>Exponential 2</string>
               </property>
              </item>
             </widget>
            </item>
            <item row="1" column="0">
             <widget class="QLabel" name="label_9">
              <property name="text">
               <string>Z Start</string>
              </property>
             </widget>
            </item>
            <item row="1" column="1">
             <widget class="QDoubleSpinBox" name="fogZStart">
              <property name="autoFillBackground">
               <bool>true</bool>
              </property>
              <property name="frame">
               <bool>true</bool>
              </property>
              <property name="maximum">
               <double>100000.000000000000000</double>
              </property>
             </widget>
            </item>
            <item row="2" column="0">
             <widget class="QLabel" name="label_10">
              <property name="text">
               <string>Z End</string>
              </property>
             </widget>
            </item>
            <item row="2" column="1">
             <widget class="QDoubleSpinBox" name="fogZEnd">
              <property name="autoFillBackground">
               <bool>true</bool>
              </property>
              <property name="frame">
               <bool>true</bool>
              </property>
              <property name="maximum">
               <double>100000.000000000000000</double>
              </property>
             </widget>
            </item>
            <item row="3" column="0">
             <widget class="QLabel" name="label_11">
              <property name="text">
               <string>Density</string>
              </property>
             </widget>
            </item>
            <item row="3" column="1">
             <widget class="QDoubleSpinBox" name="fogDensity">
              <property name="autoFillBackground">
               <bool>true</bool>
              </property>
              <property name="frame">
               <bool>true</bool>
              </property>
              <property name="maximum">
               <double>100.000000000000000</double>
              </property>
             </widget>
            </item>
            <item row="4" column="0">
             <widget class="QLabel" name="label_12">
              <property name="text">
               <string>Color</string>
              </property>
             </widget>
            </item>
            <item row="4" column="1">
             <widget class="ColorButton" name="fogColor">
              <property name="text">
               <string>Choose Color</string>
              </property>
             </widget>
            </item>
           </layout>
          </widget>
         </item>
         <item>
          <layout class="QFormLayout" name="formLayout_2">
           <item row="0" column="0">
            <widget class="QCheckBox" name="globalWeather">
             <property name="text">
              <string>Use Global Weather</string>
             </property>
            </widget>
           </item>
           <item row="0" column="1">
            <widget class="QComboBox" name="globalWeatherCombo">
             <property name="enabled">
              <bool>false</bool>
             </property>
             <property name="maxVisibleItems">
              <number>20</number>
             </property>
            </widget>
           </item>
           <item row="1" column="0">
            <widget class="QCheckBox" name="customSound">
             <property name="text">
              <string>Custom Sound Environment</string>
             </property>
            </widget>
           </item>
           <item row="1" column="1">
            <widget class="QComboBox" name="customSoundCombo">
             <property name="enabled">
              <bool>false</bool>
             </property>
            </widget>
           </item>
           <item row="2" column="0">
            <widget class="QCheckBox" name="customLighting">
             <property name="text">
              <string>Custom Light Environment</string>
             </property>
            </widget>
           </item>
           <item row="2" column="1">
            <widget class="QComboBox" name="customLightingCombo">
             <property name="enabled">
              <bool>false</bool>
             </property>
             <property name="maxVisibleItems">
              <number>20</number>
             </property>
            </widget>
           </item>
           <item row="4" column="0">
            <widget class="QLabel" name="label_13">
             <property name="text">
              <string>Game Data Set:</string>
             </property>
            </widget>
           </item>
           <item row="4" column="1">
            <widget class="QComboBox" name="gameDataSet">
             <item>
              <property name="text">
               <string>Default (Map melee status)</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Custom (TFT 1.02, RoC 1.01)</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Melee (Latest Patch)</string>
              </property>
             </item>
            </widget>
           </item>
           <item row="3" column="0">
            <widget class="QCheckBox" name="waterTinting">
             <property name="text">
              <string>Use Water Tinting Color</string>
             </property>
            </widget>
           </item>
           <item row="3" column="1">
            <widget class="ColorButton" name="waterColor">
             <property name="enabled">
              <bool>false</bool>
             </property>
             <property name="text">
              <string>Choose Color</string>
             </property>
            </widget>
           </item>
          </layout>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="tab_5">
        <attribute name="title">
         <string>Preferences</string>
        </attribute>
        <widget class="QLabel" name="label_17">
         <property name="geometry">
          <rect>
           <x>160</x>
           <y>170</y>
           <width>47</width>
           <height>13</height>
          </rect>
         </property>
         <property name="text">
          <string>?</string>
         </property>
        </widget>
       </widget>
      </widget>
     </item>
     <item>
      <widget class="QDialogButtonBox" name="buttonBox">
       <property name="standardButtons">
        <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <customwidgets>
  <customwidget>
   <class>ColorButton</class>
   <extends>QPushButton</extends>
   <header>color_button.h</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections>
  <connection>
   <sender>useImportedLoadingScreen</sender>
   <signal>toggled(bool)</signal>
   <receiver>importedLoadingScreen</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>109</x>
     <y>120</y>
    </hint>
    <hint type="destinationlabel">
     <x>168</x>
     <y>120</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>useCampaignLoadingScreen</sender>
   <signal>toggled(bool)</signal>
   <receiver>campaignLoadingScreen</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>119</x>
     <y>92</y>
    </hint>
    <hint type="destinationlabel">
     <x>179</x>
     <y>93</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>globalWeather</sender>
   <signal>toggled(bool)</signal>
   <receiver>globalWeatherCombo</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>121</x>
     <y>351</y>
    </hint>
    <hint type="destinationlabel">
     <x>242</x>
     <y>357</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>customSound</sender>
   <signal>toggled(bool)</signal>
   <receiver>customSoundCombo</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>129</x>
     <y>377</y>
    </hint>
    <hint type="destinationlabel">
     <x>225</x>
     <y>384</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>customLighting</sender>
   <signal>toggled(bool)</signal>
   <receiver>customLightingCombo</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>151</x>
     <y>408</y>
    </hint>
    <hint type="destinationlabel">
     <x>210</x>
     <y>408</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>waterTinting</sender>
   <signal>toggled(bool)</signal>
   <receiver>waterColor</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>130</x>
     <y>434</y>
    </hint>
    <hint type="destinationlabel">
     <x>218</x>
     <y>435</y>
    </hint>
   </hints>
  </connection>
 </connections>
 <buttongroups>
  <buttongroup name="loadingScreenGraphicGroup"/>
 </buttongroups>
</ui>
```

`src/menus/minimap.cpp`:

```cpp
#include "minimap.h"

#include <QMouseEvent>

import std;

Minimap::Minimap(QWidget *parent) : QWidget(parent) {
	ui.setupUi(this);
	show();
}

void Minimap::set_minimap(Texture texture) {
	QImage temp_image = QImage(texture.data.data(), texture.width, texture.height, texture.width * texture.channels, QImage::Format::Format_RGBA8888);
	ui.image->setPixmap(QPixmap::fromImage(temp_image));
}

int x_offset;
int y_offset;

void Minimap::mousePressEvent(QMouseEvent* event) {
	if (event->button() == Qt::LeftButton) {
		if (event->modifiers() & Qt::ControlModifier) {
			x_offset = event->globalPosition().x() - geometry().x();
			y_offset = event->globalPosition().y() - geometry().y();
		} else {
			float x = (event->position().x() - ui.image->horizontal_border) / (width() - ui.image->horizontal_border * 2.f);
			float y = (event->position().y() - ui.image->vertical_border) / (height() - ui.image->vertical_border * 2.f);

			x = std::clamp(x, 0.f, 1.f);
			y = std::clamp(y, 0.f, 1.f);

			emit clicked({ x, y });
		}
	}
}

void Minimap::mouseReleaseEvent(QMouseEvent*) {
	setCursor(Qt::ArrowCursor);
}

void Minimap::mouseMoveEvent(QMouseEvent* event) {
	if (event->modifiers() & Qt::ControlModifier) {
		setCursor(Qt::SizeAllCursor);
	}
	if (event->buttons() & Qt::LeftButton) {
		if (event->modifiers() & Qt::ControlModifier) {
			move(event->globalPosition().x() - x_offset, event->globalPosition().y() - y_offset);
		} else if (rect().contains(event->position().toPoint())) {
			float x = (event->position().x() - ui.image->horizontal_border) / (width() - ui.image->horizontal_border * 2.f);
			float y = (event->position().y() - ui.image->vertical_border) / (height() - ui.image->vertical_border * 2.f);
			
			x = std::clamp(x, 0.f, 1.f);
			y = std::clamp(y, 0.f, 1.f);

			emit clicked({ x, y });
		}
	}
}
```

`src/menus/minimap.h`:

```h
#pragma once

#include "ui_minimap.h"

import Texture;

class Minimap : public QWidget {
	Q_OBJECT

public:
	Minimap(QWidget* parent = nullptr);

public slots:
	void set_minimap(Texture texture);

signals:
	/// point contains the location clicked on the minimap in the range [0..1]
	void clicked(QPointF point);
private:
	Ui::Minimap ui;

	void mousePressEvent(QMouseEvent* event) override;
	void mouseReleaseEvent(QMouseEvent* event) override;
	void mouseMoveEvent(QMouseEvent* event) override;
};

```

`src/menus/minimap.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Minimap</class>
 <widget class="QWidget" name="Minimap">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>256</width>
    <height>256</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="windowTitle">
   <string>Minimap</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <property name="leftMargin">
    <number>0</number>
   </property>
   <property name="topMargin">
    <number>0</number>
   </property>
   <property name="rightMargin">
    <number>0</number>
   </property>
   <property name="bottomMargin">
    <number>0</number>
   </property>
   <item>
    <widget class="AspectRatioPixmapLabel" name="image">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="frameShape">
      <enum>QFrame::Box</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Plain</enum>
     </property>
     <property name="text">
      <string>Image</string>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <customwidgets>
  <customwidget>
   <class>AspectRatioPixmapLabel</class>
   <extends>QLabel</extends>
   <header>aspect_ratio_pixmap_label.h</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`src/menus/palette.cpp`:

```cpp
#include "palette.h"

Palette::Palette(QWidget* parent) : QDialog(parent) {
}

Palette::~Palette()
{
}

//void Palette::addShortcut(const QKeySequence sequence, const std::vector<QWidget*>& attach_to) {
//	for (auto&& i : attach_to) {
//		shortcuts.push_back(new QShortcut(sequence, i));
//	}
//}
```

`src/menus/palette.h`:

```h
#pragma once

#include <QDialog>
#include <QShortcut>

#include <vector>

import QRibbon;

/// Palette is the base for all other palette kinds and facilitates things like brush switching and shortcut management
class Palette : public QDialog {
	Q_OBJECT

public:
	Palette(QWidget* parent = nullptr);
	~Palette();

	std::vector<QShortcut*> shortcuts;

	//void addShortcut(const QKeySequence sequence, const std::vector<QWidget*>& attach_to);

signals:
	void ribbon_tab_requested(QRibbonTab* tab, QString name);

public slots:
	virtual void deactivate(QRibbonTab* tab) = 0;
};

```

`src/menus/pathing_palette.cpp`:

```cpp
#include "pathing_palette.h"

#include <QImage>
#include <QSettings>
#include <QFileDialog>
#include <QMessageBox>

import std;
import MapGlobal;

namespace fs = std::filesystem;

PathingPalette::PathingPalette(QWidget *parent) : Palette(parent) {
	ui.setupUi(this);

	setAttribute(Qt::WA_DeleteOnClose);
	show();

	map->brush = &brush;

	QRibbonSection* selection_section = new QRibbonSection;
	selection_section->setText("Selection");

	selection_mode->setText("Selection\nMode");
	selection_mode->setIcon(QIcon("data/icons/Ribbon/select32x32.png"));
	selection_mode->setCheckable(true);
	selection_mode->setEnabled(false);
	selection_section->addWidget(selection_mode);

	QRibbonSection* tools_section = new QRibbonSection;
	tools_section->setText("Tools");

	import_pathing->setText("Import\nPathing");
	import_pathing->setIcon(QIcon("data/icons/pathing_palette/import.png"));
	tools_section->addWidget(import_pathing);

	export_pathing->setText("Export\nPathing");
	export_pathing->setIcon(QIcon("data/icons/pathing_palette/export.png"));
	tools_section->addWidget(export_pathing);

	ribbon_tab->addSection(selection_section);
	ribbon_tab->addSection(tools_section);

	connect(ui.replaceType, &QPushButton::clicked, [&]() { brush.operation = PathingBrush::Operation::replace; });
	connect(ui.addType, &QPushButton::clicked, [&]() { brush.operation = PathingBrush::Operation::add; });
	connect(ui.removeType, &QPushButton::clicked, [&]() { brush.operation = PathingBrush::Operation::remove; });

	connect(ui.brushTypeGroup, &QButtonGroup::buttonToggled, [&]() {
		brush.brush_mask = 0;

		if (ui.walkable->isChecked()) {
			brush.brush_mask |= 0b00000010;
		}
		if (ui.flyable->isChecked()) {
			brush.brush_mask |= 0b00000100;
		}
		if (ui.buildable->isChecked()) {
			brush.brush_mask |= 0b00001000;
		}
	});

	connect(ui.brushSizeGroup, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) { 
		brush.set_size(glm::ivec2(button->text().toInt()));
		ui.brushSize->setValue(button->text().toInt());
	});

	connect(ui.brushSizeSlider, &QSlider::valueChanged, [&](int value) { brush.set_size(glm::ivec2(value)); });

	connect(ui.brushShapeCircle, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::circle); });
	connect(ui.brushShapeSquare, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::square); });
	connect(ui.brushShapeDiamond, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::diamond); });

	connect(import_pathing, &QSmallRibbonButton::clicked, [&]() {
		QSettings settings;
		const QString directory = settings.value("openDirectoryPathing", QDir::current().path()).toString();

		const QString file_name = QFileDialog::getOpenFileName(this, "Open Pathing Image", directory, "Images (*.png *.jpg *.jpeg *.bmp *.gif)");

		if (file_name == "") {
			return;
		}

		const fs::path path(file_name.toStdString());
		settings.setValue("openDirectoryPathing", QString::fromStdString(path.parent_path().string()));

		QImage image;
		if (!image.load(file_name)) {
			QMessageBox::critical(this, "Error", "Failed to open image");
		}
		image = image.convertToFormat(QImage::Format::Format_RGB888);
		image.flip(Qt::Orientation::Vertical);

		const bool success = map->pathing_map.from_rgb(std::span{const_cast<uint8_t*>(image.constBits()), static_cast<size_t>(image.sizeInBytes())});
		if (!success) {
			const auto msg = std::format("Failed to load image. It has to be a {}x{} RGB image", map->pathing_map.width, map->pathing_map.height);
			QMessageBox::critical(this, "Error", QString::fromStdString(msg));
		}
	});

	connect(export_pathing, &QSmallRibbonButton::clicked, [&]() {
		QSettings settings;
		const QString directory = settings.value("openDirectoryPathing", QDir::current().path()).toString() + "/pathing_map.png";

		const QString file_name = QFileDialog::getSaveFileName(this, "Open Heightmap Image", directory);

		if (file_name == "") {
			return;
		}

		const fs::path path(file_name.toStdString());
		settings.setValue("openDirectoryPathing", QString::fromStdString(path.parent_path().string()));

		const auto data = map->pathing_map.to_rgb();
		QImage image(data.data(), map->pathing_map.width, map->pathing_map.height, QImage::Format_RGB888);
		image.flip(Qt::Orientation::Vertical);
		if (!image.save(file_name, "PNG")) {
			QMessageBox::critical(this, "Error", "Failed to save image");
		}
	});
}

PathingPalette::~PathingPalette() {
	map->brush = nullptr;
}

bool PathingPalette::event(QEvent* e) {
	if (e->type() == QEvent::Close) {
		// Remove shortcut from parent
		selection_mode->disconnectShortcuts();
		ribbon_tab->setParent(nullptr);
		delete ribbon_tab;
	} else if (e->type() == QEvent::WindowActivate) {
		selection_mode->enableShortcuts();
		map->brush = &brush;
		emit ribbon_tab_requested(ribbon_tab, "Pathing Palette");
	}
	return QWidget::event(e);
}

void PathingPalette::deactivate(QRibbonTab* tab) {
	if (tab != ribbon_tab) {
		brush.clear_selection();
		selection_mode->disableShortcuts();
	}
}
```

`src/menus/pathing_palette.h`:

```h
#pragma once

#include <QDialog>

#include "ui_pathing_palette.h"

#include "palette.h"
#include "pathing_brush.h"

class PathingPalette : public Palette {
	Q_OBJECT

public:
	explicit PathingPalette(QWidget* parent = nullptr);
	~PathingPalette();

private:
	bool event(QEvent *e) override;

	Ui::PathingPalette ui;
	PathingBrush brush;

	QRibbonTab* ribbon_tab = new QRibbonTab;
	QRibbonButton* selection_mode = new QRibbonButton;
	QRibbonButton* import_pathing = new QRibbonButton;
	QRibbonButton* export_pathing = new QRibbonButton;

public slots:
	void deactivate(QRibbonTab* tab) override;
};
```

`src/menus/pathing_palette.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>PathingPalette</class>
 <widget class="QWidget" name="PathingPalette">
  <property name="windowModality">
   <enum>Qt::NonModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>242</width>
    <height>265</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Pathing Pallete</string>
  </property>
  <property name="windowOpacity">
   <double>1.000000000000000</double>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="brushOperationLabel">
     <property name="toolTip">
      <string>The type of operation the brush will apply.</string>
     </property>
     <property name="text">
      <string>Brush Operation Type</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="ToolTypeLayout">
     <item>
      <widget class="QRadioButton" name="replaceType">
       <property name="toolTip">
        <string>Replaces the existing pathing when the brush is used.</string>
       </property>
       <property name="text">
        <string>Replace</string>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">toolTypeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QRadioButton" name="addType">
       <property name="toolTip">
        <string>Adds to the existing pathing any brush types that are selected.</string>
       </property>
       <property name="text">
        <string>Add</string>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">toolTypeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QRadioButton" name="removeType">
       <property name="toolTip">
        <string>Removes from the existing pathing all the brush types selected.</string>
       </property>
       <property name="text">
        <string>Remove</string>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">toolTypeGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLabel" name="brushTypeLabel">
     <property name="toolTip">
      <string>Which pathing type will be applied by the brush.</string>
     </property>
     <property name="text">
      <string>Brush Type</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QPushButton" name="walkable">
       <property name="toolTip">
        <string>Whether the brush will apply unwalkable.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/walkable.png</normaloff>data/icons/walkable.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushTypeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="flyable">
       <property name="toolTip">
        <string>Whether the brush will apply unflyable.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/flyable.png</normaloff>data/icons/flyable.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushTypeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="buildable">
       <property name="toolTip">
        <string>Whether the brush will aply unbuildable</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/buildable.png</normaloff>data/icons/buildable.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushTypeGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLabel" name="brushSizeLabel">
     <property name="toolTip">
      <string>The brush size that will be applied on the terrain. The final dimensions are: (size-1)*2+1 x (size-1)*2+1.</string>
     </property>
     <property name="text">
      <string>Brush</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QPushButton" name="brushSize1">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 1x1.</string>
       </property>
       <property name="text">
        <string>1</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize3">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 3x3.</string>
       </property>
       <property name="text">
        <string>3</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize5">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 5x5.</string>
       </property>
       <property name="text">
        <string>5</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize7">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 7x7.</string>
       </property>
       <property name="text">
        <string>7</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize9">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 9x9.</string>
       </property>
       <property name="text">
        <string>9</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize11">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 11x11.</string>
       </property>
       <property name="text">
        <string>11</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_3">
     <item>
      <widget class="QSpinBox" name="brushSize">
       <property name="toolTip">
        <string>The current brush size</string>
       </property>
       <property name="readOnly">
        <bool>true</bool>
       </property>
       <property name="buttonSymbols">
        <enum>QAbstractSpinBox::NoButtons</enum>
       </property>
       <property name="minimum">
        <number>1</number>
       </property>
       <property name="maximum">
        <number>241</number>
       </property>
       <property name="singleStep">
        <number>2</number>
       </property>
       <property name="value">
        <number>1</number>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QSlider" name="brushSizeSlider">
       <property name="toolTip">
        <string>Sets the brush size.</string>
       </property>
       <property name="minimum">
        <number>1</number>
       </property>
       <property name="maximum">
        <number>128</number>
       </property>
       <property name="singleStep">
        <number>2</number>
       </property>
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="invertedAppearance">
        <bool>false</bool>
       </property>
       <property name="invertedControls">
        <bool>false</bool>
       </property>
       <property name="tickPosition">
        <enum>QSlider::TicksBelow</enum>
       </property>
       <property name="tickInterval">
        <number>0</number>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="brushShapeLayout">
     <item>
      <widget class="QPushButton" name="brushShapeCircle">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/brush/circle.png</normaloff>data/icons/brush/circle.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushShapeSquare">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/brush/square.png</normaloff>data/icons/brush/square.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushShapeDiamond">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/brush/diamond.png</normaloff>data/icons/brush/diamond.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_3">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <tabstops>
  <tabstop>replaceType</tabstop>
  <tabstop>addType</tabstop>
  <tabstop>removeType</tabstop>
  <tabstop>walkable</tabstop>
  <tabstop>flyable</tabstop>
  <tabstop>buildable</tabstop>
  <tabstop>brushSize1</tabstop>
  <tabstop>brushSize3</tabstop>
  <tabstop>brushSize5</tabstop>
  <tabstop>brushSize7</tabstop>
  <tabstop>brushSize9</tabstop>
  <tabstop>brushSize11</tabstop>
  <tabstop>brushSize</tabstop>
  <tabstop>brushSizeSlider</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>brushSizeSlider</sender>
   <signal>valueChanged(int)</signal>
   <receiver>brushSize</receiver>
   <slot>setValue(int)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>65</x>
     <y>191</y>
    </hint>
    <hint type="destinationlabel">
     <x>32</x>
     <y>193</y>
    </hint>
   </hints>
  </connection>
 </connections>
 <buttongroups>
  <buttongroup name="brushSizeGroup"/>
  <buttongroup name="brushTypeGroup">
   <property name="exclusive">
    <bool>false</bool>
   </property>
  </buttongroup>
  <buttongroup name="toolTypeGroup"/>
  <buttongroup name="brushShapeGroup"/>
 </buttongroups>
</ui>

```

`src/menus/settings_editor.cpp`:

```cpp
#include "settings_editor.h"

#include <QSettings>
#include <QFile>

import std;

void setTestArgs(Ui::SettingsEditor &ui) {
	ui.testArgs->setText(ui.userArgs->text() + " -mapdiff " + QString::fromStdString(std::string("") + char(ui.diff->currentIndex() + '0')) +
						(ui.windowmode->currentText() != "Default" ? " -windowmode " + QString([](int x) {
		switch (x) { case 1: return "windowed"; case 2: return "windowedfullscreen"; default: return "fullscreen";} }(ui.windowmode->currentIndex())) : "") +
						(ui.testhd->currentText() != "Default" ? " -hd " + QString([](int x) {
		switch (x) { case 1: return "1"; default: return "0";} }(ui.testhd->currentIndex())) : "") +
						(ui.testteen->currentText() != "Default" ? " -teen " + QString([](int x) {
		switch (x) { case 1: return "1"; default: return "0"; } }(ui.testteen->currentIndex())) : "") +
						" -testmapprofile " + ui.profile->text() + " -fixedseed " + (ui.fixedseed->isChecked() ? "1" : "0") + (ui.nowfpause->isChecked() ? " -nowfpause" : ""));
};

SettingsEditor::SettingsEditor(QWidget* parent)
	: QDialog(parent) {
	ui.setupUi(this);
	QSettings settings;
	ui.theme->setCurrentText(settings.value("theme", "Dark").toString());
	ui.comments->setChecked(settings.value("comments", "True").toString() != "False");
	ui.flavour->setCurrentText(settings.value("flavour").toString());
	ui.hd->setChecked(settings.value("hd", "True").toString() != "False");
	ui.teen->setChecked(settings.value("teen", "False").toString() != "False");

	ui.userArgs->setText(settings.value("userArgs", "").toString());
	ui.diff->setCurrentText(settings.value("diff", "Normal").toString());
	ui.windowmode->setCurrentText(settings.value("windowmode", "Default").toString());
	ui.testhd->setCurrentText(settings.value("testhd", "Default").toString());
	ui.testteen->setCurrentText(settings.value("testteen", "Default").toString());
	ui.profile->setText(settings.value("profile", "HiveWE").toString());
	ui.fixedseed->setChecked(settings.value("fixedseed", "True").toString() != "False");
	ui.nowfpause->setChecked(settings.value("nowfpause", "True").toString() != "False");

	connect(ui.userArgs, &QLineEdit::textChanged, [&]() { setTestArgs(ui); });
	connect(ui.diff, &QComboBox::currentTextChanged, [&]() { setTestArgs(ui); });
	connect(ui.windowmode, &QComboBox::currentTextChanged, [&]() { setTestArgs(ui); });
	connect(ui.testhd, &QComboBox::currentTextChanged, [&]() { setTestArgs(ui); });
	connect(ui.testteen, &QComboBox::currentTextChanged, [&]() { setTestArgs(ui); });
	connect(ui.profile, &QLineEdit::textChanged, [&]() { setTestArgs(ui); });
	connect(ui.fixedseed, &QCheckBox::checkStateChanged, [&]() { setTestArgs(ui); });
	connect(ui.nowfpause, &QCheckBox::checkStateChanged, [&]() { setTestArgs(ui); });
	emit ui.nowfpause->checkStateChanged(Qt::CheckState::Unchecked);


	connect(ui.buttonBox, &QDialogButtonBox::accepted, [&]() {
		save();
		QSettings settings;
		QFile file("data/themes/" + settings.value("theme").toString() + ".qss");
		file.open(QFile::ReadOnly);
		QString StyleSheet = QLatin1String(file.readAll());

		qApp->setStyleSheet(StyleSheet);
		emit accept();
		close();
	});

	connect(ui.buttonBox, &QDialogButtonBox::rejected, [&]() {
		emit reject();
		close();
	});
	show();
}

void SettingsEditor::save() const {
	QSettings settings;
	settings.setValue("theme", ui.theme->currentText());
	settings.setValue("flavour", ui.flavour->currentText());
	settings.setValue("comments", ui.comments->isChecked() ? "True" : "False");
	settings.setValue("hd", ui.hd->isChecked() ? "True" : "False");
	settings.setValue("teen", ui.teen->isChecked() ? "True" : "False");
	settings.setValue("userArgs", ui.userArgs->text());
	settings.setValue("diff", ui.diff->currentText());
	settings.setValue("windowmode", ui.windowmode->currentText());
	settings.setValue("testhd", ui.testhd->currentText());
	settings.setValue("testteen", ui.testteen->currentText());
	settings.setValue("profile", ui.profile->text());
	settings.setValue("fixedseed", ui.fixedseed->isChecked() ? "True" : "False");
	settings.setValue("nowfpause", ui.nowfpause->isChecked() ? "True" : "False");
	settings.setValue("testArgs", ui.testArgs->text());
}
```

`src/menus/settings_editor.h`:

```h
#pragma once

#include "ui_settings_editor.h"

class SettingsEditor : public QDialog {
	Q_OBJECT

public:
	explicit SettingsEditor(QWidget* parent = nullptr);
private:
	Ui::SettingsEditor ui;
	void save() const;
};
```

`src/menus/settings_editor.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>SettingsEditor</class>
 <widget class="QDialog" name="SettingsEditor">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>730</width>
    <height>530</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Settings</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_1">
   <item>
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QTabWidget" name="tabs">
       <property name="currentIndex">
        <number>0</number>
       </property>
       <property name="usesScrollButtons">
        <bool>false</bool>
       </property>
       <widget class="QWidget" name="tab">
        <attribute name="title">
         <string>General</string>
        </attribute>
        <layout class="QFormLayout" name="formLayout_2">
         <item row="0" column="0">
          <widget class="QLabel" name="themeLabel">
           <property name="text">
            <string>Theme</string>
           </property>
          </widget>
         </item>
         <item row="0" column="1">
          <widget class="QComboBox" name="theme">
           <item>
            <property name="text">
             <string>Light</string>
            </property>
           </item>
           <item>
            <property name="text">
             <string>Dark</string>
            </property>
           </item>
          </widget>
         </item>
         <item row="1" column="0">
          <widget class="QLabel" name="typeLabel">
           <property name="text">
            <string>Game Data</string>
           </property>
          </widget>
         </item>
         <item row="1" column="1">
          <widget class="QComboBox" name="flavour">
           <item>
            <property name="text">
             <string>Retail</string>
            </property>
           </item>
           <item>
            <property name="text">
             <string>PTR</string>
            </property>
           </item>
          </widget>
         </item>
         <item row="2" column="1">
          <widget class="QCheckBox" name="hd">
           <property name="text">
            <string>Enable HD Mode (requires restart)</string>
           </property>
           <property name="checked">
            <bool>true</bool>
           </property>
          </widget>
         </item>
         <item row="3" column="1">
          <widget class="QCheckBox" name="teen">
           <property name="text">
            <string>Enable Teen Mode</string>
           </property>
          </widget>
         </item>
         <item row="4" column="1">
           <widget class="QCheckBox" name="comments">
             <property name="text">
               <string>Enable Comments</string>
             </property>
             <property name="checked">
               <bool>true</bool>
             </property>
           </widget>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="tab_1">
        <attribute name="title">
         <string>Testing</string>
        </attribute>
        <layout class="QFormLayout" name="formLayout">
         <property name="labelAlignment">
          <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
         </property>
         <property name="verticalSpacing">
          <number>6</number>
         </property>
         <item row="0" column="0" colspan="2">
          <layout class="QFormLayout" name="formLayout_4">
           <property name="labelAlignment">
            <set>Qt::AlignHCenter|Qt::AlignTop</set>
           </property>
           <property name="horizontalSpacing">
            <number>6</number>
           </property>
           <property name="verticalSpacing">
            <number>0</number>
           </property>
           <item row="0" column="0">
            <widget class="QLabel" name="label">
             <property name="text">
              <string>Arguments:</string>
             </property>
            </widget>
           </item>
           <item row="0" column="1">
            <widget class="QLineEdit" name="userArgs"/>
           </item>
           <item row="1" column="0">
            <widget class="QLabel" name="label_9">
             <property name="text">
              <string>Difficulty</string>
             </property>
            </widget>
           </item>
           <item row="1" column="1">
            <widget class="QComboBox" name="diff">
             <property name="currentText">
              <string>Normal</string>
             </property>
             <item>
              <property name="text">
               <string>Easy</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Normal</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Hard</string>
              </property>
             </item>
            </widget>
           </item>
           <item row="2" column="0">
            <widget class="QLabel" name="label_8">
             <property name="text">
              <string>Window Mode</string>
             </property>
            </widget>
           </item>
           <item row="2" column="1">
            <widget class="QComboBox" name="windowmode">
             <item>
              <property name="text">
               <string>Default</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Windowed</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Windowed Fullscreen</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Fullscreen</string>
              </property>
             </item>
            </widget>
           </item>
           <item row="3" column="0">
            <widget class="QLabel" name="label_10">
             <property name="text">
              <string>Asset Mode</string>
             </property>
            </widget>
           </item>
           <item row="3" column="1">
            <widget class="QComboBox" name="testhd">
             <item>
              <property name="text">
               <string>Default</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>HD</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>SD</string>
              </property>
             </item>
            </widget>
           </item>
           <item row="4" column="0">
            <widget class="QLabel" name="label_11">
             <property name="text">
              <string>Teen Mode</string>
             </property>
            </widget>
           </item>
           <item row="4" column="1">
            <widget class="QComboBox" name="testteen">
             <item>
              <property name="text">
               <string>Default</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>On</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Off</string>
              </property>
             </item>
            </widget>
           </item>
           <item row="5" column="0">
            <widget class="QLabel" name="label_12">
             <property name="text">
              <string>Profile Name</string>
             </property>
            </widget>
           </item>
           <item row="5" column="1">
            <widget class="QLineEdit" name="profile">
             <property name="text">
              <string>HiveWE</string>
             </property>
            </widget>
           </item>
           <item row="6" column="1">
            <widget class="QCheckBox" name="fixedseed">
             <property name="text">
              <string>Fixed random Seed</string>
             </property>
             <property name="checked">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item row="7" column="1">
            <widget class="QCheckBox" name="nowfpause">
             <property name="text">
              <string>No Windows Focus Pause</string>
             </property>
             <property name="checked">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item row="8" column="0">
            <widget class="QLabel" name="label_7">
             <property name="text">
              <string>Final arguments:</string>
             </property>
            </widget>
           </item>
           <item row="8" column="1">
            <widget class="QLineEdit" name="testArgs">
             <property name="readOnly">
              <bool>true</bool>
             </property>
            </widget>
           </item>
          </layout>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="tab_2">
        <attribute name="title">
         <string>Script</string>
        </attribute>
        <property name="enabled">
         <bool>false</bool>
        </property>
        <layout class="QVBoxLayout" name="verticalLayout_4">
         <item>
          <widget class="QGroupBox" name="groupBox_2">
           <property name="title">
            <string>Generate map script</string>
           </property>
           <property name="checkable">
            <bool>true</bool>
           </property>
           <layout class="QVBoxLayout" name="verticalLayout_2">
            <item>
             <widget class="QLabel" name="label_6">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="text">
               <string>Map script generation implies converting all GUI triggers to JASS and appending the text from all custom triggers.</string>
              </property>
             </widget>
            </item>
            <item>
             <widget class="QCheckBox" name="checkBox_2">
              <property name="text">
               <string>Run VJass preprocessor</string>
              </property>
              <property name="checked">
               <bool>true</bool>
              </property>
             </widget>
            </item>
           </layout>
          </widget>
         </item>
         <item>
          <widget class="QGroupBox" name="groupBox">
           <property name="title">
            <string>Custom Tool</string>
           </property>
           <property name="checkable">
            <bool>true</bool>
           </property>
           <property name="checked">
            <bool>false</bool>
           </property>
           <layout class="QVBoxLayout" name="verticalLayout_3">
            <item>
             <layout class="QFormLayout" name="formLayout_3">
              <item row="0" column="0">
               <widget class="QLabel" name="label_2">
                <property name="text">
                 <string>Executable</string>
                </property>
               </widget>
              </item>
              <item row="1" column="0">
               <widget class="QLabel" name="label_3">
                <property name="text">
                 <string>Arguments</string>
                </property>
               </widget>
              </item>
              <item row="2" column="0">
               <widget class="QLabel" name="label_4">
                <property name="text">
                 <string>Working Directory</string>
                </property>
               </widget>
              </item>
              <item row="0" column="1">
               <layout class="QHBoxLayout" name="horizontalLayout_2">
                <item>
                 <widget class="QLineEdit" name="lineEdit_2"/>
                </item>
                <item>
                 <widget class="QToolButton" name="toolButton_2">
                  <property name="sizePolicy">
                   <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
                    <horstretch>0</horstretch>
                    <verstretch>0</verstretch>
                   </sizepolicy>
                  </property>
                  <property name="text">
                   <string>...</string>
                  </property>
                 </widget>
                </item>
               </layout>
              </item>
              <item row="2" column="1">
               <layout class="QHBoxLayout" name="horizontalLayout_4">
                <item>
                 <widget class="QLineEdit" name="lineEdit_4"/>
                </item>
                <item>
                 <widget class="QToolButton" name="toolButton_4">
                  <property name="sizePolicy">
                   <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
                    <horstretch>0</horstretch>
                    <verstretch>0</verstretch>
                   </sizepolicy>
                  </property>
                  <property name="text">
                   <string>...</string>
                  </property>
                 </widget>
                </item>
               </layout>
              </item>
              <item row="1" column="1">
               <widget class="QLineEdit" name="lineEdit_5"/>
              </item>
             </layout>
            </item>
            <item>
             <widget class="QLabel" name="label_5">
              <property name="text">
               <string>HiveWE exposes the following variables:
$hivewe_path - The absolute path to the HiveWE exe
$map_path - The absolute path to the map directory</string>
              </property>
             </widget>
            </item>
           </layout>
          </widget>
         </item>
         <item>
          <spacer name="verticalSpacer">
           <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>20</width>
             <height>194</height>
            </size>
           </property>
          </spacer>
         </item>
        </layout>
       </widget>
      </widget>
     </item>
     <item>
      <widget class="QDialogButtonBox" name="buttonBox">
       <property name="standardButtons">
        <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>

```

`src/menus/terrain_palette.cpp`:

```cpp
#include "terrain_palette.h"

import MapGlobal;

import std;
import SLK;
import Texture;
import OpenGLUtilities;
import ResourceManager;

TerrainPalette::TerrainPalette(QWidget *parent) : Palette(parent) {
	ui.setupUi(this);

	setAttribute(Qt::WA_DeleteOnClose);
	show();

	brush.tile_id = map->terrain.tileset_ids.front();
	map->brush = &brush;

	change_mode_this = new QShortcut(Qt::Key_Space, this, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);
	change_mode_parent = new QShortcut(Qt::Key_Space, parent, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);

	ui.flowLayout_placeholder->addLayout(textures_layout);
	ui.flowLayout_placeholder_2->addLayout(cliff_layout);

	// Ground Tiles
	const slk::SLK& slk = map->terrain.terrain_slk;
	for (auto&& i : map->terrain.tileset_ids) {
		const auto image = resource_manager.load<Texture>(slk.data("dir", i) + "/" + slk.data("file", i));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(48, 48);
		button->setIconSize({ 48, 48 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(i));
		button->setProperty("tileName", QString::fromUtf8(slk.data<std::string_view>("comment", i)));

		textures_layout->addWidget(button);
		textures_group->addButton(button);

		auto& cliff_tiles = map->terrain.cliff_to_ground_texture;
		const auto is_cliff_tile = std::ranges::find(cliff_tiles, map->terrain.ground_texture_to_id[i]);

		if (is_cliff_tile != cliff_tiles.end()) {
			const int index = std::distance(cliff_tiles.begin(), is_cliff_tile);

			button = new QPushButton;
			button->setIcon(icon);
			button->setFixedSize(48, 48);
			button->setIconSize({ 48, 48 });
			button->setCheckable(true); 
			button->setProperty("cliffID", QString::number(index));
			button->setProperty("tileName", QString::fromUtf8(slk.data<std::string_view>("comment", i)));

			cliff_layout->addWidget(button);
			cliff_group->addButton(button);
		}
	}

	// Blight texture
	const auto image = resource_manager.load<Texture>("TerrainArt/Blight/Ashen_Blight.dds");
	const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

	ui.blight->setIcon(icon);
	ui.blight->setFixedSize(48, 48);
	ui.blight->setIconSize({ 48, 48 });
	ui.blight->setCheckable(true);
	ui.blight->setProperty("tileID", "blight");
	ui.blight->setProperty("tileName", "Blight");
	textures_group->addButton(ui.blight);

	// Ribbon
	QRibbonSection* selection_section = new QRibbonSection;
	selection_section->setText("Selection");

	selection_mode->setText("Selection\nMode");
	selection_mode->setIcon(QIcon("data/icons/ribbon/select32x32.png"));
	selection_mode->setCheckable(true);
	selection_section->addWidget(selection_mode);

	QRibbonSection* general_section = new QRibbonSection;
	general_section->setText("General");

	QRibbonButton* enforce_water_height_limit = new QRibbonButton;
	enforce_water_height_limit->setText("Enforce Water\nHeight Limit");
	enforce_water_height_limit->setIcon(QIcon("data/icons/ribbon/variation32x32.png"));
	enforce_water_height_limit->setCheckable(true);
	enforce_water_height_limit->setChecked(true);
	general_section->addWidget(enforce_water_height_limit);

	QRibbonButton* change_doodad_heights = new QRibbonButton;
	change_doodad_heights->setText("Update\nDoodad Z");
	change_doodad_heights->setIcon(QIcon("data/icons/ribbon/changeheight32x32.png"));
	change_doodad_heights->setCheckable(true);
	change_doodad_heights->setChecked(true);
	general_section->addWidget(change_doodad_heights);

	QRibbonSection* cliff_section = new QRibbonSection;
	cliff_section->setText("Cliff");

	QRibbonButton* relative_cliff_heights = new QRibbonButton;
	relative_cliff_heights->setText("Relative\nHeight");
	relative_cliff_heights->setIcon(QIcon("data/icons/ribbon/changeheight32x32.png"));
	relative_cliff_heights->setCheckable(true);
	relative_cliff_heights->setChecked(false);
	relative_cliff_heights->setEnabled(false);
	cliff_section->addWidget(relative_cliff_heights);

	QRibbonSection* pathing_section = new QRibbonSection;
	pathing_section->setText("Pathing");

	QRibbonButton* apply_cliff_pathing = new QRibbonButton;
	apply_cliff_pathing->setText("Cliff\nPathing");
	apply_cliff_pathing->setIcon(QIcon("data/icons/ribbon/rock32x32.png"));
	apply_cliff_pathing->setCheckable(true);
	apply_cliff_pathing->setChecked(true);
	pathing_section->addWidget(apply_cliff_pathing);

	QRibbonButton* apply_tile_pathing = new QRibbonButton;
	apply_tile_pathing->setText("Tile\nPathing");
	apply_tile_pathing->setIcon(QIcon("data/icons/ribbon/tileset32x32.png"));
	apply_tile_pathing->setCheckable(true);
	apply_tile_pathing->setChecked(true);
	pathing_section->addWidget(apply_tile_pathing);

	QRibbonButton* apply_water_pathing = new QRibbonButton;
	apply_water_pathing->setText("Water\nPathing");
	apply_water_pathing->setIcon(QIcon("data/icons/ribbon/water32x32.png"));
	apply_water_pathing->setCheckable(true);
	apply_water_pathing->setChecked(true);
	pathing_section->addWidget(apply_water_pathing);

	ribbon_tab->addSection(selection_section);
	ribbon_tab->addSection(general_section);
	ribbon_tab->addSection(cliff_section);
	ribbon_tab->addSection(pathing_section);

	connect(selection_mode, &QRibbonButton::toggled, [&]() { brush.switch_mode(); });
	connect(change_mode_this, &QShortcut::activated, [&]() {
		selection_mode->click();
	});

	connect(change_mode_parent, &QShortcut::activated, [&]() {
		selection_mode->click();
	});

	connect(enforce_water_height_limit, &QRibbonButton::toggled, [&](bool checked) { brush.enforce_water_height_limits = checked; });
	connect(change_doodad_heights, &QRibbonButton::toggled, [&](bool checked) { brush.change_doodad_heights = checked; });
	connect(relative_cliff_heights, &QRibbonButton::toggled, [&](bool checked) { brush.relative_cliff_heights = checked; });

	connect(enforce_water_height_limit, &QRibbonButton::toggled, [&](bool checked) { brush.enforce_water_height_limits = checked; });

	connect(apply_cliff_pathing, &QRibbonButton::toggled, [&](bool checked) { brush.apply_cliff_pathing = checked; });
	connect(apply_tile_pathing, &QRibbonButton::toggled, [&](bool checked) { brush.apply_tile_pathing = checked; });
	connect(apply_water_pathing, &QRibbonButton::toggled, [&](bool checked) { brush.apply_water_pathing	= checked; });

	connect(ui.brushSizeButtonGroup, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) {
		ui.brushSizeSlider->setValue(button->text().toInt());
	});
	connect(ui.brushSizeSlider, &QSlider::valueChanged, [&](int value) {
		brush.set_size(glm::ivec2(value));
		ui.brushSize->setValue(value);
	});
	
	connect(ui.textureCheckbox, &QCheckBox::clicked, [&](bool checked) { brush.apply_texture = checked; });
	connect(ui.cliffCheckbox, &QCheckBox::clicked, [&](bool checked) { brush.apply_cliff = checked; });
	connect(ui.deformationCheckbox, &QCheckBox::clicked, [&](bool checked) { brush.apply_height = checked; });

	connect(textures_group, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) {
		brush.tile_id = button->property("tileID").toString().toStdString();
		ui.deformationCheckbox->setChecked(false);
		ui.cliffCheckbox->setChecked(false);
		ui.textureCheckbox->setChecked(true);
		brush.apply_cliff = false;
		brush.apply_height = false;
		brush.apply_texture = true;
	});

	connect(cliff_group, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) {
		brush.cliff_id = button->property("cliffID").toInt();
		ui.deformationCheckbox->setChecked(false);
		ui.cliffCheckbox->setChecked(true);
		ui.textureCheckbox->setChecked(false);
		brush.apply_cliff = true;
		brush.apply_height = false;
		brush.apply_texture = false;
	});

	connect(ui.cliffButtonGroup, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&]() {
		ui.deformationCheckbox->setChecked(false);
		ui.cliffCheckbox->setChecked(true);
		ui.textureCheckbox->setChecked(false);
		brush.apply_cliff = true;
		brush.apply_height = false;
		brush.apply_texture = false;
	});

	connect(cliff_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), [&]() {
		ui.deformationCheckbox->setChecked(false);
		ui.cliffCheckbox->setChecked(true);
		ui.textureCheckbox->setChecked(false);
		brush.apply_cliff = true;
		brush.apply_height = false;
		brush.apply_texture = false;
	});

	connect(ui.deformationButtonGroup, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&]() {
		ui.deformationCheckbox->setChecked(true);
		ui.cliffCheckbox->setChecked(false);
		ui.textureCheckbox->setChecked(false);
		brush.apply_cliff = false;
		brush.apply_height = true;
		brush.apply_texture = false;
	});

	connect(ui.terrainRaise, &QPushButton::clicked, [&]() { brush.deformation_type = TerrainBrush::deformation::raise; });
	connect(ui.terrainLower, &QPushButton::clicked, [&]() { brush.deformation_type = TerrainBrush::deformation::lower; });
	connect(ui.terrainPlateau, &QPushButton::clicked, [&]() { brush.deformation_type = TerrainBrush::deformation::plateau; });
	connect(ui.terrainRipple, &QPushButton::clicked, [&]() { brush.deformation_type = TerrainBrush::deformation::ripple; });
	connect(ui.terrainSmooth, &QPushButton::clicked, [&]() { brush.deformation_type = TerrainBrush::deformation::smooth; });

	connect(ui.cliffLower2, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::lower2; });
	connect(ui.cliffLower1, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::lower1; });
	connect(ui.cliffLevel, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::level; });
	connect(ui.cliffRaise1, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::raise1; });
	connect(ui.cliffRaise2, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::raise2; });
	connect(ui.cliffDeepWater, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::deep_water; });
	connect(ui.cliffShallowWater, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::shallow_water; });
	connect(ui.cliffRamp, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::ramp; });

	connect(ui.brushShapeCircle, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::circle); });
	connect(ui.brushShapeSquare, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::square); });
	connect(ui.brushShapeDiamond, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::diamond); });
}

TerrainPalette::~TerrainPalette() {
	map->brush = nullptr;
	delete change_mode_parent;
	delete change_mode_this;
}

bool TerrainPalette::event(QEvent *e) {
	if (e->type() == QEvent::Close) {
		change_mode_this->setEnabled(false);
		change_mode_parent->setEnabled(false);
		ribbon_tab->setParent(nullptr);
		delete ribbon_tab;
	} else if (e->type() == QEvent::WindowActivate) {
		change_mode_this->setEnabled(true);
		change_mode_parent->setEnabled(true);
		map->brush = &brush;
		emit ribbon_tab_requested(ribbon_tab, "Terrain Palette");
	}
	return QWidget::event(e);
}

void TerrainPalette::deactivate(QRibbonTab* tab) {
	if (tab != ribbon_tab) {
		brush.clear_selection();
		change_mode_this->setEnabled(false);
		change_mode_parent->setEnabled(false);
	}
}
```

`src/menus/terrain_palette.h`:

```h
#pragma once

#include "ui_terrain_palette.h"

#include <QDialog>

#include "palette.h"
#include "terrain_brush.h"

import QRibbon;
import FlowLayout;

class TerrainPalette : public Palette {
	Q_OBJECT

public:
	TerrainPalette(QWidget* parent = nullptr);
	~TerrainPalette();

private:
	bool event(QEvent *e) override;

	Ui::TerrainPalette ui;

	TerrainBrush brush;

	QButtonGroup* textures_group = new QButtonGroup;
	FlowLayout* textures_layout = new FlowLayout;

	QButtonGroup* cliff_group = new QButtonGroup;
	FlowLayout* cliff_layout = new FlowLayout;

	QRibbonTab* ribbon_tab = new QRibbonTab;
	QRibbonButton* selection_mode = new QRibbonButton;

	QShortcut* change_mode_this;
	QShortcut* change_mode_parent;

public slots:
	void deactivate(QRibbonTab* tab) override;
};
```

`src/menus/terrain_palette.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TerrainPalette</class>
 <widget class="QWidget" name="TerrainPalette">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>300</width>
    <height>670</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Terrain Palette</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QCheckBox" name="textureCheckbox">
     <property name="text">
      <string>Texture</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="textureLayout">
     <item>
      <layout class="QHBoxLayout" name="flowLayout_placeholder">
       <property name="spacing">
        <number>4</number>
       </property>
       <property name="topMargin">
        <number>0</number>
       </property>
      </layout>
     </item>
     <item>
      <layout class="QVBoxLayout" name="blightBoundaryLayout">
       <property name="sizeConstraint">
        <enum>QLayout::SetDefaultConstraint</enum>
       </property>
       <property name="topMargin">
        <number>0</number>
       </property>
       <item>
        <widget class="QPushButton" name="blight">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="minimumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="maximumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="baseSize">
          <size>
           <width>64</width>
           <height>64</height>
          </size>
         </property>
         <property name="toolTip">
          <string>Blight.</string>
         </property>
         <property name="text">
          <string/>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="addBoundary">
         <property name="enabled">
          <bool>false</bool>
         </property>
         <property name="sizePolicy">
          <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="minimumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="maximumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="baseSize">
          <size>
           <width>64</width>
           <height>64</height>
          </size>
         </property>
         <property name="toolTip">
          <string>Add Boundary.</string>
         </property>
         <property name="text">
          <string/>
         </property>
         <property name="icon">
          <iconset>
           <normaloff>data/icons/terrain/boundary_place.png</normaloff>data/icons/terrain/boundary_place.png</iconset>
         </property>
         <property name="iconSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="removeBoundary">
         <property name="enabled">
          <bool>false</bool>
         </property>
         <property name="sizePolicy">
          <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="minimumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="maximumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="baseSize">
          <size>
           <width>64</width>
           <height>64</height>
          </size>
         </property>
         <property name="toolTip">
          <string>Remove Boundary.</string>
         </property>
         <property name="text">
          <string/>
         </property>
         <property name="icon">
          <iconset>
           <normaloff>data/icons/terrain/boundary_remove.png</normaloff>data/icons/terrain/boundary_remove.png</iconset>
         </property>
         <property name="iconSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="verticalSpacer_2">
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>40</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QCheckBox" name="cliffCheckbox">
     <property name="text">
      <string>Cliff</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="cliffRaiseLayout">
     <property name="spacing">
      <number>6</number>
     </property>
     <property name="rightMargin">
      <number>0</number>
     </property>
     <item>
      <widget class="QPushButton" name="cliffLower2">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Lower cliff by 2.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/lower2.png</normaloff>data/icons/terrain/lower2.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffLower1">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Lower cliff by 1.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/lower1.png</normaloff>data/icons/terrain/lower1.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffLevel">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Level.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/level.png</normaloff>data/icons/terrain/level.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <property name="default">
        <bool>false</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffRaise1">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Raise cliff by 1.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/raise1.png</normaloff>data/icons/terrain/raise1.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffRaise2">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Raise cliff by 2.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/raise2.png</normaloff>data/icons/terrain/raise2.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="cliffWaterLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="cliffDeepWater">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Deep water.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/deep_water.png</normaloff>data/icons/terrain/deep_water.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffShallowWater">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Shallow water.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/shallow_water.png</normaloff>data/icons/terrain/shallow_water.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffRamp">
       <property name="enabled">
        <bool>false</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Ramp.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/ramp.png</normaloff>data/icons/terrain/ramp.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowLayout_placeholder_2"/>
   </item>
   <item>
    <widget class="QCheckBox" name="deformationCheckbox">
     <property name="text">
      <string>Deformation</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="deformationLayout">
     <item>
      <widget class="QPushButton" name="terrainLower">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Raise the terrain.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/brush_lower.png</normaloff>data/icons/terrain/brush_lower.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">deformationButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="terrainRaise">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Lower the terrain.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/brush_raise.png</normaloff>data/icons/terrain/brush_raise.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">deformationButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="terrainRipple">
       <property name="enabled">
        <bool>false</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Ripple the terrain randomly.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/brush_ripple.png</normaloff>data/icons/terrain/brush_ripple.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">deformationButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="terrainPlateau">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Plateau/flatten terrain.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/brush_plateau.png</normaloff>data/icons/terrain/brush_plateau.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">deformationButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="terrainSmooth">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Smooth terrain.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/terrain/brush_smooth.png</normaloff>data/icons/terrain/brush_smooth.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">deformationButtonGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLabel" name="label_2">
     <property name="text">
      <string>Brush Size</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QPushButton" name="brushSize1">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 1x1.</string>
       </property>
       <property name="text">
        <string>1</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize3">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 3x3.</string>
       </property>
       <property name="text">
        <string>3</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize5">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 5x5.</string>
       </property>
       <property name="text">
        <string>5</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize7">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 7x7.</string>
       </property>
       <property name="text">
        <string>7</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize9">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 9x9.</string>
       </property>
       <property name="text">
        <string>9</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize11">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 11x11.</string>
       </property>
       <property name="text">
        <string>11</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_4">
     <item>
      <widget class="QSpinBox" name="brushSize">
       <property name="toolTip">
        <string>The current brush size</string>
       </property>
       <property name="readOnly">
        <bool>true</bool>
       </property>
       <property name="buttonSymbols">
        <enum>QAbstractSpinBox::NoButtons</enum>
       </property>
       <property name="minimum">
        <number>1</number>
       </property>
       <property name="maximum">
        <number>241</number>
       </property>
       <property name="singleStep">
        <number>2</number>
       </property>
       <property name="value">
        <number>1</number>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QSlider" name="brushSizeSlider">
       <property name="toolTip">
        <string>Sets the brush size.</string>
       </property>
       <property name="minimum">
        <number>1</number>
       </property>
       <property name="maximum">
        <number>128</number>
       </property>
       <property name="singleStep">
        <number>2</number>
       </property>
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="invertedAppearance">
        <bool>false</bool>
       </property>
       <property name="invertedControls">
        <bool>false</bool>
       </property>
       <property name="tickPosition">
        <enum>QSlider::TicksBelow</enum>
       </property>
       <property name="tickInterval">
        <number>0</number>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLabel" name="label">
     <property name="text">
      <string>Brush Shape</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="brushShapeLayout">
     <item>
      <widget class="QPushButton" name="brushShapeCircle">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="toolTip">
        <string>Circular brush shape</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/brush/circle.png</normaloff>data/icons/brush/circle.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushShapeSquare">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="toolTip">
        <string>Square brush shape</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/brush/square.png</normaloff>data/icons/brush/square.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushShapeDiamond">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="toolTip">
        <string>Diamond brush shape</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>data/icons/brush/diamond.png</normaloff>data/icons/brush/diamond.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_3">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
 <buttongroups>
  <buttongroup name="cliffButtonGroup"/>
  <buttongroup name="brushShapeButtonGroup"/>
  <buttongroup name="brushSizeButtonGroup"/>
  <buttongroup name="deformationButtonGroup"/>
 </buttongroups>
</ui>

```

`src/menus/tile_pather.cpp`:

```cpp
#include "tile_pather.h"

import std;
import OpenGLUtilities;
import Texture;
import MapGlobal;
import SLK;
import ResourceManager;
import <glad/glad.h>;

TilePather::TilePather(QWidget *parent) : QDialog(parent) {
	ui.setupUi(this);

	setAttribute(Qt::WA_DeleteOnClose);
	show();

	ui.flowlayout_placeholder->addLayout(selected_layout);

	for (auto&&[tile_id, options] : map->terrain.pathing_options) {
		pathing_options[tile_id].unwalkable = options.unwalkable;
		pathing_options[tile_id].unflyable = options.unflyable;
		pathing_options[tile_id].unbuildable = options.unbuildable;
	}

	const slk::SLK& slk = map->terrain.terrain_slk;
	for (auto&& i : map->terrain.tileset_ids) {
		const auto image = resource_manager.load<Texture>(slk.data("dir", i) + "\\" + slk.data("file", i));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(64, 64);
		button->setIconSize({ 64, 64 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(i));
		button->setProperty("tileName", QString::fromUtf8(slk.data<std::string_view>("comment", i)));

		selected_layout->addWidget(button);
		selected_group->addButton(button);
	}

	selected_group->buttons().first()->setChecked(true);
	changed_tile(selected_group->buttons().first());

	connect(selected_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), this, &TilePather::changed_tile);

	connect(ui.buttonBox, &QDialogButtonBox::accepted, this, &TilePather::save_tiles);
	connect(ui.buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);

	connect(ui.unwalkable, &QPushButton::clicked, [&](bool checked) { pathing_options[current_tile].unwalkable = checked; });
	connect(ui.unflyable, &QPushButton::clicked, [&](bool checked) { pathing_options[current_tile].unflyable = checked; });
	connect(ui.unbuildable, &QPushButton::clicked, [&](bool checked) { pathing_options[current_tile].unbuildable = checked; });

	connect(ui.replaceType, &QPushButton::clicked, [&]() { pathing_options[current_tile].operation = PathingOptions::Operation::replace; });
	connect(ui.addType, &QPushButton::clicked, [&]() { pathing_options[current_tile].operation = PathingOptions::Operation::add; });
	connect(ui.removeType, &QPushButton::clicked, [&]() { pathing_options[current_tile].operation = PathingOptions::Operation::remove; });

	connect(ui.applyRetroactively, &QCheckBox::clicked, [&](bool checked) { pathing_options[current_tile].apply_retroactively = checked; });
}

void TilePather::changed_tile(QAbstractButton* button) {
	ui.selectedTileLabel->setText("Tile: " + button->property("tileName").toString());

	current_tile = button->property("tileID").toString().toStdString();

	ui.unwalkable->setChecked(pathing_options[current_tile].unwalkable);
	ui.unflyable->setChecked(pathing_options[current_tile].unflyable);
	ui.unbuildable->setChecked(pathing_options[current_tile].unbuildable);

	ui.applyRetroactively->setChecked(pathing_options[current_tile].apply_retroactively);

	switch (pathing_options[current_tile].operation) {
	case PathingOptions::Operation::replace:
		ui.replaceType->setChecked(true);
		break;
	case PathingOptions::Operation::add:
		ui.addType->setChecked(true);
		break;
	case PathingOptions::Operation::remove:
		ui.removeType->setChecked(true);
		break;
	}
}

void TilePather::save_tiles() {
	for (auto&&[tile_id, options] : pathing_options) {
		// Save state
		map->terrain.pathing_options[tile_id].unwalkable = options.unwalkable;
		map->terrain.pathing_options[tile_id].unflyable = options.unflyable;
		map->terrain.pathing_options[tile_id].unbuildable = options.unbuildable;

		if (!options.apply_retroactively) {
			continue;
		}

		uint8_t mask = 0;
		if (options.unwalkable) {
			mask |= 0b00000010;
		}
		if (options.unflyable) {
			mask |= 0b00000100;
		}
		if (options.unbuildable) {
			mask |= 0b00001000;
		}

		const int id = map->terrain.ground_texture_to_id.at(tile_id);
		for (int i = 0; i < map->terrain.width; i++) {
			for (int j = 0; j < map->terrain.height; j++) {
				if (map->terrain.real_tile_texture(i, j) != id) {
					continue;
				}

				const int left = std::max(i * 4 - 2, 0);
				const int bottom = std::max(j * 4 - 2, 0);

				const int right = std::min(i * 4 + 2, map->pathing_map.width);
				const int top = std::min(j * 4 + 2, map->pathing_map.height);

				for (int x = left; x < right; x++) {
					for (int y = bottom; y < top; y++) {
						uint8_t byte_cell = map->pathing_map.pathing_cells_static[y * map->pathing_map.width + x];

						switch (options.operation) {
						case PathingOptions::Operation::replace:
							byte_cell &= ~0b00001110;
							byte_cell |= mask;
							break;
						case PathingOptions::Operation::add:
							byte_cell |= mask;
							break;
						case PathingOptions::Operation::remove:
							byte_cell &= ~mask;
							break;
						}

						map->pathing_map.pathing_cells_static[y * map->pathing_map.width + x] = byte_cell;
					}
				}
			}
		}
	}

	glTextureSubImage2D(map->pathing_map.texture_static, 0, 0, 0, map->pathing_map.width, map->pathing_map.height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, map->pathing_map.pathing_cells_static.data());

	close();
}
```

`src/menus/tile_pather.h`:

```h
#pragma once

#include "ui_tile_pather.h"

#include <QWidget>
#include <QDialog>
#include <QButtonGroup>
#include <QAbstractButton>

#include <string>

import FlowLayout;

struct PathingOptions {
	bool unwalkable = false;
	bool unflyable = false;
	bool unbuildable = false;

	enum class Operation {
		replace,
		add,
		remove
	};
	Operation operation = Operation::replace;

	bool apply_retroactively = false;
};

class TilePather : public QDialog {
	Q_OBJECT

public:
	explicit TilePather(QWidget* parent = nullptr);

private:
	void changed_tile(QAbstractButton* button);
	void save_tiles();

	Ui::TilePather ui;
	QButtonGroup* selected_group = new QButtonGroup;
	FlowLayout* selected_layout = new FlowLayout;

	std::string current_tile;
	std::unordered_map<std::string, PathingOptions> pathing_options;
};
```

`src/menus/tile_pather.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TilePather</class>
 <widget class="QWidget" name="TilePather">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>580</width>
    <height>260</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Tile Pathing</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="pathingTileLabel">
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:10pt; font-weight:600;&quot;&gt;Pathing Tile&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="selectedTileLabel">
     <property name="text">
      <string>Tile:</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowlayout_placeholder"/>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QGroupBox" name="groupBox_2">
       <property name="title">
        <string>Pathing</string>
       </property>
       <layout class="QHBoxLayout" name="horizontalLayout_4">
        <item>
         <widget class="QPushButton" name="unwalkable">
          <property name="toolTip">
           <string>Whether the brush will apply unwalkable.</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>data/icons/walkable.png</normaloff>data/icons/walkable.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="unflyable">
          <property name="toolTip">
           <string>Whether the brush will apply unflyable.</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>data/icons/flyable.png</normaloff>data/icons/flyable.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="unbuildable">
          <property name="toolTip">
           <string>Whether the brush will aply unbuildable</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>data/icons/buildable.png</normaloff>data/icons/buildable.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QGroupBox" name="groupBox">
       <property name="toolTip">
        <string>How the new pathing is applied</string>
       </property>
       <property name="title">
        <string>Operation Type</string>
       </property>
       <layout class="QHBoxLayout" name="horizontalLayout_3">
        <item>
         <widget class="QRadioButton" name="replaceType">
          <property name="toolTip">
           <string>Replaces the existing pathing</string>
          </property>
          <property name="text">
           <string>Replace</string>
          </property>
          <property name="checked">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QRadioButton" name="addType">
          <property name="toolTip">
           <string>Adds to the existing pathing any types that are selected.</string>
          </property>
          <property name="text">
           <string>Add</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QRadioButton" name="removeType">
          <property name="toolTip">
           <string>Removes from the existing pathing all the types selected.</string>
          </property>
          <property name="text">
           <string>Remove</string>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QGroupBox" name="groupBox_3">
       <property name="title">
        <string>Application</string>
       </property>
       <layout class="QVBoxLayout" name="verticalLayout_2">
        <item>
         <widget class="QCheckBox" name="applyRetroactively">
          <property name="toolTip">
           <string>Whether the pathing is applied to all existing tiles or only to newly placed tiles.</string>
          </property>
          <property name="text">
           <string>Apply Retroactively</string>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>

```

`src/menus/tile_picker.cpp`:

```cpp
#include "tile_picker.h"

#include <QPushButton>

import std;
import ResourceManager;
import Texture;
import OpenGLUtilities;
import SLK;
import MapGlobal;

TilePicker::TilePicker(QWidget* parent, std::vector<std::string> from_ids, std::vector<std::string> to_ids) : QDialog(parent) {
	ui.setupUi(this);

	ui.flowlayout_placeholder_1->addLayout(from_layout);
	ui.flowlayout_placeholder_2->addLayout(to_layout);

	const slk::SLK& slk = map->terrain.terrain_slk;
	for (auto&& i : from_ids) {
		const auto image = resource_manager.load<Texture>(slk.data("dir", i) + "\\" + slk.data("file", i));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(64, 64);
		button->setIconSize({ 64, 64 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(i));
		button->setProperty("tileName", QString::fromUtf8(slk.data<std::string_view>("comment", i)));

		from_layout->addWidget(button);
		from_group->addButton(button);
	}

	for (auto&& i : to_ids) {
		const auto image = resource_manager.load<Texture>(slk.data("dir", i) + "\\" + slk.data("file", i));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(64, 64);
		button->setIconSize({ 64, 64 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(i));
		button->setProperty("tileName", QString::fromUtf8(slk.data<std::string_view>("comment", i)));

		to_layout->addWidget(button);
		to_group->addButton(button);
	}

	to_group->buttons().first()->setChecked(true);
	from_group->buttons().first()->setChecked(true);

	connect(ui.buttonBox, &QDialogButtonBox::accepted, this, &TilePicker::completed);
	connect(ui.buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);
	
	connect(from_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) {
		ui.selectedTileLabel->setText("Tile: " + button->property("tileName").toString());
	});

	connect(to_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) {
		ui.replacingTileLabel->setText("Tile: " + button->property("tileName").toString());
	});
}

void TilePicker::completed() {
	const std::string from_tile = from_group->checkedButton()->property("tileID").toString().toStdString();
	const std::string to_tile = to_group->checkedButton()->property("tileID").toString().toStdString();
	emit tile_chosen(from_tile, to_tile);
	close();
}
```

`src/menus/tile_picker.h`:

```h
#pragma once

#include "ui_tile_picker.h"

#include <QDialog>
#include <QButtonGroup>

#include <string>

import FlowLayout;

class TilePicker : public QDialog {
	Q_OBJECT

public:
	TilePicker(QWidget* parent, std::vector<std::string> from_ids, std::vector<std::string> to_ids);

signals:
	void tile_chosen(std::string from_id, std::string to_id);

private:
	void completed();

	Ui::TilePicker ui;

	QButtonGroup* from_group = new QButtonGroup;
	QButtonGroup* to_group = new QButtonGroup;

	FlowLayout* from_layout = new FlowLayout;
	FlowLayout* to_layout = new FlowLayout;
};
```

`src/menus/tile_picker.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TilePicker</class>
 <widget class="QWidget" name="TilePicker">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>579</width>
    <height>153</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>TilePicker</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="label">
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:10pt; font-weight:600;&quot;&gt;Replace Tile:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="selectedTileLabel">
     <property name="text">
      <string>Tile:</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowlayout_placeholder_1"/>
   </item>
   <item>
    <widget class="QLabel" name="availableTilesLabel">
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:10pt; font-weight:600;&quot;&gt;By Tile:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="replacingTileLabel">
     <property name="text">
      <string>Tile:</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowlayout_placeholder_2"/>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>
```

`src/menus/tile_setter.cpp`:

```cpp
#include "tile_setter.h"
#include "tile_picker.h"

#include <QPushButton>
#include <QLabel>

import std;
import ResourceManager;
import OpenGLUtilities;
import MapGlobal;
import Globals;
import SLK;
import Texture;
import <glm/glm.hpp>;

TileSetter::TileSetter(QWidget *parent) : QDialog(parent) {
	ui.setupUi(this);

	setAttribute(Qt::WA_DeleteOnClose);
	show();

	// widget_list->setViewMode(QListView::IconMode);
	// widget_list->setResizeMode(QListView::Adjust);
	// widget_list->setFlow(QListView::LeftToRight);
	// widget_list->setMovement(QListView::Snap);
	// widget_list->setGridSize(QSize(80, 80));
	// widget_list->setIconSize(QSize(64, 64));
	// widget_list->setUniformItemSizes(true);
	// widget_list->setWrapping(true);
	// widget_list->setDropIndicatorShown(true);
	// widget_list->setDragDropMode(QAbstractItemView::InternalMove);
	// widget_list->setAttribute(Qt::WA_TranslucentBackground);
	// widget_list->setStyleSheet("QListWidget { background: transparent; }");
	// widget_list->setAutoFillBackground(false);
	// ui.flowlayout_placeholder_1->addWidget(widget_list);

	ui.flowlayout_placeholder_1->addLayout(selected_layout);
	ui.flowlayout_placeholder_2->addLayout(available_layout);

	slk::SLK& slk = map->terrain.terrain_slk;
	for (auto&& i : map->terrain.tileset_ids) {
		const auto image = resource_manager.load<Texture>(slk.data("dir", i) + "\\" + slk.data("file", i));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		// QListWidgetItem* item = new QListWidgetItem;
		// // item->setFlags(item->flags() | Qt::ItemIsDragEnabled | Qt::ItemIsSelectable | Qt::ItemIsEnabled);
		// item->setIcon(icon);
		// item->setText(QString::fromStdString(slk.data("comment", i)));
		// widget_list->addItem(item);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(64, 64);
		button->setIconSize({ 64, 64 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(i));
		button->setProperty("tileName", QString::fromUtf8(slk.data<std::string_view>("comment", i)));

		selected_layout->addWidget(button);
		selected_group->addButton(button);
	}

	for (auto&& [key, value] : world_edit_data.section("TileSets")) {
//		const std::string tileset_key = split(value, ',').front();
		ui.tileset->addItem(QString::fromStdString(value[0]), QString::fromStdString(key));
	}

	update_available_tiles();

	connect(ui.tileset, &QComboBox::currentTextChanged, this, &TileSetter::update_available_tiles);
	connect(selected_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), this, &TileSetter::existing_tile_clicked);
	connect(available_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), this, &TileSetter::available_tile_clicked);
	connect(ui.additionalAdd, &QPushButton::clicked, this, &TileSetter::add_tile);
	connect(ui.selectedRemove, &QPushButton::clicked, this, &TileSetter::remove_tile);
	connect(ui.selectedShiftLeft, &QPushButton::clicked, this, &TileSetter::shift_left);
	connect(ui.selectedShiftRight, &QPushButton::clicked, this, &TileSetter::shift_right);
	connect(ui.buttonBox, &QDialogButtonBox::accepted, this, &TileSetter::save_tiles);
	connect(ui.buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);
}

void TileSetter::add_tile() const {
	const auto available_button = available_group->checkedButton();
	if (!available_button) {
		return;
	}

	QPushButton* button = new QPushButton;
	button->setIcon(available_button->icon());
	button->setFixedSize(64, 64);
	button->setIconSize({ 64, 64 });
	button->setCheckable(true);
	button->setProperty("tileID", available_button->property("tileID"));
	button->setProperty("tileName", available_button->property("tileName"));

	selected_layout->addWidget(button);
	selected_group->addButton(button);

	if (selected_group->buttons().size() >= 64) {
		ui.additionalAdd->setDisabled(true);
	}
}

void TileSetter::remove_tile() const {
	const auto selected_button = selected_group->checkedButton();
	if (!selected_button) {
		return;
	}

	selected_layout->removeWidget(selected_button);
	selected_group->removeButton(selected_button);
	selected_button->deleteLater();

	ui.additionalAdd->setEnabled(true);
}

void TileSetter::update_available_tiles() const {
	available_layout->clear();

	const std::string tileset = ui.tileset->currentData().toString().toStdString();

	const slk::SLK& slk = map->terrain.terrain_slk;
	for (auto&&[key, value] : map->terrain.terrain_slk.row_headers) {
		if (key.front() != tileset.front()) {
			continue;
		}

		const auto image = resource_manager.load<Texture>(slk.data("dir", key) + "\\" + slk.data("file", key));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(64, 64);
		button->setIconSize({ 64, 64 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(key));
		button->setProperty("tileName", QString::fromUtf8(slk.data<std::string_view>("comment", key)));

		available_layout->addWidget(button);
		available_group->addButton(button);
	}
}

void TileSetter::existing_tile_clicked(QAbstractButton* button) const {
	ui.selectedTileLabel->setText("Tile: " + button->property("tileName").toString());

	const int index = selected_layout->indexOf(button);
	ui.selectedShiftLeft->setEnabled(index != 0);
	ui.selectedShiftRight->setEnabled(index != selected_layout->count() - 1);

	// Check if cliff tile
	const std::string tile_id = button->property("tileID").toString().toStdString();
	auto& cliff_tiles = map->terrain.cliff_to_ground_texture;
	if (map->terrain.ground_texture_to_id.contains(tile_id)) {
		const auto is_cliff_tile = std::ranges::find(cliff_tiles, map->terrain.ground_texture_to_id[tile_id]);
		ui.selectedRemove->setEnabled(is_cliff_tile == cliff_tiles.end());
	}
}

void TileSetter::available_tile_clicked(const QAbstractButton* button) const {
	ui.additionalTileLabel->setText("Tile: " + button->property("tileName").toString());

	// Check if tile was already in existing/modified tileset
	bool tile_already_added = false;
	for (auto&& i : selected_group->buttons()) {
		if (i->property("tileID") == button->property("tileID")) {
			tile_already_added = true;
		}
	}
	tile_already_added |= selected_group->buttons().size() >= 64;
	ui.additionalAdd->setDisabled(tile_already_added);
}

void TileSetter::shift_left() const {
	const auto selected_button = selected_group->checkedButton();
	if (!selected_button) {
		return;
	}

	const int index = selected_layout->indexOf(selected_button);
	selected_layout->move_widget(index - 1, selected_button);

	if (index - 1 == 0) {
		ui.selectedShiftLeft->setEnabled(false);
	}

	ui.selectedShiftRight->setEnabled(true);
}

void TileSetter::shift_right() const {
	const auto selected_button = selected_group->checkedButton();
	if (!selected_button) {
		return;
	}

	const int index = selected_layout->indexOf(selected_button);
	selected_layout->move_widget(index + 1, selected_button);

	if (index + 1 == selected_layout->count() - 1) {
		ui.selectedShiftRight->setEnabled(false);
	}

	ui.selectedShiftLeft->setEnabled(true);
}

void TileSetter::save_tiles() {
	std::vector<std::string> to_ids;
	for (auto&& j : selected_layout->items()) {
		to_ids.push_back(j->widget()->property("tileID").toString().toStdString());
	}

	from_to_id.resize(map->terrain.tileset_ids.size());
	for (size_t i = 0; i < map->terrain.tileset_ids.size(); i++) {
		const std::string from_id = map->terrain.tileset_ids[i];

		const auto found = std::ranges::find(to_ids, from_id);
		if (found != to_ids.end()) {
			from_to_id[i] =  found - to_ids.begin();
		} else {
			TilePicker replace_dialog(this, { from_id }, to_ids);
			connect(&replace_dialog, &TilePicker::tile_chosen, [&](std::string id, const std::string& to_id) {
				const auto tile_found = std::ranges::find(to_ids, to_id);
				from_to_id[i] = tile_found - to_ids.begin();
			});
			replace_dialog.exec();
		}
	}

	map->terrain.change_tileset(to_ids, from_to_id);
	close();
}
```

`src/menus/tile_setter.h`:

```h
#pragma once

#include <vector>
#include <QButtonGroup>
#include <QDialog>
#include "ui_tile_setter.h"

#include <vector>

import FlowLayout;

class TileSetter : public QDialog {
	Q_OBJECT

public:
	explicit TileSetter(QWidget* parent = nullptr);

private:
	void add_tile() const;
	void remove_tile() const;
	void update_available_tiles() const;
	void existing_tile_clicked(QAbstractButton* button) const;
	void available_tile_clicked(const QAbstractButton* button) const;
	void shift_left() const;
	void shift_right() const;
	void save_tiles();

	Ui::TileSetter ui;

	// QListWidget* widget_list = new QListWidget;

	QButtonGroup* selected_group = new QButtonGroup;
	QButtonGroup* available_group = new QButtonGroup;

	FlowLayout* selected_layout = new FlowLayout;
	FlowLayout* available_layout = new FlowLayout;

	std::vector<int> from_to_id;
};
```

`src/menus/tile_setter.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TileSetter</class>
 <widget class="QWidget" name="TileSetter">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>580</width>
    <height>340</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>0</width>
    <height>0</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>TileSetter</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <property name="sizeConstraint">
    <enum>QLayout::SetDefaultConstraint</enum>
   </property>
   <item>
    <widget class="QLabel" name="selectedTilesLabel">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="toolTip">
      <string>The tiles in the map tileset.</string>
     </property>
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:10pt; font-weight:600;&quot;&gt;Selected Tiles&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="selectedTileLabel">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="toolTip">
      <string>The current tilename.</string>
     </property>
     <property name="text">
      <string>Tile: </string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowlayout_placeholder_1">
     <property name="sizeConstraint">
      <enum>QLayout::SetDefaultConstraint</enum>
     </property>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QPushButton" name="selectedShiftLeft">
       <property name="toolTip">
        <string>Shifts the selected tile left.</string>
       </property>
       <property name="text">
        <string>Shift Left</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="selectedShiftRight">
       <property name="toolTip">
        <string>Shift the selected tile right.</string>
       </property>
       <property name="text">
        <string>Shift Right</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="selectedRemove">
       <property name="toolTip">
        <string>Removes the selected tile from the tleset.</string>
       </property>
       <property name="text">
        <string>Remove</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_3">
     <item>
      <widget class="QLabel" name="additionalTilesLabel">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="toolTip">
        <string>Tiles you can add to the map tileset.</string>
       </property>
       <property name="text">
        <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:10pt; font-weight:600;&quot;&gt;Additonal Tiles&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QComboBox" name="tileset">
       <property name="toolTip">
        <string>The tileset to choose additional tiles from.</string>
       </property>
       <property name="maxVisibleItems">
        <number>20</number>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLabel" name="additionalTileLabel">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="toolTip">
      <string>The current tilename.</string>
     </property>
     <property name="text">
      <string>Tile:</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowlayout_placeholder_2">
     <property name="sizeConstraint">
      <enum>QLayout::SetDefaultConstraint</enum>
     </property>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QPushButton" name="additionalAdd">
       <property name="enabled">
        <bool>false</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="toolTip">
        <string>Adds the selected additional tile to the map tileset.</string>
       </property>
       <property name="text">
        <string>Add</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>
```

`src/menus/unit_palette.cpp`:

```cpp
#include "unit_palette.h"

#include <QComboBox>
#include <QLineEdit>
#include <QListView>
#include <QAbstractProxyModel>
#include <QSortFilterProxyModel>

//#include "globals.h"
//#include <map_global.h>
#include <object_editor.h>

import std;
import TableModel;
import WindowHandler;
import MapGlobal;
import Globals;

UnitPalette::UnitPalette(QWidget* parent) : Palette(parent) {
	ui.setupUi(this);
	setAttribute(Qt::WA_DeleteOnClose);
	show();

	for (const auto& player : map->info.players) {
		std::string color_lookup = std::to_string(player.internal_number);
		if (color_lookup.size() == 1) {
			color_lookup = "0" + color_lookup;
		}

		const auto player_name = std::format("{} ({})", map->trigger_strings.string(player.name), world_edit_strings.data("WorldEditStrings", "WESTRING_UNITCOLOR_" + color_lookup));

		ui.player->addItem(QString::fromStdString(player_name), player.internal_number);
	}
	ui.player->addItem("Neutral Hostile", 24);
	ui.player->addItem("Neutral Passive", 27);

	QRibbonSection* selection_section = new QRibbonSection;
	selection_section->setText("Selection");

	selection_mode->setText("Selection\nMode");
	selection_mode->setIcon(QIcon("data/icons/Ribbon/select32x32.png"));
	selection_mode->setCheckable(true);
	selection_section->addWidget(selection_mode);

	selector = new UnitSelector(this);
	selector->setObjectName("selector");
	ui.verticalLayout->addWidget(selector);

	find_this = new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), this, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);
	find_parent = new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), parent, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);
	selection_mode->setShortCut(Qt::Key_Space, { this, parent });

	current_selection_section = new QRibbonSection;
	current_selection_section->setText("Current Selection");
	current_selection_section->setEnabled(false);

	QSmallRibbonButton* edit_in_oe = new QSmallRibbonButton;
	edit_in_oe->setText("Edit in OE");
	edit_in_oe->setIcon(QIcon("data/icons/Ribbon/objecteditor32x32.png"));

	QSmallRibbonButton* select_in_palette = new QSmallRibbonButton;
	select_in_palette->setText("Select in Palette");
	select_in_palette->setToolTip("Or click the unit with middle mouse button");
	select_in_palette->setIcon(QIcon("data/icons/Ribbon/units32x32.png"));

	QVBoxLayout* info_layout = new QVBoxLayout;
	info_layout->addWidget(selection_name);
	info_layout->addWidget(edit_in_oe);
	info_layout->addWidget(select_in_palette);

	current_selection_section->addLayout(info_layout);

	ribbon_tab->addSection(selection_section);
	ribbon_tab->addSection(current_selection_section);
	
	connect(selection_mode, &QRibbonButton::toggled, [&]() { brush.switch_mode(); });

	connect(ui.player, QOverload<int>::of(&QComboBox::currentIndexChanged), [&]() {
		brush.player_id = ui.player->currentData().toInt();
	});

	connect(find_this, &QShortcut::activated, [&]() {
		activateWindow();
		selector->search->setFocus();
		selector->search->selectAll();
	});

	connect(find_parent, &QShortcut::activated, [&]() {
		activateWindow();
		selector->search->setFocus();
		selector->search->selectAll();
	});

	
	connect(selector, &UnitSelector::unitSelected, [&](const std::string& id) { 
		brush.set_unit(id); 
		selection_mode->setChecked(false);
	});

	connect(edit_in_oe, &QSmallRibbonButton::clicked, [&]() {
		bool created;
		auto editor = window_handler.create_or_raise<ObjectEditor>(nullptr, created);
		const Unit* unit = *brush.selections.begin();
		if (items_slk.row_headers.contains(unit->id)) {
			editor->select_id(ObjectEditor::Category::item, unit->id);
		} else {
			editor->select_id(ObjectEditor::Category::unit, unit->id);
		}
	});

	connect(select_in_palette, &QSmallRibbonButton::clicked, [&]() {
		const Unit* unit= *brush.selections.begin();
		select_id_in_palette(unit->id);
	});

	connect(&brush, &UnitBrush::selection_changed, this, &UnitPalette::update_selection_info);
}

UnitPalette::~UnitPalette() {
	map->brush = nullptr;
}

bool UnitPalette::event(QEvent* e) {
	if (e->type() == QEvent::Close) {
		// Remove shortcut from parent
		find_this->setEnabled(false);
		find_parent->setEnabled(false);
		selection_mode->disconnectShortcuts();
		ribbon_tab->setParent(nullptr);
		delete ribbon_tab;
	} else if (e->type() == QEvent::WindowActivate) {
		find_this->setEnabled(true);
		find_parent->setEnabled(true);
		selection_mode->enableShortcuts();
		map->brush = &brush;
		emit ribbon_tab_requested(ribbon_tab, "Unit Palette");
	}
	return QWidget::event(e);
}

void UnitPalette::select_id_in_palette(std::string id) {
	selector->search->clear();

	const auto index = selector->filter_model->mapFromSource(selector->list_model->mapFromSource(units_table->rowIDToIndex(id)));
	selector->units->setCurrentIndex(index);
	emit selector->unitSelected(id);
}

void UnitPalette::deactivate(QRibbonTab* tab) {
	if (tab != ribbon_tab) {
		brush.clear_selection();
		selection_mode->disableShortcuts();
		find_this->setEnabled(false);
		find_parent->setEnabled(false);
	}
}

void UnitPalette::update_selection_info() {
	if (brush.selections.empty()) {
		if (current_selection_section->isEnabled()) {
			current_selection_section->setEnabled(false);
		}
		selection_name->setText("");
	} else {
		if (!current_selection_section->isEnabled()) {
			current_selection_section->setEnabled(true);
		}
		const Unit& unit = **brush.selections.begin();

		bool same_object = true;
		for (const auto& i : brush.selections) {
			same_object = same_object && i->id == unit.id;
		}

		// Set the name
		if (same_object) {
			auto index = units_table->index(units_slk.row_headers.at(unit.id), units_slk.column_headers.at("name"));
			selection_name->setText(units_table->data(index).toString());
		} else {
			selection_name->setText("Various");
		}
	}
}
```

`src/menus/unit_palette.h`:

```h
#pragma once

#include "ui_unit_palette.h"
#include "unit_brush.h"
#include "palette.h"
//#include "UnitSelector.h"

#include <QAbstractProxyModel>
#include <QSortFilterProxyModel>
#include <QLineEdit>
#include <QRadioButton>
#include <QCheckBox>
#include <QFormLayout>
#include <QDoubleValidator>
#include <QComboBox>
#include <QListView>
#include <QToolButton>
#include <QShortcut>
#include <QFrame>
#include <QGridLayout>
#include <QBoxLayout>
#include <QLabel>
#include <QMenu>
#include <QTabWidget>
#include <QStyle>
#include <QStyleOption>
#include <QPainter>
#include <QMap>
#include <QScrollArea>
#include <QPushButton>
#include <QKeySequence>

#include <string>

import UnitListModel;
import UnitSelector;
import QRibbon;

class UnitPalette : public Palette {
	Q_OBJECT

public:
	UnitPalette(QWidget* parent = nullptr);
	~UnitPalette();

private:
	bool event(QEvent* e) override;

	void select_id_in_palette(std::string id);

	Ui::UnitPalette ui;

	UnitBrush brush;

	QRibbonTab* ribbon_tab = new QRibbonTab;
	QRibbonButton* selection_mode = new QRibbonButton;

	UnitSelector* selector;
	
	QRibbonSection* current_selection_section = new QRibbonSection;
	QLabel* selection_name = new QLabel;

	QShortcut* find_this;
	QShortcut* find_parent;

public slots:
	void deactivate(QRibbonTab* tab) override;
	void update_selection_info();
};
```

`src/menus/unit_palette.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>UnitPalette</class>
 <widget class="QDialog" name="UnitPalette">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>244</width>
    <height>560</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Unit Palette</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Place as</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QComboBox" name="player">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>

```

`src/model_editor/model_editor.cpp`:

```cpp
#include "model_editor.h"

#include "model_editor_glwidget.h"

#include <QLabel>

import std;
import BinaryReader;
import Hierarchy;
import MDX;
import Utilities;

ModelEditor::ModelEditor(QWidget* parent) : QMainWindow(parent) {
	setWindowTitle("Model Editor");
	setAttribute(Qt::WA_DeleteOnClose);
	resize(1200, 800);

	dock_manager = new ads::CDockManager;
	dock_manager->setStyleSheet("");
	setCentralWidget(dock_manager);

	QLabel* image = new QLabel();
	image->setPixmap(QPixmap("data/icons/model_editor/background.png"));
	image->setAlignment(Qt::AlignCenter);

	const auto centraldock_widget = dock_manager->createDockWidget("CentralWidget");
	centraldock_widget->setWidget(image);
	centraldock_widget->setFeature(ads::CDockWidget::NoTab, true);
	dock_area = dock_manager->setCentralWidget(centraldock_widget);

	show();
}

std::expected<void, std::string> ModelEditor::open_model(const fs::path& path, const bool local_file) const {
	auto reader = [&] {
		if (local_file) {
			return read_file(path);
		} else {
			return hierarchy.open_file(path);
		}
	 }();

	if (!reader) {
		return std::unexpected(reader.error());
	}

	const auto mdx = std::make_shared<mdx::MDX>(reader.value());
	auto* gl_widget = new ModelEditorGLWidget(nullptr, mdx);

	auto* dock_tab = dock_manager->createDockWidget("");
	dock_tab->setFeature(ads::CDockWidget::DockWidgetFeature::DockWidgetDeleteOnClose, true);
	dock_tab->setWidget(gl_widget);
	// dock_tab->setObjectName(QString::fromStdString(item->id));
	dock_tab->setWindowTitle(QString::fromStdString(path.filename().string()));

	dock_manager->addDockWidget(ads::CenterDockWidgetArea, dock_tab, dock_area);
	return {};
}

```

`src/model_editor/model_editor.h`:

```h
#pragma once

#include <filesystem>
namespace fs = std::filesystem;
#include <expected>

#include "global_search.h"

#include <QMainWindow>
#include <QKeyEvent>

#include <DockManager.h>
#include <DockAreaWidget.h>

class ModelEditor : public QMainWindow {
	Q_OBJECT

public:
	explicit ModelEditor(QWidget* parent = nullptr);

	[[nodiscard]] std::expected<void, std::string> open_model(const fs::path& path, bool local_file) const;


	void keyPressEvent(QKeyEvent* event) override {
		if (event->key() == Qt::Key_Shift && !event->isAutoRepeat()) {
			if (double_shift_timer.isValid() && double_shift_timer.elapsed() < 400) {

				GlobalSearchWidget search_widget = new GlobalSearchWidget(this);
				double_shift_timer.invalidate();
			} else {
				double_shift_timer.start();
			}
		}
		QMainWindow::keyPressEvent(event);
	}

private:
	ads::CDockManager* dock_manager;
	ads::CDockAreaWidget* dock_area = nullptr;

	QElapsedTimer double_shift_timer;
};
```

`src/model_editor/model_editor_camera.cpp`:

```cpp
#include "model_editor_camera.h"

import std;

void ModelEditorCamera::reset() {
	distance = 20;
	horizontal_angle = 0.0f;
	vertical_angle = -0.977f;
	update(0);
}

void ModelEditorCamera::update(double delta) {
	direction = glm::vec3(
		std::cos(vertical_angle) * std::sin(horizontal_angle),
		std::cos(vertical_angle) * std::cos(horizontal_angle),
		std::sin(vertical_angle));

	direction = glm::normalize(direction);
	// Calculate axis directions for camera as referential point:
	// Z axis is simply the direction we are facing
	// X axis is then the cross product between the "fake" up and Z
	X = glm::cross(direction, up);
	X = glm::normalize(X);
	// Y Axis is cross product between X and Z, e.g is the real up
	Y = glm::cross(X, direction);
	Y = glm::normalize(Y);

	// The vector that is perpendicular to the up vector, thus points forward
	forward = glm::cross(X, up);

	projection = glm::perspective(fov, aspect_ratio, draw_distance_close, draw_distance_far);
	view = glm::lookAt(position - direction * distance, position, up);
	projection_view = projection * view;

	// for billboarded animated mesh
	glm::vec3 opDirection = -direction; // camera->position - this->position;

	glm::vec3 opDirectionZ = glm::normalize(glm::vec3(opDirection.x, opDirection.y, 0));
	float angleZ = glm::atan(opDirectionZ.y, opDirectionZ.x);
	glm::vec3 axisZ = glm::vec3(0, 0, 1);

	glm::vec3 opDirectionY = glm::normalize(opDirection);
	glm::vec3 axisY = glm::vec3(0, -1, 0);

	decomposed_rotation = glm::angleAxis(angleZ, axisZ) * glm::angleAxis(glm::asin(opDirectionY.z), axisY);
}

void ModelEditorCamera::mouse_move_event(QMouseEvent* event, const InputHandler& my_input_handler) {
	glm::vec2 diff = my_input_handler.mouse - my_input_handler.previous_mouse;

	if (rolling || (event->buttons() == Qt::RightButton && event->modifiers() & Qt::ControlModifier)) {
		horizontal_angle += diff.x * 0.01f;
		vertical_angle -= diff.y * 0.01f;
		vertical_angle = std::max(-glm::pi<float>() / 2.f + 0.001f, std::min(vertical_angle, glm::pi<float>() / 2.f - 0.001f));
		update(0);
	} else if (event->buttons() == Qt::RightButton) {
		position += X * (-diff.x * 0.025f * (distance / 30.f));
		position += forward * (-diff.y * 0.025f * (distance / 30.f));
		update(0);
	}
}

void ModelEditorCamera::mouse_scroll_event(QWheelEvent* event) {
	distance = std::clamp(distance * std::pow(0.999f, static_cast<float>(event->angleDelta().y())), 0.001f, 1000.f);
	update(0);
}

void ModelEditorCamera::mouse_press_event(QMouseEvent* event) {
	switch (event->button()) {
		case Qt::MiddleButton:
			rolling = true;
			break;
		default:
			break;
	}
}

void ModelEditorCamera::mouse_release_event(QMouseEvent* event) {
	switch (event->button()) {
		case Qt::MiddleButton:
			rolling = false;
			break;
		default:
			break;
	}
}
```

`src/model_editor/model_editor_camera.h`:

```h
#pragma once

#include <QMouseEvent>

import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;
import <glm/gtc/quaternion.hpp>;
import Camera;

struct ModelEditorCamera {
	glm::vec3 position = { 0, 0, 0 };

	float distance = 20.f;

	glm::vec3 direction = { 0, 1, 0 };
	glm::vec3 X = { 1, 0, 0 };
	glm::vec3 Y = { 0, 1, 0 };
	glm::vec3 up = { 0, 0, 1 };
	glm::vec3 forward = { 0, 1, 0 };

	float fov = 70.f;
	float aspect_ratio = 16.f / 9.f;
	float draw_distance_close = 0.05f;
	float draw_distance_far = 2000.f;
	float fov_rad = (glm::pi<double>() / 180.f) * static_cast<double>(fov); // Need radians
	float tan_height = 2.f * glm::tan(fov_rad * 0.5f);

	glm::mat4 projection = glm::perspective(fov, aspect_ratio, draw_distance_close, draw_distance_far);
	glm::mat4 view = glm::lookAt(position - direction * distance, position, up);
	glm::mat4 projection_view;

	glm::vec4 frustum_planes[6];

	// Used for decomposing camera information to get rotation, for camera-centric Billboarded model elements
	glm::vec3 decomposed_scale;
	glm::quat decomposed_rotation;
	glm::vec3 decomposed_translation;
	glm::vec3 decomposed_skew;
	glm::vec4 decomposed_perspective;

	float horizontal_angle = 0.f;
	float vertical_angle = -0.977f;

	bool rolling = false;

	void update(double delta);

	void mouse_move_event(QMouseEvent* event, const InputHandler& my_input_handler);
	void mouse_scroll_event(QWheelEvent* event);
	void mouse_press_event(QMouseEvent* event);
	void mouse_release_event(QMouseEvent* event);
	void reset();
};
```

`src/model_editor/model_editor_glwidget.cpp`:

```cpp
#include "model_editor_glwidget.h"

#include <QTimer>
#include <QPainter>
#include <QFileDialog>
#include <QSettings>
#include <QStandardPaths>
#include <QDesktopServices>

#include <qt_imgui/qt_imGui.h>

import std;
import OpenGLUtilities;
import BinaryReader;
import Hierarchy;
import MDX;
import Camera;
import ResourceManager;
import <imgui.h>;

namespace fs = std::filesystem;

// 2025/07/30 These aren't in the class due to some compiler issue with modules
InputHandler my_input_handler;
mdx::MDX::OptimizationStats stats;

ModelEditorGLWidget::ModelEditorGLWidget(QWidget* parent, std::shared_ptr<mdx::MDX> mdx) : QOpenGLWidget(parent), mdx(mdx) {
	makeCurrent();

	setMouseTracking(true);
	setFocus();
	setFocusPolicy(Qt::WheelFocus);

	connect(this, &QOpenGLWidget::frameSwapped, [&]() { update(); });
}

void ModelEditorGLWidget::initializeGL() {
	ref = QtImGui::initialize(this, false);

	glEnable(GL_DEPTH_TEST);
	glEnable(GL_CULL_FACE);
	glDepthFunc(GL_LEQUAL);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	glClearColor(0, 0, 0, 1);
	
	glGenVertexArrays(1, &vao);
	glBindVertexArray(vao);

	mesh = std::make_shared<EditableMesh>(mdx, std::nullopt);
	skeleton = SkeletalModelInstance(mdx);
	recenter_camera();

	shader = resource_manager.load<Shader>({ "data/shaders/editable_mesh_hd.vert", "data/shaders/editable_mesh_hd.frag" });
}

void ModelEditorGLWidget::resizeGL(const int w, const int h) {
	glViewport(0, 0, w, h);
	camera.aspect_ratio = double(w) / h;
	camera.update(delta);
	delta = elapsed_timer.nsecsElapsed() / 1'000'000'000.0;
}

void ModelEditorGLWidget::paintGL() {
	makeCurrent();
	
	delta = elapsed_timer.nsecsElapsed() / 1'000'000'000.0;
	elapsed_timer.start();

	skeleton.update_location(glm::vec3(0.f), glm::quat(), glm::vec3(1.f));
	skeleton.update(delta);

	camera.update(delta);

	glBindVertexArray(vao);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(true);
	glClearColor(0.3f, 0.3f, 0.3f, 1.f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	shader->use();
	mesh->render(0, skeleton, camera.projection_view, camera.direction);

	glEnable(GL_BLEND);

	glBindVertexArray(0);

	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	QtImGui::newFrame(ref);

	if (ImGui::Begin("General")) {
		ImGui::Text(std::format("FPS: {:.2f}", 1.0 / delta).c_str());

		if (ImGui::Button("Edit MDL")) {

			auto mdl = mesh->mdx->to_mdl();

			auto path = QStandardPaths::writableLocation(QStandardPaths::TempLocation) + "/" + QString::fromStdString(mesh->mdx->name) + ".mdl";

			std::ofstream file(path.toStdString());
			file.write(mdl.data(), mdl.size());
			file.close();

			QDesktopServices::openUrl(QUrl(path, QUrl::TolerantMode));
		}

		if (ImGui::Button("Open Model")) {
			const QSettings settings;

			const QString file_name = QFileDialog::getOpenFileName(this, "Open Model File",
															 settings.value("openDirectory", QDir::current().path()).toString(),
															 "MDX (*.mdx *.MDX)");

			if (file_name == "") {
				return;
			}

			const fs::path path = file_name.toStdString();
			if (path.extension() != ".mdx" && path.extension() != ".MDX") {
				throw;
			}

			BinaryReader reader = hierarchy.open_file(path).value();
			const auto mdx = std::make_shared<mdx::MDX>(reader);
			mesh = std::make_shared<EditableMesh>(mdx, std::nullopt);
			skeleton = SkeletalModelInstance(mdx);
			recenter_camera();
		}

		ImGui::Text(std::format("name: {}", mesh->mdx->name).c_str());

		size_t vertices = 0;
		size_t triangles = 0;
		for (const auto& i : mesh->mdx->geosets) {
			vertices += i.vertices.size();
			triangles += i.faces.size() / 3;
		}

		ImGui::Text(std::format("Vertices: {}", vertices).c_str());
		ImGui::Text(std::format("Triangles: {}", triangles).c_str());
	}
	ImGui::End();

	if (ImGui::Begin("Animation")) {
		ImGui::Text("Animation");
		ImGui::SameLine();
		if (ImGui::BeginCombo("##combo", mesh->mdx->sequences[skeleton.sequence_index].name.c_str())) {
			for (size_t i = 0; i < mesh->mdx->sequences.size(); i++) {
				if (ImGui::Selectable(mesh->mdx->sequences[i].name.c_str(), i == skeleton.sequence_index)) {
					skeleton.set_sequence(i);
				}
				if (i == skeleton.sequence_index) {
					ImGui::SetItemDefaultFocus();
				}
			}
			ImGui::EndCombo();
		}

		ImGui::Text(std::format("Start frame: {}", mesh->mdx->sequences[skeleton.sequence_index].start_frame).c_str());
		ImGui::Text(std::format("End frame: {}", mesh->mdx->sequences[skeleton.sequence_index].end_frame).c_str());
		ImGui::Text(std::format("Current frame: {}", skeleton.current_frame).c_str());
		ImGui::Text(std::format("Looping: {}", mesh->mdx->sequences[skeleton.sequence_index].flags == mdx::Sequence::Flags::looping).c_str());
	}
	ImGui::End();

	// if (ImGui::Begin("Optimizer")) {
	// 	static float max_error = 0.0001f;
	// 	if (ImGui::SliderFloat("Max error", &max_error, 0.0f, 0.01f, "%.5f")) {
	// 		BinaryReader reader = hierarchy.open_file("units/human/footman/footman.mdx").value();
	// 		auto mdx = std::make_shared<mdx::MDX>(reader);
	// 		stats = mdx->optimize(max_error);
	//
	// 		const auto writer = mdx->save();
	// 		optimization_file_size_reduction = std::ssize(reader.buffer) - std::ssize(writer.buffer);
	// 		optimization_file_size_reduction_percent = static_cast<float>(std::ssize(writer.buffer) - std::ssize(reader.buffer)) / std::ssize(reader.buffer) * 100.f;
	//
	// 		mesh = std::make_shared<EditableMesh>(mdx, std::nullopt);
	// 		skeleton = SkeletalModelInstance(mesh->mdx);
	// 	}
	// }
	// ImGui::End();
	//
	// if (ImGui::Begin("Optimization Stats")) {
	// 	if (optimization_file_size_reduction >= 0) {
	// 		ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Size change: %i KiB (%.2f%%) less", optimization_file_size_reduction / 1024, optimization_file_size_reduction_percent);
	// 	} else {
	// 		ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "Size change: %i KiB (%.2f%%) more", optimization_file_size_reduction / 1024, optimization_file_size_reduction_percent);
	// 	}
	//
	// 	ImGui::Text("Materials removed %i", stats.materials_removed);
	// 	ImGui::Text("Textures removed %i", stats.textures_removed);
	//
	// 	if (ImGui::BeginTable("Optimization Stats", 3)) {
	// 		ImGui::TableSetupColumn("Type");
	// 		ImGui::TableSetupColumn("Count");
	// 		ImGui::TableSetupColumn("Removed");
	// 		ImGui::TableHeadersRow();
	//
	// 		ImGui::TableNextColumn();
	// 		ImGui::Text("Constant tracks");
	// 		ImGui::TableNextColumn();
	// 		ImGui::Text("%i", stats.constant_tracks);
	// 		ImGui::TableNextColumn();
	// 		{
	// 			const auto percent_removed = stats.constant_tracks_removed > 0 ? static_cast<float>(stats.constant_tracks_removed) / stats.constant_tracks * 100.f : 0.f;
	// 			ImGui::Text("%i (%.2f%%)", stats.constant_tracks_removed, percent_removed);
	// 		}
	//
	// 		ImGui::TableNextColumn();
	// 		ImGui::Text("Linear tracks");
	// 		ImGui::TableNextColumn();
	// 		ImGui::Text("%i", stats.linear_tracks);
	// 		ImGui::TableNextColumn();
	// 		{
	// 			const auto percent_removed = stats.linear_tracks_removed > 0 ? static_cast<float>(stats.linear_tracks_removed) / stats.linear_tracks * 100.f : 0.f;
	// 			ImGui::Text("%i (%.2f%%)", stats.linear_tracks_removed, percent_removed);
	// 		}
	//
	// 		ImGui::TableNextColumn();
	// 		ImGui::Text("Bezier tracks");
	// 		ImGui::TableNextColumn();
	// 		ImGui::Text("%i", stats.bezier_tracks);
	// 		ImGui::TableNextColumn();
	// 		{
	// 			const auto percent_removed = stats.bezier_tracks_removed > 0 ? static_cast<float>(stats.bezier_tracks_removed) / stats.bezier_tracks * 100.f : 0.f;
	// 			ImGui::Text("%i (%.2f%%)", stats.bezier_tracks_removed, percent_removed);
	// 		}
	//
	// 		ImGui::TableNextColumn();
	// 		ImGui::Text("Hermite tracks");
	// 		ImGui::TableNextColumn();
	// 		ImGui::Text("%i", stats.hermite_tracks);
	// 		ImGui::TableNextColumn();
	// 		{
	// 			const auto percent_removed = stats.hermite_tracks_removed > 0 ? static_cast<float>(stats.hermite_tracks_removed) / stats.hermite_tracks * 100.f : 0.f;
	// 			ImGui::Text("%i (%.2f%%)", stats.hermite_tracks_removed, percent_removed);
	// 		}
	//
	// 		ImGui::EndTable();
	// 	}
	// }
	// ImGui::End();

	ImGui::Render();
	QtImGui::render(ref);
}

void ModelEditorGLWidget::keyPressEvent(QKeyEvent* event) {
	my_input_handler.keys_pressed.emplace(event->key());
}

void ModelEditorGLWidget::keyReleaseEvent(QKeyEvent* event) {
	my_input_handler.keys_pressed.erase(event->key());
}

void ModelEditorGLWidget::mouseMoveEvent(QMouseEvent* event) {
	my_input_handler.mouse_move_event(event);
	camera.mouse_move_event(event, my_input_handler);
}

void ModelEditorGLWidget::mousePressEvent(QMouseEvent* event) {
	makeCurrent();
	
	camera.mouse_press_event(event);
}

void ModelEditorGLWidget::mouseReleaseEvent(QMouseEvent* event) {
	camera.mouse_release_event(event);
}

void ModelEditorGLWidget::wheelEvent(QWheelEvent* event) {
	camera.mouse_scroll_event(event);
}

void ModelEditorGLWidget::recenter_camera() {
	// Fit mesh extents AABB into screen
	const auto& extent = mesh->mdx->sequences[skeleton.sequence_index].extent;
	const glm::vec3 size = extent.maximum - extent.minimum;
	const float radius = length(size) * 0.5f * 1.1f;
	const float dist = radius / std::sin(camera.fov_rad * 0.5f);
	camera.distance = dist;
	camera.position.z = extent.minimum.z + size.z / 2.f;
}
```

`src/model_editor/model_editor_glwidget.h`:

```h
#pragma once

#include <glad/glad.h>
#include <memory>
#define QT_NO_OPENGL
#include <QObject>
#include <QOpenGLWidget>
#include "qt_imgui/qt_imGui.h"
#include <model_editor/model_editor_camera.h>

import EditableMesh;
import SkeletalModelInstance;
import MDX;
import Shader;

class ModelEditorGLWidget: public QOpenGLWidget {
	Q_OBJECT

  public:
	QElapsedTimer elapsed_timer;
	GLuint vao;

	double delta = 0.0;

	ModelEditorGLWidget() = delete;
	explicit ModelEditorGLWidget(QWidget* parent, std::shared_ptr<mdx::MDX> model);
	~ModelEditorGLWidget() = default;

	void initializeGL() override;
	void resizeGL(int w, int h) override;
	void paintGL() override;

	void keyPressEvent(QKeyEvent* event) override;
	void keyReleaseEvent(QKeyEvent* event) override;
	void mouseMoveEvent(QMouseEvent* event) override;
	void mousePressEvent(QMouseEvent* event) override;
	void mouseReleaseEvent(QMouseEvent* event) override;
	void wheelEvent(QWheelEvent* event) override;

	std::shared_ptr<mdx::MDX> mdx;
	std::shared_ptr<EditableMesh> mesh;
	SkeletalModelInstance skeleton;
	std::shared_ptr<Shader> shader;

	int64_t optimization_file_size_reduction = 0;
	float optimization_file_size_reduction_percent = 0.f;

	QtImGui::RenderRef ref = nullptr;
	ModelEditorCamera camera;

	void recenter_camera();
};

```

`src/models/list/ability_list_model.ixx`:

```ixx
module;

#include <QSortFilterProxyModel>

export module AbilityListModel;

import std;
import Globals;
import BaseListModel;

export class AbilityListModel: public BaseListModel {
	Q_OBJECT

  public:
	explicit AbilityListModel(QObject* parent = nullptr) : BaseListModel(abilities_slk, parent) {}

	[[nodiscard]]
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override {
		if (!proxyIndex.isValid()) {
			return {};
		}

		return sourceModel()->index(proxyIndex.row(), abilities_slk.column_headers.at("name"));
	}

	[[nodiscard]]
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		switch (role) {
			case Qt::DisplayRole:
				return mapToSource(index).data(role).toString() + " " + QString::fromUtf8(abilities_slk.data<std::string_view>("editorsuffix", index.row()));
			case Qt::UserRole:
				return QString::fromStdString("abilities/" + abilities_slk.data("race", index.row()) + "/" + abilities_slk.index_to_row.at(index.row()));
			case Qt::DecorationRole:
				return sourceModel()->index(index.row(), abilities_slk.column_headers.at("art")).data(role);

			default:
				return BaseListModel::data(index, role);
		}
	}
};

export class AbilityListFilter: public QSortFilterProxyModel {
	Q_OBJECT

	[[nodiscard]]
	bool filterAcceptsRow(const int sourceRow, const QModelIndex& sourceParent) const override {
		if (!filterRegularExpression().pattern().isEmpty()) {
			if (QString::fromStdString(abilities_slk.index_to_row.at(sourceRow)).contains(filterRegularExpression())) {
				return true;
			}

			const QModelIndex source_index = sourceModel()->index(sourceRow, 0);
			return source_index.data().toString().contains(filterRegularExpression());
		}
		return true;
	}

  public:
	using QSortFilterProxyModel::QSortFilterProxyModel;
};

#include "ability_list_model.moc"

```

`src/models/list/base_list_model.ixx`:

```ixx
module;

#include <QIdentityProxyModel>
#include <QSortFilterProxyModel>
#include <QSize>

export module BaseListModel;

import Globals;
import SLK;
import TableModel;

export class BaseListModel: public QIdentityProxyModel {
	Q_OBJECT

  public:
	[[nodiscard]]
	QModelIndex mapFromSource(const QModelIndex& sourceIndex) const override {
		if (!sourceIndex.isValid()) {
			return {};
		}

		return createIndex(sourceIndex.row(), 0);
	}

	[[nodiscard]]
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override {
		if (!proxyIndex.isValid()) {
			return {};
		}

		return sourceModel()->index(proxyIndex.row(), slk.column_headers.at("name"));
	}

	[[nodiscard]]
	QVariant data(const QModelIndex& index, const int role) const override {
		if (!index.isValid()) {
			return {};
		}

		switch (role) {
			case Qt::DisplayRole:
				return mapToSource(index).data(role).toString();
			case Qt::DecorationRole:
				return sourceModel()->index(index.row(), items_slk.column_headers.at("art")).data(role);
			default:
				return mapToSource(index).data(role);
		}
	}

	[[nodiscard]]
	Qt::ItemFlags flags(const QModelIndex& index) const override {
		if (!index.isValid()) {
			return Qt::NoItemFlags;
		}

		return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
	}

	[[nodiscard]]
	int rowCount(const QModelIndex& parent) const override {
		return sourceModel()->rowCount();
	}

	[[nodiscard]]
	int columnCount(const QModelIndex& parent) const override {
		return 1;
	}

	[[nodiscard]]
	QModelIndex index(const int row, const int column, const QModelIndex& parent) const override {
		return createIndex(row, column);
	}

	[[nodiscard]]
	QModelIndex parent(const QModelIndex& child) const override {
		return QModelIndex();
	}

	explicit BaseListModel(const slk::SLK& slk, QObject* parent = nullptr) : QIdentityProxyModel(parent), slk(slk) {}

	const slk::SLK& slk;
};

#include "base_list_model.moc"

```

`src/models/list/buff_list_model.ixx`:

```ixx
module;

#include <QSortFilterProxyModel>

export module BuffListModel;

import BaseListModel;
import Globals;

export class BuffListModel: public BaseListModel {
	Q_OBJECT

  public:
	explicit BuffListModel(QObject* parent = nullptr) : BaseListModel(buff_slk, parent) {}

	[[nodiscard]]
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override {
		if (!proxyIndex.isValid()) {
			return {};
		}

		return sourceModel()->index(proxyIndex.row(), buff_slk.column_headers.at("editorname"));
	}

	[[nodiscard]]
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		switch (role) {
			case Qt::DisplayRole: {
				const QString editorname = sourceModel()->index(index.row(), buff_slk.column_headers.at("editorname")).data(role).toString();
				const QString editorsuffix = QString::fromUtf8(buff_slk.data<std::string_view>("editorsuffix", index.row()));
				if (editorname.isEmpty()) {
					return sourceModel()->index(index.row(), buff_slk.column_headers.at("bufftip")).data(role).toString() + " " + editorsuffix;;
				} else {
					return editorname + " " + editorsuffix;
				}
			}
			case Qt::UserRole:
				return QString::fromStdString("buffs/" + buff_slk.data("race", index.row()) + "/" + buff_slk.index_to_row.at(index.row()));
			case Qt::DecorationRole:
				return sourceModel()->index(index.row(), buff_slk.column_headers.at("buffart")).data(role);
			default:
				return BaseListModel::data(index, role);
		}
	}
};

export class BuffListFilter: public QSortFilterProxyModel {
	Q_OBJECT

	[[nodiscard]]
	bool filterAcceptsRow(const int sourceRow, const QModelIndex& sourceParent) const override {
		if (!filterRegularExpression().pattern().isEmpty()) {
			if (QString::fromStdString(buff_slk.index_to_row.at(sourceRow)).contains(filterRegularExpression())) {
				return true;
			}

			const QModelIndex source_index = sourceModel()->index(sourceRow, 0);
			return source_index.data().toString().contains(filterRegularExpression());
		}

		return true;
	}

  public:
	using QSortFilterProxyModel::QSortFilterProxyModel;
};

#include "buff_list_model.moc"

```

`src/models/list/destructible_list_model.ixx`:

```ixx
module;

#include <QSortFilterProxyModel>

export module DestructibleListModel;

import std;
import QIconResource;
import ResourceManager;
import Globals;
import BaseListModel;

export class DestructableListModel: public BaseListModel {
	Q_OBJECT

  public:
	explicit DestructableListModel(QObject* parent = nullptr) : BaseListModel(destructibles_slk, parent) {
		for (auto&& [key, value] : world_edit_data.section("DestructibleCategories")) {
			const std::string tileset_key = value.front();
			icons[key.front()] = resource_manager.load<QIconResource>(value[1]);
		}
	}

	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override {
		if (!proxyIndex.isValid()) {
			return {};
		}

		return sourceModel()->index(proxyIndex.row(), destructibles_slk.column_headers.at("name"));
	}

	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		switch (role) {
			case Qt::DisplayRole:
				return sourceModel()->data(mapToSource(index), role).toString() + " " + QString::fromUtf8(destructibles_slk.data<std::string_view>("editorsuffix", index.row()));
			case Qt::UserRole:
				return QString::fromStdString("destructibles/" + destructibles_slk.data("category", index.row()) + "/" + destructibles_slk.index_to_row.at(index.row()));
			case Qt::DecorationRole: {
				const char category = destructibles_slk.data<std::string_view>("category", index.row()).front();
				if (icons.contains(category)) {
					return icons.at(category)->icon;
				} else {
					return {};
				}
			}
			default:
				return BaseListModel::data(index, role);
		}
	}

  private:
	std::unordered_map<char, std::shared_ptr<QIconResource>> icons;
};

export class DestructableListFilter: public QSortFilterProxyModel {
	[[nodiscard]] bool filterAcceptsRow(const int sourceRow, const QModelIndex& sourceParent) const override {
		if (!filterRegularExpression().pattern().isEmpty()) {
			if (QString::fromStdString(destructibles_slk.index_to_row.at(sourceRow)).contains(filterRegularExpression())) {
				return true;
			}

			const QModelIndex source_index = sourceModel()->index(sourceRow, 0);
			return source_index.data().toString().contains(filterRegularExpression());
		}

		if (filterCategory) {
			if (destructibles_slk.data<std::string_view>("category", sourceRow) != filterCategory->toStdString()) {
				return false;
			}
		}

		if (filterTileset) {
			const std::string_view tilesets = destructibles_slk.data<std::string_view>("tilesets", sourceRow);
			if (tilesets.find('*') == std::string::npos && tilesets.find(*filterTileset) == std::string::npos && filterTileset != '*') {
				return false;
			}
		}

		return true;
	}

	[[nodiscard]] bool lessThan(const QModelIndex& left, const QModelIndex& right) const override {
		return destructibles_slk.data<std::string_view>("name", left.row()) < destructibles_slk.data<std::string_view>("name", right.row());
	}

	std::optional<QString> filterCategory;
	std::optional<char> filterTileset;

  public:
	void setFilterCategory(const QString& category) {
		filterCategory = category;
		invalidateFilter();
	}

	void setFilterTileset(char tileset) {
		filterTileset = tileset;
		invalidateFilter();
	}

	using QSortFilterProxyModel::QSortFilterProxyModel;
};

#include "destructible_list_model.moc"

```

`src/models/list/doodad_list_model.ixx`:

```ixx
module;

#include <QSortFilterProxyModel>

export module DoodadListModel;

import std;
import QIconResource;
import ResourceManager;
import Globals;
import BaseListModel;

export class DoodadListModel: public BaseListModel {
	Q_OBJECT

  public:
	explicit DoodadListModel(QObject* parent) : BaseListModel(doodads_slk, parent) {
		for (auto&& [key, value] : world_edit_data.section("DoodadCategories")) {
			const std::string tileset_key = value.front();
			icons[key.front()] = resource_manager.load<QIconResource>(value[1]);
		}
	}

	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override {
		if (!proxyIndex.isValid()) {
			return {};
		}

		return sourceModel()->index(proxyIndex.row(), doodads_slk.column_headers.at("name"));
	}

	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		switch (role) {
			case Qt::DisplayRole:
				return sourceModel()->data(mapToSource(index), role).toString();
			case Qt::UserRole:
				return QString::fromStdString("doodads/" + doodads_slk.data("category", index.row()) + "/" + doodads_slk.index_to_row.at(index.row()));
			case Qt::DecorationRole: {
				const char category = doodads_slk.data<std::string_view>("category", index.row()).front();
				if (icons.contains(category)) {
					return icons.at(category)->icon;
				} else {
					return {};
				}
			}
			default:
				return BaseListModel::data(index, role);
		}
	}

  private:
	std::unordered_map<char, std::shared_ptr<QIconResource>> icons;
};

export class DoodadListFilter : public QSortFilterProxyModel {
	[[nodiscard]] bool filterAcceptsRow(const int sourceRow, const QModelIndex& sourceParent) const override {
		if (!filterRegularExpression().pattern().isEmpty()) {
			if (QString::fromStdString(doodads_slk.index_to_row.at(sourceRow)).contains(filterRegularExpression())) {
				return true;
			}

			const QModelIndex source_index = sourceModel()->index(sourceRow, 0);
			return source_index.data().toString().contains(filterRegularExpression());
		}

		if (filterCategory) {
			if (doodads_slk.data<std::string_view>("category", sourceRow) != filterCategory->toStdString()) {
				return false;
			}
		}

		if (filterTileset) {
			const std::string_view tilesets = doodads_slk.data<std::string_view>("tilesets", sourceRow);
			if (tilesets.find('*') == std::string::npos && tilesets.find(*filterTileset) == std::string::npos && filterTileset != '*') {
				return false;
			}
		}

		return true;
	}

	bool lessThan(const QModelIndex& left, const QModelIndex& right) const override {
		return doodads_slk.data<std::string_view>("name", left.row()) < doodads_slk.data<std::string_view>("name", right.row());
	}

	std::optional<QString> filterCategory;
	std::optional<char> filterTileset;

public:
	void setFilterCategory(const QString& category) {
		filterCategory = category;
		invalidateFilter();
	}

	void setFilterTileset(const char tileset) {
		filterTileset = tileset;
		invalidateFilter();
	}

	using QSortFilterProxyModel::QSortFilterProxyModel;
};

#include "doodad_list_model.moc"

```

`src/models/list/item_list_model.ixx`:

```ixx
module;

#include <QSortFilterProxyModel>

export module ItemListModel;

import Globals;
import BaseListModel;

export class ItemListModel: public BaseListModel {
	Q_OBJECT

  public:
	explicit ItemListModel(QObject* parent = nullptr) : BaseListModel(items_slk, parent) {}

	[[nodiscard]]
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override {
		if (!proxyIndex.isValid()) {
			return {};
		}

		return sourceModel()->index(proxyIndex.row(), items_slk.column_headers.at("name"));
	}

	[[nodiscard]]
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		switch (role) {
			case Qt::DisplayRole:
				return mapToSource(index).data(role).toString();
			case Qt::UserRole:
				return QString::fromStdString("items/" + items_slk.data("class", index.row()) + "/" + items_slk.index_to_row.at(index.row()));
			case Qt::DecorationRole:
				return sourceModel()->index(index.row(), items_slk.column_headers.at("art")).data(role);
			default:
				return BaseListModel::data(index, role);
		}
	}
};

export class ItemListFilter: public QSortFilterProxyModel {
	Q_OBJECT

	[[nodiscard]]
	bool filterAcceptsRow(const int sourceRow, const QModelIndex& sourceParent) const override {
		if (!filterRegularExpression().pattern().isEmpty()) {
			if (QString::fromStdString(items_slk.index_to_row.at(sourceRow)).contains(filterRegularExpression())) {
				return true;
			}

			const QModelIndex source_index = sourceModel()->index(sourceRow, 0);
			return source_index.data().toString().contains(filterRegularExpression());
		}
		return true;
	}

public:
	using QSortFilterProxyModel::QSortFilterProxyModel;
};

#include "item_list_model.moc"

```

`src/models/list/unit_list_model.ixx`:

```ixx
module;

#include <QSortFilterProxyModel>
#include <QSize>

export module UnitListModel;

import BaseListModel;
import Globals;

export class UnitListModel: public BaseListModel {
	Q_OBJECT

  public:
	explicit UnitListModel(QObject* parent = nullptr) : BaseListModel(units_slk, parent) {}

	[[nodiscard]]
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override {
		if (!proxyIndex.isValid()) {
			return {};
		}

		return sourceModel()->index(proxyIndex.row(), units_slk.column_headers.at("name"));
	}

	[[nodiscard]]
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		switch (role) {
			case Qt::DisplayRole:
				return mapToSource(index).data(role).toString() + " " + QString::fromUtf8(units_slk.data<std::string_view>("editorsuffix", index.row()));
			case Qt::UserRole:
				return QString::fromStdString("units/" + units_slk.data("race", index.row()) + "/" + units_slk.index_to_row.at(index.row()));
			case Qt::DecorationRole:
				return sourceModel()->index(index.row(), units_slk.column_headers.at("art")).data(role);
			default:
				return BaseListModel::data(index, role);
		}
	}
};

export class UnitListFilter: public QSortFilterProxyModel {
	Q_OBJECT

	[[nodiscard]]
	bool filterAcceptsRow(const int sourceRow, const QModelIndex& sourceParent) const override {
		if (!filterRegularExpression().pattern().isEmpty()) {
			if (QString::fromStdString(units_slk.index_to_row.at(sourceRow)).contains(filterRegularExpression())) {
				return true;
			}

			const QModelIndex source_index = sourceModel()->index(sourceRow, 0);
			return source_index.data().toString().contains(filterRegularExpression());
		}

		if (filterRace) {
			if (units_slk.data<std::string_view>("race", sourceRow) != filterRace->toStdString()) {
				return false;
			}
		}

		return true;
	}

	[[nodiscard]]
	bool lessThan(const QModelIndex& left, const QModelIndex& right) const override {
		QString leftIndex = "0";
		{
			const bool isHostile = units_slk.data<std::string_view>("hostilepal", left.row()) == "1";
			const bool isBuilding = units_slk.data<std::string_view>("isbldg", left.row()) == "1";
			const bool isHero = isupper(units_slk.index_to_row.at(left.row()).front());
			const bool isSpecial = units_slk.data<std::string_view>("special", left.row()) == "1";

			if (isSpecial) {
				leftIndex = "3";
			} else if (isBuilding) {
				leftIndex = "1";
			} else if (isHero) {
				leftIndex = "2";
			}
			leftIndex += QString::fromUtf8(units_slk.data<std::string_view>("name", left.row()));
		}

		QString rightIndex = "0";
		{
			const bool isHostile = units_slk.data<std::string_view>("hostilepal", right.row()) == "1";
			const bool isBuilding = units_slk.data<std::string_view>("isbldg", right.row()) == "1";
			const bool isHero = isupper(units_slk.index_to_row.at(right.row()).front());
			const bool isSpecial = units_slk.data<std::string_view>("special", right.row()) == "1";

			if (isSpecial) {
				rightIndex = "3";
			} else if (isBuilding) {
				rightIndex = "1";
			} else if (isHero) {
				rightIndex = "2";
			}
			rightIndex += QString::fromUtf8(units_slk.data<std::string_view>("name", right.row()));
		}

		return leftIndex < rightIndex;
	}

	std::optional<QString> filterRace;

  public:
	using QSortFilterProxyModel::QSortFilterProxyModel;

  public slots:

	void setFilterRace(const QString& race) {
		filterRace = race;
		invalidateFilter();
	}
};

#include "unit_list_model.moc"

```

`src/models/list/upgrade_list_model.ixx`:

```ixx
module;

#include <QSortFilterProxyModel>

export module UpgradeListModel;

import BaseListModel;
import Globals;

export class UpgradeListModel: public BaseListModel {
	Q_OBJECT

  public:
	explicit UpgradeListModel(QObject* parent = nullptr) : BaseListModel(upgrade_slk, parent) {}

	[[nodiscard]]
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override {
		if (!proxyIndex.isValid()) {
			return {};
		}

		return sourceModel()->index(proxyIndex.row(), upgrade_slk.column_headers.at("name1"));
	}

	[[nodiscard]]
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		switch (role) {
			case Qt::DisplayRole:
				return mapToSource(index).data(role).toString() + " " + QString::fromUtf8(upgrade_slk.data<std::string_view>("editorsuffix", index.row()));
			case Qt::UserRole:
				return QString::fromStdString("upgrades/" + upgrade_slk.data("race", index.row()) + "/" + upgrade_slk.index_to_row.at(index.row()));
			case Qt::DecorationRole:
				return sourceModel()->index(index.row(), upgrade_slk.column_headers.at("art1")).data(role);
			default:
				return BaseListModel::data(index, role);
		}
	}
};

export class UpgradeListFilter: public QSortFilterProxyModel {
	Q_OBJECT

	[[nodiscard]]
	bool filterAcceptsRow(const int sourceRow, const QModelIndex& sourceParent) const override {
		if (!filterRegularExpression().pattern().isEmpty()) {
			if (QString::fromStdString(upgrade_slk.index_to_row.at(sourceRow)).contains(filterRegularExpression())) {
				return true;
			}

			const QModelIndex source_index = sourceModel()->index(sourceRow, 0);
			return source_index.data().toString().contains(filterRegularExpression());
		}

		return true;
	}


  public:
	using QSortFilterProxyModel::QSortFilterProxyModel;

};

#include "upgrade_list_model.moc"

```

`src/models/single_model.cpp`:

```cpp
#include "single_model.h"

#include "model_view.h"

#include <QPainter>
#include <QPlainTextEdit>
#include <QDialogButtonBox>
#include <QTimer>
#include <QSpinBox>
#include <QCheckBox>
#include <QListWidget>
#include <QPushButton>
#include <QTreeView>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QSortFilterProxyModel>

#include "object_editor/icon_view.h"

import std;
import BaseTreeModel;
import AbilityTreeModel;
import UpgradeTreeModel;
import UnitTreeModel;
import UnitSelector;
import Utilities;
import Globals;

SingleModel::SingleModel(TableModel* table, QObject* parent) : QAbstractProxyModel(parent) {
	slk = table->slk;
	meta_slk = table->meta_slk;
	setSourceModel(table);
	connect(this, &SingleModel::dataChanged, [this](const auto& index) {
		if (!index.isValid()) {
			return;
		}
		if (id_mapping[index.row()].field == "levels" || id_mapping[index.row()].field == "maxlevel" || id_mapping[index.row()].field == "numvar") {
			buildMapping();
		}
	});
}

QModelIndex SingleModel::mapFromSource(const QModelIndex& sourceIndex) const {
	if (!sourceIndex.isValid()) {
		return {};
	}

	if (sourceIndex.row() != slk->row_headers.at(id)) {
		std::print("Invalid ID for SLK {}\n", id);
		return {};
	}

	const std::string& field = slk->index_to_column.at(sourceIndex.column());
	for (size_t i = 0; i < id_mapping.size(); i++) {
		if (id_mapping[i].field == field) {
			//std::print("Found {} at {} {} {}\n", field, i, headerData(i, Qt::Vertical, Qt::DisplayRole).toString().toStdString(), meta_slk->data("displayname", id_mapping[i].key));
			return createIndex(i, 0);
		}
	}
	std::print("Not found {}\t{}\n", sourceIndex.row(), sourceIndex.column());
	return {};
}

QModelIndex SingleModel::mapToSource(const QModelIndex& proxyIndex) const {
	if (!proxyIndex.isValid()) {
		return {};
	}

	const std::string& column = id_mapping[proxyIndex.row()].field;
	return sourceModel()->index(slk->row_headers.at(id), slk->column_headers.at(column));
}

QVariant SingleModel::data(const QModelIndex& index, int role) const {
	if (role != Qt::ForegroundRole) {
		return QAbstractProxyModel::data(index, role);
	}

	if (slk->shadow_data.contains(id) && slk->shadow_data.at(id).contains(id_mapping[index.row()].field)) {
		return QColor("violet");
	}

	return {};
}

QVariant SingleModel::headerData(int section, Qt::Orientation orientation, int role) const {
	if (role == Qt::DisplayRole) {
		if (orientation == Qt::Orientation::Vertical) {
			const std::string_view category = world_edit_data.data<std::string_view>("ObjectEditorCategories", meta_slk->data<std::string_view>("category", id_mapping[section].key));
			const auto category2 = string_replaced(category, "&", "");
			const std::string_view display_name = meta_slk->data<std::string_view>("displayname", id_mapping[section].key);

			if (id_mapping[section].level > 0) {
				return QString::fromStdString(std::format("{} - {} - Level {} ({})", category2, display_name, id_mapping[section].level, id_mapping[section].key));
			} else {
				return QString::fromStdString(std::format("{} - {} ({})", category2, display_name, id_mapping[section].key));
			}
		} else {
			return "UnitID";
		}
	} else if (role == Qt::ForegroundRole) {
		if (orientation == Qt::Orientation::Vertical) {
			if (slk->shadow_data.contains(id) && slk->shadow_data.at(id).contains(id_mapping[section].field)) {
				return QColor("violet");
			} else {
				return QColor("white");
			}
		}
	}
	return QAbstractProxyModel::headerData(section, orientation, role);
}

bool SingleModel::setData(const QModelIndex& index, const QVariant& value, int role) {
	// Force a header redraw because the header text should change color depending on whether the data field is a custom value or not
	emit headerDataChanged(Qt::Orientation::Vertical, index.row(), index.row());
	return QAbstractProxyModel::setData(index, value, role);
}

int SingleModel::rowCount(const QModelIndex& parent) const {
	return id_mapping.size();
}

int SingleModel::columnCount(const QModelIndex& parent) const {
	return 1;
}

QModelIndex SingleModel::index(int row, int column, const QModelIndex& parent) const {
	return createIndex(row, column);
}

QModelIndex SingleModel::parent(const QModelIndex& child) const {
	return QModelIndex();
}

void SingleModel::setSourceModel(QAbstractItemModel* sourceModel) {
	beginResetModel();

	if (this->sourceModel()) {
		disconnect(sourceModel, &QAbstractItemModel::dataChanged, this, &SingleModel::sourceDataChanged);
	}

	QAbstractProxyModel::setSourceModel(sourceModel);

	connect(sourceModel, &QAbstractItemModel::dataChanged, this, &SingleModel::sourceDataChanged);

	endResetModel();
}

std::string SingleModel::getID() const {
	return id;
}

void SingleModel::setID(const std::string newID) {
	id = newID;
	buildMapping();
}

void SingleModel::buildMapping() {
	beginResetModel();
	id_mapping.clear();

	for (const auto& [key, index] : meta_slk->row_headers) {
		// Unit an ability SLKs contain usespecific, but only abilities use `usespecific`, the cell is always empty for units.
		const std::string_view use_specific = meta_slk->data<std::string_view>("usespecific", key);
		const std::string_view not_specific = meta_slk->data<std::string_view>("notspecific", key);
		if (!use_specific.empty()) {
			std::string_view id_to_check = id;
			if (slk->shadow_data.contains("id") && slk->shadow_data.at(id).contains("oldid")) {
				id_to_check = slk->shadow_data.at(id).at("oldid");
			}

			// For abilities we also have to check the one this might be aliasing
			const std::string_view aliasing_ability = slk->data<std::string_view>("code", id);
			if (!use_specific.contains(id_to_check) && !use_specific.contains(aliasing_ability)) {
				continue;
			}
		}

		if (!not_specific.empty()) {
			std::string_view id_to_check = id;
			if (slk->shadow_data.contains("id") && slk->shadow_data.at(id).contains("oldid")) {
				id_to_check = slk->shadow_data.at(id).at("oldid");
			}

			// For abilities we also have to check the one this might be aliasing
			const std::string_view aliasing_ability = slk->data<std::string_view>("code", id);
			if (not_specific.contains(id_to_check) && not_specific.contains(aliasing_ability)) {
				continue;
			}
		}

		std::string field_name = to_lowercase_copy(meta_slk->data<std::string_view>("field", key));
		if (meta_slk->column_headers.contains("data") && meta_slk->data<int>("data", key) > 0) {
			field_name += static_cast<char>('a' + (meta_slk->data<int>("data", key) - 1));
		}

		if (meta_slk->column_headers.contains("repeat") && meta_slk->data<int>("repeat", key) > 0) {
			int iterations = 1;
			if (slk->column_headers.contains("levels")) {
				iterations = slk->data<int>("levels", id);
			} else if (slk->column_headers.contains("numvar")) {
				iterations = slk->data<int>("numvar", id);
			} else if (slk->column_headers.contains("maxlevel")) {
				iterations = slk->data<int>("maxlevel", id);
			}

			for (int i = 0; i < iterations; i++) {
				std::string new_field_name;
				if (meta_slk->column_headers.contains("appendindex") && meta_slk->data<int>("appendindex", key) > 0) {
					if (i == 0) {
						new_field_name = field_name;
					} else {
						new_field_name = field_name + std::to_string(i);
					}
				} else {
					new_field_name = field_name + std::to_string(i + 1);
				}

				// We add a virtual column if it does not exist in the base table
				if (!slk->column_headers.contains(new_field_name)) {
					slk->add_column(new_field_name);
				}

				id_mapping.push_back({ key, new_field_name, i + 1 });
			}
		} else {
			// We add a virtual column if it does not exist in the base table
			if (!slk->column_headers.contains(field_name)) {
				slk->add_column(field_name);
			}

			id_mapping.push_back({ key, field_name, 0 });
		}
	}

	std::ranges::sort(id_mapping, [&](const auto& left, const auto& right) {
		const std::string_view category1 = world_edit_data.data<std::string_view>("ObjectEditorCategories", meta_slk->data<std::string_view>("category", left.key));
		const std::string left_string = std::format("{} - {}{}", category1, meta_slk->data<std::string_view>("displayname", left.key), left.field);

		const std::string_view category2 = world_edit_data.data<std::string_view>("ObjectEditorCategories", meta_slk->data<std::string_view>("category", right.key));
		const std::string right_string = std::format("{} - {}{}", category2, meta_slk->data<std::string_view>("displayname", right.key), right.field);

		return left_string < right_string;
	});
	endResetModel();
}

void SingleModel::sourceDataChanged(const QModelIndex& topLeft, const QModelIndex& bottomRight, const QVector<int>& roles) {
	Q_ASSERT(topLeft.isValid() ? topLeft.model() == sourceModel() : true);
	Q_ASSERT(bottomRight.isValid() ? bottomRight.model() == sourceModel() : true);

	for (size_t i = topLeft.row(); i < bottomRight.row(); i++) {
		if (i == slk->row_headers.at(id)) {
			const auto top_left = mapFromSource(createIndex(i, topLeft.column()));
			const auto bottom_right = mapFromSource(createIndex(i, bottomRight.column()));
			emit dataChanged(top_left, bottom_right, roles);
			return;
		}
	}
}

/// Manually color the headers because the default QHeaderView will only alternatively color the items
void AlterHeader::paintSection(QPainter* painter, const QRect& rect, int logicalIndex) const {
	const Qt::Alignment align = (Qt::AlignLeft | Qt::AlignTop);

	if (logicalIndex % 2 > 0) {
		painter->fillRect(rect, palette().color(QPalette::AlternateBase));
	} else {
		painter->fillRect(rect, palette().color(QPalette::Base));
	}

	painter->setPen(QPen(model()->headerData(logicalIndex, orientation(), Qt::ForegroundRole).value<QColor>()));
	painter->drawText(rect.adjusted(2 * style()->pixelMetric(QStyle::PM_HeaderMargin, nullptr, this), 5, 0, 0), align, model()->headerData(logicalIndex, orientation(), Qt::DisplayRole).toString());
	painter->setPen(QPen(palette().color(QPalette::Base)));
	painter->drawLine(rect.x(), rect.bottom(), rect.right(), rect.bottom());
}

TableDelegate::TableDelegate(QWidget* parent) : QStyledItemDelegate(parent) {
}

QWidget* TableDelegate::createEditor(QWidget* parent, const QStyleOptionViewItem&, const QModelIndex& index) const {
	const auto model = static_cast<const SingleModel*>(index.model());
	const auto& mapping = model->getMapping();

	const std::string type = model->meta_slk->data("type", mapping[index.row()].key);
	const std::string minVal = model->meta_slk->data("minval", mapping[index.row()].key);
	const std::string maxVal = model->meta_slk->data("maxval", mapping[index.row()].key);

	if (type == "int") {
		QSpinBox* editor = new QSpinBox(parent);
		editor->setMinimum(INT_MIN);
		editor->setMaximum(INT_MAX);
		// handle empty minVal, maxVal
		// editor->setMinimum(std::stoi(minVal));
		// editor->setMaximum(std::stoi(maxVal));
		// editor->setSingleStep(std::clamp((std::stoi(maxVal) - std::stoi(minVal)) / 10, 1, 10));
		return editor;
	} else if (type == "real" || type == "unreal") {
		QDoubleSpinBox* editor = new QDoubleSpinBox(parent);
		editor->setMinimum(-99999999999.0);
		editor->setMaximum(99999999999.0);
		// editor->setMinimum(std::stod(minVal));
		// editor->setMaximum(std::stod(maxVal));
		// editor->setSingleStep(std::clamp((std::stod(maxVal) - std::stod(minVal)) / 10.0, 0.1, 10.0));
		return editor;
	} else if (type == "string") {
		QTextEdit* editor = new QTextEdit(parent);
//		editor->setMaxLength(std::stoi(maxVal));
		return editor;
	} else if (type == "model") {
		return create_model_editor(parent);
	} else if (type == "targetList") {
		return create_target_list_editor(parent);
	} else if (type == "unitList") {
		return create_unit_list_editor(parent);
	} else if (type == "upgradeList") {
		return create_upgrade_list_editor(parent);
	}else if (type == "abilityList" || type == "heroAbilityList" || type == "abilitySkinList") {
		return create_ability_list_editor(parent);
	} else if (type.ends_with("List")) {
		return create_list_editor(parent);
	} else if (unit_editor_data.section_exists(type)) {
		QComboBox* editor = new QComboBox(parent);
		for (const auto& [key, value] : unit_editor_data.section(type)) {
			if (key == "NumValues" || key == "Sort" || key.ends_with("_Alt")) {
				continue;
			}

			QString displayText = QString::fromStdString(value[1]);
			displayText.replace('&', "");

			editor->addItem(displayText, QString::fromStdString(value[0]));
		}
		return editor;
	} else if (type == "icon") {
		return create_icon_editor(parent);
	} else if (type == "doodadCategory") {
		QComboBox* editor = new QComboBox(parent);
		for (auto&& [key, value] : world_edit_data.section("DoodadCategories")) {
			editor->addItem(QString::fromStdString(value[0]), QString::fromStdString(key));
		}
		return editor;
	} else if (type == "destructableCategory") {
		QComboBox* editor = new QComboBox(parent);
		for (auto&& [key, value] : world_edit_data.section("DestructibleCategories")) {
			editor->addItem(QString::fromStdString(value[0]), QString::fromStdString(key));
		}
		return editor;
	} else {
		return new QLineEdit(parent);
	}
}

void TableDelegate::setEditorData(QWidget* editor, const QModelIndex& index) const {
	const auto model = static_cast<const SingleModel*>(index.model());
	const auto& mapping = model->getMapping();

	const std::string_view type = model->meta_slk->data<std::string_view>("type", mapping[index.row()].key);

	if (type == "int") {
		static_cast<QSpinBox*>(editor)->setValue(model->data(index, Qt::EditRole).toInt());
	} else if (type == "real" || type == "unreal") {
		static_cast<QDoubleSpinBox*>(editor)->setValue(model->data(index, Qt::EditRole).toDouble());
	} else if (type == "string") {
		// A hack to resolve TRIGSTR. The downside of taking the Display value is that we overwrite the TRIGSTR reference
		static_cast<QTextEdit*>(editor)->setText(model->data(index, Qt::DisplayRole).toString());
	} else if (type == "targetList") {
		auto parts = model->data(index, Qt::EditRole).toString().split(',');
		for (const auto& i : parts) {
			QCheckBox* box = editor->findChild<QCheckBox*>(i);
			if (box) {
				box->setChecked(true);
			}
		}
	} else if (type == "model") {
		ModelView* list = editor->findChild<ModelView*>("modelView");
		list->set_current_model_path(model->data(index, Qt::EditRole).toString());
	} else if (type == "unitList") {
		QListWidget* list = editor->findChild<QListWidget*>("unitList");

		auto ids = model->data(index, Qt::EditRole).toString().split(',', Qt::SkipEmptyParts);
		for (const auto& id : ids) {
			QListWidgetItem* item = new QListWidgetItem;
			item->setText(units_table->data(id.toStdString(), "name").toString());
			item->setIcon(units_table->data(id.toStdString(), "art", Qt::DecorationRole).value<QIcon>());
			item->setData(Qt::StatusTipRole, id);
			list->addItem(item);
		}
	} else if (type == "upgradeList") {
		QListWidget* list = editor->findChild<QListWidget*>("upgradeList");

		auto ids = model->data(index, Qt::EditRole).toString().split(',', Qt::SkipEmptyParts);
		for (const auto& id : ids) {
			QListWidgetItem* item = new QListWidgetItem;
			item->setText(upgrade_table->data(id.toStdString(), "name1").toString());
			item->setIcon(upgrade_table->data(id.toStdString(), "art1", Qt::DecorationRole).value<QIcon>());
			item->setData(Qt::StatusTipRole, id);
			list->addItem(item);
		}
	} else if (type == "abilityList" || type == "heroAbilityList" || type == "abilitySkinList") {
		QListWidget* list = editor->findChild<QListWidget*>("abilityList");

		auto ids = model->data(index, Qt::EditRole).toString().split(',', Qt::SkipEmptyParts);
		for (const auto& id : ids) {
			QListWidgetItem* item = new QListWidgetItem;
			item->setText(abilities_table->data(id.toStdString(), "name").toString());
			item->setIcon(abilities_table->data(id.toStdString(), "art", Qt::DecorationRole).value<QIcon>());
			item->setData(Qt::StatusTipRole, id);
			list->addItem(item);
		}
	} else if (type.ends_with("List")) {
		editor->findChild<QPlainTextEdit*>("editor")->setPlainText(model->data(index, Qt::EditRole).toString());
	} else if (unit_editor_data.section_exists(type)) {
		auto combo = static_cast<QComboBox*>(editor);
		// Find the item with the right userdata and set it as current index
		for (int i = 0; i < combo->count(); i++) {
			if (combo->itemData(i, Qt::UserRole).toString() == model->data(index, Qt::EditRole).toString()) {
				combo->setCurrentIndex(i);
			}
		}
	} else if (type == "icon") {
		IconView* list = editor->findChild<IconView*>("iconView");
		list->setCurrentIconPath(model->data(index, Qt::EditRole).toString());
	} else if (type == "doodadCategory") {
		const auto combo = static_cast<QComboBox*>(editor);
		for (int i = 0; i < combo->count(); i++) {
			if (combo->itemData(i, Qt::UserRole).toString() == model->data(index, Qt::EditRole).toString()) {
				combo->setCurrentIndex(i);
			}
		}
	} else if (type == "destructableCategory") {
		auto combo = static_cast<QComboBox*>(editor);
		for (int i = 0; i < combo->count(); i++) {
			if (combo->itemData(i, Qt::UserRole).toString() == model->data(index, Qt::EditRole).toString()) {
				combo->setCurrentIndex(i);
			}
		}
	} else {
		static_cast<QLineEdit*>(editor)->setText(model->data(index, Qt::EditRole).toString());
	}
}

void TableDelegate::setModelData(QWidget* editor, QAbstractItemModel* model, const QModelIndex& index) const {
	auto singlemodel = static_cast<SingleModel*>(model);
	auto& mapping = singlemodel->getMapping();

	const std::string_view type = singlemodel->meta_slk->data<std::string_view>("type", mapping[index.row()].key);

	if (type == "int") {
		singlemodel->setData(index, static_cast<QSpinBox*>(editor)->value());
	} else if (type == "real" || type == "unreal") {
		singlemodel->setData(index, static_cast<QDoubleSpinBox*>(editor)->value());
	} else if (type == "string") {
		auto text = static_cast<QTextEdit*>(editor)->toPlainText();
		text.replace('\n', "|n");
		singlemodel->setData(index, text);
	} else if (type == "model") {
		ModelView* list = editor->findChild<ModelView*>("modelView");
		singlemodel->setData(index, list->current_model_path());
	} else if (type == "unitList") {
		QListWidget* list = editor->findChild<QListWidget*>("unitList");

		QString result;
		for (int i = 0; i < list->count(); i++) {
			QListWidgetItem* item = list->item(i);
			if (!result.isEmpty()) {
				result += ',';
			}
			result += item->data(Qt::StatusTipRole).toString();
		}
		model->setData(index, result, Qt::EditRole);
	} else if (type == "abilityList" || type == "heroAbilityList" || type == "abilitySkinList") {
		QListWidget* list = editor->findChild<QListWidget*>("abilityList");
		
		QString result;
		for (int i = 0; i < list->count(); i++) {
			QListWidgetItem* item = list->item(i);
			if (!result.isEmpty()) {
				result += ',';
			}
			result += item->data(Qt::StatusTipRole).toString();
		}
		model->setData(index, result, Qt::EditRole);
	} else if (type == "upgradeList") {
		QListWidget* list = editor->findChild<QListWidget*>("upgradeList");

		QString result;
		for (int i = 0; i < list->count(); i++) {
			QListWidgetItem* item = list->item(i);
			if (!result.isEmpty()) {
				result += ',';
			}
			result += item->data(Qt::StatusTipRole).toString();
		}
		model->setData(index, result, Qt::EditRole);
	} else if (type == "targetList") {
		QString result;
		for (const auto& [key, value] : unit_editor_data.section(type)) {
			if (key == "NumValues" || key == "Sort" || key.ends_with("_Alt")) {
				continue;
			}

			QCheckBox* box = editor->findChild<QCheckBox*>(QString::fromStdString(value[0]));
			if (box && box->isChecked()) {
				if (!result.isEmpty()) {
					result += ",";
				}
				result += QString::fromStdString(value[0]);
			}
		}
		model->setData(index, result, Qt::EditRole);
	}  else if (type.ends_with("List")) {
		singlemodel->setData(index, editor->findChild<QPlainTextEdit*>("editor")->toPlainText());
	} else if (unit_editor_data.section_exists(type)) {
		auto combo = static_cast<QComboBox*>(editor);
		singlemodel->setData(index, combo->currentData());
	} else if (type == "icon") {
		IconView* list = editor->findChild<IconView*>("iconView");
		singlemodel->setData(index, list->currentIconPath());
	} else if (type == "doodadCategory") {
		auto combo = static_cast<QComboBox*>(editor);
		singlemodel->setData(index, combo->currentData());
	} else if (type == "destructableCategory") {
		auto combo = static_cast<QComboBox*>(editor);
		singlemodel->setData(index, combo->currentData());
	} else {
		singlemodel->setData(index, static_cast<QLineEdit*>(editor)->text());
	}
}

void TableDelegate::updateEditorGeometry(QWidget* editor, const QStyleOptionViewItem& option, const QModelIndex&) const {
	if (dynamic_cast<QDialog*>(editor)) {
		
	} else {
		editor->setGeometry(option.rect);
	}
}

QWidget* TableDelegate::create_list_editor(QWidget* parent) const {
	auto editor = new QWidget(parent);

	QDialog* dialog = new QDialog(editor, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
	dialog->setAttribute(Qt::WA_DeleteOnClose);
	dialog->setWindowModality(Qt::WindowModality::WindowModal);

	QVBoxLayout* layout = new QVBoxLayout(dialog);

	QPlainTextEdit* text_edit = new QPlainTextEdit;
	text_edit->setObjectName("editor");

	QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
	connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
	connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);

	layout->addWidget(text_edit);
	layout->addWidget(buttonBox);

	connect(dialog, &QDialog::accepted, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->commitData(editor);
		emit delegate->closeEditor(editor);
	});

	connect(dialog, &QDialog::rejected, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->closeEditor(editor);
	});

	dialog->show();

	return editor;

}

QWidget* TableDelegate::create_model_editor(QWidget* parent) const {
	auto editor = new QWidget(parent);

	QDialog* dialog = new QDialog(editor, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
	dialog->setAttribute(Qt::WA_DeleteOnClose);
	dialog->resize(530, 512);
	dialog->setWindowModality(Qt::WindowModality::WindowModal);

	ModelView* view = new ModelView;
	view->setObjectName("modelView");

	QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
	connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
	connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);

	connect(dialog, &QDialog::accepted, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->commitData(editor);
		emit delegate->closeEditor(editor);
	});

	connect(dialog, &QDialog::rejected, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->closeEditor(editor);
	});

	QVBoxLayout* layout = new QVBoxLayout(dialog);
	layout->addWidget(view);
	layout->addWidget(buttonBox);

	dialog->show();

	return editor;
}


QWidget* TableDelegate::create_target_list_editor(QWidget* parent) const {
	auto editor = new QWidget(parent);

	QDialog* dialog = new QDialog(editor, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
	dialog->setAttribute(Qt::WA_DeleteOnClose);
	dialog->setWindowModality(Qt::WindowModality::WindowModal);

	QVBoxLayout* layout = new QVBoxLayout(dialog);
	QGridLayout* flow = new QGridLayout;

	for (const auto& [key, value] : unit_editor_data.section("targetList")) {
		if (key == "NumValues" || key == "Sort" || key.ends_with("_Alt")) {
			continue;
		}

		QString displayText = QString::fromStdString(value[1]);
		displayText.replace('&', "");

		QCheckBox* flag = new QCheckBox(displayText);
		flag->setObjectName(QString::fromStdString(value[0]));

		flow->addWidget(flag);
	}

	QDialogButtonBox* buttonBox = new QDialogButtonBox;
	buttonBox->setStandardButtons(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
	connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
	connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);

	layout->addLayout(flow);
	layout->addWidget(buttonBox);

	connect(dialog, &QDialog::accepted, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->commitData(editor);
		emit delegate->closeEditor(editor);
	});

	connect(dialog, &QDialog::rejected, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->closeEditor(editor);
	});

	dialog->show();

	return editor;
}

QWidget* TableDelegate::create_upgrade_list_editor(QWidget* parent) const {
	auto editor = new QWidget(parent);

	QDialog* dialog = new QDialog(editor, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
	dialog->setAttribute(Qt::WA_DeleteOnClose);
	dialog->resize(256, 360);
	dialog->setWindowModality(Qt::WindowModality::WindowModal);

	QVBoxLayout* layout = new QVBoxLayout(dialog);

	QListWidget* list = new QListWidget;
	list->setObjectName("upgradeList");
	list->setIconSize(QSize(32, 32));
	list->setDragDropMode(QAbstractItemView::DragDropMode::InternalMove);
	layout->addWidget(list);

	QHBoxLayout* hbox = new QHBoxLayout;

	QPushButton* add = new QPushButton("Add");
	QPushButton* remove = new QPushButton("Remove");
	remove->setDisabled(true);
	hbox->addWidget(add);
	hbox->addWidget(remove);
	layout->addLayout(hbox);
	connect(add, &QPushButton::clicked, [=]() {
		QDialog* selectdialog = new QDialog(dialog, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
		selectdialog->resize(300, 560);
		selectdialog->setWindowModality(Qt::WindowModality::WindowModal);

		QVBoxLayout* selectlayout = new QVBoxLayout(selectdialog);

		UpgradeTreeModel* uupgradeTreeModel = new UpgradeTreeModel(dialog);
		uupgradeTreeModel->setSourceModel(upgrade_table);
		QSortFilterProxyModel* filter = new QSortFilterProxyModel;
		filter->setSourceModel(uupgradeTreeModel);
		filter->setRecursiveFilteringEnabled(true);
		filter->setFilterCaseSensitivity(Qt::CaseSensitivity::CaseInsensitive);

		QLineEdit* search = new QLineEdit;
		search->setPlaceholderText("Search Upgrades");
		QTreeView* view = new QTreeView;
		view->setModel(filter);
		view->header()->hide();
		view->setSelectionBehavior(QAbstractItemView::SelectRows);
		view->setSelectionMode(QAbstractItemView::ExtendedSelection);
		view->expandAll();

		connect(search, &QLineEdit::textChanged, filter, QOverload<const QString&>::of(&QSortFilterProxyModel::setFilterFixedString));

		selectlayout->addWidget(search);
		selectlayout->addWidget(view);

		QDialogButtonBox* buttonBox2 = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
		connect(buttonBox2, &QDialogButtonBox::accepted, selectdialog, &QDialog::accept);
		connect(buttonBox2, &QDialogButtonBox::rejected, selectdialog, &QDialog::reject);
		selectlayout->addWidget(buttonBox2);

		auto add = [filter, list, selectdialog](const QModelIndex& index) {
			QModelIndex sourceIndex = filter->mapToSource(index);
			BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(sourceIndex.internalPointer());
			if (treeItem->baseCategory || treeItem->subCategory) {
				return;
			}

			QListWidgetItem* item = new QListWidgetItem;
			item->setData(Qt::StatusTipRole, QString::fromStdString(treeItem->id));
			item->setText(upgrade_table->data(treeItem->id, "name1").toString());
			item->setIcon(upgrade_table->data(treeItem->id, "art1", Qt::DecorationRole).value<QIcon>());
			list->addItem(item);
		};

		connect(view, &QTreeView::activated, [=](const QModelIndex& index) {
			add(index);
			selectdialog->close();
		});

		connect(selectdialog, &QDialog::accepted, [=]() {
			for (const auto& i : view->selectionModel()->selectedIndexes()) {
				add(i);
			}
			selectdialog->close();
		});

		selectdialog->show();
		selectdialog->move(dialog->geometry().topRight() + QPoint(10, dialog->geometry().height() - selectdialog->geometry().height()));
	});

	connect(remove, &QPushButton::clicked, [=]() {
		for (auto i : list->selectedItems()) {
			delete i;
		}
	});
	connect(list, &QListWidget::itemSelectionChanged, [=]() {
		remove->setEnabled(list->selectedItems().size() > 0);
	});

	QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
	connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
	connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
	layout->addWidget(buttonBox);

	connect(dialog, &QDialog::accepted, [=](){
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->commitData(editor);
		emit delegate->closeEditor(editor);
	});

	connect(dialog, &QDialog::rejected, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->closeEditor(editor);
	});

	dialog->show();

	return editor;
}

QWidget* TableDelegate::create_unit_list_editor(QWidget* parent) const {
	auto editor = new QWidget(parent);

	QDialog* dialog = new QDialog(editor, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
	dialog->setAttribute(Qt::WA_DeleteOnClose);
	dialog->resize(256, 360);
	dialog->setWindowModality(Qt::WindowModality::WindowModal);

	QVBoxLayout* layout = new QVBoxLayout(dialog);

	QListWidget* list = new QListWidget;
	list->setObjectName("unitList");
	list->setIconSize(QSize(32, 32));
	list->setDragDropMode(QAbstractItemView::DragDropMode::InternalMove);
	layout->addWidget(list);

	QHBoxLayout* hbox = new QHBoxLayout;

	QPushButton* add = new QPushButton("Add");
	QPushButton* remove = new QPushButton("Remove");
	remove->setDisabled(true);
	hbox->addWidget(add);
	hbox->addWidget(remove);
	layout->addLayout(hbox);
	connect(add, &QPushButton::clicked, [=]() {
		QDialog* selectdialog = new QDialog(dialog, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
		selectdialog->resize(300, 560);
		selectdialog->setWindowModality(Qt::WindowModality::WindowModal);

		QVBoxLayout* selectlayout = new QVBoxLayout(selectdialog);

		UnitTreeModel* unitTreeModel = new UnitTreeModel(dialog);
		unitTreeModel->setSourceModel(units_table);
		QSortFilterProxyModel* filter = new QSortFilterProxyModel;
		filter->setSourceModel(unitTreeModel);
		filter->setRecursiveFilteringEnabled(true);
		filter->setFilterCaseSensitivity(Qt::CaseSensitivity::CaseInsensitive);

		QLineEdit* search = new QLineEdit;
		search->setPlaceholderText("Search Units");
		QTreeView* view = new QTreeView;
		view->setModel(filter);
		view->header()->hide();
		view->setSelectionBehavior(QAbstractItemView::SelectRows);
		view->setSelectionMode(QAbstractItemView::ExtendedSelection);
		view->expandAll();

		connect(search, &QLineEdit::textChanged, filter, QOverload<const QString&>::of(&QSortFilterProxyModel::setFilterFixedString));

		selectlayout->addWidget(search);
		selectlayout->addWidget(view);

		QDialogButtonBox* buttonBox2 = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
		connect(buttonBox2, &QDialogButtonBox::accepted, selectdialog, &QDialog::accept);
		connect(buttonBox2, &QDialogButtonBox::rejected, selectdialog, &QDialog::reject);
		selectlayout->addWidget(buttonBox2);

		auto add = [filter, list, selectdialog](const QModelIndex& index) {
			QModelIndex sourceIndex = filter->mapToSource(index);
			BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(sourceIndex.internalPointer());
			if (treeItem->baseCategory || treeItem->subCategory) {
				return;
			}

			QListWidgetItem* item = new QListWidgetItem;
			item->setData(Qt::StatusTipRole, QString::fromStdString(treeItem->id));
			item->setText(units_table->data(treeItem->id, "name").toString());
			item->setIcon(units_table->data(treeItem->id, "art", Qt::DecorationRole).value<QIcon>());
			list->addItem(item);
		};

		connect(view, &QTreeView::activated, [=](const QModelIndex& index) {
			add(index);
			selectdialog->close();
		});

		connect(selectdialog, &QDialog::accepted, [=]() {
			for (const auto& i : view->selectionModel()->selectedIndexes()) {
				add(i);
			}
			selectdialog->close();
		});

		selectdialog->show();
		selectdialog->move(dialog->geometry().topRight() + QPoint(10, dialog->geometry().height() - selectdialog->geometry().height()));
	});

	connect(remove, &QPushButton::clicked, [=]() {
		for (auto i : list->selectedItems()) {
			delete i;
		}
	});
	connect(list, &QListWidget::itemSelectionChanged, [=]() {
		remove->setEnabled(list->selectedItems().size() > 0);
	});

	QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
	connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
	connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
	layout->addWidget(buttonBox);

	connect(dialog, &QDialog::accepted, [=](){
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->commitData(editor);
		emit delegate->closeEditor(editor);
	});

	connect(dialog, &QDialog::rejected, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->closeEditor(editor);
	});

	dialog->show();

	return editor;
}

QWidget* TableDelegate::create_ability_list_editor(QWidget* parent) const {
	auto editor = new QWidget(parent);

	QDialog* dialog = new QDialog(editor, Qt::Window | Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
	dialog->setAttribute(Qt::WA_DeleteOnClose);
	dialog->resize(256, 360);
	dialog->setWindowModality(Qt::WindowModality::WindowModal);

	QVBoxLayout* layout = new QVBoxLayout(dialog);

	QListWidget* list = new QListWidget;
	list->setObjectName("abilityList");
	list->setIconSize(QSize(32, 32));
	list->setDragDropMode(QAbstractItemView::DragDropMode::InternalMove);
	list->setSelectionBehavior(QAbstractItemView::SelectRows);
	list->setSelectionMode(QAbstractItemView::ExtendedSelection);

	layout->addWidget(list);

	QHBoxLayout* hbox = new QHBoxLayout;

	QPushButton* add = new QPushButton("Add");
	QPushButton* remove = new QPushButton("Remove");
	remove->setDisabled(true);
	hbox->addWidget(add);
	hbox->addWidget(remove);
	layout->addLayout(hbox);
	connect(add, &QPushButton::clicked, [=]() {
		QDialog* selectdialog = new QDialog(dialog, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
		selectdialog->resize(300, 560);
		selectdialog->setWindowModality(Qt::WindowModality::WindowModal);

		QVBoxLayout* selectlayout = new QVBoxLayout(selectdialog);

		AbilityTreeModel* abilityTreeModel = new AbilityTreeModel(dialog);
		abilityTreeModel->setSourceModel(abilities_table);
		QSortFilterProxyModel* filter = new QSortFilterProxyModel;
		filter->setSourceModel(abilityTreeModel);
		filter->setRecursiveFilteringEnabled(true);
		filter->setFilterCaseSensitivity(Qt::CaseSensitivity::CaseInsensitive);

		QLineEdit* search = new QLineEdit;
		search->setPlaceholderText("Search Abilities");
		QTreeView* view = new QTreeView;
		view->setModel(filter);
		view->header()->hide();
		view->setSelectionBehavior(QAbstractItemView::SelectRows);
		view->setSelectionMode(QAbstractItemView::ExtendedSelection);
		view->expandAll();

		connect(search, &QLineEdit::textChanged, filter, QOverload<const QString&>::of(&QSortFilterProxyModel::setFilterFixedString));

		selectlayout->addWidget(search);
		selectlayout->addWidget(view);

		QDialogButtonBox* buttonBox2 = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
		connect(buttonBox2, &QDialogButtonBox::accepted, selectdialog, &QDialog::accept);
		connect(buttonBox2, &QDialogButtonBox::rejected, selectdialog, &QDialog::reject);
		selectlayout->addWidget(buttonBox2);

		auto add = [filter, list, selectdialog](const QModelIndex& index) {
			QModelIndex sourceIndex = filter->mapToSource(index);
			BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(sourceIndex.internalPointer());
			if (treeItem->baseCategory || treeItem->subCategory) {
				return;
			}

			QListWidgetItem* item = new QListWidgetItem;
			item->setData(Qt::StatusTipRole, QString::fromStdString(treeItem->id));
			item->setText(abilities_table->data(treeItem->id, "name").toString());
			item->setIcon(abilities_table->data(treeItem->id, "art", Qt::DecorationRole).value<QIcon>());

			list->addItem(item);
		};

		connect(view, &QTreeView::activated, [=](const QModelIndex& index) {
			add(index);
			selectdialog->close();
		});

		connect(selectdialog, &QDialog::accepted, [=]() {
			for (const auto& i : view->selectionModel()->selectedIndexes()) {
				add(i);
			}
			selectdialog->close();
		});

		selectdialog->show();
		selectdialog->move(dialog->geometry().topRight() + QPoint(10, dialog->geometry().height() - selectdialog->geometry().height()));
	});
	connect(remove, &QPushButton::clicked, [=]() {
		for (auto i : list->selectedItems()) {
			delete i;
		}
	});
	connect(list, &QListWidget::itemSelectionChanged, [=]() {
		remove->setEnabled(list->selectedItems().size() > 0);
	});

	QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
	connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
	connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
	layout->addWidget(buttonBox);

	connect(dialog, &QDialog::accepted, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->commitData(editor);
		emit delegate->closeEditor(editor);
	});

	connect(dialog, &QDialog::rejected, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->closeEditor(editor);
	});

	dialog->show();

	return editor;
}

QWidget* TableDelegate::create_icon_editor(QWidget* parent) const {
	auto editor = new QWidget(parent);

	QDialog* dialog = new QDialog(editor, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
	dialog->setAttribute(Qt::WA_DeleteOnClose);
	dialog->resize(530, 512);
	dialog->setWindowModality(Qt::WindowModality::WindowModal);

	IconView* view = new IconView;
	view->setObjectName("iconView");

	QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
	connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
	connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);

	connect(dialog, &QDialog::accepted, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->commitData(editor);
		emit delegate->closeEditor(editor);
	});

	connect(dialog, &QDialog::rejected, [=]() {
		const auto delegate = const_cast<TableDelegate*>(this);
		emit delegate->closeEditor(editor);
	});

	QVBoxLayout* layout = new QVBoxLayout(dialog);
	layout->addWidget(view);
	layout->addWidget(buttonBox);

	dialog->show();

	return editor;
}
```

`src/models/single_model.h`:

```h
#pragma once

#include <QAbstractProxyModel>
#include <QIdentityProxyModel>
#include <QHeaderView>
#include <QStyledItemDelegate>

#include <string>
#include <vector>

import TableModel;
import SLK;

class SingleModel : public QAbstractProxyModel {
	Q_OBJECT
		
public:
	QModelIndex mapFromSource(const QModelIndex& sourceIndex) const override;
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override;
	
	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role) const override;

	bool setData(const QModelIndex& index, const QVariant& value, int role = Qt::EditRole) override;

	int rowCount(const QModelIndex& parent = QModelIndex()) const override;
	int columnCount(const QModelIndex& parent = QModelIndex()) const override;

	QModelIndex index(int row, int column, const QModelIndex& parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex& child) const override;

	void setSourceModel(QAbstractItemModel* sourceModel) override;

	explicit SingleModel(TableModel* table, QObject* parent = nullptr);
	void setID(const std::string id);
	std::string getID() const;

	struct Mapping {
		std::string key;
		std::string field;
		int level;
	};

	const std::vector<Mapping>& getMapping() const {
		return id_mapping;
	}

	slk::SLK* meta_slk;
private:
	void buildMapping();

	slk::SLK* slk;

	std::string id = "hpea";
	std::vector<Mapping> id_mapping;

	void sourceDataChanged(const QModelIndex& topLeft, const QModelIndex& bottomRight, const QVector<int>& roles);

};

// Provides row headers that have alternate colors
class AlterHeader : public QHeaderView {
	Q_OBJECT

public:
	using QHeaderView::QHeaderView;
protected:
	void paintSection(QPainter* painter, const QRect& rect, int logicalIndex) const;
};


class TableDelegate : public QStyledItemDelegate {
	Q_OBJECT

public:
	TableDelegate(QWidget* parent = nullptr);

	QWidget* createEditor(QWidget* parent, const QStyleOptionViewItem& option, const QModelIndex& index) const override;

	void setEditorData(QWidget* editor, const QModelIndex& index) const override;
	void setModelData(QWidget* editor, QAbstractItemModel* model, const QModelIndex& index) const override;

	void updateEditorGeometry(QWidget* editor, const QStyleOptionViewItem& option, const QModelIndex& index) const override;

	QWidget* create_list_editor(QWidget* parent) const;
	QWidget* create_model_editor(QWidget* parent) const;
	QWidget* create_target_list_editor(QWidget* parent) const;
	QWidget* create_upgrade_list_editor(QWidget* parent) const;
	QWidget* create_unit_list_editor(QWidget* parent) const;
	QWidget* create_ability_list_editor(QWidget* parent) const;
	QWidget* create_icon_editor(QWidget* parent) const;

	[[nodiscard]] QSize sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const override {
		QSize size = QStyledItemDelegate::sizeHint(option, index);

		QVariant decoration = index.data(Qt::DecorationRole);
		bool hasIcon = decoration.canConvert<QIcon>();

		if (!hasIcon) {
			size.rheight() += 8; // Add vertical padding (4px top + 4px bottom)
		}


		return size;
	}
};
```

`src/models/table_model.ixx`:

```ixx
module;

#include <QAbstractTableModel>

export module TableModel;

import std;
import Globals;
import QIconResource;
import SLK;
import TriggerStrings;
import QIconResource;
import Hierarchy;
import ResourceManager;
import UnorderedMap;
import <absl/strings/str_split.h>;
import <absl/strings/str_join.h>;

namespace fs = std::filesystem;

hive::unordered_map<std::string, std::shared_ptr<QIconResource>> path_to_icon;


export class TableModel;

export inline TableModel* units_table;
export inline TableModel* items_table;
export inline TableModel* abilities_table;
export inline TableModel* doodads_table;
export inline TableModel* destructibles_table;
export inline TableModel* upgrade_table;
export inline TableModel* buff_table;

export class TableModel : public QAbstractTableModel {
	std::shared_ptr<QIconResource> invalid_icon;

  public:
	slk::SLK* meta_slk;
	slk::SLK* slk;
	TriggerStrings* trigger_strings;

	explicit TableModel(slk::SLK* slk, slk::SLK* meta_slk, TriggerStrings* trigger_strings, QObject* parent = nullptr)
		: QAbstractTableModel(parent), slk(slk), meta_slk(meta_slk), trigger_strings(trigger_strings) {

		invalid_icon = resource_manager.load<QIconResource>("ReplaceableTextures/WorldEditUI/DoodadPlaceholder.dds");
	}

	[[nodiscard]] int rowCount(const QModelIndex& parent = QModelIndex()) const override {
		return slk->rows();
	}

	[[nodiscard]] int columnCount(const QModelIndex& parent = QModelIndex()) const override {
		return slk->columns();
	}

	[[nodiscard]] QVariant data(const QModelIndex& index, const int role = Qt::DisplayRole) const override {
		if (!index.isValid()) {
			return {};
		}

		const std::string& id = slk->index_to_row.at(index.row());
		const std::string& field = slk->index_to_column.at(index.column());
		return data(id, field, role);
	}

	[[nodiscard]] QVariant data(const std::string_view id, const std::string_view field, const int role = Qt::DisplayRole) const {
		switch (role) {
			case Qt::DisplayRole: {
				const std::string_view field_data = slk->data<std::string_view>(field, id);
				const std::string_view meta_id = slk->field_to_meta_id(*meta_slk, field, id).value();
				const std::string_view type = meta_slk->data<std::string_view>("type", meta_id);
				if (type == "string") {
					QString qt_string;
					if (field_data.starts_with("TRIGSTR")) {
						const auto data = trigger_strings->string(field_data);
						qt_string = QString::fromUtf8(data);
					} else {
						qt_string = QString::fromUtf8(field_data);
					}

					qt_string.replace("|n", "\n");
					return qt_string;
				} else if (type == "bool") {
					return field_data == "1";
				} else if (type == "unitList") {
					std::vector<std::string_view> parts = absl::StrSplit(field_data, ',', absl::SkipEmpty());

					QStringList result;
					for (const auto& part : parts) {
						result.append(units_table->data(part, "name", role).toString());
					}
					return result.join('\n');
				} else if (type == "abilityList" || type == "abilitySkinList" || type == "heroAbilityList") {
					std::vector<std::string_view> parts = absl::StrSplit(field_data, ',', absl::SkipEmpty());

					QStringList result;
					for (const auto& part : parts) {
						result.append(abilities_table->data(part, "name", role).toString());
					}
					return result.join('\n');
				} else if (type == "upgradeList") {
					std::vector<std::string_view> parts = absl::StrSplit(field_data, ',', absl::SkipEmpty());

					QStringList result;
					for (const auto& part : parts) {
						result.append(upgrade_table->data(part, "name1", role).toString());
					}
					return result.join('\n');
				} else if (type == "buffList") {
					std::vector<std::string_view> parts = absl::StrSplit(field_data, ',', absl::SkipEmpty());

					QStringList result;
					for (const auto& part : parts) {
						QString editor_name = buff_table->data(part, "editorname", role).toString();
						if (editor_name.isEmpty()) {
							result += buff_table->data(part, "bufftip", role).toString();
						} else {
							result += editor_name;
						}
					}
					return result.join('\n');
				} else if (type == "techList") {
					std::vector<std::string_view> parts = absl::StrSplit(field_data, ',', absl::SkipEmpty());

					QStringList result;
					for (const auto& part : parts) {
						if (units_slk.row_headers.contains(part)) {
							result += units_table->data(part, "name", role).toString();
						} else if (upgrade_slk.row_headers.contains(part)) {
							result += upgrade_table->data(part, "name1", role).toString();
						} else {
							result += QString::fromStdString(std::string(part));
						}
					}
					return result.join('\n');
				} else if (type == "targetList") {
					std::vector<std::string_view> parts = absl::StrSplit(field_data, ',', absl::SkipEmpty());
					QStringList result;
					for (size_t i = 0; i < parts.size(); i++) {
						for (const auto& [key, value] : unit_editor_data.section(type)) {
							if (key == "NumValues" || key == "Sort" || key.ends_with("_Alt")) {
								continue;
							}

							if (value[0] == parts[i]) {
								result += QString::fromStdString(value[1]);
							}
						}
					}
					QString result_qstring = result.join(", ");
					result_qstring.replace('&', "");
					return result_qstring;
				} else if (type == "tilesetList") {
					std::vector<std::string_view> parts = absl::StrSplit(field_data, ',', absl::SkipEmpty());
					QStringList result;
					for (const auto& part : parts) {
						if (part == "*") {
							result += "All";
						} else {
							result += QString::fromStdString(world_edit_data.data<std::string>("TileSets", part));
						}
					}
					return result.join(", ");
				} else if (unit_editor_data.section_exists(type)) {
					for (const auto& [key, value] : unit_editor_data.section(type)) {
						if (key == "NumValues" || key == "Sort" || key.ends_with("_Alt")) {
							continue;
						}

						if (slk->data<std::string_view>(field, id) == value[0]) {
							QString displayText = QString::fromStdString(value[1]);
							displayText.replace('&', "");
							return displayText;
						}
					}
				} else if (type == "doodadCategory") {
					for (auto&& [key, value] : world_edit_data.section("DoodadCategories")) {
						if (field_data == key) {
							return QString::fromStdString(value[0]);
						}
					}
				} else if (type == "destructableCategory") {
					for (auto&& [key, value] : world_edit_data.section("DestructibleCategories")) {
						if (field_data == key) {
							return QString::fromStdString(value[0]);
						}
					}
				}

				return QString::fromUtf8(field_data);
			}
			case Qt::EditRole:
				return QString::fromUtf8(slk->data<std::string_view>(field, id));
			case Qt::CheckStateRole: {
				const std::string_view meta_id = slk->field_to_meta_id(*meta_slk, field, id).value();
				const std::string_view type = meta_slk->data<std::string_view>("type", meta_id);
				if (type != "bool") {
					return {};
				}

				return (slk->data<std::string_view>(field, id) == "1") ? Qt::Checked : Qt::Unchecked;
			}
			case Qt::DecorationRole:
				const std::string_view meta_id = slk->field_to_meta_id(*meta_slk, field, id).value();
				const std::string_view type = meta_slk->data<std::string_view>("type", meta_id);
				if (type != "icon") {
					return {};
				}

				const std::string_view icon = slk->data<std::string_view>(field, id);
				if (icon.empty()) {
					return invalid_icon->icon;
				}

				if (path_to_icon.contains(icon)) {
					return path_to_icon.at(icon)->icon;
				}

				fs::path icon_path = icon;
				if (!hierarchy.file_exists(icon)) {
					icon_path.replace_extension(".dds");
					if (!hierarchy.file_exists(icon_path)) {
						return invalid_icon->icon;
					}
				}

				path_to_icon[icon_path.string()] = resource_manager.load<QIconResource>(icon_path);
				return path_to_icon.at(icon_path.string())->icon;
		}

		return {};
	}

	bool setData(const QModelIndex& index, const QVariant& value, int role = Qt::EditRole) override {
		if (!index.isValid()) {
			return {};
		}

		switch (role) {
			case Qt::EditRole:
				slk->set_shadow_data(index.column(), index.row(), value.toString().toStdString());
				emit dataChanged(index, index, { Qt::DisplayRole, Qt::EditRole, Qt::DecorationRole });
				return true;
			case Qt::CheckStateRole: {
				const std::string& id = slk->index_to_row.at(index.row());
				const std::string& field = slk->index_to_column.at(index.column());
				const std::string_view meta_id = slk->field_to_meta_id(*meta_slk, field, id).value();
				const std::string_view type = meta_slk->data<std::string_view>("type", meta_id);
				if (type != "bool") {
					return false;
				}

				slk->set_shadow_data(index.column(), index.row(), (value.toInt() == Qt::Checked) ? "1" : "0");
				emit dataChanged(index, index, { role });
				return true;
			}
		}
		return false;
	}

	QVariant headerData(int section, const Qt::Orientation orientation, const int role = Qt::DisplayRole) const override {
		if (role != Qt::DisplayRole) {
			return {};
		}

		if (orientation == Qt::Orientation::Horizontal) {
			return QString::fromUtf8(slk->data<std::string_view>(section, 0));
		} else {
			return QString::fromUtf8(slk->data<std::string_view>(0, section));
		}
	}

	[[nodiscard]] Qt::ItemFlags flags(const QModelIndex& index) const override {
		if (!index.isValid()) {
			return Qt::NoItemFlags;
		}

		Qt::ItemFlags flags = QAbstractTableModel::flags(index);

		const std::string_view id = slk->index_to_row.at(index.row());
		const std::string_view field = slk->index_to_column.at(index.column());
		const std::string_view meta_id = slk->field_to_meta_id(*meta_slk, field, id).value();
		const std::string_view type = meta_slk->data<std::string_view>("type", meta_id);
		if (type == "bool") {
			flags |= Qt::ItemIsUserCheckable;
		}

		if (!(flags & Qt::ItemIsUserCheckable)) {
			flags |= Qt::ItemIsEditable;
		}

		return flags;
	}

	template<typename F>
	void addRow(F f) {
		beginInsertRows(QModelIndex(), rowCount(), rowCount());
		f();
		endInsertRows();
	}

	void copyRow(std::string_view row_header, std::string_view new_row_header) {
		beginInsertRows(QModelIndex(), rowCount(), rowCount());

		slk->copy_row(row_header, new_row_header, true);
		endInsertRows();
	}

	void deleteRow(const std::string_view row_header) {
		const int row = slk->row_headers.at(row_header);
		beginRemoveRows(QModelIndex(), row, row);
		slk->remove_row(row_header);
		endRemoveRows();
	}

	// Returns the model index belonging to the row with the given id
	QModelIndex rowIDToIndex(const std::string_view id) const {
		return createIndex(slk->row_headers.at(id), 0);
	}
};
```

`src/models/tree/ability_tree_model.ixx`:

```ixx
module;

#include <QMap>
#include <QModelIndex>

export module AbilityTreeModel;

import std;
import BaseTreeModel;
import SLK;
import Globals;
import UnorderedMap;

export class AbilityTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		BaseTreeItem* item;
	};

	hive::unordered_map<std::string, Category> categories;
	std::vector<std::string> rowToCategory;

	std::array<std::string, 3> subCategories = {
		"Units",
		"Heroes",
		"Items"
	};

	BaseTreeItem* getFolderParent(const std::string& id) const override {
		const std::string_view race = abilities_slk.data<std::string_view>("race", id);
		auto found_race = categories.find(race);
		if (found_race == categories.end()) {
			std::println("Warning: Empty or invalid race for ability ID `{}`, race `{}`", id, race);
			return nullptr;
		}
		const bool isHero = abilities_slk.data<bool>("hero", id);
		const bool isItem = abilities_slk.data<bool>("item", id);

		int subIndex = 0;
		if (isHero) {
			subIndex = 1;
		} else if (isItem) {
			subIndex = 2;
		}

		return found_race->second.item->children[subIndex];
	}

  public:
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

		switch (role) {
			case Qt::EditRole:
			case Qt::DisplayRole:
				if (item->baseCategory) {
					return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
				} else if (item->subCategory) {
					return QString::fromStdString(subCategories[index.row()]);
				} else {
					return QAbstractProxyModel::data(index, role).toString() + " " + sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorsuffix")), role).toString();
				}
			default:
				return BaseTreeModel::data(index, role);
		}
	}

	explicit AbilityTreeModel(QObject* parent) : BaseTreeModel(parent) {
		slk = &abilities_slk;

		for (const auto& [key, value] : unit_editor_data.section("unitRace")) {
			if (key == "Sort" || key == "NumValues") {
				continue;
			}

			categories[value[0]].name = value[1];
			categories[value[0]].item = new BaseTreeItem(rootItem);
			categories[value[0]].item->baseCategory = true;
			rowToCategory.push_back(value[0]);
		}

		for (const auto& i : rootItem->children) {
			for (const auto& subCategory : subCategories) {
				BaseTreeItem* item = new BaseTreeItem(i);
				item->subCategory = true;
			}
		}

		for (int i = 0; i < abilities_slk.rows(); i++) {
			const std::string& id = abilities_slk.index_to_row.at(i);

			BaseTreeItem* parent_item = getFolderParent(id);
			if (!parent_item) {
				continue;
			}

			BaseTreeItem* item = new BaseTreeItem(parent_item);
			item->id = id;
			items.emplace(id, item);
		}

		categoryChangeFields = { "race", "hero", "item" };
	}
};
```

`src/models/tree/base_tree_model.ixx`:

```ixx
module;

#include <QAbstractProxyModel>
#include <QPainter>
#include <QFileIconProvider>
#include <QSortFilterProxyModel>

export module BaseTreeModel;

import std;
import SLK;

export class BaseTreeItem {
  public:
	QVector<BaseTreeItem*> children;
	BaseTreeItem* parent = nullptr;

	explicit BaseTreeItem(BaseTreeItem* parent = nullptr)
		: parent(parent) {
		if (parent != nullptr) {
			parent->appendChild(this);
		}
	}

	~BaseTreeItem() {
		qDeleteAll(children);
	}

	void appendChild(BaseTreeItem* item) {
		item->parent = this;
		children.append(item);
	}

	void removeChild(BaseTreeItem* item) {
		item->parent = nullptr;
		children.removeOne(item);
	}

	int row() const {
		if (parent) {
			return parent->children.indexOf(const_cast<BaseTreeItem*>(this));
		}

		return 0;
	}

	std::string id;
	bool baseCategory = false;
	bool subCategory = false;
};

export class BaseTreeModel : public QAbstractProxyModel {
	int rowCount(const QModelIndex& parent) const override {
		if (parent.column() > 0) {
			return 0;
		}

		BaseTreeItem* parentItem;

		if (!parent.isValid()) {
			parentItem = rootItem;
		} else {
			parentItem = static_cast<BaseTreeItem*>(parent.internalPointer());
		}

		return parentItem->children.count();
	}

	int columnCount(const QModelIndex& parent) const override {
		return 1;
	}

	Qt::ItemFlags flags(const QModelIndex& index) const override {
		if (!index.isValid()) {
			return Qt::NoItemFlags;
		}

		return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
	}

	QModelIndex index(int row, int column, const QModelIndex& parent) const override {
		if (!hasIndex(row, column, parent))
			return QModelIndex();

		BaseTreeItem* parentItem;

		if (!parent.isValid()) {
			parentItem = rootItem;
		} else {
			parentItem = static_cast<BaseTreeItem*>(parent.internalPointer());
		}

		BaseTreeItem* childItem = parentItem->children.at(row);
		if (childItem)
			return createIndex(row, column, childItem);
		return QModelIndex();
	}

	QModelIndex parent(const QModelIndex& index) const override {
		if (!index.isValid()) {
			return {};
		}

		BaseTreeItem* childItem = static_cast<BaseTreeItem*>(index.internalPointer());
		BaseTreeItem* parentItem = childItem->parent;

		if (parentItem == rootItem)
			return QModelIndex();

		return createIndex(parentItem->row(), 0, parentItem);
	}

	void rowsInserted(const QModelIndex& parent, int first, int last) {
		assert(first == last);

		const std::string id = slk->index_to_row.at(first);
		BaseTreeItem* parent_item = getFolderParent(id);

		beginInsertRows(createIndex(parent_item->row(), 0, parent_item), parent_item->children.size(), parent_item->children.size());
		BaseTreeItem* item = new BaseTreeItem(parent_item);
		item->id = id;
		items.emplace(id, item);
		endInsertRows();
	}

	void rowsRemoved(const QModelIndex& parent, int first, int last) {
		assert(first == last);

		const std::string id = slk->index_to_row.at(first);
		BaseTreeItem* child = items.at(id);

		BaseTreeItem* parent_item = child->parent;
		const int row = parent_item->children.indexOf(child);

		beginRemoveRows(createIndex(parent_item->row(), 0, parent_item), row, row);
		parent_item->removeChild(child);
		items.erase(id);
		delete child;
		endRemoveRows();
	}

	void sourceDataChanged(const QModelIndex& topLeft, const QModelIndex& bottomRight, const QVector<int>& roles) {
		Q_ASSERT(topLeft.isValid());
		Q_ASSERT(topLeft.model() == this->sourceModel());
		Q_ASSERT(bottomRight.isValid());
		Q_ASSERT(bottomRight.model() == this->sourceModel());

		// If the changed field is one of those that determine the item's location in the tree we have to move it
		if (std::find(categoryChangeFields.begin(), categoryChangeFields.end(), slk->index_to_column[topLeft.column()]) != categoryChangeFields.end()) {
			const std::string id = slk->index_to_row.at(topLeft.row());

			BaseTreeItem* parent_item = items.at(id)->parent;
			int row = parent_item->children.indexOf(items.at(id));

			BaseTreeItem* new_parent = getFolderParent(id);
			const QModelIndex source_parent = createIndex(parent_item->row(), 0, parent_item);
			const QModelIndex target_parent = createIndex(new_parent->row(), 0, new_parent);

			beginMoveRows(source_parent, row, row, target_parent, new_parent->children.size());
			BaseTreeItem* child = parent_item->children[row];
			parent_item->removeChild(child);
			new_parent->appendChild(child);
			endMoveRows();
		}

		emit dataChanged(mapFromSource(topLeft), mapFromSource(bottomRight), roles);
	}

	// BaseTreeItem* newItem(std::string id);
	// void removeItem(std::string id);

	virtual BaseTreeItem* getFolderParent(const std::string& id) const {
		return nullptr;
	};

  public:
	explicit BaseTreeModel(QObject* parent = nullptr)
		: QAbstractProxyModel(parent) {
		rootItem = new BaseTreeItem();

		QFileIconProvider icons;
		folderIcon = icons.icon(QFileIconProvider::Folder);
	}

	~BaseTreeModel() {
		delete rootItem;
	}

	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

		switch (role) {
			case Qt::DecorationRole:
				if (item->baseCategory || item->subCategory) {
					return folderIcon;
				}
				if (slk->column_headers.contains("art")) {
					return sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("art")), role);
				} else {
					return sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("buffart")), role);
				}
			case Qt::ForegroundRole:
				if (item->baseCategory || item->subCategory) {
					return {};
				}

				if (slk->shadow_data.contains(item->id)) {
					return QColor("violet");
				} else {
					return {};
				}
			case Qt::ToolTipRole:
				if (item->baseCategory || item->subCategory) {
					return {};
				}

				return "ID: " + QString::fromStdString(item->id);
			default:
				return {};
		}
	}

	QModelIndex mapFromSource(const QModelIndex& sourceIndex) const override {
		if (!sourceIndex.isValid()) {
			return {};
		}

		const std::string id = slk->index_to_row.at(sourceIndex.row());
		const BaseTreeItem* parent_item = items.at(id)->parent;
		const int row = parent_item->children.indexOf(items.at(id));
		return createIndex(row, 0, items.at(id));
	}

	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override {
		if (!proxyIndex.isValid()) {
			return {};
		}

		BaseTreeItem* item = static_cast<BaseTreeItem*>(proxyIndex.internalPointer());

		if (item->baseCategory || item->subCategory) {
			return {};
		}

		if (slk->column_headers.contains("name")) {
			return createIndex(slk->row_headers.at(item->id), slk->column_headers.at("name"), item);
		} else {
			return createIndex(slk->row_headers.at(item->id), slk->column_headers.at("bufftip"), item);
		}
	}

	void setSourceModel(QAbstractItemModel* sourceModel) override {
		beginResetModel();

		if (this->sourceModel()) {
			disconnect(sourceModel, &QAbstractItemModel::rowsInserted, this, &BaseTreeModel::rowsInserted);
			disconnect(sourceModel, &QAbstractItemModel::rowsAboutToBeRemoved, this, &BaseTreeModel::rowsRemoved);
			disconnect(sourceModel, &QAbstractItemModel::dataChanged, this, &BaseTreeModel::sourceDataChanged);
		}

		QAbstractProxyModel::setSourceModel(sourceModel);

		connect(sourceModel, &QAbstractItemModel::rowsInserted, this, &BaseTreeModel::rowsInserted);
		connect(sourceModel, &QAbstractItemModel::rowsAboutToBeRemoved, this, &BaseTreeModel::rowsRemoved);
		connect(sourceModel, &QAbstractItemModel::dataChanged, this, &BaseTreeModel::sourceDataChanged);

		endResetModel();
	}

	QModelIndex getIdIndex(const std::string& id) {
		const BaseTreeItem* parent_item = items.at(id)->parent;
		const int row = parent_item->children.indexOf(items.at(id));
		return createIndex(row, 0, items.at(id));
	}

	BaseTreeItem* rootItem;
	QIcon folderIcon;

	std::vector<std::string> categoryChangeFields;

  protected:
	slk::SLK* slk;
	std::unordered_map<std::string, BaseTreeItem*> items;
};

export class BaseFilter : public QSortFilterProxyModel {
	Q_OBJECT

	bool filterCustom = false;

  public:
	slk::SLK* slk;

	using QSortFilterProxyModel::QSortFilterProxyModel;

	bool filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const {
		QModelIndex index0 = sourceModel()->index(sourceRow, 0, sourceParent);
		BaseTreeItem* item = static_cast<BaseTreeItem*>(index0.internalPointer());

		if (filterCustom) {
			if (item->baseCategory || item->subCategory) {
				return false;
			}

			if (!(slk->shadow_data.contains(item->id) && slk->shadow_data.at(item->id).contains("oldid"))) {
				return false;
			}
		}

		return sourceModel()->data(index0).toString().contains(filterRegularExpression());
	}

  public slots:
	void setFilterCustom(bool filter) {
		filterCustom = filter;
		invalidateFilter();
	}
};

#include "base_tree_model.moc"
```

`src/models/tree/buff_tree_model.ixx`:

```ixx
module;

#include <QMap>
#include <QModelIndex>

export module BuffTreeModel;

import std;
import BaseTreeModel;
import SLK;
import Globals;
import UnorderedMap;

export class BuffTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		BaseTreeItem* item;
	};

	hive::unordered_map<std::string, Category> categories;
	std::vector<std::string> rowToCategory;

	std::array<std::string, 2> subCategories = {
		"Buffs",
		"Effects",
	};

	BaseTreeItem* getFolderParent(const std::string& id) const override {
		const std::string_view race = buff_slk.data<std::string_view>("race", id);
		if (race.empty()) {
			std::cout << "Empty race for " << id << " in buffs\n";
			return nullptr;
		}
		const bool isEffect = buff_slk.data("iseffect", id) == "1";
		const int subIndex = isEffect ? 1 : 0;

		return categories.at(race).item->children[subIndex];
	}

  public:
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

		switch (role) {
			case Qt::EditRole:
			case Qt::DisplayRole:
				if (item->baseCategory) {
					return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
				} else if (item->subCategory) {
					return QString::fromStdString(subCategories[index.row()]);
				} else {
					const QString editorname = sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorname")), role).toString();
					if (editorname.isEmpty()) {
						return QAbstractProxyModel::data(index, role).toString() + " " + sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorsuffix")), role).toString();
					} else {
						return editorname + " " + sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorsuffix")), role).toString();
					}
				}
			default:
				return BaseTreeModel::data(index, role);
		}
	}

	explicit BuffTreeModel(QObject* parent)
		: BaseTreeModel(parent) {
		slk = &buff_slk;

		for (const auto& [key, value] : unit_editor_data.section("unitRace")) {
			if (key == "Sort" || key == "NumValues") {
				continue;
			}

			categories[value[0]].name = value[1];
			categories[value[0]].item = new BaseTreeItem(rootItem);
			categories[value[0]].item->baseCategory = true;
			rowToCategory.push_back(value[0]);
		}

		for (const auto& i : rootItem->children) {
			for (const auto& subCategory : subCategories) {
				BaseTreeItem* item = new BaseTreeItem(i);
				item->subCategory = true;
			}
		}

		for (int i = 0; i < buff_slk.rows(); i++) {
			const std::string& id = buff_slk.index_to_row.at(i);

			BaseTreeItem* parent_item = getFolderParent(id);
			if (!parent_item) {
				continue;
			}

			BaseTreeItem* item = new BaseTreeItem(parent_item);
			item->id = id;
			items.emplace(id, item);
		}

		categoryChangeFields = { "race", "iseffect" };
	}
};
```

`src/models/tree/destructible_tree_model.ixx`:

```ixx
module;

#include <QMap>
#include <QMargins>
#include <QObject>
#include <QModelIndex>
#include <QSize>
#include <QIcon>

export module DestructibleTreeModel;

import std;
import BaseTreeModel;
import QIconResource;
import SLK;
import Globals;
import ResourceManager;

export class DestructibleTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		std::shared_ptr<QIconResource> icon;
		BaseTreeItem* item;
	};

	std::unordered_map<char, Category> categories;
	std::vector<char> rowToCategory;

	BaseTreeItem* getFolderParent(const std::string& id) const override {
		const std::string_view category = destructibles_slk.data<std::string_view>("category", id);

		return categories.at(category.front()).item;
	}

  public:
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

		switch (role) {
			case Qt::EditRole:
			case Qt::DisplayRole:
				if (item->baseCategory) {
					return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
				} else {
					return QAbstractProxyModel::data(index, role).toString() + " " + sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorsuffix")), role).toString();
				}
			case Qt::DecorationRole:
				if (item->baseCategory || item->subCategory) {
					return folderIcon;
				}

				return categories.at(rowToCategory[index.parent().row()]).icon->icon;
			default:
				return BaseTreeModel::data(index, role);
		}
	}

	explicit DestructibleTreeModel(QObject* parent)
		: BaseTreeModel(parent) {
		slk = &destructibles_slk;

		for (const auto& [key, value] : world_edit_data.section("DestructibleCategories")) {
			categories[key.front()].name = value[0];
			categories[key.front()].icon = resource_manager.load<QIconResource>(value[1]);
			categories[key.front()].item = new BaseTreeItem(rootItem);
			categories[key.front()].item->baseCategory = true;
			rowToCategory.push_back(key.front());
		}

		for (const auto& [id, index] : destructibles_slk.row_headers) {
			BaseTreeItem* item = new BaseTreeItem(getFolderParent(id));
			item->id = id;
			items.emplace(id, item);
		}

		categoryChangeFields = { "category" };
	}
};
```

`src/models/tree/doodad_tree_model.ixx`:

```ixx
module;

#include <QMap>
#include <QObject>
#include <QModelIndex>
#include <QIcon>

export module DoodadTreeModel;

import std;
import BaseTreeModel;
import QIconResource;
import SLK;
import Globals;

export class DoodadTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		std::shared_ptr<QIconResource> icon;
		BaseTreeItem* item;
	};

	std::unordered_map<char, Category> categories;
	std::vector<char> rowToCategory;

	BaseTreeItem* getFolderParent(const std::string& id) const override {
		const std::string_view category = doodads_slk.data<std::string_view>("category", id);

		return categories.at(category.front()).item;
	}

  public:
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

		switch (role) {
			case Qt::EditRole:
			case Qt::DisplayRole:
				if (item->baseCategory) {
					return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
				} else {
					return QAbstractProxyModel::data(index, role).toString();
				}
			case Qt::DecorationRole:
				if (item->baseCategory || item->subCategory) {
					return folderIcon;
				}

				return categories.at(rowToCategory[index.parent().row()]).icon->icon;
			default:
				return BaseTreeModel::data(index, role);
		}
	}

	explicit DoodadTreeModel(QObject* parent)
		: BaseTreeModel(parent) {
		slk = &doodads_slk;

		for (const auto& [key, value] : world_edit_data.section("DoodadCategories")) {
			categories[key.front()].name = value[0];
			categories[key.front()].icon = resource_manager.load<QIconResource>(value[1]);
			categories[key.front()].item = new BaseTreeItem(rootItem);
			categories[key.front()].item->baseCategory = true;
			rowToCategory.push_back(key.front());
		}

		for (size_t i = 0; i < doodads_slk.rows(); i++) {
			const std::string& id = doodads_slk.index_to_row.at(i);
			BaseTreeItem* item = new BaseTreeItem(getFolderParent(id));
			item->id = id;
			items.emplace(id, item);
		}

		categoryChangeFields = { "category" };
	}
};
```

`src/models/tree/item_tree_model.ixx`:

```ixx
module;

#include <QMap>
#include <QObject>
#include <QModelIndex>
#include <QIcon>

export module ItemTreeModel;

import std;
import BaseTreeModel;
import SLK;
import Globals;
import UnorderedMap;

export class ItemTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		BaseTreeItem* item;
	};

	hive::unordered_map<std::string, Category> categories;
	std::vector<std::string> rowToCategory;

	BaseTreeItem* getFolderParent(const std::string& id) const override {
		const std::string_view itemClass = items_slk.data<std::string_view>("class", id);
		if (itemClass.empty()) {
			std::cout << "Empty class for " << id << " in items\n";
			return nullptr;
		}

		return categories.at(itemClass).item;
	}

  public:
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

		switch (role) {
			case Qt::EditRole:
			case Qt::DisplayRole:
				if (item->baseCategory) {
					return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
				} else {
					return QAbstractProxyModel::data(index, role);
				}
			default:
				return BaseTreeModel::data(index, role);
		}
	}

	explicit ItemTreeModel(QObject* parent)
		: BaseTreeModel(parent) {
		slk = &items_slk;

		for (const auto& [key, value] : unit_editor_data.section("itemClass")) {
			if (key == "Sort" || key == "NumValues") {
				continue;
			}

			categories[value[0]].name = value[1];
			categories[value[0]].item = new BaseTreeItem(rootItem);
			categories[value[0]].item->baseCategory = true;
			rowToCategory.push_back(value[0]);
		}

		for (int i = 0; i < items_slk.rows(); i++) {
			const std::string& id = items_slk.index_to_row.at(i);

			BaseTreeItem* parent_item = getFolderParent(id);
			if (!parent_item) {
				continue;
			}
			BaseTreeItem* item = new BaseTreeItem(parent_item);
			item->id = id;
			items.emplace(id, item);
		}

		categoryChangeFields = { "class" };
	}
};
```

`src/models/tree/unit_tree_model.ixx`:

```ixx
module;

#include <QMargins>
#include <QObject>
#include <QModelIndex>

export module UnitTreeModel;

import std;
import BaseTreeModel;
import SLK;
import Globals;
import UnorderedMap;

export class UnitTreeModel : public BaseTreeModel {
	Q_OBJECT

	struct Category {
		std::string name;
		BaseTreeItem* item;
	};

	hive::unordered_map<std::string, Category> categories;
	std::vector<std::string> rowToCategory;

	std::array<std::string, 4> subCategories = {
		"Units",
		"Buildings",
		"Heroes",
		"Special",
	};

	BaseTreeItem* getFolderParent(const std::string& id) const override {
		const std::string_view race = units_slk.data<std::string_view>("race", id);
		const bool isBuilding = units_slk.data<std::string_view>("isbldg", id) == "1";
		const bool isHero = isupper(id.front());
		const bool isSpecial = units_slk.data<std::string_view>("special", id) == "1";

		int subIndex = 0;
		if (isSpecial) {
			subIndex = 3;
		} else if (isBuilding) {
			subIndex = 1;
		} else if (isHero) {
			subIndex = 2;
		}

		return categories.at(race).item->children[subIndex];
	}

  public:
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

		switch (role) {
			case Qt::EditRole:
			case Qt::DisplayRole:
				if (item->baseCategory) {
					return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
				} else if (item->subCategory) {
					return QString::fromStdString(subCategories[index.row()] + " (" + std::to_string(item->children.size()) + ")");
				} else {
					if (units_slk.data<std::string_view>("campaign", item->id) == "1") {
						const std::string_view properNames = units_slk.data<std::string_view>("propernames", item->id);

						if (!properNames.empty()) {
							return QString::fromUtf8(properNames).split(',').first();
						}
					}

					return QAbstractProxyModel::data(index, role).toString() + " " + sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorsuffix")), role).toString();
				}
			default:
				return BaseTreeModel::data(index, role);
		}
	}

	explicit UnitTreeModel(QObject* parent)
		: BaseTreeModel(parent) {
		slk = &units_slk;

		for (const auto& [key, value] : unit_editor_data.section("unitRace")) {
			if (key == "Sort" || key == "NumValues") {
				continue;
			}

			categories[value[0]].name = value[1];
			categories[value[0]].item = new BaseTreeItem(rootItem);
			categories[value[0]].item->baseCategory = true;
			rowToCategory.push_back(value[0]);
		}

		for (const auto& i : rootItem->children) {
			for (const auto& subCategory : subCategories) {
				BaseTreeItem* item = new BaseTreeItem(i);
				item->subCategory = true;
			}
		}

		for (size_t i = 0; i < units_slk.rows(); i++) {
			const std::string id = units_slk.index_to_row.at(i);
			BaseTreeItem* item = new BaseTreeItem(getFolderParent(id));
			item->id = id;
			items.emplace(id, item);
		}

		categoryChangeFields = { "race", "isbldg", "special" };
	}
};

#include "unit_tree_model.moc"
```

`src/models/tree/upgrade_tree_model.ixx`:

```ixx
module;

#include <QMap>
#include <QModelIndex>

export module UpgradeTreeModel;

import std;
import BaseTreeModel;
import SLK;
import Globals;
import UnorderedMap;

export class UpgradeTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		BaseTreeItem* item;
	};

	hive::unordered_map<std::string, Category> categories;
	std::vector<std::string> rowToCategory;

	BaseTreeItem* getFolderParent(const std::string& id) const override {
		const std::string_view race = upgrade_slk.data<std::string_view>("race", id);
		if (race.empty()) {
			std::cout << "Empty race for " << id << " in items\n";
			return nullptr;
		}

		return categories.at(race).item;
	}

	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override {
		if (!proxyIndex.isValid()) {
			return {};
		}

		BaseTreeItem* item = static_cast<BaseTreeItem*>(proxyIndex.internalPointer());

		if (item->baseCategory || item->subCategory) {
			return {};
		}

		return createIndex(slk->row_headers.at(item->id), slk->column_headers.at("name1"), item);
	}

  public:
	QVariant data(const QModelIndex& index, int role) const override {
		if (!index.isValid()) {
			return {};
		}

		BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

		switch (role) {
			case Qt::DecorationRole:
				if (item->baseCategory || item->subCategory) {
					return folderIcon;
				}
				return sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("art1")), role);
			case Qt::EditRole:
			case Qt::DisplayRole:
				if (item->baseCategory) {
					return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
				} else {
					return QAbstractProxyModel::data(index, role).toString() + " " + QString::fromUtf8(upgrade_slk.data<std::string_view>("editorsuffix", item->id));
				}
			default:
				return BaseTreeModel::data(index, role);
		}
	}

	explicit UpgradeTreeModel(QObject* parent)
		: BaseTreeModel(parent) {
		slk = &upgrade_slk;

		for (const auto& [key, value] : unit_editor_data.section("unitRace")) {
			if (key == "Sort" || key == "NumValues") {
				continue;
			}

			categories[value[0]].name = value[1];
			categories[value[0]].item = new BaseTreeItem(rootItem);
			categories[value[0]].item->baseCategory = true;
			rowToCategory.push_back(value[0]);
		}

		for (int i = 0; i < upgrade_slk.rows(); i++) {
			const std::string& id = upgrade_slk.index_to_row.at(i);

			const std::string_view race = upgrade_slk.data<std::string_view>("race", id);
			if (race.empty()) {
				std::cout << "Empty race for " << i << " in items\n";
				continue;
			}

			BaseTreeItem* parent_item = getFolderParent(id);
			if (!parent_item) {
				continue;
			}

			BaseTreeItem* item = new BaseTreeItem(parent_item);
			item->id = id;
			items.emplace(id, item);
		}

		categoryChangeFields = { "race" };
	}
};
```

`src/object_editor/ability_list_editor.ixx`:

```ixx
//module;
//
//#include <QObject>
//#include <QWidget>
//#include <QDialog>
//#include <QVBoxLayout>
//#include <QListWidget>
//#include <QPushButton>
//#include <QSortFilterProxyModel>
//#include <QTreeView>
//#include <QDialogButtonBox>
//#include <QTreeView>
//
export module ability_list_editor;
//
//import AbilityTreeModel;
//
//
//export QDialog* create_ability_list_editor(QWidget* editor) {
//	QDialog* dialog = new QDialog(editor, Qt::Window | Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
//	dialog->setObjectName("dialog");
//	dialog->resize(256, 360);
//	dialog->setWindowModality(Qt::WindowModality::WindowModal);
//
//	QVBoxLayout* layout = new QVBoxLayout(dialog);
//
//	QListWidget* list = new QListWidget;
//	list->setObjectName("abilityList");
//	list->setIconSize(QSize(32, 32));
//	list->setDragDropMode(QAbstractItemView::DragDropMode::InternalMove);
//	layout->addWidget(list);
//
//	QHBoxLayout* hbox = new QHBoxLayout;
//
//	QPushButton* add = new QPushButton("Add");
//	QPushButton* remove = new QPushButton("Remove");
//	remove->setDisabled(true);
//	hbox->addWidget(add);
//	hbox->addWidget(remove);
//	layout->addLayout(hbox);
//	connect(add, &QPushButton::clicked, [=]() {
//		QDialog* selectdialog = new QDialog(dialog, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
//		selectdialog->resize(300, 560);
//		selectdialog->setWindowModality(Qt::WindowModality::WindowModal);
//
//		QVBoxLayout* selectlayout = new QVBoxLayout(selectdialog);
//
//		AbilityTreeModel* abilityTreeModel = new AbilityTreeModel(dialog);
//		abilityTreeModel->setSourceModel(abilities_table);
//		QSortFilterProxyModel* filter = new QSortFilterProxyModel;
//		filter->setSourceModel(abilityTreeModel);
//		filter->setRecursiveFilteringEnabled(true);
//		filter->setFilterCaseSensitivity(Qt::CaseSensitivity::CaseInsensitive);
//
//		QLineEdit* search = new QLineEdit;
//		search->setPlaceholderText("Search Abilities");
//		QTreeView* view = new QTreeView;
//		view->setModel(filter);
//		view->header()->hide();
//		view->expandAll();
//
//		connect(search, &QLineEdit::textChanged, filter, QOverload<const QString&>::of(&QSortFilterProxyModel::setFilterFixedString));
//
//		selectlayout->addWidget(search);
//		selectlayout->addWidget(view);
//
//		QDialogButtonBox* buttonBox2 = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
//		connect(buttonBox2, &QDialogButtonBox::accepted, selectdialog, &QDialog::accept);
//		connect(buttonBox2, &QDialogButtonBox::rejected, selectdialog, &QDialog::reject);
//		selectlayout->addWidget(buttonBox2);
//
//		auto add = [filter, list, selectdialog](const QModelIndex& index) {
//			QModelIndex sourceIndex = filter->mapToSource(index);
//			BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(sourceIndex.internalPointer());
//			if (treeItem->baseCategory || treeItem->subCategory) {
//				return;
//			}
//
//			std::print("Valid\n");
//
//			QListWidgetItem* item = new QListWidgetItem;
//			item->setText(QString::fromStdString(abilities_slk.data("name", treeItem->id)));
//			item->setData(Qt::StatusTipRole, QString::fromStdString(treeItem->id));
//			auto one = abilities_slk.row_headers.at(treeItem->id);
//			auto two = abilities_slk.column_headers.at("art");
//			item->setIcon(abilities_table->data(abilities_table->index(one, two), Qt::DecorationRole).value<QIcon>());
//			list->addItem(item);
//			selectdialog->close();
//		};
//
//		connect(view, &QTreeView::activated, [=](const QModelIndex& index) {
//			add(index);
//		});
//
//		connect(selectdialog, &QDialog::accepted, [=]() {
//			auto indices = view->selectionModel()->selectedIndexes();
//			if (indices.size()) {
//				add(indices.front());
//			}
//		});
//
//		selectdialog->show();
//		selectdialog->move(dialog->geometry().topRight() + QPoint(10, dialog->geometry().height() - selectdialog->geometry().height()));
//	});
//	connect(remove, &QPushButton::clicked, [=]() {
//		for (auto i : list->selectedItems()) {
//			delete i;
//		}
//	});
//	connect(list, &QListWidget::itemSelectionChanged, [=]() {
//		remove->setEnabled(list->selectedItems().size() > 0);
//	});
//
//	QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
//	// connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
//	connect(buttonBox, &QDialogButtonBox::accepted, [=]() {
//		dialog->accept();
//
//		auto yeet = const_cast<TableDelegate*>(this);
//		emit yeet->commitData(editor);
//		emit yeet->closeEditor(editor);
//	});
//	connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
//	layout->addWidget(buttonBox);
//
//	dialog->show();
//	// dialog->move(parent->geometry().center() - QPoint(dialog->geometry().width() / 2, dialog->geometry().height() / 2));
//	return editor;
//}
```

`src/object_editor/global_search.cpp`:

```cpp
#include "global_search.h"

#include "model_editor.h"
#include "object_editor.h"
#include "trigger_editor.h"

#include <QLayout>
#include <QFrame>
#include <QDialog>
#include <ui_object_editor.h>
#include <QPainter>

import std;
import WindowHandler;
import Globals;
import TableModel;

GlobalSearchWidget::GlobalSearchWidget(QWidget* parent) : QDialog(parent) {
	setWindowFlag(Qt::FramelessWindowHint, true);
	setAttribute(Qt::WA_DeleteOnClose);

	resize(500, 700);

	ability_list_model = new AbilityListModel(this);
	ability_list_model->setSourceModel(abilities_table);
	ability_filter_model = new AbilityListFilter(this);
	ability_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	ability_filter_model->setSourceModel(ability_list_model);
	ability_filter_model->sort(0, Qt::AscendingOrder);

	destructable_list_model = new DestructableListModel(this);
	destructable_list_model->setSourceModel(destructibles_table);
	destructable_filter_model = new DestructableListFilter(this);
	destructable_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	destructable_filter_model->setSourceModel(destructable_list_model);
	destructable_filter_model->sort(0, Qt::AscendingOrder);

	doodad_list_model = new DoodadListModel(this);
	doodad_list_model->setSourceModel(doodads_table);
	doodad_filter_model = new DoodadListFilter(this);
	doodad_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	doodad_filter_model->setSourceModel(doodad_list_model);
	doodad_filter_model->sort(0, Qt::AscendingOrder);

	items_list_model = new ItemListModel(this);
	items_list_model->setSourceModel(items_table);
	item_filter_model = new ItemListFilter(this);
	item_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	item_filter_model->setSourceModel(items_list_model);
	item_filter_model->sort(0, Qt::AscendingOrder);

	unit_list_model = new UnitListModel(this);
	unit_list_model->setSourceModel(units_table);
	units_filter_model = new UnitListFilter(this);
	units_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	units_filter_model->setSourceModel(unit_list_model);
	units_filter_model->sort(0, Qt::AscendingOrder);

	upgrade_list_model = new UpgradeListModel(this);
	upgrade_list_model->setSourceModel(upgrade_table);
	upgrade_filter_model = new UpgradeListFilter(this);
	upgrade_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	upgrade_filter_model->setSourceModel(upgrade_list_model);
	upgrade_filter_model->sort(0, Qt::AscendingOrder);

	buff_list_model = new BuffListModel(this);
	buff_list_model->setSourceModel(buff_table);
	buff_filter_model = new BuffListFilter(this);
	buff_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	buff_filter_model->setSourceModel(buff_list_model);
	buff_filter_model->sort(0, Qt::AscendingOrder);

	action_model = new ActionListModel(this);
	action_filter_model = new QSortFilterProxyModel(this);
	action_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	action_filter_model->setSourceModel(action_model);
	action_filter_model->sort(0, Qt::AscendingOrder);

	concat_table = new QConcatenateTablesProxyModel(this);
	concat_table->addSourceModel(units_filter_model);
	concat_table->addSourceModel(ability_filter_model);
	concat_table->addSourceModel(destructable_filter_model);
	concat_table->addSourceModel(doodad_filter_model);
	concat_table->addSourceModel(item_filter_model);
	concat_table->addSourceModel(upgrade_filter_model);
	concat_table->addSourceModel(buff_filter_model);
	concat_table->addSourceModel(action_filter_model);

	list = new QListView;
	list->setModel(concat_table);
	list->setUniformItemSizes(true);
	list->setGridSize(QSize(list->gridSize().width(), 32));
	list->setIconSize(QSize(32, 32));
	list->setCurrentIndex(concat_table->index(0, 0));
	list->setItemDelegate(new ExtraTextDelegate(list));

	edit->setClearButtonEnabled(true);
	edit->setPlaceholderText("Find anything");
	edit->addAction(QIcon("data/icons/object_editor/search.png"), QLineEdit::LeadingPosition);
	edit->installEventFilter(this);

	QVBoxLayout* layout = new QVBoxLayout;
	layout->addWidget(edit);
	layout->addWidget(list);
	layout->setSpacing(3);

	setLayout(layout);
	show();

	edit->installEventFilter(this);

	connect(edit, &QLineEdit::textEdited, ability_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(edit, &QLineEdit::textEdited, item_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(edit, &QLineEdit::textEdited, units_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(edit, &QLineEdit::textEdited, doodad_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(edit, &QLineEdit::textEdited, destructable_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(edit, &QLineEdit::textEdited, upgrade_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(edit, &QLineEdit::textEdited, buff_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(edit, &QLineEdit::textEdited, action_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(edit, &QLineEdit::textEdited, [&] {
		list->setCurrentIndex(concat_table->index(0, 0));
	});

	connect(list, &QListView::activated, [=](const QModelIndex& index) {
		const auto model = concat_table->mapToSource(index).model();
		if (model == action_filter_model) {
			if (index.data() == "Open Model Editor") {
				bool created;
				window_handler.create_or_raise<ModelEditor>(nullptr, created);
			} else if (index.data() == "Open Object Editor") {
				bool created;
				window_handler.create_or_raise<ObjectEditor>(nullptr, created);
			} else if (index.data() == "Open Trigger Editor") {
				bool created;
				window_handler.create_or_raise<TriggerEditor>(nullptr, created);
			}
			return;
		}

		std::string id;
		TableModel* table_model = nullptr;
		if (model == units_filter_model) {
			const int row = units_filter_model->mapToSource(concat_table->mapToSource(index)).row();
			id = units_slk.index_to_row.at(row);
			table_model = units_table;
		} else if (model == destructable_filter_model) {
			const int row = destructable_filter_model->mapToSource(concat_table->mapToSource(index)).row();
			id = destructibles_slk.index_to_row.at(row);
			table_model = destructibles_table;
		} else if (model == doodad_filter_model) {
			const int row = doodad_filter_model->mapToSource(concat_table->mapToSource(index)).row();
			id = doodads_slk.index_to_row.at(row);
			table_model = doodads_table;
		} else if (model == item_filter_model) {
			const int row = item_filter_model->mapToSource(concat_table->mapToSource(index)).row();
			id = items_slk.index_to_row.at(row);
			table_model = items_table;
		} else if (model == ability_filter_model) {
			const int row = ability_filter_model->mapToSource(concat_table->mapToSource(index)).row();
			id = abilities_slk.index_to_row.at(row);
			table_model = abilities_table;
		} else if (model == buff_filter_model) {
			const int row = buff_filter_model->mapToSource(concat_table->mapToSource(index)).row();
			id = buff_slk.index_to_row.at(row);
			table_model = buff_table;
		} else if (model == upgrade_filter_model) {
			const int row = upgrade_filter_model->mapToSource(concat_table->mapToSource(index)).row();
			id = upgrade_slk.index_to_row.at(row);
			table_model = upgrade_table;
		}

		bool created;
		auto* object_editor = window_handler.create_or_raise<ObjectEditor>(nullptr, created);
		object_editor->open_by_id(table_model, id, index.data(Qt::DisplayRole).toString(), index.data(Qt::DecorationRole).value<QIcon>());
	});
}

bool GlobalSearchWidget::eventFilter(QObject *object, QEvent *event) {
	if (object == edit && event->type() == QEvent::KeyPress) {
		const QKeyEvent *keyEvent = static_cast<const QKeyEvent *>(event);

		if (keyEvent->key() == Qt::Key_Down || keyEvent->key() == Qt::Key_Up || keyEvent->key() == Qt::Key_Return || keyEvent->key() == Qt::Key_Enter) {
			QCoreApplication::sendEvent(list, event);
			return true;
		}
	}
	return false;
}
```

`src/object_editor/global_search.h`:

```h
#pragma once

#include <string>
#include <print>

#include <QEvent>
#include <QListView>
#include <QDialog>
#include <QPushButton>
#include <QLineEdit>
#include <QConcatenateTablesProxyModel>
#include <QStyledItemDelegate>
#include <QPainter>
#include <QSortFilterProxyModel>

import DestructibleListModel;
import UnitListModel;
import BaseListModel;
import DoodadListModel;
import ItemListModel;
import AbilityListModel;
import UpgradeListModel;
import BuffListModel;

class ActionListModel : public QAbstractListModel {
public:
	struct Item { QString text; QIcon icon; };
	QList<Item> items;

	explicit ActionListModel(QObject* parent = nullptr) : QAbstractListModel(parent) {
		items = {
			{"Open Object Editor", QIcon("data/icons/ribbon/objecteditor32x32.png")},
			{"Open Model Editor", QIcon("data/icons/ribbon/model_editor.png")},
			{"Open Trigger Editor", QIcon("data/icons/ribbon/triggereditor32x32.png")}
		};
	}

	int rowCount(const QModelIndex& parent = QModelIndex()) const override {
		return parent.isValid() ? 0 : items.size();
	}

	QVariant data(const QModelIndex& index, const int role) const override {
		if (!index.isValid() || index.row() >= items.size()) {
			return {};
		}

		const auto& it = items[index.row()];
		if (role == Qt::DisplayRole) {
			return it.text;
		}
		if (role == Qt::DecorationRole) {
			return it.icon;
		}
		return {};
	}
};

class ExtraTextDelegate : public QStyledItemDelegate {
public:
	using QStyledItemDelegate::QStyledItemDelegate;

	QFont font = QFont("Consolas");

	void paint(QPainter *painter, const QStyleOptionViewItem &option,
			   const QModelIndex &index) const override {

		QStyledItemDelegate::paint(painter, option, index);

		const QString rightText = index.data(Qt::UserRole).toString();
		if (rightText.isEmpty()) {
			return;
		}

		painter->save();
		painter->setFont(font);
		painter->setPen(Qt::gray);

		const QRect rect = option.rect;
		const QRect rightRect = rect.adjusted(6, 0, -6, 0);
		const QFontMetrics fm = painter->fontMetrics();
		const int x = rightRect.right() - fm.horizontalAdvance(rightText);
		const int y = rightRect.top() + (rightRect.height() - fm.height()) / 2;

		painter->drawText(x, y + fm.ascent(), rightText);
		painter->restore();
	}
};

class GlobalSearchWidget : public QDialog {
	Q_OBJECT

	QLineEdit* edit = new QLineEdit;
	QPushButton* case_sensitive = new QPushButton;
	QPushButton* match_whole_word = new QPushButton;
	QPushButton* regular_expression = new QPushButton;

	DoodadListModel* doodad_list_model;
	DoodadListFilter* doodad_filter_model;
	DestructableListModel* destructable_list_model;
	DestructableListFilter* destructable_filter_model;
	UnitListModel* unit_list_model;
	UnitListFilter* units_filter_model;
	AbilityListModel* ability_list_model;
	AbilityListFilter* ability_filter_model;
	ItemListModel* items_list_model;
	ItemListFilter* item_filter_model;
	UpgradeListModel* upgrade_list_model;
	UpgradeListFilter* upgrade_filter_model;
	BuffListModel* buff_list_model;
	BuffListFilter* buff_filter_model;

	ActionListModel* action_model;
	QSortFilterProxyModel* action_filter_model;

	QConcatenateTablesProxyModel* concat_table;


	QListView* list;

public:
	GlobalSearchWidget(QWidget* parent = nullptr);

	void changeEvent(QEvent* e) override {
		if (e->type() == QEvent::ActivationChange && !isActiveWindow()) {
			close();
		}
	}

	bool eventFilter(QObject *object, QEvent *event) override;

	signals:
		void text_changed(QString text);
	void previous();
	void next();

};
```

`src/object_editor/icon_view.cpp`:

```cpp
#include "icon_view.h"

#include <QVBoxLayout>
#include <QPushButton>
#include <QListView>
#include <QFile>
#include <QJsonDocument>
#include <QJsonArray>
#include <QJsonObject>
#include <QLabel>

import std;
import Hierarchy;
import Globals;

namespace fs = std::filesystem;

std::unordered_map<std::string, std::shared_ptr<QIconResource>> icon_cache;

IconModel::IconModel(QObject* parent) : QAbstractListModel(parent) {
	//std::unordered_map<std::string, QString> icons_map;

	//for (const auto& [key, values] : units_slk.base_data) {
	//	if (!values.contains("art")) {
	//		continue;
	//	}

	//	//std::string art_path = values.at("art");
	//	std::string art_path = to_lowercase_copy(values.at("art"));
	//	art_path = fs::path(art_path).replace_extension("").string();
	//	art_path = split(art_path, ',').front();

	//	if (icons_map.contains(art_path)) {
	//		QString& data = icons_map.at(art_path);
	//		QString new_data = QString::fromStdString(values.at("name"));
	//		if (!data.contains(new_data)) {
	//			data += ", " + new_data;
	//		}
	//	} else {
	//		icons_map.emplace(art_path, QString::fromStdString(values.at("name")));
	//	}
	//}

	//for (const auto& [key, values] : items_slk.base_data) {
	//	if (!values.contains("art")) {
	//		continue;
	//	}

	//	//std::string art_path = values.at("art");
	//	std::string art_path = to_lowercase_copy(values.at("art"));
	//	art_path = fs::path(art_path).replace_extension("").string();
	//	art_path = split(art_path, ',').front();

	//	if (icons_map.contains(art_path)) {
	//		QString& data = icons_map.at(art_path);
	//		QString new_data = QString::fromStdString(values.at("name"));
	//		if (!data.contains(new_data)) {
	//			data += ", " + new_data;
	//		}
	//	} else {
	//		icons_map.emplace(art_path, QString::fromStdString(values.at("name")));
	//	}
	//}

	//for (const auto& [key, values] : buff_slk.base_data) {
	//	if (!values.contains("buffart")) {
	//		continue;
	//	}

	//	QString tags;
	//	if (!values.contains("bufftip") && !values.contains("editorname")) {
	//		std::print("Missing buff name: {}\n", key);
	//		continue;
	//	} else if (!values.contains("bufftip")) {
	//		tags = QString::fromStdString(values.at("editorname"));
	//	} else {
	//		tags = QString::fromStdString(values.at("bufftip"));
	//	}
	//	
	//	//std::string art_path = values.at("buffart");
	//	std::string art_path = to_lowercase_copy(values.at("buffart"));
	//	art_path = fs::path(art_path).replace_extension("").string();
	//	art_path = split(art_path, ',').front();

	//	if (icons_map.contains(art_path)) {
	//		QString& data = icons_map.at(art_path);

	//		if (!data.contains(tags)) {
	//			data += ", " + tags;
	//		}
	//	} else {
	//		icons_map.emplace(art_path, tags);
	//	}
	//}

	//for (const auto& [key, values] : abilities_slk.base_data) {
	//	if (!values.contains("art")) {
	//		continue;
	//	}

	//	QString tags;
	//	if (values.contains("name")) {
	//		tags = QString::fromStdString(values.at("name"));
	//	} else if (values.contains("tip")) {
	//		tags = QString::fromStdString(values.at("tip"));
	//	} else {
	//		std::print("Missing ability name: {}\n", key);
	//		continue;
	//	}
	//	std::string art_path = to_lowercase_copy(values.at("art"));
	//	art_path = fs::path(art_path).replace_extension("").string();

	//	//std::string art_path = values.at("art");
	//	art_path = split(art_path, ',').front();

	//	if (icons_map.contains(art_path)) {
	//		QString& data = icons_map.at(art_path);
	//		if (!data.contains(tags)) {
	//			data += ", " + tags;
	//		}
	//	} else {
	//		icons_map.emplace(art_path, tags);
	//	}
	//}

	//for (const auto& i : fs::directory_iterator("C:/Users/User/Desktop/Warcraft/MPQContent/1.32.x/_hd.w3mod/replaceabletextures/commandbuttons")) {
	//	fs::path path = i.path().lexically_relative("C:/Users/User/Desktop/Warcraft/MPQContent/1.32.x/_hd.w3mod");
	//	path.replace_extension("");
	//	if (icons_map.contains(path.string())) {
	//		continue;
	//	}

	//	icons_map.emplace(path.string(), QString::fromStdString(path.stem().string()).remove(0, 3));
	//}

	//QJsonDocument json;
	//QJsonArray array;
	//for (const auto& [key, value] : icons_map) {
	//	icons.push_back({ key, value });
	//	QJsonObject object;
	//	object["src"] = QString::fromStdString(key);
	//	
	//	QJsonArray raaaa;
	//	auto parts = value.split(", ");
	//	for (const auto& i : parts) {
	//		raaaa.append(i);
	//	}
	//	object["tags"] = raaaa;
	//
	//	array.append(object);
	//}
	//json.setArray(array);
	//std::ofstream file("C:/Users/User/stack/Projects/HiveWE/HiveWE/data/warcraft/icon_tags.json");
	//std::string output = json.toJson().toStdString();
	//file.write(output.data(), output.size());
	//file.close();

	QFile file(fs::path("data/warcraft/icon_tags.json"));
	file.open(QIODevice::ReadOnly);

	QJsonParseError error;
	QJsonDocument json = QJsonDocument::fromJson(file.readAll(), &error);
	file.close();

	if (json.isNull()) {
		std::print("Error parsing icon_tags.json: {}", error.errorString().toStdString());
	}

	for (const auto& i : json.array()) {
		QJsonObject object = i.toObject();
		
		QJsonArray tags = object["tags"].toArray();

		QString text;
		if (tags.size()) {
			text = tags.at(0).toString();
			for (int i = 1; i < tags.size(); i++) {
				text += ", " + tags.at(i).toString();
			}
		}

		std::string string_path = object["src"].toString().toStdString() + ".dds";
		if (!hierarchy.file_exists(string_path)) {
			continue;
		}
		icons.emplace_back(string_path, text);
	}
}

QVariant IconModel::data(const QModelIndex& index, int role) const {
	switch (role) {
		case Qt::DecorationRole: {
			std::string string_path = icons[index.row()].first;

			if (icon_cache.contains(string_path)) {
				return icon_cache.at(string_path)->icon;
			} else {
				icon_cache.emplace(string_path, resource_manager.load<QIconResource>(string_path));
				return icon_cache.at(string_path)->icon;
			}
		}
		case Qt::ToolTipRole:
			return icons[index.row()].second;
		case Qt::EditRole:
			return QString::fromStdString(icons[index.row()].first);
	}

	return {};
}

IconView::IconView(QWidget* parent) : QWidget(parent) {
	model = new IconModel;

	filter->setSourceModel(model);
	filter->setFilterCaseSensitivity(Qt::CaseInsensitive);
	filter->setFilterRole(Qt::ItemDataRole::ToolTipRole);

	view->setViewMode(QListView::IconMode);
	view->setIconSize(QSize(64, 64));
	view->setResizeMode(QListView::ResizeMode::Adjust);
	view->setUniformItemSizes(true);
	view->setWordWrap(true);
	view->setWrapping(true);
	view->setModel(filter);

	QVBoxLayout* layout = new QVBoxLayout;
	layout->setContentsMargins(0, 0, 0, 0);
	//layout->addWidget(type);
	layout->addWidget(search);
	layout->addWidget(view);

	QHBoxLayout* hlayout = new QHBoxLayout;
	hlayout->addWidget(new QLabel("Path"));
	hlayout->addWidget(finalPath);
	//layout->addWidget(finalPath);
	layout->addLayout(hlayout);
	setLayout(layout);

	type->addItem("Units");
	type->addItem("Items");
	type->addItem("Abilities");
	type->addItem("Upgrades");
	type->addItem("Buffs");
	search->setPlaceholderText("Search Icons");

	//connect(type, &QComboBox::currentTextChanged, filter, &QSortFilterProxyModel::setFilterFixedString);
	connect(search, &QLineEdit::textEdited, filter, &QSortFilterProxyModel::setFilterFixedString);

	connect(view->selectionModel(), &QItemSelectionModel::selectionChanged, [&]() {
		if (!view->currentIndex().isValid()) {
			finalPath->clear();
			return;
		}
		
		finalPath->setText(filter->data(view->currentIndex(), Qt::EditRole).toString());
	});
}

QString IconView::currentIconPath() {
	return finalPath->text();
}

void IconView::setCurrentIconPath(QString path) {
	finalPath->setText(path);
}
```

`src/object_editor/icon_view.h`:

```h
#pragma once

#include <unordered_map>
#include <memory>

#include <QDialog>
#include <QComboBox>
#include <QLineEdit>
#include <QListView>
#include <QAbstractListModel>
#include <QSortFilterProxyModel>

import QIconResource;

class IconModel : public QAbstractListModel {
	int rowCount(const QModelIndex& parent = QModelIndex()) const override {
		return static_cast<int>(icons.size());
	}

public:
	explicit IconModel(QObject* parent = nullptr);

	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;

	std::vector<std::pair<std::string, QString>> icons;
};

class IconView : public QWidget {
	Q_OBJECT

	QComboBox* type = new QComboBox;
	QLineEdit* search = new QLineEdit;
	QListView* view = new QListView;
	QLineEdit* finalPath = new QLineEdit;

	QSortFilterProxyModel* filter = new QSortFilterProxyModel;
	IconModel* model;

public:
	IconView(QWidget* parent = nullptr);

	QString currentIconPath();
	void setCurrentIconPath(QString path);
};
```

`src/object_editor/model_view.cpp`:

```cpp
#include "model_view.h"

#include "model_editor.h"

#include <QVBoxLayout>
#include <QPushButton>
#include <QListView>
#include <QLabel>
#include <QMessageBox>

import std;
import Hierarchy;
import Globals;
import WindowHandler;

namespace fs = std::filesystem;

ModelView::ModelView(QWidget* parent) : QWidget(parent) {
	QVBoxLayout* layout = new QVBoxLayout;
	layout->setContentsMargins(0, 0, 0, 0);
	//layout->addWidget(type);
	layout->addWidget(search);
	layout->addWidget(new QLabel("Coming soon: a grid view of models here"));
	// layout->addWidget(view);

	open_in_model_editor->setIcon(QIcon("data/icons/ribbon/model_editor.png"));
	open_in_model_editor->setIconSize(QSize(20, 20));
	open_in_model_editor->setToolTip("Open in Model Editor");

	QHBoxLayout* hlayout = new QHBoxLayout;
	hlayout->addWidget(new QLabel("Path"));
	hlayout->addWidget(finalPath);
	hlayout->addWidget(open_in_model_editor);
	//layout->addWidget(finalPath);
	layout->addLayout(hlayout);
	setLayout(layout);

	type->addItem("Units");
	type->addItem("Items");
	type->addItem("Abilities");
	type->addItem("Upgrades");
	type->addItem("Buffs");
	search->setPlaceholderText("Search Models");

	connect(open_in_model_editor, &QPushButton::clicked, [this] {
		bool created = false;
		auto model_editor = window_handler.create_or_raise<ModelEditor>(nullptr, created);

		auto path = fs::path(finalPath->text().toStdString());
		path.replace_extension(".mdx");

		const auto opened = model_editor->open_model(path, false);
		if (!opened) {
			QMessageBox::critical(this, "Error opening model", QString::fromStdString(std::format("Failed to open model with: {}", opened.error())));
		}
	});
}

QString ModelView::current_model_path() {
	return finalPath->text();
}

void ModelView::set_current_model_path(const QString& path) {
	finalPath->setText(path);
}

```

`src/object_editor/model_view.h`:

```h
#pragma once

#include <unordered_map>
#include <memory>

#include <QComboBox>
#include <QLineEdit>
#include <QPushButton>

class ModelView : public QWidget {
	Q_OBJECT

	QComboBox* type = new QComboBox;
	QLineEdit* search = new QLineEdit;
	QLineEdit* finalPath = new QLineEdit;
	QPushButton* open_in_model_editor = new QPushButton;

public:
	ModelView(QWidget* parent = nullptr);

	QString current_model_path();
	void set_current_model_path(const QString& path);
};
```

`src/object_editor/object_editor.cpp`:

```cpp
#include "object_editor.h"

#include <QTableView>
#include <QLineEdit>
#include <QToolBar>
#include <QDialogButtonBox>
#include <QSortFilterProxyModel>
#include <QAbstractProxyModel>
#include <QPushButton>
#include <QTimer>
#include <QLabel>
#include <QShortcut>
#include <QDialog>
#include <QToolButton>
#include <QScrollArea>
#include <QScrollBar>
#include <QMenu>

import std;
import UnitSelector;
import MapGlobal;
import Globals;
import ResourceManager;
import SlkConversions;
import "single_model.h";

ObjectEditor::ObjectEditor(QWidget* parent) : QMainWindow(parent) {
	ui.setupUi(this);
	setAttribute(Qt::WA_DeleteOnClose);

	std::ifstream f("data/warcraft/ability_insights.json");
	ability_insights = nlohmann::json::parse(f);

	custom_unit_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewUnit"));
	custom_item_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewItem"));
	custom_doodad_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewDood"));
	custom_destructible_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewDest"));
	custom_ability_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewAbil"));
	custom_buff_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewBuff"));
	custom_upgrade_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewUpgr"));

	dock_manager = new ads::CDockManager;
	dock_manager->setStyleSheet("");
	setCentralWidget(dock_manager);

	QLabel* image = new QLabel();
	image->setPixmap(QPixmap("data/icons/object_editor/background.png"));
	image->setAlignment(Qt::AlignCenter);

	auto centraldock_widget = new ads::CDockWidget(dock_manager, "CentralWidget");
	centraldock_widget->setWidget(image);
	centraldock_widget->setFeature(ads::CDockWidget::NoTab, true);
	dock_area = dock_manager->setCentralWidget(centraldock_widget);

	unitTreeModel = new UnitTreeModel(this);
	itemTreeModel = new ItemTreeModel(this);
	doodadTreeModel = new DoodadTreeModel(this);
	destructibleTreeModel = new DestructibleTreeModel(this);
	abilityTreeModel = new AbilityTreeModel(this);
	upgradeTreeModel = new UpgradeTreeModel(this);
	buffTreeModel = new BuffTreeModel(this);

	addTypeTreeView(unitTreeModel, unitTreeFilter, units_table, unit_explorer, custom_unit_icon->icon, "Units", Category::unit);
	addTypeTreeView(itemTreeModel, itemTreeFilter, items_table, item_explorer, custom_item_icon->icon, "Items", Category::item);
	addTypeTreeView(doodadTreeModel, doodadTreeFilter, doodads_table, doodad_explorer, custom_doodad_icon->icon, "Doodads", Category::doodad);
	addTypeTreeView(destructibleTreeModel, destructibleTreeFilter, destructibles_table, destructible_explorer, custom_destructible_icon->icon, "Destructibles", Category::destructible);
	addTypeTreeView(abilityTreeModel, abilityTreeFilter, abilities_table, ability_explorer, custom_ability_icon->icon, "Abilities", Category::ability);
	addTypeTreeView(upgradeTreeModel, upgradeTreeFilter, upgrade_table, upgrade_explorer, custom_upgrade_icon->icon, "Upgrades", Category::upgrade);
	addTypeTreeView(buffTreeModel, buffTreeFilter, buff_table, buff_explorer, custom_buff_icon->icon, "Buffs", Category::buff);

	explorer_area->setCurrentIndex(0);
	// Set initial sizes, the second size doesn't really matter with only 2 dock areas
	dock_manager->setSplitterSizes(explorer_area, { 645, 9999 });

	connect(unit_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(unitTreeFilter, units_table, index); });
	connect(item_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(itemTreeFilter, items_table, index); });
	connect(doodad_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(doodadTreeFilter, doodads_table, index); });
	connect(destructible_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(destructibleTreeFilter, destructibles_table, index); });
	connect(ability_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(abilityTreeFilter, abilities_table, index); });
	connect(upgrade_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(upgradeTreeFilter, upgrade_table, index); });
	connect(buff_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(buffTreeFilter, buff_table, index); });

	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), this), &QShortcut::activated, [&]() {
		auto edit = explorer_area->currentDockWidget()->findChild<QLineEdit*>("search");
		edit->setFocus();
		edit->selectAll();
	});

	show();
}

void ObjectEditor::itemClicked(const QSortFilterProxyModel* model, TableModel* table, const QModelIndex& index) {
	const BaseTreeItem* item = static_cast<BaseTreeItem*>(model->mapToSource(index).internalPointer());
	if (item->baseCategory || item->subCategory) {
		return;
	}

	open_by_id(table, item->id, index.data(Qt::DisplayRole).toString(), index.data(Qt::DecorationRole).value<QIcon>());
}

void ObjectEditor::open_by_id(TableModel* table, const std::string& id, const QString& name, QIcon icon) {
	// If there is already one open for this item
	if (const auto found = dock_manager->findDockWidget(QString::fromStdString(id)); found) {
		found->dockAreaWidget()->setCurrentDockWidget(found);
		found->setFocus();
		found->raise();
		return;
	}

	QVBoxLayout* layout = new QVBoxLayout;
	layout->setContentsMargins(0, 0, 0, 0);

	const auto found = ability_insights.find(id);
	if (found != ability_insights.end()) {
		QLabel* title = new QLabel(QString::fromUtf8((*found)["name"].get<std::string_view>()));
		QFont font1 = title->font();
		font1.setBold(true);
		font1.setPointSize(15);
		title->setFont(font1);

		std::string all_tags = "Tags: ";
		for (const auto& tag : (*found)["tags"]) {
			all_tags += tag.get<std::string_view>() + " ";
		}

		QLabel* tags = new QLabel(QString::fromStdString(all_tags));
		QFont font2 = tags->font();
		font2.setBold(true);
		tags->setFont(font2);

		QLabel* label = new QLabel(QString::fromUtf8((*found)["raw_text"].get<std::string_view>()));
		QLabel* latest_tested_version = new QLabel("Latest tested version: " + QString::fromUtf8((*found)["latest_tested_version"].get<std::string_view>()));
		latest_tested_version->setFont(font2);

		QLabel* link = new QLabel("Fix mistakes or add info directly in <a href=\"https://docs.google.com/document/d/1z17FTnhyfVL87tJgLmwWks3Low6TuQ0tjfKHXBELWpo/edit\">the Google Docs</a>!");
		link->setOpenExternalLinks(true);

		layout->addWidget(title);
		layout->addWidget(tags);
		layout->addWidget(label);
		layout->addWidget(latest_tested_version);
		layout->addWidget(link);
		label->setWordWrap(true);
	}

	QTableView* view = new QTableView;
	TableDelegate* delegate = new TableDelegate;
	view->setItemDelegate(delegate);
	view->horizontalHeader()->hide();
	view->setAlternatingRowColors(true);
	view->setVerticalHeader(new AlterHeader(Qt::Vertical, view));
	view->verticalHeader()->setSectionResizeMode(QHeaderView::ResizeMode::ResizeToContents);
	view->verticalHeader()->setMinimumSectionSize(28);
	view->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeMode::Stretch);
	view->setIconSize({ 24, 24 });
	view->setWordWrap(true);
	view->setSizeAdjustPolicy(QAbstractScrollArea::SizeAdjustPolicy::AdjustToContents);
	layout->addWidget(view);

	QWidget* container = new QWidget;
	container->setLayout(layout);

	QScrollArea* area = new QScrollArea;
	area->setWidget(container);
	area->setWidgetResizable(true);

	ads::CDockWidget* dock_tab = new ads::CDockWidget(dock_manager, "");
	dock_tab->setFeature(ads::CDockWidget::DockWidgetFeature::DockWidgetDeleteOnClose, true);
	dock_tab->setWidget(area);
	// dock_tab->setWidget(view);
	dock_tab->setObjectName(QString::fromStdString(id));
	dock_tab->setWindowTitle(name);
	dock_tab->setIcon(icon);

	SingleModel* single_model = new SingleModel(table, this);
	single_model->setID(id);
	view->setModel(single_model);

	dock_manager->addDockWidget(ads::CenterDockWidgetArea, dock_tab, dock_area);

	// Scroll just past the ability insights
	const int y = view->mapTo(area->widget(), QPoint(0,0)).y();
	area->verticalScrollBar()->setValue(y);
}

void ObjectEditor::addTypeTreeView(BaseTreeModel* treeModel, BaseFilter*& filter, TableModel* table, QTreeView* view, QIcon icon, QString name, Category category) {
	treeModel->setSourceModel(table);
	filter = new BaseFilter;
	filter->slk = table->slk;
	filter->setRecursiveFilteringEnabled(true);
	filter->setFilterCaseSensitivity(Qt::CaseSensitivity::CaseInsensitive);
	filter->setSourceModel(treeModel);
	view->setModel(filter);
	view->header()->hide();
	view->setContextMenuPolicy(Qt::CustomContextMenu);
	view->setSelectionBehavior(QAbstractItemView::SelectRows);
	view->setSelectionMode(QAbstractItemView::ExtendedSelection);
	view->setUniformRowHeights(true);
	view->expandAll();

	connect(view, &QTreeView::customContextMenuRequested, [=, this](const QPoint& pos) {
		QMenu menu;
		QAction* addAction = menu.addAction("Add " + name);
		QAction* removeAction = menu.addAction("Remove " + name);

		if (category == Category::doodad) {
			QAction* convert_to_destructible = menu.addAction("Convert to destructible");

			{
				const auto selection = view->selectionModel()->selectedIndexes();
				if (selection.isEmpty()) {
					convert_to_destructible->setDisabled(true);
				} else {
					const auto treeItem = static_cast<BaseTreeItem*>(filter->mapToSource(selection.front()).internalPointer());
					if (treeItem->id.empty()) {
						convert_to_destructible->setDisabled(true);
					}
				}
			}

			connect(convert_to_destructible, &QAction::triggered, [=, this]() {
				QModelIndexList selection = view->selectionModel()->selectedIndexes();

				for (const auto& i : selection) {
					BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(filter->mapToSource(i).internalPointer());
					if (treeItem->id.empty()) {
						continue;
					}
					std::string new_id;
					destructibles_table->addRow([&] {
						// We pick a barrel (LTbr) for no good reason
						new_id = convert_doodad_to_destructible(treeItem->id, "LTbr");
					});

					const auto index = destructibles_table->rowIDToIndex(new_id);
					const auto index2 = destructibleTreeModel->mapFromSource(index);
					const auto index3 = destructibleTreeFilter->mapFromSource(index2);
					itemClicked(destructibleTreeFilter, destructibles_table, index3);
				}
			});
		}

		QModelIndexList selection = view->selectionModel()->selectedIndexes();
		if (selection.empty()) {
			removeAction->setDisabled(true);
		} else {
			BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(filter->mapToSource(selection.front()).internalPointer());
			if (!table->slk->shadow_data.contains(treeItem->id) || !table->slk->shadow_data.at(treeItem->id).contains("oldid")) {
				removeAction->setDisabled(true);	
			}
		}
		
		connect(addAction, &QAction::triggered, [=, this]() {
			QDialog* selectdialog = new QDialog(this, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
			selectdialog->resize(300, 560);
			selectdialog->setWindowModality(Qt::WindowModality::WindowModal);

			QLineEdit* nameEdit = new QLineEdit;
			nameEdit->setPlaceholderText("New name");
			nameEdit->setReadOnly(true);

			QLineEdit* id = new QLineEdit;
			id->setPlaceholderText("Free ID");
			id->setText(QString::fromStdString(map->get_unique_id(false)));
			id->setFont(QFont("consolas"));

			QHBoxLayout* nameLayout = new QHBoxLayout;
			nameLayout->addWidget(nameEdit, 3);
			nameLayout->addWidget(id, 1);

			BaseFilter* sub_filter = new BaseFilter;
			sub_filter->slk = table->slk;
			sub_filter->setRecursiveFilteringEnabled(true);
			sub_filter->setFilterCaseSensitivity(Qt::CaseSensitivity::CaseInsensitive);
			sub_filter->setSourceModel(treeModel);

			QLineEdit* search = new QLineEdit;
			search->setPlaceholderText("Search " + name);

			QTreeView* sub_view = new QTreeView;
			sub_view->setModel(sub_filter);
			sub_view->setUniformRowHeights(true);
			sub_view->header()->hide();
			sub_view->expandAll();

			QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
			connect(buttonBox, &QDialogButtonBox::accepted, selectdialog, &QDialog::accept);
			connect(buttonBox, &QDialogButtonBox::rejected, selectdialog, &QDialog::reject);

			QVBoxLayout* selectlayout = new QVBoxLayout(selectdialog);
			selectlayout->addLayout(nameLayout);
			selectlayout->addWidget(search);
			selectlayout->addWidget(sub_view);
			selectlayout->addWidget(buttonBox);

			connect(search, &QLineEdit::textChanged, [=](const QString& string) {
				sub_filter->setFilterFixedString(string);
				sub_view->expandAll();
			});

			connect(sub_view->selectionModel(), &QItemSelectionModel::currentChanged, [table, sub_filter, filter, id, nameEdit](const QModelIndex& current, const QModelIndex& previous) {
				if (!current.isValid()) {
					return;
				}
				nameEdit->setText(sub_filter->data(current).toString());
				const BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(sub_filter->mapToSource(current).internalPointer());
				if (treeItem->baseCategory || treeItem->subCategory) {
					return;
				}
				id->setText(QString::fromStdString(map->get_unique_id(!islower(treeItem->id.front()))));
			});

			connect(id, &QLineEdit::textChanged, [buttonBox](const QString& text) {
				buttonBox->button(QDialogButtonBox::Ok)->setEnabled(text.size() == 4);
			});

			auto select = [view, table, sub_filter, filter, selectdialog, id, treeModel](const QModelIndex& index) {
				if (id->text().size() != 4) {
					return;
				}

				const BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(sub_filter->mapToSource(index).internalPointer());
				if (treeItem->baseCategory || treeItem->subCategory) {
					return;
				}

				selectdialog->close();
				table->copyRow(treeItem->id, id->text().toStdString());

				QModelIndex new_index = filter->mapFromSource(treeModel->mapFromSource(table->index(table->rowCount() - 1, 0)));
				view->setCurrentIndex(new_index);
				view->scrollTo(new_index, QAbstractItemView::ScrollHint::PositionAtCenter);
			};

			connect(sub_view, &QTreeView::activated, [select](const QModelIndex& index) { select(index); });

			connect(selectdialog, &QDialog::accepted, [sub_view, select]() {
				auto indices = sub_view->selectionModel()->selectedIndexes();
				if (indices.empty()) {
					return;
				}

				select(indices.front());
			});

			connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), selectdialog), &QShortcut::activated, [=]() {
				search->setFocus();
				search->selectAll();
			});

			selectdialog->show();
			search->setFocus();
		});

		connect(removeAction, &QAction::triggered, [=, this]() {
			std::vector<std::string> ids_to_delete;
			for (const auto& i : selection) {
				BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(filter->mapToSource(i).internalPointer());
				ids_to_delete.push_back(treeItem->id);

				// Close any open dock widget
				if (auto found = dock_manager->findDockWidget(QString::fromStdString(treeItem->id)); found) {
					found->closeDockWidget();
				}
			}
			for (const auto& i : ids_to_delete) {
				table->deleteRow(i);
			}
		});

		menu.exec(view->mapToGlobal(pos));
	});

	QLineEdit* search = new QLineEdit;
	search->setObjectName("search");
	search->setClearButtonEnabled(true);
	search->setPlaceholderText("Search " + name);
	connect(search, &QLineEdit::textChanged, [=](const QString& string) {
		filter->setFilterFixedString(string);
		view->expandAll();
	});

	QToolButton* hideDefault = new QToolButton;
	hideDefault->setIcon(icon);
	hideDefault->setToolTip("Hide default " + name);
	hideDefault->setCheckable(true);
	connect(hideDefault, &QToolButton::toggled, [=](bool checked) {
		filter->setFilterCustom(checked);
		if (!checked) {
			view->expandAll();
		}
	});

	QToolBar* bar = new QToolBar;
	bar->addWidget(search);
	bar->addWidget(hideDefault);

	ads::CDockWidget* tab = new ads::CDockWidget(dock_manager, name);
	tab->setToolBar(bar);
	tab->setWidget(view);
	tab->setFeature(ads::CDockWidget::DockWidgetClosable, false);
	tab->setFeature(ads::CDockWidget::DockWidgetAlwaysCloseAndDelete, false);
	tab->setIcon(icon);
	if (explorer_area == nullptr) {
		explorer_area = dock_manager->addDockWidget(ads::LeftDockWidgetArea, tab);
	} else {
		dock_manager->addDockWidget(ads::CenterDockWidgetArea, tab, explorer_area);
	}
}

void ObjectEditor::select_id(Category category, const std::string& id) const {
	explorer_area->setCurrentIndex(static_cast<int>(category));
	const auto edit = explorer_area->currentDockWidget()->findChild<QLineEdit*>("search");
	edit->clear();

	switch (category) {
		case Category::unit: {
			const auto index = unitTreeFilter->mapFromSource(unitTreeModel->getIdIndex(id));
			unit_explorer->setCurrentIndex(index);
			unit_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit unit_explorer->doubleClicked(index);
			break;
		}
		case Category::item: {
			const auto index = itemTreeFilter->mapFromSource(itemTreeModel->getIdIndex(id));
			item_explorer->setCurrentIndex(index);
			item_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit item_explorer->doubleClicked(index);
			break;
		}
		case Category::doodad: {
			const auto index = doodadTreeFilter->mapFromSource(doodadTreeModel->getIdIndex(id));
			doodad_explorer->setCurrentIndex(index);
			doodad_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit doodad_explorer->doubleClicked(index);
			break;
		}
		case Category::destructible: {
			const auto index = destructibleTreeFilter->mapFromSource(destructibleTreeModel->getIdIndex(id));
			destructible_explorer->setCurrentIndex(index);
			destructible_explorer->scrollTo(index, QAbstractItemView::PositionAtCenter);
			emit destructible_explorer->doubleClicked(index);
			break;
		}
		case Category::ability: {
			const auto index = abilityTreeFilter->mapFromSource(abilityTreeModel->getIdIndex(id));
			ability_explorer->setCurrentIndex(index);
			ability_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit ability_explorer->doubleClicked(index);
			break;
		}
		case Category::upgrade: {
			const auto index = upgradeTreeFilter->mapFromSource(upgradeTreeModel->getIdIndex(id));
			upgrade_explorer->setCurrentIndex(index);
			upgrade_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit upgrade_explorer->doubleClicked(index);
			break;
		}
		case Category::buff: {
			const auto index = buffTreeFilter->mapFromSource(buffTreeModel->getIdIndex(id));
			buff_explorer->setCurrentIndex(index);
			buff_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit buff_explorer->doubleClicked(index);
			break;
		}
	}
}
```

`src/object_editor/object_editor.h`:

```h
#pragma once

#include <QMainWindow>

#include "ui_object_editor.h"

#include "DockManager.h"
#include "DockAreaWidget.h"
#include <QTreeView>
#include <QSortFilterProxyModel>

#include "global_search.h"
#include "nlohmann/json.hpp"

#include <string>
#include <memory>

import BaseTreeModel;
import AbilityTreeModel;
import DoodadTreeModel;
import BuffTreeModel;
import DestructibleTreeModel;
import UnitTreeModel;
import UpgradeTreeModel;
import ItemTreeModel;
import TableModel;
import QIconResource;

class ObjectEditor : public QMainWindow {
	Q_OBJECT

public:
	explicit ObjectEditor(QWidget* parent = nullptr);

	enum class Category {
		unit,
		item,
		doodad,
		destructible,
		ability,
		upgrade,
		buff
	};

	void select_id(Category category, const std::string& id) const;
	void open_by_id(TableModel* table, const std::string& id, const QString& name, QIcon icon);

private:
	Ui::ObjectEditor ui;

	ads::CDockManager* dock_manager;
	ads::CDockAreaWidget* dock_area = nullptr;
	ads::CDockAreaWidget* explorer_area = nullptr;

	QTreeView* unit_explorer = new QTreeView;
	QTreeView* doodad_explorer = new QTreeView;
	QTreeView* item_explorer = new QTreeView;
	QTreeView* destructible_explorer = new QTreeView;
	QTreeView* ability_explorer = new QTreeView;
	QTreeView* upgrade_explorer = new QTreeView;
	QTreeView* buff_explorer = new QTreeView;
	
	UnitTreeModel* unitTreeModel;
	DoodadTreeModel* doodadTreeModel;
	DestructibleTreeModel* destructibleTreeModel;
	AbilityTreeModel* abilityTreeModel;
	ItemTreeModel* itemTreeModel;
	BuffTreeModel* buffTreeModel;
	UpgradeTreeModel* upgradeTreeModel;

	BaseFilter* unitTreeFilter;
	BaseFilter* doodadTreeFilter;
	BaseFilter* destructibleTreeFilter;
	BaseFilter* abilityTreeFilter;
	BaseFilter* itemTreeFilter;
	BaseFilter* buffTreeFilter;
	BaseFilter* upgradeTreeFilter;

	std::shared_ptr<QIconResource> custom_unit_icon;
	std::shared_ptr<QIconResource> custom_item_icon;
	std::shared_ptr<QIconResource> custom_doodad_icon;
	std::shared_ptr<QIconResource> custom_destructible_icon;
	std::shared_ptr<QIconResource> custom_ability_icon;
	std::shared_ptr<QIconResource> custom_buff_icon;
	std::shared_ptr<QIconResource> custom_upgrade_icon;

	nlohmann::json ability_insights;

	void itemClicked(const QSortFilterProxyModel* model, TableModel* table, const QModelIndex& index);
	void addTypeTreeView(BaseTreeModel* treeModel, BaseFilter*& filter, TableModel* table, QTreeView* view, QIcon icon, QString name, Category category);

	QElapsedTimer double_shift_timer;

	void keyPressEvent(QKeyEvent* event) override {
		if (event->key() == Qt::Key_Shift && !event->isAutoRepeat()) {
			if (double_shift_timer.isValid() && double_shift_timer.elapsed() < 400) {

				GlobalSearchWidget search_widget = new GlobalSearchWidget(this);
				double_shift_timer.invalidate();
			} else {
				double_shift_timer.start();
			}
		}
		QMainWindow::keyPressEvent(event);
	}
};
```

`src/object_editor/object_editor.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>ObjectEditor</class>
 <widget class="QMainWindow" name="ObjectEditor">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1338</width>
    <height>804</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Object Editor</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QHBoxLayout" name="horizontalLayout"/>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`src/object_editor/slk_conversions.ixx`:

```ixx
export module SlkConversions;

import std;
import Map;
import MapGlobal;
import SLK;
import Globals;

/// Returns the new destructible ID
export std::string convert_doodad_to_destructible(const std::string_view doodad_id, const std::string_view base_destructible) {
	const auto new_id = map->get_unique_id(true);
	destructibles_slk.copy_row(base_destructible, new_id, false);

	const auto mapping = std::unordered_map<std::string, std::string>{
		{"fixedrot", "fixedrot"},
		{"maxroll", "maxroll"},
		{"maxpitch", "maxpitch"},
		{"showinmm", "showinmm"},
		{"usemmcolor", "usemmcolor"},
		{"mmred", "mmred"},
		{"mmgreen", "mmgreen"},
		{"mmblue", "mmblue"},
		{"file", "file"},
		{"selsize", "selsize"},
		{"showinfog", "fogvis"},
		{"vertr1", "colorr"}, // We grab the colors from variation 1
		{"vertg1", "colorg"},
		{"vertb1", "colorb"},
		{"numvar", "numvar"},
		{"canscalerandscale", "canscalerandscale"},
		{"tilesetspecific", "tilesetspecific"},
		{"maxscale", "maxscale"},
		{"minscale", "minscale"},
		{"userlist", "userlist"},
		{"oncliffs", "oncliffs"},
		{"onwater", "onwater"},
		{"tilesets", "tilesets"},
		{"useclickhelper", "useclickhelper"},
		{"pathtex", "pathtex"},
		{"walkable", "walkable"},
		{"soundloop", "loopsound"},
		{"name", "name"},
	};

	for (const auto& [header_from, header_to] : mapping) {
		const auto data = doodads_slk.data(header_from, doodad_id);
		destructibles_slk.set_shadow_data(header_to, new_id, data);
	}
	return new_id;
}

```

`src/qt_imgui/imgui_renderer.cpp`:

```cpp
#include "imgui_renderer.h"

#include <QDateTime>
#include <QGuiApplication>
#include <QMouseEvent>
#include <QClipboard>
#include <QCursor>

#ifdef ANDROID
#define GL_VERTEX_ARRAY_BINDING           0x85B5 // Missing in android as of May 2020
#define USE_GLSL_ES
#endif

#ifdef USE_GLSL_ES
#define IMGUIRENDERER_GLSL_VERSION "#version 300 es\n"
#else
#define IMGUIRENDERER_GLSL_VERSION "#version 330\n"
#endif

namespace QtImGui {

namespace {

// Keyboard mapping. Dear ImGui use those indices to peek into the io.KeysDown[] array.
const QHash<int, int> keyMap = {
    { Qt::Key_Tab, ImGuiKey_Tab },
    { Qt::Key_Left, ImGuiKey_LeftArrow },
    { Qt::Key_Right, ImGuiKey_RightArrow },
    { Qt::Key_Up, ImGuiKey_UpArrow },
    { Qt::Key_Down, ImGuiKey_DownArrow },
    { Qt::Key_PageUp, ImGuiKey_PageUp },
    { Qt::Key_PageDown, ImGuiKey_PageDown },
    { Qt::Key_Home, ImGuiKey_Home },
    { Qt::Key_End, ImGuiKey_End },
    { Qt::Key_Insert, ImGuiKey_Insert },
    { Qt::Key_Delete, ImGuiKey_Delete },
    { Qt::Key_Backspace, ImGuiKey_Backspace },
    { Qt::Key_Space, ImGuiKey_Space },
    { Qt::Key_Enter, ImGuiKey_Enter },
    { Qt::Key_Return, ImGuiKey_Enter },
    { Qt::Key_Escape, ImGuiKey_Escape },
    { Qt::Key_A, ImGuiKey_A },
    { Qt::Key_C, ImGuiKey_C },
    { Qt::Key_V, ImGuiKey_V },
    { Qt::Key_X, ImGuiKey_X },
    { Qt::Key_Y, ImGuiKey_Y },
    { Qt::Key_Z, ImGuiKey_Z },
    { Qt::MiddleButton, ImGuiMouseButton_Middle }
};

#ifndef QT_NO_CURSOR
const QHash<ImGuiMouseCursor, Qt::CursorShape> cursorMap = {
    { ImGuiMouseCursor_Arrow,      Qt::CursorShape::ArrowCursor },
    { ImGuiMouseCursor_TextInput,  Qt::CursorShape::IBeamCursor },
    { ImGuiMouseCursor_ResizeAll,  Qt::CursorShape::SizeAllCursor },
    { ImGuiMouseCursor_ResizeNS,   Qt::CursorShape::SizeVerCursor },
    { ImGuiMouseCursor_ResizeEW,   Qt::CursorShape::SizeHorCursor },
    { ImGuiMouseCursor_ResizeNESW, Qt::CursorShape::SizeBDiagCursor },
    { ImGuiMouseCursor_ResizeNWSE, Qt::CursorShape::SizeFDiagCursor },
    { ImGuiMouseCursor_Hand,       Qt::CursorShape::PointingHandCursor },
    { ImGuiMouseCursor_NotAllowed, Qt::CursorShape::ForbiddenCursor },
};
#endif

QByteArray g_currentClipboardText;

} // namespace

void ImGuiRenderer::initialize(WindowWrapper *window) {
    m_window.reset(window);

    g_ctx = ImGui::CreateContext();
    ImGui::SetCurrentContext(g_ctx);

    // Setup backend capabilities flags
    ImGuiIO &io = ImGui::GetIO();
    #ifndef QT_NO_CURSOR
    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors; // We can honor GetMouseCursor() values (optional)
    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;  // We can honor io.WantSetMousePos requests (optional, rarely used)
    #endif
    io.BackendPlatformName = "qtimgui";
    
    // Setup keyboard mapping
    // for (auto key : keyMap.values()) {
    //     io.KeyMap[key] = key;
    // }
    
    // io.RenderDrawListsFn = [](ImDrawData *drawData) {
    //    instance()->renderDrawList(drawData);
    // };
    io.SetClipboardTextFn = [](void *user_data, const char *text) {
        Q_UNUSED(user_data);
        QGuiApplication::clipboard()->setText(text);
    };
    io.GetClipboardTextFn = [](void *user_data) {
        Q_UNUSED(user_data);
        g_currentClipboardText = QGuiApplication::clipboard()->text().toUtf8();
        return (const char *)g_currentClipboardText.data();
    };

    window->installEventFilter(this);
}

void ImGuiRenderer::renderDrawList(ImDrawData *draw_data)
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
    const ImGuiIO& io = ImGui::GetIO();
    int fb_width = (int)(io.DisplaySize.x * io.DisplayFramebufferScale.x);
    int fb_height = (int)(io.DisplaySize.y * io.DisplayFramebufferScale.y);
    if (fb_width == 0 || fb_height == 0)
        return;
    draw_data->ScaleClipRects(io.DisplayFramebufferScale);

    // Backup GL state
    GLint last_active_texture; glGetIntegerv(GL_ACTIVE_TEXTURE, &last_active_texture);
    glActiveTexture(GL_TEXTURE0);
    GLint last_program; glGetIntegerv(GL_CURRENT_PROGRAM, &last_program);
    GLint last_texture; glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
    GLint last_array_buffer; glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);
    GLint last_element_array_buffer; glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &last_element_array_buffer);
    GLint last_vertex_array; glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);
    GLint last_blend_src_rgb; glGetIntegerv(GL_BLEND_SRC_RGB, &last_blend_src_rgb);
    GLint last_blend_dst_rgb; glGetIntegerv(GL_BLEND_DST_RGB, &last_blend_dst_rgb);
    GLint last_blend_src_alpha; glGetIntegerv(GL_BLEND_SRC_ALPHA, &last_blend_src_alpha);
    GLint last_blend_dst_alpha; glGetIntegerv(GL_BLEND_DST_ALPHA, &last_blend_dst_alpha);
    GLint last_blend_equation_rgb; glGetIntegerv(GL_BLEND_EQUATION_RGB, &last_blend_equation_rgb);
    GLint last_blend_equation_alpha; glGetIntegerv(GL_BLEND_EQUATION_ALPHA, &last_blend_equation_alpha);
    GLint last_viewport[4]; glGetIntegerv(GL_VIEWPORT, last_viewport);
    GLint last_scissor_box[4]; glGetIntegerv(GL_SCISSOR_BOX, last_scissor_box);
    GLboolean last_enable_blend = glIsEnabled(GL_BLEND);
    GLboolean last_enable_cull_face = glIsEnabled(GL_CULL_FACE);
    GLboolean last_enable_depth_test = glIsEnabled(GL_DEPTH_TEST);
    GLboolean last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);

    // Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
    glEnable(GL_BLEND);
    glBlendEquation(GL_FUNC_ADD);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glEnable(GL_SCISSOR_TEST);

    // Setup viewport, orthographic projection matrix
    glViewport(0, 0, (GLsizei)fb_width, (GLsizei)fb_height);
    const float ortho_projection[4][4] =
    {
        { 2.0f/io.DisplaySize.x, 0.0f,                   0.0f, 0.0f },
        { 0.0f,                  2.0f/-io.DisplaySize.y, 0.0f, 0.0f },
        { 0.0f,                  0.0f,                  -1.0f, 0.0f },
        {-1.0f,                  1.0f,                   0.0f, 1.0f },
    };
    glUseProgram(g_ShaderHandle);
    glUniform1i(g_AttribLocationTex, 0);
    glUniformMatrix4fv(g_AttribLocationProjMtx, 1, GL_FALSE, &ortho_projection[0][0]);
    glBindVertexArray(g_VaoHandle);

    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];
        const ImDrawIdx* idx_buffer_offset = 0;

        glBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);
        glBufferData(GL_ARRAY_BUFFER, (GLsizeiptr)cmd_list->VtxBuffer.Size * sizeof(ImDrawVert), (const GLvoid*)cmd_list->VtxBuffer.Data, GL_STREAM_DRAW);

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_ElementsHandle);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, (GLsizeiptr)cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx), (const GLvoid*)cmd_list->IdxBuffer.Data, GL_STREAM_DRAW);

        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
            if (pcmd->UserCallback)
            {
                pcmd->UserCallback(cmd_list, pcmd);
            }
            else
            {
                glBindTexture(GL_TEXTURE_2D, (GLuint)(size_t)pcmd->TextureId);
                glScissor((int)pcmd->ClipRect.x, (int)(fb_height - pcmd->ClipRect.w), (int)(pcmd->ClipRect.z - pcmd->ClipRect.x), (int)(pcmd->ClipRect.w - pcmd->ClipRect.y));
                glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
            }
            idx_buffer_offset += pcmd->ElemCount;
        }
    }

    // Restore modified GL state
    glUseProgram(last_program);
    glBindTexture(GL_TEXTURE_2D, last_texture);
    glActiveTexture(last_active_texture);
    glBindVertexArray(last_vertex_array);
    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, last_element_array_buffer);
    glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);
    glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);
    if (last_enable_blend) glEnable(GL_BLEND); else glDisable(GL_BLEND);
    if (last_enable_cull_face) glEnable(GL_CULL_FACE); else glDisable(GL_CULL_FACE);
    if (last_enable_depth_test) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);
    if (last_enable_scissor_test) glEnable(GL_SCISSOR_TEST); else glDisable(GL_SCISSOR_TEST);
    glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);
    glScissor(last_scissor_box[0], last_scissor_box[1], (GLsizei)last_scissor_box[2], (GLsizei)last_scissor_box[3]);
}

bool ImGuiRenderer::createFontsTexture()
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    // Build texture atlas
    ImGuiIO& io = ImGui::GetIO();
    unsigned char* pixels;
    int width, height;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   // Load as RGBA 32-bits (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.

    // Upload texture to graphics system
    GLint last_texture;
    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
    glGenTextures(1, &g_FontTexture);
    glBindTexture(GL_TEXTURE_2D, g_FontTexture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);

    // Store our identifier
	io.Fonts->TexID = g_FontTexture;
    // io.Fonts->TexID = (void *)(size_t)g_FontTexture;

    // Restore state
    glBindTexture(GL_TEXTURE_2D, last_texture);

    return true;
}

bool ImGuiRenderer::createDeviceObjects()
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    // Backup GL state
    GLint last_texture, last_array_buffer, last_vertex_array;
    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
    glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);
    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);

    const GLchar *vertex_shader =
        IMGUIRENDERER_GLSL_VERSION
        "uniform mat4 ProjMtx;\n"
        "in vec2 Position;\n"
        "in vec2 UV;\n"
        "in vec4 Color;\n"
        "out vec2 Frag_UV;\n"
        "out vec4 Frag_Color;\n"
        "void main()\n"
        "{\n"
        "	Frag_UV = UV;\n"
        "	Frag_Color = Color;\n"
        "	gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
        "}\n";

    const GLchar* fragment_shader =
        IMGUIRENDERER_GLSL_VERSION
        "precision mediump float;"
        "uniform sampler2D Texture;\n"
        "in vec2 Frag_UV;\n"
        "in vec4 Frag_Color;\n"
        "out vec4 Out_Color;\n"
        "void main()\n"
        "{\n"
        "	Out_Color = Frag_Color * texture( Texture, Frag_UV.st);\n"
        "}\n";

    g_ShaderHandle = glCreateProgram();
    g_VertHandle = glCreateShader(GL_VERTEX_SHADER);
    g_FragHandle = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(g_VertHandle, 1, &vertex_shader, 0);
    glShaderSource(g_FragHandle, 1, &fragment_shader, 0);
    glCompileShader(g_VertHandle);
    glCompileShader(g_FragHandle);
    glAttachShader(g_ShaderHandle, g_VertHandle);
    glAttachShader(g_ShaderHandle, g_FragHandle);
    glLinkProgram(g_ShaderHandle);

    g_AttribLocationTex = glGetUniformLocation(g_ShaderHandle, "Texture");
    g_AttribLocationProjMtx = glGetUniformLocation(g_ShaderHandle, "ProjMtx");
    g_AttribLocationPosition = glGetAttribLocation(g_ShaderHandle, "Position");
    g_AttribLocationUV = glGetAttribLocation(g_ShaderHandle, "UV");
    g_AttribLocationColor = glGetAttribLocation(g_ShaderHandle, "Color");

    glGenBuffers(1, &g_VboHandle);
    glGenBuffers(1, &g_ElementsHandle);

    glGenVertexArrays(1, &g_VaoHandle);
    glBindVertexArray(g_VaoHandle);
    glBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);
    glEnableVertexAttribArray(g_AttribLocationPosition);
    glEnableVertexAttribArray(g_AttribLocationUV);
    glEnableVertexAttribArray(g_AttribLocationColor);

#define OFFSETOF(TYPE, ELEMENT) ((size_t)&(((TYPE *)0)->ELEMENT))
    glVertexAttribPointer(g_AttribLocationPosition, 2, GL_FLOAT, GL_FALSE, sizeof(ImDrawVert), (GLvoid*)OFFSETOF(ImDrawVert, pos));
    glVertexAttribPointer(g_AttribLocationUV, 2, GL_FLOAT, GL_FALSE, sizeof(ImDrawVert), (GLvoid*)OFFSETOF(ImDrawVert, uv));
    glVertexAttribPointer(g_AttribLocationColor, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(ImDrawVert), (GLvoid*)OFFSETOF(ImDrawVert, col));
#undef OFFSETOF

    createFontsTexture();

    // Restore modified GL state
    glBindTexture(GL_TEXTURE_2D, last_texture);
    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
    glBindVertexArray(last_vertex_array);

    return true;
}

void ImGuiRenderer::newFrame()
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    if (!g_FontTexture)
        createDeviceObjects();

    ImGuiIO& io = ImGui::GetIO();

    // Setup display size (every frame to accommodate for window resizing)
    io.DisplaySize = ImVec2(m_window->size().width(), m_window->size().height());
    io.DisplayFramebufferScale = ImVec2(m_window->devicePixelRatio(), m_window->devicePixelRatio());

    // Setup time step
    double current_time =  QDateTime::currentMSecsSinceEpoch() / double(1000);
    io.DeltaTime = g_Time > 0.0 ? (float)(current_time - g_Time) : (float)(1.0f/60.0f);
    if (io.DeltaTime <= 0.0f) io.DeltaTime = 0.00001f;
    g_Time = current_time;
    
    
    // If ImGui wants to set cursor position (for example, during navigation by using keyboard)
    // we need to do it here (before getting `QCursor::pos()` below).
    setCursorPos(io);

    // Setup inputs
    // (we already got mouse wheel, keyboard keys & characters from glfw callbacks polled in glfwPollEvents())
    if (m_window->isActive())
    {
        const QPoint pos = m_window->mapFromGlobal(QCursor::pos());
        io.MousePos = ImVec2(pos.x(), pos.y());   // Mouse position in screen coordinates (set to -1,-1 if no mouse / on another screen, etc.)
    }
    else
    {
        io.MousePos = ImVec2(-1,-1);
    }

    for (int i = 0; i < 3; i++)
    {
        io.MouseDown[i] = g_MousePressed[i];
    }

    io.MouseWheelH = g_MouseWheelH;
    io.MouseWheel = g_MouseWheel;
    g_MouseWheelH = 0;
    g_MouseWheel = 0;

    
    updateCursorShape(io);
    

    // Start the frame
    ImGui::NewFrame();
}

void ImGuiRenderer::render()
{
  // Select current context
  ImGui::SetCurrentContext(g_ctx);

  auto drawData = ImGui::GetDrawData();
  renderDrawList(drawData);
}

ImGuiRenderer::ImGuiRenderer()
  : g_ctx(nullptr)
{
}

ImGuiRenderer::~ImGuiRenderer()
{
  // remove this context
  ImGui::DestroyContext(g_ctx);
}

void ImGuiRenderer::onMousePressedChange(QMouseEvent *event)
{
    g_MousePressed[0] = event->buttons() & Qt::LeftButton;
    g_MousePressed[1] = event->buttons() & Qt::RightButton;
    g_MousePressed[2] = event->buttons() & Qt::MiddleButton;
}

void ImGuiRenderer::onWheel(QWheelEvent *event)
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    // Handle horizontal component
    if(event->pixelDelta().x() != 0)
    {
        g_MouseWheelH += event->pixelDelta().x() / (ImGui::GetTextLineHeight());
    } else {
        // Magic number of 120 comes from Qt doc on QWheelEvent::pixelDelta()
        g_MouseWheelH += event->angleDelta().x() / 120.0f;
    }

    // Handle vertical component
    if(event->pixelDelta().y() != 0)
    {
        // 5 lines per unit
        g_MouseWheel += event->pixelDelta().y() / (5.0 * ImGui::GetTextLineHeight());
    } else {
        // Magic number of 120 comes from Qt doc on QWheelEvent::pixelDelta()
        g_MouseWheel += event->angleDelta().y() / 120.0f;
    }
}

void ImGuiRenderer::onKeyPressRelease(QKeyEvent *event)
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    ImGuiIO& io = ImGui::GetIO();
    
    const bool key_pressed = (event->type() == QEvent::KeyPress);
    
    // Translate `Qt::Key` into `ImGuiKey`, and apply 'pressed' state for that key
    const auto key_it = keyMap.constFind( event->key() );
    if (key_it != keyMap.constEnd()) { // Qt's key found in keyMap
        const int imgui_key = *(key_it);
    	io.AddKeyEvent(static_cast<ImGuiKey>(imgui_key), key_pressed);
        // io.KeysDown[imgui_key] = key_pressed;
    }

    if (key_pressed) {
        const QString text = event->text();
        if (text.size() == 1) {
            io.AddInputCharacter( text.at(0).unicode() );
        }
    }

#ifdef Q_OS_MAC
    io.KeyCtrl  = event->modifiers() & Qt::MetaModifier;
    io.KeyShift = event->modifiers() & Qt::ShiftModifier;
    io.KeyAlt   = event->modifiers() & Qt::AltModifier;
    io.KeySuper = event->modifiers() & Qt::ControlModifier; // Comamnd key
#else
    io.KeyCtrl  = event->modifiers() & Qt::ControlModifier;
    io.KeyShift = event->modifiers() & Qt::ShiftModifier;
    io.KeyAlt   = event->modifiers() & Qt::AltModifier;
    io.KeySuper = event->modifiers() & Qt::MetaModifier;
#endif
}

void ImGuiRenderer::updateCursorShape(const ImGuiIO& io)
{
    // NOTE: This code will be executed, only if the following flags have been set:
    // - backend flag: `ImGuiBackendFlags_HasMouseCursors`    - enabled
    // - config  flag: `ImGuiConfigFlags_NoMouseCursorChange` - disabled

#ifndef QT_NO_CURSOR
    if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)
        return;

    const ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
    if (io.MouseDrawCursor || (imgui_cursor == ImGuiMouseCursor_None))
    {
        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
        m_window->setCursorShape(Qt::CursorShape::BlankCursor);
    }
    else
    {
        // Show OS mouse cursor
        
        // Translate `ImGuiMouseCursor` into `Qt::CursorShape` and show it, if we can
        const auto cursor_it = cursorMap.constFind( imgui_cursor );
        if(cursor_it != cursorMap.constEnd()) // `Qt::CursorShape` found for `ImGuiMouseCursor`
        {
            const Qt::CursorShape qt_cursor_shape = *(cursor_it);
            m_window->setCursorShape(qt_cursor_shape);
        }
        else // shape NOT found - use default
        {
            m_window->setCursorShape(Qt::CursorShape::ArrowCursor);
        }
    }
#else
    Q_UNUSED(io);
#endif
}

void ImGuiRenderer::setCursorPos(const ImGuiIO& io)
{
    // NOTE: This code will be executed, only if the following flags have been set:
    // - backend flag: `ImGuiBackendFlags_HasSetMousePos`      - enabled
    // - config  flag: `ImGuiConfigFlags_NavEnableSetMousePos` - enabled
    
#ifndef QT_NO_CURSOR
    if(io.WantSetMousePos) {
        m_window->setCursorPos({(int)io.MousePos.x, (int)io.MousePos.y});
    }
#else
    Q_UNUSED(io);
#endif
}

bool ImGuiRenderer::eventFilter(QObject *watched, QEvent *event)
{
  if (watched == m_window->object()) {
    switch (event->type()) {
    case QEvent::MouseButtonDblClick:
    case QEvent::MouseButtonPress:
    case QEvent::MouseButtonRelease:
      this->onMousePressedChange(static_cast<QMouseEvent*>(event));
      break;
    case QEvent::Wheel:
      this->onWheel(static_cast<QWheelEvent*>(event));
      break;
    case QEvent::KeyPress:
    case QEvent::KeyRelease:
      this->onKeyPressRelease(static_cast<QKeyEvent*>(event));
      break;
    default:
      break;
    }
  }
  return QObject::eventFilter(watched, event);
}

ImGuiRenderer* ImGuiRenderer::instance() {
    static ImGuiRenderer* instance = nullptr;
    if (!instance) {
        instance = new ImGuiRenderer();
    }
    return instance;
}

} // namespace QtImGui

```

`src/qt_imgui/imgui_renderer.h`:

```h
#pragma once

#include <glad/glad.h>
#define QT_NO_OPENGL

#include <QObject>
#include <QPoint>
#include <imgui.h>
#include <memory>

class QMouseEvent;
class QWheelEvent;
class QKeyEvent;

namespace QtImGui {

class WindowWrapper {
public:
    virtual ~WindowWrapper() {}
    virtual void installEventFilter(QObject *object) = 0;
    virtual QSize size() const = 0;
    virtual qreal devicePixelRatio() const = 0;
    virtual bool isActive() const = 0;
    virtual QPoint mapFromGlobal(const QPoint &p) const = 0;
    virtual QObject* object() = 0;
    
    virtual void setCursorShape(Qt::CursorShape shape) = 0;
    virtual void setCursorPos(const QPoint& local_pos) = 0;
};

class ImGuiRenderer : public QObject {
    Q_OBJECT
public:
    void initialize(WindowWrapper *window);
    void newFrame();
    void render();
    bool eventFilter(QObject *watched, QEvent *event);

    static ImGuiRenderer *instance();

public:
    ImGuiRenderer();
    ~ImGuiRenderer();

private:
    void onMousePressedChange(QMouseEvent *event);
    void onWheel(QWheelEvent *event);
    void onKeyPressRelease(QKeyEvent *event);
    
    void updateCursorShape(const ImGuiIO &io);
    void setCursorPos(const ImGuiIO &io);

    void renderDrawList(ImDrawData *draw_data);
    bool createFontsTexture();
    bool createDeviceObjects();

    std::unique_ptr<WindowWrapper> m_window;
    double       g_Time = 0.0f;
    bool         g_MousePressed[3] = { false, false, false };
    float        g_MouseWheel;
    float        g_MouseWheelH;
    GLuint       g_FontTexture = 0;
    int          g_ShaderHandle = 0, g_VertHandle = 0, g_FragHandle = 0;
    int          g_AttribLocationTex = 0, g_AttribLocationProjMtx = 0;
    int          g_AttribLocationPosition = 0, g_AttribLocationUV = 0, g_AttribLocationColor = 0;
    unsigned int g_VboHandle = 0, g_VaoHandle = 0, g_ElementsHandle = 0;

    ImGuiContext* g_ctx = nullptr;
};

} // namespace QtImGui

```

`src/qt_imgui/qt_imgui.cpp`:

```cpp
#include "qt_imgui.h"

#include "imgui_renderer.h"
#include <QWindow>
#ifdef QT_WIDGETS_LIB
#include <QWidget>
#endif

namespace QtImGui {

class QWindowWrapper : public WindowWrapper
{
public:
  QWindowWrapper(ImGuiRenderer* r) 
    : r(r)
  {}
  ~QWindowWrapper() {
    if (r && (r != ImGuiRenderer::instance())) {
      delete r;
    }
  }

public:
  void newFrame() { r->newFrame(); }

  void render() { r->render(); }
private:
  ImGuiRenderer* r;
};

#ifdef QT_WIDGETS_LIB

namespace {

class QWidgetWindowWrapper : public QWindowWrapper {
public:
    QWidgetWindowWrapper(QWidget *w, ImGuiRenderer* r) 
      : QWindowWrapper(r), w(w)
    {}
    void installEventFilter(QObject *object) override {
        return w->installEventFilter(object);
    }
    QSize size() const override {
        return w->size();
    }
    qreal devicePixelRatio() const override {
        return w->devicePixelRatioF();
    }
    bool isActive() const override {
        return w->isActiveWindow();
    }
    QPoint mapFromGlobal(const QPoint &p) const override {
        return w->mapFromGlobal(p);
    }
    QObject* object() override {
        return w;
    }
    
    void setCursorShape(Qt::CursorShape shape) override
    {
        #ifndef QT_NO_CURSOR
            w->setCursor(shape);
        #else
            Q_UNUSED(shape);
        #endif
    }
    
    void setCursorPos(const QPoint& local_pos) override
    {
        #ifndef QT_NO_CURSOR
            // Convert position from widget-space into screen-space
            const QPoint global_pos = w->mapToGlobal(local_pos);

            QCursor cursor = w->cursor();
            cursor.setPos(global_pos);
            w->setCursor(cursor);
        #else
            Q_UNUSED(local_pos);
        #endif
    }
    
private:
    QWidget *w;
};
  
} // namespace

RenderRef initialize(QWidget *window, bool defaultRender) {
  if (defaultRender) {
    auto* wrapper = new QWidgetWindowWrapper(window, ImGuiRenderer::instance());
    ImGuiRenderer::instance()->initialize(wrapper);
    return reinterpret_cast<RenderRef>(dynamic_cast<QWindowWrapper*>(wrapper));
  } else {
    auto* render = new ImGuiRenderer();
    auto* wrapper = new QWidgetWindowWrapper(window, render);
    render->initialize(wrapper);
    return reinterpret_cast<RenderRef>(dynamic_cast<QWindowWrapper*>(wrapper));
  }
}

#endif // QT_WIDGETS_LIB

namespace {

class QWindowWindowWrapper : public QWindowWrapper {
public:
    QWindowWindowWrapper(QWindow *w, ImGuiRenderer* r) 
      : QWindowWrapper(r), w(w)
    {}
    void installEventFilter(QObject *object) override {
        return w->installEventFilter(object);
    }
    QSize size() const override {
        return w->size();
    }
    qreal devicePixelRatio() const override {
        return w->devicePixelRatio();
    }
    bool isActive() const override {
        return w->isActive();
    }
    QPoint mapFromGlobal(const QPoint &p) const override {
        return w->mapFromGlobal(p);
    }
    QObject* object() override {
        return w;
    }
    
    void setCursorShape(Qt::CursorShape shape) override
    {
        #ifndef QT_NO_CURSOR
            w->setCursor(shape);
        #else
            Q_UNUSED(shape);
        #endif
    }
    
    void setCursorPos(const QPoint& local_pos) override
    {
        #ifndef QT_NO_CURSOR
            // Convert position from window-space into screen-space
            const QPoint global_pos = w->mapToGlobal(local_pos);

            QCursor cursor = w->cursor();
            cursor.setPos(global_pos);
            w->setCursor(cursor);
        #else
            Q_UNUSED(local_pos);
        #endif
    }

private:
    QWindow *w;
};

} // namespace

RenderRef initialize(QWindow* window, bool defaultRender) {
  if (defaultRender) {
    auto* wrapper = new QWindowWindowWrapper(window, ImGuiRenderer::instance());
    ImGuiRenderer::instance()->initialize(wrapper);
    return reinterpret_cast<RenderRef>(dynamic_cast<QWindowWrapper*>(wrapper));
  }
  else {
    auto* render = new ImGuiRenderer();
    auto* wrapper = new QWindowWindowWrapper(window, render);
    render->initialize(wrapper);
    return reinterpret_cast<RenderRef>(dynamic_cast<QWindowWrapper*>(wrapper));
  }
}

void newFrame(RenderRef ref) {
  if (!ref) {
    ImGuiRenderer::instance()->newFrame();
  } else {
    auto wrapper = reinterpret_cast<QWindowWrapper*>(ref);
    wrapper->newFrame();
  }
}

void render(RenderRef ref)
{
  if (!ref) {
    ImGuiRenderer::instance()->render();
  } else {
    auto wrapper = reinterpret_cast<QWindowWrapper*>(ref);
    wrapper->render();
  }
}

} // namespace QtImGui

```

`src/qt_imgui/qt_imgui.h`:

```h
#pragma once

class QWidget;
class QWindow;

namespace QtImGui {

typedef void* RenderRef;

#ifdef QT_WIDGETS_LIB
RenderRef initialize(QWidget *window, bool defaultRender = true);
#endif

RenderRef initialize(QWindow *window, bool defaultRender = true);
void newFrame(RenderRef ref = nullptr);
void render(RenderRef ref = nullptr);

}

```

`src/resource.h`:

```h

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`src/resources/cliff_mesh.ixx`:

```ixx
export module CliffMesh;

import std;
import BinaryReader;
import ResourceManager;
import Hierarchy;
import MDX;
import <glm/glm.hpp>;
import <glad/glad.h>;

namespace fs = std::filesystem;

export class CliffMesh : public Resource {
  public:
	GLuint vertex_buffer;
	GLuint uv_buffer;
	GLuint normal_buffer;
	GLuint index_buffer;
	GLuint instance_buffer;
	size_t indices;

	static constexpr const char* name = "CliffMesh";

	std::vector<glm::vec4> render_jobs;

	explicit CliffMesh(const fs::path& path) {
		if (path.extension() == ".mdx" || path.extension() == ".MDX") {
			auto reader = hierarchy.open_file(path).value();
			const mdx::MDX model = mdx::MDX(reader);

			auto set = model.geosets.front();

			glCreateBuffers(1, &vertex_buffer);
			glNamedBufferData(vertex_buffer, static_cast<int>(set.vertices.size() * sizeof(glm::vec3)), set.vertices.data(), GL_STATIC_DRAW);

			glCreateBuffers(1, &uv_buffer);
			glNamedBufferData(uv_buffer, static_cast<int>(set.uv_sets.front().size() * sizeof(glm::vec2)), set.uv_sets.front().data(), GL_STATIC_DRAW);

			glCreateBuffers(1, &normal_buffer);
			glNamedBufferData(normal_buffer, static_cast<int>(set.normals.size() * sizeof(glm::vec3)), set.normals.data(), GL_STATIC_DRAW);

			glCreateBuffers(1, &instance_buffer);

			indices = set.faces.size();
			glCreateBuffers(1, &index_buffer);
			glNamedBufferData(index_buffer, static_cast<int>(set.faces.size() * sizeof(uint16_t)), set.faces.data(), GL_STATIC_DRAW);
		}
	}

	~CliffMesh() {
		glDeleteBuffers(1, &vertex_buffer);
		glDeleteBuffers(1, &uv_buffer);
		glDeleteBuffers(1, &normal_buffer);
		glDeleteBuffers(1, &instance_buffer);
		glDeleteBuffers(1, &index_buffer);
	}

	void render_queue(const glm::vec4 position) {
		render_jobs.push_back(position);
	}

	void render() {
		if (render_jobs.empty()) {
			return;
		}

		glNamedBufferData(instance_buffer, static_cast<int>(render_jobs.size() * sizeof(glm::vec4)), render_jobs.data(), GL_STATIC_DRAW);

		glEnableVertexAttribArray(0);
		glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

		glEnableVertexAttribArray(1);
		glBindBuffer(GL_ARRAY_BUFFER, uv_buffer);
		glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

		glEnableVertexAttribArray(2);
		glBindBuffer(GL_ARRAY_BUFFER, normal_buffer);
		glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

		glEnableVertexAttribArray(3);
		glBindBuffer(GL_ARRAY_BUFFER, instance_buffer);
		glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 0, nullptr);
		glVertexAttribDivisor(3, 1);

		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);
		glDrawElementsInstanced(GL_TRIANGLES, indices, GL_UNSIGNED_SHORT, nullptr, static_cast<int>(render_jobs.size()));

		glVertexAttribDivisor(3, 0); // ToDo use vao
		glDisableVertexAttribArray(0);
		glDisableVertexAttribArray(1);
		glDisableVertexAttribArray(2);
		glDisableVertexAttribArray(3);

		render_jobs.clear();
	}
};
```

`src/resources/editable_mesh.ixx`:

```ixx
export module EditableMesh;

import std;
import MDX;
import ResourceManager;
import GPUTexture;
import Shader;
import SkeletalModelInstance;
import Hierarchy;
import BinaryReader;
import <glm/glm.hpp>;
import <glad/glad.h>;

namespace fs = std::filesystem;

export class EditableMesh: public Resource {
  public:
	struct MeshEntry {
		int vertices = 0;
		int indices = 0;
		int base_vertex = 0;
		int base_index = 0;

		int material_id = 0;
		mdx::Extent extent;

		bool hd = true;
		mdx::GeosetAnimation* geoset_anim; // can be nullptr, often
	};

	std::shared_ptr<mdx::MDX> mdx;

	std::vector<MeshEntry> geosets;
	bool has_mesh; // ToDo remove when added support for meshless

	GLuint vao;
	GLuint vertex_buffer;
	GLuint uv_buffer;
	GLuint normal_buffer;
	GLuint tangent_buffer;
	GLuint weight_buffer;
	GLuint index_buffer;
	GLuint layer_alpha;
	GLuint geoset_color;

	std::vector<std::shared_ptr<GPUTexture>> textures;

	static constexpr const char* name = "EditableMesh";

	EditableMesh() = delete;

	explicit EditableMesh(std::shared_ptr<mdx::MDX> mdx, std::optional<std::pair<int, std::string>> replaceable_id_override) {
		this->mdx = mdx;

		size_t vertices = 0;
		size_t indices = 0;
		size_t matrices = 0;

		glGenVertexArrays(1, &vao);
		glBindVertexArray(vao);

		has_mesh = mdx->geosets.size();
		if (!has_mesh) {
			return;
		}

		// Calculate required space
		for (const auto& i : mdx->geosets) {
			if (i.lod != 0) {
				continue;
			}
			vertices += i.vertices.size();
			indices += i.faces.size();
			matrices += i.matrix_groups.size();
		}

		// Allocate space
		glCreateBuffers(1, &vertex_buffer);
		glNamedBufferData(vertex_buffer, vertices * sizeof(glm::vec3), nullptr, GL_DYNAMIC_DRAW);

		glCreateBuffers(1, &uv_buffer);
		glNamedBufferData(uv_buffer, vertices * sizeof(glm::vec2), nullptr, GL_DYNAMIC_DRAW);

		glCreateBuffers(1, &normal_buffer);
		glNamedBufferData(normal_buffer, vertices * sizeof(glm::vec3), nullptr, GL_DYNAMIC_DRAW);

		glCreateBuffers(1, &tangent_buffer);
		glNamedBufferData(tangent_buffer, vertices * sizeof(glm::vec4), nullptr, GL_DYNAMIC_DRAW);

		glCreateBuffers(1, &weight_buffer);
		glNamedBufferData(weight_buffer, vertices * sizeof(glm::uvec2), nullptr, GL_DYNAMIC_DRAW);

		glCreateBuffers(1, &index_buffer);
		glNamedBufferData(index_buffer, indices * sizeof(uint16_t), nullptr, GL_DYNAMIC_DRAW);

		// Buffer Data
		int base_vertex = 0;
		int base_index = 0;

		for (const auto& i : mdx->geosets) {
			if (i.lod != 0) {
				continue;
			}
			MeshEntry entry;
			entry.vertices = static_cast<int>(i.vertices.size());
			entry.base_vertex = base_vertex;

			entry.indices = static_cast<int>(i.faces.size());
			entry.base_index = base_index;

			entry.material_id = i.material_id;
			entry.geoset_anim = nullptr;
			entry.extent = i.extent;

			geosets.push_back(entry);

			// If the skin vector is empty then the model has SD bone weights and we convert them to the HD skin weights.
			// Technically SD supports infinite bones per vertex, but we limit it to 4 like HD does.
			// This could cause graphical inconsistensies with the game, but after more than 4 bones the contribution per bone is low enough that we don't care
			if (i.skin.empty()) {
				std::vector<glm::u8vec4> groups;
				std::vector<glm::u8vec4> weights;

				int bone_offset = 0;
				for (const auto& group_size : i.matrix_groups) {
					int bone_count = std::min(group_size, 4u);
					glm::uvec4 indices(0);
					glm::uvec4 weightss(0);

					int weight = 255 / bone_count;
					for (int j = 0; j < bone_count; j++) {
						indices[j] = i.matrix_indices[bone_offset + j];
						weightss[j] = weight;
					}

					int remainder = 255 - weight * bone_count;
					weightss[0] += remainder;

					groups.push_back(indices);
					weights.push_back(weightss);
					bone_offset += group_size;
				}

				std::vector<glm::u8vec4> skin_weights;
				skin_weights.reserve(entry.vertices * 2);
				for (const auto& vertex_group : i.vertex_groups) {
					skin_weights.push_back(groups[vertex_group]);
					skin_weights.push_back(weights[vertex_group]);
				}

				glNamedBufferSubData(weight_buffer, base_vertex * sizeof(glm::uvec2), entry.vertices * 8, skin_weights.data());
			} else {
				glNamedBufferSubData(weight_buffer, base_vertex * sizeof(glm::uvec2), entry.vertices * 8, i.skin.data());
			}

			glNamedBufferSubData(vertex_buffer, base_vertex * sizeof(glm::vec3), entry.vertices * sizeof(glm::vec3), i.vertices.data());
			glNamedBufferSubData(uv_buffer, base_vertex * sizeof(glm::vec2), entry.vertices * sizeof(glm::vec2), i.uv_sets.front().data());
			glNamedBufferSubData(normal_buffer, base_vertex * sizeof(glm::vec3), entry.vertices * sizeof(glm::vec3), i.normals.data());
			glNamedBufferSubData(tangent_buffer, base_vertex * sizeof(glm::vec4), entry.vertices * sizeof(glm::vec4), i.tangents.data());
			glNamedBufferSubData(index_buffer, base_index * sizeof(uint16_t), entry.indices * sizeof(uint16_t), i.faces.data());

			base_vertex += entry.vertices;
			base_index += entry.indices;
		}

		// animations geoset ids > geosets
		for (auto& i : mdx->animations) {
			if (i.geoset_id < geosets.size()) {
				geosets[i.geoset_id].geoset_anim = &i;
			}
		}

		for (size_t i = 0; i < mdx->textures.size(); i++) {
			const mdx::Texture& texture = mdx->textures[i];

			if (texture.replaceable_id != 0) {
				// Figure out if this is an HD texture
				// Unfortunately replaceable ID textures don't have any additional information on whether they are diffuse/normal/orm
				// So we take a guess using the index
				std::string suffix("");
				bool found = false;
				for (const auto& material : mdx->materials) {
					for (const auto& layer : material.layers) {
						for (size_t j = 0; j < layer.textures.size(); j++) {
							if (layer.textures[j].id != i) {
								continue;
							}

							found = true;

							if (layer.hd) {
								switch (j) {
									case 0:
										suffix = "_diffuse";
										break;
									case 1:
										suffix = "_normal";
										break;
									case 2:
										suffix = "_orm";
										break;
									case 3:
										suffix = "_emissive";
										break;
								}
							}
							break;
						}
						if (found) {
							break;
						}
					}
					if (found) {
						break;
					}
				}

				if (replaceable_id_override && texture.replaceable_id == replaceable_id_override->first) {
					textures.push_back(
						resource_manager.load<GPUTexture>(replaceable_id_override->second + suffix, std::to_string(texture.flags))
					);
				} else {
					textures.push_back(resource_manager.load<GPUTexture>(
						mdx::replaceable_id_to_texture.at(texture.replaceable_id) + suffix,
						std::to_string(texture.flags)
					));
				}
			} else {
				textures.push_back(resource_manager.load<GPUTexture>(texture.file_name, std::to_string(texture.flags)));
			}
			glTextureParameteri(textures.back()->id, GL_TEXTURE_WRAP_S, texture.flags & 1 ? GL_REPEAT : GL_CLAMP_TO_EDGE);
			glTextureParameteri(textures.back()->id, GL_TEXTURE_WRAP_T, texture.flags & 2 ? GL_REPEAT : GL_CLAMP_TO_EDGE);
		}

		glEnableVertexArrayAttrib(vao, 0);
		glEnableVertexArrayAttrib(vao, 1);
		glEnableVertexArrayAttrib(vao, 2);
		glEnableVertexArrayAttrib(vao, 3);
		glEnableVertexArrayAttrib(vao, 4);

		glVertexArrayElementBuffer(vao, index_buffer);

		glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

		glBindBuffer(GL_ARRAY_BUFFER, uv_buffer);
		glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

		glBindBuffer(GL_ARRAY_BUFFER, normal_buffer);
		glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

		glBindBuffer(GL_ARRAY_BUFFER, tangent_buffer);
		glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 0, nullptr);

		glBindBuffer(GL_ARRAY_BUFFER, weight_buffer);
		glVertexAttribIPointer(4, 2, GL_UNSIGNED_INT, 0, nullptr);
	}

	virtual ~EditableMesh() {
		glDeleteBuffers(1, &vertex_buffer);
		glDeleteBuffers(1, &uv_buffer);
		glDeleteBuffers(1, &normal_buffer);
		glDeleteBuffers(1, &tangent_buffer);
		glDeleteBuffers(1, &weight_buffer);
		glDeleteBuffers(1, &index_buffer);
		glDeleteBuffers(1, &layer_alpha);
		glDeleteBuffers(1, &geoset_color);
	}

	void render(
		const int team_color_index,
		const SkeletalModelInstance& skeleton,
		const glm::mat4& projection_view,
		const glm::vec3 light_direction
	) const {
		render_opaque(false, team_color_index, skeleton, projection_view, light_direction);
	}

  private:
	void render_opaque(
		const bool render_hd,
		const int team_color_index,
		const SkeletalModelInstance& skeleton,
		const glm::mat4& projection_view,
		const glm::vec3 light_direction
	) const {
		if (!has_mesh) {
			return;
		}
		glm::mat4 M = glm::mat4(1.f);
		glm::mat4 MVP = projection_view * M;

		glBindVertexArray(vao);

		glUniformMatrix4fv(0, 1, false, &MVP[0][0]);
		glUniform3fv(3, 1, &light_direction.x);
		glUniformMatrix4fv(4, 1, false, &M[0][0]);
		glUniform1i(6, mdx->bones.size());
		glUniform1i(9, team_color_index);
		glUniformMatrix4fv(11, mdx->bones.size(), false, &skeleton.world_matrices[0][0][0]);

		for (const auto& i : geosets) {
			const auto& layers = mdx->materials[i.material_id].layers;

			if (layers[0].blend_mode != 0 && layers[0].blend_mode != 1) {
				continue;
			}

			glm::vec3 geoset_color(1.f);
			float geoset_anim_visibility = 1.0f;
			if (i.geoset_anim && skeleton.sequence_index >= 0) {
				geoset_color = skeleton.get_geoset_animation_color(*i.geoset_anim);
				geoset_anim_visibility = skeleton.get_geoset_animation_visiblity(*i.geoset_anim);
			}

			for (const auto& j : layers) {
				if (j.hd != render_hd) {
					continue;
				}

				float layer_visibility = 1.0f;
				if (skeleton.sequence_index >= 0) {
					layer_visibility = skeleton.get_layer_visiblity(j);
				}

				const glm::vec4 layer_color = glm::vec4(geoset_color, layer_visibility * geoset_anim_visibility);

				// We don't have to render fully transparent meshes
				// Some Reforged bridges for instance have a FilterMode None but a static alpha of 0 for some materials
				// TODO: this is a hack, if the first instance has an alpha animation that triggers this condition then all instances will be hidden, even if the others have a positive alpha
				if (layer_color.a <= 0.01f) {
					continue;
				}

				glUniform1f(1, j.blend_mode == 1 ? 0.75f : -1.0f);
				glUniform1i(2, !(j.shading_flags & 0x1));
				glUniform4fv(8, 1, &layer_color[0]);
				const bool is_team_color =
					(mdx->textures[j.textures[0].id].replaceable_id == 1 || mdx->textures[j.textures[0].id].replaceable_id == 2);
				glUniform1i(10, is_team_color);

				switch (j.blend_mode) {
					case 0:
					case 1:
						glBlendFunc(GL_ONE, GL_ZERO);
						break;
					case 2:
						glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
						break;
					case 3:
						glBlendFunc(GL_SRC_ALPHA, GL_ONE);
						break;
					case 4:
						glBlendFunc(GL_SRC_ALPHA, GL_ONE);
						break;
					case 5:
						glBlendFunc(GL_ZERO, GL_SRC_COLOR);
						break;
					case 6:
						glBlendFunc(GL_DST_COLOR, GL_SRC_COLOR);
						break;
				}

				if (j.shading_flags & 0x10) {
					glDisable(GL_CULL_FACE);
				} else {
					glEnable(GL_CULL_FACE);
				}

				if (j.shading_flags & 0x40) {
					glDisable(GL_DEPTH_TEST);
				} else {
					glEnable(GL_DEPTH_TEST);
				}

				if (j.shading_flags & 0x80) {
					glDepthMask(false);
				} else {
					glDepthMask(true);
				}

				for (size_t texture_slot = 0; texture_slot < j.textures.size(); texture_slot++) {
					glBindTextureUnit(texture_slot, textures[j.textures[texture_slot].id]->id);
				}

				glDrawElementsBaseVertex(
					GL_TRIANGLES,
					i.indices,
					GL_UNSIGNED_SHORT,
					reinterpret_cast<void*>(i.base_index * sizeof(uint16_t)),
					i.base_vertex
				);
			}
		}
	}
};

```

`src/resources/gpu_texture.ixx`:

```ixx
export module GPUTexture;

import std;
import types;
import BinaryReader;
import ResourceManager;
import Hierarchy;
import BLP;
import <soil2/SOIL2.h>;
import <glad/glad.h>;

namespace fs = std::filesystem;

export class GPUTexture : public Resource {
  public:
	GLuint id = 0;

	static constexpr const char* name = "GPUTexture";

	explicit GPUTexture(const fs::path& path) {
		fs::path new_path = path;

		new_path.replace_extension(".tga");
		BinaryReader reader = hierarchy.open_file(new_path)
			.or_else([&](const std::string&) {
				new_path.replace_extension(".blp");
				return hierarchy.open_file(new_path);
			})
			.or_else([&](const std::string&) {
				new_path.replace_extension(".dds");
				return hierarchy.open_file(new_path);
			})
			.or_else([&](const std::string&) {
				std::println("Error loading texture {}", new_path.string());
				new_path = "Textures/btntempw.dds";
				return hierarchy.open_file(new_path);
			})
			.value();

		if (new_path.extension() == ".blp") {
			int width;
			int height;
			int channels;
			const u8* data = blp::load(reader, width, height, channels);

			glCreateTextures(GL_TEXTURE_2D, 1, &id);
			glTextureStorage2D(id, std::log2(std::max(width, height)) + 1, GL_RGBA8, width, height);
			glTextureSubImage2D(id, 0, 0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data);
			glGenerateTextureMipmap(id);
			delete data;
		} else {
			id = SOIL_load_OGL_texture_from_memory(
				reader.buffer.data(),
				static_cast<int>(reader.buffer.size()),
				SOIL_LOAD_AUTO,
				SOIL_LOAD_AUTO,
				SOIL_FLAG_DDS_LOAD_DIRECT | SOIL_FLAG_SRGB_COLOR_SPACE
			);
			if (id == 0) {
				glCreateTextures(GL_TEXTURE_2D, 1, &id);
				std::println("Error loading texture: {}", path.string());
			}
		}

		glTextureParameteri(id, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTextureParameteri(id, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTextureParameteri(id, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTextureParameteri(id, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	}

	virtual ~GPUTexture() {
		glDeleteTextures(1, &id);
	}
};
```

`src/resources/ground_texture.ixx`:

```ixx
export module GroundTexture;

import std;
import BinaryReader;
import ResourceManager;
import OpenGLUtilities;
import BLP;
import Hierarchy;
import <soil2/SOIL2.h>;
import <glm/glm.hpp>;
import <glad/glad.h>;

namespace fs = std::filesystem;

export class GroundTexture : public Resource {
  public:
	GLuint id = 0;
	GLuint64 bindless_handle = 0;
	int tile_size;
	bool extended = false;
	glm::vec4 minimap_color;

	static constexpr const char* name = "GroundTexture";

	explicit GroundTexture(const fs::path& path) {
		fs::path new_path = path;

		if (hierarchy.hd) {
			new_path.replace_filename(path.stem().string() + "_diffuse");
		}

		new_path.replace_extension(".tga");
		BinaryReader reader = hierarchy.open_file(new_path)
			.or_else([&](const std::string&) {
				new_path.replace_extension(".blp");
				return hierarchy.open_file(new_path);
			})
			.or_else([&](const std::string&) {
				new_path.replace_extension(".dds");
				return hierarchy.open_file(new_path);
			})
			.or_else([&](const std::string&) {
				std::println("Error loading texture {}", new_path.string());
				new_path = "Textures/btntempw.dds";
				return hierarchy.open_file(new_path);
			})
			.value();

		int width;
		int height;
		int channels;
		uint8_t* data;

		if (new_path.extension() == ".blp") {
			data = blp::load(reader, width, height, channels);
		} else {
			data = SOIL_load_image_from_memory(reader.buffer.data(), static_cast<int>(reader.buffer.size()), &width, &height, &channels, SOIL_LOAD_AUTO);
		}

		tile_size = std::max(height * 0.25f, 1.f);
		extended = (width == height * 2);
		int lods = log2(tile_size) + 1;

		const int format = channels == 3 ? GL_RGB : GL_RGBA;
		const int bit_format = channels == 3 ? GL_RGB8 : GL_RGBA8;

		glCreateTextures(GL_TEXTURE_2D_ARRAY, 1, &id);
		glTextureStorage3D(id, lods, bit_format, tile_size, tile_size, extended ? 32 : 16);
		glTextureParameteri(id, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTextureParameteri(id, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTextureParameteri(id, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

		glPixelStorei(GL_UNPACK_ROW_LENGTH, width);
		for (int y = 0; y < 4; y++) {
			for (int x = 0; x < 4; x++) {
				glTextureSubImage3D(id, 0, 0, 0, y * 4 + x, tile_size, tile_size, 1, format, GL_UNSIGNED_BYTE, data + (y * tile_size * width + x * tile_size) * channels);

				if (extended) {
					glTextureSubImage3D(id, 0, 0, 0, y * 4 + x + 16, tile_size, tile_size, 1, format, GL_UNSIGNED_BYTE, data + (y * tile_size * width + (x + 4) * tile_size) * channels);
				}
			}
		}
		delete data;
		glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
		glGenerateTextureMipmap(id);

		glGetTextureSubImage(id, lods - 1, 0, 0, 0, 1, 1, 1, format, GL_FLOAT, 16, &minimap_color);
		minimap_color *= 255.f;

		bindless_handle = glGetTextureHandleARB(id);
		glMakeTextureHandleResidentARB(bindless_handle);
	}

	virtual ~GroundTexture() {
		glMakeTextureHandleNonResidentARB(bindless_handle);
		glDeleteTextures(1, &id);
	}
};
```

`src/resources/pathing_texture.ixx`:

```ixx
export module PathingTexture;

import std;
import types;
import ResourceManager;
import Hierarchy;
import BLP;
import BinaryReader;
import <soil2/SOIL2.h>;
import <glm/glm.hpp>;

namespace fs = std::filesystem;

export class PathingTexture : public Resource {
  public:
	int width;
	int height;
	int channels;
	std::vector<u8> data;

	bool homogeneous;

	static constexpr const char* name = "PathingTexture";

	explicit PathingTexture(const fs::path& path) {
		BinaryReader reader = hierarchy.open_file(path).value();
		uint8_t* image_data;

		if (path.extension() == ".blp" || path.extension() == ".BLP") {
			image_data = blp::load(reader, width, height, channels);
		} else {
			image_data = SOIL_load_image_from_memory(reader.buffer.data(), static_cast<int>(reader.buffer.size()), &width, &height, &channels, SOIL_LOAD_AUTO);
		}
		data = std::vector<u8>(image_data, image_data + width * height * channels);
		delete image_data;

		homogeneous = true;
		for (size_t i = 0; i < data.size(); i += channels) {
			if (channels == 3) {
				homogeneous = homogeneous && *reinterpret_cast<glm::u8vec3*>(data.data() + i) == *reinterpret_cast<glm::u8vec3*>(data.data());
			} else if (channels == 4) {
				homogeneous = homogeneous && *reinterpret_cast<glm::u8vec4*>(data.data() + i) == *reinterpret_cast<glm::u8vec4*>(data.data());
			}
		}
	}
};
```

`src/resources/qicon_resource.ixx`:

```ixx
module;

#include <QIcon>
#include <QImage>
#include <QPixMap>

export module QIconResource;

import std;
import ResourceManager;
import Texture;

namespace fs = std::filesystem;

export class QIconResource : public Resource {
  public:
	QIcon icon;

	static constexpr const char* name = "QIconResource";

	explicit QIconResource() = default;

	explicit QIconResource(const fs::path& path) {
		const auto image = resource_manager.load<Texture>(path);
		QImage temp_image(image->data.data(), image->width, image->height, image->channels == 3 ? QImage::Format::Format_RGB888 : QImage::Format::Format_RGBA8888);
		auto pix = QPixmap::fromImage(temp_image);
		icon = QIcon(pix);
	}
};
```

`src/resources/shader.ixx`:

```ixx
export module Shader;

import std;
import ResourceManager;
import Utilities;
import <glad/glad.h>;

namespace fs = std::filesystem;

export class Shader : public Resource {
  public:
	GLuint program;

	static constexpr const char* name = "Shader";

	// vertex: .vert
	// fragment: .frag
	// compute: .comp
	explicit Shader(std::initializer_list<fs::path> paths) {
		program = glCreateProgram();

		for (const auto& path : paths) {
			GLuint shader;
			if (path.extension() == ".vert") {
				shader = glCreateShader(GL_VERTEX_SHADER);
			} else if (path.extension() == ".frag") {
				shader = glCreateShader(GL_FRAGMENT_SHADER);
			} else if (path.extension() == ".comp") {
				shader = glCreateShader(GL_COMPUTE_SHADER);
			}

			static char buffer[512];
			GLint status;
			const std::string source = read_text_file(path);
			const char* source_c_str = source.c_str();
			glShaderSource(shader, 1, &source_c_str, nullptr);
			glCompileShader(shader);

			glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
			if (!status) {
				glGetShaderInfoLog(shader, 512, nullptr, buffer);
				std::print("{}\n{}\n", path.string(), buffer);
			}

			glAttachShader(program, shader);
		}

		glLinkProgram(program);
		static char buffer[512];
		GLint status;
		glGetProgramiv(program, GL_LINK_STATUS, &status);
		if (!status) {
			glGetProgramInfoLog(program, 512, nullptr, buffer);

			std::print("Failed to link\n");
			for (const auto& path : paths) {
				std::print("{}\n", path.string());
			}
			std::print("{}\n", buffer);
		}
	}

	~Shader() {
		glDeleteProgram(program);
	}

	void use() const {
		glUseProgram(program);
	}
};
```

`src/resources/skinned_mesh.ixx`:

```ixx
module;

#include <glad/glad.h>

export module SkinnedMesh;

import std;
import MDX;
import BinaryReader;
import ResourceManager;
import GPUTexture;
import Shader;
import Hierarchy;
import Camera;
import SkeletalModelInstance;
import Utilities;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;
import <glm/gtc/quaternion.hpp>;
import <glm/gtc/packing.hpp>;

namespace fs = std::filesystem;

export class SkinnedMesh : public Resource {
  public:
	struct MeshEntry {
		int vertices = 0;
		int indices = 0;
		int base_vertex = 0;
		int base_index = 0;

		int material_id = 0;
		mdx::Extent extent;

		mdx::GeosetAnimation* geoset_anim; // can be nullptr, often
	};

	std::shared_ptr<mdx::MDX> mdx;

	std::vector<MeshEntry> geosets;
	bool has_mesh; // ToDo remove when added support for meshless
	bool has_transparent_layers = false;

	uint32_t instance_vertex_count = 0;

	GLuint vao;
	GLuint vertex_snorm_buffer;
	GLuint uv_snorm_buffer;
	GLuint normal_buffer;
	GLuint tangent_buffer;
	GLuint weight_buffer;
	GLuint index_buffer;

	GLuint instance_ssbo;
	GLuint instance_team_color_index_ssbo;
	GLuint layer_colors_ssbo;
	GLuint bones_ssbo;
	GLuint bones_ssbo_colored;

	int skip_count = 0;

	fs::path path;
	std::vector<std::shared_ptr<GPUTexture>> textures;
	std::vector<glm::mat4> render_jobs;
	std::vector<glm::vec3> render_colors;
	std::vector<uint32_t> render_team_color_indexes;
	std::vector<const SkeletalModelInstance*> skeletons;
	std::vector<glm::mat4> instance_bone_matrices;
	std::vector<glm::vec4> layer_colors;

	static constexpr const char* name = "SkinnedMesh";

	explicit SkinnedMesh(const fs::path& path, std::optional<std::pair<int, std::string>> replaceable_id_override) {
		if (path.extension() != ".mdx" && path.extension() != ".MDX") {
			throw;
		}

		BinaryReader reader = hierarchy.open_file(path).value();
		this->path = path;

		size_t vertices = 0;
		size_t indices = 0;
		size_t matrices = 0;

		mdx = std::make_shared<mdx::MDX>(reader);

		glGenVertexArrays(1, &vao);
		glBindVertexArray(vao);

		has_mesh = mdx->geosets.size();
		if (!has_mesh) {
			return;
		}

		for (const auto& i : mdx->geosets) {
			const auto& layer = mdx->materials[i.material_id].layers[0];
			if (layer.blend_mode != 0 && layer.blend_mode != 1) {
				has_transparent_layers = true;
				break;
			}
		}

		// Calculate required space
		for (const auto& i : mdx->geosets) {
			if (i.lod != 0) {
				continue;
			}
			vertices += i.vertices.size();
			indices += i.faces.size();
			matrices += i.matrix_groups.size();
		}

		// Allocate space
		glCreateBuffers(1, &vertex_snorm_buffer);
		glNamedBufferStorage(vertex_snorm_buffer, vertices * sizeof(glm::uvec2), nullptr, GL_DYNAMIC_STORAGE_BIT | GL_MAP_READ_BIT);

		glCreateBuffers(1, &uv_snorm_buffer);
		glNamedBufferStorage(uv_snorm_buffer, vertices * sizeof(uint32_t), nullptr, GL_DYNAMIC_STORAGE_BIT | GL_MAP_READ_BIT);

		glCreateBuffers(1, &normal_buffer);
		glNamedBufferStorage(normal_buffer, vertices * sizeof(uint32_t), nullptr, GL_DYNAMIC_STORAGE_BIT | GL_MAP_READ_BIT);

		glCreateBuffers(1, &tangent_buffer);
		glNamedBufferStorage(tangent_buffer, vertices * sizeof(glm::vec4), nullptr, GL_DYNAMIC_STORAGE_BIT | GL_MAP_READ_BIT);

		glCreateBuffers(1, &weight_buffer);
		glNamedBufferStorage(weight_buffer, vertices * sizeof(glm::uvec2), nullptr, GL_DYNAMIC_STORAGE_BIT | GL_MAP_READ_BIT);

		glCreateBuffers(1, &index_buffer);
		glNamedBufferStorage(index_buffer, indices * sizeof(uint16_t), nullptr, GL_DYNAMIC_STORAGE_BIT | GL_MAP_READ_BIT);

		glCreateBuffers(1, &instance_ssbo);
		glCreateBuffers(1, &instance_team_color_index_ssbo);
		glCreateBuffers(1, &layer_colors_ssbo);
		glCreateBuffers(1, &bones_ssbo);
		glCreateBuffers(1, &bones_ssbo_colored);

		// Buffer Data
		int base_vertex = 0;
		int base_index = 0;

		for (const auto& i : mdx->geosets) {
			if (i.lod != 0) {
				continue;
			}
			MeshEntry entry;
			entry.vertices = static_cast<int>(i.vertices.size());
			entry.base_vertex = base_vertex;

			entry.indices = static_cast<int>(i.faces.size());
			entry.base_index = base_index;

			entry.material_id = i.material_id;
			entry.geoset_anim = nullptr;
			entry.extent = i.extent;

			geosets.push_back(entry);

			if (i.skin.empty()) {
				// If the skin vector is empty, then the model has SD bone weights, and we convert them to the HD skin weights.
				const auto skin_weights = mdx::MDX::matrix_groups_as_skin_weights(i);
				glNamedBufferSubData(weight_buffer, base_vertex * sizeof(glm::uvec2), entry.vertices * 8, skin_weights.data());
			} else {
				glNamedBufferSubData(weight_buffer, base_vertex * sizeof(glm::uvec2), entry.vertices * 8, i.skin.data());
			}

			std::vector<glm::uvec2> vertices_snorm;
			for (const auto& j : i.vertices) {
				vertices_snorm.push_back(pack_vec3_to_uvec2(j, 8192.f));
			}
			glNamedBufferSubData(vertex_snorm_buffer, base_vertex * sizeof(glm::uvec2), entry.vertices * sizeof(glm::uvec2), vertices_snorm.data());

			std::vector<uint32_t> uvs_snorm;
			for (const auto& j : i.uv_sets.front()) {
				uvs_snorm.push_back(glm::packSnorm2x16((j + 1.f) / 8.f));
			}
			glNamedBufferSubData(uv_snorm_buffer, base_vertex * sizeof(uint32_t), entry.vertices * sizeof(uint32_t), uvs_snorm.data());

			std::vector<uint32_t> normals_oct_snorm;
			for (const auto& normal : i.normals) {
				normals_oct_snorm.push_back(glm::packSnorm2x16(float32x3_to_oct(normal)));
			}
			glNamedBufferSubData(normal_buffer, base_vertex * sizeof(uint32_t), entry.vertices * sizeof(uint32_t), normals_oct_snorm.data());

			if (!i.tangents.empty()) {
				glNamedBufferSubData(tangent_buffer, base_vertex * sizeof(glm::vec4), entry.vertices * sizeof(glm::vec4), i.tangents.data());
			} else {
				//glNamedBufferSubData(tangent_buffer, base_vertex * sizeof(glm::vec4), entry.vertices * sizeof(glm::vec4), normals_vec4.data());
			}

			glNamedBufferSubData(index_buffer, base_index * sizeof(uint16_t), entry.indices * sizeof(uint16_t), i.faces.data());

			base_vertex += entry.vertices;
			base_index += entry.indices;
		}

		for (const auto& i : geosets) {
			skip_count += mdx->materials[i.material_id].layers.size();
			instance_vertex_count += i.indices;
		}

		// animations geoset ids > geosets
		for (auto& i : mdx->animations) {
			if (i.geoset_id >= 0 && i.geoset_id < geosets.size()) {
				geosets[i.geoset_id].geoset_anim = &i;
			}
		}

		for (size_t i = 0; i < mdx->textures.size(); i++) {
			const mdx::Texture& texture = mdx->textures[i];
			
			if (texture.replaceable_id != 0) {
				// Figure out if this is an HD texture
				// Unfortunately replaceable ID textures don't have any additional information on whether they are diffuse/normal/orm
				// So we take a guess using the index
				std::string suffix("");
				bool found = false;
				for (const auto& material : mdx->materials) {
					for (const auto& layer : material.layers) {
						for (size_t j = 0; j < layer.textures.size(); j++) {
							if (layer.textures[j].id != i) {
								continue;
							}

							found = true;

							if (layer.hd) {
								switch (j) {
									case 0:
										suffix = "_diffuse";
										break;
									case 1:
										suffix = "_normal";
										break;
									case 2:
										suffix = "_orm";
										break;
									case 3:
										suffix = "_emissive";
										break;
								}
							}
							break;
						}
						if (found) {
							break;
						}
					}
					if (found) {
						break;
					}
				}

				if (replaceable_id_override && texture.replaceable_id == replaceable_id_override->first) {
					textures.push_back(resource_manager.load<GPUTexture>(replaceable_id_override->second + suffix, std::to_string(texture.flags)));
				} else {
					textures.push_back(resource_manager.load<GPUTexture>(mdx::replaceable_id_to_texture.at(texture.replaceable_id) + suffix, std::to_string(texture.flags)));
				}
			} else {
				textures.push_back(resource_manager.load<GPUTexture>(texture.file_name, std::to_string(texture.flags)));
			}
			// TODO we should have a unique texture resource for each combination of the below two settings
			// Or emulate it in the shader?
			glTextureParameteri(textures.back()->id, GL_TEXTURE_WRAP_S, texture.flags & 1 ? GL_REPEAT : GL_CLAMP_TO_EDGE);
			glTextureParameteri(textures.back()->id, GL_TEXTURE_WRAP_T, texture.flags & 2 ? GL_REPEAT : GL_CLAMP_TO_EDGE);
		}

		// Reclaim some space
		for (auto& i : mdx->geosets) {
			i.vertices.clear();
			i.vertices.shrink_to_fit();
			i.normals.clear();
			i.normals.shrink_to_fit();
			i.face_type_groups.clear();
			i.face_type_groups.shrink_to_fit();
			i.face_groups.clear();
			i.face_groups.shrink_to_fit();
			i.faces.clear();
			i.faces.shrink_to_fit();
			i.vertex_groups.clear();
			i.vertex_groups.shrink_to_fit();
			i.matrix_groups.clear();
			i.matrix_groups.shrink_to_fit();
			i.matrix_indices.clear();
			i.matrix_indices.shrink_to_fit();
			i.tangents.clear();
			i.tangents.shrink_to_fit();
			i.skin.clear();
			i.skin.shrink_to_fit();
			i.uv_sets.clear();
			i.uv_sets.shrink_to_fit();
		}

		glVertexArrayElementBuffer(vao, index_buffer);
	}

	~SkinnedMesh() {
		glDeleteBuffers(1, &vertex_snorm_buffer);
		glDeleteBuffers(1, &uv_snorm_buffer);
		glDeleteBuffers(1, &normal_buffer);
		glDeleteBuffers(1, &tangent_buffer);
		glDeleteBuffers(1, &weight_buffer);
		glDeleteBuffers(1, &index_buffer);
		glDeleteBuffers(1, &layer_colors_ssbo);
		glDeleteBuffers(1, &instance_ssbo);
		glDeleteBuffers(1, &bones_ssbo);
		glDeleteBuffers(1, &bones_ssbo_colored);
	}

	void upload_render_data() {
		if (!has_mesh) {
			return;
		}

		glNamedBufferData(instance_ssbo, render_jobs.size() * sizeof(glm::mat4), render_jobs.data(), GL_DYNAMIC_DRAW);
		glNamedBufferData(instance_team_color_index_ssbo, render_team_color_indexes.size() * sizeof(uint32_t), render_team_color_indexes.data(), GL_DYNAMIC_DRAW);

		for (int i = 0; i < render_jobs.size(); i++) {
			instance_bone_matrices.insert(instance_bone_matrices.end(), skeletons[i]->world_matrices.begin(), skeletons[i]->world_matrices.begin() + mdx->bones.size());
		}

		glNamedBufferData(bones_ssbo, instance_bone_matrices.size() * sizeof(glm::mat4), instance_bone_matrices.data(), GL_DYNAMIC_DRAW);

		for (size_t k = 0; k < render_jobs.size(); k++) {
			for (const auto& i : geosets) {
				glm::vec3 geoset_color = render_colors[k];
				float geoset_anim_visibility = 1.0f;
				if (i.geoset_anim && skeletons[k]->sequence_index >= 0) {
					geoset_color *= skeletons[k]->get_geoset_animation_color(*i.geoset_anim);
					geoset_anim_visibility = skeletons[k]->get_geoset_animation_visiblity(*i.geoset_anim);
				}

				const auto& layers = mdx->materials[i.material_id].layers;
				for (auto& j : layers) {
					float layer_visibility = 1.0f;
					if (skeletons[k]->sequence_index >= 0) {
						layer_visibility = skeletons[k]->get_layer_visiblity(j);
					}
					layer_colors.push_back(glm::vec4(geoset_color, layer_visibility * geoset_anim_visibility));
				}
			}
		}

		glNamedBufferData(layer_colors_ssbo, layer_colors.size() * sizeof(glm::vec4), layer_colors.data(), GL_DYNAMIC_DRAW);
	}

	void clear_render_data() {
		render_jobs.clear();
		render_colors.clear();
		render_team_color_indexes.clear();
		skeletons.clear();
		instance_bone_matrices.clear();
		layer_colors.clear();
	}

	void render_opaque(const bool render_hd, const bool render_lighting) const {
		if (!has_mesh) {
			return;
		}

		glBindVertexArray(vao);

		glUniform1i(4, skip_count);
		glUniform1ui(6, mdx->bones.size());
		glUniform1i(7, 0); // non-instanced instanceID uniform

		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, layer_colors_ssbo);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, uv_snorm_buffer);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, vertex_snorm_buffer);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, tangent_buffer);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 4, normal_buffer);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 5, instance_ssbo);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 6, weight_buffer);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 7, bones_ssbo);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 8, instance_team_color_index_ssbo);

		int lay_index = 0;
		for (const auto& i : geosets) {
			const auto& layers = mdx->materials[i.material_id].layers;

			if (layers[0].blend_mode != 0 && layers[0].blend_mode != 1) {
				lay_index += layers.size();
				continue;
			}

			for (const auto& j : layers) {
				if (j.hd != render_hd) {
					lay_index += 1;
					continue;
				}

				// We don't have to render fully transparent meshes
				// Some Reforged bridges for instance have a FilterMode None but a static alpha of 0 for some materials
				// TODO: this is a hack, if the first instance has an alpha animation that triggers this condition then all instances will be hidden, even if the others have a positive alpha
				if (layer_colors[lay_index].a <= 0.01f) {
					lay_index += 1;
					continue;
				}

				glUniform1f(1, j.blend_mode == 1 ? 0.75f : -1.0f);
				glUniform1i(2, !(j.shading_flags & 0x1) && render_lighting);
				glUniform1i(5, lay_index);
				const bool is_team_color =
					(mdx->textures[j.textures[0].id].replaceable_id == 1 || mdx->textures[j.textures[0].id].replaceable_id == 2);
				glUniform1i(10, is_team_color);

				switch (j.blend_mode) {
					case 0:
					case 1:
						glBlendFunc(GL_ONE, GL_ZERO);
						break;
					case 2:
						glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
						break;
					case 3:
						glBlendFunc(GL_SRC_ALPHA, GL_ONE);
						break;
					case 4:
						glBlendFunc(GL_SRC_ALPHA, GL_ONE);
						break;
					case 5:
						glBlendFunc(GL_ZERO, GL_SRC_COLOR);
						break;
					case 6:
						glBlendFunc(GL_DST_COLOR, GL_SRC_COLOR);
						break;
				}

				if (j.shading_flags & 0x10) {
					glDisable(GL_CULL_FACE);
				} else {
					glEnable(GL_CULL_FACE);
				}

				if (j.shading_flags & 0x40) {
					glDisable(GL_DEPTH_TEST);
				} else {
					glEnable(GL_DEPTH_TEST);
				}

				if (j.shading_flags & 0x80) {
					glDepthMask(false);
				} else {
					glDepthMask(true);
				}

				for (size_t texture_slot = 0; texture_slot < j.textures.size(); texture_slot++) {
					glBindTextureUnit(texture_slot, textures[j.textures[texture_slot].id]->id);
				}

				glDrawElementsInstancedBaseVertex(GL_TRIANGLES, i.indices, GL_UNSIGNED_SHORT, reinterpret_cast<void*>(i.base_index * sizeof(uint16_t)), render_jobs.size(), i.base_vertex);
				lay_index += 1;
			}
		}
	}

	void render_transparent(const int instance_id, const bool render_hd, const bool render_lighting) const {
		if (!has_mesh) {
			return;
		}

		glBindVertexArray(vao);

		glUniform1i(4, skip_count);
		glUniform1ui(6, mdx->bones.size());
		glUniform1i(7, instance_id);

		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, layer_colors_ssbo);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, uv_snorm_buffer);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, vertex_snorm_buffer);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, tangent_buffer);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 4, normal_buffer);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 5, instance_ssbo);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 6, weight_buffer);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 7, bones_ssbo);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 8, instance_team_color_index_ssbo);

		int layer_index = 0;
		for (const auto& i : geosets) {
			const auto& layers = mdx->materials[i.material_id].layers;

			if (layers[0].blend_mode == 0 || layers[0].blend_mode == 1) {
				layer_index += layers.size();
				continue;
			}

			for (const auto& j : layers) {
				if (j.hd != render_hd) {
					layer_index += 1;
					continue;
				}

				// We don't have to render fully transparent meshes
				if (layer_colors[instance_id * skip_count + layer_index].a <= 0.01f) {
					layer_index += 1;
					continue;
				}

				glUniform1i(2, !(j.shading_flags & 0x1) && render_lighting);
				glUniform1i(5, layer_index);
				const bool is_team_color =
					(mdx->textures[j.textures[0].id].replaceable_id == 1 || mdx->textures[j.textures[0].id].replaceable_id == 2);
				glUniform1i(10, is_team_color);

				switch (j.blend_mode) {
					case 2:
						glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
						break;
					case 3:
						glBlendFunc(GL_SRC_ALPHA, GL_ONE);
						break;
					case 4:
						glBlendFunc(GL_SRC_ALPHA, GL_ONE);
						break;
					case 5:
						glBlendFunc(GL_ZERO, GL_SRC_COLOR);
						break;
					case 6:
						glBlendFunc(GL_DST_COLOR, GL_SRC_COLOR);
						break;
				}

				if (j.shading_flags & 0x10) {
					glDisable(GL_CULL_FACE);
				} else {
					glEnable(GL_CULL_FACE);
				}

				if (j.shading_flags & 0x40) {
					glDisable(GL_DEPTH_TEST);
				} else {
					glEnable(GL_DEPTH_TEST);
				}

				for (size_t texture_slot = 0; texture_slot < j.textures.size(); texture_slot++) {
					glBindTextureUnit(texture_slot, textures[j.textures[texture_slot].id]->id);
				}

				glDrawElementsBaseVertex(GL_TRIANGLES, i.indices, GL_UNSIGNED_SHORT, reinterpret_cast<void*>(i.base_index * sizeof(uint16_t)), i.base_vertex);
				layer_index += 1;
			}
		}
	}

	void render_color_coded(const SkeletalModelInstance& skeleton, const int id) const {
		if (!has_mesh) {
			return;
		}

		glBindVertexArray(vao);

		glm::mat4 MVP = camera.projection_view * skeleton.matrix;
		glUniformMatrix4fv(0, 1, false, &MVP[0][0]);

		glUniform1i(7, id);

		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, bones_ssbo_colored);
		glNamedBufferData(bones_ssbo_colored, mdx->bones.size() * sizeof(glm::mat4), skeleton.world_matrices.data(), GL_DYNAMIC_DRAW);

		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, vertex_snorm_buffer);
		glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, weight_buffer);

		for (const auto& i : geosets) {
			float geoset_anim_visibility = 1.0f;
			if (i.geoset_anim && skeleton.sequence_index >= 0) {
				geoset_anim_visibility = skeleton.get_geoset_animation_visiblity(*i.geoset_anim);
			}

			for (const auto& j : mdx->materials[i.material_id].layers) {
				float layer_visibility = 1.0f;
				if (skeleton.sequence_index >= 0) {
					layer_visibility = skeleton.get_layer_visiblity(j);
				}

				const float final_visibility = layer_visibility * geoset_anim_visibility;
				if (final_visibility <= 0.001f) {
					continue;
				}

				if (j.shading_flags & 0x40) {
					glDisable(GL_DEPTH_TEST);
				} else {
					glEnable(GL_DEPTH_TEST);
				}

				if (j.shading_flags & 0x80) {
					glDepthMask(false);
				} else {
					glDepthMask(true);
				}

				if (j.shading_flags & 0x10) {
					glDisable(GL_CULL_FACE);
				} else {
					glEnable(GL_CULL_FACE);
				}

				glDrawElementsBaseVertex(GL_TRIANGLES, i.indices, GL_UNSIGNED_SHORT, reinterpret_cast<void*>(i.base_index * sizeof(uint16_t)), i.base_vertex);
				break;
			}
		}
	}
};
```

`src/resources/skinned_mesh/render_node.ixx`:

```ixx
export module RenderNode;

import MDX;
import MathOperations;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;
import <glm/gtc/quaternion.hpp>;

export struct RenderNode {
	const mdx::Node* node;
	glm::vec3 pivot;

	bool dont_inherit_translation;
	bool dont_inherit_scaling;
	bool dont_inherit_rotation;

	bool billboarded;
	bool billboardedX;
	bool billboardedY;
	bool billboardedZ;

	RenderNode() = default;
	RenderNode(const mdx::Node& node, const glm::vec3 pivot) {
		this->node = &node;
		this->pivot = pivot;

		dont_inherit_translation = node.flags & mdx::Node::Flags::dont_inherit_translation;
		dont_inherit_rotation = node.flags & mdx::Node::Flags::dont_inherit_rotation;
		dont_inherit_scaling = node.flags & mdx::Node::Flags::dont_inherit_scaling;
		billboarded = node.flags & mdx::Node::Flags::billboarded;
		billboardedX = node.flags & mdx::Node::Flags::billboarded_lock_x;
		billboardedY = node.flags & mdx::Node::Flags::billboarded_lock_y;
		billboardedZ = node.flags & mdx::Node::Flags::billboarded_lock_z;
	}
};
```

`src/resources/skinned_mesh/skeletal_model_instance.ixx`:

```ixx
module;

#include <cassert>
#include <chrono>

export module SkeletalModelInstance;

import std;
import Camera;
import Utilities;
import MathOperations;
import RenderNode;
import MDX;
import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;
import <glm/gtc/quaternion.hpp>;

// Ghostwolf mentioned this to me once, so I used it,
// as 0.75, experimentally determined as a guess at
// whatever WC3 is doing. Do more research if necessary?
#define MAGIC_RENDER_SHOW_CONSTANT 0.75

// Instead of recalculating the extents of the current sequence every frame we can keep track of it
struct CurrentKeyFrame {
	int start = -1;
	int end = 0;
	int left = 0;
	int right = 0;
};

export class SkeletalModelInstance {
  public:
	std::shared_ptr<mdx::MDX> model;

	int sequence_index = 0; // can be -1 if not animating
	int current_frame = 0;

	glm::mat4 matrix = glm::mat4(1.f);

	std::vector<CurrentKeyFrame> current_keyframes;
	std::vector<RenderNode> render_nodes;
	std::vector<glm::mat4> world_matrices;

	SkeletalModelInstance() = default;
	explicit SkeletalModelInstance(const std::shared_ptr<mdx::MDX>& model) : model(model) {
		const size_t node_count = model->bones.size() +
							model->lights.size() +
							model->help_bones.size() +
							model->attachments.size() +
							model->emitters1.size() +
							model->emitters2.size() +
							model->ribbons.size() +
							model->event_objects.size() +
							model->collision_shapes.size() +
							model->corn_emitters.size();

		// ToDo: for each camera: add camera source node to renderNodes
		render_nodes.resize(node_count);
		world_matrices.resize(node_count);
		model->for_each_node([&](const mdx::Node& node) {
			// Seen it happen with Emmitter1, is this an error in the model?
			// ToDo purge (when adding a validation layer or just crashing)
			if (node.id == -1) {
				return;
			}

			render_nodes[node.id] = RenderNode(node, model->pivots[node.id]);
		});

		current_keyframes.resize(model->unique_tracks);

		for (size_t i = 0; i < model->sequences.size(); i++) {
			if (model->sequences[i].name.find("Stand") != std::string::npos || model->sequences[i].name.find("stand") != std::string::npos) {
				set_sequence(static_cast<int>(i));
				break;
			}
		}
	}

	void update_location(const glm::vec3 position, const glm::quat& rotation, const glm::vec3& scale) {
		from_rotation_translation_scale_origin(rotation, position, scale, matrix, glm::vec3(0, 0, 0));
	}

	void update_location(const glm::vec3 position, const float angle, const glm::vec3& scale) {
		const glm::quat rotation = glm::angleAxis(angle, glm::vec3(0, 0, 1));
		from_rotation_translation_scale_origin(rotation, position, scale, matrix, glm::vec3(0, 0, 0));
	}

	void update(const double delta) {
		if (model->sequences.empty() || sequence_index == -1) {
			return;
		}

		// Advance current frame
		const mdx::Sequence& sequence = model->sequences[sequence_index];
		//if (sequence.flags & mdx::Sequence::non_looping) {
		//	current_frame = std::min<int>(current_frame + delta * 1000.0, sequence.end_frame);
		//} else {
			current_frame += delta * 1000.0;
			if (current_frame > sequence.end_frame) {
				current_frame = sequence.start_frame;
			}
		//}

		for (const auto& i : render_nodes) {
			advance_keyframes(i.node->KGTR);
			advance_keyframes(i.node->KGRT);
			advance_keyframes(i.node->KGSC);
		}

		for (const auto& i : model->animations) {
			advance_keyframes(i.KGAC);
			advance_keyframes(i.KGAO);
		}

		for (const auto& i : model->materials) {
			for (const auto& j : i.layers) {
				advance_keyframes(j.KMTA);
				// Add more when required
			}
		}

		update_nodes();
	}

void update_nodes() {
		assert(sequence_index >= 0 && sequence_index < model->sequences.size());

		const glm::mat3 inverse_model_rotation = glm::transpose(
			glm::mat3 {
				glm::normalize(glm::vec3(matrix[0])),
				glm::normalize(glm::vec3(matrix[1])),
				glm::normalize(glm::vec3(matrix[2])),
			}
		);

		// Todo, node->parent_id can be higher than their current id. No ordering exists
		// So in the loop below the parent_matrix might be empty for the first frame and an animation might be one frame behind
		for (const auto& node : render_nodes) {
			const glm::vec3 position = interpolate_keyframes(node.node->KGTR, TRANSLATION_IDENTITY);
			const glm::quat rotation = interpolate_keyframes(node.node->KGRT, ROTATION_IDENTITY);
			const glm::vec3 scale = interpolate_keyframes(node.node->KGSC, SCALE_IDENTITY);

			glm::quat final_rotation = rotation;
			if (node.billboarded) {
				const glm::mat3 cam_world = inverse_model_rotation * glm::mat3(camera.view_inverse);
				const glm::mat3 inverse_camera_world = glm::mat3(cam_world[2], cam_world[0], cam_world[1]);

				if (node.node->parent_id != -1) {
					// Extract and invert parent rotation to keep billboard effect
					const glm::mat4& parent_matrix = world_matrices[node.node->parent_id];
					const glm::vec3 parent_scale = glm::vec3(
						glm::length(glm::vec3(parent_matrix[0])),
						glm::length(glm::vec3(parent_matrix[1])),
						glm::length(glm::vec3(parent_matrix[2]))
					);
					const glm::mat3 parent_rotation = glm::mat3(
						glm::vec3(parent_matrix[0]) / parent_scale.x,
						glm::vec3(parent_matrix[1]) / parent_scale.y,
						glm::vec3(parent_matrix[2]) / parent_scale.z
					);
					final_rotation = glm::quat_cast(glm::transpose(parent_rotation)) * glm::quat_cast(inverse_camera_world);
				} else {
					final_rotation = glm::quat_cast(inverse_camera_world);
				}
			}

			from_rotation_translation_scale_origin(final_rotation, position, scale, world_matrices[node.node->id], node.pivot);

			if (node.node->parent_id != -1) {
				world_matrices[node.node->id] = world_matrices[node.node->parent_id] * world_matrices[node.node->id];
			}
		}
	}

	// Sets the current sequence to sequence_index and recalculates required keyframe data
	void set_sequence(const int sequence_index) {
		this->sequence_index = sequence_index;
		current_frame = model->sequences[sequence_index].start_frame;

		for (const auto& i : render_nodes) {
			calculate_sequence_extents(i.node->KGTR);
			calculate_sequence_extents(i.node->KGRT);
			calculate_sequence_extents(i.node->KGSC);
		}

		for (const auto& i : model->animations) {
			calculate_sequence_extents(i.KGAC);
			calculate_sequence_extents(i.KGAO);
		}

		for (const auto& i : model->materials) {
			for (const auto& j : i.layers) {
				calculate_sequence_extents(j.KMTA);
				// Add more when required
			}
		}
	}
	
	template <typename T>
	void calculate_sequence_extents(const mdx::TrackHeader<T>& header) {
		if (header.id == -1) {
			return;
		}

		const mdx::Sequence& sequence = model->sequences[sequence_index];
		int local_sequence_start = sequence.start_frame;
		int local_sequence_end = sequence.end_frame;

		if (header.global_sequence_ID >= 0 && model->global_sequences.size()) {
			local_sequence_start = 0;
			local_sequence_end = model->global_sequences[header.global_sequence_ID];
		}

		CurrentKeyFrame& current = current_keyframes[header.id];
		current.start = -1;
		current.right = -1;

		// Find the sequence start and end tracks, these are not always exactly at the sequence start/end
		for (int i = 0; i < header.tracks.size(); i++) {
			const mdx::Track<T>& track = header.tracks[i];

			if (track.frame > local_sequence_end) {
				break;
			}

			if (track.frame >= local_sequence_start && current.start == -1) {
				current.start = i;
			}

			current.end = i;
		}

		// Set the starting left/right track index
		if (current.start != -1) {
			current.left = current.start;

			if (current.end > current.start) {
				current.right = current.left + 1;
			} else {
				current.right = current.left;
			}
		}
	}


	template <typename T>
	void advance_keyframes(const mdx::TrackHeader<T>& header) {
		if (header.id == -1) {
			return;
		}
		CurrentKeyFrame& current = current_keyframes[header.id];

		int local_current_frame = current_frame;

		if (header.global_sequence_ID >= 0 && model->global_sequences.size()) {
			int local_sequence_end = model->global_sequences[header.global_sequence_ID];
			if (local_sequence_end == 0) {
				local_current_frame = 0;
			} else {
				local_current_frame = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % local_sequence_end;
			}
		}

		// If there are no tracks in sequence
		if (current.start == -1) {
			return;
		}

		// If there is only 1 track
		if (current.start == current.end) {
			return;
		}

		// Detect if we looped
		if (header.tracks[current.left].frame > local_current_frame) {
			current.left = current.start;
			current.right = current.start + 1;
		}

		// Scan till we find two tracks
		while (header.tracks[current.right].frame < local_current_frame) {
			current.left = current.right;
			current.right++;

			// Reached last keyframe
			if (current.right > current.end) {
				break;
			}

			// No need for interpolation if current_frame is exactly on a track
			if (header.tracks[current.right].frame == local_current_frame) {
				current.left = current.right;
			}
		}

		// The first/last tracks are not always exactly at the sequence start/end
		const bool past_end = header.tracks[current.end].frame < local_current_frame;
		const bool before_start = header.tracks[current.start].frame > local_current_frame;
		if (past_end || before_start) {
			current.left = current.end;
			current.right = current.start;
		}
	}

	// Returns RGB instead of BGR as Blizzard used internally
	glm::vec3 get_geoset_animation_color(const mdx::GeosetAnimation& animation) const {
		// bgr to rgb
		const auto animation_color = glm::vec3(animation.color.b, animation.color.g, animation.color.r);
		const auto interpolated_color = interpolate_keyframes<glm::vec3>(animation.KGAC, animation_color);
		// rgb to bgr
		return glm::vec3(interpolated_color.b, interpolated_color.g, interpolated_color.r);
	}

	float get_geoset_animation_visiblity(const mdx::GeosetAnimation& animation) const {
		return interpolate_keyframes(animation.KGAO, animation.alpha);
	}

	float get_layer_visiblity(const mdx::Layer& layer) const {
		return interpolate_keyframes(layer.KMTA, layer.alpha);
	}

	template <typename T>
	T interpolate_keyframes(const mdx::TrackHeader<T>& header, const T& default_value) const {
		if (header.id == -1) {
			return default_value;
		}

		const CurrentKeyFrame& current = current_keyframes[header.id];
		const mdx::Sequence& sequence = model->sequences[sequence_index];

		int local_current_frame = current_frame;
		int local_sequence_start = sequence.start_frame;
		int local_sequence_end = sequence.end_frame;

		if (header.global_sequence_ID >= 0 && model->global_sequences.size()) {
			local_sequence_start = 0;
			local_sequence_end = model->global_sequences[header.global_sequence_ID];
			if (local_sequence_end == 0) {
				local_current_frame = 0;
			} else {
				local_current_frame = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % local_sequence_end;
			}
		}

		// If there are no tracks in sequence
		if (current.start == -1) {
			return default_value;
		}

		// If there is only 1 track
		if (current.start == current.end) {
			return header.tracks[current.left].value;
		}

		const T ceil_in_tan = header.tracks[current.right].inTan;
		const T floor_out_tan = header.tracks[current.left].outTan;

		int floor_time = header.tracks[current.left].frame;
		const int ceil_time = header.tracks[current.right].frame;
		const T floor_value = header.tracks[current.left].value;
		const T ceil_value = header.tracks[current.right].value;

		// This is the implementation that correctly handles missing start/end frames.
		// The game and WE however have a buggy implementation which is the one we end up using for compatibility
		// float t;
		// if (ceil_time - floor_time < 0) {
		//	int duration = (local_sequence_end - floor_time) + (ceil_time - local_sequence_start);

		//	if (local_current_frame > floor_time) {
		//		t = (local_current_frame - floor_time) / (float)duration;
		//	} else {
		//		t = (local_current_frame - local_sequence_start + (local_sequence_end - floor_time)) / (float)duration;
		//	}
		//} else {
		//	t = (local_current_frame - floor_time) / static_cast<float>(ceil_time - floor_time);
		//}

		// The (incorrect) implementation both the game and WE use
		int time_between_frames = ceil_time - floor_time;
		if (time_between_frames < 0) {
			time_between_frames += (local_sequence_end - local_sequence_start);
			if (local_current_frame < floor_time) {
				floor_time = ceil_time;
			}
		}
		const float t = time_between_frames == 0 ? 0.f : ((local_current_frame - floor_time) / static_cast<float>(time_between_frames));

		return interpolate(floor_value, floor_out_tan, ceil_in_tan, ceil_value, t, static_cast<int>(header.interpolation_type));
	}
};
```

`src/resources/texture.ixx`:

```ixx
module;

#include <vector>
#include <filesystem>

export module Texture;

import Hierarchy;
import BLP;
import BinaryReader;
import ResourceManager;
import <soil2/SOIL2.h>;

namespace fs = std::filesystem;

export class Texture : public Resource {
  public:
	int width;
	int height;
	int channels;
	std::vector<uint8_t> data;

	static constexpr const char* name = "Texture";

	explicit Texture() = default;
	explicit Texture(const fs::path& path) {
		fs::path new_path = path;

		if (hierarchy.hd) {
			new_path.replace_filename(path.stem().string() + "_diffuse");
		}

		new_path.replace_extension(".tga");
		BinaryReader reader = hierarchy.open_file(new_path)
			.or_else([&](const std::string&) {
				new_path.replace_extension(".blp");
				return hierarchy.open_file(new_path);
			})
			.or_else([&](const std::string&) {
				new_path.replace_extension(".dds");
				return hierarchy.open_file(new_path);
			})
			.or_else([&](const std::string&) {
				std::println("Error loading texture {}", new_path.string());
				new_path = "Textures/btntempw.dds";
				return hierarchy.open_file(new_path);
			})
			.value();

		uint8_t* image_data;

		if (new_path.extension() == ".blp") {
			image_data = blp::load(reader, width, height, channels);
		} else {
			image_data = SOIL_load_image_from_memory(reader.buffer.data(), static_cast<int>(reader.buffer.size()), &width, &height, &channels, SOIL_LOAD_AUTO);
		}
		data = std::vector<uint8_t>(image_data, image_data + width * height * channels);
		delete image_data;
	}
};
```

`src/test.ixx`:

```ixx
export module test;

import std;
import BinaryReader;
import MDX;
import no_init_allocator;
import <glm/glm.hpp>;

namespace fs = std::filesystem;

void parse_all_mdx() {
	std::vector<fs::path> paths;

	for (const auto i : fs::recursive_directory_iterator("D:/Warcraft/WC3/Assets")) {
		if (i.is_regular_file() && (i.path().extension() == ".mdx" || i.path().extension() == ".MDX")) {
			paths.push_back(i.path());
		}
	}

	auto min = glm::vec3(99999.f, 99999.f, 99999.f);
	auto max = glm::vec3(-99999.f, -99999.f, -99999.f);

	std::for_each(std::execution::seq, paths.begin(), paths.end(), [&](const fs::path& path) {
		std::ifstream stream(path, std::ios::binary);
		auto buffer = std::vector<uint8_t, default_init_allocator<uint8_t>>(std::istreambuf_iterator<char>(stream), std::istreambuf_iterator<char>());

		BinaryReader reader(buffer);
		auto mdx = mdx::MDX(reader);
		
		//min = glm::min(min, mdx.extent.minimum);
		//max = glm::max(min, mdx.extent.maximum);

		//std::println("x: {} y: {} z: {}", (max - min).x, (max - min).y, (max - min).z);

		//min = mdx.extent.minimum / 128.f;
		//max = mdx.extent.maximum / 128.f;

		//std::println("x: {} y: {} z: {} path: {}", (max - min).x, (max - min).y, (max - min).z, path.string());
	});
}

export void execute_tests() {
	std::print("[INFO] Parsing all MDX files\n");
	auto begin = std::chrono::steady_clock::now();
	parse_all_mdx();
	auto delta = (std::chrono::steady_clock::now() - begin).count() / 1'000'000.f;
	std::print("[INFO] Done parsing in {}ms\n", delta);
}

```

`src/trigger_editor/jass_editor.cpp`:

```cpp
#include "jass_editor.h"

#include <cmath>

#include <QShortcut>

import no_init_allocator;
import Hierarchy;

int Styling::styleAt(int idx) const {
	if (idx > 0) {
		return editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, idx);
	}
	return JASS_DEFAULT;
}

int Styling::styleToken(JassToken const& token, int start) {
	JassStyle style = JASS_DEFAULT;

	switch (token.type()) {
		case TOKEN_COMMENT_LINE:
			style = JASS_COMMENT;
			break;
		case TOKEN_PREPROCESSOR_COMMENT:
			style = JASS_PREPROCESSOR_COMMENT;
			break;
		case TOKEN_COMMENT_BLOCK:
			// TODO@Daniel:
			// Style docstring parameters

			style = JASS_COMMENT;
			break;
		case TOKEN_STRING:
			for (JassToken const& sequence : token.nested_tokens()) {
				setStyling(sequence.start() - start, JASS_STRING);
				setStyling(sequence.length(), JASS_ESCAPE_SEQUENCE);

				start = sequence.stop();
			}

			style = JASS_STRING;
			break;
		case TOKEN_RAWCODE:
			style = JASS_RAWCODE;
			break;
		case TOKEN_NUMBER:
			style = JASS_NUMBER;
			break;
		case TOKEN_IDENTIFIER:
			if (natives_.contains(token.value())) {
				style = JASS_NATIVE;
			} else if (functions_.contains(token.value())) {
				style = JASS_FUNCTION;
			} else if (constants_.contains(token.value())) {
				style = JASS_CONSTANT;
			} else if (types_.contains(token.value())) {
				style = JASS_TYPE;
			} else if (keywords_.contains(token.value())) {
				style = JASS_KEYWORD;
			}
			break;
	}

	setStyling(token.stop() - start, style);

	return token.stop();
}

void Styling::setKeywords(QSet<QString> list) {
	keywords_ = std::move(list);
}

void Styling::setOperators(QSet<QString> list) {
	operators_ = std::move(list);
}

void Styling::setNatives(QSet<QString> list) {
	natives_ = std::move(list);
}

void Styling::setFunctions(QSet<QString> list) {
	functions_ = std::move(list);
}

void Styling::setConstants(QSet<QString> list) {
	constants_ = std::move(list);
}

void Styling::setTypes(QSet<QString> list) {
	types_ = std::move(list);
}

Styling::Styling(QWidget* parent) : QsciLexerCustom(parent) {
	setDefaultFont(QFont("Consolas", 10));

	// TODO@Daniel:
	// Set from external configuration
	// I suggest YAML since it is very intuitive to use, though that may be just a personal preference
	setColor(QColor(181, 206, 168), JASS_NUMBER); // numbers
	setColor(QColor(56, 156, 214), JASS_KEYWORD); // keywords
	setColor(QColor(214, 157, 133), JASS_STRING); // string
	setColor(QColor(255, 204, 0), JASS_ESCAPE_SEQUENCE); // character escape sequences
	setColor(QColor(214, 157, 133), JASS_RAWCODE); // rawcode
	setColor(QColor(87, 166, 74), JASS_COMMENT); // comment
	setColor(QColor(155, 155, 155), JASS_PREPROCESSOR_COMMENT); // preprocessor comment
	setColor(QColor(189, 99, 197), JASS_NATIVE); // native
	setColor(QColor(200, 100, 100), JASS_FUNCTION); // function
	setColor(QColor(184, 215, 163), JASS_CONSTANT); // constant
	setColor(QColor(78, 201, 176), JASS_TYPE); // type

	std::vector<std::string> operators = { "+", "-", "/", "*", ",", "=", ":", "(", ")", ">=", "<=", "!=", "[", "]", "<", ">", "&" };

	// TODO@Daniel:
	// Types should be in their own list
	keywords_ = { "class", "return", "if", "else", "while", "for", "in", "break", "new", "null", "package", "endpackage",
		"function", "returns", "public", "private", "protected", "import", "initlater", "native", "nativetype", "extends", "interface",
		"implements", "module", "use", "abstract", "static", "thistype", "override", "immutable", "it", "array", "and", "or", "not",
		"this", "construct", "ondestroy", "destroy", "type", "constant", "endfunction", "nothing", "init", "castTo", "tuple", "div",
		"mod", "let", "from", "to", "downto", "step", "endpackage", "skip", "true", "false", "var", "instanceof", "super", "enum",
		"switch", "case", "default", "typeId", "begin", "end", "compiletime", "library", "endlibrary", "scope", "endscope", "requires",
		"uses", "needs", "struct", "endstruct", "then", "endif", "loop", "exitwhen", "endloop", "method", "takes", "endmethod", "set",
		"call", "globals", "endglobals", "initializer", "elseif", "vararg", "local" };
}

const char* Styling::language() const {
	return "VJass";
}

QString Styling::description(int style) const {
	switch (style) {
		case JASS_DEFAULT:
			return "Default";
		case JASS_COMMENT:
			return "Comment";
		case JASS_PREPROCESSOR_COMMENT:
			return "Preprocessor comment";
		case JASS_STRING:
			return "String literal";
		case JASS_ESCAPE_SEQUENCE:
			return "Character escape sequence";
		case JASS_NUMBER:
			return "Numbers";
		case JASS_OPERATOR:
			return "Operators";
		case JASS_NATIVE:
			return "Natives";
		case JASS_FUNCTION:
			return "Functions";
		case JASS_CONSTANT:
			return "Constant globals";
		case JASS_TYPE:
			return "Types and structs";
	}
	return "Unknown";
}

void Styling::styleText(int start, int end) {
	startStyling(start);

	// TODO@Daniel:
	// Eat up unfinished string/rawcode/comment block 

	int starting_style = styleAt(start - 1);

	JassTokenizer tokenizer(editor()->text().mid(start));

	int idx = 0;
	switch (starting_style) {
		case JASS_COMMENT:
			idx = styleToken(tokenizer.parse_comment_block(), idx);
			break;
		case JASS_STRING:
			idx = styleToken(tokenizer.parse_string(), idx);
			break;
		case JASS_RAWCODE:
			idx = styleToken(tokenizer.parse_rawcode(), idx);
			break;
		default:
			break;
	}

	do {
		idx = styleToken(tokenizer.next(), idx);
	} while (idx < tokenizer.text_size() && idx + start < end);
}

bool Styling::caseSensitive() const {
	return false;
}

JassEditor::JassEditor(QWidget* parent) : QsciScintilla(parent), lexer(this), api(&lexer) {
	setLexer(&lexer);
	setCaretForegroundColor(QColor(255, 255, 255));
	setMargins(2);
	setMarginType(0, QsciScintilla::MarginType::NumberMargin);
	setMarginWidth(0, "00");
	setMarginWidth(1, "0");
	setMarginLineNumbers(0, true);

	setIndentationsUseTabs(true);
	setTabIndents(true);
	setIndentationGuides(true);
	setAutoIndent(true);
	setTabWidth(4);
	setEolMode(QsciScintilla::EolUnix);

	// Autocompletion
	setAutoCompletionSource(QsciScintilla::AutoCompletionSource::AcsAll);
	setAutoCompletionUseSingle(QsciScintilla::AcusExplicit);
	setAutoCompletionReplaceWord(false);
	setAutoCompletionThreshold(1);
	setAutoCompletionCaseSensitivity(false);
	SendScintilla(SCI_AUTOCSETCASEINSENSITIVEBEHAVIOUR, SC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE);
	SendScintilla(SCI_AUTOCSETCANCELATSTART, false);

	SendScintilla(SCI_STYLESETBACK, STYLE_BRACELIGHT, qRgb(30, 75, 125));
	SendScintilla(SCI_STYLESETBACK, STYLE_BRACEBAD, qRgb(125, 60, 25));
	setBraceMatching(QsciScintilla::BraceMatch::SloppyBraceMatch);

	// Column selections
	SendScintilla(SCI_SETMULTIPLESELECTION, true);
	SendScintilla(SCI_SETVIRTUALSPACEOPTIONS, SCVS_RECTANGULARSELECTION | SCVS_NOWRAPLINESTART);
	SendScintilla(SCI_SETADDITIONALSELECTIONTYPING, true);
	SendScintilla(SCI_SETMULTIPASTE, SC_MULTIPASTE_EACH);

	setCallTipsBackgroundColor(palette().color(QPalette::ColorRole::Base));
	setCallTipsForegroundColor(palette().color(QPalette::ColorRole::Text).darker());
	setCallTipsHighlightColor(palette().color(QPalette::ColorRole::Text));

	indicatorDefine(IndicatorStyle::StraightBoxIndicator, search_indicator);
	SendScintilla(SCI_INDICSETFORE, search_indicator, qRgb(0, 56, 119));
	SendScintilla(SCI_INDICSETALPHA, search_indicator, 255);
	SendScintilla(SCI_INDICSETUNDER, search_indicator, true);

	QSet<QString> types;
	QSet<QString> natives;
	QSet<QString> functions;
	QSet<QString> constants;

	// Primitive types
	types.insert("nothing");
	types.insert("boolean");
	types.insert("code");
	types.insert("integer");
	types.insert("real");
	types.insert("string");
	types.insert("handle");

	// NOTE@Daniel:
	// I hadn't noticed that this wasn't a QString before I finished JassTokenizer
	std::vector<uint8_t, default_init_allocator<uint8_t>> common_data = hierarchy.open_file("Scripts/common.j").value().buffer;
	QString common_script(QByteArray((char const*)common_data.data(), (int)common_data.size()));

	std::vector<uint8_t, default_init_allocator<uint8_t>> blizzard_data = hierarchy.open_file("Scripts/blizzard.j").value().buffer;
	QString blizzard_script(QByteArray((char const*)blizzard_data.data(), (int)blizzard_data.size()));

	std::vector<uint8_t, default_init_allocator<uint8_t>> cheat_data = hierarchy.open_file("Scripts/cheats.j").value().buffer;
	QString cheat_script(QByteArray((char const*)cheat_data.data(), (int)cheat_data.size()));

	// TODO@Daniel:
	// This should be in it's own class
	JassTokenizer tokenizer(common_script + '\n' + blizzard_script + '\n' + cheat_script);

	JassToken token = tokenizer.next();
	while (token.type() != TOKEN_EOF) {
		if (token.value() == "function") {
			token = tokenizer.eat_comment_blocks();

			if (token.type() == TOKEN_IDENTIFIER) {
				QString value = token.value();

				token = tokenizer.eat_comment_blocks();
				if (token.value() == "takes") {
					QStringList parameters;

					do {
						JassToken type_name = tokenizer.eat_comment_blocks();
						JassToken identifier_name = tokenizer.eat_comment_blocks();

						parameters.append(type_name.value() + ' ' + identifier_name.value());

						token = tokenizer.eat_comment_blocks();
					} while (token.type() == TOKEN_OPERATOR);

					QString parameter_string = parameters.join(", ");
					QString declaration = value + '(' + parameter_string + ')';
					functions.insert(value);
					api.add(declaration);
				}
			}
		} else if (token.value() == "native") {
			token = tokenizer.eat_comment_blocks();

			if (token.type() == TOKEN_IDENTIFIER) {
				QString value = token.value();

				token = tokenizer.eat_comment_blocks();
				if (token.value() == "takes") {
					QStringList parameters;

					do {
						JassToken type_name = tokenizer.eat_comment_blocks();
						JassToken identifier_name = tokenizer.eat_comment_blocks();

						parameters.append(type_name.value() + ' ' + identifier_name.value());

						token = tokenizer.eat_comment_blocks();
					} while (token.type() == TOKEN_OPERATOR);

					QString parameter_string = parameters.join(", ");
					QString declaration = value + '(' + parameter_string + ')';
					natives.insert(value);
					api.add(declaration);
				}
			}
		} else if (token.value() == "type" || token.value() == "struct") {
			token = tokenizer.eat_comment_blocks();

			if (token.type() == TOKEN_IDENTIFIER) {
				types.insert(token.value());
				api.add(token.value());

				token = tokenizer.next();
			}
		} else if (token.value() == "constant") {
			token = tokenizer.eat_comment_blocks();

			if (token.value() != "function" && token.value() != "native" && types.contains(token.value())) {
				token = tokenizer.eat_comment_blocks();

				constants.insert(token.value());
				api.add(token.value());

				token = tokenizer.next();
			}
		} else {
			token = tokenizer.next();
		}
	}
	api.prepare();

	lexer.setTypes(types);
	lexer.setNatives(natives);
	lexer.setFunctions(functions);
	lexer.setConstants(constants);

	connect(this, &QsciScintilla::textChanged, this, &JassEditor::calculate_margin_width);
}

void JassEditor::highlight_text(const std::string& search_text) {
	SendScintilla(SCI_SETINDICATORCURRENT, search_indicator);
	SendScintilla(SCI_INDICATORCLEARRANGE, 0, text().length());

	if (search_text.empty()) {
		return;
	}

	SendScintilla(SCI_TARGETWHOLEDOCUMENT);

	int found = SendScintilla(SCI_SEARCHINTARGET, search_text.size(), search_text.data());
	while (found != -1) {
		int line_start = SendScintilla(SCI_LINEFROMPOSITION, found);
		int line_end = SendScintilla(SCI_LINEFROMPOSITION, found + (int)search_text.size());

		int index = SendScintilla(SCI_POSITIONFROMLINE, line_start);

		fillIndicatorRange(line_start, found - index, line_end, found - index + search_text.size(), 8);

		SendScintilla(SCI_SETTARGETRANGE, found + search_text.size(), text().length());

		found = SendScintilla(SCI_SEARCHINTARGET, search_text.size(), search_text.data());
	}
}

void JassEditor::calculate_margin_width() {
	const int new_width = std::log10(lines()) + 2;
	if (new_width != max_line_number_width) {
		max_line_number_width = new_width;
		setMarginWidth(0, QString('0').repeated(new_width));
	}
}
```

`src/trigger_editor/jass_editor.h`:

```h
#pragma once

#include <QSet>
#include <QString>

#include "jass_tokenizer.h"

#define QSCINTILLA_DLL
#include <Qsci/qsciapis.h>
#include <Qsci/qsciscintilla.h>
#include <Qsci/qscilexercustom.h>

class Styling : public QsciLexerCustom {
private:
	Q_OBJECT

	// TODO@Daniel:
	// Rearrange
	QSet<QString> keywords_;
	QSet<QString> natives_;
	QSet<QString> functions_;
	QSet<QString> constants_;
	QSet<QString> operators_;
	QSet<QString> types_;

	enum JassStyle {
		// NOTE@Daniel:
		// Style IDs may change
		JASS_DEFAULT = QsciScintilla::STYLE_DEFAULT,
		JASS_COMMENT = QsciScintilla::STYLE_LASTPREDEFINED,
		JASS_PREPROCESSOR_COMMENT,
		JASS_STRING,
		JASS_ESCAPE_SEQUENCE,
		JASS_RAWCODE,
		JASS_KEYWORD,
		JASS_NUMBER,

		// NOTE@Daniel:
		// Having a separate style is really useful, in my opinion
		// However, I don't know if there should be a distinction between different operators
		JASS_OPERATOR,

		// TODO@Daniel:
		// Make distinction between user declared natives/functions and those in common.j/common.ai/blizzard.j
		JASS_NATIVE,
		JASS_FUNCTION,
		JASS_CONSTANT,
		JASS_TYPE
	};

public:
	int styleAt(int idx) const;

	int styleToken(JassToken const& token, int start);

	void setKeywords(QSet<QString> list);
	void setOperators(QSet<QString> list);
	void setNatives(QSet<QString> list);
	void setFunctions(QSet<QString> list);
	void setConstants(QSet<QString> list);
	void setTypes(QSet<QString> list);

	Styling(QWidget* parent);
	const char* language() const override;
	QString description(int style) const override;
	void styleText(int start, int end) override;
	bool caseSensitive() const override;
};

class JassEditor : public QsciScintilla {
private:
	Q_OBJECT

	Styling lexer;
	QsciAPIs api;

	static constexpr int search_indicator = 8;

public:
	JassEditor(QWidget* parent = nullptr);
	void highlight_text(const std::string& text);
	int max_line_number_width;

	void calculate_margin_width();
};
```

`src/trigger_editor/jass_tokenizer.cpp`:

```cpp
#include "jass_tokenizer.h"

JassToken::JassToken(QString value, int start, int stop, JassTokenType type, QList<JassToken> nested_tokens) :
	value_(std::move(value)),
	start_(start),
	stop_(stop),
	type_(type),
	nested_tokens_(std::move(nested_tokens)) {

}

QString const& JassToken::value() const {
	return value_;
}

int JassToken::start() const {
	return start_;
}

int JassToken::stop() const {
	return stop_;
}

JassTokenType JassToken::type() const {
	return type_;
}

QList<JassToken> const& JassToken::nested_tokens() const {
	return nested_tokens_;
}

int JassToken::length() const {
	return stop() - start();
}

QChar JassTokenizer::at(int idx) const {
	if (idx < 0 || idx >= text_size()) {
		return '\0';
	}

	return text_[idx];
}

JassTokenizer::JassTokenizer(QString str) :
	text_(std::move(str)),
	idx_(0) {
}

int JassTokenizer::text_size() const {
	return text_.size();
}

JassToken JassTokenizer::parse_comment_block() {
	int stop = idx_;
	if (at(stop) == '/' && at(stop + 1) == '*') {
		stop += 2;
	}

	while (stop + 1 < text_size()) {
		// TODO@Daniel:
		// Handle docstring parameters
		if (at(stop) == '*' && at(stop + 1) == '/') {
			stop++;
			break;
		} else {
			stop++;
		}
	}
	stop++;

	QString value = text_.mid(idx_, stop - idx_);
	JassToken token(value, idx_, stop, TOKEN_COMMENT_BLOCK);

	idx_ = stop;

	return token;
}

JassToken JassTokenizer::parse_string() {
	QString slash_escapes = "\\nt\"";
	QString pipe_escapes = "cnr";

	QList<JassToken> nested_tokens;

	int stop = idx_;
	if (at(stop) == '"') {
		stop++;
	}

	while (stop < text_size()) {
		if (at(stop) == '"') {
			stop++;
			break;
		}

		// Iirc, there are only single character escapes
		bool is_slash_escape = at(stop) == '\\' && slash_escapes.contains(at(stop + 1));
		bool is_pipe_escape = at(stop) == '|' && pipe_escapes.contains(at(stop + 1));
		if (is_pipe_escape || is_slash_escape) {
			QString value = text_.mid(stop, stop + 2);
			JassToken token(value, stop, stop + 2, TOKEN_ESCAPE_SEQUENCE);
			nested_tokens.append(token);

			stop++;
		}
		stop++;
	}

	QString value = text_.mid(idx_, stop - idx_);
	JassToken token(value, idx_, stop, TOKEN_STRING, nested_tokens);

	idx_ = stop;

	return token;
}

JassToken JassTokenizer::parse_rawcode() {
	int stop = idx_;
	if (at(stop) == '\'') {
		stop++;
	}

	while (stop < text_size()) {
		// Iirc, there are no escape sequences in rawcodes
		if (at(stop) == '\'') {
			stop++;
			break;
		} else {
			stop++;
		}
	}

	QString value = text_.mid(idx_, stop - idx_);
	JassToken token(value, idx_, stop, TOKEN_RAWCODE);

	idx_ = stop;

	return token;
}

JassToken JassTokenizer::eat_all_of(JassTokenType token_type) {
	JassToken token = next();
	while (token.type() == token_type) {
		token = next();
	}
	return token;
}

JassToken JassTokenizer::eat_until(JassTokenType token_type) {
	JassToken token = next();
	while (token.type() != token_type) {
		token = next();
	}
	return token;
}

JassToken JassTokenizer::eat_comment_blocks() {
	return eat_all_of(TOKEN_COMMENT_BLOCK);
}

JassToken JassTokenizer::next() {
	// Skipping leading whitespace
	while (at(idx_).isSpace() && at(idx_) != '\r' && at(idx_) != '\n') {
		idx_++;
	}

	if (idx_ >= text_size()) {
		return JassToken("", text_size(), text_size(), TOKEN_EOF);
	}

	int stop = idx_ + 1;

	JassTokenType type = TOKEN_OTHER;

	QList<JassToken> nested_tokens;

	switch (at(idx_).toLatin1()) {
		case '/':
			if (idx_ + 1 >= text_size()) {
				break;
			}

			switch (at(idx_ + 1).toLatin1()) {
				case '/':
					// Technically, changing stop here isn't needed but keeps it somewhat consistent
					if (at(idx_ + 2) == '!') {
						type = TOKEN_PREPROCESSOR_COMMENT;
						stop = idx_ + 3;
					} else {
						type = TOKEN_COMMENT_LINE;
						stop = idx_ + 2;
					}

					while (at(stop) != '\r' && at(stop) != '\n') {
						stop++;
					}
					break;
				case '*':
					return parse_comment_block();
			}
			break;
		case '"':
			return parse_string();
		case '\'':
			return parse_rawcode();
		case '\n':
			type = TOKEN_NEWLINE;
			stop = idx_ + 1;
			break;
		case '\r':
			type = TOKEN_NEWLINE;
			if (at(idx_ + 1) == '\n') {
				stop = idx_ + 2;
			} else {
				stop = idx_ + 1;
			}
			break;
		case ',':
		case '.':
		case '[':
		case ']':
		case '(':
		case ')':
			type = TOKEN_OPERATOR;
			stop = idx_ + 1;
			break;
		default:
			// TODO@Daniel:
			// Move these out since they will be needed elsewhere as well
			if (at(idx_).isLetter() || at(idx_) == '_') {
				type = TOKEN_IDENTIFIER;
				while (at(stop).isLetter() || at(stop).isDigit() || at(stop) == '_') {
					stop++;
				}
			} else if (at(idx_).isDigit()) {
				type = TOKEN_NUMBER;
				while (at(stop).isDigit()) {
					stop++;
				}
			}
			break;
	}

	QString value = text_.mid(idx_, stop - idx_);

	JassToken token(value, idx_, stop, type, nested_tokens);
	idx_ = stop;

	return token;
}

```

`src/trigger_editor/jass_tokenizer.h`:

```h
#pragma once

#pragma warning(push, 0)
#include <QChar>
#include <QString>
#include <QList>
#pragma warning(pop) 

enum JassTokenType {
	TOKEN_NUMBER,
	TOKEN_IDENTIFIER,
	TOKEN_COMMENT_LINE,
	TOKEN_PREPROCESSOR_COMMENT,
	TOKEN_NEWLINE,
	TOKEN_COMMENT_BLOCK,
	// TODO@Daniel:
	// Ideally, operators should each have their own token type
	TOKEN_OPERATOR,
	TOKEN_STRING,
	TOKEN_RAWCODE,
	TOKEN_ESCAPE_SEQUENCE,
	TOKEN_WHITESPACE,
	TOKEN_OTHER,
	TOKEN_EOF
};

class JassToken {
private:
	QString value_;
	int start_;
	int stop_;

	JassTokenType type_;

	// For escape sequences in strings, parameters in docstring and similar
	QList<JassToken> nested_tokens_;

public:
	JassToken(QString value, int start, int stop, JassTokenType type, QList<JassToken> nested_tokens = QList<JassToken>());

	QString const& value() const;

	int start() const;
	int stop() const;

	JassTokenType type() const;

	QList<JassToken> const& nested_tokens() const;

	int length() const;
};

// TODO@Daniel:
// Add iterator for convenience
class JassTokenizer {
private:
	// TODO@Daniel:
	// Support multiple 'files' instead of just one
	// Will help with block comments across files and such
	QString text_;

	int idx_;

	QChar at(int idx) const;

public:
	JassTokenizer(QString str);

	int text_size() const;

	JassToken parse_comment_block();
	JassToken parse_string();
	JassToken parse_rawcode();

	JassToken eat_all_of(JassTokenType token_type);
	JassToken eat_until(JassTokenType token_type);
	JassToken eat_comment_blocks();

	JassToken next();
};
```

`src/trigger_editor/search_window.cpp`:

```cpp
#include "search_window.h"

#include <QLayout>
#include <QFrame>

SearchWindow::SearchWindow(QWidget* parent) : QFrame(parent) {
	setAttribute(Qt::WA_DeleteOnClose);

	setMinimumSize(182, 53);
	setAutoFillBackground(true);
	setFrameStyle(QFrame::NoFrame);

	// Top row
	edit->setPlaceholderText("Find text");

	QPushButton* close_button = new QPushButton(this);
	close_button->setText("X");
	close_button->setMaximumSize(23, 23);

	QHBoxLayout* top_row = new QHBoxLayout;
	top_row->addWidget(edit);
	top_row->addWidget(close_button);

	// Bottom row
	case_sensitive->setCheckable(true);
	case_sensitive->setMaximumSize(23, 23);
	match_whole_word->setCheckable(true);
	match_whole_word->setMaximumSize(23, 23);
	regular_expression->setCheckable(true);
	regular_expression->setMaximumSize(23, 23);

	QHBoxLayout* bottom_row = new QHBoxLayout;
	bottom_row->addWidget(case_sensitive);
	bottom_row->addWidget(match_whole_word);
	bottom_row->addWidget(regular_expression);
	bottom_row->addStretch();

	QVBoxLayout* layout = new QVBoxLayout;
	layout->addLayout(top_row);
	layout->addLayout(bottom_row);
	layout->setSpacing(3);

	setLayout(layout);
	show();

	connect(edit, &QLineEdit::textChanged, this, &SearchWindow::text_changed);
	connect(close_button, &QPushButton::clicked, this, &QWidget::close);
}
```

`src/trigger_editor/search_window.h`:

```h
#include <string>

#include <QFrame>
#include <QPushButton>
#include <QLineEdit>

class SearchWindow : public QFrame {
	Q_OBJECT

	QLineEdit* edit = new QLineEdit;
	QPushButton* case_sensitive = new QPushButton;
	QPushButton* match_whole_word = new QPushButton;
	QPushButton* regular_expression = new QPushButton;

public:
	SearchWindow(QWidget* parent = nullptr);

signals:
	void text_changed(QString text);
	void previous();
	void next();
};
```

`src/trigger_editor/trigger_editor.cpp`:

```cpp
#include "trigger_editor.h"

#include <QPlainTextEdit>
#include <QSettings>
#include <QSplitter>
#include <QMessageBox>
#include <QMap>
#include <QPainter>
#include <QLineEdit>
#include <QPushButton>
#include <QFileIconProvider>
#include <QTreeWidget>

#include "HiveWE.h"
#include "jass_editor.h"
#include "search_window.h"
#include "variable_editor.h"
#include "trigger_model.h"

import std;
import Utilities;
import Triggers;
import Globals;
import OpenGLUtilities;
import MapGlobal;

constexpr int map_header_id = 0;

TriggerEditor::TriggerEditor(QWidget* parent) : QMainWindow(parent) {
	ui.setupUi(this);
	setAttribute(Qt::WA_DeleteOnClose);

	model = new TreeModel(explorer);
	explorer->setModel(model);
	explorer->expandToDepth(1);

	compile_output->setReadOnly(true);
	dock_manager = new ads::CDockManager;
	dock_manager->setStyleSheet("");
	setCentralWidget(dock_manager);

	QLabel* image = new QLabel();
	image->setPixmap(QPixmap("data/icons/trigger_editor/background.png"));
	image->setAlignment(Qt::AlignCenter);

	ads::CDockWidget* centraldock_widget = new ads::CDockWidget(dock_manager, "");
	centraldock_widget->setWidget(image);
	centraldock_widget->setObjectName("-1");
	centraldock_widget->setFeature(ads::CDockWidget::NoTab, true);
	dock_area = dock_manager->setCentralWidget(centraldock_widget);

	ads::CDockWidget* explorer_widget = new ads::CDockWidget(dock_manager, "Trigger Explorer");
	explorer_widget->setObjectName("-1");
	explorer_widget->setFeature(ads::CDockWidget::DockWidgetClosable, false);
	explorer_widget->setWidget(explorer);
	dock_manager->addDockWidget(ads::LeftDockWidgetArea, explorer_widget, dock_area);

	ads::CDockWidget* output_widget = new ads::CDockWidget(dock_manager, "Output");
	output_widget->setObjectName("-11");
	output_widget->setFeature(ads::CDockWidget::DockWidgetClosable, false);
	output_widget->setWidget(compile_output);
	dock_manager->addDockWidget(ads::BottomDockWidgetArea, output_widget, dock_area);

	show();

	QFileIconProvider icons;
	gui_icon = icons.icon(QFileIconProvider::File);
	script_icon = texture_to_icon(world_edit_data.data("WorldEditArt", "SEIcon_TriggerScript") + ".dds");
	script_icon_disabled = texture_to_icon(world_edit_data.data("WorldEditArt", "SEIcon_TriggerScriptDisable") + ".dds");
	variable_icon = texture_to_icon(world_edit_data.data("WorldEditArt", "SEIcon_TriggerGlobalVariable") + ".dds");
	comment_icon = texture_to_icon(world_edit_data.data("WorldEditArt", "SEIcon_TriggerComment") + ".dds");

	event_icon = texture_to_icon(string_replaced(world_edit_data.data("WorldEditArt", "SEIcon_Event"), "blp", "dds"));
	condition_icon = texture_to_icon(string_replaced(world_edit_data.data("WorldEditArt", "SEIcon_Condition"), "blp", "dds"));
	action_icon = texture_to_icon(string_replaced(world_edit_data.data("WorldEditArt", "SEIcon_Action"), "blp", "dds"));

	ui.actionCreateCategory->setIcon(icons.icon(QFileIconProvider::Folder));
	ui.actionCreateGuiTrigger->setIcon(gui_icon);
	ui.actionCreateJassTrigger->setIcon(script_icon);
	ui.actionCreateVariable->setIcon(variable_icon);
	ui.actionCreateComment->setIcon(comment_icon);

	connect(ui.actionGenerateScript, &QAction::triggered, [&]() {
		save_changes();

		ScriptMode mode = ScriptMode::jass;
		if (map->info.lua) {
			mode = ScriptMode::lua;
		}
		const auto result =
			map->triggers
				.generate_map_script(map->terrain, map->units, map->doodads, map->info, map->sounds, map->regions, map->cameras, mode);

		if (!result) {
			compile_output->setPlainText(QString::fromStdString(result.error()));
		}
	});
	connect(ui.actionCreateCategory, &QAction::triggered, explorer, &TriggerExplorer::createCategory);
	connect(ui.actionCreateGuiTrigger, &QAction::triggered, explorer, &TriggerExplorer::createGuiTrigger);
	connect(ui.actionCreateJassTrigger, &QAction::triggered, explorer, &TriggerExplorer::createJassTrigger);
	connect(ui.actionCreateVariable, &QAction::triggered, explorer, &TriggerExplorer::createVariable);
	connect(ui.actionCreateComment, &QAction::triggered, explorer, &TriggerExplorer::createComment);

	connect(explorer, &QTreeView::doubleClicked, this, &TriggerEditor::item_clicked);
	connect(explorer, &TriggerExplorer::itemAboutToBeDeleted, [&](TreeItem* item) {
		if (auto found = dock_manager->findDockWidget(QString::number(item->id)); found) {
			found->closeDockWidget();
		}
	});
	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), this), &QShortcut::activated, this, &TriggerEditor::focus_search_window);
}

TriggerEditor::~TriggerEditor() {
	save_changes();
}

void TriggerEditor::focus_search_window() {
	SearchWindow* search = new SearchWindow(this);
	search->move(500, 10);

	connect(search, &SearchWindow::text_changed, [&](QString text) {
		for (const auto& tab : dock_manager->dockWidgetsMap()) {
			int trigger_id = tab->objectName().toInt();
			if (trigger_id < 0) {
				continue;
			}

			auto editor = tab->findChild<JassEditor*>("jass_editor");
			if (editor) {
				editor->highlight_text(text.toStdString());
			}
		}
	});
}

void TriggerEditor::item_clicked(const QModelIndex& index) {
	const TreeItem* item = static_cast<TreeItem*>(index.internalPointer());
	if (item->type == Classifier::category) {
		return;
	}

	if (auto found = dock_manager->findDockWidget(QString::number(item->id)); found) {
		found->dockAreaWidget()->setCurrentDockWidget(found);
		found->setFocus();
		found->raise();
		return;
	}

	ads::CDockWidget* dock_tab = new ads::CDockWidget(dock_manager, "");
	dock_tab->setFeature(ads::CDockWidget::DockWidgetFeature::DockWidgetDeleteOnClose, true);

	if (item->type == Classifier::gui || item->type == Classifier::script) {
		QSettings settings;
		bool comments_enabled = settings.value("comments").toString() != "False";

		QSplitter* splitter = new QSplitter(Qt::Orientation::Vertical);

		if (item->id == 0) { // Map header
			JassEditor* jass_editor = new JassEditor;
			jass_editor->setObjectName("jass_editor");
			jass_editor->setText(QString::fromStdString(map->triggers.global_jass));

			dock_tab->setWindowTitle("Map Header");
			dock_tab->setObjectName("0");
			dock_tab->setIcon(model->data(index, Qt::DecorationRole).value<QIcon>());

			if (comments_enabled) {
				QPlainTextEdit* comments_editor = new QPlainTextEdit;
				comments_editor->setObjectName("comments");
				comments_editor->setPlaceholderText("Optional comments here");
				splitter->addWidget(comments_editor);
				comments_editor->setPlainText(QString::fromStdString(map->triggers.global_jass_comment));
			}

			splitter->addWidget(jass_editor);
		} else {
			const Trigger& trigger = *std::ranges::find_if(map->triggers.triggers, [item](const Trigger& trigger) {
				return trigger.id == item->id;
			});

			if (comments_enabled) {
				QPlainTextEdit* comments_editor = new QPlainTextEdit;
				comments_editor->setObjectName("comments");
				comments_editor->setPlaceholderText("Optional comments here");
				comments_editor->setPlainText(QString::fromStdString(trigger.description));
				splitter->addWidget(comments_editor);
			}

			dock_tab->setWindowTitle(QString::fromStdString(trigger.name));
			dock_tab->setObjectName(QString::number(trigger.id));
			dock_tab->setIcon(model->data(index, Qt::DecorationRole).value<QIcon>());

			if (!trigger.is_comment) {
				if (trigger.is_script) {
					JassEditor* edit = new JassEditor;
					edit->setObjectName("jass_editor");
					splitter->addWidget(edit);
					edit->setText(QString::fromStdString(trigger.custom_text));
				} else {
					QTreeWidget* edit = new QTreeWidget;
					edit->setHeaderHidden(true);
					edit->setUniformRowHeights(true);
					splitter->addWidget(edit);
					show_gui_trigger(edit, trigger);
					edit->expandAll();
				}
			}
		}

		splitter->setStretchFactor(0, 1);
		splitter->setStretchFactor(1, 7);
		dock_tab->setWidget(splitter);
	} else if (item->type == Classifier::variable) {
		TriggerVariable& variable =
			*std::ranges::find_if(map->triggers.variables, [item](const TriggerVariable& i) {
				return i.id == item->id;
			});

		dock_tab->setWindowTitle(QString::fromStdString(variable.name));
		dock_tab->setObjectName(QString::number(variable.id));
		VariableEditor* edit = new VariableEditor(variable);
		edit->setObjectName("var_editor");
		dock_tab->setWidget(edit);
	} else if (item->type == Classifier::comment) {
		Trigger& trigger = *std::ranges::find_if(map->triggers.triggers, [item](const Trigger& trigger) {
			return trigger.id == item->id;
		});

		QPlainTextEdit* comments_editor = new QPlainTextEdit;
		comments_editor->setObjectName("comments");
		comments_editor->setPlaceholderText("Optional comments here");
		comments_editor->setPlainText(QString::fromStdString(trigger.description));

		dock_tab->setWindowTitle(QString::fromStdString(trigger.name));
		dock_tab->setObjectName(QString::number(trigger.id));
		dock_tab->setIcon(model->data(index, Qt::DecorationRole).value<QIcon>());
		dock_tab->setWidget(comments_editor);
	}

	connect(dock_tab, &ads::CDockWidget::closeRequested, [&, dock_tab]() {
		save_tab(dock_tab);
	});

	dock_manager->addDockWidget(ads::CenterDockWidgetArea, dock_tab, dock_area);
}

void TriggerEditor::save_tab(ads::CDockWidget* tab) {
	const int trigger_id = tab->objectName().toInt();

	if (trigger_id < 0) {
		return;
	}

	// Comments
	auto comments = tab->findChild<QPlainTextEdit*>("comments");
	if (comments) {
		if (trigger_id == map_header_id) {
			map->triggers.global_jass_comment = comments->toPlainText().toStdString();
		} else {
			Trigger& trigger =
				*std::ranges::find_if(map->triggers.triggers, [trigger_id](const Trigger& trigger) {
					return trigger.id == trigger_id;
				});

			trigger.description = comments->toPlainText().toStdString();
		}
	}

	// Jass editor
	auto jass_editor = tab->findChild<JassEditor*>("jass_editor");
	if (jass_editor) {
		if (trigger_id == map_header_id) {
			map->triggers.global_jass = jass_editor->text().toStdString();
		} else {
			Trigger& trigger =
				*std::ranges::find_if(map->triggers.triggers, [trigger_id](const Trigger& trigger) {
					return trigger.id == trigger_id;
				});

			trigger.custom_text = jass_editor->text().toStdString();
		}
	}

	// Variable editor
	auto var_editor = tab->findChild<VariableEditor*>("var_editor");
	if (var_editor) {
		TriggerVariable& variable =
			*std::ranges::find_if(map->triggers.variables, [trigger_id](const TriggerVariable& i) {
				return i.id == trigger_id;
			});

		variable.name = var_editor->ui.name->text().toStdString();
		variable.type = var_editor->ui.type->text().toStdString();
		variable.is_array = var_editor->ui.array->isChecked();
		variable.array_size = var_editor->ui.array_size->value();
		variable.is_initialized = !var_editor->ui.value->text().isEmpty();
		variable.initial_value = var_editor->ui.value->text().toStdString();
	}
}

void TriggerEditor::show_gui_trigger(QTreeWidget* edit, const Trigger& trigger) {
	QTreeWidgetItem* events = new QTreeWidgetItem(edit);
	events->setText(0, "Events");
	events->setIcon(0, event_icon);

	QTreeWidgetItem* conditions = new QTreeWidgetItem(edit);
	conditions->setText(0, "Conditions");
	conditions->setIcon(0, condition_icon);

	QTreeWidgetItem* actions = new QTreeWidgetItem(edit);
	actions->setText(0, "Actions");
	actions->setIcon(0, action_icon);

	std::function<void(QTreeWidgetItem*, const ECA&)> recurse = [&](QTreeWidgetItem* parent, const ECA& i) {
		QTreeWidgetItem* eca = new QTreeWidgetItem(parent);
		std::string category;

		std::vector<std::string> string_parameters;

		switch (i.type) {
			case ECA::Type::event:
				string_parameters = map->triggers.trigger_data.whole_data("TriggerEvents", "_" + i.name + "_Parameters");
				category = map->triggers.trigger_data.data("TriggerEvents", "_" + i.name + "_Category");
				break;
			case ECA::Type::condition:
				string_parameters = map->triggers.trigger_data.whole_data("TriggerConditions", "_" + i.name + "_Parameters");
				category = map->triggers.trigger_data.data("TriggerConditions", "_" + i.name + "_Category");
				break;
			case ECA::Type::action:
				string_parameters = map->triggers.trigger_data.whole_data("TriggerActions", "_" + i.name + "_Parameters");
				category = map->triggers.trigger_data.data("TriggerActions", "_" + i.name + "_Category");
				break;
		}

		eca->setText(0, QString::fromStdString(get_parameters_names(string_parameters, i.parameters)));

		if (auto found = trigger_icons.find(category); found == trigger_icons.end()) {
			const std::string icon_path = map->triggers.trigger_data.data("TriggerCategories", category, 1);
			const std::string final_path = icon_path + ".dds";
			const QIcon icon = texture_to_icon(final_path);
			trigger_icons[category] = icon;
			eca->setIcon(0, icon);
		} else {
			eca->setIcon(0, found->second);
		}

		QTreeWidgetItem* sub1 = eca;
		QTreeWidgetItem* sub2 = eca;
		QTreeWidgetItem* sub3 = eca;

		if (i.name == "AndMultiple" || i.name == "OrMultiple") {
			sub1 = new QTreeWidgetItem(eca, {"Conditions"});
			sub1->setIcon(0, condition_icon);
		} else if (i.name == "IfThenElseMultiple") {
			sub1 = new QTreeWidgetItem(eca, {"If - Conditions"});
			sub1->setIcon(0, condition_icon);
			sub2 = new QTreeWidgetItem(eca, {"Then - Actions"});
			sub2->setIcon(0, action_icon);
			sub3 = new QTreeWidgetItem(eca, {"Else - Actions"});
			sub3->setIcon(0, action_icon);
		} else if (i.name == "ForLoopAMultiple" || i.name == "ForLoopBMultiple" || i.name == "ForLoopVarMultiple" || i.name == "ForLoopA"
				   || i.name == "ForLoopB" || i.name == "ForLoopVar" || i.name == "ForForceMultiple" || i.name == "ForGroupMultiple") {
			sub1 = new QTreeWidgetItem(eca, {"Loop - Actions"});
			sub1->setIcon(0, action_icon);
		}

		for (const auto& j : i.ecas) {
			if (j.group == 0) {
				recurse(sub1, j);
			} else if (j.group == 1) {
				recurse(sub2, j);
			} else if (j.group == 2) {
				recurse(sub3, j);
			}
		}
	};

	for (const auto& i : trigger.ecas) {
		if (i.type == ECA::Type::event) {
			recurse(events, i);
		} else if (i.type == ECA::Type::condition) {
			recurse(conditions, i);
		} else if (i.type == ECA::Type::action) {
			recurse(actions, i);
		}
	}
}

std::string TriggerEditor::get_parameters_names(
	const std::vector<std::string>& string_parameters,
	const std::vector<TriggerParameter>& parameters
) const {
	std::string result;

	size_t current_parameter = 0;
	for (const auto& i : string_parameters) {
		if (i.empty() || i.front() != '~') {
			result += i;
			continue;
		}
		const TriggerParameter& j = parameters.at(current_parameter);

		if (j.has_sub_parameter) {
			std::vector<std::string> sub_string_parameters;
			switch (j.sub_parameter.type) {
				case ECA::Type::event:
					sub_string_parameters =
						map->triggers.trigger_data.whole_data("TriggerEvents", "_" + j.sub_parameter.name + "_Parameters");
					break;
				case ECA::Type::condition:
					sub_string_parameters =
						map->triggers.trigger_data.whole_data("TriggerConditions", "_" + j.sub_parameter.name + "_Parameters");
					break;
				case ECA::Type::action:
					sub_string_parameters =
						map->triggers.trigger_data.whole_data("TriggerActions", "_" + j.sub_parameter.name + "_Parameters");
					break;
				case ECA::Type::call:
					sub_string_parameters =
						map->triggers.trigger_data.whole_data("TriggerCalls", "_" + j.sub_parameter.name + "_Parameters");
					break;
			}
			result += "(" + get_parameters_names(sub_string_parameters, j.sub_parameter.parameters) + ")";
		} else {
			switch (j.type) {
				case TriggerParameter::Type::preset:
					result += map->triggers.trigger_data.data("TriggerParams", j.value, 3);
					break;
				case TriggerParameter::Type::string: {
					std::string pre_result;
					if (j.value.size() == 4) {
						if (units_slk.row_headers.contains(j.value)) {
							pre_result = units_slk.data("name", j.value);
						} else if (items_slk.row_headers.contains(j.value)) {
							pre_result = items_slk.data("name", j.value);
						} else {
							pre_result = j.value;
						}
					}

					if (pre_result.starts_with("TRIGSTR")) {
						result += map->trigger_strings.string(pre_result);
					} else if (!pre_result.empty()) {
						result += pre_result;
					} else if (j.value.starts_with("TRIGSTR")) {
						result += map->trigger_strings.string(j.value);
					} else {
						result += j.value;
					}
					break;
				}
				case TriggerParameter::Type::variable: {
					if (j.value.starts_with("gg_unit")) {
						std::string type = j.value.substr(8, 4);
						std::string instance = j.value.substr(13);
						result += units_slk.data("name", type);
						result += " " + instance;
					} else {
						//std::string type = map->triggers.variables[j.value].type;
						//if (type == "unit") {
						//std::cout << "test\n";
						//} else {
						result += j.value;
						//}
					}
					break;
				}
				default:
					result += j.value;
			}
		}
		current_parameter++;
	}

	return result;
}

void TriggerEditor::save_changes() {
	for (const auto& tab : dock_manager->dockWidgetsMap()) {
		save_tab(tab);
	}
}

```

`src/trigger_editor/trigger_editor.h`:

```h
#pragma once

#include "ui_trigger_editor.h"

#include <QTreeView>
#include <QTreeWidget>
#include <QPlainTextEdit>
#include <QKeyEvent>

#include <vector>
#include <string>
#include <unordered_map>

#include "DockManager.h"
#include "DockAreaWidget.h"
#include "trigger_explorer.h"
#include "global_search.h"

import Triggers;

class TriggerEditor : public QMainWindow {
	Q_OBJECT

public:
	explicit TriggerEditor(QWidget* parent = nullptr);
	~TriggerEditor() override;

	void save_changes();
private:
	Ui::TriggerEditor ui;

	ads::CDockManager* dock_manager = nullptr;
	ads::CDockAreaWidget* dock_area = nullptr;

	TriggerExplorer* explorer = new TriggerExplorer;
	TreeModel* model;

	QPlainTextEdit* compile_output = new QPlainTextEdit;

	QIcon folder_icon;
	QIcon gui_icon;
	QIcon gui_icon_disabled;
	QIcon script_icon;
	QIcon script_icon_disabled;
	QIcon variable_icon;
	QIcon comment_icon;

	QIcon event_icon;
	QIcon condition_icon;
	QIcon action_icon;

	std::unordered_map<std::string, QIcon> trigger_icons;

	void focus_search_window();
	void save_tab(ads::CDockWidget* tab);

	void item_clicked(const QModelIndex& index);
	void show_gui_trigger(QTreeWidget* edit, const Trigger& trigger);

	std::string get_parameters_names(const std::vector<std::string>& string_parameters, const std::vector<TriggerParameter>& parameters) const;

	QElapsedTimer double_shift_timer;

	void keyPressEvent(QKeyEvent* event) override {
		if (event->key() == Qt::Key_Shift && !event->isAutoRepeat()) {
			if (double_shift_timer.isValid() && double_shift_timer.elapsed() < 400) {

				GlobalSearchWidget search_widget = new GlobalSearchWidget(this);
				double_shift_timer.invalidate();
			} else {
				double_shift_timer.start();
			}
		}
		QMainWindow::keyPressEvent(event);
	}
};
```

`src/trigger_editor/trigger_editor.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TriggerEditor</class>
 <widget class="QMainWindow" name="TriggerEditor">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1280</width>
    <height>720</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Trigger Editor</string>
  </property>
  <widget class="QWidget" name="centralwidget"/>
  <widget class="QToolBar" name="toolBar">
   <property name="windowTitle">
    <string>toolBar</string>
   </property>
   <property name="iconSize">
    <size>
     <width>16</width>
     <height>16</height>
    </size>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
   <addaction name="actionGenerateScript"/>
   <addaction name="separator"/>
   <addaction name="actionCreateCategory"/>
   <addaction name="actionCreateGuiTrigger"/>
   <addaction name="actionCreateJassTrigger"/>
   <addaction name="actionCreateVariable"/>
   <addaction name="actionCreateComment"/>
  </widget>
  <action name="actionGenerateScript">
   <property name="icon">
    <iconset>
     <normaloff>Data/Icons/Ribbon/triggereditor32x32.png</normaloff>Data/Icons/Ribbon/triggereditor32x32.png</iconset>
   </property>
   <property name="text">
    <string>GenerateScript</string>
   </property>
   <property name="toolTip">
    <string>Generate map script and check for errors</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+F10</string>
   </property>
  </action>
  <action name="actionCreateGuiTrigger">
   <property name="text">
    <string>Create Gui Trigger</string>
   </property>
   <property name="toolTip">
    <string>Creates a GUI trigger</string>
   </property>
  </action>
  <action name="actionCreateJassTrigger">
   <property name="text">
    <string>Create Jass Trigger</string>
   </property>
   <property name="toolTip">
    <string>Creates a Jass Trigger</string>
   </property>
  </action>
  <action name="actionCreateComment">
   <property name="text">
    <string>Create Comment</string>
   </property>
   <property name="toolTip">
    <string>Creates a Comment</string>
   </property>
  </action>
  <action name="actionCreateVariable">
   <property name="text">
    <string>actionCreateVariable</string>
   </property>
   <property name="toolTip">
    <string>Create a global variable</string>
   </property>
  </action>
  <action name="actionCreateCategory">
   <property name="text">
    <string>Create Category</string>
   </property>
   <property name="toolTip">
    <string>Create a category</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`src/trigger_editor/trigger_explorer.cpp`:

```cpp
#include <functional>

#include <QStringList>
#include <QFileIconProvider>
#include <QPainter>
#include <QMessageBox>
#include <QStack>
#include <set>

#include "trigger_model.h"

#include "trigger_explorer.h"
#include "HiveWE.h"

import Triggers;
import Utilities;
import MapGlobal;
import OpenGLUtilities;
import Globals;

constexpr int map_header_id = 0;

TriggerExplorer::TriggerExplorer(QWidget* parent) : QTreeView(parent) {
	setSelectionMode(QAbstractItemView::SingleSelection);
	setSelectionBehavior(QAbstractItemView::SelectRows);
	setContextMenuPolicy(Qt::CustomContextMenu);
	setUniformRowHeights(true);
	setHeaderHidden(true);
	setEditTriggers(QAbstractItemView::EditTrigger::EditKeyPressed);
	setDragEnabled(true);
	setDragDropMode(QAbstractItemView::InternalMove);
	setAcceptDrops(true);
	setDropIndicatorShown(true);
	setDefaultDropAction(Qt::MoveAction);

	contextMenu->addAction(addCategory);
	contextMenu->addAction(addGuiTrigger);
	contextMenu->addAction(addJassTrigger);
	contextMenu->addAction(addComment);
	contextMenu->addAction(deleteRow);
	contextMenu->addAction(renameRow);
	contextMenu->addAction(isEnabled);
	contextMenu->addAction(runOnInitialization);
	contextMenu->addAction(initiallyOn);
	isEnabled->setCheckable(true);
	runOnInitialization->setCheckable(true);
	initiallyOn->setCheckable(true);

	addCategory->setText("Add Category");
	addGuiTrigger->setText("Add GUI Trigger");
	addJassTrigger->setText("Add Jass Trigger");
	addComment->setText("Add Comment");
	deleteRow->setText("Delete");
	renameRow->setText("Rename");
	isEnabled->setText("Enabled");
	runOnInitialization->setText("Run on Map Initialization");
	initiallyOn->setText("Initially On");

	connect(this, &QTreeView::customContextMenuRequested, [&](const QPoint& point) {
		const int count = selectionModel()->selectedRows().count();

		if (count == 0) {
			selectionModel()->select(model()->index(0, 0), QItemSelectionModel::SelectionFlag::ClearAndSelect);
		}

		const TreeItem* item = static_cast<TreeItem*>(selectionModel()->selectedRows().front().internalPointer());

		addCategory->setVisible(item->id == 0 || item->type == Classifier::category);
		addGuiTrigger->setVisible(item->type == Classifier::category);
		addJassTrigger->setVisible(item->type == Classifier::category);
		addComment->setVisible(item->type == Classifier::category);
		renameRow->setVisible(item->id != 0);
		deleteRow->setVisible(item->id != 0);

		isEnabled->setVisible(item->id != 0  && (item->type == Classifier::gui || item->type == Classifier::script));
		isEnabled->setChecked(item->enabled);
		initiallyOn->setVisible(item->type == Classifier::gui);
		initiallyOn->setChecked(item->initially_on);

		runOnInitialization->setVisible(false);
		if (item->type == Classifier::script || item->type == Classifier::gui) {
			for (int i = 0; i < map->triggers.triggers.size(); i++) {
				Trigger& trigger = map->triggers.triggers[i];
				if (trigger.id == item->id) {
					runOnInitialization->setVisible(item->type == Classifier::gui && trigger.is_script);
					runOnInitialization->setChecked(item->run_on_initialization);
					break;
				}
			}
		}
 
		contextMenu->popup(viewport()->mapToGlobal(point));
	});

	connect(addCategory, &QAction::triggered, this, &TriggerExplorer::createCategory);
	connect(addGuiTrigger, &QAction::triggered, this, &TriggerExplorer::createGuiTrigger);
	connect(addJassTrigger, &QAction::triggered, this, &TriggerExplorer::createJassTrigger);
	connect(addComment, &QAction::triggered, this, &TriggerExplorer::createComment);
	connect(deleteRow, &QAction::triggered, this, &TriggerExplorer::deleteSelection);
	connect(renameRow, &QAction::triggered, this, [&]() {
		const auto index = selectionModel()->selectedRows().front();

		edit(index);
	});
	connect(isEnabled, &QAction::triggered, this, [&](bool checked) {
		const auto index = selectionModel()->selectedRows().front();
		TreeItem* item = static_cast<TreeItem*>(index.internalPointer());

		item->enabled = checked;

		for (int i = 0; i < map->triggers.triggers.size(); i++) {
			Trigger& trigger = map->triggers.triggers[i];
			if (trigger.id == item->id) {
				trigger.is_enabled = checked;
				break;
			}
		}
	});
	connect(runOnInitialization, &QAction::triggered, this, [&](bool checked) {
		const auto index = selectionModel()->selectedRows().front();
		TreeItem* item = static_cast<TreeItem*>(index.internalPointer());

		item->run_on_initialization = checked;

		for (int i = 0; i < map->triggers.triggers.size(); i++) {
			Trigger& trigger = map->triggers.triggers[i];
			if (trigger.id == item->id) {
				trigger.run_on_initialization = checked;
				break;
			}
		}
	});
	connect(initiallyOn, &QAction::triggered, this, [&](bool checked) {
		auto index = selectionModel()->selectedRows().front();
		TreeItem* item = static_cast<TreeItem*>(index.internalPointer());

		item->initially_on = checked;

		for (int i = 0; i < map->triggers.triggers.size(); i++) {
			Trigger& trigger = map->triggers.triggers[i];
			if (trigger.id == item->id) {
				trigger.initially_on = checked;
				break;
			}
		}
	});
}

void TriggerExplorer::createCategory() {
	QModelIndex index;
	if (selectionModel()->selectedRows().empty()) {
		index = model()->index(0, 0);
	} else {
		index = selectionModel()->selectedRows().front();
	}

	TreeItem* parent_item = static_cast<TreeItem*>(index.internalPointer());

	if (parent_item->type != Classifier::category && parent_item->id != map_header_id) {
		parent_item = parent_item->parent;
		index = index.parent();
	}

	TriggerCategory category;
	category.name = "New Category";
	category.id = ++Trigger::next_id;
	category.parent_id = parent_item->id;
	map->triggers.categories.push_back(category);

	dynamic_cast<TreeModel*>(model())->insertItem(index, Classifier::category, category.id);
	expand(index);


	selectionModel()->setCurrentIndex(index.sibling(parent_item->children.size() - 1, 0), QItemSelectionModel::SelectionFlag::ClearAndSelect);
}

void TriggerExplorer::createJassTrigger() {
	QModelIndex index;
	if (selectionModel()->selectedRows().empty()) {
		index = model()->index(0, 0).sibling(0, 0);
	} else {
		index = selectionModel()->selectedRows().front();
	}

	TreeItem* parent_item = static_cast<TreeItem*>(index.internalPointer());

	// Select a category
	if (parent_item->id == map_header_id) {
		parent_item = parent_item->children.front();
		index = index.sibling(0, 0);
	}

	// Select a category
	if (parent_item->type != Classifier::category) {
		parent_item = parent_item->parent;
		index = index.parent();
	}

	Trigger trigger;
	trigger.classifier = Classifier::script;
	trigger.name = "New Trigger";
	trigger.id = ++Trigger::next_id;
	trigger.is_script = true;
	trigger.parent_id = parent_item->id;
	map->triggers.triggers.push_back(trigger);
	
	dynamic_cast<TreeModel*>(model())->insertItem(index, trigger.classifier, trigger.id);
	expand(index);
	selectionModel()->setCurrentIndex(index.sibling(parent_item->children.size() - 1, 0), QItemSelectionModel::SelectionFlag::ClearAndSelect);
}

void TriggerExplorer::createGuiTrigger() {
	QModelIndex index;
	if (selectionModel()->selectedRows().empty()) {
		index = model()->index(0, 0).sibling(0, 0);
	} else {
		index = selectionModel()->selectedRows().front();
	}

	TreeItem* parent_item = static_cast<TreeItem*>(index.internalPointer());

	if (parent_item->id == map_header_id) {
		parent_item = parent_item->children.front();
		index = index.sibling(0, 0);
	}

	// Select a category
	if (parent_item->type != Classifier::category) {
		parent_item = parent_item->parent;
		index = index.parent();
	}

	Trigger trigger;
	trigger.classifier = Classifier::gui;
	trigger.name = "New Trigger";
	trigger.id = ++Trigger::next_id;
	trigger.parent_id = parent_item->id;
	map->triggers.triggers.push_back(trigger);

	dynamic_cast<TreeModel*>(model())->insertItem(index, trigger.classifier, trigger.id);
	expand(index);
	selectionModel()->setCurrentIndex(index.sibling(parent_item->children.size() - 1, 0), QItemSelectionModel::SelectionFlag::ClearAndSelect);
}

void TriggerExplorer::createVariable() {
	QModelIndex index;
	if (selectionModel()->selectedRows().empty()) {
		index = model()->index(0, 0).sibling(0, 0);
	} else {
		index = selectionModel()->selectedRows().front();
	}

	TreeItem* parent_item = static_cast<TreeItem*>(index.internalPointer());

	if (parent_item->id == map_header_id) {
		parent_item = parent_item->children.front();
		index = index.sibling(0, 0);
	}

	// Select a category
	if (parent_item->type != Classifier::category) {
		parent_item = parent_item->parent;
		index = index.parent();
	}

	TriggerVariable variable;
	variable.id = ++Trigger::next_id;
	variable.name = "NewVariable";
	variable.parent_id = parent_item->id;
	map->triggers.variables.push_back(variable);

	dynamic_cast<TreeModel*>(model())->insertItem(index, Classifier::variable, variable.id);
	expand(index);
	selectionModel()->setCurrentIndex(index.sibling(parent_item->children.size() - 1, 0), QItemSelectionModel::SelectionFlag::ClearAndSelect);
}

void TriggerExplorer::createComment() {
	QModelIndex index;
	if (selectionModel()->selectedRows().empty()) {
		index = model()->index(0, 0).sibling(0, 0);
	} else {
		index = selectionModel()->selectedRows().front();
	}

	TreeItem* parent_item = static_cast<TreeItem*>(index.internalPointer());

	if (parent_item->id == map_header_id) {
		parent_item = parent_item->children.front();
		index = index.sibling(0, 0);
	}

	// Select a category
	if (parent_item->type != Classifier::category) {
		parent_item = parent_item->parent;
		index = index.parent();
	}

	Trigger trigger;
	trigger.classifier = Classifier::comment;
	trigger.name = "New Comment";
	trigger.id = ++Trigger::next_id;
	trigger.parent_id = parent_item->id;
	map->triggers.triggers.push_back(trigger);

	dynamic_cast<TreeModel*>(model())->insertItem(index, trigger.classifier, trigger.id);
	expand(index);
	selectionModel()->setCurrentIndex(index.sibling(parent_item->children.size() - 1, 0), QItemSelectionModel::SelectionFlag::ClearAndSelect);
}

void recursively_delete(TreeItem* parent) {
	for (auto child : parent->children) {
		recursively_delete(child);
	}

	switch (parent->type) {
		case Classifier::comment:
		case Classifier::gui:
		case Classifier::script:
			for (int i = 0; i < map->triggers.triggers.size(); i++) {
				const Trigger& trigger = map->triggers.triggers[i];
				if (trigger.id == parent->id) {
					map->triggers.triggers.erase(map->triggers.triggers.begin() + i);
					break;
				}
			}
			break;
		case Classifier::category:
			for (int i = 0; i < map->triggers.categories.size(); i++) {
				const TriggerCategory& category = map->triggers.categories[i];
				if (category.id == parent->id) {
					map->triggers.categories.erase(map->triggers.categories.begin() + i);
					break;
				}
			}
			break;
		case Classifier::variable:
			for (int i = 0; i < map->triggers.categories.size(); i++) {
				const TriggerVariable& variable = map->triggers.variables[i] ;
				if (variable.id == parent->id) {
					map->triggers.variables.erase(map->triggers.variables.begin() + i);
					break;
				}
			}
			break;
	}
};

void TriggerExplorer::deleteSelection() {
	auto indices = selectionModel()->selectedRows();

	int choice = QMessageBox::question(this, "Delete selected items?", "Are you sure you want to delete these triggers PERMANENTLY?", QMessageBox::Yes | QMessageBox::No, QMessageBox::No);

	if (choice == QMessageBox::Yes) {
		for (const auto index : indices) {
			if (index.isValid()) {
				TreeItem* item = static_cast<TreeItem*>(index.internalPointer());
				recursively_delete(item);
				emit itemAboutToBeDeleted(item);

				dynamic_cast<TreeModel*>(model())->deleteItem(index);
			}
		}
	}
}


```

`src/trigger_editor/trigger_explorer.h`:

```h
#pragma once

#include <QAbstractItemModel>

#include <QVariant>
#include <QVector>
#include <QIcon>
#include <QMenu>
#include <QTreeView>
#include <QMimeData>
#include "trigger_model.h"

import Triggers;

class TriggerExplorer : public QTreeView {
	Q_OBJECT

	QMenu* contextMenu = new QMenu(this);
	QAction* addCategory = new QAction;
	QAction* addGuiTrigger = new QAction;
	QAction* addJassTrigger = new QAction;
	QAction* addComment = new QAction;
	QAction* deleteRow = new QAction;
	QAction* renameRow = new QAction;
	QAction* isEnabled = new QAction;
	QAction* runOnInitialization = new QAction;
	QAction* initiallyOn = new QAction;

public:
	explicit TriggerExplorer(QWidget* parent = nullptr);

	void createCategory();
	void createJassTrigger();
	void createGuiTrigger();
	void createVariable();
	void createComment();
	void deleteSelection();

signals:
	void itemAboutToBeDeleted(TreeItem* item);
};
```

`src/trigger_editor/trigger_model.cpp`:

```cpp
#include <trigger_model.h>

#include <QStringList>
#include <QFileIconProvider>
#include <QPainter>
#include <QMessageBox>
#include <QStack>
#include <set>

import MapGlobal;
import OpenGLUtilities;
import Globals;

constexpr int map_header_id = 0;

TreeModel::TreeModel(QObject* parent) : QAbstractItemModel(parent) {
	rootItem = new TreeItem();

	TreeItem* map_header = new TreeItem(rootItem);
	map_header->id = 0;
	map_header->type = Classifier::script;
	folders[0] = map_header;

	for (const auto& i : map->triggers.categories) {
		if (i.parent_id == -1) {
			continue;
		}

		TreeItem* item = new TreeItem(folders[i.parent_id]);
		item->id = i.id;
		item->type = Classifier::category;
		folders[i.id] = item;
	}

	for (auto& i : map->triggers.triggers) {
		TreeItem* item = new TreeItem(folders[i.parent_id]);
		item->id = i.id;
		item->type = i.classifier;
		item->enabled = i.is_enabled;
		item->initially_on = i.initially_on;
		item->run_on_initialization = i.run_on_initialization;
	}

	for (const auto& i : map->triggers.variables) {
		TreeItem* item = new TreeItem(folders[i.parent_id]);
		item->id = i.id;
		item->type = Classifier::variable;
	}

	QFileIconProvider icons;
	folder_icon = icons.icon(QFileIconProvider::Folder);
	gui_icon = icons.icon(QFileIconProvider::File);

	{
		auto pix = gui_icon.pixmap({16, 16});
		QPainter painter(&pix);
		painter.setPen(QPen(QBrush(Qt::red), 2));
		painter.drawLine(4, 4, 12, 12);
		painter.drawLine(12, 4, 4, 12);
		painter.end();

		gui_icon_disabled = QIcon(pix);
	}

	script_icon = texture_to_icon(world_edit_data.data("WorldEditArt", "SEIcon_TriggerScript") + ".dds");
	script_icon_disabled = texture_to_icon(world_edit_data.data("WorldEditArt", "SEIcon_TriggerScriptDisable") + ".dds");
	variable_icon = texture_to_icon(world_edit_data.data("WorldEditArt", "SEIcon_TriggerGlobalVariable") + ".dds");
	comment_icon = texture_to_icon(world_edit_data.data("WorldEditArt", "SEIcon_TriggerComment") + ".dds");
}

TreeModel::~TreeModel() {
	delete rootItem;
}

int TreeModel::columnCount(const QModelIndex& parent) const {
	return 1;
}

void TreeModel::insertItem(const QModelIndex& parent, Classifier classifier, int id) {
	TreeItem* parent_item = static_cast<TreeItem*>(parent.internalPointer());
	beginInsertRows(parent, parent_item->children.size(), parent_item->children.size());
	TreeItem* new_item = new TreeItem(parent_item);
	new_item->type = classifier;
	new_item->id = id;
	endInsertRows();
}

void TreeModel::deleteItem(const QModelIndex& item) {
	beginRemoveRows(item.parent(), item.row(), item.row());
	TreeItem* itemm = static_cast<TreeItem*>(item.internalPointer());
	itemm->parent->removeChild(itemm);
	endRemoveRows();
}

bool TreeModel::removeRows(int row, int count, const QModelIndex& parent) {
	puts("remove\n");
	return false;
}

//bool TreeModel::moveRows(const QModelIndex& sourceParent, int sourceRow, int count, const QModelIndex& destinationParent, int destinationChild) {
//	//TreeItem* source_parent = static_cast<TreeItem*>(sourceParent.internalPointer());
//	//TreeItem* destination_parent = static_cast<TreeItem*>(sourceParent.internalPointer());
//
//	//beginMoveRows(sourceParent, sourceRow, sourceRow + count, destinationParent, destinationChild);
//
//	//for (int i = sourceRow; i < sourceRow + count; i++) {
//	//	source_parent->children[i]
//	//}
//
//
//	puts("moves\n");
//	return false;
//
//	//endMoveRows();
//}

bool TreeModel::insertRows(int row, int count, const QModelIndex& parent) {
	puts("insert\n");
	return false;
}

//bool TreeModel::moveRow(const QModelIndex& sourceParent, int sourceRow, const QModelIndex& destinationParent, int destinationChild) {
//	puts("move\n");
//	return false;
//}

QStringList TreeModel::mimeTypes() const {
	return {"yeet"};
}

QMimeData* TreeModel::mimeData(const QModelIndexList& indexes) const {
	QByteArray byteData;
	QDataStream stream(&byteData, QIODevice::WriteOnly);

	for (const QModelIndex& index : indexes) {
		QModelIndex localIndex = index;
		QStack<int> indexParentStack;
		while (localIndex.isValid()) {
			indexParentStack << localIndex.row();
			localIndex = localIndex.parent();
		}

		stream << indexParentStack.size();
		while (!indexParentStack.isEmpty()) {
			stream << indexParentStack.pop();
		}
	}

	QMimeData* result = new QMimeData();
	result->setData("yeet", byteData);
	return result;
}

bool TreeModel::dropMimeData(const QMimeData* data, Qt::DropAction action, int row, int column, const QModelIndex& destinationParent) {
	if (!destinationParent.isValid()) {
		return false;
	}

	QModelIndexList indexes;
	auto mimeData = data->data("yeet");
	QDataStream stream(&mimeData, QIODevice::ReadOnly);

	while (!stream.atEnd()) {
		int childDepth = 0;
		stream >> childDepth;

		QModelIndex currentIndex = {};
		for (int i = 0; i < childDepth; ++i) {
			int row = 0;
			stream >> row;
			currentIndex = index(row, 0, currentIndex);
		}
		indexes << currentIndex;
	}

	QModelIndex destinationParentIndex = destinationParent;
	QModelIndex sourceParent = indexes.front().parent();
	QModelIndex child = indexes.front();

	TreeItem* sourceParentItem = static_cast<TreeItem*>(sourceParent.internalPointer());
	TreeItem* destinationParentItem = static_cast<TreeItem*>(destinationParentIndex.internalPointer());
	TreeItem* childItem = static_cast<TreeItem*>(child.internalPointer());

	if (destinationParentItem->id == map_header_id && childItem->type != Classifier::category) {
		return false;
	}

	if (destinationParentItem->id != map_header_id && destinationParentItem->type != Classifier::category) {
		destinationParentItem = destinationParentItem->parent;
		destinationParentIndex = destinationParentIndex.parent();
	}

	if (sourceParentItem == destinationParentItem) {
		return false;
	}

	beginMoveRows(sourceParent, child.row(), child.row(), destinationParentIndex, destinationParentItem->children.size());
	sourceParentItem->children.removeAll(childItem);
	destinationParentItem->appendChild(childItem);
	childItem->parent = destinationParentItem;

	switch (childItem->type) {
		case Classifier::comment:
		case Classifier::gui:
		case Classifier::script:
			for (int i = 0; i < map->triggers.triggers.size(); i++) {
				Trigger& trigger = map->triggers.triggers[i];
				if (trigger.id == childItem->id) {
					trigger.parent_id = destinationParentItem->id;
					break;
				}
			}
			break;
		case Classifier::category:
			for (int i = 0; i < map->triggers.categories.size(); i++) {
				TriggerCategory& category = map->triggers.categories[i];
				if (category.id == childItem->id) {
					category.parent_id = destinationParentItem->id;
					break;
				}
			}
			break;
		case Classifier::variable:
			for (int i = 0; i < map->triggers.categories.size(); i++) {
				TriggerVariable& variable = map->triggers.variables[i];
				if (variable.id == childItem->id) {
					variable.parent_id = destinationParentItem->id;
					break;
				}
			}
			break;
	}
	endMoveRows();

	return true;
}

QVariant TreeModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return QVariant();
	}

	TreeItem* item = static_cast<TreeItem*>(index.internalPointer());

	switch (role) {
		case Qt::DisplayRole:
		case Qt::EditRole:
			return item->data(index.column());
		case Qt::DecorationRole:
			switch (item->type) {
				case Classifier::category:
					return folder_icon;
				case Classifier::script:
					return item->enabled ? script_icon : script_icon_disabled;
				case Classifier::gui:
					return item->enabled ? gui_icon : gui_icon_disabled;
				case Classifier::variable:
					return variable_icon;
				case Classifier::comment:
					return comment_icon;
			}
		default:
			return QVariant();
	}
}

bool TreeModel::setData(const QModelIndex& index, const QVariant& value, int role) {
	if (!index.isValid()) {
		return false;
	}

	TreeItem* item = static_cast<TreeItem*>(index.internalPointer());
	return item->setData(index, value, role);
}

Qt::ItemFlags TreeModel::flags(const QModelIndex& index) const {
	if (!index.isValid()) {
		return Qt::NoItemFlags;
	}

	TreeItem* item = static_cast<TreeItem*>(index.internalPointer());

	return QAbstractItemModel::flags(index) | Qt::ItemIsEditable
		| ((item->id == map_header_id) ? Qt::ItemFlag::NoItemFlags : Qt::ItemIsDragEnabled) | Qt::ItemIsDropEnabled;
}

Qt::DropActions TreeModel::supportedDropActions() const {
	// return Qt::CopyAction | Qt::MoveAction;
	return Qt::IgnoreAction;

}

QVariant TreeModel::headerData(int section, Qt::Orientation orientation, int role) const {
	if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
		return rootItem->data(section);
	}

	return QVariant();
}

QModelIndex TreeModel::index(int row, int column, const QModelIndex& parent) const {
	if (!hasIndex(row, column, parent)) {
		return QModelIndex();
	}

	TreeItem* parentItem;

	if (!parent.isValid()) {
		parentItem = rootItem;
	} else {
		parentItem = static_cast<TreeItem*>(parent.internalPointer());
	}

	const TreeItem* childItem = parentItem->children.at(row);
	if (childItem) {
		return createIndex(row, column, childItem);
	} else {
		return QModelIndex();
	}
}

QModelIndex TreeModel::parent(const QModelIndex& index) const {
	if (!index.isValid()) {
		return QModelIndex();
	}

	TreeItem* childItem = static_cast<TreeItem*>(index.internalPointer());
	TreeItem* parentItem = childItem->parent;

	if (parentItem == rootItem) {
		return QModelIndex();
	}

	return createIndex(parentItem->row(), 0, parentItem);
}

int TreeModel::rowCount(const QModelIndex& parent) const {
	TreeItem* parentItem;
	if (parent.column() > 0) {
		return 0;
	}

	if (!parent.isValid()) {
		parentItem = rootItem;
	} else {
		parentItem = static_cast<TreeItem*>(parent.internalPointer());
	}

	return parentItem->children.count();
}

TreeItem::TreeItem(TreeItem* parent) : parent(parent) {
	if (parent != nullptr) {
		parent->appendChild(this);
	}
}

TreeItem::~TreeItem() {
	qDeleteAll(children);
}

void TreeItem::appendChild(TreeItem* item) {
	children.append(item);
}

void TreeItem::removeChild(TreeItem* item) {
	children.removeOne(item);
	delete item;
}

QVariant TreeItem::data(int column) const {
	if (column != 0) {
		throw;
	}

	switch (type) {
		case Classifier::comment:
		case Classifier::gui:
		case Classifier::script:
			for (const auto& i : map->triggers.triggers) {
				if (i.id == id) {
					return QString::fromStdString(i.name);
				}
			}
			if (id == 0) {
				return "Map Header";
			}
			break;
		case Classifier::variable:
			for (const auto& i : map->triggers.variables) {
				if (i.id == id) {
					return QString::fromStdString(i.name);
				}
			}
			break;
		case Classifier::category:
			for (const auto& i : map->triggers.categories) {
				if (i.id == id) {
					return QString::fromStdString(i.name);
				}
			}
	}
	return "Not found";
}

bool TreeItem::setData(const QModelIndex& index, const QVariant& value, int role) {
	if (value.toString().isEmpty()) {
		return false;
	}

	switch (type) {
		case Classifier::comment:
		case Classifier::gui:
		case Classifier::script:
			for (auto& i : map->triggers.triggers) {
				if (i.id == id) {
					i.name = value.toString().toStdString();
					return true;
				}
			}
			break;
		case Classifier::variable:
			for (auto& i : map->triggers.variables) {
				if (i.id == id) {
					i.name = value.toString().toStdString();
					return true;
				}
			}
			break;
		case Classifier::category:
			for (auto& i : map->triggers.categories) {
				if (i.id == id) {
					i.name = value.toString().toStdString();
					return true;
				}
			}
			break;
	}
	return false;
}

int TreeItem::row() const {
	if (parent) {
		return parent->children.indexOf(const_cast<TreeItem*>(this));
	}

	return 0;
}

```

`src/trigger_editor/trigger_model.h`:

```h
#pragma once

#include <QAbstractItemModel>

#include <QVariant>
#include <QVector>
#include <QIcon>
#include <QMenu>
#include <QTreeView>
#include <QMimeData>

import Triggers;

class TreeItem {
public:
	explicit TreeItem(TreeItem* parentItem = nullptr);
	~TreeItem();

	void appendChild(TreeItem* child);
	void removeChild(TreeItem* child);

	QVariant data(int column) const;
	bool setData(const QModelIndex& index, const QVariant& value, int role);
	int row() const;

	Classifier type = Classifier::category;
	int id = -1;
	bool enabled = true;
	bool run_on_initialization = false;
	bool initially_on = true;
	QVector<TreeItem*> children;
	TreeItem* parent = nullptr;
private:
};

class TreeModel : public QAbstractItemModel {
	Q_OBJECT

public:
	explicit TreeModel(QObject* parent = nullptr);
	~TreeModel();

	QVariant data(const QModelIndex& index, int role) const override;
	bool setData(const QModelIndex& index, const QVariant& value, int role) override;
	Qt::ItemFlags flags(const QModelIndex& index) const override;
	Qt::DropActions supportedDropActions() const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
	QModelIndex index(int row, int column, const QModelIndex& parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex& index) const override;
	int rowCount(const QModelIndex& parent = QModelIndex()) const override;
	int columnCount(const QModelIndex& parent = QModelIndex()) const override;


	void insertItem(const QModelIndex& parent, Classifier classifier, int id);
	void deleteItem(const QModelIndex& item);

	bool removeRows(int row, int count, const QModelIndex& parent = QModelIndex()) override;
	//bool moveRows(const QModelIndex& sourceParent, int sourceRow, int count, const QModelIndex& destinationParent, int destinationChild) override;
	bool insertRows(int row, int count, const QModelIndex& parent = QModelIndex()) override;
	//bool moveRow(const QModelIndex& sourceParent, int sourceRow, const QModelIndex& destinationParent, int destinationChild);

	QStringList mimeTypes() const override;
	QMimeData* mimeData(const QModelIndexList& indexes) const override;
	bool dropMimeData(const QMimeData* data, Qt::DropAction action, int row, int column, const QModelIndex& parent) override;

private:
	TreeItem* rootItem;

	std::unordered_map<int, TreeItem*> folders;

	QIcon folder_icon;
	QIcon gui_icon;
	QIcon gui_icon_disabled;
	QIcon script_icon;
	QIcon script_icon_disabled;
	QIcon variable_icon;
	QIcon comment_icon;
};
```

`src/trigger_editor/variable_editor.cpp`:

```cpp
#include "variable_editor.h"

VariableEditor::VariableEditor(TriggerVariable& variable) : QWidget() {
	ui.setupUi(this);
	ui.name->setText(QString::fromStdString(variable.name));
	ui.type->setText(QString::fromStdString(variable.type));
	ui.array->setChecked(variable.is_array);
	ui.array_size->setEnabled(variable.is_array);
	ui.array_size->setValue(variable.array_size);
	ui.value->setText(QString::fromStdString(variable.initial_value));
	connect(ui.array, &QCheckBox::checkStateChanged, ui.array_size, &QSpinBox::setEnabled);
}
```

`src/trigger_editor/variable_editor.h`:

```h
#include <qwidget.h>

#include "ui_variable_editor.h"

import Triggers;

class VariableEditor : public QWidget {
	Q_OBJECT
public:
	Ui::VariableEditor ui;
	VariableEditor(TriggerVariable& variable);
};
```

`src/trigger_editor/variable_editor.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>VariableEditor</class>
    <widget class="QWidget" name="VariableEditor" native="true">
     <widget class="QWidget" name="formLayoutWidget">
      <property name="geometry">
       <rect>
        <x>0</x>
        <y>10</y>
        <width>339</width>
        <height>200</height>
       </rect>
      </property>
      <layout class="QFormLayout" name="formLayout">
       <item row="1" column="0">
        <widget class="QLabel" name="label">
         <property name="minimumSize">
          <size>
           <width>0</width>
           <height>0</height>
          </size>
         </property>
         <property name="text">
          <string>Variable Name: </string>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::NoTextInteraction</set>
         </property>
        </widget>
       </item>
       <item row="1" column="1">
        <widget class="QLineEdit" name="name"/>
       </item>
       <item row="2" column="0">
        <widget class="QLabel" name="label_2">
         <property name="minimumSize">
          <size>
           <width>0</width>
           <height>0</height>
          </size>
         </property>
         <property name="text">
          <string>Variable Type: </string>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::NoTextInteraction</set>
         </property>
        </widget>
       </item>
       <item row="2" column="1">
        <widget class="QLineEdit" name="type"/>
       </item>
       <item row="3" column="1">
        <layout class="QHBoxLayout" name="horizontalLayout">
         <item>
          <widget class="QCheckBox" name="array">
           <property name="text">
            <string>Array</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLabel" name="label_3">
           <property name="enabled">
            <bool>false</bool>
           </property>
           <property name="maximumSize">
            <size>
             <width>16777215</width>
             <height>16777215</height>
            </size>
           </property>
           <property name="text">
            <string>Size: </string>
           </property>
           <property name="alignment">
            <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QSpinBox" name="array_size">
           <property name="enabled">
            <bool>false</bool>
           </property>
           <property name="frame">
            <bool>true</bool>
           </property>
           <property name="prefix">
            <string/>
           </property>
           <property name="maximum">
            <number>65535</number>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item row="4" column="1">
        <widget class="QLineEdit" name="value"/>
       </item>
       <item row="4" column="0">
        <widget class="QLabel" name="label_4">
         <property name="minimumSize">
          <size>
           <width>0</width>
           <height>0</height>
          </size>
         </property>
         <property name="text">
          <string>Initial Value: </string>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::NoTextInteraction</set>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>
```

`src/types.ixx`:

```ixx
export module types;

import std;

export {
	using u8  = std::uint8_t;
	using u16 = std::uint16_t;
	using u32 = std::uint32_t;
	using u64 = std::uint64_t;

	using i8  = std::int8_t;
	using i16 = std::int16_t;
	using i32 = std::int32_t;
	using i64 = std::int64_t;

	using f32 = float;
	using f64 = double;
}
```

`src/utilities/math_operations.ixx`:

```ixx
export module MathOperations;

import <glm/glm.hpp>;
import <glm/gtc/matrix_transform.hpp>;
import <glm/gtc/quaternion.hpp>;

export extern const glm::vec3 TRANSLATION_IDENTITY(0);
export extern const glm::vec3 SCALE_IDENTITY(1);
export extern const glm::quat ROTATION_IDENTITY(1, 0, 0, 0);

// Equivalent to, but much faster than
// worldMatrix = glm::translate(glm::mat4(1.f), position);
// worldMatrix = glm::translate(worldMatrix, pivot);
// worldMatrix = glm::scale(worldMatrix, scale);
// Normally rotation would come before scale, but WC3 is special
// worldMatrix *= glm::mat4_cast(rotation);
// worldMatrix = glm::translate(worldMatrix, -pivot);
export void
from_rotation_translation_scale_origin(const glm::quat& q, const glm::vec3& v, const glm::vec3& s, glm::mat4& out, const glm::vec3& pivot) {
	// ho tom bambadil
	// tom bombadillo
	// Retera was here
	// (This code is copied from the holy bible)
	const float x = q.x;
	const float y = q.y;
	const float z = q.z;
	const float w = q.w;
	const float x2 = x + x;
	const float y2 = y + y;
	const float z2 = z + z;
	const float xx = x * x2;
	const float xy = x * y2;
	const float xz = x * z2;
	const float yy = y * y2;
	const float yz = y * z2;
	const float zz = z * z2;
	const float wx = w * x2;
	const float wy = w * y2;
	const float wz = w * z2;
	const float sx = s.x;
	const float sy = s.y;
	const float sz = s.z;

	out[0][0] = (1 - (yy + zz)) * sx;
	out[0][1] = (xy + wz) * sy; // was sx for R * S
	out[0][2] = (xz - wy) * sz; // was sx for R * S
	out[0][3] = 0;
	out[1][0] = (xy - wz) * sx; // was sy for R * S
	out[1][1] = (1 - (xx + zz)) * sy;
	out[1][2] = (yz + wx) * sz; // was sy for R * S
	out[1][3] = 0;
	out[2][0] = (xz + wy) * sx; // was sz for R * S
	out[2][1] = (yz - wx) * sy; // was sz for R * S
	out[2][2] = (1 - (xx + yy)) * sz;
	out[2][3] = 0;
	out[3][0] = v.x + pivot.x - (out[0][0] * pivot.x + out[1][0] * pivot.y + out[2][0] * pivot.z);
	out[3][1] = v.y + pivot.y - (out[0][1] * pivot.x + out[1][1] * pivot.y + out[2][1] * pivot.z);
	out[3][2] = v.z + pivot.z - (out[0][2] * pivot.x + out[1][2] * pivot.y + out[2][2] * pivot.z);
	out[3][3] = 1;
}

glm::quat ghostwolfSquad(const glm::quat a, const glm::quat aOutTan, const glm::quat bInTan, const glm::quat b, float t) {
	glm::quat temp1;
	glm::quat temp2;
	temp1 = glm::slerp(a, b, t);
	temp2 = glm::slerp(aOutTan, bInTan, t);
	return glm::slerp(temp1, temp2, 2 * t * (1 - t));
}

float hermite(float a, float aOutTan, float bInTan, float b, float t) {
	float factorTimes2 = t * t;
	float factor1 = factorTimes2 * (2 * t - 3) + 1;
	float factor2 = factorTimes2 * (t - 2) + t;
	float factor3 = factorTimes2 * (t - 1);
	float factor4 = factorTimes2 * (3 - 2 * t);
	return (a * factor1) + (aOutTan * factor2) + (bInTan * factor3) + (b * factor4);
}

float bezier(float a, float aOutTan, float bInTan, float b, float t) {
	float invt = 1 - t;
	float factorSquared = t * t;
	float inverseFactorSquared = invt * invt;
	float factor1 = inverseFactorSquared * invt;
	float factor2 = 3 * t * inverseFactorSquared;
	float factor3 = 3 * factorSquared * invt;
	float factor4 = factorSquared * t;
	return (a * factor1) + (aOutTan * factor2) + (bInTan * factor3) + (b * factor4);
}

// template <typename T>
// inline void interpolate(T& out, const T* start, const T* outTan, const T* inTan, const T* end, float t, int interpolationType) {
//	out = *start;
// }

export float interpolate(const float start, const float outTan, const float inTan, const float end, float t, int interpolationType) {
	switch (interpolationType) {
		case 1: // LINEAR
			return glm::mix(start, end, t);
		case 2: // HERMITE
			return hermite(start, outTan, inTan, end, t);
		case 3: // BEZIER
			return bezier(start, outTan, inTan, end, t);
		default:
			return start;
	}
}

export glm::vec3
interpolate(const glm::vec3 start, const glm::vec3 outTan, const glm::vec3 inTan, const glm::vec3 end, float t, int interpolationType) {
	switch (interpolationType) {
		case 1: // LINEAR
			return glm::mix(start, end, t);
		case 2: { // HERMITE
			glm::vec3 out;
			out.x = hermite(start.x, outTan.x, inTan.x, end.x, t);
			out.y = hermite(start.y, outTan.y, inTan.y, end.y, t);
			out.z = hermite(start.z, outTan.z, inTan.z, end.z, t);
			return out;
		}
		case 3: { // BEZIER
			glm::vec3 out;
			out.x = bezier(start.x, outTan.x, inTan.x, end.x, t);
			out.y = bezier(start.y, outTan.y, inTan.y, end.y, t);
			out.z = bezier(start.z, outTan.z, inTan.z, end.z, t);
			return out;
		}
		default:
			return start;
	}
}

export glm::quat
interpolate(const glm::quat start, const glm::quat outTan, const glm::quat inTan, const glm::quat end, float t, int interpolationType) {
	switch (interpolationType) {
		case 1: // LINEAR
			return glm::slerp(start, end, t);
		case 2: // HERMITE
			// GLM uses both {x, y, z, w} and {w, x, y, z} convention, in different places, sometimes.
			// Their squad is {w, x, y, z} but we are elsewhere using {x, y, z, w}, so we will
			// continue using the copy of the Matrix Eater "ghostwolfSquad" for now.
			// out = glm::squad(*start, *outTan, *inTan, *end, t);
			return ghostwolfSquad(start, outTan, inTan, end, t);
		case 3: // BEZIER
			// GLM uses both {x, y, z, w} and {w, x, y, z} convention, in different places, sometimes.
			// Their squad is {w, x, y, z} but we are elsewhere using {x, y, z, w}, so we will
			// continue using the copy of the Matrix Eater "ghostwolfSquad" for now.
			// out = glm::squad(*start, *outTan, *inTan, *end, t);
			return ghostwolfSquad(start, outTan, inTan, end, t);
		default:
			return start;
	}
}

export uint32_t interpolate(const uint32_t start, const uint32_t, const uint32_t, const uint32_t, float, int) {
	return start;
}

export glm::quat safeQuatLookAt(glm::vec3 const& lookFrom, glm::vec3 const& lookTo, glm::vec3 const& up, glm::vec3 const& alternativeUp) {
	glm::vec3 direction = lookTo - lookFrom;
	float directionLength = glm::length(direction);

	// Check if the direction is valid; Also deals with NaN
	if (!(directionLength > 0.0001)) {
		return glm::quat(1, 0, 0, 0); // Just return identity
	}

	// Normalize direction
	direction /= directionLength;

	// Is the normal up (nearly) parallel to direction?
	if (glm::abs(glm::dot(direction, up)) > .9999f) {
		// Use alternative up
		return glm::quatLookAt(direction, alternativeUp);
	} else {
		return glm::quatLookAt(direction, up);
	}
}

```

`src/utilities/modification_tables.ixx`:

```ixx
export module ModificationTables;

import std;
import std.compat;
import BinaryReader;
import BinaryWriter;
import Hierarchy;
import SLK;
import Utilities;
import UnorderedMap;
import <cassert>;

namespace fs = std::filesystem;

constexpr int mod_table_write_version = 3;

void load_modification_table(BinaryReader& reader, const uint32_t version, slk::SLK& slk, const slk::SLK& meta_slk, const bool modification, const bool optional_ints) {
	const uint32_t objects = reader.read<uint32_t>();
	for (size_t i = 0; i < objects; i++) {
		const std::string original_id = reader.read_string(4);
		const std::string modified_id = reader.read_string(4);

		if (version >= 3) {
			const uint32_t set_count = reader.read<uint32_t>();
			if (set_count > 1) {
				std::println("Set count of {} detected", set_count);
			}
			const uint32_t set_flag = reader.read<uint32_t>();
		}
		if (modification && !slk.base_data.contains(modified_id)) {
			slk.copy_row(original_id, modified_id, false);
		}

		const uint32_t modifications = reader.read<uint32_t>();

		for (size_t j = 0; j < modifications; j++) {
			const std::string modification_id = reader.read_string(4);
			const uint32_t type = reader.read<uint32_t>();

			std::string column_header = to_lowercase_copy(meta_slk.data<std::string_view>("field", modification_id));
			if (optional_ints) {
				const uint32_t level_variation = reader.read<uint32_t>();
				const uint32_t data_pointer = reader.read<uint32_t>();
				if (data_pointer != 0) {
					column_header += static_cast<char>('a' + data_pointer - 1);
				}
				if (meta_slk.data<std::string_view>("repeat", modification_id) == "1") {
					column_header += std::to_string(level_variation);
				}
			}

			std::string data;
			switch (type) {
				case 0:
					data = std::to_string(reader.read<int>());
					break;
				case 1:
				case 2:
					data = std::to_string(reader.read<float>());
					break;
				case 3:
					data = reader.read_c_string();
					break;
				default:
					std::println("Unknown data type {} while loading modification table.", type);
			}
			reader.advance(4);

			if (column_header == "") {
				std::println("Unknown mod id: {}", modification_id);
				continue;
			}

			if (modification) {
				slk.set_shadow_data(column_header, modified_id, data);
			} else {
				slk.set_shadow_data(column_header, original_id, data);
			}
		}
	}
}

export void load_modification_file(const std::string_view file_name, slk::SLK& base_data, const slk::SLK& meta_slk, const bool optional_ints) {
	BinaryReader reader = hierarchy.map_file_read(file_name).value();

	const int version = reader.read<uint32_t>();
	if (version != 1 && version != 2 && version != 3) {
		std::cout << "Unknown modification table version of " << version << " detected. Attempting to load, but may crash.\n";
	}

	load_modification_table(reader, version, base_data, meta_slk, false, optional_ints);
	load_modification_table(reader, version, base_data, meta_slk, true, optional_ints);
}

// The idea of SLKs and mod files is quite bad, but I can deal with them
// The way they are implemented is horrible though
void save_modification_table(BinaryWriter& writer, const slk::SLK& slk, const slk::SLK& meta_slk, const bool custom, const bool optional_ints, const bool skin) {
	BinaryWriter sub_writer;

	size_t count = 0;
	for (const auto& [id, properties] : slk.shadow_data) {
		// If we are writing custom objects then we only want rows with oldid set as the others are base rows
		if (!custom && properties.contains("oldid")) {
			continue;
		} else if (custom && !properties.contains("oldid")) {
			continue;
		}
		count++;

		if (custom) {
			sub_writer.write_string(properties.at("oldid"));
			sub_writer.write_string(id);
		} else {
			sub_writer.write_string(id);
			sub_writer.write<uint32_t>(0);
		}

		// 1.33 fields not yet researched
		sub_writer.write<uint32_t>(1); // sets count
		sub_writer.write<uint32_t>(0); // set flags

		// Split properties, or another way to save war3mapSkin.w3* files correctly?
		// netsafe slk field is probably what vanilla uses (if anyone wants to try this)
		// No changes in skin files and all in main ones is a valid state, but not nice
		if (skin) {
			sub_writer.write<uint32_t>(0); // "no changes"
			continue;
		}
		sub_writer.write<uint32_t>(properties.size() - (properties.contains("oldid") ? 1 : 0));

		for (const auto& [property_id, value] : properties) {
			// The oldis property is a HiveWE specific field of storing the ID a unit/ability is based on
			if (property_id == "oldid") {
				continue;
			}

			int variation = 0;
			int data_pointer = 0;

			size_t nr_position = property_id.find_first_of("0123456789");
			if (nr_position != std::string::npos) {
				variation = std::stoi(property_id.substr(nr_position));
			}

			// If it is a data field then it will contain a data_pointer/column at the end
			if (property_id.starts_with("data")) {
				data_pointer = property_id[4] - 'a' + 1;
			}

			const auto meta_id2 = slk.field_to_meta_id(meta_slk, property_id, id);
			if (!meta_id2) {
				std::println("Meta data key not found for id {} property {}", id, property_id);
				exit(0);
			}
			const std::string meta_data_key = std::string(meta_id2.value());

			sub_writer.write_string(meta_data_key);
			// There's an error in AbilityMetaData.slk where Crs1 instead uses Crs so we need to pad till 4 characters
			for (size_t i = 0; i < 4 - meta_data_key.size(); i++) {
				sub_writer.write<uint8_t>('\0');
			}

			int write_type = -1;
			const std::string_view type = meta_slk.data<std::string_view>("type", meta_data_key);
			if (type == "int" || type == "bool" || type.ends_with("Flags") || type == "attackBits" || type == "channelType" || type == "deathType" || type == "defenseTypeInt" || type == "detectionType" || type == "spellDetail" || type == "teamColor" || type == "techAvail") {
				write_type = 0;
			} else if (type == "real") {
				write_type = 1;
			} else if (type == "unreal") {
				write_type = 2;
			} else { // string
				write_type = 3;
			}

			sub_writer.write<uint32_t>(write_type);

			if (optional_ints) {
				sub_writer.write<uint32_t>(variation);
				sub_writer.write<uint32_t>(data_pointer);
			}

			if (write_type == 0) {
				sub_writer.write<int>(std::stoi(value));
			} else if (write_type == 1 || write_type == 2) {
				sub_writer.write<float>(std::stof(value));
			} else {
				sub_writer.write_c_string(value);
			}

			sub_writer.write<uint32_t>(0);
		}
	}

	writer.write<uint32_t>(count);
	writer.write_vector(sub_writer.buffer);
}

export void save_modification_file(const std::string_view file_name, const slk::SLK& slk, const slk::SLK& meta_slk, const bool optional_ints, const bool skin) {
	BinaryWriter writer;
	writer.write<uint32_t>(mod_table_write_version);

	save_modification_table(writer, slk, meta_slk, false, optional_ints, skin);
	save_modification_table(writer, slk, meta_slk, true, optional_ints, skin);

	hierarchy.map_file_write(file_name, writer.buffer);
}

```

`src/utilities/no_init_allocator.ixx`:

```ixx
export module no_init_allocator;

import std;

export template <typename T, typename A = std::allocator<T>>
class default_init_allocator : public A {
	typedef std::allocator_traits<A> a_t;

  public:
	using A::A; // Inherit constructors from A

	template <typename U>
	struct rebind {
		using other = default_init_allocator<U, typename a_t::template rebind_alloc<U>>;
	};

	template <typename U>
	void construct(U* ptr) noexcept(std::is_nothrow_default_constructible_v<U>) {
		::new (static_cast<void*>(ptr)) U;
	}

	template <typename U, typename... Args>
	void construct(U* ptr, Args&&... args) {
		a_t::construct(static_cast<A&>(*this),
					   ptr, std::forward<Args>(args)...);
	}
};
```

`src/utilities/opengl_utilities.ixx`:

```ixx
module;

#include <QSettings>
#include <QPainter>
#include <QIcon>

export module OpenGLUtilities;

import std;
import ResourceManager;
import Texture;
import <glad/glad.h>;
import <glm/glm.hpp>;

namespace fs = std::filesystem;

export class Shapes {
  public:
	void init() {
		glCreateBuffers(1, &vertex_buffer);
		glNamedBufferData(vertex_buffer, quad_vertices.size() * sizeof(glm::vec2), quad_vertices.data(), GL_STATIC_DRAW);

		glCreateBuffers(1, &index_buffer);
		glNamedBufferData(index_buffer, quad_indices.size() * sizeof(unsigned int) * 3, quad_indices.data(), GL_STATIC_DRAW);
	}

	GLuint vertex_buffer;
	GLuint index_buffer;

	const std::vector<glm::vec2> quad_vertices = {
		{ 1, 1 },
		{ 0, 1 },
		{ 0, 0 },
		{ 1, 0 }
	};

	const std::vector<glm::uvec3> quad_indices = {
		{ 0, 1, 2 },
		{ 2, 3, 0 }
	};
};

export inline Shapes shapes;

/// Convert a Tground texture into an QIcon with two states
export QIcon ground_texture_to_icon(uint8_t* data, const int width, const int height) {
	QImage temp_image = QImage(data, width, height, QImage::Format::Format_RGBA8888);
	const int size = height / 4;

	auto pix = QPixmap::fromImage(temp_image.copy(0, 0, size, size));

	QIcon icon;
	icon.addPixmap(pix, QIcon::Normal, QIcon::Off);

	QPainter painter(&pix);
	painter.fillRect(0, 0, size, size, QColor(255, 255, 0, 64));
	painter.end();

	icon.addPixmap(pix, QIcon::Normal, QIcon::On);

	return icon;
}

/// Loads a texture from the hierarchy and returns an icon
export QIcon texture_to_icon(fs::path path) {
	auto tex = resource_manager.load<Texture>(path);
	QImage temp_image = QImage(tex->data.data(), tex->width, tex->height, tex->channels == 3 ? QImage::Format::Format_RGB888 : QImage::Format::Format_RGBA8888);
	auto pix = QPixmap::fromImage(temp_image);
	return QIcon(pix);
};

export fs::path find_warcraft_directory() {
	QSettings settings;
	if (settings.contains("warcraftDirectory")) {
		return settings.value("warcraftDirectory").toString().toStdString();
	} else if (fs::exists("C:/Program Files/Warcraft III")) {
		return "C:/Program Files/Warcraft III";
	} else if (fs::exists("C:/Program Files (x86)/Warcraft III")) {
		return "C:/Program Files (x86)/Warcraft III";
	} else {
		return "";
	}
}
```

`src/utilities/timer.ixx`:

```ixx
export module Timer;

import std;

export class Timer {
	std::chrono::steady_clock::time_point start_time;

  public:
	Timer() {
		start_time = std::chrono::steady_clock::now();
	}

	double elapsed_ms() {
		return static_cast<double>((std::chrono::steady_clock::now() - start_time).count()) / 1'000'000;
	}

	void reset() {
		start_time = std::chrono::steady_clock::now();
	}
};
```

`src/utilities/unordered_map.ixx`:

```ixx
export module UnorderedMap;

import std;
import "ankerl/unordered_dense.h";

struct string_hash {
    using is_transparent = void; // enable heterogeneous lookup
    using is_avalanching = void; // mark class as high quality avalanching hash

    [[nodiscard]] auto operator()(const char* str) const noexcept -> uint64_t {
        return ankerl::unordered_dense::hash<std::string_view>{}(str);
    }

    [[nodiscard]] auto operator()(std::string_view str) const noexcept -> uint64_t {
        return ankerl::unordered_dense::hash<std::string_view>{}(str);
    }

    [[nodiscard]] auto operator()(std::string const& str) const noexcept -> uint64_t {
        return ankerl::unordered_dense::hash<std::string_view>{}(str);
    }
};


export namespace hive {
    template <typename T>
    concept StringLike = std::same_as<T, std::string>;

	/// Under the hood this is an ankerl::unordered_dense::map
	/// This template makes it pick the heterogeneous lookup version when the Key is std::string and otherwise uses the default
    template <typename Key, typename Value>
    using unordered_map = std::conditional_t<
        StringLike<Key>,
        ankerl::unordered_dense::map<Key, Value, string_hash, std::equal_to<>>,
        ankerl::unordered_dense::map<Key, Value>
    >;
}
```

`src/utilities/utilities.ixx`:

```ixx
export module Utilities;

import std;
import <glm/glm.hpp>;
import BinaryReader;
import no_init_allocator;
import types;

namespace fs = std::filesystem;

// String functions
export std::string_view trimmed(const std::string_view string) {
	size_t start = 0;
	while (start < string.size() && std::isspace(string[start])) {
		start += 1;
	}

	size_t end = string.size();
	while (end > start && std::isspace(string[end - 1])) {
		end -= 1;
	}

	return string.substr(start, end - start);
}

export std::string string_replaced(const std::string_view source, const std::string_view from, const std::string_view to) {
	std::string new_string;
	new_string.reserve(source.length()); // avoids a few memory allocations

	size_t lastPos = 0;
	size_t findPos;

	while (std::string::npos != (findPos = source.find(from, lastPos))) {
		new_string.append(source, lastPos, findPos - lastPos);
		new_string += to;
		lastPos = findPos + from.length();
	}

	// Care for the rest after last occurrence
	new_string += source.substr(lastPos);

	return new_string;
}

export std::string to_lowercase_copy(const std::string_view string) {
	std::string output(string);
	std::transform(output.begin(), output.end(), output.begin(), [](unsigned char c) { return std::tolower(c); });
	return output;
}

export void to_lowercase(std::string& string) {
	std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) { return std::tolower(c); });
}

// trim from start (in place)
export void ltrim(std::string& s) {
	s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
				return !std::isspace(ch);
			}));
}

// trim from end (in place)
export void rtrim(std::string& s) {
	s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
				return !std::isspace(ch);
			}).base(),
			s.end());
}

// trim from both ends (in place)
export void trim(std::string& s) {
	ltrim(s);
	rtrim(s);
}

export bool is_number(const std::string& s) {
	return !s.empty() && std::find_if(s.begin(), s.end(), [](char c) { return !std::isdigit(c); }) == s.end();
}

export std::string read_text_file(const fs::path& path) {
	std::ifstream textfile(path.c_str());
	std::string line;
	std::string text;

	if (!textfile.is_open())
		return "";

	while (getline(textfile, line)) {
		text += line + "\n";
	}

	return text;
}

// Splits a string
export std::vector<std::string> split_string_escaped(const std::string_view input) {
	std::vector<std::string> result;
	std::string current;
	bool in_quotes = false;

	for (char c : input) {
		if (c == '"') {
			in_quotes = !in_quotes;
		} else if (c == ',' && !in_quotes) {
			result.push_back(current);
			current.clear();
		} else {
			current.push_back(c);
		}
	}
	result.push_back(current);
	return result;
}

export auto read_file(const fs::path& path) -> std::expected<BinaryReader, std::string> {
	std::ifstream stream(path, std::ios::binary);
	if (stream) {
		return BinaryReader(
			std::vector<u8, default_init_allocator<u8>>(std::istreambuf_iterator(stream), std::istreambuf_iterator<char>())
		);
	} else {
		return std::unexpected("Unable to open file");
	}
};

export struct ItemSet {
	std::vector<std::pair<int, std::string>> items;
};

// Returns 1 or -1
export glm::vec2 sign_not_zero(glm::vec2 v) {
	return glm::vec2((v.x >= 0.f) ? +1.f : -1.f, (v.y >= 0.f) ? +1.f : -1.f);
}
// Assume normalized input. Output is on [-1, 1] for each component.
export glm::vec2 float32x3_to_oct(glm::vec3 v) {
	// Project the sphere onto the octahedron, and then onto the xy plane
	glm::vec2 p = glm::vec2(v) * (1.f / (std::abs(v.x) + std::abs(v.y) + std::abs(v.z)));
	// Reflect the folds of the lower hemisphere over the diagonals
	return (v.z <= 0.f) ? ((1.f - glm::abs(glm::vec2(p.y, p.x))) * sign_not_zero(p)) : p;
}

/// 21 bits per component ~= 2,097,152 distinct values
/// With an extent of 4096 that would give a precision of ~0.0019
export glm::uvec2 pack_vec3_to_uvec2(const glm::vec3 v, const float extent) {
	glm::vec3 normalized = glm::clamp(v / extent, glm::vec3(-1.0f), glm::vec3(1.0f));
	normalized = (normalized + 1.0f) * 0.5f;

	const uint64_t x = normalized.x * static_cast<float>((1ull << 21) - 1); // 21 bits
	const uint64_t y = normalized.y * static_cast<float>((1ull << 21) - 1); // 21 bits
	const uint64_t z = normalized.z * static_cast<float>((1ull << 22) - 1); // 22 bits
	const uint64_t packed = x << 43 | y << 22 | z;

	return glm::uvec2(packed & 0xFFFFFFFF, packed >> 32);
}

// From http://www.jcgt.org/published/0006/02/01/
export bool intersect_aabb(const glm::vec3& aabb_min, const glm::vec3& aabb_max, const glm::vec3& origin, const glm::vec3& direction) {
	const glm::vec3 t1 = (aabb_min - origin) / direction;
	const glm::vec3 t2 = (aabb_max - origin) / direction;
	const glm::vec3 tmin = glm::min(t1, t2);
	const glm::vec3 tmax = glm::max(t1, t2);
	
	return glm::min(tmax.x, glm::min(tmax.y, tmax.z)) > glm::max(glm::max(tmin.x, 0.f), glm::max(tmin.y, tmin.z));
}

export bool intersect_sphere(const glm::vec3& origin, const glm::vec3& direction, glm::vec3 position, float radius) {
	glm::vec3 op = position - origin;
	float b = glm::dot(op, direction);
	float disc = b * b - dot(op, op) + radius * radius;
	return disc >= 0.0f;
}

// Only works with uniform scaling
export void transform_aabb_uniform(const glm::vec3& min, const glm::vec3& max, glm::vec3& new_min, glm::vec3& new_max, const glm::mat4& transform) {
	new_min = transform[3];
	new_max = transform[3];
	for (size_t i = 0; i < 3; i++) {
		for (size_t j = 0; j < 3; j++) {
			float e = transform[i][j] * min[j];
			float f = transform[i][j] * max[j];
			if (e < f) {
				new_min[i] += e;
				new_max[i] += f;
			} else {
				new_min[i] += f;
				new_max[i] += e;
			}
		}
	}
}

// Works with non uniform scaling. For uniform scaling use the faster transform_aabb_uniform()
export void transform_aabb_non_uniform(const glm::vec3& min, const glm::vec3& max, glm::vec3& new_min, glm::vec3& new_max, const glm::mat4& transform) {
	glm::vec4 p1 = transform * glm::vec4(min, 1.f);
	glm::vec4 p2 = transform * glm::vec4(max.x, min.y, min.z, 1.f);
	glm::vec4 p3 = transform * glm::vec4(max.x, max.y, min.z, 1.f);
	glm::vec4 p4 = transform * glm::vec4(min.x, max.y, min.z, 1.f);
	glm::vec4 p5 = transform * glm::vec4(min.x, min.y, max.z, 1.f);
	glm::vec4 p6 = transform * glm::vec4(max.x, min.y, max.z, 1.f);
	glm::vec4 p7 = transform * glm::vec4(max, 1.f);
	glm::vec4 p8 = transform * glm::vec4(min.x, max.y, max.z, 1.f);

	new_min = glm::min(p1, glm::min(p2, glm::min(p3, glm::min(p4, glm::min(p5, glm::min(p6, glm::min(p7, p8)))))));
	new_max = glm::max(p1, glm::max(p2, glm::max(p3, glm::max(p4, glm::max(p5, glm::max(p6, glm::max(p7, p8)))))));
}
```

`tabs.editorconfig`:

```editorconfig
root = true

[*]
end_of_line = lf
insert_final_newline = false
indent_style = tab
indent_size = 4
```

`vcpkg.json`:

```json
{
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json",
  "vcpkg-configuration": {
    "overlay-ports": [
      "overlay-ports"
    ]
  },
  "name": "hivewe",
  "version": "0.7.0",
  "builtin-baseline": "9cbe1df2acf09b1d53cf6e48afa5fda44f61147d",
  "dependencies": [
    {
      "name": "abseil",
      "features": [
        "cxx17"
      ]
    },
    "bullet3",
    "bzip2",
    "casclib",
    {
      "name": "glad",
      "default-features": false,
      "features": [
        "extensions",
        "gl-api-46",
        "loader"
      ]
    },
    "glm",
    "imgui",
    "libjpeg-turbo",
    {
      "name": "mimalloc",
      "features": [
        "override"
      ]
    },
    "nlohmann-json",
    "outcome",
    "qt-advanced-docking-system",
    {
      "name": "qtbase",
      "default-features": false,
      "features": [
        "gui",
        "jpeg",
        "opengl",
        "png",
        "widgets"
      ]
    },
    "soil2",
    "stormlib",
    "tbb",
    "unordered-dense",
    "qscintilla"
  ]
}

```