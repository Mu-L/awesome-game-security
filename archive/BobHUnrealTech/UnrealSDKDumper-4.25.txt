Project Path: arc_BobHUnrealTech_UnrealSDKDumper-4.25_2fgwn2uu

Source Tree:

```txt
arc_BobHUnrealTech_UnrealSDKDumper-4.25_2fgwn2uu
├── Dumper
│   ├── ClassSizeFixer.cpp
│   ├── ClassSizeFixer.h
│   ├── Dumper.aps
│   ├── Dumper.vcxproj
│   ├── Dumper.vcxproj.filters
│   ├── Dumper.vcxproj.user
│   ├── EngineHeaderExport.cpp
│   ├── EngineHeaderExport.h
│   ├── RefGraphSolver.cpp
│   ├── RefGraphSolver.h
│   ├── defs.h
│   ├── dumper.cpp
│   ├── dumper.h
│   ├── engine.cpp
│   ├── engine.h
│   ├── engine_code
│   │   ├── BasicTypes_Classes.h
│   │   ├── BasicTypes_Package.cpp
│   │   ├── BasicTypes_Package.h
│   │   ├── BasicTypes_Structs.h
│   │   ├── CoreUObject_Classes.h
│   │   ├── CoreUObject_Package.cpp
│   │   ├── CoreUObject_Package.h
│   │   ├── CoreUObject_Params.h
│   │   ├── CoreUObject_Structs.h
│   │   ├── GlobalOffset.h
│   │   ├── Injected_GetBoneWorldPos.cpp
│   │   └── fortest.txt
│   ├── engine_code.aps
│   ├── engine_code.rc
│   ├── generic.cpp
│   ├── generic.h
│   ├── main.cpp
│   ├── memory.cpp
│   ├── memory.h
│   ├── relation.txt
│   ├── resource.h
│   ├── utils.cpp
│   ├── utils.h
│   ├── wrappers.cpp
│   └── wrappers.h
├── README.md
├── UnrealDumper.sln
├── build.ps1
├── include
│   ├── fmt
│   │   ├── core.h
│   │   ├── format-inl.h
│   │   ├── format.cc
│   │   └── format.h
│   ├── hash
│   │   └── hash.h
│   └── types.h
├── tools
│   ├── ClassNameParser.cpp
│   └── non_utf8_convert_test.cpp
├── with_ptr_scan.png
└── without_ptr_scan.png

```

`Dumper/ClassSizeFixer.cpp`:

```cpp
#include "ClassSizeFixer.h"


std::unordered_map<void*, int> ClassSizeFixer::sizeMp;
```

`Dumper/ClassSizeFixer.h`:

```h
#pragma once
#include <unordered_map>
#include "wrappers.h"
class ClassSizeFixer
{

  inline static void LoadStruct(UE_UStruct& to_fix) {
    void* addr = to_fix.GetAddress();
    sizeMp[addr] = to_fix.GetSize();
  }
  
  inline static int FixStruct(UE_UStruct& to_fix) {
    auto super = to_fix.GetSuper();
    if (!super) {
      return 0;
    }
    auto superAddr = super.GetAddress();
    if (sizeMp.count(superAddr) == 0) {
      printf("Unknow super for struct: %s\n", to_fix.GetFullName().c_str());
      return 0;
    }
    bool fixed = false;
    for (auto prop = to_fix.GetChildProperties().Cast<UE_FProperty>(); prop; prop = prop.GetNext().Cast<UE_FProperty>()) {
      auto propInterface = prop.GetInterface();
      auto member_offset = propInterface.GetOffset();
      if (sizeMp[superAddr] > member_offset) {
        fixed = true;
        sizeMp[superAddr] = member_offset;
      }
    }
    if (fixed) {
      printf("Fixed class [%s] from 0x%X -> 0x%X \n", super.GetName().c_str(), super.GetSize(), sizeMp[superAddr]);
    }
    to_fix.FixedSize = sizeMp[superAddr];
    return fixed;
  }

public:
  // map struct/class -> it's size
  static std::unordered_map<void*, int> sizeMp;

  inline static void LoadPackage(UE_UPackage& package) {
    auto& objects = package.Package->second;
    for (auto& object : objects) {
      if (object.IsA<UE_UClass>()) {
        auto structData = object.Cast<UE_UStruct>();
        LoadStruct(structData);
      }
      else if (object.IsA<UE_UScriptStruct>()) {
        auto structData = object.Cast<UE_UStruct>();
        LoadStruct(structData);
      }
    }
  }

  inline static int FixAllPackage(std::vector<UE_UPackage>& packages) {
    int totFixed = 0;
    for (auto& package : packages) {
      auto& objects = package.Package->second;
      for (auto& object : objects) {
        if (object.IsA<UE_UClass>()) {
          auto structData = object.Cast<UE_UStruct>();
          totFixed += FixStruct(structData);
        }
        else if (object.IsA<UE_UScriptStruct>()) {
          auto structData = object.Cast<UE_UStruct>();
          totFixed += FixStruct(structData);
        }
      }
    }
    return totFixed;
  }
};

```

`Dumper/Dumper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4e175db2-cffd-48f9-888f-af140e44068d}</ProjectGuid>
    <RootNamespace>Dumper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)include;$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>obj\$(Configuration)\</IntDir>
    <LibraryPath>$(SolutionDir)libs;$(LibraryPath)</LibraryPath>
    <TargetName>cheat</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)include;$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>obj\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
    <LibraryPath>$(SolutionDir)libs;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnabled>true</VcpkgEnabled>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <CallingConvention>FastCall</CallingConvention>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ExceptionHandling>Async</ExceptionHandling>
      <AdditionalOptions>/Zc:char8_t- %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <CallingConvention>FastCall</CallingConvention>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>Async</ExceptionHandling>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <StringPooling>true</StringPooling>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <CompileAs>CompileAsCpp</CompileAs>
      <ControlFlowGuard>
      </ControlFlowGuard>
      <DisableLanguageExtensions>false</DisableLanguageExtensions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <AdditionalOptions>/Zc:char8_t- %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\include\fmt\format.cc" />
    <ClCompile Include="ClassSizeFixer.cpp" />
    <ClCompile Include="dumper.cpp" />
    <ClCompile Include="engine.cpp" />
    <ClCompile Include="EngineHeaderExport.cpp" />
    <ClCompile Include="generic.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="memory.cpp" />
    <ClCompile Include="RefGraphSolver.cpp" />
    <ClCompile Include="utils.cpp" />
    <ClCompile Include="wrappers.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ClassSizeFixer.h" />
    <ClInclude Include="defs.h" />
    <ClInclude Include="dumper.h" />
    <ClInclude Include="engine.h" />
    <ClInclude Include="EngineHeaderExport.h" />
    <ClInclude Include="generic.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="RefGraphSolver.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="utils.h" />
    <ClInclude Include="wrappers.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="engine_code.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Dumper/Dumper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="include">
      <UniqueIdentifier>{7feed74c-41d0-4a17-93ca-9e368259955d}</UniqueIdentifier>
    </Filter>
    <Filter Include="headers">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="sources">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="resource">
      <UniqueIdentifier>{b42fa9c3-26f9-488c-ac27-d54504489d13}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>sources</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>sources</Filter>
    </ClCompile>
    <ClCompile Include="wrappers.cpp">
      <Filter>sources</Filter>
    </ClCompile>
    <ClCompile Include="generic.cpp">
      <Filter>sources</Filter>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <Filter>sources</Filter>
    </ClCompile>
    <ClCompile Include="engine.cpp">
      <Filter>sources</Filter>
    </ClCompile>
    <ClCompile Include="dumper.cpp">
      <Filter>sources</Filter>
    </ClCompile>
    <ClCompile Include="RefGraphSolver.cpp">
      <Filter>sources</Filter>
    </ClCompile>
    <ClCompile Include="EngineHeaderExport.cpp">
      <Filter>sources</Filter>
    </ClCompile>
    <ClCompile Include="ClassSizeFixer.cpp">
      <Filter>sources</Filter>
    </ClCompile>
    <ClCompile Include="..\include\fmt\format.cc">
      <Filter>sources</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="engine.h">
      <Filter>headers</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>headers</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>headers</Filter>
    </ClInclude>
    <ClInclude Include="wrappers.h">
      <Filter>headers</Filter>
    </ClInclude>
    <ClInclude Include="generic.h">
      <Filter>headers</Filter>
    </ClInclude>
    <ClInclude Include="defs.h">
      <Filter>headers</Filter>
    </ClInclude>
    <ClInclude Include="dumper.h">
      <Filter>headers</Filter>
    </ClInclude>
    <ClInclude Include="RefGraphSolver.h">
      <Filter>headers</Filter>
    </ClInclude>
    <ClInclude Include="EngineHeaderExport.h">
      <Filter>headers</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>headers</Filter>
    </ClInclude>
    <ClInclude Include="ClassSizeFixer.h">
      <Filter>headers</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="engine_code.rc">
      <Filter>resource</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Dumper/Dumper.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`Dumper/EngineHeaderExport.cpp`:

```cpp
#include "EngineHeaderExport.h"
#include <Windows.h>
#include <unordered_map>
#include <string>
#include <vector>
#include <filesystem>
#include "dumper.h"
#include "defs.h"


HMODULE GetMainModule() {
  HMODULE hModule = 0;
  GetModuleHandleEx(
    GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
    (LPCTSTR) GetMainModule,
    &hModule
  );
  return hModule;
}

bool EngineHeaderExport::LoadResourceText(std::string& str, int resourceID)
{
  static std::unordered_map<int, std::string> mp;
  if (mp.count(resourceID)) {
    str = mp[resourceID];
    return true;
  }
  HRSRC hRes = FindResource(GetMainModule(), MAKEINTRESOURCE(resourceID), MAKEINTRESOURCE(TEXTFILE));
  if (!hRes) return false;
  HGLOBAL hData = LoadResource(GetMainModule(), hRes);
  if (!hData) return false;
  DWORD hSize = SizeofResource(GetMainModule(), hRes);
  char* hFinal = (char*)LockResource(hData);
  str.assign(hFinal, hSize);
  mp[resourceID] = str;
  return true;
}

void EngineHeaderExport::ReplaceVAR(std::string& str) {
  auto replaceSubstr = [](std::string& originalStr, std::string substring, std::string replacement) {
    size_t pos = 0;
    const size_t substringLength = substring.length();
    const size_t replacementLength = replacement.length();

    while ((pos = originalStr.find(substring, pos)) != std::string::npos) {
      originalStr.replace(pos, substringLength, replacement);
      pos += replacementLength; // Move past the replaced substring
    }
  };
  auto dumper_ins = Dumper::GetInstance();

  // windows \r\n 会识别成两个换行，要避免这种情况
  replaceSubstr(str, "\r\n", "\n");

  replaceSubstr(str, "VAR_GAME_NAME", dumper_ins->gameName);
  replaceSubstr(str, "VAR_GAME_VERSION", "default" /*TODO: recognise the game version*/);
  replaceSubstr(str, "VAR_NAMESPACE", GNameSpace);
}



```

`Dumper/EngineHeaderExport.h`:

```h
#pragma once
#include <string>
#include <filesystem>
#include <fmt/core.h>
#include <fstream>
#include "resource.h"
/*
* Author: BobH
* Time: 2023.7.19
* Usage: 引擎自带的头文件的导出，可能需要判断游戏的版本？
*/


#ifndef ENGINEHEADEREXPORT
#define ENGINEHEADEREXPORT

class EngineHeaderExport
{
public:
  static void ReplaceVAR(std::string& str);
  static bool LoadResourceText(std::string& str, int resourceID);
  static inline void Process(std::filesystem::path dir) {
    const static std::vector<std::pair<int, std::string>> EngineFiles = {
      std::make_pair(BASICTYPES_PACKAGE, "SDK/BasicTypes_Package.h"),
      std::make_pair(BASICTYPES_CLASSES, "SDK/BasicTypes_Classes.h"),
      std::make_pair(BASICTYPES_STRUCT, "SDK/BasicTypes_Structs.h"),
      std::make_pair(COREUOBJECT_PACKAGE, "SDK/CoreUObject_Package.h"),
      std::make_pair(COREUOBJECT_CLASSES, "SDK/CoreUObject_Classes.h"),
      std::make_pair(COREUOBJECT_STRUCT, "SDK/CoreUObject_Structs.h"),
      std::make_pair(COREUOBJECT_CPP, "SDK/CoreUObject_Package.cpp"),
      std::make_pair(BASICTYPES_CPP, "SDK/BasicTypes_Package.cpp"),
      std::make_pair(COREUOBJECT_PARAM, "SDK/CoreUObject_Params.h"),
      std::make_pair(GLOBAL_OFFSET, "GlobalOffset.h"),
    };
    // 导出两个引擎文件
    for (auto& enginefile : EngineFiles) {
      std::ofstream output(dir / enginefile.second);
      std::string content;
      if (!LoadResourceText(content, enginefile.first)) {
        printf("[ERROR] Fail to read engine header file: %s\n", enginefile.second.c_str());
        continue;
      }
      ReplaceVAR(content);
      // fmt::print(file, "{}", content);
      output << content;
    }
  }
};

#endif

```

`Dumper/RefGraphSolver.cpp`:

```cpp
#include "RefGraphSolver.h"

std::unordered_map<std::string, std::string> RefGraphSolver::typeDefMap;


std::vector<RefGraphSolver::Node*> RefGraphSolver::packageNodes;

std::unordered_map<std::string, RefGraphSolver::Node*> RefGraphSolver::nodesMap;

std::vector<std::string> RefGraphSolver::packageHeaderOrder;

std::vector<std::string> RefGraphSolver::BasicTypes = {
	"TArray",
	"FString",
	"FUObjectItem",
	"TUObjectArray",
	"FNameEntryHeader",
	"FNameEntry",
	"FNameEntryAllocator",
	"FNamePool",
	"FName",
	"TEnumAsByte",
	"FScriptInterface",
	"TScriptInterface",
	"FTextData",
	"FText",
	"FScriptDelegate",
	"FScriptMulticastDelegate",
	"FMulticastSparseDelegate",
	"TPair",
	"TSetElement",
	"TMap",
	"FStringAssetReference_",
	"FUniqueObjectGuid_",
	"FStructBaseChain",
	"FWeakObjectPtr",
	"TWeakObjectPtr",
	"TAutoPointer",
	"TAutoWeakObjectPtr",
	"TPersistentObjectPtr",
	"FLazyObjectPtr",
	"FAssetPtr",
	"TAssetPtr",
	"TLazyObjectPtr",
	"ObjectNames",
	"ObjectFlags",
};

std::vector<std::string> RefGraphSolver::CoreUObject = {
	"EInterpCurveMode",
	"ERangeBoundTypes",
	"ELocalizedTextSourceCategory",
	"EAutomationEventType",
	"EMouseCursor",
	"ELifetimeCondition",
	"EDataValidationResult",
	"EPropertyAccessChangeNotifyMode",
	"EUnit",
	"EPixelFormat",
	"EAxis",
	"ELogTimes",
	"ESearchDir",
	"ESearchCase",
	"FJoinabilitySettings",
	"FUniqueNetIdWrapper",
	"FGuid",
	"FRotator",
	"FVector",
	"FVector4",
	"FVector2D",
	"FTwoVectors",
	"FPlane",
	"FQuat",
	"FPackedNormal",
	"FPackedRGB10A2N",
	"FPackedRGBA16N",
	"FIntPoint",
	"FIntVector",
	"FColor",
	"FLinearColor",
	"FBox",
	"FBox2D",
	"FBoxSphereBounds",
	"FOrientedBox",
	"FMatrix",
	"FInterpCurvePointFloat",
	"FInterpCurveFloat",
	"FInterpCurvePointVector2D",
	"FInterpCurveVector2D",
	"FInterpCurvePointVector",
	"FInterpCurveVector",
	"FInterpCurvePointQuat",
	"FInterpCurveQuat",
	"FInterpCurvePointTwoVectors",
	"FInterpCurveTwoVectors",
	"FInterpCurvePointLinearColor",
	"FInterpCurveLinearColor",
	"FTransform",
	"FRandomStream",
	"FDateTime",
	"FFrameNumber",
	"FFrameRate",
	"FFrameTime",
	"FQualifiedFrameTime",
	"FTimecode",
	"FTimespan",
	"FSoftObjectPath",
	"FSoftClassPath",
	"FPrimaryAssetType",
	"FPrimaryAssetId",
	"FFallbackStruct",
	"FFloatRangeBound",
	"FFloatRange",
	"FInt32RangeBound",
	"FInt32Range",
	"FFloatInterval",
	"FInt32Interval",
	"FPolyglotTextData",
	"FAutomationEvent",
	"FAutomationExecutionEntry",
	"UObject",
	"UPackage",
	"UField",
	"UStruct",
	"UClass",
	"UFunction",
	"UInterface",
	"UGCObjectReferencer",
	"UTextBuffer",
	"UScriptStruct",
	"UDelegateFunction",
	"USparseDelegateFunction",
	"UDynamicClass",
	"UPackageMap",
	"UEnum",
	"ULinkerPlaceholderClass",
	"ULinkerPlaceholderExportObject",
	"ULinkerPlaceholderFunction",
	"UMetaData",
	"UObjectRedirector",
	"UProperty",
	"UEnumProperty",
	"UArrayProperty",
	"UObjectPropertyBase",
	"UBoolProperty",
	"UNumericProperty",
	"UByteProperty",
	"UObjectProperty",
	"UClassProperty",
	"UDelegateProperty",
	"UDoubleProperty",
	"UFloatProperty",
	"UIntProperty",
	"UInt8Property",
	"UInt16Property",
	"UInt64Property",
	"UInterfaceProperty",
	"ULazyObjectProperty",
	"UMapProperty",
	"UMulticastDelegateProperty",
	"UMulticastInlineDelegateProperty",
	"UMulticastSparseDelegateProperty",
	"UNameProperty",
	"USetProperty",
	"USoftObjectProperty",
	"USoftClassProperty",
	"UStrProperty",
	"UStructProperty",
	"UUInt16Property",
	"UUInt32Property",
	"UUInt64Property",
	"UWeakObjectProperty",
	"UTextProperty",
	"UPropertyWrapper",
	"UMulticastDelegatePropertyWrapper",
	"UMulticastInlineDelegatePropertyWrapper",
};

std::vector<std::string> RefGraphSolver::CppTypes = {
	"void",
	"float",
	"char",
	"bool",
	"double",
	"int8_t",
	"int16_t",
	"int32_t",
	"int64_t",
	"uint8_t",
	"uint16_t",
	"uint32_t",
	"uint64_t",
};


```

`Dumper/RefGraphSolver.h`:

```h
#pragma once
#include <unordered_map>
#include <vector>
#include <string>
#include <set>
#include <cassert>
#include <fmt/core.h>
#include <fstream>
#include <queue>
#include "wrappers.h"

/*
* Author: BobH
* Time: 2023.7.18
* Usage: 类依赖关系构建图, 拓扑排序, 获得正确头文件顺序
*/

const bool verboseDebug = 1;
const bool ignoreTemplateRef = true; // 模板引用，且有class标志，编译器可以自动识别不用考虑顺序问题
const bool ignoreFuncParamRef = true; // 函数参数引用，有class标志，编译器可自动识别不用考虑顺序问题

#define DEBUG

#ifndef REFGRAPHSOLVER
#define REFGRAPHSOLVER

class RefGraphSolver
{
  struct Node {
    Node() {
      packageName = "";
      indeg = 0;
      outdeg = 0;
      neighbors = std::vector<Node*>();
    }
    Node(std::string name) {
      static int id = 0;
      debug_id = ++id;
      packageName = name;
      indeg = 0;
      outdeg = 0;
      neighbors = std::vector<Node*>();
    }
    std::string packageName;
    std::vector<Node*> neighbors;
    int indeg, outdeg;
    int debug_id;
  };

  // map the TypeName -> PackageName
  static std::unordered_map<std::string, std::string> typeDefMap;


  // map the packageName -> NodePointer
  static std::unordered_map<std::string, Node*> nodesMap;

  // Store all the package nodes for topo sort
  static std::vector<Node*> packageNodes;

  // 硬件自带的类型定义，需要手动获取写上去的
  static std::vector<std::string> BasicTypes;
  static std::vector<std::string> CoreUObject;
  static std::vector<std::string> CppTypes;

  static void PushNode(std::string packageName) {
    auto newNode = new Node(packageName);
    nodesMap[packageName] = newNode;
    packageNodes.push_back(newNode);
  }

  static void LoadUnrealPackageDef() {
    // 加载虚幻引擎自带的一些类的定义，这些定义不是从游戏中dump的，是从引擎代码中抠出来的，需要单独加载
    for (auto ClassName : BasicTypes) {
      typeDefMap[ClassName] = "BasicTypes";
    }
    for (auto ClassName : CoreUObject) {
      typeDefMap[ClassName] = "CoreUObject";
    }
    for (auto ClassName : CppTypes) {
      typeDefMap[ClassName] = "CppTypes";
    }
    PushNode("BasicTypes");
    PushNode("CoreUObject");
    PushNode("CppTypes");
  }



  static std::string GetPureTypeName(std::string fullTypeName) {
    auto removeSubstring = [](std::string& input, const std::string toRemove) {
      size_t pos = input.find(toRemove);
      while (pos != std::string::npos) {
        input.erase(pos, toRemove.length());
        pos = input.find(toRemove, pos);
      }
    };
    auto trim = [](std::string& input) {
      if (input == "") return;
      size_t start = 0;
      size_t end = input.length() - 1;

      // Find the first non-space character from the beginning of the string
      while (start <= end && std::isspace(input[start])) {
        start++;
      }

      // Find the last non-space character from the end of the string
      while (end >= start && std::isspace(input[end])) {
        end--;
      }

      // Return the trimmed substring
      input = input.substr(start, end - start + 1);
    };
    std::string res = fullTypeName;
    removeSubstring(res, "static");
    removeSubstring(res, "enum");
    removeSubstring(res, "class");
    removeSubstring(res, "struct");
    removeSubstring(res, "*");
    trim(res);
    return res;
  }

  static std::vector<std::string> GetGenericTypes(std::string genericTypeName) {
    auto removeSubstring = [](std::string& input, const std::string toRemove) {
      size_t pos = input.find(toRemove);
      while (pos != std::string::npos) {
        input.erase(pos, toRemove.length());
        pos = input.find(toRemove, pos);
      }
    };
    auto splitString = [](const std::string& input, const std::string& delimiters) {
      std::vector<std::string> tokens;
      std::string::size_type startPos = 0;
      std::string::size_type endPos = 0;

      while (endPos != std::string::npos) {
        endPos = input.find_first_of(delimiters, startPos);

        // 如果找到了分隔符
        if (endPos != startPos) {
          std::string token = input.substr(startPos, endPos - startPos);
          tokens.push_back(token);
        }

        // 跳过分隔符，继续查找下一个子串
        if (endPos != std::string::npos) {
          startPos = endPos + 1;
        }
      }
      tokens.pop_back();
      return tokens;
    };
    removeSubstring(genericTypeName, " ");
    const std::string delimiters = "<>,";
    return splitString(genericTypeName, delimiters);
  }

  static void LoadPackageDef(UE_UPackage& package) {
    std::string packageName = package.packageName;
    if (packageName == "CoreUObject") return;
    for (auto& klass : package.Classes) {
      typeDefMap[klass.ClassName] = packageName;
    }
    for (auto& stru : package.Structures) {
      typeDefMap[stru.ClassName] = packageName;
    }
    for (auto& enums : package.Enums) {
      typeDefMap[enums.EnumName] = packageName;
    }
    if(package.Classes.size() || package.Structures.size() || package.Enums.size()) PushNode(packageName);
  }

  static bool AddEdge(std::string packageReferer, std::string packageReferee) {
    static std::ofstream output("relation.txt");
    // packageReferer -> packageReferee
    if (nodesMap.count(packageReferer) == 0) {
      printf("Could not found Referer class node \"%s\"!", packageReferer.c_str());
      return false;
    }
    if (nodesMap.count(packageReferee) == 0) {
      printf("Could not found Referee class node \"%s\"!", packageReferee.c_str() );
      return false;
    }
    auto pReferer = nodesMap[packageReferer];
    auto pReferee = nodesMap[packageReferee];
    pReferer->indeg++;
    pReferee->outdeg++;
    pReferee->neighbors.push_back(pReferer);
    output << pReferer->packageName << " referes " << pReferee->packageName << std::endl;
    return true;
  }

  static void FixUndefinedClassMember(UE_UPackage::Member& member) {
    // 修复结构中一些没出现的结构，直接用char代替
    member.Type = "/*" + member.Type + "*/" + "char";
    member.Name += fmt::format("[{:#0x}]", member.Size);
  }

  static bool CanIgnoreRef(std::string typeName) {
    // suppose that all template can be ignored.
    // printf("Judge ignore: %s\n", typeName.c_str());
    return true;
  }

  static void BuildRefGraph(UE_UPackage& package) {
    std::string packageName = package.packageName;
    if (packageName == "CoreUObject") {
      // 处理特殊的类，不要使用dump数据
      package.Classes.clear();
      package.Enums.clear();
      package.Structures.clear();
      return;
    }

    // 存储依赖的类型，去重
    std::set<std::string> refTypes;

    // 存储依赖的package，去重
    std::set <std::string> refPackages;

    auto processStruct = [&refTypes, &refPackages, &packageName](UE_UPackage::Struct& klass) {
      
      // 处理继承依赖
      auto& superName = klass.SuperName;
      if (superName == "FNone" && verboseDebug) {
        // printf("EmptySuperClass: %s\n", klass.ClassName.c_str());
      }
      assert(superName.find("<") == std::string::npos);  // Should not be possible?
      if (superName != "FNone" && superName != "") refTypes.insert(superName);

      // 处理成员类型依赖
      for (auto& member : klass.Members) {
        auto purename = GetPureTypeName(member.Type);
        if (purename.find("<") != std::string::npos) {
          // generic type
          auto genericTypes = GetGenericTypes(purename);
          bool should_fix = false;
          for (auto& tname : genericTypes) {
            assert(tname != "");
            if (typeDefMap.count(tname) == 0) {
              should_fix = true;
              FixUndefinedClassMember(member);
              break;
            }
          }
          if (!should_fix && ignoreTemplateRef && CanIgnoreRef(purename)) {
            continue;
          }
          if(!should_fix)
            for (auto& tname : genericTypes) {
              assert(tname != "");
              refTypes.insert(tname);
            }
        }
        else {
          assert(purename != "");
          if (typeDefMap.count(purename) == 0)
            FixUndefinedClassMember(member);
          else
            refTypes.insert(purename);
        }
      }
      // 处理函数类型依赖
      for (auto& function : klass.Functions) {
        // 处理返回值
        bool deleteFunction = false; // 如果这个函数返回值有问题，那就设置成void了
        auto purename = GetPureTypeName(function.RetType);
        if (purename.find("<") != std::string::npos) {
          // generic type
          auto genericTypes = GetGenericTypes(purename);
          bool should_fix = false;
          for (auto& tname : genericTypes) {
            assert(tname != "");
            if (typeDefMap.count(tname) == 0) {
              should_fix = true;
              function.RetType = "void";
              function.CppName = "void " + function.FuncName;
              function.paramInfo.clear();
              break;
            }
          }
          if (!should_fix && ignoreTemplateRef && CanIgnoreRef(purename)) {
            goto paramProcess;
          }
          if(!should_fix)
            for (auto& tname : genericTypes) {
              assert(tname != "");
              refTypes.insert(tname);
            }
        }
        else {
          assert(purename != "");
          if (typeDefMap.count(purename) == 0) {
            function.RetType = "void";
            function.CppName = "void " + function.FuncName;
            function.paramInfo.clear();
          }
          else {
            refTypes.insert(purename);
          }
        }
        paramProcess:;
        // 处理参数
        for (auto paramtype : function.ParamTypes) {
          auto purename = GetPureTypeName(paramtype);
          if (purename.find("<") != std::string::npos) {
            // generic type
            auto genericTypes = GetGenericTypes(purename);
            bool should_fix = false;
            for (auto& tname : genericTypes) {
              assert(tname != "");
              if (typeDefMap.count(tname) == 0) {
                should_fix = true;
                function.Params = "/*" + function.Params + "*/";
                function.paramInfo.clear();
                function.ParamTypes.clear();
                function.badDeclareFunc = true;
                goto end;
              }
            }
            if (!should_fix && ignoreTemplateRef && CanIgnoreRef(purename)) {
              continue;
            }
            if(!should_fix)
              for (auto& tname : genericTypes) {
                assert(tname != "");
                refTypes.insert(tname);
              }
          }
          else {
            assert(purename != "");
            if (typeDefMap.count(purename) == 0) {
              function.Params = "/*" + function.Params + "*/";
              function.paramInfo.clear();
              function.ParamTypes.clear();
              function.badDeclareFunc = true;
              goto end;
            }
            else {
              auto isEnumType = [](std::string& type) {
                if (type.size() <= 4) return false;
                if (type.substr(0, 4) == "enum") return true;
                return false;
              };
              // 只有指针才可以忽略
              if (ignoreFuncParamRef && !isEnumType(paramtype) && paramtype.find("*") != std::string::npos) continue;
              // printf("insert  %s\n", purename.c_str());
              refTypes.insert(purename);
            }
          }
        }
        end:;
      }
    };

    // 找出所有类型引用
    for (auto& klass : package.Classes) {
      processStruct(klass);
    }
    for (auto& klass : package.Structures) {
      processStruct(klass);
    }
    
    // 找出所有Package引用
    for (auto& refType : refTypes) {
      if (typeDefMap.count(refType) == 0) {
        printf("[Warning] Cannot find type \"%s\" in any package!\n", refType.c_str());
        continue;
      }
      refPackages.insert(typeDefMap[refType]);
    }

    // 链接关系
    for(auto& targetPackage : refPackages) {
      if (packageName == targetPackage) continue;
      AddEdge(packageName, targetPackage);
    }
  }

  static void FixPackageTypeOrder(UE_UPackage& package) {
    std::string packageName = package.packageName;
    if (packageName == "CoreUObject") {
      // 处理特殊的类，不要使用dump数据
      package.Classes.clear();
      package.Enums.clear();
      package.Structures.clear();
      return;
    }

    /// DEBUG!!!
    // if (packageName != "Engine") return;

    // inclassTypeName -> Node*
    std::unordered_map<std::string, Node*> classMp, structMp;
    std::unordered_map<std::string, int> typeMap; // 区分到底是struct还是class

    auto isTypeInCurrentPackage = [&packageName](std::string typeName) {
      if (typeDefMap.count(typeName) == 0) return false;
      return typeDefMap[typeName] == packageName;
    };

    auto insertEdge = [&typeMap](std::string referer, std::string referee, std::unordered_map<std::string, Node*>& nodeMp) {
      if (typeMap[referer] != typeMap[referee]) return;  // class -> struct, struct -> class 没必要处理
      if (referer == referee) return; // 消除自环
      Node* per, * pee;
      if (nodeMp.count(referer)) {
        per = nodeMp[referer];
      }
      else {
        per = new Node(referer);
        nodeMp[referer] = per;
      }
      if (nodeMp.count(referee)) {
        pee = nodeMp[referee];
      }
      else {
        pee = new Node(referee);
        nodeMp[referee] = pee;
      }
      pee->outdeg++;
      per->indeg++;
      pee->neighbors.push_back(per);
      // if (verboseDebug) printf("SelfAddEdge %s -> %s\n", referer.c_str(), referee.c_str());
    };

    auto processStruct = [&isTypeInCurrentPackage, &insertEdge](UE_UPackage::Struct& klass, std::unordered_map<std::string, Node*>& mp) {
      if (klass.ClassName == "FALSAnimRotateInPlace") {
        // _CrtDbgBreak();
      }
      // 处理继承依赖
      auto& superName = klass.SuperName;
      assert(superName.find("<") == std::string::npos);  // Should not be possible?
      if (superName != "FNone" && superName != "" && isTypeInCurrentPackage(superName)) {
        insertEdge(klass.ClassName, superName, mp);
      }

      // 处理成员类型依赖
      for (auto& member : klass.Members) {
        if (member.Type.find("*") != std::string::npos) {
          // class pointre, can be ignored
          continue;
        }
        auto purename = GetPureTypeName(member.Type);
        if (purename.find("<") != std::string::npos) {
          // generic type
          auto genericTypes = GetGenericTypes(purename);
          if (ignoreTemplateRef && CanIgnoreRef(purename)) {
            continue;
          }
          for (auto& tname : genericTypes) {
            assert(tname != "");
            if (isTypeInCurrentPackage(tname)) insertEdge(klass.ClassName, tname, mp);
          }
        }
        else {
          assert(purename != "");
          if (isTypeInCurrentPackage(purename)) insertEdge(klass.ClassName, purename, mp);
        }
      }

      // 处理函数类型依赖
      for (auto& function : klass.Functions) {
        // 处理返回值
        if(function.RetType.find("*") == std::string::npos){
          auto purename = GetPureTypeName(function.RetType);
          if (purename.find("<") != std::string::npos) {
            // generic type
            auto genericTypes = GetGenericTypes(purename);
            if (ignoreTemplateRef && CanIgnoreRef(purename)) {
              continue;
            }
            for (auto& tname : genericTypes) {
              assert(tname != "");
              if (isTypeInCurrentPackage(tname)) insertEdge(klass.ClassName, tname, mp);
            }
          }
          else {
            assert(purename != "");
            if (isTypeInCurrentPackage(purename)) insertEdge(klass.ClassName, purename, mp);
          }
        }
        // 处理参数
        for (auto paramtype : function.ParamTypes) {
          auto purename = GetPureTypeName(paramtype);
          if (purename.find("<") != std::string::npos) {
            // generic type
            auto genericTypes = GetGenericTypes(purename);
            if (ignoreTemplateRef && CanIgnoreRef(purename)) {
              continue;
            }
            for (auto& tname : genericTypes) {
              assert(tname != "");
              if (isTypeInCurrentPackage(tname)) insertEdge(klass.ClassName, tname, mp);
            }
          }
          else {
            assert(purename != "");
            if (ignoreFuncParamRef) continue;
            if (isTypeInCurrentPackage(purename)) insertEdge(klass.ClassName, purename, mp);
          }
        }
      }
    };

    auto inclassTopo = [&packageName](std::vector<UE_UPackage::Struct>& classes, std::unordered_map<std::string, Node*>& mp) {
      std::vector<UE_UPackage::Struct> newOrder;
      std::unordered_map<std::string, UE_UPackage::Struct> mp2;
      std::unordered_map<std::string, bool> debug;
      std::queue<Node*> queue;
      for (auto& klass : classes) {
        mp2[klass.ClassName] = klass;
        // 将没有约束关系的类先放进去
        if (mp.count(klass.ClassName) == 0) {
          newOrder.push_back(klass);
          debug[klass.ClassName] = true;
        }
        else {
          if (mp[klass.ClassName]->indeg == 0) {
            queue.push(mp[klass.ClassName]);
          }
        }
      }
      while (!queue.empty()) {
        Node* front = queue.front();
        debug[front->packageName] = true;
        newOrder.push_back(mp2[front->packageName]);
        queue.pop();
        for (auto other : front->neighbors) {
          other->indeg--;
          if (other->indeg == 0) queue.push(other);
        }
      }
      for (auto& ori : classes) {
        if (debug.count(ori.ClassName) == 0) {
          printf("[disappear][%s] %s\n", packageName.c_str(), ori.ClassName.c_str());
        }
      }
      assert(newOrder.size() == classes.size());
      classes = newOrder;
    };
    for (auto& klass : package.Classes) {
      typeMap[klass.ClassName] = 1;
    }
    for (auto& klass : package.Structures) {
      typeMap[klass.ClassName] = 2;
    }

    // 找出所有自类型引用
    for (auto& klass : package.Classes) {
      processStruct(klass, classMp);
    }
    for (auto& klass : package.Structures) {
      processStruct(klass, structMp);
    }
    inclassTopo(package.Classes, classMp);
    inclassTopo(package.Structures, structMp);
  }

  static void TopoSort() {
    std::queue<Node*> queue;
    for (Node* node : packageNodes) {
      if (node->indeg == 0) {
        // 表示这个模块已经不依赖于其他模块了，可以输出
        queue.push(node);
      }
    }
    int cnt = 0;
    while (!queue.empty()) {
      Node* front = queue.front();
      queue.pop();
      cnt++;
      // if(verboseDebug) printf("package[%d]: %s\n", cnt, front->packageName.c_str());
      packageHeaderOrder.push_back(front->packageName);
      for (auto other : front->neighbors) {
        other->indeg--;
        if (other->indeg == 0) queue.push(other);
      }
    }
    if (cnt != packageNodes.size()) {
      printf("[Warning] Not all packages are included in the header for the reference problem. \n");
      for (Node* node : packageNodes) {
        if (node->indeg != 0) {
          printf("\tPackageName: %s\n", node->packageName.c_str());
        }
      }
    }
  }

public:
  static void Process(std::vector<UE_UPackage>& packages) {
    LoadUnrealPackageDef();
    std::unordered_map<std::string, int> packageNameMp;
    for (UE_UPackage& package : packages) {
      package.packageName = package.GetObject().GetName();
      if (packageNameMp.count(package.packageName) > 0) {
        package.packageName += fmt::format("_{}", ++packageNameMp[package.packageName]);
      }
      else {
        packageNameMp[package.packageName] = 1;
      }
      LoadPackageDef(package);
    }

    if (verboseDebug) {
      printf("\nLoaded all packages defs! \n");
    }

    for (UE_UPackage& package : packages) {
      BuildRefGraph(package);
    }

    if (verboseDebug) {
      printf("\nReference graph builded! \n");
    }


    // 处理类内的依赖关系
    fmt::print("Fixing package type order... \n");
    for (UE_UPackage& package : packages) {
      FixPackageTypeOrder(package);
    }

    TopoSort();
  }

  static std::vector<std::string> packageHeaderOrder;

};

#endif
```

`Dumper/defs.h`:

```h
#pragma once
#include <types.h>

#ifdef GetObject
#undef GetObject
#endif

enum class STATUS {
  SUCCESS,
  FAILED,
  WINDOW_NOT_FOUND,
  PROCESS_NOT_FOUND,
  READER_ERROR,
  CANNOT_GET_PROCNAME,
  MODULE_NOT_FOUND,
  ENGINE_NOT_FOUND,
  ENGINE_FAILED,
  CANNOT_READ,
  INVALID_IMAGE,
  FILE_NOT_OPEN,
  ZERO_PACKAGES
};

#define GNameSpace "Dumper"
```

`Dumper/dumper.cpp`:

```cpp
#include <Windows.h>
#include <fmt/core.h>
#include "dumper.h"
#include "engine.h"
#include "memory.h"
#include "utils.h"
#include "wrappers.h"
#include "RefGraphSolver.h"
#include "EngineHeaderExport.h"
#include "ClassSizeFixer.h"

Dumper::~Dumper() {
	if (Image) VirtualFree(Image, 0, MEM_RELEASE);
}

STATUS Dumper::Init(int argc, char* argv[]) {
	for (auto i = 1; i < argc; i++) {
		auto arg = argv[i];
		uint16 arg16 = *(uint16*)arg;
		if (arg16 == 'h-') {
			printf("'-p' - dump only names and objects\n'-w' - wait for input (it gives me time to inject mods)\n'-f packageNameHere' - specifies package where we should look for pointers in paddings (can take a lot of time)\n");
			fmt::print("-pch enable precompiled headers include pch.h");
			return STATUS::FAILED;
		}
		else if (arg16 == 'p-') {
			Full = false;
		}
		else if (arg16 == 'w-') {
			Wait = true;
		}
		else if (arg16 == 'f-') {
			i++;
			if (i < argc) { PackageName = argv[i]; }
			else { return STATUS::FAILED; }
		}
		else if (!strcmp(arg, "--spacing")) {
			Spacing = true;
		}
		else if (!strcmp(arg, "-pch")) {
			this->pch_head = true;
		}
	}

	if (Wait) {
		system("pause");
	}

	uint32_t pid = 0;

	{
		HWND hWnd = FindWindowA("UnrealWindow", nullptr);
		if (!hWnd) {
			return STATUS::WINDOW_NOT_FOUND;
		};
		GetWindowThreadProcessId(hWnd, (DWORD*)(&pid));
		if (!pid) {
			return STATUS::PROCESS_NOT_FOUND;
		};
	}

	if (!ReaderInit(pid)) {
		return STATUS::READER_ERROR;
	};

	fs::path processName;

	{
		wchar_t processPath[MAX_PATH]{};
		if (!GetProccessPath(pid, processPath, MAX_PATH)) { return STATUS::CANNOT_GET_PROCNAME; };
		processName = fs::path(processPath).filename();
		printf("Found UE4 game: %ls\n", processName.c_str());
	}

	{
		auto root = fs::path(argv[0]);
		root.remove_filename();
		auto game = processName.stem();
		gameName = game.string();
		Directory = root / "Games" / game;
		fs::create_directories(Directory);

		uint64 size = GetImageSize();
		if (!size) { return STATUS::MODULE_NOT_FOUND; }

		Image = VirtualAlloc(0, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
		if (!Read((void*)Base, Image, size)) {
			return STATUS::CANNOT_READ;
		}

		return EngineInit(game.string(), Image);
	}
}
void Dumper::GenerateSDKHeader(const fs::path& dir) {
	File file(dir / "SDK.h", "w");
	const std::vector<std::string> stlLib = {
	  "set",
	  "string",
	  "vector",
	  "locale",
	  "unordered_set",
	  "unordered_map",
	  "iostream",
	  "sstream",
	  "cstdint",
	  "Windows.h",
	};
	const std::vector<int> ignoreWarningCode = {
	  4099,
	};
	for (auto& stlName : stlLib) {
		fmt::print(file, "#include <{}>\n", stlName);
	}

	for (auto& code : ignoreWarningCode) {
		fmt::print(file, "#pragma warning(disable: {})\n", code);
	}

	fmt::print(file, "\n// Note: The content of GlobalOffset.h should be updated by yourself!! \n\n");

	fmt::print(file, "#include \"GlobalOffset.h\"\n");

	fmt::print(file, "\n// SDK headers \n\n");
	for (auto& packageName : RefGraphSolver::packageHeaderOrder) {
		if (packageName == "CppTypes") continue; // ignore

		char chars[] = "/\\:*?\"<>|+";
		for (auto c : chars) {
			auto pos = packageName.find(c);
			if (pos != std::string::npos) {
				packageName[pos] = '_';
			}
		}
		fmt::print(file, "#include \"SDK/{}_package.h\"\n", packageName);
	}

}

STATUS Dumper::Dump() {
	/*
	 * Names dumping.
	 * We go through each block, except last, that is not fully filled.
	 * In each block we calculate next entry depending on previous entry size.
	 */
	{
		File file(Directory / "NamesDump.txt", "w");
		if (!file) { return STATUS::FILE_NOT_OPEN; }
		size_t size = 0;
		NamePoolData.Dump([&file, &size](std::string_view name, uint32_t id) {
			fmt::print(file, "[{:0>6}] {}\n", id, name);
			size++;
			});
		fmt::print("Names: {}\n", size);
	}
	{
		// Why we need to iterate all objects twice? We dumping objects and filling
		// packages simultaneously.
		std::unordered_map<uint8*, std::vector<UE_UObject>> packages;
		{
			File file(Directory / "ObjectsDump.txt", "w");
			if (!file) { return STATUS::FILE_NOT_OPEN; }
			size_t size = 0;


			std::function<void(UE_UObject)> callback;
			if (Full) {
				callback = [&file, &size, &packages](UE_UObject object) {

					auto isFunction = object.IsA<UE_UFunction>();
					if (isFunction) {
						fmt::print(file, "[{:0>6}] <{}> <{}> {} {:x}\n", object.GetIndex(), object.GetAddress(), Read<void*>(object.GetAddress()), object.GetFullName(), object.Cast<UE_UFunction>().GetFunc() - Base);
					}
					else {
						fmt::print(file, "[{:0>6}] <{}> <{}> {}\n", object.GetIndex(), object.GetAddress(), Read<void*>(object.GetAddress()), object.GetFullName());
					}
					size++;
					if (isFunction || object.IsA<UE_UStruct>() || object.IsA<UE_UEnum>()) {
						auto packageObj = object.GetPackageObject();
						packages[packageObj].push_back(object);
					}
					};
			}
			else {
				callback = [&file, &size](UE_UObject object) {
					fmt::print(file, "[{:0>6}] <{}> <{}> {}\n", object.GetIndex(), object.GetAddress(), Read<void*>(object.GetAddress()), object.GetFullName());
					size++;
					};
			}

			ObjObjects.Dump(callback);

			fmt::print("Objects: {}\n", size);
		}

		if (!Full) {
			return STATUS::SUCCESS;
		}

		//{
		//    // Clearing all packages with small amount of objects (comment this if
		//    you need all packages to be dumped) size_t size = packages.size();
		//    size_t erased = std::erase_if(packages, [](std::pair<byte* const,
		//    std::vector<UE_UObject>>& package) { return package.second.size() < 2;
		//    });

		//    fmt::print("Wiped {} out of {}\n", erased, size);
		//}

		// Checking if we have any package after clearing.
		if (!packages.size()) {
			return STATUS::ZERO_PACKAGES;
		}

		fmt::print("Packages: {}\n", packages.size());
		std::vector<UE_UPackage> processedPackage;
		{
			auto path = Directory / "SDK";
			fs::create_directories(path);

			// 输出引擎自带的头
			EngineHeaderExport::Process(Directory);

			int i = 1;
			int saved = 0;
			std::string unsaved{};

			bool lock = true;
			if (PackageName) lock = false;

			// 先修复大小
			for (UE_UPackage package : packages) {
				fmt::print("\rFixing class size: {}/{}", i++, packages.size());
				ClassSizeFixer::LoadPackage(package);
				processedPackage.push_back(package);
			}
			printf("\n");
			int fixedClassCnt = ClassSizeFixer::FixAllPackage(processedPackage);
			printf("fixed %d classes size!\n", fixedClassCnt);
			i = 1;
			// 先全部处理
			for (UE_UPackage& package : processedPackage) {
				fmt::print("\rProcessing: {}/{}", i++, packages.size());

				if (!lock && package.GetObject().GetName() == PackageName) {
					package.FindPointers = true;
					lock = true;
				}
				package.Process();
			}

			// 再解决依赖关系问题
			RefGraphSolver::Process(processedPackage);

			fmt::print("Writing sdk files... \n");
			pch_head_include = this->pch_head;
			// 再导出sdk
			for (UE_UPackage& package : processedPackage) {
				if (package.Save(path, Spacing)) {
					saved++;
				}
				else {
					unsaved += (package.GetObject().GetName() + ", ");
				};
			}

			// 导出总的SDK头文件
			Dumper::GenerateSDKHeader(Directory);

			fmt::print("\nSaved packages: {}\n", saved);

			if (unsaved.size()) {
				unsaved.erase(unsaved.size() - 2);
				fmt::print("Unsaved empty packages: [ {} ]\n", unsaved);
			}



		}
	}
	return STATUS::SUCCESS;
}

```

`Dumper/dumper.h`:

```h
#pragma once
#include "defs.h"
#include <filesystem>

namespace fs = std::filesystem;

class Dumper {
protected:
	bool Full = true;
	bool Wait = false;
	bool Spacing = false;
	bool pch_head = false;
	fs::path Directory;
	const char* PackageName = nullptr;
	void* Image = nullptr;


private:
	Dumper() {};

public:
	std::string gameName;
	static Dumper* GetInstance() {
		static Dumper dumper;
		return &dumper;
	}
	~Dumper();
	STATUS Init(int argc, char* argv[]);
	void GenerateSDKHeader(const fs::path& dir);
	STATUS Dump();
};

```

`Dumper/engine.cpp`:

```cpp
#include <Windows.h>
#include "engine.h"
#include "generic.h"
#include "memory.h"
#include "utils.h"
#include "wrappers.h"

Offsets offsets;

ansi_fn Decrypt_ANSI = nullptr;
// wide_fn Decrypt_WIDE = nullptr;

struct {
	uint16 Stride = 2;
	struct {
		uint16 Size = 24;
	} FUObjectItem;
	struct {
		uint16 Number = 4;
	} FName;
	struct {
		uint16 Info = 0;
		uint16 WideBit = 0;
		uint16 LenBit = 6;
		uint16 HeaderSize = 2;
	} FNameEntry;
	struct {
		uint16 Index = 0xC;
		uint16 Class = 0x10;
		uint16 Name = 0x18;
		uint16 Outer = 0x20;
	} UObject;
	struct {
		uint16 Next = 0x28;
	} UField;
	struct {
		uint16 SuperStruct = 0x40;
		uint16 Children = 0x48;
		uint16 ChildProperties = 0x50;
		uint16 PropertiesSize = 0x58;
	} UStruct;
	struct {
		uint16 Names = 0x40;
	} UEnum;
	struct {
		uint16 FunctionFlags = 0xB0;
		uint16 Func = 0xB0 + 0x28;
	} UFunction;
	struct {
		uint16 Class = 0x8;
		uint16 Next = 0x20;
		uint16 Name = 0x28;
	} FField;
	struct {
		uint16 ArrayDim = 0x38;
		uint16 ElementSize = 0x3C;
		uint16 PropertyFlags = 0x40;
		uint16 Offset = 0x4C;
		uint16 Size = 0x78;
	} FProperty;
	struct {
		uint16 ArrayDim = 0;
		uint16 ElementSize = 0;
		uint16 PropertyFlags = 0;
		uint16 Offset = 0;
		uint16 Size = 0; // sizeof(UProperty)
	} UProperty;
} Default;
static_assert(sizeof(Default) == sizeof(Offsets));

struct
{
	uint16 Stride = 2;
	struct
	{
		uint16 Size = 24;
	} FUObjectItem;
	struct
	{
		uint16 Number = 4;
	} FName;
	struct
	{
		uint16 Info = 0;
		uint16 WideBit = 0;
		uint16 LenBit = 6;
		uint16 HeaderSize = 2;
	} FNameEntry;
	struct
	{
		uint16 Index = 0xC;
		uint16 Class = 0x10;
		uint16 Name = 0x18;
		uint16 Outer = 0x20;
	} UObject;
	struct
	{
		uint16 Next = 0x28;
	} UField;
	struct
	{
		uint16 SuperStruct = 0x40;
		uint16 Children = 0x48;
		uint16 ChildProperties = 0;
		uint16 PropertiesSize = 0x50;
	} UStruct;
	struct
	{
		uint16 Names = 0x40;
	} UEnum;
	struct
	{
		uint16 FunctionFlags = 0x98;
		uint16 Func = 0xC0;
	} UFunction;
	struct
	{
		uint16 Class = 0;
		uint16 Next = 0;
		uint16 Name = 0;
	} FField;
	struct
	{
		uint16 ArrayDim = 0;
		uint16 ElementSize = 0;
		uint16 PropertyFlags = 0;
		uint16 Offset = 0;
		uint16 Size = 0;
	} FProperty;
	struct
	{
		uint16 ArrayDim = 0x30;
		uint16 ElementSize = 0x34;
		uint16 PropertyFlags = 0x38;
		uint16 Offset = 0x44;
		uint16 Size = 0x70; // sizeof(UProperty)
	} UProperty;
} Squad;
static_assert(sizeof(Squad) == sizeof(Offsets));

struct {
	uint16 Stride = 4;
	struct {
		uint16 Size = 24;
	} FUObjectItem;
	struct {
		uint16 Number = 8;
	} FName;
	struct {
		uint16 Info = 4;
		uint16 WideBit = 0;
		uint16 LenBit = 1;
		uint16 HeaderSize = 6;
	} FNameEntry;
	struct {
		uint16 Index = 0xC;
		uint16 Class = 0x10;
		uint16 Name = 0x18;
		uint16 Outer = 0x28;
	} UObject;
	struct {
		uint16 Next = 0x30;
	} UField;
	struct {
		uint16 SuperStruct = 0x48;
		uint16 Children = 0x50;
		uint16 ChildProperties = 0x58;
		uint16 PropertiesSize = 0x60;
	} UStruct;
	struct {
		uint16 Names = 0x48;
	} UEnum;
	struct {
		uint16 FunctionFlags = 0xB8;
		uint16 Func = 0xB8 + 0x28; // ue3-ue4, always +0x28 from flags location.
	} UFunction;
	struct {
		uint16 Class = 0x8;
		uint16 Next = 0x20;
		uint16 Name = 0x28;
	} FField;
	struct {
		uint16 ArrayDim = 0x38;
		uint16 ElementSize = 0x3C;
		uint16 PropertyFlags = 0x40;
		uint16 Offset = 0x4C;
		uint16 Size = 0x80;
	} FProperty;
	struct {
		uint16 ArrayDim = 0;
		uint16 ElementSize = 0;
		uint16 PropertyFlags = 0;
		uint16 Offset = 0;
		uint16 Size = 0; // sizeof(UProperty)
	} UProperty;
} DeadByDaylight;
static_assert(sizeof(DeadByDaylight) == sizeof(Offsets));

struct {
	uint16 Stride = 2;
	struct {
		uint16 Size = 24;
	} FUObjectItem;
	struct {
		uint16 Number = 4;
	} FName;
	struct {
		uint16 Info = 0;
		uint16 WideBit = 0;
		uint16 LenBit = 6;
		uint16 HeaderSize = 2;
	} FNameEntry;
	struct {
		uint16 Index = 0xC;
		uint16 Class = 0x10;
		uint16 Name = 0x18;
		uint16 Outer = 0x20;
	} UObject;
	struct {
		uint16 Next = 0x28;
	} UField;
	struct {
		uint16 SuperStruct = 0x40;
		uint16 Children = 0x48;
		uint16 ChildProperties = 0x50;
		uint16 PropertiesSize = 0x58;
	} UStruct;
	struct {
		uint16 Names = 0x40;
	} UEnum;
	struct {
		uint16 FunctionFlags = 0xB0;
		uint16 Func = 0xB0 + 0x30;
	} UFunction;
	struct {
		uint16 Class = 0x8;
		uint16 Next = 0x20;
		uint16 Name = 0x28;
	} FField;
	struct {
		uint16 ArrayDim = 0x38;
		uint16 ElementSize = 0x3C;
		uint16 PropertyFlags = 0x40;
		uint16 Offset = 0x4C;
		uint16 Size = 0x78;
	} FProperty;
	struct {
		uint16 ArrayDim = 0;
		uint16 ElementSize = 0;
		uint16 PropertyFlags = 0;
		uint16 Offset = 0;
		uint16 Size = 0; // sizeof(UProperty)
	} UProperty;
} Scavengers;
static_assert(sizeof(Scavengers) == sizeof(Offsets));

struct {
	uint16 Stride = 2;
	struct {
		uint16 Size = 32;
	} FUObjectItem;
	struct {
		uint16 Number = 4;
	} FName;
	struct {
		uint16 Info = 0;
		uint16 WideBit = 0;
		uint16 LenBit = 6;
		uint16 HeaderSize = 2;
	} FNameEntry;
	struct {
		uint16 Index = 0xC;
		uint16 Class = 0x10;
		uint16 Name = 0x18;
		uint16 Outer = 0x20;
	} UObject;
	struct {
		uint16 Next = 0x28;
	} UField;
	struct {
		uint16 SuperStruct = 0x40;
		uint16 Children = 0x48;
		uint16 ChildProperties = 0x50;
		uint16 PropertiesSize = 0x58;
	} UStruct;
	struct {
		uint16 Names = 0x40;
	} UEnum;
	struct {
		uint16 FunctionFlags = 0xB0;
		uint16 Func = 0xB0 + 0x28;
	} UFunction;
	struct {
		uint16 Class = 0x8;
		uint16 Next = 0x20;
		uint16 Name = 0x28;
	} FField;
	struct {
		uint16 ArrayDim = 0x38;
		uint16 ElementSize = 0x3C;
		uint16 PropertyFlags = 0x40;
		uint16 Offset = 0x4C;
		uint16 Size = 0x78;
	} FProperty;
	struct {
		uint16 ArrayDim = 0;
		uint16 ElementSize = 0;
		uint16 PropertyFlags = 0;
		uint16 Offset = 0;
		uint16 Size = 0; // sizeof(UProperty)
	} UProperty;
} Brickadia;
static_assert(sizeof(Brickadia) == sizeof(Offsets));

struct {
	uint16 Stride = 4;
	struct {
		uint16 Size = 24;
	} FUObjectItem;
	struct {
		uint16 Number = 8;
	} FName;
	struct {
		uint16 Info = 4;
		uint16 WideBit = 0;
		uint16 LenBit = 1;
		uint16 HeaderSize = 6;
	} FNameEntry;
	struct {
		uint16 Index = 0xC;
		uint16 Class = 0x10;
		uint16 Name = 0x18;
		uint16 Outer = 0x28;
	} UObject;
	struct {
		uint16 Next = 0x30;
	} UField;
	struct {
		uint16 SuperStruct = 0x48;
		uint16 Children = 0x50;
		uint16 ChildProperties = 0x58;
		uint16 PropertiesSize = 0x60;
	} UStruct;
	struct {
		uint16 Names = 0x48;
	} UEnum;
	struct {
		uint16 FunctionFlags = 0xB8;
		uint16 Func = 0xB8 + 0x28;
	} UFunction;
	struct {
		uint16 Class = 0x8;
		uint16 Next = 0x20;
		uint16 Name = 0x28;
	} FField;
	struct {
		uint16 ArrayDim = 0x38;
		uint16 ElementSize = 0x3C;
		uint16 PropertyFlags = 0x40;
		uint16 Offset = 0x4C;
		uint16 Size = 0x80;
	} FProperty;
	struct {
		uint16 ArrayDim = 0;
		uint16 ElementSize = 0;
		uint16 PropertyFlags = 0;
		uint16 Offset = 0;
		uint16 Size = 0; // sizeof(UProperty)
	} UProperty;
} Core;
static_assert(sizeof(Core) == sizeof(Offsets));

struct {
	uint16 Stride = 2;
	struct {
		uint16 Size = 24;
	} FUObjectItem;
	struct {
		uint16 Number = 4;
	} FName;
	struct {
		uint16 Info = 0;
		uint16 WideBit = 0;
		uint16 LenBit = 6;
		uint16 HeaderSize = 2;
	} FNameEntry;
	struct {
		uint16 Index = 0xC;
		uint16 Class = 0x10;
		uint16 Name = 0x18;
		uint16 Outer = 0x20;
	} UObject;
	struct {
		uint16 Next = 0x28;
	} UField;
	struct {
		uint16 SuperStruct = 0x40;
		uint16 Children = 0x48;
		uint16 ChildProperties = 0x50;
		uint16 PropertiesSize = 0x58;
	} UStruct;
	struct {
		uint16 Names = 0x40;
	} UEnum;
	struct {
		uint16 FunctionFlags = 0xB0;
		uint16 Func = 0xB0 + 0x28;
	} UFunction;
	struct {
		uint16 Class = 0x8;
		uint16 Next = 0x20;
		uint16 Name = 0x28;
	} FField;
	struct {
		uint16 ArrayDim = 0x38;
		uint16 ElementSize = 0x3C;
		uint16 PropertyFlags = 0x40;
		uint16 Offset = 0x4C;
		uint16 Size = 0x78;
	} FProperty;
	struct {
		uint16 ArrayDim = 0x38;
		uint16 ElementSize = 0x3C;
		uint16 PropertyFlags = 0x40;
		uint16 Offset = 0x4C;
		uint16 Size = 0x78; // sizeof(UProperty)
	} UProperty;
} Calabiyau;
static_assert(sizeof(Calabiyau) == sizeof(Offsets));
struct {
	uint16 Stride = 4;
	struct {
		uint16 Size = 24;
	} FUObjectItem;
	struct {
		uint16 Number = 8;
	} FName;
	struct {
		uint16 Info = 4;
		uint16 WideBit = 0;
		uint16 LenBit = 1;
		uint16 HeaderSize = 6;
	} FNameEntry;
	struct {
		uint16 Index = 0xC;
		uint16 Class = 0x10;
		uint16 Name = 0x18;
		uint16 Outer = 0x28;
	} UObject;
	struct {
		uint16 Next = 0x30;
	} UField;
	struct {
		uint16 SuperStruct = 0x48;
		uint16 Children = 0x50;
		uint16 ChildProperties = 0x58;
		uint16 PropertiesSize = 0x60;
	} UStruct;
	struct {
		uint16 Names = 0x48;
	} UEnum;
	struct {
		uint16 FunctionFlags = 0xB8;
		uint16 Func = 0xB8 + 0x28;
	} UFunction;
	struct {
		uint16 Class = 0x8;
		uint16 Next = 0x20;
		uint16 Name = 0x28;
	} FField;
	struct {
		uint16 ArrayDim = 0x38;
		uint16 ElementSize = 0x3C;
		uint16 PropertyFlags = 0x40;
		uint16 Offset = 0x4C;
		uint16 Size = 0x80;
	} FProperty;
	struct {
		uint16 ArrayDim = 0;
		uint16 ElementSize = 0;
		uint16 PropertyFlags = 0;
		uint16 Offset = 0;
		uint16 Size = 0; // sizeof(UProperty)
	} UProperty;
} MingChao;//鸣潮
static_assert(sizeof(MingChao) == sizeof(Offsets));
struct {
	void* offsets; // address to filled offsets structure
	std::pair<const char*, uint32> names; // NamePoolData signature
	std::pair<const char*, uint32> objects; // ObjObjects signature
	std::function<bool(void*, void*)> callback;
} engines[] = {
  { // RogueCompany | PropWitchHuntModule-Win64-Shipping | Scum
	&Default,
	{"\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\xC6\x05\x00\x00\x00\x00\x01\x0F\x10\x03\x4C\x8D\x44\x24\x20\x48\x8B\xC8", 30},
	{"\x48\x8B\x05\x00\x00\x00\x00\x48\x8B\x0C\xC8\x48\x8D\x04\xD1\xEB", 16},
	nullptr
  },
  { // Scavenger-Win64-Shipping
	&Scavengers,
	{"\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\xC6\x05\x00\x00\x00\x00\x01\x0F\x10\x03\x4C\x8D\x44\x24\x20\x48\x8B\xC8", 30},
	{"\x48\x8B\x05\x00\x00\x00\x00\x48\x8B\x0C\xC8\x48\x8D\x04\xD1\xEB", 16},
	nullptr
  },
  { // DeadByDaylight-Win64-Shipping
	&DeadByDaylight,
	{"\x48\x8D\x35\x00\x00\x00\x00\xEB\x16", 9},
	{"\x48\x8B\x05\x00\x00\x00\x00\x48\x8B\x0C\xC8\x48\x8D\x04\xD1\xEB", 16},
	nullptr
  },
  { // Brickadia-Win64-Shipping
	&Brickadia,
	{"\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\xC6\x05\x00\x00\x00\x00\x00\x85", 20},
	{"\x48\x8B\x05\x00\x00\x00\x00\x48\x63\x8C\x24\xE0", 12},
	nullptr
  },
  { // POLYGON-Win64-Shipping
	&Default,
	{"\x48\x8D\x35\x00\x00\x00\x00\xEB\x16", 9},
	{"\x48\x8d\x1d\x00\x00\x00\x00\x39\x44\x24\x68", 11},
	nullptr
  },
  { // FortniteClient-Win64-Shipping
	&Default,
	{"\x4C\x8D\x35\x00\x00\x00\x00\x0F\x10\x07\x83\xFB\x01", 13},
	{"\x48\x8B\x05\x00\x00\x00\x00\x48\x8B\x0C\xC8\x48\x8D\x04\xD1\xEB", 16},
	[](void* start, void* end) {
	  if (!Decrypt_ANSI) {
		auto decryptAnsi = FindPointer(start, end, "\xE8\x00\x00\x00\x00\x0F\xB7\x3F\x33\xF6\xC1\xEF\x06\x48\x89\x33\x48\x89\x73\x08\x85\xFF\x0F\x84\x00\x00\x00\x00\x40\x00\x00\x00\x00", 33);
		if (decryptAnsi) {
			/*
			mov [rsp +8], rbx
			push rdi
			sub rsp, 0x20
			mov ebx, edx
			mov rdi, rcx
			mov rax, 0xDEADBEEFDEADBEEF
			jmp rax
			*/
			uint8 trampoline[] = { 0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x89, 0xD3, 0x48, 0x89, 0xCF, 0x48, 0xB8, 0xEF, 0xBE, 0xAD, 0xDE, 0xEF, 0xBE, 0xAD, 0xDE, 0xFF, 0xE0 };
			*(uint64*)(trampoline + 17) = (uint64)((uint8*)decryptAnsi + 0x4A); // https://i.imgur.com/zWtMDar.png
			Decrypt_ANSI = (ansi_fn)VirtualAlloc(0, sizeof(trampoline), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
			if (Decrypt_ANSI) {
			  memcpy((void*)Decrypt_ANSI, trampoline, sizeof(trampoline));
			  return true;
			}
		  }
		}
		return false;
	  }
	},
	{ // TheIsleClient-Win64-Shipping
	  &Default,
	  {"\x48\x8D\x05\x00\x00\x00\x00\xEB\x13", 9},
	  {"\x48\x8B\x05\x00\x00\x00\x00\x48\x8B\x0C\xC8\x48\x8D\x04\xD1\xEB\x03", 17},
	  nullptr
	},
	{ // PortalWars-Win64-Shipping
	  &Default,
	  {"\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\xC6\x05\x00\x00\x00\x00\x01\x0F\x10\x03\x4C\x8D\x44\x24\x20\x48\x8B\xC8", 30},
	  {"\x48\x8B\x05\x00\x00\x00\x00\x48\x8B\x0C\xC8\x48\x8D\x1C\xD1\xEB\x03\x49\x8B\xDD", 20},
	  nullptr
	},
	{ // Tiger-Win64-Shipping.exe
	  &Default,
	  {"\x48\x8D\x35\x00\x00\x00\x00\xEB\x16", 9},
	  {"\x48\x8d\x1d\x00\x00\x00\x00\x39\x44\x24\x68", 11},
	  nullptr
	},
	{ // Platform-Win64-Shipping.exe
	  &Core,
	  {"\x48\x8D\x35\x00\x00\x00\x00\xEB\x16", 9},
	  {"\x48\x8d\x1d\x00\x00\x00\x00\x39\x44\x24\x68", 11},
	  nullptr
	},
	{//Beached-Win64-Test.exe
	 &Default,
	 {"\x48\x8D\x0D\x00\x00\x00\x00\xE8\xC6\x05\x00\x00\x00\x00\x0F\x10\x03\x4C\x8D\x44\x24\x20\x48\x8B\xC8",30},
	 {"\x48\x8B\x05\x00\x00\x00\x00\xC1\xF9\x10\x48\x63\xC9\x48\x8B\x14\xC8\x4B\x8D\x0C\x40\x4C\x8D\x04\xCA\xEB\x03",27},
	 nullptr
	},
	{//PromodClient-Win64-Shipping.exe
	 &Default,
	 {"\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\xC6\x05\x00\x00\x00\x00\x01\x0F\x10\x03\x4C\x8D\x44\x24\x20\x48\x8B\xC8",30},
	 {"\x48\x8B\x15\x00\x00\x00\x00\x0F\x1F\x44\x00\x00",12},
	 nullptr
	},
	{//Dauntless-Win64-Shipping.exe
	 &Default,
	  {"\x48\x8d\x0d\x00\x00\x00\x00\xe8\x00\x00\x00\x00\xc6\x05\x00\x00\x00\x00\x00\x0f\x10\x03", 22}, //GName
	  {"\x48\x8B\x05\x00\x00\x00\x00\xC1\xF9", 9},//Gobject 
	  nullptr
	},
	{//SquadGame.exe
	 &Squad,
	  {"\x4C\x8D\x05\x00\x00\x00\x00\xEB\x16\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00", 22}, //GName
	  {"\x48\x8D\x1D\x00\x00\x00\x00\x8B\x05\x00\x00\x00\x00\x39\x45\x88\x7C\x20\x48\x8D\x45\x88\x48\x89\x85\x90\x05\x00\x00", 30}, //Gobject 
	  nullptr
	},
	{ // Calabiyau | Seria
	  &Default,
	  {"\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\xC6\x05\x00\x00\x00\x00\x01\x0F\x10\x03\x4C\x8D\x44\x24\x20\x48\x8B\xC8", 30},
	  {"\x48\x8B\x05\x00\x00\x00\x00\x48\x8B\x0C\xC8\x48\x8D\x04\xD1\xEB", 16},
	  nullptr
	},
	{ // 玩鸣潮超大逼，小时候dump鸣潮完一直超批精尽人亡了
		&MingChao,
		{ "\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\xD0\xC6\x05\x00\x00\x00\x00\x01", 22 },//GName
		{ "\x48\x8B\x05\x00\x00\x00\x00\x48\x8B\x0C\xC8\x48\x8D\x04\xD1\xEB", 16 },//Gobject 
			nullptr
	}
};

std::unordered_map<std::string, decltype(&engines[0])> games = {
  {"RogueCompany", &engines[0]},
  {"SCUM", &engines[0]},
  {"PropWitchHuntModule-Win64-Shipping", &engines[0]},
  {"HLL-Win64-Shipping", &engines[0]},
  {"Scavenger-Win64-Shipping", &engines[1]},
  {"DeadByDaylight-Win64-Shipping", &engines[2]},
  {"Brickadia-Win64-Shipping", &engines[3]},
  {"POLYGON-Win64-Shipping", &engines[4]},
  {"FortniteClient-Win64-Shipping", &engines[5]},
  {"TheIsleClient-Win64-Shipping", &engines[6]},
  {"PortalWars-Win64-Shipping", &engines[7]},
  {"Tiger-Win64-Shipping", &engines[0]},
  {"Platform-Win64-Shipping", &engines[9]},
  {"Beached-Win64-Test",&engines[0]},
  {"PromodClient-Win64-Shipping",&engines[0]},
  {"Dauntless-Win64-Shipping",&engines[12]},
  {"ProjectBoundarySteam-Win64-Shipping",&engines[0]},
  {"Prospect-Win64-Shipping",&engines[0]},
  {"SquadGame", &engines[13]},
  {"Calabiyau-Win64-Shipping", &engines[14]},
  {"Seria", &engines[14]},
  {"Game", &engines[14]},
  {"Client-Win64-Shipping",&engines[15]}
};

STATUS EngineInit(std::string game, void* image) {

	auto it = games.find(game);
	if (it == games.end()) { return STATUS::ENGINE_NOT_FOUND; }

	auto engine = it->second;
	offsets = *(Offsets*)(engine->offsets);

	void* names = nullptr;
	void* objects = nullptr;

	uint8 found = 0;
	if (!engine->callback) {
		found |= 4;
	}

	IterateExSections(
		image,
		[&](void* start, void* end)->bool {
			if (!(found & 1)) if (names = FindPointer(start, end, engine->names.first, engine->names.second)) found |= 1;
			if (!(found & 2)) if (objects = FindPointer(start, end, engine->objects.first, engine->objects.second)) found |= 2;
			if (!(found & 4)) if (engine->callback(start, end)) found |= 4;
			if (found == 7) return 1;
			return 0;
		}
	);

	if (found != 7) return STATUS::ENGINE_FAILED;

	NamePoolData = *(decltype(NamePoolData)*)names;
	ObjObjects = *(decltype(ObjObjects)*)objects;

	auto entry = UE_FNameEntry(NamePoolData.GetEntry(0));

	// exception handler exclusively for Decrypt_ANSI
	try {
		if (*(uint32*)entry.String().data() != 'enoN') return STATUS::ENGINE_FAILED;
	}
	catch (...) {
		return STATUS::ENGINE_FAILED;
	}

	return STATUS::SUCCESS;
}

```

`Dumper/engine.h`:

```h
#pragma once
#include "defs.h"
#include <string>
#include <vector>

struct Offsets {
  uint16 Stride = 0; // alignof(FNameEntry)
  struct {
    uint16 Size = 0;
  } FUObjectItem;
  struct {
    uint16 Number = 0;
  } FName;
  struct {
    uint16 Info =
        0; // Offset to Memory filled with info about type and size of string
    uint16 WideBit =
        0; // Offset to bit which shows if string uses wide characters
    uint16 LenBit = 0; // Offset to bit which has lenght of string
    uint16 HeaderSize =
        0; // Size of FNameEntry header (offset where a string begins)
  } FNameEntry;
  struct {
    uint16 Index = 0; // Offset to index of this object in all objects array
    uint16 Class = 0; // Offset to UClass pointer (UClass* ClassPrivate)
    uint16 Name = 0;  // Offset to FName structure
    uint16 Outer = 0; // (UObject* OuterPrivate)
  } UObject;
  struct {
    uint16 Next = 0;
  } UField;
  struct {
    uint16 SuperStruct = 0;
    uint16 Children = 0;
    uint16 ChildProperties = 0;
    uint16 PropertiesSize = 0;
  } UStruct;
  struct {
    uint16 Names = 0;
  } UEnum;
  struct {
    uint16 FunctionFlags = 0;
    uint16 Func = 0; // ue3-ue4, always +0x28 from flags location.
  } UFunction;
  struct {
    uint16 Class = 0;
    uint16 Next = 0;
    uint16 Name = 0;
  } FField;
  struct {
    uint16 ArrayDim = 0;
    uint16 ElementSize = 0;
    uint16 PropertyFlags = 0;
    uint16 Offset = 0;
    uint16 Size = 0; // sizeof(FProperty)
  } FProperty;
  struct {
    uint16 ArrayDim = 0;
    uint16 ElementSize = 0;
    uint16 PropertyFlags = 0;
    uint16 Offset = 0;
    uint16 Size = 0; // sizeof(UProperty)
  } UProperty;
};

extern Offsets offsets;

typedef int64(_fastcall* ansi_fn)(char* a1, int a2); // buf, len
// typedef int64(_fastcall*wide_fn)(wchar_t* a1, int a2);

extern ansi_fn Decrypt_ANSI;
// extern wide_fn Decrypt_WIDE;

STATUS EngineInit(std::string game, void* image);

```

`Dumper/engine_code.rc`:

```rc
#include "resource.h"

FOR_TEST_FILE TEXTFILE "engine_code\\fortest.txt"

BASICTYPES_PACKAGE TEXTFILE "engine_code\\BasicTypes_Package.h"

BASICTYPES_CLASSES TEXTFILE "engine_code\\BasicTypes_Classes.h"

BASICTYPES_STRUCT TEXTFILE "engine_code\\BasicTypes_Structs.h"

COREUOBJECT_PACKAGE TEXTFILE "engine_code\\CoreUObject_Package.h"

COREUOBJECT_CLASSES TEXTFILE "engine_code\\CoreUObject_Classes.h"

COREUOBJECT_STRUCT TEXTFILE "engine_code\\CoreUObject_Structs.h"

COREUOBJECT_CPP TEXTFILE "engine_code\\CoreUObject_Package.cpp"

BASICTYPES_CPP TEXTFILE "engine_code\\BasicTypes_Package.cpp"

COREUOBJECT_PARAM TEXTFILE "engine_code\\CoreUObject_Params.h"

GLOBAL_OFFSET TEXTFILE "engine_code\\GlobalOffset.h"

INJECTED_GETBONEWORLDPOS TEXTFILE "engine_code\\Injected_GetBoneWorldPos.cpp"



```

`Dumper/engine_code/BasicTypes_Classes.h`:

```h
#pragma once

/**
 * Name: VAR_GAME_NAME
 * Version: VAR_GAME_VERSION
 */

#ifdef _MSC_VER
	#pragma pack(push, 0x01)
#endif

namespace VAR_NAMESPACE
{
	// --------------------------------------------------
	// # Classes
	// --------------------------------------------------
	/**
	 * PredefinedClass BasicTypes.TArray
	 * Size -> 0x0000
	 */
	template<typename T>
	class TArray
	{
	private:
		T*                                                         _data;                                                   // 0x0000(0x0000)
		int32_t                                                    _count;                                                  // 0x0000(0x0000)
		int32_t                                                    _max;                                                    // 0x0000(0x0000)

		friend class FString;
	public:
		TArray()
		{
			_data = nullptr;
			_count = 0;
			_max = 0;
		}

		T* Data() const
		{
			return _data;
		}

		int32_t Count() const
		{
			return _count;
		}

		int32_t Max() const
		{
			return _max;
		}

		bool IsValidIndex(int32_t i) const
		{
			return i < _count;
		}

		T& operator[](int32_t i)
		{
			return _data[i];
		}

		const T& operator[](int32_t i) const
		{
			return _data[i];
		}

	};

	/**
	 * PredefinedClass BasicTypes.FString
	 * Size -> 0x0000
	 */
	class FString : public TArray<wchar_t>
	{
	public:
		FString();
		FString(const wchar_t* other);
		const wchar_t* wc_str() const;
		const char* c_str() const;
		bool IsValid() const;
		std::string ToString() const;
		std::wstring ToStringW() const;
	};

	/**
	 * PredefinedClass BasicTypes.FUObjectItem
	 * Size -> 0x0000
	 */
	class FUObjectItem
	{
	public:
		class UObject*                                             Object;                                                  // 0x0000(0x0008)
		int32_t                                                    Flags;                                                   // 0x0008(0x0004)
		int32_t                                                    ClusterIndex;                                            // 0x000C(0x0004)
		int32_t                                                    SerialNumber;                                            // 0x0010(0x0004)
		unsigned char                                              pad_3O6WJCU9AC[0x04];                                    // 0x0014(0x0004)

	public:
		bool IsUnreachable() const;
		bool IsPendingKill() const;
	};

	/**
	 * PredefinedClass BasicTypes.TUObjectArray
	 * Size -> 0x0000
	 */
	class TUObjectArray
	{
	private:
		static const constexpr int32_t                             NumElementsPerChunk = 64 * 1024;                         // 0x0000(0x0000)
		FUObjectItem**                                             Objects;                                                 // 0x0000(0x0000)
		FUObjectItem*                                              PreAllocatedObjects;                                     // 0x0000(0x0000)
	public:
		int32_t                                                    MaxElements;                                             // 0x0000(0x0000)
		int32_t                                                    NumElements;                                             // 0x0000(0x0000)
		int32_t                                                    MaxChunks;                                               // 0x0000(0x0000)
		int32_t                                                    NumChunks;                                               // 0x0000(0x0000)

	public:
		int32_t Count() const;
		int32_t Max() const;
		bool IsValidIndex(int32_t Index) const;
		FUObjectItem* GetObjectPtr(int32_t Index) const;
		UObject* GetByIndex(int32_t index) const;
		FUObjectItem* GetItemByIndex(int32_t index) const;
		UObject* operator[](int32_t i);
		const UObject* operator[](int32_t i) const;
	};

	/**
	 * PredefinedClass BasicTypes.FNameEntryHeader
	 * Size -> 0x0000
	 */
	class FNameEntryHeader
	{
	public:
		static const constexpr uint32_t                            ProbeHashBits = 5;                                       // 0x0000(0x0000)
		uint16_t                                                   bIsWide : 1;                                             // 0x0000(0x0000)
		uint16_t                                                   LowercaseProbeHash : ProbeHashBits;                      // 0x0000(0x0000)
		uint16_t                                                   Len : 10;                                                // 0x0000(0x0000)
	};

	/**
	 * PredefinedClass BasicTypes.FNameEntry
	 * Size -> 0x0000
	 */
	class FNameEntry
	{
	public:
		FNameEntryHeader                                           Header;                                                  // 0x0000(0x0000)
		union
		{
			char                                                      AnsiName[1024];                                          // 0x0000(0x0000)
			wchar_t                                                   WideName[1024];                                          // 0x0000(0x0000)
		};

	public:
		int32_t GetLength() const;
		bool IsWide() const;
		int32_t GetId() const;
		std::string GetAnsiName() const;
		std::wstring GetWideName() const;
		std::string GetName() const;
	};

	/**
	 * PredefinedClass BasicTypes.FNameEntryAllocator
	 * Size -> 0x0000
	 */
	class FNameEntryAllocator
	{
	private:
		uint8_t                                                    FrwLock[0x8];                                            // 0x0000(0x0000)
	public:
		static const constexpr int32_t                             Stride = 0x02;                                           // 0x0000(0x0000)
		static const constexpr int32_t                             MaxOffset = Stride * (1 << 16);                          // 0x0000(0x0000)
		int32_t                                                    CurrentBlock;                                            // 0x0000(0x0000)
		int32_t                                                    CurrentByteCursor;                                       // 0x0000(0x0000)
		uint8_t*                                                   Blocks[8192];                                            // 0x0000(0x0000)

	public:
		int32_t NumBlocks() const;
		FNameEntry* GetById(int32_t key) const;
		bool IsValidIndex(int32_t key) const;
		bool IsValidIndex(int32_t key, uint32_t block, uint16_t offset) const;
	};

	/**
	 * PredefinedClass BasicTypes.FNamePool
	 * Size -> 0x0000
	 */
	class FNamePool
	{
	public:
		FNameEntryAllocator                                        Allocator;                                               // 0x0000(0x0000)
		int32_t                                                    AnsiCount;                                               // 0x0000(0x0000)
		int32_t                                                    WideCount;                                               // 0x0000(0x0000)

	public:
		FNameEntry* GetNext(uintptr_t& nextFNameAddress, uint32_t* comparisonId) const;
		int32_t Count() const;
		bool IsValidIndex(int32_t index) const;
		FNameEntry* GetById(int32_t id) const;
		FNameEntry* operator[](int32_t id) const;
	};

	/**
	 * PredefinedClass BasicTypes.FName
	 * Size -> 0x0000
	 */
	class FName
	{
	public:
		static FNamePool*                                          GNames;                                                  // 0x0000(0x0000)
		int32_t                                                    ComparisonIndex;                                         // 0x0000(0x0000)
		int32_t                                                    Number;                                                  // 0x0000(0x0000)

	public:
		FName();
		FName(int32_t i);
		FName(const char* nameToFind);
		FName(const wchar_t* nameToFind);
		static FNamePool& GetGlobalNames();
		std::string GetNameA() const;
		std::wstring GetNameW() const;
		std::string GetName() const;
	};

	/**
	 * PredefinedClass BasicTypes.TEnumAsByte
	 * Size -> 0x0000
	 */
	template<class TEnum>
	class TEnumAsByte
	{
	private:
		uint8_t                                                    _value;                                                  // 0x0000(0x0000)

	public:
		TEnumAsByte()
		{

		}

		TEnumAsByte(TEnum value)
		{
			_value = static_cast<uint8_t>(value);
		}

		TEnumAsByte(int32_t value)
		{
			_value = static_cast<uint8_t>(value);
		}

		TEnumAsByte(uint8_t value)
		{
			_value = value;
		}

		operator TEnum() const
		{
			return (TEnum)_value;
		}

		TEnum GetValue() const
		{
			return (TEnum)_value;
		}

	};

	/**
	 * PredefinedClass BasicTypes.FScriptInterface
	 * Size -> 0x0000
	 */
	class FScriptInterface
	{
	private:
		UObject*                                                   ObjectPointer;                                           // 0x0000(0x0000)
		void*                                                      InterfacePointer;                                        // 0x0000(0x0000)

	public:
		UObject* GetObjectPtr() const;
		UObject*& GetObjectRef();
		void* GetInterface() const;
	};

	/**
	 * PredefinedClass BasicTypes.TScriptInterface
	 * Size -> 0x0000
	 */
	template<class InterfaceType>
	class TScriptInterface : public FScriptInterface
	{
	public:
		InterfaceType* operator->() const
		{
			return (InterfaceType*)GetInterface();
		}

		InterfaceType& operator*() const
		{
			return *((InterfaceType*)GetInterface());
		}

		operator bool() const
		{
			return GetInterface() != nullptr;
		}

	};

	/**
	 * PredefinedClass BasicTypes.FTextData
	 * Size -> 0x0000
	 */
	class FTextData
	{
	private:
		uint8_t                                                    UnknownData[0x28];                                       // 0x0000(0x0000)
	public:
		wchar_t*                                                   Name;                                                    // 0x0000(0x0000)
		int32_t*                                                   Length;                                                  // 0x0000(0x0000)
	};

	/**
	 * PredefinedClass BasicTypes.FText
	 * Size -> 0x0000
	 */
	class FText
	{
	private:
		FTextData*                                                 Data;                                                    // 0x0000(0x0000)
		uint8_t                                                    UnknownData[0x10];                                       // 0x0000(0x0000)

	public:
		wchar_t* Get() const;
		std::string ToString() const;
		std::wstring ToWString() const;
	};

	/**
	 * PredefinedClass BasicTypes.FScriptDelegate
	 * Size -> 0x0000
	 */
	class FScriptDelegate
	{
	private:
		uint8_t                                                    UnknownData[0x10];                                       // 0x0000(0x0000)
	};

	/**
	 * PredefinedClass BasicTypes.FScriptMulticastDelegate
	 * Size -> 0x0000
	 */
	class FScriptMulticastDelegate
	{
	private:
		uint8_t                                                    UnknownData[0x10];                                       // 0x0000(0x0000)
	};

	/**
	 * PredefinedClass BasicTypes.FMulticastSparseDelegate
	 * Size -> 0x0000
	 */
	class FMulticastSparseDelegate
	{
	private:
		uint8_t                                                    UnknownData[0x01];                                       // 0x0000(0x0000)
	};

	#ifdef _MSC_VER
		#pragma pack(pop)
	#endif	/**
	 * PredefinedClass BasicTypes.TPair
	 * Size -> 0x0000
	 */
	template<typename KeyType, typename ValueType>
	class TPair
	{
	public:
		KeyType                                                    First;                                                   // 0x0000(0x0000)
		ValueType                                                  Second;                                                  // 0x0000(0x0000)
	};
	#ifdef _MSC_VER
		#pragma pack(push, 0x01)
	#endif
	#ifdef _MSC_VER
		#pragma pack(pop)
	#endif	/**
	 * PredefinedClass BasicTypes.TSetElement
	 * Size -> 0x0000
	 */
	template<typename ElementType>
	class TSetElement
	{
	public:
		ElementType                                                Value;                                                   // 0x0000(0x0000)
		int32_t                                                    HashNextId;                                              // 0x0000(0x0000)
		int32_t                                                    HashIndex;                                               // 0x0000(0x0000)
	};
	#ifdef _MSC_VER
		#pragma pack(push, 0x01)
	#endif
	/**
	 * PredefinedClass BasicTypes.TMap
	 * Size -> 0x0000
	 */
	template<typename Key, typename Value>
	class TMap
	{
	public:
		TArray<TSetElement<TPair<Key, Value>>>                     Data;                                                    // 0x0000(0x0000)
	private:
		uint8_t                                                    UnknownData01[0x04];                                     // 0x0000(0x0000)
		uint8_t                                                    UnknownData02[0x04];                                     // 0x0000(0x0000)
		uint8_t                                                    UnknownData03[0x08];                                     // 0x0000(0x0000)
		uint8_t                                                    UnknownData04[0x08];                                     // 0x0000(0x0000)
		uint8_t                                                    UnknownData_MayBeSize[0x04];                             // 0x0000(0x0000)
		uint8_t                                                    UnknownData_MayBeFlag[0x04];                             // 0x0000(0x0000)
		uint8_t                                                    UnknownData05[0x08];                                     // 0x0000(0x0000)
		uint8_t                                                    UnknownData06[0x08];                                     // 0x0000(0x0000)
		uint8_t                                                    UnknownData07[0x08];                                     // 0x0000(0x0000)
		uint8_t                                                    UnknownData_MayBeSize02[0x04];                           // 0x0000(0x0000)
		uint8_t                                                    UnknownData08[0x04];                                     // 0x0000(0x0000)
	};

	/**
	 * PredefinedClass BasicTypes.FStringAssetReference_
	 * Size -> 0x0000
	 */
	class FStringAssetReference_
	{
	private:
		uint8_t                                                    UnknownData[0x10];                                       // 0x0000(0x0000)
	};

	/**
	 * PredefinedClass BasicTypes.FUniqueObjectGuid_
	 * Size -> 0x0000
	 */
	class FUniqueObjectGuid_
	{
	private:
		uint8_t                                                    UnknownData[0x10];                                       // 0x0000(0x0000)
	};

	/**
	 * PredefinedClass BasicTypes.FStructBaseChain
	 * Size -> 0x0000
	 */
	class FStructBaseChain
	{
	private:
		FStructBaseChain**                                         StructBaseChainArray;                                    // 0x0000(0x0000)
		int32_t                                                    NumStructBasesInChainMinusOne;                           // 0x0000(0x0000)
		uint8_t                                                    Padding_0[0x04];                                         // 0x0000(0x0000)
	};

	/**
	 * PredefinedClass BasicTypes.FWeakObjectPtr
	 * Size -> 0x0000
	 */
	class FWeakObjectPtr
	{
	public:
		int32_t                                                    ObjectIndex;                                             // 0x0000(0x0000)
		int32_t                                                    ObjectSerialNumber;                                      // 0x0000(0x0000)

	public:
		bool SerialNumbersMatch(FUObjectItem* objectItem) const;
		bool IsValid() const;
		UObject* Get() const;
	};

	/**
	 * PredefinedClass BasicTypes.TWeakObjectPtr
	 * Size -> 0x0000
	 */
	template<class T, class TWeakObjectPtrBase = FWeakObjectPtr>
	class TWeakObjectPtr : public TWeakObjectPtrBase
	{
	public:
		T* Get() const
		{
			return (T*)TWeakObjectPtrBase::Get();
		}

		T& operator*() const
		{
			return *Get();
		}

		T* operator->() const
		{
			return Get();
		}

		bool IsValid()
		{
			return TWeakObjectPtrBase::IsValid();
		}

	};

	/**
	 * PredefinedClass BasicTypes.TAutoPointer
	 * Size -> 0x0000
	 */
	template<class T, class TBase>
	class TAutoPointer : public TBase
	{
	public:
		operator T*() const
		{
			return TBase::Get();
		}

		operator const T*() const
		{
			return (const T*)TBase::Get();
		}

		operator bool() const
		{
			return TBase::Get() != nullptr;
		}

	};

	/**
	 * PredefinedClass BasicTypes.TAutoWeakObjectPtr
	 * Size -> 0x0000
	 */
	template<class T>
	class TAutoWeakObjectPtr : public TAutoPointer<T, TWeakObjectPtr<T>>
	{
		friend class FString;	};

	/**
	 * PredefinedClass BasicTypes.TPersistentObjectPtr
	 * Size -> 0x0000
	 */
	template<typename TObjectID>
	class TPersistentObjectPtr
	{
	public:
		FWeakObjectPtr                                             WeakPtr;                                                 // 0x0000(0x0000)
		int32_t                                                    TagAtLastTest;                                           // 0x0000(0x0000)
		TObjectID                                                  ObjectID;                                                // 0x0000(0x0000)
	};

	/**
	 * PredefinedClass BasicTypes.FLazyObjectPtr
	 * Size -> 0x0000
	 */
	class FLazyObjectPtr : public TPersistentObjectPtr<FUniqueObjectGuid_>
	{	};

	/**
	 * PredefinedClass BasicTypes.FAssetPtr
	 * Size -> 0x0000
	 */
	class FAssetPtr : public TPersistentObjectPtr<FStringAssetReference_>
	{	};

	/**
	 * PredefinedClass BasicTypes.TAssetPtr
	 * Size -> 0x0000
	 */
	template<typename ObjectType>
	class TAssetPtr : public FAssetPtr
	{	};

	/**
	 * PredefinedClass BasicTypes.TLazyObjectPtr
	 * Size -> 0x0000
	 */
	template<typename ObjectType>
	class TLazyObjectPtr : public FLazyObjectPtr
	{	};

	/**
	 * PredefinedClass BasicTypes.ObjectNames
	 * Size -> 0x0000
	 */
	class ObjectNames
	{	};

}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif

```

`Dumper/engine_code/BasicTypes_Package.cpp`:

```cpp
/**
 * Name: VAR_GAME_NAME
 * Version: VAR_GAME_VERSION
 */

#include "../SDK.h"

namespace VAR_NAMESPACE
{
	// --------------------------------------------------
	// # Structs Static Fields
	// --------------------------------------------------
	FNamePool*                                                  FName::GNames = nullptr;                                 // 0x0000(0x0000)

	// --------------------------------------------------
	// # Global functions
	// --------------------------------------------------
	/**
	 * Initialize SDK
	 */
	bool InitSdk(const std::wstring& moduleName, uintptr_t gObjectsOffset, uintptr_t gNamesOffset, uintptr_t gWorldOffset)
	{
		auto mBaseAddress = reinterpret_cast<uintptr_t>(GetModuleHandleW(moduleName.c_str()));
		if (!mBaseAddress)
			return false;
		
		UObject::GObjects = reinterpret_cast<VAR_NAMESPACE::TUObjectArray*>(mBaseAddress + gObjectsOffset);
		FName::GNames = reinterpret_cast<VAR_NAMESPACE::FNamePool*>(mBaseAddress + gNamesOffset);
		UWorld::GWorld = reinterpret_cast<VAR_NAMESPACE::UWorld**>(mBaseAddress + gWorldOffset);
		
		return true;
	}
	
	/**
	 * Initialize SDK
	 */
	bool InitSdk()
	{
		return InitSdk(L"VAR_GAME_NAME.exe", GOBJECT_OFFSET, GNAME_OFFSET, GWORLD_OFFSET);
	}

	// --------------------------------------------------
	// # Structs Functions
	// --------------------------------------------------
	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FString.FString
	 * 		Flags  -> ()
	 */
	FString::FString()
	{

	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FString.FString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const wchar_t*                                     other
	 */
	FString::FString(const wchar_t* other)
	{
		_max = _count = *other ? static_cast<int32_t>(std::wcslen(other)) + 1 : 0;
		if (_count)
			_data = const_cast<wchar_t*>(other);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FString.wc_str
	 * 		Flags  -> ()
	 */
	const wchar_t* FString::wc_str() const
	{
		return _data;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FString.c_str
	 * 		Flags  -> ()
	 */
	const char* FString::c_str() const
	{
		return (const char*)_data;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FString.IsValid
	 * 		Flags  -> ()
	 */
	bool FString::IsValid() const
	{
		return _data != nullptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FString.ToString
	 * 		Flags  -> ()
	 */
	std::string FString::ToString() const
	{
		size_t length = std::wcslen(_data);
		std::string str(length, '\0');
		std::use_facet<std::ctype<wchar_t>>(std::locale()).narrow(_data, _data + length, '?', &str[0]);
		return str;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FString.ToStringW
	 * 		Flags  -> ()
	 */
	std::wstring FString::ToStringW() const
	{
		std::wstring str(_data);
		return str;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FUObjectItem.IsUnreachable
	 * 		Flags  -> ()
	 */
	bool FUObjectItem::IsUnreachable() const
	{
		return !!(Flags & static_cast<std::underlying_type_t<ObjectFlags>>(ObjectFlags::Unreachable));
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FUObjectItem.IsPendingKill
	 * 		Flags  -> ()
	 */
	bool FUObjectItem::IsPendingKill() const
	{
		return !!(Flags & static_cast<std::underlying_type_t<ObjectFlags>>(ObjectFlags::PendingKill));
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.TUObjectArray.Count
	 * 		Flags  -> ()
	 */
	int32_t TUObjectArray::Count() const
	{
		return NumElements;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.TUObjectArray.Max
	 * 		Flags  -> ()
	 */
	int32_t TUObjectArray::Max() const
	{
		return MaxElements;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.TUObjectArray.IsValidIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index
	 */
	bool TUObjectArray::IsValidIndex(int32_t Index) const
	{
		return Index < Count() && Index >= 0;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.TUObjectArray.GetObjectPtr
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index
	 */
	FUObjectItem* TUObjectArray::GetObjectPtr(int32_t Index) const
	{
		const int32_t ChunkIndex = Index / NumElementsPerChunk;
		const int32_t WithinChunkIndex = Index % NumElementsPerChunk;
		if (!IsValidIndex(Index)) return nullptr;
		if (ChunkIndex > NumChunks) return nullptr;
		if (Index > MaxElements) return nullptr;
		FUObjectItem* Chunk = Objects[ChunkIndex];
		if (!Chunk) return nullptr;
		return Chunk + WithinChunkIndex;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.TUObjectArray.GetByIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            index
	 */
	UObject* TUObjectArray::GetByIndex(int32_t index) const
	{
		FUObjectItem* ItemPtr = GetObjectPtr(index);
		if (!ItemPtr) return nullptr;
		return (*ItemPtr).Object;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.TUObjectArray.GetItemByIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            index
	 */
	FUObjectItem* TUObjectArray::GetItemByIndex(int32_t index) const
	{
		FUObjectItem* ItemPtr = GetObjectPtr(index);
		if (!ItemPtr) return nullptr;
		return ItemPtr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.TUObjectArray.operator[]
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            i
	 */
	UObject* TUObjectArray::operator[](int32_t i)
	{
		return GetByIndex(i);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.TUObjectArray.operator[]
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            i
	 */
	const UObject* TUObjectArray::operator[](int32_t i) const
	{
		return GetByIndex(i);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNameEntry.GetLength
	 * 		Flags  -> ()
	 */
	int32_t FNameEntry::GetLength() const
	{
		return Header.Len;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNameEntry.IsWide
	 * 		Flags  -> ()
	 */
	bool FNameEntry::IsWide() const
	{
		return Header.bIsWide;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNameEntry.GetId
	 * 		Flags  -> ()
	 */
	int32_t FNameEntry::GetId() const
	{
		throw std::exception("This game doesn't use 'FNAME_POOL_WITH_CASE_PRESERVING_NAME' so 'ComparisonId' not stored in 'FNameEntry'");
	}

	std::string WideStringToUTF8(const wchar_t* wideString)
	{
		if (wideString == nullptr)
			return "";

		// 获取转换后的字符串长度（包括终止null字符）
		int utf8Length = WideCharToMultiByte(CP_UTF8, 0, wideString, -1, nullptr, 0, nullptr, nullptr);

		if (utf8Length == 0)
			return "";

		// 分配内存来保存转换后的UTF-8字符串
		char* utf8Buffer = new char[utf8Length];

		// 进行实际的转换
		WideCharToMultiByte(CP_UTF8, 0, wideString, -1, utf8Buffer, utf8Length, nullptr, nullptr);

		// 创建std::string并将转换后的UTF-8数据拷贝进去
		std::string utf8String(utf8Buffer);

		// 释放内存
		delete[] utf8Buffer;

		return utf8String;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNameEntry.GetAnsiName
	 * 		Flags  -> ()
	 */
	std::string FNameEntry::GetAnsiName() const
	{
		uint32_t len = GetLength();
		if (len > 1024) return "[Error: Overflow]";
		if (IsWide()) {
			wchar_t wbuf[1024]{};
			for (int i = 0; i < len; i++) {
				wbuf[i] = WideName[i];
			}
			return WideStringToUTF8(wbuf);
		}
		else {
			char buf[1024]{};
			for (int i = 0; i < len; i++) {
				buf[i] = AnsiName[i];
			}
			return std::string(buf);
		}
		return std::string((const char*)AnsiName, len);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNameEntry.GetWideName
	 * 		Flags  -> ()
	 */
	std::wstring FNameEntry::GetWideName() const
	{
		uint32_t len = GetLength();
		return std::wstring((const wchar_t*)WideName, len);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNameEntry.GetName
	 * 		Flags  -> ()
	 */
	std::string FNameEntry::GetName() const
	{
		return GetAnsiName();
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNameEntryAllocator.NumBlocks
	 * 		Flags  -> ()
	 */
	int32_t FNameEntryAllocator::NumBlocks() const
	{
		return CurrentBlock + 1;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNameEntryAllocator.GetById
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            key
	 */
	FNameEntry* FNameEntryAllocator::GetById(int32_t key) const
	{
		int block = key >> 16;
		int offset = (uint16_t)key;
		if (!IsValidIndex(key, block, offset))
			return reinterpret_cast<FNameEntry*>(Blocks[0] + 0); // "None"
		return reinterpret_cast<FNameEntry*>(Blocks[block] + ((uint64_t)offset * Stride));
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNameEntryAllocator.IsValidIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            key
	 */
	bool FNameEntryAllocator::IsValidIndex(int32_t key) const
	{
		uint32_t block = key >> 16;
		uint16_t offset = key;
		return IsValidIndex(key, block, offset);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNameEntryAllocator.IsValidIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            key
	 * 		uint32_t                                           block
	 * 		uint16_t                                           offset
	 */
	bool FNameEntryAllocator::IsValidIndex(int32_t key, uint32_t block, uint16_t offset) const
	{
		return (key >= 0 && block < static_cast<uint32_t>(NumBlocks()) && offset * Stride < MaxOffset);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNamePool.GetNext
	 * 		Flags  -> ()
	 * Parameters:
	 * 		uintptr_t&                                         nextFNameAddress
	 * 		uint32_t*                                          comparisonId
	 */
	FNameEntry* FNamePool::GetNext(uintptr_t& nextFNameAddress, uint32_t* comparisonId) const
	{
		static int lastBlock = 0;
		if (!nextFNameAddress)
		{
			lastBlock = 0;
			nextFNameAddress = reinterpret_cast<uintptr_t>(Allocator.Blocks[0]);
		}
		RePlay:
		int32_t nextFNameComparisonId = MAKELONG((uint16_t)((nextFNameAddress - reinterpret_cast<uintptr_t>(Allocator.Blocks[lastBlock])) / 2), (uint16_t)lastBlock);
		int32_t block = nextFNameComparisonId >> 16;
		int32_t offset = (uint16_t)nextFNameComparisonId;
		int32_t offsetFromBlock = static_cast<int32_t>(nextFNameAddress - reinterpret_cast<uintptr_t>(Allocator.Blocks[lastBlock]));
		
		// Get entry information
		const uintptr_t entryOffset = nextFNameAddress;
		const int toAdd = 0x00 + 0x02; // HeaderOffset + HeaderSize
		const uint16_t nameHeader = *reinterpret_cast<uint16_t*>(entryOffset);
		int nameLength = nameHeader >> 6;
		bool isWide = (nameHeader & 1) != 0;
		if (isWide)
			nameLength += nameLength;
		
		// if odd number (odd numbers are aligned with 0x00)
		if (!isWide && nameLength % 2 != 0)
			nameLength += 1;
		
		// Block end ?
		if (offsetFromBlock + toAdd + (nameLength * 2) >= 0xFFFF * FNameEntryAllocator::Stride || nameHeader == 0x00 || block == Allocator.CurrentBlock && offset >= Allocator.CurrentByteCursor)
		{
			nextFNameAddress = reinterpret_cast<uintptr_t>(Allocator.Blocks[++lastBlock]);
			goto RePlay;
		}
		
		// We hit last Name in last Block
		if (lastBlock > Allocator.CurrentBlock)
			return nullptr;
		
		// Get next name address
		nextFNameAddress = entryOffset + toAdd + nameLength;
		
		// Get name
		FNameEntry* ret = Allocator.GetById(nextFNameComparisonId);
		
		if (comparisonId)
			*comparisonId = nextFNameComparisonId;
		
		return ret;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNamePool.Count
	 * 		Flags  -> ()
	 */
	int32_t FNamePool::Count() const
	{
		return AnsiCount;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNamePool.IsValidIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            index
	 */
	bool FNamePool::IsValidIndex(int32_t index) const
	{
		return Allocator.IsValidIndex(static_cast<int32_t>(index));
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNamePool.GetById
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            id
	 */
	FNameEntry* FNamePool::GetById(int32_t id) const
	{
		return Allocator.GetById(id);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FNamePool.operator[]
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            id
	 */
	FNameEntry* FNamePool::operator[](int32_t id) const
	{
		return GetById(id);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FName.FName
	 * 		Flags  -> ()
	 */
	FName::FName()
	{
		ComparisonIndex = 0;
		Number = 0;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FName.FName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            i
	 */
	FName::FName(int32_t i)
	{
		ComparisonIndex = i;
		Number = 0;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FName.FName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const char*                                        nameToFind
	 */
	FName::FName(const char* nameToFind)
	{
		Number = 0;
		static std::unordered_set<int> cache;
		for (auto i : cache)
		{
			if (GetGlobalNames()[i]->GetAnsiName() == nameToFind)
			{
				ComparisonIndex = i;
				#ifdef FNAME_POOL_WITH_CASE_PRESERVING_NAME
				DisplayIndex = i;
				#endif
				return;
			}
		}
		
		#ifdef FNAME_POOL
		uintptr_t lastFNameAddress = NULL;
		uint32_t curComparisonId = 0;
		for (FNameEntry* name = GetGlobalNames().GetNext(lastFNameAddress, &curComparisonId); name != nullptr; name = GetGlobalNames().GetNext(lastFNameAddress, &curComparisonId))
		{
			if (name->GetAnsiName() == nameToFind)
			{
				cache.insert(curComparisonId);
				ComparisonIndex = curComparisonId;
				#ifdef FNAME_POOL_WITH_CASE_PRESERVING_NAME
				DisplayIndex = curComparisonId;
				#endif
				return;
			}
		}
		#else
		for (int32_t i = 0; i < GetGlobalNames().Count(); ++i)
		{
			if (GetGlobalNames()[i]->GetAnsiName() == nameToFind)
			{
				cache.insert(i);
				ComparisonIndex = i;
				return;
			}
		}
		#endif
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FName.FName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const wchar_t*                                     nameToFind
	 */
	FName::FName(const wchar_t* nameToFind)
	{
		Number = 0;
		static std::unordered_set<int> cache;
		for (auto i : cache)
		{
			if (GetGlobalNames()[i]->GetWideName() == nameToFind)
			{
				ComparisonIndex = i;
				#ifdef FNAME_POOL_WITH_CASE_PRESERVING_NAME
				DisplayIndex = i;
				#endif
				return;
			}
		}
		
		#ifdef FNAME_POOL
		uintptr_t lastFNameAddress = NULL;
		uint32_t curComparisonId = 0;
		for (FNameEntry* name = GetGlobalNames().GetNext(lastFNameAddress, &curComparisonId); name != nullptr; name = GetGlobalNames().GetNext(lastFNameAddress, &curComparisonId))
		{
			if (name->GetWideName() == nameToFind)
			{
				cache.insert(curComparisonId);
				ComparisonIndex = curComparisonId;
				#ifdef FNAME_POOL_WITH_CASE_PRESERVING_NAME
				DisplayIndex = curComparisonId;
				#endif
				return;
			}
		}
		#else
		for (int32_t i = 0; i < GetGlobalNames().Count(); ++i)
		{
			if (GetGlobalNames()[i]->GetWideName() == nameToFind)
			{
				cache.insert(i);
				ComparisonIndex = i;
				return;
			}
		}
		#endif
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FName.GetGlobalNames
	 * 		Flags  -> ()
	 */
	FNamePool& FName::GetGlobalNames()
	{
		return *GNames;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FName.GetNameA
	 * 		Flags  -> ()
	 */
	std::string FName::GetNameA() const
	{
		return GetGlobalNames()[ComparisonIndex]->GetAnsiName();
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FName.GetNameW
	 * 		Flags  -> ()
	 */
	std::wstring FName::GetNameW() const
	{
		return GetGlobalNames()[ComparisonIndex]->GetWideName();
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FName.GetName
	 * 		Flags  -> ()
	 */
	std::string FName::GetName() const
	{
		return GetNameA();
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FScriptInterface.GetObjectPtr
	 * 		Flags  -> ()
	 */
	UObject* FScriptInterface::GetObjectPtr() const
	{
		return ObjectPointer;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FScriptInterface.GetObjectRef
	 * 		Flags  -> ()
	 */
	UObject*& FScriptInterface::GetObjectRef()
	{
		return ObjectPointer;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FScriptInterface.GetInterface
	 * 		Flags  -> ()
	 */
	void* FScriptInterface::GetInterface() const
	{
		return ObjectPointer != nullptr ? InterfacePointer : nullptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FText.Get
	 * 		Flags  -> ()
	 */
	wchar_t* FText::Get() const
	{
		return Data != nullptr ? Data->Name : nullptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FText.ToString
	 * 		Flags  -> ()
	 */
	std::string FText::ToString() const
	{
		wchar_t* name = Get();
		if (!name)
		    return "NOT FOUND";
		
		size_t length = std::wcslen(name);
		std::string str(length, '\0');
		std::use_facet<std::ctype<wchar_t>>(std::locale()).narrow(name, name + length, '?', &str[0]);
		
		return str;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FText.ToWString
	 * 		Flags  -> ()
	 */
	std::wstring FText::ToWString() const
	{
		wchar_t* name = Get();
		if (!name)
		    return L"NOT FOUND";
		
		std::wstring str(name);
		return str;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FWeakObjectPtr.SerialNumbersMatch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		FUObjectItem*                                      objectItem
	 */
	bool FWeakObjectPtr::SerialNumbersMatch(FUObjectItem* objectItem) const
	{
		return objectItem->SerialNumber == ObjectSerialNumber;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FWeakObjectPtr.IsValid
	 * 		Flags  -> ()
	 */
	bool FWeakObjectPtr::IsValid() const
	{
		if (ObjectSerialNumber == 0 || ObjectIndex < 0)
			return false;
		
		auto ObjectItem = UObject::GetGlobalObjects().GetItemByIndex(ObjectIndex);
		if (!ObjectItem)
			return false;
		
		if (!SerialNumbersMatch(ObjectItem))
			return false;
		
		return !(ObjectItem->IsUnreachable() || ObjectItem->IsPendingKill());
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction BasicTypes.FWeakObjectPtr.Get
	 * 		Flags  -> ()
	 */
	UObject* FWeakObjectPtr::Get() const
	{
		if (!IsValid())
			return nullptr;
		
		auto ObjectItem = UObject::GetGlobalObjects().GetItemByIndex(ObjectIndex);
		if (!ObjectItem)
			return nullptr;
		
		return ObjectItem->Object;
	}

}



```

`Dumper/engine_code/BasicTypes_Package.h`:

```h
#pragma once

/**
 * Name: VAR_GAME_NAME
 * Version: VAR_GAME_VERSION
 */

#define UE4
#define FNAME_POOL
#define GOBJECTS_CHUNKS

#ifdef _MSC_VER
	#pragma pack(push, 0x01)
#endif

namespace VAR_NAMESPACE
{
	// --------------------------------------------------
	// # Forwards
	// --------------------------------------------------
	class UObject;

	// --------------------------------------------------
	// # Global functions
	// --------------------------------------------------
	bool InitSdk(const std::wstring& moduleName, uintptr_t gObjectsOffset, uintptr_t gNamesOffset, uintptr_t gWorldOffset);
	bool InitSdk();
	template<typename Fn>
	Fn GetVFunction(const void* instance, size_t index)
	{
		auto vtable = *static_cast<const void***>(const_cast<void*>(instance));
		return reinterpret_cast<Fn>(const_cast<void (*)>(vtable[index]));
	}

}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif

#include "BasicTypes_Structs.h"
#include "BasicTypes_Classes.h"


```

`Dumper/engine_code/BasicTypes_Structs.h`:

```h
#pragma once

/**
 * Name: VAR_GAME_NAME
 * Version: VAR_GAME_VERSION
 */

#ifdef _MSC_VER
	#pragma pack(push, 0x01)
#endif

namespace VAR_NAMESPACE
{
	// --------------------------------------------------
	// # Enums
	// --------------------------------------------------
	/**
	 * PredefinedEnum BasicTypes.ObjectFlags
	 */
	enum class ObjectFlags : int32_t
	{
		None              = 0,
		Native            = 1 << 25,
		Async             = 1 << 26,
		AsyncLoading      = 1 << 27,
		Unreachable       = 1 << 28,
		PendingKill       = 1 << 29,
		RootSet           = 1 << 30,
		NoStrongReference = 1 << 31
	};

}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif

```

`Dumper/engine_code/CoreUObject_Classes.h`:

```h
#pragma once

/**
 * Name: VAR_GAME_NAME
 * Version: VAR_GAME_VERSION
 */

#ifdef _MSC_VER
	#pragma pack(push, 0x01)
#endif

namespace VAR_NAMESPACE
{
	// --------------------------------------------------
	// # Classes
	// --------------------------------------------------
	/**
	 * Class CoreUObject.Object
	 * Size -> 0x0028
	 */
	class UObject
	{
	public:
		static class TUObjectArray*                                GObjects;                                                // 0x0000(0x0008) PREDEFINED PROPERTY
		void*                                                      VfTable;                                                 // 0x0000(0x0008) PRE-DEFINED PROPERTY
		int32_t                                                    Flags;                                                   // 0x0008(0x0004) PRE-DEFINED PROPERTY
		int32_t                                                    InternalIndex;                                           // 0x000C(0x0004) PRE-DEFINED PROPERTY
		class UClass*                                              Class;                                                   // 0x0010(0x0008) PRE-DEFINED PROPERTY
		FName                                                      Name;                                                    // 0x0018(0x0008) PRE-DEFINED PROPERTY
		class UObject*                                             Outer;                                                   // 0x0020(0x0008) PRE-DEFINED PROPERTY

	public:
		static TUObjectArray& GetGlobalObjects();
		std::string GetName() const;
		std::string GetFullName() const;
		template<typename T>
		static T* FindObject(const std::string& name)
		{
			for (int32_t i = 0; i < UObject::GetGlobalObjects().Count(); ++i)
			{
				auto object = UObject::GetGlobalObjects().GetByIndex(i);
			
				if (!object)
					continue;
			
				if (object->GetFullName() == name)
					return static_cast<T*>(object);
			}
			return nullptr;
		}

		template<typename T>
		static T* FindObject()
		{
			auto v = T::StaticClass();
			for (int32_t i = 0; i < UObject::GetGlobalObjects().Count(); ++i)
			{
				auto object = UObject::GetGlobalObjects().GetByIndex(i);
			
				if (!object)
					continue;
			
				if (object->IsA(v))
					return static_cast<T*>(object);
			}
			return nullptr;
		}

		template<typename T>
		static std::vector<T*> FindObjects(const std::string& name)
		{
			std::vector<T*> ret;
			for (int32_t i = 0; i < UObject::GetGlobalObjects().Count(); ++i)
			{
				auto object = UObject::GetGlobalObjects().GetByIndex(i);
			
				if (!object)
					continue;
			
				if (object->GetFullName() == name)
					ret.push_back(static_cast<T*>(object));
			}
			return ret;
		}

		template<typename T>
		static std::vector<T*> FindObjects()
		{
			std::vector<T*> ret;
			auto v = T::StaticClass();
			for (int i = 0; i < UObject::GetGlobalObjects().Count(); ++i)
			{
				auto object = UObject::GetGlobalObjects().GetByIndex(i);
			
				if (!object)
					continue;
			
				if (object->IsA(v))
					ret.push_back(static_cast<T*>(object));
			}
			return ret;
		}

		static UClass* FindClass(const std::string& name);
		template<typename T>
		static T* GetObjectCasted(size_t index)
		{
			return static_cast<T*>(UObject::GetGlobalObjects().GetByIndex(index));
		}

		bool IsA(UClass* cmp) const;
		void ExecuteUbergraph(int32_t EntryPoint);
		void ProcessEvent(class UFunction* function, void* parms);
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.Package
	 * Size -> 0x0070 (FullSize[0x0098] - InheritedSize[0x0028])
	 */
	class UPackage : public UObject
	{
	public:
		unsigned char                                              UnknownData_JKMV[0x70];                                  // 0x0028(0x0070) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.Field
	 * Size -> 0x0008 (FullSize[0x0030] - InheritedSize[0x0028])
	 */
	class UField : public UObject
	{
	public:
		class UField*                                              Next;                                                    // 0x0028(0x0008) PRE-DEFINED PROPERTY

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.Struct
	 * Size -> 0x0080 (FullSize[0x00B0] - InheritedSize[0x0030])
	 */
	class UStruct : public UField, public FStructBaseChain
	{
	public:
		class UStruct*                                             SuperField;                                              // 0x0040(0x0008) PRE-DEFINED PROPERTY
		class UField*                                              Children;                                                // 0x0048(0x0008) PRE-DEFINED PROPERTY
		class FField*                                              ChildProperties;                                         // 0x0050(0x0008) PRE-DEFINED PROPERTY
		int32_t                                                    PropertySize;                                            // 0x0058(0x0004) PRE-DEFINED PROPERTY
		int32_t                                                    MinAlignment;                                            // 0x005C(0x0004) PRE-DEFINED PROPERTY
		TArray<uint8_t>                                            Script;                                                  // 0x0060(0x0010) PRE-DEFINED PROPERTY
		class FProperty*                                           PropertyLink;                                            // 0x0070(0x0008) PRE-DEFINED PROPERTY
		class FProperty*                                           RefLink;                                                 // 0x0078(0x0008) PRE-DEFINED PROPERTY
		class FProperty*                                           DestructorLink;                                          // 0x0080(0x0008) PRE-DEFINED PROPERTY
		class FProperty*                                           PostConstructLink;                                       // 0x0088(0x0008) PRE-DEFINED PROPERTY
		TArray<UObject*>                                           ScriptAndPropertyObjectReferences;                       // 0x0090(0x0010) PRE-DEFINED PROPERTY
		class FUnresolvedScriptPropertiesArray*                    UnresolvedScriptProperties;                              // 0x00A0(0x0008) PRE-DEFINED PROPERTY
		class FUnversionedStructSchema*                            UnversionedSchema;                                       // 0x00A8(0x0008) PRE-DEFINED PROPERTY

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.Class
	 * Size -> 0x0180 (FullSize[0x0230] - InheritedSize[0x00B0])
	 */
	class UClass : public UStruct
	{
	public:
		unsigned char                                              UnknownData_3KEP[0x180];                                 // 0x00B0(0x0180) MISSED OFFSET (PADDING)

	public:
		template<typename T>
		T* CreateDefaultObjectOfType()
		{
			return static_cast<T*>(CreateDefaultObject());
		}

		UObject* CreateDefaultObject();
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.Function
	 * Size -> 0x0030 (FullSize[0x00E0] - InheritedSize[0x00B0])
	 */
	class UFunction : public UStruct
	{
	public:
		int32_t                                                    FunctionFlags;                                           // 0x00B0(0x0004) PRE-DEFINED PROPERTY
		uint8_t                                                    NumParms;                                                // 0x00B4(0x0001) PRE-DEFINED PROPERTY
		uint16_t                                                   ParmsSize;                                               // 0x00B5(0x0002) PRE-DEFINED PROPERTY
		unsigned char                                              pad_9DKM1U89KD[0x01];                                    // 0x00B7(0x0001) PRE-DEFINED PROPERTY
		uint16_t                                                   ReturnValueOffset;                                       // 0x00B8(0x0002) PRE-DEFINED PROPERTY
		uint16_t                                                   RPCId;                                                   // 0x00BA(0x0002) PRE-DEFINED PROPERTY
		uint16_t                                                   RPCResponseId;                                           // 0x00BC(0x0002) PRE-DEFINED PROPERTY
		unsigned char                                              pad_V5Q41ZNRCD[0x02];                                    // 0x00BE(0x0002) PRE-DEFINED PROPERTY
		class UProperty*                                           FirstPropertyToInit;                                     // 0x00C0(0x0008) PRE-DEFINED PROPERTY
		class UFunction*                                           EventGraphFunction;                                      // 0x00C8(0x0008) PRE-DEFINED PROPERTY
		int32_t                                                    EventGraphCallOffset;                                    // 0x00D0(0x0004) PRE-DEFINED PROPERTY
		unsigned char                                              pad_2VFYNYQPLT[0x04];                                    // 0x00D4(0x0004) PRE-DEFINED PROPERTY
		void*                                                      Func;                                                    // 0x00D8(0x0008) PRE-DEFINED PROPERTY

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.Interface
	 * Size -> 0x0000 (FullSize[0x0028] - InheritedSize[0x0028])
	 */
	class UInterface : public UObject
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.GCObjectReferencer
	 * Size -> 0x0048 (FullSize[0x0070] - InheritedSize[0x0028])
	 */
	class UGCObjectReferencer : public UObject
	{
	public:
		unsigned char                                              UnknownData_S80G[0x48];                                  // 0x0028(0x0048) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.TextBuffer
	 * Size -> 0x0028 (FullSize[0x0050] - InheritedSize[0x0028])
	 */
	class UTextBuffer : public UObject
	{
	public:
		unsigned char                                              UnknownData_PC0O[0x28];                                  // 0x0028(0x0028) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.ScriptStruct
	 * Size -> 0x0010 (FullSize[0x00C0] - InheritedSize[0x00B0])
	 */
	class UScriptStruct : public UStruct
	{
	public:
		unsigned char                                              UnknownData_J108[0x10];                                  // 0x00B0(0x0010) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.DelegateFunction
	 * Size -> 0x0000 (FullSize[0x00E0] - InheritedSize[0x00E0])
	 */
	class UDelegateFunction : public UFunction
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.SparseDelegateFunction
	 * Size -> 0x0010 (FullSize[0x00F0] - InheritedSize[0x00E0])
	 */
	class USparseDelegateFunction : public UDelegateFunction
	{
	public:
		unsigned char                                              UnknownData_TCCC[0x10];                                  // 0x00E0(0x0010) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.DynamicClass
	 * Size -> 0x0080 (FullSize[0x02B0] - InheritedSize[0x0230])
	 */
	class UDynamicClass : public UClass
	{
	public:
		unsigned char                                              UnknownData_SKHZ[0x80];                                  // 0x0230(0x0080) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.PackageMap
	 * Size -> 0x00B8 (FullSize[0x00E0] - InheritedSize[0x0028])
	 */
	class UPackageMap : public UObject
	{
	public:
		unsigned char                                              UnknownData_0HS4[0xB8];                                  // 0x0028(0x00B8) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.Enum
	 * Size -> 0x0030 (FullSize[0x0060] - InheritedSize[0x0030])
	 */
	class UEnum : public UField
	{
	public:
		unsigned char                                              UnknownData_33BZ[0x30];                                  // 0x0030(0x0030) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.LinkerPlaceholderClass
	 * Size -> 0x01B8 (FullSize[0x03E8] - InheritedSize[0x0230])
	 */
	class ULinkerPlaceholderClass : public UClass
	{
	public:
		unsigned char                                              UnknownData_NJL9[0x1B8];                                 // 0x0230(0x01B8) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.LinkerPlaceholderExportObject
	 * Size -> 0x00C8 (FullSize[0x00F0] - InheritedSize[0x0028])
	 */
	class ULinkerPlaceholderExportObject : public UObject
	{
	public:
		unsigned char                                              UnknownData_Z2WW[0xC8];                                  // 0x0028(0x00C8) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.LinkerPlaceholderFunction
	 * Size -> 0x01B8 (FullSize[0x0298] - InheritedSize[0x00E0])
	 */
	class ULinkerPlaceholderFunction : public UFunction
	{
	public:
		unsigned char                                              UnknownData_FSGM[0x1B8];                                 // 0x00E0(0x01B8) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.MetaData
	 * Size -> 0x00A0 (FullSize[0x00C8] - InheritedSize[0x0028])
	 */
	class UMetaData : public UObject
	{
	public:
		unsigned char                                              UnknownData_2PUA[0xA0];                                  // 0x0028(0x00A0) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.ObjectRedirector
	 * Size -> 0x0008 (FullSize[0x0030] - InheritedSize[0x0028])
	 */
	class UObjectRedirector : public UObject
	{
	public:
		unsigned char                                              UnknownData_8O2W[0x8];                                   // 0x0028(0x0008) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.Property
	 * Size -> 0x0040 (FullSize[0x0070] - InheritedSize[0x0030])
	 */
	class UProperty : public UField
	{
	public:
		unsigned char                                              UnknownData_TU5E[0x40];                                  // 0x0030(0x0040) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.EnumProperty
	 * Size -> 0x0010 (FullSize[0x0080] - InheritedSize[0x0070])
	 */
	class UEnumProperty : public UProperty
	{
	public:
		unsigned char                                              UnknownData_04CD[0x10];                                  // 0x0070(0x0010) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.ArrayProperty
	 * Size -> 0x0008 (FullSize[0x0078] - InheritedSize[0x0070])
	 */
	class UArrayProperty : public UProperty
	{
	public:
		unsigned char                                              UnknownData_KJOQ[0x8];                                   // 0x0070(0x0008) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.ObjectPropertyBase
	 * Size -> 0x0008 (FullSize[0x0078] - InheritedSize[0x0070])
	 */
	class UObjectPropertyBase : public UProperty
	{
	public:
		unsigned char                                              UnknownData_GMOZ[0x8];                                   // 0x0070(0x0008) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.BoolProperty
	 * Size -> 0x0008 (FullSize[0x0078] - InheritedSize[0x0070])
	 */
	class UBoolProperty : public UProperty
	{
	public:
		unsigned char                                              UnknownData_QRBC[0x8];                                   // 0x0070(0x0008) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.NumericProperty
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UNumericProperty : public UProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.ByteProperty
	 * Size -> 0x0008 (FullSize[0x0078] - InheritedSize[0x0070])
	 */
	class UByteProperty : public UNumericProperty
	{
	public:
		unsigned char                                              UnknownData_CKFL[0x8];                                   // 0x0070(0x0008) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.ObjectProperty
	 * Size -> 0x0000 (FullSize[0x0078] - InheritedSize[0x0078])
	 */
	class UObjectProperty : public UObjectPropertyBase
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.ClassProperty
	 * Size -> 0x0008 (FullSize[0x0080] - InheritedSize[0x0078])
	 */
	class UClassProperty : public UObjectProperty
	{
	public:
		unsigned char                                              UnknownData_IG7U[0x8];                                   // 0x0078(0x0008) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.DelegateProperty
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UDelegateProperty : public UProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.DoubleProperty
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UDoubleProperty : public UNumericProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.FloatProperty
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UFloatProperty : public UNumericProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.IntProperty
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UIntProperty : public UNumericProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.Int8Property
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UInt8Property : public UNumericProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.Int16Property
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UInt16Property : public UNumericProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.Int64Property
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UInt64Property : public UNumericProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.InterfaceProperty
	 * Size -> 0x0008 (FullSize[0x0078] - InheritedSize[0x0070])
	 */
	class UInterfaceProperty : public UProperty
	{
	public:
		unsigned char                                              UnknownData_TJ58[0x8];                                   // 0x0070(0x0008) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.LazyObjectProperty
	 * Size -> 0x0000 (FullSize[0x0078] - InheritedSize[0x0078])
	 */
	class ULazyObjectProperty : public UObjectPropertyBase
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.MapProperty
	 * Size -> 0x0028 (FullSize[0x0098] - InheritedSize[0x0070])
	 */
	class UMapProperty : public UProperty
	{
	public:
		unsigned char                                              UnknownData_NMOE[0x28];                                  // 0x0070(0x0028) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.MulticastDelegateProperty
	 * Size -> 0x0008 (FullSize[0x0078] - InheritedSize[0x0070])
	 */
	class UMulticastDelegateProperty : public UDelegateProperty
	{
	public:
		unsigned char                                              UnknownData_2GO9[0x8];                                   // 0x0070(0x0008) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.MulticastInlineDelegateProperty
	 * Size -> 0x0000 (FullSize[0x0078] - InheritedSize[0x0078])
	 */
	class UMulticastInlineDelegateProperty : public UMulticastDelegateProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.MulticastSparseDelegateProperty
	 * Size -> 0x0000 (FullSize[0x0078] - InheritedSize[0x0078])
	 */
	class UMulticastSparseDelegateProperty : public UMulticastDelegateProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.NameProperty
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UNameProperty : public UProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.SetProperty
	 * Size -> 0x0020 (FullSize[0x0090] - InheritedSize[0x0070])
	 */
	class USetProperty : public UProperty
	{
	public:
		unsigned char                                              UnknownData_OOPF[0x20];                                  // 0x0070(0x0020) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.SoftObjectProperty
	 * Size -> 0x0000 (FullSize[0x0078] - InheritedSize[0x0078])
	 */
	class USoftObjectProperty : public UObjectPropertyBase
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.SoftClassProperty
	 * Size -> 0x0008 (FullSize[0x0080] - InheritedSize[0x0078])
	 */
	class USoftClassProperty : public USoftObjectProperty
	{
	public:
		unsigned char                                              UnknownData_WSYX[0x8];                                   // 0x0078(0x0008) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.StrProperty
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UStrProperty : public UProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.StructProperty
	 * Size -> 0x0008 (FullSize[0x0078] - InheritedSize[0x0070])
	 */
	class UStructProperty : public UProperty
	{
	public:
		unsigned char                                              UnknownData_A06R[0x8];                                   // 0x0070(0x0008) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.UInt16Property
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UUInt16Property : public UNumericProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.UInt32Property
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UUInt32Property : public UNumericProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.UInt64Property
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UUInt64Property : public UNumericProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.WeakObjectProperty
	 * Size -> 0x0000 (FullSize[0x0078] - InheritedSize[0x0078])
	 */
	class UWeakObjectProperty : public UObjectPropertyBase
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.TextProperty
	 * Size -> 0x0000 (FullSize[0x0070] - InheritedSize[0x0070])
	 */
	class UTextProperty : public UProperty
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.PropertyWrapper
	 * Size -> 0x0008 (FullSize[0x0030] - InheritedSize[0x0028])
	 */
	class UPropertyWrapper : public UObject
	{
	public:
		unsigned char                                              UnknownData_6WQC[0x8];                                   // 0x0028(0x0008) MISSED OFFSET (PADDING)

	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.MulticastDelegatePropertyWrapper
	 * Size -> 0x0000 (FullSize[0x0030] - InheritedSize[0x0030])
	 */
	class UMulticastDelegatePropertyWrapper : public UPropertyWrapper
	{
	public:
		static UClass* StaticClass();
	};

	/**
	 * Class CoreUObject.MulticastInlineDelegatePropertyWrapper
	 * Size -> 0x0000 (FullSize[0x0030] - InheritedSize[0x0030])
	 */
	class UMulticastInlineDelegatePropertyWrapper : public UMulticastDelegatePropertyWrapper
	{
	public:
		static UClass* StaticClass();
	};

}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif

```

`Dumper/engine_code/CoreUObject_Package.cpp`:

```cpp
/**
 * Name: VAR_GAME_NAME
 * Version: VAR_GAME_VERSION
 */

#include "../SDK.h"

namespace VAR_NAMESPACE
{
	// --------------------------------------------------
	// # Structs Static Fields
	// --------------------------------------------------
	class TUObjectArray*                                        UObject::GObjects = nullptr;                             // 0x0000(0x0008) PREDEFINED PROPERTY
	class UWorld**                                              UWorld::GWorld = nullptr;
	// --------------------------------------------------
	// # Structs Functions
	// --------------------------------------------------
	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	FRotator::FRotator()
	{
		Pitch = 0.0f;
		Yaw = 0.0f;
		Roll = 0.0f;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              pitch
	 * 		float                                              yaw
	 * 		float                                              roll
	 */
	FRotator::FRotator(float pitch, float yaw, float roll)
	{
		Pitch = pitch;
		Yaw = yaw;
		Roll = roll;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FRotator FRotator::operator +(float scalar) const
	{
		return FRotator(Pitch + scalar, Yaw + scalar, Roll + scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FRotator&                                    other
	 */
	FRotator FRotator::operator +(const FRotator& other) const
	{
		return FRotator(Pitch + other.Pitch, Yaw + other.Yaw, Roll + other.Roll);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FRotator FRotator::operator -(float scalar) const
	{
		return FRotator(Pitch - scalar, Yaw - scalar, Roll - scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FRotator&                                    other
	 */
	FRotator FRotator::operator -(const FRotator& other) const
	{
		return FRotator(Pitch - other.Pitch, Yaw - other.Yaw, Roll - other.Roll);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FRotator FRotator::operator *(float scalar) const
	{
		return FRotator(Pitch * scalar, Yaw * scalar, Roll * scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FRotator&                                    other
	 */
	FRotator FRotator::operator *(const FRotator& other) const
	{
		return FRotator(Pitch * other.Pitch, Yaw * other.Yaw, Roll * other.Roll);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FRotator FRotator::operator /(float scalar) const
	{
		return FRotator(Pitch / scalar, Yaw / scalar, Roll / scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FRotator&                                    other
	 */
	FRotator FRotator::operator /(const FRotator& other) const
	{
		return FRotator(Pitch / other.Pitch, Yaw / other.Yaw, Roll / other.Roll);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FRotator&                                    other
	 */
	FRotator& FRotator::operator =(const FRotator& other)
	{
		Pitch = other.Pitch; Yaw = other.Yaw; Roll = other.Roll; return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FRotator& FRotator::operator +=(float scalar)
	{
		Pitch += scalar;
		Yaw += scalar;
		Roll += scalar;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FRotator&                                    other
	 */
	FRotator& FRotator::operator +=(const FRotator& other)
	{
		Pitch += other.Pitch;
		Yaw += other.Yaw;
		Roll += other.Roll;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FRotator& FRotator::operator -=(float scalar)
	{
		Pitch -= scalar;
		Yaw -= scalar;
		Roll -= scalar;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FRotator&                                    other
	 */
	FRotator& FRotator::operator -=(const FRotator& other)
	{
		Pitch -= other.Pitch;
		Yaw -= other.Yaw;
		Roll -= other.Roll;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FRotator&                                    other
	 */
	FRotator& FRotator::operator *=(const FRotator& other)
	{
		Pitch *= other.Pitch;
		Yaw *= other.Yaw;
		Roll *= other.Roll;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const float                                        other
	 */
	FRotator& FRotator::operator *=(const float other)
	{
		Pitch *= other;
		Yaw *= other;
		Roll *= other;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FRotator&                                    other
	 */
	FRotator& FRotator::operator /=(const FRotator& other)
	{
		Pitch /= other.Pitch;
		Yaw /= other.Yaw;
		Roll /= other.Roll;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const float                                        other
	 */
	FRotator& FRotator::operator /=(const float other)
	{
		Pitch /= other;
		Yaw /= other;
		Roll /= other;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	float FRotator::Size() const
	{
		return sqrt(Pitch * Pitch + Yaw * Yaw + Roll * Roll);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	FRotator FRotator::Clamp() const
	{
		FRotator r = { Pitch, Yaw, Roll };
		if (r.Yaw > 180.0f)
			r.Yaw -= 360.0f;
		else if (r.Yaw < -180.0f)
			r.Yaw += 360.0f;
		if (r.Pitch > 180.0f)
			r.Pitch -= 360.0f;
		else if (r.Pitch < -180.0f)
			r.Pitch += 360.0f;
		if (r.Pitch < -89.0f)
			r.Pitch = -89.0f;
		else if (r.Pitch > 89.0f)
			r.Pitch = 89.0f;
		r.Roll = 0.0f;
		return r;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	FVector::FVector()
	{
		X = 0;
		Y = 0;
		Z = 0;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              x
	 * 		float                                              y
	 * 		float                                              z
	 */
	FVector::FVector(float x, float y, float z)
	{
		X = x;
		Y = y;
		Z = z;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector FVector::operator +(float scalar) const
	{
		return FVector(X + scalar, Y + scalar, Z + scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector&                                     other
	 */
	FVector FVector::operator +(const FVector& other) const
	{
		return FVector(X + other.X, Y + other.Y, Z + other.Z);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector FVector::operator -(float scalar) const
	{
		return FVector(X - scalar, Y - scalar, Z - scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector&                                     other
	 */
	FVector FVector::operator -(const FVector& other) const
	{
		return FVector(X - other.X, Y - other.Y, Z - other.Z);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector FVector::operator *(float scalar) const
	{
		return FVector(X * scalar, Y * scalar, Z * scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector&                                     other
	 */
	FVector FVector::operator *(const FVector& other) const
	{
		return FVector(X * other.X, Y * other.Y, Z * other.Z);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector FVector::operator /(float scalar) const
	{
		return FVector(X / scalar, Y / scalar, Z / scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector&                                     other
	 */
	FVector FVector::operator /(const FVector& other) const
	{
		return FVector(X / other.X, Y / other.Y, Z / other.Z);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector&                                     other
	 */
	FVector& FVector::operator =(const FVector& other)
	{
		X = other.X;
		Y = other.Y;
		Z = other.Z;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector& FVector::operator +=(float scalar)
	{
		X += scalar;
		Y += scalar;
		Z += scalar;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector&                                     other
	 */
	FVector& FVector::operator +=(const FVector& other)
	{
		X += other.X;
		Y += other.Y;
		Z += other.Z;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector& FVector::operator -=(float scalar)
	{
		X -= scalar;
		Y -= scalar;
		Z -= scalar;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector&                                     other
	 */
	FVector& FVector::operator -=(const FVector& other)
	{
		X -= other.X;
		Y -= other.Y;
		Z -= other.Z;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector&                                     other
	 */
	FVector& FVector::operator *=(const FVector& other)
	{
		X *= other.X;
		Y *= other.Y;
		Z *= other.Z;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector& FVector::operator *=(float scalar)
	{
		X *= scalar;
		Y *= scalar;
		Z *= scalar;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	bool FVector::IsValid()
	{
		return X == 0.0f && Y == 0.0f;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		FVector&                                           angle
	 */
	void FVector::Normalize360(FVector& angle)
	{
		const float maxX1 = 80.0f;
		
		while (angle.X > maxX1)
			angle.X -= 180.0f;
		while (angle.X < -maxX1)
			angle.X += 180.0f;
		while (angle.Y > 180.0f)
			angle.Y -= 360.0f;
		while (angle.Y < -180.0f)
			angle.Y += 360.0f;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector&                                     b
	 */
	float FVector::Dot(const FVector& b) const
	{
		return (X * b.X) + (Y * b.Y) + (Z * b.Z);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	float FVector::MagnitudeSqr() const
	{
		return Dot(*this);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	float FVector::Magnitude() const
	{
		return std::sqrtf(MagnitudeSqr());
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	FVector FVector::Unit() const
	{
		const float fMagnitude = Magnitude();
		return FVector(X / fMagnitude, Y / fMagnitude, Z / fMagnitude);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	FRotator FVector::ToRotator() const
	{
		static constexpr float PI = 3.14159265359f;
		// Pitch, Yaw, Roll
		return FRotator(asinf(Z / Magnitude()) * 180.0f / PI, atan2f(Y, X) * 180.0f / PI, 0.0f);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector&                                     v
	 */
	float FVector::Distance(const FVector& v) const
	{
		return float(sqrtf(powf(v.X - X, 2.0f) + powf(v.Y - Y, 2.0f) + powf(v.Z - Z, 2.0f)));
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		FVector&                                           v
	 */
	float FVector::DistanceMeter(FVector& v) const
	{
		return Distance(v) * 0.01f;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	FVector2D::FVector2D()
	{
		X = 0;
		Y = 0;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              x
	 * 		float                                              y
	 */
	FVector2D::FVector2D(float x, float y)
	{
		X = x;
		Y = y;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	bool FVector2D::IsValid()
	{
		return X == 0 && Y == 0;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		FVector2D&                                         v
	 */
	float FVector2D::Distance(FVector2D& v) const
	{
		return powf(v.X - X, 2) + powf(v.Y - Y, 2);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector2D&                                   other
	 */
	FVector2D FVector2D::operator +(const FVector2D& other) const
	{
		return FVector2D(X + other.X, Y + other.Y);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector2D FVector2D::operator +(float scalar) const
	{
		return FVector2D(X + scalar, Y + scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector2D FVector2D::operator -(float scalar) const
	{
		return FVector2D(X - scalar, Y - scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector2D&                                   other
	 */
	FVector2D FVector2D::operator -(const FVector2D& other) const
	{
		return FVector2D(X - other.X, Y - other.Y);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector2D FVector2D::operator *(float scalar) const
	{
		return FVector2D(X * scalar, Y * scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector2D&                                   other
	 */
	FVector2D FVector2D::operator *(const FVector2D& other) const
	{
		return FVector2D(X * other.X, Y * other.Y);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector2D FVector2D::operator /(float scalar) const
	{
		return FVector2D(X / scalar, Y / scalar);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector2D&                                   other
	 */
	FVector2D FVector2D::operator /(const FVector2D& other) const
	{
		return FVector2D(X / other.X, Y / other.Y);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector2D&                                   other
	 */
	FVector2D& FVector2D::operator =(const FVector2D& other)
	{
		X = other.X;
		Y = other.Y;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector2D& FVector2D::operator +=(float scalar)
	{
		X += scalar;
		Y += scalar;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector2D&                                   other
	 */
	FVector2D& FVector2D::operator +=(const FVector2D& other)
	{
		X += other.X;
		Y += other.Y;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector2D& FVector2D::operator -=(float scalar)
	{
		X -= scalar;
		Y -= scalar;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector2D&                                   other
	 */
	FVector2D& FVector2D::operator -=(const FVector2D& other)
	{
		X -= other.X;
		Y -= other.Y;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FVector2D&                                   other
	 */
	FVector2D& FVector2D::operator *=(const FVector2D& other)
	{
		X *= other.X;
		Y *= other.Y;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              scalar
	 */
	FVector2D& FVector2D::operator *=(float scalar)
	{
		X *= scalar;
		Y *= scalar;
		return *this;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	FLinearColor::FLinearColor()
	{
		R = 0;
		G = 0;
		B = 0;
		A = 0;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              r
	 * 		float                                              g
	 * 		float                                              b
	 * 		float                                              a
	 */
	FLinearColor::FLinearColor(float r, float g, float b, float a)
	{
		R = r;
		G = g;
		B = b;
		A = a;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const FMatrix&                                     other
	 */
	FMatrix FMatrix::operator *(const FMatrix& other) const
	{
		FMatrix ret;
		
		ret.XPlane.X = XPlane.X * other.XPlane.X + XPlane.Y * other.YPlane.X + XPlane.Z * other.ZPlane.X + XPlane.W * other.WPlane.X;
		ret.XPlane.Y = XPlane.X * other.XPlane.Y + XPlane.Y * other.YPlane.Y + XPlane.Z * other.ZPlane.Y + XPlane.W * other.WPlane.Y;
		ret.XPlane.Z = XPlane.X * other.XPlane.Z + XPlane.Y * other.YPlane.Z + XPlane.Z * other.ZPlane.Z + XPlane.W * other.WPlane.Z;
		ret.XPlane.W = XPlane.X * other.XPlane.W + XPlane.Y * other.YPlane.W + XPlane.Z * other.ZPlane.W + XPlane.W * other.WPlane.W;
		
		ret.YPlane.X = YPlane.X * other.XPlane.X + YPlane.Y * other.YPlane.X + YPlane.Z * other.ZPlane.X + YPlane.W * other.WPlane.X;
		ret.YPlane.Y = YPlane.X * other.XPlane.Y + YPlane.Y * other.YPlane.Y + YPlane.Z * other.ZPlane.Y + YPlane.W * other.WPlane.Y;
		ret.YPlane.Z = YPlane.X * other.XPlane.Z + YPlane.Y * other.YPlane.Z + YPlane.Z * other.ZPlane.Z + YPlane.W * other.WPlane.Z;
		ret.YPlane.W = YPlane.X * other.XPlane.W + YPlane.Y * other.YPlane.W + YPlane.Z * other.ZPlane.W + YPlane.W * other.WPlane.W;
		
		ret.ZPlane.X = ZPlane.X * other.XPlane.X + ZPlane.Y * other.YPlane.X + ZPlane.Z * other.ZPlane.X + ZPlane.W * other.WPlane.X;
		ret.ZPlane.Y = ZPlane.X * other.XPlane.Y + ZPlane.Y * other.YPlane.Y + ZPlane.Z * other.ZPlane.Y + ZPlane.W * other.WPlane.Y;
		ret.ZPlane.Z = ZPlane.X * other.XPlane.Z + ZPlane.Y * other.YPlane.Z + ZPlane.Z * other.ZPlane.Z + ZPlane.W * other.WPlane.Z;
		ret.ZPlane.W = ZPlane.X * other.XPlane.W + ZPlane.Y * other.YPlane.W + ZPlane.Z * other.ZPlane.W + ZPlane.W * other.WPlane.W;
		
		ret.WPlane.X = WPlane.X * other.XPlane.X + WPlane.Y * other.YPlane.X + WPlane.Z * other.ZPlane.X + WPlane.W * other.WPlane.X;
		ret.WPlane.Y = WPlane.X * other.XPlane.Y + WPlane.Y * other.YPlane.Y + WPlane.Z * other.ZPlane.Y + WPlane.W * other.WPlane.Y;
		ret.WPlane.Z = WPlane.X * other.XPlane.Z + WPlane.Y * other.YPlane.Z + WPlane.Z * other.ZPlane.Z + WPlane.W * other.WPlane.Z;
		ret.WPlane.W = WPlane.X * other.XPlane.W + WPlane.Y * other.YPlane.W + WPlane.Z * other.ZPlane.W + WPlane.W * other.WPlane.W;
		
		return ret;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	FMatrix FTransform::ToMatrixWithScale() const
	{
		FMatrix OutMatrix;
		OutMatrix.WPlane.X = Translation.X;
		OutMatrix.WPlane.Y = Translation.Y;
		OutMatrix.WPlane.Z = Translation.Z;
		
		const float x2 = Rotation.X + Rotation.X;
		const float y2 = Rotation.Y + Rotation.Y;
		const float z2 = Rotation.Z + Rotation.Z;
		
		{
			const float xx2 = Rotation.X * x2;
			const float yy2 = Rotation.Y * y2;
			const float zz2 = Rotation.Z * z2;
		
			OutMatrix.XPlane.X = (1.0f - (yy2 + zz2)) * Scale3D.X;
			OutMatrix.YPlane.Y = (1.0f - (xx2 + zz2)) * Scale3D.Y;
			OutMatrix.ZPlane.Z = (1.0f - (xx2 + yy2)) * Scale3D.Z;
		}
		
		{
			const float yz2 = Rotation.Y * z2;
			const float wx2 = Rotation.W * x2;
		
			OutMatrix.ZPlane.Y = (yz2 - wx2) * Scale3D.Z;
			OutMatrix.YPlane.Z = (yz2 + wx2) * Scale3D.Y;
		}
		
		{
			const float xy2 = Rotation.X * y2;
			const float wz2 = Rotation.W * z2;
		
			OutMatrix.YPlane.X = (xy2 - wz2) * Scale3D.Y;
			OutMatrix.XPlane.Y = (xy2 + wz2) * Scale3D.X;
		}
		
		{
			const float xz2 = Rotation.X * z2;
			const float wy2 = Rotation.W * y2;
		
			OutMatrix.ZPlane.X = (xz2 + wy2) * Scale3D.Z;
			OutMatrix.XPlane.Z = (xz2 - wy2) * Scale3D.X;
		}
		
		OutMatrix.XPlane.W = 0.0f;
		OutMatrix.YPlane.W = 0.0f;
		OutMatrix.ZPlane.W = 0.0f;
		OutMatrix.WPlane.W = 1.0f;
		
		return OutMatrix;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	TUObjectArray& UObject::GetGlobalObjects()
	{
		return *GObjects;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	std::string UObject::GetName() const
	{
		std::string name(Name.GetName());
		if (Name.Number > 0)
			name += '_' + std::to_string(Name.Number);
		auto pos = name.rfind('/');
		if (pos == std::string::npos)
			return name;
		return name.substr(pos + 1);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	std::string UObject::GetFullName() const
	{
		std::string name;
		if (Class != nullptr)
		{
			std::string temp;
			for (auto p = Outer; p; p = p->Outer)
			{
				temp = p->GetName() + "." + temp;
			}
			name = Class->GetName();
			name += " ";
			name += temp;
			name += GetName();
		}
		return name;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		const std::string&                                 name
	 */
	UClass* UObject::FindClass(const std::string& name)
	{
		return FindObject<UClass>(name);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		UClass*                                            cmp
	 */
	bool UObject::IsA(UClass* cmp) const
	{
		for (auto super = Class; super; super = static_cast<UClass*>(super->SuperField))
		{
			if (super == cmp)
				return true;
		}
		
		return false;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0227CE00
	 * 		Name   -> Function CoreUObject.Object.ExecuteUbergraph
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            EntryPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObject::ExecuteUbergraph(int32_t EntryPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function CoreUObject.Object.ExecuteUbergraph");
		
		UObject_ExecuteUbergraph_Params params {};
		params.EntryPoint = EntryPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFunction*                                   function
	 * 		void*                                              parms
	 */
	void UObject::ProcessEvent(class UFunction* function, void* parms)
	{
		GetVFunction<void(*)(UObject*, class UFunction*, void*)>(this, PROCESS_EVENTS_INDEX)(this, function, parms);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Object");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPackage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPackage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Package");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UField.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UField::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Field");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStruct.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStruct::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Struct");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 */
	UObject* UClass::CreateDefaultObject()
	{
		return GetVFunction<UObject*(*)(UClass*)>(this, CREATE_DEFAULT_OBJECT_INDEX)(this);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Class");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFunction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFunction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Function");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Interface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGCObjectReferencer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGCObjectReferencer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.GCObjectReferencer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTextBuffer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTextBuffer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.TextBuffer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScriptStruct.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScriptStruct::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.ScriptStruct");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDelegateFunction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDelegateFunction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.DelegateFunction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USparseDelegateFunction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USparseDelegateFunction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.SparseDelegateFunction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDynamicClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDynamicClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.DynamicClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPackageMap.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPackageMap::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.PackageMap");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnum.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnum::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Enum");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULinkerPlaceholderClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULinkerPlaceholderClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.LinkerPlaceholderClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULinkerPlaceholderExportObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULinkerPlaceholderExportObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.LinkerPlaceholderExportObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULinkerPlaceholderFunction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULinkerPlaceholderFunction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.LinkerPlaceholderFunction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.MetaData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectRedirector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectRedirector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.ObjectRedirector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Property");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnumProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnumProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.EnumProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArrayProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArrayProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.ArrayProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectPropertyBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectPropertyBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.ObjectPropertyBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBoolProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBoolProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.BoolProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNumericProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNumericProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.NumericProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UByteProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UByteProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.ByteProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.ObjectProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.ClassProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDelegateProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDelegateProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.DelegateProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDoubleProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDoubleProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.DoubleProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFloatProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFloatProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.FloatProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UIntProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UIntProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.IntProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInt8Property.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInt8Property::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Int8Property");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInt16Property.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInt16Property::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Int16Property");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInt64Property.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInt64Property::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.Int64Property");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterfaceProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterfaceProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.InterfaceProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULazyObjectProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULazyObjectProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.LazyObjectProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.MapProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMulticastDelegateProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMulticastDelegateProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.MulticastDelegateProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMulticastInlineDelegateProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMulticastInlineDelegateProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.MulticastInlineDelegateProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMulticastSparseDelegateProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMulticastSparseDelegateProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.MulticastSparseDelegateProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNameProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNameProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.NameProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USetProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USetProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.SetProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoftObjectProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoftObjectProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.SoftObjectProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoftClassProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoftClassProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.SoftClassProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStrProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStrProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.StrProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStructProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStructProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.StructProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUInt16Property.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUInt16Property::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.UInt16Property");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUInt32Property.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUInt32Property::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.UInt32Property");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUInt64Property.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUInt64Property::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.UInt64Property");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeakObjectProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeakObjectProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.WeakObjectProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTextProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTextProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.TextProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPropertyWrapper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPropertyWrapper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.PropertyWrapper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMulticastDelegatePropertyWrapper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMulticastDelegatePropertyWrapper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.MulticastDelegatePropertyWrapper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMulticastInlineDelegatePropertyWrapper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMulticastInlineDelegatePropertyWrapper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class CoreUObject.MulticastInlineDelegatePropertyWrapper");
		return ptr;
	}

}



```

`Dumper/engine_code/CoreUObject_Package.h`:

```h
#pragma once

/**
 * Name: VAR_GAME_NAME
 * Version: VAR_GAME_VERSION
 */
#ifdef _MSC_VER
	#pragma pack(push, 0x01)
#endif

namespace VAR_NAMESPACE
{
}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif

#include "CoreUObject_Structs.h"
#include "CoreUObject_Classes.h"
#include "CoreUObject_Params.h"


```

`Dumper/engine_code/CoreUObject_Params.h`:

```h
#pragma once

/**
 * Name: VAR_GAME_NAME
 * Version: VAR_GAME_VERSION
 */

#ifdef _MSC_VER
	#pragma pack(push, 0x01)
#endif

namespace VAR_NAMESPACE
{
	// --------------------------------------------------
	// # Structs
	// --------------------------------------------------
	/**
	 * Function CoreUObject.Object.ExecuteUbergraph
	 */
	struct UObject_ExecuteUbergraph_Params
	{
	public:
		int32_t                                                    EntryPoint;                                              // 0x0000(0x0004)  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	};

}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif

```

`Dumper/engine_code/CoreUObject_Structs.h`:

```h
#pragma once

/**
 * Name: VAR_GAME_NAME
 * Version: VAR_GAME_VERSION
 */

#ifdef _MSC_VER
	#pragma pack(push, 0x01)
#endif

namespace VAR_NAMESPACE
{
	// --------------------------------------------------
	// # Enums
	// --------------------------------------------------
	/**
	 * Enum CoreUObject.EInterpCurveMode
	 */
	enum class EInterpCurveMode : uint8_t
	{
		CIM_Linear           = 0,
		CIM_CurveAuto        = 1,
		CIM_Constant         = 2,
		CIM_CurveUser        = 3,
		CIM_CurveBreak       = 4,
		CIM_CurveAutoClamped = 5,
		CIM_MAX              = 6
	};

	/**
	 * Enum CoreUObject.ERangeBoundTypes
	 */
	enum class ERangeBoundTypes : uint8_t
	{
		Exclusive = 0,
		Inclusive = 1,
		Open      = 2,
		MAX       = 3
	};

	/**
	 * Enum CoreUObject.ELocalizedTextSourceCategory
	 */
	enum class ELocalizedTextSourceCategory : uint8_t
	{
		Game   = 0,
		Engine = 1,
		Editor = 2,
		MAX    = 3
	};

	/**
	 * Enum CoreUObject.EAutomationEventType
	 */
	enum class EAutomationEventType : uint8_t
	{
		Info    = 0,
		Warning = 1,
		Error   = 2,
		MAX     = 3
	};

	/**
	 * Enum CoreUObject.EMouseCursor
	 */
	enum class EMouseCursor : uint8_t
	{
		None            = 0,
		Default         = 1,
		TextEditBeam    = 2,
		ResizeLeftRight = 3,
		ResizeUpDown    = 4,
		ResizeSouthEast = 5,
		ResizeSouthWest = 6,
		CardinalCross   = 7,
		Crosshairs      = 8,
		Hand            = 9,
		GrabHand        = 10,
		GrabHandClosed  = 11,
		SlashedCircle   = 12,
		EyeDropper      = 13,
		MAX             = 14
	};

	/**
	 * Enum CoreUObject.ELifetimeCondition
	 */
	enum class ELifetimeCondition : uint8_t
	{
		COND_None                       = 0,
		COND_InitialOnly                = 1,
		COND_OwnerOnly                  = 2,
		COND_SkipOwner                  = 3,
		COND_SimulatedOnly              = 4,
		COND_AutonomousOnly             = 5,
		COND_SimulatedOrPhysics         = 6,
		COND_InitialOrOwner             = 7,
		COND_Custom                     = 8,
		COND_ReplayOrOwner              = 9,
		COND_ReplayOnly                 = 10,
		COND_SimulatedOnlyNoReplay      = 11,
		COND_SimulatedOrPhysicsNoReplay = 12,
		COND_SkipReplay                 = 13,
		COND_Never                      = 14,
		COND_Max                        = 15
	};

	/**
	 * Enum CoreUObject.EDataValidationResult
	 */
	enum class EDataValidationResult : uint8_t
	{
		Invalid      = 0,
		Valid        = 1,
		NotValidated = 2,
		MAX          = 3
	};

	/**
	 * Enum CoreUObject.EPropertyAccessChangeNotifyMode
	 */
	enum class EPropertyAccessChangeNotifyMode : uint8_t
	{
		Default = 0,
		Never   = 1,
		Always  = 2,
		MAX     = 3
	};

	/**
	 * Enum CoreUObject.EUnit
	 */
	enum class EUnit : uint8_t
	{
		Micrometers          = 0,
		Millimeters          = 1,
		Centimeters          = 2,
		Meters               = 3,
		Kilometers           = 4,
		Inches               = 5,
		Feet                 = 6,
		Yards                = 7,
		Miles                = 8,
		Lightyears           = 9,
		Degrees              = 10,
		Radians              = 11,
		MetersPerSecond      = 12,
		KilometersPerHour    = 13,
		MilesPerHour         = 14,
		Celsius              = 15,
		Farenheit            = 16,
		Kelvin               = 17,
		Micrograms           = 18,
		Milligrams           = 19,
		Grams                = 20,
		Kilograms            = 21,
		MetricTons           = 22,
		Ounces               = 23,
		Pounds               = 24,
		Stones               = 25,
		Newtons              = 26,
		PoundsForce          = 27,
		KilogramsForce       = 28,
		Hertz                = 29,
		Kilohertz            = 30,
		Megahertz            = 31,
		Gigahertz            = 32,
		RevolutionsPerMinute = 33,
		Bytes                = 34,
		Kilobytes            = 35,
		Megabytes            = 36,
		Gigabytes            = 37,
		Terabytes            = 38,
		Lumens               = 39,
		Milliseconds         = 40,
		Seconds              = 41,
		Minutes              = 42,
		Hours                = 43,
		Days                 = 44,
		Months               = 45,
		Years                = 46,
		Multiplier           = 47,
		Percentage           = 48,
		Unspecified          = 49,
		MAX                  = 50
	};

	/**
	 * Enum CoreUObject.EPixelFormat
	 */
	enum class EPixelFormat : uint8_t
	{
		PF_Unknown            = 0,
		PF_A32B32G32R32F      = 1,
		PF_B8G8R8A8           = 2,
		PF_G8                 = 3,
		PF_G16                = 4,
		PF_DXT1               = 5,
		PF_DXT3               = 6,
		PF_DXT5               = 7,
		PF_UYVY               = 8,
		PF_FloatRGB           = 9,
		PF_FloatRGBA          = 10,
		PF_DepthStencil       = 11,
		PF_ShadowDepth        = 12,
		PF_R32_FLOAT          = 13,
		PF_G16R16             = 14,
		PF_G16R16F            = 15,
		PF_G16R16F_FILTER     = 16,
		PF_G32R32F            = 17,
		PF_A2B10G10R10        = 18,
		PF_A16B16G16R16       = 19,
		PF_D24                = 20,
		PF_R16F               = 21,
		PF_R16F_FILTER        = 22,
		PF_BC5                = 23,
		PF_V8U8               = 24,
		PF_A1                 = 25,
		PF_FloatR11G11B10     = 26,
		PF_A8                 = 27,
		PF_R32_UINT           = 28,
		PF_R32_SINT           = 29,
		PF_PVRTC2             = 30,
		PF_PVRTC4             = 31,
		PF_R16_UINT           = 32,
		PF_R16_SINT           = 33,
		PF_R16G16B16A16_UINT  = 34,
		PF_R16G16B16A16_SINT  = 35,
		PF_R5G6B5_UNORM       = 36,
		PF_R8G8B8A8           = 37,
		PF_A8R8G8B8           = 38,
		PF_BC4                = 39,
		PF_R8G8               = 40,
		PF_ATC_RGB            = 41,
		PF_ATC_RGBA_E         = 42,
		PF_ATC_RGBA_I         = 43,
		PF_X24_G8             = 44,
		PF_ETC1               = 45,
		PF_ETC2_RGB           = 46,
		PF_ETC2_RGBA          = 47,
		PF_R32G32B32A32_UINT  = 48,
		PF_R16G16_UINT        = 49,
		PF_ASTC_4x4           = 50,
		PF_ASTC_6x6           = 51,
		PF_ASTC_8x8           = 52,
		PF_ASTC_10x10         = 53,
		PF_ASTC_12x12         = 54,
		PF_BC6H               = 55,
		PF_BC7                = 56,
		PF_R8_UINT            = 57,
		PF_L8                 = 58,
		PF_XGXR8              = 59,
		PF_R8G8B8A8_UINT      = 60,
		PF_R8G8B8A8_SNORM     = 61,
		PF_R16G16B16A16_UNORM = 62,
		PF_R16G16B16A16_SNORM = 63,
		PF_PLATFORM_HDR       = 64,
		PF_PLATFORM_HDR01     = 65,
		PF_PLATFORM_HDR02     = 66,
		PF_NV12               = 67,
		PF_R32G32_UINT        = 68,
		PF_ETC2_R11_EAC       = 69,
		PF_ETC2_RG11_EAC      = 70,
		_PF_MAX_              = 71
	};

	/**
	 * Enum CoreUObject.EAxis
	 */
	enum class EAxis : uint8_t
	{
		None = 0,
		X    = 1,
		Y    = 2,
		Z    = 3,
		MAX  = 4
	};

	/**
	 * Enum CoreUObject.ELogTimes
	 */
	enum class ELogTimes : uint8_t
	{
		None            = 0,
		UTC             = 1,
		SinceGStartTime = 2,
		Local           = 3,
		MAX             = 4
	};

	/**
	 * Enum CoreUObject.ESearchDir
	 */
	enum class ESearchDir : uint8_t
	{
		FromStart = 0,
		FromEnd   = 1,
		MAX       = 2
	};

	/**
	 * Enum CoreUObject.ESearchCase
	 */
	enum class ESearchCase : uint8_t
	{
		CaseSensitive = 0,
		IgnoreCase    = 1,
		MAX           = 2
	};

	// --------------------------------------------------
	// # Structs
	// --------------------------------------------------
	/**
	 * ScriptStruct CoreUObject.JoinabilitySettings
	 * Size -> 0x0014
	 */
	struct FJoinabilitySettings
	{
	public:
		class FName                                                SessionName;                                             // 0x0000(0x0008) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		bool                                                       bPublicSearchable;                                       // 0x0008(0x0001) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		bool                                                       bAllowInvites;                                           // 0x0009(0x0001) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		bool                                                       bJoinViaPresence;                                        // 0x000A(0x0001) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		bool                                                       bJoinViaPresenceFriendsOnly;                             // 0x000B(0x0001) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    MaxPlayers;                                              // 0x000C(0x0004) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    MaxPartySize;                                            // 0x0010(0x0004) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.UniqueNetIdWrapper
	 * Size -> 0x0001
	 */
	struct FUniqueNetIdWrapper
	{
	public:
		unsigned char                                              UnknownData_BIXJ[0x1];                                   // 0x0000(0x0001) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.Guid
	 * Size -> 0x0010
	 */
	struct FGuid
	{
	public:
		int32_t                                                    A;                                                       // 0x0000(0x0004) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    B;                                                       // 0x0004(0x0004) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    C;                                                       // 0x0008(0x0004) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    D;                                                       // 0x000C(0x0004) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.Rotator
	 * Size -> 0x000C
	 */
	struct FRotator
	{
	public:
		float                                                      Pitch;                                                   // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      Yaw;                                                     // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      Roll;                                                    // 0x0008(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic

	public:
		FRotator();
		FRotator(float pitch, float yaw, float roll);
		FRotator operator +(float scalar) const;
		FRotator operator +(const FRotator& other) const;
		FRotator operator -(float scalar) const;
		FRotator operator -(const FRotator& other) const;
		FRotator operator *(float scalar) const;
		FRotator operator *(const FRotator& other) const;
		FRotator operator /(float scalar) const;
		FRotator operator /(const FRotator& other) const;
		FRotator& operator =(const FRotator& other);
		FRotator& operator +=(float scalar);
		FRotator& operator +=(const FRotator& other);
		FRotator& operator -=(float scalar);
		FRotator& operator -=(const FRotator& other);
		FRotator& operator *=(const FRotator& other);
		FRotator& operator *=(const float other);
		FRotator& operator /=(const FRotator& other);
		FRotator& operator /=(const float other);
		float Size() const;
		FRotator Clamp() const;
	};

	/**
	 * ScriptStruct CoreUObject.Vector
	 * Size -> 0x000C
	 */
	struct FVector
	{
	public:
		float                                                      X;                                                       // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      Y;                                                       // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      Z;                                                       // 0x0008(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic

	public:
		FVector();
		FVector(float x, float y, float z);
		FVector operator +(float scalar) const;
		FVector operator +(const FVector& other) const;
		FVector operator -(float scalar) const;
		FVector operator -(const FVector& other) const;
		FVector operator *(float scalar) const;
		FVector operator *(const FVector& other) const;
		FVector operator /(float scalar) const;
		FVector operator /(const FVector& other) const;
		FVector& operator =(const FVector& other);
		FVector& operator +=(float scalar);
		FVector& operator +=(const FVector& other);
		FVector& operator -=(float scalar);
		FVector& operator -=(const FVector& other);
		FVector& operator *=(const FVector& other);
		FVector& operator *=(float scalar);
		bool IsValid();
		void Normalize360(FVector& angle);
		float Dot(const FVector& b) const;
		float MagnitudeSqr() const;
		float Magnitude() const;
		FVector Unit() const;
		FRotator ToRotator() const;
		float Distance(const FVector& v) const;
		float DistanceMeter(FVector& v) const;
		friend bool operator ==(const FVector& first, const FVector& second)
		{
			return first.X == second.X && first.Y == second.Y && first.Z == second.Z;
		}

		friend bool operator !=(const FVector& first, const FVector& second)
		{
			return !(first == second);
		}

	};

	/**
	 * ScriptStruct CoreUObject.Vector4
	 * Size -> 0x0010
	 */
	struct FVector4
	{
	public:
		float                                                      X;                                                       // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      Y;                                                       // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      Z;                                                       // 0x0008(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      W;                                                       // 0x000C(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.Vector2D
	 * Size -> 0x0008
	 */
	struct FVector2D
	{
	public:
		float                                                      X;                                                       // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      Y;                                                       // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic

	public:
		FVector2D();
		FVector2D(float x, float y);
		bool IsValid();
		float Distance(FVector2D& v) const;
		FVector2D operator +(const FVector2D& other) const;
		FVector2D operator +(float scalar) const;
		FVector2D operator -(float scalar) const;
		FVector2D operator -(const FVector2D& other) const;
		FVector2D operator *(float scalar) const;
		FVector2D operator *(const FVector2D& other) const;
		FVector2D operator /(float scalar) const;
		FVector2D operator /(const FVector2D& other) const;
		FVector2D& operator =(const FVector2D& other);
		FVector2D& operator +=(float scalar);
		FVector2D& operator +=(const FVector2D& other);
		FVector2D& operator -=(float scalar);
		FVector2D& operator -=(const FVector2D& other);
		FVector2D& operator *=(const FVector2D& other);
		FVector2D& operator *=(float scalar);
	};

	/**
	 * ScriptStruct CoreUObject.TwoVectors
	 * Size -> 0x0018
	 */
	struct FTwoVectors
	{
	public:
		struct FVector                                             v1;                                                      // 0x0000(0x000C) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector                                             v2;                                                      // 0x000C(0x000C) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.Plane
	 * Size -> 0x0004 (FullSize[0x0010] - InheritedSize[0x000C])
	 */
	struct FPlane : public FVector
	{
	public:
		float                                                      W;                                                       // 0x000C(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.Quat
	 * Size -> 0x0010
	 */
	struct FQuat
	{
	public:
		float                                                      X;                                                       // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      Y;                                                       // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      Z;                                                       // 0x0008(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      W;                                                       // 0x000C(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.PackedNormal
	 * Size -> 0x0004
	 */
	struct FPackedNormal
	{
	public:
		unsigned char                                              X;                                                       // 0x0000(0x0001) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              Y;                                                       // 0x0001(0x0001) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              Z;                                                       // 0x0002(0x0001) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              W;                                                       // 0x0003(0x0001) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.PackedRGB10A2N
	 * Size -> 0x0004
	 */
	struct FPackedRGB10A2N
	{
	public:
		int32_t                                                    Packed;                                                  // 0x0000(0x0004) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.PackedRGBA16N
	 * Size -> 0x0008
	 */
	struct FPackedRGBA16N
	{
	public:
		int32_t                                                    XY;                                                      // 0x0000(0x0004) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    ZW;                                                      // 0x0004(0x0004) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.IntPoint
	 * Size -> 0x0008
	 */
	struct FIntPoint
	{
	public:
		int32_t                                                    X;                                                       // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    Y;                                                       // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.IntVector
	 * Size -> 0x000C
	 */
	struct FIntVector
	{
	public:
		int32_t                                                    X;                                                       // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    Y;                                                       // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    Z;                                                       // 0x0008(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.Color
	 * Size -> 0x0004
	 */
	struct FColor
	{
	public:
		unsigned char                                              B;                                                       // 0x0000(0x0001) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              G;                                                       // 0x0001(0x0001) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              R;                                                       // 0x0002(0x0001) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              A;                                                       // 0x0003(0x0001) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.LinearColor
	 * Size -> 0x0010
	 */
	struct FLinearColor
	{
	public:
		float                                                      R;                                                       // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      G;                                                       // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      B;                                                       // 0x0008(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      A;                                                       // 0x000C(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic

	public:
		FLinearColor();
		FLinearColor(float r, float g, float b, float a);
	};

	/**
	 * ScriptStruct CoreUObject.Box
	 * Size -> 0x001C
	 */
	struct FBox
	{
	public:
		struct FVector                                             Min;                                                     // 0x0000(0x000C) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector                                             Max;                                                     // 0x000C(0x000C) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              IsValid;                                                 // 0x0018(0x0001) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_2TKS[0x3];                                   // 0x0019(0x0003) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.Box2D
	 * Size -> 0x0014
	 */
	struct FBox2D
	{
	public:
		struct FVector2D                                           Min;                                                     // 0x0000(0x0008) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector2D                                           Max;                                                     // 0x0008(0x0008) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              bIsValid;                                                // 0x0010(0x0001) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_D3G5[0x3];                                   // 0x0011(0x0003) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.BoxSphereBounds
	 * Size -> 0x001C
	 */
	struct FBoxSphereBounds
	{
	public:
		struct FVector                                             Origin;                                                  // 0x0000(0x000C) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector                                             BoxExtent;                                               // 0x000C(0x000C) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      SphereRadius;                                            // 0x0018(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.OrientedBox
	 * Size -> 0x003C
	 */
	struct FOrientedBox
	{
	public:
		struct FVector                                             Center;                                                  // 0x0000(0x000C) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector                                             AxisX;                                                   // 0x000C(0x000C) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector                                             AxisY;                                                   // 0x0018(0x000C) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector                                             AxisZ;                                                   // 0x0024(0x000C) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      ExtentX;                                                 // 0x0030(0x0004) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      ExtentY;                                                 // 0x0034(0x0004) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      ExtentZ;                                                 // 0x0038(0x0004) Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.Matrix
	 * Size -> 0x0040
	 */
	struct FMatrix
	{
	public:
		struct FPlane                                              XPlane;                                                  // 0x0000(0x0010) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FPlane                                              YPlane;                                                  // 0x0010(0x0010) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FPlane                                              ZPlane;                                                  // 0x0020(0x0010) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FPlane                                              WPlane;                                                  // 0x0030(0x0010) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic

	public:
		FMatrix operator *(const FMatrix& other) const;
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurvePointFloat
	 * Size -> 0x0014
	 */
	struct FInterpCurvePointFloat
	{
	public:
		float                                                      InVal;                                                   // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      OutVal;                                                  // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      ArriveTangent;                                           // 0x0008(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      LeaveTangent;                                            // 0x000C(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		EInterpCurveMode                                           InterpMode;                                              // 0x0010(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_W6NQ[0x3];                                   // 0x0011(0x0003) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurveFloat
	 * Size -> 0x0018
	 */
	struct FInterpCurveFloat
	{
	public:
		TArray<struct FInterpCurvePointFloat>                      Points;                                                  // 0x0000(0x0010) Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		bool                                                       bIsLooped;                                               // 0x0010(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_61QV[0x3];                                   // 0x0011(0x0003) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		float                                                      LoopKeyOffset;                                           // 0x0014(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurvePointVector2D
	 * Size -> 0x0020
	 */
	struct FInterpCurvePointVector2D
	{
	public:
		float                                                      InVal;                                                   // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector2D                                           OutVal;                                                  // 0x0004(0x0008) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector2D                                           ArriveTangent;                                           // 0x000C(0x0008) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector2D                                           LeaveTangent;                                            // 0x0014(0x0008) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		EInterpCurveMode                                           InterpMode;                                              // 0x001C(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_N61P[0x3];                                   // 0x001D(0x0003) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurveVector2D
	 * Size -> 0x0018
	 */
	struct FInterpCurveVector2D
	{
	public:
		TArray<struct FInterpCurvePointVector2D>                   Points;                                                  // 0x0000(0x0010) Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		bool                                                       bIsLooped;                                               // 0x0010(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_125D[0x3];                                   // 0x0011(0x0003) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		float                                                      LoopKeyOffset;                                           // 0x0014(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurvePointVector
	 * Size -> 0x002C
	 */
	struct FInterpCurvePointVector
	{
	public:
		float                                                      InVal;                                                   // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector                                             OutVal;                                                  // 0x0004(0x000C) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector                                             ArriveTangent;                                           // 0x0010(0x000C) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FVector                                             LeaveTangent;                                            // 0x001C(0x000C) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		EInterpCurveMode                                           InterpMode;                                              // 0x0028(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_VNGX[0x3];                                   // 0x0029(0x0003) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurveVector
	 * Size -> 0x0018
	 */
	struct FInterpCurveVector
	{
	public:
		TArray<struct FInterpCurvePointVector>                     Points;                                                  // 0x0000(0x0010) Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		bool                                                       bIsLooped;                                               // 0x0010(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_85H5[0x3];                                   // 0x0011(0x0003) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		float                                                      LoopKeyOffset;                                           // 0x0014(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurvePointQuat
	 * Size -> 0x0050
	 */
	struct FInterpCurvePointQuat
	{
	public:
		float                                                      InVal;                                                   // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_S09S[0xC];                                   // 0x0004(0x000C) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		struct FQuat                                               OutVal;                                                  // 0x0010(0x0010) Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic
		struct FQuat                                               ArriveTangent;                                           // 0x0020(0x0010) Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic
		struct FQuat                                               LeaveTangent;                                            // 0x0030(0x0010) Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic
		EInterpCurveMode                                           InterpMode;                                              // 0x0040(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_C0QG[0xF];                                   // 0x0041(0x000F) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurveQuat
	 * Size -> 0x0018
	 */
	struct FInterpCurveQuat
	{
	public:
		TArray<struct FInterpCurvePointQuat>                       Points;                                                  // 0x0000(0x0010) Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		bool                                                       bIsLooped;                                               // 0x0010(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_JP5L[0x3];                                   // 0x0011(0x0003) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		float                                                      LoopKeyOffset;                                           // 0x0014(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurvePointTwoVectors
	 * Size -> 0x0050
	 */
	struct FInterpCurvePointTwoVectors
	{
	public:
		float                                                      InVal;                                                   // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FTwoVectors                                         OutVal;                                                  // 0x0004(0x0018) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic
		struct FTwoVectors                                         ArriveTangent;                                           // 0x001C(0x0018) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic
		struct FTwoVectors                                         LeaveTangent;                                            // 0x0034(0x0018) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic
		EInterpCurveMode                                           InterpMode;                                              // 0x004C(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_TPVK[0x3];                                   // 0x004D(0x0003) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurveTwoVectors
	 * Size -> 0x0018
	 */
	struct FInterpCurveTwoVectors
	{
	public:
		TArray<struct FInterpCurvePointTwoVectors>                 Points;                                                  // 0x0000(0x0010) Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		bool                                                       bIsLooped;                                               // 0x0010(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_40K7[0x3];                                   // 0x0011(0x0003) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		float                                                      LoopKeyOffset;                                           // 0x0014(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurvePointLinearColor
	 * Size -> 0x0038
	 */
	struct FInterpCurvePointLinearColor
	{
	public:
		float                                                      InVal;                                                   // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FLinearColor                                        OutVal;                                                  // 0x0004(0x0010) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FLinearColor                                        ArriveTangent;                                           // 0x0014(0x0010) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FLinearColor                                        LeaveTangent;                                            // 0x0024(0x0010) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		EInterpCurveMode                                           InterpMode;                                              // 0x0034(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_JN00[0x3];                                   // 0x0035(0x0003) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.InterpCurveLinearColor
	 * Size -> 0x0018
	 */
	struct FInterpCurveLinearColor
	{
	public:
		TArray<struct FInterpCurvePointLinearColor>                Points;                                                  // 0x0000(0x0010) Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		bool                                                       bIsLooped;                                               // 0x0010(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_D4GE[0x3];                                   // 0x0011(0x0003) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		float                                                      LoopKeyOffset;                                           // 0x0014(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.Transform
	 * Size -> 0x0030
	 */
	struct FTransform
	{
	public:
		struct FQuat                                               Rotation;                                                // 0x0000(0x0010) Edit, BlueprintVisible, SaveGame, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic
		struct FVector                                             Translation;                                             // 0x0010(0x000C) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_99P9[0x4];                                   // 0x001C(0x0004) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		struct FVector                                             Scale3D;                                                 // 0x0020(0x000C) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_LDH0[0x4];                                   // 0x002C(0x0004) MISSED OFFSET (PADDING)

	public:
		FMatrix ToMatrixWithScale() const;
	};

	/**
	 * ScriptStruct CoreUObject.RandomStream
	 * Size -> 0x0008
	 */
	struct FRandomStream
	{
	public:
		int32_t                                                    InitialSeed;                                             // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    Seed;                                                    // 0x0004(0x0004) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.DateTime
	 * Size -> 0x0008
	 */
	struct FDateTime
	{
	public:
		unsigned char                                              UnknownData_B9XD[0x8];                                   // 0x0000(0x0008) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.FrameNumber
	 * Size -> 0x0004
	 */
	struct FFrameNumber
	{
	public:
		int32_t                                                    Value;                                                   // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.FrameRate
	 * Size -> 0x0008
	 */
	struct FFrameRate
	{
	public:
		int32_t                                                    Numerator;                                               // 0x0000(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    Denominator;                                             // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.FrameTime
	 * Size -> 0x0008
	 */
	struct FFrameTime
	{
	public:
		struct FFrameNumber                                        FrameNumber;                                             // 0x0000(0x0004) BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      SubFrame;                                                // 0x0004(0x0004) BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.QualifiedFrameTime
	 * Size -> 0x0010
	 */
	struct FQualifiedFrameTime
	{
	public:
		struct FFrameTime                                          Time;                                                    // 0x0000(0x0008) BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FFrameRate                                          Rate;                                                    // 0x0008(0x0008) BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.Timecode
	 * Size -> 0x0014
	 */
	struct FTimecode
	{
	public:
		int32_t                                                    Hours;                                                   // 0x0000(0x0004) BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    Minutes;                                                 // 0x0004(0x0004) BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    Seconds;                                                 // 0x0008(0x0004) BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    Frames;                                                  // 0x000C(0x0004) BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		bool                                                       bDropFrameFormat;                                        // 0x0010(0x0001) BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_K120[0x3];                                   // 0x0011(0x0003) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.Timespan
	 * Size -> 0x0008
	 */
	struct FTimespan
	{
	public:
		unsigned char                                              UnknownData_W280[0x8];                                   // 0x0000(0x0008) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.SoftObjectPath
	 * Size -> 0x0018
	 */
	struct FSoftObjectPath
	{
	public:
		class FName                                                AssetPathName;                                           // 0x0000(0x0008) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		class FString                                              SubPathString;                                           // 0x0008(0x0010) ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.SoftClassPath
	 * Size -> 0x0000 (FullSize[0x0018] - InheritedSize[0x0018])
	 */
	struct FSoftClassPath : public FSoftObjectPath
	{	};

	/**
	 * ScriptStruct CoreUObject.PrimaryAssetType
	 * Size -> 0x0008
	 */
	struct FPrimaryAssetType
	{
	public:
		class FName                                                Name;                                                    // 0x0000(0x0008) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.PrimaryAssetId
	 * Size -> 0x0010
	 */
	struct FPrimaryAssetId
	{
	public:
		struct FPrimaryAssetType                                   PrimaryAssetType;                                        // 0x0000(0x0008) Edit, BlueprintVisible, ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		class FName                                                PrimaryAssetName;                                        // 0x0008(0x0008) Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.FallbackStruct
	 * Size -> 0x0001
	 */
	struct FFallbackStruct
	{
	public:
		unsigned char                                              UnknownData_JCOY[0x1];                                   // 0x0000(0x0001) MISSED OFFSET (PADDING)
	};

	/**
	 * ScriptStruct CoreUObject.FloatRangeBound
	 * Size -> 0x0008
	 */
	struct FFloatRangeBound
	{
	public:
		ERangeBoundTypes                                           Type;                                                    // 0x0000(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_TFVP[0x3];                                   // 0x0001(0x0003) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		float                                                      Value;                                                   // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.FloatRange
	 * Size -> 0x0010
	 */
	struct FFloatRange
	{
	public:
		struct FFloatRangeBound                                    LowerBound;                                              // 0x0000(0x0008) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FFloatRangeBound                                    UpperBound;                                              // 0x0008(0x0008) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.Int32RangeBound
	 * Size -> 0x0008
	 */
	struct FInt32RangeBound
	{
	public:
		ERangeBoundTypes                                           Type;                                                    // 0x0000(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_132F[0x3];                                   // 0x0001(0x0003) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		int32_t                                                    Value;                                                   // 0x0004(0x0004) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.Int32Range
	 * Size -> 0x0010
	 */
	struct FInt32Range
	{
	public:
		struct FInt32RangeBound                                    LowerBound;                                              // 0x0000(0x0008) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FInt32RangeBound                                    UpperBound;                                              // 0x0008(0x0008) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.FloatInterval
	 * Size -> 0x0008
	 */
	struct FFloatInterval
	{
	public:
		float                                                      Min;                                                     // 0x0000(0x0004) Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		float                                                      Max;                                                     // 0x0004(0x0004) Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.Int32Interval
	 * Size -> 0x0008
	 */
	struct FInt32Interval
	{
	public:
		int32_t                                                    Min;                                                     // 0x0000(0x0004) Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    Max;                                                     // 0x0004(0x0004) Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.PolyglotTextData
	 * Size -> 0x00B8
	 */
	struct FPolyglotTextData
	{
	public:
		ELocalizedTextSourceCategory                               Category;                                                // 0x0000(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_3XXD[0x7];                                   // 0x0001(0x0007) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		class FString                                              NativeCulture;                                           // 0x0008(0x0010) Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		class FString                                              Namespace;                                               // 0x0018(0x0010) Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		class FString                                              Key;                                                     // 0x0028(0x0010) Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		class FString                                              NativeString;                                            // 0x0038(0x0010) Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		TMap<class FString, class FString>                         LocalizedStrings;                                        // 0x0048(0x0050) Edit, BlueprintVisible, NativeAccessSpecifierPublic
		bool                                                       bIsMinimalPatch;                                         // 0x0098(0x0001) Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_X8TK[0x7];                                   // 0x0099(0x0007) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		class FText                                                CachedText;                                              // 0x00A0(0x0018) Transient, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.AutomationEvent
	 * Size -> 0x0038
	 */
	struct FAutomationEvent
	{
	public:
		EAutomationEventType                                       Type;                                                    // 0x0000(0x0001) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_HUNG[0x7];                                   // 0x0001(0x0007) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		class FString                                              Message;                                                 // 0x0008(0x0010) ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		class FString                                              Context;                                                 // 0x0018(0x0010) ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		struct FGuid                                               Artifact;                                                // 0x0028(0x0010) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

	/**
	 * ScriptStruct CoreUObject.AutomationExecutionEntry
	 * Size -> 0x0058
	 */
	struct FAutomationExecutionEntry
	{
	public:
		struct FAutomationEvent                                    Event;                                                   // 0x0000(0x0038) ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		class FString                                              Filename;                                                // 0x0038(0x0010) ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		int32_t                                                    LineNumber;                                              // 0x0048(0x0004) ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
		unsigned char                                              UnknownData_HB3S[0x4];                                   // 0x004C(0x0004) MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
		struct FDateTime                                           Timestamp;                                               // 0x0050(0x0008) ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
	};

}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif

```

`Dumper/engine_code/GlobalOffset.h`:

```h
#pragma once

/**
 * Name: VAR_GAME_NAME
 * Version: VAR_GAME_VERSION
 */
 
// Note: You should update the following offset by yourself!

#define PROCESS_EVENTS_INDEX 0x00
#define CREATE_DEFAULT_OBJECT_INDEX 0x00
#define POST_RENDER_INDEX 0x00
#define GET_BONE_MATRIX_OFFSET 0x00
#define GET_VIEW_POINT_INDEX 0x00
#define GET_PLAYER_VIEW_POINT_OFFSET 0x00

#define GOBJECT_OFFSET 0x00000000
#define GNAME_OFFSET 0x00000000
#define GWORLD_OFFSET 0x00000000
```

`Dumper/engine_code/Injected_GetBoneWorldPos.cpp`:

```cpp
	/**
	 * GetBoneWithRotation
	 */
	FVector USkeletalMeshComponent::GetBoneWorldPos(const int32_t& boneId) const
	{
		if (GET_BONE_MATRIX_OFFSET > 0x00)
		{
		
		   typedef void(*GetBoneMatrixType)(const USkinnedMeshComponent*, FMatrix&, int);
			static GetBoneMatrixType GetBoneMatrixPtr = nullptr;
			if (!GetBoneMatrixPtr)
				GetBoneMatrixPtr = reinterpret_cast<GetBoneMatrixType>((uintptr_t)GetModuleHandle(nullptr) + GET_BONE_MATRIX_OFFSET);
		
			FMatrix matrix;
			GetBoneMatrixPtr(this, matrix, boneId);
		
			return matrix.WPlane;
		}
		
		FVector worldPos{};
		
		const TArray<struct FTransform>& componentSpaceTransforms = CachedBoneSpaceTransforms/* CachedBoneSpaceTransforms */;
		int32_t componentToWorldOffset = 0x190 /* 0x190 || 0x1C0 || 0x1D0 || 0x250 */;
		
		if (boneId >= componentSpaceTransforms.Count())
			return worldPos;
		
		FMatrix targetBoneMatrix = componentSpaceTransforms[boneId].ToMatrixWithScale();
		FMatrix componentToWorldMatrix = (*reinterpret_cast<FTransform*>(reinterpret_cast<uintptr_t>(this) + componentToWorldOffset)).ToMatrixWithScale();
		FMatrix newMatrix = targetBoneMatrix * componentToWorldMatrix;
		
		worldPos = { newMatrix.WPlane.X, newMatrix.WPlane.Y, newMatrix.WPlane.Z };
		return worldPos;
	}

```

`Dumper/engine_code/fortest.txt`:

```txt
this is resource test!

```

`Dumper/generic.cpp`:

```cpp
#include "engine.h"
#include "memory.h"
#include "wrappers.h"

uint8* FNamePool::GetEntry(FNameEntryHandle handle) const {
	if (handle.Block >= 8192) return nullptr;
	return (uint8*)(Blocks[handle.Block] + offsets.Stride * (uint64)(handle.Offset));
}

void FNamePool::DumpBlock(uint32 blockId, uint32 blockSize, std::function<void(std::string_view, uint32)> callback) const {
	uint8* it = Blocks[blockId];
	uint8* end = it + blockSize - offsets.FNameEntry.HeaderSize;
	FNameEntryHandle entryHandle = { blockId, 0 };
	while (it < end) {
		auto entry = UE_FNameEntry(it);
		auto [wide, len] = entry.Info();
		if (len) {
			char buf[1024];
			entry.String(buf, wide, len);
			callback(std::string_view(buf), entryHandle);
			uint16 size = UE_FNameEntry::Size(wide, len);
			entryHandle.Offset += size / offsets.Stride;
			it += size;
		}
		else {
			break;
		};
	}
}

void FNamePool::Dump(std::function<void(std::string_view, uint32)> callback) const {
	for (uint32 i = 0; i < CurrentBlock; i++) {
		DumpBlock(i, offsets.Stride * 65536, callback);
	}
	DumpBlock(CurrentBlock, CurrentByteCursor, callback);
}

uint8* TUObjectArray::GetObjectPtr(uint32 id) const {
	if (id >= NumElements) return nullptr;
	uint64 chunkIndex = id / 65536;
	if (chunkIndex >= NumChunks) return nullptr;
	uint8* chunk = Read<uint8*>(Objects + chunkIndex);
	if (!chunk) return nullptr;
	uint32 withinChunkIndex = id % 65536 * offsets.FUObjectItem.Size;
	auto item = Read<uint8*>(chunk + withinChunkIndex);
	return item;
}

void TUObjectArray::Dump(std::function<void(uint8*)> callback) const {
	for (uint32 i = 0; i < NumElements; i++) {
		uint8* object = GetObjectPtr(i);
		if (!object) continue;
		callback(object);
	}
}

UE_UObject TUObjectArray::FindObject(const std::string& name) const {
	for (uint32 i = 0; i < NumElements; i++) {
		UE_UObject object = GetObjectPtr(i);
		if (object && object.GetFullName() == name) {
			return object;
		}
	}
	return nullptr;
}

void TUObjectArray::ForEachObjectOfClass(const UE_UClass cmp, std::function<bool(uint8*)> callback) const {
	for (uint32 i = 0; i < NumElements; i++) {
		UE_UObject object = GetObjectPtr(i);
		if (object && object.IsA(cmp) && object.GetName().find("_Default") == std::string::npos) {
			if (callback(object)) return;
		}
	}
}

bool TUObjectArray::IsObject(UE_UObject address) const {
	for (uint32 i = 0; i < NumElements; i++) {
		UE_UObject object = GetObjectPtr(i);
		if (address == object) {
			return true;
		}
	}
	return false;
}

TUObjectArray ObjObjects;
FNamePool NamePoolData;

```

`Dumper/generic.h`:

```h
#pragma once
#include "defs.h"
#include <functional>
#include <string>
#include <string_view>

struct TArray {
  uint8* Data;
  uint32 Count;
  uint32 Max;
};

struct FNameEntryHandle {
  uint32 Block = 0;
  uint32 Offset = 0;
  FNameEntryHandle(uint32 block, uint32 offset) : Block(block), Offset(offset){};
  FNameEntryHandle(uint32 id) : Block(id >> 16), Offset(id & 65535){};
  operator uint32() const { return (Block << 16 | Offset); }
};

struct FNamePool {
  uint8 Lock[8];
  uint32 CurrentBlock;
  uint32 CurrentByteCursor;
  uint8* Blocks[8192];
  uint8* GetEntry(FNameEntryHandle handle) const;
  void DumpBlock(uint32 blockId, uint32 blockSize, std::function<void(std::string_view, uint32)> callback) const;
  void Dump(std::function<void(std::string_view, uint32)> callback) const;
};

struct TUObjectArray {
  uint8** Objects;
  uint8* PreAllocatedObjects;
  uint32 MaxElements;
  uint32 NumElements;
  uint32 MaxChunks;
  uint32 NumChunks;

  uint8* GetObjectPtr(uint32 id) const;
  void Dump(std::function<void(uint8*)> callback) const;
  class UE_UObject FindObject(const std::string &name) const;
  void ForEachObjectOfClass(const class UE_UClass cmp, std::function<bool(uint8*)> callback) const;
  bool IsObject(UE_UObject address) const;
};

extern TUObjectArray ObjObjects;
extern FNamePool NamePoolData;

```

`Dumper/main.cpp`:

```cpp
#include <fmt/core.h>
#include "dumper.h"
#include "utils.h"

int main(int argc, char* argv[])
{
    uint64 start;
    uint64 end;
    uint64 time;


    auto dumper = Dumper::GetInstance();

    start = GetTime();
    switch (dumper->Init(argc, argv))
    {
    case STATUS::WINDOW_NOT_FOUND: { puts("Can't find UE4 window"); return 1; }
    case STATUS::PROCESS_NOT_FOUND: { puts("Can't find process"); return 1; }
    case STATUS::READER_ERROR: { puts("Can't init reader"); return 1; }
    case STATUS::CANNOT_GET_PROCNAME: { puts("Can't get process name"); return 1; }
    case STATUS::ENGINE_NOT_FOUND: { puts("Can't find offsets for this game"); return 1; }
    case STATUS::ENGINE_FAILED: { puts("Can't init engine for this game"); return 1; }
    case STATUS::MODULE_NOT_FOUND: { puts("Can't enumerate modules (protected process?)"); return 1; }
    case STATUS::CANNOT_READ: { puts("Can't read process memory"); return 1; }
    case STATUS::INVALID_IMAGE: { puts("Can't get executable sections"); return 1; }
    case STATUS::SUCCESS: { break; };
    default: { return 1; }
    }
    end = GetTime();
    time = (end - start) / 10000;
    fmt::print("Init time: {} ms\n", time);

    start = GetTime();
    switch (dumper->Dump())
    {
    case STATUS::FILE_NOT_OPEN: { puts("Can't open file"); return 1; }
    case STATUS::ZERO_PACKAGES: { puts("Size of packages is zero"); return 1; }
    case STATUS::SUCCESS: { break; }
    default: { return 1; }
    }
    end = GetTime();
    time = (end - start) / 10000;
    fmt::print("Dump time: {} ms\n", time);

    return 0;
}

```

`Dumper/memory.cpp`:

```cpp
#include <Windows.h>
#include <winternl.h>
#include "memory.h"

HANDLE hProcess;
uint64 Base;

bool Read(void* address, void* buffer, uint64 size) {
	uint64 read;
	return ReadProcessMemory(hProcess, address, buffer, size, &read) && read == size;
}

bool ReaderInit(uint32 pid) {
	PROCESS_BASIC_INFORMATION pbi;
	hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, 0, pid);
	if (!hProcess) return false;
	if (0 > NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), 0)) goto failed;
	Base = Read<uint64>((uint8*)pbi.PebBaseAddress + 0x10);
	if (!Base) goto failed;
	return true;
failed:
	CloseHandle(hProcess);
	return false;
}

uint64 GetImageSize() {
	char buffer[0x400];
	if (!Read((void*)Base, buffer, 0x400)) return 0;
	auto nt = (PIMAGE_NT_HEADERS)(buffer + ((PIMAGE_DOS_HEADER)buffer)->e_lfanew);
	return nt->OptionalHeader.SizeOfImage;
}

```

`Dumper/memory.h`:

```h
#pragma once
#include "defs.h"

extern uint64 Base;

bool Read(void* address, void* buffer, uint64 size);
template <typename T> T Read(void *address) {
  T buffer{};
  Read(address, &buffer, sizeof(T));
  return buffer;
}

bool ReaderInit(uint32 pid);

uint64 GetImageSize();

```

`Dumper/relation.txt`:

```txt
GameplayAbilities referes BasicTypes
GameplayAbilities referes CoreUObject
GameplayAbilities referes CppTypes
GameplayAbilities referes Engine
GameplayAbilities referes GameplayTags
GameplayAbilities referes GameplayTasks
ABPC_Seq_Interface referes CoreUObject
ABPC_Seq_Interface referes CppTypes
BP_SplineMoveConfig referes CoreUObject
BP_SplineMoveConfig referes CppTypes
BP_SplineMoveConfig referes Engine
TsDecoratorWaitSwitchControl referes AIModule
TsDecoratorWaitSwitchControl referes CoreUObject
TsDecoratorWaitSwitchControl referes CppTypes
Engine referes AudioExtensions
Engine referes AudioPlatformConfiguration
Engine referes BasicTypes
Engine referes Chaos
Engine referes ClothingSystemRuntimeInterface
Engine referes CoreUObject
Engine referes CppTypes
Engine referes DeveloperSettings
Engine referes InputCore
Engine referes PacketHandler
Engine referes PhysicsCore
Engine referes PropertyAccess
Engine referes Slate
Engine referes SlateCore
Engine referes StaticMeshDescription
KuroBackgroundDownload referes BasicTypes
KuroBackgroundDownload referes CoreUObject
KuroBackgroundDownload referes CppTypes
KawaiiPhysics referes AnimGraphRuntime
KawaiiPhysics referes BasicTypes
KawaiiPhysics referes CoreUObject
KawaiiPhysics referes CppTypes
KawaiiPhysics referes Engine
SEffectData referes CoreUObject
SGEData referes BasicTypes
SGEData referes CoreUObject
SGEData referes CppTypes
WP_Overcast referes CoreUObject
WP_Overcast referes WeatherPreset
WwiseResourceLoader referes BasicTypes
WwiseResourceLoader referes CoreUObject
WwiseResourceLoader referes CppTypes
WwiseResourceLoader referes Engine
WwiseResourceLoader referes WwiseFileHandler
GameplayTasks referes BasicTypes
GameplayTasks referes CoreUObject
GameplayTasks referes CppTypes
GameplayTasks referes Engine
KuroDevice referes CoreUObject
KuroDevice referes CppTypes
KuroDevice referes Engine
BP_CameraConfig referes CoreUObject
BP_CameraConfig referes CppTypes
BP_CameraConfig referes Engine
SWeaponMaterialParams referes CoreUObject
json2struct referes BasicTypes
json2struct referes CoreUObject
json2struct referes Engine
SimpleNpcFlowData referes BasicTypes
SimpleNpcFlowData referes CoreUObject
SimpleNpcFlowData referes CppTypes
SimpleNpcFlowData referes ESimpleNpcFlowCheckType
SimpleNpcFlowData referes ESimpleNpcFlowIndex
SimpleNpcFlowData referes SimplpNpcStateData
KuroSceneInteraction_57 referes CoreUObject
KuroSceneInteraction_57 referes Engine
SQLiteCore referes CoreUObject
SQLiteCore referes CppTypes
TsAnimNotifyStateSetMovementMode referes BasicTypes
TsAnimNotifyStateSetMovementMode referes CoreUObject
TsAnimNotifyStateSetMovementMode referes CppTypes
TsAnimNotifyStateSetMovementMode referes Engine
TsAnimNotifyStateSetMovementMode referes KuroRenderingRuntimeBPPlugin
WwiseFileHandler referes BasicTypes
WwiseFileHandler referes CoreUObject
WwiseFileHandler referes CppTypes
WwiseFileHandler referes Engine
WwiseFileHandler referes WwiseObjectUtils
BP_SuperFarFog referes BP_GlobalGI
BP_SuperFarFog referes CoreUObject
BP_SuperFarFog referes CppTypes
BP_SuperFarFog referes Engine
BP_SuperFarFog referes KuroCurve
BP_SuperFarFog referes KuroRenderingRuntimeBPPlugin
AkAudio referes BasicTypes
AkAudio referes CoreUObject
AkAudio referes CppTypes
AkAudio referes Engine
AkAudio referes MovieScene
AkAudio referes SlateCore
AkAudio referes UMG
AkAudio referes WwiseObjectUtils
AkAudio referes WwiseResourceLoader
LGUI referes AkAudio
LGUI referes BasicTypes
LGUI referes CoreUObject
LGUI referes CppTypes
LGUI referes Engine
LGUI referes InputCore
LGUI referes KuroCurve
LGUI referes KuroDynamicAtlas
LGUI referes LTween
LGUI referes LevelSequence
LGUI referes MovieScene
LGUI referes Niagara
LGUI referes Slate
LGUI referes SlateCore
LGUI referes SpinePlugin
PropertyAccess referes BasicTypes
PropertyAccess referes CoreUObject
PropertyAccess referes CppTypes
KuroLogAnalyzer referes CoreUObject
KuroLogAnalyzer referes CppTypes
KuroLogAnalyzer referes Engine
SCameraDebugTool_CameraFrameInfoRegion referes CoreUObject
SCameraDebugTool_CameraFrameInfoRegion referes CppTypes
WP_Sunny referes CoreUObject
WP_Sunny referes WeatherPreset
Niagara referes BasicTypes
Niagara referes CoreUObject
Niagara referes CppTypes
Niagara referes DeveloperSettings
Niagara referes Engine
Niagara referes MovieScene
Niagara referes NiagaraCore
Niagara referes NiagaraShader
BP_Cinematics_Tick referes CoreUObject
BP_Cinematics_Tick referes CppTypes
BP_Cinematics_Tick referes Engine
BP_Cinematics_Tick referes KuroGAS
BP_Cinematics_Tick referes KuroRenderingRuntimeBPPlugin
SSeqOptionJumpGroup referes BasicTypes
SSeqOptionJumpGroup referes CoreUObject
SSeqOptionJumpGroup referes CppTypes
SSeqCharacterBlend referes BasicTypes
SSeqCharacterBlend referes CoreUObject
SSeqCharacterBlend referes CppTypes
SSeqCharacterBlend referes Engine
Puerts referes BasicTypes
Puerts referes CoreUObject
Puerts referes CppTypes
Puerts referes Engine
LTween referes BasicTypes
LTween referes CoreUObject
LTween referes CppTypes
LTween referes Engine
SSettlementCamera referes CoreUObject
SSettlementCamera referes CppTypes
SSettlementCamera referes SCameraModifier
KuroSceneInteraction_52 referes CoreUObject
KuroSceneInteraction_52 referes Engine
BP_BaseItem referes CoreUObject
BP_BaseItem referes CppTypes
BP_BaseItem referes Engine
BP_BaseItem referes TsBaseItem
PD_CloudPrefab referes CoreUObject
PD_CloudPrefab referes CppTypes
PD_CloudPrefab referes Engine
PD_CloudPrefab referes SAnomaliesParameters
PD_CloudPrefab referes SCloudCover
PD_CloudPrefab referes SCloudParameters
PD_CloudPrefab referes SMountainParameters
PD_CloudPrefab referes SPOICloudParameters
JsEnv referes BasicTypes
JsEnv referes CoreUObject
JsEnv referes CppTypes
JsEnv referes Engine
JsEnv referes ItemMaterialControllerActorData
JsEnv referes SCameraConfig
JsEnv referes UMG
PD_MaterialDebug referes CoreUObject
PD_MaterialDebug referes Engine
PacketHandler referes CoreUObject
NiagaraCore referes CoreUObject
CS_HitShake referes CoreUObject
CS_HitShake referes Engine
PrefabSystem referes BasicTypes
PrefabSystem referes CoreUObject
PrefabSystem referes CppTypes
PrefabSystem referes Engine
MagicLeapIdentity referes BasicTypes
MagicLeapIdentity referes CoreUObject
MagicLeapIdentity referes CppTypes
BP_CharacterData referes CoreUObject
BP_CharacterData referes Engine
WwiseSimpleExternalSource referes BasicTypes
WwiseSimpleExternalSource referes CoreUObject
WwiseSimpleExternalSource referes CppTypes
WwiseSimpleExternalSource referes Engine
TsDecoratorActorsLocation referes AIModule
TsDecoratorActorsLocation referes BasicTypes
TsDecoratorActorsLocation referes CoreUObject
TsDecoratorActorsLocation referes CppTypes
NetCore referes BasicTypes
NetCore referes CoreUObject
NetCore referes CppTypes
SCounterAttackBuff referes CoreUObject
SCounterAttackBuff referes CppTypes
MovieScene referes BasicTypes
MovieScene referes CoreUObject
MovieScene referes CppTypes
MovieScene referes Engine
BP_BaseVision referes CoreUObject
BP_BaseVision referes CppTypes
BP_BaseVision referes Engine
BP_BaseVision referes SVisionData
BP_BaseVision referes TsBaseCharacter
LGUI_TexturePackerImporter referes BasicTypes
LGUI_TexturePackerImporter referes CoreUObject
LGUI_TexturePackerImporter referes CppTypes
LGUI_TexturePackerImporter referes Engine
LGUI_TexturePackerImporter referes LGUI
BP_SM_BindStateCue referes CoreUObject
BP_SM_BindStateCue referes CppTypes
BP_SM_BindStateCue referes SMSystem
NiagaraShader referes BasicTypes
NiagaraShader referes CoreUObject
NiagaraShader referes CppTypes
BP_SM_ConditionMontageTimeRemaining referes CoreUObject
BP_SM_ConditionMontageTimeRemaining referes CppTypes
BP_SM_ConditionMontageTimeRemaining referes SMSystem
TsTaskWander referes CoreUObject
TsTaskWander referes CppTypes
TsTaskWander referes Engine
TsTaskWander referes TsTaskAbortImmediatelyBase
DeveloperSettings referes CoreUObject
DeveloperSettings referes CppTypes
NiagaraAnimNotifies referes BasicTypes
NiagaraAnimNotifies referes CoreUObject
NiagaraAnimNotifies referes CppTypes
NiagaraAnimNotifies referes Engine
NiagaraAnimNotifies referes Niagara
BP_SM_BindStateMeshVisible referes BasicTypes
BP_SM_BindStateMeshVisible referes CoreUObject
BP_SM_BindStateMeshVisible referes CppTypes
BP_SM_BindStateMeshVisible referes SMSystem
SFootstepAudioEventParam referes AkAudio
SFootstepAudioEventParam referes CoreUObject
SFootstepAudioEventParam referes CppTypes
SFootstepAudioEventParam referes Engine
TimeManagement referes BasicTypes
TimeManagement referes CoreUObject
TimeManagement referes CppTypes
TimeManagement referes Engine
TASdkPlugin referes BasicTypes
TASdkPlugin referes CoreUObject
TASdkPlugin referes CppTypes
TASdkPlugin referes Engine
TASdkPlugin referes JsEnv
KuroGameplay referes AIModule
KuroGameplay referes BasicTypes
KuroGameplay referes CoreUObject
KuroGameplay referes CppTypes
KuroGameplay referes Engine
KuroGameplay referes KuroCurve
KuroGameplay referes KuroRenderingRuntimeBPPlugin
KuroGameplay referes MovieScene
KuroGameplay referes Niagara
KuroGameplay referes Slate
KuroGameplay referes SlateCore
KuroGameplay referes UMG
SStrikeInfo referes CoreUObject
SStrikeInfo referes CppTypes
SStrikeInfo referes ECamp
SStrikeInfo referes SrikeElement
SStrikeInfo referes StrikeType
ABP_PerformanceRole referes AnimGraphRuntime
ABP_PerformanceRole referes CoreUObject
ABP_PerformanceRole referes CppTypes
ABP_PerformanceRole referes EPerformanceRoleState
ABP_PerformanceRole referes Engine
ABP_PerformanceRole referes KuroAnim
ABP_PerformanceRole referes SPerformanceRoleInfo
ABP_PerformanceRole referes TsUiSceneActor
KuroAudio referes AkAudio
KuroAudio referes BasicTypes
KuroAudio referes CoreUObject
KuroAudio referes CppTypes
KuroAudio referes Engine
KuroAudio referes MovieScene
TimeOfDayData referes CoreUObject
TimeOfDayData referes CppTypes
AIModule referes BasicTypes
AIModule referes CoreUObject
AIModule referes CppTypes
AIModule referes Engine
AIModule referes GameplayTags
AIModule referes GameplayTasks
AIModule referes NavigationSystem
BP_ManagerBase referes BP_EventManager
BP_ManagerBase referes BP_MainGameInstance
BP_ManagerBase referes CoreUObject
BP_ManagerBase referes CppTypes
UMG referes BasicTypes
UMG referes CoreUObject
UMG referes CppTypes
UMG referes Engine
UMG referes InputCore
UMG referes MovieScene
UMG referes MovieSceneTracks
UMG referes PropertyPath
UMG referes Slate
UMG referes SlateCore
T4MRuntime referes CoreUObject
T4MRuntime referes CppTypes
T4MRuntime referes Engine
KuroAI referes AIModule
KuroAI referes CoreUObject
KuroAI referes CppTypes
SSequenceCamera_Settings referes CoreUObject
SSequenceCamera_Settings referes CppTypes
SSequenceCamera_Settings referes LevelSequence
KuroInput referes BasicTypes
KuroInput referes CoreUObject
KuroInput referes CppTypes
KuroInput referes Engine
KuroInput referes Slate
ImgMediaFactory referes BasicTypes
ImgMediaFactory referes CoreUObject
ImgMediaFactory referes CppTypes
KuroData referes BasicTypes
KuroData referes CoreUObject
KuroData referes CppTypes
KuroData referes Engine
KuroEffectMakerRuntime referes CoreUObject
KuroEffectMakerRuntime referes CppTypes
KuroEffectMakerRuntime referes Engine
BP_ActorManager referes CoreUObject
KuroEditorRuntime referes BasicTypes
KuroEditorRuntime referes CoreUObject
KuroEditorRuntime referes CppTypes
KuroEditorRuntime referes Engine
GA_Common_QTE referes BP_QTE_Camera
GA_Common_QTE referes CoreUObject
GA_Common_QTE referes CppTypes
GA_Common_QTE referes Engine
GA_Common_QTE referes GA_Base
GA_Common_QTE referes GameplayAbilities
GA_Common_QTE referes SCameraModifier_Settings
GA_Common_QTE referes TsBaseCharacter
WorldFunctionLibrary referes BasicTypes
WorldFunctionLibrary referes CoreUObject
WorldFunctionLibrary referes CppTypes
WorldFunctionLibrary referes EPawnChannel
WorldFunctionLibrary referes EWeatherState
WorldFunctionLibrary referes EWuYinQuState
WorldFunctionLibrary referes Engine
WorldFunctionLibrary referes TsEntityDebugInfoManager
KuroGameScreenshot referes BasicTypes
KuroGameScreenshot referes CoreUObject
KuroGameScreenshot referes CppTypes
KuroGameScreenshot referes Engine
SBulletLogicTypeRow referes BulletLogicType
SBulletLogicTypeRow referes CoreUObject
KuroGAS referes BasicTypes
KuroGAS referes CoreUObject
KuroGAS referes CppTypes
KuroGAS referes Engine
KuroGAS referes GameplayAbilities
KuroGAS referes GameplayTags
Synthesis referes AudioMixer
Synthesis referes BasicTypes
Synthesis referes CoreUObject
Synthesis referes CppTypes
Synthesis referes Engine
Synthesis referes SlateCore
Synthesis referes UMG
BP_Fx_WayFinding referes CoreUObject
BP_Fx_WayFinding referes CppTypes
BP_Fx_WayFinding referes Engine
BP_Fx_WayFinding referes Niagara
EffectBlueprintFunctionLibrary referes AkAudio
EffectBlueprintFunctionLibrary referes BP_ScreenEffectSystem
EffectBlueprintFunctionLibrary referes BasicTypes
EffectBlueprintFunctionLibrary referes CoreUObject
EffectBlueprintFunctionLibrary referes CppTypes
EffectBlueprintFunctionLibrary referes EEffectStatisticsSortType
EffectBlueprintFunctionLibrary referes Engine
EffectBlueprintFunctionLibrary referes UEffectStatisticsEntryData
MediaAssets referes AudioMixer
MediaAssets referes BasicTypes
MediaAssets referes CoreUObject
MediaAssets referes CppTypes
MediaAssets referes Engine
MediaAssets referes MediaUtils
KuroMovement referes BasicTypes
KuroMovement referes CoreUObject
KuroMovement referes CppTypes
KuroMovement referes Engine
KuroNetwork referes BasicTypes
KuroNetwork referes CoreUObject
KuroNetwork referes CppTypes
KuroNetwork referes Engine
KuroNetwork referes JsEnv
SMaterialControllerFloatParameter referes BasicTypes
SMaterialControllerFloatParameter referes CoreUObject
SMaterialControllerFloatParameter referes CppTypes
SMaterialControllerFloatParameter referes SMaterialControllerFloatGroup
KuroSplines referes CoreUObject
KuroSplines referes CppTypes
KuroSplines referes Engine
SSimpleInteractResult referes CoreUObject
SSimpleInteractResult referes CppTypes
TsSkeletalObserver referes CharRenderingComponent
TsSkeletalObserver referes CoreUObject
TsSkeletalObserver referes CppTypes
TsSkeletalObserver referes ECharacterDitherType
TsSkeletalObserver referes Engine
SBulletDataExe referes CoreUObject
KuroPointCloud referes CoreUObject
KuroPointCloud referes CppTypes
KuroPointCloud referes Engine
SMapConfig referes BasicTypes
SMapConfig referes CoreUObject
SMapConfig referes CppTypes
KuroSqliteBpLib referes BasicTypes
KuroSqliteBpLib referes CoreUObject
KuroSqliteBpLib referes CppTypes
KuroSqliteBpLib referes Engine
KuroSqliteBpLib referes JsEnv
InteractiveToolsFramework referes CoreUObject
InteractiveToolsFramework referes CppTypes
InteractiveToolsFramework referes Engine
TsUiBlur referes CoreUObject
TsUiBlur referes Engine
TsUiBlur referes LGUI
KuroRenderingRuntimeBPPlugin referes ActorSequence
KuroRenderingRuntimeBPPlugin referes BasicTypes
KuroRenderingRuntimeBPPlugin referes CoreUObject
KuroRenderingRuntimeBPPlugin referes CppTypes
KuroRenderingRuntimeBPPlugin referes DeveloperSettings
KuroRenderingRuntimeBPPlugin referes Engine
KuroRenderingRuntimeBPPlugin referes KuroCurve
KuroRenderingRuntimeBPPlugin referes KuroPointCloud
KuroRenderingRuntimeBPPlugin referes LevelSequence
KuroRenderingRuntimeBPPlugin referes MovieScene
KuroRenderingRuntimeBPPlugin referes Niagara
KuroRenderingRuntimeBPPlugin referes PhysicsCore
KuroRenderingRuntimeBPPlugin referes ProceduralMeshComponent
KuroRenderingRuntimeBPPlugin referes Renderer
KuroWorldPartition referes CoreUObject
KuroWorldPartition referes CppTypes
KuroWorldPartition referes Engine
ProceduralMeshComponent referes CoreUObject
ProceduralMeshComponent referes CppTypes
ProceduralMeshComponent referes Engine
TsStartupPlayerController referes CoreUObject
TsStartupPlayerController referes TsBasePlayerController
LevelSequence referes BasicTypes
LevelSequence referes CoreUObject
LevelSequence referes CppTypes
LevelSequence referes Engine
LevelSequence referes MediaAssets
LevelSequence referes MovieScene
LevelSequence referes UMG
HeadMountedDisplay referes BasicTypes
HeadMountedDisplay referes CoreUObject
HeadMountedDisplay referes CppTypes
HeadMountedDisplay referes Engine
HeadMountedDisplay referes InputCore
WeatherData referes CoreUObject
WeatherData referes CppTypes
KuroRenderingShadingModule referes CoreUObject
KuroRenderingShadingModule referes CppTypes
KuroRenderingShadingModule referes Engine
ActorSequence referes BasicTypes
ActorSequence referes CoreUObject
ActorSequence referes CppTypes
ActorSequence referes Engine
ActorSequence referes MovieScene
KuroUtility referes BasicTypes
KuroUtility referes CoreUObject
KuroUtility referes CppTypes
KuroUtility referes Engine
KuroUtility referes MovieScene
CrashSight referes BasicTypes
CrashSight referes CoreUObject
CrashSight referes CppTypes
CrashSight referes Engine
TsTaskBattleWander referes CoreUObject
TsTaskBattleWander referes CppTypes
TsTaskBattleWander referes Engine
TsTaskBattleWander referes TsTaskAbortImmediatelyBase
MagicLeapAR referes AugmentedReality
MagicLeapAR referes BasicTypes
MagicLeapAR referes CoreUObject
MagicLeapAR referes CppTypes
MagicLeapAR referes Engine
MagicLeapAR referes MRMesh
MagicLeapAR referes MagicLeapImageTracker
MagicLeapAR referes MagicLeapPlanes
SNiagaraParam referes CoreUObject
SNiagaraParam referes CppTypes
KuroVoxelRuntime referes BasicTypes
KuroVoxelRuntime referes CoreUObject
KuroVoxelRuntime referes CppTypes
KuroVoxelRuntime referes Engine
KuroVoxelRuntime referes KuroWorldPartition
TsAnimNotifyStateEnterWaterMoveOffset referes BasicTypes
TsAnimNotifyStateEnterWaterMoveOffset referes CoreUObject
TsAnimNotifyStateEnterWaterMoveOffset referes CppTypes
TsAnimNotifyStateEnterWaterMoveOffset referes KuroRenderingRuntimeBPPlugin
KuroAnim referes AnimGraphRuntime
KuroAnim referes BasicTypes
KuroAnim referes CoreUObject
KuroAnim referes CppTypes
KuroAnim referes Engine
KuroAnim referes GameplayTags
KuroAnim referes KuroGAS
MeshDescription referes CoreUObject
MeshDescription referes CppTypes
sInputCommand referes CoreUObject
sInputCommand referes CppTypes
sInputCommand referes ECommandType
sInputCommand referes GameplayTags
MagicLeapController referes BasicTypes
MagicLeapController referes CoreUObject
MagicLeapController referes CppTypes
MagicLeapController referes Engine
MagicLeapController referes InputCore
KuroCurve referes CoreUObject
KuroCurve referes CppTypes
KuroCurve referes Engine
KuroDynamicAtlas referes BasicTypes
KuroDynamicAtlas referes CoreUObject
KuroDynamicAtlas referes CppTypes
KuroDynamicAtlas referes Engine
MagicLeapEyeTracker referes CoreUObject
MagicLeapEyeTracker referes CppTypes
MagicLeapEyeTracker referes Engine
KuroPushSdk referes BasicTypes
KuroPushSdk referes CoreUObject
KuroPushSdk referes CppTypes
KuroPushSdk referes Engine
KuroComponent referes BasicTypes
KuroComponent referes CoreUObject
KuroComponent referes CppTypes
KuroComponent referes Engine
KuroComponent referes Niagara
RawInput referes BasicTypes
RawInput referes CoreUObject
RawInput referes CppTypes
RawInput referes DeveloperSettings
RawInput referes Engine
RawInput referes InputCore
NavmeshPartition referes CoreUObject
NavmeshPartition referes CppTypes
NavmeshPartition referes Engine
BP_SM_ActionCue referes CoreUObject
BP_SM_ActionCue referes SMSystem
ABP_NA028 referes ABP_BaseAnimal
ABP_NA028 referes CoreUObject
SFootstepAkAudioEvent referes CoreUObject
SFootstepAkAudioEvent referes CppTypes
SFootstepAkAudioEvent referes EFootstepAkAudioEventType
NavigationSystem referes BasicTypes
NavigationSystem referes CoreUObject
NavigationSystem referes CppTypes
NavigationSystem referes Engine
PathFindModule referes CoreUObject
PathFindModule referes CppTypes
PathFindModule referes Engine
PathFindModule referes NavigationSystem
SSceneInteractionTags referes CoreUObject
SSceneInteractionTags referes SSceneInteractionAudio
SSceneInteractionTags referes SSceneInteractionSequence
SCaughtBindingInfo referes BasicTypes
SCaughtBindingInfo referes CoreUObject
SCaughtBindingInfo referes CppTypes
SCaughtBindingInfo referes ECaughtDirectionType
JsonUtilities referes BasicTypes
JsonUtilities referes CoreUObject
JsonUtilities referes CppTypes
RoadNetRuntime referes CoreUObject
RoadNetRuntime referes CppTypes
RoadNetRuntime referes Engine
BP_TrailGrassDrawerComponent referes CoreUObject
BP_TrailGrassDrawerComponent referes CppTypes
BP_TrailGrassDrawerComponent referes Engine
BP_TrailGrassDrawerComponent referes KuroRenderingRuntimeBPPlugin
BP_TrailGrassDrawerComponent referes STrailGrassDrawInfo
RoadNetNavigationRuntime referes CoreUObject
RoadNetNavigationRuntime referes CppTypes
RoadNetNavigationRuntime referes Engine
SMountainParameters referes CoreUObject
SMountainParameters referes CppTypes
KuroPhysicsSplit referes CoreUObject
KuroPhysicsSplit referes CppTypes
KuroPhysicsSplit referes Engine
GA_Interaction_DurationInteract referes CoreUObject
GA_Interaction_DurationInteract referes CppTypes
GA_Interaction_DurationInteract referes Engine
GA_Interaction_DurationInteract referes GA_Base
AnimationCore referes BasicTypes
AnimationCore referes CoreUObject
AnimationCore referes CppTypes
VolumeGIRender referes CoreUObject
VolumeGIRender referes CppTypes
VolumeGIRender referes Engine
TsAiController referes AIModule
TsAiController referes BasicTypes
TsAiController referes CoreUObject
TsAiController referes CppTypes
TsAiController referes ECharacterState
TsAiController referes Engine
TsAiController referes GameplayTags
TsAiController referes KuroGameplay
TsAiController referes KuroUtility
TsAiController referes SAiConditions
LGUI_BMFGenImporter referes BasicTypes
LGUI_BMFGenImporter referes CoreUObject
LGUI_BMFGenImporter referes CppTypes
LGUI_BMFGenImporter referes Engine
LGUI_BMFGenImporter referes LGUI
LogicDataSuiGuang referes BasicTypes
LogicDataSuiGuang referes CoreUObject
LogicDataSuiGuang referes CppTypes
LogicDataSuiGuang referes GameplayTags
LogicDataSuiGuang referes LogicDataBase
NCS_In_Lv6 referes BP_CameraShakeAndForceFeedback
NCS_In_Lv6 referes CoreUObject
PDA_RainConfig_CommonDrop referes AkAudio
PDA_RainConfig_CommonDrop referes CoreUObject
PDA_RainConfig_CommonDrop referes CppTypes
PDA_RainConfig_CommonDrop referes Engine
PDA_RainConfig_CommonDrop referes KuroCurve
PDA_RainConfig_CommonDrop referes Niagara
AudioMaterialPlugin referes CoreUObject
AudioMaterialPlugin referes CppTypes
AudioMaterialPlugin referes Engine
AudioMaterialPlugin referes KuroWorldPartition
AudioMaterialPlugin referes NavmeshPartition
KuroSceneInteraction_60 referes CoreUObject
KuroSceneInteraction_60 referes Engine
SSkillBehaviorCue referes CoreUObject
SSkillBehaviorCue referes CppTypes
SMaterialControllerTextureGroup referes CoreUObject
SMaterialControllerTextureGroup referes Engine
DLSS referes BasicTypes
DLSS referes CoreUObject
DLSS referes CppTypes
Foliage referes BasicTypes
Foliage referes CoreUObject
Foliage referes CppTypes
Foliage referes Engine
ChaosNiagara referes CoreUObject
ChaosNiagara referes CppTypes
ChaosNiagara referes Engine
ChaosNiagara referes Niagara
DLSSBlueprint referes CoreUObject
DLSSBlueprint referes CppTypes
DLSSBlueprint referes Engine
StreamlineBlueprint referes CoreUObject
StreamlineBlueprint referes CppTypes
StreamlineBlueprint referes Engine
KuroSceneInteraction_10 referes CoreUObject
KuroSceneInteraction_10 referes Engine
BP_Cloud_None referes BP_CloudPrefab
BP_Cloud_None referes CoreUObject
BP_Cloud_None referes CppTypes
BP_Cloud_None referes Engine
BPL_EffectUtil referes CoreUObject
BPL_EffectUtil referes CppTypes
BPL_EffectUtil referes Engine
HoudiniEngineRuntime referes BasicTypes
HoudiniEngineRuntime referes CoreUObject
HoudiniEngineRuntime referes CppTypes
HoudiniEngineRuntime referes Engine
HoudiniEngineRuntime referes Foliage
HoudiniEngineRuntime referes PhysicsCore
SReBulletDataMain referes BasicTypes
SReBulletDataMain referes CoreUObject
SReBulletDataMain referes CppTypes
SReBulletDataMain referes SReBulletDataAimed
SReBulletDataMain referes SReBulletDataBase
SReBulletDataMain referes SReBulletDataEntity
SReBulletDataMain referes SReBulletDataExe
SReBulletDataMain referes SReBulletDataInteraction
SReBulletDataMain referes SReBulletDataLogic
SReBulletDataMain referes SReBulletDataMove
SReBulletDataMain referes SReBulletDataObstacles
SReBulletDataMain referes SReBulletDataPerformance
SReBulletDataMain referes SReBulletDataScale
SReBulletDataMain referes SReBulletDataTime
BP_UIShowRoom referes CoreUObject
BP_UIShowRoom referes CppTypes
BP_UIShowRoom referes Engine
KuroPuertsWrapper referes BasicTypes
KuroPuertsWrapper referes CoreUObject
KuroPuertsWrapper referes CppTypes
KuroPuertsWrapper referes Engine
TsAnimNotifyCameraShake referes BasicTypes
TsAnimNotifyCameraShake referes CoreUObject
TsAnimNotifyCameraShake referes CppTypes
TsAnimNotifyCameraShake referes KuroRenderingRuntimeBPPlugin
ABP_Base_Sword referes AnimGraphRuntime
ABP_Base_Sword referes CoreUObject
ABP_Base_Sword referes CppTypes
ABP_Base_Sword referes Engine
ABP_Base_Sword referes KuroAnim
BP_CineCamera referes CinematicCamera
BP_CineCamera referes CoreUObject
BP_CineCamera referes CppTypes
BP_CineCamera referes Engine
SBulletEffectOnHitConf referes CoreUObject
SBulletEffectOnHitConf referes CppTypes
SBulletEffectOnHitConf referes EBulletEffectOnHitType
TsTaskPlayMontage referes CoreUObject
TsTaskPlayMontage referes CppTypes
TsTaskPlayMontage referes Engine
TsTaskPlayMontage referes TsTaskAbortImmediatelyBase
KuroHotPatch referes BasicTypes
KuroHotPatch referes CoreUObject
KuroHotPatch referes CppTypes
KuroHotPatch referes Engine
KuroPakKey referes BasicTypes
KuroPakKey referes CoreUObject
KuroPakKey referes CppTypes
KuroPakKey referes Engine
KuroImposter referes CoreUObject
KuroImposter referes CppTypes
KuroImposter referes Engine
HoudiniNiagara referes BasicTypes
HoudiniNiagara referes CoreUObject
HoudiniNiagara referes CppTypes
HoudiniNiagara referes Niagara
SMSystem referes BasicTypes
SMSystem referes CoreUObject
SMSystem referes CppTypes
SMSystem referes Engine
TsBaseCharacter referes BP_BasePlatform
TsBaseCharacter referes BP_FightManager
TsBaseCharacter referes CharRenderingComponent
TsBaseCharacter referes CoreUObject
TsBaseCharacter referes CppTypes
TsBaseCharacter referes ECamp
TsBaseCharacter referes ECharacterDitherType
TsBaseCharacter referes ECharacterRenderingType
TsBaseCharacter referes Engine
TsBaseCharacter referes KuroGAS
TsBaseCharacter referes KuroGameplay
TsBaseCharacter referes NavigationSystem
TsBaseCharacter referes PD_CharacterControllerData
TsBaseCharacter referes TsCharacterDebugComponent
AudioAnalyzer referes CoreUObject
AudioAnalyzer referes CppTypes
AudioAnalyzer referes Engine
AudioSynesthesia referes AudioAnalyzer
AudioSynesthesia referes CoreUObject
AudioSynesthesia referes CppTypes
AudioSynesthesia referes Engine
ControlRig referes AnimGraphRuntime
ControlRig referes AnimationCore
ControlRig referes BasicTypes
ControlRig referes CoreUObject
ControlRig referes CppTypes
ControlRig referes DeveloperSettings
ControlRig referes Engine
ControlRig referes LevelSequence
ControlRig referes MovieScene
ControlRig referes MovieSceneTracks
ControlRig referes RigVM
SCameraConfig referes CoreUObject
SCameraConfig referes CppTypes
SCameraConfig referes EFightCameraType
SCameraConfig referes GameplayTags
SCameraConfig referes SBaseCurve
SBulletTailEffect referes CoreUObject
SBulletTailEffect referes CppTypes
BulletSceneInteraction referes CoreUObject
BulletSceneInteraction referes CppTypes
BulletSceneInteraction referes Engine
BulletSceneInteraction referes SKuroInteractionLimbsConfig
BulletSceneInteraction referes SWaterEffectObject
KuroSceneInteraction_47 referes CoreUObject
KuroSceneInteraction_47 referes Engine
MagicLeapPrivileges referes CoreUObject
MagicLeapPrivileges referes CppTypes
MagicLeapPrivileges referes Engine
AnimGraphRuntime referes AnimationCore
AnimGraphRuntime referes BasicTypes
AnimGraphRuntime referes CoreUObject
AnimGraphRuntime referes CppTypes
AnimGraphRuntime referes Engine
TPrefab_SM_Gat_38A referes CoreUObject
TPrefab_SM_Gat_38A referes Engine
SE_UISpriteFadeController referes CoreUObject
SE_UISpriteFadeController referes CppTypes
SE_UISpriteFadeController referes Engine
SE_UISpriteFadeController referes SE_UISpriteController
MovieSceneTracks referes BasicTypes
MovieSceneTracks referes CoreUObject
MovieSceneTracks referes CppTypes
MovieSceneTracks referes Engine
MovieSceneTracks referes MovieScene
ClothingSystemRuntimeInterface referes BasicTypes
ClothingSystemRuntimeInterface referes CoreUObject
ClothingSystemRuntimeInterface referes CppTypes
ClothingSystemRuntimeCommon referes BasicTypes
ClothingSystemRuntimeCommon referes ClothingSystemRuntimeInterface
ClothingSystemRuntimeCommon referes CoreUObject
ClothingSystemRuntimeCommon referes CppTypes
ClothingSystemRuntimeCommon referes Engine
SCondition referes BasicTypes
SCondition referes CoreUObject
SCondition referes CppTypes
ChaosCloth referes ClothingSystemRuntimeCommon
ChaosCloth referes ClothingSystemRuntimeInterface
ChaosCloth referes CoreUObject
ChaosCloth referes CppTypes
ChaosCloth referes Engine
BPL_Fight referes CoreUObject
BPL_Fight referes CppTypes
BPL_Fight referes Engine
BPL_Fight referes GameplayAbilities
BPL_Fight referes GameplayTags
BPL_Fight referes KuroGAS
GeometryCache referes CoreUObject
GeometryCache referes CppTypes
GeometryCache referes Engine
GeometryCacheTracks referes CoreUObject
GeometryCacheTracks referes CppTypes
GeometryCacheTracks referes GeometryCache
GeometryCacheTracks referes MovieScene
SManipulatePointInfo referes CoreUObject
SManipulatePointInfo referes Engine
SEntityProperty referes BasicTypes
SEntityProperty referes CoreUObject
SEntityProperty referes CppTypes
LightPropagationVolumeRuntime referes CoreUObject
LightPropagationVolumeRuntime referes CppTypes
LightPropagationVolumeRuntime referes Renderer
TsAnimNotifyReSkillEvent referes BasicTypes
TsAnimNotifyReSkillEvent referes CoreUObject
TsAnimNotifyReSkillEvent referes CppTypes
TsAnimNotifyReSkillEvent referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStateHideMesh referes BasicTypes
TsAnimNotifyStateHideMesh referes CoreUObject
TsAnimNotifyStateHideMesh referes CppTypes
TsAnimNotifyStateHideMesh referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStateHideMesh referes PD_CharacterControllerData
SReBulletDataAimed referes CoreUObject
SReBulletDataAimed referes CppTypes
ImgMedia referes BasicTypes
ImgMedia referes CoreUObject
ImgMedia referes CppTypes
ImgMedia referes Engine
ImgMedia referes MediaAssets
SEffectFloatParameter referes BasicTypes
SEffectFloatParameter referes CoreUObject
SEffectFloatParameter referes CppTypes
MediaCompositing referes CoreUObject
MediaCompositing referes CppTypes
MediaCompositing referes MediaAssets
MediaCompositing referes MovieScene
MediaCompositing referes MovieSceneTracks
TemplateSequence referes CoreUObject
TemplateSequence referes CppTypes
TemplateSequence referes Engine
TemplateSequence referes MovieScene
SCamera_NewConfig referes CoreUObject
SCamera_NewConfig referes CppTypes
SCamera_NewConfig referes SCamera_Setting
SBulletDataTime referes CoreUObject
SBulletDataTime referes CppTypes
SBulletDataTime referes STimeScale
GA_Interaction_StandControl referes CoreUObject
GA_Interaction_StandControl referes CppTypes
GA_Interaction_StandControl referes Engine
GA_Interaction_StandControl referes GA_Base
TsAnimNotifyStateAddBuff referes BasicTypes
TsAnimNotifyStateAddBuff referes CoreUObject
TsAnimNotifyStateAddBuff referes CppTypes
TsAnimNotifyStateAddBuff referes ESkillBehaviorBuffTargetType
TsAnimNotifyStateAddBuff referes KuroRenderingRuntimeBPPlugin
AudioMixer referes BasicTypes
AudioMixer referes CoreUObject
AudioMixer referes CppTypes
AudioMixer referes Engine
TsHotFixActionHandle referes BasicTypes
TsHotFixActionHandle referes CoreUObject
TsHotFixActionHandle referes CppTypes
TsHotFixActionHandle referes InputCore
SE_ControllerBase referes CoreUObject
SE_ControllerBase referes CppTypes
SE_ControllerBase referes Engine
SequenceDialogue referes BasicTypes
SequenceDialogue referes CoreUObject
SequenceDialogue referes CppTypes
SequenceDialogue referes Engine
SequenceDialogue referes MovieScene
SequenceDialogue referes MovieSceneTracks
ReactUMG referes CoreUObject
ReactUMG referes CppTypes
ReactUMG referes Engine
ReactUMG referes UMG
SNpcSetupPartInfo referes CoreUObject
ApexDestruction referes CoreUObject
ApexDestruction referes CppTypes
ApexDestruction referes Engine
GooglePAD referes BasicTypes
GooglePAD referes CoreUObject
GooglePAD referes CppTypes
GooglePAD referes Engine
SlateCore referes BasicTypes
SlateCore referes CoreUObject
SlateCore referes CppTypes
KuroSceneInteraction_24 referes CoreUObject
KuroSceneInteraction_24 referes Engine
TapCommon referes BasicTypes
TapCommon referes CoreUObject
TapCommon referes CppTypes
TapCommon referes Engine
TapCommon referes JsonUtilities
TapCommon referes SlateCore
TapCommon referes UMG
SHardnessStageInfo referes CoreUObject
SHardnessStageInfo referes CppTypes
TapLogin referes BasicTypes
TapLogin referes CoreUObject
TapLogin referes CppTypes
TapLogin referes SlateCore
TapLogin referes TapCommon
SBulletDataMain referes BasicTypes
SBulletDataMain referes CoreUObject
SBulletDataMain referes CppTypes
SBulletDataMain referes SBulletDataBase
SBulletDataMain referes SBulletDataCollision
SBulletDataMain referes SBulletDataEffect
SBulletDataMain referes SBulletDataExe
SBulletDataMain referes SBulletDataMove
SBulletDataMain referes SBulletDataScale
SBulletDataMain referes SBulletDataTime
KuroSceneInteraction_75 referes CoreUObject
KuroSceneInteraction_75 referes Engine
TapUpdate referes BasicTypes
TapUpdate referes CoreUObject
TapUpdate referes CppTypes
TapUpdate referes Engine
BP_MO1DundishuMd00601_Camera referes CoreUObject
BP_MO1DundishuMd00601_Camera referes Engine
KuroiOSDelegate referes CoreUObject
KuroiOSDelegate referes CppTypes
KuroiOSDelegate referes Engine
SpinePlugin referes BasicTypes
SpinePlugin referes CoreUObject
SpinePlugin referes CppTypes
SpinePlugin referes Engine
SpinePlugin referes ProceduralMeshComponent
SpinePlugin referes SlateCore
SpinePlugin referes UMG
TPrefab_SM_Gat_13A referes CoreUObject
TPrefab_SM_Gat_13A referes Engine
BP_BasePlatform referes CoreUObject
BP_BasePlatform referes CppTypes
BP_BasePlatform referes Engine
SEffectVectorParameter referes BasicTypes
SEffectVectorParameter referes CoreUObject
BP_EventManager referes BP_ManagerBase
BP_EventManager referes BasicTypes
BP_EventManager referes CoreUObject
BP_EventManager referes CppTypes
BP_EventManager referes ECaughtResultType
BP_EventManager referes ECharacterState
BP_EventManager referes GameplayTags
BP_EventManager referes SHitInformation
TpSafe referes BasicTypes
TpSafe referes CoreUObject
TpSafe referes CppTypes
TpSafe referes Engine
TpSafe referes JsEnv
GA_Common_Paralysis_Camera referes BP_QTE_Camera
GA_Common_Paralysis_Camera referes CoreUObject
GA_Common_Paralysis_Camera referes CppTypes
GA_Common_Paralysis_Camera referes Engine
GA_Common_Paralysis_Camera referes GA_Passive
GA_Common_Paralysis_Camera referes SCameraModifier_Settings
LogicDataShakeScreen referes BasicTypes
LogicDataShakeScreen referes CoreUObject
LogicDataShakeScreen referes CppTypes
LogicDataShakeScreen referes LogicDataBase
MagicLeapARPin referes BasicTypes
MagicLeapARPin referes CoreUObject
MagicLeapARPin referes CppTypes
MagicLeapARPin referes Engine
TsAnimNotifyStateWeaponHang referes BasicTypes
TsAnimNotifyStateWeaponHang referes CoreUObject
TsAnimNotifyStateWeaponHang referes CppTypes
TsAnimNotifyStateWeaponHang referes KuroRenderingRuntimeBPPlugin
SSkillBehaviorAction referes BasicTypes
SSkillBehaviorAction referes CoreUObject
SSkillBehaviorAction referes CppTypes
SSkillBehaviorAction referes ECameraAnsEffectiveClientType
SSkillBehaviorAction referes ESkillBehaviorActionType
SSkillBehaviorAction referes ESkillBehaviorBestSpotType
SSkillBehaviorAction referes ESkillBehaviorBuffTargetType
SSkillBehaviorAction referes ESkillBehaviorLocationForwardType
SSkillBehaviorAction referes ESkillBehaviorLocationType
SSkillBehaviorAction referes ESkillBehaviorRestrictType
SSkillBehaviorAction referes ESkillBehaviorRotationType
SSkillBehaviorAction referes Engine
SSkillBehaviorAction referes GameplayTags
SSkillBehaviorAction referes SCameraModifier_Settings
SSkillBehaviorAction referes SSequenceCamera_Settings
MagicLeapSharedWorld referes CoreUObject
MagicLeapSharedWorld referes CppTypes
MagicLeapSharedWorld referes Engine
MagicLeapSharedWorld referes MagicLeapARPin
MagicLeap referes BasicTypes
MagicLeap referes CoreUObject
MagicLeap referes CppTypes
MagicLeap referes Engine
MagicLeap referes HeadMountedDisplay
MagicLeap referes MRMesh
GA_Role_Bianshen_Level_Youyidie referes BP_BaseVision
GA_Role_Bianshen_Level_Youyidie referes BasicTypes
GA_Role_Bianshen_Level_Youyidie referes CoreUObject
GA_Role_Bianshen_Level_Youyidie referes CppTypes
GA_Role_Bianshen_Level_Youyidie referes Engine
GA_Role_Bianshen_Level_Youyidie referes GA_Base
GA_Role_Bianshen_Level_Youyidie referes GameplayAbilities
GA_Role_Bianshen_Level_Youyidie referes GameplayTags
GA_Role_Bianshen_Level_Youyidie referes KuroGAS
GA_Role_Bianshen_Level_Youyidie referes SVisionData
GA_Role_Bianshen_Level_Youyidie referes TsBaseCharacter
AugmentedReality referes BasicTypes
AugmentedReality referes CoreUObject
AugmentedReality referes CppTypes
AugmentedReality referes Engine
AugmentedReality referes MRMesh
MagicLeapAudio referes CoreUObject
MagicLeapAudio referes CppTypes
MagicLeapAudio referes Engine
TsUiHotKeyActorComponent referes BasicTypes
TsUiHotKeyActorComponent referes CoreUObject
TsUiHotKeyActorComponent referes CppTypes
TsUiHotKeyActorComponent referes Engine
TsUiHotKeyActorComponent referes LGUI
BP_BasePathLineBullet referes CoreUObject
BP_BasePathLineBullet referes Engine
LiveLinkInterface referes BasicTypes
LiveLinkInterface referes CoreUObject
LiveLinkInterface referes CppTypes
AssetRegistry referes BasicTypes
AssetRegistry referes CoreUObject
AssetRegistry referes CppTypes
MagicLeapHandTracking referes BasicTypes
MagicLeapHandTracking referes CoreUObject
MagicLeapHandTracking referes CppTypes
MagicLeapHandTracking referes Engine
MagicLeapHandTracking referes InputCore
MagicLeapHandTracking referes LiveLinkInterface
BP_SM_ConditionPartLife referes BasicTypes
BP_SM_ConditionPartLife referes CoreUObject
BP_SM_ConditionPartLife referes CppTypes
BP_SM_ConditionPartLife referes SMSystem
BP_ThunderGenerator referes AkAudio
BP_ThunderGenerator referes CoreUObject
BP_ThunderGenerator referes CppTypes
BP_ThunderGenerator referes Engine
BP_ThunderGenerator referes KuroCurve
BP_ThunderGenerator referes KuroRenderingRuntimeBPPlugin
BP_ThunderGenerator referes PDA_ThunderConfig
BP_ThunderGenerator referes PDA_ThunderConfigMap
TsAnimNotifyRoleSitDown referes BasicTypes
TsAnimNotifyRoleSitDown referes CoreUObject
TsAnimNotifyRoleSitDown referes CppTypes
TsAnimNotifyRoleSitDown referes KuroRenderingRuntimeBPPlugin
MagicLeapImageTracker referes BasicTypes
MagicLeapImageTracker referes CoreUObject
MagicLeapImageTracker referes CppTypes
MagicLeapImageTracker referes Engine
MagicLeapPlanes referes CoreUObject
MagicLeapPlanes referes CppTypes
MagicLeapPlanes referes Engine
MagicLeapSecureStorage referes BasicTypes
MagicLeapSecureStorage referes CoreUObject
MagicLeapSecureStorage referes CppTypes
MagicLeapSecureStorage referes Engine
KuroSceneInteraction_116 referes CoreUObject
KuroSceneInteraction_116 referes Engine
MagicLeapHandMeshing referes CoreUObject
MagicLeapHandMeshing referes CppTypes
MagicLeapHandMeshing referes Engine
BPF_CameraHelper referes CoreUObject
BPF_CameraHelper referes CppTypes
BPF_CameraHelper referes Engine
SCloudParameters referes CoreUObject
SCloudParameters referes CppTypes
SCloudParameters referes Engine
SCloudParameters referes KuroCurve
BP_WeatherController referes BP_GlobalGI
BP_WeatherController referes BP_WeatherData
BP_WeatherController referes CoreUObject
BP_WeatherController referes CppTypes
BP_WeatherController referes Engine
BP_WeatherController referes KuroRenderingRuntimeBPPlugin
FieldSystemEngine referes Chaos
FieldSystemEngine referes CoreUObject
FieldSystemEngine referes CppTypes
FieldSystemEngine referes Engine
MagicLeapLightEstimation referes CoreUObject
MagicLeapLightEstimation referes CppTypes
MagicLeapLightEstimation referes Engine
AvfMediaFactory referes CoreUObject
AvfMediaFactory referes CppTypes
WmfMediaFactory referes CoreUObject
WmfMediaFactory referes CppTypes
GA_WuYinQu_YiLuoYuanXiang_Ball referes BasicTypes
GA_WuYinQu_YiLuoYuanXiang_Ball referes CoreUObject
GA_WuYinQu_YiLuoYuanXiang_Ball referes CppTypes
GA_WuYinQu_YiLuoYuanXiang_Ball referes Engine
GA_WuYinQu_YiLuoYuanXiang_Ball referes GA_Base
GA_WuYinQu_YiLuoYuanXiang_Ball referes GameplayAbilities
GA_WuYinQu_YiLuoYuanXiang_Ball referes GameplayTags
SAttributeModifierData referes CoreUObject
SAttributeModifierData referes CppTypes
SAttributeModifierData referes EAttributeOperation
SAttributeModifierData referes EAttributeTarget
SAttributeModifierData referes GameplayAbilities
SWaterEffectSubConfig referes CoreUObject
SWaterEffectSubConfig referes CppTypes
KuroSceneInteraction_15 referes CoreUObject
KuroSceneInteraction_15 referes Engine
AndroidPermission referes BasicTypes
AndroidPermission referes CoreUObject
AndroidPermission referes CppTypes
AndroidPermission referes Engine
SInputHoldConfig referes CoreUObject
SInputHoldConfig referes CppTypes
SSeqJumpWithOption referes BasicTypes
SSeqJumpWithOption referes CoreUObject
SSeqJumpWithOption referes CppTypes
TsAnimNotifyBattleState referes BasicTypes
TsAnimNotifyBattleState referes CoreUObject
TsAnimNotifyBattleState referes CppTypes
TsAnimNotifyBattleState referes KuroRenderingRuntimeBPPlugin
MIDIDevice referes BasicTypes
MIDIDevice referes CoreUObject
MIDIDevice referes CppTypes
MIDIDevice referes Engine
MobilePatchingUtils referes BasicTypes
MobilePatchingUtils referes CoreUObject
MobilePatchingUtils referes CppTypes
MobilePatchingUtils referes Engine
PDA_AudioVisualizationGlobalConfigs referes CoreUObject
PDA_AudioVisualizationGlobalConfigs referes Engine
BP_ScreenEffectSystem referes CoreUObject
BP_ScreenEffectSystem referes CppTypes
BP_ScreenEffectSystem referes EffectScreenPlayData
BP_ScreenEffectSystem referes Engine
BP_ScreenEffectSystem referes LGUI
WindowsDeviceProfileSelector referes BasicTypes
WindowsDeviceProfileSelector referes CoreUObject
WindowsDeviceProfileSelector referes CppTypes
SSkillMontage referes BasicTypes
SSkillMontage referes CoreUObject
WP_Blizzard referes CoreUObject
WP_Blizzard referes WeatherPreset
KuroSDK referes BasicTypes
KuroSDK referes CoreUObject
KuroSDK referes CppTypes
KuroSDK referes Engine
InputCore referes BasicTypes
InputCore referes CoreUObject
InputCore referes CppTypes
Slate referes BasicTypes
Slate referes CoreUObject
Slate referes CppTypes
Slate referes InputCore
Slate referes SlateCore
STags referes CoreUObject
TsAnimNotifyStateSimpleDisableCollision referes BasicTypes
TsAnimNotifyStateSimpleDisableCollision referes CoreUObject
TsAnimNotifyStateSimpleDisableCollision referes CppTypes
TsAnimNotifyStateSimpleDisableCollision referes KuroRenderingRuntimeBPPlugin
ImageWriteQueue referes BasicTypes
ImageWriteQueue referes CoreUObject
ImageWriteQueue referes CppTypes
ImageWriteQueue referes Engine
MaterialShaderQualitySettings referes CoreUObject
MaterialShaderQualitySettings referes CppTypes
EyeTracker referes CoreUObject
EyeTracker referes CppTypes
EyeTracker referes Engine
SInputShowList referes CoreUObject
Renderer referes CoreUObject
Renderer referes CppTypes
TsAnimNotifyEnableEntity referes BasicTypes
TsAnimNotifyEnableEntity referes CoreUObject
TsAnimNotifyEnableEntity referes CppTypes
TsAnimNotifyEnableEntity referes KuroRenderingRuntimeBPPlugin
NCS_Down_Lv6 referes BP_CameraShakeAndForceFeedback
NCS_Down_Lv6 referes CoreUObject
EngineSettings referes BasicTypes
EngineSettings referes CoreUObject
EngineSettings referes CppTypes
GA_Role_Zhaohuan referes CoreUObject
GA_Role_Zhaohuan referes CppTypes
GA_Role_Zhaohuan referes Engine
GA_Role_Zhaohuan referes GA_Base
SAIConfig referes BasicTypes
SAIConfig referes CoreUObject
SAIConfig referes CppTypes
SAIConfig referes EActionPlan
KuroSceneInteraction_6 referes CoreUObject
KuroSceneInteraction_6 referes Engine
PhysicsCore referes BasicTypes
PhysicsCore referes Chaos
PhysicsCore referes CoreUObject
PhysicsCore referes CppTypes
PhysicsCore referes DeveloperSettings
MRMesh referes CoreUObject
MRMesh referes CppTypes
MRMesh referes Engine
SC_PlayerFemale_wuguanzhefenshe referes BasicTypes
SC_PlayerFemale_wuguanzhefenshe referes CoreUObject
SC_PlayerFemale_wuguanzhefenshe referes CppTypes
SC_PlayerFemale_wuguanzhefenshe referes Engine
SC_PlayerFemale_wuguanzhefenshe referes LevelSequence
WebBrowser referes CoreUObject
WebBrowser referes CppTypes
TsAnimNotifyStateTurnAdd referes BasicTypes
TsAnimNotifyStateTurnAdd referes CoreUObject
TsAnimNotifyStateTurnAdd referes CppTypes
TsAnimNotifyStateTurnAdd referes KuroRenderingRuntimeBPPlugin
SReBulletDataExe referes CoreUObject
SReBulletDataExe referes GameplayTags
BuildPatchServices referes BasicTypes
BuildPatchServices referes CoreUObject
BuildPatchServices referes CppTypes
SSkillInfo referes BasicTypes
SSkillInfo referes CoreUObject
SSkillInfo referes CppTypes
SSkillInfo referes ESkillGenre
SSkillInfo referes ESkillLoadType
SSkillInfo referes ESkillMode
SSkillInfo referes ESkillOverrideType
SSkillInfo referes ESkillType
SSkillInfo referes SSkillCooldownInfo
SSkillInfo referes SSkillTarget
BP_KuroSeqEvent referes BasicTypes
BP_KuroSeqEvent referes CoreUObject
BP_KuroSeqEvent referes CppTypes
BP_KuroSeqEvent referes Engine
BP_KuroSeqEvent referes SSeqCharacterBlendGroup
BP_KuroSeqEvent referes SSubtitleSettings
BP_SkyDome referes CoreUObject
BP_SkyDome referes CppTypes
BP_SkyDome referes Engine
BP_SkyDome referes PresetChangeInfo
BP_SkyDome referes PresetSelection
BP_SkyDome referes TimeOfDayCurves
BP_SkyDome referes TimeOfDayData
BP_SkyDome referes WeatherData
Landscape referes BasicTypes
Landscape referes CoreUObject
Landscape referes CppTypes
Landscape referes DeveloperSettings
Landscape referes Engine
Landscape referes PhysicsCore
TPrefab_SM_Pro_XiShengDie referes CoreUObject
TPrefab_SM_Pro_XiShengDie referes Engine
BP_Simpleholographic referes CoreUObject
BP_Simpleholographic referes CppTypes
BP_Simpleholographic referes EHolographicState
BP_Simpleholographic referes Engine
BP_Simpleholographic referes PD_HolographicEffect
BP_Simpleholographic referes SHolographicData
BP_Simpleholographic referes SMaterialParamCache
CinematicCamera referes BasicTypes
CinematicCamera referes CoreUObject
CinematicCamera referes CppTypes
CinematicCamera referes Engine
AudioExtensions referes CoreUObject
SEffectStateFloatCurve referes CoreUObject
SEffectStateFloatCurve referes KuroCurve
GameplayTags referes BasicTypes
GameplayTags referes CoreUObject
GameplayTags referes CppTypes
GameplayTags referes DeveloperSettings
GameplayTags referes Engine
StaticMeshDescription referes BasicTypes
StaticMeshDescription referes CoreUObject
StaticMeshDescription referes CppTypes
StaticMeshDescription referes MeshDescription
BP_MainGameInstance referes CoreUObject
BP_MainGameInstance referes CppTypes
BP_MainGameInstance referes Engine
BP_MainGameInstance referes KuroUtility
SMaterialControllerColorParameter referes BasicTypes
SMaterialControllerColorParameter referes CoreUObject
SMaterialControllerColorParameter referes CppTypes
SMaterialControllerColorParameter referes SMaterialControllerColorGroup
MovieSceneCapture referes BasicTypes
MovieSceneCapture referes CoreUObject
MovieSceneCapture referes CppTypes
MovieSceneCapture referes Engine
MovieSceneCapture referes ImageWriteQueue
MoviePlayer referes CoreUObject
MoviePlayer referes CppTypes
SGIData referes CoreUObject
SGIData referes CppTypes
Overlay referes BasicTypes
Overlay referes CoreUObject
TsUiNavigationTextChangeListener referes BasicTypes
TsUiNavigationTextChangeListener referes CoreUObject
TsUiNavigationTextChangeListener referes CppTypes
TsUiNavigationTextChangeListener referes Engine
TsUiNavigationTextChangeListener referes LGUI
ClothingSystemRuntimeNv referes ClothingSystemRuntimeCommon
ClothingSystemRuntimeNv referes ClothingSystemRuntimeInterface
ClothingSystemRuntimeNv referes CoreUObject
ClothingSystemRuntimeNv referes CppTypes
ABP_BaseAnimal referes AnimGraphRuntime
ABP_BaseAnimal referes CoreUObject
ABP_BaseAnimal referes CppTypes
ABP_BaseAnimal referes EAnimalEcologicalState
ABP_BaseAnimal referes Engine
ABP_BaseAnimal referes GameplayTags
ABP_BaseAnimal referes KuroAnim
ABP_BaseAnimal referes TsBaseCharacter
ChaosSolverEngine referes Chaos
ChaosSolverEngine referes CoreUObject
ChaosSolverEngine referes CppTypes
ChaosSolverEngine referes DeveloperSettings
ChaosSolverEngine referes Engine
LogicDataWhirlpool referes CoreUObject
LogicDataWhirlpool referes CppTypes
LogicDataWhirlpool referes LogicDataBase
GA_Role_Manipulate referes BPE_ManipulateState
GA_Role_Manipulate referes CoreUObject
GA_Role_Manipulate referes CppTypes
GA_Role_Manipulate referes Engine
GA_Role_Manipulate referes GA_Base
GA_Role_Manipulate referes GameplayAbilities
GA_Role_Manipulate referes GameplayTags
GeometryCollectionEngine referes Chaos
GeometryCollectionEngine referes ChaosSolverEngine
GeometryCollectionEngine referes CoreUObject
GeometryCollectionEngine referes CppTypes
GeometryCollectionEngine referes Engine
GeometryCollectionEngine referes PhysicsCore
SSceneUITagConfig referes BasicTypes
SSceneUITagConfig referes CoreUObject
BP_SM_TaskSkillByName referes BasicTypes
BP_SM_TaskSkillByName referes CoreUObject
BP_SM_TaskSkillByName referes CppTypes
BP_SM_TaskSkillByName referes SMSystem
TsUiNavigationBehaviorListener referes BasicTypes
TsUiNavigationBehaviorListener referes CoreUObject
TsUiNavigationBehaviorListener referes CppTypes
TsUiNavigationBehaviorListener referes Engine
TsUiNavigationBehaviorListener referes LGUI
TsUiNavigationBehaviorListener referes SNavigationCursor
TsUiNavigationBehaviorListener referes SNavigationMode
RigVM referes BasicTypes
RigVM referes CoreUObject
RigVM referes CppTypes
LuminRuntimeSettings referes BasicTypes
LuminRuntimeSettings referes CoreUObject
LuminRuntimeSettings referes CppTypes
LuminRuntimeSettings referes Engine
TsDecoratorIsAutonomous referes AIModule
TsDecoratorIsAutonomous referes CoreUObject
TsDecoratorIsAutonomous referes CppTypes
SAiWeaponSocket referes CoreUObject
SAiWeaponSocket referes CppTypes
EffectModelStaticMesh referes CoreUObject
EffectModelStaticMesh referes CppTypes
EffectModelStaticMesh referes Engine
EffectModelStaticMesh referes KuroCurve
EffectModelStaticMesh referes KuroGameplay
SPanelQteAction referes CoreUObject
SPanelQteAction referes CppTypes
BP_BaseHulu_Seq referes CoreUObject
BP_BaseHulu_Seq referes CppTypes
BP_BaseHulu_Seq referes Engine
Chaos referes CoreUObject
Chaos referes CppTypes
BP_MainPlayerState referes CoreUObject
BP_MainPlayerState referes Engine
GA_Role_AimThrow referes CoreUObject
GA_Role_AimThrow referes CppTypes
GA_Role_AimThrow referes Engine
GA_Role_AimThrow referes GA_Base
GA_Role_AimThrow referes GameplayAbilities
GA_Role_AimThrow referes GameplayTasks
KuroSceneInteraction_94 referes CoreUObject
KuroSceneInteraction_94 referes Engine
AudioPlatformConfiguration referes CoreUObject
AudioPlatformConfiguration referes CppTypes
SWaterEffectObject referes CoreUObject
SWaterEffectObject referes CppTypes
MediaUtils referes CoreUObject
MediaUtils referes CppTypes
CharRenderingComponent referes BasicTypes
CharRenderingComponent referes CoreUObject
CharRenderingComponent referes CppTypes
CharRenderingComponent referes ECharacterBodySpecifiedType
CharRenderingComponent referes ECharacterControllerCaseType
CharRenderingComponent referes ECharacterDitherType
CharRenderingComponent referes ECharacterRenderingType
CharRenderingComponent referes ECharacterSlotSpecifiedType
CharRenderingComponent referes Engine
CharRenderingComponent referes PDA_InteractionPlayerConfig
CharRenderingComponent referes PD_MaterialDebug
TimeOfDayCurves referes CoreUObject
TimeOfDayCurves referes Engine
SPointsRow referes CoreUObject
SPointsRow referes CppTypes
PDA_WuYinQuBattleData referes CoreUObject
PDA_WuYinQuBattleData referes CppTypes
PDA_WuYinQuBattleData referes EWuYinQuState
PDA_WuYinQuBattleData referes Engine
PDA_WuYinQuBattleData referes PDA_InteractionGlobalConfigParameters
PDA_WuYinQuBattleData referes PDA_WuYinQuBattleFightingData
PDA_WuYinQuBattleData referes PDA_WuYinQuBattleIdleData
TsAnimNotifyRoleFinishInteract referes BasicTypes
TsAnimNotifyRoleFinishInteract referes CoreUObject
TsAnimNotifyRoleFinishInteract referes CppTypes
TsAnimNotifyRoleFinishInteract referes ERoleInteractType
TsAnimNotifyRoleFinishInteract referes KuroRenderingRuntimeBPPlugin
NCS_Down_Lv3 referes CoreUObject
NCS_Down_Lv3 referes KuroAnim
WwiseObjectUtils referes CoreUObject
WwiseObjectUtils referes CppTypes
PropertyPath referes BasicTypes
PropertyPath referes CoreUObject
PropertyPath referes CppTypes
SNpcPathPoint referes BasicTypes
SNpcPathPoint referes CoreUObject
BP_SM_TaskLeaveFight referes CoreUObject
BP_SM_TaskLeaveFight referes CppTypes
BP_SM_TaskLeaveFight referes SMSystem
CS_Manipulate_Cast_Lv1 referes CoreUObject
CS_Manipulate_Cast_Lv1 referes Engine
EngineMessages referes BasicTypes
EngineMessages referes CoreUObject
EngineMessages referes CppTypes
BP_Clouds referes AkAudio
BP_Clouds referes CoreUObject
BP_Clouds referes CppTypes
BP_Clouds referes E_Cloud_Presents
BP_Clouds referes Engine
BP_Clouds referes KuroRenderingRuntimeBPPlugin
BP_Clouds referes PD_CloudPrefab
BP_Clouds referes PD_CloudPreset
BP_Clouds referes SGIData
KuroSceneInteraction_5 referes CoreUObject
KuroSceneInteraction_5 referes Engine
Serialization referes BasicTypes
Serialization referes CoreUObject
Serialization referes CppTypes
TsAnimNotifyStateAddMaterialController referes CoreUObject
TsAnimNotifyStateAddMaterialController referes CppTypes
TsAnimNotifyStateAddMaterialController referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStateAddMaterialController referes PD_CharacterControllerData
SSceneInteractionMaterialController referes CoreUObject
SSceneInteractionMaterialController referes CppTypes
SSceneInteractionMaterialController referes Engine
SSceneInteractionMaterialController referes ItemMaterialControllerActorData
SessionMessages referes BasicTypes
SessionMessages referes CoreUObject
SessionMessages referes CppTypes
TsSceneUiTag referes BasicTypes
TsSceneUiTag referes CoreUObject
TsSceneUiTag referes CppTypes
TsSceneUiTag referes Engine
SEffectColorParameter referes BasicTypes
SEffectColorParameter referes CoreUObject
TsAnimNotifyStateSetRootMotionScale referes BasicTypes
TsAnimNotifyStateSetRootMotionScale referes CoreUObject
TsAnimNotifyStateSetRootMotionScale referes CppTypes
TsAnimNotifyStateSetRootMotionScale referes GameplayTags
TsAnimNotifyStateSetRootMotionScale referes KuroRenderingRuntimeBPPlugin
SBulletDataEffect referes CoreUObject
SBulletDataEffect referes CppTypes
BP_RainComponent_CommonDrop referes CoreUObject
BP_RainComponent_CommonDrop referes CppTypes
BP_RainComponent_CommonDrop referes Engine
BP_RainComponent_CommonDrop referes KuroRenderingRuntimeBPPlugin
BP_RainComponent_CommonDrop referes Niagara
BP_RainComponent_CommonDrop referes PDA_RainConfig_CommonDrop
AutomationMessages referes BasicTypes
AutomationMessages referes CoreUObject
AutomationMessages referes CppTypes
DmgTypeBP_Environmental referes CoreUObject
DmgTypeBP_Environmental referes Engine
PD_NpcSetupData referes BasicTypes
PD_NpcSetupData referes CoreUObject
PD_NpcSetupData referes CppTypes
PD_NpcSetupData referes ENpcSetupType
PD_NpcSetupData referes Engine
GA_WuYinQu_HuangShiGaoDi_Environment_Passive referes CoreUObject
GA_WuYinQu_HuangShiGaoDi_Environment_Passive referes CppTypes
GA_WuYinQu_HuangShiGaoDi_Environment_Passive referes Engine
GA_WuYinQu_HuangShiGaoDi_Environment_Passive referes GA_Passive
TsAnimNotifyStateTimeStopRequest referes BasicTypes
TsAnimNotifyStateTimeStopRequest referes CoreUObject
TsAnimNotifyStateTimeStopRequest referes CppTypes
TsAnimNotifyStateTimeStopRequest referes KuroRenderingRuntimeBPPlugin
MagicLeapARPinInfoActor referes CoreUObject
MagicLeapARPinInfoActor referes CppTypes
MagicLeapARPinInfoActor referes Engine
MagicLeapARPinInfoActor referes MagicLeapARPin
PDA_RainConfigs referes CoreUObject
PDA_RainConfigs referes Engine
PDA_RainConfigs referes PDA_RainConfig_CommonDrop
PDA_RainConfigs referes PDA_RainConfig_CommonReverse
PDA_RainConfig_CommonReverse referes AkAudio
PDA_RainConfig_CommonReverse referes CoreUObject
PDA_RainConfig_CommonReverse referes CppTypes
PDA_RainConfig_CommonReverse referes Engine
PDA_RainConfig_CommonReverse referes KuroCurve
PDA_RainConfig_CommonReverse referes Niagara
SCommonRainSpawnerConfig referes CoreUObject
SCommonRainSpawnerConfig referes CppTypes
PDA_ModelLensFlareConfig referes CoreUObject
PDA_ModelLensFlareConfig referes KuroRenderingRuntimeBPPlugin
SPOICloudParameters referes CoreUObject
SPOICloudParameters referes CppTypes
SPOICloudParameters referes Engine
AnimNotifyAddMotionVertexOffset referes AnimNotifyAddMaterialControllerData
AnimNotifyAddMotionVertexOffset referes BasicTypes
AnimNotifyAddMotionVertexOffset referes CoreUObject
SCloudCover referes CoreUObject
SCloudCover referes Engine
SAnomaliesParameters referes CoreUObject
SAnomaliesParameters referes CppTypes
SAnomaliesParameters referes Engine
PresetChangeInfo referes CoreUObject
PresetChangeInfo referes CppTypes
PresetChangeInfo referes Engine
PresetChangeInfo referes PresetSelection
KuroSceneInteraction_81 referes CoreUObject
KuroSceneInteraction_81 referes Engine
WeatherPreset referes CoreUObject
WeatherPreset referes WeatherData
WP_Stormy referes CoreUObject
WP_Stormy referes WeatherPreset
KuroSceneInteraction_79 referes CoreUObject
KuroSceneInteraction_79 referes Engine
WP_Snowy referes CoreUObject
WP_Snowy referes WeatherPreset
BP_SM_BindStatePartPanelVisible referes BasicTypes
BP_SM_BindStatePartPanelVisible referes CoreUObject
BP_SM_BindStatePartPanelVisible referes CppTypes
BP_SM_BindStatePartPanelVisible referes SMSystem
BP_SeqNPC referes ABPC_Seq_Body_V2
BP_SeqNPC referes BP_NpcCombinedMesh
BP_SeqNPC referes CoreUObject
BP_SeqNPC referes CppTypes
BP_SeqNPC referes PD_NpcSetupData
WP_Smoky referes CoreUObject
WP_Smoky referes WeatherPreset
BP_BaseRole_Seq_V2 referes ABPC_Seq_Body_V2
BP_BaseRole_Seq_V2 referes BP_Fx_Scanning
BP_BaseRole_Seq_V2 referes BasicTypes
BP_BaseRole_Seq_V2 referes CharRenderingComponent
BP_BaseRole_Seq_V2 referes CoreUObject
BP_BaseRole_Seq_V2 referes CppTypes
BP_BaseRole_Seq_V2 referes Engine
BP_BaseRole_Seq_V2 referes PD_CharacterControllerData
BP_BaseRole_Seq_V2 referes PD_CharacterControllerDataGroup
SCameraDebugTool_CameraFrameInfo referes CoreUObject
SCameraDebugTool_CameraFrameInfo referes CppTypes
SCameraDebugTool_CameraFrameInfo referes SCameraDebugTool_CameraModeInfo
WP_Rainy referes CoreUObject
WP_Rainy referes WeatherPreset
WP_HalfSunny referes CoreUObject
WP_HalfSunny referes WeatherPreset
WP_Gloomy referes CoreUObject
WP_Gloomy referes WeatherPreset
BP_SM_ActionEnterFight referes CoreUObject
BP_SM_ActionEnterFight referes SMSystem
SNavigationGroup referes BasicTypes
SNavigationGroup referes CoreUObject
SNavigationGroup referes CppTypes
SNavigationGroup referes LGUI
SNavigationGroup referes TsUiNavigationBehaviorListener
EmptyEntity1 referes BP_BaseItem
EmptyEntity1 referes CoreUObject
WP_Foggy referes CoreUObject
WP_Foggy referes WeatherPreset
TsAnimNotifyStateSetWalkOff referes BasicTypes
TsAnimNotifyStateSetWalkOff referes CoreUObject
TsAnimNotifyStateSetWalkOff referes CppTypes
TsAnimNotifyStateSetWalkOff referes KuroRenderingRuntimeBPPlugin
WP_Cloudy referes CoreUObject
WP_Cloudy referes WeatherPreset
LogicDataSpawnObstacles referes BasicTypes
LogicDataSpawnObstacles referes CoreUObject
LogicDataSpawnObstacles referes CppTypes
LogicDataSpawnObstacles referes EBulletLogicObstacles
LogicDataSpawnObstacles referes Engine
LogicDataSpawnObstacles referes LogicDataBase
WP_Clean referes CoreUObject
WP_Clean referes WeatherPreset
AnimNotifyStateGhost referes BasicTypes
AnimNotifyStateGhost referes CoreUObject
AnimNotifyStateGhost referes CppTypes
AnimNotifyStateGhost referes KuroRenderingRuntimeBPPlugin
TimeOfDayPreset referes CoreUObject
TimeOfDayPreset referes TimeOfDayData
PD_CloudPreset referes CoreUObject
PD_CloudPreset referes Engine
BP_CloudPrefab referes CoreUObject
BP_CloudPrefab referes CppTypes
BP_CloudPrefab referes Engine
BP_CloudPrefab referes KuroRenderingRuntimeBPPlugin
BP_CloudPrefab referes PD_CloudPrefab
BP_CloudPrefab referes SAnomaliesParameters
BP_CloudPrefab referes SCloudParameters
BP_CloudPrefab referes SGIData
BP_CloudPrefab referes SPOICloudParameters
GA_Interaction_StandControl_Passive referes CoreUObject
GA_Interaction_StandControl_Passive referes CppTypes
GA_Interaction_StandControl_Passive referes Engine
GA_Interaction_StandControl_Passive referes GA_Passive
SHitWhirlpool referes CoreUObject
SHitWhirlpool referes CppTypes
SHitWhirlpool referes EVelocityCurveType
STrailGrassDrawInfo referes CoreUObject
STrailGrassDrawInfo referes CppTypes
STrailGrassDrawInfo referes Engine
GA_Execution_wuguanzhefenshen referes BasicTypes
GA_Execution_wuguanzhefenshen referes CoreUObject
GA_Execution_wuguanzhefenshen referes CppTypes
GA_Execution_wuguanzhefenshen referes ECaughtResultType
GA_Execution_wuguanzhefenshen referes Engine
GA_Execution_wuguanzhefenshen referes GA_Base
GA_Execution_wuguanzhefenshen referes TsBaseCharacter
BP_MainGameState referes CoreUObject
BP_MainGameState referes Engine
TsParkourCheckPoint referes BasicTypes
TsParkourCheckPoint referes CoreUObject
TsParkourCheckPoint referes CppTypes
TsParkourCheckPoint referes Engine
AIC_MO1GAziziMd00501 referes AIC_AICommon
AIC_MO1GAziziMd00501 referes CoreUObject
AIC_MO1GAziziMd00501 referes CppTypes
AIC_MO1GAziziMd00501 referes Engine
AIC_MO1GAziziMd00501 referes SAiConditions
TsEntityBase referes CoreUObject
TsEntityBase referes CppTypes
TsEntityBase referes Engine
TsEntityBase referes KuroRenderingRuntimeBPPlugin
GA_Common_AirAttack referes CoreUObject
GA_Common_AirAttack referes CppTypes
GA_Common_AirAttack referes Engine
GA_Common_AirAttack referes GA_Base
BP_KuroCheatManager referes BP_CharacterController
BP_KuroCheatManager referes CoreUObject
BP_KuroCheatManager referes CppTypes
BP_KuroCheatManager referes Engine
BP_KuroCheatManager referes InputCore
SReBulletDataTime referes BasicTypes
SReBulletDataTime referes CoreUObject
SReBulletDataTime referes CppTypes
SReBulletDataTime referes STimeScale
TsLguiEventSystemActor referes CoreUObject
TsLguiEventSystemActor referes CppTypes
TsLguiEventSystemActor referes Engine
TsLguiEventSystemActor referes LGUI
GA_Qte_Nvzhu referes BP_QTE_Camera
GA_Qte_Nvzhu referes BasicTypes
GA_Qte_Nvzhu referes CoreUObject
GA_Qte_Nvzhu referes CppTypes
GA_Qte_Nvzhu referes Engine
GA_Qte_Nvzhu referes GA_Passive
SBulletDataBase referes BasicTypes
SBulletDataBase referes CoreUObject
SBulletDataBase referes CppTypes
SBulletDataBase referes EBulletHitDirectionType
SBulletDataBase referes EBulletRelativeDir
SBulletDataBase referes EBulletShape
SBulletDataBase referes EBulletType
SUiEnvironmentProperty referes CoreUObject
SUiEnvironmentProperty referes CppTypes
BP_EffectActor referes BasicTypes
BP_EffectActor referes CoreUObject
BP_EffectActor referes CppTypes
BP_EffectActor referes EEffectPlay
BP_EffectActor referes EEffectType
BP_EffectActor referes Engine
BP_EffectActor referes KuroRenderingRuntimeBPPlugin
TsCharacterDebugComponent referes AIModule
TsCharacterDebugComponent referes BasicTypes
TsCharacterDebugComponent referes CoreUObject
TsCharacterDebugComponent referes CppTypes
TsCharacterDebugComponent referes Engine
GA_Interaction_Giant referes CoreUObject
GA_Interaction_Giant referes CppTypes
GA_Interaction_Giant referes Engine
GA_Interaction_Giant referes GA_Base
EffectModelAudio referes AkAudio
EffectModelAudio referes CoreUObject
EffectModelAudio referes CppTypes
EffectModelAudio referes KuroAudio
EffectModelAudio referes KuroGameplay
BP_BaseNPC referes BP_Lipsync_AL
BP_BaseNPC referes CoreUObject
BP_BaseNPC referes CppTypes
BP_BaseNPC referes Engine
BP_BaseNPC referes NavigationSystem
BP_BaseNPC referes TsBaseCharacter
BulletLogicType referes BasicTypes
BulletLogicType referes CoreUObject
BulletLogicType referes CppTypes
BulletLogicType referes EBulletHitDirectionType
BulletLogicType referes EBulletType
BulletLogicType referes Engine
BulletLogicType referes GameplayTags
EffectModelDecal referes CoreUObject
EffectModelDecal referes CppTypes
EffectModelDecal referes Engine
EffectModelDecal referes KuroCurve
EffectModelDecal referes KuroGameplay
GA_Base referes BasicTypes
GA_Base referes CoreUObject
GA_Base referes CppTypes
GA_Base referes EAimViewState
GA_Base referes EPawnChannel
GA_Base referes ESkillType
GA_Base referes Engine
GA_Base referes GameplayAbilities
GA_Base referes GameplayTags
GA_Base referes KuroGAS
GA_Base referes SSkillInfo
BP_KuroMasterSeqEvent referes BasicTypes
BP_KuroMasterSeqEvent referes CoreUObject
BP_KuroMasterSeqEvent referes CppTypes
BP_KuroMasterSeqEvent referes Engine
GA_Passive referes CoreUObject
GA_Passive referes CppTypes
GA_Passive referes Engine
GA_Passive referes GA_Base
TsBaseItem referes BasicTypes
TsBaseItem referes CoreUObject
TsBaseItem referes CppTypes
TsBaseItem referes Engine
BPL_Input referes CoreUObject
BPL_Input referes CppTypes
BPL_Input referes EInputAction
BPL_Input referes Engine
KuroSceneInteraction_85 referes CoreUObject
KuroSceneInteraction_85 referes Engine
CharacterBlueprintFunctionLibrary referes BasicTypes
CharacterBlueprintFunctionLibrary referes CoreUObject
CharacterBlueprintFunctionLibrary referes CppTypes
CharacterBlueprintFunctionLibrary referes Engine
CharacterBlueprintFunctionLibrary referes TsBaseCharacter
SSubtitleSettings referes BasicTypes
SSubtitleSettings referes CoreUObject
SSubtitleSettings referes CppTypes
SBulletGE referes CoreUObject
SBulletGE referes KuroGAS
BP_InputBase referes CoreUObject
BP_InputBase referes CppTypes
BP_InputBase referes Engine
BP_InputBase referes SInputCaches
BP_InputBase referes SInputHoldConfig
BP_InputBase referes TsBaseCharacter
BP_InputBase referes sInputCommand
SUiRoleCameraSetting referes CoreUObject
SUiRoleCameraSetting referes CppTypes
BP_BulletLogicBase referes CoreUObject
BP_BulletLogicBase referes CppTypes
BP_BulletLogicBase referes SBulletDataMain
SCamp referes CoreUObject
BPI_Tick referes CoreUObject
BPI_Tick referes CppTypes
EffectModelNiagara referes CoreUObject
EffectModelNiagara referes KuroGameplay
LogicDataManipulatableTagsChange referes CoreUObject
LogicDataManipulatableTagsChange referes CppTypes
LogicDataManipulatableTagsChange referes GameplayTags
LogicDataManipulatableTagsChange referes LogicDataBase
STransitionLinearColorIndexGroup referes CoreUObject
NCS_Block_Perfect referes BP_CameraShakeAndForceFeedback
NCS_Block_Perfect referes CoreUObject
PD_CharacterControllerDataGroup referes CoreUObject
PD_CharacterControllerDataGroup referes CppTypes
PD_CharacterControllerDataGroup referes Engine
STransitionFloatIndexGroup referes CoreUObject
SStateBasedEffectLinearColorCurveSection referes CoreUObject
SStateBasedEffectLinearColorCurveSection referes SEffectStateLinearColorCurve
SStateBasedEffectFloatCurveSection referes CoreUObject
SStateBasedEffectFloatCurveSection referes SEffectStateFloatCurve
SHitMapping referes BasicTypes
SHitMapping referes CoreUObject
SHitMapping referes CppTypes
BPI_EffectInterface referes CoreUObject
BPI_EffectInterface referes CppTypes
SEffectStateLinearColorCurve referes CoreUObject
SEffectStateLinearColorCurve referes KuroCurve
KuroSceneInteraction_20 referes CoreUObject
KuroSceneInteraction_20 referes Engine
SEffectStateInfo referes CoreUObject
SEffectStateInfo referes CppTypes
BP_SM_ConditionBuffStack referes CoreUObject
BP_SM_ConditionBuffStack referes CppTypes
BP_SM_ConditionBuffStack referes SMSystem
PDA_FoliageClusteredEffectConfig referes CoreUObject
PDA_FoliageClusteredEffectConfig referes Engine
SHolographicData referes CoreUObject
SHolographicData referes CppTypes
SHolographicData referes Engine
TsEntityDebugInfoManager referes BasicTypes
TsEntityDebugInfoManager referes CoreUObject
TsEntityDebugInfoManager referes CppTypes
TsEntityDebugInfoManager referes Engine
TsGameSplineActor referes CoreUObject
TsGameSplineActor referes CppTypes
TsGameSplineActor referes Engine
PD_StateMachineEffect referes CoreUObject
PD_StateMachineEffect referes CppTypes
PD_StateMachineEffect referes EEffectState
PD_StateMachineEffect referes Engine
PD_StateMachineEffect referes SEffectStateInfo
SBulletDataScale referes CoreUObject
SBulletDataScale referes CppTypes
SBulletDataScale referes Engine
ABP_R2T1PlayerFemaleMd10011_PC referes CoreUObject
ABP_R2T1PlayerFemaleMd10011_PC referes CppTypes
ABP_R2T1PlayerFemaleMd10011_PC referes Engine
ABP_R2T1PlayerFemaleMd10011_PC referes KawaiiPhysics
ABP_R2T1PlayerFemaleMd10011_PC referes KuroAnim
TsAnimNotifyStateInteractionRotateToLocation referes BasicTypes
TsAnimNotifyStateInteractionRotateToLocation referes CoreUObject
TsAnimNotifyStateInteractionRotateToLocation referes CppTypes
TsAnimNotifyStateInteractionRotateToLocation referes KuroRenderingRuntimeBPPlugin
SBulletDataMove referes BasicTypes
SBulletDataMove referes CoreUObject
SBulletDataMove referes CppTypes
SBulletDataMove referes EBulletFollowType
SBulletDataMove referes Engine
SBulletDataCollision referes BasicTypes
SBulletDataCollision referes CoreUObject
SBulletDataCollision referes CppTypes
SBulletDataChild referes CoreUObject
SBulletDataChild referes CppTypes
PDA_WaterEffectConfigs referes CoreUObject
PDA_WaterEffectConfigs referes CppTypes
PDA_WaterEffectConfigs referes Engine
PDA_WaterEffectConfigs referes SWaterEffectSubConfig
BP_TrailGrassActor referes BP_TrailGrassSensorComponent
BP_TrailGrassActor referes CoreUObject
BP_TrailGrassActor referes Engine
SQuestRequest referes BasicTypes
SQuestRequest referes CoreUObject
SQuestRequest referes CppTypes
SQuestRequest referes EQuestHandleType
SQuestRequest referes Engine
TsAnimNotifyEndSkill referes BasicTypes
TsAnimNotifyEndSkill referes CoreUObject
TsAnimNotifyEndSkill referes CppTypes
TsAnimNotifyEndSkill referes KuroRenderingRuntimeBPPlugin
BP_SM_ActionRemoveBuff referes CoreUObject
BP_SM_ActionRemoveBuff referes CppTypes
BP_SM_ActionRemoveBuff referes SMSystem
SInteractionLimit referes CoreUObject
SInteractionLimit referes CppTypes
SInteractionLimit referes EInteractOptionLimit
SSkillCooldownInfo referes CoreUObject
SSkillCooldownInfo referes CppTypes
GA_Role_ManipulateCancle referes CoreUObject
GA_Role_ManipulateCancle referes CppTypes
GA_Role_ManipulateCancle referes Engine
GA_Role_ManipulateCancle referes GA_Base
SMaterialControllerColorGroup referes CoreUObject
SMaterialControllerColorGroup referes KuroCurve
SNavigationMode referes CoreUObject
SNavigationMode referes CppTypes
SNavigationMode referes Engine
SNavigationMode referes LGUI
CameraBlueprintFunctionLibrary referes BasicTypes
CameraBlueprintFunctionLibrary referes CoreUObject
CameraBlueprintFunctionLibrary referes CppTypes
CameraBlueprintFunctionLibrary referes EAimAssistMode
CameraBlueprintFunctionLibrary referes ECameraAnsEffectiveClientType
CameraBlueprintFunctionLibrary referes ECustomCameraMode
CameraBlueprintFunctionLibrary referes Engine
CameraBlueprintFunctionLibrary referes GameplayTags
CameraBlueprintFunctionLibrary referes LevelSequence
CameraBlueprintFunctionLibrary referes SBaseCurve
CameraBlueprintFunctionLibrary referes SCameraDebugTool_CameraModeInfo
CameraBlueprintFunctionLibrary referes SCameraModifier_Settings
CameraBlueprintFunctionLibrary referes SSequenceCamera_Settings
TsEffectFunctionLibrary referes BasicTypes
TsEffectFunctionLibrary referes CoreUObject
TsEffectFunctionLibrary referes CppTypes
TsEffectFunctionLibrary referes EEffectPlay
TsEffectFunctionLibrary referes EEffectType
TsEffectFunctionLibrary referes Engine
ItemMaterialControllerActorData referes CoreUObject
ItemMaterialControllerActorData referes CppTypes
ItemMaterialControllerActorData referes ECharacterControllerUVSwitch
ItemMaterialControllerActorData referes Engine
ItemMaterialControllerActorData referes KuroCurve
BP_StateMachineEffectBase referes BasicTypes
BP_StateMachineEffectBase referes CoreUObject
BP_StateMachineEffectBase referes CppTypes
BP_StateMachineEffectBase referes EEffectState
BP_StateMachineEffectBase referes Engine
BP_StateMachineEffectBase referes KuroRenderingRuntimeBPPlugin
BP_StateMachineEffectBase referes PD_StateMachineEffect
BP_StateMachineEffectBase referes SEffectStateInfo
GA_WuYinQu_YuanNiaoZe_Passive referes CoreUObject
GA_WuYinQu_YuanNiaoZe_Passive referes CppTypes
GA_WuYinQu_YuanNiaoZe_Passive referes Engine
GA_WuYinQu_YuanNiaoZe_Passive referes GA_Passive
AnimNotifyEffect referes BasicTypes
AnimNotifyEffect referes CoreUObject
AnimNotifyEffect referes CppTypes
AnimNotifyEffect referes EAnimNotifyEffectLocationType
AnimNotifyEffect referes ESkillEffectType
AnimNotifyEffect referes KuroRenderingRuntimeBPPlugin
SMaterialControllerTextureParameter referes BasicTypes
SMaterialControllerTextureParameter referes CoreUObject
SMaterialControllerTextureParameter referes CppTypes
SMaterialControllerTextureParameter referes SMaterialControllerTextureGroup
SMaterialControllerLoopTime referes CoreUObject
SMaterialControllerLoopTime referes CppTypes
KuroSceneInteraction_8 referes CoreUObject
KuroSceneInteraction_8 referes Engine
SSceneInteractionSequence referes CoreUObject
SSceneInteractionSequence referes CppTypes
SSceneInteractionSequence referes LevelSequence
EffectModelGroup referes CoreUObject
EffectModelGroup referes KuroCurve
EffectModelGroup referes KuroGameplay
BP_SM_BindStateDisableCollision referes CoreUObject
BP_SM_BindStateDisableCollision referes SMSystem
BPI_CreatureInterface referes CoreUObject
BPI_CreatureInterface referes CppTypes
BP_FightManager referes BP_ActorManager
BP_FightManager referes BP_ManagerBase
BP_FightManager referes BasicTypes
BP_FightManager referes CoreUObject
BP_FightManager referes CppTypes
BP_FightManager referes ECamp
BP_FightManager referes ERelation
BP_FightManager referes Engine
BP_FightManager referes SHitMapping
BP_SM_ActionDispatchEvent referes BasicTypes
BP_SM_ActionDispatchEvent referes CoreUObject
BP_SM_ActionDispatchEvent referes SMSystem
TsTaskWait referes BasicTypes
TsTaskWait referes CoreUObject
TsTaskWait referes CppTypes
TsTaskWait referes Engine
TsTaskWait referes TsTaskAbortImmediatelyBase
GA_WuYinQu_YuanNiaoZe referes CoreUObject
GA_WuYinQu_YuanNiaoZe referes CppTypes
GA_WuYinQu_YuanNiaoZe referes Engine
GA_WuYinQu_YuanNiaoZe referes GA_Base
GA_WuYinQu_YuanNiaoZe referes GameplayAbilities
GA_WuYinQu_YuanNiaoZe referes GameplayTags
GA_Hook_SwingingEnd referes CoreUObject
GA_Hook_SwingingEnd referes CppTypes
GA_Hook_SwingingEnd referes Engine
GA_Hook_SwingingEnd referes GA_Base
GA_Hook_SwingingEnd referes GameplayAbilities
GA_Hook_SwingingEnd referes GameplayTags
PDA_InteractionPlayerConfig referes CoreUObject
PDA_InteractionPlayerConfig referes CppTypes
PDA_InteractionPlayerConfig referes Engine
PDA_InteractionPlayerConfig referes KuroRenderingRuntimeBPPlugin
PDA_InteractionPlayerConfig referes PDA_WaterEffectConfigs
SMovementRotationSetting referes CoreUObject
SMovementRotationSetting referes CppTypes
SMovementRotationSetting referes SBaseCurve
BulletCampType referes CoreUObject
BulletCampType referes CppTypes
BulletCampType referes Engine
SLockOnPart referes BasicTypes
SLockOnPart referes CoreUObject
SLockOnPart referes CppTypes
TPrefab_SM_Gat_16A referes CoreUObject
TPrefab_SM_Gat_16A referes Engine
ABP_SwordSwordCommon referes AnimGraphRuntime
ABP_SwordSwordCommon referes BasicTypes
ABP_SwordSwordCommon referes CoreUObject
ABP_SwordSwordCommon referes CppTypes
ABP_SwordSwordCommon referes EWeaponViewName
ABP_SwordSwordCommon referes Engine
ABP_SwordSwordCommon referes TsBaseCharacter
ABP_SwordSwordCommon referes TsUiSceneRoleActor
PD_CurveFloatData referes CoreUObject
PD_CurveFloatData referes CppTypes
PD_CurveFloatData referes Engine
PD_CurveFloatData referes KuroCurve
STimeScale referes CoreUObject
STimeScale referes CppTypes
STimeScale referes Engine
BP_CameraShakeAndForceFeedback referes CoreUObject
BP_CameraShakeAndForceFeedback referes KuroAnim
BP_CameraShakeAndForceFeedback referes KuroInput
KuroSceneInteraction_48 referes CoreUObject
KuroSceneInteraction_48 referes Engine
TsTaskUseSkill referes CoreUObject
TsTaskUseSkill referes CppTypes
TsTaskUseSkill referes Engine
TsTaskUseSkill referes TsTaskAbortImmediatelyBase
SReBulletDataScale referes CoreUObject
SReBulletDataScale referes CppTypes
SReBulletDataScale referes Engine
GA_Role_Move_B_Net referes CoreUObject
GA_Role_Move_B_Net referes CppTypes
GA_Role_Move_B_Net referes Engine
GA_Role_Move_B_Net referes GA_Base
GA_Role_Move_B_Net referes GameplayAbilities
GA_Role_Move_B_Net referes GameplayTags
SReBulletDataObstacles referes CoreUObject
SReBulletDataObstacles referes CppTypes
SSkillTarget referes CoreUObject
SSkillTarget referes CppTypes
SSkillTarget referes ESkillTargetDirection
SSkillTarget referes ESkillTargetPriority
SUiAnimNotifyEffect referes BasicTypes
SUiAnimNotifyEffect referes CoreUObject
SUiAnimNotifyEffect referes EPerformanceRoleState
KuroSceneInteraction_51 referes CoreUObject
KuroSceneInteraction_51 referes Engine
SReBulletDataMove referes BasicTypes
SReBulletDataMove referes CoreUObject
SReBulletDataMove referes CppTypes
SReBulletDataMove referes EBulletDestOffset
SReBulletDataMove referes EBulletFollowType
SReBulletDataMove referes EBulletTarget
SReBulletDataMove referes EInitialVelocityDirection
SReBulletDataMove referes EMoveTrajectory
SReBulletDataMove referes Engine
SReBulletDataLogic referes CoreUObject
BP_SM_BindStateCollisionChannel referes CoreUObject
BP_SM_BindStateCollisionChannel referes SMSystem
TsAnimNotifyStateRoleRotate referes CoreUObject
TsAnimNotifyStateRoleRotate referes CppTypes
TsAnimNotifyStateRoleRotate referes GameplayTags
TsAnimNotifyStateRoleRotate referes KuroRenderingRuntimeBPPlugin
SReBulletDataInteraction referes CoreUObject
SReBulletDataEntity referes CoreUObject
SReBulletDataEntity referes CppTypes
SReBulletDataBase referes BasicTypes
SReBulletDataBase referes CoreUObject
SReBulletDataBase referes CppTypes
SReBulletDataBase referes EBulletRelativeDir
SReBulletDataBase referes EBulletShape
SReBulletDataBase referes EBulletSyncType
SReBulletDataBase referes EHitType
SReBulletDataBase referes EPositionStandard
SReBulletDataBase referes GameplayTags
GA_MO1DundishuMd00601_Attack04 referes CoreUObject
GA_MO1DundishuMd00601_Attack04 referes CppTypes
GA_MO1DundishuMd00601_Attack04 referes Engine
GA_MO1DundishuMd00601_Attack04 referes GA_Monster_Base
SMovementSetting_Posture referes CoreUObject
SMovementSetting_Posture referes SMovementSetting
NCS_Block_Nomal referes BP_CameraShakeAndForceFeedback
NCS_Block_Nomal referes CoreUObject
GA_Role_Hook referes CoreUObject
GA_Role_Hook referes CppTypes
GA_Role_Hook referes Engine
GA_Role_Hook referes GA_Base
GA_Role_Hook referes GameplayAbilities
GA_Role_Hook referes TsBaseCharacter
SCounterAttackEffect referes CoreUObject
SCounterAttackEffect referes CppTypes
SCounterAttackEffect referes SCounterAttackCamera
SCounterAttackEffect referes STimeScale
SCaughtTriggerInfo referes BasicTypes
SCaughtTriggerInfo referes CoreUObject
SCaughtTriggerInfo referes CppTypes
BP_UiActorCallBack referes BasicTypes
BP_UiActorCallBack referes CoreUObject
BP_UiActorCallBack referes CppTypes
BP_UiActorCallBack referes EPerformanceRoleState
BP_UiActorCallBack referes Engine
BP_UiActorCallBack referes SUiAnimNotifyEffect
BP_UiActorCallBack referes SUiAnimNotifyModel
PD_CharacterControllerData referes CoreUObject
PD_CharacterControllerData referes CppTypes
PD_CharacterControllerData referes ECharacterBodySpecifiedType
PD_CharacterControllerData referes ECharacterControllerApplyType
PD_CharacterControllerData referes ECharacterControllerChannelSwitch
PD_CharacterControllerData referes ECharacterControllerType
PD_CharacterControllerData referes ECharacterControllerUVSwitch
PD_CharacterControllerData referes ECharacterSlotSpecifiedType
PD_CharacterControllerData referes Engine
PD_CharacterControllerData referes KuroRenderingRuntimeBPPlugin
PD_CharacterControllerData referes SMaterialControllerColorGroup
PD_CharacterControllerData referes SMaterialControllerFloatGroup
PD_CharacterControllerData referes SMaterialControllerLoopTime
SimplpNpcStateData referes CoreUObject
SimplpNpcStateData referes CppTypes
BP_SequenceData_Generated referes BasicTypes
BP_SequenceData_Generated referes CoreUObject
BP_SequenceData_Generated referes Engine
SStateBasedEffect referes BP_StateMachineEffectBase
SStateBasedEffect referes CoreUObject
SSceneInteractionMontage referes CoreUObject
SSceneInteractionMontage referes CppTypes
SSceneInteractionMontage referes Engine
SSceneInteractionitemIndestructibleEffectsParameters referes CoreUObject
SSceneInteractionitemIndestructibleEffectsParameters referes CppTypes
TsAiBlueprintFunctionLibrary referes BasicTypes
TsAiBlueprintFunctionLibrary referes CoreUObject
TsAiBlueprintFunctionLibrary referes CppTypes
TsAiBlueprintFunctionLibrary referes EQuestStepState
TsAiBlueprintFunctionLibrary referes Engine
TsAiBlueprintFunctionLibrary referes GameplayTags
EffectModelGpuParticle referes CoreUObject
EffectModelGpuParticle referes CppTypes
EffectModelGpuParticle referes KuroCurve
EffectModelGpuParticle referes KuroGameplay
EffectModelGpuParticle referes KuroRenderingRuntimeBPPlugin
SSceneInteractionCrossStateEffect referes BP_EffectActor
SSceneInteractionCrossStateEffect referes CoreUObject
SSceneInteractionCrossStateEffect referes CppTypes
LogicDataManipulatableCreateBullet referes CoreUObject
LogicDataManipulatableCreateBullet referes CppTypes
LogicDataManipulatableCreateBullet referes EBulletObject
LogicDataManipulatableCreateBullet referes GameplayTags
LogicDataManipulatableCreateBullet referes LogicDataBase
SSceneInteractionAudio referes AkAudio
SSceneInteractionAudio referes CoreUObject
SSceneInteractionAudio referes CppTypes
SKuroInteractionLimbsConfig referes BasicTypes
SKuroInteractionLimbsConfig referes CoreUObject
SKuroInteractionLimbsConfig referes CppTypes
KuroSceneInteraction_68 referes CoreUObject
KuroSceneInteraction_68 referes Engine
GA_WuYinQu_HuangShiGaoDi2_Attack_Passive referes CoreUObject
GA_WuYinQu_HuangShiGaoDi2_Attack_Passive referes CppTypes
GA_WuYinQu_HuangShiGaoDi2_Attack_Passive referes Engine
GA_WuYinQu_HuangShiGaoDi2_Attack_Passive referes GA_Passive
TsAnimNotifyAddTag referes BasicTypes
TsAnimNotifyAddTag referes CoreUObject
TsAnimNotifyAddTag referes CppTypes
TsAnimNotifyAddTag referes GameplayTags
TsAnimNotifyAddTag referes KuroRenderingRuntimeBPPlugin
SSkillBehaviorBullet referes BasicTypes
SSkillBehaviorBullet referes CoreUObject
SSkillBehaviorBullet referes CppTypes
SCameraModifier_Condition referes CoreUObject
SCameraModifier_Condition referes CppTypes
SCameraModifier_Condition referes ECameraModifyConditionType
SCameraModifier_Condition referes GameplayTags
ABP_SwordScabbarcdCommon referes AnimGraphRuntime
ABP_SwordScabbarcdCommon referes CoreUObject
ABP_SwordScabbarcdCommon referes CppTypes
ABP_SwordScabbarcdCommon referes EWeaponViewName
ABP_SwordScabbarcdCommon referes Engine
ABP_SwordScabbarcdCommon referes TsBaseCharacter
ABP_SwordScabbarcdCommon referes TsUiSceneRoleActor
KuroSceneInteraction_32 referes CoreUObject
KuroSceneInteraction_32 referes Engine
BP_KuroProjectilePathTracer referes CoreUObject
BP_KuroProjectilePathTracer referes CppTypes
BP_KuroProjectilePathTracer referes Engine
BP_KuroProjectilePathTracer referes PD_KuroProjectileAsset
GlobalBlueprintFunctionLibrary referes CoreUObject
GlobalBlueprintFunctionLibrary referes Engine
ItemMaterialControllerMPCData referes CoreUObject
ItemMaterialControllerMPCData referes Engine
TsTaskSkillWander referes CoreUObject
TsTaskSkillWander referes CppTypes
TsTaskSkillWander referes Engine
TsTaskSkillWander referes TsTaskAbortImmediatelyBase
BPL_WorldUtility referes BasicTypes
BPL_WorldUtility referes CoreUObject
BPL_WorldUtility referes CppTypes
BPL_WorldUtility referes Engine
BPL_WorldUtility referes SAIConfig
BPL_WorldUtility referes SEntityConfig
BPL_WorldUtility referes SEntityProperty
BPL_WorldUtility referes SMapConfig
BPL_WorldUtility referes SModelConfig
SUiCameraAnimationBlendSettings referes CoreUObject
SUiCameraAnimationBlendSettings referes CppTypes
BP_ABPLogicParams referes CoreUObject
BP_ABPLogicParams referes CppTypes
BP_ABPLogicParams referes ECharParentMoveState
BP_ABPLogicParams referes ECharState
BP_ABPLogicParams referes ECharViewDirectionState
BP_ABPLogicParams referes EHitAnim
BP_ABPLogicParams referes SClimbInfo
BP_ABPLogicParams referes SClimbState
SServerInfo referes BasicTypes
SServerInfo referes CoreUObject
SServerInfo referes CppTypes
AnimNotifyStateEffect referes BasicTypes
AnimNotifyStateEffect referes CoreUObject
AnimNotifyStateEffect referes CppTypes
AnimNotifyStateEffect referes ESkillEffectType
AnimNotifyStateEffect referes GameplayTags
AnimNotifyStateEffect referes KuroRenderingRuntimeBPPlugin
KuroSceneInteraction_4 referes CoreUObject
KuroSceneInteraction_4 referes Engine
CS_Manipulate_Absorb referes CoreUObject
CS_Manipulate_Absorb referes Engine
TsDecoratorCheckFsmState referes AIModule
TsDecoratorCheckFsmState referes BasicTypes
TsDecoratorCheckFsmState referes CoreUObject
TsDecoratorCheckFsmState referes CppTypes
SSceneInteractionMaterialParameterCollection referes CoreUObject
UiBlueprintFunctionLibrary referes BasicTypes
UiBlueprintFunctionLibrary referes CoreUObject
UiBlueprintFunctionLibrary referes CppTypes
UiBlueprintFunctionLibrary referes EWeaponViewName
UiBlueprintFunctionLibrary referes Engine
PDA_BadSignalParameters referes CoreUObject
PDA_BadSignalParameters referes CppTypes
PDA_BadSignalParameters referes Engine
TsDecoratorFight referes AIModule
TsDecoratorFight referes CoreUObject
TsDecoratorFight referes CppTypes
AkiWorld_WP referes CoreUObject
AkiWorld_WP referes CppTypes
AkiWorld_WP referes Engine
GA_WuYinQu_YiLuoYuanXiang_Ball_Passive referes CoreUObject
GA_WuYinQu_YiLuoYuanXiang_Ball_Passive referes CppTypes
GA_WuYinQu_YiLuoYuanXiang_Ball_Passive referes Engine
GA_WuYinQu_YiLuoYuanXiang_Ball_Passive referes GA_Passive
SSkillBehavior referes CoreUObject
BP_SM_BindStateBoneVisible referes BasicTypes
BP_SM_BindStateBoneVisible referes CoreUObject
BP_SM_BindStateBoneVisible referes CppTypes
BP_SM_BindStateBoneVisible referes SMSystem
AIC_MO1DundishuMd00601 referes AIC_AICommon
AIC_MO1DundishuMd00601 referes CoreUObject
AIC_MO1DundishuMd00601 referes CppTypes
AIC_MO1DundishuMd00601 referes Engine
AIC_MO1DundishuMd00601 referes SAiConditions
AIC_MO1DundishuMd00601 referes TsBaseCharacter
GA_Interaction_Catapult referes CoreUObject
GA_Interaction_Catapult referes CppTypes
GA_Interaction_Catapult referes Engine
GA_Interaction_Catapult referes GA_Base
TsUiAutoPlayLevelSequenceComponent referes CoreUObject
TsUiAutoPlayLevelSequenceComponent referes CppTypes
TsUiAutoPlayLevelSequenceComponent referes Engine
TsUiAutoPlayLevelSequenceComponent referes LGUI
SSequencesKeyFrames referes CoreUObject
TsAnimNotifyStateRotate referes BasicTypes
TsAnimNotifyStateRotate referes CoreUObject
TsAnimNotifyStateRotate referes CppTypes
TsAnimNotifyStateRotate referes EAnsRotateBlackboardType
TsAnimNotifyStateRotate referes Engine
TsAnimNotifyStateRotate referes KuroRenderingRuntimeBPPlugin
GA_VisionControl referes CoreUObject
GA_VisionControl referes CppTypes
GA_VisionControl referes Engine
GA_VisionControl referes GA_Base
Item_ShengXian referes BP_BaseItem
Item_ShengXian referes CoreUObject
TsTaskTurnToTarget referes BasicTypes
TsTaskTurnToTarget referes CoreUObject
TsTaskTurnToTarget referes CppTypes
TsTaskTurnToTarget referes Engine
TsTaskTurnToTarget referes TsTaskAbortImmediatelyBase
NCS_Up_Lv9 referes BP_CameraShakeAndForceFeedback
NCS_Up_Lv9 referes CoreUObject
KuroSceneInteraction_17 referes CoreUObject
KuroSceneInteraction_17 referes Engine
SkyBoxEntity referes BP_BaseItem
SkyBoxEntity referes CoreUObject
SkyBoxEntity referes CppTypes
SkyBoxEntity referes KuroRenderingRuntimeBPPlugin
BP_SM_BindStateBoneCollision referes BasicTypes
BP_SM_BindStateBoneCollision referes CoreUObject
BP_SM_BindStateBoneCollision referes CppTypes
BP_SM_BindStateBoneCollision referes SMSystem
BP_SnowActor referes CoreUObject
BP_SnowActor referes Engine
BP_SnowActor referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyCameraModify referes BasicTypes
TsAnimNotifyCameraModify referes CoreUObject
TsAnimNotifyCameraModify referes CppTypes
TsAnimNotifyCameraModify referes ECameraAnsEffectiveClientType
TsAnimNotifyCameraModify referes GameplayTags
TsAnimNotifyCameraModify referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyCameraModify referes SCameraModifier_Settings
EffectViewComponent referes CoreUObject
EffectViewComponent referes CppTypes
EffectViewComponent referes Engine
TsTaskRandomFloat referes BasicTypes
TsTaskRandomFloat referes CoreUObject
TsTaskRandomFloat referes CppTypes
TsTaskRandomFloat referes Engine
TsTaskRandomFloat referes TsTaskAbortImmediatelyBase
SWeaponMesh referes BasicTypes
SWeaponMesh referes CoreUObject
SWeaponMesh referes CppTypes
BP_UiSceneRenderingComponent referes BP_GlobalGI
BP_UiSceneRenderingComponent referes BasicTypes
BP_UiSceneRenderingComponent referes CoreUObject
BP_UiSceneRenderingComponent referes CppTypes
BP_UiSceneRenderingComponent referes Engine
BP_SM_ActionResetPart referes BasicTypes
BP_SM_ActionResetPart referes CoreUObject
BP_SM_ActionResetPart referes CppTypes
BP_SM_ActionResetPart referes SMSystem
PDA_InteractionGlobalConfig referes CoreUObject
PDA_InteractionGlobalConfig referes CppTypes
PDA_InteractionGlobalConfig referes Engine
PDA_InteractionGlobalConfig referes PDA_InteractionGlobalConfigParameters
TPrefab_SM_Pro_Mine_5 referes CoreUObject
TPrefab_SM_Pro_Mine_5 referes Engine
SWeaponSocket referes CoreUObject
SWeaponSocket referes SWeaponSocketItem
NCS_Out_Lv3 referes CoreUObject
NCS_Out_Lv3 referes KuroAnim
SceneEffectStatePostVolume referes CoreUObject
SceneEffectStatePostVolume referes CppTypes
SceneEffectStatePostVolume referes Engine
SceneEffectStatePostVolume referes KuroRenderingRuntimeBPPlugin
ABP_MO1DundishuMd00601 referes ABP_MonsterCommon
ABP_MO1DundishuMd00601 referes CoreUObject
SSceneDecorationConfig referes BasicTypes
SSceneDecorationConfig referes CoreUObject
SFootprint referes CoreUObject
SFootprint referes CppTypes
SFootprint referes PhysicsCore
BP_InteractFoliageManager referes CoreUObject
BP_InteractFoliageManager referes CppTypes
BP_InteractFoliageManager referes Engine
SUiRoleCameraOffsetSetting referes CoreUObject
SUiRoleCameraOffsetSetting referes CppTypes
TPrefab_SM_Gat_17A referes CoreUObject
TPrefab_SM_Gat_17A referes Engine
SSkillBehaviorCondition referes CoreUObject
SSkillBehaviorCondition referes CppTypes
SSkillBehaviorCondition referes ESkillBehaviorComparisonLogic
SSkillBehaviorCondition referes ESkillBehaviorConditionType
SSkillBehaviorCondition referes GameplayTags
SCameraDebugTool_ControllerModification referes BasicTypes
SCameraDebugTool_ControllerModification referes CoreUObject
TsMeshAnimBlueprintFunctionLibrary referes BasicTypes
TsMeshAnimBlueprintFunctionLibrary referes CoreUObject
TsMeshAnimBlueprintFunctionLibrary referes CppTypes
TsMeshAnimBlueprintFunctionLibrary referes Engine
TsMeshAnimBlueprintFunctionLibrary referes SFootstepAudioEventParam
TsMeshAnimBlueprintFunctionLibrary referes SWeaponSocketItem
SCameraDebugTool_SubCameraModification referes BasicTypes
SCameraDebugTool_SubCameraModification referes CoreUObject
SCameraDebugTool_SubCameraModification referes CppTypes
SCameraDebugTool_CameraProperty referes BasicTypes
SCameraDebugTool_CameraProperty referes CoreUObject
SCameraDebugTool_CameraProperty referes CppTypes
SCameraDebugTool_CameraModeInfo referes CoreUObject
SCameraDebugTool_CameraModeInfo referes CppTypes
SCameraDebugTool_CameraModeInfo referes ECustomCameraMode
SNavigationCursor referes CoreUObject
SNavigationCursor referes CppTypes
SNavigationCursor referes ECursorOffsetType
DataTableUtil referes BasicTypes
DataTableUtil referes CoreUObject
DataTableUtil referes CppTypes
DataTableUtil referes ECamp
DataTableUtil referes Engine
DataTableUtil referes SAIConfig
DataTableUtil referes SAiWeaponSocket
DataTableUtil referes SCamp
DataTableUtil referes SCharacterFightInfo
DataTableUtil referes SCipherGameplay
DataTableUtil referes SConditionGroup
DataTableUtil referes SHitMapping
DataTableUtil referes SInteractionConfig
DataTableUtil referes SManipulateConfig
DataTableUtil referes SModelConfig
DataTableUtil referes SParkourConfig
DataTableUtil referes SRoleQualityInfo
DataTableUtil referes SSceneDecorationConfig
DataTableUtil referes SSceneUITagConfig
DataTableUtil referes SSequencesNetwork
DataTableUtil referes SUiCameraAnimationBlendSettings
DataTableUtil referes SUiCameraAnimationSettings
DataTableUtil referes SVisionData
DataTableUtil referes SWeaponSocketItem
TsDecoratorWander referes AIModule
TsDecoratorWander referes CoreUObject
TsDecoratorWander referes CppTypes
SSequenceMember referes CoreUObject
SSequenceMember referes CppTypes
GA_Interaction_Bounce_Passive referes CoreUObject
GA_Interaction_Bounce_Passive referes CppTypes
GA_Interaction_Bounce_Passive referes Engine
GA_Interaction_Bounce_Passive referes GA_Passive
GA_WuYinQu_HuangShiGaoDi_Environment referes CoreUObject
GA_WuYinQu_HuangShiGaoDi_Environment referes CppTypes
GA_WuYinQu_HuangShiGaoDi_Environment referes Engine
GA_WuYinQu_HuangShiGaoDi_Environment referes GA_Base
GA_WuYinQu_HuangShiGaoDi_Environment referes GameplayAbilities
GA_WuYinQu_HuangShiGaoDi_Environment referes GameplayTags
KuroSceneInteraction_59 referes CoreUObject
KuroSceneInteraction_59 referes Engine
SScenePropertyEffect referes BP_EffectActor
SScenePropertyEffect referes CoreUObject
SScenePropertyEffect referes SSceneInteractionMaterialController
SimpleNpcFlowComponent referes CoreUObject
SimpleNpcFlowComponent referes Engine
SWaterEffectItem referes CoreUObject
SWaterEffectItem referes CppTypes
NCS_Down_Lv4 referes CoreUObject
NCS_Down_Lv4 referes KuroAnim
SWaterEffectGroup referes CoreUObject
SWaterEffectGroup referes CppTypes
SNpcHookPart referes CoreUObject
SNpcHookPart referes CppTypes
SNpcHookPart referes Engine
TsAnimNotifyStateCaughtTrigger referes BasicTypes
TsAnimNotifyStateCaughtTrigger referes CoreUObject
TsAnimNotifyStateCaughtTrigger referes CppTypes
TsAnimNotifyStateCaughtTrigger referes KuroRenderingRuntimeBPPlugin
SMaterialControllerFloatGroup referes CoreUObject
SMaterialControllerFloatGroup referes KuroCurve
SSceneInteractionitem referes CoreUObject
SSceneInteractionitem referes CppTypes
SSceneInteractionitem referes PD_CharacterControllerDataGroup
SSceneInteractionitem referes SSceneInteractionAudio
SSceneInteractionitem referes SSceneInteractionMontage
SSceneInteractionitem referes SSceneInteractionSequence
TsAnimNotifyStateModifyTough referes BasicTypes
TsAnimNotifyStateModifyTough referes CoreUObject
TsAnimNotifyStateModifyTough referes CppTypes
TsAnimNotifyStateModifyTough referes KuroRenderingRuntimeBPPlugin
SMaterialDebugInfo referes BasicTypes
SMaterialDebugInfo referes CoreUObject
BPL_CharacterUtility referes BasicTypes
BPL_CharacterUtility referes CoreUObject
BPL_CharacterUtility referes CppTypes
BPL_CharacterUtility referes EMovementDirection
BPL_CharacterUtility referes Engine
BPL_CharacterUtility referes SAttributeModifierData
BPL_CharacterUtility referes SBulletDataMain
BPL_CharacterUtility referes SCaughtInfo
BPL_CharacterUtility referes SDamageData
BPL_CharacterUtility referes SEffectData
BPL_CharacterUtility referes SHitEffect
BPL_CharacterUtility referes SMovementSetting_State
BPL_CharacterUtility referes SReBulletDataMain
BPL_CharacterUtility referes SSkillInfo
BPL_CharacterUtility referes SVisionData
SCharacterFightInfo referes CoreUObject
BP_SM_ActionResetStatus referes CoreUObject
BP_SM_ActionResetStatus referes SMSystem
SCharacterPart referes BasicTypes
SCharacterPart referes CoreUObject
SCharacterPart referes CppTypes
SCharacterPart referes GameplayTags
SCharacterPart referes KuroGameplay
SCharacterPart referes PD_CharacterControllerData
SCaughtInfo referes CoreUObject
SCaughtInfo referes SCaughtBindingInfo
SCaughtInfo referes SCaughtTriggerInfo
SVisionCounterAttack referes CoreUObject
SVisionCounterAttack referes CppTypes
SVisionCounterAttack referes SCounterAttackEffect
SCounterAttack referes CoreUObject
SCounterAttack referes CppTypes
SCounterAttack referes GameplayTags
SCounterAttack referes SCounterAttackEffect
SClimbInfo referes CoreUObject
SClimbInfo referes CppTypes
SClimbState referes CoreUObject
SClimbState referes EClimbState
SClimbState referes EEnterClimb
SClimbState referes EExitClimb
SMovementSetting_State referes CoreUObject
SMovementSetting_State referes SMovementSetting_Posture
SInputCaches referes CoreUObject
SInputCaches referes CppTypes
KuroSceneInteraction_2 referes CoreUObject
KuroSceneInteraction_2 referes Engine
SCounterAttackCamera referes BasicTypes
SCounterAttackCamera referes CoreUObject
SCounterAttackCamera referes CppTypes
SCounterAttackCamera referes GameplayTags
SCounterAttackCamera referes SCameraModifier_Settings
SReBulletDataPerformance referes CoreUObject
SReBulletDataPerformance referes CppTypes
SReBulletDataChildren referes CoreUObject
SReBulletDataChildren referes CppTypes
SReBulletDataChildren referes EBulletChildrenType
SHitInformation referes BasicTypes
SHitInformation referes BulletLogicType
SHitInformation referes CoreUObject
SHitInformation referes CppTypes
SHitInformation referes SHitEffect
SHitInformation referes SReBulletDataMain
SHitInformation referes TsBaseCharacter
SUiCameraAnimationSettings referes BasicTypes
SUiCameraAnimationSettings referes CoreUObject
SUiCameraAnimationSettings referes CppTypes
SUiCameraAnimationSettings referes EUiCameraAnimationLocationType
SUiCameraAnimationSettings referes EUiCameraAnimationRotationType
SUiCameraAnimationSettings referes EUiCameraAnimationTargetType
SUiCameraAnimationSettings referes Engine
NCS_In_Lv2 referes CoreUObject
NCS_In_Lv2 referes KuroAnim
SSequencesNetwrokNode referes BasicTypes
SSequencesNetwrokNode referes CoreUObject
SSequencesNetwrokNode referes CppTypes
SSequencesNetwrokNode referes ESeqSwtichType
SSequencesNetwrokNode referes SeqCameraMode
SSequencesNetwork referes CoreUObject
SSequencesNetwork referes SSequencesNetwrokNode
BPL_CameraUtility referes CoreUObject
BPL_CameraUtility referes CppTypes
BPL_CameraUtility referes Engine
SAiConditions referes CoreUObject
SAiConditions referes SConDitionGroupType
SUiAnimNotifyModel referes BasicTypes
SUiAnimNotifyModel referes CoreUObject
SUiAnimNotifyModel referes CppTypes
SUiAnimNotifyModel referes EPerformanceRoleState
NCS_In_Lv1 referes CoreUObject
NCS_In_Lv1 referes KuroAnim
SConditionGroup referes BasicTypes
SConditionGroup referes CoreUObject
SConditionGroup referes CppTypes
SConditionGroup referes SConDitionGroupType
SimpleHolographicComponent referes CoreUObject
SimpleHolographicComponent referes CppTypes
SimpleHolographicComponent referes EHolographicState
SimpleHolographicComponent referes Engine
SimpleHolographicComponent referes PD_HolographicEffect
SimpleHolographicComponent referes SHolographicData
SimpleHolographicComponent referes SMaterialParamCache
SMovementSetting referes CoreUObject
SMovementSetting referes CppTypes
SMovementSetting referes Engine
SMovementSetting referes SMovementRotationSetting
SHitEffect referes CoreUObject
SHitEffect referes CppTypes
SHitEffect referes EHitAnim
SHitEffect referes EVelocityCurveType
SHitEffect referes SHitWhirlpool
EffectScreenPlayData referes AkAudio
EffectScreenPlayData referes CoreUObject
EffectScreenPlayData referes CppTypes
EffectScreenPlayData referes E_SE_PlayOrder
EffectScreenPlayData referes Engine
EffectScreenPlayData referes PrefabSystem
SVisionData referes BasicTypes
SVisionData referes CoreUObject
SVisionData referes CppTypes
SVisionData referes EVisionType
SInputShow referes CoreUObject
SInputShow referes CppTypes
SInputShow referes EInputAction
SInputShow referes GameplayTags
SEntityConfig referes BasicTypes
SEntityConfig referes CoreUObject
SEntityConfig referes CppTypes
SEntityConfig referes EBossStateViewType
SEntityConfig referes ECamp
SEntityConfig referes EEntityType
SEntityConfig referes EGameplayFunctionType
SEntityConfig referes EHeadStateViewType
SEntityConfig referes SAiWeaponSocket
BPI_NpcEcological referes CoreUObject
BPI_NpcEcological referes CppTypes
SWeaponSocketItem referes BasicTypes
SWeaponSocketItem referes CoreUObject
SWeaponSocketItem referes CppTypes
SWeaponSocketItem referes GameplayTags
SGMOrderInfo referes BasicTypes
SGMOrderInfo referes CoreUObject
SGMOrderInfo referes CppTypes
SParkourPointInfo referes CoreUObject
SParkourPointInfo referes CppTypes
BP_Miaozhunxian_Bullet referes CoreUObject
BP_Miaozhunxian_Bullet referes Engine
GA_Role_LandEnd_Net referes CoreUObject
GA_Role_LandEnd_Net referes CppTypes
GA_Role_LandEnd_Net referes Engine
GA_Role_LandEnd_Net referes GA_Base
GA_Role_LandEnd_Net referes GameplayTags
SCipherGameplay referes BasicTypes
SCipherGameplay referes CoreUObject
SCipherGameplay referes CppTypes
SCipherGameplay referes ECipherGameplayType
SInteractionOption referes BasicTypes
SInteractionOption referes CoreUObject
SInteractionOption referes CppTypes
SInteractionOption referes EInteractOptionType
SInteractionOption referes EinteractionIconType
SInteractionOption referes SInteractionLimit
SInteractionOption referes SQuestRequest
GA_Tool_ScreenShot referes CoreUObject
GA_Tool_ScreenShot referes CppTypes
GA_Tool_ScreenShot referes Engine
GA_Tool_ScreenShot referes GA_Base
SInteractionConfig referes BasicTypes
SInteractionConfig referes CoreUObject
SInteractionConfig referes CppTypes
SInteractionConfig referes EInteractionType
SInteractionConfig referes EinteractionIconType
LogicDataSpeedReduce referes CoreUObject
LogicDataSpeedReduce referes CppTypes
LogicDataSpeedReduce referes LogicDataBase
NiagaraScalabilitySetting referes CoreUObject
NiagaraScalabilitySetting referes Engine
SParkourConfig referes BasicTypes
SParkourConfig referes CoreUObject
SParkourConfig referes CppTypes
SFloatCurve referes CoreUObject
SFloatCurve referes Engine
SBaseCurve referes CoreUObject
SBaseCurve referes CppTypes
SBaseCurve referes EBaseCurveType
ABPC_Seq_Body_V2 referes BasicTypes
ABPC_Seq_Body_V2 referes CoreUObject
ABPC_Seq_Body_V2 referes CppTypes
ABPC_Seq_Body_V2 referes Engine
SCamera_Setting referes CoreUObject
SCamera_Setting referes CppTypes
SCamera_Setting referes EFightCameraType
SCamera_Setting referes GameplayTags
ABP_Switch_Seq_V2 referes AnimGraphRuntime
ABP_Switch_Seq_V2 referes CoreUObject
ABP_Switch_Seq_V2 referes CppTypes
ABP_Switch_Seq_V2 referes Engine
SAiAttributeRate referes CoreUObject
SAiAttributeRate referes CppTypes
SAiAttributeRate referes EAttributeType
BP_FSM_ConditionHate referes CoreUObject
BP_FSM_ConditionHate referes CppTypes
BP_FSM_ConditionHate referes KuroUtility
SCameraModifier_Settings referes BasicTypes
SCameraModifier_Settings referes CoreUObject
SCameraModifier_Settings referes CppTypes
SCameraModifier_Settings referes SCameraModifier_Lens
SCameraModifier_Settings referes SFloatCurve
BP_VolumetricSphereLight referes CoreUObject
BP_VolumetricSphereLight referes CppTypes
BP_VolumetricSphereLight referes Engine
LogicDataBase referes CoreUObject
LogicDataBase referes EBulletLogicStage
LogicDataBase referes KuroUtility
SCameraModifier_Lens referes CoreUObject
SCameraModifier_Lens referes CppTypes
SCameraModifier referes CoreUObject
SCameraModifier referes CppTypes
SCameraModifier referes SBaseCurve
SCameraModifier referes SCameraModifier_Settings
TsAnimNotifyStateShowUiCalabash referes BasicTypes
TsAnimNotifyStateShowUiCalabash referes CoreUObject
TsAnimNotifyStateShowUiCalabash referes CppTypes
TsAnimNotifyStateShowUiCalabash referes KuroRenderingRuntimeBPPlugin
SModelConfig referes BasicTypes
SModelConfig referes CoreUObject
SModelConfig referes CppTypes
SModelConfig referes EBodyType
SQuest referes BasicTypes
SQuest referes CoreUObject
SQuest referes CppTypes
SQuest referes EQuestType
SSeqCharacterBlendGroup referes CoreUObject
SRoleQualityInfo referes BasicTypes
SRoleQualityInfo referes CoreUObject
SRoleQualityInfo referes CppTypes
KuroSceneInteraction_113 referes CoreUObject
KuroSceneInteraction_113 referes Engine
SManipulateConfig referes BasicTypes
SManipulateConfig referes CoreUObject
SManipulateConfig referes CppTypes
TsMoveBlueprintFunctionLibrary referes BasicTypes
TsMoveBlueprintFunctionLibrary referes CoreUObject
TsMoveBlueprintFunctionLibrary referes CppTypes
TsMoveBlueprintFunctionLibrary referes EClimbState
TsMoveBlueprintFunctionLibrary referes EEnterClimb
TsMoveBlueprintFunctionLibrary referes EExitClimb
TsMoveBlueprintFunctionLibrary referes EMovementDirection
TsMoveBlueprintFunctionLibrary referes Engine
TsMoveBlueprintFunctionLibrary referes SClimbInfo
TsMoveBlueprintFunctionLibrary referes SClimbState
TsMoveBlueprintFunctionLibrary referes SMovementSetting
TsMoveBlueprintFunctionLibrary referes SMovementSetting_State
GA_Mingzhongzhigui_Vision referes CoreUObject
GA_Mingzhongzhigui_Vision referes CppTypes
GA_Mingzhongzhigui_Vision referes Engine
GA_Mingzhongzhigui_Vision referes GA_Base
GA_Mingzhongzhigui_Vision referes GameplayTasks
GA_Mingzhongzhigui_Vision referes SCameraModifier_Settings
GA_Mingzhongzhigui_Vision referes TsBaseCharacter
GmDebugBlueprintFunctionLibrary referes BasicTypes
GmDebugBlueprintFunctionLibrary referes CoreUObject
GmDebugBlueprintFunctionLibrary referes CppTypes
GmDebugBlueprintFunctionLibrary referes Engine
BP_Lipsync_AL referes BasicTypes
BP_Lipsync_AL referes CoreUObject
BP_Lipsync_AL referes CppTypes
BP_Lipsync_AL referes Engine
BP_TestGameMode referes BP_MainGameInstance
BP_TestGameMode referes BasicTypes
BP_TestGameMode referes CoreUObject
BP_TestGameMode referes CppTypes
BP_TestGameMode referes Engine
BP_TestGameMode referes KuroUtility
BP_FSM_Node referes CoreUObject
BP_FSM_Node referes CppTypes
BP_FSM_Node referes KuroUtility
TsControlBlueprintFunctionLibrary referes BasicTypes
TsControlBlueprintFunctionLibrary referes CoreUObject
TsControlBlueprintFunctionLibrary referes CppTypes
TsControlBlueprintFunctionLibrary referes Engine
SceneInteractionActor referes BasicTypes
SceneInteractionActor referes CoreUObject
SceneInteractionActor referes CppTypes
SceneInteractionActor referes Engine
SceneInteractionActor referes GameplayTags
SceneInteractionActor referes KuroRenderingRuntimeBPPlugin
SceneInteractionActor referes LevelSequence
SceneInteractionActor referes TsBaseCharacter
InputBlueprintFunctionLibrary referes BasicTypes
InputBlueprintFunctionLibrary referes CoreUObject
InputBlueprintFunctionLibrary referes CppTypes
InputBlueprintFunctionLibrary referes Engine
PD_KuroProjectileAsset referes CoreUObject
PD_KuroProjectileAsset referes CppTypes
PD_KuroProjectileAsset referes Engine
PDA_TrailingConfigData referes CoreUObject
PDA_TrailingConfigData referes CppTypes
PDA_TrailingConfigData referes ETrailingAttachType
PDA_TrailingConfigData referes Engine
PDA_TrailingConfigData referes KuroCurve
BP_ScreenEffectPlayer referes CoreUObject
BP_ScreenEffectPlayer referes CppTypes
BP_ScreenEffectPlayer referes E_SE_PlayState
BP_ScreenEffectPlayer referes EffectScreenPlayData
BP_ScreenEffectPlayer referes Engine
BP_ScreenEffectPlayer referes LGUI
BP_LevelSequenceHalo referes CoreUObject
BP_LevelSequenceHalo referes CppTypes
BP_LevelSequenceHalo referes E_BillboardMode
BP_LevelSequenceHalo referes Engine
BP_LevelSequenceHalo referes KuroRenderingRuntimeBPPlugin
BP_LevelSequenceHalo referes PD_HaloPointLightConfig
BulletBlueprintFunctionLibrary referes BasicTypes
BulletBlueprintFunctionLibrary referes CoreUObject
BulletBlueprintFunctionLibrary referes CppTypes
BulletBlueprintFunctionLibrary referes Engine
BulletBlueprintFunctionLibrary referes SReBulletDataMain
BulletBlueprintFunctionLibrary referes TsBaseCharacter
TPrefab_SM_Pro_Tow_03A referes CoreUObject
TPrefab_SM_Pro_Tow_03A referes Engine
SEffectType referes CoreUObject
SEffectType referes CppTypes
SEffectType referes EAttributeEffectType
SDamageData referes CoreUObject
SDamageData referes CppTypes
PDA_WuYinQuBattleFightingData referes CoreUObject
PDA_WuYinQuBattleFightingData referes Engine
PDA_WuYinQuBattleFightingData referes KuroRenderingRuntimeBPPlugin
TsServiceAnimalPerception referes AIModule
TsServiceAnimalPerception referes CoreUObject
TsServiceAnimalPerception referes CppTypes
TsServiceAnimalPerception referes Engine
ABP_Common_NPC_Seq referes AnimGraphRuntime
ABP_Common_NPC_Seq referes CoreUObject
ABP_Common_NPC_Seq referes CppTypes
ABP_Common_NPC_Seq referes Engine
ABP_Common_NPC_Seq referes KuroAnim
PD_HaloPointLightConfig referes CoreUObject
PD_HaloPointLightConfig referes CppTypes
PD_HaloPointLightConfig referes Engine
PDA_ThunderConfigMap referes CoreUObject
PDA_ThunderConfigMap referes Engine
BP_ControlTodTime referes CoreUObject
BP_ControlTodTime referes CppTypes
BP_ControlTodTime referes Engine
BP_ControlTodTime referes KuroRenderingRuntimeBPPlugin
TsHideActorBlueprintFunctionLibrary referes CoreUObject
TsHideActorBlueprintFunctionLibrary referes CppTypes
TsHideActorBlueprintFunctionLibrary referes Engine
TsBpFxEffect referes BasicTypes
TsBpFxEffect referes CoreUObject
TsBpFxEffect referes CppTypes
TsBpFxEffect referes Engine
SFloatPayload referes CoreUObject
ConditionBulletSceneInteraction referes CoreUObject
ConditionBulletSceneInteraction referes CppTypes
EffectModelBillboard referes CoreUObject
EffectModelBillboard referes CppTypes
EffectModelBillboard referes KuroGameplay
EffectModelBillboard referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyBonesShowControl referes BasicTypes
TsAnimNotifyBonesShowControl referes CoreUObject
TsAnimNotifyBonesShowControl referes CppTypes
TsAnimNotifyBonesShowControl referes KuroRenderingRuntimeBPPlugin
BP_KuroISMGroup referes CoreUObject
BP_KuroISMGroup referes CppTypes
BP_KuroISMGroup referes Engine
PDA_WuYinQuBattleIdleData referes CoreUObject
PDA_WuYinQuBattleIdleData referes Engine
PDA_WuYinQuBattleIdleData referes KuroRenderingRuntimeBPPlugin
PD_SE_ControllerCommonData referes CoreUObject
PD_SE_ControllerCommonData referes Engine
PD_SE_ControllerCommonData referes S_SE_ControllerCommon
SCharacterSlotSpecifiedStruct referes CoreUObject
SCharacterSlotSpecifiedStruct referes CppTypes
SCharacterSlotSpecifiedStruct referes ECharacterSlotSpecifiedType
SCharacterBodySpecifiedStruct referes CoreUObject
SCharacterBodySpecifiedStruct referes CppTypes
SCharacterBodySpecifiedStruct referes ECharacterBodySpecifiedType
PDA_DecalShadowConfig referes CoreUObject
PDA_DecalShadowConfig referes CppTypes
PDA_DecalShadowConfig referes Engine
SPartHitEffect referes BasicTypes
SPartHitEffect referes CoreUObject
SPartHitEffect referes CppTypes
SPerformanceRoleInfo referes CoreUObject
SPerformanceRoleInfo referes CppTypes
SAimPart referes BasicTypes
SAimPart referes CoreUObject
SAimPart referes CppTypes
SGlobalRtpcEntry referes AkAudio
SGlobalRtpcEntry referes BasicTypes
SGlobalRtpcEntry referes CoreUObject
SGlobalRtpcEntry referes CppTypes
BP_QTE_Camera referes BasicTypes
BP_QTE_Camera referes CoreUObject
BP_QTE_Camera referes CppTypes
BP_QTE_Camera referes ECameraAnsEffectiveClientType
BP_QTE_Camera referes Engine
BP_QTE_Camera referes GameplayTags
BP_QTE_Camera referes SBaseCurve
BP_QTE_Camera referes SCameraModifier_Settings
SFoliageClusteredEffectEntry referes CoreUObject
SFoliageClusteredEffectEntry referes CppTypes
SFoliageClusteredEffectEntry referes EffectClusteredStuffSettings
SFoliageClusteredEffectEntry referes Foliage
ItemMaterialControllerGlobalData referes CoreUObject
ItemMaterialControllerGlobalData referes CppTypes
ItemMaterialControllerGlobalData referes Engine
ItemMaterialControllerGlobalData referes KuroCurve
TsTaskAbortImmediatelyBase referes AIModule
TsTaskAbortImmediatelyBase referes CoreUObject
TsTaskAbortImmediatelyBase referes CppTypes
TsTaskAbortImmediatelyBase referes Engine
EffectClusteredStuffSettings referes CoreUObject
EffectClusteredStuffSettings referes CppTypes
EffectClusteredStuffSettings referes Engine
TsAnimNotifyChangeSkillPriority referes BasicTypes
TsAnimNotifyChangeSkillPriority referes CoreUObject
TsAnimNotifyChangeSkillPriority referes CppTypes
TsAnimNotifyChangeSkillPriority referes KuroRenderingRuntimeBPPlugin
AudioVisualizationInstanceBase referes AkAudio
AudioVisualizationInstanceBase referes BasicTypes
AudioVisualizationInstanceBase referes CoreUObject
AudioVisualizationInstanceBase referes CppTypes
AudioVisualizationInstanceBase referes Engine
SE_ControllerInterface referes CoreUObject
SE_ControllerInterface referes CppTypes
SE_UISpriteController referes CoreUObject
SE_UISpriteController referes CppTypes
SE_UISpriteController referes E_SE_PlayState
SE_UISpriteController referes Engine
SE_UISpriteController referes PD_SE_ControllerCommonData
SE_UISpriteController referes SE_ControllerBase
OnlyData referes BasicTypes
OnlyData referes CoreUObject
OnlyData referes CppTypes
OnlyData referes Engine
OnlyData referes SBulletDataMain
OnlyData referes SHitEffect
OnlyData referes SReBulletDataMain
S_SE_ControllerCommon referes CoreUObject
S_SE_ControllerCommon referes CppTypes
TsAxisHandle referes BasicTypes
TsAxisHandle referes CoreUObject
TsAxisHandle referes CppTypes
TsAxisHandle referes TsBasePlayerController
TsActionHandle referes BasicTypes
TsActionHandle referes CoreUObject
TsActionHandle referes CppTypes
TsActionHandle referes InputCore
TsActionHandle referes TsBasePlayerController
KuroSceneInteraction_33 referes CoreUObject
KuroSceneInteraction_33 referes Engine
TsBasePlayerController referes BasicTypes
TsBasePlayerController referes CoreUObject
TsBasePlayerController referes CppTypes
TsBasePlayerController referes Engine
TsBasePlayerController referes InputCore
TsBasePlayerController referes KuroInput
TsBasePlayerController referes TsActionHandle
TsBasePlayerController referes TsAxisHandle
BP_SM_TaskRandomMontage referes CoreUObject
BP_SM_TaskRandomMontage referes CppTypes
BP_SM_TaskRandomMontage referes SMSystem
TsCharacterController referes CoreUObject
TsCharacterController referes CppTypes
TsCharacterController referes Engine
TsCharacterController referes TsBasePlayerController
PlotBlueprintFunctionLibrary referes BasicTypes
PlotBlueprintFunctionLibrary referes CoreUObject
PlotBlueprintFunctionLibrary referes CppTypes
PlotBlueprintFunctionLibrary referes Engine
BP_Fx_Control_Obj referes CoreUObject
BP_Fx_Control_Obj referes CppTypes
BP_Fx_Control_Obj referes Engine
BP_Fx_Control_Obj referes Niagara
SMaterialParamCache referes CoreUObject
SMaterialParamCache referes CppTypes
SMaterialParamCache referes Engine
SHolographicMaterialsCache referes CoreUObject
PD_HolographicEffect referes CoreUObject
PD_HolographicEffect referes CppTypes
PD_HolographicEffect referes Engine
PD_HolographicEffect referes SHolographicData
CounterAttackEffectData referes CoreUObject
CounterAttackEffectData referes CppTypes
CounterAttackEffectData referes KuroUtility
CounterAttackCameraData referes CoreUObject
CounterAttackCameraData referes KuroUtility
CounterAttackCameraData referes SCounterAttackCamera
CounterAttackCameraData referes STimeScale
SNavigationDynamicListenerConfig referes CoreUObject
SNavigationDynamicListenerConfig referes CppTypes
SNavigationDynamicListenerConfig referes Engine
SWeaponLevelMaterialData referes CoreUObject
KFC_AICommon referes BasicTypes
KFC_AICommon referes CoreUObject
KFC_AICommon referes CppTypes
KFC_AICommon referes ECamp
KFC_AICommon referes ERelation
KFC_AICommon referes Engine
KFC_AICommon referes KuroUtility
KuroSceneInteraction_54 referes CoreUObject
KuroSceneInteraction_54 referes Engine
BP_ActorBulletPreview referes CoreUObject
BP_ActorBulletPreview referes CppTypes
BP_ActorBulletPreview referes EBulletShape
BP_ActorBulletPreview referes Engine
BP_ActorBulletPreview referes SReBulletDataMain
GA_Qunnie_Role referes BP_BaseVision
GA_Qunnie_Role referes CoreUObject
GA_Qunnie_Role referes CppTypes
GA_Qunnie_Role referes Engine
GA_Qunnie_Role referes GA_Base
GA_Qunnie_Role referes TsBaseCharacter
ICM_AutomaticFlight_DataBase referes CoreUObject
ICM_AutomaticFlight_DataBase referes CppTypes
ICM_AutomaticFlight_DataBase referes Engine
ICM_AutomaticFlight_DataBase referes KuroUtility
LogicDataSplineMovement referes CoreUObject
LogicDataSplineMovement referes CppTypes
LogicDataSplineMovement referes LogicDataBase
TsGameplayBlueprintFunctionLibrary referes BasicTypes
TsGameplayBlueprintFunctionLibrary referes CoreUObject
TsGameplayBlueprintFunctionLibrary referes CppTypes
TsGameplayBlueprintFunctionLibrary referes EAimViewState
TsGameplayBlueprintFunctionLibrary referes ECharParentMoveState
TsGameplayBlueprintFunctionLibrary referes ECharState
TsGameplayBlueprintFunctionLibrary referes ECharViewDirectionState
TsGameplayBlueprintFunctionLibrary referes EHitAnim
TsGameplayBlueprintFunctionLibrary referes EVisionType
TsGameplayBlueprintFunctionLibrary referes Engine
TsGameplayBlueprintFunctionLibrary referes GameplayAbilities
TsGameplayBlueprintFunctionLibrary referes GameplayTags
TsGameplayBlueprintFunctionLibrary referes SCounterAttack
TsGameplayBlueprintFunctionLibrary referes SCounterAttackBuff
TsGameplayBlueprintFunctionLibrary referes SHitInformation
TsGameplayBlueprintFunctionLibrary referes SSkillInfo
TsGameplayBlueprintFunctionLibrary referes SVisionCounterAttack
TsGameplayBlueprintFunctionLibrary referes TsBaseCharacter
SDynamicMontageParams referes CoreUObject
SDynamicMontageParams referes CppTypes
SDynamicMontageParams referes Engine
Audio_Multi_Base referes AkAudio
Audio_Multi_Base referes CoreUObject
Audio_Multi_Base referes CppTypes
Audio_Multi_Base referes Engine
LevelGamePlayBlueprintFunctionLibrary referes BasicTypes
LevelGamePlayBlueprintFunctionLibrary referes CoreUObject
LevelGamePlayBlueprintFunctionLibrary referes CppTypes
LevelGamePlayBlueprintFunctionLibrary referes Engine
ABP_ParaglidingBase referes AnimGraphRuntime
ABP_ParaglidingBase referes CoreUObject
ABP_ParaglidingBase referes CppTypes
ABP_ParaglidingBase referes EffectModelGroup
ABP_ParaglidingBase referes Engine
ABP_ParaglidingBase referes TsBaseCharacter
BP_Fx_Scanning referes CoreUObject
BP_Fx_Scanning referes CppTypes
BP_Fx_Scanning referes Engine
BP_Fx_Scanning referes TsBpFxEffect
ABPI_Seq_LevelB referes CoreUObject
ABPI_Seq_LevelB referes CppTypes
TPrefab_SM_Gat_14A referes CoreUObject
TPrefab_SM_Gat_14A referes Engine
ABP_BaseRole_Seq_V2 referes AnimGraphRuntime
ABP_BaseRole_Seq_V2 referes CoreUObject
ABP_BaseRole_Seq_V2 referes CppTypes
ABP_BaseRole_Seq_V2 referes Engine
ABP_BaseRole_Seq_V2 referes KuroAnim
BPI_NPC referes BasicTypes
BPI_NPC referes CoreUObject
BPI_NPC referes CppTypes
BPI_NPC referes SEntityConfig
BPI_NPC referes SInteractionConfig
ABP_BaseRole referes AnimGraphRuntime
ABP_BaseRole referes CoreUObject
ABP_BaseRole referes CppTypes
ABP_BaseRole referes Engine
ABP_BaseRole referes KuroAnim
ABP_BaseRole referes SDynamicMontageParams
ABP_BaseRole referes TsBaseCharacter
SKposeEffect referes BasicTypes
SKposeEffect referes CoreUObject
SKposeEffect referes CppTypes
LogicDataDestroyOtherBullet referes BasicTypes
LogicDataDestroyOtherBullet referes CoreUObject
LogicDataDestroyOtherBullet referes CppTypes
LogicDataDestroyOtherBullet referes ECamp
LogicDataDestroyOtherBullet referes LogicDataBase
LogicDataShowMesh referes CoreUObject
LogicDataShowMesh referes CppTypes
LogicDataShowMesh referes LogicDataBase
LogicDataSupport referes CoreUObject
LogicDataSupport referes CppTypes
LogicDataSupport referes ECamp
LogicDataSupport referes GameplayTags
LogicDataSupport referes LogicDataBase
LogicDataRebound referes CoreUObject
LogicDataRebound referes CppTypes
LogicDataRebound referes LogicDataBase
LogicDataRebound referes SCounterAttackCamera
LogicDataFreeze referes CoreUObject
LogicDataFreeze referes CppTypes
LogicDataFreeze referes EBulletObject
LogicDataFreeze referes GameplayTags
LogicDataFreeze referes LogicDataBase
LogicDataAdditiveAccelerate referes CoreUObject
LogicDataAdditiveAccelerate referes CppTypes
LogicDataAdditiveAccelerate referes Engine
LogicDataAdditiveAccelerate referes LogicDataBase
BP_GamePlayOre referes BP_BaseItem
BP_GamePlayOre referes CoreUObject
LogicDataForce referes CoreUObject
LogicDataForce referes CppTypes
LogicDataForce referes Engine
LogicDataForce referes GameplayTags
LogicDataForce referes LogicDataBase
LogicDataDestroyBullet referes BasicTypes
LogicDataDestroyBullet referes CoreUObject
LogicDataDestroyBullet referes CppTypes
LogicDataDestroyBullet referes EBulletObject
LogicDataDestroyBullet referes LogicDataBase
LogicDataCreateBullet referes BasicTypes
LogicDataCreateBullet referes CoreUObject
LogicDataCreateBullet referes CppTypes
LogicDataCreateBullet referes EBulletObject
LogicDataCreateBullet referes LogicDataBase
BP_KposeBase referes BP_Enum_PlatformSize
BP_KposeBase referes BasicTypes
BP_KposeBase referes CoreUObject
BP_KposeBase referes CppTypes
BP_KposeBase referes Engine
BP_KposeBase referes KuroRenderingRuntimeBPPlugin
PDA_InteractionGlobalConfigParameters referes CoreUObject
PDA_InteractionGlobalConfigParameters referes CppTypes
PDA_InteractionGlobalConfigParameters referes Engine
PDA_InteractionActorConfig referes CoreUObject
PDA_InteractionActorConfig referes CppTypes
PDA_InteractionActorConfig referes Engine
PDA_InteractionActorConfig referes KuroCurve
CommonEffectMoveSpline2 referes CoreUObject
CommonEffectMoveSpline2 referes Engine
CommonEffectMoveSpline2 referes KuroSplines
BP_KuroDestructibleActor referes ApexDestruction
BP_KuroDestructibleActor referes CharRenderingComponent
BP_KuroDestructibleActor referes CoreUObject
BP_KuroDestructibleActor referes CppTypes
BP_KuroDestructibleActor referes Engine
BP_KuroDestructibleActor referes PD_CharacterControllerData
BP_SM_ConditionCheckState referes BasicTypes
BP_SM_ConditionCheckState referes CoreUObject
BP_SM_ConditionCheckState referes SMSystem
BP_LightsGroup referes BasicTypes
BP_LightsGroup referes CoreUObject
BP_LightsGroup referes CppTypes
BP_LightsGroup referes Engine
BPL_BulletPreview referes BasicTypes
BPL_BulletPreview referes CoreUObject
BPL_BulletPreview referes CppTypes
BPL_BulletPreview referes Engine
KuroSceneInteraction_121 referes CoreUObject
KuroSceneInteraction_121 referes Engine
TsAnimNotifyAddBuff referes BasicTypes
TsAnimNotifyAddBuff referes CoreUObject
TsAnimNotifyAddBuff referes CppTypes
TsAnimNotifyAddBuff referes KuroRenderingRuntimeBPPlugin
GA_Role_ManipulateThrow referes CoreUObject
GA_Role_ManipulateThrow referes CppTypes
GA_Role_ManipulateThrow referes Engine
GA_Role_ManipulateThrow referes GA_Base
BP_Miaozhunxian referes CoreUObject
BP_Miaozhunxian referes CppTypes
BP_Miaozhunxian referes Engine
BP_TeleControlConfig referes BasicTypes
BP_TeleControlConfig referes CoreUObject
BP_TeleControlConfig referes CppTypes
BP_TeleControlConfig referes Engine
BP_TeleControlConfig referes GameplayTags
BP_CharacterRenderingFunctionLibrary referes CoreUObject
BP_CharacterRenderingFunctionLibrary referes CppTypes
BP_CharacterRenderingFunctionLibrary referes Engine
BP_CharacterRenderingFunctionLibrary referes SWeaponLevelMaterialData
BP_CharacterRenderingFunctionLibrary referes SWeaponMaterialParams
BP_CharacterController referes BP_KuroCheatManager
BP_CharacterController referes CoreUObject
BP_CharacterController referes CppTypes
BP_CharacterController referes Engine
BP_CharacterController referes InputCore
BP_CharacterController referes TsBaseCharacter
BP_CharacterController referes TsCharacterController
TsAnimNotifyAudioEvent referes BasicTypes
TsAnimNotifyAudioEvent referes CoreUObject
TsAnimNotifyAudioEvent referes CppTypes
TsAnimNotifyAudioEvent referes KuroRenderingRuntimeBPPlugin
PDA_EffectPaths referes CoreUObject
PDA_EffectPaths referes Engine
BP_Wwise_AudioSpectrum referes AkAudio
BP_Wwise_AudioSpectrum referes AudioSynesthesia
BP_Wwise_AudioSpectrum referes CoreUObject
BP_Wwise_AudioSpectrum referes CppTypes
BP_Wwise_AudioSpectrum referes Engine
TsUiNavigationPlatformChangeListener referes CoreUObject
TsUiNavigationPlatformChangeListener referes CppTypes
TsUiNavigationPlatformChangeListener referes Engine
TsUiNavigationPlatformChangeListener referes LGUI
BP_Nvzhu referes CoreUObject
BP_Nvzhu referes CppTypes
BP_Nvzhu referes Engine
BP_Nvzhu referes TsBaseCharacter
TsUiNavigationPanelConfig referes BasicTypes
TsUiNavigationPanelConfig referes CoreUObject
TsUiNavigationPanelConfig referes CppTypes
TsUiNavigationPanelConfig referes Engine
TsUiNavigationPanelConfig referes LGUI
TsUiNavigationPanelConfig referes SNavigationGroup
EffectModelGhost referes CoreUObject
EffectModelGhost referes Engine
EffectModelGhost referes KuroCurve
EffectModelGhost referes KuroGameplay
BP_SM_BindStatePalsy referes CoreUObject
BP_SM_BindStatePalsy referes SMSystem
BP_SM_ConditionListenBeHit referes CoreUObject
BP_SM_ConditionListenBeHit referes CppTypes
BP_SM_ConditionListenBeHit referes SMSystem
KuroSceneInteraction_16 referes CoreUObject
KuroSceneInteraction_16 referes Engine
BP_SM_ConditionListenEvent referes BasicTypes
BP_SM_ConditionListenEvent referes CoreUObject
BP_SM_ConditionListenEvent referes SMSystem
BP_SM_ConditionCheckPartActivated referes BasicTypes
BP_SM_ConditionCheckPartActivated referes CoreUObject
BP_SM_ConditionCheckPartActivated referes SMSystem
BP_SM_ConditionTaskFinish referes CoreUObject
BP_SM_ConditionTaskFinish referes SMSystem
BP_RainComponent_CommonReverse referes CoreUObject
BP_RainComponent_CommonReverse referes CppTypes
BP_RainComponent_CommonReverse referes Engine
BP_RainComponent_CommonReverse referes KuroRenderingRuntimeBPPlugin
BP_RainComponent_CommonReverse referes Niagara
BP_RainComponent_CommonReverse referes PDA_RainConfig_CommonReverse
PDA_GlobalRenderDataReference referes CoreUObject
PDA_GlobalRenderDataReference referes Engine
PDA_GlobalRenderDataReference referes PDA_DecalShadowConfig
PDA_GlobalRenderDataReference referes PDA_ModelLensFlareConfig
BP_SM_ConditionCheckInstState referes CoreUObject
BP_SM_ConditionCheckInstState referes GameplayTags
BP_SM_ConditionCheckInstState referes SMSystem
BP_SM_ConditionTag referes CoreUObject
BP_SM_ConditionTag referes CppTypes
BP_SM_ConditionTag referes GameplayTags
BP_SM_ConditionTag referes SMSystem
BP_SM_ConditionHate referes CoreUObject
BP_SM_ConditionHate referes SMSystem
KuroSceneInteraction_49 referes CoreUObject
KuroSceneInteraction_49 referes Engine
BP_SM_ConditionAttributeRate referes CoreUObject
BP_SM_ConditionAttributeRate referes CppTypes
BP_SM_ConditionAttributeRate referes EAttributeType
BP_SM_ConditionAttributeRate referes SMSystem
BP_SM_ConditionAttribute referes CoreUObject
BP_SM_ConditionAttribute referes CppTypes
BP_SM_ConditionAttribute referes EAttributeType
BP_SM_ConditionAttribute referes SMSystem
Ani_NewLevelSequence_Up referes CoreUObject
Ani_NewLevelSequence_Up referes CppTypes
Ani_NewLevelSequence_Up referes Engine
Ani_NewLevelSequence_Up referes LevelSequence
BP_SM_ConditionTrue referes CoreUObject
BP_SM_ConditionTrue referes SMSystem
BP_SM_BindStateSkillCounter referes BasicTypes
BP_SM_BindStateSkillCounter referes CoreUObject
BP_SM_BindStateSkillCounter referes CppTypes
BP_SM_BindStateSkillCounter referes SMSystem
BP_NpcCombinedMesh referes BasicTypes
BP_NpcCombinedMesh referes CoreUObject
BP_NpcCombinedMesh referes CppTypes
BP_NpcCombinedMesh referes EBodyPartName
BP_NpcCombinedMesh referes Engine
BP_NpcCombinedMesh referes PD_NpcSetupData
BP_SM_BindStateDisableActor referes CoreUObject
BP_SM_BindStateDisableActor referes SMSystem
BP_SM_BindStateDeathMontage referes BasicTypes
BP_SM_BindStateDeathMontage referes CoreUObject
BP_SM_BindStateDeathMontage referes CppTypes
BP_SM_BindStateDeathMontage referes EMonsterDeathType
BP_SM_BindStateDeathMontage referes SMSystem
BP_SM_BindStateAiSenseEnable referes CoreUObject
BP_SM_BindStateAiSenseEnable referes CppTypes
BP_SM_BindStateAiSenseEnable referes SMSystem
BP_SM_BindStateAiHateConfig referes CoreUObject
BP_SM_BindStateAiHateConfig referes CppTypes
BP_SM_BindStateAiHateConfig referes SMSystem
BP_SM_BindStateTag referes CoreUObject
BP_SM_BindStateTag referes GameplayTags
BP_SM_BindStateTag referes SMSystem
BP_SM_BindStateBuff referes CoreUObject
BP_SM_BindStateBuff referes CppTypes
BP_SM_BindStateBuff referes SMSystem
NCS_Left_Lv3 referes CoreUObject
NCS_Left_Lv3 referes KuroAnim
BP_SM_TaskMoveToTarget referes CoreUObject
BP_SM_TaskMoveToTarget referes CppTypes
BP_SM_TaskMoveToTarget referes SMSystem
BP_SM_TaskMontage referes BasicTypes
BP_SM_TaskMontage referes CoreUObject
BP_SM_TaskMontage referes CppTypes
BP_SM_TaskMontage referes SMSystem
BP_SM_TaskSkill referes CoreUObject
BP_SM_TaskSkill referes CppTypes
BP_SM_TaskSkill referes SMSystem
BP_SM_ActionStopMontage referes CoreUObject
BP_SM_ActionStopMontage referes SMSystem
BP_SM_ActionActivateSkillGroup referes CoreUObject
BP_SM_ActionActivateSkillGroup referes CppTypes
BP_SM_ActionActivateSkillGroup referes SMSystem
BP_SM_ActionActivatePart referes BasicTypes
BP_SM_ActionActivatePart referes CoreUObject
BP_SM_ActionActivatePart referes CppTypes
BP_SM_ActionActivatePart referes SMSystem
BP_SM_ActionChangeInstState referes CoreUObject
BP_SM_ActionChangeInstState referes GameplayTags
BP_SM_ActionChangeInstState referes SMSystem
BP_SM_ActionAddBuff referes CoreUObject
BP_SM_ActionAddBuff referes CppTypes
BP_SM_ActionAddBuff referes SMSystem
TsEffectActor referes BasicTypes
TsEffectActor referes CoreUObject
TsEffectActor referes CppTypes
TsEffectActor referes Engine
TsTaskBlackBoardSetValues referes CoreUObject
TsTaskBlackBoardSetValues referes CppTypes
TsTaskBlackBoardSetValues referes Engine
TsTaskBlackBoardSetValues referes TsTaskAbortImmediatelyBase
DefaultBulletSceneInteraction referes CoreUObject
DefaultBulletSceneInteraction referes Engine
BP_SM_ConditionTimer referes CoreUObject
BP_SM_ConditionTimer referes CppTypes
BP_SM_ConditionTimer referes SMSystem
BP_TrailGrassSensorComponent referes CoreUObject
BP_TrailGrassSensorComponent referes CppTypes
BP_TrailGrassSensorComponent referes Engine
BP_TrailGrassSensorComponent referes KuroRenderingRuntimeBPPlugin
BP_TrailGrassSensorComponent referes STrailGrassDrawInfo
BP_SM_ConditionLeaveFight referes CoreUObject
BP_SM_ConditionLeaveFight referes SMSystem
BP_FSM_ConditionTag referes CoreUObject
BP_FSM_ConditionTag referes CppTypes
BP_FSM_ConditionTag referes GameplayTags
BP_FSM_ConditionTag referes KuroUtility
TsAnimNotifyClearCharInput referes BasicTypes
TsAnimNotifyClearCharInput referes CoreUObject
TsAnimNotifyClearCharInput referes CppTypes
TsAnimNotifyClearCharInput referes KuroRenderingRuntimeBPPlugin
BP_FSM_ConditionCheckState referes CoreUObject
BP_FSM_ConditionCheckState referes CppTypes
BP_FSM_ConditionCheckState referes KuroUtility
GA_WuYinQu_HuangShiGaoDi2_Attack referes BasicTypes
GA_WuYinQu_HuangShiGaoDi2_Attack referes CoreUObject
GA_WuYinQu_HuangShiGaoDi2_Attack referes CppTypes
GA_WuYinQu_HuangShiGaoDi2_Attack referes Engine
GA_WuYinQu_HuangShiGaoDi2_Attack referes GA_Base
GA_WuYinQu_HuangShiGaoDi2_Attack referes GameplayAbilities
GA_WuYinQu_HuangShiGaoDi2_Attack referes GameplayTags
BP_FSM_ConditionSkillEnd referes CoreUObject
BP_FSM_ConditionSkillEnd referes KuroUtility
BP_FSM_ConditionAttributeRate referes CoreUObject
BP_FSM_ConditionAttributeRate referes KuroUtility
BP_FSM_ConditionAttribute referes CoreUObject
BP_FSM_ConditionAttribute referes KuroUtility
KuroSceneInteraction_46 referes CoreUObject
KuroSceneInteraction_46 referes Engine
BP_StartupPlayerController referes CoreUObject
BP_StartupPlayerController referes TsStartupPlayerController
BPI_AnimalEcological referes CoreUObject
BPI_AnimalEcological referes CppTypes
BPI_AnimalEcological referes GameplayTags
TsPhotographerSource referes CoreUObject
TsPhotographerSource referes Engine
TsPhotographer referes CoreUObject
TsPhotographer referes CppTypes
TsPhotographer referes Engine
BP_GlobalGameplayPostProcess referes CoreUObject
BP_GlobalGameplayPostProcess referes CppTypes
BP_GlobalGameplayPostProcess referes Engine
BP_GlobalGameplayPostProcess referes KuroRenderingRuntimeBPPlugin
LGUIEventSystemActor referes CoreUObject
LGUIEventSystemActor referes CppTypes
LGUIEventSystemActor referes Engine
LGUIEventSystemActor referes InputCore
LGUIEventSystemActor referes LGUI
ItemMaterialDataMap referes CoreUObject
ItemMaterialDataMap referes Engine
BP_PartHitEffect referes CoreUObject
BP_PartHitEffect referes CppTypes
BP_PartHitEffect referes Engine
TsSceneDecorativeUiActor referes CoreUObject
TsSceneDecorativeUiActor referes CppTypes
TsSceneDecorativeUiActor referes TsSceneUiTag
TsTaskSetTag referes BasicTypes
TsTaskSetTag referes CoreUObject
TsTaskSetTag referes CppTypes
TsTaskSetTag referes Engine
TsTaskSetTag referes GameplayTags
TsTaskSetTag referes TsTaskAbortImmediatelyBase
EffectClusteredStuffDefaultSettings referes CoreUObject
EffectClusteredStuffDefaultSettings referes Engine
BP_Weather referes CoreUObject
BP_Weather referes Engine
BP_Weather referes KuroRenderingRuntimeBPPlugin
BP_MovePathLine referes CoreUObject
BP_MovePathLine referes CppTypes
BP_MovePathLine referes Engine
BP_MovePathLine referes KuroSplines
TsAnimNotifyStateAddCharRendering referes CoreUObject
TsAnimNotifyStateAddCharRendering referes CppTypes
TsAnimNotifyStateAddCharRendering referes ECharacterRenderingType
TsAnimNotifyStateAddCharRendering referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyAddCharRendering referes CoreUObject
TsAnimNotifyAddCharRendering referes CppTypes
TsAnimNotifyAddCharRendering referes ECharacterRenderingType
TsAnimNotifyAddCharRendering referes KuroRenderingRuntimeBPPlugin
TsRecordGameplayCue referes CoreUObject
TsRecordGameplayCue referes CppTypes
TsRecordGameplayCue referes Engine
TsRecordGameplayCue referes KuroAnim
TsRecordEffect referes BasicTypes
TsRecordEffect referes CoreUObject
TsRecordEffect referes CppTypes
TsRecordEffect referes Engine
TsRecordEffect referes KuroAnim
TsRecordEffect referes KuroGameplay
UEffectStatisticsEntryData referes BasicTypes
UEffectStatisticsEntryData referes CoreUObject
UEffectStatisticsEntryData referes CppTypes
KuroSceneInteraction_22 referes CoreUObject
KuroSceneInteraction_22 referes Engine
EffectModelPostProcess referes CoreUObject
EffectModelPostProcess referes KuroGameplay
EffectModelSkeletalMesh referes CoreUObject
EffectModelSkeletalMesh referes CppTypes
EffectModelSkeletalMesh referes Engine
EffectModelSkeletalMesh referes KuroCurve
EffectModelSkeletalMesh referes KuroGameplay
AnimNotifyStateAddMaterialControllerDataGroup referes BasicTypes
AnimNotifyStateAddMaterialControllerDataGroup referes CoreUObject
AnimNotifyStateAddMaterialControllerDataGroup referes CppTypes
AnimNotifyStateAddMaterialControllerDataGroup referes KuroRenderingRuntimeBPPlugin
AnimNotifyStateAddMaterialControllerDataGroup referes PD_CharacterControllerDataGroup
GA_Common_ManipulateSwitchMode referes CoreUObject
GA_Common_ManipulateSwitchMode referes CppTypes
GA_Common_ManipulateSwitchMode referes Engine
GA_Common_ManipulateSwitchMode referes GA_Base
KuroSceneInteraction_83 referes CoreUObject
KuroSceneInteraction_83 referes Engine
AnimNotifyStateAddMaterialControllerData referes BasicTypes
AnimNotifyStateAddMaterialControllerData referes CoreUObject
AnimNotifyStateAddMaterialControllerData referes CppTypes
AnimNotifyStateAddMaterialControllerData referes KuroRenderingRuntimeBPPlugin
AnimNotifyStateAddMaterialControllerData referes PD_CharacterControllerData
AnimNotifyAddMeshMaterialControllerDataGroup referes BP_MaterialControllerRenderActor
AnimNotifyAddMeshMaterialControllerDataGroup referes BasicTypes
AnimNotifyAddMeshMaterialControllerDataGroup referes CoreUObject
AnimNotifyAddMeshMaterialControllerDataGroup referes CppTypes
AnimNotifyAddMeshMaterialControllerDataGroup referes KuroRenderingRuntimeBPPlugin
AnimNotifyAddMeshMaterialControllerDataGroup referes PD_CharacterControllerDataGroup
AnimNotifyAddMeshMaterialControllerData referes BP_MaterialControllerRenderActor
AnimNotifyAddMeshMaterialControllerData referes BasicTypes
AnimNotifyAddMeshMaterialControllerData referes CoreUObject
AnimNotifyAddMeshMaterialControllerData referes CppTypes
AnimNotifyAddMeshMaterialControllerData referes KuroRenderingRuntimeBPPlugin
AnimNotifyAddMeshMaterialControllerData referes PD_CharacterControllerData
KuroSceneInteraction_30 referes CoreUObject
KuroSceneInteraction_30 referes Engine
AnimNotifyAddMaterialControllerDataGroup referes BasicTypes
AnimNotifyAddMaterialControllerDataGroup referes CoreUObject
AnimNotifyAddMaterialControllerDataGroup referes CppTypes
AnimNotifyAddMaterialControllerDataGroup referes KuroRenderingRuntimeBPPlugin
AnimNotifyAddMaterialControllerDataGroup referes PD_CharacterControllerDataGroup
AnimNotifyAddMaterialControllerData referes BasicTypes
AnimNotifyAddMaterialControllerData referes CoreUObject
AnimNotifyAddMaterialControllerData referes CppTypes
AnimNotifyAddMaterialControllerData referes KuroRenderingRuntimeBPPlugin
AnimNotifyAddMaterialControllerData referes PD_CharacterControllerData
AnimNotifyAddTransferEffect referes AnimNotifyAddMaterialControllerData
AnimNotifyAddTransferEffect referes BasicTypes
AnimNotifyAddTransferEffect referes CoreUObject
BP_Item referes CoreUObject
BP_Item referes CppTypes
BP_Item referes EEntityType
BP_Item referes Engine
BP_EffectPreview referes CoreUObject
BP_EffectPreview referes CppTypes
BP_EffectPreview referes Engine
BP_EffectPreview referes KuroRenderingRuntimeBPPlugin
BPF_ActorComponentHelper referes CoreUObject
BPF_ActorComponentHelper referes CppTypes
BPF_ActorComponentHelper referes Engine
PD_CharacterMaterialContainerData referes CoreUObject
PD_CharacterMaterialContainerData referes Engine
PD_CurveLinearColorData referes CoreUObject
PD_CurveLinearColorData referes CppTypes
PD_CurveLinearColorData referes Engine
PD_CurveLinearColorData referes KuroCurve
PDA_ComplexBrokenData referes CoreUObject
PDA_ComplexBrokenData referes Engine
PDA_ComplexBrokenData referes SMaterialControllerFloatGroup
BP_MaterialControllerRenderActor referes CharRenderingComponent
BP_MaterialControllerRenderActor referes CoreUObject
BP_MaterialControllerRenderActor referes Engine
TsSimpleNpc referes BasicTypes
TsSimpleNpc referes CharRenderingComponent
TsSimpleNpc referes CoreUObject
TsSimpleNpc referes CppTypes
TsSimpleNpc referes Engine
TsSimpleNpc referes KuroRenderingRuntimeBPPlugin
NCS_Out_Lv7 referes BP_CameraShakeAndForceFeedback
NCS_Out_Lv7 referes CoreUObject
TPrefab_SM_Pro_Box_03_CBT3 referes CoreUObject
TPrefab_SM_Pro_Box_03_CBT3 referes Engine
BPI_Animation referes CoreUObject
BPI_Animation referes CppTypes
AIC_AICommon referes BasicTypes
AIC_AICommon referes CoreUObject
AIC_AICommon referes CppTypes
AIC_AICommon referes ECharacterState
AIC_AICommon referes Engine
AIC_AICommon referes KuroComponent
AIC_AICommon referes SAiConditions
AIC_AICommon referes TsAiController
AIC_AICommon referes TsBaseCharacter
GA_HuanXiangShouFu referes CoreUObject
GA_HuanXiangShouFu referes CppTypes
GA_HuanXiangShouFu referes Engine
GA_HuanXiangShouFu referes GA_Passive
BulletCommonDataAsset referes CoreUObject
BulletCommonDataAsset referes Engine
PD_WeaponLevelMaterialDatas referes CoreUObject
PD_WeaponLevelMaterialDatas referes Engine
GA_Role_FixHook referes CoreUObject
GA_Role_FixHook referes CppTypes
GA_Role_FixHook referes Engine
GA_Role_FixHook referes GA_Base
GA_Role_FixHook referes TsBaseCharacter
NCS_Up_Lv2 referes CoreUObject
NCS_Up_Lv2 referes KuroAnim
TsUiSceneActor referes CoreUObject
TsUiSceneActor referes CppTypes
TsUiSceneActor referes EPerformanceRoleState
TsUiSceneActor referes Engine
TsUiSceneRoleActor referes CharRenderingComponent
TsUiSceneRoleActor referes CoreUObject
TsUiSceneRoleActor referes CppTypes
TsUiSceneRoleActor referes ECharacterDitherType
TsUiSceneRoleActor referes Engine
TsUiSceneRoleActor referes TsUiSceneActor
NCS_Out_Lv2 referes CoreUObject
NCS_Out_Lv2 referes KuroAnim
BP_UiCameraAnimation referes CoreUObject
BP_UiCameraAnimation referes CppTypes
BP_UiCameraAnimation referes Engine
BP_GlobalGI referes BP_Clouds
BP_GlobalGI referes BP_ControlTodTime
BP_GlobalGI referes BP_UiSceneRenderingComponent
BP_GlobalGI referes BasicTypes
BP_GlobalGI referes CoreUObject
BP_GlobalGI referes CppTypes
BP_GlobalGI referes E_Cloud_Presents
BP_GlobalGI referes Engine
BP_GlobalGI referes KuroCurve
BP_GlobalGI referes KuroRenderingRuntimeBPPlugin
BPI_PhysicInteraction referes CoreUObject
BPI_PhysicInteraction referes CppTypes
BP_InputComponent referes BP_InputBase
BP_InputComponent referes CoreUObject
BP_InputComponent referes CppTypes
BP_InputComponent referes SInputCaches
BP_InputComponent referes SInputHoldConfig
BP_InputComponent referes sInputCommand
BP_FightCameraConfig referes CoreUObject
BP_FightCameraConfig referes Engine
BP_FightCameraConfig referes SSettlementCamera
BP_Droplets referes CoreUObject
BP_Droplets referes CppTypes
BP_Droplets referes Engine
BP_Droplets referes KuroRenderingRuntimeBPPlugin
BP_Droplets referes ProceduralMeshComponent
BP_BasePathLine_Edgewall referes CoreUObject
BP_BasePathLine_Edgewall referes CppTypes
BP_BasePathLine_Edgewall referes Engine
BP_BasePathLine referes CoreUObject
BP_BasePathLine referes CppTypes
BP_BasePathLine referes Engine
KuroSceneInteraction_86 referes CoreUObject
KuroSceneInteraction_86 referes Engine
BP_SequenceData referes BP_SequenceData_Generated
BP_SequenceData referes BasicTypes
BP_SequenceData referes CoreUObject
BP_SequenceData referes CppTypes
BP_SequenceData referes EPlotSequenceType
BP_SequenceData referes Engine
BP_AudioVisualizer referes AkAudio
BP_AudioVisualizer referes BasicTypes
BP_AudioVisualizer referes CoreUObject
BP_AudioVisualizer referes CppTypes
BP_AudioVisualizer referes Engine
BP_KuroRainGenerator referes BP_RainComponent_CommonDrop
BP_KuroRainGenerator referes BP_RainComponent_CommonReverse
BP_KuroRainGenerator referes CoreUObject
BP_KuroRainGenerator referes CppTypes
BP_KuroRainGenerator referes Engine
BP_KuroRainGenerator referes KuroRenderingRuntimeBPPlugin
BP_KuroRainGenerator referes Niagara
BP_KuroRainGenerator referes PDA_RainConfigs
BP_LensDropletManager referes CoreUObject
BP_LensDropletManager referes CppTypes
BP_LensDropletManager referes Engine
BP_LensDropletManager referes KuroRenderingRuntimeBPPlugin
BP_LensDropletManager referes ProceduralMeshComponent
PDA_ThunderConfig referes AkAudio
PDA_ThunderConfig referes CoreUObject
PDA_ThunderConfig referes CppTypes
PDA_ThunderConfig referes Engine
PDA_ThunderConfig referes KuroCurve
PDA_ThunderConfig referes Niagara
BP_WeatherData referes CoreUObject
SSpecialEnergyBarKey referes CoreUObject
SSpecialEnergyBarKey referes CppTypes
SSpecialEnergyBar referes BasicTypes
SSpecialEnergyBar referes CoreUObject
SSpecialEnergyBar referes CppTypes
SSpecialEnergyBar referes ESpecialEnergyBarPrefabType
BP_VolumetricSphereLightSuperFar referes CoreUObject
BP_VolumetricSphereLightSuperFar referes CppTypes
BP_VolumetricSphereLightSuperFar referes Engine
BP_VolumetricSphereLightSuperFar referes KuroRenderingRuntimeBPPlugin
SBulletCampRow referes BulletCampType
SBulletCampRow referes CoreUObject
SAllKuroBpDataGroup referes CoreUObject
SAllKuroBpDataGroup referes KuroUtility
SPanelQte referes CoreUObject
SPanelQte referes CppTypes
SPanelQte referes EPanelQteViewType
Ani_MissionPnlProcess_StartWithChild referes BasicTypes
Ani_MissionPnlProcess_StartWithChild referes CoreUObject
Ani_MissionPnlProcess_StartWithChild referes CppTypes
Ani_MissionPnlProcess_StartWithChild referes Engine
Ani_MissionPnlProcess_StartWithChild referes LevelSequence
Ani_MissionPnlProcess_Start referes CoreUObject
Ani_MissionPnlProcess_Start referes CppTypes
Ani_MissionPnlProcess_Start referes Engine
Ani_MissionPnlProcess_Start referes LevelSequence
EffectModelLight referes CoreUObject
EffectModelLight referes KuroGameplay
ABP_Seq_Nvzhu_Switch referes ABP_Switch_Seq_V2
ABP_Seq_Nvzhu_Switch referes CoreUObject
TsAnimNotifyStateAudioEvent referes BasicTypes
TsAnimNotifyStateAudioEvent referes CoreUObject
TsAnimNotifyStateAudioEvent referes CppTypes
TsAnimNotifyStateAudioEvent referes KuroAudio
TsAnimNotifyStateAudioEvent referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStateAddTag referes BasicTypes
TsAnimNotifyStateAddTag referes CoreUObject
TsAnimNotifyStateAddTag referes CppTypes
TsAnimNotifyStateAddTag referes GameplayTags
TsAnimNotifyStateAddTag referes KuroRenderingRuntimeBPPlugin
ABP_Nvzhu referes ABP_BaseRole
ABP_Nvzhu referes CoreUObject
TPrefab_SM_Gat_01A referes CoreUObject
TPrefab_SM_Gat_01A referes Engine
TsAnimNotifyStateAccelInSplineMove referes CoreUObject
TsAnimNotifyStateAccelInSplineMove referes CppTypes
TsAnimNotifyStateAccelInSplineMove referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyChangeAcceleration referes BasicTypes
TsAnimNotifyChangeAcceleration referes CoreUObject
TsAnimNotifyChangeAcceleration referes CppTypes
TsAnimNotifyChangeAcceleration referes ECharState
TsAnimNotifyChangeAcceleration referes KuroRenderingRuntimeBPPlugin
KuroSceneInteraction_11 referes CoreUObject
KuroSceneInteraction_11 referes Engine
TsAnimNotifySendGamePlayEvent referes BasicTypes
TsAnimNotifySendGamePlayEvent referes CoreUObject
TsAnimNotifySendGamePlayEvent referes CppTypes
TsAnimNotifySendGamePlayEvent referes GameplayTags
TsAnimNotifySendGamePlayEvent referes KuroRenderingRuntimeBPPlugin
KuroSceneInteraction_14 referes CoreUObject
KuroSceneInteraction_14 referes Engine
TsAnimNotifyStateAddLocationBlackboard referes BasicTypes
TsAnimNotifyStateAddLocationBlackboard referes CoreUObject
TsAnimNotifyStateAddLocationBlackboard referes CppTypes
TsAnimNotifyStateAddLocationBlackboard referes EAnsBlackboardType
TsAnimNotifyStateAddLocationBlackboard referes Engine
TsAnimNotifyStateAddLocationBlackboard referes KuroRenderingRuntimeBPPlugin
NCS_Role_Manipulate_Intercat referes BP_CameraShakeAndForceFeedback
NCS_Role_Manipulate_Intercat referes CoreUObject
BP_AnimNotify_AddMaterialControllerData referes AnimNotifyAddMaterialControllerData
BP_AnimNotify_AddMaterialControllerData referes CoreUObject
TsAnimNotifyBreakPoint referes BasicTypes
TsAnimNotifyBreakPoint referes CoreUObject
TsAnimNotifyBreakPoint referes CppTypes
TsAnimNotifyBreakPoint referes KuroRenderingRuntimeBPPlugin
GamePlayScan referes BP_Fx_Scanning
GamePlayScan referes CoreUObject
GamePlayScan referes CppTypes
GamePlayScan referes Engine
TsSimpleInteractBase referes CoreUObject
TsSimpleInteractBase referes CppTypes
TsSimpleInteractBase referes Engine
TsSimpleInteractBase referes KuroRenderingRuntimeBPPlugin
TsSimpleInteractBase referes SSimpleInteractResult
TsSimpleInteractHookPoint referes CoreUObject
TsSimpleInteractHookPoint referes TsSimpleInteractBase
TsSceneInteractBlueprintFunctionLibrary referes CoreUObject
TsSceneInteractBlueprintFunctionLibrary referes CppTypes
TsSceneInteractBlueprintFunctionLibrary referes Engine
FK_Shake_AssestData referes CoreUObject
FK_Shake_AssestData referes CppTypes
FK_Shake_AssestData referes Engine
FK_Shake_AssestData referes KuroAnim
NCS_In_Lv3 referes CoreUObject
NCS_In_Lv3 referes KuroAnim
BP_Fx_ZP_Atk01 referes CoreUObject
BP_Fx_ZP_Atk01 referes Engine
NCS_Up_Lv4 referes CoreUObject
NCS_Up_Lv4 referes KuroAnim
GA_Role_Saomiao referes CoreUObject
GA_Role_Saomiao referes CppTypes
GA_Role_Saomiao referes Engine
GA_Role_Saomiao referes GA_Base
BP_MO1GAziziMd00501 referes CoreUObject
BP_MO1GAziziMd00501 referes CppTypes
BP_MO1GAziziMd00501 referes Engine
BP_MO1GAziziMd00501 referes TsBaseCharacter
NCS_Up_Lv8 referes BP_CameraShakeAndForceFeedback
NCS_Up_Lv8 referes CoreUObject
GA_Hook_Swinging referes CoreUObject
GA_Hook_Swinging referes CppTypes
GA_Hook_Swinging referes Engine
GA_Hook_Swinging referes GA_Base
GA_Hook_Swinging referes GameplayAbilities
GA_Hook_Swinging referes SCameraModifier_Settings
NCS_Up_Lv1 referes CoreUObject
NCS_Up_Lv1 referes KuroAnim
GA_Role_Manipulate_Interact referes CoreUObject
GA_Role_Manipulate_Interact referes CppTypes
GA_Role_Manipulate_Interact referes Engine
GA_Role_Manipulate_Interact referes GA_Base
GA_Role_Manipulate_Interact referes GameplayAbilities
GA_Role_Manipulate_Interact referes GameplayTasks
GA_Role_Manipulate_Interact referes TsBaseCharacter
GA_Role_Manipulate_ExtraAction referes CoreUObject
GA_Role_Manipulate_ExtraAction referes CppTypes
GA_Role_Manipulate_ExtraAction referes Engine
GA_Role_Manipulate_ExtraAction referes GA_Base
GA_Interaction_Bounce referes CoreUObject
GA_Interaction_Bounce referes CppTypes
GA_Interaction_Bounce referes Engine
GA_Interaction_Bounce referes GA_Base
TPrefab_SM_Gat_15A referes CoreUObject
TPrefab_SM_Gat_15A referes Engine
TsAnimNotifyCatapult referes BasicTypes
TsAnimNotifyCatapult referes CoreUObject
TsAnimNotifyCatapult referes CppTypes
TsAnimNotifyCatapult referes KuroRenderingRuntimeBPPlugin
GA_Interaction_Catapult_Passive referes CoreUObject
GA_Interaction_Catapult_Passive referes CppTypes
GA_Interaction_Catapult_Passive referes Engine
GA_Interaction_Catapult_Passive referes GA_Passive
GA_Interaction_Giant_Passive referes CoreUObject
GA_Interaction_Giant_Passive referes CppTypes
GA_Interaction_Giant_Passive referes Engine
GA_Interaction_Giant_Passive referes GA_Passive
GA_Common_limitmove referes CoreUObject
GA_Common_limitmove referes CppTypes
GA_Common_limitmove referes Engine
GA_Common_limitmove referes GA_Base
GA_LimitDodge referes CoreUObject
GA_LimitDodge referes CppTypes
GA_LimitDodge referes Engine
GA_LimitDodge referes GA_Passive
GA_LimitDodge referes TsBaseCharacter
TsTaskMoveToActor referes BasicTypes
TsTaskMoveToActor referes CoreUObject
TsTaskMoveToActor referes CppTypes
TsTaskMoveToActor referes Engine
TsTaskMoveToActor referes TsTaskAbortImmediatelyBase
GA_Role_Move_F_Net referes CoreUObject
GA_Role_Move_F_Net referes CppTypes
GA_Role_Move_F_Net referes Engine
GA_Role_Move_F_Net referes GA_Base
GA_Role_Move_F_Net referes GameplayAbilities
GA_Role_Move_F_Net referes GameplayTags
GA_Role_Move_F_Net referes KuroGAS
GA_WuYinQu_HuKouSanMai_Ball_Passive referes CoreUObject
GA_WuYinQu_HuKouSanMai_Ball_Passive referes CppTypes
GA_WuYinQu_HuKouSanMai_Ball_Passive referes Engine
GA_WuYinQu_HuKouSanMai_Ball_Passive referes GA_Passive
GA_WuYinQu_HuKouSanMai_Ball referes BasicTypes
GA_WuYinQu_HuKouSanMai_Ball referes CoreUObject
GA_WuYinQu_HuKouSanMai_Ball referes CppTypes
GA_WuYinQu_HuKouSanMai_Ball referes Engine
GA_WuYinQu_HuKouSanMai_Ball referes GA_Base
GA_WuYinQu_HuKouSanMai_Ball referes GameplayAbilities
GA_WuYinQu_HuKouSanMai_Ball referes GameplayTags
GA_WuYinQu_HuangShiGaoDi2__Environment_Passive referes CoreUObject
GA_WuYinQu_HuangShiGaoDi2__Environment_Passive referes CppTypes
GA_WuYinQu_HuangShiGaoDi2__Environment_Passive referes Engine
GA_WuYinQu_HuangShiGaoDi2__Environment_Passive referes GA_Passive
GA_WuYinQu_HuangShiGaoDi2__Environment referes CoreUObject
GA_WuYinQu_HuangShiGaoDi2__Environment referes CppTypes
GA_WuYinQu_HuangShiGaoDi2__Environment referes Engine
GA_WuYinQu_HuangShiGaoDi2__Environment referes GA_Base
GA_WuYinQu_HuangShiGaoDi2__Environment referes GameplayAbilities
GA_WuYinQu_HuangShiGaoDi2__Environment referes GameplayTags
GA_WuYinQu_QiChiCun_RandomQTE_Passive referes CoreUObject
GA_WuYinQu_QiChiCun_RandomQTE_Passive referes CppTypes
GA_WuYinQu_QiChiCun_RandomQTE_Passive referes Engine
GA_WuYinQu_QiChiCun_RandomQTE_Passive referes GA_Passive
GA_WuYinQu_QiChiCun_RandomQTE referes CoreUObject
GA_WuYinQu_QiChiCun_RandomQTE referes CppTypes
GA_WuYinQu_QiChiCun_RandomQTE referes Engine
GA_WuYinQu_QiChiCun_RandomQTE referes GA_Base
GA_WuYinQu_QiChiCun_RandomQTE referes GameplayAbilities
GA_WuYinQu_QiChiCun_RandomQTE referes GameplayTags
GA_Role_Suyan referes CoreUObject
GA_Role_Suyan referes CppTypes
GA_Role_Suyan referes Engine
GA_Role_Suyan referes GA_Base
GA_Role_ShowVision referes CoreUObject
GA_Role_ShowVision referes CppTypes
GA_Role_ShowVision referes Engine
GA_Role_ShowVision referes GA_Base
GA_Role_Manipulate_Hold referes BPE_ManipulateState
GA_Role_Manipulate_Hold referes CoreUObject
GA_Role_Manipulate_Hold referes CppTypes
GA_Role_Manipulate_Hold referes EClimbState
GA_Role_Manipulate_Hold referes Engine
GA_Role_Manipulate_Hold referes GA_Base
GA_Role_Manipulate_Hold referes GameplayAbilities
GA_Role_Manipulate_Hold referes GameplayTags
GA_Role_Manipulate_Hold referes GameplayTasks
GA_Role_Bianshen referes BP_BaseVision
GA_Role_Bianshen referes BasicTypes
GA_Role_Bianshen referes CoreUObject
GA_Role_Bianshen referes CppTypes
GA_Role_Bianshen referes Engine
GA_Role_Bianshen referes GA_Base
GA_Role_Bianshen referes GameplayAbilities
GA_Role_Bianshen referes KuroGAS
GA_Role_Bianshen referes SVisionData
GA_Role_Bianshen referes TsBaseCharacter
GA_Fuhuo_Nvzhu referes CoreUObject
GA_Fuhuo_Nvzhu referes CppTypes
GA_Fuhuo_Nvzhu referes Engine
GA_Fuhuo_Nvzhu referes GA_Passive
TsAnimNotifyStateSetCollisionChannel referes BasicTypes
TsAnimNotifyStateSetCollisionChannel referes CoreUObject
TsAnimNotifyStateSetCollisionChannel referes CppTypes
TsAnimNotifyStateSetCollisionChannel referes KuroRenderingRuntimeBPPlugin
GA_ExitSkill_Nvzhu_Passive referes BP_QTE_Camera
GA_ExitSkill_Nvzhu_Passive referes BasicTypes
GA_ExitSkill_Nvzhu_Passive referes CoreUObject
GA_ExitSkill_Nvzhu_Passive referes CppTypes
GA_ExitSkill_Nvzhu_Passive referes Engine
GA_ExitSkill_Nvzhu_Passive referes GA_Passive
GA_ExitSkill_Nvzhu_Passive referes GameplayAbilities
KuroSceneInteraction_37 referes CoreUObject
KuroSceneInteraction_37 referes Engine
BP_Fx_ZP_Atk06 referes CoreUObject
BP_Fx_ZP_Atk06 referes Engine
TPrefab_SM_Gat_28A referes CoreUObject
TPrefab_SM_Gat_28A referes Engine
TsAnimNotifyStateBurst referes BasicTypes
TsAnimNotifyStateBurst referes CoreUObject
TsAnimNotifyStateBurst referes CppTypes
TsAnimNotifyStateBurst referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyControllerShake referes BasicTypes
TsAnimNotifyControllerShake referes CoreUObject
TsAnimNotifyControllerShake referes CppTypes
TsAnimNotifyControllerShake referes KuroInput
TsAnimNotifyControllerShake referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStateSetHitPriority referes BasicTypes
TsAnimNotifyStateSetHitPriority referes CoreUObject
TsAnimNotifyStateSetHitPriority referes CppTypes
TsAnimNotifyStateSetHitPriority referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStateJumpLandDetect referes BasicTypes
TsAnimNotifyStateJumpLandDetect referes CoreUObject
TsAnimNotifyStateJumpLandDetect referes CppTypes
TsAnimNotifyStateJumpLandDetect referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStateAbsoluteTimeStop referes BasicTypes
TsAnimNotifyStateAbsoluteTimeStop referes CoreUObject
TsAnimNotifyStateAbsoluteTimeStop referes CppTypes
TsAnimNotifyStateAbsoluteTimeStop referes KuroRenderingRuntimeBPPlugin
NCS_Down_Lv9 referes BP_CameraShakeAndForceFeedback
NCS_Down_Lv9 referes CoreUObject
TsAnimNotifyStateHideBone referes BasicTypes
TsAnimNotifyStateHideBone referes CoreUObject
TsAnimNotifyStateHideBone referes CppTypes
TsAnimNotifyStateHideBone referes KuroRenderingRuntimeBPPlugin
AttackShake_Wuguanzhe01 referes CoreUObject
AttackShake_Wuguanzhe01 referes Engine
AttackShake_Wuguanzhe01_3 referes CoreUObject
AttackShake_Wuguanzhe01_3 referes Engine
TsAnimNotifyStateGoThrough referes BasicTypes
TsAnimNotifyStateGoThrough referes CoreUObject
TsAnimNotifyStateGoThrough referes CppTypes
TsAnimNotifyStateGoThrough referes KuroRenderingRuntimeBPPlugin
SC_PlayerFemale_Shanghen referes CoreUObject
SC_PlayerFemale_Shanghen referes CppTypes
SC_PlayerFemale_Shanghen referes Engine
SC_PlayerFemale_Shanghen referes LevelSequence
TsAnimNotifySetMovementMode referes BasicTypes
TsAnimNotifySetMovementMode referes CoreUObject
TsAnimNotifySetMovementMode referes CppTypes
TsAnimNotifySetMovementMode referes Engine
TsAnimNotifySetMovementMode referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStateShowManipualteFx referes BasicTypes
TsAnimNotifyStateShowManipualteFx referes CoreUObject
TsAnimNotifyStateShowManipualteFx referes CppTypes
TsAnimNotifyStateShowManipualteFx referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStateCleanBurstCamera referes BasicTypes
TsAnimNotifyStateCleanBurstCamera referes CoreUObject
TsAnimNotifyStateCleanBurstCamera referes CppTypes
TsAnimNotifyStateCleanBurstCamera referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStateTurnModelBlackboard referes BasicTypes
TsAnimNotifyStateTurnModelBlackboard referes CoreUObject
TsAnimNotifyStateTurnModelBlackboard referes CppTypes
TsAnimNotifyStateTurnModelBlackboard referes Engine
TsAnimNotifyStateTurnModelBlackboard referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStatePositionBranchTarget referes BasicTypes
TsAnimNotifyStatePositionBranchTarget referes CoreUObject
TsAnimNotifyStatePositionBranchTarget referes CppTypes
TsAnimNotifyStatePositionBranchTarget referes Engine
TsAnimNotifyStatePositionBranchTarget referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyStateCaughtBinding referes BasicTypes
TsAnimNotifyStateCaughtBinding referes CoreUObject
TsAnimNotifyStateCaughtBinding referes CppTypes
TsAnimNotifyStateCaughtBinding referes KuroRenderingRuntimeBPPlugin
TsAnimNotifySwitchSequenceCamera referes BasicTypes
TsAnimNotifySwitchSequenceCamera referes CoreUObject
TsAnimNotifySwitchSequenceCamera referes CppTypes
TsAnimNotifySwitchSequenceCamera referes ESequenceCameraAnsEffectiveClientType
TsAnimNotifySwitchSequenceCamera referes KuroRenderingRuntimeBPPlugin
TsAnimNotifySwitchSequenceCamera referes SSequenceCamera_Settings
TsAnimNotifyFightStand referes BasicTypes
TsAnimNotifyFightStand referes CoreUObject
TsAnimNotifyFightStand referes CppTypes
TsAnimNotifyFightStand referes KuroRenderingRuntimeBPPlugin
SC_PlayerFemale_Burst01 referes BasicTypes
SC_PlayerFemale_Burst01 referes CoreUObject
SC_PlayerFemale_Burst01 referes CppTypes
SC_PlayerFemale_Burst01 referes Engine
SC_PlayerFemale_Burst01 referes LevelSequence
TsAnimNotifyStateNextAtt referes BasicTypes
TsAnimNotifyStateNextAtt referes CoreUObject
TsAnimNotifyStateNextAtt referes CppTypes
TsAnimNotifyStateNextAtt referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyWeaponHide referes BasicTypes
TsAnimNotifyWeaponHide referes CoreUObject
TsAnimNotifyWeaponHide referes CppTypes
TsAnimNotifyWeaponHide referes KuroRenderingRuntimeBPPlugin
BP_Fx_ZP_Atk07 referes CoreUObject
BP_Fx_ZP_Atk07 referes Engine
KuroSceneInteraction_120 referes CoreUObject
KuroSceneInteraction_120 referes Engine
TsTriggerVolume referes AkAudio
TsTriggerVolume referes BasicTypes
TsTriggerVolume referes CoreUObject
TsTriggerVolume referes CppTypes
TsTriggerVolume referes ETriggerType
TsTriggerVolume referes Engine
TsTriggerVolume referes KuroRenderingRuntimeBPPlugin
BP_HaloPointLight referes CoreUObject
BP_HaloPointLight referes CppTypes
BP_HaloPointLight referes E_BillboardMode
BP_HaloPointLight referes Engine
BP_HaloPointLight referes KuroRenderingRuntimeBPPlugin
BP_HaloPointLight referes PD_HaloPointLightConfig
BP_Fx_BirdsFlySpline referes CoreUObject
BP_Fx_BirdsFlySpline referes CppTypes
BP_Fx_BirdsFlySpline referes EffectModelNiagara
BP_Fx_BirdsFlySpline referes Engine
BP_Fx_BirdsFlySpline referes KuroRenderingRuntimeBPPlugin
BP_EffectActorWaterFall_Medium referes BasicTypes
BP_EffectActorWaterFall_Medium referes CoreUObject
BP_EffectActorWaterFall_Medium referes CppTypes
BP_EffectActorWaterFall_Medium referes EEffectPlay
BP_EffectActorWaterFall_Medium referes EEffectType
BP_EffectActorWaterFall_Medium referes Engine
BP_EffectActorWaterFall_Medium referes KuroRenderingRuntimeBPPlugin
BP_EffectActorWaterFall_Low referes BasicTypes
BP_EffectActorWaterFall_Low referes CoreUObject
BP_EffectActorWaterFall_Low referes CppTypes
BP_EffectActorWaterFall_Low referes EEffectPlay
BP_EffectActorWaterFall_Low referes EEffectType
BP_EffectActorWaterFall_Low referes Engine
BP_EffectActorWaterFall_Low referes KuroRenderingRuntimeBPPlugin
KuroSceneInteraction_105 referes CoreUObject
KuroSceneInteraction_105 referes Engine
BP_EffectActorWaterFall_High referes BasicTypes
BP_EffectActorWaterFall_High referes CoreUObject
BP_EffectActorWaterFall_High referes CppTypes
BP_EffectActorWaterFall_High referes EEffectPlay
BP_EffectActorWaterFall_High referes EEffectType
BP_EffectActorWaterFall_High referes Engine
BP_EffectActorWaterFall_High referes KuroRenderingRuntimeBPPlugin
WuYinQuBattleActor referes BasicTypes
WuYinQuBattleActor referes CoreUObject
WuYinQuBattleActor referes CppTypes
WuYinQuBattleActor referes Engine
WuYinQuBattleActor referes KuroRenderingRuntimeBPPlugin
WuYinQuBattleActor referes PDA_WuYinQuBattleData
W0003 referes CoreUObject
W0003 referes CppTypes
W0003 referes Engine
W0003 referes LevelSequence
TPrefab_SM_Pro_EMP_RefreshPoint referes CoreUObject
TPrefab_SM_Pro_EMP_RefreshPoint referes Engine
CS_HitFinishShake referes CoreUObject
CS_HitFinishShake referes Engine
Seq_Dajijiguan02_Start referes CoreUObject
Seq_Dajijiguan02_Start referes CppTypes
Seq_Dajijiguan02_Start referes Engine
Seq_Dajijiguan02_Start referes LevelSequence
Seq_Dajijiguan02_Init referes CoreUObject
Seq_Dajijiguan02_Init referes CppTypes
Seq_Dajijiguan02_Init referes Engine
Seq_Dajijiguan02_Init referes LevelSequence
Seq_Dajijiguan02_End referes CoreUObject
Seq_Dajijiguan02_End referes CppTypes
Seq_Dajijiguan02_End referes Engine
Seq_Dajijiguan02_End referes LevelSequence
ABP_MonsterCommon referes AnimGraphRuntime
ABP_MonsterCommon referes BP_ABPLogicParams
ABP_MonsterCommon referes BasicTypes
ABP_MonsterCommon referes CoreUObject
ABP_MonsterCommon referes CppTypes
ABP_MonsterCommon referes ECharParentMoveState
ABP_MonsterCommon referes ECharState
ABP_MonsterCommon referes EHitAnim
ABP_MonsterCommon referes EMovementDirection
ABP_MonsterCommon referes EWalkingPosture
ABP_MonsterCommon referes Engine
ABP_MonsterCommon referes FK_Shake_AssestData
ABP_MonsterCommon referes GameplayTags
ABP_MonsterCommon referes KuroAnim
ABP_MonsterCommon referes TsBaseCharacter
TsDecoratorTagCheck referes AIModule
TsDecoratorTagCheck referes BasicTypes
TsDecoratorTagCheck referes CoreUObject
TsDecoratorTagCheck referes CppTypes
TsDecoratorTagCheck referes SConDitionGroupType
TPrefab_SM_Gat_18A referes CoreUObject
TPrefab_SM_Gat_18A referes Engine
ABP_MO1GAziziMd00501 referes ABP_MonsterCommon
ABP_MO1GAziziMd00501 referes CoreUObject
BP_MO1DundishuMd00601 referes CoreUObject
BP_MO1DundishuMd00601 referes CppTypes
BP_MO1DundishuMd00601 referes Engine
BP_MO1DundishuMd00601 referes TsBaseCharacter
TPrefab_SM_Pro_Tow_02A referes CoreUObject
TPrefab_SM_Pro_Tow_02A referes Engine
TPrefab_SM_Pro_HuanXiangBox_02_CBT3 referes CoreUObject
TPrefab_SM_Pro_HuanXiangBox_02_CBT3 referes Engine
TPrefab_SM_Pro_HuanXiangBox_03_CBT3 referes CoreUObject
TPrefab_SM_Pro_HuanXiangBox_03_CBT3 referes Engine
TsAnimNotifyStateAicAnimEvent referes BasicTypes
TsAnimNotifyStateAicAnimEvent referes CoreUObject
TsAnimNotifyStateAicAnimEvent referes CppTypes
TsAnimNotifyStateAicAnimEvent referes KuroRenderingRuntimeBPPlugin
TPrefab_SM_Pro_Box_02_CBT3 referes CoreUObject
TPrefab_SM_Pro_Box_02_CBT3 referes Engine
TPrefab_SM_Pro_Box_01_CBT3 referes CoreUObject
TPrefab_SM_Pro_Box_01_CBT3 referes Engine
TPrefab_SM_ExplosiveRock_Base referes CoreUObject
TPrefab_SM_ExplosiveRock_Base referes Engine
TPrefab_SM_Pro_WGZS_JinGu referes CoreUObject
TPrefab_SM_Pro_WGZS_JinGu referes Engine
KuroSceneInteraction_56 referes CoreUObject
KuroSceneInteraction_56 referes Engine
BP_InteractedBox referes BP_BaseItem
BP_InteractedBox referes CoreUObject
BP_InteractedBox referes CppTypes
BP_InteractedBox referes Engine
BP_InteractedBox referes ProceduralMeshComponent
BP_BaseAnimal referes CoreUObject
BP_BaseAnimal referes CppTypes
BP_BaseAnimal referes Engine
BP_BaseAnimal referes TsBaseCharacter
BP_BaseBird referes BP_BaseAnimal
BP_BaseBird referes CoreUObject
KuroSceneInteraction_108 referes CoreUObject
KuroSceneInteraction_108 referes Engine
BP_NA028 referes BP_BaseBird
BP_NA028 referes CoreUObject
BP_NA032 referes BP_BaseAnimal
BP_NA032 referes CoreUObject
KuroSceneInteraction_44 referes CoreUObject
KuroSceneInteraction_44 referes Engine
ABP_NA_032 referes ABP_BaseAnimal
ABP_NA_032 referes CoreUObject
BP_CommonSmallAnimal referes BP_BaseAnimal
BP_CommonSmallAnimal referes CoreUObject
ABP_NA006 referes ABP_BaseAnimal
ABP_NA006 referes CoreUObject
BP_NA006 referes BP_CommonSmallAnimal
BP_NA006 referes CoreUObject
BP_NA006 referes Engine
TPrefab_SM_Gat_19A referes CoreUObject
TPrefab_SM_Gat_19A referes Engine
TPrefab_SM_Gat_09A referes CoreUObject
TPrefab_SM_Gat_09A referes Engine
TPrefab_SM_Gat_34A referes CoreUObject
TPrefab_SM_Gat_34A referes Engine
TPrefab_SM_Pro_Box_08 referes CoreUObject
TPrefab_SM_Pro_Box_08 referes Engine
TPrefab_SM_Gat_39A referes CoreUObject
TPrefab_SM_Gat_39A referes Engine
BP_InputComponent_Nvzhu referes BP_InputComponent
BP_InputComponent_Nvzhu referes CoreUObject
BP_InputComponent_Nvzhu referes CppTypes
BP_InputComponent_Nvzhu referes sInputCommand
ABP_SwordSwordCommon_PC referes CoreUObject
ABP_SwordSwordCommon_PC referes CppTypes
ABP_SwordSwordCommon_PC referes Engine
ABP_SwordSwordCommon_PC referes KawaiiPhysics
ABP_SwordSwordCommon_PC referes TsBaseCharacter
KuroSceneInteraction_3 referes CoreUObject
KuroSceneInteraction_3 referes Engine
ABP_EParagliderMd10011 referes ABP_ParaglidingBase
ABP_EParagliderMd10011 referes CoreUObject
TPrefab_SM_ExplosiveRock referes CoreUObject
TPrefab_SM_ExplosiveRock referes Engine
TPrefab_SM_Pro_EMP_Item referes CoreUObject
TPrefab_SM_Pro_EMP_Item referes Engine
KuroSceneInteraction_7 referes CoreUObject
KuroSceneInteraction_7 referes Engine
TPrefab_SM_WYQ_Middle_Shengxian referes CoreUObject
TPrefab_SM_WYQ_Middle_Shengxian referes Engine
GA_Monster_Base referes CoreUObject
GA_Monster_Base referes CppTypes
GA_Monster_Base referes Engine
GA_Monster_Base referes GA_Base
GA_Monster_Base referes TsBaseCharacter
GA_MO1DundishuMd00601_Attack01 referes CoreUObject
GA_MO1DundishuMd00601_Attack01 referes CppTypes
GA_MO1DundishuMd00601_Attack01 referes Engine
GA_MO1DundishuMd00601_Attack01 referes GA_Monster_Base
GA_MO1DundishuMd00601_Attack01 referes SHitInformation
GA_Common_YuanShengLiZi referes BasicTypes
GA_Common_YuanShengLiZi referes CoreUObject
GA_Common_YuanShengLiZi referes CppTypes
GA_Common_YuanShengLiZi referes EffectModelGroup
GA_Common_YuanShengLiZi referes Engine
GA_Common_YuanShengLiZi referes GA_Passive
GA_Monster_Common_Didi_JiyanInstance referes CoreUObject
GA_Monster_Common_Didi_JiyanInstance referes CppTypes
GA_Monster_Common_Didi_JiyanInstance referes Engine
GA_Monster_Common_Didi_JiyanInstance referes GA_Monster_Base
GA_Monster_Common_Didi_JiyanInstance referes TsBaseCharacter
TsAnimNotifyStateBonesShowControl referes BasicTypes
TsAnimNotifyStateBonesShowControl referes CoreUObject
TsAnimNotifyStateBonesShowControl referes CppTypes
TsAnimNotifyStateBonesShowControl referes KuroRenderingRuntimeBPPlugin
TsAnimNotifyHideMesh referes BasicTypes
TsAnimNotifyHideMesh referes CoreUObject
TsAnimNotifyHideMesh referes CppTypes
TsAnimNotifyHideMesh referes KuroRenderingRuntimeBPPlugin
TsTaskPatrol referes CoreUObject
TsTaskPatrol referes CppTypes
TsTaskPatrol referes Engine
TsTaskPatrol referes TsTaskAbortImmediatelyBase
TsAnimNotifySkillBehavior referes BasicTypes
TsAnimNotifySkillBehavior referes CoreUObject
TsAnimNotifySkillBehavior referes CppTypes
TsAnimNotifySkillBehavior referes KuroRenderingRuntimeBPPlugin
KuroSceneInteraction_9 referes CoreUObject
KuroSceneInteraction_9 referes Engine
TsDecoratorBlackboard referes AIModule
TsDecoratorBlackboard referes BasicTypes
TsDecoratorBlackboard referes CoreUObject
TsDecoratorBlackboard referes CppTypes
TsDecoratorCoolDown referes AIModule
TsDecoratorCoolDown referes CoreUObject
TsDecoratorCoolDown referes CppTypes
TsDecoratorBlackboardIntCompare referes AIModule
TsDecoratorBlackboardIntCompare referes BasicTypes
TsDecoratorBlackboardIntCompare referes CoreUObject
TsDecoratorBlackboardIntCompare referes CppTypes
TsDecoratorBlackboardFloatCompare referes AIModule
TsDecoratorBlackboardFloatCompare referes BasicTypes
TsDecoratorBlackboardFloatCompare referes CoreUObject
TsDecoratorBlackboardFloatCompare referes CppTypes
TsDecoratorBlackboardBooleanCompare referes AIModule
TsDecoratorBlackboardBooleanCompare referes BasicTypes
TsDecoratorBlackboardBooleanCompare referes CoreUObject
TsDecoratorBlackboardBooleanCompare referes CppTypes
TsTaskTeamWander referes CoreUObject
TsTaskTeamWander referes CppTypes
TsTaskTeamWander referes Engine
TsTaskTeamWander referes TsTaskAbortImmediatelyBase
TsTaskSelectSkill referes CoreUObject
TsTaskSelectSkill referes CppTypes
TsTaskSelectSkill referes Engine
TsTaskSelectSkill referes TsTaskAbortImmediatelyBase
TsTaskPatrolPerformanceQuery referes CoreUObject
TsTaskPatrolPerformanceQuery referes CppTypes
TsTaskPatrolPerformanceQuery referes Engine
TsTaskPatrolPerformanceQuery referes TsTaskAbortImmediatelyBase
TsTaskUseSkillDesignated referes BasicTypes
TsTaskUseSkillDesignated referes CoreUObject
TsTaskUseSkillDesignated referes CppTypes
TsTaskUseSkillDesignated referes Engine
TsTaskUseSkillDesignated referes TsTaskAbortImmediatelyBase
AIC_CommonAnimal referes CoreUObject
AIC_CommonAnimal referes CppTypes
AIC_CommonAnimal referes Engine
AIC_CommonAnimal referes TsAiController
AIC_CommonAnimal referes TsBaseCharacter
AIC_NA006 referes AIC_CommonAnimal
AIC_NA006 referes CoreUObject
TsTaskAnimalDestroySelf referes CoreUObject
TsTaskAnimalDestroySelf referes CppTypes
TsTaskAnimalDestroySelf referes Engine
TsTaskAnimalDestroySelf referes TsTaskAbortImmediatelyBase
TsDecoratorBlackboardHasEntity referes AIModule
TsDecoratorBlackboardHasEntity referes BasicTypes
TsDecoratorBlackboardHasEntity referes CoreUObject
TsDecoratorBlackboardHasEntity referes CppTypes
TsTaskTerritoryWander referes BasicTypes
TsTaskTerritoryWander referes CoreUObject
TsTaskTerritoryWander referes CppTypes
TsTaskTerritoryWander referes Engine
TsTaskTerritoryWander referes TsTaskAbortImmediatelyBase
TsTaskSwitchAnimalState referes CoreUObject
TsTaskSwitchAnimalState referes CppTypes
TsTaskSwitchAnimalState referes EAnimalEcologicalState
TsTaskSwitchAnimalState referes Engine
TsTaskSwitchAnimalState referes TsTaskAbortImmediatelyBase
TsTaskQueryFleeLocation referes BasicTypes
TsTaskQueryFleeLocation referes CoreUObject
TsTaskQueryFleeLocation referes CppTypes
TsTaskQueryFleeLocation referes Engine
TsTaskQueryFleeLocation referes TsTaskAbortImmediatelyBase
TsTaskAnimalMoveTo referes BasicTypes
TsTaskAnimalMoveTo referes CoreUObject
TsTaskAnimalMoveTo referes CppTypes
TsTaskAnimalMoveTo referes ECharState
TsTaskAnimalMoveTo referes Engine
TsTaskAnimalMoveTo referes TsTaskAbortImmediatelyBase
KuroSceneInteraction_12 referes CoreUObject
KuroSceneInteraction_12 referes Engine
KuroSceneInteraction_13 referes CoreUObject
KuroSceneInteraction_13 referes Engine
KuroSceneInteraction_21 referes CoreUObject
KuroSceneInteraction_21 referes Engine
KuroSceneInteraction_23 referes CoreUObject
KuroSceneInteraction_23 referes Engine
KuroSceneInteraction_25 referes CoreUObject
KuroSceneInteraction_25 referes Engine
KuroSceneInteraction_26 referes CoreUObject
KuroSceneInteraction_26 referes Engine
KuroSceneInteraction_28 referes CoreUObject
KuroSceneInteraction_28 referes Engine
KuroSceneInteraction_29 referes CoreUObject
KuroSceneInteraction_29 referes Engine
KuroSceneInteraction_31 referes CoreUObject
KuroSceneInteraction_31 referes Engine
KuroSceneInteraction_106 referes CoreUObject
KuroSceneInteraction_106 referes Engine
KuroSceneInteraction_34 referes CoreUObject
KuroSceneInteraction_34 referes Engine
AIC_NA028 referes AIC_CommonAnimal
AIC_NA028 referes CoreUObject
KuroSceneInteraction_35 referes CoreUObject
KuroSceneInteraction_35 referes Engine
KuroSceneInteraction_38 referes CoreUObject
KuroSceneInteraction_38 referes Engine
KuroSceneInteraction_39 referes CoreUObject
KuroSceneInteraction_39 referes Engine
KuroSceneInteraction_40 referes CoreUObject
KuroSceneInteraction_40 referes Engine
KuroSceneInteraction_41 referes CoreUObject
KuroSceneInteraction_41 referes Engine
KuroSceneInteraction_42 referes CoreUObject
KuroSceneInteraction_42 referes Engine
KuroSceneInteraction_43 referes CoreUObject
KuroSceneInteraction_43 referes Engine
KuroSceneInteraction_45 referes CoreUObject
KuroSceneInteraction_45 referes Engine
KuroSceneInteraction_50 referes CoreUObject
KuroSceneInteraction_50 referes Engine
KuroSceneInteraction_53 referes CoreUObject
KuroSceneInteraction_53 referes Engine
TPrefab_SM_Pro_EMP_Base_LevelInstance_2 referes CoreUObject
TPrefab_SM_Pro_EMP_Base_LevelInstance_2 referes Engine
KuroSceneInteraction_61 referes CoreUObject
KuroSceneInteraction_61 referes Engine
KuroSceneInteraction_64 referes CoreUObject
KuroSceneInteraction_64 referes Engine
KuroSceneInteraction_65 referes CoreUObject
KuroSceneInteraction_65 referes Engine
KuroSceneInteraction_67 referes CoreUObject
KuroSceneInteraction_67 referes Engine
KuroSceneInteraction_71 referes CoreUObject
KuroSceneInteraction_71 referes Engine
KuroSceneInteraction_72 referes CoreUObject
KuroSceneInteraction_72 referes Engine
KuroSceneInteraction_74 referes CoreUObject
KuroSceneInteraction_74 referes Engine
KuroSceneInteraction_76 referes CoreUObject
KuroSceneInteraction_76 referes Engine
KuroSceneInteraction_77 referes CoreUObject
KuroSceneInteraction_77 referes Engine
KuroSceneInteraction_80 referes CoreUObject
KuroSceneInteraction_80 referes Engine
KuroSceneInteraction_84 referes CoreUObject
KuroSceneInteraction_84 referes Engine
KuroSceneInteraction_89 referes CoreUObject
KuroSceneInteraction_89 referes Engine
KuroSceneInteraction_91 referes CoreUObject
KuroSceneInteraction_91 referes Engine
KuroSceneInteraction_92 referes CoreUObject
KuroSceneInteraction_92 referes Engine
KuroSceneInteraction_93 referes CoreUObject
KuroSceneInteraction_93 referes Engine
AIC_NA032 referes AIC_CommonAnimal
AIC_NA032 referes CoreUObject
TsTaskChangePatrol referes BasicTypes
TsTaskChangePatrol referes CoreUObject
TsTaskChangePatrol referes CppTypes
TsTaskChangePatrol referes Engine
TsTaskChangePatrol referes TsTaskAbortImmediatelyBase
KuroSceneInteraction_95 referes CoreUObject
KuroSceneInteraction_95 referes Engine
KuroSceneInteraction_96 referes CoreUObject
KuroSceneInteraction_96 referes Engine
KuroSceneInteraction_97 referes CoreUObject
KuroSceneInteraction_97 referes Engine
KuroSceneInteraction_98 referes CoreUObject
KuroSceneInteraction_98 referes Engine
KuroSceneInteraction_102 referes CoreUObject
KuroSceneInteraction_102 referes Engine
KuroSceneInteraction_103 referes CoreUObject
KuroSceneInteraction_103 referes Engine
KuroSceneInteraction_104 referes CoreUObject
KuroSceneInteraction_104 referes Engine
KuroSceneInteraction_109 referes CoreUObject
KuroSceneInteraction_109 referes Engine
KuroSceneInteraction_112 referes CoreUObject
KuroSceneInteraction_112 referes Engine
KuroSceneInteraction_114 referes CoreUObject
KuroSceneInteraction_114 referes Engine
KuroSceneInteraction_117 referes CoreUObject
KuroSceneInteraction_117 referes Engine
KuroSceneInteraction_118 referes CoreUObject
KuroSceneInteraction_118 referes Engine
KuroSceneInteraction_119 referes CoreUObject
KuroSceneInteraction_119 referes Engine

```

`Dumper/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Dumper.rc

// 新对象的下一组默认值
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#define TEXTFILE 255

#define FOR_TEST_FILE 254


#define BASICTYPES_PACKAGE 253

#define BASICTYPES_CLASSES 252

#define BASICTYPES_STRUCT 251

#define COREUOBJECT_PACKAGE 250

#define COREUOBJECT_CLASSES 249

#define COREUOBJECT_STRUCT 248

#define COREUOBJECT_CPP 247

#define BASICTYPES_CPP 246

#define COREUOBJECT_PARAM 245

#define GLOBAL_OFFSET 244

#define INJECTED_GETBONEWORLDPOS 243


```

`Dumper/utils.cpp`:

```cpp
#include <windows.h>
#include <winternl.h>
#include "memory.h"
#include "utils.h"

bool Compare(uint8* data, uint8 *sig, uint32 size) {
  for (uint32 i = 0; i < size; i++) {
    if (data[i] != sig[i] && sig[i] != 0x00) {
      return false;
    }
  }
  return true;
}

uint8* FindSignature(void* start, void* end, const char* sig, uint32 size) {
  for (uint8* it = (uint8*)start; it < (uint8*)end - size; it++) {
    if (Compare(it, (uint8*)sig, size)) {
      return it;
    };
  }
  return 0;
}

void* FindPointer(void* start, void* end, const char* sig, uint32 size, int32 addition) {
  uint8* address = FindSignature(start, end, sig, size);
  if (!address) return nullptr;
  int32 k;
  for (k = 0; sig[k]; k++);
  int32 offset = *(int32*)(address + k);
  return address + k + 4 + offset + addition;
}

void IterateExSections(void* data, std::function<bool(void*, void*)> callback) {
  auto dos = (PIMAGE_DOS_HEADER)data;
  auto nt = (PIMAGE_NT_HEADERS)((uint8*)data + dos->e_lfanew);
  auto s = IMAGE_FIRST_SECTION(nt);
  for (auto i = 0; i < nt->FileHeader.NumberOfSections; i++, s++) {
    if (s->Characteristics & IMAGE_SCN_CNT_CODE) {
      auto start = (uint8*)data + s->VirtualAddress;
      auto end = start + s->SizeOfRawData;
      if (callback(start, end)) break;
    }
  }
}

uint32 GetProccessPath(uint32 pid, wchar_t* processName, uint32 size) {
  HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, 0, pid);
  if (!QueryFullProcessImageNameW(hProcess, 0, processName, (DWORD*)(&size))) size = 0;
  CloseHandle(hProcess);
  return size;
}

uint64 GetTime() {
  LARGE_INTEGER ret;
  NtQuerySystemTime(&ret);
  return ret.QuadPart;
}

```

`Dumper/utils.h`:

```h
#pragma once
#include <functional>
#include "defs.h"

bool Compare(uint8* data, uint8* sig, uint32 size);

uint8* FindSignature(void* start, void* end, const char* sig, uint32 size);

void* FindPointer(void* start, void* end, const char* sig, uint32 size, int32 addition = 0);

void IterateExSections(void* data, std::function<bool(void*, void*)> callback);

uint32 GetProccessPath(uint32 pid, wchar_t* processName, uint32 size);

uint64 GetTime();

```

`Dumper/wrappers.cpp`:

```cpp
#include <Windows.h>
#include <algorithm>
#include <fmt/core.h>
#include <hash/hash.h>
#include <algorithm>
#include <sstream>
#include "engine.h"
#include "memory.h"
#include "wrappers.h"
#include "ClassSizeFixer.h"
#include "EngineHeaderExport.h"
#include <cassert>
#include <unordered_set>

std::pair<bool, uint16> UE_FNameEntry::Info() const {
	auto info = Read<uint16>(object + offsets.FNameEntry.Info);
	auto len = info >> offsets.FNameEntry.LenBit;
	bool wide = (info >> offsets.FNameEntry.WideBit) & 1;
	return { wide, len };
}

std::string UE_FNameEntry::String(bool wide, uint16 len) const {
	if (wide) {
		wchar_t wbuf[1024]{};
		Read(object + offsets.FNameEntry.HeaderSize, wbuf, len * 2ull);
		return WideStringToUTF8(wbuf);
	}
	else {
		char buf[1024]{};
		Read(object + offsets.FNameEntry.HeaderSize, buf, len);
		if (Decrypt_ANSI) {
			Decrypt_ANSI(buf, len);
		}
		return std::string(buf);
	}
}

void UnicodeToUTF8(const std::wstring& str, std::string& out)
{
	int len = WideCharToMultiByte(CP_UTF8, 0, str.c_str(), static_cast<int>(str.length()), nullptr, 0, nullptr, nullptr);
	out.resize(len);
	WideCharToMultiByte(CP_UTF8, 0, str.c_str(), static_cast<int>(str.length()), const_cast<LPSTR>(out.data()), len, nullptr, nullptr);
}

void UTF8ToUnicode(const std::string& str, std::wstring& out)
{
	int len = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), static_cast<int>(str.length()), nullptr, 0);
	out.resize(len);
	MultiByteToWideChar(CP_UTF8, 0, str.c_str(), static_cast<int>(str.length()), const_cast<LPWSTR>(out.data()), len);
}

std::string UE_FNameEntry::WideStringToUTF8(const wchar_t* wideString)
{
	if (wideString == nullptr)
		return "";
	std::string retval{};
	UnicodeToUTF8(wideString, retval);
	return retval;
	//std::wstring str(wideString);
	//// 获取转换后的字符串长度（包括终止null字符）
	//int utf8Length = WideCharToMultiByte(CP_UTF8, 0, str.c_str(), str.size(), nullptr, 0, nullptr, nullptr);

	//if (utf8Length == 0)
	//	return "";

	//// 分配内存来保存转换后的UTF-8字符串
	//char* utf8Buffer = new char[utf8Length];

	//// 进行实际的转换
	//WideCharToMultiByte(CP_UTF8, 0, str.c_str(), str.size(), utf8Buffer, utf8Length, nullptr, nullptr);

	//// 创建std::string并将转换后的UTF-8数据拷贝进去
	//std::string utf8String(utf8Buffer);

	//// 释放内存
	//delete[] utf8Buffer;

	//return utf8String;
}

void UE_FNameEntry::String(char* buf, bool wide, uint16 len) const {
	std::string tmp = String(wide, len);
	strcpy_s(buf, 1024, tmp.c_str());
}

std::string UE_FNameEntry::String() const {
	auto [wide, len] = this->Info();
	return this->String(wide, len);
}

uint16 UE_FNameEntry::Size(bool wide, uint16 len) {
	uint16 bytes = offsets.FNameEntry.HeaderSize + len * (wide ? 2 : 1);
	return (bytes + offsets.Stride - 1u) & ~(offsets.Stride - 1u);
}

std::string UE_FName::GetName() const {
	uint32 index = Read<uint32>(object);
	auto entry = UE_FNameEntry(NamePoolData.GetEntry(index));
	if (!entry) return std::string();
	auto [wide, len] = entry.Info();
	auto name = entry.String(wide, len);
	uint32 number = Read<uint32>(object + offsets.FName.Number);
	if (number > 0) {
		name += '_' + std::to_string(number);
	}
	auto pos = name.rfind('/');
	if (pos != std::string::npos) {
		name = name.substr(pos + 1);
	}
	return name;
}

uint32 UE_UObject::GetIndex() const {
	return Read<uint32>(object + offsets.UObject.Index);
};

UE_UClass UE_UObject::GetClass() const {
	return Read<UE_UClass>(object + offsets.UObject.Class);
}

UE_UObject UE_UObject::GetOuter() const {
	return Read<UE_UObject>(object + offsets.UObject.Outer);
}

UE_UObject UE_UObject::GetPackageObject() const {
	UE_UObject package(nullptr);
	for (auto outer = GetOuter(); outer; outer = outer.GetOuter()) {
		package = outer;
	}
	return package;
}

std::string UE_UObject::GetName() const {
	auto fname = UE_FName(object + offsets.UObject.Name);
	return fname.GetName();
}

std::string UE_UObject::GetFullName() const {
	std::string temp;
	for (auto outer = GetOuter(); outer; outer = outer.GetOuter()) {
		temp = outer.GetName() + "." + temp;
	}
	UE_UClass objectClass = GetClass();
	std::string name = objectClass.GetName() + " " + temp + GetName();
	return name;
}

std::string UE_UObject::GetCppName() const {
	std::string name;
	if (IsA<UE_UClass>()) {
		for (auto c = Cast<UE_UStruct>(); c; c = c.GetSuper()) {
			if (c == UE_AActor::StaticClass()) {
				name = "A";
				break;
			}
			else if (c == UE_UObject::StaticClass()) {
				name = "U";
				break;
			}
		}
	}
	else {
		name = "F";
	}

	name += GetName();
	return name;
}

bool UE_UObject::IsA(UE_UClass cmp) const {
	for (auto super = GetClass(); super; super = super.GetSuper().Cast<UE_UClass>()) {
		if (super == cmp) {
			return true;
		}
	}

	return false;
}

UE_UClass UE_UObject::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.Object"));
	return obj;
};

UE_UClass UE_AActor::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class Engine.Actor"));
	return obj;
}

UE_UField UE_UField::GetNext() const {
	return Read<UE_UField>(object + offsets.UField.Next);
}

UE_UClass UE_UField::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.Field"));
	return obj;
};

std::string IUProperty::GetName() const {
	return ((UE_UProperty*)(this->prop))->GetName();
}

int32 IUProperty::GetArrayDim() const {
	return ((UE_UProperty*)(this->prop))->GetArrayDim();
}

int32 IUProperty::GetSize() const {
	return ((UE_UProperty*)(this->prop))->GetSize();
}

int32 IUProperty::GetOffset() const {
	return ((UE_UProperty*)(this->prop))->GetOffset();
}

uint64 IUProperty::GetPropertyFlags() const {
	return ((UE_UProperty*)(this->prop))->GetPropertyFlags();
}

std::pair<PropertyType, std::string> IUProperty::GetType() const {
	return ((UE_UProperty*)(this->prop))->GetType();
}

uint8 IUProperty::GetFieldMask() const {
	return ((UE_UBoolProperty*)(this->prop))->GetFieldMask();
}

int32 UE_UProperty::GetArrayDim() const {
	return Read<int32>(object + offsets.UProperty.ArrayDim);
}

int32 UE_UProperty::GetSize() const {
	return Read<int32>(object + offsets.UProperty.ElementSize);
}

int32 UE_UProperty::GetOffset() const {
	return Read<int32>(object + offsets.UProperty.Offset);
}

uint64 UE_UProperty::GetPropertyFlags() const {
	return Read<uint64>(object + offsets.UProperty.PropertyFlags);
}

std::pair<PropertyType, std::string> UE_UProperty::GetType() const {
	if (IsA<UE_UDoubleProperty>()) { return { PropertyType::DoubleProperty,Cast<UE_UDoubleProperty>().GetTypeStr() }; };
	if (IsA<UE_UFloatProperty>()) { return { PropertyType::FloatProperty, Cast<UE_UFloatProperty>().GetTypeStr() }; };
	if (IsA<UE_UIntProperty>()) { return { PropertyType::IntProperty, Cast<UE_UIntProperty>().GetTypeStr() }; };
	if (IsA<UE_UInt16Property>()) { return { PropertyType::Int16Property,Cast<UE_UInt16Property>().GetTypeStr() }; };
	if (IsA<UE_UInt64Property>()) { return { PropertyType::Int64Property, Cast<UE_UInt64Property>().GetTypeStr() }; };
	if (IsA<UE_UInt8Property>()) { return { PropertyType::Int8Property, Cast<UE_UInt8Property>().GetTypeStr() }; };
	if (IsA<UE_UUInt16Property>()) { return { PropertyType::UInt16Property, Cast<UE_UUInt16Property>().GetTypeStr() }; };
	if (IsA<UE_UUInt32Property>()) { return { PropertyType::UInt32Property, Cast<UE_UUInt32Property>().GetTypeStr() }; }
	if (IsA<UE_UUInt64Property>()) { return { PropertyType::UInt64Property, Cast<UE_UUInt64Property>().GetTypeStr() }; };
	if (IsA<UE_UTextProperty>()) { return { PropertyType::TextProperty, Cast<UE_UTextProperty>().GetTypeStr() }; }
	if (IsA<UE_UStrProperty>()) { return { PropertyType::TextProperty, Cast<UE_UStrProperty>().GetTypeStr() }; };
	if (IsA<UE_UClassProperty>()) { return { PropertyType::ClassProperty, Cast<UE_UClassProperty>().GetTypeStr() }; };
	if (IsA<UE_UStructProperty>()) { return { PropertyType::StructProperty, Cast<UE_UStructProperty>().GetTypeStr() }; };
	if (IsA<UE_UNameProperty>()) { return { PropertyType::NameProperty, Cast<UE_UNameProperty>().GetTypeStr() }; };
	if (IsA<UE_UBoolProperty>()) { return { PropertyType::BoolProperty, Cast<UE_UBoolProperty>().GetTypeStr() }; }
	if (IsA<UE_UByteProperty>()) { return { PropertyType::ByteProperty, Cast<UE_UByteProperty>().GetTypeStr() }; };
	if (IsA<UE_UArrayProperty>()) { return { PropertyType::ArrayProperty, Cast<UE_UArrayProperty>().GetTypeStr() }; };
	if (IsA<UE_UEnumProperty>()) { return { PropertyType::EnumProperty, Cast<UE_UEnumProperty>().GetTypeStr() }; };
	if (IsA<UE_USetProperty>()) { return { PropertyType::SetProperty, Cast<UE_USetProperty>().GetTypeStr() }; };
	if (IsA<UE_UMapProperty>()) { return { PropertyType::MapProperty, Cast<UE_UMapProperty>().GetTypeStr() }; };
	if (IsA<UE_UInterfaceProperty>()) { return { PropertyType::InterfaceProperty, Cast<UE_UInterfaceProperty>().GetTypeStr() }; };
	if (IsA<UE_UMulticastDelegateProperty>()) { return { PropertyType::MulticastDelegateProperty, Cast<UE_UMulticastDelegateProperty>().GetTypeStr() }; };
	if (IsA<UE_UWeakObjectProperty>()) { return { PropertyType::WeakObjectProperty, Cast<UE_UWeakObjectProperty>().GetTypeStr() }; };
	if (IsA<UE_UObjectPropertyBase>()) { return { PropertyType::ObjectProperty, Cast<UE_UObjectPropertyBase>().GetTypeStr() }; };
	return { PropertyType::Unknown, GetClass().GetName() };
}

IUProperty UE_UProperty::GetInterface() const { return IUProperty(this); }

UE_UClass UE_UProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.Property"));
	return obj;
}

UE_UStruct UE_UStruct::GetSuper() const {
	return Read<UE_UStruct>(object + offsets.UStruct.SuperStruct);
}

UE_FField UE_UStruct::GetChildProperties() const {
	if (offsets.UStruct.ChildProperties) return Read<UE_FField>(object + offsets.UStruct.ChildProperties);
	else return nullptr;
}

UE_UField UE_UStruct::GetChildren() const {
	return Read<UE_UField>(object + offsets.UStruct.Children);
}

int32 UE_UStruct::GetSize() const {
	return Read<int32>(object + offsets.UStruct.PropertiesSize);
};

UE_UClass UE_UStruct::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.Struct"));
	return obj;
};

uint64 UE_UFunction::GetFunc() const {
	return Read<uint64>(object + offsets.UFunction.Func);
}

uint32 UE_UFunction::GetFunctionFlagInt() const {
	auto flags = Read<uint32>(object + offsets.UFunction.FunctionFlags);
	return flags;
}

void GetFlagOutVector(uint32 flag, std::vector<std::string>& out) {
	auto flags = flag;
	if (flags == FUNC_None) {
		out.push_back("None");
		return;
	}
	else {
		if (flags & FUNC_Final) {
			out.push_back("Final");
		}
		if (flags & FUNC_RequiredAPI) {
			out.push_back("RequiredAPI");
		}
		if (flags & FUNC_BlueprintAuthorityOnly) {
			out.push_back("BlueprintAuthorityOnly");
		}
		if (flags & FUNC_BlueprintCosmetic) {
			out.push_back("BlueprintCosmetic");
		}
		if (flags & FUNC_Net) {
			out.push_back("Net");
		}
		if (flags & FUNC_NetReliable) {
			out.push_back("NetReliable");
		}
		if (flags & FUNC_NetRequest) {
			out.push_back("NetRequest");
		}
		if (flags & FUNC_Exec) {
			out.push_back("Exec");
		}
		if (flags & FUNC_Native) {
			out.push_back("Native");
		}
		if (flags & FUNC_Event) {
			out.push_back("Event");
		}
		if (flags & FUNC_NetResponse) {
			out.push_back("NetResponse");
		}
		if (flags & FUNC_Static) {
			out.push_back("Static");
		}
		if (flags & FUNC_NetMulticast) {
			out.push_back("NetMulticast");
		}
		if (flags & FUNC_UbergraphFunction) {
			out.push_back("UbergraphFunction");
		}
		if (flags & FUNC_MulticastDelegate) {
			out.push_back("MulticastDelegate");
		}
		if (flags & FUNC_Public) {
			out.push_back("Public");
		}
		if (flags & FUNC_Private) {
			out.push_back("Private");
		}
		if (flags & FUNC_Protected) {
			out.push_back("Protected");
		}
		if (flags & FUNC_Delegate) {
			out.push_back("Delegate");
		}
		if (flags & FUNC_NetServer) {
			out.push_back("NetServer");
		}
		if (flags & FUNC_HasOutParms) {
			out.push_back("HasOutParms");
		}
		if (flags & FUNC_HasDefaults) {
			out.push_back("HasDefaults");
		}
		if (flags & FUNC_NetClient) {
			out.push_back("NetClient");
		}
		if (flags & FUNC_DLLImport) {
			out.push_back("DLLImport");
		}
		if (flags & FUNC_BlueprintCallable) {
			out.push_back("BlueprintCallable");
		}
		if (flags & FUNC_BlueprintEvent) {
			out.push_back("BlueprintEvent");
		}
		if (flags & FUNC_BlueprintPure) {
			out.push_back("BlueprintPure");
		}
		if (flags & FUNC_EditorOnly) {
			out.push_back("EditorOnly");
		}
		if (flags & FUNC_Const) {
			out.push_back("Const");
		}
		if (flags & FUNC_NetValidate) {
			out.push_back("NetValidate");
		}
	}
}

std::string UE_UFunction::GetFunctionFlags() const {
	auto flags = Read<uint32>(object + offsets.UFunction.FunctionFlags);
	std::string result;
	if (flags == FUNC_None) {
		result = "None";
	}
	else {
		if (flags & FUNC_Final) {
			result += "Final|";
		}
		if (flags & FUNC_RequiredAPI) {
			result += "RequiredAPI|";
		}
		if (flags & FUNC_BlueprintAuthorityOnly) {
			result += "BlueprintAuthorityOnly|";
		}
		if (flags & FUNC_BlueprintCosmetic) {
			result += "BlueprintCosmetic|";
		}
		if (flags & FUNC_Net) {
			result += "Net|";
		}
		if (flags & FUNC_NetReliable) {
			result += "NetReliable";
		}
		if (flags & FUNC_NetRequest) {
			result += "NetRequest|";
		}
		if (flags & FUNC_Exec) {
			result += "Exec|";
		}
		if (flags & FUNC_Native) {
			result += "Native|";
		}
		if (flags & FUNC_Event) {
			result += "Event|";
		}
		if (flags & FUNC_NetResponse) {
			result += "NetResponse|";
		}
		if (flags & FUNC_Static) {
			result += "Static|";
		}
		if (flags & FUNC_NetMulticast) {
			result += "NetMulticast|";
		}
		if (flags & FUNC_UbergraphFunction) {
			result += "UbergraphFunction|";
		}
		if (flags & FUNC_MulticastDelegate) {
			result += "MulticastDelegate|";
		}
		if (flags & FUNC_Public) {
			result += "Public|";
		}
		if (flags & FUNC_Private) {
			result += "Private|";
		}
		if (flags & FUNC_Protected) {
			result += "Protected|";
		}
		if (flags & FUNC_Delegate) {
			result += "Delegate|";
		}
		if (flags & FUNC_NetServer) {
			result += "NetServer|";
		}
		if (flags & FUNC_HasOutParms) {
			result += "HasOutParms|";
		}
		if (flags & FUNC_HasDefaults) {
			result += "HasDefaults|";
		}
		if (flags & FUNC_NetClient) {
			result += "NetClient|";
		}
		if (flags & FUNC_DLLImport) {
			result += "DLLImport|";
		}
		if (flags & FUNC_BlueprintCallable) {
			result += "BlueprintCallable|";
		}
		if (flags & FUNC_BlueprintEvent) {
			result += "BlueprintEvent|";
		}
		if (flags & FUNC_BlueprintPure) {
			result += "BlueprintPure|";
		}
		if (flags & FUNC_EditorOnly) {
			result += "EditorOnly|";
		}
		if (flags & FUNC_Const) {
			result += "Const|";
		}
		if (flags & FUNC_NetValidate) {
			result += "NetValidate|";
		}
		if (result.size()) {
			result.erase(result.size() - 1);
		}
	}
	return result;
}

UE_UClass UE_UFunction::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.Function"));
	return obj;
}

UE_UClass UE_UScriptStruct::StaticClass() {
	static UE_UClass obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.ScriptStruct"));
	return obj;
};

UE_UClass UE_UClass::StaticClass() {
	static UE_UClass obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.Class"));
	return obj;
};

TArray UE_UEnum::GetNames() const {
	return Read<TArray>(object + offsets.UEnum.Names);
}

UE_UClass UE_UEnum::StaticClass() {
	static UE_UClass obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.Enum"));
	return obj;
}

std::string UE_UDoubleProperty::GetTypeStr() const { return "double"; }

UE_UClass UE_UDoubleProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.DoubleProperty"));
	return obj;
}

UE_UStruct UE_UStructProperty::GetStruct() const {
	return Read<UE_UStruct>(object + offsets.UProperty.Size);
}

std::string UE_UStructProperty::GetTypeStr() const {
	return "struct " + GetStruct().GetCppName();
}

UE_UClass UE_UStructProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.StructProperty"));
	return obj;
}

std::string UE_UNameProperty::GetTypeStr() const { return "struct FName"; }

UE_UClass UE_UNameProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.NameProperty"));
	return obj;
}

UE_UClass UE_UObjectPropertyBase::GetPropertyClass() const {
	return Read<UE_UClass>(object + offsets.UProperty.Size);
}

std::string UE_UObjectPropertyBase::GetTypeStr() const {
	return "struct " + GetPropertyClass().GetCppName() + "*";
}

UE_UClass UE_UObjectPropertyBase::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.ObjectPropertyBase"));
	return obj;
}

UE_UProperty UE_UArrayProperty::GetInner() const {
	return Read<UE_UProperty>(object + offsets.UProperty.Size);
}

std::string UE_UArrayProperty::GetTypeStr() const {
	return "struct TArray<" + GetInner().GetType().second + ">";
}

UE_UClass UE_UArrayProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.ArrayProperty"));
	return obj;
}

UE_UEnum UE_UByteProperty::GetEnum() const {
	return Read<UE_UEnum>(object + offsets.UProperty.Size);
}

std::string UE_UByteProperty::GetTypeStr() const {
	auto e = GetEnum();
	if (e) return "enum class " + e.GetName();
	return "char";
}

UE_UClass UE_UByteProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.ByteProperty"));
	return obj;
}

uint8 UE_UBoolProperty::GetFieldMask() const {
	return Read<uint8>(object + offsets.UProperty.Size + 3);
}

std::string UE_UBoolProperty::GetTypeStr() const {
	if (GetFieldMask() == 0xFF) {
		return "bool";
	};
	return "char";
}

UE_UClass UE_UBoolProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.BoolProperty"));
	return obj;
}

std::string UE_UFloatProperty::GetTypeStr() const { return "float"; }

UE_UClass UE_UFloatProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.FloatProperty"));
	return obj;
}

std::string UE_UIntProperty::GetTypeStr() const { return "int"; }

UE_UClass UE_UIntProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.IntProperty"));
	return obj;
}

std::string UE_UInt16Property::GetTypeStr() const { return "int16"; }

UE_UClass UE_UInt16Property::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.Int16Property"));
	return obj;
}

std::string UE_UInt64Property::GetTypeStr() const { return "int64"; }

UE_UClass UE_UInt64Property::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.Int64Property"));
	return obj;
}

std::string UE_UInt8Property::GetTypeStr() const { return "uint8"; }

UE_UClass UE_UInt8Property::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.Int8Property"));
	return obj;
}

std::string UE_UUInt16Property::GetTypeStr() const { return "uint16"; }

UE_UClass UE_UUInt16Property::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.UInt16Property"));
	return obj;
}

std::string UE_UUInt32Property::GetTypeStr() const { return "uint32"; }

UE_UClass UE_UUInt32Property::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.UInt32Property"));
	return obj;
}

std::string UE_UUInt64Property::GetTypeStr() const { return "uint64"; }

UE_UClass UE_UUInt64Property::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.UInt64Property"));
	return obj;
}

std::string UE_UTextProperty::GetTypeStr() const { return "struct FText"; }

UE_UClass UE_UTextProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.TextProperty"));
	return obj;
}

std::string UE_UStrProperty::GetTypeStr() const { return "struct FString"; }

UE_UClass UE_UStrProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.StrProperty"));
	return obj;
}

UE_UClass UE_UEnumProperty::GetEnum() const {
	return Read<UE_UClass>(object + offsets.UProperty.Size + 8);
}

std::string UE_UEnumProperty::GetTypeStr() const {
	return "enum class " + GetEnum().GetName();
}

UE_UClass UE_UEnumProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.EnumProperty"));
	return obj;
}

UE_UClass UE_UClassProperty::GetMetaClass() const {
	return Read<UE_UClass>(object + offsets.UProperty.Size + 8);
}

std::string UE_UClassProperty::GetTypeStr() const {
	return "struct " + GetMetaClass().GetCppName() + "*";
}

UE_UClass UE_UClassProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.ClassProperty"));
	return obj;
}

UE_UProperty UE_USetProperty::GetElementProp() const {
	return Read<UE_UProperty>(object + offsets.UProperty.Size);
}

std::string UE_USetProperty::GetTypeStr() const {
	return "struct TSet<" + GetElementProp().GetType().second + ">";
}

UE_UClass UE_USetProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.SetProperty"));
	return obj;
}

UE_UProperty UE_UMapProperty::GetKeyProp() const {
	return Read<UE_UProperty>(object + offsets.UProperty.Size);
}

UE_UProperty UE_UMapProperty::GetValueProp() const {
	return Read<UE_UProperty>(object + offsets.UProperty.Size + 8);
}

std::string UE_UMapProperty::GetTypeStr() const {
	return fmt::format("struct TMap<{}, {}>", GetKeyProp().GetType().second, GetValueProp().GetType().second);
}

UE_UClass UE_UMapProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.MapProperty"));
	return obj;
}

UE_UProperty UE_UInterfaceProperty::GetInterfaceClass() const {
	return Read<UE_UProperty>(object + offsets.UProperty.Size);
}

std::string UE_UInterfaceProperty::GetTypeStr() const {
	return "struct TScriptInterface<" + GetInterfaceClass().GetType().second + ">";
}

UE_UClass UE_UInterfaceProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.InterfaceProperty"));
	return obj;
}

std::string UE_UMulticastDelegateProperty::GetTypeStr() const {
	return "struct FScriptMulticastDelegate";
}

UE_UClass UE_UMulticastDelegateProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.MulticastDelegateProperty"));
	return obj;
}

std::string UE_UWeakObjectProperty::GetTypeStr() const {
	return "struct TWeakObjectPtr<" + this->Cast<UE_UStructProperty>().GetTypeStr() + ">";
}

UE_UClass UE_UWeakObjectProperty::StaticClass() {
	static auto obj = (UE_UClass)(ObjObjects.FindObject("Class CoreUObject.WeakObjectProperty"));
	return obj;
}

std::string UE_FFieldClass::GetName() const {
	auto name = UE_FName(object);
	return name.GetName();
}

UE_FField UE_FField::GetNext() const {
	return Read<UE_FField>(object + offsets.FField.Next);
};

std::string UE_FField::GetName() const {
	auto name = UE_FName(object + offsets.FField.Name);
	return name.GetName();
}

std::string IFProperty::GetName() const {
	return ((UE_FProperty*)prop)->GetName();
}

int32 IFProperty::GetArrayDim() const {
	return ((UE_FProperty*)prop)->GetArrayDim();
}

int32 IFProperty::GetSize() const { return ((UE_FProperty*)prop)->GetSize(); }

int32 IFProperty::GetOffset() const {
	return ((UE_FProperty*)prop)->GetOffset();
}

uint64 IFProperty::GetPropertyFlags() const {
	return ((UE_FProperty*)prop)->GetPropertyFlags();
}

std::pair<PropertyType, std::string> IFProperty::GetType() const {
	return ((UE_FProperty*)prop)->GetType();
}

uint8 IFProperty::GetFieldMask() const {
	return ((UE_FBoolProperty*)prop)->GetFieldMask();
}

int32 UE_FProperty::GetArrayDim() const {
	return Read<int32>(object + offsets.FProperty.ArrayDim);
}

int32 UE_FProperty::GetSize() const {
	return Read<int32>(object + offsets.FProperty.ElementSize);
}

int32 UE_FProperty::GetOffset() const {
	return Read<int32>(object + offsets.FProperty.Offset);
}

uint64 UE_FProperty::GetPropertyFlags() const {
	return Read<uint64>(object + offsets.FProperty.PropertyFlags);
}

type UE_FProperty::GetType() const {
	auto objectClass = Read<UE_FFieldClass>(object + offsets.FField.Class);
	type type = { PropertyType::Unknown, objectClass.GetName() };

	auto& str = type.second;
	auto hash = Hash(str.c_str(), str.size());
	switch (hash) {
	case HASH("StructProperty"): {
		auto obj = this->Cast<UE_FStructProperty>();
		type = { PropertyType::StructProperty, obj.GetTypeStr() };
		break;
	}
	case HASH("ObjectProperty"): {
		auto obj = this->Cast<UE_FObjectPropertyBase>();
		type = { PropertyType::ObjectProperty, obj.GetTypeStr() };
		break;
	}
	case HASH("SoftObjectProperty"): {
		auto obj = this->Cast<UE_FObjectPropertyBase>();
		type = { PropertyType::SoftObjectProperty, "struct TSoftObjectPtr<" + obj.GetPropertyClass().GetCppName() + ">" };
		break;
	}
	case HASH("FloatProperty"): {
		type = { PropertyType::FloatProperty, "float" };
		break;
	}
	case HASH("ByteProperty"): {
		auto obj = this->Cast<UE_FByteProperty>();
		type = { PropertyType::ByteProperty, obj.GetTypeStr() };
		break;
	}
	case HASH("BoolProperty"): {
		auto obj = this->Cast<UE_FBoolProperty>();
		type = { PropertyType::BoolProperty, obj.GetTypeStr() };
		break;
	}
	case HASH("IntProperty"): {
		type = { PropertyType::IntProperty, "int32_t" };
		break;
	}
	case HASH("Int8Property"): {
		type = { PropertyType::Int8Property, "int8_t" };
		break;
	}
	case HASH("Int16Property"): {
		type = { PropertyType::Int16Property, "int16_t" };
		break;
	}
	case HASH("Int64Property"): {
		type = { PropertyType::Int64Property, "int64_t" };
		break;
	}
	case HASH("UInt16Property"): {
		type = { PropertyType::UInt16Property, "uint16_t" };
		break;
	}
	case HASH("UInt32Property"): {
		type = { PropertyType::UInt32Property, "uint32_t" };
		break;
	}
	case HASH("UInt64Property"): {
		type = { PropertyType::UInt64Property, "uint64_t" };
		break;
	}
	case HASH("NameProperty"): {
		type = { PropertyType::NameProperty, "struct FName" };
		break;
	}
	case HASH("DelegateProperty"): {
		type = { PropertyType::DelegateProperty, "struct FDelegate" };
		break;
	}
	case HASH("SetProperty"): {
		auto obj = this->Cast<UE_FSetProperty>();
		type = { PropertyType::SetProperty, obj.GetTypeStr() };
		break;
	}
	case HASH("ArrayProperty"): {
		auto obj = this->Cast<UE_FArrayProperty>();
		type = { PropertyType::ArrayProperty, obj.GetTypeStr() };
		break;
	}
	case HASH("WeakObjectProperty"): {
		auto obj = this->Cast<UE_FStructProperty>();
		type = { PropertyType::WeakObjectProperty, "struct TWeakObjectPtr<" + obj.GetTypeStr() + ">" };

		break;
	}
	case HASH("StrProperty"): {
		type = { PropertyType::StrProperty, "struct FString" };
		break;
	}
	case HASH("TextProperty"): {
		type = { PropertyType::TextProperty, "struct FText" };
		break;
	}
	case HASH("MulticastSparseDelegateProperty"): {
		type = { PropertyType::MulticastSparseDelegateProperty, "struct FMulticastSparseDelegate" };
		break;
	}
	case HASH("EnumProperty"): {
		auto obj = this->Cast<UE_FEnumProperty>();
		type = { PropertyType::EnumProperty, obj.GetTypeStr() };
		break;
	}
	case HASH("DoubleProperty"): {
		type = { PropertyType::DoubleProperty, "double" };
		break;
	}
	case HASH("MulticastDelegateProperty"): {
		type = { PropertyType::MulticastDelegateProperty, "FMulticastDelegate" };
		break;
	}
	case HASH("ClassProperty"): {
		auto obj = this->Cast<UE_FClassProperty>();
		type = { PropertyType::ClassProperty, obj.GetTypeStr() };
		break;
	}
	case HASH("MulticastInlineDelegateProperty"): {
		type = { PropertyType::MulticastDelegateProperty, "struct FMulticastInlineDelegate" };
		break;
	}
	case HASH("MapProperty"): {
		auto obj = this->Cast<UE_FMapProperty>();
		type = { PropertyType::MapProperty, obj.GetTypeStr() };
		break;
	}
	case HASH("InterfaceProperty"): {
		auto obj = this->Cast<UE_FInterfaceProperty>();
		type = { PropertyType::InterfaceProperty, obj.GetTypeStr() };
		break;
	}
	case HASH("FieldPathProperty"): {
		auto obj = this->Cast<UE_FFieldPathProperty>();
		type = { PropertyType::FieldPathProperty, obj.GetTypeStr() };
		break;
	}
	case HASH("SoftClassProperty"): {
		type = { PropertyType::SoftClassProperty, "struct TSoftClassPtr<UObject>" };
		break;
	}
	}

	return type;
}

IFProperty UE_FProperty::GetInterface() const { return IFProperty(this); }

UE_UStruct UE_FStructProperty::GetStruct() const {
	return Read<UE_UStruct>(object + offsets.FProperty.Size);
}

std::string UE_FStructProperty::GetTypeStr() const {
	return "struct " + GetStruct().GetCppName();
}

UE_UClass UE_FObjectPropertyBase::GetPropertyClass() const {
	return Read<UE_UClass>(object + offsets.FProperty.Size);
}

std::string UE_FObjectPropertyBase::GetTypeStr() const {
	return "struct " + GetPropertyClass().GetCppName() + "*";
}

UE_FProperty UE_FArrayProperty::GetInner() const {
	return Read<UE_FProperty>(object + offsets.FProperty.Size);
}

std::string UE_FArrayProperty::GetTypeStr() const {
	return "struct TArray<" + GetInner().GetType().second + ">";
}

UE_UEnum UE_FByteProperty::GetEnum() const {
	return Read<UE_UEnum>(object + offsets.FProperty.Size);
}

std::string UE_FByteProperty::GetTypeStr() const {
	auto e = GetEnum();
	if (e) return "enum class " + e.GetName();
	return "char";
}

uint8 UE_FBoolProperty::GetFieldMask() const {
	return Read<uint8>(object + offsets.FProperty.Size + 3);
}

std::string UE_FBoolProperty::GetTypeStr() const {
	if (GetFieldMask() == 0xFF) {
		return "bool";
	};
	return "char";
}

UE_UClass UE_FEnumProperty::GetEnum() const {
	return Read<UE_UClass>(object + offsets.FProperty.Size + 8);
}

std::string UE_FEnumProperty::GetTypeStr() const {
	return "enum class " + GetEnum().GetName();
}

UE_UClass UE_FClassProperty::GetMetaClass() const {
	return Read<UE_UClass>(object + offsets.FProperty.Size);
}

std::string UE_FClassProperty::GetTypeStr() const {
	return "struct " + GetMetaClass().GetCppName() + "*";
}

UE_FProperty UE_FSetProperty::GetElementProp() const {
	return Read<UE_FProperty>(object + offsets.FProperty.Size);
}

std::string UE_FSetProperty::GetTypeStr() const {
	return "struct TSet<" + GetElementProp().GetType().second + ">";
}

UE_FProperty UE_FMapProperty::GetKeyProp() const {
	return Read<UE_FProperty>(object + offsets.FProperty.Size);
}

UE_FProperty UE_FMapProperty::GetValueProp() const {
	return Read<UE_FProperty>(object + offsets.FProperty.Size + 8);
}

std::string UE_FMapProperty::GetTypeStr() const {
	return fmt::format("struct TMap<{}, {}>", GetKeyProp().GetType().second, GetValueProp().GetType().second);
}

UE_UClass UE_FInterfaceProperty::GetInterfaceClass() const {
	return Read<UE_UClass>(object + offsets.FProperty.Size);
}

std::string UE_FInterfaceProperty::GetTypeStr() const {
	return "struct TScriptInterface<I" + GetInterfaceClass().GetName() + ">";
}

UE_FName UE_FFieldPathProperty::GetPropertyName() const {
	return Read<UE_FName>(object + offsets.FProperty.Size);
}

std::string UE_FFieldPathProperty::GetTypeStr() const {
	return "struct TFieldPath<F" + GetPropertyName().GetName() + ">";
}

void UE_UPackage::GenerateBitPadding(std::vector<Member>& members, uint32 offset, uint8 bitOffset, uint8 size) {
	Member padding;
	padding.Type = "char";
	padding.Name = fmt::format("pad_{:0X}_{} : {}", offset, bitOffset, size);
	padding.Offset = offset;
	padding.Size = 1;
	members.push_back(padding);
}

void UE_UPackage::GeneratePadding(std::vector<Member>& members, uint32 offset, uint32 size) {
	Member padding;
	padding.Type = "char";
	padding.Name = fmt::format("pad_{:0X}[{:#0x}]", offset, size);
	padding.Offset = offset;
	padding.Size = size;
	members.push_back(padding);
}

void UE_UPackage::FillPadding(UE_UStruct object, std::vector<Member>& members, uint32& offset, uint8& bitOffset, uint32 end, bool findPointers) {
	if (bitOffset && bitOffset < 8) {
		UE_UPackage::GenerateBitPadding(members, offset, bitOffset, 8 - bitOffset);
		bitOffset = 0;
		offset++;
	}

	auto size = end - offset;
	if (findPointers && size >= 8) {

		auto normalizedOffset = (offset + 7) & ~7;

		if (normalizedOffset != offset) {
			auto diff = normalizedOffset - offset;
			GeneratePadding(members, offset, diff);
			offset += diff;
		}

		auto normalizedSize = size - size % 8;

		auto num = normalizedSize / 8;

		uint64* pointers = new uint64[num * 2]();
		uint64* buffer = pointers + num;

		uint32 found = 0;
		auto callback = [&](UE_UObject object) {

			auto address = (uint64*)((uint64)object.GetAddress() + offset);

			Read(address, buffer, normalizedSize);

			for (uint32 i = 0; i < num; i++) {

				if (pointers[i]) continue;

				auto ptr = buffer[i];
				if (!ptr) continue;

				uint64 vftable;
				if (Read((void*)ptr, &vftable, 8)) {
					pointers[i] = ptr;
				}
				else {
					pointers[i] = (uint64)-1;
				}

				found++;
			}

			if (found == num) return true;

			return false;

			};

		ObjObjects.ForEachObjectOfClass((UE_UClass)object, callback);

		auto start = offset;
		for (uint32 i = 0; i < num; i++) {
			auto ptr = pointers[i];
			if (ptr && ptr != (uint64)-1) {

				auto ptrObject = UE_UObject((void*)ptr);

				auto ptrOffset = start + i * 8;
				if (ptrOffset > offset) {
					GeneratePadding(members, offset, ptrOffset - offset);
					offset = ptrOffset;
				}

				Member m;
				m.Offset = offset;
				m.Size = 8;

				if (ptrObject.IsA<UE_UObject>()) {
					m.Type = "struct " + ptrObject.GetClass().GetCppName() + "*";
					m.Name = ptrObject.GetName();
				}
				else {
					m.Type = "void*";
					m.Name = fmt::format("ptr_{:x}", ptr);
				}


				members.push_back(m);

				offset += 8;
			}
		}
		delete[] pointers;

	}


	if (offset != end) {
		GeneratePadding(members, offset, end - offset);
		offset = end;
	}
}

void UE_UPackage::GenerateFunction(UE_UFunction fn, Function* out, std::unordered_map<std::string, int>& memberMap) {
	out->FullName = ProcessUTF8Char(fn.GetFullName());
	out->Flags = fn.GetFunctionFlags();
	out->FuncFlag = fn.GetFunctionFlagInt();
	out->Func = fn.GetFunc();
	out->FuncName = fn.GetName();
	out->FuncName = GetValidClassName(ProcessUTF8Char(out->FuncName));
	if (memberMap.count(out->FuncName) > 0) {
		out->FuncName += fmt::format("_{}", ++memberMap[out->FuncName]);
	}
	if (out->FuncFlag & FUNC_Static) {
		out->FuncName = "STATIC_" + out->FuncName;
	}

	std::unordered_map<std::string, int> paramCntMp;
	auto generateParam = [&](IProperty* prop) {

		auto param_offset = prop->GetOffset();
		auto param_size = prop->GetSize();
		auto flags = prop->GetPropertyFlags();
		// if property has 'ReturnParm' flag
		if (flags & 0x400) {
			ParamInfo retInfo;
			out->RetType = prop->GetType().second;
			retInfo.Name = "ReturnValue";
			retInfo.Offset = param_offset;
			retInfo.Size = param_size;
			retInfo.Type = out->RetType;
			retInfo.flags = flags;
			out->paramInfo.push_back(retInfo);
			out->CppName = prop->GetType().second + " " + out->FuncName;
		}
		// if property has 'Parm' flag
		else if (flags & 0x80) {
			ParamInfo paramInfo;
			out->ParamTypes.push_back(prop->GetType().second);
			auto ParamName = GetValidClassName(prop->GetName());
			if (paramCntMp.count(ParamName) > 0) {
				ParamName += fmt::format("_{}", ++paramCntMp[ParamName]);
			}
			else {
				paramCntMp[ParamName] = 1;
			}
			if (ParamName[0] >= '0' && ParamName[0] <= '9') {
				ParamName = "_" + ParamName;
			}
			paramInfo.Offset = param_offset;
			paramInfo.Size = param_size;
			paramInfo.flags = flags;
			paramInfo.Name = ParamName;
			if (prop->GetArrayDim() > 1) {
				out->Params += fmt::format("{}* {}, ", prop->GetType().second, ParamName);
				paramInfo.Type = fmt::format("{}*", prop->GetType().second);
			}
			else {
				if (flags & 0x100) {
					out->Params += fmt::format("{}& {}, ", prop->GetType().second, ParamName);
					paramInfo.Type = fmt::format("{}&", prop->GetType().second);
				}
				else {
					out->Params += fmt::format("{} {}, ", prop->GetType().second, ParamName);
					paramInfo.Type = prop->GetType().second;
				}
			}
			out->paramInfo.push_back(paramInfo);
		}
		};

	for (auto prop = fn.GetChildProperties().Cast<UE_FProperty>(); prop; prop = prop.GetNext().Cast<UE_FProperty>()) {
		auto propInterface = prop.GetInterface();
		generateParam(&propInterface);
	}
	for (auto prop = fn.GetChildren().Cast<UE_UProperty>(); prop; prop = prop.GetNext().Cast<UE_UProperty>()) {
		auto propInterface = prop.GetInterface();
		generateParam(&propInterface);
	}
	if (out->Params.size()) {
		out->Params.erase(out->Params.size() - 2);
	}

	if (out->CppName.size() == 0) {
		out->RetType = "void";
		out->CppName = "void " + out->FuncName;
	}
}

std::string to_hex_string(int value) {
	std::stringstream stream;
	stream << std::setfill('0') << std::setw(2) << std::hex << value;
	return stream.str();
}

std::string UE_UPackage::ProcessUTF8Char(std::string input) {
	// 移除空字符
	std::string tmp;
	for (char ch : input) {
		if (ch != '\0') {
			tmp += ch;
		}
	}
	std::string result;
	// 转义非法字符
	for (std::size_t i = 0; i < tmp.size(); ++i) {
		char ch = tmp[i];
		if ((ch & 0x80) == 0x00) {
			// Single-byte character (ASCII range)
			result += ch;
		}
		else if ((ch & 0xE0) == 0xC0) {
			// Two-byte character (UTF-8 encoded Chinese character)
			result += ch;
			result += tmp[++i];
		}
		else if ((ch & 0xF0) == 0xE0) {
			// Three-byte character (UTF-8 encoded Chinese character)
			result += ch;
			result += tmp[++i];
			result += tmp[++i];
		}
		else {
			// Not a valid UTF-8 character, replace with byte code
			result += "_x" + to_hex_string(static_cast<unsigned char>(ch));
		}
	}
	return result;
}

std::string UE_UPackage::GetCpp_xString(std::string& input) {
	std::string result = "";
	for (char& c : input) {
		result += "\\x" + to_hex_string(static_cast<unsigned char>(c));
	}
	return result;
}

std::string UE_UPackage::GetValidClassName(std::string str) {
	if (str[0] >= '0' && str[0] <= '9') {
		str = "_" + str;
	}
	// step1: 替换非法的字符
	static const char* Chinese_error_char[] = {
		u8"（",
		u8"）"
	};
	static char chars[] = " /\\:*?\"<>|+().&-=![]{}#\'";
	std::transform(str.begin(), str.end(), str.begin(), [=](char c)->char {
		for (char e_c : chars) {
			if (e_c == c) {
				return '_';
			}
		}
		return c;
		}
	);
	//替换特殊的字符串
	for (auto& i : Chinese_error_char) {
		auto pos = str.find(i);
		if (pos != str.npos) {
			str.replace(pos, strlen(i), u8"_");
		}
	}


	str = ProcessUTF8Char(str);

	return str;
}

// To solve the redefine of the same class name
std::unordered_map<std::string, int> typeDefCnt;

void UE_UPackage::GenerateStruct(UE_UStruct object, std::vector<Struct>& arr, bool findPointers) {
	Struct s;
	//s.Size = object.GetSize();
	if (ClassSizeFixer::sizeMp.count(object.GetAddress()))
		s.Size = ClassSizeFixer::sizeMp[object.GetAddress()]; // Fix the class
	else
		s.Size = object.GetSize();
	if (s.Size == 0) {
		// return;
	}
	s.Inherited = 0;

	s.FullName = ProcessUTF8Char(object.GetFullName());
	s.ClassName = object.GetCppName();

	if (s.ClassName == "UWorld") {
		// 插入Gworld 惊静态成员变量
		Member static_gworld;
		static_gworld.Type = "static class UWorld**";
		static_gworld.Offset = 0;
		static_gworld.Name = "GWorld";
		static_gworld.Size = 8;
		s.Members.push_back(static_gworld);
	}

	if (typeDefCnt.count(s.ClassName)) {
		s.ClassName += fmt::format("_def{}", ++typeDefCnt[s.ClassName]);
	}
	else {
		typeDefCnt[s.ClassName] = 1;
	}

	if (object.IsA<UE_UClass>()) {
		s.CppName = "class " + GetValidClassName(s.ClassName);
	}
	else {
		s.CppName = "struct " + GetValidClassName(s.ClassName);
	}

	s.SuperName = GetValidClassName(object.GetSuper().GetCppName());

	auto super = object.GetSuper();

	if (super) {
		s.CppName += " : public " + s.SuperName;
		//s.Inherited = super.GetSize();
		s.Inherited = ClassSizeFixer::sizeMp[super.GetAddress()];
	}

	uint32 offset = s.Inherited;

	uint8 bitOffset = 0;
	std::unordered_map<std::string, int> memberNameCntMp;
	std::unordered_map<std::string, int> functionNameCntMp;

	auto generateMember = [&](IProperty* prop, Member* m) {
		auto arrDim = prop->GetArrayDim();
		m->Size = prop->GetSize() * arrDim;
		m->isSuspectMember = false;
		if (m->Size == 0) {
			return;
		} // this shouldn't be zero

		auto type = prop->GetType();
		m->Type = type.second;

		m->Name = prop->GetName();

		FixKeywordConflict(m->Name);
		m->Name = GetValidClassName(m->Name);
		m->Offset = prop->GetOffset();

		if (m->Name[0] >= '0' && m->Name[0] <= '9') {
			m->Name = "_" + m->Name;
		}

		if (memberNameCntMp.count(m->Name) > 0) {
			memberNameCntMp[m->Name]++;
			m->Name += fmt::format("_{}", memberNameCntMp[m->Name]);
		}
		else {
			memberNameCntMp[m->Name] = 1;
		}
		if (m->Offset < s.Inherited) {
			// Should be solved by ClassSizeFixer and this will not appear!
			// Impossible situation, but some game still fucking appear
			// mark the member to suspect member, and do not actually use it.
			printf("[Warning] Bad member offset: [%s]->[%s] offset: %X \n", s.FullName.c_str(), m->Name.c_str(), m->Offset);
			m->isSuspectMember = true;
			return;
		}
		if (m->Offset > offset) {
			UE_UPackage::FillPadding(object, s.Members, offset, bitOffset, m->Offset, findPointers);
		}
		if (type.first == PropertyType::BoolProperty && *(uint32*)type.second.data() != 'loob') {
			auto boolProp = prop;
			auto mask = boolProp->GetFieldMask();
			uint8 zeros = 0, ones = 0;
			while (mask & ~1) {
				mask >>= 1;
				zeros++;
			}
			while (mask & 1) {
				mask >>= 1;
				ones++;
			}
			if (zeros > bitOffset) {
				UE_UPackage::GenerateBitPadding(s.Members, offset, bitOffset, zeros - bitOffset);
				bitOffset = zeros;
			}
			m->Name += fmt::format(" : {}", ones);
			bitOffset += ones;

			if (bitOffset == 8) {
				offset++;
				bitOffset = 0;
			}

		}
		else {
			if (arrDim > 1) {
				m->Name += fmt::format("[{:#0x}]", arrDim);
			}

			offset += m->Size;
		}
		};

	for (auto prop = object.GetChildProperties().Cast<UE_FProperty>(); prop; prop = prop.GetNext().Cast<UE_FProperty>()) {
		Member m;
		auto propInterface = prop.GetInterface();
		generateMember(&propInterface, &m);
		s.Members.push_back(m);
	}

	for (auto child = object.GetChildren(); child; child = child.GetNext()) {
		if (child.IsA<UE_UProperty>()) {
			auto prop = child.Cast<UE_UProperty>();
			Member m;
			auto propInterface = prop.GetInterface();
			generateMember(&propInterface, &m);
			s.Members.push_back(m);
		}
	}

	for (auto child = object.GetChildren(); child; child = child.GetNext()) {
		if (child.IsA<UE_UFunction>()) {
			auto fn = child.Cast<UE_UFunction>();
			Function f;
			GenerateFunction(fn, &f, memberNameCntMp);
			// to avoid the repeat function name ...
			if (functionNameCntMp.count(f.FullName) == 0) {
				functionNameCntMp[f.FullName] = 1;
				s.Functions.push_back(f);
			}
		}
	}
	// 如果是USkeletalMeshComponent，则注入GetBoneWorldPos声明
	if (s.ClassName == "USkeletalMeshComponent") {
		Function GetBoneWorldPos_fn;
		GetBoneWorldPos_fn.CppName = "FVector GetBoneWorldPos";
		GetBoneWorldPos_fn.FuncName = "GetBoneWorldPos";
		GetBoneWorldPos_fn.Params = "const int32_t& boneId";
		GetBoneWorldPos_fn.RetType = "FVector";
		GetBoneWorldPos_fn.FullName = "Dumper_Generated_Function";
		GetBoneWorldPos_fn.Func = Base;
		GetBoneWorldPos_fn.declareConst = " const";
		s.Functions.push_back(GetBoneWorldPos_fn);
	}
	// 生成StaticClass方法
	{
		Function static_class_fn;
		static_class_fn.CppName = "static UClass* StaticClass";
		static_class_fn.FuncName = "StaticClass";
		static_class_fn.RetType = "UClass*";
		static_class_fn.FullName = "Dumper_Generated_Function";
		static_class_fn.Func = Base;
		s.Functions.push_back(static_class_fn);
	}

	if (s.Size > offset) {
		UE_UPackage::FillPadding(object, s.Members, offset, bitOffset, s.Size, findPointers);
	}

	arr.push_back(s);
}

void UE_UPackage::FixKeywordConflict(std::string& tocheck) {
	const std::vector<std::string> cppKeyword = {
	  "alignas",
	  "alignof",
	  "and",
	  "and_eq",
	  "asm",
	  "auto",
	  "bitand",
	  "bitor",
	  "bool",
	  "break",
	  "case",
	  "catch",
	  "char",
	  "char16_t",
	  "char32_t",
	  "class",
	  "compl",
	  "concept",
	  "const",
	  "constexpr",
	  "const_cast",
	  "continue",
	  "decltype",
	  "default",
	  "delete",
	  "do",
	  "double",
	  "dynamic_cast",
	  "else",
	  "enum",
	  "explicit",
	  "export",
	  "extern",
	  "false",
	  "float",
	  "for",
	  "friend",
	  "goto",
	  "if",
	  "inline",
	  "int",
	  "long",
	  "mutable",
	  "namespace",
	  "new",
	  "noexcept",
	  "not",
	  "not_eq",
	  "nullptr",
	  "operator",
	  "or",
	  "or_eq",
	  "private",
	  "protected",
	  "public",
	  "register",
	  "reinterpret_cast",
	  "requires",
	  "return",
	  "short",
	  "signed",
	  "sizeof",
	  "static",
	  "static_assert",
	  "static_cast",
	  "struct",
	  "switch",
	  "template",
	  "this",
	  "thread_local",
	  "throw",
	  "true",
	  "try",
	  "typedef",
	  "typeid",
	  "typename",
	  "union",
	  "unsigned",
	  "using",
	  "virtual",
	  "void",
	  "volatile",
	  "wchar_t",
	  "while",
	  "xor",
	  "xor_eq"
	};
	const std::vector<std::string> includeKeyword = {
	  "IGNORE",
	  "ABSOLUTE",
	  "RELATIVE",
	  "DEBUG",
	  "RELEASE"
	};
	for (auto& keyword : cppKeyword) {
		if (tocheck == keyword) {
			tocheck += "_1";
			return;
		}
	}
	for (auto& keyword : includeKeyword) {
		if (tocheck == keyword) {
			tocheck += "_1";
			return;
		}
	}
}

void UE_UPackage::GenerateEnum(UE_UEnum object, std::vector<Enum>& arr) {
	Enum e;
	e.FullName = ProcessUTF8Char(object.GetFullName());

	auto names = object.GetNames();

	uint64 max = 0;
	uint64 nameSize = ((offsets.FName.Number + 4) + 7) & ~(7);
	uint64 pairSize = nameSize + 8;
	std::unordered_map <std::string, size_t>enum_names{};

	for (uint32 i = 0; i < names.Count; i++) {

		auto pair = names.Data + i * pairSize;
		auto name = UE_FName(pair);
		auto str = name.GetName();
		auto pos = str.find_last_of(':');
		if (pos != std::string::npos) {
			str = str.substr(pos + 1);
		}

		//auto value = Read<int64>(pair + nameSize);
		// this read some wrong value, so I force it to be ordered... May be wrong?
		auto value = i;

		if ((uint64)value > max) max = value;

		UE_UPackage::FixKeywordConflict(str);
		//解决重复的enum
		if (enum_names.find(str) == enum_names.end()) {
			enum_names[str] = 0;
		}
		else {
			enum_names[str] += 1;
			auto size = enum_names[str];
			str = fmt::format("{}_{}", str, size);
		}

		str.append(" = ").append(fmt::format("{}", value));

		e.Members.push_back(str);
	}

	const char* type = nullptr;

	// I didn't see int16 yet, so I assume the engine generates only int32 and uint8:
	if (max > 256) {
		type = " : unsigned int"; // I assume if enum has a negative value it is int32
	}
	else {
		type = " : unsigned char";
	}

	e.EnumName = object.GetName();

	e.CppName = "enum class " + object.GetName() + type;

	if (e.Members.size()) {
		arr.push_back(e);
	}
}

void UE_UPackage::SaveStruct(std::vector<Struct>& arr, FILE* file) {
	for (auto& s : arr) {
		fmt::print(file, "// {}\n// Size: {:#04x} (Inherited: {:#04x})\n{} {{\npublic:\n", s.FullName, s.Size, s.Inherited, s.CppName);
		for (auto& m : s.Members) {
			if (m.isSuspectMember) {
				fmt::print(file, "\n\t// {} {}; // Bad member offset! {:#04x}({:#04x})", m.Type, m.Name, m.Offset, m.Size);
			}
			else {
				fmt::print(file, "\n\t{} {}; // {:#04x}({:#04x})", m.Type, m.Name, m.Offset, m.Size);
			}
		}
		if (s.Functions.size()) {
			fwrite("\n", 1, 1, file);
			for (auto& f : s.Functions) {
				fmt::print(file, "\n\t{}({}){}; // {} // ({}) // @ game+{:#08x}", f.CppName, f.Params, f.declareConst, f.FullName, f.Flags, f.Func - Base);
			}
		}
		fmt::print(file, "\n}};\n\n");
	}
}

void UE_UPackage::SaveStructSpacing(std::vector<Struct>& arr, FILE* file) {
	for (auto& s : arr) {
		fmt::print(file, "// {}\n// Size: {:#04x} (Inherited: {:#04x})\n{} {{\npublic:\n", s.FullName, s.Size, s.Inherited, s.CppName);
		for (auto& m : s.Members) {
			if (m.isSuspectMember) {
				fmt::print(file, "\n\t// {:69} {:60} //  Bad member offset! {:#04x}({:#04x})", m.Type, m.Name + ";", m.Offset, m.Size);
			}
			else {
				fmt::print(file, "\n\t{:69} {:60} // {:#04x}({:#04x})", m.Type, m.Name + ";", m.Offset, m.Size);
			}
		}
		if (s.Functions.size()) {
			fwrite("\n", 1, 1, file);
			for (auto& f : s.Functions) {
				fmt::print(file, "\n\t{:130} // {} // ({}) // @ game+{:#08x}", fmt::format("{}({}){};", f.CppName, f.Params, f.declareConst), f.FullName, f.Flags, f.Func - Base);
			}
		}

		fmt::print(file, "\n}};\n\n");
	}
}

void UE_UPackage::SaveEnum(std::vector<Enum>& arr, FILE* file) {
	for (auto& e : arr) {
		fmt::print(file, "// {}\n{} {{", e.FullName, e.CppName);

		auto lastIdx = e.Members.size() - 1;
		for (auto i = 0; i < lastIdx; i++) {
			auto& m = e.Members.at(i);
			fmt::print(file, "\n\t{},", m);
		}

		auto& m = e.Members.at(lastIdx);
		fmt::print(file, "\n\t{}", m);

		fmt::print(file, "\n}};\n\n");
	}
}

void UE_UPackage::Process() {
	auto& objects = Package->second;
	for (auto& object : objects) {
		if (object.IsA<UE_UClass>()) {
			GenerateStruct(object.Cast<UE_UStruct>(), Classes, FindPointers);
		}
		else if (object.IsA<UE_UScriptStruct>()) {
			GenerateStruct(object.Cast<UE_UStruct>(), Structures, false);
		}
		else if (object.IsA<UE_UEnum>()) {
			GenerateEnum(object.Cast<UE_UEnum>(), Enums);
		}
	}
}

void UE_UPackage::AddAlignDef(FILE* file, int type) {
	if (type == 1) {
		fmt::print(file, "\n#ifdef _MSC_VER\n\t#pragma pack(push, 0x01)\n#endif\n");
	}
	else if (type == 2) {
		fmt::print(file, "\n#ifdef _MSC_VER\n\t#pragma pack(pop)\n#endif\n");
	}
}

void UE_UPackage::AddNamespaceDef(FILE* file, int type) {

	if (type == 1) {
		fmt::print(file, "\nnamespace {} {{\n", GNameSpace);
	}
	else if (type == 2) {
		fmt::print(file, "\n}}\n");
	}
}

void UE_UPackage::SavePackageHeader(bool hasClassHeader, bool hasStructHeader, FILE* file) {
	fmt::print(file, "#pragma once\n\n");
	std::string packageName = this->packageName;
	char chars[] = "/\\:*?\"<>|+";
	for (auto c : chars) {
		auto pos = packageName.find(c);
		if (pos != std::string::npos) {
			packageName[pos] = '_';
		}
	}
	if (hasStructHeader) {
		fmt::print(file, "#include \"{}_struct.h\"\n", packageName);
	}
	if (hasClassHeader) {
		fmt::print(file, "#include \"{}_classes.h\"\n", packageName);
	}
	fmt::print(file, "#include \"{}_param.h\"\n", packageName);
}

void UE_UPackage::SavePackageCpp(FILE* cppFile, FILE* paramFile) {
	struct ParamStruct {
		std::string paramName;
		std::string funcName;
	};
	struct FunctionHeader {
		uint32 RVA;
		std::string name;
		std::vector<std::string> flags;
	};
	std::string gameInfo = "/**\n * Name: VAR_GAME_NAME\n * Version : VAR_GAME_VERSION\n */ \n";
	EngineHeaderExport::ReplaceVAR(gameInfo);
	fmt::print(cppFile, "{}", gameInfo);
	fmt::print(paramFile, "{}", gameInfo);
	fmt::print(paramFile, "#pragma once\n\n");
	AddAlignDef(paramFile, 1);
	fmt::print(paramFile, "\n\nnamespace {}\n{{\n", GNameSpace);
	if (pch_head_include) {
		fmt::print(cppFile, "#include \"../pch.h\"");
	}
	fmt::print(cppFile, "#include \"../SDK.h\"");
	fmt::print(cppFile, "\n\nnamespace {}\n{{\n", GNameSpace);
	auto GenerateFunctionHeader = [](FILE* file, FunctionHeader& header) {
		fmt::print(file, "\t/**\n");
		fmt::print(file, "\t * Function: \n");
		fmt::print(file, "\t * \tRVA: {:#08X}\n", header.RVA);
		fmt::print(file, "\t * \tName: {}\n", header.name);
		std::string flags = "(";
		for (int i = 0; i < header.flags.size(); i++) {
			if (i != 0) {
				flags += ", " + header.flags[i];
			}
			else {
				flags += header.flags[i];
			}
		}
		flags += ")";
		fmt::print(file, "\t * \tFlags: {}\n", flags);
		fmt::print(file, "\t */\n");
		};
	auto InjectGetBoneWorldPos = [](FILE* file, Struct& stru) {
		std::string codeTemplate;
		auto replaceSubstr = [](std::string& originalStr, std::string substring, std::string replacement) {
			size_t pos = 0;
			const size_t substringLength = substring.length();
			const size_t replacementLength = replacement.length();

			while ((pos = originalStr.find(substring, pos)) != std::string::npos) {
				originalStr.replace(pos, substringLength, replacement);
				pos += replacementLength; // Move past the replaced substring
			}
			};
		if (!EngineHeaderExport::LoadResourceText(codeTemplate, INJECTED_GETBONEWORLDPOS)) return;
		replaceSubstr(codeTemplate, "\r\n", "\n");
		fmt::print(file, "\n{}\n", codeTemplate);
		};
	auto GenerateStaticClass = [&GenerateFunctionHeader, &InjectGetBoneWorldPos](FILE* file, Struct& stru) {
		if (stru.ClassName == "USkinnedMeshComponent") {
			// inject GetBoneWorldPos function
			InjectGetBoneWorldPos(file, stru);
		}
		FunctionHeader header;
		header.RVA = 0;
		header.name = fmt::format("PredefinedFunction {}.StaticClass", GetValidClassName(stru.ClassName));
		header.flags.push_back("Predefined");
		header.flags.push_back("Static");
		GenerateFunctionHeader(file, header);
		fmt::print(file, "\tUClass* {}::StaticClass()\n\t{{\n", GetValidClassName(stru.ClassName));
		fmt::print(file, "\t\tstatic UClass* ptr = nullptr;\n");
		fmt::print(file, "\t\tif (!ptr)\n");
		fmt::print(file, "\t\t\tptr = UObject::FindClass(\"{}\");\n", GetCpp_xString(stru.FullName));
		fmt::print(file, "\t\treturn ptr;\n");
		fmt::print(file, "\t}}\n\n");
		};

	auto GenerateProxyFunctionParamStruct = [](FILE* file, Function& func) {
		// 生成函数参数结构体
		if (func.FullName == "Dumper_Generated_Function") return;
		static std::unordered_map<std::string, int> paramStructNameMp;

		// 生成的结构体的名字
		func.GeneratedParamName = GetValidClassName(func.FullName);
		if (paramStructNameMp.count(func.GeneratedParamName)) {
			func.GeneratedParamName = func.GeneratedParamName + fmt::format("_Param_{}", ++paramStructNameMp[func.GeneratedParamName]);
		}
		else {
			paramStructNameMp[func.GeneratedParamName] = 1;
			func.GeneratedParamName = func.GeneratedParamName + "_Param";
		}

		// 对func的参数列表按偏移排序然后生成结构体
		std::sort(func.paramInfo.begin(), func.paramInfo.end(), [](const ParamInfo& a, const ParamInfo& b) {
			return a.Offset < b.Offset;
			});
		uint32 offset = 0;
		std::vector<Member> members;
		auto replaceSubstr = [](std::string& originalStr, std::string substring, std::string replacement) {
			size_t pos = 0;
			const size_t substringLength = substring.length();
			const size_t replacementLength = replacement.length();

			while ((pos = originalStr.find(substring, pos)) != std::string::npos) {
				originalStr.replace(pos, substringLength, replacement);
				pos += replacementLength; // Move past the replaced substring
			}
			};
		for (auto& param : func.paramInfo) {
			assert(param.Size != 0);
			assert(param.Offset >= offset);
			if (param.Offset > offset) {
				Member padding;
				padding.Type = "char";
				padding.Name = fmt::format("pad_{:0X}[{:#0x}]", offset, param.Offset - offset);
				padding.Offset = offset;
				padding.Size = param.Offset - offset;
				members.push_back(padding);
				offset += padding.Size;
			}
			Member mParam;
			mParam.Type = param.Type;
			replaceSubstr(mParam.Type, "&", "");
			mParam.Name = param.Name;
			mParam.Offset = param.Offset;
			mParam.Size = param.Size;
			mParam.isSuspectMember = false;
			offset += mParam.Size;
			members.push_back(mParam);
		}
		fmt::print(file, "\tstruct {}\n\t{{\n\tpublic:\n", func.GeneratedParamName);
		for (auto& m : members) {
			fmt::print(file, "\n\t\t{} {}; // {:#04x}({:#04x})", m.Type, m.Name, m.Offset, m.Size);
		}
		fmt::print(file, "\n\t}};\n\n");
		};
	auto GenerateProxyFunctionBody = [&GenerateFunctionHeader](FILE* file, Function& func, Struct& stru) {
		// 生成函数体
		if (func.FullName == "Dumper_Generated_Function") return;
		FunctionHeader header;
		header.RVA = static_cast<uint32>(func.Func - Base);
		header.name = ProcessUTF8Char(func.FullName);
		GetFlagOutVector(func.FuncFlag, header.flags);
		GenerateFunctionHeader(file, header);
		std::string ProcessedFullName = GetCpp_xString(func.FullName);
		fmt::print(file, "\t{} {}::{}({})\n\t{{\n", func.RetType, GetValidClassName(stru.ClassName), func.FuncName, func.Params);
		fmt::print(file, "\t\tstatic UFunction* fn = nullptr;\n");
		fmt::print(file, "\t\tif (!fn)\n");
		fmt::print(file, "\t\t\tfn = UObject::FindObject<UFunction>(\"{}\");\n", ProcessedFullName);
		fmt::print(file, "\t\t{} params {{ }};\n", func.GeneratedParamName);
		for (auto& param : func.paramInfo) {
			if (param.Name == "ReturnValue") continue;
			fmt::print(file, "\t\tparams.{} = {};\n", param.Name, param.Name);
		}
		fmt::print(file, "\n\t\tauto flags = fn->FunctionFlags;\n");
		if (func.FuncFlag & FUNC_Native) {
			fmt::print(file, "\t\tfn->FunctionFlags |= 0x00000400;\n");
		}
		fmt::print(file, "\t\tUObject::ProcessEvent(fn, &params);\n");
		fmt::print(file, "\t\tfn->FunctionFlags = flags;\n\n");

		for (auto& param : func.paramInfo) {
			if (param.Type[param.Type.size() - 1] == '&') {
				fmt::print(file, "\t\t{} = params.{};\n", param.Name, param.Name);
			}
		}

		if (func.RetType != "void") {
			if (func.badDeclareFunc) {
				fmt::print(file, "\t\treturn {{ }};  // BAD DECLARE FUNCTION!\n");
			}
			else {
				fmt::print(file, "\t\treturn params.ReturnValue;\n");
			}
		}
		fmt::print(file, "\t}}\n");
		};
	for (auto& stru : this->Structures) {
		GenerateStaticClass(cppFile, stru);
	}
	for (auto& stru : this->Classes) {
		GenerateStaticClass(cppFile, stru);
	}
	// 开始生成代理函数
	for (auto& stru : this->Structures) {
		for (auto& func : stru.Functions) {
			GenerateProxyFunctionParamStruct(paramFile, func);
			GenerateProxyFunctionBody(cppFile, func, stru);
		}
	}
	for (auto& stru : this->Classes) {
		for (auto& func : stru.Functions) {
			GenerateProxyFunctionParamStruct(paramFile, func);
			GenerateProxyFunctionBody(cppFile, func, stru);
		}
	}

	fmt::print(cppFile, "}}");
	fmt::print(paramFile, "}}");
	AddAlignDef(paramFile, 2);
}

bool UE_UPackage::Save(const fs::path& dir, bool spacing) {
	if (!(Classes.size() || Structures.size() || Enums.size())) {
		return false;
	}

	std::string packageName = this->packageName;

	char chars[] = "/\\:*?\"<>|+";
	for (auto c : chars) {
		auto pos = packageName.find(c);
		if (pos != std::string::npos) {
			packageName[pos] = '_';
		}
	}
	bool hasClassHeader = false;
	bool hasStructHeader = false;

	if (Classes.size()) {
		File file(dir / (packageName + "_classes.h"), "w");
		hasClassHeader = true;
		if (!file) {
			return false;
		}
		UE_UPackage::AddAlignDef(file, 1);
		UE_UPackage::AddNamespaceDef(file, 1);
		if (spacing) {
			UE_UPackage::SaveStructSpacing(Classes, file);
		}
		else {
			UE_UPackage::SaveStruct(Classes, file);
		}
		UE_UPackage::AddNamespaceDef(file, 2);
		UE_UPackage::AddAlignDef(file, 2);
	}

	if (Structures.size() || Enums.size()) {
		File file(dir / (packageName + "_struct.h"), "w");
		hasStructHeader = true;
		if (!file) {
			return false;
		}
		UE_UPackage::AddAlignDef(file, 1);
		UE_UPackage::AddNamespaceDef(file, 1);
		if (Enums.size()) {
			UE_UPackage::SaveEnum(Enums, file);
		}

		if (Structures.size()) {
			if (spacing) {
				UE_UPackage::SaveStructSpacing(Structures, file);
			}
			else {
				UE_UPackage::SaveStruct(Structures, file);
			}
		}
		UE_UPackage::AddNamespaceDef(file, 2);
		UE_UPackage::AddAlignDef(file, 2);
	}
	{
		// 导出package对应的头文件
		File file(dir / (packageName + "_package.h"), "w");
		UE_UPackage::SavePackageHeader(hasClassHeader, hasStructHeader, file);
	}
	{
		// 导出代理用函数的cpp文件
		File cpp(dir / (packageName + "_package.cpp"), "w");
		File param(dir / (packageName + "_param.h"), "w");
		UE_UPackage::SavePackageCpp(cpp, param);
	}

	return true;
}

UE_UObject UE_UPackage::GetObject() const { return UE_UObject(Package->first); }



```

`Dumper/wrappers.h`:

```h
#pragma once
#include "generic.h"
#include <filesystem>
#undef GetObject

namespace fs = std::filesystem;

class RefGraphSolver;
class ClassSizeFixer;

// Wrapper for 'FILE*' that closes the file handle when it goes out of scope
class File {
private:
	FILE* file;

public:
	File(fs::path path, const char* mode) {
		fopen_s(&file, path.string().c_str(), mode);
	}
	~File() {
		if (file) {
			fclose(file);
		}
	}
	operator bool() const { return file != nullptr; }
	operator FILE* () { return file; }
};

// Wrapper for array unit in global names array
class UE_FNameEntry {
protected:
	uint8* object;

public:
	UE_FNameEntry(uint8* object) : object(object) {}
	UE_FNameEntry() : object(nullptr) {}
	operator bool() { return object != nullptr; }
	// Gets info about contained string (bool wide, uint16 len) depending on
	// 'offsets.FNameEntry' info
	std::pair<bool, uint16> Info() const;
	// Gets string out of array unit
	std::string String(bool wide, uint16 len) const;
	// Gets string out of array unit
	void String(char* buf, bool wide, uint16 len) const;
	std::string String() const;
	static std::string WideStringToUTF8(const wchar_t* wideString);

	// Calculates the unit size depending on 'offsets.FNameEntry' and information
	// about string
	static uint16 Size(bool wide, uint16 len);
};

class UE_FName {
protected:
	uint8* object;

public:
	UE_FName(uint8* object) : object(object) {}
	UE_FName() : object(nullptr) {}
	std::string GetName() const;
};

class UE_UClass;
class UE_FField;

enum class PropertyType {
	Unknown,
	StructProperty,
	ObjectProperty,
	SoftObjectProperty,
	FloatProperty,
	ByteProperty,
	BoolProperty,
	IntProperty,
	Int8Property,
	Int16Property,
	Int64Property,
	UInt16Property,
	UInt32Property,
	UInt64Property,
	NameProperty,
	DelegateProperty,
	SetProperty,
	ArrayProperty,
	WeakObjectProperty,
	StrProperty,
	TextProperty,
	MulticastSparseDelegateProperty,
	EnumProperty,
	DoubleProperty,
	MulticastDelegateProperty,
	ClassProperty,
	MulticastInlineDelegateProperty,
	MapProperty,
	InterfaceProperty,
	FieldPathProperty,
	SoftClassProperty
};

class UE_UObject {
protected:
	uint8* object;

public:
	UE_UObject(void* object) : object((uint8*)object) {}
	UE_UObject() : object(nullptr) {}
	bool operator==(const UE_UObject obj) const { return obj.object == object; };
	bool operator!=(const UE_UObject obj) const { return obj.object != object; };
	uint32 GetIndex() const;
	UE_UClass GetClass() const;
	UE_UObject GetOuter() const;
	UE_UObject GetPackageObject() const;
	std::string GetName() const;
	std::string GetFullName() const;
	std::string GetCppName() const;
	void* GetAddress() const { return object; }
	operator uint8* () const { return object; };
	operator bool() const { return object != nullptr; }

	template <typename Base> Base Cast() const { return Base(object); }

	template <typename T> bool IsA() const;

	bool IsA(UE_UClass cmp) const;

	static UE_UClass StaticClass();
};

class UE_AActor : public UE_UObject {
public:
	static UE_UClass StaticClass();
};

class UE_UField : public UE_UObject {
public:
	using UE_UObject::UE_UObject;
	UE_UField GetNext() const;
	static UE_UClass StaticClass();
};

typedef std::pair<PropertyType, std::string> type;

class IProperty {
protected:
	const void* prop;

public:
	IProperty(const void* object) : prop(object) {}
	virtual std::string GetName() const = 0;
	virtual int32 GetArrayDim() const = 0;
	virtual int32 GetSize() const = 0;
	virtual int32 GetOffset() const = 0;
	virtual uint64 GetPropertyFlags() const = 0;
	virtual type GetType() const = 0;
	virtual uint8 GetFieldMask() const = 0;
};

class IUProperty : public IProperty {
public:
	using IProperty::IProperty;
	IUProperty(const class UE_UProperty* object) : IProperty(object) {}
	virtual std::string GetName() const;
	virtual int32 GetArrayDim() const;
	virtual int32 GetSize() const;
	virtual int32 GetOffset() const;
	virtual uint64 GetPropertyFlags() const;
	virtual type GetType() const;
	virtual uint8 GetFieldMask() const;
};

class UE_UProperty : public UE_UField {
public:
	using UE_UField::UE_UField;
	int32 GetArrayDim() const;
	int32 GetSize() const;
	int32 GetOffset() const;
	uint64 GetPropertyFlags() const;
	type GetType() const;

	IUProperty GetInterface() const;
	static UE_UClass StaticClass();
};

class UE_UStruct : public UE_UField {
public:
	uint32 FixedSize = 0;
	using UE_UField::UE_UField;
	UE_UStruct GetSuper() const;
	UE_FField GetChildProperties() const;
	UE_UField GetChildren() const;
	int32 GetSize() const;
	static UE_UClass StaticClass();
};

enum EFunctionFlags : uint32
{
	// Function flags.
	FUNC_None = 0x00000000,
	FUNC_Final = 0x00000001,	// Function is final (prebindable, non-overridable function).
	FUNC_RequiredAPI = 0x00000002,	// Indicates this function is DLL exported/imported.
	FUNC_BlueprintAuthorityOnly = 0x00000004,   // Function will only run if the object has network authority
	FUNC_BlueprintCosmetic = 0x00000008,   // Function is cosmetic in nature and should not be invoked on dedicated servers
	// FUNC_				= 0x00000010,   // unused.
	// FUNC_				= 0x00000020,   // unused.
	FUNC_Net = 0x00000040,   // Function is network-replicated.
	FUNC_NetReliable = 0x00000080,   // Function should be sent reliably on the network.
	FUNC_NetRequest = 0x00000100,	// Function is sent to a net service
	FUNC_Exec = 0x00000200,	// Executable from command line.
	FUNC_Native = 0x00000400,	// Native function.
	FUNC_Event = 0x00000800,   // Event function.
	FUNC_NetResponse = 0x00001000,   // Function response from a net service
	FUNC_Static = 0x00002000,   // Static function.
	FUNC_NetMulticast = 0x00004000,	// Function is networked multicast Server -> All Clients
	FUNC_UbergraphFunction = 0x00008000,   // Function is used as the merge 'ubergraph' for a blueprint, only assigned when using the persistent 'ubergraph' frame
	FUNC_MulticastDelegate = 0x00010000,	// Function is a multi-cast delegate signature (also requires FUNC_Delegate to be set!)
	FUNC_Public = 0x00020000,	// Function is accessible in all classes (if overridden, parameters must remain unchanged).
	FUNC_Private = 0x00040000,	// Function is accessible only in the class it is defined in (cannot be overridden, but function name may be reused in subclasses.  IOW: if overridden, parameters don't need to match, and Super.Func() cannot be accessed since it's private.)
	FUNC_Protected = 0x00080000,	// Function is accessible only in the class it is defined in and subclasses (if overridden, parameters much remain unchanged).
	FUNC_Delegate = 0x00100000,	// Function is delegate signature (either single-cast or multi-cast, depending on whether FUNC_MulticastDelegate is set.)
	FUNC_NetServer = 0x00200000,	// Function is executed on servers (set by replication code if passes check)
	FUNC_HasOutParms = 0x00400000,	// function has out (pass by reference) parameters
	FUNC_HasDefaults = 0x00800000,	// function has structs that contain defaults
	FUNC_NetClient = 0x01000000,	// function is executed on clients
	FUNC_DLLImport = 0x02000000,	// function is imported from a DLL
	FUNC_BlueprintCallable = 0x04000000,	// function can be called from blueprint code
	FUNC_BlueprintEvent = 0x08000000,	// function can be overridden/implemented from a blueprint
	FUNC_BlueprintPure = 0x10000000,	// function can be called from blueprint code, and is also pure (produces no side effects). If you set this, you should set FUNC_BlueprintCallable as well.
	FUNC_EditorOnly = 0x20000000,	// function can only be called from an editor scrippt.
	FUNC_Const = 0x40000000,	// function can be called from blueprint code, and only reads state (never writes state)
	FUNC_NetValidate = 0x80000000,	// function must supply a _Validate implementation
	FUNC_AllFlags = 0xFFFFFFFF,
};

class UE_UFunction : public UE_UStruct {
public:
	using UE_UStruct::UE_UStruct;
	uint64 GetFunc() const;
	uint32 GetFunctionFlagInt() const;
	std::string GetFunctionFlags() const;
	static UE_UClass StaticClass();
};

class UE_UScriptStruct : public UE_UStruct {
public:
	using UE_UStruct::UE_UStruct;
	static UE_UClass StaticClass();
};

class UE_UClass : public UE_UStruct {
public:
	using UE_UStruct::UE_UStruct;
	static UE_UClass StaticClass();
};

class UE_UEnum : public UE_UField {
public:
	using UE_UField::UE_UField;
	TArray GetNames() const;
	static UE_UClass StaticClass();
};

class UE_UDoubleProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UFloatProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UIntProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UInt16Property : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UInt64Property : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UInt8Property : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UUInt16Property : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UUInt32Property : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UUInt64Property : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UTextProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UStrProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UStructProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	UE_UStruct GetStruct() const;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UNameProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UObjectPropertyBase : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	UE_UClass GetPropertyClass() const;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UArrayProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	UE_UProperty GetInner() const;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UByteProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	UE_UEnum GetEnum() const;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UBoolProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	uint8 GetFieldMask() const;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UEnumProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	UE_UClass GetEnum() const;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UClassProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	UE_UClass GetMetaClass() const;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_USetProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	UE_UProperty GetElementProp() const;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UMapProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	UE_UProperty GetKeyProp() const;
	UE_UProperty GetValueProp() const;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UInterfaceProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	UE_UProperty GetInterfaceClass() const;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UMulticastDelegateProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_UWeakObjectProperty : public UE_UProperty {
public:
	using UE_UProperty::UE_UProperty;
	std::string GetTypeStr() const;
	static UE_UClass StaticClass();
};

class UE_FFieldClass {
protected:
	uint8* object;

public:
	UE_FFieldClass(uint8* object) : object(object) {};
	UE_FFieldClass() : object(nullptr) {};
	std::string GetName() const;
};

class UE_FField {
protected:
	uint8* object;

public:
	UE_FField(uint8* object) : object(object) {}
	UE_FField() : object(nullptr) {}
	operator bool() const { return object != nullptr; }
	UE_FField GetNext() const;
	std::string GetName() const;

	template <typename Base> Base Cast() const { return Base(object); }
};

class IFProperty : public IProperty {
public:
	IFProperty(const class UE_FProperty* object) : IProperty(object) {}
	virtual std::string GetName() const;
	virtual int32 GetArrayDim() const;
	virtual int32 GetSize() const;
	virtual int32 GetOffset() const;
	virtual uint64 GetPropertyFlags() const;
	virtual type GetType() const;
	virtual uint8 GetFieldMask() const;
};



class UE_FProperty : public UE_FField {
public:
	using UE_FField::UE_FField;
	int32 GetArrayDim() const;
	int32 GetSize() const;
	int32 GetOffset() const;
	uint64 GetPropertyFlags() const;
	type GetType() const;
	IFProperty GetInterface() const;
};

class UE_FStructProperty : public UE_FProperty {
public:
	using UE_FProperty::UE_FProperty;
	UE_UStruct GetStruct() const;
	std::string GetTypeStr() const;
};

class UE_FObjectPropertyBase : public UE_FProperty {
public:
	using UE_FProperty::UE_FProperty;
	UE_UClass GetPropertyClass() const;
	std::string GetTypeStr() const;
};

class UE_FArrayProperty : public UE_FProperty {
public:
	using UE_FProperty::UE_FProperty;
	UE_FProperty GetInner() const;
	std::string GetTypeStr() const;
};

class UE_FByteProperty : public UE_FProperty {
public:
	using UE_FProperty::UE_FProperty;
	UE_UEnum GetEnum() const;
	std::string GetTypeStr() const;
};

class UE_FBoolProperty : public UE_FProperty {
public:
	using UE_FProperty::UE_FProperty;
	uint8 GetFieldMask() const;
	std::string GetTypeStr() const;
};

class UE_FEnumProperty : public UE_FProperty {
public:
	using UE_FProperty::UE_FProperty;
	UE_UClass GetEnum() const;
	std::string GetTypeStr() const;
};

class UE_FClassProperty : public UE_FObjectPropertyBase {
public:
	using UE_FObjectPropertyBase::UE_FObjectPropertyBase;
	UE_UClass GetMetaClass() const;
	std::string GetTypeStr() const;
};

class UE_FSetProperty : public UE_FProperty {
public:
	using UE_FProperty::UE_FProperty;
	UE_FProperty GetElementProp() const;
	std::string GetTypeStr() const;
};

class UE_FMapProperty : public UE_FProperty {
public:
	using UE_FProperty::UE_FProperty;
	UE_FProperty GetKeyProp() const;
	UE_FProperty GetValueProp() const;
	std::string GetTypeStr() const;
};

class UE_FInterfaceProperty : public UE_FProperty {
public:
	using UE_FProperty::UE_FProperty;
	UE_UClass GetInterfaceClass() const;
	std::string GetTypeStr() const;
};

class UE_FFieldPathProperty : public UE_FProperty {
public:
	using UE_FProperty::UE_FProperty;
	UE_FName GetPropertyName() const;
	std::string GetTypeStr() const;
};

template <typename T> bool UE_UObject::IsA() const {
	auto cmp = T::StaticClass();
	if (!cmp) {
		return false;
	}

	return IsA(cmp);
}

class UE_UPackage {
private:
	struct Member {
		Member() {
			isSuspectMember = false;
		}
		bool isSuspectMember;
		std::string Type;
		std::string Name;
		uint32 Offset = 0;
		uint32 Size = 0;
	};
	struct ParamInfo {
		uint32 Offset = 0;
		uint32 Size = 0;
		std::string Name;
		std::string Type;
		uint64 flags;
	};
	struct Function {
		std::vector<ParamInfo> paramInfo;
		std::vector<std::string> ParamTypes;
		uint32 FuncFlag;
		std::string FuncName;
		std::string RetType;
		std::string FullName;
		std::string CppName;
		std::string Params;
		std::string Flags;
		std::string GeneratedParamName;
		std::string declareConst;
		uint64 Func = 0;
		bool badDeclareFunc = false;
	};
	struct Struct {
		std::string FullName;
		std::string CppName;
		std::string ClassName;
		std::string SuperName;
		uint32 Inherited = 0;
		uint32 Size = 0;
		std::vector<Member> Members;
		std::vector<Function> Functions;
	};
	struct Enum {
		std::string FullName;
		std::string CppName;
		std::string EnumName;
		std::vector<std::string> Members;
	};

private:
	std::pair<uint8* const, std::vector<UE_UObject>>* Package;
	std::vector<Struct> Classes;
	std::vector<Struct> Structures;
	std::vector<Enum> Enums;
public:
	std::string packageName;
	bool FindPointers = false;


private:
	static void GenerateBitPadding(std::vector<Member>& members, uint32 offset, uint8 bitOffset, uint8 size);
	static void GeneratePadding(std::vector<Member>& members, uint32 offset, uint32 size);
	static void FillPadding(UE_UStruct object, std::vector<Member>& members, uint32& offset, uint8& bitOffset, uint32 end, bool findPointers);
	static void GenerateFunction(UE_UFunction fn, Function* out, std::unordered_map<std::string, int>& memberMap);
	// static void GenerateFunction(UE_UFunction fn, Function* out);
	static std::string ProcessUTF8Char(std::string input);
	static std::string GetCpp_xString(std::string& input);
	static std::string GetValidClassName(std::string str);
	static void GenerateStruct(UE_UStruct object, std::vector<Struct>& arr, bool findPointers);
	static void FixKeywordConflict(std::string& tocheck);
	static void GenerateEnum(UE_UEnum object, std::vector<Enum>& arr);
	static void SaveStruct(std::vector<Struct>& arr, FILE* file);
	static void SaveStructSpacing(std::vector<Struct>& arr, FILE* file); // save struct with spacing to members applied
	static void SaveEnum(std::vector<Enum>& arr, FILE* file);
public:
	UE_UPackage(std::pair<uint8* const, std::vector<UE_UObject>>& package) : Package(&package) {};
	void Process();
	static void AddAlignDef(FILE* file, int type);
	static void AddNamespaceDef(FILE* file, int type);
	void SavePackageHeader(bool hasClassHeader, bool hasStructHeader, FILE* file);
	void SavePackageCpp(FILE* cppFile, FILE* paramFile);
	bool Save(const fs::path& dir, bool spacing);
	UE_UObject GetObject() const;

	friend RefGraphSolver;
	friend ClassSizeFixer;
};

inline bool pch_head_include{};

```

`README.md`:

```md
# UnrealSDKDumper 
![workflow](https://github.com/BobHUnrealTech/UnrealSDKDumper-4.25/actions/workflows/build.yml/badge.svg)

### 支持的游戏
 - Fortnite
 - Rogue Company
 - Dead By Daylight
 - Witch It
 - Brickadia
 - POLYGON
 - SCUM
 - Scavengers
 - The Isle
 - Splitgate
 - Dauntless
 - Boundary
 - The Cycle: Frontier
 - Calabiyau(卡拉彼丘)
 - Seria(晶核：魔导觉醒)
 - Game(尘白禁区)
 - Client-Win64-Shipping(鸣潮)
### 支持引擎版本: 
- UE 4.23-4.27

### 我们做了什么

- 根据不同package包含的类的引用关系，进行拓扑排序，确定头文件正确引用顺序
- 测试大量游戏，找出一些造成sdk编译出错的变量名（例如：+.()<> 中文等），并进行处理
- 生成一个导入即可编译成功的sdk.h文件以及导入即可用的SDK文件夹
- 对游戏中的中文宽字符字符串进行特殊处理，使得SDK能够导出中文类名、变量名、函数名
- 修改了CheatGear中FindObject对字符串的比较逻辑，使得SDK能够调用中文函数，获取中文类

### Todo:

- 自动生成VS脚手架项目，尝试做到像CheatGear一样能够打开即用
- 生成偏移断言测试项目，方便测试各个成员偏移是否符合预期

### Contributor

Modified by BobH
```

`UnrealDumper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30621.155
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Dumper", "Dumper\Dumper.vcxproj", "{4E175DB2-CFFD-48F9-888F-AF140E44068D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4E175DB2-CFFD-48F9-888F-AF140E44068D}.Debug|x64.ActiveCfg = Debug|x64
		{4E175DB2-CFFD-48F9-888F-AF140E44068D}.Debug|x64.Build.0 = Debug|x64
		{4E175DB2-CFFD-48F9-888F-AF140E44068D}.Release|x64.ActiveCfg = Release|x64
		{4E175DB2-CFFD-48F9-888F-AF140E44068D}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A8A9CB85-8DA6-437E-A3AC-07498C5192D3}
	EndGlobalSection
EndGlobal

```

`build.ps1`:

```ps1
param([string]$buildtfm = 'x64')

$build64	 = $buildtfm -eq 'x64'
$build86	 = $buildtfm -eq 'x86'

$msbuildPath = Split-Path (& "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -latest -requires Microsoft.Component.MSBuild -find MSBuild\Current\Bin\amd64\MSBuild.exe | Select-Object -First 1) -Parent
Write-Host "VisualStudioCompiler:" + $msbuildPath
$env:PATH = $msbuildPath + ';' + $env:PATH

if($build86){
    msbuild UnrealDumper.sln -target:Dumper /p:Platform=x86 /p:Configuration=Release
}

if($build64){
    msbuild UnrealDumper.sln -target:Dumper /p:Platform=x64 /p:Configuration=Release
}
```

`include/fmt/core.h`:

```h
// Formatting library for C++ - the core API for char/UTF-8
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_CORE_H_
#define FMT_CORE_H_

#include <cstdio>  // std::FILE
#include <cstring>
#include <iterator>
#include <limits>
#include <string>
#include <type_traits>

// The fmt library version in the form major * 10000 + minor * 100 + patch.
#define FMT_VERSION 80001

#if defined (__clang__ ) && !defined(__ibmxl__)
#  define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)
#else
#  define FMT_CLANG_VERSION 0
#endif

#if defined(__GNUC__) && !defined(__clang__) && !defined(__INTEL_COMPILER) && \
    !defined(__NVCOMPILER)
#  define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
#else
#  define FMT_GCC_VERSION 0
#endif

#ifndef FMT_GCC_PRAGMA
// Workaround _Pragma bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59884.
#  if FMT_GCC_VERSION >= 504
#    define FMT_GCC_PRAGMA(arg) _Pragma(arg)
#  else
#    define FMT_GCC_PRAGMA(arg)
#  endif
#endif

#ifdef __ICL
#  define FMT_ICC_VERSION __ICL
#elif defined(__INTEL_COMPILER)
#  define FMT_ICC_VERSION __INTEL_COMPILER
#else
#  define FMT_ICC_VERSION 0
#endif

#ifdef __NVCC__
#  define FMT_NVCC __NVCC__
#else
#  define FMT_NVCC 0
#endif

#ifdef _MSC_VER
#  define FMT_MSC_VER _MSC_VER
#  define FMT_MSC_WARNING(...) __pragma(warning(__VA_ARGS__))
#else
#  define FMT_MSC_VER 0
#  define FMT_MSC_WARNING(...)
#endif

#ifdef __has_feature
#  define FMT_HAS_FEATURE(x) __has_feature(x)
#else
#  define FMT_HAS_FEATURE(x) 0
#endif

#if defined(__has_include) &&                             \
    (!defined(__INTELLISENSE__) || FMT_MSC_VER > 1900) && \
    (!FMT_ICC_VERSION || FMT_ICC_VERSION >= 1600)
#  define FMT_HAS_INCLUDE(x) __has_include(x)
#else
#  define FMT_HAS_INCLUDE(x) 0
#endif

#ifdef __has_cpp_attribute
#  define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
#else
#  define FMT_HAS_CPP_ATTRIBUTE(x) 0
#endif

#define FMT_HAS_CPP14_ATTRIBUTE(attribute) \
  (__cplusplus >= 201402L && FMT_HAS_CPP_ATTRIBUTE(attribute))

#define FMT_HAS_CPP17_ATTRIBUTE(attribute) \
  (__cplusplus >= 201703L && FMT_HAS_CPP_ATTRIBUTE(attribute))

// Check if relaxed C++14 constexpr is supported.
// GCC doesn't allow throw in constexpr until version 6 (bug 67371).
#ifndef FMT_USE_CONSTEXPR
#  define FMT_USE_CONSTEXPR                                           \
    (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VER >= 1912 || \
     (FMT_GCC_VERSION >= 600 && __cplusplus >= 201402L)) &&           \
        !FMT_NVCC && !FMT_ICC_VERSION
#endif
#if FMT_USE_CONSTEXPR
#  define FMT_CONSTEXPR constexpr
#  define FMT_CONSTEXPR_DECL constexpr
#else
#  define FMT_CONSTEXPR
#  define FMT_CONSTEXPR_DECL
#endif

#if ((__cplusplus >= 202002L) &&                              \
     (!defined(_GLIBCXX_RELEASE) || _GLIBCXX_RELEASE > 9)) || \
    (__cplusplus >= 201709L && FMT_GCC_VERSION >= 1002)
#  define FMT_CONSTEXPR20 constexpr
#else
#  define FMT_CONSTEXPR20
#endif

// Check if constexpr std::char_traits<>::compare,length is supported.
#if defined(__GLIBCXX__)
#  if __cplusplus >= 201703L && defined(_GLIBCXX_RELEASE) && \
      _GLIBCXX_RELEASE >= 7  // GCC 7+ libstdc++ has _GLIBCXX_RELEASE.
#    define FMT_CONSTEXPR_CHAR_TRAITS constexpr
#  endif
#elif defined(_LIBCPP_VERSION) && __cplusplus >= 201703L && \
    _LIBCPP_VERSION >= 4000
#  define FMT_CONSTEXPR_CHAR_TRAITS constexpr
#elif FMT_MSC_VER >= 1914 && _MSVC_LANG >= 201703L
#  define FMT_CONSTEXPR_CHAR_TRAITS constexpr
#endif
#ifndef FMT_CONSTEXPR_CHAR_TRAITS
#  define FMT_CONSTEXPR_CHAR_TRAITS
#endif

// Check if exceptions are disabled.
#ifndef FMT_EXCEPTIONS
#  if (defined(__GNUC__) && !defined(__EXCEPTIONS)) || \
      FMT_MSC_VER && !_HAS_EXCEPTIONS
#    define FMT_EXCEPTIONS 0
#  else
#    define FMT_EXCEPTIONS 1
#  endif
#endif

// Define FMT_USE_NOEXCEPT to make fmt use noexcept (C++11 feature).
#ifndef FMT_USE_NOEXCEPT
#  define FMT_USE_NOEXCEPT 0
#endif

#if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \
    FMT_GCC_VERSION >= 408 || FMT_MSC_VER >= 1900
#  define FMT_DETECTED_NOEXCEPT noexcept
#  define FMT_HAS_CXX11_NOEXCEPT 1
#else
#  define FMT_DETECTED_NOEXCEPT throw()
#  define FMT_HAS_CXX11_NOEXCEPT 0
#endif

#ifndef FMT_NOEXCEPT
#  if FMT_EXCEPTIONS || FMT_HAS_CXX11_NOEXCEPT
#    define FMT_NOEXCEPT FMT_DETECTED_NOEXCEPT
#  else
#    define FMT_NOEXCEPT
#  endif
#endif

// [[noreturn]] is disabled on MSVC and NVCC because of bogus unreachable code
// warnings.
#if FMT_EXCEPTIONS && FMT_HAS_CPP_ATTRIBUTE(noreturn) && !FMT_MSC_VER && \
    !FMT_NVCC
#  define FMT_NORETURN [[noreturn]]
#else
#  define FMT_NORETURN
#endif

#if __cplusplus == 201103L || __cplusplus == 201402L
#  if defined(__INTEL_COMPILER) || defined(__PGI)
#    define FMT_FALLTHROUGH
#  elif defined(__clang__)
#    define FMT_FALLTHROUGH [[clang::fallthrough]]
#  elif FMT_GCC_VERSION >= 700 && \
      (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= 520)
#    define FMT_FALLTHROUGH [[gnu::fallthrough]]
#  else
#    define FMT_FALLTHROUGH
#  endif
#elif FMT_HAS_CPP17_ATTRIBUTE(fallthrough) || \
    (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
#  define FMT_FALLTHROUGH [[fallthrough]]
#else
#  define FMT_FALLTHROUGH
#endif

#ifndef FMT_USE_FLOAT
#  define FMT_USE_FLOAT 1
#endif
#ifndef FMT_USE_DOUBLE
#  define FMT_USE_DOUBLE 1
#endif
#ifndef FMT_USE_LONG_DOUBLE
#  define FMT_USE_LONG_DOUBLE 1
#endif

#ifndef FMT_INLINE
#  if FMT_GCC_VERSION || FMT_CLANG_VERSION
#    define FMT_INLINE inline __attribute__((always_inline))
#  else
#    define FMT_INLINE inline
#  endif
#endif

#ifndef FMT_BEGIN_NAMESPACE
#  define FMT_BEGIN_NAMESPACE \
    namespace fmt {           \
    inline namespace v8 {
#  define FMT_END_NAMESPACE \
    }                       \
    }
#endif

#ifndef FMT_MODULE_EXPORT
#  define FMT_MODULE_EXPORT
#  define FMT_MODULE_EXPORT_BEGIN
#  define FMT_MODULE_EXPORT_END
#  define FMT_BEGIN_DETAIL_NAMESPACE namespace detail {
#  define FMT_END_DETAIL_NAMESPACE }
#endif

#if !defined(FMT_HEADER_ONLY) && defined(_WIN32)
#  define FMT_CLASS_API FMT_MSC_WARNING(suppress : 4275)
#  ifdef FMT_EXPORT
#    define FMT_API __declspec(dllexport)
#  elif defined(FMT_SHARED)
#    define FMT_API __declspec(dllimport)
#  endif
#else
#  define FMT_CLASS_API
#  if defined(FMT_EXPORT) || defined(FMT_SHARED)
#    if defined(__GNUC__) || defined(__clang__)
#      define FMT_API __attribute__((visibility("default")))
#    endif
#  endif
#endif
#ifndef FMT_API
#  define FMT_API
#endif

// libc++ supports string_view in pre-c++17.
#if (FMT_HAS_INCLUDE(<string_view>) &&                       \
     (__cplusplus > 201402L || defined(_LIBCPP_VERSION))) || \
    (defined(_MSVC_LANG) && _MSVC_LANG > 201402L && _MSC_VER >= 1910)
#  include <string_view>
#  define FMT_USE_STRING_VIEW
#elif FMT_HAS_INCLUDE("experimental/string_view") && __cplusplus >= 201402L
#  include <experimental/string_view>
#  define FMT_USE_EXPERIMENTAL_STRING_VIEW
#endif

#ifndef FMT_UNICODE
#  define FMT_UNICODE !FMT_MSC_VER
#endif

#ifndef FMT_CONSTEVAL
#  if ((FMT_GCC_VERSION >= 1000 || FMT_CLANG_VERSION >= 1101) &&      \
       __cplusplus > 201703L && !defined(__apple_build_version__)) || \
      (defined(__cpp_consteval) && (!FMT_MSC_VER || _MSC_FULL_VER >= 193030704))
  // consteval is broken in MSVC before VS2022 and Apple clang 13.
#    define FMT_CONSTEVAL consteval
#    define FMT_HAS_CONSTEVAL
#  else
#    define FMT_CONSTEVAL
#  endif
#endif

#ifndef FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
#  if defined(__cpp_nontype_template_args) &&                \
      ((FMT_GCC_VERSION >= 903 && __cplusplus >= 201709L) || \
       __cpp_nontype_template_args >= 201911L)
#    define FMT_USE_NONTYPE_TEMPLATE_PARAMETERS 1
#  else
#    define FMT_USE_NONTYPE_TEMPLATE_PARAMETERS 0
#  endif
#endif

// Enable minimal optimizations for more compact code in debug mode.
FMT_GCC_PRAGMA("GCC push_options")
#ifndef __OPTIMIZE__
FMT_GCC_PRAGMA("GCC optimize(\"Og\")")
#endif

FMT_BEGIN_NAMESPACE
FMT_MODULE_EXPORT_BEGIN

// Implementations of enable_if_t and other metafunctions for older systems.
template <bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;
template <bool B, typename T, typename F>
using conditional_t = typename std::conditional<B, T, F>::type;
template <bool B> using bool_constant = std::integral_constant<bool, B>;
template <typename T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <typename T>
using remove_const_t = typename std::remove_const<T>::type;
template <typename T>
using remove_cvref_t = typename std::remove_cv<remove_reference_t<T>>::type;
template <typename T> struct type_identity { using type = T; };
template <typename T> using type_identity_t = typename type_identity<T>::type;

struct monostate {
  constexpr monostate() {}
};

// An enable_if helper to be used in template parameters which results in much
// shorter symbols: https://godbolt.org/z/sWw4vP. Extra parentheses are needed
// to workaround a bug in MSVC 2019 (see #1140 and #1186).
#ifdef FMT_DOC
#  define FMT_ENABLE_IF(...)
#else
#  define FMT_ENABLE_IF(...) enable_if_t<(__VA_ARGS__), int> = 0
#endif

FMT_BEGIN_DETAIL_NAMESPACE

// Suppress "unused variable" warnings with the method described in
// https://herbsutter.com/2009/10/18/mailbag-shutting-up-compiler-warnings/.
// (void)var does not work on many Intel compilers.
template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}

constexpr FMT_INLINE auto is_constant_evaluated(bool default_value = false)
    FMT_NOEXCEPT -> bool {
#ifdef __cpp_lib_is_constant_evaluated
  ignore_unused(default_value);
  return std::is_constant_evaluated();
#else
  return default_value;
#endif
}

// A function to suppress "conditional expression is constant" warnings.
template <typename T> constexpr FMT_INLINE auto const_check(T value) -> T {
  return value;
}

FMT_NORETURN FMT_API void assert_fail(const char* file, int line,
                                      const char* message);

#ifndef FMT_ASSERT
#  ifdef NDEBUG
// FMT_ASSERT is not empty to avoid -Werror=empty-body.
#    define FMT_ASSERT(condition, message) \
      ::fmt::detail::ignore_unused((condition), (message))
#  else
#    define FMT_ASSERT(condition, message)                                    \
      ((condition) /* void() fails with -Winvalid-constexpr on clang 4.0.1 */ \
           ? (void)0                                                          \
           : ::fmt::detail::assert_fail(__FILE__, __LINE__, (message)))
#  endif
#endif

#if defined(FMT_USE_STRING_VIEW)
template <typename Char> using std_string_view = std::basic_string_view<Char>;
#elif defined(FMT_USE_EXPERIMENTAL_STRING_VIEW)
template <typename Char>
using std_string_view = std::experimental::basic_string_view<Char>;
#else
template <typename T> struct std_string_view {};
#endif

#ifdef FMT_USE_INT128
// Do nothing.
#elif defined(__SIZEOF_INT128__) && !FMT_NVCC && \
    !(FMT_CLANG_VERSION && FMT_MSC_VER)
#  define FMT_USE_INT128 1
using int128_t = __int128_t;
using uint128_t = __uint128_t;
template <typename T> inline auto convert_for_visit(T value) -> T {
  return value;
}
#else
#  define FMT_USE_INT128 0
#endif
#if !FMT_USE_INT128
enum class int128_t {};
enum class uint128_t {};
// Reduce template instantiations.
template <typename T> inline auto convert_for_visit(T) -> monostate {
  return {};
}
#endif

// Casts a nonnegative integer to unsigned.
template <typename Int>
FMT_CONSTEXPR auto to_unsigned(Int value) ->
    typename std::make_unsigned<Int>::type {
  FMT_ASSERT(value >= 0, "negative value");
  return static_cast<typename std::make_unsigned<Int>::type>(value);
}

FMT_MSC_WARNING(suppress : 4566) constexpr unsigned char micro[] = "\u00B5";

constexpr auto is_utf8() -> bool {
  // Avoid buggy sign extensions in MSVC's constant evaluation mode.
  // https://developercommunity.visualstudio.com/t/C-difference-in-behavior-for-unsigned/1233612
  using uchar = unsigned char;
  return FMT_UNICODE || (sizeof(micro) == 3 && uchar(micro[0]) == 0xC2 &&
                         uchar(micro[1]) == 0xB5);
}
FMT_END_DETAIL_NAMESPACE

/**
  An implementation of ``std::basic_string_view`` for pre-C++17. It provides a
  subset of the API. ``fmt::basic_string_view`` is used for format strings even
  if ``std::string_view`` is available to prevent issues when a library is
  compiled with a different ``-std`` option than the client code (which is not
  recommended).
 */
template <typename Char> class basic_string_view {
 private:
  const Char* data_;
  size_t size_;

 public:
  using value_type = Char;
  using iterator = const Char*;

  constexpr basic_string_view() FMT_NOEXCEPT : data_(nullptr), size_(0) {}

  /** Constructs a string reference object from a C string and a size. */
  constexpr basic_string_view(const Char* s, size_t count) FMT_NOEXCEPT
      : data_(s),
        size_(count) {}

  /**
    \rst
    Constructs a string reference object from a C string computing
    the size with ``std::char_traits<Char>::length``.
    \endrst
   */
  FMT_CONSTEXPR_CHAR_TRAITS
  FMT_INLINE
  basic_string_view(const Char* s)
      : data_(s),
        size_(detail::const_check(std::is_same<Char, char>::value &&
                                  !detail::is_constant_evaluated(true))
                  ? std::strlen(reinterpret_cast<const char*>(s))
                  : std::char_traits<Char>::length(s)) {}

  /** Constructs a string reference from a ``std::basic_string`` object. */
  template <typename Traits, typename Alloc>
  FMT_CONSTEXPR basic_string_view(
      const std::basic_string<Char, Traits, Alloc>& s) FMT_NOEXCEPT
      : data_(s.data()),
        size_(s.size()) {}

  template <typename S, FMT_ENABLE_IF(std::is_same<
                                      S, detail::std_string_view<Char>>::value)>
  FMT_CONSTEXPR basic_string_view(S s) FMT_NOEXCEPT : data_(s.data()),
                                                      size_(s.size()) {}

  /** Returns a pointer to the string data. */
  constexpr auto data() const -> const Char* { return data_; }

  /** Returns the string size. */
  constexpr auto size() const -> size_t { return size_; }

  constexpr auto begin() const -> iterator { return data_; }
  constexpr auto end() const -> iterator { return data_ + size_; }

  constexpr auto operator[](size_t pos) const -> const Char& {
    return data_[pos];
  }

  FMT_CONSTEXPR void remove_prefix(size_t n) {
    data_ += n;
    size_ -= n;
  }

  // Lexicographically compare this string reference to other.
  FMT_CONSTEXPR_CHAR_TRAITS auto compare(basic_string_view other) const -> int {
    size_t str_size = size_ < other.size_ ? size_ : other.size_;
    int result = std::char_traits<Char>::compare(data_, other.data_, str_size);
    if (result == 0)
      result = size_ == other.size_ ? 0 : (size_ < other.size_ ? -1 : 1);
    return result;
  }

  FMT_CONSTEXPR_CHAR_TRAITS friend auto operator==(basic_string_view lhs,
                                                   basic_string_view rhs)
      -> bool {
    return lhs.compare(rhs) == 0;
  }
  friend auto operator!=(basic_string_view lhs, basic_string_view rhs) -> bool {
    return lhs.compare(rhs) != 0;
  }
  friend auto operator<(basic_string_view lhs, basic_string_view rhs) -> bool {
    return lhs.compare(rhs) < 0;
  }
  friend auto operator<=(basic_string_view lhs, basic_string_view rhs) -> bool {
    return lhs.compare(rhs) <= 0;
  }
  friend auto operator>(basic_string_view lhs, basic_string_view rhs) -> bool {
    return lhs.compare(rhs) > 0;
  }
  friend auto operator>=(basic_string_view lhs, basic_string_view rhs) -> bool {
    return lhs.compare(rhs) >= 0;
  }
};

using string_view = basic_string_view<char>;

/** Specifies if ``T`` is a character type. Can be specialized by users. */
template <typename T> struct is_char : std::false_type {};
template <> struct is_char<char> : std::true_type {};

// Returns a string view of `s`.
template <typename Char, FMT_ENABLE_IF(is_char<Char>::value)>
FMT_INLINE auto to_string_view(const Char* s) -> basic_string_view<Char> {
  return s;
}
template <typename Char, typename Traits, typename Alloc>
inline auto to_string_view(const std::basic_string<Char, Traits, Alloc>& s)
    -> basic_string_view<Char> {
  return s;
}
template <typename Char>
constexpr auto to_string_view(basic_string_view<Char> s)
    -> basic_string_view<Char> {
  return s;
}
template <typename Char,
          FMT_ENABLE_IF(!std::is_empty<detail::std_string_view<Char>>::value)>
inline auto to_string_view(detail::std_string_view<Char> s)
    -> basic_string_view<Char> {
  return s;
}

// A base class for compile-time strings. It is defined in the fmt namespace to
// make formatting functions visible via ADL, e.g. format(FMT_STRING("{}"), 42).
struct compile_string {};

template <typename S>
struct is_compile_string : std::is_base_of<compile_string, S> {};

template <typename S, FMT_ENABLE_IF(is_compile_string<S>::value)>
constexpr auto to_string_view(const S& s)
    -> basic_string_view<typename S::char_type> {
  return basic_string_view<typename S::char_type>(s);
}

FMT_BEGIN_DETAIL_NAMESPACE

void to_string_view(...);
using fmt::v8::to_string_view;

// Specifies whether S is a string type convertible to fmt::basic_string_view.
// It should be a constexpr function but MSVC 2017 fails to compile it in
// enable_if and MSVC 2015 fails to compile it as an alias template.
template <typename S>
struct is_string : std::is_class<decltype(to_string_view(std::declval<S>()))> {
};

template <typename S, typename = void> struct char_t_impl {};
template <typename S> struct char_t_impl<S, enable_if_t<is_string<S>::value>> {
  using result = decltype(to_string_view(std::declval<S>()));
  using type = typename result::value_type;
};

// Reports a compile-time error if S is not a valid format string.
template <typename..., typename S, FMT_ENABLE_IF(!is_compile_string<S>::value)>
FMT_INLINE void check_format_string(const S&) {
#ifdef FMT_ENFORCE_COMPILE_STRING
  static_assert(is_compile_string<S>::value,
                "FMT_ENFORCE_COMPILE_STRING requires all format strings to use "
                "FMT_STRING.");
#endif
}
template <typename..., typename S, FMT_ENABLE_IF(is_compile_string<S>::value)>
void check_format_string(S);

FMT_NORETURN FMT_API void throw_format_error(const char* message);

struct error_handler {
  constexpr error_handler() = default;
  constexpr error_handler(const error_handler&) = default;

  // This function is intentionally not constexpr to give a compile-time error.
  void on_error(const char* message) { throw_format_error(message); }
};
FMT_END_DETAIL_NAMESPACE

/** String's character type. */
template <typename S> using char_t = typename detail::char_t_impl<S>::type;

/**
  \rst
  Parsing context consisting of a format string range being parsed and an
  argument counter for automatic indexing.
  You can use the ``format_parse_context`` type alias for ``char`` instead.
  \endrst
 */
template <typename Char, typename ErrorHandler = detail::error_handler>
class basic_format_parse_context : private ErrorHandler {
 private:
  basic_string_view<Char> format_str_;
  int next_arg_id_;

 public:
  using char_type = Char;
  using iterator = typename basic_string_view<Char>::iterator;

  explicit constexpr basic_format_parse_context(
      basic_string_view<Char> format_str, ErrorHandler eh = {},
      int next_arg_id = 0)
      : ErrorHandler(eh), format_str_(format_str), next_arg_id_(next_arg_id) {}

  /**
    Returns an iterator to the beginning of the format string range being
    parsed.
   */
  constexpr auto begin() const FMT_NOEXCEPT -> iterator {
    return format_str_.begin();
  }

  /**
    Returns an iterator past the end of the format string range being parsed.
   */
  constexpr auto end() const FMT_NOEXCEPT -> iterator {
    return format_str_.end();
  }

  /** Advances the begin iterator to ``it``. */
  FMT_CONSTEXPR void advance_to(iterator it) {
    format_str_.remove_prefix(detail::to_unsigned(it - begin()));
  }

  /**
    Reports an error if using the manual argument indexing; otherwise returns
    the next argument index and switches to the automatic indexing.
   */
  FMT_CONSTEXPR auto next_arg_id() -> int {
    // Don't check if the argument id is valid to avoid overhead and because it
    // will be checked during formatting anyway.
    if (next_arg_id_ >= 0) return next_arg_id_++;
    on_error("cannot switch from manual to automatic argument indexing");
    return 0;
  }

  /**
    Reports an error if using the automatic argument indexing; otherwise
    switches to the manual indexing.
   */
  FMT_CONSTEXPR void check_arg_id(int) {
    if (next_arg_id_ > 0)
      on_error("cannot switch from automatic to manual argument indexing");
    else
      next_arg_id_ = -1;
  }

  FMT_CONSTEXPR void check_arg_id(basic_string_view<Char>) {}

  FMT_CONSTEXPR void on_error(const char* message) {
    ErrorHandler::on_error(message);
  }

  constexpr auto error_handler() const -> ErrorHandler { return *this; }
};

using format_parse_context = basic_format_parse_context<char>;

template <typename Context> class basic_format_arg;
template <typename Context> class basic_format_args;
template <typename Context> class dynamic_format_arg_store;

// A formatter for objects of type T.
template <typename T, typename Char = char, typename Enable = void>
struct formatter {
  // A deleted default constructor indicates a disabled formatter.
  formatter() = delete;
};

// Specifies if T has an enabled formatter specialization. A type can be
// formattable even if it doesn't have a formatter e.g. via a conversion.
template <typename T, typename Context>
using has_formatter =
    std::is_constructible<typename Context::template formatter_type<T>>;

// Checks whether T is a container with contiguous storage.
template <typename T> struct is_contiguous : std::false_type {};
template <typename Char>
struct is_contiguous<std::basic_string<Char>> : std::true_type {};

class appender;

FMT_BEGIN_DETAIL_NAMESPACE

template <typename Context, typename T>
constexpr auto has_const_formatter_impl(T*)
    -> decltype(typename Context::template formatter_type<T>().format(
                    std::declval<const T&>(), std::declval<Context&>()),
                true) {
  return true;
}
template <typename Context>
constexpr auto has_const_formatter_impl(...) -> bool {
  return false;
}
template <typename T, typename Context>
constexpr auto has_const_formatter() -> bool {
  return has_const_formatter_impl<Context>(static_cast<T*>(nullptr));
}

// Extracts a reference to the container from back_insert_iterator.
template <typename Container>
inline auto get_container(std::back_insert_iterator<Container> it)
    -> Container& {
  using bi_iterator = std::back_insert_iterator<Container>;
  struct accessor : bi_iterator {
    accessor(bi_iterator iter) : bi_iterator(iter) {}
    using bi_iterator::container;
  };
  return *accessor(it).container;
}

template <typename Char, typename InputIt, typename OutputIt>
FMT_CONSTEXPR auto copy_str(InputIt begin, InputIt end, OutputIt out)
    -> OutputIt {
  while (begin != end) *out++ = static_cast<Char>(*begin++);
  return out;
}

template <typename Char, typename T, typename U,
          FMT_ENABLE_IF(
              std::is_same<remove_const_t<T>, U>::value&& is_char<U>::value)>
FMT_CONSTEXPR auto copy_str(T* begin, T* end, U* out) -> U* {
  if (is_constant_evaluated()) return copy_str<Char, T*, U*>(begin, end, out);
  auto size = to_unsigned(end - begin);
  memcpy(out, begin, size * sizeof(U));
  return out + size;
}

/**
  \rst
  A contiguous memory buffer with an optional growing ability. It is an internal
  class and shouldn't be used directly, only via `~fmt::basic_memory_buffer`.
  \endrst
 */
template <typename T> class buffer {
 private:
  T* ptr_;
  size_t size_;
  size_t capacity_;

 protected:
  // Don't initialize ptr_ since it is not accessed to save a few cycles.
  FMT_MSC_WARNING(suppress : 26495)
  buffer(size_t sz) FMT_NOEXCEPT : size_(sz), capacity_(sz) {}

  FMT_CONSTEXPR20 buffer(T* p = nullptr, size_t sz = 0,
                         size_t cap = 0) FMT_NOEXCEPT : ptr_(p),
                                                        size_(sz),
                                                        capacity_(cap) {}

  FMT_CONSTEXPR20 ~buffer() = default;
  buffer(buffer&&) = default;

  /** Sets the buffer data and capacity. */
  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) FMT_NOEXCEPT {
    ptr_ = buf_data;
    capacity_ = buf_capacity;
  }

  /** Increases the buffer capacity to hold at least *capacity* elements. */
  virtual FMT_CONSTEXPR20 void grow(size_t capacity) = 0;

 public:
  using value_type = T;
  using const_reference = const T&;

  buffer(const buffer&) = delete;
  void operator=(const buffer&) = delete;

  auto begin() FMT_NOEXCEPT -> T* { return ptr_; }
  auto end() FMT_NOEXCEPT -> T* { return ptr_ + size_; }

  auto begin() const FMT_NOEXCEPT -> const T* { return ptr_; }
  auto end() const FMT_NOEXCEPT -> const T* { return ptr_ + size_; }

  /** Returns the size of this buffer. */
  constexpr auto size() const FMT_NOEXCEPT -> size_t { return size_; }

  /** Returns the capacity of this buffer. */
  constexpr auto capacity() const FMT_NOEXCEPT -> size_t { return capacity_; }

  /** Returns a pointer to the buffer data. */
  FMT_CONSTEXPR auto data() FMT_NOEXCEPT -> T* { return ptr_; }

  /** Returns a pointer to the buffer data. */
  FMT_CONSTEXPR auto data() const FMT_NOEXCEPT -> const T* { return ptr_; }

  /** Clears this buffer. */
  void clear() { size_ = 0; }

  // Tries resizing the buffer to contain *count* elements. If T is a POD type
  // the new elements may not be initialized.
  FMT_CONSTEXPR20 void try_resize(size_t count) {
    try_reserve(count);
    size_ = count <= capacity_ ? count : capacity_;
  }

  // Tries increasing the buffer capacity to *new_capacity*. It can increase the
  // capacity by a smaller amount than requested but guarantees there is space
  // for at least one additional element either by increasing the capacity or by
  // flushing the buffer if it is full.
  FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
    if (new_capacity > capacity_) grow(new_capacity);
  }

  FMT_CONSTEXPR20 void push_back(const T& value) {
    try_reserve(size_ + 1);
    ptr_[size_++] = value;
  }

  /** Appends data to the end of the buffer. */
  template <typename U> void append(const U* begin, const U* end);

  template <typename I> FMT_CONSTEXPR auto operator[](I index) -> T& {
    return ptr_[index];
  }
  template <typename I>
  FMT_CONSTEXPR auto operator[](I index) const -> const T& {
    return ptr_[index];
  }
};

struct buffer_traits {
  explicit buffer_traits(size_t) {}
  auto count() const -> size_t { return 0; }
  auto limit(size_t size) -> size_t { return size; }
};

class fixed_buffer_traits {
 private:
  size_t count_ = 0;
  size_t limit_;

 public:
  explicit fixed_buffer_traits(size_t limit) : limit_(limit) {}
  auto count() const -> size_t { return count_; }
  auto limit(size_t size) -> size_t {
    size_t n = limit_ > count_ ? limit_ - count_ : 0;
    count_ += size;
    return size < n ? size : n;
  }
};

// A buffer that writes to an output iterator when flushed.
template <typename OutputIt, typename T, typename Traits = buffer_traits>
class iterator_buffer final : public Traits, public buffer<T> {
 private:
  OutputIt out_;
  enum { buffer_size = 256 };
  T data_[buffer_size];

 protected:
  void grow(size_t) override {
    if (this->size() == buffer_size) flush();
  }

  void flush() {
    auto size = this->size();
    this->clear();
    out_ = copy_str<T>(data_, data_ + this->limit(size), out_);
  }

 public:
  explicit iterator_buffer(OutputIt out, size_t n = buffer_size)
      : Traits(n), buffer<T>(data_, 0, buffer_size), out_(out) {}
  iterator_buffer(iterator_buffer&& other)
      : Traits(other), buffer<T>(data_, 0, buffer_size), out_(other.out_) {}
  ~iterator_buffer() { flush(); }

  auto out() -> OutputIt {
    flush();
    return out_;
  }
  auto count() const -> size_t { return Traits::count() + this->size(); }
};

template <typename T>
class iterator_buffer<T*, T, fixed_buffer_traits> final
    : public fixed_buffer_traits,
      public buffer<T> {
 private:
  T* out_;
  enum { buffer_size = 256 };
  T data_[buffer_size];

 protected:
  void grow(size_t) override {
    if (this->size() == this->capacity()) flush();
  }

  void flush() {
    size_t n = this->limit(this->size());
    if (this->data() == out_) {
      out_ += n;
      this->set(data_, buffer_size);
    }
    this->clear();
  }

 public:
  explicit iterator_buffer(T* out, size_t n = buffer_size)
      : fixed_buffer_traits(n), buffer<T>(out, 0, n), out_(out) {}
  iterator_buffer(iterator_buffer&& other)
      : fixed_buffer_traits(other),
        buffer<T>(std::move(other)),
        out_(other.out_) {
    if (this->data() != out_) {
      this->set(data_, buffer_size);
      this->clear();
    }
  }
  ~iterator_buffer() { flush(); }

  auto out() -> T* {
    flush();
    return out_;
  }
  auto count() const -> size_t {
    return fixed_buffer_traits::count() + this->size();
  }
};

template <typename T> class iterator_buffer<T*, T> final : public buffer<T> {
 protected:
  void grow(size_t) override {}

 public:
  explicit iterator_buffer(T* out, size_t = 0) : buffer<T>(out, 0, ~size_t()) {}

  auto out() -> T* { return &*this->end(); }
};

// A buffer that writes to a container with the contiguous storage.
template <typename Container>
class iterator_buffer<std::back_insert_iterator<Container>,
                      enable_if_t<is_contiguous<Container>::value,
                                  typename Container::value_type>>
    final : public buffer<typename Container::value_type> {
 private:
  Container& container_;

 protected:
  void grow(size_t capacity) override {
    container_.resize(capacity);
    this->set(&container_[0], capacity);
  }

 public:
  explicit iterator_buffer(Container& c)
      : buffer<typename Container::value_type>(c.size()), container_(c) {}
  explicit iterator_buffer(std::back_insert_iterator<Container> out, size_t = 0)
      : iterator_buffer(get_container(out)) {}
  auto out() -> std::back_insert_iterator<Container> {
    return std::back_inserter(container_);
  }
};

// A buffer that counts the number of code units written discarding the output.
template <typename T = char> class counting_buffer final : public buffer<T> {
 private:
  enum { buffer_size = 256 };
  T data_[buffer_size];
  size_t count_ = 0;

 protected:
  void grow(size_t) override {
    if (this->size() != buffer_size) return;
    count_ += this->size();
    this->clear();
  }

 public:
  counting_buffer() : buffer<T>(data_, 0, buffer_size) {}

  auto count() -> size_t { return count_ + this->size(); }
};

template <typename T>
using buffer_appender = conditional_t<std::is_same<T, char>::value, appender,
                                      std::back_insert_iterator<buffer<T>>>;

// Maps an output iterator to a buffer.
template <typename T, typename OutputIt>
auto get_buffer(OutputIt out) -> iterator_buffer<OutputIt, T> {
  return iterator_buffer<OutputIt, T>(out);
}

template <typename Buffer>
auto get_iterator(Buffer& buf) -> decltype(buf.out()) {
  return buf.out();
}
template <typename T> auto get_iterator(buffer<T>& buf) -> buffer_appender<T> {
  return buffer_appender<T>(buf);
}

template <typename T, typename Char = char, typename Enable = void>
struct fallback_formatter {
  fallback_formatter() = delete;
};

// Specifies if T has an enabled fallback_formatter specialization.
template <typename T, typename Char>
using has_fallback_formatter =
    std::is_constructible<fallback_formatter<T, Char>>;

struct view {};

template <typename Char, typename T> struct named_arg : view {
  const Char* name;
  const T& value;
  named_arg(const Char* n, const T& v) : name(n), value(v) {}
};

template <typename Char> struct named_arg_info {
  const Char* name;
  int id;
};

template <typename T, typename Char, size_t NUM_ARGS, size_t NUM_NAMED_ARGS>
struct arg_data {
  // args_[0].named_args points to named_args_ to avoid bloating format_args.
  // +1 to workaround a bug in gcc 7.5 that causes duplicated-branches warning.
  T args_[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)];
  named_arg_info<Char> named_args_[NUM_NAMED_ARGS];

  template <typename... U>
  arg_data(const U&... init) : args_{T(named_args_, NUM_NAMED_ARGS), init...} {}
  arg_data(const arg_data& other) = delete;
  auto args() const -> const T* { return args_ + 1; }
  auto named_args() -> named_arg_info<Char>* { return named_args_; }
};

template <typename T, typename Char, size_t NUM_ARGS>
struct arg_data<T, Char, NUM_ARGS, 0> {
  // +1 to workaround a bug in gcc 7.5 that causes duplicated-branches warning.
  T args_[NUM_ARGS != 0 ? NUM_ARGS : +1];

  template <typename... U>
  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
  FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
  FMT_CONSTEXPR FMT_INLINE auto named_args() -> std::nullptr_t {
    return nullptr;
  }
};

template <typename Char>
inline void init_named_args(named_arg_info<Char>*, int, int) {}

template <typename T> struct is_named_arg : std::false_type {};
template <typename T> struct is_statically_named_arg : std::false_type {};

template <typename T, typename Char>
struct is_named_arg<named_arg<Char, T>> : std::true_type {};

template <typename Char, typename T, typename... Tail,
          FMT_ENABLE_IF(!is_named_arg<T>::value)>
void init_named_args(named_arg_info<Char>* named_args, int arg_count,
                     int named_arg_count, const T&, const Tail&... args) {
  init_named_args(named_args, arg_count + 1, named_arg_count, args...);
}

template <typename Char, typename T, typename... Tail,
          FMT_ENABLE_IF(is_named_arg<T>::value)>
void init_named_args(named_arg_info<Char>* named_args, int arg_count,
                     int named_arg_count, const T& arg, const Tail&... args) {
  named_args[named_arg_count++] = {arg.name, arg_count};
  init_named_args(named_args, arg_count + 1, named_arg_count, args...);
}

template <typename... Args>
FMT_CONSTEXPR FMT_INLINE void init_named_args(std::nullptr_t, int, int,
                                              const Args&...) {}

template <bool B = false> constexpr auto count() -> size_t { return B ? 1 : 0; }
template <bool B1, bool B2, bool... Tail> constexpr auto count() -> size_t {
  return (B1 ? 1 : 0) + count<B2, Tail...>();
}

template <typename... Args> constexpr auto count_named_args() -> size_t {
  return count<is_named_arg<Args>::value...>();
}

enum class type {
  none_type,
  // Integer types should go first,
  int_type,
  uint_type,
  long_long_type,
  ulong_long_type,
  int128_type,
  uint128_type,
  bool_type,
  char_type,
  last_integer_type = char_type,
  // followed by floating-point types.
  float_type,
  double_type,
  long_double_type,
  last_numeric_type = long_double_type,
  cstring_type,
  string_type,
  pointer_type,
  custom_type
};

// Maps core type T to the corresponding type enum constant.
template <typename T, typename Char>
struct type_constant : std::integral_constant<type, type::custom_type> {};

#define FMT_TYPE_CONSTANT(Type, constant) \
  template <typename Char>                \
  struct type_constant<Type, Char>        \
      : std::integral_constant<type, type::constant> {}

FMT_TYPE_CONSTANT(int, int_type);
FMT_TYPE_CONSTANT(unsigned, uint_type);
FMT_TYPE_CONSTANT(long long, long_long_type);
FMT_TYPE_CONSTANT(unsigned long long, ulong_long_type);
FMT_TYPE_CONSTANT(int128_t, int128_type);
FMT_TYPE_CONSTANT(uint128_t, uint128_type);
FMT_TYPE_CONSTANT(bool, bool_type);
FMT_TYPE_CONSTANT(Char, char_type);
FMT_TYPE_CONSTANT(float, float_type);
FMT_TYPE_CONSTANT(double, double_type);
FMT_TYPE_CONSTANT(long double, long_double_type);
FMT_TYPE_CONSTANT(const Char*, cstring_type);
FMT_TYPE_CONSTANT(basic_string_view<Char>, string_type);
FMT_TYPE_CONSTANT(const void*, pointer_type);

constexpr bool is_integral_type(type t) {
  return t > type::none_type && t <= type::last_integer_type;
}

constexpr bool is_arithmetic_type(type t) {
  return t > type::none_type && t <= type::last_numeric_type;
}

struct unformattable {};
struct unformattable_char : unformattable {};
struct unformattable_const : unformattable {};
struct unformattable_pointer : unformattable {};

template <typename Char> struct string_value {
  const Char* data;
  size_t size;
};

template <typename Char> struct named_arg_value {
  const named_arg_info<Char>* data;
  size_t size;
};

template <typename Context> struct custom_value {
  using parse_context = typename Context::parse_context_type;
  void* value;
  void (*format)(void* arg, parse_context& parse_ctx, Context& ctx);
};

// A formatting argument value.
template <typename Context> class value {
 public:
  using char_type = typename Context::char_type;

  union {
    monostate no_value;
    int int_value;
    unsigned uint_value;
    long long long_long_value;
    unsigned long long ulong_long_value;
    int128_t int128_value;
    uint128_t uint128_value;
    bool bool_value;
    char_type char_value;
    float float_value;
    double double_value;
    long double long_double_value;
    const void* pointer;
    string_value<char_type> string;
    custom_value<Context> custom;
    named_arg_value<char_type> named_args;
  };

  constexpr FMT_INLINE value() : no_value() {}
  constexpr FMT_INLINE value(int val) : int_value(val) {}
  constexpr FMT_INLINE value(unsigned val) : uint_value(val) {}
  constexpr FMT_INLINE value(long long val) : long_long_value(val) {}
  constexpr FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
  FMT_INLINE value(int128_t val) : int128_value(val) {}
  FMT_INLINE value(uint128_t val) : uint128_value(val) {}
  constexpr FMT_INLINE value(float val) : float_value(val) {}
  constexpr FMT_INLINE value(double val) : double_value(val) {}
  FMT_INLINE value(long double val) : long_double_value(val) {}
  constexpr FMT_INLINE value(bool val) : bool_value(val) {}
  constexpr FMT_INLINE value(char_type val) : char_value(val) {}
  FMT_CONSTEXPR FMT_INLINE value(const char_type* val) {
    string.data = val;
    if (is_constant_evaluated()) string.size = {};
  }
  FMT_CONSTEXPR FMT_INLINE value(basic_string_view<char_type> val) {
    string.data = val.data();
    string.size = val.size();
  }
  FMT_INLINE value(const void* val) : pointer(val) {}
  FMT_INLINE value(const named_arg_info<char_type>* args, size_t size)
      : named_args{args, size} {}

  template <typename T> FMT_CONSTEXPR FMT_INLINE value(T& val) {
    using value_type = remove_cvref_t<T>;
    custom.value = const_cast<value_type*>(&val);
    // Get the formatter type through the context to allow different contexts
    // have different extension points, e.g. `formatter<T>` for `format` and
    // `printf_formatter<T>` for `printf`.
    custom.format = format_custom_arg<
        value_type,
        conditional_t<has_formatter<value_type, Context>::value,
                      typename Context::template formatter_type<value_type>,
                      fallback_formatter<value_type, char_type>>>;
  }
  value(unformattable);
  value(unformattable_char);
  value(unformattable_const);
  value(unformattable_pointer);

 private:
  // Formats an argument of a custom type, such as a user-defined class.
  template <typename T, typename Formatter>
  static void format_custom_arg(void* arg,
                                typename Context::parse_context_type& parse_ctx,
                                Context& ctx) {
    auto f = Formatter();
    parse_ctx.advance_to(f.parse(parse_ctx));
    using qualified_type =
        conditional_t<has_const_formatter<T, Context>(), const T, T>;
    ctx.advance_to(f.format(*static_cast<qualified_type*>(arg), ctx));
  }
};

template <typename Context, typename T>
FMT_CONSTEXPR auto make_arg(const T& value) -> basic_format_arg<Context>;

// To minimize the number of types we need to deal with, long is translated
// either to int or to long long depending on its size.
enum { long_short = sizeof(long) == sizeof(int) };
using long_type = conditional_t<long_short, int, long long>;
using ulong_type = conditional_t<long_short, unsigned, unsigned long long>;

// Maps formatting arguments to core types.
// arg_mapper reports errors by returning unformattable instead of using
// static_assert because it's used in the is_formattable trait.
template <typename Context> struct arg_mapper {
  using char_type = typename Context::char_type;

  FMT_CONSTEXPR FMT_INLINE auto map(signed char val) -> int { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(unsigned char val) -> unsigned {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(short val) -> int { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(unsigned short val) -> unsigned {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(int val) -> int { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(unsigned val) -> unsigned { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(long val) -> long_type { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(unsigned long val) -> ulong_type {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(long long val) -> long long { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(unsigned long long val)
      -> unsigned long long {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(int128_t val) -> int128_t { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(uint128_t val) -> uint128_t { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(bool val) -> bool { return val; }

  template <typename T, FMT_ENABLE_IF(std::is_same<T, char>::value ||
                                      std::is_same<T, char_type>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(T val) -> char_type {
    return val;
  }
  template <typename T, enable_if_t<(std::is_same<T, wchar_t>::value ||
#ifdef __cpp_char8_t
                                     std::is_same<T, char8_t>::value ||
#endif
                                     std::is_same<T, char16_t>::value ||
                                     std::is_same<T, char32_t>::value) &&
                                        !std::is_same<T, char_type>::value,
                                    int> = 0>
  FMT_CONSTEXPR FMT_INLINE auto map(T) -> unformattable_char {
    return {};
  }

  FMT_CONSTEXPR FMT_INLINE auto map(float val) -> float { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(double val) -> double { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(long double val) -> long double {
    return val;
  }

  FMT_CONSTEXPR FMT_INLINE auto map(char_type* val) -> const char_type* {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(const char_type* val) -> const char_type* {
    return val;
  }
  template <typename T,
            FMT_ENABLE_IF(is_string<T>::value && !std::is_pointer<T>::value &&
                          std::is_same<char_type, char_t<T>>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
      -> basic_string_view<char_type> {
    return to_string_view(val);
  }
  template <typename T,
            FMT_ENABLE_IF(is_string<T>::value && !std::is_pointer<T>::value &&
                          !std::is_same<char_type, char_t<T>>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T&) -> unformattable_char {
    return {};
  }
  template <typename T,
            FMT_ENABLE_IF(
                std::is_constructible<basic_string_view<char_type>, T>::value &&
                !is_string<T>::value && !has_formatter<T, Context>::value &&
                !has_fallback_formatter<T, char_type>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
      -> basic_string_view<char_type> {
    return basic_string_view<char_type>(val);
  }
  template <
      typename T,
      FMT_ENABLE_IF(
          std::is_constructible<std_string_view<char_type>, T>::value &&
          !std::is_constructible<basic_string_view<char_type>, T>::value &&
          !is_string<T>::value && !has_formatter<T, Context>::value &&
          !has_fallback_formatter<T, char_type>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
      -> basic_string_view<char_type> {
    return std_string_view<char_type>(val);
  }
  FMT_CONSTEXPR FMT_INLINE auto map(const signed char* val)
      -> decltype(this->map("")) {
    return map(reinterpret_cast<const char*>(val));
  }
  FMT_CONSTEXPR FMT_INLINE auto map(const unsigned char* val)
      -> decltype(this->map("")) {
    return map(reinterpret_cast<const char*>(val));
  }
  FMT_CONSTEXPR FMT_INLINE auto map(signed char* val)
      -> decltype(this->map("")) {
    return map(reinterpret_cast<const char*>(val));
  }
  FMT_CONSTEXPR FMT_INLINE auto map(unsigned char* val)
      -> decltype(this->map("")) {
    return map(reinterpret_cast<const char*>(val));
  }

  FMT_CONSTEXPR FMT_INLINE auto map(void* val) -> const void* { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(const void* val) -> const void* {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(std::nullptr_t val) -> const void* {
    return val;
  }

  // We use SFINAE instead of a const T* parameter to avoid conflicting with
  // the C array overload.
  template <
      typename T,
      FMT_ENABLE_IF(std::is_convertible<const T&, const void*>::value &&
                    !std::is_convertible<const T&, const char_type*>::value)>
  FMT_CONSTEXPR auto map(const T&) -> unformattable_pointer {
    return {};
  }

  template <typename T, std::size_t N,
            FMT_ENABLE_IF(!std::is_same<T, wchar_t>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T (&values)[N]) -> const T (&)[N] {
    return values;
  }

  template <typename T,
            FMT_ENABLE_IF(std::is_enum<T>::value &&
                          !has_formatter<T, Context>::value &&
                          !has_fallback_formatter<T, char_type>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
      -> decltype(std::declval<arg_mapper>().map(
          static_cast<typename std::underlying_type<T>::type>(val))) {
    return map(static_cast<typename std::underlying_type<T>::type>(val));
  }

  template <typename T, typename U = remove_cvref_t<T>>
  struct formattable
      : bool_constant<has_const_formatter<U, Context>() ||
                      !std::is_const<remove_reference_t<T>>::value ||
                      has_fallback_formatter<U, char_type>::value> {};

#if FMT_MSC_VER != 0 && FMT_MSC_VER < 1910
  // Workaround a bug in MSVC.
  template <typename T> FMT_CONSTEXPR FMT_INLINE auto do_map(T&& val) -> T& {
    return val;
  }
#else
  template <typename T, FMT_ENABLE_IF(formattable<T>::value)>
  FMT_CONSTEXPR FMT_INLINE auto do_map(T&& val) -> T& {
    return val;
  }
  template <typename T, FMT_ENABLE_IF(!formattable<T>::value)>
  FMT_CONSTEXPR FMT_INLINE auto do_map(T&&) -> unformattable_const {
    return {};
  }
#endif

  template <typename T, typename U = remove_cvref_t<T>,
            FMT_ENABLE_IF(!is_string<U>::value && !is_char<U>::value &&
                          !std::is_array<U>::value &&
                          (has_formatter<U, Context>::value ||
                           has_fallback_formatter<U, char_type>::value))>
  FMT_CONSTEXPR FMT_INLINE auto map(T&& val)
      -> decltype(this->do_map(std::forward<T>(val))) {
    return do_map(std::forward<T>(val));
  }

  template <typename T, FMT_ENABLE_IF(is_named_arg<T>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T& named_arg)
      -> decltype(std::declval<arg_mapper>().map(named_arg.value)) {
    return map(named_arg.value);
  }

  auto map(...) -> unformattable { return {}; }
};

// A type constant after applying arg_mapper<Context>.
template <typename T, typename Context>
using mapped_type_constant =
    type_constant<decltype(arg_mapper<Context>().map(std::declval<const T&>())),
                  typename Context::char_type>;

enum { packed_arg_bits = 4 };
// Maximum number of arguments with packed types.
enum { max_packed_args = 62 / packed_arg_bits };
enum : unsigned long long { is_unpacked_bit = 1ULL << 63 };
enum : unsigned long long { has_named_args_bit = 1ULL << 62 };

FMT_END_DETAIL_NAMESPACE

// An output iterator that appends to a buffer.
// It is used to reduce symbol sizes for the common case.
class appender : public std::back_insert_iterator<detail::buffer<char>> {
  using base = std::back_insert_iterator<detail::buffer<char>>;

  template <typename T>
  friend auto get_buffer(appender out) -> detail::buffer<char>& {
    return detail::get_container(out);
  }

 public:
  using std::back_insert_iterator<detail::buffer<char>>::back_insert_iterator;
  appender(base it) : base(it) {}
  using _Unchecked_type = appender;  // Mark iterator as checked.

  auto operator++() -> appender& {
    base::operator++();
    return *this;
  }

  auto operator++(int) -> appender {
    auto tmp = *this;
    ++*this;
    return tmp;
  }
};

// A formatting argument. It is a trivially copyable/constructible type to
// allow storage in basic_memory_buffer.
template <typename Context> class basic_format_arg {
 private:
  detail::value<Context> value_;
  detail::type type_;

  template <typename ContextType, typename T>
  friend FMT_CONSTEXPR auto detail::make_arg(const T& value)
      -> basic_format_arg<ContextType>;

  template <typename Visitor, typename Ctx>
  friend FMT_CONSTEXPR auto visit_format_arg(Visitor&& vis,
                                             const basic_format_arg<Ctx>& arg)
      -> decltype(vis(0));

  friend class basic_format_args<Context>;
  friend class dynamic_format_arg_store<Context>;

  using char_type = typename Context::char_type;

  template <typename T, typename Char, size_t NUM_ARGS, size_t NUM_NAMED_ARGS>
  friend struct detail::arg_data;

  basic_format_arg(const detail::named_arg_info<char_type>* args, size_t size)
      : value_(args, size) {}

 public:
  class handle {
   public:
    explicit handle(detail::custom_value<Context> custom) : custom_(custom) {}

    void format(typename Context::parse_context_type& parse_ctx,
                Context& ctx) const {
      custom_.format(custom_.value, parse_ctx, ctx);
    }

   private:
    detail::custom_value<Context> custom_;
  };

  constexpr basic_format_arg() : type_(detail::type::none_type) {}

  constexpr explicit operator bool() const FMT_NOEXCEPT {
    return type_ != detail::type::none_type;
  }

  auto type() const -> detail::type { return type_; }

  auto is_integral() const -> bool { return detail::is_integral_type(type_); }
  auto is_arithmetic() const -> bool {
    return detail::is_arithmetic_type(type_);
  }
};

/**
  \rst
  Visits an argument dispatching to the appropriate visit method based on
  the argument type. For example, if the argument type is ``double`` then
  ``vis(value)`` will be called with the value of type ``double``.
  \endrst
 */
template <typename Visitor, typename Context>
FMT_CONSTEXPR FMT_INLINE auto visit_format_arg(
    Visitor&& vis, const basic_format_arg<Context>& arg) -> decltype(vis(0)) {
  switch (arg.type_) {
  case detail::type::none_type:
    break;
  case detail::type::int_type:
    return vis(arg.value_.int_value);
  case detail::type::uint_type:
    return vis(arg.value_.uint_value);
  case detail::type::long_long_type:
    return vis(arg.value_.long_long_value);
  case detail::type::ulong_long_type:
    return vis(arg.value_.ulong_long_value);
  case detail::type::int128_type:
    return vis(detail::convert_for_visit(arg.value_.int128_value));
  case detail::type::uint128_type:
    return vis(detail::convert_for_visit(arg.value_.uint128_value));
  case detail::type::bool_type:
    return vis(arg.value_.bool_value);
  case detail::type::char_type:
    return vis(arg.value_.char_value);
  case detail::type::float_type:
    return vis(arg.value_.float_value);
  case detail::type::double_type:
    return vis(arg.value_.double_value);
  case detail::type::long_double_type:
    return vis(arg.value_.long_double_value);
  case detail::type::cstring_type:
    return vis(arg.value_.string.data);
  case detail::type::string_type:
    using sv = basic_string_view<typename Context::char_type>;
    return vis(sv(arg.value_.string.data, arg.value_.string.size));
  case detail::type::pointer_type:
    return vis(arg.value_.pointer);
  case detail::type::custom_type:
    return vis(typename basic_format_arg<Context>::handle(arg.value_.custom));
  }
  return vis(monostate());
}

FMT_BEGIN_DETAIL_NAMESPACE

template <typename Char, typename InputIt>
auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
  get_container(out).append(begin, end);
  return out;
}

#if FMT_GCC_VERSION && FMT_GCC_VERSION < 500
// A workaround for gcc 4.8 to make void_t work in a SFINAE context.
template <typename... Ts> struct void_t_impl { using type = void; };
template <typename... Ts>
using void_t = typename detail::void_t_impl<Ts...>::type;
#else
template <typename...> using void_t = void;
#endif

template <typename It, typename T, typename Enable = void>
struct is_output_iterator : std::false_type {};

template <typename It, typename T>
struct is_output_iterator<
    It, T,
    void_t<typename std::iterator_traits<It>::iterator_category,
           decltype(*std::declval<It>() = std::declval<T>())>>
    : std::true_type {};

template <typename OutputIt>
struct is_back_insert_iterator : std::false_type {};
template <typename Container>
struct is_back_insert_iterator<std::back_insert_iterator<Container>>
    : std::true_type {};

template <typename OutputIt>
struct is_contiguous_back_insert_iterator : std::false_type {};
template <typename Container>
struct is_contiguous_back_insert_iterator<std::back_insert_iterator<Container>>
    : is_contiguous<Container> {};
template <>
struct is_contiguous_back_insert_iterator<appender> : std::true_type {};

// A type-erased reference to an std::locale to avoid heavy <locale> include.
class locale_ref {
 private:
  const void* locale_;  // A type-erased pointer to std::locale.

 public:
  constexpr locale_ref() : locale_(nullptr) {}
  template <typename Locale> explicit locale_ref(const Locale& loc);

  explicit operator bool() const FMT_NOEXCEPT { return locale_ != nullptr; }

  template <typename Locale> auto get() const -> Locale;
};

template <typename> constexpr auto encode_types() -> unsigned long long {
  return 0;
}

template <typename Context, typename Arg, typename... Args>
constexpr auto encode_types() -> unsigned long long {
  return static_cast<unsigned>(mapped_type_constant<Arg, Context>::value) |
         (encode_types<Context, Args...>() << packed_arg_bits);
}

template <typename Context, typename T>
FMT_CONSTEXPR auto make_arg(const T& value) -> basic_format_arg<Context> {
  basic_format_arg<Context> arg;
  arg.type_ = mapped_type_constant<T, Context>::value;
  arg.value_ = arg_mapper<Context>().map(value);
  return arg;
}

// The type template parameter is there to avoid an ODR violation when using
// a fallback formatter in one translation unit and an implicit conversion in
// another (not recommended).
template <bool IS_PACKED, typename Context, type, typename T,
          FMT_ENABLE_IF(IS_PACKED)>
FMT_CONSTEXPR FMT_INLINE auto make_arg(T&& val) -> value<Context> {
  const auto& arg = arg_mapper<Context>().map(std::forward<T>(val));

  constexpr bool formattable_char =
      !std::is_same<decltype(arg), const unformattable_char&>::value;
  static_assert(formattable_char, "Mixing character types is disallowed.");

  constexpr bool formattable_const =
      !std::is_same<decltype(arg), const unformattable_const&>::value;
  static_assert(formattable_const, "Cannot format a const argument.");

  // Formatting of arbitrary pointers is disallowed. If you want to output
  // a pointer cast it to "void *" or "const void *". In particular, this
  // forbids formatting of "[const] volatile char *" which is printed as bool
  // by iostreams.
  constexpr bool formattable_pointer =
      !std::is_same<decltype(arg), const unformattable_pointer&>::value;
  static_assert(formattable_pointer,
                "Formatting of non-void pointers is disallowed.");

  constexpr bool formattable =
      !std::is_same<decltype(arg), const unformattable&>::value;
  static_assert(
      formattable,
      "Cannot format an argument. To make type T formattable provide a "
      "formatter<T> specialization: https://fmt.dev/latest/api.html#udt");
  return {arg};
}

template <bool IS_PACKED, typename Context, type, typename T,
          FMT_ENABLE_IF(!IS_PACKED)>
inline auto make_arg(const T& value) -> basic_format_arg<Context> {
  return make_arg<Context>(value);
}
FMT_END_DETAIL_NAMESPACE

// Formatting context.
template <typename OutputIt, typename Char> class basic_format_context {
 public:
  /** The character type for the output. */
  using char_type = Char;

 private:
  OutputIt out_;
  basic_format_args<basic_format_context> args_;
  detail::locale_ref loc_;

 public:
  using iterator = OutputIt;
  using format_arg = basic_format_arg<basic_format_context>;
  using parse_context_type = basic_format_parse_context<Char>;
  template <typename T> using formatter_type = formatter<T, char_type>;

  basic_format_context(basic_format_context&&) = default;
  basic_format_context(const basic_format_context&) = delete;
  void operator=(const basic_format_context&) = delete;
  /**
   Constructs a ``basic_format_context`` object. References to the arguments are
   stored in the object so make sure they have appropriate lifetimes.
   */
  constexpr basic_format_context(
      OutputIt out, basic_format_args<basic_format_context> ctx_args,
      detail::locale_ref loc = detail::locale_ref())
      : out_(out), args_(ctx_args), loc_(loc) {}

  constexpr auto arg(int id) const -> format_arg { return args_.get(id); }
  FMT_CONSTEXPR auto arg(basic_string_view<char_type> name) -> format_arg {
    return args_.get(name);
  }
  FMT_CONSTEXPR auto arg_id(basic_string_view<char_type> name) -> int {
    return args_.get_id(name);
  }
  auto args() const -> const basic_format_args<basic_format_context>& {
    return args_;
  }

  FMT_CONSTEXPR auto error_handler() -> detail::error_handler { return {}; }
  void on_error(const char* message) { error_handler().on_error(message); }

  // Returns an iterator to the beginning of the output range.
  FMT_CONSTEXPR auto out() -> iterator { return out_; }

  // Advances the begin iterator to ``it``.
  void advance_to(iterator it) {
    if (!detail::is_back_insert_iterator<iterator>()) out_ = it;
  }

  FMT_CONSTEXPR auto locale() -> detail::locale_ref { return loc_; }
};

template <typename Char>
using buffer_context =
    basic_format_context<detail::buffer_appender<Char>, Char>;
using format_context = buffer_context<char>;

// Workaround an alias issue: https://stackoverflow.com/q/62767544/471164.
#define FMT_BUFFER_CONTEXT(Char) \
  basic_format_context<detail::buffer_appender<Char>, Char>

template <typename T, typename Char = char>
using is_formattable = bool_constant<
    !std::is_base_of<detail::unformattable,
                     decltype(detail::arg_mapper<buffer_context<Char>>().map(
                         std::declval<T>()))>::value &&
    !detail::has_fallback_formatter<T, Char>::value>;

/**
  \rst
  An array of references to arguments. It can be implicitly converted into
  `~fmt::basic_format_args` for passing into type-erased formatting functions
  such as `~fmt::vformat`.
  \endrst
 */
template <typename Context, typename... Args>
class format_arg_store
#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
    // Workaround a GCC template argument substitution bug.
    : public basic_format_args<Context>
#endif
{
 private:
  static const size_t num_args = sizeof...(Args);
  static const size_t num_named_args = detail::count_named_args<Args...>();
  static const bool is_packed = num_args <= detail::max_packed_args;

  using value_type = conditional_t<is_packed, detail::value<Context>,
                                   basic_format_arg<Context>>;

  detail::arg_data<value_type, typename Context::char_type, num_args,
                   num_named_args>
      data_;

  friend class basic_format_args<Context>;

  static constexpr unsigned long long desc =
      (is_packed ? detail::encode_types<Context, Args...>()
                 : detail::is_unpacked_bit | num_args) |
      (num_named_args != 0
           ? static_cast<unsigned long long>(detail::has_named_args_bit)
           : 0);

 public:
  template <typename... T>
  FMT_CONSTEXPR FMT_INLINE format_arg_store(T&&... args)
      :
#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
        basic_format_args<Context>(*this),
#endif
        data_{detail::make_arg<
            is_packed, Context,
            detail::mapped_type_constant<remove_cvref_t<T>, Context>::value>(
            std::forward<T>(args))...} {
    detail::init_named_args(data_.named_args(), 0, 0, args...);
  }
};

/**
  \rst
  Constructs a `~fmt::format_arg_store` object that contains references to
  arguments and can be implicitly converted to `~fmt::format_args`. `Context`
  can be omitted in which case it defaults to `~fmt::context`.
  See `~fmt::arg` for lifetime considerations.
  \endrst
 */
template <typename Context = format_context, typename... Args>
constexpr auto make_format_args(Args&&... args)
    -> format_arg_store<Context, remove_cvref_t<Args>...> {
  return {std::forward<Args>(args)...};
}

/**
  \rst
  Returns a named argument to be used in a formatting function.
  It should only be used in a call to a formatting function or
  `dynamic_format_arg_store::push_back`.

  **Example**::

    fmt::print("Elapsed time: {s:.2f} seconds", fmt::arg("s", 1.23));
  \endrst
 */
template <typename Char, typename T>
inline auto arg(const Char* name, const T& arg) -> detail::named_arg<Char, T> {
  static_assert(!detail::is_named_arg<T>(), "nested named arguments");
  return {name, arg};
}

/**
  \rst
  A view of a collection of formatting arguments. To avoid lifetime issues it
  should only be used as a parameter type in type-erased functions such as
  ``vformat``::

    void vlog(string_view format_str, format_args args);  // OK
    format_args args = make_format_args(42);  // Error: dangling reference
  \endrst
 */
template <typename Context> class basic_format_args {
 public:
  using size_type = int;
  using format_arg = basic_format_arg<Context>;

 private:
  // A descriptor that contains information about formatting arguments.
  // If the number of arguments is less or equal to max_packed_args then
  // argument types are passed in the descriptor. This reduces binary code size
  // per formatting function call.
  unsigned long long desc_;
  union {
    // If is_packed() returns true then argument values are stored in values_;
    // otherwise they are stored in args_. This is done to improve cache
    // locality and reduce compiled code size since storing larger objects
    // may require more code (at least on x86-64) even if the same amount of
    // data is actually copied to stack. It saves ~10% on the bloat test.
    const detail::value<Context>* values_;
    const format_arg* args_;
  };

  constexpr auto is_packed() const -> bool {
    return (desc_ & detail::is_unpacked_bit) == 0;
  }
  auto has_named_args() const -> bool {
    return (desc_ & detail::has_named_args_bit) != 0;
  }

  FMT_CONSTEXPR auto type(int index) const -> detail::type {
    int shift = index * detail::packed_arg_bits;
    unsigned int mask = (1 << detail::packed_arg_bits) - 1;
    return static_cast<detail::type>((desc_ >> shift) & mask);
  }

  constexpr FMT_INLINE basic_format_args(unsigned long long desc,
                                         const detail::value<Context>* values)
      : desc_(desc), values_(values) {}
  constexpr basic_format_args(unsigned long long desc, const format_arg* args)
      : desc_(desc), args_(args) {}

 public:
  constexpr basic_format_args() : desc_(0), args_(nullptr) {}

  /**
   \rst
   Constructs a `basic_format_args` object from `~fmt::format_arg_store`.
   \endrst
   */
  template <typename... Args>
  constexpr FMT_INLINE basic_format_args(
      const format_arg_store<Context, Args...>& store)
      : basic_format_args(format_arg_store<Context, Args...>::desc,
                          store.data_.args()) {}

  /**
   \rst
   Constructs a `basic_format_args` object from
   `~fmt::dynamic_format_arg_store`.
   \endrst
   */
  constexpr FMT_INLINE basic_format_args(
      const dynamic_format_arg_store<Context>& store)
      : basic_format_args(store.get_types(), store.data()) {}

  /**
   \rst
   Constructs a `basic_format_args` object from a dynamic set of arguments.
   \endrst
   */
  constexpr basic_format_args(const format_arg* args, int count)
      : basic_format_args(detail::is_unpacked_bit | detail::to_unsigned(count),
                          args) {}

  /** Returns the argument with the specified id. */
  FMT_CONSTEXPR auto get(int id) const -> format_arg {
    format_arg arg;
    if (!is_packed()) {
      if (id < max_size()) arg = args_[id];
      return arg;
    }
    if (id >= detail::max_packed_args) return arg;
    arg.type_ = type(id);
    if (arg.type_ == detail::type::none_type) return arg;
    arg.value_ = values_[id];
    return arg;
  }

  template <typename Char>
  auto get(basic_string_view<Char> name) const -> format_arg {
    int id = get_id(name);
    return id >= 0 ? get(id) : format_arg();
  }

  template <typename Char>
  auto get_id(basic_string_view<Char> name) const -> int {
    if (!has_named_args()) return -1;
    const auto& named_args =
        (is_packed() ? values_[-1] : args_[-1].value_).named_args;
    for (size_t i = 0; i < named_args.size; ++i) {
      if (named_args.data[i].name == name) return named_args.data[i].id;
    }
    return -1;
  }

  auto max_size() const -> int {
    unsigned long long max_packed = detail::max_packed_args;
    return static_cast<int>(is_packed() ? max_packed
                                        : desc_ & ~detail::is_unpacked_bit);
  }
};

/** An alias to ``basic_format_args<format_context>``. */
// A separate type would result in shorter symbols but break ABI compatibility
// between clang and gcc on ARM (#1919).
using format_args = basic_format_args<format_context>;

// We cannot use enum classes as bit fields because of a gcc bug
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414.
namespace align {
enum type { none, left, right, center, numeric };
}
using align_t = align::type;
namespace sign {
enum type { none, minus, plus, space };
}
using sign_t = sign::type;

FMT_BEGIN_DETAIL_NAMESPACE

// Workaround an array initialization issue in gcc 4.8.
template <typename Char> struct fill_t {
 private:
  enum { max_size = 4 };
  Char data_[max_size] = {Char(' '), Char(0), Char(0), Char(0)};
  unsigned char size_ = 1;

 public:
  FMT_CONSTEXPR void operator=(basic_string_view<Char> s) {
    auto size = s.size();
    if (size > max_size) return throw_format_error("invalid fill");
    for (size_t i = 0; i < size; ++i) data_[i] = s[i];
    size_ = static_cast<unsigned char>(size);
  }

  constexpr auto size() const -> size_t { return size_; }
  constexpr auto data() const -> const Char* { return data_; }

  FMT_CONSTEXPR auto operator[](size_t index) -> Char& { return data_[index]; }
  FMT_CONSTEXPR auto operator[](size_t index) const -> const Char& {
    return data_[index];
  }
};
FMT_END_DETAIL_NAMESPACE

enum class presentation_type : unsigned char {
  none,
  // Integer types should go first,
  dec,             // 'd'
  oct,             // 'o'
  hex_lower,       // 'x'
  hex_upper,       // 'X'
  bin_lower,       // 'b'
  bin_upper,       // 'B'
  hexfloat_lower,  // 'a'
  hexfloat_upper,  // 'A'
  exp_lower,       // 'e'
  exp_upper,       // 'E'
  fixed_lower,     // 'f'
  fixed_upper,     // 'F'
  general_lower,   // 'g'
  general_upper,   // 'G'
  chr,             // 'c'
  string,          // 's'
  pointer          // 'p'
};

// Format specifiers for built-in and string types.
template <typename Char> struct basic_format_specs {
  int width;
  int precision;
  presentation_type type;
  align_t align : 4;
  sign_t sign : 3;
  bool alt : 1;  // Alternate form ('#').
  bool localized : 1;
  detail::fill_t<Char> fill;

  constexpr basic_format_specs()
      : width(0),
        precision(-1),
        type(presentation_type::none),
        align(align::none),
        sign(sign::none),
        alt(false),
        localized(false) {}
};

using format_specs = basic_format_specs<char>;

FMT_BEGIN_DETAIL_NAMESPACE

enum class arg_id_kind { none, index, name };

// An argument reference.
template <typename Char> struct arg_ref {
  FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}

  FMT_CONSTEXPR explicit arg_ref(int index)
      : kind(arg_id_kind::index), val(index) {}
  FMT_CONSTEXPR explicit arg_ref(basic_string_view<Char> name)
      : kind(arg_id_kind::name), val(name) {}

  FMT_CONSTEXPR auto operator=(int idx) -> arg_ref& {
    kind = arg_id_kind::index;
    val.index = idx;
    return *this;
  }

  arg_id_kind kind;
  union value {
    FMT_CONSTEXPR value(int id = 0) : index{id} {}
    FMT_CONSTEXPR value(basic_string_view<Char> n) : name(n) {}

    int index;
    basic_string_view<Char> name;
  } val;
};

// Format specifiers with width and precision resolved at formatting rather
// than parsing time to allow re-using the same parsed specifiers with
// different sets of arguments (precompilation of format strings).
template <typename Char>
struct dynamic_format_specs : basic_format_specs<Char> {
  arg_ref<Char> width_ref;
  arg_ref<Char> precision_ref;
};

struct auto_id {};

// A format specifier handler that sets fields in basic_format_specs.
template <typename Char> class specs_setter {
 protected:
  basic_format_specs<Char>& specs_;

 public:
  explicit FMT_CONSTEXPR specs_setter(basic_format_specs<Char>& specs)
      : specs_(specs) {}

  FMT_CONSTEXPR specs_setter(const specs_setter& other)
      : specs_(other.specs_) {}

  FMT_CONSTEXPR void on_align(align_t align) { specs_.align = align; }
  FMT_CONSTEXPR void on_fill(basic_string_view<Char> fill) {
    specs_.fill = fill;
  }
  FMT_CONSTEXPR void on_sign(sign_t s) { specs_.sign = s; }
  FMT_CONSTEXPR void on_hash() { specs_.alt = true; }
  FMT_CONSTEXPR void on_localized() { specs_.localized = true; }

  FMT_CONSTEXPR void on_zero() {
    if (specs_.align == align::none) specs_.align = align::numeric;
    specs_.fill[0] = Char('0');
  }

  FMT_CONSTEXPR void on_width(int width) { specs_.width = width; }
  FMT_CONSTEXPR void on_precision(int precision) {
    specs_.precision = precision;
  }
  FMT_CONSTEXPR void end_precision() {}

  FMT_CONSTEXPR void on_type(presentation_type type) { specs_.type = type; }
};

// Format spec handler that saves references to arguments representing dynamic
// width and precision to be resolved at formatting time.
template <typename ParseContext>
class dynamic_specs_handler
    : public specs_setter<typename ParseContext::char_type> {
 public:
  using char_type = typename ParseContext::char_type;

  FMT_CONSTEXPR dynamic_specs_handler(dynamic_format_specs<char_type>& specs,
                                      ParseContext& ctx)
      : specs_setter<char_type>(specs), specs_(specs), context_(ctx) {}

  FMT_CONSTEXPR dynamic_specs_handler(const dynamic_specs_handler& other)
      : specs_setter<char_type>(other),
        specs_(other.specs_),
        context_(other.context_) {}

  template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
    specs_.width_ref = make_arg_ref(arg_id);
  }

  template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
    specs_.precision_ref = make_arg_ref(arg_id);
  }

  FMT_CONSTEXPR void on_error(const char* message) {
    context_.on_error(message);
  }

 private:
  dynamic_format_specs<char_type>& specs_;
  ParseContext& context_;

  using arg_ref_type = arg_ref<char_type>;

  FMT_CONSTEXPR auto make_arg_ref(int arg_id) -> arg_ref_type {
    context_.check_arg_id(arg_id);
    return arg_ref_type(arg_id);
  }

  FMT_CONSTEXPR auto make_arg_ref(auto_id) -> arg_ref_type {
    return arg_ref_type(context_.next_arg_id());
  }

  FMT_CONSTEXPR auto make_arg_ref(basic_string_view<char_type> arg_id)
      -> arg_ref_type {
    context_.check_arg_id(arg_id);
    basic_string_view<char_type> format_str(
        context_.begin(), to_unsigned(context_.end() - context_.begin()));
    return arg_ref_type(arg_id);
  }
};

template <typename Char> constexpr bool is_ascii_letter(Char c) {
  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

// Converts a character to ASCII. Returns a number > 127 on conversion failure.
template <typename Char, FMT_ENABLE_IF(std::is_integral<Char>::value)>
constexpr auto to_ascii(Char value) -> Char {
  return value;
}
template <typename Char, FMT_ENABLE_IF(std::is_enum<Char>::value)>
constexpr auto to_ascii(Char value) ->
    typename std::underlying_type<Char>::type {
  return value;
}

template <typename Char>
FMT_CONSTEXPR auto code_point_length(const Char* begin) -> int {
  if (const_check(sizeof(Char) != 1)) return 1;
  auto lengths =
      "\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0\0\0\0\2\2\2\2\3\3\4";
  int len = lengths[static_cast<unsigned char>(*begin) >> 3];

  // Compute the pointer to the next character early so that the next
  // iteration can start working on the next character. Neither Clang
  // nor GCC figure out this reordering on their own.
  return len + !len;
}

// Return the result via the out param to workaround gcc bug 77539.
template <bool IS_CONSTEXPR, typename T, typename Ptr = const T*>
FMT_CONSTEXPR auto find(Ptr first, Ptr last, T value, Ptr& out) -> bool {
  for (out = first; out != last; ++out) {
    if (*out == value) return true;
  }
  return false;
}

template <>
inline auto find<false, char>(const char* first, const char* last, char value,
                              const char*& out) -> bool {
  out = static_cast<const char*>(
      std::memchr(first, value, to_unsigned(last - first)));
  return out != nullptr;
}

// Parses the range [begin, end) as an unsigned integer. This function assumes
// that the range is non-empty and the first character is a digit.
template <typename Char>
FMT_CONSTEXPR auto parse_nonnegative_int(const Char*& begin, const Char* end,
                                         int error_value) noexcept -> int {
  FMT_ASSERT(begin != end && '0' <= *begin && *begin <= '9', "");
  unsigned value = 0, prev = 0;
  auto p = begin;
  do {
    prev = value;
    value = value * 10 + unsigned(*p - '0');
    ++p;
  } while (p != end && '0' <= *p && *p <= '9');
  auto num_digits = p - begin;
  begin = p;
  if (num_digits <= std::numeric_limits<int>::digits10)
    return static_cast<int>(value);
  // Check for overflow.
  const unsigned max = to_unsigned((std::numeric_limits<int>::max)());
  return num_digits == std::numeric_limits<int>::digits10 + 1 &&
                 prev * 10ull + unsigned(p[-1] - '0') <= max
             ? static_cast<int>(value)
             : error_value;
}

// Parses fill and alignment.
template <typename Char, typename Handler>
FMT_CONSTEXPR auto parse_align(const Char* begin, const Char* end,
                               Handler&& handler) -> const Char* {
  FMT_ASSERT(begin != end, "");
  auto align = align::none;
  auto p = begin + code_point_length(begin);
  if (p >= end) p = begin;
  for (;;) {
    switch (to_ascii(*p)) {
    case '<':
      align = align::left;
      break;
    case '>':
      align = align::right;
      break;
    case '^':
      align = align::center;
      break;
    default:
      break;
    }
    if (align != align::none) {
      if (p != begin) {
        auto c = *begin;
        if (c == '{')
          return handler.on_error("invalid fill character '{'"), begin;
        handler.on_fill(basic_string_view<Char>(begin, to_unsigned(p - begin)));
        begin = p + 1;
      } else
        ++begin;
      handler.on_align(align);
      break;
    } else if (p == begin) {
      break;
    }
    p = begin;
  }
  return begin;
}

template <typename Char> FMT_CONSTEXPR bool is_name_start(Char c) {
  return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || '_' == c;
}

template <typename Char, typename IDHandler>
FMT_CONSTEXPR auto do_parse_arg_id(const Char* begin, const Char* end,
                                   IDHandler&& handler) -> const Char* {
  FMT_ASSERT(begin != end, "");
  Char c = *begin;
  if (c >= '0' && c <= '9') {
    int index = 0;
    if (c != '0')
      index =
          parse_nonnegative_int(begin, end, (std::numeric_limits<int>::max)());
    else
      ++begin;
    if (begin == end || (*begin != '}' && *begin != ':'))
      handler.on_error("invalid format string");
    else
      handler(index);
    return begin;
  }
  if (!is_name_start(c)) {
    handler.on_error("invalid format string");
    return begin;
  }
  auto it = begin;
  do {
    ++it;
  } while (it != end && (is_name_start(c = *it) || ('0' <= c && c <= '9')));
  handler(basic_string_view<Char>(begin, to_unsigned(it - begin)));
  return it;
}

template <typename Char, typename IDHandler>
FMT_CONSTEXPR FMT_INLINE auto parse_arg_id(const Char* begin, const Char* end,
                                           IDHandler&& handler) -> const Char* {
  Char c = *begin;
  if (c != '}' && c != ':') return do_parse_arg_id(begin, end, handler);
  handler();
  return begin;
}

template <typename Char, typename Handler>
FMT_CONSTEXPR auto parse_width(const Char* begin, const Char* end,
                               Handler&& handler) -> const Char* {
  using detail::auto_id;
  struct width_adapter {
    Handler& handler;

    FMT_CONSTEXPR void operator()() { handler.on_dynamic_width(auto_id()); }
    FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_width(id); }
    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
      handler.on_dynamic_width(id);
    }
    FMT_CONSTEXPR void on_error(const char* message) {
      if (message) handler.on_error(message);
    }
  };

  FMT_ASSERT(begin != end, "");
  if ('0' <= *begin && *begin <= '9') {
    int width = parse_nonnegative_int(begin, end, -1);
    if (width != -1)
      handler.on_width(width);
    else
      handler.on_error("number is too big");
  } else if (*begin == '{') {
    ++begin;
    if (begin != end) begin = parse_arg_id(begin, end, width_adapter{handler});
    if (begin == end || *begin != '}')
      return handler.on_error("invalid format string"), begin;
    ++begin;
  }
  return begin;
}

template <typename Char, typename Handler>
FMT_CONSTEXPR auto parse_precision(const Char* begin, const Char* end,
                                   Handler&& handler) -> const Char* {
  using detail::auto_id;
  struct precision_adapter {
    Handler& handler;

    FMT_CONSTEXPR void operator()() { handler.on_dynamic_precision(auto_id()); }
    FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_precision(id); }
    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
      handler.on_dynamic_precision(id);
    }
    FMT_CONSTEXPR void on_error(const char* message) {
      if (message) handler.on_error(message);
    }
  };

  ++begin;
  auto c = begin != end ? *begin : Char();
  if ('0' <= c && c <= '9') {
    auto precision = parse_nonnegative_int(begin, end, -1);
    if (precision != -1)
      handler.on_precision(precision);
    else
      handler.on_error("number is too big");
  } else if (c == '{') {
    ++begin;
    if (begin != end)
      begin = parse_arg_id(begin, end, precision_adapter{handler});
    if (begin == end || *begin++ != '}')
      return handler.on_error("invalid format string"), begin;
  } else {
    return handler.on_error("missing precision specifier"), begin;
  }
  handler.end_precision();
  return begin;
}

template <typename Char>
FMT_CONSTEXPR auto parse_presentation_type(Char type) -> presentation_type {
  switch (to_ascii(type)) {
  case 'd':
    return presentation_type::dec;
  case 'o':
    return presentation_type::oct;
  case 'x':
    return presentation_type::hex_lower;
  case 'X':
    return presentation_type::hex_upper;
  case 'b':
    return presentation_type::bin_lower;
  case 'B':
    return presentation_type::bin_upper;
  case 'a':
    return presentation_type::hexfloat_lower;
  case 'A':
    return presentation_type::hexfloat_upper;
  case 'e':
    return presentation_type::exp_lower;
  case 'E':
    return presentation_type::exp_upper;
  case 'f':
    return presentation_type::fixed_lower;
  case 'F':
    return presentation_type::fixed_upper;
  case 'g':
    return presentation_type::general_lower;
  case 'G':
    return presentation_type::general_upper;
  case 'c':
    return presentation_type::chr;
  case 's':
    return presentation_type::string;
  case 'p':
    return presentation_type::pointer;
  default:
    return presentation_type::none;
  }
}

// Parses standard format specifiers and sends notifications about parsed
// components to handler.
template <typename Char, typename SpecHandler>
FMT_CONSTEXPR FMT_INLINE auto parse_format_specs(const Char* begin,
                                                 const Char* end,
                                                 SpecHandler&& handler)
    -> const Char* {
  if (begin + 1 < end && begin[1] == '}' && is_ascii_letter(*begin) &&
      *begin != 'L') {
    presentation_type type = parse_presentation_type(*begin++);
    if (type == presentation_type::none)
      handler.on_error("invalid type specifier");
    handler.on_type(type);
    return begin;
  }

  if (begin == end) return begin;

  begin = parse_align(begin, end, handler);
  if (begin == end) return begin;

  // Parse sign.
  switch (to_ascii(*begin)) {
  case '+':
    handler.on_sign(sign::plus);
    ++begin;
    break;
  case '-':
    handler.on_sign(sign::minus);
    ++begin;
    break;
  case ' ':
    handler.on_sign(sign::space);
    ++begin;
    break;
  default:
    break;
  }
  if (begin == end) return begin;

  if (*begin == '#') {
    handler.on_hash();
    if (++begin == end) return begin;
  }

  // Parse zero flag.
  if (*begin == '0') {
    handler.on_zero();
    if (++begin == end) return begin;
  }

  begin = parse_width(begin, end, handler);
  if (begin == end) return begin;

  // Parse precision.
  if (*begin == '.') {
    begin = parse_precision(begin, end, handler);
    if (begin == end) return begin;
  }

  if (*begin == 'L') {
    handler.on_localized();
    ++begin;
  }

  // Parse type.
  if (begin != end && *begin != '}') {
    presentation_type type = parse_presentation_type(*begin++);
    if (type == presentation_type::none)
      handler.on_error("invalid type specifier");
    handler.on_type(type);
  }
  return begin;
}

template <typename Char, typename Handler>
FMT_CONSTEXPR auto parse_replacement_field(const Char* begin, const Char* end,
                                           Handler&& handler) -> const Char* {
  struct id_adapter {
    Handler& handler;
    int arg_id;

    FMT_CONSTEXPR void operator()() { arg_id = handler.on_arg_id(); }
    FMT_CONSTEXPR void operator()(int id) { arg_id = handler.on_arg_id(id); }
    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
      arg_id = handler.on_arg_id(id);
    }
    FMT_CONSTEXPR void on_error(const char* message) {
      if (message) handler.on_error(message);
    }
  };

  ++begin;
  if (begin == end) return handler.on_error("invalid format string"), end;
  if (*begin == '}') {
    handler.on_replacement_field(handler.on_arg_id(), begin);
  } else if (*begin == '{') {
    handler.on_text(begin, begin + 1);
  } else {
    auto adapter = id_adapter{handler, 0};
    begin = parse_arg_id(begin, end, adapter);
    Char c = begin != end ? *begin : Char();
    if (c == '}') {
      handler.on_replacement_field(adapter.arg_id, begin);
    } else if (c == ':') {
      begin = handler.on_format_specs(adapter.arg_id, begin + 1, end);
      if (begin == end || *begin != '}')
        return handler.on_error("unknown format specifier"), end;
    } else {
      return handler.on_error("missing '}' in format string"), end;
    }
  }
  return begin + 1;
}

template <bool IS_CONSTEXPR, typename Char, typename Handler>
FMT_CONSTEXPR FMT_INLINE void parse_format_string(
    basic_string_view<Char> format_str, Handler&& handler) {
  // Workaround a name-lookup bug in MSVC's modules implementation.
  using detail::find;

  auto begin = format_str.data();
  auto end = begin + format_str.size();
  if (end - begin < 32) {
    // Use a simple loop instead of memchr for small strings.
    const Char* p = begin;
    while (p != end) {
      auto c = *p++;
      if (c == '{') {
        handler.on_text(begin, p - 1);
        begin = p = parse_replacement_field(p - 1, end, handler);
      } else if (c == '}') {
        if (p == end || *p != '}')
          return handler.on_error("unmatched '}' in format string");
        handler.on_text(begin, p);
        begin = ++p;
      }
    }
    handler.on_text(begin, end);
    return;
  }
  struct writer {
    FMT_CONSTEXPR void operator()(const Char* pbegin, const Char* pend) {
      if (pbegin == pend) return;
      for (;;) {
        const Char* p = nullptr;
        if (!find<IS_CONSTEXPR>(pbegin, pend, Char('}'), p))
          return handler_.on_text(pbegin, pend);
        ++p;
        if (p == pend || *p != '}')
          return handler_.on_error("unmatched '}' in format string");
        handler_.on_text(pbegin, p);
        pbegin = p + 1;
      }
    }
    Handler& handler_;
  } write{handler};
  while (begin != end) {
    // Doing two passes with memchr (one for '{' and another for '}') is up to
    // 2.5x faster than the naive one-pass implementation on big format strings.
    const Char* p = begin;
    if (*begin != '{' && !find<IS_CONSTEXPR>(begin + 1, end, Char('{'), p))
      return write(begin, end);
    write(begin, p);
    begin = parse_replacement_field(p, end, handler);
  }
}

template <typename T, typename ParseContext>
FMT_CONSTEXPR auto parse_format_specs(ParseContext& ctx)
    -> decltype(ctx.begin()) {
  using char_type = typename ParseContext::char_type;
  using context = buffer_context<char_type>;
  using mapped_type = conditional_t<
      mapped_type_constant<T, context>::value != type::custom_type,
      decltype(arg_mapper<context>().map(std::declval<const T&>())), T>;
  auto f = conditional_t<has_formatter<mapped_type, context>::value,
                         formatter<mapped_type, char_type>,
                         fallback_formatter<T, char_type>>();
  return f.parse(ctx);
}

// A parse context with extra argument id checks. It is only used at compile
// time because adding checks at runtime would introduce substantial overhead
// and would be redundant since argument ids are checked when arguments are
// retrieved anyway.
template <typename Char, typename ErrorHandler = error_handler>
class compile_parse_context
    : public basic_format_parse_context<Char, ErrorHandler> {
 private:
  int num_args_;
  using base = basic_format_parse_context<Char, ErrorHandler>;

 public:
  explicit FMT_CONSTEXPR compile_parse_context(
      basic_string_view<Char> format_str,
      int num_args = (std::numeric_limits<int>::max)(), ErrorHandler eh = {})
      : base(format_str, eh), num_args_(num_args) {}

  FMT_CONSTEXPR auto next_arg_id() -> int {
    int id = base::next_arg_id();
    if (id >= num_args_) this->on_error("argument not found");
    return id;
  }

  FMT_CONSTEXPR void check_arg_id(int id) {
    base::check_arg_id(id);
    if (id >= num_args_) this->on_error("argument not found");
  }
  using base::check_arg_id;
};

template <typename ErrorHandler>
FMT_CONSTEXPR void check_int_type_spec(presentation_type type,
                                       ErrorHandler&& eh) {
  if (type > presentation_type::bin_upper && type != presentation_type::chr)
    eh.on_error("invalid type specifier");
}

// Checks char specs and returns true if the type spec is char (and not int).
template <typename Char, typename ErrorHandler = error_handler>
FMT_CONSTEXPR auto check_char_specs(const basic_format_specs<Char>& specs,
                                    ErrorHandler&& eh = {}) -> bool {
  if (specs.type != presentation_type::none &&
      specs.type != presentation_type::chr) {
    check_int_type_spec(specs.type, eh);
    return false;
  }
  if (specs.align == align::numeric || specs.sign != sign::none || specs.alt)
    eh.on_error("invalid format specifier for char");
  return true;
}

// A floating-point presentation format.
enum class float_format : unsigned char {
  general,  // General: exponent notation or fixed point based on magnitude.
  exp,      // Exponent notation with the default precision of 6, e.g. 1.2e-3.
  fixed,    // Fixed point with the default precision of 6, e.g. 0.0012.
  hex
};

struct float_specs {
  int precision;
  float_format format : 8;
  sign_t sign : 8;
  bool upper : 1;
  bool locale : 1;
  bool binary32 : 1;
  bool fallback : 1;
  bool showpoint : 1;
};

template <typename ErrorHandler = error_handler, typename Char>
FMT_CONSTEXPR auto parse_float_type_spec(const basic_format_specs<Char>& specs,
                                         ErrorHandler&& eh = {})
    -> float_specs {
  auto result = float_specs();
  result.showpoint = specs.alt;
  result.locale = specs.localized;
  switch (specs.type) {
  case presentation_type::none:
    result.format = float_format::general;
    break;
  case presentation_type::general_upper:
    result.upper = true;
    FMT_FALLTHROUGH;
  case presentation_type::general_lower:
    result.format = float_format::general;
    break;
  case presentation_type::exp_upper:
    result.upper = true;
    FMT_FALLTHROUGH;
  case presentation_type::exp_lower:
    result.format = float_format::exp;
    result.showpoint |= specs.precision != 0;
    break;
  case presentation_type::fixed_upper:
    result.upper = true;
    FMT_FALLTHROUGH;
  case presentation_type::fixed_lower:
    result.format = float_format::fixed;
    result.showpoint |= specs.precision != 0;
    break;
  case presentation_type::hexfloat_upper:
    result.upper = true;
    FMT_FALLTHROUGH;
  case presentation_type::hexfloat_lower:
    result.format = float_format::hex;
    break;
  default:
    eh.on_error("invalid type specifier");
    break;
  }
  return result;
}

template <typename ErrorHandler = error_handler>
FMT_CONSTEXPR auto check_cstring_type_spec(presentation_type type,
                                           ErrorHandler&& eh = {}) -> bool {
  if (type == presentation_type::none || type == presentation_type::string)
    return true;
  if (type != presentation_type::pointer) eh.on_error("invalid type specifier");
  return false;
}

template <typename ErrorHandler = error_handler>
FMT_CONSTEXPR void check_string_type_spec(presentation_type type,
                                          ErrorHandler&& eh = {}) {
  if (type != presentation_type::none && type != presentation_type::string)
    eh.on_error("invalid type specifier");
}

template <typename ErrorHandler>
FMT_CONSTEXPR void check_pointer_type_spec(presentation_type type,
                                           ErrorHandler&& eh) {
  if (type != presentation_type::none && type != presentation_type::pointer)
    eh.on_error("invalid type specifier");
}

// A parse_format_specs handler that checks if specifiers are consistent with
// the argument type.
template <typename Handler> class specs_checker : public Handler {
 private:
  detail::type arg_type_;

  FMT_CONSTEXPR void require_numeric_argument() {
    if (!is_arithmetic_type(arg_type_))
      this->on_error("format specifier requires numeric argument");
  }

 public:
  FMT_CONSTEXPR specs_checker(const Handler& handler, detail::type arg_type)
      : Handler(handler), arg_type_(arg_type) {}

  FMT_CONSTEXPR void on_align(align_t align) {
    if (align == align::numeric) require_numeric_argument();
    Handler::on_align(align);
  }

  FMT_CONSTEXPR void on_sign(sign_t s) {
    require_numeric_argument();
    if (is_integral_type(arg_type_) && arg_type_ != type::int_type &&
        arg_type_ != type::long_long_type && arg_type_ != type::char_type) {
      this->on_error("format specifier requires signed argument");
    }
    Handler::on_sign(s);
  }

  FMT_CONSTEXPR void on_hash() {
    require_numeric_argument();
    Handler::on_hash();
  }

  FMT_CONSTEXPR void on_localized() {
    require_numeric_argument();
    Handler::on_localized();
  }

  FMT_CONSTEXPR void on_zero() {
    require_numeric_argument();
    Handler::on_zero();
  }

  FMT_CONSTEXPR void end_precision() {
    if (is_integral_type(arg_type_) || arg_type_ == type::pointer_type)
      this->on_error("precision not allowed for this argument type");
  }
};

constexpr int invalid_arg_index = -1;

#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
template <int N, typename T, typename... Args, typename Char>
constexpr auto get_arg_index_by_name(basic_string_view<Char> name) -> int {
  if constexpr (detail::is_statically_named_arg<T>()) {
    if (name == T::name) return N;
  }
  if constexpr (sizeof...(Args) > 0)
    return get_arg_index_by_name<N + 1, Args...>(name);
  (void)name;  // Workaround an MSVC bug about "unused" parameter.
  return invalid_arg_index;
}
#endif

template <typename... Args, typename Char>
FMT_CONSTEXPR auto get_arg_index_by_name(basic_string_view<Char> name) -> int {
#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
  if constexpr (sizeof...(Args) > 0)
    return get_arg_index_by_name<0, Args...>(name);
#endif
  (void)name;
  return invalid_arg_index;
}

template <typename Char, typename ErrorHandler, typename... Args>
class format_string_checker {
 private:
  using parse_context_type = compile_parse_context<Char, ErrorHandler>;
  enum { num_args = sizeof...(Args) };

  // Format specifier parsing function.
  using parse_func = const Char* (*)(parse_context_type&);

  parse_context_type context_;
  parse_func parse_funcs_[num_args > 0 ? num_args : 1];

 public:
  explicit FMT_CONSTEXPR format_string_checker(
      basic_string_view<Char> format_str, ErrorHandler eh)
      : context_(format_str, num_args, eh),
        parse_funcs_{&parse_format_specs<Args, parse_context_type>...} {}

  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}

  FMT_CONSTEXPR auto on_arg_id() -> int { return context_.next_arg_id(); }
  FMT_CONSTEXPR auto on_arg_id(int id) -> int {
    return context_.check_arg_id(id), id;
  }
  FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
    auto index = get_arg_index_by_name<Args...>(id);
    if (index == invalid_arg_index) on_error("named argument is not found");
    return context_.check_arg_id(index), index;
#else
    (void)id;
    on_error("compile-time checks for named arguments require C++20 support");
    return 0;
#endif
  }

  FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}

  FMT_CONSTEXPR auto on_format_specs(int id, const Char* begin, const Char*)
      -> const Char* {
    context_.advance_to(context_.begin() + (begin - &*context_.begin()));
    // id >= 0 check is a workaround for gcc 10 bug (#2065).
    return id >= 0 && id < num_args ? parse_funcs_[id](context_) : begin;
  }

  FMT_CONSTEXPR void on_error(const char* message) {
    context_.on_error(message);
  }
};

template <typename... Args, typename S,
          enable_if_t<(is_compile_string<S>::value), int>>
void check_format_string(S format_str) {
  FMT_CONSTEXPR auto s = to_string_view(format_str);
  using checker = format_string_checker<typename S::char_type, error_handler,
                                        remove_cvref_t<Args>...>;
  FMT_CONSTEXPR bool invalid_format =
      (parse_format_string<true>(s, checker(s, {})), true);
  ignore_unused(invalid_format);
}

template <typename Char>
void vformat_to(
    buffer<Char>& buf, basic_string_view<Char> fmt,
    basic_format_args<FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args,
    locale_ref loc = {});

FMT_API void vprint_mojibake(std::FILE*, string_view, format_args);
#ifndef _WIN32
inline void vprint_mojibake(std::FILE*, string_view, format_args) {}
#endif
FMT_END_DETAIL_NAMESPACE

// A formatter specialization for the core types corresponding to detail::type
// constants.
template <typename T, typename Char>
struct formatter<T, Char,
                 enable_if_t<detail::type_constant<T, Char>::value !=
                             detail::type::custom_type>> {
 private:
  detail::dynamic_format_specs<Char> specs_;

 public:
  // Parses format specifiers stopping either at the end of the range or at the
  // terminating '}'.
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    auto begin = ctx.begin(), end = ctx.end();
    if (begin == end) return begin;
    using handler_type = detail::dynamic_specs_handler<ParseContext>;
    auto type = detail::type_constant<T, Char>::value;
    auto checker =
        detail::specs_checker<handler_type>(handler_type(specs_, ctx), type);
    auto it = detail::parse_format_specs(begin, end, checker);
    auto eh = ctx.error_handler();
    switch (type) {
    case detail::type::none_type:
      FMT_ASSERT(false, "invalid argument type");
      break;
    case detail::type::bool_type:
      if (specs_.type == presentation_type::none ||
          specs_.type == presentation_type::string) {
        break;
      }
      FMT_FALLTHROUGH;
    case detail::type::int_type:
    case detail::type::uint_type:
    case detail::type::long_long_type:
    case detail::type::ulong_long_type:
    case detail::type::int128_type:
    case detail::type::uint128_type:
      detail::check_int_type_spec(specs_.type, eh);
      break;
    case detail::type::char_type:
      detail::check_char_specs(specs_, eh);
      break;
    case detail::type::float_type:
      if (detail::const_check(FMT_USE_FLOAT))
        detail::parse_float_type_spec(specs_, eh);
      else
        FMT_ASSERT(false, "float support disabled");
      break;
    case detail::type::double_type:
      if (detail::const_check(FMT_USE_DOUBLE))
        detail::parse_float_type_spec(specs_, eh);
      else
        FMT_ASSERT(false, "double support disabled");
      break;
    case detail::type::long_double_type:
      if (detail::const_check(FMT_USE_LONG_DOUBLE))
        detail::parse_float_type_spec(specs_, eh);
      else
        FMT_ASSERT(false, "long double support disabled");
      break;
    case detail::type::cstring_type:
      detail::check_cstring_type_spec(specs_.type, eh);
      break;
    case detail::type::string_type:
      detail::check_string_type_spec(specs_.type, eh);
      break;
    case detail::type::pointer_type:
      detail::check_pointer_type_spec(specs_.type, eh);
      break;
    case detail::type::custom_type:
      // Custom format specifiers are checked in parse functions of
      // formatter specializations.
      break;
    }
    return it;
  }

  template <typename FormatContext>
  FMT_CONSTEXPR auto format(const T& val, FormatContext& ctx) const
      -> decltype(ctx.out());
};

template <typename Char> struct basic_runtime { basic_string_view<Char> str; };

/** A compile-time format string. */
template <typename Char, typename... Args> class basic_format_string {
 private:
  basic_string_view<Char> str_;

 public:
  template <typename S,
            FMT_ENABLE_IF(
                std::is_convertible<const S&, basic_string_view<Char>>::value)>
  FMT_CONSTEVAL FMT_INLINE basic_format_string(const S& s) : str_(s) {
    static_assert(
        detail::count<
            (std::is_base_of<detail::view, remove_reference_t<Args>>::value &&
             std::is_reference<Args>::value)...>() == 0,
        "passing views as lvalues is disallowed");
#ifdef FMT_HAS_CONSTEVAL
    if constexpr (detail::count_named_args<Args...>() == 0) {
      using checker = detail::format_string_checker<Char, detail::error_handler,
                                                    remove_cvref_t<Args>...>;
      detail::parse_format_string<true>(str_, checker(s, {}));
    }
#else
    detail::check_format_string<Args...>(s);
#endif
  }
  basic_format_string(basic_runtime<Char> r) : str_(r.str) {}

  FMT_INLINE operator basic_string_view<Char>() const { return str_; }
};

#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
// Workaround broken conversion on older gcc.
template <typename... Args> using format_string = string_view;
template <typename S> auto runtime(const S& s) -> basic_string_view<char_t<S>> {
  return s;
}
#else
template <typename... Args>
using format_string = basic_format_string<char, type_identity_t<Args>...>;
/**
  \rst
  Creates a runtime format string.

  **Example**::

    // Check format string at runtime instead of compile-time.
    fmt::print(fmt::runtime("{:d}"), "I am not a number");
  \endrst
 */
template <typename S> auto runtime(const S& s) -> basic_runtime<char_t<S>> {
  return {{s}};
}
#endif

FMT_API auto vformat(string_view fmt, format_args args) -> std::string;

/**
  \rst
  Formats ``args`` according to specifications in ``fmt`` and returns the result
  as a string.

  **Example**::

    #include <fmt/core.h>
    std::string message = fmt::format("The answer is {}.", 42);
  \endrst
*/
template <typename... T>
FMT_INLINE auto format(format_string<T...> fmt, T&&... args) -> std::string {
  return vformat(fmt, fmt::make_format_args(args...));
}

/** Formats a string and writes the output to ``out``. */
template <typename OutputIt,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
auto vformat_to(OutputIt out, string_view fmt, format_args args) -> OutputIt {
  using detail::get_buffer;
  auto&& buf = get_buffer<char>(out);
  detail::vformat_to(buf, fmt, args, {});
  return detail::get_iterator(buf);
}

/**
 \rst
 Formats ``args`` according to specifications in ``fmt``, writes the result to
 the output iterator ``out`` and returns the iterator past the end of the output
 range. `format_to` does not append a terminating null character.

 **Example**::

   auto out = std::vector<char>();
   fmt::format_to(std::back_inserter(out), "{}", 42);
 \endrst
 */
template <typename OutputIt, typename... T,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
FMT_INLINE auto format_to(OutputIt out, format_string<T...> fmt, T&&... args)
    -> OutputIt {
  return vformat_to(out, fmt, fmt::make_format_args(args...));
}

template <typename OutputIt> struct format_to_n_result {
  /** Iterator past the end of the output range. */
  OutputIt out;
  /** Total (not truncated) output size. */
  size_t size;
};

template <typename OutputIt, typename... T,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
auto vformat_to_n(OutputIt out, size_t n, string_view fmt, format_args args)
    -> format_to_n_result<OutputIt> {
  using traits = detail::fixed_buffer_traits;
  auto buf = detail::iterator_buffer<OutputIt, char, traits>(out, n);
  detail::vformat_to(buf, fmt, args, {});
  return {buf.out(), buf.count()};
}

/**
  \rst
  Formats ``args`` according to specifications in ``fmt``, writes up to ``n``
  characters of the result to the output iterator ``out`` and returns the total
  (not truncated) output size and the iterator past the end of the output range.
  `format_to_n` does not append a terminating null character.
  \endrst
 */
template <typename OutputIt, typename... T,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
FMT_INLINE auto format_to_n(OutputIt out, size_t n, format_string<T...> fmt,
                            T&&... args) -> format_to_n_result<OutputIt> {
  return vformat_to_n(out, n, fmt, fmt::make_format_args(args...));
}

/** Returns the number of chars in the output of ``format(fmt, args...)``. */
template <typename... T>
FMT_INLINE auto formatted_size(format_string<T...> fmt, T&&... args) -> size_t {
  auto buf = detail::counting_buffer<>();
  detail::vformat_to(buf, string_view(fmt), fmt::make_format_args(args...), {});
  return buf.count();
}

FMT_API void vprint(string_view fmt, format_args args);
FMT_API void vprint(std::FILE* f, string_view fmt, format_args args);

/**
  \rst
  Formats ``args`` according to specifications in ``fmt`` and writes the output
  to ``stdout``.

  **Example**::

    fmt::print("Elapsed time: {0:.2f} seconds", 1.23);
  \endrst
 */
template <typename... T>
FMT_INLINE void print(format_string<T...> fmt, T&&... args) {
  const auto& vargs = fmt::make_format_args(args...);
  return detail::is_utf8() ? vprint(fmt, vargs)
                           : detail::vprint_mojibake(stdout, fmt, vargs);
}

/**
  \rst
  Formats ``args`` according to specifications in ``fmt`` and writes the
  output to the file ``f``.

  **Example**::

    fmt::print(stderr, "Don't {}!", "panic");
  \endrst
 */
template <typename... T>
FMT_INLINE void print(std::FILE* f, format_string<T...> fmt, T&&... args) {
  const auto& vargs = fmt::make_format_args(args...);
  return detail::is_utf8() ? vprint(f, fmt, vargs)
                           : detail::vprint_mojibake(f, fmt, vargs);
}

FMT_MODULE_EXPORT_END
FMT_GCC_PRAGMA("GCC pop_options")
FMT_END_NAMESPACE

#ifdef FMT_HEADER_ONLY
#  include "format.h"
#endif
#endif  // FMT_CORE_H_

```

`include/fmt/format-inl.h`:

```h
// Formatting library for C++ - implementation
//
// Copyright (c) 2012 - 2016, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_FORMAT_INL_H_
#define FMT_FORMAT_INL_H_

#include <algorithm>
#include <cctype>
#include <cerrno>  // errno
#include <climits>
#include <cmath>
#include <cstdarg>
#include <cstring>  // std::memmove
#include <cwchar>
#include <exception>

#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
#  include <locale>
#endif

#ifdef _WIN32
#  include <io.h>  // _isatty
#endif

#include "format.h"

FMT_BEGIN_NAMESPACE
namespace detail {

FMT_FUNC void assert_fail(const char* file, int line, const char* message) {
  // Use unchecked std::fprintf to avoid triggering another assertion when
  // writing to stderr fails
  std::fprintf(stderr, "%s:%d: assertion failed: %s", file, line, message);
  // Chosen instead of std::abort to satisfy Clang in CUDA mode during device
  // code pass.
  std::terminate();
}

FMT_FUNC void throw_format_error(const char* message) {
  FMT_THROW(format_error(message));
}

#ifndef _MSC_VER
#  define FMT_SNPRINTF snprintf
#else  // _MSC_VER
inline int fmt_snprintf(char* buffer, size_t size, const char* format, ...) {
  va_list args;
  va_start(args, format);
  int result = vsnprintf_s(buffer, size, _TRUNCATE, format, args);
  va_end(args);
  return result;
}
#  define FMT_SNPRINTF fmt_snprintf
#endif  // _MSC_VER

FMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,
                                string_view message) FMT_NOEXCEPT {
  // Report error code making sure that the output fits into
  // inline_buffer_size to avoid dynamic memory allocation and potential
  // bad_alloc.
  out.try_resize(0);
  static const char SEP[] = ": ";
  static const char ERROR_STR[] = "error ";
  // Subtract 2 to account for terminating null characters in SEP and ERROR_STR.
  size_t error_code_size = sizeof(SEP) + sizeof(ERROR_STR) - 2;
  auto abs_value = static_cast<uint32_or_64_or_128_t<int>>(error_code);
  if (detail::is_negative(error_code)) {
    abs_value = 0 - abs_value;
    ++error_code_size;
  }
  error_code_size += detail::to_unsigned(detail::count_digits(abs_value));
  auto it = buffer_appender<char>(out);
  if (message.size() <= inline_buffer_size - error_code_size)
    format_to(it, FMT_STRING("{}{}"), message, SEP);
  format_to(it, FMT_STRING("{}{}"), ERROR_STR, error_code);
  FMT_ASSERT(out.size() <= inline_buffer_size, "");
}

FMT_FUNC void report_error(format_func func, int error_code,
                           const char* message) FMT_NOEXCEPT {
  memory_buffer full_message;
  func(full_message, error_code, message);
  // Don't use fwrite_fully because the latter may throw.
  if (std::fwrite(full_message.data(), full_message.size(), 1, stderr) > 0)
    std::fputc('\n', stderr);
}

// A wrapper around fwrite that throws on error.
inline void fwrite_fully(const void* ptr, size_t size, size_t count,
                         FILE* stream) {
  size_t written = std::fwrite(ptr, size, count, stream);
  if (written < count) FMT_THROW(system_error(errno, "cannot write to file"));
}

#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
template <typename Locale>
locale_ref::locale_ref(const Locale& loc) : locale_(&loc) {
  static_assert(std::is_same<Locale, std::locale>::value, "");
}

template <typename Locale> Locale locale_ref::get() const {
  static_assert(std::is_same<Locale, std::locale>::value, "");
  return locale_ ? *static_cast<const std::locale*>(locale_) : std::locale();
}

template <typename Char>
FMT_FUNC auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char> {
  auto& facet = std::use_facet<std::numpunct<Char>>(loc.get<std::locale>());
  auto grouping = facet.grouping();
  auto thousands_sep = grouping.empty() ? Char() : facet.thousands_sep();
  return {std::move(grouping), thousands_sep};
}
template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref loc) {
  return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())
      .decimal_point();
}
#else
template <typename Char>
FMT_FUNC auto thousands_sep_impl(locale_ref) -> thousands_sep_result<Char> {
  return {"\03", FMT_STATIC_THOUSANDS_SEPARATOR};
}
template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref) {
  return '.';
}
#endif
}  // namespace detail

#if !FMT_MSC_VER
FMT_API FMT_FUNC format_error::~format_error() FMT_NOEXCEPT = default;
#endif

FMT_FUNC std::system_error vsystem_error(int error_code, string_view format_str,
                                         format_args args) {
  auto ec = std::error_code(error_code, std::generic_category());
  return std::system_error(ec, vformat(format_str, args));
}

namespace detail {

template <> FMT_FUNC int count_digits<4>(detail::fallback_uintptr n) {
  // fallback_uintptr is always stored in little endian.
  int i = static_cast<int>(sizeof(void*)) - 1;
  while (i > 0 && n.value[i] == 0) --i;
  auto char_digits = std::numeric_limits<unsigned char>::digits / 4;
  return i >= 0 ? i * char_digits + count_digits<4, unsigned>(n.value[i]) : 1;
}

// log10(2) = 0x0.4d104d427de7fbcc...
static constexpr uint64_t log10_2_significand = 0x4d104d427de7fbcc;

template <typename T = void> struct basic_impl_data {
  // Normalized 64-bit significands of pow(10, k), for k = -348, -340, ..., 340.
  // These are generated by support/compute-powers.py.
  static constexpr uint64_t pow10_significands[87] = {
      0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,
      0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,
      0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,
      0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,
      0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,
      0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,
      0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,
      0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,
      0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,
      0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,
      0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,
      0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,
      0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,
      0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,
      0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,
      0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,
      0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,
      0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,
      0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,
      0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,
      0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,
      0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,
      0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,
      0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,
      0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,
      0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,
      0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,
      0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,
      0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,
  };

#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
#  pragma GCC diagnostic push
#  pragma GCC diagnostic ignored "-Wnarrowing"
#endif
  // Binary exponents of pow(10, k), for k = -348, -340, ..., 340, corresponding
  // to significands above.
  static constexpr int16_t pow10_exponents[87] = {
      -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980, -954,
      -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,  -688, -661,
      -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,  -422,  -396, -369,
      -343,  -316,  -289,  -263,  -236,  -210,  -183,  -157,  -130,  -103, -77,
      -50,   -24,   3,     30,    56,    83,    109,   136,   162,   189,  216,
      242,   269,   295,   322,   348,   375,   402,   428,   455,   481,  508,
      534,   561,   588,   614,   641,   667,   694,   720,   747,   774,  800,
      827,   853,   880,   907,   933,   960,   986,   1013,  1039,  1066};
#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
#  pragma GCC diagnostic pop
#endif

  static constexpr uint64_t power_of_10_64[20] = {
      1, FMT_POWERS_OF_10(1ULL), FMT_POWERS_OF_10(1000000000ULL),
      10000000000000000000ULL};
};

// This is a struct rather than an alias to avoid shadowing warnings in gcc.
struct impl_data : basic_impl_data<> {};

#if __cplusplus < 201703L
template <typename T>
constexpr uint64_t basic_impl_data<T>::pow10_significands[];
template <typename T> constexpr int16_t basic_impl_data<T>::pow10_exponents[];
template <typename T> constexpr uint64_t basic_impl_data<T>::power_of_10_64[];
#endif

template <typename T> struct bits {
  static FMT_CONSTEXPR_DECL const int value =
      static_cast<int>(sizeof(T) * std::numeric_limits<unsigned char>::digits);
};

// Returns the number of significand bits in Float excluding the implicit bit.
template <typename Float> constexpr int num_significand_bits() {
  // Subtract 1 to account for an implicit most significant bit in the
  // normalized form.
  return std::numeric_limits<Float>::digits - 1;
}

// A floating-point number f * pow(2, e).
struct fp {
  uint64_t f;
  int e;

  static constexpr const int num_significand_bits = bits<decltype(f)>::value;

  constexpr fp() : f(0), e(0) {}
  constexpr fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}

  // Constructs fp from an IEEE754 floating-point number. It is a template to
  // prevent compile errors on systems where n is not IEEE754.
  template <typename Float> explicit FMT_CONSTEXPR fp(Float n) { assign(n); }

  template <typename Float>
  using is_supported = bool_constant<sizeof(Float) == sizeof(uint64_t) ||
                                     sizeof(Float) == sizeof(uint32_t)>;

  // Assigns d to this and return true iff predecessor is closer than successor.
  template <typename Float, FMT_ENABLE_IF(is_supported<Float>::value)>
  FMT_CONSTEXPR bool assign(Float n) {
    // Assume float is in the format [sign][exponent][significand].
    const int num_float_significand_bits =
        detail::num_significand_bits<Float>();
    const uint64_t implicit_bit = 1ULL << num_float_significand_bits;
    const uint64_t significand_mask = implicit_bit - 1;
    constexpr bool is_double = sizeof(Float) == sizeof(uint64_t);
    auto u = bit_cast<conditional_t<is_double, uint64_t, uint32_t>>(n);
    f = u & significand_mask;
    const uint64_t exponent_mask = (~0ULL >> 1) & ~significand_mask;
    int biased_e =
        static_cast<int>((u & exponent_mask) >> num_float_significand_bits);
    // The predecessor is closer if n is a normalized power of 2 (f == 0) other
    // than the smallest normalized number (biased_e > 1).
    bool is_predecessor_closer = f == 0 && biased_e > 1;
    if (biased_e != 0)
      f += implicit_bit;
    else
      biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).
    const int exponent_bias = std::numeric_limits<Float>::max_exponent - 1;
    e = biased_e - exponent_bias - num_float_significand_bits;
    return is_predecessor_closer;
  }

  template <typename Float, FMT_ENABLE_IF(!is_supported<Float>::value)>
  bool assign(Float) {
    FMT_ASSERT(false, "");
    return false;
  }
};

// Normalizes the value converted from double and multiplied by (1 << SHIFT).
template <int SHIFT = 0> FMT_CONSTEXPR fp normalize(fp value) {
  // Handle subnormals.
  const uint64_t implicit_bit = 1ULL << num_significand_bits<double>();
  const auto shifted_implicit_bit = implicit_bit << SHIFT;
  while ((value.f & shifted_implicit_bit) == 0) {
    value.f <<= 1;
    --value.e;
  }
  // Subtract 1 to account for hidden bit.
  const auto offset =
      fp::num_significand_bits - num_significand_bits<double>() - SHIFT - 1;
  value.f <<= offset;
  value.e -= offset;
  return value;
}

inline bool operator==(fp x, fp y) { return x.f == y.f && x.e == y.e; }

// Computes lhs * rhs / pow(2, 64) rounded to nearest with half-up tie breaking.
FMT_CONSTEXPR inline uint64_t multiply(uint64_t lhs, uint64_t rhs) {
#if FMT_USE_INT128
  auto product = static_cast<__uint128_t>(lhs) * rhs;
  auto f = static_cast<uint64_t>(product >> 64);
  return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;
#else
  // Multiply 32-bit parts of significands.
  uint64_t mask = (1ULL << 32) - 1;
  uint64_t a = lhs >> 32, b = lhs & mask;
  uint64_t c = rhs >> 32, d = rhs & mask;
  uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;
  // Compute mid 64-bit of result and round.
  uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);
  return ac + (ad >> 32) + (bc >> 32) + (mid >> 32);
#endif
}

FMT_CONSTEXPR inline fp operator*(fp x, fp y) {
  return {multiply(x.f, y.f), x.e + y.e + 64};
}

// Returns a cached power of 10 `c_k = c_k.f * pow(2, c_k.e)` such that its
// (binary) exponent satisfies `min_exponent <= c_k.e <= min_exponent + 28`.
FMT_CONSTEXPR inline fp get_cached_power(int min_exponent,
                                         int& pow10_exponent) {
  const int shift = 32;
  const auto significand = static_cast<int64_t>(log10_2_significand);
  int index = static_cast<int>(
      ((min_exponent + fp::num_significand_bits - 1) * (significand >> shift) +
       ((int64_t(1) << shift) - 1))  // ceil
      >> 32                          // arithmetic shift
  );
  // Decimal exponent of the first (smallest) cached power of 10.
  const int first_dec_exp = -348;
  // Difference between 2 consecutive decimal exponents in cached powers of 10.
  const int dec_exp_step = 8;
  index = (index - first_dec_exp - 1) / dec_exp_step + 1;
  pow10_exponent = first_dec_exp + index * dec_exp_step;
  return {impl_data::pow10_significands[index],
          impl_data::pow10_exponents[index]};
}

// A simple accumulator to hold the sums of terms in bigint::square if uint128_t
// is not available.
struct accumulator {
  uint64_t lower;
  uint64_t upper;

  constexpr accumulator() : lower(0), upper(0) {}
  constexpr explicit operator uint32_t() const {
    return static_cast<uint32_t>(lower);
  }

  FMT_CONSTEXPR void operator+=(uint64_t n) {
    lower += n;
    if (lower < n) ++upper;
  }
  FMT_CONSTEXPR void operator>>=(int shift) {
    FMT_ASSERT(shift == 32, "");
    (void)shift;
    lower = (upper << 32) | (lower >> 32);
    upper >>= 32;
  }
};

class bigint {
 private:
  // A bigint is stored as an array of bigits (big digits), with bigit at index
  // 0 being the least significant one.
  using bigit = uint32_t;
  using double_bigit = uint64_t;
  enum { bigits_capacity = 32 };
  basic_memory_buffer<bigit, bigits_capacity> bigits_;
  int exp_;

  FMT_CONSTEXPR20 bigit operator[](int index) const {
    return bigits_[to_unsigned(index)];
  }
  FMT_CONSTEXPR20 bigit& operator[](int index) {
    return bigits_[to_unsigned(index)];
  }

  static FMT_CONSTEXPR_DECL const int bigit_bits = bits<bigit>::value;

  friend struct formatter<bigint>;

  FMT_CONSTEXPR20 void subtract_bigits(int index, bigit other, bigit& borrow) {
    auto result = static_cast<double_bigit>((*this)[index]) - other - borrow;
    (*this)[index] = static_cast<bigit>(result);
    borrow = static_cast<bigit>(result >> (bigit_bits * 2 - 1));
  }

  FMT_CONSTEXPR20 void remove_leading_zeros() {
    int num_bigits = static_cast<int>(bigits_.size()) - 1;
    while (num_bigits > 0 && (*this)[num_bigits] == 0) --num_bigits;
    bigits_.resize(to_unsigned(num_bigits + 1));
  }

  // Computes *this -= other assuming aligned bigints and *this >= other.
  FMT_CONSTEXPR20 void subtract_aligned(const bigint& other) {
    FMT_ASSERT(other.exp_ >= exp_, "unaligned bigints");
    FMT_ASSERT(compare(*this, other) >= 0, "");
    bigit borrow = 0;
    int i = other.exp_ - exp_;
    for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)
      subtract_bigits(i, other.bigits_[j], borrow);
    while (borrow > 0) subtract_bigits(i, 0, borrow);
    remove_leading_zeros();
  }

  FMT_CONSTEXPR20 void multiply(uint32_t value) {
    const double_bigit wide_value = value;
    bigit carry = 0;
    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
      double_bigit result = bigits_[i] * wide_value + carry;
      bigits_[i] = static_cast<bigit>(result);
      carry = static_cast<bigit>(result >> bigit_bits);
    }
    if (carry != 0) bigits_.push_back(carry);
  }

  FMT_CONSTEXPR20 void multiply(uint64_t value) {
    const bigit mask = ~bigit(0);
    const double_bigit lower = value & mask;
    const double_bigit upper = value >> bigit_bits;
    double_bigit carry = 0;
    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
      double_bigit result = bigits_[i] * lower + (carry & mask);
      carry =
          bigits_[i] * upper + (result >> bigit_bits) + (carry >> bigit_bits);
      bigits_[i] = static_cast<bigit>(result);
    }
    while (carry != 0) {
      bigits_.push_back(carry & mask);
      carry >>= bigit_bits;
    }
  }

 public:
  FMT_CONSTEXPR20 bigint() : exp_(0) {}
  explicit bigint(uint64_t n) { assign(n); }
  FMT_CONSTEXPR20 ~bigint() {
    FMT_ASSERT(bigits_.capacity() <= bigits_capacity, "");
  }

  bigint(const bigint&) = delete;
  void operator=(const bigint&) = delete;

  FMT_CONSTEXPR20 void assign(const bigint& other) {
    auto size = other.bigits_.size();
    bigits_.resize(size);
    auto data = other.bigits_.data();
    std::copy(data, data + size, make_checked(bigits_.data(), size));
    exp_ = other.exp_;
  }

  FMT_CONSTEXPR20 void assign(uint64_t n) {
    size_t num_bigits = 0;
    do {
      bigits_[num_bigits++] = n & ~bigit(0);
      n >>= bigit_bits;
    } while (n != 0);
    bigits_.resize(num_bigits);
    exp_ = 0;
  }

  FMT_CONSTEXPR20 int num_bigits() const {
    return static_cast<int>(bigits_.size()) + exp_;
  }

  FMT_NOINLINE FMT_CONSTEXPR20 bigint& operator<<=(int shift) {
    FMT_ASSERT(shift >= 0, "");
    exp_ += shift / bigit_bits;
    shift %= bigit_bits;
    if (shift == 0) return *this;
    bigit carry = 0;
    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
      bigit c = bigits_[i] >> (bigit_bits - shift);
      bigits_[i] = (bigits_[i] << shift) + carry;
      carry = c;
    }
    if (carry != 0) bigits_.push_back(carry);
    return *this;
  }

  template <typename Int> FMT_CONSTEXPR20 bigint& operator*=(Int value) {
    FMT_ASSERT(value > 0, "");
    multiply(uint32_or_64_or_128_t<Int>(value));
    return *this;
  }

  friend FMT_CONSTEXPR20 int compare(const bigint& lhs, const bigint& rhs) {
    int num_lhs_bigits = lhs.num_bigits(), num_rhs_bigits = rhs.num_bigits();
    if (num_lhs_bigits != num_rhs_bigits)
      return num_lhs_bigits > num_rhs_bigits ? 1 : -1;
    int i = static_cast<int>(lhs.bigits_.size()) - 1;
    int j = static_cast<int>(rhs.bigits_.size()) - 1;
    int end = i - j;
    if (end < 0) end = 0;
    for (; i >= end; --i, --j) {
      bigit lhs_bigit = lhs[i], rhs_bigit = rhs[j];
      if (lhs_bigit != rhs_bigit) return lhs_bigit > rhs_bigit ? 1 : -1;
    }
    if (i != j) return i > j ? 1 : -1;
    return 0;
  }

  // Returns compare(lhs1 + lhs2, rhs).
  friend FMT_CONSTEXPR20 int add_compare(const bigint& lhs1, const bigint& lhs2,
                                         const bigint& rhs) {
    int max_lhs_bigits = (std::max)(lhs1.num_bigits(), lhs2.num_bigits());
    int num_rhs_bigits = rhs.num_bigits();
    if (max_lhs_bigits + 1 < num_rhs_bigits) return -1;
    if (max_lhs_bigits > num_rhs_bigits) return 1;
    auto get_bigit = [](const bigint& n, int i) -> bigit {
      return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
    };
    double_bigit borrow = 0;
    int min_exp = (std::min)((std::min)(lhs1.exp_, lhs2.exp_), rhs.exp_);
    for (int i = num_rhs_bigits - 1; i >= min_exp; --i) {
      double_bigit sum =
          static_cast<double_bigit>(get_bigit(lhs1, i)) + get_bigit(lhs2, i);
      bigit rhs_bigit = get_bigit(rhs, i);
      if (sum > rhs_bigit + borrow) return 1;
      borrow = rhs_bigit + borrow - sum;
      if (borrow > 1) return -1;
      borrow <<= bigit_bits;
    }
    return borrow != 0 ? -1 : 0;
  }

  // Assigns pow(10, exp) to this bigint.
  FMT_CONSTEXPR20 void assign_pow10(int exp) {
    FMT_ASSERT(exp >= 0, "");
    if (exp == 0) return assign(1);
    // Find the top bit.
    int bitmask = 1;
    while (exp >= bitmask) bitmask <<= 1;
    bitmask >>= 1;
    // pow(10, exp) = pow(5, exp) * pow(2, exp). First compute pow(5, exp) by
    // repeated squaring and multiplication.
    assign(5);
    bitmask >>= 1;
    while (bitmask != 0) {
      square();
      if ((exp & bitmask) != 0) *this *= 5;
      bitmask >>= 1;
    }
    *this <<= exp;  // Multiply by pow(2, exp) by shifting.
  }

  FMT_CONSTEXPR20 void square() {
    int num_bigits = static_cast<int>(bigits_.size());
    int num_result_bigits = 2 * num_bigits;
    basic_memory_buffer<bigit, bigits_capacity> n(std::move(bigits_));
    bigits_.resize(to_unsigned(num_result_bigits));
    using accumulator_t = conditional_t<FMT_USE_INT128, uint128_t, accumulator>;
    auto sum = accumulator_t();
    for (int bigit_index = 0; bigit_index < num_bigits; ++bigit_index) {
      // Compute bigit at position bigit_index of the result by adding
      // cross-product terms n[i] * n[j] such that i + j == bigit_index.
      for (int i = 0, j = bigit_index; j >= 0; ++i, --j) {
        // Most terms are multiplied twice which can be optimized in the future.
        sum += static_cast<double_bigit>(n[i]) * n[j];
      }
      (*this)[bigit_index] = static_cast<bigit>(sum);
      sum >>= bits<bigit>::value;  // Compute the carry.
    }
    // Do the same for the top half.
    for (int bigit_index = num_bigits; bigit_index < num_result_bigits;
         ++bigit_index) {
      for (int j = num_bigits - 1, i = bigit_index - j; i < num_bigits;)
        sum += static_cast<double_bigit>(n[i++]) * n[j--];
      (*this)[bigit_index] = static_cast<bigit>(sum);
      sum >>= bits<bigit>::value;
    }
    remove_leading_zeros();
    exp_ *= 2;
  }

  // If this bigint has a bigger exponent than other, adds trailing zero to make
  // exponents equal. This simplifies some operations such as subtraction.
  FMT_CONSTEXPR20 void align(const bigint& other) {
    int exp_difference = exp_ - other.exp_;
    if (exp_difference <= 0) return;
    int num_bigits = static_cast<int>(bigits_.size());
    bigits_.resize(to_unsigned(num_bigits + exp_difference));
    for (int i = num_bigits - 1, j = i + exp_difference; i >= 0; --i, --j)
      bigits_[j] = bigits_[i];
    std::uninitialized_fill_n(bigits_.data(), exp_difference, 0);
    exp_ -= exp_difference;
  }

  // Divides this bignum by divisor, assigning the remainder to this and
  // returning the quotient.
  FMT_CONSTEXPR20 int divmod_assign(const bigint& divisor) {
    FMT_ASSERT(this != &divisor, "");
    if (compare(*this, divisor) < 0) return 0;
    FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, "");
    align(divisor);
    int quotient = 0;
    do {
      subtract_aligned(divisor);
      ++quotient;
    } while (compare(*this, divisor) >= 0);
    return quotient;
  }
};

enum class round_direction { unknown, up, down };

// Given the divisor (normally a power of 10), the remainder = v % divisor for
// some number v and the error, returns whether v should be rounded up, down, or
// whether the rounding direction can't be determined due to error.
// error should be less than divisor / 2.
FMT_CONSTEXPR inline round_direction get_round_direction(uint64_t divisor,
                                                         uint64_t remainder,
                                                         uint64_t error) {
  FMT_ASSERT(remainder < divisor, "");  // divisor - remainder won't overflow.
  FMT_ASSERT(error < divisor, "");      // divisor - error won't overflow.
  FMT_ASSERT(error < divisor - error, "");  // error * 2 won't overflow.
  // Round down if (remainder + error) * 2 <= divisor.
  if (remainder <= divisor - remainder && error * 2 <= divisor - remainder * 2)
    return round_direction::down;
  // Round up if (remainder - error) * 2 >= divisor.
  if (remainder >= error &&
      remainder - error >= divisor - (remainder - error)) {
    return round_direction::up;
  }
  return round_direction::unknown;
}

namespace digits {
enum result {
  more,  // Generate more digits.
  done,  // Done generating digits.
  error  // Digit generation cancelled due to an error.
};
}

struct gen_digits_handler {
  char* buf;
  int size;
  int precision;
  int exp10;
  bool fixed;

  FMT_CONSTEXPR digits::result on_digit(char digit, uint64_t divisor,
                                        uint64_t remainder, uint64_t error,
                                        bool integral) {
    FMT_ASSERT(remainder < divisor, "");
    buf[size++] = digit;
    if (!integral && error >= remainder) return digits::error;
    if (size < precision) return digits::more;
    if (!integral) {
      // Check if error * 2 < divisor with overflow prevention.
      // The check is not needed for the integral part because error = 1
      // and divisor > (1 << 32) there.
      if (error >= divisor || error >= divisor - error) return digits::error;
    } else {
      FMT_ASSERT(error == 1 && divisor > 2, "");
    }
    auto dir = get_round_direction(divisor, remainder, error);
    if (dir != round_direction::up)
      return dir == round_direction::down ? digits::done : digits::error;
    ++buf[size - 1];
    for (int i = size - 1; i > 0 && buf[i] > '9'; --i) {
      buf[i] = '0';
      ++buf[i - 1];
    }
    if (buf[0] > '9') {
      buf[0] = '1';
      if (fixed)
        buf[size++] = '0';
      else
        ++exp10;
    }
    return digits::done;
  }
};

// Generates output using the Grisu digit-gen algorithm.
// error: the size of the region (lower, upper) outside of which numbers
// definitely do not round to value (Delta in Grisu3).
FMT_INLINE FMT_CONSTEXPR20 digits::result grisu_gen_digits(
    fp value, uint64_t error, int& exp, gen_digits_handler& handler) {
  const fp one(1ULL << -value.e, value.e);
  // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be
  // zero because it contains a product of two 64-bit numbers with MSB set (due
  // to normalization) - 1, shifted right by at most 60 bits.
  auto integral = static_cast<uint32_t>(value.f >> -one.e);
  FMT_ASSERT(integral != 0, "");
  FMT_ASSERT(integral == value.f >> -one.e, "");
  // The fractional part of scaled value (p2 in Grisu) c = value % one.
  uint64_t fractional = value.f & (one.f - 1);
  exp = count_digits(integral);  // kappa in Grisu.
  // Non-fixed formats require at least one digit and no precision adjustment.
  if (handler.fixed) {
    // Adjust fixed precision by exponent because it is relative to decimal
    // point.
    handler.precision += exp + handler.exp10;
    // Check if precision is satisfied just by leading zeros, e.g.
    // format("{:.2f}", 0.001) gives "0.00" without generating any digits.
    if (handler.precision <= 0) {
      if (handler.precision < 0) return digits::done;
      // Divide by 10 to prevent overflow.
      uint64_t divisor = impl_data::power_of_10_64[exp - 1] << -one.e;
      auto dir = get_round_direction(divisor, value.f / 10, error * 10);
      if (dir == round_direction::unknown) return digits::error;
      handler.buf[handler.size++] = dir == round_direction::up ? '1' : '0';
      return digits::done;
    }
  }
  // Generate digits for the integral part. This can produce up to 10 digits.
  do {
    uint32_t digit = 0;
    auto divmod_integral = [&](uint32_t divisor) {
      digit = integral / divisor;
      integral %= divisor;
    };
    // This optimization by Milo Yip reduces the number of integer divisions by
    // one per iteration.
    switch (exp) {
    case 10:
      divmod_integral(1000000000);
      break;
    case 9:
      divmod_integral(100000000);
      break;
    case 8:
      divmod_integral(10000000);
      break;
    case 7:
      divmod_integral(1000000);
      break;
    case 6:
      divmod_integral(100000);
      break;
    case 5:
      divmod_integral(10000);
      break;
    case 4:
      divmod_integral(1000);
      break;
    case 3:
      divmod_integral(100);
      break;
    case 2:
      divmod_integral(10);
      break;
    case 1:
      digit = integral;
      integral = 0;
      break;
    default:
      FMT_ASSERT(false, "invalid number of digits");
    }
    --exp;
    auto remainder = (static_cast<uint64_t>(integral) << -one.e) + fractional;
    auto result = handler.on_digit(static_cast<char>('0' + digit),
                                   impl_data::power_of_10_64[exp] << -one.e,
                                   remainder, error, true);
    if (result != digits::more) return result;
  } while (exp > 0);
  // Generate digits for the fractional part.
  for (;;) {
    fractional *= 10;
    error *= 10;
    char digit = static_cast<char>('0' + (fractional >> -one.e));
    fractional &= one.f - 1;
    --exp;
    auto result = handler.on_digit(digit, one.f, fractional, error, false);
    if (result != digits::more) return result;
  }
}

// A 128-bit integer type used internally,
struct uint128_wrapper {
  uint128_wrapper() = default;

#if FMT_USE_INT128
  uint128_t internal_;

  constexpr uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT
      : internal_{static_cast<uint128_t>(low) |
                  (static_cast<uint128_t>(high) << 64)} {}

  constexpr uint128_wrapper(uint128_t u) : internal_{u} {}

  constexpr uint64_t high() const FMT_NOEXCEPT {
    return uint64_t(internal_ >> 64);
  }
  constexpr uint64_t low() const FMT_NOEXCEPT { return uint64_t(internal_); }

  uint128_wrapper& operator+=(uint64_t n) FMT_NOEXCEPT {
    internal_ += n;
    return *this;
  }
#else
  uint64_t high_;
  uint64_t low_;

  constexpr uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT
      : high_{high},
        low_{low} {}

  constexpr uint64_t high() const FMT_NOEXCEPT { return high_; }
  constexpr uint64_t low() const FMT_NOEXCEPT { return low_; }

  uint128_wrapper& operator+=(uint64_t n) FMT_NOEXCEPT {
#  if defined(_MSC_VER) && defined(_M_X64)
    unsigned char carry = _addcarry_u64(0, low_, n, &low_);
    _addcarry_u64(carry, high_, 0, &high_);
    return *this;
#  else
    uint64_t sum = low_ + n;
    high_ += (sum < low_ ? 1 : 0);
    low_ = sum;
    return *this;
#  endif
  }
#endif
};

// Implementation of Dragonbox algorithm: https://github.com/jk-jeon/dragonbox.
namespace dragonbox {
// Computes 128-bit result of multiplication of two 64-bit unsigned integers.
inline uint128_wrapper umul128(uint64_t x, uint64_t y) FMT_NOEXCEPT {
#if FMT_USE_INT128
  return static_cast<uint128_t>(x) * static_cast<uint128_t>(y);
#elif defined(_MSC_VER) && defined(_M_X64)
  uint128_wrapper result;
  result.low_ = _umul128(x, y, &result.high_);
  return result;
#else
  const uint64_t mask = (uint64_t(1) << 32) - uint64_t(1);

  uint64_t a = x >> 32;
  uint64_t b = x & mask;
  uint64_t c = y >> 32;
  uint64_t d = y & mask;

  uint64_t ac = a * c;
  uint64_t bc = b * c;
  uint64_t ad = a * d;
  uint64_t bd = b * d;

  uint64_t intermediate = (bd >> 32) + (ad & mask) + (bc & mask);

  return {ac + (intermediate >> 32) + (ad >> 32) + (bc >> 32),
          (intermediate << 32) + (bd & mask)};
#endif
}

// Computes upper 64 bits of multiplication of two 64-bit unsigned integers.
inline uint64_t umul128_upper64(uint64_t x, uint64_t y) FMT_NOEXCEPT {
#if FMT_USE_INT128
  auto p = static_cast<uint128_t>(x) * static_cast<uint128_t>(y);
  return static_cast<uint64_t>(p >> 64);
#elif defined(_MSC_VER) && defined(_M_X64)
  return __umulh(x, y);
#else
  return umul128(x, y).high();
#endif
}

// Computes upper 64 bits of multiplication of a 64-bit unsigned integer and a
// 128-bit unsigned integer.
inline uint64_t umul192_upper64(uint64_t x, uint128_wrapper y) FMT_NOEXCEPT {
  uint128_wrapper g0 = umul128(x, y.high());
  g0 += umul128_upper64(x, y.low());
  return g0.high();
}

// Computes upper 32 bits of multiplication of a 32-bit unsigned integer and a
// 64-bit unsigned integer.
inline uint32_t umul96_upper32(uint32_t x, uint64_t y) FMT_NOEXCEPT {
  return static_cast<uint32_t>(umul128_upper64(x, y));
}

// Computes middle 64 bits of multiplication of a 64-bit unsigned integer and a
// 128-bit unsigned integer.
inline uint64_t umul192_middle64(uint64_t x, uint128_wrapper y) FMT_NOEXCEPT {
  uint64_t g01 = x * y.high();
  uint64_t g10 = umul128_upper64(x, y.low());
  return g01 + g10;
}

// Computes lower 64 bits of multiplication of a 32-bit unsigned integer and a
// 64-bit unsigned integer.
inline uint64_t umul96_lower64(uint32_t x, uint64_t y) FMT_NOEXCEPT {
  return x * y;
}

// Computes floor(log10(pow(2, e))) for e in [-1700, 1700] using the method from
// https://fmt.dev/papers/Grisu-Exact.pdf#page=5, section 3.4.
inline int floor_log10_pow2(int e) FMT_NOEXCEPT {
  FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
  const int shift = 22;
  return (e * static_cast<int>(log10_2_significand >> (64 - shift))) >> shift;
}

// Various fast log computations.
inline int floor_log2_pow10(int e) FMT_NOEXCEPT {
  FMT_ASSERT(e <= 1233 && e >= -1233, "too large exponent");
  const uint64_t log2_10_integer_part = 3;
  const uint64_t log2_10_fractional_digits = 0x5269e12f346e2bf9;
  const int shift_amount = 19;
  return (e * static_cast<int>(
                  (log2_10_integer_part << shift_amount) |
                  (log2_10_fractional_digits >> (64 - shift_amount)))) >>
         shift_amount;
}
inline int floor_log10_pow2_minus_log10_4_over_3(int e) FMT_NOEXCEPT {
  FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
  const uint64_t log10_4_over_3_fractional_digits = 0x1ffbfc2bbc780375;
  const int shift_amount = 22;
  return (e * static_cast<int>(log10_2_significand >> (64 - shift_amount)) -
          static_cast<int>(log10_4_over_3_fractional_digits >>
                           (64 - shift_amount))) >>
         shift_amount;
}

// Returns true iff x is divisible by pow(2, exp).
inline bool divisible_by_power_of_2(uint32_t x, int exp) FMT_NOEXCEPT {
  FMT_ASSERT(exp >= 1, "");
  FMT_ASSERT(x != 0, "");
#ifdef FMT_BUILTIN_CTZ
  return FMT_BUILTIN_CTZ(x) >= exp;
#else
  return exp < num_bits<uint32_t>() && x == ((x >> exp) << exp);
#endif
}
inline bool divisible_by_power_of_2(uint64_t x, int exp) FMT_NOEXCEPT {
  FMT_ASSERT(exp >= 1, "");
  FMT_ASSERT(x != 0, "");
#ifdef FMT_BUILTIN_CTZLL
  return FMT_BUILTIN_CTZLL(x) >= exp;
#else
  return exp < num_bits<uint64_t>() && x == ((x >> exp) << exp);
#endif
}

// Table entry type for divisibility test.
template <typename T> struct divtest_table_entry {
  T mod_inv;
  T max_quotient;
};

// Returns true iff x is divisible by pow(5, exp).
inline bool divisible_by_power_of_5(uint32_t x, int exp) FMT_NOEXCEPT {
  FMT_ASSERT(exp <= 10, "too large exponent");
  static constexpr const divtest_table_entry<uint32_t> divtest_table[] = {
      {0x00000001, 0xffffffff}, {0xcccccccd, 0x33333333},
      {0xc28f5c29, 0x0a3d70a3}, {0x26e978d5, 0x020c49ba},
      {0x3afb7e91, 0x0068db8b}, {0x0bcbe61d, 0x0014f8b5},
      {0x68c26139, 0x000431bd}, {0xae8d46a5, 0x0000d6bf},
      {0x22e90e21, 0x00002af3}, {0x3a2e9c6d, 0x00000897},
      {0x3ed61f49, 0x000001b7}};
  return x * divtest_table[exp].mod_inv <= divtest_table[exp].max_quotient;
}
inline bool divisible_by_power_of_5(uint64_t x, int exp) FMT_NOEXCEPT {
  FMT_ASSERT(exp <= 23, "too large exponent");
  static constexpr const divtest_table_entry<uint64_t> divtest_table[] = {
      {0x0000000000000001, 0xffffffffffffffff},
      {0xcccccccccccccccd, 0x3333333333333333},
      {0x8f5c28f5c28f5c29, 0x0a3d70a3d70a3d70},
      {0x1cac083126e978d5, 0x020c49ba5e353f7c},
      {0xd288ce703afb7e91, 0x0068db8bac710cb2},
      {0x5d4e8fb00bcbe61d, 0x0014f8b588e368f0},
      {0x790fb65668c26139, 0x000431bde82d7b63},
      {0xe5032477ae8d46a5, 0x0000d6bf94d5e57a},
      {0xc767074b22e90e21, 0x00002af31dc46118},
      {0x8e47ce423a2e9c6d, 0x0000089705f4136b},
      {0x4fa7f60d3ed61f49, 0x000001b7cdfd9d7b},
      {0x0fee64690c913975, 0x00000057f5ff85e5},
      {0x3662e0e1cf503eb1, 0x000000119799812d},
      {0xa47a2cf9f6433fbd, 0x0000000384b84d09},
      {0x54186f653140a659, 0x00000000b424dc35},
      {0x7738164770402145, 0x0000000024075f3d},
      {0xe4a4d1417cd9a041, 0x000000000734aca5},
      {0xc75429d9e5c5200d, 0x000000000170ef54},
      {0xc1773b91fac10669, 0x000000000049c977},
      {0x26b172506559ce15, 0x00000000000ec1e4},
      {0xd489e3a9addec2d1, 0x000000000002f394},
      {0x90e860bb892c8d5d, 0x000000000000971d},
      {0x502e79bf1b6f4f79, 0x0000000000001e39},
      {0xdcd618596be30fe5, 0x000000000000060b}};
  return x * divtest_table[exp].mod_inv <= divtest_table[exp].max_quotient;
}

// Replaces n by floor(n / pow(5, N)) returning true if and only if n is
// divisible by pow(5, N).
// Precondition: n <= 2 * pow(5, N + 1).
template <int N>
bool check_divisibility_and_divide_by_pow5(uint32_t& n) FMT_NOEXCEPT {
  static constexpr struct {
    uint32_t magic_number;
    int bits_for_comparison;
    uint32_t threshold;
    int shift_amount;
  } infos[] = {{0xcccd, 16, 0x3333, 18}, {0xa429, 8, 0x0a, 20}};
  constexpr auto info = infos[N - 1];
  n *= info.magic_number;
  const uint32_t comparison_mask = (1u << info.bits_for_comparison) - 1;
  bool result = (n & comparison_mask) <= info.threshold;
  n >>= info.shift_amount;
  return result;
}

// Computes floor(n / pow(10, N)) for small n and N.
// Precondition: n <= pow(10, N + 1).
template <int N> uint32_t small_division_by_pow10(uint32_t n) FMT_NOEXCEPT {
  static constexpr struct {
    uint32_t magic_number;
    int shift_amount;
    uint32_t divisor_times_10;
  } infos[] = {{0xcccd, 19, 100}, {0xa3d8, 22, 1000}};
  constexpr auto info = infos[N - 1];
  FMT_ASSERT(n <= info.divisor_times_10, "n is too large");
  return n * info.magic_number >> info.shift_amount;
}

// Computes floor(n / 10^(kappa + 1)) (float)
inline uint32_t divide_by_10_to_kappa_plus_1(uint32_t n) FMT_NOEXCEPT {
  return n / float_info<float>::big_divisor;
}
// Computes floor(n / 10^(kappa + 1)) (double)
inline uint64_t divide_by_10_to_kappa_plus_1(uint64_t n) FMT_NOEXCEPT {
  return umul128_upper64(n, 0x83126e978d4fdf3c) >> 9;
}

// Various subroutines using pow10 cache
template <class T> struct cache_accessor;

template <> struct cache_accessor<float> {
  using carrier_uint = float_info<float>::carrier_uint;
  using cache_entry_type = uint64_t;

  static uint64_t get_cached_power(int k) FMT_NOEXCEPT {
    FMT_ASSERT(k >= float_info<float>::min_k && k <= float_info<float>::max_k,
               "k is out of range");
    static constexpr const uint64_t pow10_significands[] = {
        0x81ceb32c4b43fcf5, 0xa2425ff75e14fc32, 0xcad2f7f5359a3b3f,
        0xfd87b5f28300ca0e, 0x9e74d1b791e07e49, 0xc612062576589ddb,
        0xf79687aed3eec552, 0x9abe14cd44753b53, 0xc16d9a0095928a28,
        0xf1c90080baf72cb2, 0x971da05074da7bef, 0xbce5086492111aeb,
        0xec1e4a7db69561a6, 0x9392ee8e921d5d08, 0xb877aa3236a4b44a,
        0xe69594bec44de15c, 0x901d7cf73ab0acda, 0xb424dc35095cd810,
        0xe12e13424bb40e14, 0x8cbccc096f5088cc, 0xafebff0bcb24aaff,
        0xdbe6fecebdedd5bf, 0x89705f4136b4a598, 0xabcc77118461cefd,
        0xd6bf94d5e57a42bd, 0x8637bd05af6c69b6, 0xa7c5ac471b478424,
        0xd1b71758e219652c, 0x83126e978d4fdf3c, 0xa3d70a3d70a3d70b,
        0xcccccccccccccccd, 0x8000000000000000, 0xa000000000000000,
        0xc800000000000000, 0xfa00000000000000, 0x9c40000000000000,
        0xc350000000000000, 0xf424000000000000, 0x9896800000000000,
        0xbebc200000000000, 0xee6b280000000000, 0x9502f90000000000,
        0xba43b74000000000, 0xe8d4a51000000000, 0x9184e72a00000000,
        0xb5e620f480000000, 0xe35fa931a0000000, 0x8e1bc9bf04000000,
        0xb1a2bc2ec5000000, 0xde0b6b3a76400000, 0x8ac7230489e80000,
        0xad78ebc5ac620000, 0xd8d726b7177a8000, 0x878678326eac9000,
        0xa968163f0a57b400, 0xd3c21bcecceda100, 0x84595161401484a0,
        0xa56fa5b99019a5c8, 0xcecb8f27f4200f3a, 0x813f3978f8940984,
        0xa18f07d736b90be5, 0xc9f2c9cd04674ede, 0xfc6f7c4045812296,
        0x9dc5ada82b70b59d, 0xc5371912364ce305, 0xf684df56c3e01bc6,
        0x9a130b963a6c115c, 0xc097ce7bc90715b3, 0xf0bdc21abb48db20,
        0x96769950b50d88f4, 0xbc143fa4e250eb31, 0xeb194f8e1ae525fd,
        0x92efd1b8d0cf37be, 0xb7abc627050305ad, 0xe596b7b0c643c719,
        0x8f7e32ce7bea5c6f, 0xb35dbf821ae4f38b, 0xe0352f62a19e306e};
    return pow10_significands[k - float_info<float>::min_k];
  }

  static carrier_uint compute_mul(carrier_uint u,
                                  const cache_entry_type& cache) FMT_NOEXCEPT {
    return umul96_upper32(u, cache);
  }

  static uint32_t compute_delta(const cache_entry_type& cache,
                                int beta_minus_1) FMT_NOEXCEPT {
    return static_cast<uint32_t>(cache >> (64 - 1 - beta_minus_1));
  }

  static bool compute_mul_parity(carrier_uint two_f,
                                 const cache_entry_type& cache,
                                 int beta_minus_1) FMT_NOEXCEPT {
    FMT_ASSERT(beta_minus_1 >= 1, "");
    FMT_ASSERT(beta_minus_1 < 64, "");

    return ((umul96_lower64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;
  }

  static carrier_uint compute_left_endpoint_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return static_cast<carrier_uint>(
        (cache - (cache >> (float_info<float>::significand_bits + 2))) >>
        (64 - float_info<float>::significand_bits - 1 - beta_minus_1));
  }

  static carrier_uint compute_right_endpoint_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return static_cast<carrier_uint>(
        (cache + (cache >> (float_info<float>::significand_bits + 1))) >>
        (64 - float_info<float>::significand_bits - 1 - beta_minus_1));
  }

  static carrier_uint compute_round_up_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return (static_cast<carrier_uint>(
                cache >>
                (64 - float_info<float>::significand_bits - 2 - beta_minus_1)) +
            1) /
           2;
  }
};

template <> struct cache_accessor<double> {
  using carrier_uint = float_info<double>::carrier_uint;
  using cache_entry_type = uint128_wrapper;

  static uint128_wrapper get_cached_power(int k) FMT_NOEXCEPT {
    FMT_ASSERT(k >= float_info<double>::min_k && k <= float_info<double>::max_k,
               "k is out of range");

    static constexpr const uint128_wrapper pow10_significands[] = {
#if FMT_USE_FULL_CACHE_DRAGONBOX
      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
      {0x9faacf3df73609b1, 0x77b191618c54e9ad},
      {0xc795830d75038c1d, 0xd59df5b9ef6a2418},
      {0xf97ae3d0d2446f25, 0x4b0573286b44ad1e},
      {0x9becce62836ac577, 0x4ee367f9430aec33},
      {0xc2e801fb244576d5, 0x229c41f793cda740},
      {0xf3a20279ed56d48a, 0x6b43527578c11110},
      {0x9845418c345644d6, 0x830a13896b78aaaa},
      {0xbe5691ef416bd60c, 0x23cc986bc656d554},
      {0xedec366b11c6cb8f, 0x2cbfbe86b7ec8aa9},
      {0x94b3a202eb1c3f39, 0x7bf7d71432f3d6aa},
      {0xb9e08a83a5e34f07, 0xdaf5ccd93fb0cc54},
      {0xe858ad248f5c22c9, 0xd1b3400f8f9cff69},
      {0x91376c36d99995be, 0x23100809b9c21fa2},
      {0xb58547448ffffb2d, 0xabd40a0c2832a78b},
      {0xe2e69915b3fff9f9, 0x16c90c8f323f516d},
      {0x8dd01fad907ffc3b, 0xae3da7d97f6792e4},
      {0xb1442798f49ffb4a, 0x99cd11cfdf41779d},
      {0xdd95317f31c7fa1d, 0x40405643d711d584},
      {0x8a7d3eef7f1cfc52, 0x482835ea666b2573},
      {0xad1c8eab5ee43b66, 0xda3243650005eed0},
      {0xd863b256369d4a40, 0x90bed43e40076a83},
      {0x873e4f75e2224e68, 0x5a7744a6e804a292},
      {0xa90de3535aaae202, 0x711515d0a205cb37},
      {0xd3515c2831559a83, 0x0d5a5b44ca873e04},
      {0x8412d9991ed58091, 0xe858790afe9486c3},
      {0xa5178fff668ae0b6, 0x626e974dbe39a873},
      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
      {0x80fa687f881c7f8e, 0x7ce66634bc9d0b9a},
      {0xa139029f6a239f72, 0x1c1fffc1ebc44e81},
      {0xc987434744ac874e, 0xa327ffb266b56221},
      {0xfbe9141915d7a922, 0x4bf1ff9f0062baa9},
      {0x9d71ac8fada6c9b5, 0x6f773fc3603db4aa},
      {0xc4ce17b399107c22, 0xcb550fb4384d21d4},
      {0xf6019da07f549b2b, 0x7e2a53a146606a49},
      {0x99c102844f94e0fb, 0x2eda7444cbfc426e},
      {0xc0314325637a1939, 0xfa911155fefb5309},
      {0xf03d93eebc589f88, 0x793555ab7eba27cb},
      {0x96267c7535b763b5, 0x4bc1558b2f3458df},
      {0xbbb01b9283253ca2, 0x9eb1aaedfb016f17},
      {0xea9c227723ee8bcb, 0x465e15a979c1cadd},
      {0x92a1958a7675175f, 0x0bfacd89ec191eca},
      {0xb749faed14125d36, 0xcef980ec671f667c},
      {0xe51c79a85916f484, 0x82b7e12780e7401b},
      {0x8f31cc0937ae58d2, 0xd1b2ecb8b0908811},
      {0xb2fe3f0b8599ef07, 0x861fa7e6dcb4aa16},
      {0xdfbdcece67006ac9, 0x67a791e093e1d49b},
      {0x8bd6a141006042bd, 0xe0c8bb2c5c6d24e1},
      {0xaecc49914078536d, 0x58fae9f773886e19},
      {0xda7f5bf590966848, 0xaf39a475506a899f},
      {0x888f99797a5e012d, 0x6d8406c952429604},
      {0xaab37fd7d8f58178, 0xc8e5087ba6d33b84},
      {0xd5605fcdcf32e1d6, 0xfb1e4a9a90880a65},
      {0x855c3be0a17fcd26, 0x5cf2eea09a550680},
      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
      {0xd0601d8efc57b08b, 0xf13b94daf124da27},
      {0x823c12795db6ce57, 0x76c53d08d6b70859},
      {0xa2cb1717b52481ed, 0x54768c4b0c64ca6f},
      {0xcb7ddcdda26da268, 0xa9942f5dcf7dfd0a},
      {0xfe5d54150b090b02, 0xd3f93b35435d7c4d},
      {0x9efa548d26e5a6e1, 0xc47bc5014a1a6db0},
      {0xc6b8e9b0709f109a, 0x359ab6419ca1091c},
      {0xf867241c8cc6d4c0, 0xc30163d203c94b63},
      {0x9b407691d7fc44f8, 0x79e0de63425dcf1e},
      {0xc21094364dfb5636, 0x985915fc12f542e5},
      {0xf294b943e17a2bc4, 0x3e6f5b7b17b2939e},
      {0x979cf3ca6cec5b5a, 0xa705992ceecf9c43},
      {0xbd8430bd08277231, 0x50c6ff782a838354},
      {0xece53cec4a314ebd, 0xa4f8bf5635246429},
      {0x940f4613ae5ed136, 0x871b7795e136be9a},
      {0xb913179899f68584, 0x28e2557b59846e40},
      {0xe757dd7ec07426e5, 0x331aeada2fe589d0},
      {0x9096ea6f3848984f, 0x3ff0d2c85def7622},
      {0xb4bca50b065abe63, 0x0fed077a756b53aa},
      {0xe1ebce4dc7f16dfb, 0xd3e8495912c62895},
      {0x8d3360f09cf6e4bd, 0x64712dd7abbbd95d},
      {0xb080392cc4349dec, 0xbd8d794d96aacfb4},
      {0xdca04777f541c567, 0xecf0d7a0fc5583a1},
      {0x89e42caaf9491b60, 0xf41686c49db57245},
      {0xac5d37d5b79b6239, 0x311c2875c522ced6},
      {0xd77485cb25823ac7, 0x7d633293366b828c},
      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
      {0xa8530886b54dbdeb, 0xd9f57f830283fdfd},
      {0xd267caa862a12d66, 0xd072df63c324fd7c},
      {0x8380dea93da4bc60, 0x4247cb9e59f71e6e},
      {0xa46116538d0deb78, 0x52d9be85f074e609},
      {0xcd795be870516656, 0x67902e276c921f8c},
      {0x806bd9714632dff6, 0x00ba1cd8a3db53b7},
      {0xa086cfcd97bf97f3, 0x80e8a40eccd228a5},
      {0xc8a883c0fdaf7df0, 0x6122cd128006b2ce},
      {0xfad2a4b13d1b5d6c, 0x796b805720085f82},
      {0x9cc3a6eec6311a63, 0xcbe3303674053bb1},
      {0xc3f490aa77bd60fc, 0xbedbfc4411068a9d},
      {0xf4f1b4d515acb93b, 0xee92fb5515482d45},
      {0x991711052d8bf3c5, 0x751bdd152d4d1c4b},
      {0xbf5cd54678eef0b6, 0xd262d45a78a0635e},
      {0xef340a98172aace4, 0x86fb897116c87c35},
      {0x9580869f0e7aac0e, 0xd45d35e6ae3d4da1},
      {0xbae0a846d2195712, 0x8974836059cca10a},
      {0xe998d258869facd7, 0x2bd1a438703fc94c},
      {0x91ff83775423cc06, 0x7b6306a34627ddd0},
      {0xb67f6455292cbf08, 0x1a3bc84c17b1d543},
      {0xe41f3d6a7377eeca, 0x20caba5f1d9e4a94},
      {0x8e938662882af53e, 0x547eb47b7282ee9d},
      {0xb23867fb2a35b28d, 0xe99e619a4f23aa44},
      {0xdec681f9f4c31f31, 0x6405fa00e2ec94d5},
      {0x8b3c113c38f9f37e, 0xde83bc408dd3dd05},
      {0xae0b158b4738705e, 0x9624ab50b148d446},
      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
      {0x87f8a8d4cfa417c9, 0xe54ca5d70a80e5d7},
      {0xa9f6d30a038d1dbc, 0x5e9fcf4ccd211f4d},
      {0xd47487cc8470652b, 0x7647c32000696720},
      {0x84c8d4dfd2c63f3b, 0x29ecd9f40041e074},
      {0xa5fb0a17c777cf09, 0xf468107100525891},
      {0xcf79cc9db955c2cc, 0x7182148d4066eeb5},
      {0x81ac1fe293d599bf, 0xc6f14cd848405531},
      {0xa21727db38cb002f, 0xb8ada00e5a506a7d},
      {0xca9cf1d206fdc03b, 0xa6d90811f0e4851d},
      {0xfd442e4688bd304a, 0x908f4a166d1da664},
      {0x9e4a9cec15763e2e, 0x9a598e4e043287ff},
      {0xc5dd44271ad3cdba, 0x40eff1e1853f29fe},
      {0xf7549530e188c128, 0xd12bee59e68ef47d},
      {0x9a94dd3e8cf578b9, 0x82bb74f8301958cf},
      {0xc13a148e3032d6e7, 0xe36a52363c1faf02},
      {0xf18899b1bc3f8ca1, 0xdc44e6c3cb279ac2},
      {0x96f5600f15a7b7e5, 0x29ab103a5ef8c0ba},
      {0xbcb2b812db11a5de, 0x7415d448f6b6f0e8},
      {0xebdf661791d60f56, 0x111b495b3464ad22},
      {0x936b9fcebb25c995, 0xcab10dd900beec35},
      {0xb84687c269ef3bfb, 0x3d5d514f40eea743},
      {0xe65829b3046b0afa, 0x0cb4a5a3112a5113},
      {0x8ff71a0fe2c2e6dc, 0x47f0e785eaba72ac},
      {0xb3f4e093db73a093, 0x59ed216765690f57},
      {0xe0f218b8d25088b8, 0x306869c13ec3532d},
      {0x8c974f7383725573, 0x1e414218c73a13fc},
      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
      {0xdbac6c247d62a583, 0xdf45f746b74abf3a},
      {0x894bc396ce5da772, 0x6b8bba8c328eb784},
      {0xab9eb47c81f5114f, 0x066ea92f3f326565},
      {0xd686619ba27255a2, 0xc80a537b0efefebe},
      {0x8613fd0145877585, 0xbd06742ce95f5f37},
      {0xa798fc4196e952e7, 0x2c48113823b73705},
      {0xd17f3b51fca3a7a0, 0xf75a15862ca504c6},
      {0x82ef85133de648c4, 0x9a984d73dbe722fc},
      {0xa3ab66580d5fdaf5, 0xc13e60d0d2e0ebbb},
      {0xcc963fee10b7d1b3, 0x318df905079926a9},
      {0xffbbcfe994e5c61f, 0xfdf17746497f7053},
      {0x9fd561f1fd0f9bd3, 0xfeb6ea8bedefa634},
      {0xc7caba6e7c5382c8, 0xfe64a52ee96b8fc1},
      {0xf9bd690a1b68637b, 0x3dfdce7aa3c673b1},
      {0x9c1661a651213e2d, 0x06bea10ca65c084f},
      {0xc31bfa0fe5698db8, 0x486e494fcff30a63},
      {0xf3e2f893dec3f126, 0x5a89dba3c3efccfb},
      {0x986ddb5c6b3a76b7, 0xf89629465a75e01d},
      {0xbe89523386091465, 0xf6bbb397f1135824},
      {0xee2ba6c0678b597f, 0x746aa07ded582e2d},
      {0x94db483840b717ef, 0xa8c2a44eb4571cdd},
      {0xba121a4650e4ddeb, 0x92f34d62616ce414},
      {0xe896a0d7e51e1566, 0x77b020baf9c81d18},
      {0x915e2486ef32cd60, 0x0ace1474dc1d122f},
      {0xb5b5ada8aaff80b8, 0x0d819992132456bb},
      {0xe3231912d5bf60e6, 0x10e1fff697ed6c6a},
      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
      {0xb1736b96b6fd83b3, 0xbd308ff8a6b17cb3},
      {0xddd0467c64bce4a0, 0xac7cb3f6d05ddbdf},
      {0x8aa22c0dbef60ee4, 0x6bcdf07a423aa96c},
      {0xad4ab7112eb3929d, 0x86c16c98d2c953c7},
      {0xd89d64d57a607744, 0xe871c7bf077ba8b8},
      {0x87625f056c7c4a8b, 0x11471cd764ad4973},
      {0xa93af6c6c79b5d2d, 0xd598e40d3dd89bd0},
      {0xd389b47879823479, 0x4aff1d108d4ec2c4},
      {0x843610cb4bf160cb, 0xcedf722a585139bb},
      {0xa54394fe1eedb8fe, 0xc2974eb4ee658829},
      {0xce947a3da6a9273e, 0x733d226229feea33},
      {0x811ccc668829b887, 0x0806357d5a3f5260},
      {0xa163ff802a3426a8, 0xca07c2dcb0cf26f8},
      {0xc9bcff6034c13052, 0xfc89b393dd02f0b6},
      {0xfc2c3f3841f17c67, 0xbbac2078d443ace3},
      {0x9d9ba7832936edc0, 0xd54b944b84aa4c0e},
      {0xc5029163f384a931, 0x0a9e795e65d4df12},
      {0xf64335bcf065d37d, 0x4d4617b5ff4a16d6},
      {0x99ea0196163fa42e, 0x504bced1bf8e4e46},
      {0xc06481fb9bcf8d39, 0xe45ec2862f71e1d7},
      {0xf07da27a82c37088, 0x5d767327bb4e5a4d},
      {0x964e858c91ba2655, 0x3a6a07f8d510f870},
      {0xbbe226efb628afea, 0x890489f70a55368c},
      {0xeadab0aba3b2dbe5, 0x2b45ac74ccea842f},
      {0x92c8ae6b464fc96f, 0x3b0b8bc90012929e},
      {0xb77ada0617e3bbcb, 0x09ce6ebb40173745},
      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
      {0x8f57fa54c2a9eab6, 0x9fa946824a12232e},
      {0xb32df8e9f3546564, 0x47939822dc96abfa},
      {0xdff9772470297ebd, 0x59787e2b93bc56f8},
      {0x8bfbea76c619ef36, 0x57eb4edb3c55b65b},
      {0xaefae51477a06b03, 0xede622920b6b23f2},
      {0xdab99e59958885c4, 0xe95fab368e45ecee},
      {0x88b402f7fd75539b, 0x11dbcb0218ebb415},
      {0xaae103b5fcd2a881, 0xd652bdc29f26a11a},
      {0xd59944a37c0752a2, 0x4be76d3346f04960},
      {0x857fcae62d8493a5, 0x6f70a4400c562ddc},
      {0xa6dfbd9fb8e5b88e, 0xcb4ccd500f6bb953},
      {0xd097ad07a71f26b2, 0x7e2000a41346a7a8},
      {0x825ecc24c873782f, 0x8ed400668c0c28c9},
      {0xa2f67f2dfa90563b, 0x728900802f0f32fb},
      {0xcbb41ef979346bca, 0x4f2b40a03ad2ffba},
      {0xfea126b7d78186bc, 0xe2f610c84987bfa9},
      {0x9f24b832e6b0f436, 0x0dd9ca7d2df4d7ca},
      {0xc6ede63fa05d3143, 0x91503d1c79720dbc},
      {0xf8a95fcf88747d94, 0x75a44c6397ce912b},
      {0x9b69dbe1b548ce7c, 0xc986afbe3ee11abb},
      {0xc24452da229b021b, 0xfbe85badce996169},
      {0xf2d56790ab41c2a2, 0xfae27299423fb9c4},
      {0x97c560ba6b0919a5, 0xdccd879fc967d41b},
      {0xbdb6b8e905cb600f, 0x5400e987bbc1c921},
      {0xed246723473e3813, 0x290123e9aab23b69},
      {0x9436c0760c86e30b, 0xf9a0b6720aaf6522},
      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
      {0xe7958cb87392c2c2, 0xb60b1d1230b20e05},
      {0x90bd77f3483bb9b9, 0xb1c6f22b5e6f48c3},
      {0xb4ecd5f01a4aa828, 0x1e38aeb6360b1af4},
      {0xe2280b6c20dd5232, 0x25c6da63c38de1b1},
      {0x8d590723948a535f, 0x579c487e5a38ad0f},
      {0xb0af48ec79ace837, 0x2d835a9df0c6d852},
      {0xdcdb1b2798182244, 0xf8e431456cf88e66},
      {0x8a08f0f8bf0f156b, 0x1b8e9ecb641b5900},
      {0xac8b2d36eed2dac5, 0xe272467e3d222f40},
      {0xd7adf884aa879177, 0x5b0ed81dcc6abb10},
      {0x86ccbb52ea94baea, 0x98e947129fc2b4ea},
      {0xa87fea27a539e9a5, 0x3f2398d747b36225},
      {0xd29fe4b18e88640e, 0x8eec7f0d19a03aae},
      {0x83a3eeeef9153e89, 0x1953cf68300424ad},
      {0xa48ceaaab75a8e2b, 0x5fa8c3423c052dd8},
      {0xcdb02555653131b6, 0x3792f412cb06794e},
      {0x808e17555f3ebf11, 0xe2bbd88bbee40bd1},
      {0xa0b19d2ab70e6ed6, 0x5b6aceaeae9d0ec5},
      {0xc8de047564d20a8b, 0xf245825a5a445276},
      {0xfb158592be068d2e, 0xeed6e2f0f0d56713},
      {0x9ced737bb6c4183d, 0x55464dd69685606c},
      {0xc428d05aa4751e4c, 0xaa97e14c3c26b887},
      {0xf53304714d9265df, 0xd53dd99f4b3066a9},
      {0x993fe2c6d07b7fab, 0xe546a8038efe402a},
      {0xbf8fdb78849a5f96, 0xde98520472bdd034},
      {0xef73d256a5c0f77c, 0x963e66858f6d4441},
      {0x95a8637627989aad, 0xdde7001379a44aa9},
      {0xbb127c53b17ec159, 0x5560c018580d5d53},
      {0xe9d71b689dde71af, 0xaab8f01e6e10b4a7},
      {0x9226712162ab070d, 0xcab3961304ca70e9},
      {0xb6b00d69bb55c8d1, 0x3d607b97c5fd0d23},
      {0xe45c10c42a2b3b05, 0x8cb89a7db77c506b},
      {0x8eb98a7a9a5b04e3, 0x77f3608e92adb243},
      {0xb267ed1940f1c61c, 0x55f038b237591ed4},
      {0xdf01e85f912e37a3, 0x6b6c46dec52f6689},
      {0x8b61313bbabce2c6, 0x2323ac4b3b3da016},
      {0xae397d8aa96c1b77, 0xabec975e0a0d081b},
      {0xd9c7dced53c72255, 0x96e7bd358c904a22},
      {0x881cea14545c7575, 0x7e50d64177da2e55},
      {0xaa242499697392d2, 0xdde50bd1d5d0b9ea},
      {0xd4ad2dbfc3d07787, 0x955e4ec64b44e865},
      {0x84ec3c97da624ab4, 0xbd5af13bef0b113f},
      {0xa6274bbdd0fadd61, 0xecb1ad8aeacdd58f},
      {0xcfb11ead453994ba, 0x67de18eda5814af3},
      {0x81ceb32c4b43fcf4, 0x80eacf948770ced8},
      {0xa2425ff75e14fc31, 0xa1258379a94d028e},
      {0xcad2f7f5359a3b3e, 0x096ee45813a04331},
      {0xfd87b5f28300ca0d, 0x8bca9d6e188853fd},
      {0x9e74d1b791e07e48, 0x775ea264cf55347e},
      {0xc612062576589dda, 0x95364afe032a819e},
      {0xf79687aed3eec551, 0x3a83ddbd83f52205},
      {0x9abe14cd44753b52, 0xc4926a9672793543},
      {0xc16d9a0095928a27, 0x75b7053c0f178294},
      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
      {0x971da05074da7bee, 0xd3f6fc16ebca5e04},
      {0xbce5086492111aea, 0x88f4bb1ca6bcf585},
      {0xec1e4a7db69561a5, 0x2b31e9e3d06c32e6},
      {0x9392ee8e921d5d07, 0x3aff322e62439fd0},
      {0xb877aa3236a4b449, 0x09befeb9fad487c3},
      {0xe69594bec44de15b, 0x4c2ebe687989a9b4},
      {0x901d7cf73ab0acd9, 0x0f9d37014bf60a11},
      {0xb424dc35095cd80f, 0x538484c19ef38c95},
      {0xe12e13424bb40e13, 0x2865a5f206b06fba},
      {0x8cbccc096f5088cb, 0xf93f87b7442e45d4},
      {0xafebff0bcb24aafe, 0xf78f69a51539d749},
      {0xdbe6fecebdedd5be, 0xb573440e5a884d1c},
      {0x89705f4136b4a597, 0x31680a88f8953031},
      {0xabcc77118461cefc, 0xfdc20d2b36ba7c3e},
      {0xd6bf94d5e57a42bc, 0x3d32907604691b4d},
      {0x8637bd05af6c69b5, 0xa63f9a49c2c1b110},
      {0xa7c5ac471b478423, 0x0fcf80dc33721d54},
      {0xd1b71758e219652b, 0xd3c36113404ea4a9},
      {0x83126e978d4fdf3b, 0x645a1cac083126ea},
      {0xa3d70a3d70a3d70a, 0x3d70a3d70a3d70a4},
      {0xcccccccccccccccc, 0xcccccccccccccccd},
      {0x8000000000000000, 0x0000000000000000},
      {0xa000000000000000, 0x0000000000000000},
      {0xc800000000000000, 0x0000000000000000},
      {0xfa00000000000000, 0x0000000000000000},
      {0x9c40000000000000, 0x0000000000000000},
      {0xc350000000000000, 0x0000000000000000},
      {0xf424000000000000, 0x0000000000000000},
      {0x9896800000000000, 0x0000000000000000},
      {0xbebc200000000000, 0x0000000000000000},
      {0xee6b280000000000, 0x0000000000000000},
      {0x9502f90000000000, 0x0000000000000000},
      {0xba43b74000000000, 0x0000000000000000},
      {0xe8d4a51000000000, 0x0000000000000000},
      {0x9184e72a00000000, 0x0000000000000000},
      {0xb5e620f480000000, 0x0000000000000000},
      {0xe35fa931a0000000, 0x0000000000000000},
      {0x8e1bc9bf04000000, 0x0000000000000000},
      {0xb1a2bc2ec5000000, 0x0000000000000000},
      {0xde0b6b3a76400000, 0x0000000000000000},
      {0x8ac7230489e80000, 0x0000000000000000},
      {0xad78ebc5ac620000, 0x0000000000000000},
      {0xd8d726b7177a8000, 0x0000000000000000},
      {0x878678326eac9000, 0x0000000000000000},
      {0xa968163f0a57b400, 0x0000000000000000},
      {0xd3c21bcecceda100, 0x0000000000000000},
      {0x84595161401484a0, 0x0000000000000000},
      {0xa56fa5b99019a5c8, 0x0000000000000000},
      {0xcecb8f27f4200f3a, 0x0000000000000000},
      {0x813f3978f8940984, 0x4000000000000000},
      {0xa18f07d736b90be5, 0x5000000000000000},
      {0xc9f2c9cd04674ede, 0xa400000000000000},
      {0xfc6f7c4045812296, 0x4d00000000000000},
      {0x9dc5ada82b70b59d, 0xf020000000000000},
      {0xc5371912364ce305, 0x6c28000000000000},
      {0xf684df56c3e01bc6, 0xc732000000000000},
      {0x9a130b963a6c115c, 0x3c7f400000000000},
      {0xc097ce7bc90715b3, 0x4b9f100000000000},
      {0xf0bdc21abb48db20, 0x1e86d40000000000},
      {0x96769950b50d88f4, 0x1314448000000000},
      {0xbc143fa4e250eb31, 0x17d955a000000000},
      {0xeb194f8e1ae525fd, 0x5dcfab0800000000},
      {0x92efd1b8d0cf37be, 0x5aa1cae500000000},
      {0xb7abc627050305ad, 0xf14a3d9e40000000},
      {0xe596b7b0c643c719, 0x6d9ccd05d0000000},
      {0x8f7e32ce7bea5c6f, 0xe4820023a2000000},
      {0xb35dbf821ae4f38b, 0xdda2802c8a800000},
      {0xe0352f62a19e306e, 0xd50b2037ad200000},
      {0x8c213d9da502de45, 0x4526f422cc340000},
      {0xaf298d050e4395d6, 0x9670b12b7f410000},
      {0xdaf3f04651d47b4c, 0x3c0cdd765f114000},
      {0x88d8762bf324cd0f, 0xa5880a69fb6ac800},
      {0xab0e93b6efee0053, 0x8eea0d047a457a00},
      {0xd5d238a4abe98068, 0x72a4904598d6d880},
      {0x85a36366eb71f041, 0x47a6da2b7f864750},
      {0xa70c3c40a64e6c51, 0x999090b65f67d924},
      {0xd0cf4b50cfe20765, 0xfff4b4e3f741cf6d},
      {0x82818f1281ed449f, 0xbff8f10e7a8921a4},
      {0xa321f2d7226895c7, 0xaff72d52192b6a0d},
      {0xcbea6f8ceb02bb39, 0x9bf4f8a69f764490},
      {0xfee50b7025c36a08, 0x02f236d04753d5b4},
      {0x9f4f2726179a2245, 0x01d762422c946590},
      {0xc722f0ef9d80aad6, 0x424d3ad2b7b97ef5},
      {0xf8ebad2b84e0d58b, 0xd2e0898765a7deb2},
      {0x9b934c3b330c8577, 0x63cc55f49f88eb2f},
      {0xc2781f49ffcfa6d5, 0x3cbf6b71c76b25fb},
      {0xf316271c7fc3908a, 0x8bef464e3945ef7a},
      {0x97edd871cfda3a56, 0x97758bf0e3cbb5ac},
      {0xbde94e8e43d0c8ec, 0x3d52eeed1cbea317},
      {0xed63a231d4c4fb27, 0x4ca7aaa863ee4bdd},
      {0x945e455f24fb1cf8, 0x8fe8caa93e74ef6a},
      {0xb975d6b6ee39e436, 0xb3e2fd538e122b44},
      {0xe7d34c64a9c85d44, 0x60dbbca87196b616},
      {0x90e40fbeea1d3a4a, 0xbc8955e946fe31cd},
      {0xb51d13aea4a488dd, 0x6babab6398bdbe41},
      {0xe264589a4dcdab14, 0xc696963c7eed2dd1},
      {0x8d7eb76070a08aec, 0xfc1e1de5cf543ca2},
      {0xb0de65388cc8ada8, 0x3b25a55f43294bcb},
      {0xdd15fe86affad912, 0x49ef0eb713f39ebe},
      {0x8a2dbf142dfcc7ab, 0x6e3569326c784337},
      {0xacb92ed9397bf996, 0x49c2c37f07965404},
      {0xd7e77a8f87daf7fb, 0xdc33745ec97be906},
      {0x86f0ac99b4e8dafd, 0x69a028bb3ded71a3},
      {0xa8acd7c0222311bc, 0xc40832ea0d68ce0c},
      {0xd2d80db02aabd62b, 0xf50a3fa490c30190},
      {0x83c7088e1aab65db, 0x792667c6da79e0fa},
      {0xa4b8cab1a1563f52, 0x577001b891185938},
      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},
      {0x80b05e5ac60b6178, 0x544f8158315b05b4},
      {0xa0dc75f1778e39d6, 0x696361ae3db1c721},
      {0xc913936dd571c84c, 0x03bc3a19cd1e38e9},
      {0xfb5878494ace3a5f, 0x04ab48a04065c723},
      {0x9d174b2dcec0e47b, 0x62eb0d64283f9c76},
      {0xc45d1df942711d9a, 0x3ba5d0bd324f8394},
      {0xf5746577930d6500, 0xca8f44ec7ee36479},
      {0x9968bf6abbe85f20, 0x7e998b13cf4e1ecb},
      {0xbfc2ef456ae276e8, 0x9e3fedd8c321a67e},
      {0xefb3ab16c59b14a2, 0xc5cfe94ef3ea101e},
      {0x95d04aee3b80ece5, 0xbba1f1d158724a12},
      {0xbb445da9ca61281f, 0x2a8a6e45ae8edc97},
      {0xea1575143cf97226, 0xf52d09d71a3293bd},
      {0x924d692ca61be758, 0x593c2626705f9c56},
      {0xb6e0c377cfa2e12e, 0x6f8b2fb00c77836c},
      {0xe498f455c38b997a, 0x0b6dfb9c0f956447},
      {0x8edf98b59a373fec, 0x4724bd4189bd5eac},
      {0xb2977ee300c50fe7, 0x58edec91ec2cb657},
      {0xdf3d5e9bc0f653e1, 0x2f2967b66737e3ed},
      {0x8b865b215899f46c, 0xbd79e0d20082ee74},
      {0xae67f1e9aec07187, 0xecd8590680a3aa11},
      {0xda01ee641a708de9, 0xe80e6f4820cc9495},
      {0x884134fe908658b2, 0x3109058d147fdcdd},
      {0xaa51823e34a7eede, 0xbd4b46f0599fd415},
      {0xd4e5e2cdc1d1ea96, 0x6c9e18ac7007c91a},
      {0x850fadc09923329e, 0x03e2cf6bc604ddb0},
      {0xa6539930bf6bff45, 0x84db8346b786151c},
      {0xcfe87f7cef46ff16, 0xe612641865679a63},
      {0x81f14fae158c5f6e, 0x4fcb7e8f3f60c07e},
      {0xa26da3999aef7749, 0xe3be5e330f38f09d},
      {0xcb090c8001ab551c, 0x5cadf5bfd3072cc5},
      {0xfdcb4fa002162a63, 0x73d9732fc7c8f7f6},
      {0x9e9f11c4014dda7e, 0x2867e7fddcdd9afa},
      {0xc646d63501a1511d, 0xb281e1fd541501b8},
      {0xf7d88bc24209a565, 0x1f225a7ca91a4226},
      {0x9ae757596946075f, 0x3375788de9b06958},
      {0xc1a12d2fc3978937, 0x0052d6b1641c83ae},
      {0xf209787bb47d6b84, 0xc0678c5dbd23a49a},
      {0x9745eb4d50ce6332, 0xf840b7ba963646e0},
      {0xbd176620a501fbff, 0xb650e5a93bc3d898},
      {0xec5d3fa8ce427aff, 0xa3e51f138ab4cebe},
      {0x93ba47c980e98cdf, 0xc66f336c36b10137},
      {0xb8a8d9bbe123f017, 0xb80b0047445d4184},
      {0xe6d3102ad96cec1d, 0xa60dc059157491e5},
      {0x9043ea1ac7e41392, 0x87c89837ad68db2f},
      {0xb454e4a179dd1877, 0x29babe4598c311fb},
      {0xe16a1dc9d8545e94, 0xf4296dd6fef3d67a},
      {0x8ce2529e2734bb1d, 0x1899e4a65f58660c},
      {0xb01ae745b101e9e4, 0x5ec05dcff72e7f8f},
      {0xdc21a1171d42645d, 0x76707543f4fa1f73},
      {0x899504ae72497eba, 0x6a06494a791c53a8},
      {0xabfa45da0edbde69, 0x0487db9d17636892},
      {0xd6f8d7509292d603, 0x45a9d2845d3c42b6},
      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},
      {0xa7f26836f282b732, 0x8e6cac7768d7141e},
      {0xd1ef0244af2364ff, 0x3207d795430cd926},
      {0x8335616aed761f1f, 0x7f44e6bd49e807b8},
      {0xa402b9c5a8d3a6e7, 0x5f16206c9c6209a6},
      {0xcd036837130890a1, 0x36dba887c37a8c0f},
      {0x802221226be55a64, 0xc2494954da2c9789},
      {0xa02aa96b06deb0fd, 0xf2db9baa10b7bd6c},
      {0xc83553c5c8965d3d, 0x6f92829494e5acc7},
      {0xfa42a8b73abbf48c, 0xcb772339ba1f17f9},
      {0x9c69a97284b578d7, 0xff2a760414536efb},
      {0xc38413cf25e2d70d, 0xfef5138519684aba},
      {0xf46518c2ef5b8cd1, 0x7eb258665fc25d69},
      {0x98bf2f79d5993802, 0xef2f773ffbd97a61},
      {0xbeeefb584aff8603, 0xaafb550ffacfd8fa},
      {0xeeaaba2e5dbf6784, 0x95ba2a53f983cf38},
      {0x952ab45cfa97a0b2, 0xdd945a747bf26183},
      {0xba756174393d88df, 0x94f971119aeef9e4},
      {0xe912b9d1478ceb17, 0x7a37cd5601aab85d},
      {0x91abb422ccb812ee, 0xac62e055c10ab33a},
      {0xb616a12b7fe617aa, 0x577b986b314d6009},
      {0xe39c49765fdf9d94, 0xed5a7e85fda0b80b},
      {0x8e41ade9fbebc27d, 0x14588f13be847307},
      {0xb1d219647ae6b31c, 0x596eb2d8ae258fc8},
      {0xde469fbd99a05fe3, 0x6fca5f8ed9aef3bb},
      {0x8aec23d680043bee, 0x25de7bb9480d5854},
      {0xada72ccc20054ae9, 0xaf561aa79a10ae6a},
      {0xd910f7ff28069da4, 0x1b2ba1518094da04},
      {0x87aa9aff79042286, 0x90fb44d2f05d0842},
      {0xa99541bf57452b28, 0x353a1607ac744a53},
      {0xd3fa922f2d1675f2, 0x42889b8997915ce8},
      {0x847c9b5d7c2e09b7, 0x69956135febada11},
      {0xa59bc234db398c25, 0x43fab9837e699095},
      {0xcf02b2c21207ef2e, 0x94f967e45e03f4bb},
      {0x8161afb94b44f57d, 0x1d1be0eebac278f5},
      {0xa1ba1ba79e1632dc, 0x6462d92a69731732},
      {0xca28a291859bbf93, 0x7d7b8f7503cfdcfe},
      {0xfcb2cb35e702af78, 0x5cda735244c3d43e},
      {0x9defbf01b061adab, 0x3a0888136afa64a7},
      {0xc56baec21c7a1916, 0x088aaa1845b8fdd0},
      {0xf6c69a72a3989f5b, 0x8aad549e57273d45},
      {0x9a3c2087a63f6399, 0x36ac54e2f678864b},
      {0xc0cb28a98fcf3c7f, 0x84576a1bb416a7dd},
      {0xf0fdf2d3f3c30b9f, 0x656d44a2a11c51d5},
      {0x969eb7c47859e743, 0x9f644ae5a4b1b325},
      {0xbc4665b596706114, 0x873d5d9f0dde1fee},
      {0xeb57ff22fc0c7959, 0xa90cb506d155a7ea},
      {0x9316ff75dd87cbd8, 0x09a7f12442d588f2},
      {0xb7dcbf5354e9bece, 0x0c11ed6d538aeb2f},
      {0xe5d3ef282a242e81, 0x8f1668c8a86da5fa},
      {0x8fa475791a569d10, 0xf96e017d694487bc},
      {0xb38d92d760ec4455, 0x37c981dcc395a9ac},
      {0xe070f78d3927556a, 0x85bbe253f47b1417},
      {0x8c469ab843b89562, 0x93956d7478ccec8e},
      {0xaf58416654a6babb, 0x387ac8d1970027b2},
      {0xdb2e51bfe9d0696a, 0x06997b05fcc0319e},
      {0x88fcf317f22241e2, 0x441fece3bdf81f03},
      {0xab3c2fddeeaad25a, 0xd527e81cad7626c3},
      {0xd60b3bd56a5586f1, 0x8a71e223d8d3b074},
      {0x85c7056562757456, 0xf6872d5667844e49},
      {0xa738c6bebb12d16c, 0xb428f8ac016561db},
      {0xd106f86e69d785c7, 0xe13336d701beba52},
      {0x82a45b450226b39c, 0xecc0024661173473},
      {0xa34d721642b06084, 0x27f002d7f95d0190},
      {0xcc20ce9bd35c78a5, 0x31ec038df7b441f4},
      {0xff290242c83396ce, 0x7e67047175a15271},
      {0x9f79a169bd203e41, 0x0f0062c6e984d386},
      {0xc75809c42c684dd1, 0x52c07b78a3e60868},
      {0xf92e0c3537826145, 0xa7709a56ccdf8a82},
      {0x9bbcc7a142b17ccb, 0x88a66076400bb691},
      {0xc2abf989935ddbfe, 0x6acff893d00ea435},
      {0xf356f7ebf83552fe, 0x0583f6b8c4124d43},
      {0x98165af37b2153de, 0xc3727a337a8b704a},
      {0xbe1bf1b059e9a8d6, 0x744f18c0592e4c5c},
      {0xeda2ee1c7064130c, 0x1162def06f79df73},
      {0x9485d4d1c63e8be7, 0x8addcb5645ac2ba8},
      {0xb9a74a0637ce2ee1, 0x6d953e2bd7173692},
      {0xe8111c87c5c1ba99, 0xc8fa8db6ccdd0437},
      {0x910ab1d4db9914a0, 0x1d9c9892400a22a2},
      {0xb54d5e4a127f59c8, 0x2503beb6d00cab4b},
      {0xe2a0b5dc971f303a, 0x2e44ae64840fd61d},
      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},
      {0xb10d8e1456105dad, 0x7425a83e872c5f47},
      {0xdd50f1996b947518, 0xd12f124e28f77719},
      {0x8a5296ffe33cc92f, 0x82bd6b70d99aaa6f},
      {0xace73cbfdc0bfb7b, 0x636cc64d1001550b},
      {0xd8210befd30efa5a, 0x3c47f7e05401aa4e},
      {0x8714a775e3e95c78, 0x65acfaec34810a71},
      {0xa8d9d1535ce3b396, 0x7f1839a741a14d0d},
      {0xd31045a8341ca07c, 0x1ede48111209a050},
      {0x83ea2b892091e44d, 0x934aed0aab460432},
      {0xa4e4b66b68b65d60, 0xf81da84d5617853f},
      {0xce1de40642e3f4b9, 0x36251260ab9d668e},
      {0x80d2ae83e9ce78f3, 0xc1d72b7c6b426019},
      {0xa1075a24e4421730, 0xb24cf65b8612f81f},
      {0xc94930ae1d529cfc, 0xdee033f26797b627},
      {0xfb9b7cd9a4a7443c, 0x169840ef017da3b1},
      {0x9d412e0806e88aa5, 0x8e1f289560ee864e},
      {0xc491798a08a2ad4e, 0xf1a6f2bab92a27e2},
      {0xf5b5d7ec8acb58a2, 0xae10af696774b1db},
      {0x9991a6f3d6bf1765, 0xacca6da1e0a8ef29},
      {0xbff610b0cc6edd3f, 0x17fd090a58d32af3},
      {0xeff394dcff8a948e, 0xddfc4b4cef07f5b0},
      {0x95f83d0a1fb69cd9, 0x4abdaf101564f98e},
      {0xbb764c4ca7a4440f, 0x9d6d1ad41abe37f1},
      {0xea53df5fd18d5513, 0x84c86189216dc5ed},
      {0x92746b9be2f8552c, 0x32fd3cf5b4e49bb4},
      {0xb7118682dbb66a77, 0x3fbc8c33221dc2a1},
      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},
      {0x8f05b1163ba6832d, 0x29cb4d87f2a7400e},
      {0xb2c71d5bca9023f8, 0x743e20e9ef511012},
      {0xdf78e4b2bd342cf6, 0x914da9246b255416},
      {0x8bab8eefb6409c1a, 0x1ad089b6c2f7548e},
      {0xae9672aba3d0c320, 0xa184ac2473b529b1},
      {0xda3c0f568cc4f3e8, 0xc9e5d72d90a2741e},
      {0x8865899617fb1871, 0x7e2fa67c7a658892},
      {0xaa7eebfb9df9de8d, 0xddbb901b98feeab7},
      {0xd51ea6fa85785631, 0x552a74227f3ea565},
      {0x8533285c936b35de, 0xd53a88958f87275f},
      {0xa67ff273b8460356, 0x8a892abaf368f137},
      {0xd01fef10a657842c, 0x2d2b7569b0432d85},
      {0x8213f56a67f6b29b, 0x9c3b29620e29fc73},
      {0xa298f2c501f45f42, 0x8349f3ba91b47b8f},
      {0xcb3f2f7642717713, 0x241c70a936219a73},
      {0xfe0efb53d30dd4d7, 0xed238cd383aa0110},
      {0x9ec95d1463e8a506, 0xf4363804324a40aa},
      {0xc67bb4597ce2ce48, 0xb143c6053edcd0d5},
      {0xf81aa16fdc1b81da, 0xdd94b7868e94050a},
      {0x9b10a4e5e9913128, 0xca7cf2b4191c8326},
      {0xc1d4ce1f63f57d72, 0xfd1c2f611f63a3f0},
      {0xf24a01a73cf2dccf, 0xbc633b39673c8cec},
      {0x976e41088617ca01, 0xd5be0503e085d813},
      {0xbd49d14aa79dbc82, 0x4b2d8644d8a74e18},
      {0xec9c459d51852ba2, 0xddf8e7d60ed1219e},
      {0x93e1ab8252f33b45, 0xcabb90e5c942b503},
      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},
      {0xe7109bfba19c0c9d, 0x0cc512670a783ad4},
      {0x906a617d450187e2, 0x27fb2b80668b24c5},
      {0xb484f9dc9641e9da, 0xb1f9f660802dedf6},
      {0xe1a63853bbd26451, 0x5e7873f8a0396973},
      {0x8d07e33455637eb2, 0xdb0b487b6423e1e8},
      {0xb049dc016abc5e5f, 0x91ce1a9a3d2cda62},
      {0xdc5c5301c56b75f7, 0x7641a140cc7810fb},
      {0x89b9b3e11b6329ba, 0xa9e904c87fcb0a9d},
      {0xac2820d9623bf429, 0x546345fa9fbdcd44},
      {0xd732290fbacaf133, 0xa97c177947ad4095},
      {0x867f59a9d4bed6c0, 0x49ed8eabcccc485d},
      {0xa81f301449ee8c70, 0x5c68f256bfff5a74},
      {0xd226fc195c6a2f8c, 0x73832eec6fff3111},
      {0x83585d8fd9c25db7, 0xc831fd53c5ff7eab},
      {0xa42e74f3d032f525, 0xba3e7ca8b77f5e55},
      {0xcd3a1230c43fb26f, 0x28ce1bd2e55f35eb},
      {0x80444b5e7aa7cf85, 0x7980d163cf5b81b3},
      {0xa0555e361951c366, 0xd7e105bcc332621f},
      {0xc86ab5c39fa63440, 0x8dd9472bf3fefaa7},
      {0xfa856334878fc150, 0xb14f98f6f0feb951},
      {0x9c935e00d4b9d8d2, 0x6ed1bf9a569f33d3},
      {0xc3b8358109e84f07, 0x0a862f80ec4700c8},
      {0xf4a642e14c6262c8, 0xcd27bb612758c0fa},
      {0x98e7e9cccfbd7dbd, 0x8038d51cb897789c},
      {0xbf21e44003acdd2c, 0xe0470a63e6bd56c3},
      {0xeeea5d5004981478, 0x1858ccfce06cac74},
      {0x95527a5202df0ccb, 0x0f37801e0c43ebc8},
      {0xbaa718e68396cffd, 0xd30560258f54e6ba},
      {0xe950df20247c83fd, 0x47c6b82ef32a2069},
      {0x91d28b7416cdd27e, 0x4cdc331d57fa5441},
      {0xb6472e511c81471d, 0xe0133fe4adf8e952},
      {0xe3d8f9e563a198e5, 0x58180fddd97723a6},
      {0x8e679c2f5e44ff8f, 0x570f09eaa7ea7648},
      {0xb201833b35d63f73, 0x2cd2cc6551e513da},
      {0xde81e40a034bcf4f, 0xf8077f7ea65e58d1},
      {0x8b112e86420f6191, 0xfb04afaf27faf782},
      {0xadd57a27d29339f6, 0x79c5db9af1f9b563},
      {0xd94ad8b1c7380874, 0x18375281ae7822bc},
      {0x87cec76f1c830548, 0x8f2293910d0b15b5},
      {0xa9c2794ae3a3c69a, 0xb2eb3875504ddb22},
      {0xd433179d9c8cb841, 0x5fa60692a46151eb},
      {0x849feec281d7f328, 0xdbc7c41ba6bcd333},
      {0xa5c7ea73224deff3, 0x12b9b522906c0800},
      {0xcf39e50feae16bef, 0xd768226b34870a00},
      {0x81842f29f2cce375, 0xe6a1158300d46640},
      {0xa1e53af46f801c53, 0x60495ae3c1097fd0},
      {0xca5e89b18b602368, 0x385bb19cb14bdfc4},
      {0xfcf62c1dee382c42, 0x46729e03dd9ed7b5},
      {0x9e19db92b4e31ba9, 0x6c07a2c26a8346d1},
      {0xc5a05277621be293, 0xc7098b7305241885},
      { 0xf70867153aa2db38,
        0xb8cbee4fc66d1ea7 }
#else
      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
      {0x95a8637627989aad, 0xdde7001379a44aa9},
      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
      {0xc350000000000000, 0x0000000000000000},
      {0x9dc5ada82b70b59d, 0xf020000000000000},
      {0xfee50b7025c36a08, 0x02f236d04753d5b4},
      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},
      {0xa6539930bf6bff45, 0x84db8346b786151c},
      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},
      {0xd910f7ff28069da4, 0x1b2ba1518094da04},
      {0xaf58416654a6babb, 0x387ac8d1970027b2},
      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},
      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},
      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},
      { 0x95527a5202df0ccb,
        0x0f37801e0c43ebc8 }
#endif
    };

#if FMT_USE_FULL_CACHE_DRAGONBOX
    return pow10_significands[k - float_info<double>::min_k];
#else
    static constexpr const uint64_t powers_of_5_64[] = {
        0x0000000000000001, 0x0000000000000005, 0x0000000000000019,
        0x000000000000007d, 0x0000000000000271, 0x0000000000000c35,
        0x0000000000003d09, 0x000000000001312d, 0x000000000005f5e1,
        0x00000000001dcd65, 0x00000000009502f9, 0x0000000002e90edd,
        0x000000000e8d4a51, 0x0000000048c27395, 0x000000016bcc41e9,
        0x000000071afd498d, 0x0000002386f26fc1, 0x000000b1a2bc2ec5,
        0x000003782dace9d9, 0x00001158e460913d, 0x000056bc75e2d631,
        0x0001b1ae4d6e2ef5, 0x000878678326eac9, 0x002a5a058fc295ed,
        0x00d3c21bcecceda1, 0x0422ca8b0a00a425, 0x14adf4b7320334b9};

    static constexpr const uint32_t pow10_recovery_errors[] = {
        0x50001400, 0x54044100, 0x54014555, 0x55954415, 0x54115555, 0x00000001,
        0x50000000, 0x00104000, 0x54010004, 0x05004001, 0x55555544, 0x41545555,
        0x54040551, 0x15445545, 0x51555514, 0x10000015, 0x00101100, 0x01100015,
        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04450514, 0x45414110,
        0x55555145, 0x50544050, 0x15040155, 0x11054140, 0x50111514, 0x11451454,
        0x00400541, 0x00000000, 0x55555450, 0x10056551, 0x10054011, 0x55551014,
        0x69514555, 0x05151109, 0x00155555};

    static const int compression_ratio = 27;

    // Compute base index.
    int cache_index = (k - float_info<double>::min_k) / compression_ratio;
    int kb = cache_index * compression_ratio + float_info<double>::min_k;
    int offset = k - kb;

    // Get base cache.
    uint128_wrapper base_cache = pow10_significands[cache_index];
    if (offset == 0) return base_cache;

    // Compute the required amount of bit-shift.
    int alpha = floor_log2_pow10(kb + offset) - floor_log2_pow10(kb) - offset;
    FMT_ASSERT(alpha > 0 && alpha < 64, "shifting error detected");

    // Try to recover the real cache.
    uint64_t pow5 = powers_of_5_64[offset];
    uint128_wrapper recovered_cache = umul128(base_cache.high(), pow5);
    uint128_wrapper middle_low =
        umul128(base_cache.low() - (kb < 0 ? 1u : 0u), pow5);

    recovered_cache += middle_low.high();

    uint64_t high_to_middle = recovered_cache.high() << (64 - alpha);
    uint64_t middle_to_low = recovered_cache.low() << (64 - alpha);

    recovered_cache =
        uint128_wrapper{(recovered_cache.low() >> alpha) | high_to_middle,
                        ((middle_low.low() >> alpha) | middle_to_low)};

    if (kb < 0) recovered_cache += 1;

    // Get error.
    int error_idx = (k - float_info<double>::min_k) / 16;
    uint32_t error = (pow10_recovery_errors[error_idx] >>
                      ((k - float_info<double>::min_k) % 16) * 2) &
                     0x3;

    // Add the error back.
    FMT_ASSERT(recovered_cache.low() + error >= recovered_cache.low(), "");
    return {recovered_cache.high(), recovered_cache.low() + error};
#endif
  }

  static carrier_uint compute_mul(carrier_uint u,
                                  const cache_entry_type& cache) FMT_NOEXCEPT {
    return umul192_upper64(u, cache);
  }

  static uint32_t compute_delta(cache_entry_type const& cache,
                                int beta_minus_1) FMT_NOEXCEPT {
    return static_cast<uint32_t>(cache.high() >> (64 - 1 - beta_minus_1));
  }

  static bool compute_mul_parity(carrier_uint two_f,
                                 const cache_entry_type& cache,
                                 int beta_minus_1) FMT_NOEXCEPT {
    FMT_ASSERT(beta_minus_1 >= 1, "");
    FMT_ASSERT(beta_minus_1 < 64, "");

    return ((umul192_middle64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;
  }

  static carrier_uint compute_left_endpoint_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return (cache.high() -
            (cache.high() >> (float_info<double>::significand_bits + 2))) >>
           (64 - float_info<double>::significand_bits - 1 - beta_minus_1);
  }

  static carrier_uint compute_right_endpoint_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return (cache.high() +
            (cache.high() >> (float_info<double>::significand_bits + 1))) >>
           (64 - float_info<double>::significand_bits - 1 - beta_minus_1);
  }

  static carrier_uint compute_round_up_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return ((cache.high() >>
             (64 - float_info<double>::significand_bits - 2 - beta_minus_1)) +
            1) /
           2;
  }
};

// Various integer checks
template <class T>
bool is_left_endpoint_integer_shorter_interval(int exponent) FMT_NOEXCEPT {
  return exponent >=
             float_info<
                 T>::case_shorter_interval_left_endpoint_lower_threshold &&
         exponent <=
             float_info<T>::case_shorter_interval_left_endpoint_upper_threshold;
}
template <class T>
bool is_endpoint_integer(typename float_info<T>::carrier_uint two_f,
                         int exponent, int minus_k) FMT_NOEXCEPT {
  if (exponent < float_info<T>::case_fc_pm_half_lower_threshold) return false;
  // For k >= 0.
  if (exponent <= float_info<T>::case_fc_pm_half_upper_threshold) return true;
  // For k < 0.
  if (exponent > float_info<T>::divisibility_check_by_5_threshold) return false;
  return divisible_by_power_of_5(two_f, minus_k);
}

template <class T>
bool is_center_integer(typename float_info<T>::carrier_uint two_f, int exponent,
                       int minus_k) FMT_NOEXCEPT {
  // Exponent for 5 is negative.
  if (exponent > float_info<T>::divisibility_check_by_5_threshold) return false;
  if (exponent > float_info<T>::case_fc_upper_threshold)
    return divisible_by_power_of_5(two_f, minus_k);
  // Both exponents are nonnegative.
  if (exponent >= float_info<T>::case_fc_lower_threshold) return true;
  // Exponent for 2 is negative.
  return divisible_by_power_of_2(two_f, minus_k - exponent + 1);
}

// Remove trailing zeros from n and return the number of zeros removed (float)
FMT_INLINE int remove_trailing_zeros(uint32_t& n) FMT_NOEXCEPT {
#ifdef FMT_BUILTIN_CTZ
  int t = FMT_BUILTIN_CTZ(n);
#else
  int t = ctz(n);
#endif
  if (t > float_info<float>::max_trailing_zeros)
    t = float_info<float>::max_trailing_zeros;

  const uint32_t mod_inv1 = 0xcccccccd;
  const uint32_t max_quotient1 = 0x33333333;
  const uint32_t mod_inv2 = 0xc28f5c29;
  const uint32_t max_quotient2 = 0x0a3d70a3;

  int s = 0;
  for (; s < t - 1; s += 2) {
    if (n * mod_inv2 > max_quotient2) break;
    n *= mod_inv2;
  }
  if (s < t && n * mod_inv1 <= max_quotient1) {
    n *= mod_inv1;
    ++s;
  }
  n >>= s;
  return s;
}

// Removes trailing zeros and returns the number of zeros removed (double)
FMT_INLINE int remove_trailing_zeros(uint64_t& n) FMT_NOEXCEPT {
#ifdef FMT_BUILTIN_CTZLL
  int t = FMT_BUILTIN_CTZLL(n);
#else
  int t = ctzll(n);
#endif
  if (t > float_info<double>::max_trailing_zeros)
    t = float_info<double>::max_trailing_zeros;
  // Divide by 10^8 and reduce to 32-bits
  // Since ret_value.significand <= (2^64 - 1) / 1000 < 10^17,
  // both of the quotient and the r should fit in 32-bits

  const uint32_t mod_inv1 = 0xcccccccd;
  const uint32_t max_quotient1 = 0x33333333;
  const uint64_t mod_inv8 = 0xc767074b22e90e21;
  const uint64_t max_quotient8 = 0x00002af31dc46118;

  // If the number is divisible by 1'0000'0000, work with the quotient
  if (t >= 8) {
    auto quotient_candidate = n * mod_inv8;

    if (quotient_candidate <= max_quotient8) {
      auto quotient = static_cast<uint32_t>(quotient_candidate >> 8);

      int s = 8;
      for (; s < t; ++s) {
        if (quotient * mod_inv1 > max_quotient1) break;
        quotient *= mod_inv1;
      }
      quotient >>= (s - 8);
      n = quotient;
      return s;
    }
  }

  // Otherwise, work with the remainder
  auto quotient = static_cast<uint32_t>(n / 100000000);
  auto remainder = static_cast<uint32_t>(n - 100000000 * quotient);

  if (t == 0 || remainder * mod_inv1 > max_quotient1) {
    return 0;
  }
  remainder *= mod_inv1;

  if (t == 1 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 1) + quotient * 10000000ull;
    return 1;
  }
  remainder *= mod_inv1;

  if (t == 2 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 2) + quotient * 1000000ull;
    return 2;
  }
  remainder *= mod_inv1;

  if (t == 3 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 3) + quotient * 100000ull;
    return 3;
  }
  remainder *= mod_inv1;

  if (t == 4 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 4) + quotient * 10000ull;
    return 4;
  }
  remainder *= mod_inv1;

  if (t == 5 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 5) + quotient * 1000ull;
    return 5;
  }
  remainder *= mod_inv1;

  if (t == 6 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 6) + quotient * 100ull;
    return 6;
  }
  remainder *= mod_inv1;

  n = (remainder >> 7) + quotient * 10ull;
  return 7;
}

// The main algorithm for shorter interval case
template <class T>
FMT_INLINE decimal_fp<T> shorter_interval_case(int exponent) FMT_NOEXCEPT {
  decimal_fp<T> ret_value;
  // Compute k and beta
  const int minus_k = floor_log10_pow2_minus_log10_4_over_3(exponent);
  const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);

  // Compute xi and zi
  using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
  const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);

  auto xi = cache_accessor<T>::compute_left_endpoint_for_shorter_interval_case(
      cache, beta_minus_1);
  auto zi = cache_accessor<T>::compute_right_endpoint_for_shorter_interval_case(
      cache, beta_minus_1);

  // If the left endpoint is not an integer, increase it
  if (!is_left_endpoint_integer_shorter_interval<T>(exponent)) ++xi;

  // Try bigger divisor
  ret_value.significand = zi / 10;

  // If succeed, remove trailing zeros if necessary and return
  if (ret_value.significand * 10 >= xi) {
    ret_value.exponent = minus_k + 1;
    ret_value.exponent += remove_trailing_zeros(ret_value.significand);
    return ret_value;
  }

  // Otherwise, compute the round-up of y
  ret_value.significand =
      cache_accessor<T>::compute_round_up_for_shorter_interval_case(
          cache, beta_minus_1);
  ret_value.exponent = minus_k;

  // When tie occurs, choose one of them according to the rule
  if (exponent >= float_info<T>::shorter_interval_tie_lower_threshold &&
      exponent <= float_info<T>::shorter_interval_tie_upper_threshold) {
    ret_value.significand = ret_value.significand % 2 == 0
                                ? ret_value.significand
                                : ret_value.significand - 1;
  } else if (ret_value.significand < xi) {
    ++ret_value.significand;
  }
  return ret_value;
}

template <typename T> decimal_fp<T> to_decimal(T x) FMT_NOEXCEPT {
  // Step 1: integer promotion & Schubfach multiplier calculation.

  using carrier_uint = typename float_info<T>::carrier_uint;
  using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
  auto br = bit_cast<carrier_uint>(x);

  // Extract significand bits and exponent bits.
  const carrier_uint significand_mask =
      (static_cast<carrier_uint>(1) << float_info<T>::significand_bits) - 1;
  carrier_uint significand = (br & significand_mask);
  int exponent = static_cast<int>((br & exponent_mask<T>()) >>
                                  float_info<T>::significand_bits);

  if (exponent != 0) {  // Check if normal.
    exponent += float_info<T>::exponent_bias - float_info<T>::significand_bits;

    // Shorter interval case; proceed like Schubfach.
    if (significand == 0) return shorter_interval_case<T>(exponent);

    significand |=
        (static_cast<carrier_uint>(1) << float_info<T>::significand_bits);
  } else {
    // Subnormal case; the interval is always regular.
    if (significand == 0) return {0, 0};
    exponent = float_info<T>::min_exponent - float_info<T>::significand_bits;
  }

  const bool include_left_endpoint = (significand % 2 == 0);
  const bool include_right_endpoint = include_left_endpoint;

  // Compute k and beta.
  const int minus_k = floor_log10_pow2(exponent) - float_info<T>::kappa;
  const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);
  const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);

  // Compute zi and deltai
  // 10^kappa <= deltai < 10^(kappa + 1)
  const uint32_t deltai = cache_accessor<T>::compute_delta(cache, beta_minus_1);
  const carrier_uint two_fc = significand << 1;
  const carrier_uint two_fr = two_fc | 1;
  const carrier_uint zi =
      cache_accessor<T>::compute_mul(two_fr << beta_minus_1, cache);

  // Step 2: Try larger divisor; remove trailing zeros if necessary

  // Using an upper bound on zi, we might be able to optimize the division
  // better than the compiler; we are computing zi / big_divisor here
  decimal_fp<T> ret_value;
  ret_value.significand = divide_by_10_to_kappa_plus_1(zi);
  uint32_t r = static_cast<uint32_t>(zi - float_info<T>::big_divisor *
                                              ret_value.significand);

  if (r > deltai) {
    goto small_divisor_case_label;
  } else if (r < deltai) {
    // Exclude the right endpoint if necessary
    if (r == 0 && !include_right_endpoint &&
        is_endpoint_integer<T>(two_fr, exponent, minus_k)) {
      --ret_value.significand;
      r = float_info<T>::big_divisor;
      goto small_divisor_case_label;
    }
  } else {
    // r == deltai; compare fractional parts
    // Check conditions in the order different from the paper
    // to take advantage of short-circuiting
    const carrier_uint two_fl = two_fc - 1;
    if ((!include_left_endpoint ||
         !is_endpoint_integer<T>(two_fl, exponent, minus_k)) &&
        !cache_accessor<T>::compute_mul_parity(two_fl, cache, beta_minus_1)) {
      goto small_divisor_case_label;
    }
  }
  ret_value.exponent = minus_k + float_info<T>::kappa + 1;

  // We may need to remove trailing zeros
  ret_value.exponent += remove_trailing_zeros(ret_value.significand);
  return ret_value;

  // Step 3: Find the significand with the smaller divisor

small_divisor_case_label:
  ret_value.significand *= 10;
  ret_value.exponent = minus_k + float_info<T>::kappa;

  const uint32_t mask = (1u << float_info<T>::kappa) - 1;
  auto dist = r - (deltai / 2) + (float_info<T>::small_divisor / 2);

  // Is dist divisible by 2^kappa?
  if ((dist & mask) == 0) {
    const bool approx_y_parity =
        ((dist ^ (float_info<T>::small_divisor / 2)) & 1) != 0;
    dist >>= float_info<T>::kappa;

    // Is dist divisible by 5^kappa?
    if (check_divisibility_and_divide_by_pow5<float_info<T>::kappa>(dist)) {
      ret_value.significand += dist;

      // Check z^(f) >= epsilon^(f)
      // We have either yi == zi - epsiloni or yi == (zi - epsiloni) - 1,
      // where yi == zi - epsiloni if and only if z^(f) >= epsilon^(f)
      // Since there are only 2 possibilities, we only need to care about the
      // parity. Also, zi and r should have the same parity since the divisor
      // is an even number
      if (cache_accessor<T>::compute_mul_parity(two_fc, cache, beta_minus_1) !=
          approx_y_parity) {
        --ret_value.significand;
      } else {
        // If z^(f) >= epsilon^(f), we might have a tie
        // when z^(f) == epsilon^(f), or equivalently, when y is an integer
        if (is_center_integer<T>(two_fc, exponent, minus_k)) {
          ret_value.significand = ret_value.significand % 2 == 0
                                      ? ret_value.significand
                                      : ret_value.significand - 1;
        }
      }
    }
    // Is dist not divisible by 5^kappa?
    else {
      ret_value.significand += dist;
    }
  }
  // Is dist not divisible by 2^kappa?
  else {
    // Since we know dist is small, we might be able to optimize the division
    // better than the compiler; we are computing dist / small_divisor here
    ret_value.significand +=
        small_division_by_pow10<float_info<T>::kappa>(dist);
  }
  return ret_value;
}
}  // namespace dragonbox

// Formats a floating-point number using a variation of the Fixed-Precision
// Positive Floating-Point Printout ((FPP)^2) algorithm by Steele & White:
// https://fmt.dev/papers/p372-steele.pdf.
FMT_CONSTEXPR20 inline void format_dragon(fp value, bool is_predecessor_closer,
                                          int num_digits, buffer<char>& buf,
                                          int& exp10) {
  bigint numerator;    // 2 * R in (FPP)^2.
  bigint denominator;  // 2 * S in (FPP)^2.
  // lower and upper are differences between value and corresponding boundaries.
  bigint lower;             // (M^- in (FPP)^2).
  bigint upper_store;       // upper's value if different from lower.
  bigint* upper = nullptr;  // (M^+ in (FPP)^2).
  // Shift numerator and denominator by an extra bit or two (if lower boundary
  // is closer) to make lower and upper integers. This eliminates multiplication
  // by 2 during later computations.
  int shift = is_predecessor_closer ? 2 : 1;
  uint64_t significand = value.f << shift;
  if (value.e >= 0) {
    numerator.assign(significand);
    numerator <<= value.e;
    lower.assign(1);
    lower <<= value.e;
    if (shift != 1) {
      upper_store.assign(1);
      upper_store <<= value.e + 1;
      upper = &upper_store;
    }
    denominator.assign_pow10(exp10);
    denominator <<= shift;
  } else if (exp10 < 0) {
    numerator.assign_pow10(-exp10);
    lower.assign(numerator);
    if (shift != 1) {
      upper_store.assign(numerator);
      upper_store <<= 1;
      upper = &upper_store;
    }
    numerator *= significand;
    denominator.assign(1);
    denominator <<= shift - value.e;
  } else {
    numerator.assign(significand);
    denominator.assign_pow10(exp10);
    denominator <<= shift - value.e;
    lower.assign(1);
    if (shift != 1) {
      upper_store.assign(1ULL << 1);
      upper = &upper_store;
    }
  }
  // Invariant: value == (numerator / denominator) * pow(10, exp10).
  if (num_digits < 0) {
    // Generate the shortest representation.
    if (!upper) upper = &lower;
    bool even = (value.f & 1) == 0;
    num_digits = 0;
    char* data = buf.data();
    for (;;) {
      int digit = numerator.divmod_assign(denominator);
      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.
      // numerator + upper >[=] pow10:
      bool high = add_compare(numerator, *upper, denominator) + even > 0;
      data[num_digits++] = static_cast<char>('0' + digit);
      if (low || high) {
        if (!low) {
          ++data[num_digits - 1];
        } else if (high) {
          int result = add_compare(numerator, numerator, denominator);
          // Round half to even.
          if (result > 0 || (result == 0 && (digit % 2) != 0))
            ++data[num_digits - 1];
        }
        buf.try_resize(to_unsigned(num_digits));
        exp10 -= num_digits - 1;
        return;
      }
      numerator *= 10;
      lower *= 10;
      if (upper != &lower) *upper *= 10;
    }
  }
  // Generate the given number of digits.
  exp10 -= num_digits - 1;
  if (num_digits == 0) {
    denominator *= 10;
    auto digit = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';
    buf.push_back(digit);
    return;
  }
  buf.try_resize(to_unsigned(num_digits));
  for (int i = 0; i < num_digits - 1; ++i) {
    int digit = numerator.divmod_assign(denominator);
    buf[i] = static_cast<char>('0' + digit);
    numerator *= 10;
  }
  int digit = numerator.divmod_assign(denominator);
  auto result = add_compare(numerator, numerator, denominator);
  if (result > 0 || (result == 0 && (digit % 2) != 0)) {
    if (digit == 9) {
      const auto overflow = '0' + 10;
      buf[num_digits - 1] = overflow;
      // Propagate the carry.
      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {
        buf[i] = '0';
        ++buf[i - 1];
      }
      if (buf[0] == overflow) {
        buf[0] = '1';
        ++exp10;
      }
      return;
    }
    ++digit;
  }
  buf[num_digits - 1] = static_cast<char>('0' + digit);
}

template <typename Float>
FMT_HEADER_ONLY_CONSTEXPR20 int format_float(Float value, int precision,
                                             float_specs specs,
                                             buffer<char>& buf) {
  // float is passed as double to reduce the number of instantiations.
  static_assert(!std::is_same<Float, float>::value, "");
  FMT_ASSERT(value >= 0, "value is negative");

  const bool fixed = specs.format == float_format::fixed;
  if (value <= 0) {  // <= instead of == to silence a warning.
    if (precision <= 0 || !fixed) {
      buf.push_back('0');
      return 0;
    }
    buf.try_resize(to_unsigned(precision));
    fill_n(buf.data(), precision, '0');
    return -precision;
  }

  if (specs.fallback) return snprintf_float(value, precision, specs, buf);

  if (!is_constant_evaluated() && precision < 0) {
    // Use Dragonbox for the shortest format.
    if (specs.binary32) {
      auto dec = dragonbox::to_decimal(static_cast<float>(value));
      write<char>(buffer_appender<char>(buf), dec.significand);
      return dec.exponent;
    }
    auto dec = dragonbox::to_decimal(static_cast<double>(value));
    write<char>(buffer_appender<char>(buf), dec.significand);
    return dec.exponent;
  }

  int exp = 0;
  bool use_dragon = true;
  if (is_fast_float<Float>()) {
    // Use Grisu + Dragon4 for the given precision:
    // https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf.
    const int min_exp = -60;  // alpha in Grisu.
    int cached_exp10 = 0;     // K in Grisu.
    fp normalized = normalize(fp(value));
    const auto cached_pow = get_cached_power(
        min_exp - (normalized.e + fp::num_significand_bits), cached_exp10);
    normalized = normalized * cached_pow;
    // Limit precision to the maximum possible number of significant digits in
    // an IEEE754 double because we don't need to generate zeros.
    const int max_double_digits = 767;
    if (precision > max_double_digits) precision = max_double_digits;
    gen_digits_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};
    if (grisu_gen_digits(normalized, 1, exp, handler) != digits::error &&
        !is_constant_evaluated()) {
      exp += handler.exp10;
      buf.try_resize(to_unsigned(handler.size));
      use_dragon = false;
    } else {
      exp += handler.size - cached_exp10 - 1;
      precision = handler.precision;
    }
  }
  if (use_dragon) {
    auto f = fp();
    bool is_predecessor_closer =
        specs.binary32 ? f.assign(static_cast<float>(value)) : f.assign(value);
    format_dragon(f, is_predecessor_closer, precision, buf, exp);
  }
  if (!fixed && !specs.showpoint) {
    // Remove trailing zeros.
    auto num_digits = buf.size();
    while (num_digits > 0 && buf[num_digits - 1] == '0') {
      --num_digits;
      ++exp;
    }
    buf.try_resize(num_digits);
  }
  return exp;
}

template <typename T>
int snprintf_float(T value, int precision, float_specs specs,
                   buffer<char>& buf) {
  // Buffer capacity must be non-zero, otherwise MSVC's vsnprintf_s will fail.
  FMT_ASSERT(buf.capacity() > buf.size(), "empty buffer");
  static_assert(!std::is_same<T, float>::value, "");

  // Subtract 1 to account for the difference in precision since we use %e for
  // both general and exponent format.
  if (specs.format == float_format::general ||
      specs.format == float_format::exp)
    precision = (precision >= 0 ? precision : 6) - 1;

  // Build the format string.
  enum { max_format_size = 7 };  // The longest format is "%#.*Le".
  char format[max_format_size];
  char* format_ptr = format;
  *format_ptr++ = '%';
  if (specs.showpoint && specs.format == float_format::hex) *format_ptr++ = '#';
  if (precision >= 0) {
    *format_ptr++ = '.';
    *format_ptr++ = '*';
  }
  if (std::is_same<T, long double>()) *format_ptr++ = 'L';
  *format_ptr++ = specs.format != float_format::hex
                      ? (specs.format == float_format::fixed ? 'f' : 'e')
                      : (specs.upper ? 'A' : 'a');
  *format_ptr = '\0';

  // Format using snprintf.
  auto offset = buf.size();
  for (;;) {
    auto begin = buf.data() + offset;
    auto capacity = buf.capacity() - offset;
#ifdef FMT_FUZZ
    if (precision > 100000)
      throw std::runtime_error(
          "fuzz mode - avoid large allocation inside snprintf");
#endif
    // Suppress the warning about a nonliteral format string.
    // Cannot use auto because of a bug in MinGW (#1532).
    int (*snprintf_ptr)(char*, size_t, const char*, ...) = FMT_SNPRINTF;
    int result = precision >= 0
                     ? snprintf_ptr(begin, capacity, format, precision, value)
                     : snprintf_ptr(begin, capacity, format, value);
    if (result < 0) {
      // The buffer will grow exponentially.
      buf.try_reserve(buf.capacity() + 1);
      continue;
    }
    auto size = to_unsigned(result);
    // Size equal to capacity means that the last character was truncated.
    if (size >= capacity) {
      buf.try_reserve(size + offset + 1);  // Add 1 for the terminating '\0'.
      continue;
    }
    auto is_digit = [](char c) { return c >= '0' && c <= '9'; };
    if (specs.format == float_format::fixed) {
      if (precision == 0) {
        buf.try_resize(size);
        return 0;
      }
      // Find and remove the decimal point.
      auto end = begin + size, p = end;
      do {
        --p;
      } while (is_digit(*p));
      int fraction_size = static_cast<int>(end - p - 1);
      std::memmove(p, p + 1, to_unsigned(fraction_size));
      buf.try_resize(size - 1);
      return -fraction_size;
    }
    if (specs.format == float_format::hex) {
      buf.try_resize(size + offset);
      return 0;
    }
    // Find and parse the exponent.
    auto end = begin + size, exp_pos = end;
    do {
      --exp_pos;
    } while (*exp_pos != 'e');
    char sign = exp_pos[1];
    FMT_ASSERT(sign == '+' || sign == '-', "");
    int exp = 0;
    auto p = exp_pos + 2;  // Skip 'e' and sign.
    do {
      FMT_ASSERT(is_digit(*p), "");
      exp = exp * 10 + (*p++ - '0');
    } while (p != end);
    if (sign == '-') exp = -exp;
    int fraction_size = 0;
    if (exp_pos != begin + 1) {
      // Remove trailing zeros.
      auto fraction_end = exp_pos - 1;
      while (*fraction_end == '0') --fraction_end;
      // Move the fractional part left to get rid of the decimal point.
      fraction_size = static_cast<int>(fraction_end - begin - 1);
      std::memmove(begin + 1, begin + 2, to_unsigned(fraction_size));
    }
    buf.try_resize(to_unsigned(fraction_size) + offset + 1);
    return exp - fraction_size;
  }
}
}  // namespace detail

template <> struct formatter<detail::bigint> {
  FMT_CONSTEXPR format_parse_context::iterator parse(
      format_parse_context& ctx) {
    return ctx.begin();
  }

  format_context::iterator format(const detail::bigint& n,
                                  format_context& ctx) {
    auto out = ctx.out();
    bool first = true;
    for (auto i = n.bigits_.size(); i > 0; --i) {
      auto value = n.bigits_[i - 1u];
      if (first) {
        out = format_to(out, FMT_STRING("{:x}"), value);
        first = false;
        continue;
      }
      out = format_to(out, FMT_STRING("{:08x}"), value);
    }
    if (n.exp_ > 0)
      out = format_to(out, FMT_STRING("p{}"),
                      n.exp_ * detail::bigint::bigit_bits);
    return out;
  }
};

FMT_FUNC detail::utf8_to_utf16::utf8_to_utf16(string_view s) {
  for_each_codepoint(s, [this](uint32_t cp, string_view) {
    if (cp == invalid_code_point) FMT_THROW(std::runtime_error("invalid utf8"));
    if (cp <= 0xFFFF) {
      buffer_.push_back(static_cast<wchar_t>(cp));
    } else {
      cp -= 0x10000;
      buffer_.push_back(static_cast<wchar_t>(0xD800 + (cp >> 10)));
      buffer_.push_back(static_cast<wchar_t>(0xDC00 + (cp & 0x3FF)));
    }
    return true;
  });
  buffer_.push_back(0);
}

FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
                                  const char* message) FMT_NOEXCEPT {
  FMT_TRY {
    auto ec = std::error_code(error_code, std::generic_category());
    write(std::back_inserter(out), std::system_error(ec, message).what());
    return;
  }
  FMT_CATCH(...) {}
  format_error_code(out, error_code, message);
}

FMT_FUNC void report_system_error(int error_code,
                                  const char* message) FMT_NOEXCEPT {
  report_error(format_system_error, error_code, message);
}

FMT_FUNC std::string vformat(string_view fmt, format_args args) {
  // Don't optimize the "{}" case to keep the binary size small and because it
  // can be better optimized in fmt::format anyway.
  auto buffer = memory_buffer();
  detail::vformat_to(buffer, fmt, args);
  return to_string(buffer);
}

#ifdef _WIN32
namespace detail {
using dword = conditional_t<sizeof(long) == 4, unsigned long, unsigned>;
extern "C" __declspec(dllimport) int __stdcall WriteConsoleW(  //
    void*, const void*, dword, dword*, void*);
}  // namespace detail
#endif

namespace detail {
FMT_FUNC void print(std::FILE* f, string_view text) {
#ifdef _WIN32
  auto fd = _fileno(f);
  if (_isatty(fd)) {
    detail::utf8_to_utf16 u16(string_view(text.data(), text.size()));
    auto written = detail::dword();
    if (detail::WriteConsoleW(reinterpret_cast<void*>(_get_osfhandle(fd)),
                              u16.c_str(), static_cast<uint32_t>(u16.size()),
                              &written, nullptr)) {
      return;
    }
    // Fallback to fwrite on failure. It can happen if the output has been
    // redirected to NUL.
  }
#endif
  detail::fwrite_fully(text.data(), 1, text.size(), f);
}
}  // namespace detail

FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {
  memory_buffer buffer;
  detail::vformat_to(buffer, format_str, args);
  detail::print(f, {buffer.data(), buffer.size()});
}

#ifdef _WIN32
// Print assuming legacy (non-Unicode) encoding.
FMT_FUNC void detail::vprint_mojibake(std::FILE* f, string_view format_str,
                                      format_args args) {
  memory_buffer buffer;
  detail::vformat_to(buffer, format_str,
                     basic_format_args<buffer_context<char>>(args));
  fwrite_fully(buffer.data(), 1, buffer.size(), f);
}
#endif

FMT_FUNC void vprint(string_view format_str, format_args args) {
  vprint(stdout, format_str, args);
}

FMT_END_NAMESPACE

#endif  // FMT_FORMAT_INL_H_

```

`include/fmt/format.cc`:

```cc
// Formatting library for C++
//
// Copyright (c) 2012 - 2016, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#include "fmt/format-inl.h"

FMT_BEGIN_NAMESPACE
namespace detail {

// DEPRECATED!
template <typename T = void> struct basic_data {
  FMT_API static constexpr const char digits[100][2] = {
      {'0', '0'}, {'0', '1'}, {'0', '2'}, {'0', '3'}, {'0', '4'}, {'0', '5'},
      {'0', '6'}, {'0', '7'}, {'0', '8'}, {'0', '9'}, {'1', '0'}, {'1', '1'},
      {'1', '2'}, {'1', '3'}, {'1', '4'}, {'1', '5'}, {'1', '6'}, {'1', '7'},
      {'1', '8'}, {'1', '9'}, {'2', '0'}, {'2', '1'}, {'2', '2'}, {'2', '3'},
      {'2', '4'}, {'2', '5'}, {'2', '6'}, {'2', '7'}, {'2', '8'}, {'2', '9'},
      {'3', '0'}, {'3', '1'}, {'3', '2'}, {'3', '3'}, {'3', '4'}, {'3', '5'},
      {'3', '6'}, {'3', '7'}, {'3', '8'}, {'3', '9'}, {'4', '0'}, {'4', '1'},
      {'4', '2'}, {'4', '3'}, {'4', '4'}, {'4', '5'}, {'4', '6'}, {'4', '7'},
      {'4', '8'}, {'4', '9'}, {'5', '0'}, {'5', '1'}, {'5', '2'}, {'5', '3'},
      {'5', '4'}, {'5', '5'}, {'5', '6'}, {'5', '7'}, {'5', '8'}, {'5', '9'},
      {'6', '0'}, {'6', '1'}, {'6', '2'}, {'6', '3'}, {'6', '4'}, {'6', '5'},
      {'6', '6'}, {'6', '7'}, {'6', '8'}, {'6', '9'}, {'7', '0'}, {'7', '1'},
      {'7', '2'}, {'7', '3'}, {'7', '4'}, {'7', '5'}, {'7', '6'}, {'7', '7'},
      {'7', '8'}, {'7', '9'}, {'8', '0'}, {'8', '1'}, {'8', '2'}, {'8', '3'},
      {'8', '4'}, {'8', '5'}, {'8', '6'}, {'8', '7'}, {'8', '8'}, {'8', '9'},
      {'9', '0'}, {'9', '1'}, {'9', '2'}, {'9', '3'}, {'9', '4'}, {'9', '5'},
      {'9', '6'}, {'9', '7'}, {'9', '8'}, {'9', '9'}};
  FMT_API static constexpr const char hex_digits[] = "0123456789abcdef";
  FMT_API static constexpr const char signs[4] = {0, '-', '+', ' '};
  FMT_API static constexpr const char left_padding_shifts[5] = {31, 31, 0, 1,
                                                                0};
  FMT_API static constexpr const char right_padding_shifts[5] = {0, 31, 0, 1,
                                                                 0};
  FMT_API static constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
                                                         0x1000000u | ' '};
};

#ifdef FMT_SHARED
// Required for -flto, -fivisibility=hidden and -shared to work
extern template struct basic_data<void>;
#endif

#if __cplusplus < 201703L
// DEPRECATED! These are here only for ABI compatiblity.
template <typename T> constexpr const char basic_data<T>::digits[][2];
template <typename T> constexpr const char basic_data<T>::hex_digits[];
template <typename T> constexpr const char basic_data<T>::signs[];
template <typename T> constexpr const char basic_data<T>::left_padding_shifts[];
template <typename T>
constexpr const char basic_data<T>::right_padding_shifts[];
template <typename T> constexpr const unsigned basic_data<T>::prefixes[];
#endif

template <typename T>
int format_float(char* buf, std::size_t size, const char* format, int precision,
                 T value) {
#ifdef FMT_FUZZ
  if (precision > 100000)
    throw std::runtime_error(
        "fuzz mode - avoid large allocation inside snprintf");
#endif
  // Suppress the warning about nonliteral format string.
  int (*snprintf_ptr)(char*, size_t, const char*, ...) = FMT_SNPRINTF;
  return precision < 0 ? snprintf_ptr(buf, size, format, value)
                       : snprintf_ptr(buf, size, format, precision, value);
}

template FMT_API dragonbox::decimal_fp<float> dragonbox::to_decimal(float x)
    FMT_NOEXCEPT;
template FMT_API dragonbox::decimal_fp<double> dragonbox::to_decimal(double x)
    FMT_NOEXCEPT;
}  // namespace detail

// Workaround a bug in MSVC2013 that prevents instantiation of format_float.
int (*instantiate_format_float)(double, int, detail::float_specs,
                                detail::buffer<char>&) = detail::format_float;

#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
template FMT_API detail::locale_ref::locale_ref(const std::locale& loc);
template FMT_API std::locale detail::locale_ref::get<std::locale>() const;
#endif

// Explicit instantiations for char.

template FMT_API auto detail::thousands_sep_impl(locale_ref)
    -> thousands_sep_result<char>;
template FMT_API char detail::decimal_point_impl(locale_ref);

template FMT_API void detail::buffer<char>::append(const char*, const char*);

// DEPRECATED!
// There is no correspondent extern template in format.h because of
// incompatibility between clang and gcc (#2377).
template FMT_API void detail::vformat_to(
    detail::buffer<char>&, string_view,
    basic_format_args<FMT_BUFFER_CONTEXT(char)>, detail::locale_ref);

template FMT_API int detail::snprintf_float(double, int, detail::float_specs,
                                            detail::buffer<char>&);
template FMT_API int detail::snprintf_float(long double, int,
                                            detail::float_specs,
                                            detail::buffer<char>&);
template FMT_API int detail::format_float(double, int, detail::float_specs,
                                          detail::buffer<char>&);
template FMT_API int detail::format_float(long double, int, detail::float_specs,
                                          detail::buffer<char>&);

// Explicit instantiations for wchar_t.

template FMT_API auto detail::thousands_sep_impl(locale_ref)
    -> thousands_sep_result<wchar_t>;
template FMT_API wchar_t detail::decimal_point_impl(locale_ref);

template FMT_API void detail::buffer<wchar_t>::append(const wchar_t*,
                                                      const wchar_t*);

template struct detail::basic_data<void>;

FMT_END_NAMESPACE

```

`include/fmt/format.h`:

```h
/*
 Formatting library for C++

 Copyright (c) 2012 - present, Victor Zverovich

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 --- Optional exception to the license ---

 As an exception, if, as a result of your compiling your source code, portions
 of this Software are embedded into a machine-executable object form of such
 source code, you may redistribute such embedded portions in such object form
 without including the above copyright and permission notices.
 */

#ifndef FMT_FORMAT_H_
#define FMT_FORMAT_H_

#include <cmath>         // std::signbit
#include <cstdint>       // uint32_t
#include <limits>        // std::numeric_limits
#include <memory>        // std::uninitialized_copy
#include <stdexcept>     // std::runtime_error
#include <system_error>  // std::system_error
#include <utility>       // std::swap

#ifdef __cpp_lib_bit_cast
#  include <bit>  // std::bitcast
#endif

#include "core.h"

#if FMT_GCC_VERSION
#  define FMT_GCC_VISIBILITY_HIDDEN __attribute__((visibility("hidden")))
#else
#  define FMT_GCC_VISIBILITY_HIDDEN
#endif

#ifdef __NVCC__
#  define FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)
#else
#  define FMT_CUDA_VERSION 0
#endif

#ifdef __has_builtin
#  define FMT_HAS_BUILTIN(x) __has_builtin(x)
#else
#  define FMT_HAS_BUILTIN(x) 0
#endif

#if FMT_GCC_VERSION || FMT_CLANG_VERSION
#  define FMT_NOINLINE __attribute__((noinline))
#else
#  define FMT_NOINLINE
#endif

#if FMT_MSC_VER
#  define FMT_MSC_DEFAULT = default
#else
#  define FMT_MSC_DEFAULT
#endif

#ifndef FMT_THROW
#  if FMT_EXCEPTIONS
#    if FMT_MSC_VER || FMT_NVCC
FMT_BEGIN_NAMESPACE
namespace detail {
template <typename Exception> inline void do_throw(const Exception& x) {
  // Silence unreachable code warnings in MSVC and NVCC because these
  // are nearly impossible to fix in a generic code.
  volatile bool b = true;
  if (b) throw x;
}
}  // namespace detail
FMT_END_NAMESPACE
#      define FMT_THROW(x) detail::do_throw(x)
#    else
#      define FMT_THROW(x) throw x
#    endif
#  else
#    define FMT_THROW(x)               \
      do {                             \
        FMT_ASSERT(false, (x).what()); \
      } while (false)
#  endif
#endif

#if FMT_EXCEPTIONS
#  define FMT_TRY try
#  define FMT_CATCH(x) catch (x)
#else
#  define FMT_TRY if (true)
#  define FMT_CATCH(x) if (false)
#endif

#ifndef FMT_DEPRECATED
#  if FMT_HAS_CPP14_ATTRIBUTE(deprecated) || FMT_MSC_VER >= 1900
#    define FMT_DEPRECATED [[deprecated]]
#  else
#    if (defined(__GNUC__) && !defined(__LCC__)) || defined(__clang__)
#      define FMT_DEPRECATED __attribute__((deprecated))
#    elif FMT_MSC_VER
#      define FMT_DEPRECATED __declspec(deprecated)
#    else
#      define FMT_DEPRECATED /* deprecated */
#    endif
#  endif
#endif

#ifndef FMT_MAYBE_UNUSED
#  if FMT_HAS_CPP17_ATTRIBUTE(maybe_unused)
#    define FMT_MAYBE_UNUSED [[maybe_unused]]
#  else
#    define FMT_MAYBE_UNUSED
#  endif
#endif

// Workaround broken [[deprecated]] in the Intel, PGI and NVCC compilers.
#if FMT_ICC_VERSION || defined(__PGI) || FMT_NVCC
#  define FMT_DEPRECATED_ALIAS
#else
#  define FMT_DEPRECATED_ALIAS FMT_DEPRECATED
#endif

#ifndef FMT_USE_USER_DEFINED_LITERALS
// EDG based compilers (Intel, NVIDIA, Elbrus, etc), GCC and MSVC support UDLs.
#  if (FMT_HAS_FEATURE(cxx_user_literals) || FMT_GCC_VERSION >= 407 || \
       FMT_MSC_VER >= 1900) &&                                         \
      (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= /* UDL feature */ 480)
#    define FMT_USE_USER_DEFINED_LITERALS 1
#  else
#    define FMT_USE_USER_DEFINED_LITERALS 0
#  endif
#endif

// Defining FMT_REDUCE_INT_INSTANTIATIONS to 1, will reduce the number of
// integer formatter template instantiations to just one by only using the
// largest integer type. This results in a reduction in binary size but will
// cause a decrease in integer formatting performance.
#if !defined(FMT_REDUCE_INT_INSTANTIATIONS)
#  define FMT_REDUCE_INT_INSTANTIATIONS 0
#endif

// __builtin_clz is broken in clang with Microsoft CodeGen:
// https://github.com/fmtlib/fmt/issues/519.
#if !FMT_MSC_VER
#  if FMT_HAS_BUILTIN(__builtin_clz) || FMT_GCC_VERSION || FMT_ICC_VERSION
#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
#  endif
#  if FMT_HAS_BUILTIN(__builtin_clzll) || FMT_GCC_VERSION || FMT_ICC_VERSION
#    define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
#  endif
#endif

// __builtin_ctz is broken in Intel Compiler Classic on Windows:
// https://github.com/fmtlib/fmt/issues/2510.
#ifndef __ICL
#  if FMT_HAS_BUILTIN(__builtin_ctz) || FMT_GCC_VERSION || FMT_ICC_VERSION
#    define FMT_BUILTIN_CTZ(n) __builtin_ctz(n)
#  endif
#  if FMT_HAS_BUILTIN(__builtin_ctzll) || FMT_GCC_VERSION || FMT_ICC_VERSION
#    define FMT_BUILTIN_CTZLL(n) __builtin_ctzll(n)
#  endif
#endif

#if FMT_MSC_VER
#  include <intrin.h>  // _BitScanReverse[64], _BitScanForward[64], _umul128
#endif

// Some compilers masquerade as both MSVC and GCC-likes or otherwise support
// __builtin_clz and __builtin_clzll, so only define FMT_BUILTIN_CLZ using the
// MSVC intrinsics if the clz and clzll builtins are not available.
#if FMT_MSC_VER && !defined(FMT_BUILTIN_CLZLL) && !defined(FMT_BUILTIN_CTZLL)
FMT_BEGIN_NAMESPACE
namespace detail {
// Avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning.
#  if !defined(__clang__)
#    pragma intrinsic(_BitScanForward)
#    pragma intrinsic(_BitScanReverse)
#    if defined(_WIN64)
#      pragma intrinsic(_BitScanForward64)
#      pragma intrinsic(_BitScanReverse64)
#    endif
#  endif

inline auto clz(uint32_t x) -> int {
  unsigned long r = 0;
  _BitScanReverse(&r, x);
  FMT_ASSERT(x != 0, "");
  // Static analysis complains about using uninitialized data
  // "r", but the only way that can happen is if "x" is 0,
  // which the callers guarantee to not happen.
  FMT_MSC_WARNING(suppress : 6102)
  return 31 ^ static_cast<int>(r);
}
#  define FMT_BUILTIN_CLZ(n) detail::clz(n)

inline auto clzll(uint64_t x) -> int {
  unsigned long r = 0;
#  ifdef _WIN64
  _BitScanReverse64(&r, x);
#  else
  // Scan the high 32 bits.
  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32))) return 63 ^ (r + 32);
  // Scan the low 32 bits.
  _BitScanReverse(&r, static_cast<uint32_t>(x));
#  endif
  FMT_ASSERT(x != 0, "");
  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
  return 63 ^ static_cast<int>(r);
}
#  define FMT_BUILTIN_CLZLL(n) detail::clzll(n)

inline auto ctz(uint32_t x) -> int {
  unsigned long r = 0;
  _BitScanForward(&r, x);
  FMT_ASSERT(x != 0, "");
  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
  return static_cast<int>(r);
}
#  define FMT_BUILTIN_CTZ(n) detail::ctz(n)

inline auto ctzll(uint64_t x) -> int {
  unsigned long r = 0;
  FMT_ASSERT(x != 0, "");
  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
#  ifdef _WIN64
  _BitScanForward64(&r, x);
#  else
  // Scan the low 32 bits.
  if (_BitScanForward(&r, static_cast<uint32_t>(x))) return static_cast<int>(r);
  // Scan the high 32 bits.
  _BitScanForward(&r, static_cast<uint32_t>(x >> 32));
  r += 32;
#  endif
  return static_cast<int>(r);
}
#  define FMT_BUILTIN_CTZLL(n) detail::ctzll(n)
}  // namespace detail
FMT_END_NAMESPACE
#endif

#ifdef FMT_HEADER_ONLY
#  define FMT_HEADER_ONLY_CONSTEXPR20 FMT_CONSTEXPR20
#else
#  define FMT_HEADER_ONLY_CONSTEXPR20
#endif

FMT_BEGIN_NAMESPACE
namespace detail {
// An equivalent of `*reinterpret_cast<Dest*>(&source)` that doesn't have
// undefined behavior (e.g. due to type aliasing).
// Example: uint64_t d = bit_cast<uint64_t>(2.718);
template <typename Dest, typename Source>
FMT_CONSTEXPR20 auto bit_cast(const Source& source) -> Dest {
  static_assert(sizeof(Dest) == sizeof(Source), "size mismatch");
#ifdef __cpp_lib_bit_cast
  if (is_constant_evaluated()) {
    return std::bit_cast<Dest>(source);
  }
#endif
  Dest dest;
  std::memcpy(&dest, &source, sizeof(dest));
  return dest;
}

inline auto is_big_endian() -> bool {
  const auto u = 1u;
  struct bytes {
    char data[sizeof(u)];
  };
  return bit_cast<bytes>(u).data[0] == 0;
}

// A fallback implementation of uintptr_t for systems that lack it.
struct fallback_uintptr {
  unsigned char value[sizeof(void*)];

  fallback_uintptr() = default;
  explicit fallback_uintptr(const void* p) {
    *this = bit_cast<fallback_uintptr>(p);
    if (is_big_endian()) {
      for (size_t i = 0, j = sizeof(void*) - 1; i < j; ++i, --j)
        std::swap(value[i], value[j]);
    }
  }
};
#ifdef UINTPTR_MAX
using uintptr_t = ::uintptr_t;
inline auto to_uintptr(const void* p) -> uintptr_t {
  return bit_cast<uintptr_t>(p);
}
#else
using uintptr_t = fallback_uintptr;
inline auto to_uintptr(const void* p) -> fallback_uintptr {
  return fallback_uintptr(p);
}
#endif

// Returns the largest possible value for type T. Same as
// std::numeric_limits<T>::max() but shorter and not affected by the max macro.
template <typename T> constexpr auto max_value() -> T {
  return (std::numeric_limits<T>::max)();
}
template <typename T> constexpr auto num_bits() -> int {
  return std::numeric_limits<T>::digits;
}
// std::numeric_limits<T>::digits may return 0 for 128-bit ints.
template <> constexpr auto num_bits<int128_t>() -> int { return 128; }
template <> constexpr auto num_bits<uint128_t>() -> int { return 128; }
template <> constexpr auto num_bits<fallback_uintptr>() -> int {
  return static_cast<int>(sizeof(void*) *
                          std::numeric_limits<unsigned char>::digits);
}

FMT_INLINE void assume(bool condition) {
  (void)condition;
#if FMT_HAS_BUILTIN(__builtin_assume)
  __builtin_assume(condition);
#endif
}

// An approximation of iterator_t for pre-C++20 systems.
template <typename T>
using iterator_t = decltype(std::begin(std::declval<T&>()));
template <typename T> using sentinel_t = decltype(std::end(std::declval<T&>()));

// A workaround for std::string not having mutable data() until C++17.
template <typename Char>
inline auto get_data(std::basic_string<Char>& s) -> Char* {
  return &s[0];
}
template <typename Container>
inline auto get_data(Container& c) -> typename Container::value_type* {
  return c.data();
}

#if defined(_SECURE_SCL) && _SECURE_SCL
// Make a checked iterator to avoid MSVC warnings.
template <typename T> using checked_ptr = stdext::checked_array_iterator<T*>;
template <typename T>
constexpr auto make_checked(T* p, size_t size) -> checked_ptr<T> {
  return {p, size};
}
#else
template <typename T> using checked_ptr = T*;
template <typename T> constexpr auto make_checked(T* p, size_t) -> T* {
  return p;
}
#endif

// Attempts to reserve space for n extra characters in the output range.
// Returns a pointer to the reserved range or a reference to it.
template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
#if FMT_CLANG_VERSION >= 307 && !FMT_ICC_VERSION
__attribute__((no_sanitize("undefined")))
#endif
inline auto
reserve(std::back_insert_iterator<Container> it, size_t n)
    -> checked_ptr<typename Container::value_type> {
  Container& c = get_container(it);
  size_t size = c.size();
  c.resize(size + n);
  return make_checked(get_data(c) + size, n);
}

template <typename T>
inline auto reserve(buffer_appender<T> it, size_t n) -> buffer_appender<T> {
  buffer<T>& buf = get_container(it);
  buf.try_reserve(buf.size() + n);
  return it;
}

template <typename Iterator>
constexpr auto reserve(Iterator& it, size_t) -> Iterator& {
  return it;
}

template <typename OutputIt>
using reserve_iterator =
    remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;

template <typename T, typename OutputIt>
constexpr auto to_pointer(OutputIt, size_t) -> T* {
  return nullptr;
}
template <typename T> auto to_pointer(buffer_appender<T> it, size_t n) -> T* {
  buffer<T>& buf = get_container(it);
  auto size = buf.size();
  if (buf.capacity() < size + n) return nullptr;
  buf.try_resize(size + n);
  return buf.data() + size;
}

template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
inline auto base_iterator(std::back_insert_iterator<Container>& it,
                          checked_ptr<typename Container::value_type>)
    -> std::back_insert_iterator<Container> {
  return it;
}

template <typename Iterator>
constexpr auto base_iterator(Iterator, Iterator it) -> Iterator {
  return it;
}

// <algorithm> is spectacularly slow to compile in C++20 so use a simple fill_n
// instead (#1998).
template <typename OutputIt, typename Size, typename T>
FMT_CONSTEXPR auto fill_n(OutputIt out, Size count, const T& value)
    -> OutputIt {
  for (Size i = 0; i < count; ++i) *out++ = value;
  return out;
}
template <typename T, typename Size>
FMT_CONSTEXPR20 auto fill_n(T* out, Size count, char value) -> T* {
  if (is_constant_evaluated()) {
    return fill_n<T*, Size, T>(out, count, value);
  }
  std::memset(out, value, to_unsigned(count));
  return out + count;
}

#ifdef __cpp_char8_t
using char8_type = char8_t;
#else
enum char8_type : unsigned char {};
#endif

template <typename OutChar, typename InputIt, typename OutputIt>
FMT_CONSTEXPR FMT_NOINLINE auto copy_str_noinline(InputIt begin, InputIt end,
                                                  OutputIt out) -> OutputIt {
  return copy_str<OutChar>(begin, end, out);
}

// A public domain branchless UTF-8 decoder by Christopher Wellons:
// https://github.com/skeeto/branchless-utf8
/* Decode the next character, c, from s, reporting errors in e.
 *
 * Since this is a branchless decoder, four bytes will be read from the
 * buffer regardless of the actual length of the next character. This
 * means the buffer _must_ have at least three bytes of zero padding
 * following the end of the data stream.
 *
 * Errors are reported in e, which will be non-zero if the parsed
 * character was somehow invalid: invalid byte sequence, non-canonical
 * encoding, or a surrogate half.
 *
 * The function returns a pointer to the next character. When an error
 * occurs, this pointer will be a guess that depends on the particular
 * error, but it will always advance at least one byte.
 */
FMT_CONSTEXPR inline auto utf8_decode(const char* s, uint32_t* c, int* e)
    -> const char* {
  constexpr const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};
  constexpr const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};
  constexpr const int shiftc[] = {0, 18, 12, 6, 0};
  constexpr const int shifte[] = {0, 6, 4, 2, 0};

  int len = code_point_length(s);
  const char* next = s + len;

  // Assume a four-byte character and load four bytes. Unused bits are
  // shifted out.
  *c = uint32_t(s[0] & masks[len]) << 18;
  *c |= uint32_t(s[1] & 0x3f) << 12;
  *c |= uint32_t(s[2] & 0x3f) << 6;
  *c |= uint32_t(s[3] & 0x3f) << 0;
  *c >>= shiftc[len];

  // Accumulate the various error conditions.
  using uchar = unsigned char;
  *e = (*c < mins[len]) << 6;       // non-canonical encoding
  *e |= ((*c >> 11) == 0x1b) << 7;  // surrogate half?
  *e |= (*c > 0x10FFFF) << 8;       // out of range?
  *e |= (uchar(s[1]) & 0xc0) >> 2;
  *e |= (uchar(s[2]) & 0xc0) >> 4;
  *e |= uchar(s[3]) >> 6;
  *e ^= 0x2a;  // top two bits of each tail byte correct?
  *e >>= shifte[len];

  return next;
}

enum { invalid_code_point = ~uint32_t() };

// Invokes f(cp, sv) for every code point cp in s with sv being the string view
// corresponding to the code point. cp is invalid_code_point on error.
template <typename F>
FMT_CONSTEXPR void for_each_codepoint(string_view s, F f) {
  auto decode = [f](const char* buf_ptr, const char* ptr) {
    auto cp = uint32_t();
    auto error = 0;
    auto end = utf8_decode(buf_ptr, &cp, &error);
    bool result = f(error ? invalid_code_point : cp,
                    string_view(ptr, to_unsigned(end - buf_ptr)));
    return result ? end : nullptr;
  };
  auto p = s.data();
  const size_t block_size = 4;  // utf8_decode always reads blocks of 4 chars.
  if (s.size() >= block_size) {
    for (auto end = p + s.size() - block_size + 1; p < end;) {
      p = decode(p, p);
      if (!p) return;
    }
  }
  if (auto num_chars_left = s.data() + s.size() - p) {
    char buf[2 * block_size - 1] = {};
    copy_str<char>(p, p + num_chars_left, buf);
    const char* buf_ptr = buf;
    do {
      auto end = decode(buf_ptr, p);
      if (!end) return;
      p += end - buf_ptr;
      buf_ptr = end;
    } while (buf_ptr - buf < num_chars_left);
  }
}

template <typename Char>
inline auto compute_width(basic_string_view<Char> s) -> size_t {
  return s.size();
}

// Computes approximate display width of a UTF-8 string.
FMT_CONSTEXPR inline size_t compute_width(string_view s) {
  size_t num_code_points = 0;
  // It is not a lambda for compatibility with C++14.
  struct count_code_points {
    size_t* count;
    FMT_CONSTEXPR auto operator()(uint32_t cp, string_view) const -> bool {
      *count += detail::to_unsigned(
          1 +
          (cp >= 0x1100 &&
           (cp <= 0x115f ||  // Hangul Jamo init. consonants
            cp == 0x2329 ||  // LEFT-POINTING ANGLE BRACKET
            cp == 0x232a ||  // RIGHT-POINTING ANGLE BRACKET
            // CJK ... Yi except IDEOGRAPHIC HALF FILL SPACE:
            (cp >= 0x2e80 && cp <= 0xa4cf && cp != 0x303f) ||
            (cp >= 0xac00 && cp <= 0xd7a3) ||    // Hangul Syllables
            (cp >= 0xf900 && cp <= 0xfaff) ||    // CJK Compatibility Ideographs
            (cp >= 0xfe10 && cp <= 0xfe19) ||    // Vertical Forms
            (cp >= 0xfe30 && cp <= 0xfe6f) ||    // CJK Compatibility Forms
            (cp >= 0xff00 && cp <= 0xff60) ||    // Fullwidth Forms
            (cp >= 0xffe0 && cp <= 0xffe6) ||    // Fullwidth Forms
            (cp >= 0x20000 && cp <= 0x2fffd) ||  // CJK
            (cp >= 0x30000 && cp <= 0x3fffd) ||
            // Miscellaneous Symbols and Pictographs + Emoticons:
            (cp >= 0x1f300 && cp <= 0x1f64f) ||
            // Supplemental Symbols and Pictographs:
            (cp >= 0x1f900 && cp <= 0x1f9ff))));
      return true;
    }
  };
  for_each_codepoint(s, count_code_points{&num_code_points});
  return num_code_points;
}

inline auto compute_width(basic_string_view<char8_type> s) -> size_t {
  return compute_width(basic_string_view<char>(
      reinterpret_cast<const char*>(s.data()), s.size()));
}

template <typename Char>
inline auto code_point_index(basic_string_view<Char> s, size_t n) -> size_t {
  size_t size = s.size();
  return n < size ? n : size;
}

// Calculates the index of the nth code point in a UTF-8 string.
inline auto code_point_index(basic_string_view<char8_type> s, size_t n)
    -> size_t {
  const char8_type* data = s.data();
  size_t num_code_points = 0;
  for (size_t i = 0, size = s.size(); i != size; ++i) {
    if ((data[i] & 0xc0) != 0x80 && ++num_code_points > n) return i;
  }
  return s.size();
}

template <typename T, bool = std::is_floating_point<T>::value>
struct is_fast_float : bool_constant<std::numeric_limits<T>::is_iec559 &&
                                     sizeof(T) <= sizeof(double)> {};
template <typename T> struct is_fast_float<T, false> : std::false_type {};

#ifndef FMT_USE_FULL_CACHE_DRAGONBOX
#  define FMT_USE_FULL_CACHE_DRAGONBOX 0
#endif

template <typename T>
template <typename U>
void buffer<T>::append(const U* begin, const U* end) {
  while (begin != end) {
    auto count = to_unsigned(end - begin);
    try_reserve(size_ + count);
    auto free_cap = capacity_ - size_;
    if (free_cap < count) count = free_cap;
    std::uninitialized_copy_n(begin, count, make_checked(ptr_ + size_, count));
    size_ += count;
    begin += count;
  }
}

template <typename T, typename Enable = void>
struct is_locale : std::false_type {};
template <typename T>
struct is_locale<T, void_t<decltype(T::classic())>> : std::true_type {};
}  // namespace detail

FMT_MODULE_EXPORT_BEGIN

// The number of characters to store in the basic_memory_buffer object itself
// to avoid dynamic memory allocation.
enum { inline_buffer_size = 500 };

/**
  \rst
  A dynamically growing memory buffer for trivially copyable/constructible types
  with the first ``SIZE`` elements stored in the object itself.

  You can use the ``memory_buffer`` type alias for ``char`` instead.

  **Example**::

     auto out = fmt::memory_buffer();
     format_to(std::back_inserter(out), "The answer is {}.", 42);

  This will append the following output to the ``out`` object:

  .. code-block:: none

     The answer is 42.

  The output can be converted to an ``std::string`` with ``to_string(out)``.
  \endrst
 */
template <typename T, size_t SIZE = inline_buffer_size,
          typename Allocator = std::allocator<T>>
class basic_memory_buffer final : public detail::buffer<T> {
 private:
  T store_[SIZE];

  // Don't inherit from Allocator avoid generating type_info for it.
  Allocator alloc_;

  // Deallocate memory allocated by the buffer.
  FMT_CONSTEXPR20 void deallocate() {
    T* data = this->data();
    if (data != store_) alloc_.deallocate(data, this->capacity());
  }

 protected:
  void grow(size_t size) override;

 public:
  using value_type = T;
  using const_reference = const T&;

  FMT_CONSTEXPR20 explicit basic_memory_buffer(
      const Allocator& alloc = Allocator())
      : alloc_(alloc) {
    this->set(store_, SIZE);
    if (detail::is_constant_evaluated()) {
      detail::fill_n(store_, SIZE, T{});
    }
  }
  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }

 private:
  // Move data from other to this buffer.
  FMT_CONSTEXPR20 void move(basic_memory_buffer& other) {
    alloc_ = std::move(other.alloc_);
    T* data = other.data();
    size_t size = other.size(), capacity = other.capacity();
    if (data == other.store_) {
      this->set(store_, capacity);
      if (detail::is_constant_evaluated()) {
        detail::copy_str<T>(other.store_, other.store_ + size,
                            detail::make_checked(store_, capacity));
      } else {
        std::uninitialized_copy(other.store_, other.store_ + size,
                                detail::make_checked(store_, capacity));
      }
    } else {
      this->set(data, capacity);
      // Set pointer to the inline array so that delete is not called
      // when deallocating.
      other.set(other.store_, 0);
    }
    this->resize(size);
  }

 public:
  /**
    \rst
    Constructs a :class:`fmt::basic_memory_buffer` object moving the content
    of the other object to it.
    \endrst
   */
  FMT_CONSTEXPR20 basic_memory_buffer(basic_memory_buffer&& other)
      FMT_NOEXCEPT {
    move(other);
  }

  /**
    \rst
    Moves the content of the other ``basic_memory_buffer`` object to this one.
    \endrst
   */
  auto operator=(basic_memory_buffer&& other) FMT_NOEXCEPT
      -> basic_memory_buffer& {
    FMT_ASSERT(this != &other, "");
    deallocate();
    move(other);
    return *this;
  }

  // Returns a copy of the allocator associated with this buffer.
  auto get_allocator() const -> Allocator { return alloc_; }

  /**
    Resizes the buffer to contain *count* elements. If T is a POD type new
    elements may not be initialized.
   */
  FMT_CONSTEXPR20 void resize(size_t count) { this->try_resize(count); }

  /** Increases the buffer capacity to *new_capacity*. */
  void reserve(size_t new_capacity) { this->try_reserve(new_capacity); }

  // Directly append data into the buffer
  using detail::buffer<T>::append;
  template <typename ContiguousRange>
  void append(const ContiguousRange& range) {
    append(range.data(), range.data() + range.size());
  }
};

template <typename T, size_t SIZE, typename Allocator>
void basic_memory_buffer<T, SIZE, Allocator>::grow(size_t size) {
#ifdef FMT_FUZZ
  if (size > 5000) throw std::runtime_error("fuzz mode - won't grow that much");
#endif
  const size_t max_size = std::allocator_traits<Allocator>::max_size(alloc_);
  size_t old_capacity = this->capacity();
  size_t new_capacity = old_capacity + old_capacity / 2;
  if (size > new_capacity)
    new_capacity = size;
  else if (new_capacity > max_size)
    new_capacity = size > max_size ? size : max_size;
  T* old_data = this->data();
  T* new_data =
      std::allocator_traits<Allocator>::allocate(alloc_, new_capacity);
  // The following code doesn't throw, so the raw pointer above doesn't leak.
  std::uninitialized_copy(old_data, old_data + this->size(),
                          detail::make_checked(new_data, new_capacity));
  this->set(new_data, new_capacity);
  // deallocate must not throw according to the standard, but even if it does,
  // the buffer already uses the new storage and will deallocate it in
  // destructor.
  if (old_data != store_) alloc_.deallocate(old_data, old_capacity);
}

using memory_buffer = basic_memory_buffer<char>;

template <typename T, size_t SIZE, typename Allocator>
struct is_contiguous<basic_memory_buffer<T, SIZE, Allocator>> : std::true_type {
};

namespace detail {
FMT_API void print(std::FILE*, string_view);
}

/** A formatting error such as invalid format string. */
FMT_CLASS_API
class FMT_API format_error : public std::runtime_error {
 public:
  explicit format_error(const char* message) : std::runtime_error(message) {}
  explicit format_error(const std::string& message)
      : std::runtime_error(message) {}
  format_error(const format_error&) = default;
  format_error& operator=(const format_error&) = default;
  format_error(format_error&&) = default;
  format_error& operator=(format_error&&) = default;
  ~format_error() FMT_NOEXCEPT override FMT_MSC_DEFAULT;
};

/**
  \rst
  Constructs a `~fmt::format_arg_store` object that contains references
  to arguments and can be implicitly converted to `~fmt::format_args`.
  If ``fmt`` is a compile-time string then `make_args_checked` checks
  its validity at compile time.
  \endrst
 */
template <typename... Args, typename S, typename Char = char_t<S>>
FMT_INLINE auto make_args_checked(const S& fmt,
                                  const remove_reference_t<Args>&... args)
    -> format_arg_store<buffer_context<Char>, remove_reference_t<Args>...> {
  static_assert(
      detail::count<(
              std::is_base_of<detail::view, remove_reference_t<Args>>::value &&
              std::is_reference<Args>::value)...>() == 0,
      "passing views as lvalues is disallowed");
  detail::check_format_string<Args...>(fmt);
  return {args...};
}

// compile-time support
namespace detail_exported {
#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
template <typename Char, size_t N> struct fixed_string {
  constexpr fixed_string(const Char (&str)[N]) {
    detail::copy_str<Char, const Char*, Char*>(static_cast<const Char*>(str),
                                               str + N, data);
  }
  Char data[N]{};
};
#endif

// Converts a compile-time string to basic_string_view.
template <typename Char, size_t N>
constexpr auto compile_string_to_view(const Char (&s)[N])
    -> basic_string_view<Char> {
  // Remove trailing NUL character if needed. Won't be present if this is used
  // with a raw character array (i.e. not defined as a string).
  return {s, N - (std::char_traits<Char>::to_int_type(s[N - 1]) == 0 ? 1 : 0)};
}
template <typename Char>
constexpr auto compile_string_to_view(detail::std_string_view<Char> s)
    -> basic_string_view<Char> {
  return {s.data(), s.size()};
}
}  // namespace detail_exported

FMT_BEGIN_DETAIL_NAMESPACE

template <typename T> struct is_integral : std::is_integral<T> {};
template <> struct is_integral<int128_t> : std::true_type {};
template <> struct is_integral<uint128_t> : std::true_type {};

template <typename T>
using is_signed =
    std::integral_constant<bool, std::numeric_limits<T>::is_signed ||
                                     std::is_same<T, int128_t>::value>;

// Returns true if value is negative, false otherwise.
// Same as `value < 0` but doesn't produce warnings if T is an unsigned type.
template <typename T, FMT_ENABLE_IF(is_signed<T>::value)>
FMT_CONSTEXPR auto is_negative(T value) -> bool {
  return value < 0;
}
template <typename T, FMT_ENABLE_IF(!is_signed<T>::value)>
FMT_CONSTEXPR auto is_negative(T) -> bool {
  return false;
}

template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
FMT_CONSTEXPR auto is_supported_floating_point(T) -> uint16_t {
  return (std::is_same<T, float>::value && FMT_USE_FLOAT) ||
         (std::is_same<T, double>::value && FMT_USE_DOUBLE) ||
         (std::is_same<T, long double>::value && FMT_USE_LONG_DOUBLE);
}

// Smallest of uint32_t, uint64_t, uint128_t that is large enough to
// represent all values of an integral type T.
template <typename T>
using uint32_or_64_or_128_t =
    conditional_t<num_bits<T>() <= 32 && !FMT_REDUCE_INT_INSTANTIATIONS,
                  uint32_t,
                  conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>>;
template <typename T>
using uint64_or_128_t = conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>;

#define FMT_POWERS_OF_10(factor)                                             \
  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
      (factor)*1000000000

// Converts value in the range [0, 100) to a string.
constexpr const char* digits2(size_t value) {
  // GCC generates slightly better code when value is pointer-size.
  return &"0001020304050607080910111213141516171819"
         "2021222324252627282930313233343536373839"
         "4041424344454647484950515253545556575859"
         "6061626364656667686970717273747576777879"
         "8081828384858687888990919293949596979899"[value * 2];
}

// Sign is a template parameter to workaround a bug in gcc 4.8.
template <typename Char, typename Sign> constexpr Char sign(Sign s) {
#if !FMT_GCC_VERSION || FMT_GCC_VERSION > 408
  static_assert(std::is_same<Sign, sign_t>::value, "");
#endif
  return static_cast<Char>("\0-+ "[s]);
}

template <typename T> FMT_CONSTEXPR auto count_digits_fallback(T n) -> int {
  int count = 1;
  for (;;) {
    // Integer division is slow so do it for a group of four digits instead
    // of for every digit. The idea comes from the talk by Alexandrescu
    // "Three Optimization Tips for C++". See speed-test for a comparison.
    if (n < 10) return count;
    if (n < 100) return count + 1;
    if (n < 1000) return count + 2;
    if (n < 10000) return count + 3;
    n /= 10000u;
    count += 4;
  }
}
#if FMT_USE_INT128
FMT_CONSTEXPR inline auto count_digits(uint128_t n) -> int {
  return count_digits_fallback(n);
}
#endif

#ifdef FMT_BUILTIN_CLZLL
// It is a separate function rather than a part of count_digits to workaround
// the lack of static constexpr in constexpr functions.
inline auto do_count_digits(uint64_t n) -> int {
  // This has comparable performance to the version by Kendall Willets
  // (https://github.com/fmtlib/format-benchmark/blob/master/digits10)
  // but uses smaller tables.
  // Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) - 1)).
  static constexpr uint8_t bsr2log10[] = {
      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};
  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];
  static constexpr const uint64_t zero_or_powers_of_10[] = {
      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
      10000000000000000000ULL};
  return t - (n < zero_or_powers_of_10[t]);
}
#endif

// Returns the number of decimal digits in n. Leading zeros are not counted
// except for n == 0 in which case count_digits returns 1.
FMT_CONSTEXPR20 inline auto count_digits(uint64_t n) -> int {
#ifdef FMT_BUILTIN_CLZLL
  if (!is_constant_evaluated()) {
    return do_count_digits(n);
  }
#endif
  return count_digits_fallback(n);
}

// Counts the number of digits in n. BITS = log2(radix).
template <int BITS, typename UInt>
FMT_CONSTEXPR auto count_digits(UInt n) -> int {
#ifdef FMT_BUILTIN_CLZ
  if (num_bits<UInt>() == 32)
    return (FMT_BUILTIN_CLZ(static_cast<uint32_t>(n) | 1) ^ 31) / BITS + 1;
#endif
  // Lambda avoids unreachable code warnings from NVHPC.
  return [](UInt m) {
    int num_digits = 0;
    do {
      ++num_digits;
    } while ((m >>= BITS) != 0);
    return num_digits;
  }(n);
}

template <> auto count_digits<4>(detail::fallback_uintptr n) -> int;

#ifdef FMT_BUILTIN_CLZ
// It is a separate function rather than a part of count_digits to workaround
// the lack of static constexpr in constexpr functions.
FMT_INLINE auto do_count_digits(uint32_t n) -> int {
// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.
// This increments the upper 32 bits (log10(T) - 1) when >= T is added.
#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  static constexpr uint64_t table[] = {
      FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
      FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
      FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
      FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
      FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
      FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
      FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
      FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
      FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
      FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
      FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
  };
  auto inc = table[FMT_BUILTIN_CLZ(n | 1) ^ 31];
  return static_cast<int>((n + inc) >> 32);
}
#endif

// Optional version of count_digits for better performance on 32-bit platforms.
FMT_CONSTEXPR20 inline auto count_digits(uint32_t n) -> int {
#ifdef FMT_BUILTIN_CLZ
  if (!is_constant_evaluated()) {
    return do_count_digits(n);
  }
#endif
  return count_digits_fallback(n);
}

template <typename Int> constexpr auto digits10() FMT_NOEXCEPT -> int {
  return std::numeric_limits<Int>::digits10;
}
template <> constexpr auto digits10<int128_t>() FMT_NOEXCEPT -> int {
  return 38;
}
template <> constexpr auto digits10<uint128_t>() FMT_NOEXCEPT -> int {
  return 38;
}

template <typename Char> struct thousands_sep_result {
  std::string grouping;
  Char thousands_sep;
};

template <typename Char>
FMT_API auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char>;
template <typename Char>
inline auto thousands_sep(locale_ref loc) -> thousands_sep_result<Char> {
  auto result = thousands_sep_impl<char>(loc);
  return {result.grouping, Char(result.thousands_sep)};
}
template <>
inline auto thousands_sep(locale_ref loc) -> thousands_sep_result<wchar_t> {
  return thousands_sep_impl<wchar_t>(loc);
}

template <typename Char>
FMT_API auto decimal_point_impl(locale_ref loc) -> Char;
template <typename Char> inline auto decimal_point(locale_ref loc) -> Char {
  return Char(decimal_point_impl<char>(loc));
}
template <> inline auto decimal_point(locale_ref loc) -> wchar_t {
  return decimal_point_impl<wchar_t>(loc);
}

// Compares two characters for equality.
template <typename Char> auto equal2(const Char* lhs, const char* rhs) -> bool {
  return lhs[0] == Char(rhs[0]) && lhs[1] == Char(rhs[1]);
}
inline auto equal2(const char* lhs, const char* rhs) -> bool {
  return memcmp(lhs, rhs, 2) == 0;
}

// Copies two characters from src to dst.
template <typename Char>
FMT_CONSTEXPR20 FMT_INLINE void copy2(Char* dst, const char* src) {
  if (!is_constant_evaluated() && sizeof(Char) == sizeof(char)) {
    memcpy(dst, src, 2);
    return;
  }
  *dst++ = static_cast<Char>(*src++);
  *dst = static_cast<Char>(*src);
}

template <typename Iterator> struct format_decimal_result {
  Iterator begin;
  Iterator end;
};

// Formats a decimal unsigned integer value writing into out pointing to a
// buffer of specified size. The caller must ensure that the buffer is large
// enough.
template <typename Char, typename UInt>
FMT_CONSTEXPR20 auto format_decimal(Char* out, UInt value, int size)
    -> format_decimal_result<Char*> {
  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
  out += size;
  Char* end = out;
  while (value >= 100) {
    // Integer division is slow so do it for a group of two digits instead
    // of for every digit. The idea comes from the talk by Alexandrescu
    // "Three Optimization Tips for C++". See speed-test for a comparison.
    out -= 2;
    copy2(out, digits2(static_cast<size_t>(value % 100)));
    value /= 100;
  }
  if (value < 10) {
    *--out = static_cast<Char>('0' + value);
    return {out, end};
  }
  out -= 2;
  copy2(out, digits2(static_cast<size_t>(value)));
  return {out, end};
}

template <typename Char, typename UInt, typename Iterator,
          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<Iterator>>::value)>
inline auto format_decimal(Iterator out, UInt value, int size)
    -> format_decimal_result<Iterator> {
  // Buffer is large enough to hold all digits (digits10 + 1).
  Char buffer[digits10<UInt>() + 1];
  auto end = format_decimal(buffer, value, size).end;
  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
}

template <unsigned BASE_BITS, typename Char, typename UInt>
FMT_CONSTEXPR auto format_uint(Char* buffer, UInt value, int num_digits,
                               bool upper = false) -> Char* {
  buffer += num_digits;
  Char* end = buffer;
  do {
    const char* digits = upper ? "0123456789ABCDEF" : "0123456789abcdef";
    unsigned digit = (value & ((1 << BASE_BITS) - 1));
    *--buffer = static_cast<Char>(BASE_BITS < 4 ? static_cast<char>('0' + digit)
                                                : digits[digit]);
  } while ((value >>= BASE_BITS) != 0);
  return end;
}

template <unsigned BASE_BITS, typename Char>
auto format_uint(Char* buffer, detail::fallback_uintptr n, int num_digits,
                 bool = false) -> Char* {
  auto char_digits = std::numeric_limits<unsigned char>::digits / 4;
  int start = (num_digits + char_digits - 1) / char_digits - 1;
  if (int start_digits = num_digits % char_digits) {
    unsigned value = n.value[start--];
    buffer = format_uint<BASE_BITS>(buffer, value, start_digits);
  }
  for (; start >= 0; --start) {
    unsigned value = n.value[start];
    buffer += char_digits;
    auto p = buffer;
    for (int i = 0; i < char_digits; ++i) {
      unsigned digit = (value & ((1 << BASE_BITS) - 1));
      *--p = static_cast<Char>("0123456789abcdef"[digit]);
      value >>= BASE_BITS;
    }
  }
  return buffer;
}

template <unsigned BASE_BITS, typename Char, typename It, typename UInt>
inline auto format_uint(It out, UInt value, int num_digits, bool upper = false)
    -> It {
  if (auto ptr = to_pointer<Char>(out, to_unsigned(num_digits))) {
    format_uint<BASE_BITS>(ptr, value, num_digits, upper);
    return out;
  }
  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1).
  char buffer[num_bits<UInt>() / BASE_BITS + 1];
  format_uint<BASE_BITS>(buffer, value, num_digits, upper);
  return detail::copy_str_noinline<Char>(buffer, buffer + num_digits, out);
}

// A converter from UTF-8 to UTF-16.
class utf8_to_utf16 {
 private:
  basic_memory_buffer<wchar_t> buffer_;

 public:
  FMT_API explicit utf8_to_utf16(string_view s);
  operator basic_string_view<wchar_t>() const { return {&buffer_[0], size()}; }
  auto size() const -> size_t { return buffer_.size() - 1; }
  auto c_str() const -> const wchar_t* { return &buffer_[0]; }
  auto str() const -> std::wstring { return {&buffer_[0], size()}; }
};

namespace dragonbox {

// Type-specific information that Dragonbox uses.
template <class T> struct float_info;

template <> struct float_info<float> {
  using carrier_uint = uint32_t;
  static const int significand_bits = 23;
  static const int exponent_bits = 8;
  static const int min_exponent = -126;
  static const int max_exponent = 127;
  static const int exponent_bias = -127;
  static const int decimal_digits = 9;
  static const int kappa = 1;
  static const int big_divisor = 100;
  static const int small_divisor = 10;
  static const int min_k = -31;
  static const int max_k = 46;
  static const int cache_bits = 64;
  static const int divisibility_check_by_5_threshold = 39;
  static const int case_fc_pm_half_lower_threshold = -1;
  static const int case_fc_pm_half_upper_threshold = 6;
  static const int case_fc_lower_threshold = -2;
  static const int case_fc_upper_threshold = 6;
  static const int case_shorter_interval_left_endpoint_lower_threshold = 2;
  static const int case_shorter_interval_left_endpoint_upper_threshold = 3;
  static const int shorter_interval_tie_lower_threshold = -35;
  static const int shorter_interval_tie_upper_threshold = -35;
  static const int max_trailing_zeros = 7;
};

template <> struct float_info<double> {
  using carrier_uint = uint64_t;
  static const int significand_bits = 52;
  static const int exponent_bits = 11;
  static const int min_exponent = -1022;
  static const int max_exponent = 1023;
  static const int exponent_bias = -1023;
  static const int decimal_digits = 17;
  static const int kappa = 2;
  static const int big_divisor = 1000;
  static const int small_divisor = 100;
  static const int min_k = -292;
  static const int max_k = 326;
  static const int cache_bits = 128;
  static const int divisibility_check_by_5_threshold = 86;
  static const int case_fc_pm_half_lower_threshold = -2;
  static const int case_fc_pm_half_upper_threshold = 9;
  static const int case_fc_lower_threshold = -4;
  static const int case_fc_upper_threshold = 9;
  static const int case_shorter_interval_left_endpoint_lower_threshold = 2;
  static const int case_shorter_interval_left_endpoint_upper_threshold = 3;
  static const int shorter_interval_tie_lower_threshold = -77;
  static const int shorter_interval_tie_upper_threshold = -77;
  static const int max_trailing_zeros = 16;
};

template <typename T> struct decimal_fp {
  using significand_type = typename float_info<T>::carrier_uint;
  significand_type significand;
  int exponent;
};

template <typename T>
FMT_API auto to_decimal(T x) FMT_NOEXCEPT -> decimal_fp<T>;
}  // namespace dragonbox

template <typename T>
constexpr auto exponent_mask() ->
    typename dragonbox::float_info<T>::carrier_uint {
  using uint = typename dragonbox::float_info<T>::carrier_uint;
  return ((uint(1) << dragonbox::float_info<T>::exponent_bits) - 1)
         << dragonbox::float_info<T>::significand_bits;
}

// Writes the exponent exp in the form "[+-]d{2,3}" to buffer.
template <typename Char, typename It>
FMT_CONSTEXPR auto write_exponent(int exp, It it) -> It {
  FMT_ASSERT(-10000 < exp && exp < 10000, "exponent out of range");
  if (exp < 0) {
    *it++ = static_cast<Char>('-');
    exp = -exp;
  } else {
    *it++ = static_cast<Char>('+');
  }
  if (exp >= 100) {
    const char* top = digits2(to_unsigned(exp / 100));
    if (exp >= 1000) *it++ = static_cast<Char>(top[0]);
    *it++ = static_cast<Char>(top[1]);
    exp %= 100;
  }
  const char* d = digits2(to_unsigned(exp));
  *it++ = static_cast<Char>(d[0]);
  *it++ = static_cast<Char>(d[1]);
  return it;
}

template <typename T>
FMT_HEADER_ONLY_CONSTEXPR20 auto format_float(T value, int precision,
                                              float_specs specs,
                                              buffer<char>& buf) -> int;

// Formats a floating-point number with snprintf.
template <typename T>
auto snprintf_float(T value, int precision, float_specs specs,
                    buffer<char>& buf) -> int;

template <typename T> constexpr auto promote_float(T value) -> T {
  return value;
}
constexpr auto promote_float(float value) -> double {
  return static_cast<double>(value);
}

template <typename OutputIt, typename Char>
FMT_NOINLINE FMT_CONSTEXPR auto fill(OutputIt it, size_t n,
                                     const fill_t<Char>& fill) -> OutputIt {
  auto fill_size = fill.size();
  if (fill_size == 1) return detail::fill_n(it, n, fill[0]);
  auto data = fill.data();
  for (size_t i = 0; i < n; ++i)
    it = copy_str<Char>(data, data + fill_size, it);
  return it;
}

// Writes the output of f, padded according to format specifications in specs.
// size: output size in code units.
// width: output display width in (terminal) column positions.
template <align::type align = align::left, typename OutputIt, typename Char,
          typename F>
FMT_CONSTEXPR auto write_padded(OutputIt out,
                                const basic_format_specs<Char>& specs,
                                size_t size, size_t width, F&& f) -> OutputIt {
  static_assert(align == align::left || align == align::right, "");
  unsigned spec_width = to_unsigned(specs.width);
  size_t padding = spec_width > width ? spec_width - width : 0;
  // Shifts are encoded as string literals because static constexpr is not
  // supported in constexpr functions.
  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  size_t left_padding = padding >> shifts[specs.align];
  size_t right_padding = padding - left_padding;
  auto it = reserve(out, size + padding * specs.fill.size());
  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  it = f(it);
  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  return base_iterator(out, it);
}

template <align::type align = align::left, typename OutputIt, typename Char,
          typename F>
constexpr auto write_padded(OutputIt out, const basic_format_specs<Char>& specs,
                            size_t size, F&& f) -> OutputIt {
  return write_padded<align>(out, specs, size, size, f);
}

template <align::type align = align::left, typename Char, typename OutputIt>
FMT_CONSTEXPR auto write_bytes(OutputIt out, string_view bytes,
                               const basic_format_specs<Char>& specs)
    -> OutputIt {
  return write_padded<align>(
      out, specs, bytes.size(), [bytes](reserve_iterator<OutputIt> it) {
        const char* data = bytes.data();
        return copy_str<Char>(data, data + bytes.size(), it);
      });
}

template <typename Char, typename OutputIt, typename UIntPtr>
auto write_ptr(OutputIt out, UIntPtr value,
               const basic_format_specs<Char>* specs) -> OutputIt {
  int num_digits = count_digits<4>(value);
  auto size = to_unsigned(num_digits) + size_t(2);
  auto write = [=](reserve_iterator<OutputIt> it) {
    *it++ = static_cast<Char>('0');
    *it++ = static_cast<Char>('x');
    return format_uint<4, Char>(it, value, num_digits);
  };
  return specs ? write_padded<align::right>(out, *specs, size, write)
               : base_iterator(out, write(reserve(out, size)));
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write_char(OutputIt out, Char value,
                              const basic_format_specs<Char>& specs)
    -> OutputIt {
  return write_padded(out, specs, 1, [=](reserve_iterator<OutputIt> it) {
    *it++ = value;
    return it;
  });
}
template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out, Char value,
                         const basic_format_specs<Char>& specs,
                         locale_ref loc = {}) -> OutputIt {
  return check_char_specs(specs)
             ? write_char(out, value, specs)
             : write(out, static_cast<int>(value), specs, loc);
}

// Data for write_int that doesn't depend on output iterator type. It is used to
// avoid template code bloat.
template <typename Char> struct write_int_data {
  size_t size;
  size_t padding;

  FMT_CONSTEXPR write_int_data(int num_digits, unsigned prefix,
                               const basic_format_specs<Char>& specs)
      : size((prefix >> 24) + to_unsigned(num_digits)), padding(0) {
    if (specs.align == align::numeric) {
      auto width = to_unsigned(specs.width);
      if (width > size) {
        padding = width - size;
        size = width;
      }
    } else if (specs.precision > num_digits) {
      size = (prefix >> 24) + to_unsigned(specs.precision);
      padding = to_unsigned(specs.precision - num_digits);
    }
  }
};

// Writes an integer in the format
//   <left-padding><prefix><numeric-padding><digits><right-padding>
// where <digits> are written by write_digits(it).
// prefix contains chars in three lower bytes and the size in the fourth byte.
template <typename OutputIt, typename Char, typename W>
FMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, int num_digits,
                                        unsigned prefix,
                                        const basic_format_specs<Char>& specs,
                                        W write_digits) -> OutputIt {
  // Slightly faster check for specs.width == 0 && specs.precision == -1.
  if ((specs.width | (specs.precision + 1)) == 0) {
    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
    if (prefix != 0) {
      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
        *it++ = static_cast<Char>(p & 0xff);
    }
    return base_iterator(out, write_digits(it));
  }
  auto data = write_int_data<Char>(num_digits, prefix, specs);
  return write_padded<align::right>(
      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
          *it++ = static_cast<Char>(p & 0xff);
        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
        return write_digits(it);
      });
}

template <typename Char> class digit_grouping {
 private:
  thousands_sep_result<Char> sep_;

  struct next_state {
    std::string::const_iterator group;
    int pos;
  };
  next_state initial_state() const { return {sep_.grouping.begin(), 0}; }

  // Returns the next digit group separator position.
  int next(next_state& state) const {
    if (!sep_.thousands_sep) return max_value<int>();
    if (state.group == sep_.grouping.end())
      return state.pos += sep_.grouping.back();
    if (*state.group <= 0 || *state.group == max_value<char>())
      return max_value<int>();
    state.pos += *state.group++;
    return state.pos;
  }

 public:
  explicit digit_grouping(locale_ref loc, bool localized = true) {
    if (localized)
      sep_ = thousands_sep<Char>(loc);
    else
      sep_.thousands_sep = Char();
  }
  explicit digit_grouping(thousands_sep_result<Char> sep) : sep_(sep) {}

  Char separator() const { return sep_.thousands_sep; }

  int count_separators(int num_digits) const {
    int count = 0;
    auto state = initial_state();
    while (num_digits > next(state)) ++count;
    return count;
  }

  // Applies grouping to digits and write the output to out.
  template <typename Out, typename C>
  Out apply(Out out, basic_string_view<C> digits) const {
    auto num_digits = static_cast<int>(digits.size());
    auto separators = basic_memory_buffer<int>();
    separators.push_back(0);
    auto state = initial_state();
    while (int i = next(state)) {
      if (i >= num_digits) break;
      separators.push_back(i);
    }
    for (int i = 0, sep_index = static_cast<int>(separators.size() - 1);
         i < num_digits; ++i) {
      if (num_digits - i == separators[sep_index]) {
        *out++ = separator();
        --sep_index;
      }
      *out++ = static_cast<Char>(digits[to_unsigned(i)]);
    }
    return out;
  }
};

template <typename OutputIt, typename UInt, typename Char>
auto write_int_localized(OutputIt out, UInt value, unsigned prefix,
                         const basic_format_specs<Char>& specs,
                         const digit_grouping<Char>& grouping) -> OutputIt {
  static_assert(std::is_same<uint64_or_128_t<UInt>, UInt>::value, "");
  int num_digits = count_digits(value);
  char digits[40];
  format_decimal(digits, value, num_digits);
  unsigned size = to_unsigned((prefix != 0 ? 1 : 0) + num_digits +
                              grouping.count_separators(num_digits));
  return write_padded<align::right>(
      out, specs, size, size, [&](reserve_iterator<OutputIt> it) {
        if (prefix != 0) *it++ = static_cast<Char>(prefix);
        return grouping.apply(it, string_view(digits, to_unsigned(num_digits)));
      });
}

template <typename OutputIt, typename UInt, typename Char>
auto write_int_localized(OutputIt& out, UInt value, unsigned prefix,
                         const basic_format_specs<Char>& specs, locale_ref loc)
    -> bool {
  auto grouping = digit_grouping<Char>(loc);
  out = write_int_localized(out, value, prefix, specs, grouping);
  return true;
}

FMT_CONSTEXPR inline void prefix_append(unsigned& prefix, unsigned value) {
  prefix |= prefix != 0 ? value << 8 : value;
  prefix += (1u + (value > 0xff ? 1 : 0)) << 24;
}

template <typename UInt> struct write_int_arg {
  UInt abs_value;
  unsigned prefix;
};

template <typename T>
FMT_CONSTEXPR auto make_write_int_arg(T value, sign_t sign)
    -> write_int_arg<uint32_or_64_or_128_t<T>> {
  auto prefix = 0u;
  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
  if (is_negative(value)) {
    prefix = 0x01000000 | '-';
    abs_value = 0 - abs_value;
  } else {
    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
                                            0x1000000u | ' '};
    prefix = prefixes[sign];
  }
  return {abs_value, prefix};
}

template <typename Char, typename OutputIt, typename T>
FMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, write_int_arg<T> arg,
                                        const basic_format_specs<Char>& specs,
                                        locale_ref loc) -> OutputIt {
  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
  auto abs_value = arg.abs_value;
  auto prefix = arg.prefix;
  switch (specs.type) {
  case presentation_type::none:
  case presentation_type::dec: {
    if (specs.localized &&
        write_int_localized(out, static_cast<uint64_or_128_t<T>>(abs_value),
                            prefix, specs, loc)) {
      return out;
    }
    auto num_digits = count_digits(abs_value);
    return write_int(
        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
          return format_decimal<Char>(it, abs_value, num_digits).end;
        });
  }
  case presentation_type::hex_lower:
  case presentation_type::hex_upper: {
    bool upper = specs.type == presentation_type::hex_upper;
    if (specs.alt)
      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
    int num_digits = count_digits<4>(abs_value);
    return write_int(
        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
          return format_uint<4, Char>(it, abs_value, num_digits, upper);
        });
  }
  case presentation_type::bin_lower:
  case presentation_type::bin_upper: {
    bool upper = specs.type == presentation_type::bin_upper;
    if (specs.alt)
      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
    int num_digits = count_digits<1>(abs_value);
    return write_int(out, num_digits, prefix, specs,
                     [=](reserve_iterator<OutputIt> it) {
                       return format_uint<1, Char>(it, abs_value, num_digits);
                     });
  }
  case presentation_type::oct: {
    int num_digits = count_digits<3>(abs_value);
    // Octal prefix '0' is counted as a digit, so only add it if precision
    // is not greater than the number of digits.
    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
      prefix_append(prefix, '0');
    return write_int(out, num_digits, prefix, specs,
                     [=](reserve_iterator<OutputIt> it) {
                       return format_uint<3, Char>(it, abs_value, num_digits);
                     });
  }
  case presentation_type::chr:
    return write_char(out, static_cast<Char>(abs_value), specs);
  default:
    throw_format_error("invalid type specifier");
  }
  return out;
}
template <typename Char, typename OutputIt, typename T>
FMT_CONSTEXPR FMT_NOINLINE auto write_int_noinline(
    OutputIt out, write_int_arg<T> arg, const basic_format_specs<Char>& specs,
    locale_ref loc) -> OutputIt {
  return write_int(out, arg, specs, loc);
}
template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(is_integral<T>::value &&
                        !std::is_same<T, bool>::value &&
                        std::is_same<OutputIt, buffer_appender<Char>>::value)>
FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
                                    const basic_format_specs<Char>& specs,
                                    locale_ref loc) -> OutputIt {
  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
                            loc);
}
// An inlined version of write used in format string compilation.
template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(is_integral<T>::value &&
                        !std::is_same<T, bool>::value &&
                        !std::is_same<OutputIt, buffer_appender<Char>>::value)>
FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
                                    const basic_format_specs<Char>& specs,
                                    locale_ref loc) -> OutputIt {
  return write_int(out, make_write_int_arg(value, specs.sign), specs, loc);
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> s,
                         const basic_format_specs<Char>& specs) -> OutputIt {
  auto data = s.data();
  auto size = s.size();
  if (specs.precision >= 0 && to_unsigned(specs.precision) < size)
    size = code_point_index(s, to_unsigned(specs.precision));
  auto width =
      specs.width != 0 ? compute_width(basic_string_view<Char>(data, size)) : 0;
  return write_padded(out, specs, size, width,
                      [=](reserve_iterator<OutputIt> it) {
                        return copy_str<Char>(data, data + size, it);
                      });
}
template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out,
                         basic_string_view<type_identity_t<Char>> s,
                         const basic_format_specs<Char>& specs, locale_ref)
    -> OutputIt {
  check_string_type_spec(specs.type);
  return write(out, s, specs);
}
template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out, const Char* s,
                         const basic_format_specs<Char>& specs, locale_ref)
    -> OutputIt {
  return check_cstring_type_spec(specs.type)
             ? write(out, basic_string_view<Char>(s), specs, {})
             : write_ptr<Char>(out, to_uintptr(s), &specs);
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR20 auto write_nonfinite(OutputIt out, bool isinf,
                                     basic_format_specs<Char> specs,
                                     const float_specs& fspecs) -> OutputIt {
  auto str =
      isinf ? (fspecs.upper ? "INF" : "inf") : (fspecs.upper ? "NAN" : "nan");
  constexpr size_t str_size = 3;
  auto sign = fspecs.sign;
  auto size = str_size + (sign ? 1 : 0);
  // Replace '0'-padding with space for non-finite values.
  const bool is_zero_fill =
      specs.fill.size() == 1 && *specs.fill.data() == static_cast<Char>('0');
  if (is_zero_fill) specs.fill[0] = static_cast<Char>(' ');
  return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {
    if (sign) *it++ = detail::sign<Char>(sign);
    return copy_str<Char>(str, str + str_size, it);
  });
}

// A decimal floating-point number significand * pow(10, exp).
struct big_decimal_fp {
  const char* significand;
  int significand_size;
  int exponent;
};

constexpr auto get_significand_size(const big_decimal_fp& fp) -> int {
  return fp.significand_size;
}
template <typename T>
inline auto get_significand_size(const dragonbox::decimal_fp<T>& fp) -> int {
  return count_digits(fp.significand);
}

template <typename Char, typename OutputIt>
constexpr auto write_significand(OutputIt out, const char* significand,
                                 int significand_size) -> OutputIt {
  return copy_str<Char>(significand, significand + significand_size, out);
}
template <typename Char, typename OutputIt, typename UInt>
inline auto write_significand(OutputIt out, UInt significand,
                              int significand_size) -> OutputIt {
  return format_decimal<Char>(out, significand, significand_size).end;
}
template <typename Char, typename OutputIt, typename T, typename Grouping>
FMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,
                                       int significand_size, int exponent,
                                       const Grouping& grouping) -> OutputIt {
  if (!grouping.separator()) {
    out = write_significand<Char>(out, significand, significand_size);
    return detail::fill_n(out, exponent, static_cast<Char>('0'));
  }
  auto buffer = memory_buffer();
  write_significand<char>(appender(buffer), significand, significand_size);
  detail::fill_n(appender(buffer), exponent, '0');
  return grouping.apply(out, string_view(buffer.data(), buffer.size()));
}

template <typename Char, typename UInt,
          FMT_ENABLE_IF(std::is_integral<UInt>::value)>
inline auto write_significand(Char* out, UInt significand, int significand_size,
                              int integral_size, Char decimal_point) -> Char* {
  if (!decimal_point)
    return format_decimal(out, significand, significand_size).end;
  out += significand_size + 1;
  Char* end = out;
  int floating_size = significand_size - integral_size;
  for (int i = floating_size / 2; i > 0; --i) {
    out -= 2;
    copy2(out, digits2(significand % 100));
    significand /= 100;
  }
  if (floating_size % 2 != 0) {
    *--out = static_cast<Char>('0' + significand % 10);
    significand /= 10;
  }
  *--out = decimal_point;
  format_decimal(out - integral_size, significand, integral_size);
  return end;
}

template <typename OutputIt, typename UInt, typename Char,
          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<OutputIt>>::value)>
inline auto write_significand(OutputIt out, UInt significand,
                              int significand_size, int integral_size,
                              Char decimal_point) -> OutputIt {
  // Buffer is large enough to hold digits (digits10 + 1) and a decimal point.
  Char buffer[digits10<UInt>() + 2];
  auto end = write_significand(buffer, significand, significand_size,
                               integral_size, decimal_point);
  return detail::copy_str_noinline<Char>(buffer, end, out);
}

template <typename OutputIt, typename Char>
FMT_CONSTEXPR auto write_significand(OutputIt out, const char* significand,
                                     int significand_size, int integral_size,
                                     Char decimal_point) -> OutputIt {
  out = detail::copy_str_noinline<Char>(significand,
                                        significand + integral_size, out);
  if (!decimal_point) return out;
  *out++ = decimal_point;
  return detail::copy_str_noinline<Char>(significand + integral_size,
                                         significand + significand_size, out);
}

template <typename OutputIt, typename Char, typename T, typename Grouping>
FMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,
                                       int significand_size, int integral_size,
                                       Char decimal_point,
                                       const Grouping& grouping) -> OutputIt {
  if (!grouping.separator()) {
    return write_significand(out, significand, significand_size, integral_size,
                             decimal_point);
  }
  auto buffer = basic_memory_buffer<Char>();
  write_significand(buffer_appender<Char>(buffer), significand,
                    significand_size, integral_size, decimal_point);
  grouping.apply(
      out, basic_string_view<Char>(buffer.data(), to_unsigned(integral_size)));
  return detail::copy_str_noinline<Char>(buffer.data() + integral_size,
                                         buffer.end(), out);
}

template <typename OutputIt, typename DecimalFP, typename Char,
          typename Grouping = digit_grouping<Char>>
FMT_CONSTEXPR20 auto do_write_float(OutputIt out, const DecimalFP& fp,
                                    const basic_format_specs<Char>& specs,
                                    float_specs fspecs, locale_ref loc)
    -> OutputIt {
  auto significand = fp.significand;
  int significand_size = get_significand_size(fp);
  constexpr Char zero = static_cast<Char>('0');
  auto sign = fspecs.sign;
  size_t size = to_unsigned(significand_size) + (sign ? 1 : 0);
  using iterator = reserve_iterator<OutputIt>;

  Char decimal_point =
      fspecs.locale ? detail::decimal_point<Char>(loc) : static_cast<Char>('.');

  int output_exp = fp.exponent + significand_size - 1;
  auto use_exp_format = [=]() {
    if (fspecs.format == float_format::exp) return true;
    if (fspecs.format != float_format::general) return false;
    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),
    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.
    const int exp_lower = -4, exp_upper = 16;
    return output_exp < exp_lower ||
           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);
  };
  if (use_exp_format()) {
    int num_zeros = 0;
    if (fspecs.showpoint) {
      num_zeros = fspecs.precision - significand_size;
      if (num_zeros < 0) num_zeros = 0;
      size += to_unsigned(num_zeros);
    } else if (significand_size == 1) {
      decimal_point = Char();
    }
    auto abs_output_exp = output_exp >= 0 ? output_exp : -output_exp;
    int exp_digits = 2;
    if (abs_output_exp >= 100) exp_digits = abs_output_exp >= 1000 ? 4 : 3;

    size += to_unsigned((decimal_point ? 1 : 0) + 2 + exp_digits);
    char exp_char = fspecs.upper ? 'E' : 'e';
    auto write = [=](iterator it) {
      if (sign) *it++ = detail::sign<Char>(sign);
      // Insert a decimal point after the first digit and add an exponent.
      it = write_significand(it, significand, significand_size, 1,
                             decimal_point);
      if (num_zeros > 0) it = detail::fill_n(it, num_zeros, zero);
      *it++ = static_cast<Char>(exp_char);
      return write_exponent<Char>(output_exp, it);
    };
    return specs.width > 0 ? write_padded<align::right>(out, specs, size, write)
                           : base_iterator(out, write(reserve(out, size)));
  }

  int exp = fp.exponent + significand_size;
  if (fp.exponent >= 0) {
    // 1234e5 -> 123400000[.0+]
    size += to_unsigned(fp.exponent);
    int num_zeros = fspecs.precision - exp;
#ifdef FMT_FUZZ
    if (num_zeros > 5000)
      throw std::runtime_error("fuzz mode - avoiding excessive cpu use");
#endif
    if (fspecs.showpoint) {
      if (num_zeros <= 0 && fspecs.format != float_format::fixed) num_zeros = 1;
      if (num_zeros > 0) size += to_unsigned(num_zeros) + 1;
    }
    auto grouping = Grouping(loc, fspecs.locale);
    size += to_unsigned(grouping.count_separators(significand_size));
    return write_padded<align::right>(out, specs, size, [&](iterator it) {
      if (sign) *it++ = detail::sign<Char>(sign);
      it = write_significand<Char>(it, significand, significand_size,
                                   fp.exponent, grouping);
      if (!fspecs.showpoint) return it;
      *it++ = decimal_point;
      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
    });
  } else if (exp > 0) {
    // 1234e-2 -> 12.34[0+]
    int num_zeros = fspecs.showpoint ? fspecs.precision - significand_size : 0;
    size += 1 + to_unsigned(num_zeros > 0 ? num_zeros : 0);
    auto grouping = Grouping(loc, fspecs.locale);
    size += to_unsigned(grouping.count_separators(significand_size));
    return write_padded<align::right>(out, specs, size, [&](iterator it) {
      if (sign) *it++ = detail::sign<Char>(sign);
      it = write_significand(it, significand, significand_size, exp,
                             decimal_point, grouping);
      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
    });
  }
  // 1234e-6 -> 0.001234
  int num_zeros = -exp;
  if (significand_size == 0 && fspecs.precision >= 0 &&
      fspecs.precision < num_zeros) {
    num_zeros = fspecs.precision;
  }
  bool pointy = num_zeros != 0 || significand_size != 0 || fspecs.showpoint;
  size += 1 + (pointy ? 1 : 0) + to_unsigned(num_zeros);
  return write_padded<align::right>(out, specs, size, [&](iterator it) {
    if (sign) *it++ = detail::sign<Char>(sign);
    *it++ = zero;
    if (!pointy) return it;
    *it++ = decimal_point;
    it = detail::fill_n(it, num_zeros, zero);
    return write_significand<Char>(it, significand, significand_size);
  });
}

template <typename Char> class fallback_digit_grouping {
 public:
  constexpr fallback_digit_grouping(locale_ref, bool) {}

  constexpr Char separator() const { return Char(); }

  constexpr int count_separators(int) const { return 0; }

  template <typename Out, typename C>
  constexpr Out apply(Out out, basic_string_view<C>) const {
    return out;
  }
};

template <typename OutputIt, typename DecimalFP, typename Char>
FMT_CONSTEXPR20 auto write_float(OutputIt out, const DecimalFP& fp,
                                 const basic_format_specs<Char>& specs,
                                 float_specs fspecs, locale_ref loc)
    -> OutputIt {
  if (is_constant_evaluated()) {
    return do_write_float<OutputIt, DecimalFP, Char,
                          fallback_digit_grouping<Char>>(out, fp, specs, fspecs,
                                                         loc);
  } else {
    return do_write_float(out, fp, specs, fspecs, loc);
  }
}

template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
FMT_CONSTEXPR20 bool isinf(T value) {
  if (is_constant_evaluated()) {
#if defined(__cpp_if_constexpr)
    if constexpr (std::numeric_limits<double>::is_iec559) {
      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));
      constexpr auto significand_bits =
          dragonbox::float_info<double>::significand_bits;
      return (bits & exponent_mask<double>()) &&
             !(bits & ((uint64_t(1) << significand_bits) - 1));
    }
#endif
  }
  return std::isinf(value);
}

template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
FMT_CONSTEXPR20 bool isfinite(T value) {
  if (is_constant_evaluated()) {
#if defined(__cpp_if_constexpr)
    if constexpr (std::numeric_limits<double>::is_iec559) {
      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));
      return (bits & exponent_mask<double>()) != exponent_mask<double>();
    }
#endif
  }
  return std::isfinite(value);
}

template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
FMT_INLINE FMT_CONSTEXPR bool signbit(T value) {
  if (is_constant_evaluated()) {
#ifdef __cpp_if_constexpr
    if constexpr (std::numeric_limits<double>::is_iec559) {
      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));
      return (bits & (uint64_t(1) << (num_bits<uint64_t>() - 1))) != 0;
    }
#endif
  }
  return std::signbit(value);
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(std::is_floating_point<T>::value)>
FMT_CONSTEXPR20 auto write(OutputIt out, T value,
                           basic_format_specs<Char> specs, locale_ref loc = {})
    -> OutputIt {
  if (const_check(!is_supported_floating_point(value))) return out;
  float_specs fspecs = parse_float_type_spec(specs);
  fspecs.sign = specs.sign;
  if (detail::signbit(value)) {  // value < 0 is false for NaN so use signbit.
    fspecs.sign = sign::minus;
    value = -value;
  } else if (fspecs.sign == sign::minus) {
    fspecs.sign = sign::none;
  }

  if (!detail::isfinite(value))
    return write_nonfinite(out, detail::isinf(value), specs, fspecs);

  if (specs.align == align::numeric && fspecs.sign) {
    auto it = reserve(out, 1);
    *it++ = detail::sign<Char>(fspecs.sign);
    out = base_iterator(out, it);
    fspecs.sign = sign::none;
    if (specs.width != 0) --specs.width;
  }

  memory_buffer buffer;
  if (fspecs.format == float_format::hex) {
    if (fspecs.sign) buffer.push_back(detail::sign<char>(fspecs.sign));
    snprintf_float(promote_float(value), specs.precision, fspecs, buffer);
    return write_bytes<align::right>(out, {buffer.data(), buffer.size()},
                                     specs);
  }
  int precision = specs.precision >= 0 || specs.type == presentation_type::none
                      ? specs.precision
                      : 6;
  if (fspecs.format == float_format::exp) {
    if (precision == max_value<int>())
      throw_format_error("number is too big");
    else
      ++precision;
  }
  if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;
  if (!is_fast_float<T>()) fspecs.fallback = true;
  int exp = format_float(promote_float(value), precision, fspecs, buffer);
  fspecs.precision = precision;
  auto fp = big_decimal_fp{buffer.data(), static_cast<int>(buffer.size()), exp};
  return write_float(out, fp, specs, fspecs, loc);
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(is_fast_float<T>::value)>
FMT_CONSTEXPR20 auto write(OutputIt out, T value) -> OutputIt {
  if (is_constant_evaluated()) {
    return write(out, value, basic_format_specs<Char>());
  }

  if (const_check(!is_supported_floating_point(value))) return out;

  using floaty = conditional_t<std::is_same<T, long double>::value, double, T>;
  using uint = typename dragonbox::float_info<floaty>::carrier_uint;
  auto bits = bit_cast<uint>(value);

  auto fspecs = float_specs();
  if (detail::signbit(value)) {
    fspecs.sign = sign::minus;
    value = -value;
  }

  constexpr auto specs = basic_format_specs<Char>();
  uint mask = exponent_mask<floaty>();
  if ((bits & mask) == mask)
    return write_nonfinite(out, std::isinf(value), specs, fspecs);

  auto dec = dragonbox::to_decimal(static_cast<floaty>(value));
  return write_float(out, dec, specs, fspecs, {});
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(std::is_floating_point<T>::value &&
                        !is_fast_float<T>::value)>
inline auto write(OutputIt out, T value) -> OutputIt {
  return write(out, value, basic_format_specs<Char>());
}

template <typename Char, typename OutputIt>
auto write(OutputIt out, monostate, basic_format_specs<Char> = {},
           locale_ref = {}) -> OutputIt {
  FMT_ASSERT(false, "");
  return out;
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> value)
    -> OutputIt {
  auto it = reserve(out, value.size());
  it = copy_str_noinline<Char>(value.begin(), value.end(), it);
  return base_iterator(out, it);
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(is_string<T>::value)>
constexpr auto write(OutputIt out, const T& value) -> OutputIt {
  return write<Char>(out, to_string_view(value));
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(is_integral<T>::value &&
                        !std::is_same<T, bool>::value &&
                        !std::is_same<T, Char>::value)>
FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
  bool negative = is_negative(value);
  // Don't do -abs_value since it trips unsigned-integer-overflow sanitizer.
  if (negative) abs_value = ~abs_value + 1;
  int num_digits = count_digits(abs_value);
  auto size = (negative ? 1 : 0) + static_cast<size_t>(num_digits);
  auto it = reserve(out, size);
  if (auto ptr = to_pointer<Char>(it, size)) {
    if (negative) *ptr++ = static_cast<Char>('-');
    format_decimal<Char>(ptr, abs_value, num_digits);
    return out;
  }
  if (negative) *it++ = static_cast<Char>('-');
  it = format_decimal<Char>(it, abs_value, num_digits).end;
  return base_iterator(out, it);
}

// FMT_ENABLE_IF() condition separated to workaround an MSVC bug.
template <
    typename Char, typename OutputIt, typename T,
    bool check =
        std::is_enum<T>::value && !std::is_same<T, Char>::value &&
        mapped_type_constant<T, basic_format_context<OutputIt, Char>>::value !=
            type::custom_type,
    FMT_ENABLE_IF(check)>
FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
  return write<Char>(
      out, static_cast<typename std::underlying_type<T>::type>(value));
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(std::is_same<T, bool>::value)>
FMT_CONSTEXPR auto write(OutputIt out, T value,
                         const basic_format_specs<Char>& specs = {},
                         locale_ref = {}) -> OutputIt {
  return specs.type != presentation_type::none &&
                 specs.type != presentation_type::string
             ? write(out, value ? 1 : 0, specs, {})
             : write_bytes(out, value ? "true" : "false", specs);
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out, Char value) -> OutputIt {
  auto it = reserve(out, 1);
  *it++ = value;
  return base_iterator(out, it);
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR_CHAR_TRAITS auto write(OutputIt out, const Char* value)
    -> OutputIt {
  if (!value) {
    throw_format_error("string pointer is null");
  } else {
    out = write(out, basic_string_view<Char>(value));
  }
  return out;
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(std::is_same<T, void>::value)>
auto write(OutputIt out, const T* value,
           const basic_format_specs<Char>& specs = {}, locale_ref = {})
    -> OutputIt {
  check_pointer_type_spec(specs.type, error_handler());
  return write_ptr<Char>(out, to_uintptr(value), &specs);
}

// A write overload that handles implicit conversions.
template <typename Char, typename OutputIt, typename T,
          typename Context = basic_format_context<OutputIt, Char>>
FMT_CONSTEXPR auto write(OutputIt out, const T& value) -> enable_if_t<
    std::is_class<T>::value && !is_string<T>::value &&
        !std::is_same<T, Char>::value &&
        !std::is_same<const T&,
                      decltype(arg_mapper<Context>().map(value))>::value,
    OutputIt> {
  return write<Char>(out, arg_mapper<Context>().map(value));
}

template <typename Char, typename OutputIt, typename T,
          typename Context = basic_format_context<OutputIt, Char>>
FMT_CONSTEXPR auto write(OutputIt out, const T& value)
    -> enable_if_t<mapped_type_constant<T, Context>::value == type::custom_type,
                   OutputIt> {
  using formatter_type =
      conditional_t<has_formatter<T, Context>::value,
                    typename Context::template formatter_type<T>,
                    fallback_formatter<T, Char>>;
  auto ctx = Context(out, {}, {});
  return formatter_type().format(value, ctx);
}

// An argument visitor that formats the argument and writes it via the output
// iterator. It's a class and not a generic lambda for compatibility with C++11.
template <typename Char> struct default_arg_formatter {
  using iterator = buffer_appender<Char>;
  using context = buffer_context<Char>;

  iterator out;
  basic_format_args<context> args;
  locale_ref loc;

  template <typename T> auto operator()(T value) -> iterator {
    return write<Char>(out, value);
  }
  auto operator()(typename basic_format_arg<context>::handle h) -> iterator {
    basic_format_parse_context<Char> parse_ctx({});
    context format_ctx(out, args, loc);
    h.format(parse_ctx, format_ctx);
    return format_ctx.out();
  }
};

template <typename Char> struct arg_formatter {
  using iterator = buffer_appender<Char>;
  using context = buffer_context<Char>;

  iterator out;
  const basic_format_specs<Char>& specs;
  locale_ref locale;

  template <typename T>
  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
    return detail::write(out, value, specs, locale);
  }
  auto operator()(typename basic_format_arg<context>::handle) -> iterator {
    // User-defined types are handled separately because they require access
    // to the parse context.
    return out;
  }
};

template <typename Char> struct custom_formatter {
  basic_format_parse_context<Char>& parse_ctx;
  buffer_context<Char>& ctx;

  void operator()(
      typename basic_format_arg<buffer_context<Char>>::handle h) const {
    h.format(parse_ctx, ctx);
  }
  template <typename T> void operator()(T) const {}
};

template <typename T>
using is_integer =
    bool_constant<is_integral<T>::value && !std::is_same<T, bool>::value &&
                  !std::is_same<T, char>::value &&
                  !std::is_same<T, wchar_t>::value>;

template <typename ErrorHandler> class width_checker {
 public:
  explicit FMT_CONSTEXPR width_checker(ErrorHandler& eh) : handler_(eh) {}

  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
  FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
    if (is_negative(value)) handler_.on_error("negative width");
    return static_cast<unsigned long long>(value);
  }

  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
  FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
    handler_.on_error("width is not integer");
    return 0;
  }

 private:
  ErrorHandler& handler_;
};

template <typename ErrorHandler> class precision_checker {
 public:
  explicit FMT_CONSTEXPR precision_checker(ErrorHandler& eh) : handler_(eh) {}

  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
  FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
    if (is_negative(value)) handler_.on_error("negative precision");
    return static_cast<unsigned long long>(value);
  }

  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
  FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
    handler_.on_error("precision is not integer");
    return 0;
  }

 private:
  ErrorHandler& handler_;
};

template <template <typename> class Handler, typename FormatArg,
          typename ErrorHandler>
FMT_CONSTEXPR auto get_dynamic_spec(FormatArg arg, ErrorHandler eh) -> int {
  unsigned long long value = visit_format_arg(Handler<ErrorHandler>(eh), arg);
  if (value > to_unsigned(max_value<int>())) eh.on_error("number is too big");
  return static_cast<int>(value);
}

template <typename Context, typename ID>
FMT_CONSTEXPR auto get_arg(Context& ctx, ID id) ->
    typename Context::format_arg {
  auto arg = ctx.arg(id);
  if (!arg) ctx.on_error("argument not found");
  return arg;
}

// The standard format specifier handler with checking.
template <typename Char> class specs_handler : public specs_setter<Char> {
 private:
  basic_format_parse_context<Char>& parse_context_;
  buffer_context<Char>& context_;

  // This is only needed for compatibility with gcc 4.4.
  using format_arg = basic_format_arg<buffer_context<Char>>;

  FMT_CONSTEXPR auto get_arg(auto_id) -> format_arg {
    return detail::get_arg(context_, parse_context_.next_arg_id());
  }

  FMT_CONSTEXPR auto get_arg(int arg_id) -> format_arg {
    parse_context_.check_arg_id(arg_id);
    return detail::get_arg(context_, arg_id);
  }

  FMT_CONSTEXPR auto get_arg(basic_string_view<Char> arg_id) -> format_arg {
    parse_context_.check_arg_id(arg_id);
    return detail::get_arg(context_, arg_id);
  }

 public:
  FMT_CONSTEXPR specs_handler(basic_format_specs<Char>& specs,
                              basic_format_parse_context<Char>& parse_ctx,
                              buffer_context<Char>& ctx)
      : specs_setter<Char>(specs), parse_context_(parse_ctx), context_(ctx) {}

  template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
    this->specs_.width = get_dynamic_spec<width_checker>(
        get_arg(arg_id), context_.error_handler());
  }

  template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
    this->specs_.precision = get_dynamic_spec<precision_checker>(
        get_arg(arg_id), context_.error_handler());
  }

  void on_error(const char* message) { context_.on_error(message); }
};

template <template <typename> class Handler, typename Context>
FMT_CONSTEXPR void handle_dynamic_spec(int& value,
                                       arg_ref<typename Context::char_type> ref,
                                       Context& ctx) {
  switch (ref.kind) {
  case arg_id_kind::none:
    break;
  case arg_id_kind::index:
    value = detail::get_dynamic_spec<Handler>(ctx.arg(ref.val.index),
                                              ctx.error_handler());
    break;
  case arg_id_kind::name:
    value = detail::get_dynamic_spec<Handler>(ctx.arg(ref.val.name),
                                              ctx.error_handler());
    break;
  }
}

#define FMT_STRING_IMPL(s, base, explicit)                                 \
  [] {                                                                     \
    /* Use the hidden visibility as a workaround for a GCC bug (#1973). */ \
    /* Use a macro-like name to avoid shadowing warnings. */               \
    struct FMT_GCC_VISIBILITY_HIDDEN FMT_COMPILE_STRING : base {           \
      using char_type = fmt::remove_cvref_t<decltype(s[0])>;               \
      FMT_MAYBE_UNUSED FMT_CONSTEXPR explicit                              \
      operator fmt::basic_string_view<char_type>() const {                 \
        return fmt::detail_exported::compile_string_to_view<char_type>(s); \
      }                                                                    \
    };                                                                     \
    return FMT_COMPILE_STRING();                                           \
  }()

/**
  \rst
  Constructs a compile-time format string from a string literal *s*.

  **Example**::

    // A compile-time error because 'd' is an invalid specifier for strings.
    std::string s = fmt::format(FMT_STRING("{:d}"), "foo");
  \endrst
 */
#define FMT_STRING(s) FMT_STRING_IMPL(s, fmt::compile_string, )

#if FMT_USE_USER_DEFINED_LITERALS
template <typename Char> struct udl_formatter {
  basic_string_view<Char> str;

  template <typename... T>
  auto operator()(T&&... args) const -> std::basic_string<Char> {
    return vformat(str, fmt::make_args_checked<T...>(str, args...));
  }
};

#  if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
template <typename T, typename Char, size_t N,
          fmt::detail_exported::fixed_string<Char, N> Str>
struct statically_named_arg : view {
  static constexpr auto name = Str.data;

  const T& value;
  statically_named_arg(const T& v) : value(v) {}
};

template <typename T, typename Char, size_t N,
          fmt::detail_exported::fixed_string<Char, N> Str>
struct is_named_arg<statically_named_arg<T, Char, N, Str>> : std::true_type {};

template <typename T, typename Char, size_t N,
          fmt::detail_exported::fixed_string<Char, N> Str>
struct is_statically_named_arg<statically_named_arg<T, Char, N, Str>>
    : std::true_type {};

template <typename Char, size_t N,
          fmt::detail_exported::fixed_string<Char, N> Str>
struct udl_arg {
  template <typename T> auto operator=(T&& value) const {
    return statically_named_arg<T, Char, N, Str>(std::forward<T>(value));
  }
};
#  else
template <typename Char> struct udl_arg {
  const Char* str;

  template <typename T> auto operator=(T&& value) const -> named_arg<Char, T> {
    return {str, std::forward<T>(value)};
  }
};
#  endif
#endif  // FMT_USE_USER_DEFINED_LITERALS

template <typename Locale, typename Char>
auto vformat(const Locale& loc, basic_string_view<Char> format_str,
             basic_format_args<buffer_context<type_identity_t<Char>>> args)
    -> std::basic_string<Char> {
  basic_memory_buffer<Char> buffer;
  detail::vformat_to(buffer, format_str, args, detail::locale_ref(loc));
  return {buffer.data(), buffer.size()};
}

using format_func = void (*)(detail::buffer<char>&, int, const char*);

FMT_API void format_error_code(buffer<char>& out, int error_code,
                               string_view message) FMT_NOEXCEPT;

FMT_API void report_error(format_func func, int error_code,
                          const char* message) FMT_NOEXCEPT;
FMT_END_DETAIL_NAMESPACE

FMT_API auto vsystem_error(int error_code, string_view format_str,
                           format_args args) -> std::system_error;

/**
 \rst
 Constructs :class:`std::system_error` with a message formatted with
 ``fmt::format(fmt, args...)``.
  *error_code* is a system error code as given by ``errno``.

 **Example**::

   // This throws std::system_error with the description
   //   cannot open file 'madeup': No such file or directory
   // or similar (system message may vary).
   const char* filename = "madeup";
   std::FILE* file = std::fopen(filename, "r");
   if (!file)
     throw fmt::system_error(errno, "cannot open file '{}'", filename);
 \endrst
*/
template <typename... T>
auto system_error(int error_code, format_string<T...> fmt, T&&... args)
    -> std::system_error {
  return vsystem_error(error_code, fmt, fmt::make_format_args(args...));
}

/**
  \rst
  Formats an error message for an error returned by an operating system or a
  language runtime, for example a file opening error, and writes it to *out*.
  The format is the same as the one used by ``std::system_error(ec, message)``
  where ``ec`` is ``std::error_code(error_code, std::generic_category()})``.
  It is implementation-defined but normally looks like:

  .. parsed-literal::
     *<message>*: *<system-message>*

  where *<message>* is the passed message and *<system-message>* is the system
  message corresponding to the error code.
  *error_code* is a system error code as given by ``errno``.
  \endrst
 */
FMT_API void format_system_error(detail::buffer<char>& out, int error_code,
                                 const char* message) FMT_NOEXCEPT;

// Reports a system error without throwing an exception.
// Can be used to report errors from destructors.
FMT_API void report_system_error(int error_code,
                                 const char* message) FMT_NOEXCEPT;

/** Fast integer formatter. */
class format_int {
 private:
  // Buffer should be large enough to hold all digits (digits10 + 1),
  // a sign and a null character.
  enum { buffer_size = std::numeric_limits<unsigned long long>::digits10 + 3 };
  mutable char buffer_[buffer_size];
  char* str_;

  template <typename UInt> auto format_unsigned(UInt value) -> char* {
    auto n = static_cast<detail::uint32_or_64_or_128_t<UInt>>(value);
    return detail::format_decimal(buffer_, n, buffer_size - 1).begin;
  }

  template <typename Int> auto format_signed(Int value) -> char* {
    auto abs_value = static_cast<detail::uint32_or_64_or_128_t<Int>>(value);
    bool negative = value < 0;
    if (negative) abs_value = 0 - abs_value;
    auto begin = format_unsigned(abs_value);
    if (negative) *--begin = '-';
    return begin;
  }

 public:
  explicit format_int(int value) : str_(format_signed(value)) {}
  explicit format_int(long value) : str_(format_signed(value)) {}
  explicit format_int(long long value) : str_(format_signed(value)) {}
  explicit format_int(unsigned value) : str_(format_unsigned(value)) {}
  explicit format_int(unsigned long value) : str_(format_unsigned(value)) {}
  explicit format_int(unsigned long long value)
      : str_(format_unsigned(value)) {}

  /** Returns the number of characters written to the output buffer. */
  auto size() const -> size_t {
    return detail::to_unsigned(buffer_ - str_ + buffer_size - 1);
  }

  /**
    Returns a pointer to the output buffer content. No terminating null
    character is appended.
   */
  auto data() const -> const char* { return str_; }

  /**
    Returns a pointer to the output buffer content with terminating null
    character appended.
   */
  auto c_str() const -> const char* {
    buffer_[buffer_size - 1] = '\0';
    return str_;
  }

  /**
    \rst
    Returns the content of the output buffer as an ``std::string``.
    \endrst
   */
  auto str() const -> std::string { return std::string(str_, size()); }
};

template <typename T, typename Char>
template <typename FormatContext>
FMT_CONSTEXPR FMT_INLINE auto
formatter<T, Char,
          enable_if_t<detail::type_constant<T, Char>::value !=
                      detail::type::custom_type>>::format(const T& val,
                                                          FormatContext& ctx)
    const -> decltype(ctx.out()) {
  if (specs_.width_ref.kind != detail::arg_id_kind::none ||
      specs_.precision_ref.kind != detail::arg_id_kind::none) {
    auto specs = specs_;
    detail::handle_dynamic_spec<detail::width_checker>(specs.width,
                                                       specs.width_ref, ctx);
    detail::handle_dynamic_spec<detail::precision_checker>(
        specs.precision, specs.precision_ref, ctx);
    return detail::write<Char>(ctx.out(), val, specs, ctx.locale());
  }
  return detail::write<Char>(ctx.out(), val, specs_, ctx.locale());
}

#define FMT_FORMAT_AS(Type, Base)                                        \
  template <typename Char>                                               \
  struct formatter<Type, Char> : formatter<Base, Char> {                 \
    template <typename FormatContext>                                    \
    auto format(Type const& val, FormatContext& ctx) const               \
        -> decltype(ctx.out()) {                                         \
      return formatter<Base, Char>::format(static_cast<Base>(val), ctx); \
    }                                                                    \
  }

FMT_FORMAT_AS(signed char, int);
FMT_FORMAT_AS(unsigned char, unsigned);
FMT_FORMAT_AS(short, int);
FMT_FORMAT_AS(unsigned short, unsigned);
FMT_FORMAT_AS(long, long long);
FMT_FORMAT_AS(unsigned long, unsigned long long);
FMT_FORMAT_AS(Char*, const Char*);
FMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);
FMT_FORMAT_AS(std::nullptr_t, const void*);
FMT_FORMAT_AS(detail::std_string_view<Char>, basic_string_view<Char>);

template <typename Char>
struct formatter<void*, Char> : formatter<const void*, Char> {
  template <typename FormatContext>
  auto format(void* val, FormatContext& ctx) const -> decltype(ctx.out()) {
    return formatter<const void*, Char>::format(val, ctx);
  }
};

template <typename Char, size_t N>
struct formatter<Char[N], Char> : formatter<basic_string_view<Char>, Char> {
  template <typename FormatContext>
  FMT_CONSTEXPR auto format(const Char* val, FormatContext& ctx) const
      -> decltype(ctx.out()) {
    return formatter<basic_string_view<Char>, Char>::format(val, ctx);
  }
};

// A formatter for types known only at run time such as variant alternatives.
//
// Usage:
//   using variant = std::variant<int, std::string>;
//   template <>
//   struct formatter<variant>: dynamic_formatter<> {
//     auto format(const variant& v, format_context& ctx) {
//       return visit([&](const auto& val) {
//           return dynamic_formatter<>::format(val, ctx);
//       }, v);
//     }
//   };
template <typename Char = char> class dynamic_formatter {
 private:
  detail::dynamic_format_specs<Char> specs_;
  const Char* format_str_;

  struct null_handler : detail::error_handler {
    void on_align(align_t) {}
    void on_sign(sign_t) {}
    void on_hash() {}
  };

  template <typename Context> void handle_specs(Context& ctx) {
    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
                                                       specs_.width_ref, ctx);
    detail::handle_dynamic_spec<detail::precision_checker>(
        specs_.precision, specs_.precision_ref, ctx);
  }

 public:
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    format_str_ = ctx.begin();
    // Checks are deferred to formatting time when the argument type is known.
    detail::dynamic_specs_handler<ParseContext> handler(specs_, ctx);
    return detail::parse_format_specs(ctx.begin(), ctx.end(), handler);
  }

  template <typename T, typename FormatContext>
  auto format(const T& val, FormatContext& ctx) -> decltype(ctx.out()) {
    handle_specs(ctx);
    detail::specs_checker<null_handler> checker(
        null_handler(), detail::mapped_type_constant<T, FormatContext>::value);
    checker.on_align(specs_.align);
    if (specs_.sign != sign::none) checker.on_sign(specs_.sign);
    if (specs_.alt) checker.on_hash();
    if (specs_.precision >= 0) checker.end_precision();
    return detail::write<Char>(ctx.out(), val, specs_, ctx.locale());
  }
};

/**
  \rst
  Converts ``p`` to ``const void*`` for pointer formatting.

  **Example**::

    auto s = fmt::format("{}", fmt::ptr(p));
  \endrst
 */
template <typename T> auto ptr(T p) -> const void* {
  static_assert(std::is_pointer<T>::value, "");
  return detail::bit_cast<const void*>(p);
}
template <typename T> auto ptr(const std::unique_ptr<T>& p) -> const void* {
  return p.get();
}
template <typename T> auto ptr(const std::shared_ptr<T>& p) -> const void* {
  return p.get();
}

class bytes {
 private:
  string_view data_;
  friend struct formatter<bytes>;

 public:
  explicit bytes(string_view data) : data_(data) {}
};

template <> struct formatter<bytes> {
 private:
  detail::dynamic_format_specs<char> specs_;

 public:
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    using handler_type = detail::dynamic_specs_handler<ParseContext>;
    detail::specs_checker<handler_type> handler(handler_type(specs_, ctx),
                                                detail::type::string_type);
    auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);
    detail::check_string_type_spec(specs_.type, ctx.error_handler());
    return it;
  }

  template <typename FormatContext>
  auto format(bytes b, FormatContext& ctx) -> decltype(ctx.out()) {
    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
                                                       specs_.width_ref, ctx);
    detail::handle_dynamic_spec<detail::precision_checker>(
        specs_.precision, specs_.precision_ref, ctx);
    return detail::write_bytes(ctx.out(), b.data_, specs_);
  }
};

// group_digits_view is not derived from view because it copies the argument.
template <typename T> struct group_digits_view { T value; };

/**
  \rst
  Returns a view that formats an integer value using ',' as a locale-independent
  thousands separator.

  **Example**::

    fmt::print("{}", fmt::group_digits(12345));
    // Output: "12,345"
  \endrst
 */
template <typename T> auto group_digits(T value) -> group_digits_view<T> {
  return {value};
}

template <typename T> struct formatter<group_digits_view<T>> : formatter<T> {
 private:
  detail::dynamic_format_specs<char> specs_;

 public:
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    using handler_type = detail::dynamic_specs_handler<ParseContext>;
    detail::specs_checker<handler_type> handler(handler_type(specs_, ctx),
                                                detail::type::int_type);
    auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);
    detail::check_string_type_spec(specs_.type, ctx.error_handler());
    return it;
  }

  template <typename FormatContext>
  auto format(group_digits_view<T> t, FormatContext& ctx)
      -> decltype(ctx.out()) {
    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
                                                       specs_.width_ref, ctx);
    detail::handle_dynamic_spec<detail::precision_checker>(
        specs_.precision, specs_.precision_ref, ctx);
    return detail::write_int_localized(
        ctx.out(), static_cast<detail::uint64_or_128_t<T>>(t.value), 0, specs_,
        detail::digit_grouping<char>({"\3", ','}));
  }
};

template <typename It, typename Sentinel, typename Char = char>
struct join_view : detail::view {
  It begin;
  Sentinel end;
  basic_string_view<Char> sep;

  join_view(It b, Sentinel e, basic_string_view<Char> s)
      : begin(b), end(e), sep(s) {}
};

template <typename It, typename Sentinel, typename Char>
using arg_join FMT_DEPRECATED_ALIAS = join_view<It, Sentinel, Char>;

template <typename It, typename Sentinel, typename Char>
struct formatter<join_view<It, Sentinel, Char>, Char> {
 private:
  using value_type =
#ifdef __cpp_lib_ranges
      std::iter_value_t<It>;
#else
      typename std::iterator_traits<It>::value_type;
#endif
  using context = buffer_context<Char>;
  using mapper = detail::arg_mapper<context>;

  template <typename T, FMT_ENABLE_IF(has_formatter<T, context>::value)>
  static auto map(const T& value) -> const T& {
    return value;
  }
  template <typename T, FMT_ENABLE_IF(!has_formatter<T, context>::value)>
  static auto map(const T& value) -> decltype(mapper().map(value)) {
    return mapper().map(value);
  }

  using formatter_type =
      conditional_t<is_formattable<value_type, Char>::value,
                    formatter<remove_cvref_t<decltype(map(
                                  std::declval<const value_type&>()))>,
                              Char>,
                    detail::fallback_formatter<value_type, Char>>;

  formatter_type value_formatter_;

 public:
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    return value_formatter_.parse(ctx);
  }

  template <typename FormatContext>
  auto format(const join_view<It, Sentinel, Char>& value, FormatContext& ctx)
      -> decltype(ctx.out()) {
    auto it = value.begin;
    auto out = ctx.out();
    if (it != value.end) {
      out = value_formatter_.format(map(*it), ctx);
      ++it;
      while (it != value.end) {
        out = detail::copy_str<Char>(value.sep.begin(), value.sep.end(), out);
        ctx.advance_to(out);
        out = value_formatter_.format(map(*it), ctx);
        ++it;
      }
    }
    return out;
  }
};

/**
  Returns a view that formats the iterator range `[begin, end)` with elements
  separated by `sep`.
 */
template <typename It, typename Sentinel>
auto join(It begin, Sentinel end, string_view sep) -> join_view<It, Sentinel> {
  return {begin, end, sep};
}

/**
  \rst
  Returns a view that formats `range` with elements separated by `sep`.

  **Example**::

    std::vector<int> v = {1, 2, 3};
    fmt::print("{}", fmt::join(v, ", "));
    // Output: "1, 2, 3"

  ``fmt::join`` applies passed format specifiers to the range elements::

    fmt::print("{:02}", fmt::join(v, ", "));
    // Output: "01, 02, 03"
  \endrst
 */
template <typename Range>
auto join(Range&& range, string_view sep)
    -> join_view<detail::iterator_t<Range>, detail::sentinel_t<Range>> {
  return join(std::begin(range), std::end(range), sep);
}

/**
  \rst
  Converts *value* to ``std::string`` using the default format for type *T*.

  **Example**::

    #include <fmt/format.h>

    std::string answer = fmt::to_string(42);
  \endrst
 */
template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
inline auto to_string(const T& value) -> std::string {
  auto result = std::string();
  detail::write<char>(std::back_inserter(result), value);
  return result;
}

template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
inline auto to_string(T value) -> std::string {
  // The buffer should be large enough to store the number including the sign
  // or "false" for bool.
  constexpr int max_size = detail::digits10<T>() + 2;
  char buffer[max_size > 5 ? static_cast<unsigned>(max_size) : 5];
  char* begin = buffer;
  return std::string(begin, detail::write<char>(begin, value));
}

template <typename Char, size_t SIZE>
auto to_string(const basic_memory_buffer<Char, SIZE>& buf)
    -> std::basic_string<Char> {
  auto size = buf.size();
  detail::assume(size < std::basic_string<Char>().max_size());
  return std::basic_string<Char>(buf.data(), size);
}

FMT_BEGIN_DETAIL_NAMESPACE

template <typename Char>
void vformat_to(
    buffer<Char>& buf, basic_string_view<Char> fmt,
    basic_format_args<FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args,
    locale_ref loc) {
  // workaround for msvc bug regarding name-lookup in module
  // link names into function scope
  using detail::arg_formatter;
  using detail::buffer_appender;
  using detail::custom_formatter;
  using detail::default_arg_formatter;
  using detail::get_arg;
  using detail::locale_ref;
  using detail::parse_format_specs;
  using detail::specs_checker;
  using detail::specs_handler;
  using detail::to_unsigned;
  using detail::type;
  using detail::write;
  auto out = buffer_appender<Char>(buf);
  if (fmt.size() == 2 && equal2(fmt.data(), "{}")) {
    auto arg = args.get(0);
    if (!arg) error_handler().on_error("argument not found");
    visit_format_arg(default_arg_formatter<Char>{out, args, loc}, arg);
    return;
  }

  struct format_handler : error_handler {
    basic_format_parse_context<Char> parse_context;
    buffer_context<Char> context;

    format_handler(buffer_appender<Char> out, basic_string_view<Char> str,
                   basic_format_args<buffer_context<Char>> args, locale_ref loc)
        : parse_context(str), context(out, args, loc) {}

    void on_text(const Char* begin, const Char* end) {
      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
      context.advance_to(write<Char>(context.out(), text));
    }

    FMT_CONSTEXPR auto on_arg_id() -> int {
      return parse_context.next_arg_id();
    }
    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
      return parse_context.check_arg_id(id), id;
    }
    FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
      int arg_id = context.arg_id(id);
      if (arg_id < 0) on_error("argument not found");
      return arg_id;
    }

    FMT_INLINE void on_replacement_field(int id, const Char*) {
      auto arg = get_arg(context, id);
      context.advance_to(visit_format_arg(
          default_arg_formatter<Char>{context.out(), context.args(),
                                      context.locale()},
          arg));
    }

    auto on_format_specs(int id, const Char* begin, const Char* end)
        -> const Char* {
      auto arg = get_arg(context, id);
      if (arg.type() == type::custom_type) {
        parse_context.advance_to(parse_context.begin() +
                                 (begin - &*parse_context.begin()));
        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
        return parse_context.begin();
      }
      auto specs = basic_format_specs<Char>();
      specs_checker<specs_handler<Char>> handler(
          specs_handler<Char>(specs, parse_context, context), arg.type());
      begin = parse_format_specs(begin, end, handler);
      if (begin == end || *begin != '}')
        on_error("missing '}' in format string");
      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
      context.advance_to(visit_format_arg(f, arg));
      return begin;
    }
  };
  detail::parse_format_string<false>(fmt, format_handler(out, fmt, args, loc));
}

#ifndef FMT_HEADER_ONLY
extern template FMT_API auto thousands_sep_impl<char>(locale_ref)
    -> thousands_sep_result<char>;
extern template FMT_API auto thousands_sep_impl<wchar_t>(locale_ref)
    -> thousands_sep_result<wchar_t>;
extern template FMT_API auto decimal_point_impl(locale_ref) -> char;
extern template FMT_API auto decimal_point_impl(locale_ref) -> wchar_t;
extern template auto format_float<double>(double value, int precision,
                                          float_specs specs, buffer<char>& buf)
    -> int;
extern template auto format_float<long double>(long double value, int precision,
                                               float_specs specs,
                                               buffer<char>& buf) -> int;
void snprintf_float(float, int, float_specs, buffer<char>&) = delete;
extern template auto snprintf_float<double>(double value, int precision,
                                            float_specs specs,
                                            buffer<char>& buf) -> int;
extern template auto snprintf_float<long double>(long double value,
                                                 int precision,
                                                 float_specs specs,
                                                 buffer<char>& buf) -> int;
#endif  // FMT_HEADER_ONLY

FMT_END_DETAIL_NAMESPACE

#if FMT_USE_USER_DEFINED_LITERALS
inline namespace literals {
/**
  \rst
  User-defined literal equivalent of :func:`fmt::arg`.

  **Example**::

    using namespace fmt::literals;
    fmt::print("Elapsed time: {s:.2f} seconds", "s"_a=1.23);
  \endrst
 */
#  if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
template <detail_exported::fixed_string Str>
constexpr auto operator""_a()
    -> detail::udl_arg<remove_cvref_t<decltype(Str.data[0])>,
                       sizeof(Str.data) / sizeof(decltype(Str.data[0])), Str> {
  return {};
}
#  else
constexpr auto operator"" _a(const char* s, size_t) -> detail::udl_arg<char> {
  return {s};
}
#  endif

/**
  \rst
  User-defined literal equivalent of :func:`fmt::format`.

  **Example**::

    using namespace fmt::literals;
    std::string message = "The answer is {}"_format(42);
  \endrst
 */
constexpr auto operator"" _format(const char* s, size_t n)
    -> detail::udl_formatter<char> {
  return {{s, n}};
}
}  // namespace literals
#endif  // FMT_USE_USER_DEFINED_LITERALS

template <typename Locale, FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
inline auto vformat(const Locale& loc, string_view fmt, format_args args)
    -> std::string {
  return detail::vformat(loc, fmt, args);
}

template <typename Locale, typename... T,
          FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
    -> std::string {
  return vformat(loc, string_view(fmt), fmt::make_format_args(args...));
}

template <typename... T, size_t SIZE, typename Allocator>
FMT_DEPRECATED auto format_to(basic_memory_buffer<char, SIZE, Allocator>& buf,
                              format_string<T...> fmt, T&&... args)
    -> appender {
  detail::vformat_to(buf, string_view(fmt), fmt::make_format_args(args...));
  return appender(buf);
}

template <typename OutputIt, typename Locale,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
                            detail::is_locale<Locale>::value)>
auto vformat_to(OutputIt out, const Locale& loc, string_view fmt,
                format_args args) -> OutputIt {
  using detail::get_buffer;
  auto&& buf = get_buffer<char>(out);
  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));
  return detail::get_iterator(buf);
}

template <typename OutputIt, typename Locale, typename... T,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
                            detail::is_locale<Locale>::value)>
FMT_INLINE auto format_to(OutputIt out, const Locale& loc,
                          format_string<T...> fmt, T&&... args) -> OutputIt {
  return vformat_to(out, loc, fmt, fmt::make_format_args(args...));
}

FMT_MODULE_EXPORT_END
FMT_END_NAMESPACE

#ifdef FMT_DEPRECATED_INCLUDE_XCHAR
#  include "xchar.h"
#endif

#ifdef FMT_HEADER_ONLY
#  define FMT_FUNC inline
#  include "format-inl.h"
#else
#  define FMT_FUNC
#endif

#endif  // FMT_FORMAT_H_

```

`include/hash/hash.h`:

```h
#pragma once
#include <types.h>

constexpr uint64 Prime = 1099511628211;
constexpr uint64 Basis = 14695981039346656037;

template< typename Type >
constexpr uint64 HashCompute(uint64 hash, const Type* const data, uint64 size) {
	const auto element = (uint64)(data[0]);
	return (size == 0) ? hash : HashCompute((hash * Prime) ^ element, data + 1, size - 1);
}

template< typename Type >
constexpr uint64 Hash(const Type* const data, uint64 size){
	return HashCompute(Basis, data, size);
}

#define HASH( Data ) \
	[ & ]() \
	{ \
		constexpr auto hash = Hash( Data, sizeof(Data) - 1 );	\
		return hash; \
	}()
```

`include/types.h`:

```h
typedef signed char int8;
typedef short int16;
typedef int int32;
typedef long long int64;

typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned long uint32;
typedef unsigned long long uint64;
```

`tools/ClassNameParser.cpp`:

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

using namespace std;


std::string extractStructName(const std::string& input) {
    size_t pos = input.find("struct");
    if (pos != std::string::npos) { // "class" found in the input string
        pos += 6; // Move to the character right after "class"

        // Find the next colon or newline character from the position of "class"
        size_t colonPos = input.find(":", pos);
        size_t newlinePos = input.find("\n", pos);
        
        if (colonPos != std::string::npos && newlinePos != std::string::npos) {
            // Return the content between "class" and the next colon
            if (colonPos < newlinePos)
                return input.substr(pos, colonPos - pos);
            // Return the content between "class" and the next newline
            else
                return input.substr(pos, newlinePos - pos);
        }
        else if (colonPos != std::string::npos) {
            // Return the content between "class" and the next colon
            return input.substr(pos, colonPos - pos);
        }
        else if (newlinePos != std::string::npos) {
            // Return the content between "class" and the next newline
            return input.substr(pos, newlinePos - pos);
        }
    }

    // If "class" was not found or no content between "class" and the next colon or newline
    return "";
}

std::string extractClassName(const std::string& input) {
    size_t pos = input.find("class");
    if (pos != std::string::npos) { // "class" found in the input string
        pos += 5; // Move to the character right after "class"

        // Find the next colon or newline character from the position of "class"
        size_t colonPos = input.find(":", pos);
        size_t newlinePos = input.find("\n", pos);
        
        if (colonPos != std::string::npos && newlinePos != std::string::npos) {
            // Return the content between "class" and the next colon
            if (colonPos < newlinePos)
                return input.substr(pos, colonPos - pos);
            // Return the content between "class" and the next newline
            else
                return input.substr(pos, newlinePos - pos);
        }
        else if (colonPos != std::string::npos) {
            // Return the content between "class" and the next colon
            return input.substr(pos, colonPos - pos);
        }
        else if (newlinePos != std::string::npos) {
            // Return the content between "class" and the next newline
            return input.substr(pos, newlinePos - pos);
        }
    }

    // If "class" was not found or no content between "class" and the next colon or newline
    return "";
}

std::string trimWhitespace(const std::string& input) {
    size_t start = 0;
    size_t end = input.length() - 1;

    // Find the first non-space character from the beginning of the string
    while (start <= end && std::isspace(input[start])) {
        start++;
    }

    // Find the last non-space character from the end of the string
    while (end >= start && std::isspace(input[end])) {
        end--;
    }

    // Return the trimmed substring
    return input.substr(start, end - start + 1);
}

vector<string> classnames;

ifstream input("input.h");

ofstream output("result.cpp");


int main(){
	if(!input) return -1;
	string linecontent;
	while(getline(input, linecontent)) {
		if(linecontent.find("template") != string::npos) continue;
		if(linecontent.find("friend") != string::npos) continue;
		if(linecontent.find("//") != string::npos) continue;
		if(linecontent.find("(") != string::npos) continue;
		
		string res = extractClassName(linecontent + "\n"); 
		if(res != "") {
			classnames.push_back(trimWhitespace(res));
			cout << "origin: " << linecontent << endl;
			cout << "res: " << res << endl;
		}
		res = extractStructName(linecontent + "\n");
		if(res != "") {
			classnames.push_back(trimWhitespace(res));
			cout << "origin: " << linecontent << endl;
			cout << "res: " << res << endl;
		}
	}
	output << "std::vector<std::string> RefGraphSolver::BasicTypes = {" << endl;
	for(auto name : classnames) {
		cout << "name: " << name << endl;
		output << "\t\"" << name << "\"," << endl; 
	}
	output << "};";
	return 0;
}


```

`tools/non_utf8_convert_test.cpp`:

```cpp
#include <iostream>
#include <string>
#include <fstream>

std::string replaceNonUTF8Characters(const std::string& input) {
    std::string result;
    for (std::size_t i = 0; i < input.size(); ++i) {
        char ch = input[i];
        if ((ch & 0x80) == 0x00) {
            // Single-byte character (ASCII range)
            result += ch;
        } else if ((ch & 0xE0) == 0xC0) {
            // Two-byte character (UTF-8 encoded Chinese character)
            result += ch;
            result += input[++i];
        } else if ((ch & 0xF0) == 0xE0) {
            // Three-byte character (UTF-8 encoded Chinese character)
            result += ch;
            result += input[++i];
            result += input[++i];
        } else {
            // Not a valid UTF-8 character, replace with byte code
            result += "_x" + std::to_string(static_cast<unsigned char>(ch));
        }
    }
    return result;
}

std::string removeNullCharacters(const std::string& input) {
    std::string result;
    for (char ch : input) {
        if (ch != '\0') {
            result += ch;
        }
    }
    return result;
}

int main() {
    std::ifstream inputFile("bad.h");
    if (!inputFile) {
        std::cerr << "Error opening input file 'bad.h'." << std::endl;
        return 1;
    }

    std::ofstream outputFile("good no null.h");
    if (!outputFile) {
        std::cerr << "Error creating output file 'good.h'." << std::endl;
        return 1;
    }

    std::string line;
    while (std::getline(inputFile, line)) {
    	std::string processedLine = removeNullCharacters(line);
        processedLine = replaceNonUTF8Characters(processedLine);
        outputFile << processedLine << std::endl;
    }
    return 0;
}

```