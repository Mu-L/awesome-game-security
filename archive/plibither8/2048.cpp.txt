Project Path: arc_plibither8_2048.cpp_fqm9a09n

Source Tree:

```txt
arc_plibither8_2048.cpp_fqm9a09n
├── CMakeLists.txt
├── LICENSE
├── README.md
├── archive
│   └── ai.hpp
├── assets
│   └── demo.gif
├── data
├── meson.build
├── setup.cmake
└── src
    ├── 2048.cpp
    ├── game-graphics.cpp
    ├── game-input.cpp
    ├── game-pregamemenu.cpp
    ├── game.cpp
    ├── gameboard-graphics.cpp
    ├── gameboard.cpp
    ├── global.cpp
    ├── headers
    │   ├── 2048.hpp
    │   ├── color.hpp
    │   ├── game-graphics.hpp
    │   ├── game-input.hpp
    │   ├── game-pregamemenu.hpp
    │   ├── game.hpp
    │   ├── gameboard-graphics.hpp
    │   ├── gameboard.hpp
    │   ├── global.hpp
    │   ├── loadresource.hpp
    │   ├── menu-graphics.hpp
    │   ├── menu.hpp
    │   ├── point2d.hpp
    │   ├── saveresource.hpp
    │   ├── scores-graphics.hpp
    │   ├── scores.hpp
    │   ├── statistics-graphics.hpp
    │   ├── statistics.hpp
    │   ├── tile-graphics.hpp
    │   └── tile.hpp
    ├── loadresource.cpp
    ├── menu-graphics.cpp
    ├── menu.cpp
    ├── saveresource.cpp
    ├── scores-graphics.cpp
    ├── scores.cpp
    ├── statistics-graphics.cpp
    ├── statistics.cpp
    ├── tile-graphics.cpp
    └── tile.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.7...3.21)
project(2048 LANGUAGES CXX)
enable_testing()

set(SOURCES src/2048.cpp src/gameboard.cpp src/gameboard-graphics.cpp src/game.cpp src/game-graphics.cpp src/game-input.cpp src/game-pregamemenu.cpp src/global.cpp src/loadresource.cpp src/menu.cpp src/menu-graphics.cpp src/saveresource.cpp src/scores.cpp src/scores-graphics.cpp src/statistics.cpp src/statistics-graphics.cpp src/tile.cpp src/tile-graphics.cpp)

if(CMAKE_CXX_COMPILER_ID STREQUAL GNU)
  add_compile_options(-Wall)
elseif(CMAKE_CXX_COMPILER_ID STREQUAL Clang)
  add_compile_options(-Wall)
elseif(CMAKE_CXX_COMPILER_ID MATCHES "^Intel")
  if(WIN32)
    add_compile_options(/W3)
  else()
    add_compile_options(-w2)
  endif()
elseif(CMAKE_CXX_COMPILER_ID STREQUAL NVHPC)
  add_compile_options(-a)
endif()

add_executable(2048 ${SOURCES})
target_include_directories(2048 PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src/headers/)
target_compile_features(2048 PRIVATE cxx_std_17)

# --- test

find_program(PWSH NAMES pwsh powershell)
if(PWSH)
  add_test(NAME basic COMMAND ${PWSH} -c \"echo 4 | $<TARGET_FILE:2048>\")
elseif(UNIX)
  add_test(NAME basic COMMAND sh -c "echo 4 | $<TARGET_FILE:2048>")
endif()

# --- install

install(TARGETS 2048
  RUNTIME DESTINATION bin)

install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/data
        DESTINATION ${CMAKE_INSTALL_PREFIX})

```

`LICENSE`:

```
Copyright (c) 2018, Mihir Chaturvedi

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`README.md`:

```md
# 2048.cpp

![Actions Status](https://github.com/plibither8/2048.cpp/workflows/ci/badge.svg)
[![Codacy Badge](https://api.codacy.com/project/badge/Grade/b37414d66e7d4146bf72a4a467fdc84d)](https://app.codacy.com/app/plibither8/2048.cpp?utm_source=github.com&utm_medium=referral&utm_content=plibither8/2048.cpp&utm_campaign=Badge_Grade_Dashboard)
[![Language grade: C/C++](https://img.shields.io/lgtm/grade/cpp/g/plibither8/2048.cpp.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/plibither8/2048.cpp/context:cpp)
[![Made with Love in India](https://madewithlove.org.in/badge.svg)](https://madewithlove.org.in/)
[![Run on Repl.it](https://repl.it/badge/github/plibither8/2048.cpp)](https://repl.it/github/plibither8/2048.cpp)

> Terminal version of the game "2048" written in C++.

:tada: Featured on GitHub's [Twitter](https://twitter.com/github/status/1017094930991370240) and [Facebook](https://www.facebook.com/GitHub/videos/1433491453419807/) pages! :tada:

<p align="center">
    <img align="center" alt="2048 in action!" src="assets/demo.gif"></img>
</p>

## Setup

The game and code is made to run natively on the GNU/Linux and MacOS platforms, but cross-platform compatibility for Windows has been added too.

### Requirements

* C++11 compiler (e.g. `g++`, `clang++`, `pgc++`, `icpc`, etc.)
* Virtually any platform including:
  * Linux
  * MacOS
  * Windows (via Cygwin or Windows Subsystem for Linux)
* [CMake](https://cmake.org/) or [Meson](https://mesonbuild.com/)

### Installation

1. Open your terminal in your preferred directory and clone this project:
```sh
git clone https://github.com/plibither8/2048.cpp
```
2. Enter the project directory:
```sh
cd 2048.cpp
```

---

For both CMake and Meson, the default C++ compiler on your system will be used.
If you wish to manually select a C++ compiler, optionally add `CXX=clang++ cmake` or `CXX=clang++ meson` etc.

#### Building with CMake

3. Build the executable and run tests
```sh
ctest -S setup.cmake
```
4. Install the program (optional)
```sh
cmake --install build
```

5. Run the program and play the game! :tada:
```sh
2048    # run `build/2048` if game is not installed
```

<p align="center">
    <b>OR</b>
</p>

#### Building with Meson

3. Generate build configuration
```sh
meson build
```
4. Build the executable and run tests
```sh
meson test -C build
```
5. Install the program (optional)
```sh
meson configure build --prefix=$HOME/.local
meson install -C build
```

6. Run the program and play the game! :tada:
```sh
2048    # run `build/2048` if game is not installed
```

## Contributing

First of all, thank you for contributing :smile:! A few things to note:

* If you have found a bug, or have a feature that you'd like implemented, [raise an issue](https://github.com/plibither8/2048.cpp/issues).

* If you have proposed a pull request, make sure that you run `clang-format` on the source code (both, `.cpp` and `.hpp`) files if you've made changes there.

* In your local repository, run `git update-index --skip-worktree ./data/*.txt` to ensure that changes to the data files are not tracked by git, and thus are not staged.

## Thanks

I deeply appreciate the help of the following people:

* [Michael Hirsch](https://github.com/scivision)
  * cleaned up the code,
  * organised the header files in a better way for a more efficient build,
  * added the AppVeyor CI,
  * added the Meson build system and, fixed CMake and added install feature.
* [Aiman Ismail](https://github.com/pokgak) added support for Vim keybinding.
* [Patrik Huber](https://github.com/patrikhuber) fixed a typo in the Readme.
* [zestze](https://github.com/zestze) changed `cstdlib rand` to C++ random int generator.
* [Pascal J. Bourguignon](https://github.com/informatimago) added support for ANSI arrow keys.
* [Jean-Michaël Celerier](https://github.com/jcelerier) added `CMakeLists.txt` file.
* [comwrg](https://github.com/comwrg) made the duration in the statistics and highscores human-readable, wrapping seconds to minutes and hours.
* [Christian Bundy](https://github.com/christianbundy) replaced the ugly -, + and | with box-drawing characters.
* [Tor E Hagemann](https://github.com/hagemt) fixed issue #10, causing unwanted character `1` to be printed.
* [farazxameer](https://github.com/farazxameer) implemented feature to save a game state and continue from a saved game state, refined game logic.
* [drodil](https://github.com/drodil) implemented checks to ascertain existence of data files, fixed issue #12
* [Aviskar KC](https://github.com/aviskarkc10) added arrow keys to game instructions.
* [Peter Squicciarini](https://github.com/stripedpajamas) fixed readme instructions.
* [Mark Fischer, Jr.](https://github.com/flyingfisch) fixed a typo.
* [Hugo Brandão](https://github.com/jhugobb) completely reorganised the existing project structure and updated the build method to enfore CMake.
* [Alton Alvarez](https://github.com/mathematicalist) fixed a typo.
* [cawvyoct](https://github.com/cawvyoct) made the source code much, much easier to read: removed most magic numbers, replacing them with variables to ease maintenance. Implemented `clang-format`.
* [Cong](https://github.com/cxong) edited the `Game` class constructor.
* [Tien Do](https://github.com/tiendq) added the 'exit' option in the main menu, updated the `CMakeLists.txt` file and made `Color` enum to a scoped enum.
* [ScorrMorr](https://github.com/ScorrMorr) made many methods `const`s.
* [tangmengqiu](https://github.com/tangmengqiu) fixed an error-causing instruction step in the readme.

### Maintainers

* [Mihir Chaturvedi](https://github.com/plibither8)
* [cawvyoct](https://github.com/cawvyoct)

## Notes

`[GameBoard].getTile(2,0)` refers to the 0th tile (or column) in 2nd row as in this case, x = 0 and y = 2. The specific tile is denoted the by '@' symbol in the following gameboard:

> Note: `row` and `column` indexing starts at 0.

```plaintext
┌──────┬──────┬──────┬──────┐
│      │      │      │      │
├──────┼──────┼──────┼──────┤
│      │      │      │      │
├──────┼──────┼──────┼──────┤
│   @  │      │      │      │
├──────┼──────┼──────┼──────┤
│      │      │      │      │
└──────┴──────┴──────┴──────┘
```

## To-Do

- [x] Add start menu [19/04/2018]
- [x] Save highscore / score [21/04/2018]
- [x] Save a game state and play from a saved game state
- [ ] ~~AI~~ *(Abandoned indefinitely)*

---

## License

Copyright (c) Mihir Chaturvedi. All rights reserved.

Licensed under the [MIT](LICENSE) License.

```

`archive/ai.hpp`:

```hpp
#pragma once

#include "global.hpppp"
#include "scores.hpppp"
#include "statistics.hpppp"
#include <chrono>
#include <cstdint>
#include <cstdlib>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <limits>
#include <math.hpp>
#include <string>
#include <vector>

enum Directions { UP, DOWN, RIGHT, LEFT };

class Tile {

public:
  Tile() : value(0), blocked(false) {}
  ull value;
  bool blocked;
  Color::Modifier tileColor(ull);
};

Color::Modifier Tile::tileColor(ull value) {
  std::vector<Color::Modifier> colors{red, yellow, magenta, blue, cyan, yellow,
                                      red, yellow, magenta, blue, green};
  int log = log2(value);
  int index = log < 12 ? log - 1 : 10;

  return colors[index];
}

class Game {

private:
  bool moved;
  bool win;
  bool boardFull;
  bool rexit;
  ull score;
  ull bestScore;
  ull largestTile;
  long long moveCount;
  double duration;
  ull BOARD_SIZE;
  std::vector<std::vector<Tile>> board;

  void initialiseBoardArray();
  bool addTile();
  void collectFreeTiles(std::vector<std::vector<int>> &freeTiles);
  void drawBoard();
  void input(int err = 0);
  bool canMove();
  bool testAdd(int, int, ull);
  void unblockTiles();
  void decideMove(Directions);
  void move(int, int, int, int);
  void statistics();
  void saveStats();
  void saveScore();

public:
  Game()
      : win(false), moved(true), boardFull(false), rexit(false), score(0),
        moveCount(-2), largestTile(2) {}
  void startGame(int err = 0);
};

void Game::initialiseBoardArray() {
  for (int i = 0; i < BOARD_SIZE; i++) {
    std::vector<Tile> bufferArray;
    for (int j = 0; j < BOARD_SIZE; j++) {
      Tile bufferTile;
      bufferArray.push_back(bufferTile);
    }
    board.push_back(bufferArray);
  }
}

bool Game::addTile() {

  std::vector<std::vector<int>> freeTiles;
  collectFreeTiles(freeTiles);

  if (!freeTiles.size()) {
    boardFull = true;
  }

  std::vector<int> randomFreeTile = freeTiles.at(rand() % freeTiles.size());
  int x = randomFreeTile.at(1);
  int y = randomFreeTile.at(0);
  board[y][x].value = rand() % 100 > 89 ? 4 : 2;

  moveCount++;
  moved = true;

  if (rexit) {
    return !rexit;
  }

  return canMove();
}

void Game::collectFreeTiles(std::vector<std::vector<int>> &freeTiles) {

  for (int y = 0; y < BOARD_SIZE; y++) {
    for (int x = 0; x < BOARD_SIZE; x++) {
      if (!board[y][x].value) {
        std::vector<int> newEmpty{y, x};
        freeTiles.push_back(newEmpty);
      }
    }
  }
}

void Game::drawBoard() {

  clearScreen();

  drawAscii();
  std::cout << "  +---------------------------+";
  endl();
  std::cout << "  | " << bold_on << "SCORE:" << bold_off << std::setw(19)
            << score << " |";
  endl();
  if (BOARD_SIZE == 4) {
    std::cout << "  | " << bold_on << "BEST SCORE:" << bold_off << std::setw(14)
              << (bestScore < score ? score : bestScore) << " |";
    endl();
  }
  std::cout << "  | " << bold_on << "MOVES:" << bold_off << std::setw(19)
            << moveCount << " |";
  endl();
  std::cout << "  +---------------------------+";
  endl(2);

  for (int y = 0; y < BOARD_SIZE; y++) {

    std::cout << "  +";
    for (int i = 0; i < BOARD_SIZE; i++) {
      std::cout << "------+";
    }
    endl();
    std::cout << " ";

    for (int x = 0; x < BOARD_SIZE; x++) {

      Tile currentTile = board[y][x];

      std::cout << " | ";
      if (!currentTile.value) {
        std::cout << "    ";
      } else {
        std::cout << currentTile.tileColor(currentTile.value) << bold_on
                  << std::setw(4) << currentTile.value << bold_off << def;
      }
    }

    std::cout << " | ";
    endl();
  }

  std::cout << "  +";
  for (int i = 0; i < BOARD_SIZE; i++) {
    std::cout << "------+";
  }
  endl(3);
}

void Game::input(int err) {

  moved = false;
  char c;

  std::cout << "  W => Up";
  endl();
  std::cout << "  A => Left";
  endl();
  std::cout << "  S => Down";
  endl();
  std::cout << "  D => Right";
  endl(2);
  std::cout << "  Press the keys to start and continue.";
  endl();

  if (err) {
    std::cout << red << "  Invalid input. Please try again." << def;
    endl(2);
  }

  c = getch();

  endl(4);

  switch (toupper(c)) {

  case 'W':
    decideMove(UP);
    break;
  case 'A':
    decideMove(LEFT);
    break;
  case 'S':
    decideMove(DOWN);
    break;
  case 'D':
    decideMove(RIGHT);
    break;
  default:
    drawBoard();
    input(1);
    break;
  }

  unblockTiles();
}

bool Game::canMove() {

  for (int y = 0; y < BOARD_SIZE; y++) {
    for (int x = 0; x < BOARD_SIZE; x++) {
      if (!board[y][x].value) {
        return true;
      }
    }
  }

  for (int y = 0; y < BOARD_SIZE; y++) {
    for (int x = 0; x < BOARD_SIZE; x++) {
      if (testAdd(y + 1, x, board[y][x].value)) {
        return true;
      }
      if (testAdd(y - 1, x, board[y][x].value)) {
        return true;
      }
      if (testAdd(y, x + 1, board[y][x].value)) {
        return true;
      }
      if (testAdd(y, x - 1, board[y][x].value)) {
        return true;
      }
    }
  }

  return false;
}

bool Game::testAdd(int y, int x, ull value) {

  if (y < 0 || y > BOARD_SIZE - 1 || x < 0 || x > BOARD_SIZE - 1) {
    return false;
  }

  return board[y][x].value == value;
}

void Game::unblockTiles() {

  for (int y = 0; y < BOARD_SIZE; y++) {
    for (int x = 0; x < BOARD_SIZE; x++) {
      board[y][x].blocked = false;
    }
  }
}

void Game::decideMove(Directions d) {

  switch (d) {

  case UP:

    for (int x = 0; x < BOARD_SIZE; x++) {
      int y = 1;
      while (y < BOARD_SIZE) {
        if (board[y][x].value) {
          move(y, x, -1, 0);
        }
        y++;
      }
    }
    break;

  case DOWN:

    for (int x = 0; x < BOARD_SIZE; x++) {
      int y = BOARD_SIZE - 2;
      while (y >= 0) {
        if (board[y][x].value) {
          move(y, x, 1, 0);
        }
        y--;
      }
    }
    break;

  case LEFT:

    for (int y = 0; y < BOARD_SIZE; y++) {
      int x = 1;
      while (x < BOARD_SIZE) {
        if (board[y][x].value) {
          move(y, x, 0, -1);
        }
        x++;
      }
    }
    break;

  case RIGHT:

    for (int y = 0; y < BOARD_SIZE; y++) {
      int x = BOARD_SIZE - 2;
      while (x >= 0) {
        if (board[y][x].value) {
          move(y, x, 0, 1);
        }
        x--;
      }
    }
    break;
  }
}

void Game::move(int y, int x, int k, int l) {

  Tile &currentTile = board[y][x];
  Tile &targetTile = board[y + k][x + l];

  int A = currentTile.value;
  int B = targetTile.value;
  int C = currentTile.blocked;
  int D = targetTile.blocked;

  if (B && A == B && !C && !D) {

    currentTile.value = 0;
    targetTile.value *= 2;
    score += targetTile.value;
    targetTile.blocked = true;

    largestTile =
        largestTile < targetTile.value ? targetTile.value : largestTile;
    if (!win) {
      if (targetTile.value == 2048) {
        win = true;
        std::cout << green << bold_on
                  << "  You win! Press any key to continue or 'x' to exit: "
                  << bold_off << def;
        char c;
        std::cin >> c;
        switch (toupper(c)) {
        case 'X':
          rexit = true;
          break;
        default:
          break;
        }
      }
    }

    moved = true;

  }

  else if (A && !B) {

    targetTile.value = currentTile.value;
    currentTile.value = 0;

    moved = true;
  }

  if (k + l == 1 && (k == 1 ? y : x) < BOARD_SIZE - 2) {
    move(y + k, x + l, k, l);
  } else if (k + l == -1 && (k == -1 ? y : x) > 1) {
    move(y + k, x + l, k, l);
  }
}

void Game::statistics() {

  std::cout << yellow << "  STATISTICS" << def;
  endl();
  std::cout << yellow << "  ----------" << def;
  endl();
  std::cout << "  Final score:       " << bold_on << score << bold_off;
  endl();
  std::cout << "  Largest Tile:      " << bold_on << largestTile << bold_off;
  endl();
  std::cout << "  Number of moves:   " << bold_on << moveCount << bold_off;
  endl();
  std::cout << "  Time taken:        " << bold_on << duration << " seconds"
            << bold_off;
  endl();
}

void Game::saveStats() {
  Stats stats;
  stats.collectStatistics();
  stats.bestScore = stats.bestScore < score ? score : stats.bestScore;
  stats.gameCount++;
  stats.winCount = win ? stats.winCount + 1 : stats.winCount;
  stats.totalMoveCount += moveCount;
  stats.totalDuration += duration;

  std::fstream statistics("./data/statistics.txt");
  statistics << stats.bestScore << std::endl
             << stats.gameCount << std::endl
             << stats.winCount << std::endl
             << stats.totalMoveCount << std::endl
             << stats.totalDuration;

  statistics.close();
}

void Game::saveScore() {
  Scoreboard s;
  s.score = score;
  s.win = win;
  s.moveCount = moveCount;
  s.largestTile = largestTile;
  s.duration = duration;
  s.save();
  return;
}

void Game::startGame(int err) {

  Stats stats;
  stats.collectStatistics();
  bestScore = stats.bestScore;

  clearScreen();
  drawAscii();

  if (err) {
    std::cout << red
              << "  Invalid input. Gameboard size should range from 3 to 6."
              << def;
    endl(2);
  }

  std::cout
      << bold_on
      << "  Enter gameboard size (NOTE: Scores and statistics will be saved only for the 4x4 gameboard): "
      << bold_off;

  if (!(std::cin >> BOARD_SIZE) || BOARD_SIZE < 3 || BOARD_SIZE > 10) {
    std::cin.clear();
    std::cin.ignore(std::numeric_limits<std::int32_t>::max(), '\n');
    startGame(1);
  }

  initialiseBoardArray();

  auto startTime = std::chrono::high_resolution_clock::now();

  addTile();

  while (1) {

    if (moved) {
      if (!addTile()) {
        drawBoard();
        break;
      }
    }

    drawBoard();
    input();
  }

  auto finishTime = std::chrono::high_resolution_clock::now();
  std::chrono::duration<double> elapsed = finishTime - startTime;
  duration = elapsed.count();

  std::string msg = win ? "  You win!" : "  Game over! You lose.";

  if (win) {
    std::cout << green << bold_on << msg << def << bold_off;
    endl(3);
  } else {
    std::cout << red << bold_on << msg << def << bold_off;
    endl(3);
  }

  if (BOARD_SIZE == 4) {
    statistics();
    saveStats();
    endl(2);
    saveScore();
  }
}

```

`meson.build`:

```build
project('2048', 'cpp',
  default_options : ['cpp_std=c++14', 'warning_level=2'])

main_target_name = '2048'
sources = ['src/2048.cpp', 'src/gameboard.cpp', 'src/gameboard-graphics.cpp', 'src/game.cpp', 'src/game-input.cpp', 'src/game-graphics.cpp', 'src/game-pregamemenu.cpp', 'src/global.cpp', 'src/loadresource.cpp', 'src/menu.cpp', 'src/menu-graphics.cpp', 'src/saveresource.cpp', 'src/scores.cpp', 'src/scores-graphics.cpp', 'src/statistics.cpp', 'src/statistics-graphics.cpp', 'src/tile.cpp', 'src/tile-graphics.cpp']
hdrs = include_directories('src/headers')

executable(main_target_name, sources,
  include_directories : hdrs,
  install : true)

install_data(['data/scores.txt', 'data/statistics.txt'],
  install_dir : 'data')


```

`setup.cmake`:

```cmake
# run by:
# ctest -S setup.cmake

# --- Project-specific -Doptions
# these will be used if the project isn't already configured.
set(_opts)

# --- boilerplate follows

# CTEST_CMAKE_GENERATOR must always be defined
if(NOT DEFINED CTEST_CMAKE_GENERATOR AND DEFINED ENV{CMAKE_GENERATOR})
  set(CTEST_CMAKE_GENERATOR $ENV{CMAKE_GENERATOR})
endif()
if(NOT DEFINED CTEST_CMAKE_GENERATOR AND CMAKE_VERSION VERSION_GREATER_EQUAL 3.17)
  find_program(_gen NAMES ninja ninja-build samu)
  if(_gen)
    execute_process(COMMAND ${_gen} --version
      OUTPUT_VARIABLE _ninja_version
      OUTPUT_STRIP_TRAILING_WHITESPACE
      RESULT_VARIABLE _gen_ok
      TIMEOUT 10)
    if(_gen_ok EQUAL 0 AND _ninja_version VERSION_GREATER_EQUAL 1.10)
      set(CTEST_CMAKE_GENERATOR "Ninja")
    endif()
  endif(_gen)
endif()
if(NOT DEFINED CTEST_CMAKE_GENERATOR)
  set(CTEST_BUILD_FLAGS -j)  # not --parallel as this goes to generator directly
  if(WIN32)
    set(CTEST_CMAKE_GENERATOR "MinGW Makefiles")
  else()
    set(CTEST_CMAKE_GENERATOR "Unix Makefiles")
  endif()
endif()

if(NOT DEFINED CTEST_BUILD_CONFIGURATION)
  list(APPEND _opts -DCMAKE_BUILD_TYPE=Release)
endif()

set(CTEST_SOURCE_DIRECTORY ${CMAKE_CURRENT_LIST_DIR})
if(NOT DEFINED CTEST_BINARY_DIRECTORY)
  set(CTEST_BINARY_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/build)
endif()

# -- build and test
ctest_start("Experimental")

ctest_configure(
  OPTIONS "${_opts}"
  RETURN_VALUE _ret
  CAPTURE_CMAKE_ERROR _err)
if(NOT (_ret EQUAL 0 AND _err EQUAL 0))
  message(FATAL_ERROR "Configure failed: return ${_ret} cmake return ${_err}")
endif()

ctest_build(
  RETURN_VALUE _ret
  CAPTURE_CMAKE_ERROR _err)
if(NOT (_ret EQUAL 0 AND _err EQUAL 0))
  message(FATAL_ERROR "Build failed.")
endif()

ctest_test(
  RETURN_VALUE _ret
  CAPTURE_CMAKE_ERROR _err)

if(NOT (_ret EQUAL 0 AND _err EQUAL 0))
  message(FATAL_ERROR "Test failed.")
endif()

```

`src/2048.cpp`:

```cpp
#include "2048.hpp"
#include "menu.hpp"

int main() {
  Menu::startMenu();
  return 0;
}

```

`src/game-graphics.cpp`:

```cpp
#include "game-graphics.hpp"
#include "color.hpp"
#include "global.hpp"
#include <array>
#include <iomanip>
#include <sstream>

namespace Game {
namespace Graphics {
std::string AsciiArt2048() {
  constexpr auto title_card_2048 = R"(
   /\\\\\\\\\          /\\\\\\\                /\\\         /\\\\\\\\\
  /\\\///////\\\      /\\\/////\\\            /\\\\\       /\\\///////\\\
  \///      \//\\\    /\\\    \//\\\         /\\\/\\\      \/\\\     \/\\\
             /\\\/    \/\\\     \/\\\       /\\\/\/\\\      \///\\\\\\\\\/
           /\\\//      \/\\\     \/\\\     /\\\/  \/\\\       /\\\///////\\\
         /\\\//         \/\\\     \/\\\   /\\\\\\\\\\\\\\\\   /\\\      \//\\\
        /\\\/            \//\\\    /\\\   \///////////\\\//   \//\\\      /\\\
        /\\\\\\\\\\\\\\\   \///\\\\\\\/              \/\\\      \///\\\\\\\\\/
        \///////////////      \///////                \///         \/////////
  )";
  std::ostringstream title_card_richtext;
  title_card_richtext << green << bold_on << title_card_2048 << bold_off << def;
  title_card_richtext << "\n\n\n";
  return title_card_richtext.str();
}

std::string BoardInputPrompt() {
  const auto board_size_prompt_text = {
      "(NOTE: Scores and statistics will be saved only for the 4x4 gameboard)\n",
      "Enter gameboard size - (Enter '0' to go back): "};
  constexpr auto sp = "  ";
  std::ostringstream board_size_prompt_richtext;
  board_size_prompt_richtext
      << bold_on << sp << std::begin(board_size_prompt_text)[0] << sp
      << std::begin(board_size_prompt_text)[1] << bold_off;
  return board_size_prompt_richtext.str();
}

std::string YouWinPrompt() {
  constexpr auto win_game_text = "You win! Congratulations!";
  constexpr auto sp = "  ";
  std::ostringstream win_richtext;
  win_richtext << green << bold_on << sp << win_game_text << def << bold_off
               << "\n\n\n";
  return win_richtext.str();
}

std::string GameOverPrompt() {
  constexpr auto lose_game_text = "Game over! You lose.";
  constexpr auto sp = "  ";
  std::ostringstream lose_richtext;
  lose_richtext << red << bold_on << sp << lose_game_text << def << bold_off
                << "\n\n\n";
  return lose_richtext.str();
}

std::string EndOfEndlessPrompt() {
  constexpr auto endless_mode_text =
      "End of endless mode! Thank you for playing!";
  constexpr auto sp = "  ";
  std::ostringstream endless_mode_richtext;
  endless_mode_richtext << red << bold_on << sp << endless_mode_text << def
                        << bold_off << "\n\n\n";
  return endless_mode_richtext.str();
}

std::string QuestionEndOfWinningGamePrompt() {
  constexpr auto win_but_what_next =
      "You Won! Continue playing current game? [y/n]";
  constexpr auto sp = "  ";
  std::ostringstream win_richtext;
  win_richtext << green << bold_on << sp << win_but_what_next << def << bold_off
               << ": ";
  return win_richtext.str();
}

std::string GameStateNowSavedPrompt() {
  constexpr auto state_saved_text =
      "The game has been saved. Feel free to take a break.";
  constexpr auto sp = "  ";
  std::ostringstream state_saved_richtext;
  state_saved_richtext << green << bold_on << sp << state_saved_text << def
                       << bold_off << "\n\n";
  return state_saved_richtext.str();
}

std::string GameBoardNoSaveErrorPrompt() {
  constexpr auto no_save_found_text =
      "No saved game found. Starting a new game.";
  constexpr auto sp = "  ";
  std::ostringstream no_save_richtext;
  no_save_richtext << red << bold_on << sp << no_save_found_text << def
                   << bold_off << "\n\n";
  return no_save_richtext.str();
}

std::string InvalidInputGameBoardErrorPrompt() {
  constexpr auto invalid_prompt_text = "Invalid input. Please try again.";
  constexpr auto sp = "  ";
  std::ostringstream invalid_prompt_richtext;
  invalid_prompt_richtext << red << sp << invalid_prompt_text << def << "\n\n";
  return invalid_prompt_richtext.str();
}

std::string BoardSizeErrorPrompt() {
  const auto invalid_prompt_text = {
      "Invalid input. Gameboard size should range from ", " to ", "."};
  //  constexpr auto num_of_invalid_prompt_text = 3;
  constexpr auto sp = "  ";
  std::ostringstream error_prompt_richtext;
  error_prompt_richtext << red << sp << std::begin(invalid_prompt_text)[0]
                        << MIN_GAME_BOARD_PLAY_SIZE
                        << std::begin(invalid_prompt_text)[1]
                        << MAX_GAME_BOARD_PLAY_SIZE
                        << std::begin(invalid_prompt_text)[2] << def << "\n\n";
  return error_prompt_richtext.str();
}

/**
 * @brief Generates a string prompt listing the available input commands.
 * 
 * This function creates a formatted string that lists the available input commands for the game.
 * The commands include movements (Up, Left, Down, Right), saving the game, and returning to the menu.
 * The prompt is formatted with indentation for readability.
 * 
 * 
 * 
 * @return std::string A formatted string containing the list of input commands.
 */
std::string InputCommandListPrompt() {
  constexpr auto sp = "  ";
  const auto input_commands_list_text = {
      "W or K or ↑ => Up", "A or H or ← => Left", "S or J or ↓ => Down",
      "D or L or → => Right", "Z or P => Save", "M => Return to menu"};
  std::ostringstream str_os;
  for (const auto txt : input_commands_list_text) {
    str_os << sp << txt << "\n";
  }
  return str_os.str();
}

std::string EndlessModeCommandListPrompt() {
  constexpr auto sp = "  ";
  const auto endless_mode_list_text = {"X => Quit Endless Mode"};
  std::ostringstream str_os;
  for (const auto txt : endless_mode_list_text) {
    str_os << sp << txt << "\n";
  }
  return str_os.str();
}

std::string InputCommandListFooterPrompt() {
  constexpr auto sp = "  ";
  const auto input_commands_list_footer_text = {
      "", "Press the keys to start and continue.", "\n"};
  std::ostringstream str_os;
  for (const auto txt : input_commands_list_footer_text) {
    str_os << sp << txt << "\n";
  }
  return str_os.str();
}

std::string GameScoreBoardBox(scoreboard_display_data_t scdd) {
  std::ostringstream str_os;
  constexpr auto score_text_label = "SCORE:";
  constexpr auto bestscore_text_label = "BEST SCORE:";
  constexpr auto moves_text_label = "MOVES:";

  // * border padding: vvv
  // | l-outer: 2, r-outer: 0
  // | l-inner: 1, r-inner: 1
  // * top border / bottom border: vvv
  // | tl_corner + horizontal_sep + tr_corner = length: 1 + 27 + 1
  // | bl_corner + horizontal_sep + br_corner = length: 1 + 27 + 1
  enum {
    UI_SCOREBOARD_SIZE = 27,
    UI_BORDER_OUTER_PADDING = 2,
    UI_BORDER_INNER_PADDING = 1
  }; // length of horizontal board - (corners + border padding)
  constexpr auto border_padding_char = ' ';
  constexpr auto vertical_border_pattern = "│";
  constexpr auto top_board =
      "┌───────────────────────────┐"; // Multibyte character set
  constexpr auto bottom_board =
      "└───────────────────────────┘"; // Multibyte character set
  const auto outer_border_padding =
      std::string(UI_BORDER_OUTER_PADDING, border_padding_char);
  const auto inner_border_padding =
      std::string(UI_BORDER_INNER_PADDING, border_padding_char);
  const auto inner_padding_length =
      UI_SCOREBOARD_SIZE - (std::string{inner_border_padding}.length() * 2);

  enum ScoreBoardDisplayDataFields {
    IDX_COMPETITION_MODE,
    IDX_GAMEBOARD_SCORE,
    IDX_BESTSCORE,
    IDX_MOVECOUNT,
    MAX_SCOREBOARDDISPLAYDATA_INDEXES
  };

  const auto competition_mode = std::get<IDX_COMPETITION_MODE>(scdd);
  const auto gameboard_score = std::get<IDX_GAMEBOARD_SCORE>(scdd);
  const auto temp_bestscore = std::get<IDX_BESTSCORE>(scdd);
  const auto movecount = std::get<IDX_MOVECOUNT>(scdd);

  str_os << outer_border_padding << top_board << "\n";
  str_os << outer_border_padding << vertical_border_pattern
         << inner_border_padding << bold_on << score_text_label << bold_off
         << std::string(inner_padding_length -
                            std::string{score_text_label}.length() -
                            gameboard_score.length(),
                        border_padding_char)
         << gameboard_score << inner_border_padding << vertical_border_pattern
         << "\n";
  if (competition_mode) {
    str_os << outer_border_padding << vertical_border_pattern
           << inner_border_padding << bold_on << bestscore_text_label
           << bold_off
           << std::string(inner_padding_length -
                              std::string{bestscore_text_label}.length() -
                              temp_bestscore.length(),
                          border_padding_char)
           << temp_bestscore << inner_border_padding << vertical_border_pattern
           << "\n";
  }
  str_os << outer_border_padding << vertical_border_pattern
         << inner_border_padding << bold_on << moves_text_label << bold_off
         << std::string(inner_padding_length -
                            std::string{moves_text_label}.length() -
                            movecount.length(),
                        border_padding_char)
         << movecount << inner_border_padding << vertical_border_pattern
         << "\n";
  str_os << outer_border_padding << bottom_board << "\n \n";
  return str_os.str();
}

std::string GameScoreBoardOverlay(scoreboard_display_data_t scdd) {
  std::ostringstream str_os;
  DrawAlways(str_os, DataSuppliment(scdd, GameScoreBoardBox));
  return str_os.str();
}

std::string GameEndScreenOverlay(end_screen_display_data_t esdd) {
  enum EndScreenDisplayDataFields {
    IDX_FLAG_WIN,
    IDX_FLAG_ENDLESS_MODE,
    MAX_ENDSCREENDISPLAYDATA_INDEXES
  };
  const auto did_win = std::get<IDX_FLAG_WIN>(esdd);
  const auto is_endless_mode = std::get<IDX_FLAG_ENDLESS_MODE>(esdd);

  std::ostringstream str_os;
  const auto standardWinLosePrompt = [=] {
    std::ostringstream str_os;
    DrawOnlyWhen(str_os, did_win, YouWinPrompt);
    // else..
    DrawOnlyWhen(str_os, !did_win, GameOverPrompt);
    return str_os.str();
  };
  DrawOnlyWhen(str_os, !is_endless_mode, standardWinLosePrompt);
  // else..
  DrawOnlyWhen(str_os, is_endless_mode, EndOfEndlessPrompt);
  return str_os.str();
}

std::string GameInputControlsOverlay(input_controls_display_data_t gamestatus) {
  const auto is_in_endless_mode = std::get<0>(gamestatus);
  const auto is_in_question_mode = std::get<1>(gamestatus);
  std::ostringstream str_os;
  const auto InputControlLists = [=] {
    std::ostringstream str_os;
    DrawAlways(str_os, Graphics::InputCommandListPrompt);
    DrawOnlyWhen(str_os, is_in_endless_mode,
                 Graphics::EndlessModeCommandListPrompt);
    DrawAlways(str_os, Graphics::InputCommandListFooterPrompt);
    return str_os.str();
  };
  // When game is paused to ask a question, hide regular inut prompts..
  DrawOnlyWhen(str_os, !is_in_question_mode, InputControlLists);
  return str_os.str();
}

} // namespace Graphics
} // namespace Game

```

`src/game-input.cpp`:

```cpp
#include "game-input.hpp"
#include "global.hpp"

namespace Game {
namespace Input {
bool check_input_ansi(char c, intendedmove_t &intendedmove) {
  using namespace Keypress::Code;
  if (c == CODE_ANSI_TRIGGER_1) {
    getKeypressDownInput(c);
    if (c == CODE_ANSI_TRIGGER_2) {
      getKeypressDownInput(c);
      switch (c) {
      case CODE_ANSI_UP:
        intendedmove[FLAG_MOVE_UP] = true;
        return false;
      case CODE_ANSI_DOWN:
        intendedmove[FLAG_MOVE_DOWN] = true;
        return false;
      case CODE_ANSI_RIGHT:
        intendedmove[FLAG_MOVE_RIGHT] = true;
        return false;
      case CODE_ANSI_LEFT:
        intendedmove[FLAG_MOVE_LEFT] = true;
        return false;
      }
    }
  }
  return true;
}

bool check_input_vim(char c, intendedmove_t &intendedmove) {
  using namespace Keypress::Code;
  switch (toupper(c)) {
  case CODE_VIM_UP:
    intendedmove[FLAG_MOVE_UP] = true;
    return false;
  case CODE_VIM_LEFT:
    intendedmove[FLAG_MOVE_LEFT] = true;
    return false;
  case CODE_VIM_DOWN:
    intendedmove[FLAG_MOVE_DOWN] = true;
    return false;
  case CODE_VIM_RIGHT:
    intendedmove[FLAG_MOVE_RIGHT] = true;
    return false;
  }
  return true;
}

bool check_input_wasd(char c, intendedmove_t &intendedmove) {
  using namespace Keypress::Code;
  switch (toupper(c)) {
  case CODE_WASD_UP:
    intendedmove[FLAG_MOVE_UP] = true;
    return false;
  case CODE_WASD_LEFT:
    intendedmove[FLAG_MOVE_LEFT] = true;
    return false;
  case CODE_WASD_DOWN:
    intendedmove[FLAG_MOVE_DOWN] = true;
    return false;
  case CODE_WASD_RIGHT:
    intendedmove[FLAG_MOVE_RIGHT] = true;
    return false;
  }
  return true;
}
} // namespace Input
} // namespace Game

```

`src/game-pregamemenu.cpp`:

```cpp
#include "game-pregamemenu.hpp"
#include "game-graphics.hpp"
#include "game-input.hpp"
#include "game.hpp"
#include "gameboard.hpp"
#include "global.hpp"
#include "loadresource.hpp"
#include "menu.hpp"
#include <array>
#include <iostream>
#include <limits>
#include <sstream>

namespace Game {

namespace PreGameSetup {

namespace {

enum PreGameSetupStatusFlag {
  FLAG_NULL,
  FLAG_START_GAME,
  FLAG_RETURN_TO_MAIN_MENU,
  MAX_NO_PREGAME_SETUP_STATUS_FLAGS
};

using pregamesetup_status_t =
    std::array<bool, MAX_NO_PREGAME_SETUP_STATUS_FLAGS>;

pregamesetup_status_t pregamesetup_status{};

ull stored_game_size{1};
bool FlagInputErrornousChoice{};
bool noSave{};

void process_PreGameMenu() {
  if (pregamesetup_status[FLAG_START_GAME]) {
    playGame(PlayGameFlag::BrandNewGame, GameBoard{stored_game_size},
             stored_game_size);
  }
  if (pregamesetup_status[FLAG_RETURN_TO_MAIN_MENU]) {
    Menu::startMenu();
  }
}

int Receive_Input_Playsize(std::istream &is) {
  int userInput_PlaySize{};
  if (!(is >> userInput_PlaySize)) {
    constexpr auto INVALID_INPUT_VALUE_FLAG = -1;
    userInput_PlaySize = INVALID_INPUT_VALUE_FLAG;
    is.clear();
    is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
  }
  return userInput_PlaySize;
}

void receive_input_flags(std::istream &is) {
  using namespace Input::Keypress::Code;

  // Reset ErrornousChoice flag...
  FlagInputErrornousChoice = bool{};

  // If not number, emits -1.
  // it should emit bool (valid / invalid value) and a valid number if ok input.
  // WARN:: "0-3" breaks this code!
  const auto c = Receive_Input_Playsize(is);

  const auto is_valid_game_size =
      (c >= MIN_GAME_BOARD_PLAY_SIZE) && (c <= MAX_GAME_BOARD_PLAY_SIZE);

  // Regular case;
  if (is_valid_game_size) {
    stored_game_size = c;
    pregamesetup_status[FLAG_START_GAME] = true;
  }

  // Special Case;
  bool is_not_special_case{};

  switch (c) {
  case CODE_HOTKEY_PREGAMEMENU_BACK_TO_MAINMENU:
    pregamesetup_status[FLAG_RETURN_TO_MAIN_MENU] = true;
    break;
  default:
    is_not_special_case = true;
    break;
  }

  if (!is_valid_game_size && is_not_special_case) {
    FlagInputErrornousChoice = true;
  }
}

bool soloLoop() {
  bool invalidInputValue = FlagInputErrornousChoice;
  const auto QuestionAboutBoardSizePrompt = [&invalidInputValue]() {
    std::ostringstream str_os;
    // Prints only if "invalidInputValue" is true
    DrawOnlyWhen(str_os, invalidInputValue, Graphics::BoardSizeErrorPrompt);
    DrawAlways(str_os, Graphics::BoardInputPrompt);
    return str_os.str();
  };

  pregamesetup_status = pregamesetup_status_t{};

  clearScreen();
  DrawAlways(std::cout, Game::Graphics::AsciiArt2048);
  DrawAsOneTimeFlag(std::cout, noSave, Graphics::GameBoardNoSaveErrorPrompt);
  DrawAlways(std::cout, QuestionAboutBoardSizePrompt);

  receive_input_flags(std::cin);
  process_PreGameMenu();
  return FlagInputErrornousChoice;
}

void endlessLoop() {
  while (soloLoop())
    ;
}

enum class NewGameFlag { NewGameFlagNull, NoPreviousSaveAvailable };

void SetUpNewGame(NewGameFlag ns) {
  noSave = (ns == NewGameFlag::NoPreviousSaveAvailable) ? true : false;
  endlessLoop();
}

/**
 * @brief Initializes a GameBoard object by loading game data from a specified file.
 *
 * This function constructs the full path to the game data file by prepending "../data/" to the given filename.
 * It then calls the `load_game` function to load the game data into a new GameBoard object. The function returns 
 * a tuple containing the status of the game load operation (true if successful, false otherwise) and the initialized 
 * GameBoard object.
 *
 * @param filename The name of the file from which to read the game data.
 * @return A tuple containing a boolean indicating the success of the load operation and the initialized GameBoard object.
 */
load_gameboard_status_t initialiseContinueBoardArray(const std::string& filename)
{
  using namespace Loader;
 // const auto gameboard_data_filename = "../data/" + filename;
  auto gb = GameBoard{1};
  auto loaded_game = load_game(filename, gb);
  return std::make_tuple(loaded_game, gb);
}


/**
 * @brief Continues a previously saved game from a specified file.
 * 
 * This function attempts to load the game state from the provided filename.
 * If successful, it continues the game using the loaded state. If the loading
 * fails, it sets up a new game indicating that no previous save is available.
 * 
 * @param filename The name of the file from which to load the previous game state.
 */
void DoContinueOldGame(const std::string& filename) {
  bool load_old_game_ok;
  GameBoard oldGameBoard;
  std::tie(load_old_game_ok, oldGameBoard) = initialiseContinueBoardArray(filename);
  if (load_old_game_ok) {
    playGame(PlayGameFlag::ContinuePreviousGame, oldGameBoard);
  } else {
    SetUpNewGame(NewGameFlag::NoPreviousSaveAvailable);
  }
}

} // namespace

void SetUpNewGame() {
  SetUpNewGame(NewGameFlag::NewGameFlagNull);
}

/**
 * @brief Continue a previously saved game.
 * 
 * The ContinueOldGame function has been updated to accept a filename directly.
 * This allows the user to load a specific save file instead of only the last saved game.
 * 
 * @param filename The name of the file containing the saved game to load.
 */
void ContinueOldGame(const std::string& filename) {
  DoContinueOldGame(filename);
}

} // namespace PreGameSetup

} // namespace Game

```

`src/game.cpp`:

```cpp
#include "game.hpp"
#include "game-graphics.hpp"
#include "game-input.hpp"
#include "game-pregamemenu.hpp"
#include "gameboard-graphics.hpp"
#include "gameboard.hpp"
#include "global.hpp"
#include "loadresource.hpp"
#include "menu.hpp"
#include "saveresource.hpp"
#include "scores.hpp"
#include "statistics.hpp"
#include <array>
#include <chrono>
#include <iostream>
#include <sstream>
#include <random> // Required for generating random numbers/integers in the RemoveTiles() function.

namespace Game {
namespace {
enum Directions { UP, DOWN, RIGHT, LEFT };

enum GameStatusFlag {
  FLAG_WIN,
  FLAG_END_GAME,
  FLAG_ONE_SHOT,
  FLAG_SAVED_GAME,
  FLAG_INPUT_ERROR,
  FLAG_ENDLESS_MODE,
  FLAG_GAME_IS_ASKING_QUESTION_MODE,
  FLAG_QUESTION_STAY_OR_QUIT,
  FLAG_TILES_REMOVED,           // Indicates if tiles have already been removed
  MAX_NO_GAME_STATUS_FLAGS
};

using gamestatus_t = std::array<bool, MAX_NO_GAME_STATUS_FLAGS>;

using gamestatus_gameboard_t = std::tuple<gamestatus_t, GameBoard>;

/**
 * @brief Processes the game logic for the current game state.
 * 
 * This function updates the game status and game board based on the current state.
 * It handles tile movements, checks for game-winning conditions, and verifies if the game can continue.
 * If the player cannot make any more moves, it prompts the player to remove random tiles before ending the game.
 * 
 * @param gsgb A tuple containing the current game status and game board.
 * @return gamestatus_gameboard_t A tuple containing the updated game status and game board.
 */
gamestatus_gameboard_t process_gamelogic(gamestatus_gameboard_t gsgb) {
  gamestatus_t gamestatus;
  GameBoard gb;
  std::tie(gamestatus, gb) = gsgb;
  unblockTilesOnGameboard(gb);
  if (gb.moved) {
    addTileOnGameboard(gb);
    registerMoveByOneOnGameboard(gb);
  }

  if (!gamestatus[FLAG_ENDLESS_MODE]) {
    if (hasWonOnGameboard(gb)) {
      gamestatus[FLAG_WIN] = true;
      gamestatus[FLAG_GAME_IS_ASKING_QUESTION_MODE] = true;
      gamestatus[FLAG_QUESTION_STAY_OR_QUIT] = true;
    }
  }
  if (!canMoveOnGameboard(gb)) {
    if(gamestatus[FLAG_TILES_REMOVED] == false)
    {
      char input;
      std::cout << "You lose. Do you want to remove random tiles (Y/N) ?" << std::endl;
      std::cin >> input;

      if(input == 'Y' || input == 'y')
      {
        gamestatus[FLAG_TILES_REMOVED] = true;
        removeTiles(gb);
      }
      else if (input == 'N' || input == 'n')
      {
        gamestatus[FLAG_END_GAME] = true;
        gamestatus[FLAG_START_MENU] = true;
      }
      else 
      {
        std::cout << "Invalid input." << std::endl;
      }
    }
    else
    {
      gamestatus[FLAG_END_GAME] = true;
    }
  }
  return std::make_tuple(gamestatus, gb);
}

using competition_mode_t = bool;
Graphics::scoreboard_display_data_t
make_scoreboard_display_data(ull bestScore, competition_mode_t cm,
                             GameBoard gb) {
  const auto gameboard_score = gb.score;
  const auto tempBestScore = (bestScore < gb.score ? gb.score : bestScore);
  const auto comp_mode = cm;
  const auto movecount = MoveCountOnGameBoard(gb);
  const auto scdd =
      std::make_tuple(comp_mode, std::to_string(gameboard_score),
                      std::to_string(tempBestScore), std::to_string(movecount));
  return scdd;
};

Graphics::input_controls_display_data_t
make_input_controls_display_data(gamestatus_t gamestatus) {
  const auto icdd = std::make_tuple(gamestatus[FLAG_ENDLESS_MODE],
                                    gamestatus[FLAG_QUESTION_STAY_OR_QUIT]);
  return icdd;
};

std::string DisplayGameQuestionsToPlayerPrompt(gamestatus_t gamestatus) {
  using namespace Graphics;

  std::ostringstream str_os;
  DrawOnlyWhen(str_os, gamestatus[FLAG_QUESTION_STAY_OR_QUIT],
               QuestionEndOfWinningGamePrompt);
  return str_os.str();
}

// NOTE: current_game_session_t
// : (bestScore, is_competition_mode, gamestatus, gamePlayBoard)
using current_game_session_t =
    std::tuple<ull, competition_mode_t, gamestatus_t, GameBoard>;
enum tuple_cgs_t_idx {
  IDX_BESTSCORE,
  IDX_COMP_MODE,
  IDX_GAMESTATUS,
  IDX_GAMEBOARD
};

std::string drawGraphics(current_game_session_t cgs) {
  // Graphical Output has a specific ordering...
  using namespace Graphics;
  using namespace Gameboard::Graphics;
  using tup_idx = tuple_cgs_t_idx;
  const auto bestScore = std::get<tup_idx::IDX_BESTSCORE>(cgs);
  const auto comp_mode = std::get<tup_idx::IDX_COMP_MODE>(cgs);
  const auto gb = std::get<tup_idx::IDX_GAMEBOARD>(cgs);
  const auto gamestatus = std::get<tup_idx::IDX_GAMESTATUS>(cgs);

  std::ostringstream str_os;

  // 1. Clear screen
  clearScreen();

  // 2. Draw Game Title Art
  DrawAlways(str_os, AsciiArt2048);

  // 3. Draw Scoreboard of current game session
  const auto scdd = make_scoreboard_display_data(bestScore, comp_mode, gb);
  DrawAlways(str_os, DataSuppliment(scdd, GameScoreBoardOverlay));

  // 4. Draw current 2048 game active gameboard
  DrawAlways(str_os, DataSuppliment(gb, GameBoardTextOutput));

  // 5. Draw anyinstant status feedback, like
  // "Game saved!" (which disappers after next key input).
  DrawOnlyWhen(str_os, gamestatus[FLAG_SAVED_GAME], GameStateNowSavedPrompt);

  // 6. Draw any "questions to the player" (from the game) text output
  DrawOnlyWhen(str_os, gamestatus[FLAG_GAME_IS_ASKING_QUESTION_MODE],
               DataSuppliment(gamestatus, DisplayGameQuestionsToPlayerPrompt));

  // 7. Draw Keyboard / Input Keycodes to the player
  const auto input_controls_display_data =
      make_input_controls_display_data(gamestatus);
  DrawAlways(str_os, DataSuppliment(input_controls_display_data,
                                    GameInputControlsOverlay));

  // 8. Draw any game error messages to the player (to do with keyboard input)
  DrawOnlyWhen(str_os, gamestatus[FLAG_INPUT_ERROR],
               InvalidInputGameBoardErrorPrompt);

  return str_os.str();
}

gamestatus_t update_one_shot_display_flags(gamestatus_t gamestatus) {
  const auto disable_one_shot_flag = [](bool &trigger) { trigger = !trigger; };
  if (gamestatus[FLAG_ONE_SHOT]) {
    disable_one_shot_flag(gamestatus[FLAG_ONE_SHOT]);
    // Turn off display flag: [Saved Game]
    if (gamestatus[FLAG_SAVED_GAME]) {
      disable_one_shot_flag(gamestatus[FLAG_SAVED_GAME]);
    }
    // Turn off display flag: [Input Error]
    if (gamestatus[FLAG_INPUT_ERROR]) {
      disable_one_shot_flag(gamestatus[FLAG_INPUT_ERROR]);
    }
  }
  return gamestatus;
}

using bool_gamestatus_t = std::tuple<bool, gamestatus_t>;
/**
 * @brief Processes non-standard input commands and updates the game status accordingly.
 * 
 * This function handles additional input commands that are not part of the standard gameplay.
 * It updates the game status based on the input character received. The function supports saving
 * the game, quitting endless mode, and returning to the main menu.
 * 
 * @param c The input character received from the user.
 * @param gamestatus The current game status flags.
 * @return bool_gamestatus_t A tuple containing a boolean indicating if the keycode is invalid and the updated game status flags.
 * 
 * @note Changes in the new version:
 * - Added support for returning to the main menu with CODE_RETURN_TO_MENU.
 * - When CODE_RETURN_TO_MENU is detected, the appropriate main menu flags are set.
 */
bool_gamestatus_t check_input_other(char c, gamestatus_t gamestatus) {
  using namespace Input::Keypress::Code;
  auto is_invalid_keycode{true};
  switch (toupper(c)) {
  case CODE_HOTKEY_ACTION_SAVE:
  case CODE_HOTKEY_ALTERNATE_ACTION_SAVE:
    gamestatus[FLAG_ONE_SHOT] = true;
    gamestatus[FLAG_SAVED_GAME] = true;
    is_invalid_keycode = false;
    break;
  case CODE_HOTKEY_QUIT_ENDLESS_MODE:
    if (gamestatus[FLAG_ENDLESS_MODE]) {
      gamestatus[FLAG_END_GAME] = true;
      is_invalid_keycode = false;
    }
    break;
  case CODE_RETURN_TO_MENU:
    // When CODE_RETURN_TO_MENU is detected, the main menu is set to start, and game flags are adjusted.    mainmenustatus[FLAG_START_MENU] = true;
    mainmenustatus[FLAG_START_GAME] = false;
    mainmenustatus[FLAG_CONTINUE_GAME] = false;
    is_invalid_keycode = false;
    break;
  }
  return std::make_tuple(is_invalid_keycode, gamestatus);
}
using intendedmove_gamestatus_t =
    std::tuple<Input::intendedmove_t, gamestatus_t>;
intendedmove_gamestatus_t
receive_agent_input(Input::intendedmove_t intendedmove,
                    gamestatus_t gamestatus) {
  using namespace Input;
  const bool game_still_in_play =
      !gamestatus[FLAG_END_GAME] && !gamestatus[FLAG_WIN];
  if (game_still_in_play) {
    // Game still in play. Take input commands for next turn.
    char c;
    getKeypressDownInput(c);
    // Update agent's intended move flags per control scheme (if flagged).
    const auto is_invalid_keypress_code = check_input_ansi(c, intendedmove) &&
                                          check_input_wasd(c, intendedmove) &&
                                          check_input_vim(c, intendedmove);
    bool is_invalid_special_keypress_code;
    std::tie(is_invalid_special_keypress_code, gamestatus) =
        check_input_other(c, gamestatus);
    if (is_invalid_keypress_code && is_invalid_special_keypress_code) {
      gamestatus[FLAG_ONE_SHOT] = true;
      gamestatus[FLAG_INPUT_ERROR] = true;
    }
  }
  return std::make_tuple(intendedmove, gamestatus);
}

GameBoard decideMove(Directions d, GameBoard gb) {
  switch (d) {
  case UP:
    tumbleTilesUpOnGameboard(gb);
    break;

  case DOWN:
    tumbleTilesDownOnGameboard(gb);
    break;

  case LEFT:
    tumbleTilesLeftOnGameboard(gb);
    break;

  case RIGHT:
    tumbleTilesRightOnGameboard(gb);
    break;
  }
  return gb;
}

using bool_gameboard_t = std::tuple<bool, GameBoard>;
bool_gameboard_t process_agent_input(Input::intendedmove_t intendedmove,
                                     GameBoard gb) {
  using namespace Input;
  if (intendedmove[FLAG_MOVE_LEFT]) {
    gb = decideMove(LEFT, gb);
  }
  if (intendedmove[FLAG_MOVE_RIGHT]) {
    gb = decideMove(RIGHT, gb);
  }
  if (intendedmove[FLAG_MOVE_UP]) {
    gb = decideMove(UP, gb);
  }
  if (intendedmove[FLAG_MOVE_DOWN]) {
    gb = decideMove(DOWN, gb);
  }

  return std::make_tuple(true, gb);
}

bool check_input_check_to_end_game(char c) {
  using namespace Input::Keypress::Code;
  switch (std::toupper(c)) {
  case CODE_HOTKEY_CHOICE_NO:
    return true;
  }
  return false;
}

bool continue_playing_game(std::istream &in_os) {
  char letter_choice;
  in_os >> letter_choice;
  if (check_input_check_to_end_game(letter_choice)) {
    return false;
  }
  return true;
}

/**
 * @brief Processes the current game status and updates the game loop control.
 * 
 * This function evaluates the current game status flags and takes appropriate actions:
 * - It handles winning conditions and prompts the user to continue playing.
 * - It checks for the end of the game conditions.
 * - It manages saving the game state by prompting the user for a filename.
 * - It resets the question asking event trigger for a new loop cycle.
 * 
 * @param gsgb A tuple containing the current game status and game board.
 * @return bool_gamestatus_t A tuple containing a boolean indicating whether to continue the game loop and the updated game status flags.
 * 
 * @note Changes in the new version:
 * - Added a prompt asking the user to enter a filename when saving the game state.
 */
bool_gamestatus_t process_gameStatus(gamestatus_gameboard_t gsgb) {
  gamestatus_t gamestatus;
  GameBoard gb;
  std::tie(gamestatus, gb) = gsgb;
  auto loop_again{true};
  if (!gamestatus[FLAG_ENDLESS_MODE]) {
    if (gamestatus[FLAG_WIN]) {
      if (continue_playing_game(std::cin)) {
        gamestatus[FLAG_ENDLESS_MODE] = true;
        gamestatus[FLAG_QUESTION_STAY_OR_QUIT] = false;
        gamestatus[FLAG_WIN] = false;
      } else {
        loop_again = false;
      }
    }
  }
  if (gamestatus[FLAG_END_GAME]) {
    // End endless_mode;
    loop_again = false;
  }
  if (gamestatus[FLAG_SAVED_GAME]) {
    std::cout << "Please enter the filename to save the game state" << std::endl;
    std::string filename;
    std::cin >> filename;
    Saver::saveGamePlayState(gb, filename);
  }

  // New loop cycle: reset question asking event trigger
  gamestatus[FLAG_GAME_IS_ASKING_QUESTION_MODE] = false;
  return std::make_tuple(loop_again, gamestatus);
}

using bool_current_game_session_t = std::tuple<bool, current_game_session_t>;
bool_current_game_session_t soloGameLoop(current_game_session_t cgs) {
  using namespace Input;
  using tup_idx = tuple_cgs_t_idx;
  const auto gamestatus =
      std::addressof(std::get<tup_idx::IDX_GAMESTATUS>(cgs));
  const auto gb = std::addressof(std::get<tup_idx::IDX_GAMEBOARD>(cgs));

  std::tie(*gamestatus, *gb) =
      process_gamelogic(std::make_tuple(*gamestatus, *gb));

  DrawAlways(std::cout, DataSuppliment(cgs, drawGraphics));
  *gamestatus = update_one_shot_display_flags(*gamestatus);

  intendedmove_t player_intendedmove{};
  std::tie(player_intendedmove, *gamestatus) =
      receive_agent_input(player_intendedmove, *gamestatus);
  std::tie(std::ignore, *gb) = process_agent_input(player_intendedmove, *gb);

  bool loop_again;
  std::tie(loop_again, *gamestatus) =
      process_gameStatus(std::make_tuple(*gamestatus, *gb));
  return std::make_tuple(loop_again, cgs);
}

Graphics::end_screen_display_data_t
make_end_screen_display_data(gamestatus_t world_gamestatus) {
  const auto esdd = std::make_tuple(world_gamestatus[FLAG_WIN],
                                    world_gamestatus[FLAG_ENDLESS_MODE]);
  return esdd;
};

std::string drawEndGameLoopGraphics(current_game_session_t finalgamestatus) {
  // Graphical Output has a specific ordering...
  using namespace Graphics;
  using namespace Gameboard::Graphics;
  using tup_idx = tuple_cgs_t_idx;
  const auto bestScore = std::get<tup_idx::IDX_BESTSCORE>(finalgamestatus);
  const auto comp_mode = std::get<tup_idx::IDX_COMP_MODE>(finalgamestatus);
  const auto gb = std::get<tup_idx::IDX_GAMEBOARD>(finalgamestatus);
  const auto end_gamestatus =
      std::get<tup_idx::IDX_GAMESTATUS>(finalgamestatus);

  std::ostringstream str_os;

  // 1. Clear screen
  clearScreen();

  // 2. Draw Game Title Art
  DrawAlways(str_os, AsciiArt2048);

  // 3. Draw Scoreboard of ending current game session
  const auto scdd = make_scoreboard_display_data(bestScore, comp_mode, gb);
  DrawAlways(str_os, DataSuppliment(scdd, GameScoreBoardOverlay));

  // 4. Draw snapshot of ending 2048 session's gameboard
  DrawAlways(str_os, DataSuppliment(gb, GameBoardTextOutput));

  // 5. Draw "You win!" or "You Lose" prompt, only if not in endless mode.
  const auto esdd = make_end_screen_display_data(end_gamestatus);
  DrawAlways(str_os, DataSuppliment(esdd, GameEndScreenOverlay));

  return str_os.str();
}

/**
 * @brief Runs the endless game loop until the game ends or the user returns to the menu.
 * 
 * This function manages the continuous gameplay loop for the endless game mode. 
 * It repeatedly calls the solo game loop until the game ends or the user chooses to return to the menu.
 * The game status and game board are updated accordingly in each iteration.
 * 
 * @param currentBestScore The current best score achieved.
 * @param cm The competition mode settings.
 * @param gb The current game board state.
 * @return GameBoard The final state of the game board after the loop ends.
 * 
 * @note Changes in the new version:
 * - Added checks to monitor if the current state is set to GAME or MENU.
 * - The loop will terminate if the user presses the M key and the state changes to MENU.
 */
GameBoard endlessGameLoop(ull currentBestScore, competition_mode_t cm,
                          GameBoard gb) {
  auto loop_again{true};
  auto currentgamestatus =
      std::make_tuple(currentBestScore, cm, gamestatus_t{}, gb);
  // Monitor the loop to check if the current state is still set to GAME
  // If not, then the M key was pressed, setting the current state to MENU
  // Thus, we return to the menu
  while (loop_again && ((mainmenustatus[FLAG_START_GAME] == true) || (mainmenustatus[FLAG_CONTINUE_GAME] == true))) {
    std::tie(loop_again, currentgamestatus) = soloGameLoop(currentgamestatus);
  }

  DrawAlways(std::cout,
             DataSuppliment(currentgamestatus, drawEndGameLoopGraphics));
  return gb;
}

Scoreboard::Score make_finalscore_from_game_session(double duration,
                                                    GameBoard gb) {
  Scoreboard::Score finalscore{};
  finalscore.score = gb.score;
  finalscore.win = hasWonOnGameboard(gb);
  finalscore.moveCount = MoveCountOnGameBoard(gb);
  finalscore.largestTile = gb.largestTile;
  finalscore.duration = duration;
  return finalscore;
}

void DoPostGameSaveStuff(Scoreboard::Score finalscore, competition_mode_t cm) {
  if (cm) {
    Statistics::CreateFinalScoreAndEndGameDataFile(std::cout, std::cin,
                                                   finalscore);
  }
}

} // namespace

void playGame(PlayGameFlag cont, GameBoard gb, ull userInput_PlaySize) {
  const auto is_this_a_new_game = (cont == PlayGameFlag::BrandNewGame);
  const auto is_competition_mode =
      (userInput_PlaySize == COMPETITION_GAME_BOARD_PLAY_SIZE);
  const auto bestScore = Statistics::load_game_best_score();

  if (is_this_a_new_game) {
    gb = GameBoard(userInput_PlaySize);
    addTileOnGameboard(gb);
  }

  const auto startTime = std::chrono::high_resolution_clock::now();
  gb = endlessGameLoop(bestScore, is_competition_mode, gb);
  const auto finishTime = std::chrono::high_resolution_clock::now();
  const std::chrono::duration<double> elapsed = finishTime - startTime;
  const auto duration = elapsed.count();

  if (is_this_a_new_game) {
    const auto finalscore = make_finalscore_from_game_session(duration, gb);
    DoPostGameSaveStuff(finalscore, is_competition_mode);
  }
}

void startGame() {
  PreGameSetup::SetUpNewGame();
}

/**
 * @brief Continue a previously saved game.
 * 
 * The ContinueOldGame function has been updated to accept a filename directly.
 * This allows the user to load a specific save file instead of only the last saved game.
 * 
 * @param filename The name of the file containing the saved game to load.
 */
void continueGame(const std::string& filename) {
  PreGameSetup::ContinueOldGame(filename);
}

/**
 * @brief Randomly removes two tiles from a GameBoard by setting their values to 0.
 *
 * This function uses a random number generator to select and remove two non-empty tiles 
 * from the given GameBoard by setting their values to 0. The process continues until 
 * exactly two tiles are removed.
 *
 * @param gb The GameBoard object from which tiles will be removed.
 */
void removeTiles(GameBoard& gb) {
    // Seed with a real random value, if available
    std::random_device rd;
    std::mt19937 gen(rd());

    auto& [playsize, tiles] = gb.gbda;
    std::uniform_int_distribution<> dis(0, tiles.size() - 1);

    int tiles_to_remove = 2;
    while (tiles_to_remove > 0) {
        int random_index = dis(gen);
        auto& tile = tiles[random_index];

        if (tile.value != 0) {  // Ensure it's not already an empty tile
            tile.value = 0;     // Remove the tile
            --tiles_to_remove;
        }
    }
}

} // namespace Game

```

`src/gameboard-graphics.cpp`:

```cpp
#include "gameboard-graphics.hpp"
#include "gameboard.hpp"
#include "point2d.hpp"
#include "tile-graphics.hpp"
#include "tile.hpp"
#include <algorithm>
#include <array>
#include <sstream>

namespace Game {
namespace Gameboard {
namespace Graphics {
namespace {

template<size_t num_of_bars>
std::array<std::string, num_of_bars> make_patterned_bars(int playsize) {
  auto temp_bars = std::array<std::string, num_of_bars>{};
  using bar_pattern_t = std::tuple<std::string, std::string, std::string>;

  const auto bar_pattern_list = {std::make_tuple("┌", "┬", "┐"),
                                 std::make_tuple("├", "┼", "┤"),
                                 std::make_tuple("└", "┴", "┘")};

  // generate types of horizontal bars...
  const auto generate_x_bar_pattern = [playsize](const bar_pattern_t t) {
    enum { PATTERN_HEAD, PATTERN_MID, PATTERN_TAIL };
    constexpr auto sp = "  ";
    constexpr auto separator = "──────";
    std::ostringstream temp_richtext;
    temp_richtext << sp << std::get<PATTERN_HEAD>(t);
    for (auto i = 0; i < playsize; i++) {
      const auto is_not_last_column = (i < playsize - 1);
      temp_richtext << separator
                    << (is_not_last_column ? std::get<PATTERN_MID>(t) :
                                             std::get<PATTERN_TAIL>(t));
    }
    temp_richtext << "\n";
    return temp_richtext.str();
  };
  std::transform(std::begin(bar_pattern_list), std::end(bar_pattern_list),
                 std::begin(temp_bars), generate_x_bar_pattern);
  return temp_bars;
}

std::string drawSelf(GameBoard::gameboard_data_array_t gbda) {
  enum { TOP_BAR, XN_BAR, BASE_BAR, MAX_TYPES_OF_BARS };
  const int playsize = getPlaySizeOfGameboardDataArray(gbda);
  const auto vertibar = make_patterned_bars<MAX_TYPES_OF_BARS>(playsize);
  std::ostringstream str_os;
  for (auto y = 0; y < playsize; y++) {
    const auto is_first_row = (y == 0);
    str_os << (is_first_row ? std::get<TOP_BAR>(vertibar) :
                              std::get<XN_BAR>(vertibar));
    for (auto x = 0; x < playsize; x++) {
      const auto is_first_col = (x == 0);
      const auto sp = (is_first_col ? "  " : " ");
      const auto tile = getTileOnGameboardDataArray(gbda, point2D_t{x, y});
      str_os << sp;
      str_os << "│ ";
      str_os << drawTileString(tile);
    }
    str_os << " │";
    str_os << "\n";
  }
  str_os << std::get<BASE_BAR>(vertibar);
  str_os << "\n";
  return str_os.str();
}

} // namespace

std::string GameBoardTextOutput(GameBoard gb) {
  return drawSelf(gb.gbda);
}
} // namespace Graphics
} // namespace Gameboard
} // namespace Game

```

`src/gameboard.cpp`:

```cpp
#include "gameboard.hpp"
#include "gameboard-graphics.hpp"
#include "point2d.hpp"
#include <algorithm>
#include <array>
#include <chrono>
#include <random>
#include <sstream>
#include <utility>

namespace Game {

namespace {

class RandInt {
public:
  using clock = std::chrono::system_clock;
  RandInt() : dist{0, std::numeric_limits<int>::max()} {
    seed(clock::now().time_since_epoch().count());
  }
  RandInt(const int low, const int high) : dist{low, high} {
    seed(clock::now().time_since_epoch().count());
  }
  int operator()() { return dist(re); }
  void seed(const unsigned int s) { re.seed(s); }

private:
  std::minstd_rand re;
  std::uniform_int_distribution<> dist;
};

using gameboard_data_array_t = GameBoard::gameboard_data_array_t;
enum gameboard_data_array_fields { IDX_PLAYSIZE, IDX_BOARD, MAX_NO_INDEXES };

struct gameboard_data_point_t {
  static int point2D_to_1D_index(gameboard_data_array_t gbda, point2D_t pt) {
    int x, y;
    std::tie(x, y) = pt.get();
    return x + getPlaySizeOfGameboardDataArray(gbda) * y;
  }

  tile_t operator()(gameboard_data_array_t gbda, point2D_t pt) const {
    return std::get<IDX_BOARD>(gbda)[point2D_to_1D_index(gbda, pt)];
  }
  tile_t &operator()(gameboard_data_array_t &gbda, point2D_t pt) {
    return std::get<IDX_BOARD>(gbda)[point2D_to_1D_index(gbda, pt)];
  }
};

void setTileOnGameboardDataArray(gameboard_data_array_t &gbda, point2D_t pt,
                                 tile_t tile) {
  gameboard_data_point_t{}(gbda, pt) = tile;
}

ull getTileValueOnGameboardDataArray(gameboard_data_array_t gbda,
                                     point2D_t pt) {
  return gameboard_data_point_t{}(gbda, pt).value;
}

void setTileValueOnGameboardDataArray(gameboard_data_array_t &gbda,
                                      point2D_t pt, ull value) {
  gameboard_data_point_t{}(gbda, pt).value = value;
}

bool getTileBlockedOnGameboardDataArray(gameboard_data_array_t gbda,
                                        point2D_t pt) {
  return gameboard_data_point_t{}(gbda, pt).blocked;
}

/**
 * @brief Generates a string representation of the game board data array.
 * 
 * This function creates a formatted string that represents the current state of the game board.
 * It includes the tile values and their blocked status for each position on the board.
 * The string representation ends with a "[" character to indicate the end of the data.
 * 
 * @param gbda The game board data array to be printed.
 * @return std::string A formatted string representing the game board state.
 * 
 * @note Changes in the new version:
 * - Added a "[" character at the end of the string to indicate the end of the data.
 */
std::string printStateOfGameBoardDataArray(gameboard_data_array_t gbda) {
  const int playsize = getPlaySizeOfGameboardDataArray(gbda);
  std::ostringstream os;
  for (auto y = 0; y < playsize; y++) {
    for (auto x = 0; x < playsize; x++) {
      const auto current_point = point2D_t{x, y};
      os << getTileValueOnGameboardDataArray(gbda, current_point) << ":"
         << getTileBlockedOnGameboardDataArray(gbda, current_point) << ",";
    }
    os << "\n";
  }
  os << "["; // Indicates the end of the game board data
  return os.str();
}

bool is_point_in_board_play_area(point2D_t pt, int playsize) {
  int x, y;
  std::tie(x, y) = pt.get();
  return !(y < 0 || y > playsize - 1 || x < 0 || x > playsize - 1);
}

using delta_t = std::pair<point2D_t, point2D_t>;
// NOTE: delta_t.first = focal point, delta_t.second = offset distance

bool check_recursive_offset_in_game_bounds(delta_t dt_point, int playsize) {
  int x, y, x2, y2;
  std::tie(x, y) = dt_point.first.get();
  std::tie(x2, y2) = dt_point.second.get();
  const auto positive_direction = (y2 + x2 == 1);
  const auto negative_direction = (y2 + x2 == -1);
  const auto is_positive_y_direction_flagged = (y2 == 1);
  const auto is_negative_y_direction_flagged = (y2 == -1);
  const auto is_inside_outer_bounds =
      (positive_direction &&
       (is_positive_y_direction_flagged ? y : x) < playsize - 2);
  const auto is_inside_inner_bounds =
      (negative_direction && (is_negative_y_direction_flagged ? y : x) > 1);
  return (is_inside_outer_bounds || is_inside_inner_bounds);
}

gameboard_data_array_t
unblockTilesOnGameboardDataArray(gameboard_data_array_t gbda) {
  using tile_data_array_t = GameBoard::tile_data_array_t;
  auto new_board_data_array =
      tile_data_array_t(std::get<IDX_BOARD>(gbda).size());
  std::transform(std::begin(std::get<IDX_BOARD>(gbda)),
                 std::end(std::get<IDX_BOARD>(gbda)),
                 std::begin(new_board_data_array), [](const tile_t t) {
                   return tile_t{t.value, false};
                 });
  return gameboard_data_array_t{std::get<IDX_PLAYSIZE>(gbda),
                                new_board_data_array};
}

bool canMoveOnGameboardDataArray(gameboard_data_array_t gbda) {
  auto index_counter{0};

  const auto can_move_to_offset = [=, &index_counter](const tile_t t) {
    const int playsize = getPlaySizeOfGameboardDataArray(gbda);
    const auto current_point =
        point2D_t{index_counter % playsize, index_counter / playsize};
    index_counter++;
    const auto list_of_offsets = {point2D_t{1, 0}, point2D_t{0, 1}};
    const auto current_point_value = t.value;

    const auto offset_in_range_with_same_value = [=](const point2D_t offset) {
      const auto offset_check = {
          current_point + offset, // Positive adjacent check
          current_point - offset}; // Negative adjacent Check
          
      // Use reference to avoid unnecessary copying of complex structures
      for (const auto &current_offset : offset_check) {
        if (is_point_in_board_play_area(current_offset, playsize)) {
          return getTileValueOnGameboardDataArray(gbda, current_offset) ==
                 current_point_value;
        }
      }
      return false;
    };

    return ((current_point_value == 0u) ||
            std::any_of(std::begin(list_of_offsets), std::end(list_of_offsets),
                        offset_in_range_with_same_value));
  };
  return std::any_of(std::begin(std::get<IDX_BOARD>(gbda)),
                     std::end(std::get<IDX_BOARD>(gbda)), can_move_to_offset);
}

std::vector<size_t>
collectFreeTilesOnGameboardDataArray(gameboard_data_array_t gbda) {
  std::vector<size_t> freeTiles;
  auto index_counter{0};
  for (const auto t : std::get<IDX_BOARD>(gbda)) {
    if (!t.value) {
      freeTiles.push_back(index_counter);
    }
    index_counter++;
  }
  return freeTiles;
}

bool addTileOnGameboardDataArray(gameboard_data_array_t &gbda) {
  constexpr auto CHANCE_OF_VALUE_FOUR_OVER_TWO = 89; // Percentage
  const auto index_list_of_free_tiles =
      collectFreeTilesOnGameboardDataArray(gbda);

  if (!index_list_of_free_tiles.size()) {
    return true;
  }

  const int playsize = getPlaySizeOfGameboardDataArray(gbda);
  const int rand_selected_index = index_list_of_free_tiles.at(
      RandInt{}() % index_list_of_free_tiles.size());
  const auto rand_index_as_point_t =
      point2D_t{rand_selected_index % playsize, rand_selected_index / playsize};
  const auto value_four_or_two =
      RandInt{}() % 100 > CHANCE_OF_VALUE_FOUR_OVER_TWO ? 4 : 2;
  setTileValueOnGameboardDataArray(gbda, rand_index_as_point_t,
                                   value_four_or_two);

  return false;
}

bool collaspeTilesOnGameboardDataArray(gameboard_data_array_t &gbda,
                                       delta_t dt_point) {
  tile_t currentTile = getTileOnGameboardDataArray(gbda, dt_point.first);
  tile_t targetTile =
      getTileOnGameboardDataArray(gbda, dt_point.first + dt_point.second);

  currentTile.value = 0;
  targetTile.value *= 2;
  targetTile.blocked = true;

  setTileOnGameboardDataArray(gbda, dt_point.first, currentTile);
  setTileOnGameboardDataArray(gbda, dt_point.first + dt_point.second,
                              targetTile);
  return true;
}

bool shiftTilesOnGameboardDataArray(gameboard_data_array_t &gbda,
                                    delta_t dt_point) {
  tile_t currentTile = getTileOnGameboardDataArray(gbda, dt_point.first);
  tile_t targetTile =
      getTileOnGameboardDataArray(gbda, dt_point.first + dt_point.second);

  targetTile.value = currentTile.value;
  currentTile.value = 0;

  setTileOnGameboardDataArray(gbda, dt_point.first, currentTile);
  setTileOnGameboardDataArray(gbda, dt_point.first + dt_point.second,
                              targetTile);
  return true;
}

enum class COLLASPE_OR_SHIFT_T {
  ACTION_NONE,
  ACTION_COLLASPE,
  ACTION_SHIFT,
  MAX_NUM_OF_ACTIONS
};

using bool_collaspe_shift_t = std::tuple<bool, COLLASPE_OR_SHIFT_T>;

bool_collaspe_shift_t
collasped_or_shifted_tilesOnGameboardDataArray(gameboard_data_array_t gbda,
                                               delta_t dt_point) {
  const auto currentTile = getTileOnGameboardDataArray(gbda, dt_point.first);
  const auto targetTile =
      getTileOnGameboardDataArray(gbda, dt_point.first + dt_point.second);
  const auto does_value_exist_in_target_point = targetTile.value;
  const auto is_value_same_as_target_value =
      (currentTile.value == targetTile.value);
  const auto no_tiles_are_blocked =
      (!currentTile.blocked && !targetTile.blocked);
  const auto is_there_a_current_value_but_no_target_value =
      (currentTile.value && !targetTile.value);
  const auto do_collapse =
      (does_value_exist_in_target_point && is_value_same_as_target_value &&
       no_tiles_are_blocked);
  const auto do_shift = is_there_a_current_value_but_no_target_value;
  const auto action_taken = (do_collapse || do_shift);

  if (do_collapse) {
    return std::make_tuple(action_taken, COLLASPE_OR_SHIFT_T::ACTION_COLLASPE);
  } else if (do_shift) {
    return std::make_tuple(action_taken, COLLASPE_OR_SHIFT_T::ACTION_SHIFT);
  }
  return std::make_tuple(action_taken, COLLASPE_OR_SHIFT_T::ACTION_NONE);
}

bool updateGameBoardStats(GameBoard &gb, ull target_tile_value) {
  gb.score += target_tile_value;

  //  Discover the largest tile value on the gameboard...
  gb.largestTile = std::max(gb.largestTile, target_tile_value);

  //  Discover the winning tile value on the gameboard...
  if (!hasWonOnGameboard(gb)) {
    constexpr auto GAME_TILE_WINNING_SCORE = 2048;
    if (target_tile_value == GAME_TILE_WINNING_SCORE) {
      gb.win = true;
    }
  }
  return true;
}

void moveOnGameboard(GameBoard &gb, delta_t dt_point) {
  auto did_gameboard_collaspe_or_shift_anything = bool{};
  auto action_was_taken = COLLASPE_OR_SHIFT_T::ACTION_NONE;
  std::tie(did_gameboard_collaspe_or_shift_anything, action_was_taken) =
      collasped_or_shifted_tilesOnGameboardDataArray(gb.gbda, dt_point);
  if (did_gameboard_collaspe_or_shift_anything) {
    gb.moved = true;
    if (action_was_taken == COLLASPE_OR_SHIFT_T::ACTION_COLLASPE) {
      collaspeTilesOnGameboardDataArray(gb.gbda, dt_point);
      const auto targetTile = getTileOnGameboardDataArray(
          gb.gbda, dt_point.first + dt_point.second);
      updateGameBoardStats(gb, targetTile.value);
    }
    if (action_was_taken == COLLASPE_OR_SHIFT_T::ACTION_SHIFT) {
      shiftTilesOnGameboardDataArray(gb.gbda, dt_point);
    }
  }
  if (check_recursive_offset_in_game_bounds(
          dt_point, getPlaySizeOfGameboardDataArray(gb.gbda))) {
    moveOnGameboard(
        gb, std::make_pair(dt_point.first + dt_point.second, dt_point.second));
  }
}

void doTumbleTilesUpOnGameboard(GameBoard &gb) {
  const int playsize = getPlaySizeOfGameboardDataArray(gb.gbda);
  for (auto x = 0; x < playsize; x++) {
    auto y = 1;
    while (y < playsize) {
      const auto current_point = point2D_t{x, y};
      if (getTileValueOnGameboardDataArray(gb.gbda, current_point)) {
        moveOnGameboard(gb, std::make_pair(current_point, point2D_t{0, -1}));
      }
      y++;
    }
  }
}

void doTumbleTilesDownOnGameboard(GameBoard &gb) {
  const int playsize = getPlaySizeOfGameboardDataArray(gb.gbda);
  for (auto x = 0; x < playsize; x++) {
    auto y = playsize - 2;
    while (y >= 0) {
      const auto current_point = point2D_t{x, y};
      if (getTileValueOnGameboardDataArray(gb.gbda, current_point)) {
        moveOnGameboard(gb, std::make_pair(current_point, point2D_t{0, 1}));
      }
      y--;
    }
  }
}

void doTumbleTilesLeftOnGameboard(GameBoard &gb) {
  const int playsize = getPlaySizeOfGameboardDataArray(gb.gbda);
  for (auto y = 0; y < playsize; y++) {
    auto x = 1;
    while (x < playsize) {
      const auto current_point = point2D_t{x, y};
      if (getTileValueOnGameboardDataArray(gb.gbda, current_point)) {
        moveOnGameboard(gb, std::make_pair(current_point, point2D_t{-1, 0}));
      }
      x++;
    }
  }
}

void doTumbleTilesRightOnGameboard(GameBoard &gb) {
  const int playsize = getPlaySizeOfGameboardDataArray(gb.gbda);
  for (auto y = 0; y < playsize; y++) {
    auto x = playsize - 2;
    while (x >= 0) {
      const auto current_point = point2D_t{x, y};
      if (getTileValueOnGameboardDataArray(gb.gbda, current_point)) {
        moveOnGameboard(gb, std::make_pair(current_point, point2D_t{1, 0}));
      }
      x--;
    }
  }
}

} // namespace

GameBoard::GameBoard(ull playsize)
    : GameBoard{playsize, tile_data_array_t(playsize * playsize)} {
}
GameBoard::GameBoard(ull playsize, tile_data_array_t prempt_board)
    : gbda{playsize, prempt_board} {
}

size_t getPlaySizeOfGameboardDataArray(gameboard_data_array_t gbda) {
  return std::get<IDX_PLAYSIZE>(gbda);
}

tile_t getTileOnGameboardDataArray(gameboard_data_array_t gbda, point2D_t pt) {
  return gameboard_data_point_t{}(gbda, pt);
}

bool hasWonOnGameboard(GameBoard gb) {
  return gb.win;
}

long long MoveCountOnGameBoard(GameBoard gb) {
  return gb.moveCount;
}

void unblockTilesOnGameboard(GameBoard &gb) {
  gb.gbda = unblockTilesOnGameboardDataArray(gb.gbda);
}

bool canMoveOnGameboard(GameBoard &gb) {
  return canMoveOnGameboardDataArray(gb.gbda);
}

void registerMoveByOneOnGameboard(GameBoard &gb) {
  gb.moveCount++;
  gb.moved = false;
}

bool addTileOnGameboard(GameBoard &gb) {
  return addTileOnGameboardDataArray(gb.gbda);
}

void tumbleTilesUpOnGameboard(GameBoard &gb) {
  doTumbleTilesUpOnGameboard(gb);
}

void tumbleTilesDownOnGameboard(GameBoard &gb) {
  doTumbleTilesDownOnGameboard(gb);
}

void tumbleTilesLeftOnGameboard(GameBoard &gb) {
  doTumbleTilesLeftOnGameboard(gb);
}

void tumbleTilesRightOnGameboard(GameBoard &gb) {
  doTumbleTilesRightOnGameboard(gb);
}

std::string printStateOfGameBoard(GameBoard gb) {
  return printStateOfGameBoardDataArray(gb.gbda);
}

} // namespace Game

```

`src/global.cpp`:

```cpp
#include "global.hpp"
#include "color.hpp"
#include <iostream>
#include <sstream>

#ifdef _WIN32

void getKeypressDownInput(char &c) {
  std::cin >> c;
}

#else
#  include <termios.h>
#  include <unistd.h>

char getch() {
  char buf = 0;
  struct termios old = {0};
  if (tcgetattr(0, &old) < 0)
    perror("tcsetattr()");
  old.c_lflag &= ~ICANON;
  old.c_lflag &= ~ECHO;
  old.c_cc[VMIN] = 1;
  old.c_cc[VTIME] = 0;
  if (tcsetattr(0, TCSANOW, &old) < 0)
    perror("tcsetattr ICANON");
  if (read(0, &buf, 1) < 0)
    perror("read()");
  old.c_lflag |= ICANON;
  old.c_lflag |= ECHO;
  if (tcsetattr(0, TCSADRAIN, &old) < 0)
    perror("tcsetattr ~ICANON");
  return (buf);
}

void getKeypressDownInput(char &c) {
  c = getch();
}

#endif

void pause_for_keypress() {
  char c{};
  getKeypressDownInput(c);
}

void wait_for_any_letter_input(std::istream &is) {
  char c;
  is >> c;
}

void clearScreen() {
#ifdef _WIN32
  system("cls");
#else
  system("clear");
#endif
};

std::string secondsFormat(double sec) {
  double s = sec;
  int m = s / 60;
  s -= m * 60;
  int h = m / 60;
  m %= 60;
  s = (int)s;
  std::ostringstream oss;
  if (h) {
    oss << h << "h ";
  }
  if (m) {
    oss << m << "m ";
  }
  oss << s << "s";
  return oss.str();
}

```

`src/headers/2048.hpp`:

```hpp
//#include "game.hpp"

```

`src/headers/color.hpp`:

```hpp
#ifndef COLOR_H
#define COLOR_H

#include <ostream>

namespace Color {
enum class Code {
  BOLD = 1,
  RESET = 0,
  BG_BLUE = 44,
  BG_DEFAULT = 49,
  BG_GREEN = 42,
  BG_RED = 41,
  FG_BLACK = 30,
  FG_BLUE = 34,
  FG_CYAN = 36,
  FG_DARK_GRAY = 90,
  FG_DEFAULT = 39,
  FG_GREEN = 32,
  FG_LIGHT_BLUE = 94,
  FG_LIGHT_CYAN = 96,
  FG_LIGHT_GRAY = 37,
  FG_LIGHT_GREEN = 92,
  FG_LIGHT_MAGENTA = 95,
  FG_LIGHT_RED = 91,
  FG_LIGHT_YELLOW = 93,
  FG_MAGENTA = 35,
  FG_RED = 31,
  FG_WHITE = 97,
  FG_YELLOW = 33,
};

class Modifier {

  Code code;

public:
  Modifier(Code pCode) : code(pCode) {}
  friend std::ostream &operator<<(std::ostream &os, const Modifier &mod) {
    return os << "\033[" << static_cast<int>(mod.code) << "m";
  }
};

} // namespace Color

static Color::Modifier bold_off(Color::Code::RESET);
static Color::Modifier bold_on(Color::Code::BOLD);
static Color::Modifier def(Color::Code::FG_DEFAULT);
static Color::Modifier red(Color::Code::FG_RED);
static Color::Modifier green(Color::Code::FG_GREEN);
static Color::Modifier yellow(Color::Code::FG_YELLOW);
static Color::Modifier blue(Color::Code::FG_BLUE);
static Color::Modifier magenta(Color::Code::FG_MAGENTA);
static Color::Modifier cyan(Color::Code::FG_CYAN);
static Color::Modifier lightGray(Color::Code::FG_LIGHT_GRAY);
static Color::Modifier darkGray(Color::Code::FG_DARK_GRAY);
static Color::Modifier lightRed(Color::Code::FG_LIGHT_RED);
static Color::Modifier lightGreen(Color::Code::FG_LIGHT_GREEN);
static Color::Modifier lightYellow(Color::Code::FG_LIGHT_YELLOW);
static Color::Modifier lightBlue(Color::Code::FG_LIGHT_BLUE);
static Color::Modifier lightMagenta(Color::Code::FG_LIGHT_MAGENTA);
static Color::Modifier lightCyan(Color::Code::FG_LIGHT_CYAN);

#endif

```

`src/headers/game-graphics.hpp`:

```hpp
#ifndef GAMEGRAPHICS_H
#define GAMEGRAPHICS_H

#include <string>
#include <tuple>

enum GameBoardDimensions {
  MIN_GAME_BOARD_PLAY_SIZE = 3,
  MAX_GAME_BOARD_PLAY_SIZE = 10
};
enum { COMPETITION_GAME_BOARD_PLAY_SIZE = 4 };

namespace Game {
namespace Graphics {
std::string AsciiArt2048();
std::string BoardInputPrompt();
std::string YouWinPrompt();
std::string GameOverPrompt();
std::string EndOfEndlessPrompt();
std::string InvalidInputGameBoardErrorPrompt();
std::string QuestionEndOfWinningGamePrompt();
std::string GameStateNowSavedPrompt();
std::string GameBoardNoSaveErrorPrompt();
std::string BoardSizeErrorPrompt();
std::string InputCommandListPrompt();
std::string EndlessModeCommandListPrompt();
std::string InputCommandListFooterPrompt();
using scoreboard_display_data_t =
    std::tuple<bool, std::string, std::string, std::string>;
std::string GameScoreBoardBox(scoreboard_display_data_t scdd);
std::string GameScoreBoardOverlay(scoreboard_display_data_t scdd);
using end_screen_display_data_t = std::tuple<bool, bool>;
std::string GameEndScreenOverlay(end_screen_display_data_t esdd);
using input_controls_display_data_t = std::tuple<bool, bool>;
std::string GameInputControlsOverlay(input_controls_display_data_t gamestatus);
} // namespace Graphics
} // namespace Game

#endif

```

`src/headers/game-input.hpp`:

```hpp
#ifndef GAMEINPUT_H
#define GAMEINPUT_H

#include <array>

namespace Game {
namespace Input {

namespace Keypress {
namespace Code {

enum { CODE_ESC = 27, CODE_LSQUAREBRACKET = '[' };

// Hotkey bindings:
// Style: ANSI (Arrow Keys)
enum {
  CODE_ANSI_TRIGGER_1 = CODE_ESC,
  CODE_ANSI_TRIGGER_2 = CODE_LSQUAREBRACKET
};
enum {
  CODE_ANSI_UP = 'A',
  CODE_ANSI_DOWN = 'B',
  CODE_ANSI_LEFT = 'D',
  CODE_ANSI_RIGHT = 'C'
};

// Style: WASD
enum {
  CODE_WASD_UP = 'W',
  CODE_WASD_DOWN = 'S',
  CODE_WASD_LEFT = 'A',
  CODE_WASD_RIGHT = 'D'
};

// Style: Vim
enum {
  CODE_VIM_UP = 'K',
  CODE_VIM_DOWN = 'J',
  CODE_VIM_LEFT = 'H',
  CODE_VIM_RIGHT = 'L'
};

enum {
  CODE_HOTKEY_ACTION_SAVE = 'Z',
  CODE_HOTKEY_ALTERNATE_ACTION_SAVE = 'P',
  CODE_HOTKEY_QUIT_ENDLESS_MODE = 'X',
  CODE_HOTKEY_CHOICE_NO = 'N',
  CODE_HOTKEY_CHOICE_YES = 'Y',
  CODE_HOTKEY_PREGAMEMENU_BACK_TO_MAINMENU = 0,
  CODE_RETURN_TO_MENU = 'M' // Press 'M' to return to menu
};

} // namespace Code
} // namespace Keypress

enum IntendedMoveFlag {
  FLAG_MOVE_LEFT,
  FLAG_MOVE_RIGHT,
  FLAG_MOVE_UP,
  FLAG_MOVE_DOWN,
  MAX_NO_INTENDED_MOVE_FLAGS
};
using intendedmove_t = std::array<bool, MAX_NO_INTENDED_MOVE_FLAGS>;

bool check_input_ansi(char c, intendedmove_t &intendedmove);
bool check_input_vim(char c, intendedmove_t &intendedmove);
bool check_input_wasd(char c, intendedmove_t &intendedmove);

} // namespace Input
} // namespace Game

#endif

```

`src/headers/game-pregamemenu.hpp`:

```hpp
#ifndef GAMEPREGAMEMENU_H
#define GAMEPREGAMEMENU_H

#include <string>

namespace Game {
namespace PreGameSetup {
    
void SetUpNewGame();
void ContinueOldGame(const std::string& filename);

} // namespace PreGameSetup
} // namespace Game

#endif

```

`src/headers/game.hpp`:

```hpp
#ifndef GAME_H
#define GAME_H

#include <string>

namespace Game {
struct GameBoard;

enum class PlayGameFlag { BrandNewGame, ContinuePreviousGame };
void playGame(PlayGameFlag cont, GameBoard gb,
              unsigned long long userInput_PlaySize = 1);
void startGame();
void continueGame(const std::string& filename);
void removeTiles(GameBoard& gb);

}; // namespace Game

#endif

```

`src/headers/gameboard-graphics.hpp`:

```hpp
#ifndef GAMEBOARDGRAPHICS_H
#define GAMEBOARDGRAPHICS_H

#include <string>

namespace Game {
struct GameBoard;
namespace Gameboard {
namespace Graphics {
std::string GameBoardTextOutput(GameBoard gb);

}
} // namespace Gameboard
} // namespace Game

#endif

```

`src/headers/gameboard.hpp`:

```hpp
#ifndef GAMEBOARD_H
#define GAMEBOARD_H

#include "tile.hpp"
#include <tuple>
#include <vector>

struct point2D_t;

namespace Game {

struct GameBoard {
  using tile_data_array_t = std::vector<tile_t>;
  using gameboard_data_array_t = std::tuple<size_t, tile_data_array_t>;

  gameboard_data_array_t gbda;
  bool win{};
  bool moved{true};
  ull score{};
  ull largestTile{2};
  long long moveCount{-1};

  GameBoard() = default;
  explicit GameBoard(ull playsize);
  explicit GameBoard(ull playsize, tile_data_array_t prempt_board);
};

size_t getPlaySizeOfGameboardDataArray(GameBoard::gameboard_data_array_t gbda);
tile_t getTileOnGameboardDataArray(GameBoard::gameboard_data_array_t gbda,
                                   point2D_t pt);

bool hasWonOnGameboard(GameBoard gb);
long long MoveCountOnGameBoard(GameBoard gb);

void unblockTilesOnGameboard(GameBoard &gb);
bool canMoveOnGameboard(GameBoard &gb);
bool addTileOnGameboard(GameBoard &gb);
void registerMoveByOneOnGameboard(GameBoard &gb);

void tumbleTilesUpOnGameboard(GameBoard &gb);
void tumbleTilesDownOnGameboard(GameBoard &gb);
void tumbleTilesLeftOnGameboard(GameBoard &gb);
void tumbleTilesRightOnGameboard(GameBoard &gb);

std::string printStateOfGameBoard(GameBoard gb);

} // namespace Game

#endif

```

`src/headers/global.hpp`:

```hpp
#ifndef GLOBAL_H
#define GLOBAL_H

#include <iosfwd>
#include <string>

using ull = unsigned long long;
void getKeypressDownInput(char &);

template<typename T>
void DrawAlways(std::ostream &os, T f) {
  os << f();
}

template<typename T>
void DrawOnlyWhen(std::ostream &os, bool trigger, T f) {
  if (trigger) {
    DrawAlways(os, f);
  }
}

template<typename T>
void DrawAsOneTimeFlag(std::ostream &os, bool &trigger, T f) {
  if (trigger) {
    DrawAlways(os, f);
    trigger = !trigger;
  }
}

template<typename suppliment_t>
struct DataSupplimentInternalType {
  suppliment_t suppliment_data;
  template<typename function_t>
  std::string operator()(function_t f) const {
    return f(suppliment_data);
  }
};

template<typename suppliment_t, typename function_t>
auto DataSuppliment(suppliment_t needed_data, function_t f) {
  using dsit_t = DataSupplimentInternalType<suppliment_t>;
  const auto lambda_f_to_return = [=]() {
    const dsit_t depinject_func = dsit_t{needed_data};
    return depinject_func(f);
  };
  return lambda_f_to_return;
}

void pause_for_keypress();
void wait_for_any_letter_input(std::istream &is);
void clearScreen();
std::string secondsFormat(double);

#endif

```

`src/headers/loadresource.hpp`:

```hpp
#ifndef LOADRESOURCE_H
#define LOADRESOURCE_H

#include <string>
#include <tuple>

namespace Game {
using load_gameboard_status_t = std::tuple<bool, struct GameBoard>;

namespace Loader {
load_gameboard_status_t load_GameBoard_data_from_file(std::string filename);

// Output: {[loadfile_ok_status], [decltype(gameboard.score)],
// [decltype(gameboard.moveCount)]}
std::tuple<bool, std::tuple<unsigned long long, long long>>
load_game_stats_from_file(std::string filename);
bool load_game(std::string filename, GameBoard& gb);

} // namespace Loader
} // namespace Game

#endif

```

`src/headers/menu-graphics.hpp`:

```hpp
#ifndef MENUGRAPHICS_H
#define MENUGRAPHICS_H

#include <string>

namespace Game {
namespace Graphics {
namespace Menu {
std::string MainMenuTitlePrompt();
std::string MainMenuOptionsPrompt();
std::string InputMenuErrorInvalidInputPrompt();
std::string InputMenuPrompt();
std::string MainMenuGraphicsOverlay(bool input_error_choice_invalid);
} // namespace Menu
} // namespace Graphics
} // namespace Game

#endif

```

`src/headers/menu.hpp`:

```hpp
#ifndef MENU_H
#define MENU_H

#include <array>
#include "gameboard.hpp"

/**
 * @enum MainMenuStatusFlag
 * @brief Enumeration of possible main menu status flags.
 * 
 * These flags represent various states and actions that can be triggered from the main menu.
 */
enum MainMenuStatusFlag {
  FLAG_NULL,                    /**< No action */
  FLAG_START_GAME,              /**< Start a new game */
  FLAG_START_MENU,              /**< Start menu (new flag for starting menu) */
  FLAG_CONTINUE_GAME,           /**< Continue an existing game */
  FLAG_DISPLAY_HIGHSCORES,      /**< Display the high scores */
  FLAG_EXIT_GAME,               /**< Exit the game */
  MAX_NO_MAIN_MENU_STATUS_FLAGS /**< Maximum number of main menu status flags */
};

/**
 * @typedef mainmenustatus_t
 * @brief Array type for main menu status flags.
 * 
 * This type represents an array of boolean values corresponding to each main menu status flag.
 */
using mainmenustatus_t = std::array<bool, MAX_NO_MAIN_MENU_STATUS_FLAGS>;

/**
 * @var mainmenustatus
 * @brief Global variable to track the status of main menu flags.
 * 
 * This variable is used to store the current status of each main menu flag, allowing
 * the game's main menu state to be accessed and modified globally.
 */
extern mainmenustatus_t mainmenustatus;

std::vector<std::string> listSavedGameStates(const std::string& directory);

std::string chooseGameState(const std::vector<std::string>& gamestate);

namespace Menu {
void startMenu();
} // namespace Menu

#endif

```

`src/headers/point2d.hpp`:

```hpp
#ifndef POINT_2D_H
#define POINT_2D_H

#include <tuple>

class point2D_t {
  // Simple {x,y} datastructure = std::tuple<int, int>...
  using point_datatype_t = typename std::tuple<int, int>;
  point_datatype_t point_vector{};
  explicit point2D_t(const point_datatype_t pt) : point_vector{pt} {}

public:
  enum class PointCoord { COORD_X, COORD_Y };

  point2D_t() = default;
  point2D_t(const int x, const int y) : point2D_t(std::make_tuple(x, y)) {}

  template<PointCoord dimension>
  int get() const {
    return std::get<static_cast<int>(dimension)>(point_vector);
  }
  template<PointCoord dimension>
  void set(int value) {
    std::get<static_cast<int>(dimension)>(point_vector) = value;
  }
  point_datatype_t get() const { return point_vector; }
  void set(point_datatype_t value) { point_vector = value; }

  void set(const int x, const int y) { set(std::make_tuple(x, y)); }

  point2D_t &operator+=(const point2D_t &pt) {
    this->point_vector = std::make_tuple(
        get<PointCoord::COORD_X>() + pt.get<PointCoord::COORD_X>(),
        get<PointCoord::COORD_Y>() + pt.get<PointCoord::COORD_Y>());
    return *this;
  }

  point2D_t &operator-=(const point2D_t &pt) {
    this->point_vector = std::make_tuple(
        get<PointCoord::COORD_X>() - pt.get<PointCoord::COORD_X>(),
        get<PointCoord::COORD_Y>() - pt.get<PointCoord::COORD_Y>());
    return *this;
  }
};

inline point2D_t operator+(point2D_t l, const point2D_t &r) {
  l += r;
  return l;
}

inline point2D_t operator-(point2D_t l, const point2D_t &r) {
  l -= r;
  return l;
}

#endif

```

`src/headers/saveresource.hpp`:

```hpp
#ifndef SAVERESOURCE_H
#define SAVERESOURCE_H

#include <string>
#include <tuple>

namespace Game {
struct GameBoard;

namespace Saver {
void saveGamePlayState(GameBoard gb, const std::string& filename);

} // namespace Saver
} // namespace Game

#endif

```

`src/headers/scores-graphics.hpp`:

```hpp
#ifndef SCORESGRAPHICS_H
#define SCORESGRAPHICS_H

#include <string>
#include <tuple>
#include <vector>

namespace Scoreboard {
namespace Graphics {
using scoreboard_display_data_t =
    std::tuple<std::string, std::string, std::string, std::string, std::string,
               std::string, std::string>;

using scoreboard_display_data_list_t = std::vector<scoreboard_display_data_t>;
std::string ScoreboardOverlay(scoreboard_display_data_list_t sbddl);

using finalscore_display_data_t =
    std::tuple<std::string, std::string, std::string, std::string>;
std::string EndGameStatisticsPrompt(finalscore_display_data_t finalscore);
} // namespace Graphics
} // namespace Scoreboard

#endif

```

`src/headers/scores.hpp`:

```hpp
#ifndef SCORES_H
#define SCORES_H

#include "global.hpp"
#include <iosfwd>
#include <string>
#include <tuple>
#include <vector>

namespace Scoreboard {
struct Score {
  std::string name;
  ull score;
  bool win;
  ull largestTile;
  long long moveCount;
  double duration;
};

bool operator>(const Score &a, const Score &b);

using Scoreboard_t = std::vector<Score>;
using load_score_status_t = std::tuple<bool, Scoreboard_t>;

// List of scores read until "exhausted".
// Note: returns a tuple containing a std::vector<Score> of all read scores.
load_score_status_t loadFromFileScore(std::string filename);
void saveScore(Score finalscore);
} // namespace Scoreboard

std::istream &operator>>(std::istream &is, Scoreboard::Score &s);
std::ostream &operator<<(std::ostream &os, Scoreboard::Score &s);

#endif

```

`src/headers/statistics-graphics.hpp`:

```hpp
#ifndef STATISTICSGRAPHICS_H
#define STATISTICSGRAPHICS_H

#include <string>
#include <tuple>

namespace Statistics {
namespace Graphics {
std::string AskForPlayerNamePrompt();
std::string MessageScoreSavedPrompt();

using total_stats_display_data_t =
    std::tuple<bool, std::string, std::string, std::string, std::string,
               std::string>;
std::string TotalStatisticsOverlay(total_stats_display_data_t tsdd);
} // namespace Graphics
} // namespace Statistics

#endif

```

`src/headers/statistics.hpp`:

```hpp
#ifndef STATISTICS_H
#define STATISTICS_H

#include "global.hpp"
#include <iosfwd>
#include <string>
#include <tuple>

namespace Scoreboard {
struct Score;
}

namespace Statistics {
struct total_game_stats_t {
  ull bestScore{};
  ull totalMoveCount{};
  int gameCount{};
  double totalDuration{};
  int winCount{};
};

using load_stats_status_t = std::tuple<bool, total_game_stats_t>;

load_stats_status_t loadFromFileStatistics(std::string filename);
ull load_game_best_score();
void saveEndGameStats(Scoreboard::Score finalscore);
void CreateFinalScoreAndEndGameDataFile(std::ostream &os, std::istream &is,
                                        Scoreboard::Score finalscore);
} // namespace Statistics

std::istream &operator>>(std::istream &is, Statistics::total_game_stats_t &s);
std::ostream &operator<<(std::ostream &os, Statistics::total_game_stats_t &s);

#endif

```

`src/headers/tile-graphics.hpp`:

```hpp
#ifndef TILEGRAPHICS_H
#define TILEGRAPHICS_H

#include <string>

namespace Game {
struct tile_t;
std::string drawTileString(tile_t currentTile);
} // namespace Game

#endif

```

`src/headers/tile.hpp`:

```hpp
#ifndef TILE_H
#define TILE_H

#include "global.hpp"

namespace Game {
struct tile_t {
  ull value{};
  bool blocked{};
};
} // namespace Game

#endif

```

`src/loadresource.cpp`:

```cpp
#include "loadresource.hpp"
#include "gameboard.hpp"
#include "global.hpp"
#include <algorithm>
#include <array>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <tuple>
#include <vector>

namespace Game {
namespace Loader {
namespace {

/**
 * @brief Counts the number of lines in a file until a line containing '[' is found.
 *
 * This function opens a file specified by the given filename and counts the number 
 * of lines until it encounters a line that contains the character '['. If the file 
 * cannot be opened, it prints an error message and returns -1.
 *
 * @param filename The name of the file to be read.
 * @return The number of lines read before encountering a line with '['. Returns -1 if the file cannot be opened.
 */
int GetLines(std::string filename) 
{
  std::ifstream stateFile(filename);
  if (!stateFile) {
      std::cerr << "Error. Cannot open the file: " << filename << std::endl;
      return -1; // Return -1 to indicate an error
  }

  std::string tempLine;
  int noOfLines = 0;

  while (std::getline(stateFile, tempLine)) {
      if (tempLine.find('[') != std::string::npos) {
          break; // Exit loop if '[' is found
      }
      noOfLines++;
  }

  return noOfLines;
}

/**
 * @brief Extracts tile data from a given input stream until a line containing '[' is encountered.
 *
 * This function reads lines from the provided input stream and extracts tile data 
 * formatted as comma-separated values. The process continues until either the maximum 
 * width (10 lines) is reached or a line containing the character '[' is found. When 
 * a line with '[' is encountered, the function stops reading further and processes 
 * the line up to, but not including, the '[' character.
 *
 * @param buf The input stream from which to read the tile data.
 * @return A vector of strings containing the extracted tile data.
 */
std::vector<std::string> get_file_tile_data(std::istream &buf) {
    std::vector<std::string> tempbuffer;
    enum { MAX_WIDTH = 10, MAX_HEIGHT = 10 };
    auto i{0};

    for (std::string tempLine; std::getline(buf, tempLine) && i < MAX_WIDTH; i++) {
        if (tempLine.find('[') != std::string::npos) {
            // Remove the '[' character and stop reading further
            tempLine = tempLine.substr(0, tempLine.find('['));
            std::istringstream temp_filestream(tempLine);
            auto j{0};
            for (std::string a_word; std::getline(temp_filestream, a_word, ',') && j < MAX_HEIGHT; j++) {
                tempbuffer.push_back(a_word);
            }
            break; // Stop the outer loop as the end of tile data is reached
        }

        std::istringstream temp_filestream(tempLine);
        auto j{0};
        for (std::string a_word; std::getline(temp_filestream, a_word, ',') && j < MAX_HEIGHT; j++) {
            tempbuffer.push_back(a_word);
        }
    }

    return tempbuffer;
}

std::vector<tile_t>
process_file_tile_string_data(std::vector<std::string> buf) {
  std::vector<tile_t> result_buf;
  auto tile_processed_counter{0};
  const auto prime_tile_data =
      [&tile_processed_counter](const std::string tile_data) {
        enum FieldIndex { IDX_TILE_VALUE, IDX_TILE_BLOCKED, MAX_NO_TILE_IDXS };
        std::array<int, MAX_NO_TILE_IDXS> tile_internal{};
        std::istringstream blocks(tile_data);
        auto idx_id{0};
        for (std::string temptiledata; std::getline(
                 blocks, temptiledata, ':') /*&& idx_id < MAX_NO_TILE_IDXS*/;
             idx_id++) {
          switch (idx_id) {
          case IDX_TILE_VALUE:
            std::get<IDX_TILE_VALUE>(tile_internal) = std::stoi(temptiledata);
            break;
          case IDX_TILE_BLOCKED:
            std::get<IDX_TILE_BLOCKED>(tile_internal) = std::stoi(temptiledata);
            break;
          default:
            std::cout << "ERROR: [tile_processed_counter: "
                      << tile_processed_counter
                      << "]: Read past MAX_NO_TILE_IDXS! (idx no:"
                      << MAX_NO_TILE_IDXS << ")\n";
          }
        }
        tile_processed_counter++;
        const unsigned long long tile_value =
            std::get<IDX_TILE_VALUE>(tile_internal);
        const bool tile_blocked = std::get<IDX_TILE_BLOCKED>(tile_internal);
        return tile_t{tile_value, tile_blocked};
      };
  std::transform(std::begin(buf), std::end(buf), std::back_inserter(result_buf),
                 prime_tile_data);
  return result_buf;
}

// TODO: Refactor and combine to one "gameboard" loader function!
std::tuple<bool, std::tuple<unsigned long long, long long>>
get_and_process_game_stats_string_data(std::istream &stats_file) {
  if (stats_file) {
    unsigned long long score;
    long long moveCount;
    for (std::string tempLine; std::getline(stats_file, tempLine);) {
      enum GameStatsFieldIndex {
        IDX_GAME_SCORE_VALUE,
        IDX_GAME_MOVECOUNT,
        MAX_NO_GAME_STATS_IDXS
      };
      std::istringstream line(tempLine);
      auto idx_id{0};
      for (std::string temp; std::getline(line, temp, ':'); idx_id++) {
        switch (idx_id) {
        case IDX_GAME_SCORE_VALUE:
          score = std::stoi(temp);
          break;
        case IDX_GAME_MOVECOUNT:
          moveCount = std::stoi(temp) - 1;
          break;
        default:
          // Error: No fields to process!
          break;
        }
      }
    }
    return std::make_tuple(true, std::make_tuple(score, moveCount));
  }
  return std::make_tuple(false, std::make_tuple(0, 0));
}

} // namespace

load_gameboard_status_t load_GameBoard_data_from_file(std::string filename) {
  std::ifstream stateFile(filename);
  if (stateFile) {
    const ull savedBoardPlaySize = GetLines(filename);
    const auto file_tile_data = get_file_tile_data(stateFile);
    const auto processed_tile_data =
        process_file_tile_string_data(file_tile_data);
    return std::make_tuple(true,
                           GameBoard(savedBoardPlaySize, processed_tile_data));
  }
  return std::make_tuple(false, GameBoard{});
}

// Output: [loadfile_ok_status, gameboard.score, gameboard.moveCount]
std::tuple<bool, std::tuple<unsigned long long, long long>>
load_game_stats_from_file(std::string filename) {
  std::ifstream stats(filename);
  return get_and_process_game_stats_string_data(stats);
}

/**
 * @brief Loads game data from a specified file into a GameBoard object.
 *
 * This function opens a file specified by the given filename, reads the game board data,
 * and initializes a GameBoard object with the read data. It first counts the number of lines 
 * until a line containing '[' is found to determine the size of the game board. Then, it reads
 * the tile data from the file, processes it, and updates the GameBoard object. Finally, it reads
 * the score and move count from the last relevant line containing these values.
 *
 * @param fileName The name of the file from which to read the game data.
 * @param gb The GameBoard object to be initialized with the read data.
 * @return true if the game data was successfully loaded; false otherwise.
 */
bool load_game(std::string fileName, GameBoard& gb)
{
  std::ifstream stateFile(fileName);
  if(!stateFile.is_open())
  {
    std::cerr << "Cannot open the file: " << fileName << std::endl;
    return false;
  }

  const ull savedBoardPlaySize = GetLines(fileName);
  const auto file_tile_data = get_file_tile_data(stateFile);
  const auto processed_tile_data = process_file_tile_string_data(file_tile_data);

  gb = GameBoard(savedBoardPlaySize, processed_tile_data);

  stateFile.clear();
  stateFile.seekg(0, std::ios::beg);

  std::string current_line;
  std::string last_line;

  while (std::getline(stateFile, current_line))
  {
    if (!current_line.empty() && current_line.front() == '[')
    {
      last_line = current_line;
      break;
    }
  }

  size_t opening_square_bracket = last_line.find('[');
  size_t colon = last_line.find(':');
  size_t closing_square_bracket = last_line.find(']');

  if (opening_square_bracket != std::string::npos && colon != std::string::npos && closing_square_bracket != std::string::npos)
  {
    std::string score = last_line.substr(opening_square_bracket + 1, colon - opening_square_bracket - 1);
    std::string moveCount = last_line.substr(colon + 1, closing_square_bracket - colon - 1);
    gb.score = std::stoull(score);
    gb.moveCount = std::stoll(moveCount) - 1;
  }

  return true;
}

} // namespace Loader

} // namespace Game

```

`src/menu-graphics.cpp`:

```cpp
#include "menu-graphics.hpp"
#include "color.hpp"
#include "global.hpp"
#include <sstream>

namespace Game {
namespace Graphics {
namespace Menu {

std::string MainMenuTitlePrompt() {
  constexpr auto greetings_text = "Welcome to ";
  constexpr auto gamename_text = "2048!";
  constexpr auto sp = "  ";

  std::ostringstream str_os;
  std::ostringstream title_richtext;
  title_richtext << bold_on << sp << greetings_text << blue << gamename_text
                 << def << bold_off << "\n";

  str_os << title_richtext.str();
  return str_os.str();
}

std::string MainMenuOptionsPrompt() {
  const auto menu_list_txt = {"1. Play a New Game", "2. Continue Previous Game",
                              "3. View Highscores and Statistics", "4. Exit"};
  constexpr auto sp = "        ";

  std::ostringstream str_os;

  str_os << "\n";
  for (const auto txt : menu_list_txt) {
    str_os << sp << txt << "\n";
  }
  str_os << "\n";

  return str_os.str();
}

std::string InputMenuErrorInvalidInputPrompt() {
  constexpr auto err_input_text = "Invalid input. Please try again.";
  constexpr auto sp = "  ";

  std::ostringstream str_os;
  std::ostringstream err_input_richtext;
  err_input_richtext << red << sp << err_input_text << def << "\n\n";

  str_os << err_input_richtext.str();
  return str_os.str();
}

std::string InputMenuPrompt() {
  constexpr auto prompt_choice_text = "Enter Choice: ";
  constexpr auto sp = "  ";

  std::ostringstream str_os;
  std::ostringstream prompt_choice_richtext;

  prompt_choice_richtext << sp << prompt_choice_text;

  str_os << prompt_choice_richtext.str();

  return str_os.str();
}

std::string MainMenuGraphicsOverlay(bool input_error_choice_invalid) {
  std::ostringstream str_os;
  DrawAlways(str_os, MainMenuTitlePrompt);
  DrawAlways(str_os, MainMenuOptionsPrompt);
  // Only outputs if there is an input error...
  DrawOnlyWhen(str_os, input_error_choice_invalid,
               InputMenuErrorInvalidInputPrompt);
  DrawAlways(str_os, InputMenuPrompt);
  return str_os.str();
}

} // namespace Menu
} // namespace Graphics
} // namespace Game

```

`src/menu.cpp`:

```cpp
#include "menu.hpp"
#include "color.hpp"
#include "game-graphics.hpp"
#include "game.hpp"
#include "gameboard.hpp" // To iterate over all saved Games
#include "global.hpp"
#include "menu-graphics.hpp"
#include "scores-graphics.hpp"
#include "scores.hpp"
#include "statistics-graphics.hpp"
#include "statistics.hpp"
#include <algorithm>
#include <array>
#include <iostream>
#include <sstream>
#include <vector>
#include <filesystem> //To use std::filestream

mainmenustatus_t mainmenustatus{};

/**
 * @brief Lists all saved game states in the specified directory.
 * 
 * This function scans the specified directory for regular files and returns their names
 * as a list of strings. It checks if the directory exists before attempting to list the files.
 * 
 * @param directory The directory to search for saved game state files.
 * @return std::vector<std::string> A vector containing the names of the saved game state files.
 */
std::vector<std::string> listSavedGameStates(const std::string& directory)
{
  std::vector<std::string> gameStates;

  if(!std::filesystem::exists(directory))
  {
    std::cout << "Directory does not exists." << std::endl;
    return gameStates;
  }

  for(auto& data : std::filesystem::directory_iterator(directory))
  {
    if(data.is_regular_file())
    {
      gameStates.push_back(data.path().filename().string());
    }
  }

  return gameStates;
}

/**
 * @brief Prompts the user to choose a game state from a list.
 * 
 * This function displays the available game states and prompts the user to select one.
 * If no game states are found, or if the user's choice is invalid, appropriate messages are displayed.
 * 
 * @param gamestate A vector containing the names of available game states.
 * @return std::string The name of the chosen game state, or an empty string if the choice is invalid.
 */
std::string chooseGameState(const std::vector<std::string>& gamestate)
{
  if(gamestate.empty())
  {
    std::cout << "No saved games found." << std::endl;
    return "";
  }

  std::cout << "Saved games are:" << std::endl;
  for (std::size_t i = 0; i < gamestate.size(); i++)
  {
    std::cout << i + 1 << ". " << gamestate[i] << std::endl;
  }

  unsigned int index;
  std::cout << "Choose game state:" << std::endl;
  std::cout << std::endl;
  std::cin >> index;

  if(index < 1 || index > gamestate.size())
  {
    std::cout << "Invalid choice." << std::endl;
    return "";
  }

  return gamestate[index - 1];
}

namespace {

bool FlagInputErrornousChoice{};

void startGame() {
  Game::startGame();
}

/**
 * @brief Continues a previously saved game.
 * 
 * This function prompts the user to choose a saved game state from a specified directory.
 * If a valid saved game state is selected, it continues the game using that state.
 * If no valid saved game state is selected, it notifies the user that the file is empty.
 * 
 * @note Changes in the new version:
 * - Added functionality to list and choose a saved game state from the specified directory.
 * - Validates the chosen game state file and continues the game using the selected file.
 * - Prints a message if the selected file is empty.
 */
void continueGame()
{
  std::string directory_state = "../data/SavedGameFiles/";
  std::string file_gb_state = chooseGameState(listSavedGameStates(directory_state));
  if (!file_gb_state.empty())
  {
    Game::continueGame(directory_state + file_gb_state);
  }
  else
  {
    std::cout << "The file is empty" << std::endl;
  }
}

Scoreboard::Graphics::scoreboard_display_data_list_t
make_scoreboard_display_data_list() {
  using namespace Scoreboard::Graphics;
  auto scoreList = Scoreboard::Scoreboard_t{};
  // bool loaded_scorelist;
  // Warning: Does not care if file exists or not!
  std::tie(std::ignore, scoreList) =
      Scoreboard::loadFromFileScore("../data/scores.txt");

  auto counter{1};
  const auto convert_to_display_list_t = [&counter](const Scoreboard::Score s) {
    const auto data_stats = std::make_tuple(
        std::to_string(counter), s.name, std::to_string(s.score),
        s.win ? "Yes" : "No", std::to_string(s.moveCount),
        std::to_string(s.largestTile), secondsFormat(s.duration));
    counter++;
    return data_stats;
  };

  auto scoreboard_display_list = scoreboard_display_data_list_t{};
  std::transform(std::begin(scoreList), std::end(scoreList),
                 std::back_inserter(scoreboard_display_list),
                 convert_to_display_list_t);
  return scoreboard_display_list;
};

Statistics::Graphics::total_stats_display_data_t
make_total_stats_display_data() {
  Statistics::total_game_stats_t stats;
  bool stats_file_loaded{};
  std::tie(stats_file_loaded, stats) =
      Statistics::loadFromFileStatistics("../data/statistics.txt");

  const auto tsdd = std::make_tuple(
      stats_file_loaded, std::to_string(stats.bestScore),
      std::to_string(stats.gameCount), std::to_string(stats.winCount),
      std::to_string(stats.totalMoveCount), secondsFormat(stats.totalDuration));
  return tsdd;
};

void showScores() {
  using namespace Game::Graphics;
  using namespace Scoreboard::Graphics;
  using namespace Statistics::Graphics;
  const auto sbddl = make_scoreboard_display_data_list();
  const auto tsdd = make_total_stats_display_data();

  clearScreen();
  DrawAlways(std::cout, AsciiArt2048);
  DrawAlways(std::cout, DataSuppliment(sbddl, ScoreboardOverlay));
  DrawAlways(std::cout, DataSuppliment(tsdd, TotalStatisticsOverlay));
  std::cout << std::flush;
  pause_for_keypress();
  ::Menu::startMenu();
}

void receive_input_flags(std::istream &in_os) {
  // Reset ErrornousChoice flag...
  FlagInputErrornousChoice = bool{};
  char c;
  in_os >> c;

  switch (c) {
  case '1':
    mainmenustatus[FLAG_START_GAME] = true;
    break;
  case '2':
    mainmenustatus[FLAG_CONTINUE_GAME] = true;
    break;
  case '3':
    mainmenustatus[FLAG_DISPLAY_HIGHSCORES] = true;
    break;
  case '4':
    mainmenustatus[FLAG_EXIT_GAME] = true;
    break;
  default:
    FlagInputErrornousChoice = true;
    break;
  }
}

void process_MainMenu() {
  if (mainmenustatus[FLAG_START_GAME]) {
    startGame();
  }
  if (mainmenustatus[FLAG_CONTINUE_GAME]) {
    continueGame();
  }
  if (mainmenustatus[FLAG_DISPLAY_HIGHSCORES]) {
    showScores();
  }
  if (mainmenustatus[FLAG_EXIT_GAME]) {
    exit(EXIT_SUCCESS);
  }
}

bool soloLoop() {
  // No choice in Menu selected, reset all flags...
  mainmenustatus = mainmenustatus_t{};
  clearScreen();
  DrawAlways(std::cout, Game::Graphics::AsciiArt2048);
  DrawAlways(std::cout,
             DataSuppliment(FlagInputErrornousChoice,
                            Game::Graphics::Menu::MainMenuGraphicsOverlay));
  receive_input_flags(std::cin);
  process_MainMenu();
  return FlagInputErrornousChoice;
}

/**
 * @brief Runs the endless loop until the game is exited.
 * 
 * This function continuously runs the solo game loop until the exit flag is set in the main menu status.
 * Initially, it sets the start menu flag to display the menu. If the start menu flag is set, it calls the solo loop
 * function to handle the menu interactions.
 * 
 * @note Changes in the new version:
 * - Added a condition to exit the loop when the exit flag is set in the main menu status.
 * - Integrated the menu start state and menu interaction within the loop.
 */
void endlessLoop() {
  // As long as the exit option is not selected in the menu
  while (!mainmenustatus[FLAG_EXIT_GAME])
  {
    // Initial state is Menu
    mainmenustatus[FLAG_START_MENU] = true;
    // If the menu flag is set, we enter...
    if (mainmenustatus[FLAG_START_MENU] == true)    
    {
      // ... the soloLoop() function, where we navigate the menu
      soloLoop();                         
    }                                               
  }
}

} // namespace

namespace Menu {

void startMenu() {
  endlessLoop();
}

} // namespace Menu

```

`src/saveresource.cpp`:

```cpp
#include "saveresource.hpp"
#include "gameboard.hpp"
#include <fstream>
#include <filesystem>

namespace Game {
namespace Saver {
namespace {


/**
 * @brief Generates a file from the previous game's statistics data.
 * 
 * This function writes the score and move count of the given game board to the provided output stream.
 * The data is formatted as "score:moveCount]" to indicate the end of the statistics data.
 * 
 * @param os The output stream where the statistics data will be written.
 * @param gb The game board containing the statistics to be saved.
 * @return bool Returns true after successfully writing the statistics data.
 * 
 * @note The ']' character is used to signify the end of the statistics data.
 */
bool generateFilefromPreviousGameStatisticsData(std::ostream &os,
                                                const GameBoard &gb) {
  os << gb.score << ":" << MoveCountOnGameBoard(gb) << "]" << std::endl;
  return true;
}

/**
 * @brief Generates a file from the previous game's state data.
 * 
 * This function writes the state of the given game board to the provided output stream.
 * The data is formatted using the printStateOfGameBoard function.
 * 
 * @param os The output stream where the state data will be written.
 * @param gb The game board containing the state to be saved.
 * @return bool Returns true after successfully writing the state data.
 */
bool generateFilefromPreviousGameStateData(std::ostream &os,
                                           const GameBoard &gb) {
  os << printStateOfGameBoard(gb);
  return true;
}

/**
 * @brief Saves the previous game state and statistics to a file.
 * 
 * This function creates or appends to a file specified by the filename, saving both the game state and statistics.
 * The game state is written first, followed by the game statistics.
 * 
 * @param filename The name of the file where the game state and statistics will be saved.
 * @param gb The game board containing the state and statistics to be saved.
 */
void saveToFilePreviousGameStateData(std::string filename,
                                     const GameBoard &gb) {
  std::ofstream stateFile(filename, std::ios_base::app);
  generateFilefromPreviousGameStateData(stateFile, gb);
  generateFilefromPreviousGameStatisticsData(stateFile, gb);

}

// This function can be deleted because it is no longer needed.
// The functionality to save game statistics has been integrated
// into the saveToFilePreviousGameStateData function, making this
// function redundant.
/*void saveToFilePreviousGameStatisticsData(std::string filename,
                                          const GameBoard &gb) {
  std::ofstream stats(filename, std::ios_base::app);
  generateFilefromPreviousGameStatisticsData(stats, gb);
}*/

} // namespace

/**
 * @brief Saves the current game state to a file.
 * 
 * This function checks for the existence of the directory and creates it if necessary.
 * It then removes any existing file with the specified filename before saving the 
 * current state and statistics of the provided game board to a new file. This ensures 
 * that only the most recent game state is saved.
 * 
 * @param gb The game board object containing the current state to be saved.
 * @param filename The name of the file where the game state will be saved. This file will
 *                 be located in the ../data/SavedGameFiles/ directory. If a file with this
 *                 name already exists, it will be deleted before saving the new state.
 * 
 * @note If the directory does not exist, it will be created. Ensure that the application
 *       has the necessary permissions to write to the specified location.
 */
void saveGamePlayState(GameBoard gb, const std::string& filename) {
  std::filesystem::path directory_path = "../data/SavedGameFiles/";

  if (!std::filesystem::exists(directory_path))
  {
    std::filesystem::create_directories(directory_path);
  }

  const auto path_to_file_gd_state = "../data/SavedGameFiles/" + filename;
  std::remove(path_to_file_gd_state.c_str());

  saveToFilePreviousGameStateData(path_to_file_gd_state, gb);
}

} // namespace Saver
} // namespace Game

```

`src/scores-graphics.cpp`:

```cpp
#include "scores-graphics.hpp"
#include "color.hpp"
#include <array>
#include <iomanip>
#include <sstream>

namespace Scoreboard {
namespace Graphics {

std::string ScoreboardOverlay(scoreboard_display_data_list_t sbddl) {
  constexpr auto no_save_text = "No saved scores.";
  const auto score_attributes_text = {
      "No.", "Name", "Score", "Won?", "Moves", "Largest Tile", "Duration"};
  //  constexpr auto num_of_score_attributes_text = 7;
  constexpr auto header_border_text =
      "┌─────┬────────────────────┬──────────┬──────┬───────┬──────────────┬──────────────┐";
  constexpr auto mid_border_text =
      "├─────┼────────────────────┼──────────┼──────┼───────┼──────────────┼──────────────┤";
  constexpr auto bottom_border_text =
      "└─────┴────────────────────┴──────────┴──────┴───────┴──────────────┴──────────────┘";
  constexpr auto score_title_text = "SCOREBOARD";
  constexpr auto divider_text = "──────────";
  constexpr auto sp = "  ";

  std::ostringstream str_os;

  str_os << green << bold_on << sp << score_title_text << bold_off << def
         << "\n";
  str_os << green << bold_on << sp << divider_text << bold_off << def << "\n";

  const auto number_of_scores = sbddl.size();
  if (number_of_scores) {
    str_os << sp << header_border_text << "\n";
    str_os << std::left;
    str_os << sp << "│ " << bold_on << std::begin(score_attributes_text)[0]
           << bold_off << " │ " << bold_on << std::setw(18)
           << std::begin(score_attributes_text)[1] << bold_off << " │ "
           << bold_on << std::setw(8) << std::begin(score_attributes_text)[2]
           << bold_off << " │ " << bold_on
           << std::begin(score_attributes_text)[3] << bold_off << " │ "
           << bold_on << std::begin(score_attributes_text)[4] << bold_off
           << " │ " << bold_on << std::begin(score_attributes_text)[5]
           << bold_off << " │ " << bold_on << std::setw(12)
           << std::begin(score_attributes_text)[6] << bold_off << " │"
           << "\n";
    str_os << std::right;
    str_os << sp << mid_border_text << "\n";

    const auto print_score_stat = [&](const scoreboard_display_data_t i) {
      str_os << sp << "│ " << std::setw(2) << std::get<0>(i) << ". │ "
             << std::left << std::setw(18) << std::get<1>(i) << std::right
             << " │ " << std::setw(8) << std::get<2>(i) << " │ " << std::setw(4)
             << std::get<3>(i) << " │ " << std::setw(5) << std::get<4>(i)
             << " │ " << std::setw(12) << std::get<5>(i) << " │ "
             << std::setw(12) << std::get<6>(i) << " │"
             << "\n";
    };

    // Use reference to avoid unnecessary copying of complex structures
    for (const auto& s : sbddl) {
      print_score_stat(s);
    }
    str_os << sp << bottom_border_text << "\n";
  } else {
    str_os << sp << no_save_text << "\n";
  }
  str_os << "\n\n";
  return str_os.str();
}

std::string EndGameStatisticsPrompt(finalscore_display_data_t finalscore) {
  std::ostringstream str_os;
  constexpr auto stats_title_text = "STATISTICS";
  constexpr auto divider_text = "──────────";
  constexpr auto sp = "  ";
  const auto stats_attributes_text = {
      "Final score:", "Largest Tile:", "Number of moves:", "Time taken:"};
  enum FinalScoreDisplayDataFields {
    IDX_FINAL_SCORE_VALUE,
    IDX_LARGEST_TILE,
    IDX_MOVE_COUNT,
    IDX_DURATION,
    MAX_NUM_OF_FINALSCOREDISPLAYDATA_INDEXES
  };
  const auto data_stats =
      std::array<std::string, MAX_NUM_OF_FINALSCOREDISPLAYDATA_INDEXES>{
          std::get<IDX_FINAL_SCORE_VALUE>(finalscore),
          std::get<IDX_LARGEST_TILE>(finalscore),
          std::get<IDX_MOVE_COUNT>(finalscore),
          std::get<IDX_DURATION>(finalscore)};

  std::ostringstream stats_richtext;
  stats_richtext << yellow << sp << stats_title_text << def << "\n";
  stats_richtext << yellow << sp << divider_text << def << "\n";

  auto counter{0};
  const auto populate_stats_info = [=, &counter,
                                    &stats_richtext](const std::string) {
    stats_richtext << sp << std::left << std::setw(19)
                   << std::begin(stats_attributes_text)[counter] << bold_on
                   << std::begin(data_stats)[counter] << bold_off << "\n";
    counter++;
  };

  for (const auto s : stats_attributes_text) {
    populate_stats_info(s);
  }

  str_os << stats_richtext.str();
  str_os << "\n\n";
  return str_os.str();
}

} // namespace Graphics

} // namespace Scoreboard

```

`src/scores.cpp`:

```cpp
#include "scores.hpp"
#include "color.hpp"
#include <algorithm>
#include <array>
#include <fstream>
#include <sstream>

namespace {
using namespace Scoreboard;
bool generateFilefromScoreData(std::ostream &os, Score score) {
  os << score;
  return true;
}

Scoreboard_t generateScorefromFileData(std::istream &is) {
  Score tempscore{};
  Scoreboard_t scoreList{};
  while (is >> tempscore) {
    scoreList.push_back(tempscore);
  };
  return scoreList;
}

bool saveToFileScore(std::string filename, Score s) {
  std::ofstream os(filename, std::ios_base::app);
  return generateFilefromScoreData(os, s);
}

} // namespace

namespace Scoreboard {
bool operator>(const Score &a, const Score &b) {
  return a.score > b.score;
}

load_score_status_t loadFromFileScore(std::string filename) {
  std::ifstream scores(filename);
  if (scores) {
    Scoreboard_t scoreList = generateScorefromFileData(scores);
    std::sort(std::begin(scoreList), std::end(scoreList),
              std::greater<Score>{});
    return load_score_status_t{true, scoreList};
  }
  return load_score_status_t{false, Scoreboard_t{}};
}

void saveScore(Score finalscore) {
  saveToFileScore("../data/scores.txt", finalscore);
}

} // namespace Scoreboard

using namespace Scoreboard;

std::istream &operator>>(std::istream &is, Score &s) {
  is >> s.name >> s.score >> s.win >> s.moveCount >> s.largestTile >>
      s.duration;
  return is;
}

std::ostream &operator<<(std::ostream &os, Score &s) {
  os << "\n"
     << s.name << " " << s.score << " " << s.win << " " << s.moveCount << " "
     << s.largestTile << " " << s.duration;
  return os;
}

```

`src/statistics-graphics.cpp`:

```cpp
#include "statistics-graphics.hpp"
#include "color.hpp"
#include <array>
#include <iomanip>
#include <sstream>

namespace Statistics {
namespace Graphics {

std::string AskForPlayerNamePrompt() {
  constexpr auto score_prompt_text =
      "Please enter your name to save this score: ";
  constexpr auto sp = "  ";
  std::ostringstream score_prompt_richtext;
  score_prompt_richtext << bold_on << sp << score_prompt_text << bold_off;
  return score_prompt_richtext.str();
}

std::string MessageScoreSavedPrompt() {
  constexpr auto score_saved_text = "Score saved!";
  constexpr auto sp = "  ";
  std::ostringstream score_saved_richtext;
  score_saved_richtext << "\n"
                       << green << bold_on << sp << score_saved_text << bold_off
                       << def << "\n";
  return score_saved_richtext.str();
}

std::string TotalStatisticsOverlay(total_stats_display_data_t tsdd) {
  constexpr auto stats_title_text = "STATISTICS";
  constexpr auto divider_text = "──────────";
  constexpr auto header_border_text = "┌────────────────────┬─────────────┐";
  constexpr auto footer_border_text = "└────────────────────┴─────────────┘";
  const auto stats_attributes_text = {"Best Score", "Game Count",
                                      "Number of Wins", "Total Moves Played",
                                      "Total Duration"};
  constexpr auto no_save_text = "No saved statistics.";
  constexpr auto any_key_exit_text =
      "Press any key to return to the main menu... ";
  constexpr auto sp = "  ";

  enum TotalStatsDisplayDataFields {
    IDX_DATA_AVAILABLE,
    IDX_BEST_SCORE,
    IDX_GAME_COUNT,
    IDX_GAME_WIN_COUNT,
    IDX_TOTAL_MOVE_COUNT,
    IDX_TOTAL_DURATION,
    MAX_TOTALSTATSDISPLAYDATA_INDEXES
  };

  std::ostringstream stats_richtext;

  const auto stats_file_loaded = std::get<IDX_DATA_AVAILABLE>(tsdd);
  if (stats_file_loaded) {
    constexpr auto num_of_stats_attributes_text = 5;
    auto data_stats = std::array<std::string, num_of_stats_attributes_text>{};
    data_stats = {std::get<IDX_BEST_SCORE>(tsdd),
                  std::get<IDX_GAME_COUNT>(tsdd),
                  std::get<IDX_GAME_WIN_COUNT>(tsdd),
                  std::get<IDX_TOTAL_MOVE_COUNT>(tsdd),
                  std::get<IDX_TOTAL_DURATION>(tsdd)};

    auto counter{0};
    const auto populate_stats_info = [=, &counter,
                                      &stats_richtext](const std::string) {
      stats_richtext << sp << "│ " << bold_on << std::left << std::setw(18)
                     << std::begin(stats_attributes_text)[counter] << bold_off
                     << " │ " << std::right << std::setw(11)
                     << data_stats[counter] << " │"
                     << "\n";
      counter++;
    };

    stats_richtext << green << bold_on << sp << stats_title_text << bold_off
                   << def << "\n";
    stats_richtext << green << bold_on << sp << divider_text << bold_off << def
                   << "\n";
    stats_richtext << sp << header_border_text << "\n";

    for (const auto s : stats_attributes_text) {
      populate_stats_info(s);
    }
    stats_richtext << sp << footer_border_text << "\n";

  } else {
    stats_richtext << sp << no_save_text << "\n";
  }

  stats_richtext << "\n\n\n";
  stats_richtext << sp << any_key_exit_text;

  return stats_richtext.str();
}

} // namespace Graphics
} // namespace Statistics

```

`src/statistics.cpp`:

```cpp
#include "statistics.hpp"
#include "color.hpp"
#include "scores-graphics.hpp"
#include "scores.hpp"
#include "statistics-graphics.hpp"
#include <algorithm>
#include <array>
#include <fstream>
#include <sstream>

namespace Statistics {

namespace {

std::string receive_input_player_name(std::istream &is) {
  std::string name;
  is >> name;
  return name;
}

total_game_stats_t generateStatsFromInputData(std::istream &is) {
  total_game_stats_t stats;
  is >> stats;
  return stats;
}

bool generateFilefromStatsData(std::ostream &os, total_game_stats_t stats) {
  os << stats;
  return true;
}

bool saveToFileEndGameStatistics(std::string filename, total_game_stats_t s) {
  std::ofstream filedata(filename);
  return generateFilefromStatsData(filedata, s);
}

Scoreboard::Graphics::finalscore_display_data_t
make_finalscore_display_data(Scoreboard::Score finalscore) {
  const auto fsdd = std::make_tuple(
      std::to_string(finalscore.score), std::to_string(finalscore.largestTile),
      std::to_string(finalscore.moveCount), secondsFormat(finalscore.duration));
  return fsdd;
};

} // namespace

load_stats_status_t loadFromFileStatistics(std::string filename) {
  std::ifstream statistics(filename);
  if (statistics) {
    total_game_stats_t stats = generateStatsFromInputData(statistics);
    return load_stats_status_t{true, stats};
  }
  return load_stats_status_t{false, total_game_stats_t{}};
}

ull load_game_best_score() {
  total_game_stats_t stats;
  bool stats_file_loaded{};
  ull tempscore{0};
  std::tie(stats_file_loaded, stats) =
      loadFromFileStatistics("../data/statistics.txt");
  if (stats_file_loaded) {
    tempscore = stats.bestScore;
  }
  return tempscore;
}

void saveEndGameStats(Scoreboard::Score finalscore) {
  total_game_stats_t stats;
  // Need some sort of stats data values only.
  // No need to care if file loaded successfully or not...
  std::tie(std::ignore, stats) =
      loadFromFileStatistics("../data/statistics.txt");
  stats.bestScore =
      stats.bestScore < finalscore.score ? finalscore.score : stats.bestScore;
  stats.gameCount++;
  stats.winCount = finalscore.win ? stats.winCount + 1 : stats.winCount;
  stats.totalMoveCount += finalscore.moveCount;
  stats.totalDuration += finalscore.duration;

  saveToFileEndGameStatistics("../data/statistics.txt", stats);
}

void CreateFinalScoreAndEndGameDataFile(std::ostream &os, std::istream &is,
                                        Scoreboard::Score finalscore) {
  const auto finalscore_display_data = make_finalscore_display_data(finalscore);
  DrawAlways(os, DataSuppliment(finalscore_display_data,
                                Scoreboard::Graphics::EndGameStatisticsPrompt));

  DrawAlways(os, Graphics::AskForPlayerNamePrompt);
  const auto name = receive_input_player_name(is);
  finalscore.name = name;

  Scoreboard::saveScore(finalscore);
  saveEndGameStats(finalscore);
  DrawAlways(os, Graphics::MessageScoreSavedPrompt);
}

} // namespace Statistics

using namespace Statistics;

std::istream &operator>>(std::istream &is, total_game_stats_t &s) {
  is >> s.bestScore >> s.gameCount >> s.winCount >> s.totalMoveCount >>
      s.totalDuration;
  return is;
}

std::ostream &operator<<(std::ostream &os, total_game_stats_t &s) {
  os << s.bestScore << "\n"
     << s.gameCount << "\n"
     << s.winCount << "\n"
     << s.totalMoveCount << "\n"
     << s.totalDuration;
  return os;
}

```

`src/tile-graphics.cpp`:

```cpp
#include "tile-graphics.hpp"
#include "color.hpp"
#include "tile.hpp"
#include <cmath>
#include <iomanip>
#include <sstream>
#include <vector>

namespace Game {
namespace {

Color::Modifier tileColor(ull value) {
  std::vector<Color::Modifier> colors{red, yellow, magenta, blue, cyan, yellow,
                                      red, yellow, magenta, blue, green};
  int log = log2(value);
  int index = log < 12 ? log - 1 : 10;

  return colors[index];
}
} // namespace

std::string drawTileString(tile_t currentTile) {
  std::ostringstream tile_richtext;
  if (!currentTile.value) {
    tile_richtext << "    ";
  } else {
    tile_richtext << tileColor(currentTile.value) << bold_on << std::setw(4)
                  << currentTile.value << bold_off << def;
  }
  return tile_richtext.str();
}
} // namespace Game

```

`src/tile.cpp`:

```cpp
#include "tile.hpp"

namespace Game {} // namespace Game

```