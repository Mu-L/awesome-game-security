Project Path: arc_jcalabres_hook-updater_nb78ne9s

Source Tree:

```txt
arc_jcalabres_hook-updater_nb78ne9s
├── README.md
├── apktool.jar
├── helper.py
├── img
│   └── example1.jpg
├── logger.py
├── parser.py
├── solver.py
└── updater.py

```

`README.md`:

```md
```java
            ___  ___                   ___  ___  _   _____  __  __  
      /\  /\/___\/___\/\ /\     /\ /\  / _ \/   \/_\ /__   \/__\/__\ 
     / /_/ //  ///  // //_/____/ / \ \/ /_)/ /\ //_\\  / /\/_\ / \// 
    / __  / \_// \_// __ \_____\ \_/ / ___/ /_//  _  \/ / //__/ _  \ 
    \/ /_/\___/\___/\/  \/      \___/\/  /___,'\_/ \_/\/  \__/\/ \_/                                                     
    for Android          
```
Did you created any Frida hooks with the Java API and the app has been updated being unable to use them again? 

With this tool, you will be able to update your non-functional Frida hooks to a new ones in only a few minutes!

It's provided as a solution that intends to update hooks between the same application and slightly different versions e.g. applications with minor update differences and low/mid levels of obfuscation.

# Table of Contents
1. [Features](#features)
2. [Requirements](#requirements)
3. [Setup](#setup)
4. [Usage](#usage)
5. [Examples](#examples)
6. [How it works?](#how-it-works)
7. [Metrics](#metrics)
8. [What's next?](#whats-next)
9. [Contributing](#contributing)

# Features

* Generates an updated Frida hooks file.  
* Updates hooks of applications with low/mid levels of obfuscation. 
* All non-standard API hooks are updated.
* Compatibility with the most common OS.

# Requirements

* *Apktool*
* *Python3*

# Setup

## MacOS:
```
brew install apktool
```

## Windows:
```bash
choco install apktool
```

## Linux: 

Follow this instructions from the [apktool](https://ibotpeaches.github.io/Apktool/install/) website.

# Usage

```python
updater.py [-h] -old OLD -new NEW -hooks HOOKS -out OUT
```

# Examples

You can execute the tool with the following parameters:

```
python3 updater.py -old examples/*****/7.4.1.46567.apk -new examples/*****/7.5.0.46863.apk  -hooks examples/*****/hooks.js -out examples/*****/updated_hooks.js
```
An example of execution:

![alt text](img/example1.jpg "Title")

If the solver has found the new classes and methods, a summary with the new classes and methods will be shown.

# How it works?

The user specifies two different APKs for the same application. It also specifies the old hooks file and the new hooks file paths. Then, the solver of the tool will try to find similarities between the old smali files and the new smali files from the updated APK. 

The application uses multiple metrics and a score system to detect similarities between Java classes and Java methods that are in the Smali format.

>Smali is a languaje created for representing decompiled Android bytecodes and it can be obtained using the original [baksmali](https://github.com/JesusFreke/smali) tool or using other tools that have integrated it such as apktool or jadx.

We can summarize the behaviour of this tool in different stages.

## Stage 1 - Unpacking APKs

The application unpacks the APKs into a work directory. 

## Stage 2 - Finding the old smali files

The application find all the classes specified in the configuration file and copies all the smali files that contain these classes into a the work directory.

## Stage 3 - Finding the new smali files

The application finds similarities between the specified classes and all the smali files that are inside the new provided APK. Whenever the tool finds these classes, it will copy the smali files into the work folder. Check [Class finder metrics](#class-finder-metrics) for more information.

## Stage 4 - Finding the new methods

The application will find similarities between the specified methods and the methods inside the found smali files using multiple metrics. Check [Method-finder-metrics](#class-finder-metrics) for more information.

## Stage 5 - Solver results

The results obtained will be written into the new hook file.

# Metrics

## Class finder metrics

The metrics used to find the new classes in a smali file are:

* Number of fields.
* Similarities between fields.
* Number of methods. 
* Similarities between methods.
* Similarities between method signatures.

## Method finder metrics

* Similarities between signatures.
* Similarities between Smali lines of code.

# What's next?

* Add support to dump application's DEX files in runtime.
* Improve class finder and method finder metrics.
* Code refactoring, make clean code.

# Contributing

Pull requests and issues are welcome to this repository.
```

`helper.py`:

```py
from random import betavariate
from sys import implementation
from types import new_class

from charset_normalizer import CharsetNormalizerMatches
from sqlalchemy import false
from logger import Logger
import subprocess
import shutil
import re
import os 

class Helper:

    def __init__(self):
        self.config_w_file, self.config = {}, {}
        self.aux = Aux()
        self.work_directory = os.path.join(os.getcwd(), "work")
        self.old_apk_directory = os.path.join(self.work_directory, "old_apk")
        self.new_apk_directory = os.path.join(self.work_directory, "new_apk")
        self.old_smali_directory = os.path.join(self.work_directory, "old_smali")
        self.new_smali_directory =  os.path.join(self.work_directory, "new_smali")

    def folder_rm_exists(self, folder_path):
        if os.path.isdir(folder_path):
            shutil.rmtree(folder_path)   
        
    def gen_new_hooks(self, results, old_hooks, new_hooks):
        text_in = open(old_hooks, "r").read()
        file_out = open(new_hooks, "w")
        text_out, custom_line = "", ""
        found = False
        for line in text_in.splitlines():
            for k, v in results.items() :
                (old_class, old_method) = k
                single_quote_old_class = f"Java.use('{self.aux.smali_to_class(old_class)}')"
                double_quote_old_class = single_quote_old_class.replace("'",'"')
                if found:
                    found = False
                    break
                for values in v:
                    if "\\u" in line:
                        line = self.aux.unscape_unicode(line)
                    if "<init>" in old_method.split("(")[0]:
                        old_method = old_method.replace("<init>","$init")
                    new_class = self.aux.scape_unicode(self.aux.smali_to_class(values[0]))
                    new_method = self.aux.scape_unicode(values[1].split("(")[0])
                    if single_quote_old_class in line or double_quote_old_class in line: 
                        single_quote_new_class = f"Java.use('{new_class}')"
                        custom_line = line.split("Java.use")[0] + single_quote_new_class +";" 
                    if ".implementation" in line:
                        if "." + old_method.split("(")[0]+".overload" in line or "." + old_method.split("(")[0]+".implementation" in line:
                            args = self.aux.get_smali_args(values[1])
                            custom_line = line.split(".")[0]+"."+new_method+f".overload({args}).implementation =" +line.split("=")[-1]  
                            found = True
                            break   
                        elif f'["{old_method.split("(")[0]}"].overload' in line or f'["{old_method.split("(")[0]}"].implementation' in line:
                            args = self.aux.get_smali_args(values[1])
                            custom_line = line.split('"')[0]+'"'+self.aux.scape_unicode(old_method.split("(")[0])+'"].overload('+args+').implementation ='+line.split("=")[-1]  
                            found = True
                            break      
            if not custom_line:
                text_out += line+"\n" 
            else:
                text_out += custom_line+"\n" 
                custom_line = ""
        file_out.write(text_out)
        Logger.log(f"Created updated Frida hooks in {new_hooks}.","success")

    def get_frida_config(self, file):
        hooks = self.aux.remove_comments(open(file, "r").read())
        hooks_lines = "\n".join([ll.strip() for ll in hooks.splitlines() if ll.strip()]).splitlines()
        filter = ["android.", "java.", "javax.", "okhttp3."]
        java_use = "Java.use("
        config = {}
        Logger.log(f"Finding Frida hooks to update from {file}.","info")
        for i in range(len(hooks_lines)):
            line = hooks_lines[i]
            if java_use in line:
                match = self.aux.between_quotes(line)
                if match:
                    class_hook = match.group(0).replace('"', "").replace("'","")
                    if "\\u" in class_hook:
                        class_hook = self.aux.unscape_unicode(class_hook)
                    if class_hook !="" and not any(substring in class_hook for substring in filter): 
                        next_line = hooks_lines[i+1] 
                        args = 0   
                        if ".overload" in next_line:
                            args = len(next_line.split(".overload")[1].rsplit(".implementation")[0].split(","))
                            method_hook = next_line.rsplit(".overload")[0].split(".")[-1]
                        else:
                            args = 0
                            method_hook = next_line.rsplit(".implementation")[0].split(".")[-1]
                        match = self.aux.between_quotes(method_hook)
                        if match and match.group(0)!="":
                            method_hook = self.aux.between_quotes(method_hook).group(0).replace('"',"")
                        method_hook +="(" + str(args) + ")"
                        if "\\u" in method_hook:
                            method_hook = self.aux.unscape_unicode(method_hook)
                        if "$init(" in method_hook:
                            method_hook = f"<init>({args})"
                        Logger.log(f"Found hook with class {class_hook} and method {method_hook}.","success")
                        smali_class_hook = self.aux.class_to_smali(class_hook)
                        if smali_class_hook in config:
                            config[smali_class_hook].append(method_hook) 
                        else:
                            config[smali_class_hook] = [method_hook]
        return config

    def unpack_apks(self, old_apk_path, new_apk_path):
        Logger.log("Unpacking the old apk file.","info")
        self.folder_rm_exists(self.work_directory)
        subprocess.call(['java', '-jar', 'apktool.jar','d', old_apk_path, '-o', self.old_apk_directory, '-f'], stdout=open(os.devnull, 'w'), 
        stderr=subprocess.STDOUT)
        Logger.log("Unpacking the new apk file.","info")
        subprocess.call(['java', '-jar', 'apktool.jar','d', new_apk_path, '-o', self.new_apk_directory, '-f'], stdout=open(os.devnull, 'w'), 
        stderr=subprocess.STDOUT)

    def get_smali_config(self, hooks, old_apk, new_apk):
        self.config = self.get_frida_config(hooks)
        self.unpack_apks(old_apk, new_apk)
        self.get_old_smali()
        self.get_new_smali()
        return self.config_w_file, self.new_smali_directory

    def get_old_smali(self):
        Logger.log("Finding the old smali file.","info")
        self.folder_rm_exists(self.old_smali_directory)
        os.mkdir(self.old_smali_directory)
        for config_class, values in self.config.items():
            try:
                output = subprocess.check_output(f'grep -rin \'.class .* {config_class}\' {self.old_apk_directory}/smali*', shell=True).decode("utf-8")
                smali_file = output.split(":")[0]
                shutil.copyfile(smali_file, os.path.join(self.old_smali_directory, os.path.basename(smali_file)))
                self.config_w_file[(config_class, os.path.join(self.old_smali_directory, os.path.basename(smali_file)))] = values
                Logger.log(f"Old class {config_class} has been found in {os.path.basename(smali_file)}.","success")
            except Exception as e:
                Logger.log(f"Old class {config_class} has not been found.","error")
    
    def get_new_smali(self):
        self.folder_rm_exists(self.new_smali_directory)
        os.mkdir(self.new_smali_directory)
        Logger.log("Copying all the smali files to the work folder.","info")
        for dir in os.listdir(self.new_apk_directory):  
            if "smali" in dir:
                path_dir = os.path.join(self.new_apk_directory,dir)
                shutil.copytree(path_dir, os.path.join(self.new_smali_directory, dir), dirs_exist_ok=True)

class Aux():

    def unscape_unicode(self, in_str):
        in_str = in_str.encode('unicode-escape')   
        in_str = in_str.replace(b'\\\\u', b'\\u') 
        in_str = in_str.decode('unicode-escape') 
        return in_str

    def scape_unicode(self, string):
        string = string.encode('unicode-escape').decode("utf-8")
        return string

    def remove_comments(self, string):
        pattern = r"(\".*?\"|\'.*?\')|(/\*.*?\*/|//[^\r\n]*$)"
        regex = re.compile(pattern, re.MULTILINE|re.DOTALL)
        def _replacer(match):
            if match.group(2) is not None:
                return ""
            else: 
                return match.group(1) 
        return regex.sub(_replacer, string)

    def between_quotes(self, string):
        return re.search(r"\"([^\"\\]*(\\.[^\"\\]*)*)\"|\'([^\'\\]*(\\.[^\'\\]*)*)\'", string)

    def class_to_smali(self, class_hook):
        return "L"+class_hook.replace(".", "/")+";"

    def smali_to_class(self, string):
        return string[1:-1].replace("/",".") 

    def get_smali_args(self, string):
        if len(string.split(";"))>1:
            args = ""
            for arg in string.split("(")[1].split(")")[0].split(";"):
                arg = arg.replace("/",".").replace(";",",")
                if arg != "":
                    if arg[:2].isupper():
                        arg = arg[2:]
                    elif arg[:1].isupper:
                        arg = arg[1:]
                    args+='"'+arg+'"'+", "
            return args.strip(", ")
        else:
            return ""
```

`logger.py`:

```py
HEADER = '\033[93m'
INFO = '\033[96m'
SUCCESS = '\033[92m'
SPECIAL = '\033[95m'
FAIL = '\033[91m'
BOLD = '\033[1m'
END = '\033[0m'

class Logger():

    def log(msg, type):
        if type == "info":
            print(BOLD + INFO + "[*] " + msg + END)
        elif type == "success":
            print(BOLD + SUCCESS + "[+] " + msg + END)
        elif type == "error":
             print(BOLD + FAIL + "[-] " + msg + END)
        elif type == "summary":
             print(BOLD + SPECIAL + "[~] " + msg + END)
        elif type == "header":
            print(BOLD + HEADER + msg + END)
```

`parser.py`:

```py
class Parser():
     
    def get_class(self, file):
        return open(file, "r").readline().split(" ")[-1][0:-1]

    def get_fields(self, file):
        lines = open(file, "r").readlines()
        fields = []
        for line in lines:
            if ".field" in line:
                fields.append(line)
            if ".method" in line:
                break
        return fields

    def get_methods(self, file):
        lines = open(file, "r").readlines()
        methods = []
        method_txt = ""
        add = False
        for line in lines:
            if ".method" in line:
                add = True 
            elif add and ".end method" in line:
                add = False
                methods.append(method_txt)
                method_txt = ""
            if add:
                method_txt += line
        return methods

    def get_signatures(self, methods):
        signatures = []
        for method in methods:
            signature = method.splitlines()[0]
            signatures.append(signature)
        return signatures

    def find_method_by_signature(self, method, file):
        lines = open(file, "r").readlines()
        add = False
        method_txt = ""
        for line in lines:
            if method in line:   
                add = True
            elif add and ".end method" in line:
                add = False
                method_txt += line       
            if add and line != '\n':
                method_txt += line
        return method_txt
```

`solver.py`:

```py
from logger import Logger
from parser import Parser
import os 

class Solver:

    def __init__(self):
        self.parser = Parser()
        self.weight_number_fields = 25
        self.weight_number_methods = 25
        self.weight_fields = 50
        self.weight_methods = 50
        self.weight_signature = 25

    def solve(self, config_w_file, new_smali_path):
        if config_w_file:
            Logger.log("Starting the solver...", "info")
            found = {}
            for key, signatures in config_w_file.items():
                (old_class, old_smali) = key 
                new_smali = self.find_smali(old_smali, new_smali_path)
                if new_smali == "":
                    Logger.log(f"New smali file not found for class {old_class}", "error")
                    break
                class_name = self.parser.get_class(new_smali)
                if  new_smali != "":   
                    Logger.log(f"New class {class_name} has been found in {os.path.basename(new_smali)}.", "success")
                    for signature in signatures:
                        old_method = self.parser.find_method_by_signature(signature.split('(')[0], old_smali)
                        new_method = self.find_method(old_method, new_smali, signature) 
                        if  new_method != "":   
                            Logger.log(f"Old method partial signature {signature} has been found as {new_method}.", "success")
                            self.print_summary(old_class, old_smali, class_name, signature, new_smali, new_method)
                            if old_class in found:
                                found[(old_class, signature)].append([class_name, new_method])
                            else:
                                found[(old_class, signature)] = [[class_name, new_method]]
                        else:
                            Logger.log(f"Old method partial signature {signature} has not been found.", "error")
                else:
                    Logger.log(f"New class has not been found.", "error")
        else:
            Logger.log(f"Old classes have been not found. Aborting...", "error")
        return found
        
    def find_method(self, old_method, new_smali, signature):
        new_methods = self.parser.get_methods(new_smali)
        new_signatures = self.parser.get_signatures(new_methods)
        found_signature, last_score = "", 0
        for new_signature in new_signatures:
            signature_name = signature.split("(")[0]
            args_signature = int(signature.split("(")[1].split(")")[0])
            if args_signature == 0 and signature_name+"(" in new_signature:
                found_signature = new_signature.split(' ')[-1]
                return found_signature
            elif args_signature>0 and args_signature==len(new_signature.split(";"))-1:
                if signature_name+"(" in new_signature:
                    found_signature = new_signature.split(' ')[-1]
                    return found_signature         
        if found_signature == "":
            for new_method in new_methods:
                score = self.eval_smali(old_method, new_method)
                if last_score == 0 or score >= last_score:
                    found_signature = self.parser.get_signatures([new_method])[0].split(" ")[-1]
                    last_score = score
        return found_signature

    def find_smali(self, old_smali, new_smali_path):
        smali_found, last_score = "", 0
        old_fields = self.parser.get_fields(old_smali)
        old_methods = self.parser.get_methods(old_smali)
        for dirpath, dirname, files in os.walk(new_smali_path): 
            for smali in files:
                new_methods = self.parser.get_methods(os.path.join(dirpath,smali))
                score = self.eval_fields(old_fields, self.parser.get_fields(os.path.join(dirpath,smali)))
                score += self.eval_methods(old_methods, new_methods)
                score += self.eval_signatures(self.parser.get_signatures(old_methods), self.parser.get_signatures(new_methods))
                if last_score == 0 or score >= last_score:
                    smali_found = os.path.join(dirpath,smali) 
                    last_score = score
        return smali_found
        
    def eval_fields(self, old_fields, new_fields):
        score, fields_found = 0, 0
        if len(old_fields)==len(new_fields):
            score+=self.weight_number_fields
        for field in old_fields: 
            if field in new_fields:
                fields_found+=1
        if len(new_fields) !=0:
            score += (fields_found*self.weight_fields)/(len(new_fields))
        return int(score)

    def eval_methods(self, old_methods, new_methods):
        score, methods_found = 0, 0
        if len(old_methods)==len(new_methods):
            score+=self.weight_number_methods
        for method in old_methods: 
            if method in new_methods:
                methods_found+=1
        if len(new_methods) !=0:
            score += (methods_found*self.weight_methods)/(len(new_methods))
        return int(score)

    def eval_signatures(self, old_signatures, new_signatures):
        score, signatures_found = 0, 0
        for signature in old_signatures: 
            if signature in new_signatures:
                signatures_found+=1
        if len(new_signatures) !=0:
            score += (signatures_found*self.weight_methods)/(len(new_signatures))
        return int(score)

    def eval_smali(self, old_method, new_method):
        score, lines_found = 0, 0
        lines = old_method.split("\n")
        for line in lines:
            if line in new_method.split("\n"):
                lines_found += 1    
        score = (lines_found*100)/(len(lines))
        return int(score)
    
    def print_summary(self, old_class, old_smali, class_name, signature, new_smali, new_method):
        Logger.log(f"Class: {old_class} --> {class_name}","summary")
        Logger.log(f"Method: {signature}* --> {new_method}","summary")
        Logger.log(f"File: {old_smali} --> {new_smali}","summary")
```

`updater.py`:

```py
import argparse
from logger import Logger
from helper import Helper
from solver import Solver

LOGO = """
         ___  ___                   ___  ___  _   _____  __  __  
  /\  /\/___\/___\/\ /\     /\ /\  / _ \/   \/_\ /__   \/__\/__\ 
 / /_/ //  ///  // //_/____/ / \ \/ /_)/ /\ //_\\  / /\/_\ / \// 
/ __  / \_// \_// __ \_____\ \_/ / ___/ /_//  _  \/ / //__/ _  \ 
\/ /_/\___/\___/\/  \/      \___/\/  /___,'\_/ \_/\/  \__/\/ \_/                                                               
"""

def parse_args():
    parser = argparse.ArgumentParser(description='Hook updater!')
    parser.add_argument('-old', help='Outdated Old .apk file.', required=True),
    parser.add_argument('-new', help='New .apk file.', required=True),
    parser.add_argument('-hooks', help='Frida hooks.', required=True)
    parser.add_argument('-out', help='New Frida hooks path.', required=True)
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_args()
    Logger.log(LOGO, "header")
    helper = Helper()
    config_w_file, smali_directory = helper.get_smali_config(args.hooks, args.old, args.new)
    
    solver = Solver()
    results = solver.solve(config_w_file, smali_directory)
    helper.gen_new_hooks(results, args.hooks, args.out)
```