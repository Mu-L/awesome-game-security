Project Path: arc_kotae4_lab-esp-and-aimbot_iv67qlo_

Source Tree:

```txt
arc_kotae4_lab-esp-and-aimbot_iv67qlo_
├── Chapter 1 - Defining Objectives & Gathering Information
│   └── README.md
├── Chapter 2 - Static Analysis - Exploring The Game's Executable File
│   └── README.md
├── Chapter 3 - Dynamic Analysis - Confirming Our Findings
│   └── README.md
├── Chapter 4 - Writing The ESP
│   ├── README.md
│   └── guide_images
│       ├── esp_nametags-boxes.png
│       └── esp_nametags.png
├── Chapter 5 - Writing The Aimbot
│   ├── README.md
│   └── guide_images
│       └── aimbot_findtarget.png
├── Chapter 6 - Conclusion
│   └── README.md
├── Complete Project Source Code
│   └── assaultcube-esp-aimbot
│       ├── assaultcube-esp-aimbot
│       │   ├── CheatMain.cpp
│       │   ├── CheatMain.h
│       │   ├── assaultcube-esp-aimbot.vcxproj
│       │   ├── assaultcube-esp-aimbot.vcxproj.filters
│       │   ├── dllmain.cpp
│       │   ├── game_definitions.h
│       │   ├── opengl_wrapper.cpp
│       │   ├── opengl_wrapper.h
│       │   ├── pch.cpp
│       │   └── pch.h
│       └── assaultcube-esp-aimbot.sln
└── README.md

```

`Chapter 1 - Defining Objectives & Gathering Information/README.md`:

```md
# Chapter 1 - Defining Objectives & Gathering Information

First step in any project is to define your goals. I like to think of the broad goals first and then break each one up into more detailed goals where applicable.

## Goals ##

1. ESP functionality
    * Box ESP (draw box around each player)
    * Name ESP (draw player names above their head)
2. Aimbot functionality
    * Aim at nearest enemy player (by distance in game world)
    * Skip players that are behind walls
3. Inject cheat into game process & execute
    * Using cheat engine's injector is fine

## Checklists ##

Aside from goals, I also like defining and keeping track of the implementation-specific details we need in order to complete the goals.<br>
I like to keep the top-level of these checklists as general as possible so they can be applied to any game cheat project.

### Rendering Checklist ###

- [x] Hook a drawing function
    * `gl_drawhud` seems like the best function to hook, contains a lot of strings to search for in disassembler
- [x] World-To-Screen (w2s)
    * `mvpmatrix` global referenced in `readmatrices()` function called by `gl_drawframe`
- [x] Box rendering (or line rendering and we'll construct our own box)
    * We found `box2d`, `box`, and `line` utility functions in rendergl.cpp, but it's easier to just write our own
- [x] Text rendering
    * `gl_drawhud` contains calls to both `draw_text` and `draw_textf`

### Data Checklist ###

- [x] Local player instance
    * `player1` and `cam1` global references found in `gl_drawhud` (and lots of other places)
- [x] Player list (including start, size, and how to iterate it if it's a complicated structure)
    * `vector` structure, global reference to `bots` found in `kickbot` (and lots of other places)
    * Use string `bot %s disconnected` to find in disassembler

### Aimbot Checklist ###

- [x] Raycast / Traceline (so you don't aim through walls)
    * `CBot::Think` is a virtual function and calls `MainAI` which calls `FindEnemy` which calls `IsVisible` which finally calls `TraceLine`
- [x] Set view angles (any method of making the player aim at our target)
    * `camera1`'s pitch and yaw can be set, which we found in `gl_drawhud`

I'll be marking the above checklists off as we go throughout the project and adding details, but I'll also provide the blank "template" checklist below so you can use them.

### (Blank) Rendering Checklist ###

- [ ] Hook a drawing function
- [ ] World-To-Screen (w2s)
- [ ] Box rendering
- [ ] Text rendering

### (Blank) Data Checklist ###

- [ ] Local player instance
- [ ] Player list (including start, size, and how to iterate it if it's a complicated structure)

### (Blank) Aimbot Checklist ###

- [ ] Raycast / Traceline (so you don't aim through walls)
- [ ] Set view angles (any method of making the player aim at our target)

Feel free to copy the blank checklists over to your own project.

## Gathering Information ##

With our goals and checklists defined, we can now begin the research phase of the project.<br>
We'll start by exploring the game's codebase since it's an open source project. This can also be done for Unity engine games built on the mono backend using an IL disassembler/decompiler as well as several other games or game engines. Access to a target's codebase, or partial codebase, is surprisingly common and helps tremendously.<br>
Assault Cube's codebase can be found here: https://github.com/assaultcube/AC/tree/v1.3.0.2

So, since our first goal is ESP functionality and we know we need to draw on the screen we can start by searching for the word "draw" in all .c/.cpp files<br>
To do so, I use notepad++ and its excellent 'Find in Files' search tool. I point it at the `/source/src` directory as that's where the core game code seems to be located.<br>
I get 239 hits in 15 files for the word "draw". We can be pretty confident that the core drawing functions aren't going to be located in a file named "botmanager.cpp" or anything like that, so we can manually filter these results pretty quickly.<br>
The first semi-interesting result I see is in the `main.cpp` file and it's a call to a `gl_drawframe` function (line 1572). I assume this call is in the main loop of the game application which would be perfect for our needs (we want to hook a draw function that gets called every frame).<br>
After looking into it I can see it is within an infinite `(for;;)` loop (lines 1522-1597) of the application's `main()` function (lines 1208-1605), so this is our first interesting function to note.<br>
I'm now interested in seeing the implementation of this function so I search for `gl_drawframe` in notepad++ (or if you open the project in an IDE you can probably just right-click -> go to definition).<br>
Looking at its implementation in `rendergl.cpp` (lines 1019-1167) I can see it does a lot of openGL state management before calling various game drawing functions, so hooking this function won't be perfectly ideal because we'd have to re-create the openGL state ourselves. That's not necessarily a deal-breaker but for now I want to look for something that already has an ideal graphics state set up.<br>
Scrolling to the bottom of the `gl_drawframe` function I can see it calls a function named `gl_drawhud` (line 1161). The HUD would be a nice place to draw some of our cheat's debug info (such as a "Hello World" message to let us know we've got everything working) and we could even implement our ESP features on the HUD but that would look kind of ugly as everything would be sized the same even if the target player is far away from our local player.<br>
Before looking at the implementation of `gl_drawhud`, I'll make note of how player models are drawn further up in this `gl_drawframe` function in case we do need to manually set up the graphics state for our ESP features.<br>
All of the glXXX calls leading up to `renderclients()` call at line 1121 are important as we can see these prepare the graphics state for drawing the players in the world. We can see how the far plane and the vertical fov is calculated, as well as how the camera is rotated in the world. We also see two very interestingly named functions: `transplayer()` and `readmatrices()` called at lines 1059 and 1060 just after the switch to GL_MODELVIEW matrix mode and before the call to `render_world` (line 1080). So we'll definitely have to investigate all of this later, but for now it's good enough just to jot them down.<br>
Looking at the implementation of `gl_drawhud` in renderhud.cpp (lines 750-1173) now I can immediately see some juicy details: 
```cpp
playerent *p = camera1->type<ENT_CAMERA ? (playerent *)camera1 : player1;
```
Two globals: `camera1` and `player1` will definitely be useful later. We can assume player1, being a global, is the local player instance which means we can check that off our checklist above.<br>

Continuing to scroll through this function we see all sorts of goodies:
* Call to `playerincrosshair()` at line 805, interesting because of its name: it might have something to do with raycast / traceline which we'll need to prevent our aimbot from locking onto targets behind walls
* `p->weaponsel` and `p->weaponsel->info.reloadtime` at line 808 which will give us our offsets to the player's current weapon and the info associated with that weapon
* `p->state==CS_ALIVE` at line 809 which gives us the offset to the 'state' of player struct and the constant denoting CS_ALIVE: this will be helpful for our aimbot as we can filter out players that aren't alive
* `targetplayer->team` at line 811 gives us the offset to the 'team' of player struct. Helpful for both our aimbot and ESP, we can now choose to lock on to only enemy players and also draw enemies and teammates using different colors.

And, another checklist item, drawing text at line 832:
```cpp
else if(infostr)
{
    glPushMatrix();
    glLoadIdentity();
    glOrtho(0, VIRTW * 2, VIRTH * 2, 0, -1, 1);
    glScalef(1.0, 1.0, 1.0); //set scale
    draw_text(infostr, 48, VIRTH * 2 - 3 * FONTH);
    glPopMatrix();
}
```
We see not only the call to `draw_text` but also exactly how the graphics state is set up for drawing text. We'll look into the draw_text implementation later to make sure it does what we expect it to do. We can also look at `VIRTW`, `VIRTH` and `FONTH` to see if those will be compiled to literals or global references in assembly.<br>
Just below that, around line 864 we start to see more strings too, and at line 884 we see some pretty interesting ones:
```cpp
pushfont("mono");
formatstring(text)("%05.2f YAW", camera1->yaw);     draw_text(text, VIRTW*2 - ( text_width(text) + FONTH ), VIRTH*2 - 17*FONTH/2);
formatstring(text)("%05.2f PIT", camera1->pitch);   draw_text(text, VIRTW*2 - ( text_width(text) + FONTH ), VIRTH*2 - 15*FONTH/2);
formatstring(text)("%05.2f X  ", camera1->o.x);     draw_text(text, VIRTW*2 - ( text_width(text) + FONTH ), VIRTH*2 - 13*FONTH/2);
formatstring(text)("%05.2f Y  ", camera1->o.y);     draw_text(text, VIRTW*2 - ( text_width(text) + FONTH ), VIRTH*2 - 11*FONTH/2);
formatstring(text)("%05.2f Z  ", camera1->o.z);     draw_text(text, VIRTW*2 - ( text_width(text) + FONTH ), VIRTH*2 - 9*FONTH/2);
popfont();
```
This gets us the `physent->yaw`, `physent->pitch`, and `physent->o` field offsets which represent the rotation and position of the object. We can set the pitch and yaw to force our player character to aim a certain direction, and knowing the position of each player is vital to both aimbot and ESP functionality. Since this little chunk also contains plenty of easy-to-find strings and calls to `draw_text` and `text_width` we'll probably look for this in the disassembler as opposed to the first `draw_text` call we saw around line 832.

Near the bottom of this `gl_drawhud` function we see:
```cpp
pushfont("huddigits");
draw_textf("%d", HUDPOS_HEALTH + HUDPOS_NUMBERSPACING, 823, p->health);
if(p->armour) draw_textf("%d", HUDPOS_ARMOUR + HUDPOS_NUMBERSPACING, 823, p->armour);
if(p->weaponsel && valid_weapon(p->weaponsel->type))
{
    glMatrixMode(GL_MODELVIEW);
    if (p->weaponsel->type!=GUN_GRENADE) p->weaponsel->renderstats();
    else if (p->prevweaponsel->type==GUN_AKIMBO || p->prevweaponsel->type==GUN_PISTOL) p->weapons[p->akimbo ? GUN_AKIMBO : GUN_PISTOL]->renderstats();
    else p->weapons[getprevweaponsel(p)]->renderstats();
    if(p->mag[GUN_GRENADE]) p->weapons[GUN_GRENADE]->renderstats();
    glMatrixMode(GL_PROJECTION);
}
popfont();
```
Which gets us a potentially more useful text drawing function (the f usually means 'formatted' such as in printf), as well as: the player struct's health and armour offset, the player struct's `mag` and `weapons` array offsets, the weapon struct's `type` offset and some constants (we can search for those in the source files to see all the others too).<br>
We can also note down the `pushfont` and `popfont` functions but I don't really care which font we're rendering with, so I'll leave that as a nice-to-have feature for later implementation.<br>

That concludes our gleaning of the `gl_drawhud` function. I think it's a good hooking candidate too, it has a lot of strings that should make it easy to find in our disassembler. So we can cross "Hook a drawing function" off of our checklist as well as "Text rendering".<br>
Since `gl_drawframe` also contained some interesting functions and we know that it calls `gl_drawhud` I'm curious if we can find `gl_drawframe` just by looking at `gl_drawhud`'s callers, so I'll do a quick search for `gl_drawhud` and see if it's called anywhere else.<br>
It turns out it's only called one place, which is inside `gl_drawframe`, so we can find `gl_drawframe` by looking at `gl_drawhud`'s references in our disassembler later. This will allow us to find those interesting tidbits we discovered earlier much quicker.<br>

Before moving on, let's quickly look into all those things that we noted down:
* `draw_text` / `draw_textf` functions
    * Both are declared in protos.h file at line 725, and defined in rendertext.cpp at line 385 and line 99
    * We can see draw_textf just calls draw_text after formatting the variadic arguments which is something we can implement ourselves
* `VIRTW`, `VIRTH`, `FONTH`
    * All declared in protos.h at lines 714-718
    * VIRTW is declared as a global non-const integer so we'll need to read it in memory
    * VIRTH is a preprocessor symbol defined as integer literal 1800.
    * FONTH is a preprocessor symbol resolving to (curfont->defaulth)
        * curfont is defined as a global ptr to a font object (just below VIRTW's definition too) so we'll have to read that from memory if we want to use it
* `playerincrosshair()`
    * Defined in weapon.cpp at line 371
    * Has a lot hardcoded (`player1` and `camera1`)
    * The function it calls, `intersectclosest`, will probably be better as we can pass it a vector to check from
* `transplayer()`
    * Defined in rendergl.cpp at line 595
    * Just prepares graphics state using `camera1`'s position and rotation.
    * Small enough to be inlined by compiler, so be wary of that.
* `readmatrices()`
    * Defined in rendergl.cpp at line 978
    * Looks like it constructs `mvpmatrix` and all other matrices and spatial variables like `camright`, `camup`, and `camdir`
    * Maybe small enough to be inlined by compiler, but doubtful
    * Can read these matrices from memory if we find their addresses

The `mvpmatrix` global referenced in the `readmatrices()` function lets us check off "World-To-Screen" from our checklist. We can also check off "Text rendering" for sure now that we've investigated it further.<br>
So looking at the checklist now we still need some kind of line or box drawing function, a Raycast / Traceline function, and a method for making our localplayer face a target. And, perhaps most importantly, the list of entities to target.<br>
We could easily implement our own line/box drawing function using openGL but let's see if we can find a game function first. My first thought is to look for the function that draws the radar because it has an opaque black background that doesn't seem like it'd be part of the map texture.<br>
So looking back at the `gl_drawhud` function I see a call to `drawradar` at line 921. Its implementation is at line 693 and it calls two functions: `drawradar_showmap` and `drawradar_vicinity` so let's look at the first one, found at line 464.<br>
We're looking for anything that sounds like it'd draw a line, a box, a rectangle, or anything like that.<br>
I see the `quad` call at line 498 which sounds like a rectangle, but I know that a quad is often a textured rectangle and we don't want to draw textures. I'll make note of it in case we can't find anything else. Maybe it'll be defined in some utility file that's close to other primitive drawing functions.<br>
Let's look at the `drawradar_vicinity` function now at line 569. Again, looking for any function call that sounds box-related.<br>
I see a call to `circle` but it seems to take in a texture parameter. Still, "circle" seems like it'd be defined very close to "rectangle" doesn't it? Plainly named functions like "circle" and "quad" make me think "utility functions" and who wouldn't make a utility function that draws a line or rectangle? So I'll look at its implementation and scroll through to see if I can find any such other functions.<br>
I see `circle` function defined in rendergl.cpp at line 275. I see `quad` defined right above it so my theory of these being "utility functions" is already looking good. Above `quad` I see `box2d` then `box` and finally `line`. All the functions we could need. Now we have to see if they're called anywhere in the game code, if they aren't then they'll be very difficult to find in a disassembler (assuming the compiler didn't just omit them).<br>
On second thought, these functions don't do anything special so why not just write our own? We can check "Box rendering" off our checklist now.

So next comes the Raycast / Traceline. So a good tip for finding this is to go in-game and see if you can find any kind of pop-up that displays only when you're looking at something. Or maybe you can interact with something in the world if you're looking at it and press an 'interact' key. In assault cube, we can see the player name pop up in the lower right corner of the screen when we're targeting one, and we can see this behaviour comes from `gl_drawhud` (line 841) and relies on the function `playerincrosshair()`. From looking at that function (defined in weapon.cpp at line 371) we can see it calls `intersectclosest` which seems like it'd work perfectly for us. So we can check off "Raycast / Traceline" from our checklist.<br>

The next item on our checklists: a way to make our localplayer aim at our target. This should be really easy, we should be able to just set the camera's pitch and yaw after we calculate the angle between us and the enemy, and since we've already found `camera1` in the `gl_drawhud` function (and a lot of its field offsets) we can go ahead and check that off our checklist too.<br>

Finally, the only item remaining is to find the list of entities that we want to aim at. Since assault cube is technically a multiplayer game there's the potential that some less mature people will use this lab to ruin the enjoyment of others in multiplayer matches. To guard against that, I won't be searching for the list of player entities, but rather only bot entities. Bots can be added to singleplayer games while offline and this is the ideal situation for us. We do not want to ruin anyone's multiplayer experience or give the gamedevs a headache in any way.<br>
So, if you go in game and start up a bot match (Esc -> Singleplayer -> Bot team deathmatch -> whatever else) then you'll see a message in the top left: `Bot connected: <bot name>`. That's a clue! We can search for that string in the source code and find it's used on line 937 in botmanager.cpp. Now we could look into the BotManager.CreateBot function and probably find what we're looking for, but looking at this file I can see a bunch of bot-related console commands are being registered, so I'm going to scroll down and see if I can find a really small function that loops the bots as that'll probably be easier for us to find in the disassembly later.<br>
So scrolling down I see the string `bot %s disconnected` and I see this is used in both the `kickbot` and `kickallbots` functions, but it doesn't matter which one we look at in the disassembly as they both loop a `bots` global reference and that's what we're looking for. Now we can cross the final item off our checklist: the "Player list".

So now we're all done! We've gathered all the information we need to fulfill our goals, and now all that's left is the implementation. The next chapter in this incredibly dry and meticulous novel will be finding all these functions in our disassembler and also finding all the global references and field offsets that we need.<br>

## Closing ##

Hopefully this chapter - as meticulous as it is - shines light on how you can go about familiarizing yourself with a large codebase. Being able to read other people's code is an incredibly valuable skill as a programmer and reverse engineer, so feel free to explore the codebase more on your own: it's a great exercise.
```

`Chapter 2 - Static Analysis - Exploring The Game's Executable File/README.md`:

```md
# Chapter 2 - Static Analysis #

Last chapter we pored over the game's code and found a lot of interesting functions, globals, and field offsets. This chapter we'll be loading the exe into our disassembler and finding the addresses of those functions and globals as well as the values of the field offsets. This is kind of like building a bridge between the game's source code and the compiled game binary.

## Looking at gl_drawhud ##

The `gl_drawhud` function we decided to use for our hook contained all kinds of global references, function calls, and field offsets, so we'll start there since that'll give us a good 90% of what we need.<br>
I start by picking a unique-looking string from the source code, I'll use `packages/misc/damage.png` as it's near the top of the function and a search through the project directory shows it is only used in this one place. I search for this in my disassembler and go to where it's referenced. Since we know it's only referenced once in the source code, we know that we're now looking at `gl_drawhud` in our disassembler. We can rename the function to help keep things organized.<br>
If we scroll to the very top of the function (at address `0x45F1C0`) we can see the global references to player1 and camera1.
<table style="table-layout:fixed">
<tr>
<th style="width:40%">Source Code</th>
<th style="width:60%">Disassembler</th>
</tr>
<tr>
<td>
  
```cpp
playerent *p = camera1->type<ENT_CAMERA ? (playerent *)camera1 : player1;
```
  
</td>
<td>

```asm
0x0045f1ed      mov     eax, dword [0x57e0a8]
0x0045f1f2      mov     ecx, dword [0x58ac00]
0x0045f1f8      mov     edi, ecx
0x0045f1fa      mov     dword [0x58a910], 0
0x0045f204      cmp     byte [eax + 0x77], 2
0x0045f208      cmovb   edi, eax
```

</td>
</tr>
</table>

So we can see that player1 is at `0x58ac00` and camera1 is at `0x57e0a8` and the `type` field offset is `0x77` and ENT_CAMERA is `2`.<br>
Since there isn't a call instruction until the call the glDisable, we can safely assume both `isspectating()` and `inrange()` were inlined. Let's go to the definition of `isspectating()` in the source code and try to match it up in the disassembler.

<table style="table-layout:fixed">
<tr>
<th style="width:40%">Source Code</th>
<th style="width:60%">Disassembler</th>
</tr>
<tr>
<td>
  
```cpp
bool isspectating() { return state==CS_SPECTATE || (state==CS_DEAD && spectatemode > SM_NONE); }
```
  
</td>
<td>

```asm
0x0045f20b      mov     al, byte [ecx + 0x76]
0x0045f20e      mov     dword [var_2ch], edi
0x0045f212      cmp     al, 5
0x0045f214      je      0x45f22a
0x0045f216      cmp     al, 1
0x0045f218      jne     0x45f223
0x0045f21a      cmp     dword [ecx + 0x318], 0
0x0045f221      jg      0x45f22a
0x0045f223      mov     byte [var_17h], 0
0x0045f228      jmp     0x45f22f
0x0045f22a      mov     byte [var_17h], 1
```

</td>
</tr>
</table>

This seems to be the entirety of the inlined `isspectating()` member function. We can see that `physent->state` field offset is at `0x76` and `playerent->spectatemode` field offset is at `0x318` and, importantly, CS_SPECTATE and CS_DEAD are `0x5` and `0x1` respectively. We can check the state field for those values to prevent our aimbot from locking onto dead / spectator players.<br>
If you're confused where physent and playerent came from, I just looked at the class definition in the source code:
```cpp
class physent
class dynent : public physent
class playerent : public dynent, public playerstate
```
And also the definition of camera1 is `extern physent *camera1;`, so camera1 and player1 will share some fields in common since they are derived from some of the same base classes. For example, both `camera1` and `player1` have a `->state` field.<br>

Moving on, the next interesting thing is the `VIRTW` global reference which is passed as an argument to a `glOrtho` call just before a call to `glEnable`. So let's look at that in both the source code and disassembler.

<table style="table-layout:fixed">
<tr>
<th style="width:35%">Source Code</th>
<th style="width:65%">Disassembler</th>
</tr>
<tr>
<td>
  
```cpp
glOrtho(0, VIRTW, VIRTH, 0, -1, 1);
```
  
</td>
<td>

```asm
0x0045f28f      movaps  xmm0, xmmword [0x55c250]
0x0045f296      sub     esp, 0x30
0x0045f299      xorps   xmm1, xmm1
0x0045f29c      movups  xmmword [var_20h], xmm0
0x0045f2a1      movsd   xmm0, qword [0x55bdc8]
0x0045f2a9      movsd   qword [var_18h], xmm1
0x0045f2af      movsd   qword [var_10h_2], xmm0
0x0045f2b5      movd    xmm0, dword [0x57ed2c]
0x0045f2bd      cvtdq2pd xmm0, xmm0
0x0045f2c1      movsd   qword [var_8h], xmm0
0x0045f2c7      movsd   qword [esp], xmm1
0x0045f2cc      call    dword [glOrtho] ; 0x52520c
```

</td>
</tr>
</table>

The disassembly may seem a little daunting but don't worry, we don't actually have to spend much brain power figuring it out. We know it's a function call and we know the function definition is `void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal);` and GLdouble is just a 64-bit floating point value (all of this was obtained by googling - openGL is a well-documented graphics library). We also know that function arguments are pushed onto the stack in right-to-left order. Don't see any push instructions? That's because the arguments are being `mov`'d directly onto the stack after space is allocated with the `sub esp, 0x30` instruction. My disassembler attempts to identify local variables (variables allocated on the stack) and renames them accordingly, hence why we see `movsd qword [var_18h], xmm1` instead of `movsd qword [esp+18], xmm1` or similar.<br>
So the `mov` instruction closest to the call is the first argument as seen in the source code which in this case is `0`. The second argument is the one we're interested in, `VIRTW`, which corresponds to this instruction `movsd   qword [var_8h], xmm0` and if we look up to where xmm0 is last defined we see `movd    xmm0, dword [0x57ed2c]` so `0x57ed2c` is our global `VIRTW` variable. And we don't even have to figure out the rest because that's the only variable we care about here (remember `VIRTH` is defined as an integer literal).<br>

Now, the next interesting thing we need to find is the `playerincrosshair()` function call along with the `playerent->weaponsel` field offset and the `weapon->reloading` and `weapon->info` field offsets which are referenced just after the call (all around line 808 in the source code).<br>
We can quickly find this in the disassembly by looking just past the third `glEnable` call. While I'm scrolling down past all these other calls I'm also going to make note of the various openGL constants like `GL_TEXTURE_2D`, `GL_ONE`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_MODELVIEW` and others. We could look them up in openGL's online documentation but I'm paranoid about version mismatches and would rather just look at the disassembly. It's easy to do this since they're often passed as the sole argument to these openGL function calls.<br>

So, admittedly, this part is a little hard to read as some of the calls were inlined. From that third `glEnable` call we can deduce that `playerincrosshair()` was inlined but the function that it calls (`intersectclosest(...)`) was not inlined. This is actually perfect as that's the "Raycast" function we're looking for. Its address is `0x4CA250` and it's called at address `0x45F56E`.<br>
Now let's look at the part that references playerent->weaponsel, which is just below:
<table style="table-layout:fixed">
<tr>
<th style="width:40%">Source Code</th>
<th style="width:60%">Disassembler</th>
</tr>
<tr>
<td>
  
```cpp
bool reloading = lastmillis < p->weaponsel->reloading + p->weaponsel->info.reloadtime;
```
  
</td>
<td>

```asm
0x0045f59a      mov     ecx, dword [edi + 0x364]
0x0045f5a0      mov     dword [var_3ch], eax
0x0045f5a4      mov     eax, dword [ecx + 0xc]
0x0045f5a7      movsx   eax, word [eax + 0x46]
0x0045f5ab      add     eax, dword [ecx + 0x20]
0x0045f5ae      cmp     dword [0x57f10c], eax
```

</td>
</tr>
</table>

If you were confused on where exactly this chunk starts, keep in mind that `menuvisible()` was inlined as well as `getcurcommand(NULL)`.<br>
That leaves us at the above snippet starting with `mov ecx, dword [edi + 0x364]` which is the field offset of `playerent->weaponsel`.<br>
Some compiler trickiness attempts to throw us off with `mov eax, dword [ecx + 0xc]` and make us think `0xc` is the field offset of `weapon->reloading` but we won't fall for such tricks. We can see that the next instruction is `movsx eax, word [eax + 0x46]` which makes it clear that `0xc` is the field offset of `weapon->info` and `0x46` is the field offset for `weapon->info.reloadtime` (whatever the `info` type is, haven't looked it up yet).<br>
That leaves us with `add eax, dword [ecx + 0x20]` which, finally, means the field offset for `weapon->reloading` is actually `0x20`.

And these are the openGL constants I jotted down as we scrolled past them:
```
GL_DEPTH_TEST = 0xb71
GL_MODELVIEW = 0x1700
GL_PROJECTION = 0x1701
GL_BLEND = 0xbe2
GL_SRC_ALPHA = 0x302
GL_ONE_MINUS_SRC_ALPHA = 0x303
GL_TRIANGLE_STRIP = 0x5
GL_ONE = 0x1
GL_TEXTURE_2D = 0xde1
```
Before we get to the next interesting bit, let's just nab the `CS_ALIVE` constant value first. If you'll recall the field offset of `playerent->state` was `0x76`, we can look just past the disassembly snippet we were just looking at and see `mov al, [edi+76h]` followed shortly by `test al, al` and `jz short loc_45F5C8` which corresponds partially to `if(p->state==CS_ALIVE || p->state==CS_EDITING)` in the source code which means the constant `CS_ALIVE` is `0`. We can, again, use this as a filter for our aimbot to aim only at alive enemies. Lots of ways of doing the same thing.<br>

Now, the next interesting bit is the `playerent->team` field offset which is actually very close to where we were just looking.<br>
If we scroll past the copious amount of cmp and jz instructions (that don't seem to match the source code at all, but whatever) we can see:
<table style="table-layout:fixed">
<tr>
<th style="width:40%">Source Code</th>
<th style="width:60%">Disassembler</th>
</tr>
<tr>
<td>
  
```cpp
isteam(targetplayer->team, p->team) // fragment from line 811 in renderhud.cpp
```
  
</td>
<td>

```asm
0x0045f610      mov     eax, dword [edx + 0x30c]
0x0045f616      cmp     eax, dword [edi + 0x30c]
```

</td>
</tr>
</table>

This gives us the `playerent->team` field offset at `0x30c`. Our aimbot can now be made to aim only at enemies and ignore teammates.<br>

Now, the next tidbit we need is the address of the `draw_text` function and if you recall we decided to look for the chunk starting around line 883 in the source code because this gives us the `pitch`, `yaw`, `o` fields and the `text_width` and `draw_text` functions. So let's scroll down in the disassembly until we see the string `%05.2f YAW`. I found it around address `0x46067C`.<br>
<table style="table-layout:fixed">
<tr>
<th style="width:40%">Source Code</th>
<th style="width:60%">Disassembler</th>
</tr>
<tr>
<td>
  
```cpp
// fragment of line 884 in renderhud.cpp
formatstring(text)("%05.2f YAW", camera1->yaw);
```
  
</td>
<td>

```asm
.text:0046065B  lea     eax, [esp+368h+var_318]
.text:0046065F  sub     esp, 8
.text:00460662  mov     [esp+370h+var_35C], eax
.text:00460666  mov     eax, camera1
.text:0046066B  movss   xmm0, dword ptr [eax+34h]
.text:00460670  lea     eax, [esp+370h+var_35C]
.text:00460674  cvtps2pd xmm0, xmm0
.text:00460677  movsd   qword ptr [esp+370h+x], xmm0 ; int
.text:0046067C  push    offset a052fYaw ; "%05.2f YAW"
.text:00460681  push    eax             ; int
.text:00460682  call    sub_411F40
```

</td>
</tr>
</table>

So we can see that the address of `camera1` is moved into eax and then xmm0 is loaded with the value of `camera1+0x34` which is the `yaw` field offset.<br>
The rest of the fields follow the same pattern, so if we continue looking down until we get to the string `%05.2f Z  ` we find the following offsets:
```
physent->yaw field offset @ 0x34
physent->pitch field offset @ 0x38
physent->o.x field offset @ 0x4
physent->o.y field offset @ 0x8
physent->o.z field offset @ 0xc
text_width function address @ 0x46E370
draw_text function address @ 0x46DD20
```
We're able to find the function addresses because we know formatstring is called and then the result is passed to text_width which is used in the draw_text call.<br>
We can also see that `FONTH` is part of the same draw_text calls and we know that FONTH actually just resolves to `(curfont->defaulth)` so I got address `57ED28` for the `curfont` global reference and field offset `0x18` for `curfont->defaulth`. We can also see `VIRTW` used here and confirm that the address we found earlier is correct.<br>

Now scroll all the way to the "huddigits" string for the next important tidbit:
<table style="table-layout:fixed">
<tr>
<th style="width:40%">Source Code</th>
<th style="width:60%">Disassembler</th>
</tr>
<tr>
<td>
  
```cpp
draw_textf("%d", HUDPOS_HEALTH + HUDPOS_NUMBERSPACING, 823, p->health);
if(p->armour) draw_textf("%d", HUDPOS_ARMOUR + HUDPOS_NUMBERSPACING, 823, p->armour);
```
  
</td>
<td>

```asm
0x00461628      push    dword [edi + 0xec]
0x0046162e      push    0x337      ; 823 
0x00461633      push    0x50       ; 80
0x00461635      push    0x52e994
0x0046163a      call    fcn.0046e640
0x0046163f      mov     eax, dword [edi + 0xf0]
0x00461645      add     esp, 0x10
0x00461648      test    eax, eax
0x0046164a      je      0x461664
0x0046164c      push    eax
0x0046164d      push    0x337      ; 823
0x00461652      push    0x13b      ; 315
0x00461657      push    0x52e994
0x0046165c      call    fcn.0046e640
0x00461661      add     esp, 0x10
```

</td>
</tr>
</table>

It's important to note that `edi` is the `p` variable that holds either `player1` or `camera`. In either case, it's cast as a `playerent*`. So we can see that `playerent->health` field offset is `0xec` and `playerent->armour` field offset is `0xf0`.<br>
We can also see the address of `draw_textf` is `0x46e640` and if we look into it we can see it does indeed call `draw_text` (address `0x46DD20`) so that confirms we got the right address before.<br>
Now let's snag the last stuff we need:
<table style="table-layout:fixed">
<tr>
<th style="width:40%">Source Code</th>
<th style="width:60%">Disassembler</th>
</tr>
<tr>
<td>
  
```cpp
if (p->weaponsel->type!=GUN_GRENADE) p->weaponsel->renderstats();
else if (p->prevweaponsel->type==GUN_AKIMBO || p->prevweaponsel->type==GUN_PISTOL) p->weapons[p->akimbo ? GUN_AKIMBO : GUN_PISTOL]->renderstats();
else p->weapons[getprevweaponsel(p)]->renderstats();
if(p->mag[GUN_GRENADE]) p->weapons[GUN_GRENADE]->renderstats();
```
  
</td>
<td>

```asm
0x00461683      mov     ecx, dword [edi + 0x364]
0x00461689      cmp     dword [ecx + 4], 7
0x0046168d      jne     0x4616c9
0x0046168f      mov     eax, dword [edi + 0x360]
0x00461695      mov     eax, dword [eax + 4]
0x00461698      cmp     eax, 8     ; 8
0x0046169b      je      0x4616b2
0x0046169d      cmp     eax, 1     ; 1
0x004616a0      je      0x4616b2
0x004616a2      mov     ecx, edi
0x004616a4      call    fcn.0045dd20
0x004616a9      mov     ecx, dword [edi + eax*4 + 0x33c]
0x004616b0      jmp     0x4616c9
0x004616b2      cmp     byte [edi + 0x100], 0
0x004616b9      mov     ecx, 0x340 ; 832
0x004616be      mov     eax, 0x35c ; 860
0x004616c3      cmovne  ecx, eax
0x004616c6      mov     ecx, dword [ecx + edi]
0x004616c9      mov     eax, dword [ecx]
0x004616cb      call    dword [eax + 0x38] ; 56
0x004616ce      cmp     dword [edi + 0x144], 0
0x004616d5      je      0x4616e2
0x004616d7      mov     ecx, dword [edi + 0x358]
0x004616dd      mov     eax, dword [ecx]
0x004616df      call    dword [eax + 0x38] ; 56
```

</td>
</tr>
</table>

I'm getting fatigued writing all this out so just look at the assembly and compare it to the source code and figure out how I got these:
* `weapon->type` field offset = `4`
* `GUN_GRENADE` = `7`
* `playerent->prevweaponsel` field offset = `0x360`
* `GUN_AKIMBO` = `8`
* `GUN_PISTOL` = `1`
* `playerent->akimbo` field offset = `0x100`
* `playerent->weapons` field offset = `0x33c`
* `playerent->mag` field offset is somewhere around `0x144`

The only thing we can't reliably glean is the mag field offset because in the source code we see `if(p->mag[GUN_GRENADE])` and the compiler optimized the indexing operation so the result is hardcoded into the assembly. We know `GUN_GRENADE` is `7` and we know `mag` is defined as `int ammo[NUMGUNS], mag[NUMGUNS], gunwait[NUMGUNS];` (line 257 in entity.h, remember `playerent` is derived from `dynent` and `playerstate`). So we can probably assume it starts at offset `0x128` but don't take my word for it. This is why we confirm things with dynamic analysis afterwards.<br>

We're all done with the `gl_drawhud` function! Now we move on to `gl_drawframe`...

## Harvesting gl_drawframe ##

We can find `gl_drawframe` by looking at what calls `gl_drawhud`. This should be an option in your disassembler.<br>
In IDA you can select the function name and press 'X' to see what references it.<br>
In Ghidra you can select the function name and press 'Ctrl+Shift+F' to see what references it.<br>

Arriving at the call to `gl_drawhud` inside `gl_drawframe` (at address `0x456EDE`) I can see a lot of assembly and I don't like it. Scrolling to the top of the function (at address `0x4560E0`) I can tell a lot of calls have been inlined. Thankfully, we're only here to grab `mvpmatrix` which is supposed to be referenced in a call to `readmatrices()` but I have a feeling it's inlined. Either way, it occurs right after a `glMatrixMode` call near the top of the function. It should be the second `glMatrixMode` call unless it's also called from an inlined function.<br>
So scrolling from the very top of the function and trying to follow along in the source code, I see the sse2 lib functions (tan, atan2, sinf, etc) which serves as a good marker of where I am.<br>
Finally I see the second `glMatrixMode` call and above it I see the `setperspective(...)` call hasn't been inlined, so we could nab that function address but I'm not sure we'll need it (we can just write it ourselves).<br>
Below, I see the `transplayer()` function hasn't been inlined either but we definitely won't need this as we can easily implement it ourselves.<br>
Finally, we see that the `readmatrices()` call has indeed been inlined. We can tell by looking at the source code of the `readmatrices` function and see that it starts with two calls to `glGetFloatv` which matches what we see in the disassembly.<br>
It's not so terrible to read though, the non-literal argument to each `glGetFloatv` call is the `mvmatrix.v` and `projmatrix.v` respectively. We know that these are multiplied together shortly after and the result is stored in the `mvpmatrix` which is the global reference we're trying to find.

<table style="table-layout:fixed">
<tr>
<th style="width:40%">Source Code</th>
<th style="width:60%">Disassembler</th>
</tr>
<tr>
<td>
  
```cpp
glGetFloatv(GL_MODELVIEW_MATRIX, mvmatrix.v);
glGetFloatv(GL_PROJECTION_MATRIX, projmatrix.v);
// ... (omitted because they're long, inlined matrix operations)
mvpmatrix.mul(projmatrix, mvmatrix);
```
  
</td>
<td>

```asm
0x0045640f      mov     esi, dword [glGetFloatv] ; 0x52521c
0x00456415      push    0x57e010   ; mvmatrix
0x0045641a      push    0xba6      ; 2982
0x0045641f      call    esi
0x00456421      push    0x57e0b0   ; projmatrix
0x00456426      push    0xba7      ; 2983
0x0045642b      call    esi
0x0045642d      movss   xmm0, dword [mvmatrix] ; 0x57e010
0x00456435      mov     ecx, 0x57dfd0
...             ...     ...        ... ; omitted
0x004564c8      push    0x57e010   ; mvmatrix ; int32_t arg_8h
0x004564cd      xorps   xmm0, xmm1
0x004564d0      push    0x57e0b0   ; projmatrix ; int32_t arg_4h
0x004564d5      movss   dword [0x592078], xmm0
0x004564dd      call    fcn.004114b0
```

</td>
</tr>
</table>

So I had to omit some of the inlined matrix operations in the middle there. These are really obvious to see in the disassembly as it's always a sea of `movss` instructions.<br>
So we can see our two known matrices, `mvmatrix` and `projmatrix` are pushed as arguments to a call. This call corresponds to `mvpmatrix.mul(projmatrix, mvmatrix);` and surprisingly hasn't been inlined. Since this is a class member function we know that the implicit 'this' parameter is always in register ecx. What is ecx last set to? `0x57dfd0` is the address of our `mvpmatrix`.<br>

And that's all we set out to find in `gl_drawframe` so we can move on to the next (and last) function. When we get to coding the ESP functionality we may decide to revisit this `gl_drawframe` function to find some more potentially useful variables or functions so I suggest you name it in your disassembler and save the project so you can easily return to it.


## Devouring kickbot ##

The last thing we need to find is our "Player list" which is actually exclusively the collection of bot entities. We decided to use the string `bot %s disconnected` even though it's used in two places because either place will get us the `bots` global reference. So search for that string in the disassembler and find what references it, then go to the first reference. For me, this brings me to address `0x5120E9`.<br>
I can already see the array we're looking for because I recognize the `lea ecx, [eax+edx*4]` pattern. This is how arrays are commonly looped in assembly. `eax` holds the base address of the array, `edx` is the index into the array, and `4` is the size of each element in the array. I see this instruction just below the string reference, at address `0x512125` and just above that I see `mov eax, dword_591FCC` which means our `bots` global reference is at address `0x591FCC`.<br>
At the bottom of the loop, at address `0x512136` I see:
```asm
0x0051212e      mov     edi, dword [0x591fd4]
0x00512134      cmp     edx, edi
0x00512136      jl      0x512120
```
This gives us the 'ulen' field of the vector class (@ address `0x591fd4`) which represents the number of elements. It's given as an absolute address rather than a field offset, but this is somewhat common for simple container instances defined in the global scope.<br>
We should now have all we need! We may find out later that we're missing some stuff, so be sure to name all of the functions we visited and save your disassembler database so we can quickly return to it later.


## Summary ##

That concludes this lengthy and meticulous chapter on static analysis. It took me about 12 hours to write this chapter alone. I intentionally chose places in the disassembly that'd be easy to turn into a snippet (I only had to cut some fat out of one snippet!) and easy to find for those that are following along.<br>
You should have named all of the functions we visited so we can return to them later if need be (we probably will need to). Don't forget to save your disassembler project before exiting. And close those notepad++ tabs.
```

`Chapter 3 - Dynamic Analysis - Confirming Our Findings/README.md`:

```md
# Chapter 3 - Dynamic Analysis #

In this chapter we'll be loading up cheat engine and ReClass.NET to confirm our findings and map out some data structures.<br>
To do so, we'll be plugging in all the addresses we recorded last chapter and making sure they match our expectations.

Here's all the functions and global references we found from the previous chapter:
* `gl_drawhud` function @ address `0x45F1C0`
* `player1` global reference @ address `0x58ac00`
* `camera1` global reference @ address `0x57e0a8`
* `VIRTW` global reference @ address `0x57ed2c`
* `intersectclosest` function @ address `0x4CA250`
* `text_width` function @ address `0x46E370`
* `draw_text` function @ address `0x46DD20`
* `curfont` global reference @ `0x57ED28`
* `draw_textf` function @ address `0x46e640`
* `gl_drawframe` function @ address `0x4560E0`
* `mvpmatrix` global reference @ address `0x57dfd0`
* `bots` global reference @ address `0x591FCC` (vector of playerents)
* `bots->ulen` global reference @ address `0x591fd4` (length field of vector of playerents)

And the field offsets of some structs:
* `playerent->type` @ field offset `0x77`
* `playerent->state` @ field offset `0x76`
* `playerent->spectatemode` @ field offset `0x318`
* `playerent->weaponsel` @ field offset `0x364`
* `weapon->info` @ field offset `0xc`
* `weapon->info.reloadtime` @ field offset `0x46`
* `weapon->reloading` @ field offset `0x20`
* `playerent->team` @ field offset `0x30c`
* `physent->o` @ field offset `0x4`
* `physent->yaw` @ field offset `0x34`
* `physent->pitch` @ field offset `0x38`
* `font->defaulth` @ field offset `0x18`
* `playerent->health` field offset @ `0xec`
* `playerent->armour` field offset @ `0xf0`
* `weapon->type` field offset @ `0x4`
* `playerent->prevweaponsel` field offset @ `0x360`
* `playerent->akimbo` field offset @ `0x100`
* `playerent->weapons` field offset @ `0x33c`
* `playerent->mag` field offset somewhere around `0x144`, maybe `0x128`.

## Refresher on Function Addresses and Image Bases ##

So a few things to note before we get started:<br>

With compiled languages like C/C++, functions are always going to be at the same relative position within the image. The function has already been compiled to machine code and this machine code is placed within the .text section of the image file.<br>
With interpreted languages or languages that compile to an intermediate language before being Just-In-Time (JIT) compiled, functions are dynamically allocated and will be at a random address. The JITer parses the input code and produces machine code then allocates enough space in the process to hold it via VirtualAlloc (or `new` or malloc or whatever else eventually leads to a VirtualAlloc call).<br>

The PE image format has a flag for "dynamic base". When this flag is set then Windows image loader will allocate the image at a randomized base address. This is part of ASLR and the randomized base address will change each time you restart your PC.<br>
Because of randomized base addresses, we often use image offsets for addressing. For example, let's say we load the image into our disassembler at a base address of 0x400000 and we find our `gl_drawhud` function at address `0x45F1C0` in our disassembler. Since the image base is `0x400000` we'd subtract that to get the image offset: `0x45F1C0` - `0x400000` = `0x5F1C0` and we'd add `0x5F1C0` to the randomized base address of the game process to find `gl_drawhud` in the game. For example, let's say windows decided to give the process a random base of `0x501000`, we'd do: `0x501000` + `0x5F1C0` = `0x5601C0` and this would get us `gl_drawhud`.<br>
This idea of subtracting the base to find the offset and then adding that offset to other bases to normalize everything is very important. I often set the base to 0x0 in my disassembler so all addresses are also their image offset.

Now, Assault Cube is written in C/C++ which is a compiled language and it does not have the dynamic base flag set, so we know that its base address will be `0x400000` every single time. This means there's no real need to use the base+offset paradigm. We can use the absolute addresses if we want because as long as our disassembler is basing the image at `0x400000` (it should be) then the addresses in the disassembler will match the addresses in the live game too.

With all that said, we only really need to confirm the field offsets and try to map out the rest of those data structures. We don't need to verify that the function addresses are valid because there's no way they aren't.

## Confirming Our Findings ##

Let's start by loading into the game then launching cheat engine and ReClass.NET and attaching both to the game's process.<br>
We'll look at our local player first, `player1` at address `0x58ac00`. So plug that into ReClass.NET since we're just trying to map out data structures. We can also pull up the class definition of playerent in the `entity.h` file of the game's source code. We may have to look at the dynent, physent, and playerstate definitions too which are all in the same file too.<br>
Remember, `player1` is defined as `playerent *player` so it's a pointer. We want to follow that pointer in ReClass.NET to the actual `playerent` instance. We can do that by selecting the first field and pressing the 'PTR' button then expand the drop-down twice to see the actual playerent instance.<br>
The first field is the vtable which is a pointer to somewhere in the \<DATA> section.<br>
The second field, at `0x4`, if you recall is the `playerent->o` field. "o" in this case is short for "origin" which is the player's position. We know that positions are very often stored as 3 floats (a vec3, vector3, etc). We can confirm by looking at the definition of `physent` in `entity.h` and we see that the first defined field is indeed `vec o, vel`. "vel" in this case is short for "velocity" so we can also map that. We can do this by selecting the field in ReClass.NET and pressing the 'VEC 3' button. Do this for both the `o` field and the `vel` field. If you go into the game and run around a bit you should see both `o` and `vel` changing in ReClass.NET. We can see that the 'z' component of the vectors corresponds to the height which is somewhat rare in games. Usually the 'y' component is height.<br>
Continue mapping out the data structures and making sure the known offsets we found match up with the mapping. Refer to the source code definitions but don't rely on them blindly as the compiler will pad things and the published build may use a slightly different codebase. You should also be checking that they're changing according to in-game actions.<br>
Eventually you'll get to the `mag` field offset on the `playerent` which is the only one we couldn't get an exact offset for, but if we compare our mapping in ReClass to the source code and also watch how it changes in-game as we reload, we can see that it does indeed start at offset `0x128`.<br>
Continue mapping the playerent, weapon, and guninfo structs to your heart's content. Keep in mind the compiler likes to pad things so that fields start on an address that's a multiple of 4. We don't really need **all** the fields, so don't worry if you get lost.

## Summary ##

This chapter is really short because there isn't much to do. In some games this part might be the longest part, but in this case most of our time went to reading the source code and looking at the game in a disassembler.<br>
Next chapter we'll finally start coding the thing.
```

`Chapter 4 - Writing The ESP/README.md`:

```md
# Chapter 4 - Writing The ESP #

Finally, the moment we've all been waiting for: coding the thing! A lot of people think programming is all about writing code, but those people are fools. If 90% of your time spent on a project is writing code then you're almost certainly writing awful code. Research and planning are huge parts of any project which includes what we were doing in the previous chapters.<br>
Unfortunately, I plan on writing some awful code for this project, but it's at least planned. Hear me out: writing direct, concise code that doesn't take advantage of OOP or any other design paradigms is going to be easier to follow as a beginner than some massive, abstract cheating framework.<br>

Start by creating a Visual Studio project. Use the 'Dynamic-Link Library (DLL)' template under C++ | Windows | Library filter settings. From there, I add in my `#include <MinHook>` statement to the precompiled header file `pch.h` (did you install minhook via vcpkg as recommended at the start?). I also set the 'C++ Language Standard' under 'Project->\<projName> Properties->General' to 'Preview - Features from the Latest C++ Working Draft (/std:c++latest)' for all configurations. Finally, since we know assault cube is x86, I got rid of the x64 build configuration under 'Build->Configuration Manager...' and under the 'Active solution platform' dropdown I chose '\<Edit...>' and selected x64 and removed it.<br>

Finally, it's worth noting that if you're using the code from this repo you will need to install minhook via vcpkg using the x86-windows-static triplet as I modified the vcxproj file to use that triplet (the `VcpkgTriplet` option in 'Globals' PropertyGroup).

## Part 1 - Giving Shape To Our Data ##

So first thing we're going to do is complete the "bridge" we've been building between the game, its compiled form, and now our cheat. We take all the functions and field offsets we gathered before and define them in our program.<br>
The data structures we mapped out in ReClass.NET in the previous chapter can be exported to C/C++ struct definitions which takes care of a lot of the work. To do so, in ReClass.NET, click on the 'Project' tab in the menu toolbar then 'Generate C++ Code...'. This will pop up a window for you to then select all and copy.<br>
In your Visual Studio project, create a new header file (I named mine `game_definitions.h`) and paste. You can fix up the definitions if you want. For example, I decided to make the proper inheritance chain so that `playerent` is derived from both `dynent` (which itself is derived from `physent`) and `playerstate`. I also wrote in the virtual method definitions so Visual Studio would see the vtables and correctly factor that into the total size of the classes. I also have definitions for `animstate`, `poshist`, `weapon`, and `guninfo`. I expect padding to mess up some of these definitions, but that's an easy fix if we encounter such a problem.<br>
In this `game_definitions.h` file I'm also going to include some typedef'd function definitions.<br>
The functions we gathered from the game and will be using are:
* `gl_drawhud` function @ address `0x45F1C0`
* `intersectclosest` function @ address `0x4CA250`
* `text_width` function @ address `0x46E370`
* `draw_text` function @ address `0x46DD20`


Next, we'll also need some openGL functions. We could `#include` openGL in our project, but I'd rather just provide the function definitions and then get the function addresses via `GetProcAddress`. Thinking about what we'll need from openGL and looking at what the game uses (mostly in the game's `renderhud.cpp` and `rendergl.cpp` files), these are the functions I defined:
* `glMatrixMode`
* `glPushMatrix`
* `glPopMatrix`
* `glLoadIdentity`
* `glOrtho`
* `glFrustum`
* `glEnable`
* `glDisable`
* `glBlendFunc`
* `glBegin`
* `glEnd`
* `glColor4f`
* `glVertex2f`
* `glVertex3f`
* `glRotatef`
* `glScalef`
* `glTranslatef`
* `glGetFloatv`
    * might not need since we can read mvpmatrix directly

And since I plan on getting these addresses via `GetProcAddress` calls I decided to move these definitions into their own files: `opengl_wrapper.h` and `opengl_wrapper.cpp`. We'll define a static class to access these functions and also perform all of our `GetProcAddress` calls in its static constructor (or maybe a static `Initialize` method). We could even place our custom drawing functions in this static class too, like `DrawOutline` or something. This way all of our drawing stuff is in its own class.<br>
We can get the exact openGL function definitions from its online documentation.<br>

Finally, we need something to tie this all together, so I created a class called `CheatMain` that will hold all the global references and function pointers we found from the game. This class will also perform all initialization and all cheat-related functionality: it will be the core of our program. Since we'll be doing all of our work from within hooks, we won't have an object reference. We could make a global instance of `CheatMain` and use that, or we could simply make `CheatMain` a pure static class. I'll be choosing to make it purely static.<br>
These are the global references we need to store a pointer to:
* `player1` global reference @ address `0x58ac00`
* `camera1` global reference @ address `0x57e0a8`
* `VIRTW` global reference @ address `0x57ed2c`
* `curfont` global reference @ `0x57ED28`
* `mvpmatrix` global reference @ address `0x57dfd0`
* `bots` global reference @ address `0x591FCC` (vector of playerents)

And of course we'll also store pointers to the functions whose signatures we defined in the `game_definitions.h` file.<br>
I'll include some helpful utility functions, like allocating a console window to print to.<br>

### Part 1 Codebase ###
I'll push a commit containing all the work I've done so far so you can reference the code at this exact moment in time.<br>
You can find it here: https://github.com/kotae4/lab-esp-and-aimbot/tree/Part1Chapter4 <br>
Please note that the guide itself will be changed over time so you should always use the 'main' branch for the non-code portion.<br>

## Part 2 - Drawing Hello World ##
Next, we need to add some meat to it. The first thing I always try to do is to draw the string "Hello World" on screen. So let's add a call to `draw_text` in our `hk_gl_drawhud` function in `CheatMain.cpp`. We can see the default parameters in the game's source code are 255 for color component parameters and -1 for the cursor and maxwidth parameters, so here's what my call looks like: `CheatMain::odraw_text("Hello World", 10, 10, 255, 255, 255, 255, -1, -1);`. Now we're ready to compile and inject it into the game.<br>
I use cheat engine's built-in injector. To do so, open up cheat engine and in the upper left corner click the glowing computer icon and select the game process. Then, click the 'Memory View' button near the bottom left of the main cheat engine window. In the popped up Memory View window open the 'Tools' menu then 'Inject DLL' at the bottom of the list. Select our compiled DLL and when cheat engine asks if you'd like to execute a function click 'No' (DllMain still gets executed, don't worry).<br>

### A Snag With Drawing Text ###
The game crashes immediately. A slight snag in our plans, but this is okay. This is common when you're messing with low-level stuff. So we know we could successfully inject before we added the call to `odraw_text`, so that already narrows it down perfectly. Let's compare how our call looks in assembly against how the call looks in the game's assembly. I load up two instances of my disassembler and load the cheat DLL into one and the game's exe into the other.<br>
So by looking at all the calls to draw_text in the game I can see it's definitely a non-standard calling convention. It looks like the string argument is loaded into the ecx register and the 'left' or X-coordinate argument is loaded into the edx register. The rest of the arguments are pushed onto the stack in reverse order.<br>
If we look at our compiled DLL we can see all the arguments are pushed, none are loaded into registers, hence the crash.<br>
So let's try writing a "wrapper" around `odraw_text` that mimics the assembly we see in the game. Thankfully, since this is x86, we can use `__asm` blocks to write assembly instructions directly. If it were x64 we'd have to use something like asmjit. So here's what I came up with:
```cpp
void CheatMain::draw_text(const char* str, int x, int y, int r, int g, int b, int a /*= 255*/, int cursor /*= -1*/, int maxwidth /*= -1*/)
{
	__asm
	{
		mov ecx, str
		mov edx, x
		push maxwidth
		push cursor
		push a
		push b
		push g
		push r
		push y
		call odraw_text
		add esp, 28
	}
}
```
And I call it like this at the top of `hk_gl_drawhud`, before we call the trampoline:
```cpp
CheatMain::draw_text("Hello World", 1000, 1000, 255, 0, 0);
```

Restarting the game and injecting it again we see that we don't crash anymore, but we also don't see our string being drawn anywhere. Painful.<br>
So now my idea is to go in game and place a breakpoint on the `draw_text` function (remember it's at address `0x46DD20`). We can do this in cheat engine's 'Memory View' window.<br>
The first hit for me is the "FPS 200" string and I can see I got the calling convention right. If I plug the address contained in ECX into ReClass.NET I see the "FPS 200" string. If I plug the address contained in ESP (the stack pointer) into ReClass.NET I can see the arguments that were pushed onto the stack in the same order as we're pushing ours. Everything is as it should be, but we still aren't seeing our string. Now I'm thinking maybe let's just mimic the parameter values of that call, so I change my call to:
```cpp
CheatMain::draw_text("Hello World", 4273, 3504, 255, 255, 255);
```

And after restarting the game and injecting again, I still don't see my string. Very strange. Ah, the graphics state isn't prepared for HUD drawing when our `hk_gl_drawhud` is executed.<br>
So if we look at the game's `gl_drawhud` function in `renderhud.cpp` we can see some initial work at the start:
```cpp
glDisable(GL_DEPTH_TEST);
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
...
glEnable(GL_BLEND);
```
This disables depth, clears the mv and p matrices, and enables blending which is used to get rid of the black background of the font atlas. If we scroll further down to where the first `draw_text` calls start and then look above that for more GL stuff we see:
```cpp
glEnable(GL_TEXTURE_2D);
glOrtho(0, VIRTW*2, VIRTH*2, 0, -1, 1);
```
This allows us to draw with 2d textures (which is what the font atlas is) and multiplies the current matrix (the last set matrix mode - projection in this case) by an orthographic transformation matrix.<br>
So I'm going to move all of this into a new function, `CheatMain::SetupHUDDrawing`, and call that before we start drawing text.<br>
And I just realized I have a bug in my code. In `opengl_wrapper.h` where I define all the GL constants, I accidentally placed an `=` sign between the token and the value. The correct definitions should be:
```cpp
#define GL_DEPTH_TEST 0xb71
#define GL_MODELVIEW 0x1700
#define GL_PROJECTION 0x1701
#define GL_BLEND 0xbe2
#define GL_SRC_ALPHA 0x302
#define GL_ONE_MINUS_SRC_ALPHA 0x303
#define GL_TRIANGLE_STRIP 0x5
#define GL_ONE 0x1
#define GL_TEXTURE_2D 0xde1
```
I also realized I didn't define VIRTH anywhere even though we know it's a constant, so I added `#define VIRTH 1800` to my `CheatMain.h` file.<br>
With those changes, we can compile and inject again, and finally we see our string in the lower right.<br>
We can change the coordinates now so it draws in the top-left. Here's my `hk_gl_drawhud` function now:
```cpp
CheatMain::SetupHUDDrawing();
CheatMain::draw_text("Hello World", 100, 100, 255, 255, 255);

CheatMain::draw_textf(100, 200, 255, 255, 0, "MyModule: %tx", CheatMain::hMod);

CheatMain::ogl_drawhud_trampoline(w, h, curfps, nquads, curvert, underwater, elapsed);
```
I went ahead and added a formatted version of our draw_text wrapper, as you can see. It just writes the formatted varargs into a char buffer then passes that to CheatMain::draw_text.<br>
Finally, a last note, the coordinates passed to these drawing functions are not 1:1 screen coordinates. It seems the game uses a "virtual" coordinate system, hence the presence of `VIRTW` and `VIRTH`. We could translate this virtual coordinate system back to our screenspace coordinate system, but I don't think it's entirely necessary for HUD drawing. Perhaps as we continue toward our goals we'll find a need to do so, I'm not sure yet.<br>

### Part 2 Codebase ###
Anyway, I'll push this commit now before we move on to the rest.<br>
You can view the codebase at this point in time here: https://github.com/kotae4/lab-esp-and-aimbot/tree/Part2Chapter4 <br>
Please note that the guide itself will be changed over time so you should always use the 'main' branch for the non-code portion.<br>

## Part 3 - ESP Functionality ##
Now, let's work on our first major goal: name ESP. We want to draw each player's name over their head.<br>
So I'm going to create another function for this: `DrawNametags`.<br>
In this function I'm going to loop the `bots` vector and perform world-to-screen transformation on each position, then draw their name by calling our `draw_text` with the transformed position.<br>
Ah, it is at this point I realized I have a bug in my definition of `Vector`. The `T** data` should be changed to `T* data`. Easy fix, and no more crashes from that.<br>
The world-to-screen transformation is some complicated math. I linked to some resources in the main guide, so if you're more clever than I am maybe you can understand it.<br>
But since I don't, I'm not even going to bother trying to explain what it does. I cobbled it together from many online sources until it worked. Here it is:
```cpp
Vector4f clipCoords(0.f, 0.f, 0.f, 1.f);
mvpmatrix->transform(bot->o, clipCoords);
if (clipCoords.w < 0.1f) continue;
Vector3f NDCCoords;
NDCCoords.x = clipCoords.x / clipCoords.w;
NDCCoords.y = clipCoords.y / clipCoords.w;
NDCCoords.z = clipCoords.z / clipCoords.w;
Vector3f screenPos;
// normally we'd divide by 2 here as part of the world-to-screen transformation,
// but the "virtual screen coordinate system" the game uses is actually VIRTW * 2 and VIRTH * 2
// so we can skip the divide by 2 by not multiplying VIRTW and VIRTH by 2
screenPos.x = (*VIRTW * NDCCoords.x) + (*VIRTW + NDCCoords.x);
screenPos.y = -(VIRTH * NDCCoords.y) + (VIRTH + NDCCoords.y);
```
Ah, I also added that transform function to the `Matrixf` definition. Again, it's some weird math I don't fully understand, I had to google to find it:
```cpp
void transform(const Vector3f& in, Vector4f& out) const
{
    out.x = ((in.x * data[0]) + (in.y * data[4]) + (in.z * data[8]) + data[12]);
    out.y = ((in.x * data[1]) + (in.y * data[5]) + (in.z * data[9]) + data[13]);
    out.z = ((in.x * data[2]) + (in.y * data[6]) + (in.z * data[10]) + data[14]);
    out.w = ((in.x * data[3]) + (in.y * data[7]) + (in.z * data[11]) + data[15]);
}
```
So now that we can transform world coordinates to screen coordinates we can draw the bot's names above their head. We can also check their `state` and `team` fields to change which color we draw with. I chose to draw white when either they're dead, or I'm dead, or I'm spectating, green when they're a teammate, and red otherwise. I also added some sanity checks to make sure we don't crash.<br>
Here's my complete `DrawNametags` function now:
```cpp
void CheatMain::DrawNametags()
{
	if ((bots == NULL) || (bots->count <= 0) || (bots->data[0] == NULL)) return;

	for (int index = 0; index < bots->count; index++)
	{
		playerent_wrapper* bot = bots->data[index];
		if (bot == NULL) continue;

		// the world-to-screen transformation is some complicated math that i don't fully understand.
		// i usually just copy paste until something works
		// here's some links that may help:
		// https://www.scratchapixel.com/lessons/3d-basic-rendering/computing-pixel-coordinates-of-3d-point/mathematics-computing-2d-coordinates-of-3d-points
		// https://www.3dgep.com/understanding-the-view-matrix/#Transformations
		// https://answers.unity.com/questions/1014337/calculation-behind-cameraworldtoscreenpoint.html
		// https://www.codeproject.com/Articles/42848/A-New-Perspective-on-Viewing
		Vector4f clipCoords(0.f, 0.f, 0.f, 1.f);
		mvpmatrix->transform(bot->o, clipCoords);
		if (clipCoords.w < 0.1f) continue;
		Vector3f NDCCoords;
		NDCCoords.x = clipCoords.x / clipCoords.w;
		NDCCoords.y = clipCoords.y / clipCoords.w;
		NDCCoords.z = clipCoords.z / clipCoords.w;
		Vector3f screenPos;
		// normally we'd divide by 2 here as part of the world-to-screen transformation,
		// but the "virtual screen coordinate system" the game uses is actually VIRTW * 2 and VIRTH * 2
		// so we can skip the divide by 2 by not multiplying VIRTW and VIRTH by 2
		screenPos.x = (*VIRTW * NDCCoords.x) + (*VIRTW + NDCCoords.x);
		screenPos.y = -(VIRTH * NDCCoords.y) + (VIRTH + NDCCoords.y);

		if ((bot->state == CS_DEAD) || 
        ((player1 == NULL) || (player1->state == CS_SPECTATE) || 
        ((player1->state == CS_DEAD) && (player1->spectatemode > SM_NONE))))
			draw_text(bot->name, screenPos.x, screenPos.y, 255, 255, 255);
		else if (bot->team == player1->team)
			draw_text(bot->name, screenPos.x, screenPos.y, 0, 255, 0);
		else
			draw_text(bot->name, screenPos.x, screenPos.y, 255, 0, 0);
	}
}
```

And here's what it looks like in-game:
| ![esp-nametags](guide_images/esp_nametags.png) |
|:--:|
| <sub>Image: Nametags drawn over bots, colored based on team and state</sub> | 

Now let's move on to the next feature: drawing outlines around each player.<br>
In chapter 2 we decided we'd write our own drawing function for this, so let's do that.<br>
Basically, we want to draw 4 lines:
* From (xMin, yMin) to (xMax, yMin)
* From (xMax, yMin) to (xMax, yMax)
* From (xMax, yMax) to (xMin, yMax)
* From (xMin, yMax) to (xMin, yMin)

Where xMin, yMin, xMax, and yMax are all just +- some value from the player's position.<br>
We can use the player's `eyeheight` field to offset the y value and `radius` field to offset the x value.<br>
First, we need to find the constant value of `GL_LINE_LOOP`. I search the game's code and find a string near where it's referenced. That string is "T * P x 2". Searching this in my disassembler and I find it's used in 3 places. The first place doesn't match what I'm seeing in the source code, but the second place does. So that brings me to address `0x457BBE` and somewhere further down I see two calls to `glLineWidth`, just after the first call is a call to `glBegin`. The parameter passed to that call is the value of `GL_LINE_LOOP`, which is `0x2`. I add that to `opengl_wrapper.h` before moving on.<br>
Here's what I came up with for the drawing function:
```cpp
void CheatMain::DrawOutline2d(float xMin, float yMin, float xMax, float yMax)
{
	opengl_wrapper::oglBegin(GL_LINE_LOOP);
	opengl_wrapper::oglVertex2f(xMin, yMin);
	opengl_wrapper::oglVertex2f(xMax, yMin);
	opengl_wrapper::oglVertex2f(xMax, yMax);
	opengl_wrapper::oglVertex2f(xMin, yMax);
	opengl_wrapper::oglEnd();
}
```

And the function that calls it:
```cpp
void CheatMain::DrawPlayerOutlines2d()
{
	if ((bots == NULL) || (bots->count <= 0) || (bots->data[0] == NULL)) return;

	for (int index = 0; index < bots->count; index++)
	{
		playerent_wrapper* bot = bots->data[index];
		if (bot == NULL) continue;

		Vector3f botMin(bot->o.x - bot->radius, bot->o.y, bot->o.z - bot->eyeheight);
		Vector3f botMax(bot->o.x + bot->radius, bot->o.y + bot->radius, bot->o.z);

		Vector3f botScreenMin, botScreenMax;
		bool onScreenMin, onScreenMax;
		onScreenMin = WorldToScreen(mvpmatrix, botMin, *VIRTW, VIRTH, botScreenMin);
		onScreenMax = WorldToScreen(mvpmatrix, botMax, *VIRTW, VIRTH, botScreenMax);

		if ((onScreenMin == false) && (onScreenMax == false)) continue;

		DrawOutline2d(botScreenMin.x, botScreenMin.y, botScreenMax.x, botScreenMax.y);
	}
}
```
You can see I moved the world-to-screen logic into its own function.<br>
I then add a call to `CheatMain::DrawPlayerOutlines2d` inside our `hk_gl_drawhud` underneath the `CheatMain::DrawNametags` call.<br>
Compiling this and injecting it into the game will result in... nothing. To debug why it's not drawing anything, I added a separate call to `CheatMain::DrawOutline2d` inside `hk_gl_drawhud` using hardcoded coordinates that should **definitely** appear on screen, and compiling and injecting again draws nothing.<br>
So at this point I'm thinking it's the graphics state again so I look at places in the game's code where a call to `box2d` is made and the first one I find is in `editing.cpp` around line 794. I can see it calls glDisable twice to disable GL_BLEND and GL_TEXTURE_2D before calling box2d, then glEnable again to re-enable them afterwards.<br>
This makes sense because we're drawing a primitive line instead of textures, and we don't have any need to blend colors either. If I had more experience with openGL I wouldn't have made this mistake, but such is life.<br>
Here's the fixed `DrawOutline2d` function:
```cpp
void CheatMain::DrawOutline2d(float xMin, float yMin, float xMax, float yMax, float colorR, float colorG, float colorB)
{
	opengl_wrapper::oglDisable(GL_BLEND);
	opengl_wrapper::oglDisable(GL_TEXTURE_2D);
	opengl_wrapper::oglColor4f(colorR, colorG, colorB, 1.f);
	opengl_wrapper::oglBegin(GL_LINE_LOOP);
	opengl_wrapper::oglVertex2f(xMin, yMin);
	opengl_wrapper::oglVertex2f(xMax, yMin);
	opengl_wrapper::oglVertex2f(xMax, yMax);
	opengl_wrapper::oglVertex2f(xMin, yMax);
	opengl_wrapper::oglEnd();
	opengl_wrapper::oglEnable(GL_BLEND);
	opengl_wrapper::oglEnable(GL_TEXTURE_2D);
}
```
I also added customizable colors so we can draw enemies and teammates differently like with the nametags. This involved changing `CheatMain::DrawPlayerOutlines2d` as well, so it looks even more like `CheatMain::DrawNametags`, but that's okay. I also changed the conditional that checks onScreenMin and onScreenMax to continue if either is false, this should get rid of glitchy boxes when a player is just barely on screen.<br>
Here's what it looks like in-game now:
| ![esp-nametags-boxes](guide_images/esp_nametags-boxes.png) |
|:--:|
| <sub>Image: Nametags drawn over and boxes around bots, colored based on team and state</sub> | 


And with that we are done with our first major goal: ESP functionality!<br>

### Part 3 Codebase ###
Before we move on to the next major goal, aimbot functionality, I'll push this commit.<br>
You can view the codebase at this specific point in time using this link: https://github.com/kotae4/lab-esp-and-aimbot/tree/Part3Chapter4 <br>
Please note that the guide itself will be changed over time so you should always use the 'main' branch for the non-code portion.<br>
```

`Chapter 5 - Writing The Aimbot/README.md`:

```md
# Chapter 5 - Writing The Aimbot #

The aimbot is our next major goal and there's usually only two big problem areas:
1. Calculating the angle between our player and the target player
2. Detecting if there's a wall or other solid object between us and the target player (raycast / traceline / etc)

The first one involves some complicated math that I don't fully understand. If I were to guess, I'd say this math is slightly less complicated than the math used for the world-to-screen transformation. Again, because I don't fully understand it, I can't really explain it and I usually just google wildly and try whatever I can find until it works.<br>
Google-fu is truly an invaluable skill.<br>

The second one just involves calling the `intersectclosest` function we found. Nearly every game engine will have a similar function regardless of whether it's 2D or 3D. A lot of game functionality requires knowing if something is in the bounds of something else.<br>

Now let's get into the code. First of all, our aimbot needs a target, so I'm going to create a `FindNearestTarget` function that loops over the bots and returns the one that's closest and not behind a wall (this is where `intersectclosest` comes in).<br>
Here's what I came up with:
```cpp
if (player1->state != CS_ALIVE) return NULL;
	if ((bots == NULL) || (bots->count <= 0) || (bots->data[0] == NULL)) return NULL;

	float bestDistSquared = 0.f;
	int hitZone = -1;
	for (int index = 0; index < bots->count; index++)
	{
		playerent_wrapper* bot = bots->data[index];
		if ((bot == NULL) || (bot->state == CS_DEAD)) continue;

		playerent_wrapper* target = ointersectclosest(player1->o, bot->o, player1, bestDistSquared, hitZone, true);
		if (target != NULL)
		{
			return target;
		}
	}

	return NULL;
```

## Snag with intersectclosest ##

And it crashes. It's not a hard crash like with `draw_text` but it is irrecoverable. So since we already experienced issues with `draw_text` having a weird calling convention the first thing I do is load up my disassembler and go back to that call we found in `gl_drawhud`. We know `playerincrosshair` got inlined so the call we see is actually to `intersectclosest`. So, as expected, it is a weird calling convention again. I'm guessing the global reference moved into edx is the "worldpos" that's passed as the second argument (the "to" parameter), and there's some compiler trickiness happening with the ecx register. First of all, slightly above the call we see that `camera1` is moved into ecx. That's what gets pushed to the call as the third argument (the "at" parameter), and then the compiler adds 4 to ecx which we know 4 is the offset to the `o` or origin field of the `physent` struct. So when the function is called, ecx contains the "from" parameter and edx contains the "to" parameter and both are pointers to vector3s. The rest of the arguments are pushed onto stack in reverse order which is normal.<br>
So we'll have to write a "wrapper" for this function again, using inline assembly:
```cpp
playerent_wrapper* CheatMain::intersectclosest(const Vector3f& from, const Vector3f& to, const playerent_wrapper* at, float& bestdistsquared, int& hitzone, bool aiming /*= true*/)
{
	playerent_wrapper* retVal = NULL;
	__asm
	{
		mov ecx, from
		mov edx, to
		push aiming
		push hitzone
		push bestdistsquared
		push at
		call ointersectclosest
		add esp, 16
		mov retVal, eax
	}
	return retVal;
}
```

We can now call it without crashing, but we still aren't getting the desired result. The function returns a player even if that player is behind a wall.<br>
Looking at the game code more closely this time, I now see that map geometry isn't actually being checked. When the inlined `playerincrosshair()` function calls `intersectclosest`, it passes the `worldpos` global reference. `worldpos` is the point in the world where your crosshair is resting and when the game calculates this it **does** check map geometry with a call to `intersectgeometry`. This is called from `readdepth()` which is called from `gl_drawframe` in rendergl.cpp.<br>
Since I don't want to make the same mistake, I'm going to actually read through `intersectgeometry` before deciding to use it.<br>
So `intersectgeometry` seems to loop a global reference called `world` which sounds promising. However, the function doesn't return a true or false value indicating whether a collision occurred. Instead, it simply shortens the `from` parameter to where the collision occurred. Since I can see edge cases where a collision occurs at the exact end of the ray and floating point equality tests not being super reliable I don't think this is a good function to use.<br>

So it's essentially back to the drawing board for finding a Raycast / Traceline function. All is not lost, though, because we have one big clue: bots exist. Bots have to know whether there's a wall between them and their target. So my idea is to look through the bot code and see what I can find.<br>
I open up the `bot` folder in the game's source code and immediately my eyes are drawn to... `bot_util.h`. I love utility functions as they usually contain loads of useful functions for us. So I see a `TraceLine` function and a `IsVisible` function. Looking at `IsVisible` I can see it just calls `TraceLine` and returns the `traceresult_s->collided` field (this struct is also defined in `bot_util.h` btw).<br>
So now the plan is to see if `TraceLine` or any of its callers contain strings that we could search for in our disassembler. This would make it really easy to find the function address. I don't see any strings in `TraceLine` itself, so I do a search for what calls it.<br>
I see console commands being registered in `botmanager.cpp` but I also see they're wrapped in a `#ifndef RELEASE_BUILD` so they won't be in our binary. I do see some strings in the `CBot::DoCombatNav` function in `bot_ai.cpp` but they call `condebug` and searching for its implementation I can see it's wrapped in the same preprocessor conditional. Same with `debugnav` and `AddDebugText`.<br>
So I couldn't find any strings in the callers of `TraceLine` either. Now, we could continue on to the callers of the callers... but that gets tedious real fast. Still, if worst comes to worst that is an option.<br>
For now, instead, I'll look at the `bot.h` file and I see the definition of `CBot` class has a virtual function named `Think`.<br>
And `CBot::Think` calls a juicy sounding function named `MainAI`, and that calls a function named `FindEnemy` which calls `IsVisible` which finally calls `TraceLine`. I know this seems like a lot, but familiarizing yourself with large codebases is part of the job and makes you a great asset on any team.<br>
So how do we even find `CBot::Think`? Well it's a virtual function, so it'll be part of the virtual table. Thankfully, the game has some Runtime Type Information (RTTI).<br>
In IDA we can use the ClassInformer plugin to parse the RTTI data. It'll show us a new window containing a bunch of classes. Look for `CBot` and double click it to be brought to `CBot::'vftable'`.<br>
In Ghidra, RTTI data is parsed by default (no plugin needed) so if we look at the 'Symbol Tree' window and uncollapse the 'C' folder we should see `CBot`. Uncollapse that to see its vftable.<br>
It's at address `0x55A048`. Now we just count the number of virtual functions defined before our `Think` function: 8. It also helps that it's the last defined virtual function. In general, compilers will lay these things out according to the order they appear in the source code. That's true for most things too, not just virtual functions.<br>
So we finally find `CBot::Think` at address `0x5021F0`. Now we just have to follow that call chain all the way to `TraceLine`.<br>
The first one, `MainAI` is easy because it's part of a conditional: it checks if a value is false and if it is it calls `MainAI` otherwise it calls something else. I found the call at `0x50237F`.<br>
Second, `FindEnemy` is a little trickier but if you notice `BotManager.BotsShoot()` is checked a million different times in this function and realize that it's been inlined then this serves as a pretty good pattern, then it's just a matter of counting the occurences. The second occurence, and the call we're looking for, is around address `0x507F16`.<br>
The third call we're looking for is `IsVisible`. There's some stuff in this one that doesn't quite match up with the source code, but once we realize that it's pretty easy to find what we're looking for. Just before the call to `IsVisible`, both `physent->state` and `physent->team` are referenced, and `CS_ALIVE` is checked too. We know the field offsets and value so it's pretty easy to find the call around address `0x5072F2`.<br>
Finally, `IsVisible` is a short function and only contains one call so that's obviously our `TraceLine` call found at address `0x42D3EC` and the actual address of `TraceLine` itself is `0x509010`.<br>
Before we plug that into our program, notice that the calling convention is weird once again. This time, ecx is xor'd just before the call. Maybe that's the last parameter, 'SkipTags', but I doubt it. We can see the ecx register is being set to the stack pointer and then assigned float values. So it seems the first two parameters, the vectors 'from' and 'to', are being put onto the stack. I think ecx being xor'd is because no caller of `IsVisible` provides a 'pTracer' parameter, so the default is always used which is NULL. Other callers of `TraceLine` seem to put 'pTracer' in the ecx register. One of the bool parameters is put into the dl register which is the low byte of edx. My guess is the 'CheckPlayers' parameter. That leaves us with 2 parameters remaining: the pointer to a traceresult_s struct and the last bool. If we look at how they're used in the `TraceLine` function we can deduce that they are pushed onto the stack as well.<br>
So the calling convention makes sense now: the first two parameters that can fit into a register are put into ecx and edx (in that order) and the rest of the parameters are pushed onto the stack starting from right-most. I don't know how to get visual studio to follow that calling convention (and I'm far too lazy to look it up) so I'll still be writing "wrapper" functions using inline assembly.<br>
Here's what I got:
```cpp
void CheatMain::TraceLine(Vector3f from, Vector3f to, dynent_wrapper* pTracer, bool CheckPlayers, traceresult_wrapper* tr)
{
	__asm
	{
		push 0
		push tr
		push to.z
		push to.y
		push to.x
		push from.z
		push from.y
		push from.x
		mov ecx, pTracer
		mov dl, CheckPlayers
		call oTraceLine
		add esp, 0x20
	}
}
```

And here's how I use it in my `FindNearestTarget` function:
```cpp
playerent_wrapper* CheatMain::FindNearestTarget()
{
	if ((player1 == NULL) || (player1->state != CS_ALIVE)) return NULL;
	if ((bots == NULL) || (bots->count <= 0) || (bots->data[0] == NULL)) return NULL;

	playerent_wrapper* closestTarget = NULL;
	for (int index = 0; index < bots->count; index++)
	{
		playerent_wrapper* bot = bots->data[index];
		if ((bot == NULL) || (bot->state == CS_DEAD) || (bot->team == player1->team)) continue;

		traceresult_wrapper tr{};
		TraceLine(player1->o, bot->o, player1, false, &tr);
		if (tr.collided == false)
		{
			float distSquared = Vector3f::squareddist(player1->o, bot->o);
			if (distSquared < AimDistance)
			{
				AimDistance = distSquared;
				closestTarget = bot;
			}
		}
	}

	return closestTarget;
}
```

And I made some globals so we can color the outline of the target player differently, `AimDistance` and `AimTarget`. Then I modified the `DrawPlayerOutlines2d` function to do the different coloring. This makes it easier to see if it's working as intended or not. It's important to note that the 'CheckPlayers' parameter of `TraceLine` should be `false` because we don't want our ray intersecting with a player to be a bad thing. We only care about collisions with map geometry.<br>
Loading up the game and injecting we can see it works really well.

## Taking Aim ##

So now that we have a function that gives us the nearest visible target, all that remains is to make our player look at that target.<br>
So we need some way of calculating the "aim angle" between us and them and then setting our player's pitch and yaw accordingly.<br>
As mentioned before, calculating the aim angle is some weird math that I don't understand, but here's the function I'll be using that I found on google:
```cpp
// credit: Rake / h4nsbr1x via [https://guidedhacking.com/threads/ultimate-calcangle-thread-how-to-calculate-angle-functions.8165/#post-73276]
Vector3f CalcAngle(Vector3f src, Vector3f dst)
{
	Vector3f angle;
	float dist = Vector3f::dist(src, dst);

	angle.x = -atan2f(dst.x - src.x, dst.y - src.y) / PI * 180.0f + 180.0f;
	angle.y = asinf((dst.z - src.z) / dist) * Rad2Deg;
	angle.z = 0.0f;

	return angle;
}
```

And, finally, the function to tie it all together:
```cpp
void CheatMain::DoAimbot()
{
	if ((player1 == NULL) || (player1->state != CS_ALIVE)) return;

	AimDistance = 3.402823466e+38F;
	AimTarget = FindNearestTarget();

	if (AimTarget != NULL)
	{
		Vector3f aimAngle = CalcAngle(player1->o, AimTarget->o);
		player1->rotation.x = aimAngle.x;
		player1->rotation.y = aimAngle.y;
	}
}
```

Going in-game we can see it works flawlessly:
| ![aimbot-findtarget](guide_images/aimbot_findtarget.png) |
|:--:|
| <sub>Image: Magenta outline for the nearest **visible** aim target</sub> | 

## Codebase ##

You can view the codebase at this specific point in time using this link: https://github.com/kotae4/lab-esp-and-aimbot/tree/Chapter5 <br>
Please note that the guide itself will be changed over time so you should always use the 'main' branch for the non-code portion.<br>

## Summary ##

All that's left are minor improvements and maybe some extra features, but we accomplished the major goals we set out for ourselves: ESP functionality and aimbot functionality.<br>
If you've followed along and performed the same searching, analyzing, and testing that was covered in the guide then you should feel proud of yourself! Not very many people know how to build something like this.<br>
Hopefully this walkthrough provided a helpful level of detail and shed some light on the shadowy world of game hacking too :)
```

`Chapter 6 - Conclusion/README.md`:

```md
# Chapter 6 - Conclusion #

So we're finished! We have a functioning ESP and aimbot and a very detailed writeup of the journey.<br>
However, there's always room for improvement. In this chapter, a few things will be covered:
1. Adding more features (god-mode, infinite ammo, no recoil, perfect accuracy, higher fire rate)
2. Adding an ImGui menu for users to configure various settings in-game
3. Cleaning up the code (why did I make everything static...?)

Code will be pushed after each major point and tagged.

## Part 1 - More Features ##

TO-DO
```

`Complete Project Source Code/assaultcube-esp-aimbot/assaultcube-esp-aimbot.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32210.238
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "assaultcube-esp-aimbot", "assaultcube-esp-aimbot\assaultcube-esp-aimbot.vcxproj", "{F5857EEB-3294-4DA3-9D94-D7A90A27DD7B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F5857EEB-3294-4DA3-9D94-D7A90A27DD7B}.Debug|x86.ActiveCfg = Debug|Win32
		{F5857EEB-3294-4DA3-9D94-D7A90A27DD7B}.Debug|x86.Build.0 = Debug|Win32
		{F5857EEB-3294-4DA3-9D94-D7A90A27DD7B}.Release|x86.ActiveCfg = Release|Win32
		{F5857EEB-3294-4DA3-9D94-D7A90A27DD7B}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B39F9F16-E2A1-46E7-BB5D-07D3E4027DC4}
	EndGlobalSection
EndGlobal

```

`Complete Project Source Code/assaultcube-esp-aimbot/assaultcube-esp-aimbot/CheatMain.cpp`:

```cpp
#include "pch.h"
#include "CheatMain.h"
#include "opengl_wrapper.h"
// for vararg processing in CheatMain::DbgPrint and CheatMain::draw_textf
#include <stdio.h>
#include <stdarg.h>

HMODULE CheatMain::hMod = NULL;
uintptr_t CheatMain::ProcessBaseAddress = NULL;
tgl_drawhud CheatMain::ogl_drawhud_trampoline = NULL;
playerent_wrapper* CheatMain::player1 = NULL;
physent_wrapper* CheatMain::camera1 = NULL;
int* CheatMain::VIRTW = NULL;
font_wrapper* CheatMain::curfont = NULL;
Matrixf* CheatMain::mvpmatrix = NULL;
Vector<playerent_wrapper*>* CheatMain::bots = NULL;
ttext_width CheatMain::otext_width = NULL;
tdraw_text CheatMain::odraw_text = NULL;
tTraceLine CheatMain::oTraceLine = NULL;

// globals
playerent_wrapper* AimTarget = NULL;
float AimDistance = 3.402823466e+38F;

bool CheatMain::AttachDebugConsole(void)
{
	if (FreeConsole())
	{
		if (!AllocConsole())
			return false;
	}
	else if (!AllocConsole())
		return false;

	FILE* pConOutput = nullptr;
	return (freopen_s(&pConOutput, "CONOUT$", "w", stdout) == 0);
}

void CheatMain::DbgPrint(const char* fmt, ...)
{
#ifdef DEBUGPRINT
	va_list args;
	va_start(args, fmt);
	vprintf_s(fmt, args);
	va_end(args);
#endif
	return;
}

void CheatMain::SetupHUDDrawing()
{
	opengl_wrapper::oglDisable(GL_DEPTH_TEST);
	opengl_wrapper::oglMatrixMode(GL_MODELVIEW);
	opengl_wrapper::oglLoadIdentity();
	opengl_wrapper::oglMatrixMode(GL_PROJECTION);
	opengl_wrapper::oglLoadIdentity();
	opengl_wrapper::oglEnable(GL_BLEND);
	opengl_wrapper::oglEnable(GL_TEXTURE_2D);
	opengl_wrapper::oglOrtho(0, (double)*VIRTW * 2, (double)VIRTH * 2, 0, -1, 1);
}

void CheatMain::draw_textf(int x, int y, int r, int g, int b, const char* fmt, ...)
{
	char buf[260];
	va_list args; 
	va_start(args, fmt); 
	int retVal = vsnprintf_s(buf, 260, _TRUNCATE, fmt, args);
	va_end(args);

	draw_text(buf, x, y, r, g, b);
}

void CheatMain::draw_text(const char* str, int x, int y, int r, int g, int b, int a /*= 255*/, int cursor /*= -1*/, int maxwidth /*= -1*/)
{
	__asm
	{
		mov ecx, str
		mov edx, x
		push maxwidth
		push cursor
		push a
		push b
		push g
		push r
		push y
		call odraw_text
		add esp, 28
	}
}

void CheatMain::DrawOutline2d_Color(float xMin, float yMin, float xMax, float yMax, float colorR, float colorG, float colorB)
{
	opengl_wrapper::oglDisable(GL_BLEND);
	opengl_wrapper::oglDisable(GL_TEXTURE_2D);
	opengl_wrapper::oglColor4f(colorR, colorG, colorB, 1.f);
	opengl_wrapper::oglBegin(GL_LINE_LOOP);
	opengl_wrapper::oglVertex2f(xMin, yMin);
	opengl_wrapper::oglVertex2f(xMax, yMin);
	opengl_wrapper::oglVertex2f(xMax, yMax);
	opengl_wrapper::oglVertex2f(xMin, yMax);
	opengl_wrapper::oglEnd();
	opengl_wrapper::oglEnable(GL_BLEND);
	opengl_wrapper::oglEnable(GL_TEXTURE_2D);
}

void DrawLine(float xMin, float yMin, float xMax, float yMax, float colorR, float colorG, float colorB)
{
	opengl_wrapper::oglDisable(GL_BLEND);
	opengl_wrapper::oglDisable(GL_TEXTURE_2D);
	opengl_wrapper::oglColor4f(colorR, colorG, colorB, 1.f);
	opengl_wrapper::oglBegin(GL_LINES);
	opengl_wrapper::oglVertex2f(xMin, yMin);
	opengl_wrapper::oglVertex2f(xMax, yMax);
	opengl_wrapper::oglEnd();
	opengl_wrapper::oglEnable(GL_BLEND);
	opengl_wrapper::oglEnable(GL_TEXTURE_2D);
}

bool WorldToScreen(const Matrixf *transMat, const Vector3f& in, double screenWidth, double screenHeight, Vector3f& out)
{
	// the world-to-screen transformation is some complicated math that i don't fully understand.
	// i usually just copy paste until something works
	// here's some links that may help:
	// https://www.scratchapixel.com/lessons/3d-basic-rendering/computing-pixel-coordinates-of-3d-point/mathematics-computing-2d-coordinates-of-3d-points
	// https://www.3dgep.com/understanding-the-view-matrix/#Transformations
	// https://answers.unity.com/questions/1014337/calculation-behind-cameraworldtoscreenpoint.html
	// https://www.codeproject.com/Articles/42848/A-New-Perspective-on-Viewing
	Vector4f clipCoords(0.f, 0.f, 0.f, 1.f);
	transMat->transform(in, clipCoords);
	if (clipCoords.w < 0.1f) return false;
	Vector3f NDCCoords;
	NDCCoords.x = clipCoords.x / clipCoords.w;
	NDCCoords.y = clipCoords.y / clipCoords.w;
	NDCCoords.z = clipCoords.z / clipCoords.w;
	// normally we'd divide by 2 here as part of the world-to-screen transformation,
	// but the "virtual screen coordinate system" the game uses is actually VIRTW * 2 and VIRTH * 2
	// so we can skip the divide by 2 by not multiplying VIRTW and VIRTH by 2
	out.x = (screenWidth * NDCCoords.x) + (screenWidth + NDCCoords.x);
	out.y = -(screenHeight * NDCCoords.y) + (screenHeight + NDCCoords.y);
	return true;
}

void CheatMain::DrawNametags()
{
	if (player1 == NULL) return;
	if ((bots == NULL) || (bots->count <= 0) || (bots->data[0] == NULL)) return;

	for (int index = 0; index < bots->count; index++)
	{
		playerent_wrapper* bot = bots->data[index];
		if (bot == NULL) continue;

		Vector3f screenPos;
		if (WorldToScreen(mvpmatrix, bot->o, *VIRTW, VIRTH, screenPos) == false)
			continue;

		float dist = Vector3f::dist(player1->o, bot->o);

		if ((bot->state == CS_DEAD) || 
			((player1 == NULL) || (player1->state == CS_SPECTATE) || 
				((player1->state == CS_DEAD) && (player1->spectatemode > SM_NONE))))
			draw_textf(screenPos.x, screenPos.y, 255, 255, 255, "%s [%.2fm]", bot->name, dist);
		else if (bot->team == player1->team)
			draw_textf(screenPos.x, screenPos.y, 0, 255, 0, "%s [%.2fm]", bot->name, dist);
		else
			draw_textf(screenPos.x, screenPos.y, 255, 0, 0, "%s [%.2fm]", bot->name, dist);
	}
}

void CheatMain::DrawPlayerOutlines2d()
{
	if ((bots == NULL) || (bots->count <= 0) || (bots->data[0] == NULL)) return;

	for (int index = 0; index < bots->count; index++)
	{
		playerent_wrapper* bot = bots->data[index];
		if (bot == NULL) continue;

		Vector3f botMin(bot->o.x - bot->radius, bot->o.y, bot->o.z - bot->eyeheight);
		Vector3f botMax(bot->o.x + bot->radius, bot->o.y + bot->radius, bot->o.z);

		Vector3f botScreenMin, botScreenMax;
		bool onScreenMin, onScreenMax;
		onScreenMin = WorldToScreen(mvpmatrix, botMin, *VIRTW, VIRTH, botScreenMin);
		onScreenMax = WorldToScreen(mvpmatrix, botMax, *VIRTW, VIRTH, botScreenMax);

		if ((onScreenMin == false) || (onScreenMax == false)) continue;

		if ((bot->state == CS_DEAD) ||
			((player1 == NULL) || (player1->state == CS_SPECTATE) ||
				((player1->state == CS_DEAD) && (player1->spectatemode > SM_NONE))))
			DrawOutline2d_Color(botScreenMin.x, botScreenMin.y, botScreenMax.x, botScreenMax.y, 1.f, 1.f, 1.f);
		else if (bot == AimTarget)
			DrawOutline2d_Color(botScreenMin.x, botScreenMin.y, botScreenMax.x, botScreenMax.y, 1.f, 0.f, 1.f);
		else if (bot->team == player1->team)
			DrawOutline2d_Color(botScreenMin.x, botScreenMin.y, botScreenMax.x, botScreenMax.y, 0.f, 1.f, 0.f);
		else
			DrawOutline2d_Color(botScreenMin.x, botScreenMin.y, botScreenMax.x, botScreenMax.y, 1.f, 0.f, 0.f);

		// used for figuring out whether positive z is 'up' (it is)
		// and whether physent->o was already at eye level (it is)
		botMin.x -= 0.5f;
		botMin.z = bot->o.z;
		botMax.x += 0.5f;
		botMax.z = bot->o.z;
		Vector3f expMin, expMax;
		onScreenMin = WorldToScreen(mvpmatrix, botMin, *VIRTW, VIRTH, expMin);
		onScreenMax = WorldToScreen(mvpmatrix, botMax, *VIRTW, VIRTH, expMax);
		// yellow line at head-level
		DrawLine(expMin.x, expMin.y, expMax.x, expMax.y, 1.f, 1.f, 0.f);
		botMin.z = bot->o.z - bot->eyeheight;
		botMax.z = bot->o.z - bot->eyeheight;
		onScreenMin = WorldToScreen(mvpmatrix, botMin, *VIRTW, VIRTH, expMin);
		onScreenMax = WorldToScreen(mvpmatrix, botMax, *VIRTW, VIRTH, expMax);
		// cyan line at foot-level
		DrawLine(expMin.x, expMin.y, expMax.x, expMax.y, 0.f, 1.f, 1.f);

	}
}

void CheatMain::TraceLine(Vector3f from, Vector3f to, dynent_wrapper* pTracer, bool CheckPlayers, traceresult_wrapper* tr)
{
	__asm
	{
		push 0
		push tr
		push to.z
		push to.y
		push to.x
		push from.z
		push from.y
		push from.x
		mov ecx, pTracer
		mov dl, CheckPlayers
		call oTraceLine
		add esp, 0x20
	}
}

playerent_wrapper* CheatMain::FindNearestTarget()
{
	if ((player1 == NULL) || (player1->state != CS_ALIVE)) return NULL;
	if ((bots == NULL) || (bots->count <= 0) || (bots->data[0] == NULL)) return NULL;

	playerent_wrapper* closestTarget = NULL;
	for (int index = 0; index < bots->count; index++)
	{
		playerent_wrapper* bot = bots->data[index];
		if ((bot == NULL) || (bot->state == CS_DEAD) || (bot->team == player1->team)) continue;

		traceresult_wrapper tr{};
		TraceLine(player1->o, bot->o, player1, false, &tr);
		if (tr.collided == false)
		{
			float distSquared = Vector3f::squareddist(player1->o, bot->o);
			if (distSquared < AimDistance)
			{
				AimDistance = distSquared;
				closestTarget = bot;
			}
		}
	}

	return closestTarget;
}

// credit: Rake / h4nsbr1x via [https://guidedhacking.com/threads/ultimate-calcangle-thread-how-to-calculate-angle-functions.8165/#post-73276]
Vector3f CalcAngle(Vector3f src, Vector3f dst)
{
	Vector3f angle;
	float dist = Vector3f::dist(src, dst);

	angle.x = -atan2f(dst.x - src.x, dst.y - src.y) / PI * 180.0f + 180.0f;
	angle.y = asinf((dst.z - src.z) / dist) * Rad2Deg;
	angle.z = 0.0f;

	return angle;
}

void CheatMain::DoAimbot()
{
	if ((player1 == NULL) || (player1->state != CS_ALIVE)) return;

	AimDistance = 3.402823466e+38F;
	AimTarget = FindNearestTarget();

	if (AimTarget != NULL)
	{
		Vector3f aimAngle = CalcAngle(player1->o, AimTarget->o);
		player1->rotation.x = aimAngle.x;
		player1->rotation.y = aimAngle.y;
	}
}

void hk_gl_drawhud(int w, int h, int curfps, int nquads, int curvert, bool underwater, int elapsed)
{
	CheatMain::SetupHUDDrawing();
	CheatMain::draw_text("Hello World", 100, 500, 255, 255, 255);

	CheatMain::draw_textf(100, 600, 255, 255, 0, "MyModule: %tx", CheatMain::hMod);
	if (CheatMain::player1 != NULL)
	{
		playerent_wrapper* localPlayer = CheatMain::player1;
		CheatMain::draw_textf(100, 800, 255, 255, 0, "Player1->o: (%.2f, %.2f, %.2f)", localPlayer->o.x, localPlayer->o.y, localPlayer->o.z);
	}
	if (CheatMain::camera1 != NULL)
	{
		physent_wrapper* camera = CheatMain::camera1;
		CheatMain::draw_textf(100, 850, 255, 255, 0, "Camera1->o: (%.2f, %.2f, %.2f)", camera->o.x, camera->o.y, camera->o.z);
	}

	if ((CheatMain::bots != NULL) && (CheatMain::bots->count > 0) && (CheatMain::bots->data[0] != NULL))
	{
		CheatMain::draw_textf(100, 900, 255, 255, 255, "Bot[0]: %tx (@ %tx)\nBot[0]->name: %s (@ %tx)\nBot[0]->o: (%.2f, %.2f, %.2f)",
			CheatMain::bots->data[0], &CheatMain::bots->data[0],
			CheatMain::bots->data[0]->name, &(CheatMain::bots->data[0]->name),
			CheatMain::bots->data[0]->o.x, CheatMain::bots->data[0]->o.y, CheatMain::bots->data[0]->o.z);
	}

	if (AimTarget != NULL)
	{
		CheatMain::draw_textf(2000, 500, 255, 255, 0, "ClosestTarget: %s (%.2f)", AimTarget->name, AimDistance);
	}

	// ESP functionality
	CheatMain::DrawNametags();
	CheatMain::DrawPlayerOutlines2d();

	// aimbot functionality (who would've thunk it)
	CheatMain::DoAimbot();

	// used for debugging :)
	//CheatMain::DrawOutline2d_Color(100, 100, 1000, 1000, 1.f, 0.f, 0.f);

	CheatMain::ogl_drawhud_trampoline(w, h, curfps, nquads, curvert, underwater, elapsed);
}

void CheatMain::ThreadedInitialize(HMODULE hMod)
{
	CheatMain::hMod = hMod;
	CheatMain::ProcessBaseAddress = (uintptr_t)GetModuleHandleA(NULL);
#ifdef DEBUGPRINT
	CheatMain::AttachDebugConsole();
#endif

	if (opengl_wrapper::Initialize() == false)
	{
		DbgPrint("Failed to initialize opengl_wrapper\n");
		return;
	}

	CheatMain::player1 = *(playerent_wrapper**)(0x58ac00);
	CheatMain::camera1 = *(physent_wrapper**)(0x57e0a8);

	CheatMain::VIRTW = (int*)(0x57ed2c);
	CheatMain::curfont = (font_wrapper*)(0x57ED28);
	CheatMain::mvpmatrix = (Matrixf*)(0x57dfd0);
	CheatMain::bots = (Vector<playerent_wrapper*>*)(0x591FCC);

	CheatMain::otext_width = (ttext_width)(0x46E370);
	CheatMain::odraw_text = (tdraw_text)(0x46DD20);
	CheatMain::oTraceLine = (tTraceLine)(0x509010);

	MH_STATUS mhStatus = MH_Initialize();
	if (mhStatus != MH_OK)
	{
		DbgPrint("Could not initialize MinHook (status: %d)\n", mhStatus);
		return;
	}

	uintptr_t gl_drawhud_address = 0x45F1C0;
	mhStatus = MH_CreateHook(reinterpret_cast<LPVOID>(gl_drawhud_address), &hk_gl_drawhud,  reinterpret_cast<LPVOID*>(&CheatMain::ogl_drawhud_trampoline));
	if (mhStatus != MH_OK)
	{
		DbgPrint("Could not create gl_drawhud hook (status: %d)\n", mhStatus);
		return;
	}

	mhStatus = MH_EnableHook(reinterpret_cast<LPVOID>(gl_drawhud_address));
	if (mhStatus != MH_OK)
	{
		DbgPrint("Could not enable gl_drawhud hook (status: %d)\n", mhStatus);
		return;
	}

	DbgPrint("Successfully initialized.\n");

	DbgPrint("Player: %tx\n&Player->health: %tx\nPlayer->health: %d\n", player1, &player1->health, player1->health);
	DbgPrint("Camera: %tx\n&Camera->o: %tx\nCamera->o: (%.2f, %.2f, %.2f)\n", camera1, &camera1->o, camera1->o.x, camera1->o.y, camera1->o.z);
	
	if ((CheatMain::bots != NULL) && (CheatMain::bots->count > 0) && (CheatMain::bots->data[0] != NULL))
	{
		DbgPrint("Bots: %tx\n&Bots->count: %tx\nBots->count: %d\n", bots, &bots->count, bots->count);
		DbgPrint("*Bot[0]: %tx\n&Bot[0]: %tx\n*Bot[0]->name: %s\n", bots->data[0], &bots->data[0], (bots->data[0])->name);
	}
}
```

`Complete Project Source Code/assaultcube-esp-aimbot/assaultcube-esp-aimbot/CheatMain.h`:

```h
#pragma once

#include "game_definitions.h"

#define DEBUGPRINT

#define VIRTH 1800
#define CS_ALIVE 0x0
#define CS_DEAD 0x1
#define CS_SPECTATE 0x5

#define SM_NONE 0x0

void hk_gl_drawhud(int w, int h, int curfps, int nquads, int curvert, bool underwater, int elapsed);

class CheatMain
{
public:
	// we want this class to be purely static
	CheatMain() = delete;
	CheatMain(const CheatMain&) = delete;
	CheatMain& operator=(const CheatMain& o) = delete;
	~CheatMain() = delete;

	static HMODULE hMod;
	static uintptr_t ProcessBaseAddress;
	static void ThreadedInitialize(HMODULE hMod);
	static tgl_drawhud ogl_drawhud_trampoline;

	static bool AttachDebugConsole(void);
	static void DbgPrint(const char* fmt, ...);

	static void SetupHUDDrawing();
	static void draw_textf(int x, int y, int r, int g, int b, const char* fmt, ...);
	static void draw_text(const char* str, int x, int y, int r, int g, int b, int a = 255, int cursor = -1, int maxwidth = -1);
	static void DrawOutline2d_Color(float xMin, float yMin, float xMax, float yMax, float colorR, float colorG, float colorB);

	static void DrawNametags();
	static void DrawPlayerOutlines2d();

	static void TraceLine(Vector3f from, Vector3f to, dynent_wrapper* pTracer, bool CheckPlayers, traceresult_wrapper* tr);
	static playerent_wrapper* FindNearestTarget();
	static void DoAimbot();

	static playerent_wrapper* player1;
	static physent_wrapper* camera1;
	static int* VIRTW;
	static font_wrapper* curfont;
	static Matrixf* mvpmatrix;
	static Vector<playerent_wrapper*>* bots;

	static ttext_width otext_width;
	static tdraw_text odraw_text;
	static tTraceLine oTraceLine;
};
```

`Complete Project Source Code/assaultcube-esp-aimbot/assaultcube-esp-aimbot/assaultcube-esp-aimbot.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f5857eeb-3294-4da3-9d94-d7a90a27dd7b}</ProjectGuid>
    <RootNamespace>assaultcubeespaimbot</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
	<VcpkgTriplet Condition="'$(Platform)'=='Win32'">x86-windows-static</VcpkgTriplet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;ASSAULTCUBEESPAIMBOT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <UseStandardPreprocessor>true</UseStandardPreprocessor>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;ASSAULTCUBEESPAIMBOT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <UseStandardPreprocessor>true</UseStandardPreprocessor>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;ASSAULTCUBEESPAIMBOT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <UseStandardPreprocessor>true</UseStandardPreprocessor>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;ASSAULTCUBEESPAIMBOT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <UseStandardPreprocessor>true</UseStandardPreprocessor>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="CheatMain.h" />
    <ClInclude Include="game_definitions.h" />
    <ClInclude Include="opengl_wrapper.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CheatMain.cpp" />
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="opengl_wrapper.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Complete Project Source Code/assaultcube-esp-aimbot/assaultcube-esp-aimbot/assaultcube-esp-aimbot.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="game_definitions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="opengl_wrapper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CheatMain.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="opengl_wrapper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CheatMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Complete Project Source Code/assaultcube-esp-aimbot/assaultcube-esp-aimbot/dllmain.cpp`:

```cpp
#include "pch.h"

#include "CheatMain.h"



BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    {
        HANDLE hThread = CreateThread(NULL, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(CheatMain::ThreadedInitialize), hModule, 0, NULL);
        CloseHandle(hThread);
        break;
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

`Complete Project Source Code/assaultcube-esp-aimbot/assaultcube-esp-aimbot/game_definitions.h`:

```h
#pragma once

#include <stdint.h>
#include <math.h>

#define PI    (3.141592654f)
#define Rad2Deg (57.295779513082320876798154814105f)

struct Vector3f
{
	float x, y, z;
	Vector3f() { x = y = z = 0; }
	Vector3f(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {}

	static float squareddist(const Vector3f& v1, const Vector3f& v2)
	{
		Vector3f diff{ v1.x - v2.x, v1.y - v2.y, v1.z - v2.z };
		return ((diff.x * diff.x) + (diff.y * diff.y) + (diff.z * diff.z));
	}

	static float dist(const Vector3f& v1, const Vector3f& v2)
	{
		Vector3f diff{ v1.x - v2.x, v1.y - v2.y, v1.z - v2.z };
		return sqrtf((diff.x * diff.x) + (diff.y * diff.y) + (diff.z * diff.z));
	}
};

struct Vector4f
{
	float x, y, z, w;
};

struct Matrixf
{
	float data[16];

	void transform(const Vector3f& in, Vector4f& out) const
	{
		out.x = ((in.x * data[0]) + (in.y * data[4]) + (in.z * data[8]) + data[12]);
		out.y = ((in.x * data[1]) + (in.y * data[5]) + (in.z * data[9]) + data[13]);
		out.z = ((in.x * data[2]) + (in.y * data[6]) + (in.z * data[10]) + data[14]);
		out.w = ((in.x * data[3]) + (in.y * data[7]) + (in.z * data[11]) + data[15]);
	}
};

template<typename T>
struct Vector
{
	T* data;
	int capacity;
	int count;
};

class font_wrapper
{
public:
	char pad_0000[24]; //0x0000
	int32_t defaulth; //0x0018
}; //Size: 0x001C
static_assert(sizeof(font_wrapper) == 0x1C);

class physent_wrapper
{
public:
	Vector3f o; //0x0000
	Vector3f vel; //0x000C
	Vector3f deltapos; //0x0018
	Vector3f newpos; //0x0024
	Vector3f rotation; //0x0030
	float pitchvel; //0x003C
	float maxspeed; //0x0040
	int32_t timeinair; //0x0044
	float radius; //0x0048
	float eyeheight; //0x004C
	float maxeyeheight; //0x0050
	float aboveeye; //0x0054
	bool inwater; //0x0058
	bool onfloor; //0x0059
	bool onladder; //0x005A
	bool jumpnext; //0x005B
	bool jumpd; //0x005C
	bool crouching; //0x005D
	bool crouchedinair; //0x005E
	bool trycrouch; //0x005F
	bool cancollide; //0x0060
	bool stuck; //0x0061
	bool scoping; //0x0062
	char pad_0063[1]; //0x0063
	int32_t lastjump; //0x0064
	float lastjumpheight; //0x0068
	int32_t lastsplash; //0x006C
	int8_t move; //0x0070
	int8_t strafe; //0x0071
	uint8_t state; //0x0072
	uint8_t type; //0x0073
	float eyeheightvel; //0x0074
	int32_t last_pos; //0x0078

	virtual ~physent_wrapper();
	virtual void oncollision();
	virtual void onmoved(const Vector3f& dist);
}; //Size: 0x007C
static_assert(sizeof(physent_wrapper) == 0x0080);

class animstate_wrapper
{
public:
	int32_t anim; //0x0000
	int32_t frame; //0x0004
	int32_t range; //0x0008
	int32_t basetime; //0x000C
	float speed; //0x0010
}; //Size: 0x0014
static_assert(sizeof(animstate_wrapper) == 0x14);

class dynent_wrapper : public physent_wrapper
{
public:
	bool k_left; //0x0000
	bool k_right; //0x0001
	bool k_up; //0x0002
	bool k_down; //0x0003
	class animstate_wrapper prev[2]; //0x0004
	class animstate_wrapper current[2]; //0x002C
	int32_t lastanimswitchtime[2]; //0x0054
	void* lastmodel[2]; //0x005C
	int32_t lastrendered; //0x0064

	virtual ~dynent_wrapper();
}; //Size: 0x0068
static_assert(sizeof(dynent_wrapper) == sizeof(physent_wrapper) + 0x0068);

class playerstate_wrapper
{
public:
	int32_t health; //0x0000
	int32_t armour; //0x0004
	int32_t primary; //0x0008
	int32_t nextprimary; //0x000C
	int32_t gunselect; //0x0010
	bool akimbo; //0x0014
	char pad_0015[3]; //0x0015
	int32_t ammo[9]; //0x0018
	int32_t mag[9]; //0x003C
	int32_t gunwait[9]; //0x0060
	int32_t pstatshots[9]; //0x0084
	int32_t pstatdamage[9]; //0x00A8

	virtual ~playerstate_wrapper();
	virtual void spawnstate(int gamemode);
}; //Size: 0x00CC
static_assert(sizeof(playerstate_wrapper) == 0xD0);

class poshist_wrapper
{
public:
	int32_t nextupdate; //0x0000
	int32_t curpos; //0x0004
	int32_t numpos; //0x0008
	Vector3f pos[7]; //0x000C
}; //Size: 0x0060
static_assert(sizeof(poshist_wrapper) == 0x60);

class playerent_wrapper : public dynent_wrapper, public playerstate_wrapper
{
public:
	int32_t curskin; //0x01B8
	int32_t nextskin[2]; //0x01BC
	int32_t clientnum; //0x01C4
	int32_t lastupdate; //0x01C8
	int32_t plag; //0x01CC
	int32_t ping; //0x01D0
	uint32_t address; //0x01D4
	int32_t lifesequence; //0x01D8
	int32_t frags; //0x01DC
	int32_t flagscore; //0x01E0
	int32_t deaths; //0x01E4
	int32_t tks; //0x01E8
	int32_t lastaction; //0x01EC
	int32_t lastmove; //0x01F0
	int32_t lastpain; //0x01F4
	int32_t lastvoicecom; //0x01F8
	int32_t lastdeath; //0x01FC
	int32_t clientrole; //0x0200
	bool attacking; //0x0204
	char name[260]; //0x0205
	char pad_0309[3]; //0x0309
	int32_t team; //0x030C
	int32_t weaponchanging; //0x0310
	int32_t nextweapon; //0x0314
	int32_t spectatemode; //0x0318
	int32_t followplayercn; //0x031C
	int32_t eardamagemillis; //0x0320
	float maxroll; //0x0324
	float maxrolleffect; //0x0328
	float movroll; //0x032C
	float effroll; //0x0330
	int32_t ffov; //0x0334
	int32_t scopefov; //0x0338
	class weapon_wrapper* weapons[9]; //0x033C
	class weapon_wrapper* prevweaponsel; //0x0360
	class weapon_wrapper* weaponsel; //0x0364
	class weapon_wrapper* nextweaponsel; //0x0368
	class weapon_wrapper* primweap; //0x036C
	class weapon_wrapper* nextprimweap; //0x0370
	class weapon_wrapper* lastattackweapon; //0x0374
	class poshist_wrapper history; //0x0378
	char* skin_noteam; //0x03D8
	char* skin_cla; //0x03DC
	char* skin_rvsf; //0x03E0
	float deltayaw; //0x03E4
	float deltapitch; //0x03E8
	float newyaw; //0x03EC
	float newpitch; //0x03F0
	int32_t smoothmilis; //0x03F4
	Vector3f head; //0x03F8
	bool ignored; //0x0404
	bool muted; //0x0405
	bool nocorpse; //0x0406

	virtual ~playerent_wrapper();
}; //Size: 0x0408
static_assert(sizeof(playerent_wrapper) == sizeof(dynent_wrapper) + sizeof(playerstate_wrapper) + 0x250);

class weapon_wrapper
{
public:
	int32_t type; //0x0004
	class playerent_wrapper* owner; //0x0008
	class guninfo_wrapper* info; //0x000C
	int32_t* ammo; //0x0010
	int32_t* mag; //0x0014
	int32_t* gunwait; //0x0018
	int32_t shots; //0x001C
	int32_t reloading; //0x0020
	int32_t lastaction; //0x0024

	virtual ~weapon_wrapper();
	virtual int dynspread();
	virtual float dynrecoil();
	virtual bool attack(Vector3f& targ);
	virtual void attackfx(const Vector3f& from, const Vector3f& to, int millis);
	virtual void attackphysics(Vector3f& from, Vector3f& to);
	virtual void attacksound();
	virtual bool reload(bool autoreloaded);
	virtual void reset();
	virtual bool busy();
	virtual int modelanim();
	virtual void updatetimers(int millis);
	virtual bool selectable();
	virtual bool deselectable();
	virtual void renderstats();
	virtual void renderhudmodel();
	virtual void renderaimhelp(bool teamwarning);
	virtual void onselecting(bool sound);
	virtual void ondeselecting();
	virtual void onammopicked();
	virtual void onownerdies();
	virtual void removebounceent(uintptr_t* b);
	virtual int flashtime() const;

}; //Size: 0x0028
static_assert(sizeof(weapon_wrapper) == 0x28);

class guninfo_wrapper
{
public:
	char modelname[23]; //0x0000
	char title[42]; //0x0017
	char pad_0041[1]; //0x0041
	int16_t sound; //0x0042
	int16_t reload; //0x0044
	int16_t reloadtime; //0x0046
	int16_t attackdelay; //0x0048
	int16_t damage; //0x004A
	int16_t piercing; //0x004C
	int16_t projspeed; //0x004E
	int16_t part; //0x0050
	int16_t spread; //0x0052
	int16_t recoil; //0x0054
	int16_t magsize; //0x0056
	int16_t mdl_kick_rot; //0x0058
	int16_t mdl_kick_back; //0x005A
	int16_t recoilincrease; //0x005C
	int16_t recoilbase; //0x005E
	int16_t maxrecoil; //0x0060
	int16_t recoilbackfade; //0x0062
	int16_t pushfactor; //0x0064
	bool isauto; //0x0066
	char pad_0067[1]; //0x0067
}; //Size: 0x0068
static_assert(sizeof(guninfo_wrapper) == 0x68);

class traceresult_wrapper
{
public:
	Vector3f end; //0x0000
	bool collided; //0x000C
}; //Size: 0x000D
static_assert(sizeof(traceresult_wrapper) == 0x10);

// function definitions

typedef void(__cdecl* tgl_drawhud)(int w, int h, int curfps, int nquads, int curvert, bool underwater, int elapsed);
typedef int(__cdecl* ttext_width)(const char* str);
typedef void(__cdecl* tdraw_text)(const char* str, int left, int top, int r, int g, int b, int a, int cursor, int maxwidth);
typedef void(__cdecl* tTraceLine)(Vector3f from, Vector3f to, dynent_wrapper* pTracer, bool CheckPlayers, traceresult_wrapper* tr, bool SkipTags);
```

`Complete Project Source Code/assaultcube-esp-aimbot/assaultcube-esp-aimbot/opengl_wrapper.cpp`:

```cpp
#include "pch.h"
#include "opengl_wrapper.h"

tglMatrixMode opengl_wrapper::oglMatrixMode = NULL;
tglPushMatrix opengl_wrapper::oglPushMatrix = NULL;
tglPopMatrix opengl_wrapper::oglPopMatrix = NULL;
tglLoadIdentity opengl_wrapper::oglLoadIdentity = NULL;
tglOrtho opengl_wrapper::oglOrtho = NULL;
tglFrustum opengl_wrapper::oglFrustum = NULL;
tglEnable opengl_wrapper::oglEnable = NULL;
tglDisable opengl_wrapper::oglDisable = NULL;
tglBlendFunc opengl_wrapper::oglBlendFunc = NULL;
tglBegin opengl_wrapper::oglBegin = NULL;
tglEnd opengl_wrapper::oglEnd = NULL;
tglColor4f opengl_wrapper::oglColor4f = NULL;
tglVertex2f opengl_wrapper::oglVertex2f = NULL;
tglVertex3f opengl_wrapper::oglVertex3f = NULL;
tglRotatef opengl_wrapper::oglRotatef = NULL;
tglScalef opengl_wrapper::oglScalef = NULL;
tglTranslatef opengl_wrapper::oglTranslatef = NULL;
tglGetFloatv opengl_wrapper::oglGetFloatv = NULL;

bool opengl_wrapper::Initialize()
{
	HMODULE openGLBase = GetModuleHandleA("OPENGL32.dll");
	if (openGLBase == NULL)
	{
		return false;
	}

#define LoadFcnAddr(fnName) o##fnName = (t##fnName)GetProcAddress(openGLBase, #fnName); \
		if (o##fnName == NULL) \
		{ \
			return false; \
		}

// absolute madness: https://www.scs.stanford.edu/~dm/blog/va-opt.html
// effective madness though...
#define PARENS ()

#define EXPAND(...) EXPAND4(EXPAND4(EXPAND4(EXPAND4(__VA_ARGS__))))
#define EXPAND4(...) EXPAND3(EXPAND3(EXPAND3(EXPAND3(__VA_ARGS__))))
#define EXPAND3(...) EXPAND2(EXPAND2(EXPAND2(EXPAND2(__VA_ARGS__))))
#define EXPAND2(...) EXPAND1(EXPAND1(EXPAND1(EXPAND1(__VA_ARGS__))))
#define EXPAND1(...) __VA_ARGS__

#define FOR_EACH(macro, ...)                                    \
  __VA_OPT__(EXPAND(FOR_EACH_HELPER(macro, __VA_ARGS__)))
#define FOR_EACH_HELPER(macro, a1, ...)                         \
  macro(a1)                                                     \
  __VA_OPT__(FOR_EACH_AGAIN PARENS (macro, __VA_ARGS__))
#define FOR_EACH_AGAIN() FOR_EACH_HELPER

#define LoadAllFcnAddr(...) FOR_EACH(LoadFcnAddr, __VA_ARGS__)

	// this right here saves us a good hundred lines of boilerplate code :)
	LoadAllFcnAddr(glMatrixMode, glPushMatrix, glPopMatrix, glLoadIdentity,
		glOrtho, glFrustum, glEnable, glDisable, glBlendFunc, glBegin,
		glEnd, glColor4f, glVertex2f, glVertex3f, glRotatef, glScalef, glTranslatef, glGetFloatv);


	return true;
}

```

`Complete Project Source Code/assaultcube-esp-aimbot/assaultcube-esp-aimbot/opengl_wrapper.h`:

```h
#pragma once


typedef void(__stdcall *tglMatrixMode)(int mode);
typedef void(__stdcall* tglPushMatrix)(void);
typedef void(__stdcall* tglPopMatrix)(void);
typedef void(__stdcall* tglLoadIdentity)(void);
typedef void(__stdcall* tglOrtho)(double left, double right, double bottom, double top, double nearVal, double farVal);
typedef void(__stdcall* tglFrustum)(double left, double right, double bottom, double top, double nearVal, double farVal);
typedef void(__stdcall* tglEnable)(int cap);
typedef void(__stdcall* tglDisable)(int cap);
typedef void(__stdcall* tglBlendFunc)(int sfactor, int dfactor);
typedef void(__stdcall* tglBegin)(int mode);
typedef void(__stdcall* tglEnd)(void);
typedef void(__stdcall* tglColor4f)(float red, float green, float blue, float alpha);
typedef void(__stdcall* tglVertex2f)(float x, float y);
typedef void(__stdcall* tglVertex3f)(float x, float y, float z);
typedef void(__stdcall* tglRotatef)(float angle, float x, float y, float z);
typedef void(__stdcall* tglScalef)(float x, float y, float z);
typedef void(__stdcall* tglTranslatef)(float x, float y, float z);
typedef void(__stdcall* tglGetFloatv)(int pname, float* params);

#define GL_DEPTH_TEST 0xb71
#define GL_MODELVIEW 0x1700
#define GL_PROJECTION 0x1701
#define GL_BLEND 0xbe2
#define GL_SRC_ALPHA 0x302
#define GL_ONE_MINUS_SRC_ALPHA 0x303
#define GL_LINES 0x1
#define GL_LINE_LOOP 0x2
#define GL_TRIANGLE_STRIP 0x5
#define GL_ONE 0x1
#define GL_TEXTURE_2D 0xde1

class opengl_wrapper
{
public:
	// we want this class to be purely static
	opengl_wrapper() = delete;
	opengl_wrapper(const opengl_wrapper&) = delete;
	opengl_wrapper& operator=(const opengl_wrapper& o) = delete;
	~opengl_wrapper() = delete;


	// static fields

	static tglMatrixMode oglMatrixMode;
	static tglPushMatrix oglPushMatrix;
	static tglPopMatrix oglPopMatrix;
	static tglLoadIdentity oglLoadIdentity;
	static tglOrtho oglOrtho;
	static tglFrustum oglFrustum;
	static tglEnable oglEnable;
	static tglDisable oglDisable;
	static tglBlendFunc oglBlendFunc;
	static tglBegin oglBegin;
	static tglEnd oglEnd;
	static tglColor4f oglColor4f;
	static tglVertex2f oglVertex2f;
	static tglVertex3f oglVertex3f;
	static tglRotatef oglRotatef;
	static tglScalef oglScalef;
	static tglTranslatef oglTranslatef;
	static tglGetFloatv oglGetFloatv;

	// static methods
	
	// loads function addresses via GetProcAddress, returns false if any fail.
	static bool Initialize();
};
```

`Complete Project Source Code/assaultcube-esp-aimbot/assaultcube-esp-aimbot/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`Complete Project Source Code/assaultcube-esp-aimbot/assaultcube-esp-aimbot/pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

// add headers that you want to pre-compile here
#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files
#include <windows.h>

#include <MinHook.h>

#endif //PCH_H

```

`README.md`:

```md
# lab-esp-and-aimbot #

Walkthrough of an ESP and aimbot cheat from scratch for the open-source and free game [Assault Cube](https://assault.cubers.net/).<br>
This is written solely for educational purposes. Please refer to the licenses of all software involved and act in accordance with your governing law.<br>
Reverse engineering and modification of software is an advanced subtopic of CompSci and videogames provide a great medium for learning and practicing these skills. Always hack responsibly.<br>

**Anything built alongside this lab should only be used offline against bots. Don't ruin the enjoyment of others.**<br>
The code provided by this lab will only work against bots, not against real players.

## About Rootkit Education ##

This lab and the accompanying guide were written in collaboration with RootKit, a non-profit organization dedicated to certifying and educating the next generation of aspiring developers in the Computer Science realm through advanced courses and exams. Check out [their github](https://github.com/RootKit-Org) or join [their discord](https://discord.gg/rootkit) to learn more.

## Prerequisites ##

This lab is intended to be the "final step" of the accompanied [intro to gamehacking guide](https://github.com/kotae4/intro-to-gamehacking) so if you've completed the guide you should meet all of the knowledge-based prerequisites already.<br>
It's also recommended that you go through the previous labs before attempting this one as they act as "building blocks" and further reinforce the concepts covered in the guide:
1. [lab-reversing-structures](https://github.com/kotae4/lab-reversing-structures)
2. [lab-hooking-testbed](https://github.com/kotae4/lab-hooking-testbed)

### Knowledge ###

1. Knowledge of C/C++
2. Knowledge of the Portable Executable format
3. Knowledge of what processes are and the role of the Windows Image Loader
2. Knowledge of at least one injection technique
3. Knowledge of at least one hooking technique
4. Basic knowledge of x86 assembly language
5. Conceptual knowledge of ESP and aimbot cheats
    * What it takes to draw boxes around players and make your player face a certain direction

### Software ###

1. A disassembler for static analysis (preferably one with a decompiler too)
    * This walkthrough will use IDA but [Ghidra](https://github.com/NationalSecurityAgency/ghidra) is a great free, open-source alternative.
2. A live memory viewer/editor (preferably w/ built-in disassembler and debugger)
    * This walkthrough will use [cheat engine](https://www.cheatengine.org/)
    * [ReClass.NET](https://github.com/ReClassNET/ReClass.NET) will also be used to better examine data structures
3. Visual Studio. [Community edition](https://visualstudio.microsoft.com/vs/community/) is fine.
4. [vcpkg](https://github.com/microsoft/vcpkg)
5. [Assault Cube official v1.3.0.2 binaries](https://github.com/assaultcube/AC/releases/tag/v1.3.0.2)
    * You only need to download `AssaultCube_v1.3.0.2_LockdownEdition.exe` and install
6. [Assault Cube v1.3.0.2 source code](https://github.com/assaultcube/AC/tree/v1.3.0.2)

Note: v1.3.0.2 is the latest version of assault cube at the time this was written, but it seems development has picked up again so there may be newer versions when you read this. If you want to follow the walkthrough portion of this lab in a one-to-one manner it's important that you download v1.3.0.2 even if it's older.

## Objectives ##

1. To reinforce many concepts covered in the [intro to gamehacking guide](https://github.com/kotae4/intro-to-gamehacking)
2. To gain practical experience with reverse engineering and development of modifications
3. To dispel some of the 'magic' surrounding the development of game cheats
4. To ignite your passion by building something that actually **does stuff**

## Setup Instructions ##

Besides installing and setting up all of the software listed in the prerequisites section, this project will also make use of the [minhook hooking library](https://github.com/TsudaKageyu/minhook) which can be installed globally via vcpkg.<br>
That process will be detailed here:
1. Install vcpkg ([official instructions](https://github.com/microsoft/vcpkg#quick-start-windows)).
2. (optional) Add vcpkg to your PATH environment variable
3. Integrate vcpkg with visual studio (`.\vcpkg\vcpkg integrate install` in elevated command prompt)
4. Install minhook via vcpkg
    * `.\vcpkg\vcpkg install minhook` or just `vcpkg install minhook` if added to PATH
    * The included project uses the x86-windows-static triplet, so the command would be `vcpkg install minhook:x86-windows-static`.

If you installed vcpkg to your system drive (eg: `C:\dev`) and integrated with visual studio correctly then you'll be able to simply `#include <MinHook.h>` in all current and future visual studio projects.

## Table of Contents ##

1. <a href="Chapter 1 - Defining Objectives %26 Gathering Information">Chapter 1 - Defining Our Objectives & Gathering Information</a>
2. <a href="Chapter 2 - Static Analysis - Exploring The Game's Executable File">Chapter 2 - Static Analysis - Exploring The Game's Executable File</a>
3. <a href="Chapter 3 - Dynamic Analysis - Confirming Our Findings">Chapter 3 - Dynamic Analysis - Confirming Our Findings</a>
4. <a href="Chapter 4 - Writing The ESP">Chapter 4 - Writing The ESP</a>
5. <a href="Chapter 5 - Writing The Aimbot">Chapter 5 - Writing The Aimbot</a>
6. <a href="Chapter 6 - Conclusion">Chapter 6 - Conclusion</a>
```