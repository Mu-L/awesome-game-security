Project Path: arc_blacktop_ida-mcp-rs_kdavfeu1

Source Tree:

```txt
arc_blacktop_ida-mcp-rs_kdavfeu1
├── Cargo.lock
├── Cargo.toml
├── LICENSE
├── README.md
├── build.rs
├── docs
│   ├── BUILDING.md
│   ├── README.md
│   ├── TESTING.md
│   ├── TOOLS.md
│   └── TRANSPORTS.md
├── justfile
├── src
│   ├── bin
│   │   └── gen_tools_doc.rs
│   ├── disasm.rs
│   ├── dsc.rs
│   ├── error.rs
│   ├── ida
│   │   ├── handlers
│   │   │   ├── address.rs
│   │   │   ├── analysis.rs
│   │   │   ├── annotations.rs
│   │   │   ├── controlflow.rs
│   │   │   ├── database.rs
│   │   │   ├── disasm.rs
│   │   │   ├── functions.rs
│   │   │   ├── globals.rs
│   │   │   ├── imports.rs
│   │   │   ├── memory.rs
│   │   │   ├── mod.rs
│   │   │   ├── script.rs
│   │   │   ├── search.rs
│   │   │   ├── segments.rs
│   │   │   ├── strings.rs
│   │   │   ├── structs.rs
│   │   │   ├── types.rs
│   │   │   └── xrefs.rs
│   │   ├── lock.rs
│   │   ├── loop_impl.rs
│   │   ├── mod.rs
│   │   ├── request.rs
│   │   ├── types.rs
│   │   └── worker.rs
│   ├── lib.rs
│   ├── main.rs
│   ├── server
│   │   ├── mod.rs
│   │   ├── requests.rs
│   │   └── task.rs
│   └── tool_registry.rs
└── test
    ├── README.md
    ├── http_integration.sh
    ├── justfile
    └── payloads
        ├── dsc.jsonl
        ├── mini.jsonl
        └── script.jsonl

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "aho-corasick"
version = "1.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddd31a130427c27518df266943a5308ed92d4b226cc639f5a8f1002816174301"
dependencies = [
 "memchr",
]

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anstream"
version = "0.6.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43d5b281e737544384e969a5ccad3f1cdd24b48086a0fc1b2a5262a26b8f4f4a"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5192cca8006f1fd4f7237516f40fa183bb07f8fbdfedaa0036de5ea9b0b45e78"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40c48f72fd53cd289104fc64099abca73db4166ad86ea0b4341abe65af83dadc"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "291e6a250ff86cd4a820112fb8898808a366d8f9f58ce16d1f538353ad55747d"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.61.2",
]

[[package]]
name = "anyhow"
version = "1.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a23eb6b1614318a8071c9b2521f36b424b2c83db5eb3a0fead4a6c0809af6e61"

[[package]]
name = "aquamarine"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a941c39708478e8eea39243b5983f1c42d2717b3620ee91f4a52115fd02ac43f"
dependencies = [
 "itertools 0.9.0",
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "async-trait"
version = "0.1.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9035ad2d096bed7955a320ee7e2230574d28fd3c3a0f186cbea1ff3c7eed5dbb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "atty"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
dependencies = [
 "hermit-abi",
 "libc",
 "winapi",
]

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "autocxx"
version = "0.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "54119c5e38d82c13a66cf6c6e6d089ff61c2a8f956b61f50485fd636e8f64656"
dependencies = [
 "aquamarine",
 "autocxx-macro",
 "cxx",
 "moveit",
]

[[package]]
name = "autocxx-bindgen"
version = "0.71.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7d41cf081e31a74378456586b47a5bae2b75a98e5f7c248c9d9bf433e3637f4"
dependencies = [
 "bitflags",
 "cexpr",
 "clang-sys",
 "itertools 0.13.0",
 "log",
 "prettyplease",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash",
 "shlex",
 "syn 2.0.114",
]

[[package]]
name = "autocxx-build"
version = "0.27.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d123397e75f904758fef490775a00b0ada545ab409cb0163d919799e5a30119b"
dependencies = [
 "autocxx-engine",
 "env_logger",
 "indexmap 1.9.3",
 "syn 2.0.114",
]

[[package]]
name = "autocxx-engine"
version = "0.27.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d8f30534af0f55d56743806ea9d49fbd85559f2bd3ec074fb3268ad1827fa92"
dependencies = [
 "aquamarine",
 "autocxx-bindgen",
 "autocxx-parser",
 "cc",
 "cxx-gen",
 "indexmap 1.9.3",
 "indoc",
 "itertools 0.10.5",
 "log",
 "miette",
 "once_cell",
 "prettyplease",
 "proc-macro2",
 "quote",
 "regex",
 "rustversion",
 "serde_json",
 "syn 2.0.114",
 "tempfile",
 "thiserror 1.0.69",
 "version_check",
]

[[package]]
name = "autocxx-macro"
version = "0.27.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a3c6868514727e4da46049b79941d989606e9eb054fb1915f02cad10a356b37"
dependencies = [
 "autocxx-parser",
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "autocxx-parser"
version = "0.27.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cbe64c4c35a76ef3229505d336b3eef29e95b28f457b75e0f84b456a8107af9"
dependencies = [
 "indexmap 1.9.3",
 "itertools 0.10.5",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "serde",
 "serde_json",
 "syn 2.0.114",
 "thiserror 1.0.69",
]

[[package]]
name = "axum"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b52af3cb4058c895d37317bb27508dccc8e5f2d39454016b297bf4a400597b8"
dependencies = [
 "axum-core",
 "bytes",
 "form_urlencoded",
 "futures-util",
 "http",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-util",
 "itoa",
 "matchit",
 "memchr",
 "mime",
 "percent-encoding",
 "pin-project-lite",
 "serde_core",
 "serde_json",
 "serde_path_to_error",
 "serde_urlencoded",
 "sync_wrapper",
 "tokio",
 "tower",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "axum-core"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08c78f31d7b1291f7ee735c1c6780ccde7785daae9a9206026862dab7d8792d1"
dependencies = [
 "bytes",
 "futures-core",
 "http",
 "http-body",
 "http-body-util",
 "mime",
 "pin-project-lite",
 "sync_wrapper",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "bitflags"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "812e12b5285cc515a9c72a5c1d3b6d46a19dac5acfef5265968c166106e31dd3"

[[package]]
name = "bumpalo"
version = "3.19.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5dd9dc738b7a8311c7ade152424974d8115f2cdad61e8dab8dac9f2362298510"

[[package]]
name = "bytes"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b35204fbdc0b3f4446b89fc1ac2cf84a8a68971995d0bf2e925ec7cd960f9cb3"

[[package]]
name = "cc"
version = "1.2.53"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "755d2fce177175ffca841e9a06afdb2c4ab0f593d53b4dee48147dfaade85932"
dependencies = [
 "find-msvc-tools",
 "shlex",
]

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-if"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9330f8b2ff13f34540b44e946ef35111825727b38d33286ef986142615121801"

[[package]]
name = "chrono"
version = "0.4.43"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fac4744fb15ae8337dc853fee7fb3f4e48c0fbaa23d0afe49c447b4fab126118"
dependencies = [
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "serde",
 "wasm-bindgen",
 "windows-link",
]

[[package]]
name = "clang-sys"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
dependencies = [
 "glob",
 "libc",
 "libloading",
]

[[package]]
name = "clap"
version = "4.5.54"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c6e6ff9dcd79cff5cd969a17a545d79e84ab086e444102a591e288a8aa3ce394"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.54"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa42cf4d2b7a41bc8f663a7cab4031ebafa1bf3875705bfaf8466dc60ab52c00"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.49"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a0b5487afeab2deb2ff4e03a807ad1a03ac532ff5a2cee5d86884440c7f7671"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "clap_lex"
version = "0.7.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3e64b0cc0439b12df2fa678eae89a1c56a529fd067a9115f7827f1fffd22b32"

[[package]]
name = "codespan-reporting"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af491d569909a7e4dee0ad7db7f5341fef5c614d5b8ec8cf765732aba3cff681"
dependencies = [
 "serde",
 "termcolor",
 "unicode-width 0.2.2",
]

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cxx"
version = "1.0.192"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbda285ba6e5866529faf76352bdf73801d9b44a6308d7cd58ca2379f378e994"
dependencies = [
 "cc",
 "cxx-build",
 "cxxbridge-cmd",
 "cxxbridge-flags",
 "cxxbridge-macro",
 "foldhash",
 "link-cplusplus",
]

[[package]]
name = "cxx-build"
version = "1.0.192"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af9efde466c5d532d57efd92f861da3bdb7f61e369128ce8b4c3fe0c9de4fa4d"
dependencies = [
 "cc",
 "codespan-reporting",
 "indexmap 2.13.0",
 "proc-macro2",
 "quote",
 "scratch",
 "syn 2.0.114",
]

[[package]]
name = "cxx-gen"
version = "0.7.192"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee08d1131e8f050a1d1acbb7c699e5c8d29c325dffc382331c280d99f98c2618"
dependencies = [
 "codespan-reporting",
 "indexmap 2.13.0",
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "cxxbridge-cmd"
version = "1.0.192"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3efb93799095bccd4f763ca07997dc39a69e5e61ab52d2c407d4988d21ce144d"
dependencies = [
 "clap",
 "codespan-reporting",
 "indexmap 2.13.0",
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "cxxbridge-flags"
version = "1.0.192"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3092010228026e143b32a4463ed9fa8f86dca266af4bf5f3b2a26e113dbe4e45"

[[package]]
name = "cxxbridge-macro"
version = "1.0.192"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31d72ebfcd351ae404fb00ff378dfc9571827a00722c9e735c9181aec320ba0a"
dependencies = [
 "indexmap 2.13.0",
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "darling"
version = "0.23.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25ae13da2f202d56bd7f91c25fba009e7717a1e4a1cc98a76d844b65ae912e9d"
dependencies = [
 "darling_core",
 "darling_macro",
]

[[package]]
name = "darling_core"
version = "0.23.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9865a50f7c335f53564bb694ef660825eb8610e0a53d3e11bf1b0d3df31e03b0"
dependencies = [
 "ident_case",
 "proc-macro2",
 "quote",
 "strsim",
 "syn 2.0.114",
]

[[package]]
name = "darling_macro"
version = "0.23.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3984ec7bd6cfa798e62b4a642426a5be0e68f9401cfc2a01e3fa9ea2fcdb8d"
dependencies = [
 "darling_core",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "dyn-clone"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0881ea181b1df73ff77ffaaf9c7544ecc11e82fba9b5f27b262a3c73a332555"

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "env_logger"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a12e6657c4c97ebab115a42dcee77225f7f482cdd841cf7088c657a42e9e00e7"
dependencies = [
 "atty",
 "humantime",
 "log",
 "regex",
 "termcolor",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "errno"
version = "0.3.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39cab71617ae0d63f51a36d69f866391735b51691dbda63cf6f96d042b63efeb"
dependencies = [
 "libc",
 "windows-sys 0.61.2",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "find-msvc-tools"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8591b0bcc8a98a64310a2fae1bb3e9b8564dd10e381e6e28010fde8e8e8568db"

[[package]]
name = "foldhash"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77ce24cb58228fbb8aa041425bb1050850ac19177686ea6e0f41a70416f56fdb"

[[package]]
name = "form_urlencoded"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb4cb245038516f5f85277875cdaa4f7d2c9a0fa0468de06ed190163b1581fcf"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "getrandom"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "899def5c37c4fd7b2664648c28120ecec138e4d395b459e5ca34f9cce2dd77fd"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasip2",
]

[[package]]
name = "glob"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cc23270f6e1808e30a928bdc84dea0b9b4136a8bc82338574f23baf47bbd280"

[[package]]
name = "hashbrown"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"

[[package]]
name = "hashbrown"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "841d1cc9bed7f9236f321df977030373f4a4163ae1a7dbfe1a51a2c1a51d9100"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33"
dependencies = [
 "libc",
]

[[package]]
name = "http"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3ba2a386d7f85a81f119ad7498ebe444d2e22c2af0b86b069416ace48b3311a"
dependencies = [
 "bytes",
 "itoa",
]

[[package]]
name = "http-body"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
dependencies = [
 "bytes",
 "http",
]

[[package]]
name = "http-body-util"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b021d93e26becf5dc7e1b75b1bed1fd93124b374ceb73f43d4d4eafec896a64a"
dependencies = [
 "bytes",
 "futures-core",
 "http",
 "http-body",
 "pin-project-lite",
]

[[package]]
name = "httparse"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6dbf3de79e51f3d586ab4cb9d5c3e2c14aa28ed23d180cf89b4df0454a69cc87"

[[package]]
name = "httpdate"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"

[[package]]
name = "humantime"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "135b12329e5e3ce057a9f972339ea52bc954fe1e9358ef27f95e89716fbc5424"

[[package]]
name = "hyper"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2ab2d4f250c3d7b1c9fcdff1cece94ea4e2dfbec68614f7b87cb205f24ca9d11"
dependencies = [
 "atomic-waker",
 "bytes",
 "futures-channel",
 "futures-core",
 "http",
 "http-body",
 "httparse",
 "httpdate",
 "itoa",
 "pin-project-lite",
 "pin-utils",
 "smallvec",
 "tokio",
]

[[package]]
name = "hyper-util"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "727805d60e7938b76b826a6ef209eb70eaa1812794f9424d4a4e2d740662df5f"
dependencies = [
 "bytes",
 "futures-core",
 "http",
 "http-body",
 "hyper",
 "pin-project-lite",
 "tokio",
 "tower-service",
]

[[package]]
name = "iana-time-zone"
version = "0.1.64"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "log",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "ida-mcp"
version = "0.9.3"
dependencies = [
 "anyhow",
 "bytes",
 "clap",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-util",
 "idalib",
 "idalib-build",
 "libc",
 "rmcp",
 "schemars",
 "serde",
 "serde_json",
 "thiserror 2.0.18",
 "tokio",
 "tokio-util",
 "tower-service",
 "tracing",
 "tracing-subscriber",
]

[[package]]
name = "idalib"
version = "0.7.3+9.3.260213"
source = "git+https://github.com/blacktop/idalib.git?branch=sdk-9.3#849c45ab770931d41e5264dfb184554acbc94985"
dependencies = [
 "anyhow",
 "autocxx",
 "bitflags",
 "cxx",
 "idalib-build",
 "idalib-sys",
 "thiserror 1.0.69",
]

[[package]]
name = "idalib-build"
version = "0.7.3+9.3.260213"
source = "git+https://github.com/blacktop/idalib.git?branch=sdk-9.3#849c45ab770931d41e5264dfb184554acbc94985"
dependencies = [
 "anyhow",
 "idalib-sys",
]

[[package]]
name = "idalib-sys"
version = "0.7.3+9.3.260213"
source = "git+https://github.com/blacktop/idalib.git?branch=sdk-9.3#849c45ab770931d41e5264dfb184554acbc94985"
dependencies = [
 "anyhow",
 "autocxx",
 "autocxx-bindgen",
 "autocxx-build",
 "bitflags",
 "cxx",
 "cxx-build",
 "libc",
 "objc",
 "thiserror 1.0.69",
 "windows-sys 0.59.0",
]

[[package]]
name = "ident_case"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"

[[package]]
name = "indexmap"
version = "1.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
dependencies = [
 "autocfg",
 "hashbrown 0.12.3",
 "serde",
]

[[package]]
name = "indexmap"
version = "2.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7714e70437a7dc3ac8eb7e6f8df75fd8eb422675fc7678aff7364301092b1017"
dependencies = [
 "equivalent",
 "hashbrown 0.16.1",
]

[[package]]
name = "indoc"
version = "1.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa799dd5ed20a7e349f3b4639aa80d74549c81716d9ec4f994c9b5815598306"

[[package]]
name = "is_terminal_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6cb138bb79a146c1bd460005623e142ef0181e3d0219cb493e02f7d08a35695"

[[package]]
name = "itertools"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "284f18f85651fe11e8a991b2adb42cb078325c996ed026d994719efcfca1d54b"
dependencies = [
 "either",
]

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itertools"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "413ee7dfc52ee1a4949ceeb7dbc8a33f2d6c088194d9f922fb8318faf1f01186"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92ecc6618181def0457392ccd0ee51198e065e016d1d527a7ac1b6dc7c1f09d2"

[[package]]
name = "js-sys"
version = "0.3.85"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c942ebf8e95485ca0d52d97da7c5a2c387d0e7f0ba4c35e93bfcaee045955b3"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.180"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bcc35a38544a891a5f7c865aca548a982ccb3b8650a5b06d0fd33a10283c56fc"

[[package]]
name = "libloading"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d7c4b02199fee7c5d21a5ae7d8cfa79a6ef5bb2fc834d6e9058e89c825efdc55"
dependencies = [
 "cfg-if",
 "windows-link",
]

[[package]]
name = "link-cplusplus"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f78c730aaa7d0b9336a299029ea49f9ee53b0ed06e9202e8cb7db9bae7b8c82"
dependencies = [
 "cc",
]

[[package]]
name = "linux-raw-sys"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df1d3c3b53da64cf5760482273a98e575c651a67eec7f77df96b5b642de8f039"

[[package]]
name = "log"
version = "0.4.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e5032e24019045c762d3c0f28f5b6b8bbf38563a65908389bf7978758920897"

[[package]]
name = "malloc_buf"
version = "0.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62bb907fe88d54d8d9ce32a3cceab4218ed2f6b7d35617cafe9adf84e43919cb"
dependencies = [
 "libc",
]

[[package]]
name = "matchers"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d1525a2a28c7f4fa0fc98bb91ae755d1e2d1505079e05539e35bc876b5d65ae9"
dependencies = [
 "regex-automata",
]

[[package]]
name = "matchit"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "47e1ffaa40ddd1f3ed91f717a33c8c0ee23fff369e3aa8772b9605cc1d22f4c3"

[[package]]
name = "memchr"
version = "2.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f52b00d39961fc5b2736ea853c9cc86238e165017a493d1d5c8eac6bdc4cc273"

[[package]]
name = "miette"
version = "5.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59bb584eaeeab6bd0226ccf3509a69d7936d148cf3d036ad350abe35e8c6856e"
dependencies = [
 "miette-derive",
 "once_cell",
 "thiserror 1.0.69",
 "unicode-width 0.1.14",
]

[[package]]
name = "miette-derive"
version = "5.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49e7bc1560b95a3c4a25d03de42fe76ca718ab92d1a22a55b9b4cf67b3ae635c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "mio"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a69bcab0ad47271a0234d9422b131806bf3968021e5dc9328caf2d4cd58557fc"
dependencies = [
 "libc",
 "wasi",
 "windows-sys 0.61.2",
]

[[package]]
name = "moveit"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87d7335204cb6ef7bd647fa6db0be3e4d7aa25b5823a7aa030027ddf512cefba"
dependencies = [
 "cxx",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "nu-ansi-term"
version = "0.50.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7957b9740744892f114936ab4a57b3f487491bbeafaf8083688b16841a4240e5"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "objc"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "915b1b472bc21c53464d6c8461c9d3af805ba1ef837e1cac254428f4a77177b1"
dependencies = [
 "malloc_buf",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "384b8ab6d37215f3c5301a95a4accb5d64aa607f1fcb26a11b5303878451b4fe"

[[package]]
name = "pastey"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b867cad97c0791bbd3aaa6472142568c6c9e8f71937e98379f584cfb0cf35bec"

[[package]]
name = "percent-encoding"
version = "2.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b4f627cb1b25917193a259e49bdad08f671f8d9708acfd5fe0a8c1455d87220"

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "prettyplease"
version = "0.2.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "479ca8adacdd7ce8f1fb39ce9ecccbfe93a3f1344b3d0d97f20bc0196208f62b"
dependencies = [
 "proc-macro2",
 "syn 2.0.114",
]

[[package]]
name = "proc-macro-error"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
dependencies = [
 "proc-macro-error-attr",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
 "version_check",
]

[[package]]
name = "proc-macro-error-attr"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
dependencies = [
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro2"
version = "1.0.105"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "535d180e0ecab6268a3e718bb9fd44db66bbbc256257165fc699dadf70d16fe7"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.43"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc74d9a594b72ae6656596548f56f667211f8a97b3d4c3d467150794690dc40a"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rand"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6db2770f06117d490610c7488547d543617b21bfa07796d7a12f6f1bd53850d1"
dependencies = [
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76afc826de14238e6e8c374ddcc1fa19e374fd8dd986b0d2af0d02377261d83c"
dependencies = [
 "getrandom",
]

[[package]]
name = "ref-cast"
version = "1.0.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f354300ae66f76f1c85c5f84693f0ce81d747e2c3f21a45fef496d89c960bf7d"
dependencies = [
 "ref-cast-impl",
]

[[package]]
name = "ref-cast-impl"
version = "1.0.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b7186006dcb21920990093f30e3dea63b7d6e977bf1256be20c3563a5db070da"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "regex"
version = "1.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "843bc0191f75f3e22651ae5f1e72939ab2f72a4bc30fa80a066bd66edefc24d4"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5276caf25ac86c8d810222b3dbb938e512c55c6831a10f3e6ed1c93b84041f1c"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2d987857b319362043e95f5353c0535c1f58eec5336fdfcf626430af7def58"

[[package]]
name = "rmcp"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bef41ebc9ebed2c1b1d90203e9d1756091e8a00bbc3107676151f39868ca0ee"
dependencies = [
 "async-trait",
 "axum",
 "base64",
 "bytes",
 "chrono",
 "futures",
 "http",
 "http-body",
 "http-body-util",
 "pastey",
 "pin-project-lite",
 "rand",
 "rmcp-macros",
 "schemars",
 "serde",
 "serde_json",
 "sse-stream",
 "thiserror 2.0.18",
 "tokio",
 "tokio-stream",
 "tokio-util",
 "tower-service",
 "tracing",
 "uuid",
]

[[package]]
name = "rmcp-macros"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e88ad84b8b6237a934534a62b379a5be6388915663c0cc598ceb9b3292bbbfe"
dependencies = [
 "darling",
 "proc-macro2",
 "quote",
 "serde_json",
 "syn 2.0.114",
]

[[package]]
name = "rustc-hash"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"

[[package]]
name = "rustix"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "146c9e247ccc180c1f61615433868c99f3de3ae256a30a43b49f67c2d9171f34"
dependencies = [
 "bitflags",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.61.2",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "ryu"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a50f4cf475b65d88e057964e0e9bb1f0aa9bbb2036dc65c64596b42932536984"

[[package]]
name = "schemars"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "54e910108742c57a770f492731f99be216a52fadd361b06c8fb59d74ccc267d2"
dependencies = [
 "chrono",
 "dyn-clone",
 "ref-cast",
 "schemars_derive",
 "serde",
 "serde_json",
]

[[package]]
name = "schemars_derive"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4908ad288c5035a8eb12cfdf0d49270def0a268ee162b75eeee0f85d155a7c45"
dependencies = [
 "proc-macro2",
 "quote",
 "serde_derive_internals",
 "syn 2.0.114",
]

[[package]]
name = "scratch"
version = "1.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d68f2ec51b097e4c1a75b681a8bec621909b5e91f15bb7b840c4f2f7b01148b2"

[[package]]
name = "serde"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a8e94ea7f378bd32cbbd37198a4a91436180c5bb472411e48b5ec2e2124ae9e"
dependencies = [
 "serde_core",
 "serde_derive",
]

[[package]]
name = "serde_core"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d385c7d4ca58e59fc732af25c3983b67ac852c1a25000afe1175de458b67ad"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d540f220d3187173da220f885ab66608367b6574e925011a9353e4badda91d79"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "serde_derive_internals"
version = "0.29.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "18d26a20a969b9e3fdf2fc2d9f21eda6c40e2de84c9408bb5d3b05d499aae711"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "serde_json"
version = "1.0.149"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83fc039473c5595ace860d8c4fafa220ff474b3fc6bfdb4293327f1a37e94d86"
dependencies = [
 "itoa",
 "memchr",
 "serde",
 "serde_core",
 "zmij",
]

[[package]]
name = "serde_path_to_error"
version = "0.1.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "10a9ff822e371bb5403e391ecd83e182e0e77ba7f6fe0160b795797109d1b457"
dependencies = [
 "itoa",
 "serde",
 "serde_core",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4db69cba1110affc0e9f7bcd48bbf87b3f4fc7c61fc9155afd4c469eb3d6c1b"
dependencies = [
 "errno",
 "libc",
]

[[package]]
name = "slab"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2ae44ef20feb57a68b23d846850f861394c2e02dc425a50098ae8c90267589"

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "socket2"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17129e116933cf371d018bb80ae557e889637989d8638274fb25622827b03881"
dependencies = [
 "libc",
 "windows-sys 0.60.2",
]

[[package]]
name = "sse-stream"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb4dc4d33c68ec1f27d386b5610a351922656e1fdf5c05bbaad930cd1519479a"
dependencies = [
 "bytes",
 "futures-util",
 "http-body",
 "http-body-util",
 "pin-project-lite",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.114"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4d107df263a3013ef9b1879b0df87d706ff80f65a86ea879bd9c31f9b307c2a"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sync_wrapper"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bf256ce5efdfa370213c1dabab5935a12e49f2c58d15e9eac2870d3b4f27263"

[[package]]
name = "tempfile"
version = "3.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "655da9c7eb6305c55742045d5a8d2037996d61d8de95806335c7c86ce0f82e9c"
dependencies = [
 "fastrand",
 "getrandom",
 "once_cell",
 "rustix",
 "windows-sys 0.61.2",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4288b5bcbc7920c07a1149a35cf9590a2aa808e0bc1eafaade0b80947865fbc4"
dependencies = [
 "thiserror-impl 2.0.18",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "thiserror-impl"
version = "2.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebc4ee7f67670e9b64d05fa4253e753e016c6c95ff35b89b7941d6b856dec1d5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "tokio"
version = "1.49.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72a2903cd7736441aac9df9d7688bd0ce48edccaadf181c3b90be801e81d3d86"
dependencies = [
 "bytes",
 "libc",
 "mio",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.61.2",
]

[[package]]
name = "tokio-macros"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af407857209536a95c8e56f8231ef2c2e2aff839b22e07a1ffcbc617e9db9fa5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "tokio-stream"
version = "0.1.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32da49809aab5c3bc678af03902d4ccddea2a87d028d86392a4b1560c6906c70"
dependencies = [
 "futures-core",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "tokio-util"
version = "0.7.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ae9cec805b01e8fc3fd2fe289f89149a9b66dd16786abd8b19cfa7b48cb0098"
dependencies = [
 "bytes",
 "futures-core",
 "futures-sink",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "tower"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebe5ef63511595f1344e2d5cfa636d973292adc0eec1f0ad45fae9f0851ab1d4"
dependencies = [
 "futures-core",
 "futures-util",
 "pin-project-lite",
 "sync_wrapper",
 "tokio",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "tower-layer"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"

[[package]]
name = "tower-service"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"

[[package]]
name = "tracing"
version = "0.1.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "63e71662fa4b2a2c3a26f570f037eb95bb1f85397f3cd8076caed2f026a6d100"
dependencies = [
 "log",
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7490cfa5ec963746568740651ac6781f701c9c5ea257c58e057f3ba8cf69e8da"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "tracing-core"
version = "0.1.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db97caf9d906fbde555dd62fa95ddba9eecfd14cb388e4f491a66d74cd5fb79a"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f30143827ddab0d256fd843b7a66d164e9f271cfa0dde49142c5ca0ca291f1e"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex-automata",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "unicode-ident"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9312f7c4f6ff9069b165498234ce8be658059c6728633667c526e27dc2cf1df5"

[[package]]
name = "unicode-width"
version = "0.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"

[[package]]
name = "unicode-width"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4ac048d71ede7ee76d585517add45da530660ef4390e49b098733c6e897f254"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "uuid"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2e054861b4bd027cd373e18e8d8d8e6548085000e41290d95ce0c373a654b4a"
dependencies = [
 "getrandom",
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasip2"
version = "1.0.2+wasi-0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9517f9239f02c069db75e65f174b3da828fe5f5b945c4dd26bd25d89c03ebcf5"
dependencies = [
 "wit-bindgen",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.108"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64024a30ec1e37399cf85a7ffefebdb72205ca1c972291c51512360d90bd8566"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.108"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "008b239d9c740232e71bd39e8ef6429d27097518b6b30bdf9086833bd5b6d608"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.108"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5256bae2d58f54820e6490f9839c49780dff84c65aeab9e772f15d5f0e913a55"
dependencies = [
 "bumpalo",
 "proc-macro2",
 "quote",
 "syn 2.0.114",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.108"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f01b580c9ac74c8d8f0c0e4afb04eeef2acf145458e52c03845ee9cd23e3d12"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2a7b1c03c876122aa43f3020e6c3c3ee5c05081c9a00739faf7503aeba10d22"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-core"
version = "0.62.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8e83a14d34d0623b51dce9581199302a221863196a1dde71a7663a4c2be9deb"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-implement"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "053e2e040ab57b9dc951b72c264860db7eb3b0200ba345b4e4c3b14f67855ddf"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "windows-interface"
version = "0.59.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f316c4a2570ba26bbec722032c4099d8c8bc095efccdc15688708623367e358"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-result"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7781fa89eaf60850ac3d2da7af8e5242a5ea78d1a11c49bf2910bb5a73853eb5"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7837d08f69c77cf6b07689544538e017c1bfcf57e34b4c0ff58e6c2cd3b37091"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets 0.53.5",
]

[[package]]
name = "windows-sys"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm 0.52.6",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.53.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4945f9f551b88e0d65f3db0bc25c33b8acea4d9e41163edf90dcd0b19f9069f3"
dependencies = [
 "windows-link",
 "windows_aarch64_gnullvm 0.53.1",
 "windows_aarch64_msvc 0.53.1",
 "windows_i686_gnu 0.53.1",
 "windows_i686_gnullvm 0.53.1",
 "windows_i686_msvc 0.53.1",
 "windows_x86_64_gnu 0.53.1",
 "windows_x86_64_gnullvm 0.53.1",
 "windows_x86_64_msvc 0.53.1",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9d8416fa8b42f5c947f8482c43e7d89e73a173cead56d044f6a56104a6d1b53"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d782e804c2f632e395708e99a94275910eb9100b2114651e04744e9b125006"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "960e6da069d81e09becb0ca57a65220ddff016ff2d6af6a223cf372a506593a3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa7359d10048f68ab8b09fa71c3daccfb0e9b559aed648a8f95469c27057180c"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_i686_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e7ac75179f18232fe9c285163565a57ef8d3c89254a30685b57d83a38d326c2"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c3842cdd74a865a8066ab39c8a7a473c0778a3f29370b5fd6b4b9aa7df4a499"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ffa179e2d07eee8ad8f57493436566c7cc30ac536a3379fdf008f47f6bb7ae1"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6bbff5f0aada427a1e5a6da5f1f98158182f26556f345ac9e04d36d0ebed650"

[[package]]
name = "wit-bindgen"
version = "0.51.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d7249219f66ced02969388cf2bb044a09756a083d0fab1e566056b04d9fbcaa5"

[[package]]
name = "zerocopy"
version = "0.8.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "668f5168d10b9ee831de31933dc111a459c97ec93225beb307aed970d1372dfd"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c7962b26b0a8685668b671ee4b54d007a67d4eaf05fda79ac0ecf41e32270f1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.114",
]

[[package]]
name = "zmij"
version = "1.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfcd145825aace48cff44a8844de64bf75feec3080e0aa5cdbde72961ae51a65"

```

`Cargo.toml`:

```toml
[package]
name = "ida-mcp"
version = "0.9.3"
edition = "2021"
description = "Headless IDA Pro MCP Server"
license = "MIT"
repository = "https://github.com/blacktop/ida-mcp-rs"
authors = ["blacktop"]
keywords = ["ida", "mcp", "reverse-engineering", "disassembly", "decompiler"]
categories = ["development-tools", "command-line-utilities"]

[dependencies]
idalib = { git = "https://github.com/blacktop/idalib.git", branch = "sdk-9.3" }
rmcp = { version = "0.15", features = ["server", "transport-io", "transport-streamable-http-server"] }
tokio = { version = "1", features = ["rt", "rt-multi-thread", "sync", "macros", "net", "signal"] }
tokio-util = "0.7"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
schemars = "1.2"
anyhow = "1"
thiserror = "2"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
clap = { version = "4", features = ["derive"] }
libc = "0.2"
hyper = { version = "1", features = ["http1", "server"] }
hyper-util = { version = "0.1", features = ["tokio", "service"] }
bytes = "1"
http-body = "1"
http-body-util = "0.1"
tower-service = "0.3"

[build-dependencies]
idalib-build = { git = "https://github.com/blacktop/idalib.git", branch = "sdk-9.3", package = "idalib-build" }

```

`LICENSE`:

```
MIT License

Copyright (c) 2026 blacktop

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# ida-mcp

Headless IDA Pro MCP server for AI-powered reverse engineering.

## Prerequisites

- IDA 9.3+ (or 9.2) with valid license

## Getting Started

### Install

**macOS** (via [Homebrew](https://brew.sh))
```bash
brew install blacktop/tap/ida-mcp
```

**Linux / Windows**

Download the latest binary for your platform from [GitHub Releases](https://github.com/blacktop/ida-mcp-rs/releases).

**Build from source**

See [docs/BUILDING.md](docs/BUILDING.md).

### Platform Setup

#### macOS

Standard IDA installations in `/Applications` work automatically:
```bash
claude mcp add ida -- ida-mcp
```

If you see `Library not loaded: @rpath/libida.dylib`, set `DYLD_LIBRARY_PATH` to your IDA path:
```bash
claude mcp add ida -e DYLD_LIBRARY_PATH='/path/to/IDA.app/Contents/MacOS' -- ida-mcp
```

Supported paths (auto-detected):
- `/Applications/IDA Professional 9.3.app/Contents/MacOS`
- `/Applications/IDA Home 9.3.app/Contents/MacOS`
- `/Applications/IDA Essential 9.3.app/Contents/MacOS`
- `/Applications/IDA Professional 9.2.app/Contents/MacOS`

#### Linux

Standard IDA installations are auto-detected:
```bash
claude mcp add ida -- ida-mcp
```

If you see library loading errors, set `IDADIR`:
```bash
claude mcp add ida -e IDADIR='/path/to/ida' -- ida-mcp
```

Supported paths (auto-detected):
- `/opt/idapro-9.3`, `/opt/idapro-9.2`
- `$HOME/idapro-9.3`, `$HOME/idapro-9.2`
- `/usr/local/idapro-9.3`, `/usr/local/idapro-9.2`

#### Windows

Add your IDA directory to `PATH` (System Properties > Environment Variables):
```powershell
$env:PATH = "C:\Program Files\IDA Professional 9.3;$env:PATH"
claude mcp add ida -- ida-mcp
```

Common Windows IDA paths:
- `C:\Program Files\IDA Professional 9.3`
- `C:\Program Files\IDA Home 9.3`

### Runtime Requirements

The binary links against IDA's libraries at runtime. Standard installation paths are auto-detected via baked RPATHs. For non-standard paths:

| Platform | Library | Fallback Configuration |
|----------|---------|------------------------|
| macOS | `libida.dylib` | `DYLD_LIBRARY_PATH` |
| Linux | `libida.so` | `IDADIR` or `LD_LIBRARY_PATH` |
| Windows | `ida.dll` | Add IDA dir to `PATH` |

### Configure your AI agent

#### [Claude Code](https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview)
```bash
claude mcp add ida -- ida-mcp
```

#### [Codex CLI](https://github.com/openai/codex)
```bash
codex mcp add ida -- ida-mcp
```

#### [Gemini CLI](https://github.com/google-gemini/gemini-cli)
```bash
gemini mcp add ida -- ida-mcp
```

#### [Cursor](https://cursor.com)
Add to `.cursor/mcp.json`:
```json
{
  "mcpServers": {
    "ida": { "command": "ida-mcp" }
  }
}
```

### Usage

Once configured, you can analyze binaries through your AI agent:

```
# Open a binary (IDA analyzes raw binaries automatically)
open_idb(path: "~/samples/malware")

# Discover available tools
tool_catalog(query: "find callers")

# List functions
list_functions(limit: 20)

# Disassemble by name
disasm_by_name(name: "main", count: 20)

# Decompile (requires Hex-Rays)
decompile(address: "0x100000f00")
```

#### `dyld_shared_cache` analysis

`open_dsc` opens a single module from Apple's dyld_shared_cache. On first use it runs `idat` in the background to create the `.i64` (this can take minutes). Subsequent opens are instant.

```
# Open a module from the DSC
open_dsc(path: "/path/to/dyld_shared_cache_arm64e", arch: "arm64e",
         module: "/usr/lib/libobjc.A.dylib")

# If a background task was started, poll until done
task_status(task_id: "dsc-1")

# Load additional frameworks for cross-module references
open_dsc(path: "/path/to/dyld_shared_cache_arm64e", arch: "arm64e",
         module: "/usr/lib/libobjc.A.dylib",
         frameworks: ["/System/Library/Frameworks/Foundation.framework/Foundation"])
```

Requirements:
- `idat` binary (from IDA installation) must be available via `$IDADIR` or standard install paths
- The DSC loader and `dscu` plugin (bundled with IDA 9.x)

#### IDAPython scripting

`run_script` executes Python code in the open database via IDA's IDAPython engine. stdout and stderr are captured.

```
# Inline script
run_script(code: "import idautils\nfor f in idautils.Functions():\n    print(hex(f))")

# Run a .py file from disk
run_script(file: "/path/to/analysis_script.py")

# With timeout (default 120s, max 600s)
run_script(code: "import ida_bytes; print(ida_bytes.get_bytes(0x1000, 16).hex())",
           timeout_secs: 30)
```

All `ida_*` modules, `idc`, and `idautils` are available. See the [IDAPython API reference](https://python.docs.hex-rays.com).

---

The default tool list includes all tools. Use `tool_catalog`/`tool_help` to discover capabilities and avoid dumping the full list into context.

## Docs

- [docs/TOOLS.md](docs/TOOLS.md) - Tool catalog and discovery workflow
- [docs/TRANSPORTS.md](docs/TRANSPORTS.md) - Stdio vs Streamable HTTP
- [docs/BUILDING.md](docs/BUILDING.md) - Build from source
- [docs/TESTING.md](docs/TESTING.md) - Running tests

## License

MIT Copyright (c) 2026 **blacktop**

```

`build.rs`:

```rs
use std::env;
use std::path::{Path, PathBuf};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let (install_path, ida_path, idalib_path) = idalib_build::idalib_install_paths_with(false);

    if !ida_path.exists() || !idalib_path.exists() {
        println!("cargo::warning=IDA installation not found, using SDK stubs");
        idalib_build::configure_idasdk_linkage();
    } else {
        // Configure linkage to IDA libraries
        idalib_build::configure_linkage()?;
    }

    // Always set rpaths for runtime library discovery.
    // This adds the specified install path plus common default locations
    // so the binary can find IDA libraries without DYLD_LIBRARY_PATH.
    set_rpath(&install_path);

    Ok(())
}

/// Set rpath to the IDA installation directory for runtime library loading.
/// Adds multiple common IDA installation paths so the binary can find libraries
/// without requiring DYLD_LIBRARY_PATH to be set.
fn set_rpath(install_path: &Path) {
    let os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_else(|_| {
        if cfg!(target_os = "macos") {
            "macos".to_string()
        } else if cfg!(target_os = "linux") {
            "linux".to_string()
        } else {
            "unknown".to_string()
        }
    });

    // Always add the specified install path first
    add_rpath(install_path);

    // Add common default paths as fallbacks (IDA 9.2 and 9.3 variants)
    if os == "macos" {
        // Common macOS IDA installation paths (all editions)
        let default_paths = [
            // IDA 9.3 paths
            "/Applications/IDA Professional 9.3.app/Contents/MacOS",
            "/Applications/IDA Pro 9.3.app/Contents/MacOS",
            "/Applications/IDA Home 9.3.app/Contents/MacOS",
            "/Applications/IDA Essential 9.3.app/Contents/MacOS",
            // IDA 9.2 paths
            "/Applications/IDA Professional 9.2.app/Contents/MacOS",
            "/Applications/IDA Pro 9.2.app/Contents/MacOS",
            "/Applications/IDA Home 9.2.app/Contents/MacOS",
            "/Applications/IDA Essential 9.2.app/Contents/MacOS",
        ];
        for path in default_paths {
            let p = PathBuf::from(path);
            if p != *install_path {
                add_rpath(&p);
            }
        }
    } else if os == "linux" {
        // Common Linux IDA installation paths
        let home = env::var("HOME").unwrap_or_else(|_| "/home/user".to_string());
        let default_paths = [
            // IDA 9.3 paths
            format!("{}/idapro-9.3", home),
            format!("{}/ida-pro-9.3", home),
            "/opt/idapro-9.3".to_string(),
            "/opt/ida-pro-9.3".to_string(),
            "/usr/local/idapro-9.3".to_string(),
            // IDA 9.2 paths
            format!("{}/idapro-9.2", home),
            format!("{}/ida-pro-9.2", home),
            "/opt/idapro-9.2".to_string(),
            "/opt/ida-pro-9.2".to_string(),
            "/usr/local/idapro-9.2".to_string(),
        ];
        for path in default_paths {
            let p = PathBuf::from(&path);
            if p != *install_path {
                add_rpath(&p);
            }
        }
    }
}

fn add_rpath(path: &Path) {
    println!("cargo::rustc-link-arg=-Wl,-rpath,{}", path.display());
}

```

`docs/BUILDING.md`:

```md
# Building from Source

## Prerequisites

- IDA Pro 9.3+ with valid license
- Rust 1.77+ (stable toolchain)
- LLVM/Clang (for C++ bindings)
- IDA SDK (from Hex-Rays)

## Platform-Specific Setup

### macOS (ARM64)

```bash
# Install Xcode command line tools (provides clang)
xcode-select --install

# Clone and build
git clone https://github.com/blacktop/ida-mcp-rs.git
cd ida-mcp-rs
cargo build --release
```

Default IDA path: `/Applications/IDA Professional 9.3.app/Contents/MacOS`

Override with `IDADIR`:
```bash
IDADIR='/Applications/IDA Home 9.3.app/Contents/MacOS' cargo build --release
```

### Linux (x86_64)

```bash
# Install dependencies (Ubuntu/Debian)
sudo apt-get update
sudo apt-get install -y build-essential llvm clang libclang-dev

# Set IDA path
export IDADIR=/opt/idapro-9.3

# Clone and build
git clone https://github.com/blacktop/ida-mcp-rs.git
cd ida-mcp-rs
cargo build --release
```

Common Linux IDA paths:
- `/opt/idapro-9.3`
- `/home/<user>/idapro-9.3`
- `/usr/local/idapro-9.3`

### Windows (x86_64)

```powershell
# Install LLVM (required for bindgen)
# Option 1: winget
winget install LLVM.LLVM

# Option 2: Download from https://releases.llvm.org/

# Set environment variables
$env:IDADIR = "C:\Program Files\IDA Professional 9.3"
$env:PATH = "$env:IDADIR;$env:PATH"

# Ensure LLVM is in PATH
$env:PATH = "C:\Program Files\LLVM\bin;$env:PATH"

# Clone and build
git clone https://github.com/blacktop/ida-mcp-rs.git
cd ida-mcp-rs
cargo build --release
```

Common Windows IDA paths:
- `C:\Program Files\IDA Professional 9.3`
- `C:\IDA Professional 9.3`
- `C:\Program Files\IDA Home 9.3`

## Build Output

The binary is at:
- Linux/macOS: `target/release/ida-mcp`
- Windows: `target/release/ida-mcp.exe`

## IDA SDK (for CI builds)

CI builds require the IDA SDK. Set `IDASDKDIR` to the SDK path:

```bash
export IDASDKDIR=/path/to/idasdk
cargo build --release
```

## RPATH

The IDA library path is baked into the binary via RPATH at build time. On macOS, this means the binary "just works" if built with the correct `IDADIR`.

On Linux and Windows, users may need to set environment variables at runtime:
- Linux: `IDADIR` or `LD_LIBRARY_PATH`
- Windows: Add IDA directory to `PATH`

## Run modes

```bash
# Stdio (default, single-client)
./target/release/ida-mcp

# Streamable HTTP (multi-client, SSE)
./target/release/ida-mcp serve-http --bind 127.0.0.1:8765

# CLI probe (test IDA connection)
./target/release/ida-mcp probe --path /path/to/binary --list 10
```

## Cross-Compilation

**Not supported.** idalib links against IDA's native libraries at build time. You must build natively on each platform with IDA installed.

```

`docs/README.md`:

```md
# Documentation

ida-mcp is a headless IDA Pro MCP server with a discovery-first tool model.

## Design

- **Full tool list by default** - Supports MCP clients that only register tools at connection time
- **Tool discovery** - Use `tool_catalog` to find tools, `tool_help` for docs
- **Streamable HTTP** - Multi-client support with streaming notifications
- **Serialized IDA access** - All IDA work runs through a single worker thread

## Contents

- [TOOLS.md](TOOLS.md) - Tool catalog and discovery workflow
- [TRANSPORTS.md](TRANSPORTS.md) - Stdio vs Streamable HTTP
- [BUILDING.md](BUILDING.md) - Build from source
- [TESTING.md](TESTING.md) - Running tests

```

`docs/TESTING.md`:

```md
# Testing

## Run tests

```bash
just test         # Stdio JSONL integration test
just test-http    # HTTP/SSE integration test
just test-script  # IDAPython script execution test
just test-dsc /path/to/dyld_shared_cache_arm64e  # DSC loading test
just cargo-test   # Unit tests (no IDA required)
```

All integration tests require IDA Pro with a valid license. Run `cargo build` first.

## What's tested

**Stdio test** (`just test`)
- MCP protocol handshake
- Tool discovery (`tool_catalog`, `tool_help`)
- Database operations (`open_idb`, `close_idb`, `idb_meta`, `analysis_status`)
- Analysis tools (`list_functions`, `resolve_function`, `disasm_by_name`, `find_insns`, `find_insn_operands`)
- Editing tools (`set_comments`, `rename`, `patch`, `patch_asm`)
- Types/stack tools (`declare_type`, `apply_types`, `infer_types`, `stack_frame`, `declare_stack`, `delete_stack`)
- Metadata tools (`segments`, `strings`, `imports`, `exports`, `structs`, `xrefs_to_field`, `search_structs`)

**HTTP test** (`just test-http`)
- Streamable HTTP transport with SSE
- `tools/list` returns the full tool list
- Database operations work over HTTP (`open_idb`, `list_functions`, `close_idb` with close_token)

**Script test** (`just test-script`)
- Opens a binary, then runs inline Python via `run_script`
- Verifies stdout/stderr capture
- Verifies Python error reporting (division by zero)
- Verifies file-based script execution (`.py` file path)

**DSC test** (`just test-dsc <path>`)
- Requires a real `dyld_shared_cache_arm64e` file
- Tests both sync (pre-existing `.i64`) and async (background `idat`) paths
- Polls `task_status` until completion
- Verifies the database is usable after loading (`list_functions`)

**Unit tests** (`just cargo-test`)
- `src/dsc.rs` — file type strings, idat args, script generation, Python string escaping
- `src/server/task.rs` — task registry lifecycle, deduplication, cancellation, ISO timestamps

## Test fixture

Tests use `test/fixtures/mini.c`, a minimal C program compiled into a Mach-O binary.
The tests open the raw binary via `open_idb` (IDA auto-analyzes and writes an .i64 alongside).

```

`docs/TOOLS.md`:

```md
# Tools

> Auto-generated from `src/tool_registry.rs`. Do not edit by hand.
> Regenerate with: `cargo run --bin gen_tools_doc -- docs/TOOLS.md`.

## Discovery Workflow

- `tools/list` returns the full tool set (currently 68 tools)
- `tool_catalog(query=...)` searches all tools by intent
- `tool_help(name=...)` returns full documentation and schema
- Call `close_idb` when done to release locks; in multi-client servers coordinate before closing (HTTP/SSE requires close_token from open_idb)

Note: `open_idb` accepts .i64/.idb or raw binaries (Mach-O/ELF/PE). Raw binaries are
auto-analyzed and saved as a .i64 alongside the input. If a sibling .dSYM
exists and no .i64 is present, its DWARF debug info is loaded automatically.

## Core (`core`)

Database open/close and discovery tools

| Tool | Description |
|------|-------------|
| `analysis_status` | Report auto-analysis status |
| `close_idb` | Close the current database (release locks) |
| `idb_meta` | Get database metadata and summary |
| `load_debug_info` | Load external debug info (e.g., dSYM/DWARF) |
| `open_dsc` | Open a dyld_shared_cache and load a single module |
| `open_idb` | Open an IDA database or raw binary |
| `task_status` | Check status of a background task (e.g. DSC loading) |
| `tool_catalog` | Discover available tools by query or category |
| `tool_help` | Get full documentation for a tool |

## Functions (`functions`)

List, search, and resolve functions

| Tool | Description |
|------|-------------|
| `analyze_funcs` | Run auto-analysis and wait for completion |
| `function_at` | Find the function containing an address |
| `list_funcs` | Alias of list_functions |
| `list_functions` | List functions with pagination and filtering |
| `lookup_funcs` | Batch lookup multiple functions by name |
| `resolve_function` | Find function address by name |

## Disassembly (`disassembly`)

Disassemble code at addresses

| Tool | Description |
|------|-------------|
| `disasm` | Disassemble instructions at an address |
| `disasm_by_name` | Disassemble a function by name |
| `disasm_function_at` | Disassemble the function containing an address |

## Decompile (`decompile`)

Decompile functions to pseudocode (requires Hex-Rays)

| Tool | Description |
|------|-------------|
| `decompile` | Decompile function to C pseudocode |
| `pseudocode_at` | Get pseudocode for specific address/range |

## Xrefs (`xrefs`)

Cross-reference analysis (xrefs to/from)

| Tool | Description |
|------|-------------|
| `xref_matrix` | Build xref matrix between addresses |
| `xrefs_from` | Find all references FROM an address |
| `xrefs_to` | Find all references TO an address |
| `xrefs_to_field` | Xrefs to a struct field |
| `xrefs_to_string` | Find xrefs to strings matching a query |

## Control Flow (`control_flow`)

Basic blocks, call graphs, control flow

| Tool | Description |
|------|-------------|
| `basic_blocks` | Get basic blocks of a function |
| `callees` | Find all functions called by a function |
| `callers` | Find all callers of a function |
| `callgraph` | Build call graph from a function |
| `find_paths` | Find control-flow paths between two addresses |

## Memory (`memory`)

Read bytes, strings, and data

| Tool | Description |
|------|-------------|
| `get_bytes` | Read raw bytes from an address |
| `get_global_value` | Read global value by name or address |
| `get_string` | Read string at an address |
| `get_u16` | Read 16-bit value |
| `get_u32` | Read 32-bit value |
| `get_u64` | Read 64-bit value |
| `get_u8` | Read 8-bit value |
| `int_convert` | Convert integers between bases |

## Search (`search`)

Search for bytes, strings, patterns

| Tool | Description |
|------|-------------|
| `analyze_strings` | Analyze strings with filtering |
| `find_bytes` | Search for byte pattern |
| `find_insn_operands` | Find instructions by operand substring |
| `find_insns` | Find instruction sequences by mnemonic |
| `find_string` | Find strings matching a query |
| `search` | Search for text or immediate values |
| `strings` | List all strings in the database |

## Metadata (`metadata`)

Database info, segments, imports, exports

| Tool | Description |
|------|-------------|
| `addr_info` | Resolve address to segment/function/symbol |
| `entrypoints` | List entry points |
| `export_funcs` | Export functions (JSON) |
| `exports` | List exported functions |
| `imports` | List imported functions |
| `list_globals` | List global variables |
| `segments` | List all segments |

## Types (`types`)

Types, structs, and stack variable info

| Tool | Description |
|------|-------------|
| `apply_types` | Apply a type to an address or stack variable |
| `declare_stack` | Declare a stack variable |
| `declare_type` | Declare a type in the local type library |
| `delete_stack` | Delete a stack variable |
| `infer_types` | Infer/guess type at an address |
| `local_types` | List local types |
| `read_struct` | Read a struct instance at an address |
| `search_structs` | Search structs by name |
| `stack_frame` | Get stack frame info |
| `struct_info` | Get struct info by name or ordinal |
| `structs` | List structs with pagination |

## Editing (`editing`)

Patching, renaming, and comment editing

| Tool | Description |
|------|-------------|
| `patch` | Patch bytes at an address |
| `patch_asm` | Patch instructions with assembly text |
| `rename` | Rename symbols |
| `set_comments` | Set comments at an address |

## Scripting (`scripting`)

Execute Python scripts via IDAPython

| Tool | Description |
|------|-------------|
| `run_script` | Execute Python code via IDAPython |

## Notes

- Many tools accept a single value or array (e.g., `"0x1000"` or `["0x1000", "0x2000"]`)
- String inputs may be comma-separated: `"0x1000, 0x2000"`
- Addresses accept hex (`0x1000`) or decimal (`4096`)
- Raw binaries are auto-analyzed on first open; `.i64` is saved alongside the input

```

`docs/TRANSPORTS.md`:

```md
# Transports

## Stdio (default)

- Single-client, simplest setup.
- Use with CLI agents that launch a child process.

```bash
./target/release/ida-mcp
```

## Streamable HTTP (multi-client)

- Supports multiple clients over HTTP.
- SSE is used for streaming responses within this transport.
- The server validates Origin headers; defaults allow localhost only.

```bash
./target/release/ida-mcp serve-http --bind 127.0.0.1:8765
```

Options:
- `--stateless`: POST-only mode (no sessions)
- `--allow-origin`: comma-separated allowlist
- `--sse-keep-alive-secs`: keep-alive interval (0 disables)

## Concurrency model

IDA requires main-thread access. All IDA operations are serialized through a single
worker loop, while multiple clients can submit requests concurrently.

## Shutdown

The server listens for SIGINT/SIGTERM/SIGQUIT and will close the open database
before exiting when possible.

```

`justfile`:

```
# IDA MCP Server

# Show available recipes
default:
    @just --list

# Build debug binary
build:
    cargo build

# Build release binary
release:
    cargo build --release

# Build and publish prerelease (macOS ARM64 only, for local testing)
prerelease ida_version="9.4": && (update-beta-cask ida_version)
    #!/usr/bin/env bash
    set -euo pipefail
    VERSION=$(grep '^version' Cargo.toml | head -1 | sed 's/.*"\(.*\)"/\1/')
    IDADIR="/Applications/IDA Professional {{ ida_version }}.app/Contents/MacOS" cargo build --release
    mkdir -p dist
    rm -f "dist/ida-mcp_${VERSION}_Darwin_arm64.tar.gz"
    tar -czvf "dist/ida-mcp_${VERSION}_Darwin_arm64.tar.gz" -C target/release ida-mcp -C "{{ justfile_directory() }}" README.md LICENSE
    gh release create "v${VERSION}" \
        --prerelease \
        --title "IDA Pro MCP Server v${VERSION}" \
        --notes "Prerelease for IDA Pro {{ ida_version }} beta. Requires IDA Pro {{ ida_version }} with valid license." \
        "dist/ida-mcp_${VERSION}_Darwin_arm64.tar.gz"

# Update homebrew beta cask in tap
update-beta-cask ida_version="9.4":
    #!/usr/bin/env bash
    set -euo pipefail
    VERSION=$(grep '^version' Cargo.toml | head -1 | sed 's/.*"\(.*\)"/\1/')
    TARBALL="dist/ida-mcp_${VERSION}_Darwin_arm64.tar.gz"
    SHA256=$(shasum -a 256 "$TARBALL" | awk '{print $1}')
    TAP_DIR="${HOME}/Developer/Mine/blacktop/homebrew-tap"

    if [[ ! -d "$TAP_DIR" ]]; then
        echo "Error: homebrew-tap not found at $TAP_DIR"
        exit 1
    fi

    cat > "$TAP_DIR/Casks/ida-mcp@beta.rb" << EOF
    # This file is auto-generated. DO NOT EDIT.
    cask "ida-mcp@beta" do
      version "${VERSION}"
      sha256 "${SHA256}"

      url "https://github.com/blacktop/ida-mcp-rs/releases/download/v#{version}/ida-mcp_#{version}_Darwin_arm64.tar.gz"
      name "ida-mcp (beta)"
      desc "Headless IDA Pro MCP Server for AI-powered binary analysis (beta)"
      homepage "https://github.com/blacktop/ida-mcp-rs"

      conflicts_with cask: "ida-mcp"

      binary "ida-mcp"

      postflight do
        Dir.glob("#{staged_path}/**/ida-mcp").each do |f|
          system_command "/usr/bin/xattr", args: ["-dr", "com.apple.quarantine", f]
        end
      end

      caveats do
        <<~EOS
          ida-mcp@beta requires IDA Pro {{ ida_version }}+ to be installed.
          This is a prerelease version for testing.

          Standard IDA installations work automatically:
            claude mcp add ida -- ida-mcp

          If using a non-standard path, set DYLD_LIBRARY_PATH:
            claude mcp add ida -e DYLD_LIBRARY_PATH='/path/to/ida/Contents/MacOS' -- ida-mcp
        EOS
      end
    end
    EOF

    echo "Generated $TAP_DIR/Casks/ida-mcp@beta.rb"
    cd "$TAP_DIR"
    git add "Casks/ida-mcp@beta.rb"
    git commit -m "Update ida-mcp@beta to ${VERSION}"
    git push
    echo "Pushed beta cask to homebrew-tap"

# Update homebrew stable cask in tap (run after GitHub release is created)

# Pass revision="" (default) for a fresh version, or revision="1" etc. for rebuilds.
update-cask revision="":
    #!/usr/bin/env bash
    set -euo pipefail
    VERSION=$(grep '^version' Cargo.toml | head -1 | sed 's/.*"\(.*\)"/\1/')
    REVISION="{{ revision }}"
    if [[ -n "$REVISION" ]]; then
        CASK_VERSION="${VERSION},${REVISION}"
    else
        CASK_VERSION="${VERSION}"
    fi
    TAP_DIR="${HOME}/Developer/Mine/blacktop/homebrew-tap"
    TARBALL_URL="https://github.com/blacktop/ida-mcp-rs/releases/download/v${VERSION}/ida-mcp_${VERSION}_Darwin_arm64.tar.gz"

    if [[ ! -d "$TAP_DIR" ]]; then
        echo "Error: homebrew-tap not found at $TAP_DIR"
        exit 1
    fi

    # Download tarball to get SHA256
    echo "Downloading release tarball..."
    mkdir -p dist
    curl -sL "$TARBALL_URL" -o "dist/ida-mcp_${VERSION}_Darwin_arm64.tar.gz"
    SHA256=$(shasum -a 256 "dist/ida-mcp_${VERSION}_Darwin_arm64.tar.gz" | awk '{print $1}')

    # When using a comma-separated version (e.g. "0.9.3,1"), Homebrew
    # interpolates #{version} as "0.9.3,1". Use version.before_comma
    # in the URL so only the base version appears in the download path.
    if [[ -n "$REVISION" ]]; then
        URL_VERSION='#{version.before_comma}'
    else
        URL_VERSION='#{version}'
    fi

    cat > "$TAP_DIR/Casks/ida-mcp.rb" << EOF
    # This file is auto-generated. DO NOT EDIT.
    cask "ida-mcp" do
      version "${CASK_VERSION}"
      sha256 "${SHA256}"

      url "https://github.com/blacktop/ida-mcp-rs/releases/download/v${URL_VERSION}/ida-mcp_${URL_VERSION}_Darwin_arm64.tar.gz"
      name "ida-mcp"
      desc "Headless IDA Pro MCP Server for AI-powered binary analysis"
      homepage "https://github.com/blacktop/ida-mcp-rs"

      conflicts_with cask: "ida-mcp@beta"

      binary "ida-mcp"

      postflight do
        Dir.glob("#{staged_path}/**/ida-mcp").each do |f|
          system_command "/usr/bin/xattr", args: ["-dr", "com.apple.quarantine", f]
        end
      end

      caveats do
        <<~EOS
          ida-mcp requires IDA Pro 9.2+ to be installed.

          Standard IDA installations work automatically:
            claude mcp add ida -- ida-mcp

          If using a non-standard path, set DYLD_LIBRARY_PATH:
            claude mcp add ida -e DYLD_LIBRARY_PATH='/path/to/ida/Contents/MacOS' -- ida-mcp
        EOS
      end
    end
    EOF

    echo "Generated $TAP_DIR/Casks/ida-mcp.rb (version: ${CASK_VERSION})"
    cd "$TAP_DIR"
    git add "Casks/ida-mcp.rb"
    git commit -m "Update ida-mcp to ${CASK_VERSION}"
    git push
    echo "Pushed stable cask to homebrew-tap"

# Run integration test (debug)
test: build
    cd test && SERVER_BIN=../target/debug/ida-mcp RUST_LOG=ida_mcp=trace just test

# Run HTTP integration test (debug)
test-http: build
    cd test && SERVER_BIN=../target/debug/ida-mcp RUST_LOG=ida_mcp=trace just test-http

# Run IDAPython script integration test (debug)
test-script: build
    cd test && SERVER_BIN=../target/debug/ida-mcp RUST_LOG=ida_mcp=trace just test-script

# Run cargo unit tests
cargo-test:
    RUST_BACKTRACE=1 cargo test

# Format code
fmt:
    cargo fmt --all

# Run clippy linter
lint:
    cargo clippy -- -D warnings

# Run full check (fmt + lint + test)
check: fmt lint cargo-test

# Clean build artifacts
clean:
    cargo clean
    rm -rf dist/

# Bump version and push tag
bump:
    git tag $(svu patch)
    git push --tags

```

`src/bin/gen_tools_doc.rs`:

```rs
use ida_mcp::{ToolCategory, ToolInfo, TOOL_REGISTRY};
use std::collections::HashMap;
use std::fmt::Write as _;

fn category_title(cat: ToolCategory) -> &'static str {
    match cat {
        ToolCategory::Core => "Core",
        ToolCategory::Functions => "Functions",
        ToolCategory::Disassembly => "Disassembly",
        ToolCategory::Decompile => "Decompile",
        ToolCategory::Xrefs => "Xrefs",
        ToolCategory::ControlFlow => "Control Flow",
        ToolCategory::Memory => "Memory",
        ToolCategory::Search => "Search",
        ToolCategory::Metadata => "Metadata",
        ToolCategory::Types => "Types",
        ToolCategory::Editing => "Editing",
        ToolCategory::Debug => "Debug",
        ToolCategory::Ui => "UI",
        ToolCategory::Scripting => "Scripting",
    }
}

fn is_headless_unsupported(cat: ToolCategory) -> bool {
    matches!(
        cat,
        ToolCategory::Types
            | ToolCategory::Editing
            | ToolCategory::Debug
            | ToolCategory::Ui
            | ToolCategory::Scripting
    )
}

fn all_tools_unsupported(tools: &[&ToolInfo]) -> bool {
    tools
        .iter()
        .all(|tool| tool.short_desc.contains("not supported"))
}

fn main() {
    let mut groups: HashMap<ToolCategory, Vec<&ToolInfo>> = HashMap::new();
    for tool in TOOL_REGISTRY {
        groups.entry(tool.category).or_default().push(tool);
    }
    for tools in groups.values_mut() {
        tools.sort_by_key(|t| t.name);
    }

    let tool_count = TOOL_REGISTRY.len();

    let mut out = String::new();
    let _ = writeln!(out, "# Tools\n");
    let _ = writeln!(
        out,
        "> Auto-generated from `src/tool_registry.rs`. Do not edit by hand."
    );
    let _ = writeln!(
        out,
        "> Regenerate with: `cargo run --bin gen_tools_doc -- docs/TOOLS.md`.\n"
    );

    let _ = writeln!(out, "## Discovery Workflow\n");
    let _ = writeln!(
        out,
        "- `tools/list` returns the full tool set (currently {tool_count} tools)"
    );
    let _ = writeln!(
        out,
        "- `tool_catalog(query=...)` searches all tools by intent"
    );
    let _ = writeln!(
        out,
        "- `tool_help(name=...)` returns full documentation and schema"
    );
    let _ = writeln!(
        out,
        "- Call `close_idb` when done to release locks; in multi-client servers coordinate before closing (HTTP/SSE requires close_token from open_idb)"
    );
    let _ = writeln!(out);

    let _ = writeln!(
        out,
        "Note: `open_idb` accepts .i64/.idb or raw binaries (Mach-O/ELF/PE). Raw binaries are"
    );
    let _ = writeln!(
        out,
        "auto-analyzed and saved as a .i64 alongside the input. If a sibling .dSYM"
    );
    let _ = writeln!(
        out,
        "exists and no .i64 is present, its DWARF debug info is loaded automatically.\n"
    );

    for &cat in ToolCategory::all() {
        let Some(tools) = groups.get(&cat) else {
            continue;
        };
        if tools.is_empty() {
            continue;
        }
        let _ = writeln!(out, "## {} (`{}`)\n", category_title(cat), cat.as_str());
        let _ = writeln!(out, "{}", cat.description());
        if is_headless_unsupported(cat) && all_tools_unsupported(tools) {
            let _ = writeln!(
                out,
                "Headless unsupported: these tools return NotSupported in headless mode."
            );
        }
        let _ = writeln!(out, "\n| Tool | Description |");
        let _ = writeln!(out, "|------|-------------|");
        for tool in tools {
            let _ = writeln!(out, "| `{}` | {} |", tool.name, tool.short_desc);
        }
        let _ = writeln!(out);
    }

    let _ = writeln!(out, "## Notes\n");
    let _ = writeln!(
        out,
        "- Many tools accept a single value or array (e.g., `\"0x1000\"` or `[\"0x1000\", \"0x2000\"]`)"
    );
    let _ = writeln!(
        out,
        "- String inputs may be comma-separated: `\"0x1000, 0x2000\"`"
    );
    let _ = writeln!(out, "- Addresses accept hex (`0x1000`) or decimal (`4096`)");
    let _ = writeln!(
        out,
        "- Raw binaries are auto-analyzed on first open; `.i64` is saved alongside the input"
    );

    let args: Vec<String> = std::env::args().collect();
    if args.len() > 1 {
        if let Err(err) = std::fs::write(&args[1], out) {
            eprintln!("failed to write {}: {}", args[1], err);
            std::process::exit(1);
        }
    } else {
        print!("{out}");
    }
}

```

`src/disasm.rs`:

```rs
//! Custom disassembly text generation.
//!
//! Uses IDA's generate_disasm_line to produce formatted disassembly output
//! with proper mnemonic names and operand formatting.

use idalib::{Address, IDB};

/// Generate a disassembly line at the given address.
///
/// Returns the disassembly text without color codes, or None if the address
/// is invalid or doesn't contain code.
pub fn generate_disasm_line(idb: &IDB, addr: Address) -> Option<String> {
    idb.disasm_line(addr)
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_placeholder() {
        // Tests require an open IDB
    }
}

```

`src/dsc.rs`:

```rs
//! dyld_shared_cache (DSC) support utilities.
//!
//! Builds the IDA file type selector string and the IDAPython script
//! that drives the dscu plugin to load individual modules from a DSC.
//!
//! idalib's headless mode cannot handle the DSC loader's module
//! selection — `init_database()` calls `exit(1)`. So DSC loading is
//! a two-phase process:
//!   1. Run `idat -a- -A -S<script> -T<loader> -o<out.i64> <dsc>`
//!      to create the database via IDA's autonomous CLI mode.
//!   2. Open the resulting `.i64` with idalib for interactive analysis.

use std::path::{Path, PathBuf};

use crate::error::ToolError;

/// Escape a string for safe interpolation into Python double-quoted strings.
///
/// Prevents code injection when embedding user-supplied module/framework
/// paths into generated IDAPython scripts.
fn escape_python_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
}

/// Build the IDA `-T` file type string for a dyld_shared_cache.
///
/// IDA 9.3 offers two DSC loader modes:
/// - `"(select module(s))"` — loads specific modules (was `"(single module)"` in IDA 8)
/// - `"(complete image)"` — loads the entire DSC
///
/// We always use `"(select module(s))"` for targeted module loading.
pub fn dsc_file_type(arch: &str, ida_version: u8) -> String {
    let mode = if ida_version >= 9 {
        "select module(s)"
    } else {
        "single module"
    };
    format!("Apple DYLD cache for {arch} ({mode})")
}

/// Locate the `idat` binary for running IDA in autonomous CLI mode.
///
/// Checks `$IDADIR` first, then falls back to platform-specific
/// default installation paths.
pub fn find_idat() -> Result<PathBuf, ToolError> {
    let bin_name = if cfg!(target_os = "windows") {
        "idat.exe"
    } else {
        "idat"
    };

    // Check IDADIR environment variable
    if let Ok(dir) = std::env::var("IDADIR") {
        let idat = Path::new(&dir).join(bin_name);
        if idat.exists() {
            return Ok(idat);
        }
    }

    // Platform defaults
    let candidates: &[&str] = if cfg!(target_os = "macos") {
        &[
            "/Applications/IDA Professional 9.3.app/Contents/MacOS/idat",
            "/Applications/IDA Professional 9.0.app/Contents/MacOS/idat",
            "/Applications/IDA Pro 9.3.app/Contents/MacOS/idat",
            "/Applications/IDA Pro 9.0.app/Contents/MacOS/idat",
        ]
    } else if cfg!(target_os = "linux") {
        &["/opt/ida/idat", "/opt/idapro/idat"]
    } else if cfg!(target_os = "windows") {
        &[
            r"C:\Program Files\IDA Professional 9.3\idat.exe",
            r"C:\Program Files\IDA Pro 9.3\idat.exe",
            r"C:\Program Files\IDA Professional 9.0\idat.exe",
            r"C:\Program Files\IDA Pro 9.0\idat.exe",
        ]
    } else {
        &[]
    };

    for path in candidates {
        let p = Path::new(path);
        if p.exists() {
            return Ok(p.to_path_buf());
        }
    }

    Err(ToolError::InvalidParams(
        "Cannot find idat binary. Set IDADIR environment variable \
         to your IDA installation directory."
            .into(),
    ))
}

/// Build the `idat` command-line arguments for DSC module loading.
///
/// Produces arguments matching the working invocation pattern:
/// ```text
/// idat -a- -A -P+ -Oobjc:+l -S<script> -T<loader> -o<out.i64> <dsc>
/// ```
pub fn idat_dsc_args(
    dsc_path: &Path,
    out_i64: &Path,
    script_path: &Path,
    file_type: &str,
    log_path: Option<&Path>,
) -> Vec<String> {
    let mut args = vec![
        "-a-".to_string(),       // enable auto-analysis
        "-A".to_string(),        // autonomous mode (no dialogs)
        "-P+".to_string(),       // compressed database
        "-Oobjc:+l".to_string(), // ObjC plugin options
    ];

    if let Some(log) = log_path {
        args.push(format!("-L{}", log.display()));
    }

    args.push(format!("-S{}", script_path.display()));
    args.push(format!("-T{file_type}"));
    args.push(format!("-o{}", out_i64.display()));
    args.push(dsc_path.display().to_string());

    args
}

/// Build the IDAPython script that loads modules from a DSC and
/// runs ObjC analysis.
///
/// The script uses `dscu_load_module` to communicate with the dscu
/// plugin via IDA's netnode API, then runs ObjC type, block, and
/// auto-analysis passes.
pub fn dsc_load_script(module: &str, frameworks: &[String]) -> String {
    let mut script = String::from(
        "\
import idaapi
from idc import *

def dscu_load_module(module):
    node = idaapi.netnode()
    node.create(\"$ dscu\")
    node.supset(2, module)
    load_and_run_plugin(\"dscu\", 1)
",
    );

    let escaped_module = escape_python_string(module);

    // Load primary module
    script.push_str(&format!(
        "\n# Load primary module\n\
         print(\"[ida-mcp] loading module: {escaped_module}\")\n\
         dscu_load_module(\"{escaped_module}\")\n"
    ));

    // Load additional frameworks
    for fw in frameworks {
        let escaped_fw = escape_python_string(fw);
        script.push_str(&format!(
            "\nprint(\"[ida-mcp] loading framework: {escaped_fw}\")\n\
             dscu_load_module(\"{escaped_fw}\")\n"
        ));
    }

    // ObjC and auto-analysis passes
    script.push_str(
        "\
\n# ObjC type analysis
print(\"[ida-mcp] analyzing objc types\")
load_and_run_plugin(\"objc\", 1)
print(\"[ida-mcp] analyzing NSConcreteGlobalBlock objects\")
load_and_run_plugin(\"objc\", 4)

# Auto-analysis
print(\"[ida-mcp] performing auto-analysis...\")
auto_mark_range(0, BADADDR, AU_FINAL)
auto_wait()

# Stack block analysis
print(\"[ida-mcp] analyzing NSConcreteStackBlock objects\")
load_and_run_plugin(\"objc\", 5)

print(\"[ida-mcp] DSC module loading complete\")
",
    );

    script
}

#[cfg(test)]
mod tests {
    use crate::dsc::{dsc_file_type, dsc_load_script, idat_dsc_args};
    use std::path::Path;

    #[test]
    fn file_type_ida9() {
        assert_eq!(
            dsc_file_type("arm64e", 9),
            "Apple DYLD cache for arm64e (select module(s))"
        );
    }

    #[test]
    fn file_type_ida8() {
        assert_eq!(
            dsc_file_type("arm64e", 8),
            "Apple DYLD cache for arm64e (single module)"
        );
    }

    #[test]
    fn idat_args_basic() {
        let args = idat_dsc_args(
            Path::new("/path/to/dsc"),
            Path::new("/out/dsc.i64"),
            Path::new("/tmp/script.py"),
            "Apple DYLD cache for arm64e (select module(s))",
            None,
        );
        assert!(args.contains(&"-a-".to_string()));
        assert!(args.contains(&"-A".to_string()));
        assert!(args.contains(&"-P+".to_string()));
        assert!(args.contains(&"-S/tmp/script.py".to_string()));
        assert!(args.contains(&"-o/out/dsc.i64".to_string()));
        assert!(args.contains(&"/path/to/dsc".to_string()));
    }

    #[test]
    fn idat_args_with_log() {
        let args = idat_dsc_args(
            Path::new("/path/to/dsc"),
            Path::new("/out/dsc.i64"),
            Path::new("/tmp/script.py"),
            "Apple DYLD cache for arm64e (select module(s))",
            Some(Path::new("/tmp/ida.log")),
        );
        assert!(args.contains(&"-L/tmp/ida.log".to_string()));
    }

    #[test]
    fn script_no_frameworks() {
        let script = dsc_load_script("/usr/lib/libobjc.A.dylib", &[]);
        assert!(script.contains("dscu_load_module(\"/usr/lib/libobjc.A.dylib\")"));
        assert!(script.contains("load_and_run_plugin(\"objc\", 1)"));
        assert!(script.contains("auto_wait()"));
    }

    #[test]
    fn script_with_frameworks() {
        let frameworks = vec![
            "/System/Library/Frameworks/Foundation.framework/Foundation".to_string(),
            "/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation".to_string(),
        ];
        let script = dsc_load_script("/usr/lib/libobjc.A.dylib", &frameworks);
        assert!(script.contains("dscu_load_module(\"/usr/lib/libobjc.A.dylib\")"));
        assert!(script.contains("Foundation"));
        assert!(script.contains("CoreFoundation"));
    }

    #[test]
    fn escape_python_string_basic() {
        use super::escape_python_string;
        assert_eq!(escape_python_string("normal/path"), "normal/path");
        assert_eq!(escape_python_string(r#"a"b"#), r#"a\"b"#);
        assert_eq!(escape_python_string("a\\b"), "a\\\\b");
        assert_eq!(escape_python_string("a\nb"), "a\\nb");
        assert_eq!(escape_python_string("a\rb"), "a\\rb");
    }

    #[test]
    fn script_injection_escaped() {
        use super::escape_python_string;
        let malicious = r#""); import os; os.system("rm -rf /"); print(""#;
        let escaped = escape_python_string(malicious);
        // Every `"` in the escaped string must be preceded by `\`.
        // This prevents breaking out of the Python string literal.
        for (i, ch) in escaped.char_indices() {
            if ch == '"' {
                assert!(
                    i > 0 && escaped.as_bytes()[i - 1] == b'\\',
                    "unescaped quote at index {i} in: {escaped}"
                );
            }
        }
        // The escaped form appears in the generated script
        let script = dsc_load_script(malicious, &[]);
        assert!(script.contains(&escaped));
    }
}

```

`src/error.rs`:

```rs
//! Error types for the IDA MCP server.
//!
//! Tool execution errors are returned with `is_error: true` in CallToolResult,
//! while protocol errors (invalid tool name, malformed args) are handled by rmcp.

use rmcp::model::{CallToolResult, Content};
use thiserror::Error;

/// Tool execution errors - returned with is_error: true in CallToolResult
#[derive(Error, Debug)]
pub enum ToolError {
    #[error("No database is currently open")]
    NoDatabaseOpen,

    #[error("A database is already open: {0}. Use close_idb first.")]
    DatabaseAlreadyOpen(String),

    #[error("Failed to open database: {0}")]
    OpenFailed(String),

    #[error("Database appears to be open in another instance: {0}")]
    DatabaseLocked(String),

    #[error("Invalid address format: {0}")]
    InvalidAddress(String),

    #[error("Invalid database path: {0}")]
    InvalidPath(String),

    #[error("Invalid parameters: {0}")]
    InvalidParams(String),

    #[error("Invalid tool category: {0}")]
    InvalidToolCategory(String),

    #[error("Invalid tool name: {0}")]
    InvalidToolName(String),

    #[error("Address {0:#x} is outside valid range")]
    AddressOutOfRange(u64),

    #[error("Function not found at address {0:#x}")]
    FunctionNotFound(u64),

    #[error("Function not found: {0}")]
    FunctionNameNotFound(String),

    #[error("Decompiler not available")]
    DecompilerUnavailable,

    #[error("Operation timed out after {0} seconds")]
    Timeout(u64),

    #[error("Server is busy (request queue full). Please retry.")]
    Busy,

    #[error("IDA error: {0}")]
    IdaError(String),

    #[error("Not supported: {0}")]
    NotSupported(String),

    #[error("Worker channel closed")]
    WorkerClosed,
}

impl ToolError {
    /// Convert to MCP CallToolResult with is_error: true
    pub fn to_tool_result(&self) -> CallToolResult {
        CallToolResult {
            content: vec![Content::text(self.to_string())],
            is_error: Some(true),
            meta: None,
            structured_content: None,
        }
    }
}

impl From<idalib::IDAError> for ToolError {
    fn from(e: idalib::IDAError) -> Self {
        ToolError::IdaError(e.to_string())
    }
}

impl<T> From<std::sync::mpsc::SendError<T>> for ToolError {
    fn from(_: std::sync::mpsc::SendError<T>) -> Self {
        ToolError::WorkerClosed
    }
}

impl From<tokio::sync::oneshot::error::RecvError> for ToolError {
    fn from(_: tokio::sync::oneshot::error::RecvError) -> Self {
        ToolError::WorkerClosed
    }
}

```

`src/ida/handlers/address.rs`:

```rs
//! Address context handlers.

use crate::error::ToolError;
use crate::ida::types::{AddressInfo, FunctionRangeInfo, SegmentInfo, SymbolInfo};
use idalib::IDB;

pub fn handle_addr_info(idb: &Option<IDB>, addr: u64) -> Result<AddressInfo, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let segment = db.segment_at(addr).map(|seg| {
        let perms = seg.permissions();
        let perm_str = format!(
            "{}{}{}",
            if perms.is_readable() { "r" } else { "-" },
            if perms.is_writable() { "w" } else { "-" },
            if perms.is_executable() { "x" } else { "-" }
        );

        SegmentInfo {
            name: seg.name().unwrap_or_default(),
            start: format!("{:#x}", seg.start_address()),
            end: format!("{:#x}", seg.end_address()),
            size: seg.len(),
            permissions: perm_str,
            r#type: format!("{:?}", seg.r#type()),
            bitness: seg.bitness() as u32,
        }
    });

    let function = db.function_at(addr).map(|func| {
        let start = func.start_address();
        let end = func.end_address();
        let name = func.name().unwrap_or_else(|| format!("sub_{:x}", start));
        FunctionRangeInfo {
            address: format!("{:#x}", start),
            name,
            start: format!("{:#x}", start),
            end: format!("{:#x}", end),
            size: func.len(),
        }
    });

    let symbol = db.names().get_closest_by_address(addr).map(|name| {
        let sym_addr = name.address();
        let delta_raw: i128 = if addr >= sym_addr {
            (addr - sym_addr) as i128
        } else {
            -((sym_addr - addr) as i128)
        };
        let delta = delta_raw.clamp(i64::MIN as i128, i64::MAX as i128) as i64;
        SymbolInfo {
            name: name.name().to_string(),
            address: format!("{:#x}", sym_addr),
            delta,
            exact: delta == 0,
            is_public: name.is_public(),
            is_weak: name.is_weak(),
        }
    });

    Ok(AddressInfo {
        address: format!("{:#x}", addr),
        segment,
        function,
        symbol,
    })
}

```

`src/ida/handlers/analysis.rs`:

```rs
//! Analysis status helpers.

use crate::error::ToolError;
use crate::ida::types::AnalysisStatus;
use idalib::IDB;

fn auto_state_name(state: i32) -> &'static str {
    match state {
        0 => "AU_NONE",
        10 => "AU_UNK",
        20 => "AU_CODE",
        25 => "AU_WEAK",
        30 => "AU_PROC",
        35 => "AU_TAIL",
        38 => "AU_FCHUNK",
        40 => "AU_USED",
        45 => "AU_USD2",
        50 => "AU_TYPE",
        60 => "AU_LIBF",
        70 => "AU_LBF2",
        80 => "AU_LBF3",
        90 => "AU_CHLB",
        200 => "AU_FINAL",
        _ => "AU_UNKNOWN",
    }
}

pub fn build_analysis_status(db: &IDB) -> AnalysisStatus {
    let meta = db.meta();
    let auto_enabled = meta.is_auto_enabled();
    let auto_is_ok = meta.auto_is_ok();
    let auto_state_id = meta.auto_state();
    AnalysisStatus {
        auto_enabled,
        auto_is_ok,
        auto_state: auto_state_name(auto_state_id).to_string(),
        auto_state_id,
        analysis_running: auto_enabled && !auto_is_ok,
    }
}

pub fn handle_analysis_status(idb: &Option<IDB>) -> Result<AnalysisStatus, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    Ok(build_analysis_status(db))
}

```

`src/ida/handlers/annotations.rs`:

```rs
//! Comment and rename handlers.

use crate::error::ToolError;
use crate::ida::handlers::resolve_address;
use idalib::IDB;
use serde_json::{json, Value};

pub fn handle_set_comments(
    idb: &Option<IDB>,
    addr: Option<u64>,
    name: Option<&str>,
    offset: u64,
    comment: &str,
    repeatable: bool,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let addr = resolve_address(idb, addr, name, offset)?;
    if repeatable {
        db.set_cmt_with(addr, comment, true)?;
    } else {
        db.set_cmt(addr, comment)?;
    }
    Ok(json!({
        "address": format!("{:#x}", addr),
        "repeatable": repeatable,
        "comment": comment,
    }))
}

pub fn handle_rename(
    idb: &Option<IDB>,
    addr: Option<u64>,
    current_name: Option<&str>,
    name: &str,
    flags: i32,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let addr = resolve_address(idb, addr, current_name, 0)?;
    if flags == 0 {
        db.set_name(addr, name)?;
    } else {
        db.set_name_with_flags(addr, name, flags)?;
    }
    Ok(json!({
        "address": format!("{:#x}", addr),
        "name": name,
        "flags": flags,
    }))
}

```

`src/ida/handlers/controlflow.rs`:

```rs
//! Control flow analysis handlers.

use crate::error::ToolError;
use crate::ida::handlers::parse_address_str;
use crate::ida::types::{BasicBlockInfo, FunctionInfo};
use idalib::xref::XRefQuery;
use idalib::IDB;
use serde_json::{json, Value};
use std::collections::{HashMap, HashSet, VecDeque};

pub fn handle_basic_blocks(idb: &Option<IDB>, addr: u64) -> Result<Vec<BasicBlockInfo>, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let func = db
        .function_at(addr)
        .ok_or(ToolError::FunctionNotFound(addr))?;

    let cfg = func.cfg().map_err(|e| ToolError::IdaError(e.to_string()))?;

    let mut blocks = Vec::new();
    for block in cfg.blocks() {
        let block_type = if block.is_normal() {
            "normal"
        } else if block.is_ret() {
            "ret"
        } else if block.is_cndret() {
            "cndret"
        } else if block.is_noret() {
            "noret"
        } else if block.is_indjump() {
            "indjump"
        } else if block.is_extern() {
            "extern"
        } else if block.is_error() {
            "error"
        } else {
            "unknown"
        };

        let succs: Vec<String> = block
            .succs_with(&cfg)
            .map(|b| format!("{:#x}", b.start_address()))
            .collect();

        let preds: Vec<String> = block
            .preds_with(&cfg)
            .map(|b| format!("{:#x}", b.start_address()))
            .collect();

        blocks.push(BasicBlockInfo {
            start: format!("{:#x}", block.start_address()),
            end: format!("{:#x}", block.end_address()),
            size: block.len(),
            block_type: block_type.to_string(),
            successors: succs,
            predecessors: preds,
        });
    }

    Ok(blocks)
}

pub fn handle_callees(idb: &Option<IDB>, addr: u64) -> Result<Vec<FunctionInfo>, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let func = db
        .function_at(addr)
        .ok_or(ToolError::FunctionNotFound(addr))?;

    let mut callees = Vec::new();
    let mut seen = HashSet::new();

    // Iterate through the function's addresses and find call xrefs
    let start = func.start_address();
    let end = func.end_address();
    let mut current_addr = start;

    while current_addr < end {
        if let Some(xref) = db.first_xref_from(current_addr, XRefQuery::ALL) {
            let mut xr = Some(xref);
            while let Some(x) = xr {
                // Check if this is a call (code xref to a function)
                if x.is_code() {
                    let target = x.to();
                    if !seen.contains(&target) {
                        if let Some(target_func) = db.function_at(target) {
                            seen.insert(target);
                            callees.push(FunctionInfo {
                                address: format!("{:#x}", target_func.start_address()),
                                name: target_func
                                    .name()
                                    .unwrap_or_else(|| format!("sub_{:x}", target)),
                                size: target_func.len(),
                            });
                        }
                    }
                }
                xr = x.next_from();
            }
        }

        // Move to next instruction
        if let Some(next) = db.next_head(current_addr) {
            if next <= current_addr {
                break;
            }
            current_addr = next;
        } else {
            break;
        }
    }

    Ok(callees)
}

pub fn handle_callers(idb: &Option<IDB>, addr: u64) -> Result<Vec<FunctionInfo>, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let func = db
        .function_at(addr)
        .ok_or(ToolError::FunctionNotFound(addr))?;

    let mut callers = Vec::new();
    let mut seen = HashSet::new();

    // Get xrefs to the function's start address
    let mut current = db.first_xref_to(func.start_address(), XRefQuery::ALL);

    while let Some(xref) = current {
        if xref.is_code() {
            let from_addr = xref.from();
            if let Some(caller_func) = db.function_at(from_addr) {
                let caller_start = caller_func.start_address();
                if !seen.contains(&caller_start) {
                    seen.insert(caller_start);
                    callers.push(FunctionInfo {
                        address: format!("{:#x}", caller_start),
                        name: caller_func
                            .name()
                            .unwrap_or_else(|| format!("sub_{:x}", caller_start)),
                        size: caller_func.len(),
                    });
                }
            }
        }
        current = xref.next_to();
    }

    Ok(callers)
}

pub fn handle_find_paths(
    idb: &Option<IDB>,
    start: u64,
    end: u64,
    max_paths: usize,
    max_depth: usize,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let func = db
        .function_at(start)
        .ok_or(ToolError::FunctionNotFound(start))?;
    if !func.contains_address(end) {
        return Err(ToolError::NotSupported(
            "find_paths only supports addresses within the same function".to_string(),
        ));
    }

    let cfg = func.cfg().map_err(|e| ToolError::IdaError(e.to_string()))?;
    let blocks: Vec<_> = cfg.blocks().collect();
    let mut index_by_start = HashMap::new();
    for (idx, blk) in blocks.iter().enumerate() {
        index_by_start.insert(blk.start_address(), idx);
    }

    let start_idx = blocks
        .iter()
        .position(|b| b.contains_address(start))
        .ok_or(ToolError::AddressOutOfRange(start))?;
    let end_idx = blocks
        .iter()
        .position(|b| b.contains_address(end))
        .ok_or(ToolError::AddressOutOfRange(end))?;

    let mut results: Vec<Vec<String>> = Vec::new();
    let mut path = Vec::new();

    #[allow(clippy::too_many_arguments)]
    fn dfs(
        cfg: &idalib::func::FunctionCFG<'_>,
        blocks: &[idalib::func::BasicBlock<'_>],
        index_by_start: &HashMap<u64, usize>,
        cur: usize,
        end: usize,
        max_depth: usize,
        max_paths: usize,
        path: &mut Vec<usize>,
        results: &mut Vec<Vec<String>>,
    ) {
        if results.len() >= max_paths {
            return;
        }
        if path.len() > max_depth {
            return;
        }
        path.push(cur);
        if cur == end {
            let p = path
                .iter()
                .map(|idx| format!("{:#x}", blocks[*idx].start_address()))
                .collect::<Vec<_>>();
            results.push(p);
            path.pop();
            return;
        }

        for succ in blocks[cur].succs_with(cfg) {
            if let Some(&next_idx) = index_by_start.get(&succ.start_address()) {
                if path.contains(&next_idx) {
                    continue;
                }
                dfs(
                    cfg,
                    blocks,
                    index_by_start,
                    next_idx,
                    end,
                    max_depth,
                    max_paths,
                    path,
                    results,
                );
                if results.len() >= max_paths {
                    break;
                }
            }
        }

        path.pop();
    }

    let max_depth = max_depth.max(1);
    let max_paths = max_paths.max(1);
    dfs(
        &cfg,
        &blocks,
        &index_by_start,
        start_idx,
        end_idx,
        max_depth,
        max_paths,
        &mut path,
        &mut results,
    );

    Ok(json!({ "paths": results, "count": results.len() }))
}

pub fn handle_callgraph(
    idb: &Option<IDB>,
    addr: u64,
    max_depth: usize,
    max_nodes: usize,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let root = db
        .function_at(addr)
        .ok_or(ToolError::FunctionNotFound(addr))?;

    let mut nodes: HashMap<u64, FunctionInfo> = HashMap::new();
    let mut edges: Vec<(u64, u64)> = Vec::new();
    let mut queue: VecDeque<(u64, usize)> = VecDeque::new();
    let max_depth = max_depth.max(1);
    let max_nodes = max_nodes.max(1);

    let root_addr = root.start_address();
    nodes.insert(
        root_addr,
        FunctionInfo {
            address: format!("{:#x}", root_addr),
            name: root
                .name()
                .unwrap_or_else(|| format!("sub_{:x}", root_addr)),
            size: root.len(),
        },
    );
    queue.push_back((root_addr, 0));

    while let Some((cur_addr, depth)) = queue.pop_front() {
        if depth >= max_depth {
            continue;
        }
        if nodes.len() >= max_nodes {
            break;
        }

        let callees = handle_callees(idb, cur_addr).unwrap_or_default();
        for callee in callees {
            if let Ok(target_addr) = parse_address_str(&callee.address) {
                edges.push((cur_addr, target_addr));
                if !nodes.contains_key(&target_addr) && nodes.len() < max_nodes {
                    nodes.insert(target_addr, callee.clone());
                    queue.push_back((target_addr, depth + 1));
                }
            }
        }
    }

    let nodes_vec: Vec<Value> = nodes
        .values()
        .map(|f| json!({ "address": f.address, "name": f.name, "size": f.size }))
        .collect();
    let edges_vec: Vec<Value> = edges
        .iter()
        .map(|(from, to)| json!({ "from": format!("{:#x}", from), "to": format!("{:#x}", to) }))
        .collect();

    Ok(json!({ "nodes": nodes_vec, "edges": edges_vec }))
}

```

`src/ida/handlers/database.rs`:

```rs
//! Database open/close handlers.

use crate::error::ToolError;
use crate::expand_path;
use crate::ida::handlers::analysis::build_analysis_status;
use crate::ida::lock::{
    acquire_mcp_lock, clean_stale_mcp_lock, detect_db_lock, release_mcp_lock_file,
};
use crate::ida::types::{DbInfo, DebugInfoLoad};
use idalib::{IDBOpenOptions, IDB};
use serde_json::{json, Value};
use std::ffi::OsString;
use std::fs::File;
use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};
use tracing::{info, warn};

/// Build `DbInfo` from an open IDB.
fn build_db_info(db: &IDB, path: &str, debug_info: Option<DebugInfoLoad>) -> DbInfo {
    let meta = db.meta();
    DbInfo {
        path: path.to_string(),
        file_type: format!("{:?}", meta.filetype()),
        processor: db.processor().long_name(),
        bits: if meta.is_64bit() {
            64
        } else if meta.is_32bit_exactly() {
            32
        } else {
            16
        },
        function_count: db.function_count(),
        debug_info,
        analysis_status: build_analysis_status(db),
    }
}

// Helper functions for debug info paths

fn dsym_expected_path_for_binary(path: &Path) -> Option<PathBuf> {
    let file_name = path.file_name()?;
    let mut dsym = OsString::from(path.as_os_str());
    dsym.push(".dSYM");
    let dsym_root = PathBuf::from(dsym);
    let dwarf_path = dsym_root
        .join("Contents")
        .join("Resources")
        .join("DWARF")
        .join(file_name);
    Some(dwarf_path)
}

fn dsym_path_for_binary(path: &Path) -> Option<PathBuf> {
    dsym_expected_path_for_binary(path).filter(|p| p.exists())
}

fn unpacked_id0_path(path: &Path) -> Option<PathBuf> {
    let ext = path.extension().and_then(|e| e.to_str())?;
    if ext == "i64" || ext == "idb" {
        let mut id0 = path.to_path_buf();
        id0.set_extension("id0");
        return Some(id0);
    }
    None
}

#[allow(clippy::too_many_arguments)]
pub fn handle_open(
    idb: &mut Option<IDB>,
    lock_file: &mut Option<File>,
    lock_path: &mut Option<PathBuf>,
    path: &str,
    load_debug_info: bool,
    debug_info_path: Option<&str>,
    debug_info_verbose: bool,
    force: bool,
    file_type: Option<&str>,
    auto_analyse: bool,
    extra_args: &[String],
) -> Result<DbInfo, ToolError> {
    let expanded = expand_path(path);

    // Check if a database is already open
    if let Some(db) = idb.as_ref() {
        let current_path = db.path();
        if current_path == expanded {
            // Same database - return its info instead of reopening
            info!(path = %expanded.display(), "Database already open, returning existing info");
            return Ok(build_db_info(db, &current_path.display().to_string(), None));
        } else {
            // Different database - tell them to close first
            return Err(ToolError::DatabaseAlreadyOpen(
                current_path.display().to_string(),
            ));
        }
    }

    // Check file exists
    if !expanded.exists() {
        return Err(ToolError::InvalidPath(format!(
            "File not found: {}",
            expanded.display()
        )));
    }

    // Determine if this is an IDA database or a raw binary
    let ext = expanded
        .extension()
        .and_then(|e| e.to_str())
        .unwrap_or("")
        .to_ascii_lowercase();
    let is_idb = ext == "i64" || ext == "idb" || ext == "id0";

    let mut raw_out_path = None;
    let mut dsym_path = None;
    let mut should_load_dsym = false;
    if !is_idb {
        let out_path = expanded.with_extension("i64");
        should_load_dsym = !out_path.exists();
        if should_load_dsym {
            dsym_path = dsym_path_for_binary(&expanded);
        }
        raw_out_path = Some(out_path);
    }

    // If force is enabled, try to clean up stale lock files from crashed sessions
    if force {
        if let Some(stale) = clean_stale_mcp_lock(&expanded) {
            info!(
                path = %stale.path.display(),
                pid = stale.pid,
                reason = %stale.reason,
                "Cleaned up stale lock file"
            );
        }
    }

    // Acquire MCP lock file (to detect other ida-mcp instances)
    let mcp_lock = acquire_mcp_lock(&expanded)?;

    // Open database
    let done = Arc::new(AtomicBool::new(false));
    let done_clone = done.clone();
    let path_display = expanded.display().to_string();
    let ticker = std::thread::spawn(move || {
        let start = Instant::now();
        loop {
            std::thread::sleep(Duration::from_secs(10));
            if done_clone.load(Ordering::Relaxed) {
                break;
            }
            info!(
                path = %path_display,
                elapsed = start.elapsed().as_secs(),
                "Still opening database..."
            );
        }
    });

    let open_start = Instant::now();
    let mut opened_path = expanded.clone();
    let db = if is_idb {
        // Open existing IDA database (no auto-analysis needed, but save=true to pack on close)
        let mut db = IDB::open_with(&expanded, false, true);
        if db.is_err() {
            if let Some(id0_path) = unpacked_id0_path(&expanded) {
                if id0_path.exists() {
                    info!(path = %id0_path.display(), "Falling back to unpacked ID0 database");
                    opened_path = id0_path.clone();
                    db = IDB::open_with(&id0_path, false, true);
                }
            }
        }
        db
    } else {
        // Raw binary - open with auto-analysis and save to .i64
        let out_path = raw_out_path
            .as_ref()
            .expect("raw binary should have out path");
        info!(
            "Opening raw binary with auto-analysis (idb_out={})",
            out_path.display()
        );
        opened_path = out_path.clone();
        let mut opts = IDBOpenOptions::new();
        opts.auto_analyse(auto_analyse);
        if let Some(ft) = file_type {
            info!(file_type = ft, "Using file type selector (-T flag)");
            opts.file_type(ft);
        }
        for arg in extra_args {
            opts.arg(arg);
        }
        opts.idb(out_path).save(true).open(&expanded)
    };
    done.store(true, Ordering::Relaxed);
    let _ = ticker.join();
    let db = match db {
        Ok(db) => db,
        Err(e) => {
            release_mcp_lock_file(mcp_lock);
            if let Some(lock_msg) = detect_db_lock(&expanded, &e) {
                return Err(ToolError::DatabaseLocked(lock_msg));
            }
            return Err(ToolError::OpenFailed(format!(
                "{}: {}",
                opened_path.display(),
                e
            )));
        }
    };

    let mut debug_info = None;
    if load_debug_info {
        let mut resolved = None;
        if let Some(path) = debug_info_path {
            resolved = Some(PathBuf::from(path));
        } else {
            let mut base = expanded.clone();
            if is_idb {
                if let Some(ext) = base.extension().and_then(|e| e.to_str()) {
                    if ext.eq_ignore_ascii_case("i64") || ext.eq_ignore_ascii_case("idb") {
                        base.set_extension("");
                    }
                }
            }
            if let Some(candidate) = dsym_expected_path_for_binary(&base) {
                resolved = Some(candidate);
            }
        }

        if let Some(path) = resolved {
            if !path.exists() {
                debug_info = Some(DebugInfoLoad {
                    path: path.display().to_string(),
                    loaded: false,
                    error: Some("debug info not found".to_string()),
                });
            } else {
                match db.load_debug_info(&path, debug_info_verbose) {
                    Ok(loaded) => {
                        if loaded {
                            info!(path = %path.display(), "Debug info loaded");
                            debug_info = Some(DebugInfoLoad {
                                path: path.display().to_string(),
                                loaded,
                                error: None,
                            });
                        } else {
                            warn!(path = %path.display(), "Debug info load returned false");
                            debug_info = Some(DebugInfoLoad {
                                path: path.display().to_string(),
                                loaded,
                                error: Some("load returned false".to_string()),
                            });
                        }
                    }
                    Err(e) => {
                        warn!(path = %path.display(), error = %e, "Debug info load error");
                        debug_info = Some(DebugInfoLoad {
                            path: path.display().to_string(),
                            loaded: false,
                            error: Some(e.to_string()),
                        });
                    }
                }
            }
        }
    } else if !is_idb && should_load_dsym {
        if let Some(path) = dsym_path.as_ref() {
            info!(path = %path.display(), "Loading dSYM debug info");
            match db.load_debug_info(path, false) {
                Ok(true) => info!(path = %path.display(), "dSYM debug info loaded"),
                Ok(false) => warn!(path = %path.display(), "dSYM debug info load failed"),
                Err(e) => warn!(path = %path.display(), error = %e, "dSYM debug info load error"),
            }
        }
    }

    let path_str = opened_path.display().to_string();
    let info = build_db_info(&db, &path_str, debug_info);
    info!(
        "IDA open success: type={} proc={} bits={} functions={} elapsed={}s",
        info.file_type,
        info.processor,
        info.bits,
        info.function_count,
        open_start.elapsed().as_secs()
    );

    let (lf, lp) = mcp_lock.into_parts();
    *lock_file = Some(lf);
    *lock_path = Some(lp);
    *idb = Some(db);
    Ok(info)
}

pub fn handle_load_debug_info(
    idb: &Option<IDB>,
    path: Option<&str>,
    verbose: bool,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let resolved = if let Some(path) = path {
        PathBuf::from(path)
    } else {
        let mut base = db.path().to_path_buf();
        if let Some(ext) = base.extension().and_then(|e| e.to_str()) {
            if ext.eq_ignore_ascii_case("i64") || ext.eq_ignore_ascii_case("idb") {
                base.set_extension("");
            }
        }
        dsym_path_for_binary(&base)
            .ok_or_else(|| ToolError::InvalidPath("No sibling .dSYM found".to_string()))?
    };

    if !resolved.exists() {
        return Err(ToolError::InvalidPath(format!(
            "File not found: {}",
            resolved.display()
        )));
    }

    let loaded = db.load_debug_info(&resolved, verbose)?;
    Ok(json!({
        "path": resolved.display().to_string(),
        "loaded": loaded,
    }))
}

```

`src/ida/handlers/disasm.rs`:

```rs
//! Disassembly and decompilation handlers.

use crate::disasm::generate_disasm_line;
use crate::error::ToolError;
use idalib::{Address, IDB};
use serde_json::{json, Value};
use std::collections::HashSet;

pub fn handle_disasm_by_name(
    idb: &Option<IDB>,
    name: &str,
    count: usize,
) -> Result<String, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    for (_id, func) in db.functions() {
        if let Some(func_name) = func.name() {
            if func_name == name || func_name.contains(name) {
                let addr = func.start_address();
                return handle_disasm(idb, addr, count);
            }
        }
    }

    Err(ToolError::FunctionNameNotFound(name.to_string()))
}

pub fn handle_disasm(idb: &Option<IDB>, addr: u64, count: usize) -> Result<String, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let mut lines = Vec::with_capacity(count);
    let mut current_addr: Address = addr;

    for _ in 0..count {
        // Get disassembly line
        if let Some(line) = generate_disasm_line(db, current_addr) {
            lines.push(format!("{:#x}:\t{}", current_addr, line));
        } else {
            // No more valid instructions
            break;
        }

        // Get instruction at current address to find next
        if let Some(insn) = db.insn_at(current_addr) {
            current_addr += insn.len() as u64;
        } else {
            // Move to next head
            if let Some(next) = db.next_head(current_addr) {
                if next <= current_addr {
                    break; // Prevent infinite loop
                }
                current_addr = next;
            } else {
                break;
            }
        }
    }

    if lines.is_empty() {
        return Err(ToolError::AddressOutOfRange(addr));
    }

    Ok(lines.join("\n"))
}

pub fn handle_disasm_function_at(
    idb: &Option<IDB>,
    addr: u64,
    count: usize,
) -> Result<String, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let func = db
        .function_at(addr)
        .ok_or(ToolError::FunctionNotFound(addr))?;
    let start = func.start_address();
    let end = func.end_address();

    let mut lines = Vec::new();
    let mut current_addr: Address = start;

    while current_addr < end && lines.len() < count {
        if let Some(line) = generate_disasm_line(db, current_addr) {
            lines.push(format!("{:#x}:\t{}", current_addr, line));
        } else {
            break;
        }

        if let Some(insn) = db.insn_at(current_addr) {
            current_addr += insn.len() as u64;
        } else if let Some(next) = db.next_head(current_addr) {
            if next <= current_addr {
                break;
            }
            current_addr = next;
        } else {
            break;
        }
    }

    if lines.is_empty() {
        return Err(ToolError::AddressOutOfRange(addr));
    }

    Ok(lines.join("\n"))
}

pub fn handle_decompile(idb: &Option<IDB>, addr: u64) -> Result<String, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    // Check if decompiler is available
    if !db.decompiler_available() {
        return Err(ToolError::DecompilerUnavailable);
    }

    // Find the function at this address
    let func = db
        .function_at(addr)
        .ok_or(ToolError::FunctionNotFound(addr))?;

    // Decompile function
    let cfunc = db
        .decompile(&func)
        .map_err(|e| ToolError::IdaError(e.to_string()))?;

    // Get the pseudocode as string
    Ok(cfunc.pseudocode())
}

/// Get decompiled pseudocode statements at a specific address or address range.
pub fn handle_pseudocode_at(
    idb: &Option<IDB>,
    addr: u64,
    end_addr: Option<u64>,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    // Check if decompiler is available
    if !db.decompiler_available() {
        return Err(ToolError::DecompilerUnavailable);
    }

    // Find the function at this address
    let func = db
        .function_at(addr)
        .ok_or(ToolError::FunctionNotFound(addr))?;

    let func_start = func.start_address();
    let func_end = func.end_address();
    let func_name = func
        .name()
        .unwrap_or_else(|| format!("sub_{:x}", func_start));

    // Decompile function
    let cfunc = db
        .decompile(&func)
        .map_err(|e| ToolError::IdaError(e.to_string()))?;

    let eamap_ready = cfunc.has_eamap();

    let mut statements = Vec::new();
    let mut seen_eas = HashSet::new();

    if let Some(end) = end_addr {
        // Range query - collect unique statements that cover any address in [addr, end)
        let mut cur = addr;
        while cur < end {
            if let Some(stmts) = cfunc.statements_at(cur) {
                for stmt in stmts {
                    let stmt_ea = stmt.address();
                    if seen_eas.insert(stmt_ea) {
                        let text = stmt.to_string();
                        let bounds = stmt.bounds();
                        statements.push(json!({
                            "address": format!("{:#x}", stmt_ea),
                            "text": text.trim(),
                            "opcode": stmt.opcode(),
                            "bounds": bounds.map(|b| json!({
                                "start": format!("{:#x}", b.start),
                                "end": format!("{:#x}", b.end),
                            })),
                        }));
                    }
                }
            }
            cur += 1;
        }
    } else {
        // Single address query
        if let Some(stmts) = cfunc.statements_at(addr) {
            for stmt in stmts {
                let stmt_ea = stmt.address();
                if seen_eas.insert(stmt_ea) {
                    let text = stmt.to_string();
                    let bounds = stmt.bounds();
                    statements.push(json!({
                        "address": format!("{:#x}", stmt_ea),
                        "text": text.trim(),
                        "opcode": stmt.opcode(),
                        "bounds": bounds.map(|b| json!({
                            "start": format!("{:#x}", b.start),
                            "end": format!("{:#x}", b.end),
                        })),
                    }));
                }
            }
        }
    }

    Ok(json!({
        "function": {
            "address": format!("{:#x}", func_start),
            "name": func_name,
            "start": format!("{:#x}", func_start),
            "end": format!("{:#x}", func_end),
        },
        "query_address": format!("{:#x}", addr),
        "query_end_address": end_addr.map(|a| format!("{:#x}", a)),
        "eamap_ready": eamap_ready,
        "statements": statements,
        "count": statements.len(),
    }))
}

```

`src/ida/handlers/functions.rs`:

```rs
//! Function-related handlers.

use crate::error::ToolError;
use crate::ida::handlers::parse_address_str;
use crate::ida::types::{FunctionInfo, FunctionListResult, FunctionRangeInfo};
use idalib::IDB;
use serde_json::{json, Value};

pub fn handle_list_functions(
    idb: &Option<IDB>,
    offset: usize,
    limit: usize,
    filter: Option<&str>,
) -> Result<FunctionListResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let filter_lower = filter.map(|f| f.to_lowercase());
    let mut functions = Vec::with_capacity(limit);
    let mut total = 0usize;

    for (_id, func) in db.functions() {
        let addr = func.start_address();
        let name = func.name().unwrap_or_else(|| format!("sub_{:x}", addr));
        let size = func.len();

        if let Some(f) = &filter_lower {
            if !name.to_lowercase().contains(f) {
                continue;
            }
        }

        total += 1;
        if total <= offset {
            continue;
        }
        if functions.len() >= limit {
            continue;
        }

        functions.push(FunctionInfo {
            address: format!("{:#x}", addr),
            name,
            size,
        });
    }

    let next_offset = if offset.saturating_add(functions.len()) < total {
        Some(offset.saturating_add(functions.len()))
    } else {
        None
    };

    Ok(FunctionListResult {
        functions,
        total,
        next_offset,
    })
}

pub fn handle_resolve_function(idb: &Option<IDB>, name: &str) -> Result<FunctionInfo, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    for (_id, func) in db.functions() {
        if let Some(func_name) = func.name() {
            if func_name == name || func_name.contains(name) {
                let addr = func.start_address();
                let size = func.len();
                return Ok(FunctionInfo {
                    address: format!("{:#x}", addr),
                    name: func_name,
                    size,
                });
            }
        }
    }

    Err(ToolError::FunctionNameNotFound(name.to_string()))
}

pub fn handle_lookup_funcs(idb: &Option<IDB>, queries: &[String]) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let mut results = Vec::with_capacity(queries.len());

    // Precompute functions for name lookups
    let funcs: Vec<FunctionInfo> = db
        .functions()
        .map(|(_id, func)| {
            let addr = func.start_address();
            let name = func.name().unwrap_or_else(|| format!("sub_{:x}", addr));
            let size = func.len();
            FunctionInfo {
                address: format!("{:#x}", addr),
                name,
                size,
            }
        })
        .collect();

    for query in queries {
        if let Ok(addr) = parse_address_str(query) {
            if let Some(func) = db.function_at(addr) {
                let info = FunctionInfo {
                    address: format!("{:#x}", func.start_address()),
                    name: func
                        .name()
                        .unwrap_or_else(|| format!("sub_{:x}", func.start_address())),
                    size: func.len(),
                };
                results.push(json!({"query": query, "result": info}));
            } else {
                results.push(json!({"query": query, "error": "Function not found"}));
            }
            continue;
        }

        if let Some(info) = funcs
            .iter()
            .find(|f| f.name == *query || f.name.contains(query))
        {
            results.push(json!({"query": query, "result": info}));
        } else {
            results.push(json!({"query": query, "error": "Function not found"}));
        }
    }

    Ok(json!({ "results": results }))
}

pub fn handle_analyze_funcs(idb: &mut Option<IDB>) -> Result<Value, ToolError> {
    let db = idb.as_mut().ok_or(ToolError::NoDatabaseOpen)?;
    let completed = db.auto_wait();
    Ok(json!({
        "completed": completed,
        "function_count": db.function_count(),
    }))
}

pub fn handle_function_at(idb: &Option<IDB>, addr: u64) -> Result<FunctionRangeInfo, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let func = db
        .function_at(addr)
        .ok_or(ToolError::FunctionNotFound(addr))?;
    let start = func.start_address();
    let end = func.end_address();
    let name = func.name().unwrap_or_else(|| format!("sub_{:x}", start));
    Ok(FunctionRangeInfo {
        address: format!("{:#x}", start),
        name,
        start: format!("{:#x}", start),
        end: format!("{:#x}", end),
        size: func.len(),
    })
}

```

`src/ida/handlers/globals.rs`:

```rs
//! Global variable handlers.

use crate::error::ToolError;
use crate::ida::handlers::{hex_encode, try_parse_address};
use crate::ida::types::GlobalInfo;
use idalib::IDB;
use serde_json::{json, Value};

pub fn handle_list_globals(
    idb: &Option<IDB>,
    query: Option<&str>,
    offset: usize,
    limit: usize,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let filter_lower = query.map(|q| q.to_lowercase());

    let mut globals = Vec::new();
    let mut total = 0usize;

    for name in db.names().iter() {
        if let Some(f) = &filter_lower {
            if !name.name().to_lowercase().contains(f) {
                continue;
            }
        }

        // Only consider named addresses outside of functions
        if db.function_at(name.address()).is_some() {
            continue;
        }

        total += 1;
        if total <= offset {
            continue;
        }
        if globals.len() >= limit {
            continue;
        }

        globals.push(GlobalInfo {
            address: format!("{:#x}", name.address()),
            name: name.name().to_string(),
            is_public: name.is_public(),
            is_weak: Some(name.is_weak()),
        });
    }

    let next_offset = if offset.saturating_add(globals.len()) < total {
        Some(offset.saturating_add(globals.len()))
    } else {
        None
    };

    Ok(json!({
        "globals": globals,
        "total": total,
        "next_offset": next_offset
    }))
}

pub fn handle_get_global_value(idb: &Option<IDB>, query: &str) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let addr = if let Some(a) = try_parse_address(query) {
        a
    } else {
        let mut found = None;
        for name in db.names().iter() {
            if name.name() == query {
                found = Some(name.address());
                break;
            }
        }
        found.ok_or_else(|| ToolError::FunctionNameNotFound(query.to_string()))?
    };

    let bytes = db.get_bytes(addr, 8);
    let mut val: u64 = 0;
    for (i, b) in bytes.iter().take(8).enumerate() {
        val |= (*b as u64) << (i * 8);
    }

    Ok(json!({
        "address": format!("{:#x}", addr),
        "value": val,
        "hex": format!("0x{:x}", val),
        "bytes": hex_encode(&bytes),
    }))
}

pub fn handle_idb_meta(idb: &Option<IDB>) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let meta = db.meta();

    let bits = if meta.is_64bit() {
        64
    } else if meta.is_32bit_exactly() {
        32
    } else {
        16
    };

    let md5 = hex_encode(&meta.input_file_md5());
    let sha256 = hex_encode(&meta.input_file_sha256());

    Ok(json!({
        "file_type": format!("{:?}", meta.filetype()),
        "processor": db.processor().long_name(),
        "bits": bits,
        "function_count": db.function_count(),
        "input_file_path": meta.input_file_path(),
        "input_file_size": meta.input_file_size(),
        "md5": md5,
        "sha256": sha256,
        "base_address": meta.base_address().map(|a| format!("{:#x}", a)),
        "min_address": format!("{:#x}", meta.min_address()),
        "max_address": format!("{:#x}", meta.max_address()),
        "main_address": meta.main_address().map(|a| format!("{:#x}", a)),
    }))
}

```

`src/ida/handlers/imports.rs`:

```rs
//! Import, export, and entrypoint handlers.

use crate::error::ToolError;
use crate::ida::types::{ExportInfo, ImportInfo};
use idalib::IDB;

pub fn handle_imports(
    idb: &Option<IDB>,
    offset: usize,
    limit: usize,
) -> Result<Vec<ImportInfo>, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    // Imports are names in external segments
    let mut imports = Vec::new();
    let mut count = 0;

    for name in db.names().iter() {
        // Check if this is in an external segment
        if let Some(seg) = db.segment_at(name.address()) {
            if seg.r#type().is_extern() || seg.r#type().is_import() {
                if count < offset {
                    count += 1;
                    continue;
                }

                if imports.len() >= limit {
                    break;
                }

                imports.push(ImportInfo {
                    address: format!("{:#x}", name.address()),
                    name: name.name().to_string(),
                    ordinal: count,
                });
                count += 1;
            }
        }
    }

    Ok(imports)
}

pub fn handle_exports(
    idb: &Option<IDB>,
    offset: usize,
    limit: usize,
) -> Result<Vec<ExportInfo>, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let mut exports = Vec::new();
    let mut count = 0;

    for name in db.names().iter() {
        if count < offset {
            count += 1;
            continue;
        }

        if exports.len() >= limit {
            break;
        }

        exports.push(ExportInfo {
            address: format!("{:#x}", name.address()),
            name: name.name().to_string(),
            is_public: name.is_public(),
        });
        count += 1;
    }

    Ok(exports)
}

pub fn handle_entrypoints(idb: &Option<IDB>) -> Result<Vec<String>, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let entrypoints: Vec<String> = db.entries().map(|addr| format!("{:#x}", addr)).collect();

    Ok(entrypoints)
}

```

`src/ida/handlers/memory.rs`:

```rs
//! Memory read/write handlers.

use crate::error::ToolError;
use crate::ida::handlers::resolve_address;
use crate::ida::types::BytesResult;
use idalib::IDB;
use serde_json::{json, Value};

pub fn handle_get_bytes(
    idb: &Option<IDB>,
    addr: Option<u64>,
    name: Option<&str>,
    offset: u64,
    size: usize,
) -> Result<BytesResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let addr = resolve_address(idb, addr, name, offset)?;

    // Limit size to prevent huge reads
    let size = size.min(0x10000); // 64KB max

    let bytes = db.get_bytes(addr, size);
    let hex_string = bytes
        .iter()
        .map(|b| format!("{:02x}", b))
        .collect::<String>();

    Ok(BytesResult {
        address: format!("{:#x}", addr),
        bytes: hex_string,
        length: bytes.len(),
    })
}

pub fn handle_patch_bytes(
    idb: &Option<IDB>,
    addr: Option<u64>,
    name: Option<&str>,
    offset: u64,
    bytes: &[u8],
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let addr = resolve_address(idb, addr, name, offset)?;
    db.patch_bytes(addr, bytes)?;
    Ok(json!({
        "address": format!("{:#x}", addr),
        "length": bytes.len(),
    }))
}

pub fn handle_patch_asm(
    idb: &Option<IDB>,
    addr: Option<u64>,
    name: Option<&str>,
    offset: u64,
    line: &str,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let addr = resolve_address(idb, addr, name, offset)?;
    let bytes = db
        .assemble_line(addr, line)
        .map_err(|e| ToolError::IdaError(e.to_string()))?;
    db.patch_bytes(addr, &bytes)?;
    let hex = bytes
        .iter()
        .map(|b| format!("{:02x}", b))
        .collect::<Vec<_>>()
        .join(" ");
    Ok(json!({
        "address": format!("{:#x}", addr),
        "line": line,
        "length": bytes.len(),
        "bytes": hex,
    }))
}

pub fn handle_read_int(idb: &Option<IDB>, addr: u64, size: usize) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let value = match size {
        1 => db.get_byte(addr) as u64,
        2 => db.get_word(addr) as u64,
        4 => db.get_dword(addr) as u64,
        8 => db.get_qword(addr),
        _ => {
            return Err(ToolError::IdaError(format!(
                "unsupported integer size: {}",
                size
            )))
        }
    };

    Ok(json!({
        "address": format!("{:#x}", addr),
        "size": size,
        "value": value,
        "hex": format!("0x{:x}", value)
    }))
}

```

`src/ida/handlers/mod.rs`:

```rs
//! IDA operation handlers organized by domain.

pub mod address;
pub mod analysis;
pub mod annotations;
pub mod controlflow;
pub mod database;
pub mod disasm;
pub mod functions;
pub mod globals;
pub mod imports;
pub mod memory;
pub mod script;
pub mod search;
pub mod segments;
pub mod strings;
pub mod structs;
pub mod types;
pub mod xrefs;

use crate::error::ToolError;
use idalib::IDB;

// ============================================================================
// Shared utility functions used across multiple handlers
// ============================================================================

/// Parse an address string supporting hex (0x), binary (0b), octal (0o), and decimal.
pub(crate) fn parse_address_str(s: &str) -> Result<u64, ToolError> {
    let s = s.trim();
    if s.starts_with("0x") || s.starts_with("0X") {
        u64::from_str_radix(&s[2..], 16).map_err(|_| ToolError::InvalidAddress(s.to_string()))
    } else if s.starts_with("0b") || s.starts_with("0B") {
        u64::from_str_radix(&s[2..], 2).map_err(|_| ToolError::InvalidAddress(s.to_string()))
    } else if s.starts_with("0o") || s.starts_with("0O") {
        u64::from_str_radix(&s[2..], 8).map_err(|_| ToolError::InvalidAddress(s.to_string()))
    } else {
        s.parse::<u64>()
            .map_err(|_| ToolError::InvalidAddress(s.to_string()))
    }
}

/// Try to parse an address string, returning None on failure.
pub(crate) fn try_parse_address(s: &str) -> Option<u64> {
    parse_address_str(s).ok()
}

/// Encode bytes as hex string.
pub(crate) fn hex_encode(bytes: &[u8]) -> String {
    bytes.iter().map(|b| format!("{:02x}", b)).collect()
}

/// Resolve an address by name (function or symbol).
pub(crate) fn resolve_address_by_name(idb: &Option<IDB>, name: &str) -> Result<u64, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    for (_id, func) in db.functions() {
        if let Some(func_name) = func.name() {
            if func_name == name || func_name.contains(name) {
                return Ok(func.start_address());
            }
        }
    }
    for item in db.names().iter() {
        let item_name = item.name();
        if item_name == name || item_name.contains(name) {
            return Ok(item.address());
        }
    }
    Err(ToolError::FunctionNameNotFound(name.to_string()))
}

/// Resolve an address from either explicit address, name, or name+offset.
pub(crate) fn resolve_address(
    idb: &Option<IDB>,
    addr: Option<u64>,
    name: Option<&str>,
    offset: u64,
) -> Result<u64, ToolError> {
    let base = if let Some(addr) = addr {
        addr
    } else if let Some(name) = name {
        resolve_address_by_name(idb, name)?
    } else {
        return Err(ToolError::InvalidParams(
            "expected address or name".to_string(),
        ));
    };
    Ok(base.saturating_add(offset))
}

/// Parse a byte pattern string supporting wildcards.
pub(crate) fn parse_pattern(pattern: &str) -> Result<Vec<Option<u8>>, ToolError> {
    let trimmed = pattern.trim();
    if trimmed.is_empty() {
        return Err(ToolError::IdaError("empty pattern".to_string()));
    }

    let tokens: Vec<String> = if trimmed.contains(' ') {
        trimmed.split_whitespace().map(|s| s.to_string()).collect()
    } else {
        if !trimmed.len().is_multiple_of(2) {
            return Err(ToolError::IdaError(format!(
                "invalid hex pattern length: {}",
                trimmed
            )));
        }
        trimmed
            .as_bytes()
            .chunks(2)
            .map(|c| String::from_utf8_lossy(c).to_string())
            .collect()
    };

    let mut bytes = Vec::with_capacity(tokens.len());
    for tok in tokens {
        if tok == "?" || tok == "??" {
            bytes.push(None);
            continue;
        }
        let b = u8::from_str_radix(tok.trim_start_matches("0x"), 16)
            .map_err(|_| ToolError::IdaError(format!("invalid byte: {}", tok)))?;
        bytes.push(Some(b));
    }

    Ok(bytes)
}

```

`src/ida/handlers/script.rs`:

```rs
//! Script execution handler.

use crate::error::ToolError;
use idalib::IDB;
use serde_json::{json, Value};

fn last_non_empty_line(text: &str) -> Option<&str> {
    text.lines().rev().find_map(|line| {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            None
        } else {
            Some(trimmed)
        }
    })
}

fn classify_python_error(details: &str) -> Option<&'static str> {
    let lowered = details.to_ascii_lowercase();
    if lowered.contains("syntaxerror") || lowered.contains("invalid syntax") {
        return Some("SyntaxError");
    }
    if lowered.contains("nameerror") {
        return Some("NameError");
    }
    if lowered.contains("attributeerror") {
        return Some("AttributeError");
    }
    if lowered.contains("importerror") || lowered.contains("modulenotfounderror") {
        return Some("ImportError");
    }
    if lowered.contains("typeerror") {
        return Some("TypeError");
    }
    if lowered.contains("valueerror") {
        return Some("ValueError");
    }
    None
}

pub fn handle_run_script(idb: &Option<IDB>, code: &str) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let output = db.run_python(code)?;
    let error_summary = output
        .error
        .as_deref()
        .map(str::trim)
        .filter(|s| !s.is_empty())
        .map(str::to_string)
        .or_else(|| last_non_empty_line(&output.stderr).map(str::to_string));
    let error_details = format!(
        "{}\n{}",
        error_summary.as_deref().unwrap_or_default(),
        output.stderr
    );
    let error_kind = classify_python_error(&error_details);

    let mut result = json!({
        "success": output.success,
        "stdout": output.stdout,
        "stderr": output.stderr,
    });
    if let Some(error) = &output.error {
        result["error"] = json!(error);
    } else if !output.success {
        if let Some(summary) = &error_summary {
            result["error"] = json!(summary);
        }
    }
    if let Some(summary) = &error_summary {
        result["error_summary"] = json!(summary);
    }
    if let Some(kind) = error_kind {
        result["error_kind"] = json!(kind);
    }
    Ok(result)
}

#[cfg(test)]
mod tests {
    use crate::ida::handlers::script::{classify_python_error, last_non_empty_line};

    #[test]
    fn classifies_common_python_errors() {
        assert_eq!(
            classify_python_error("Traceback\nSyntaxError: invalid syntax"),
            Some("SyntaxError")
        );
        assert_eq!(
            classify_python_error("NameError: name 'foo' is not defined"),
            Some("NameError")
        );
        assert_eq!(
            classify_python_error("ModuleNotFoundError: No module named ida_bytes"),
            Some("ImportError")
        );
    }

    #[test]
    fn finds_last_non_empty_line() {
        assert_eq!(last_non_empty_line("a\n\nb  \n"), Some("b"));
        assert_eq!(last_non_empty_line(" \n\t\n"), None);
    }
}

```

`src/ida/handlers/search.rs`:

```rs
//! Search handlers.

use crate::disasm::generate_disasm_line;
use crate::error::ToolError;
use crate::ida::handlers::parse_pattern;
use idalib::IDB;
use serde_json::{json, Value};

fn strip_comment(line: &str) -> &str {
    line.split(';').next().unwrap_or(line)
}

fn split_disasm_line(line: &str) -> (String, String, String) {
    let trimmed = strip_comment(line).trim();
    if trimmed.is_empty() {
        return (String::new(), String::new(), String::new());
    }
    let mut parts = trimmed.splitn(2, |c: char| c.is_whitespace());
    let mnemonic = parts.next().unwrap_or("").trim().to_string();
    let operands = parts.next().unwrap_or("").trim().to_string();
    (mnemonic, operands, trimmed.to_string())
}

fn next_addr(db: &IDB, current: u64) -> Option<u64> {
    if let Some(insn) = db.insn_at(current) {
        let len = insn.len() as u64;
        if len == 0 {
            return None;
        }
        return Some(current.saturating_add(len));
    }
    db.next_head(current).filter(|next| *next > current)
}

fn matches_pattern(haystack: &str, pattern: &str, case_insensitive: bool) -> bool {
    if case_insensitive {
        haystack
            .to_ascii_lowercase()
            .contains(&pattern.to_ascii_lowercase())
    } else {
        haystack.contains(pattern)
    }
}

pub fn handle_find_bytes(
    idb: &Option<IDB>,
    pattern: &str,
    max_results: usize,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let pat = parse_pattern(pattern)?;
    if pat.is_empty() {
        return Err(ToolError::IdaError("empty pattern".to_string()));
    }

    let mut matches = Vec::new();
    let pat_len = pat.len();
    let chunk_size: usize = 1024 * 1024;

    for (_id, seg) in db.segments() {
        let seg_start = seg.start_address();
        let seg_len = seg.len();
        let mut offset = 0usize;

        while offset < seg_len && matches.len() < max_results {
            let remaining = seg_len - offset;
            let read_len = remaining.min(chunk_size + pat_len.saturating_sub(1));
            let bytes = db.get_bytes(seg_start + offset as u64, read_len);
            if bytes.len() < pat_len {
                break;
            }

            for i in 0..=bytes.len() - pat_len {
                if matches.len() >= max_results {
                    break;
                }
                let mut ok = true;
                for (j, pb) in pat.iter().enumerate() {
                    if let Some(b) = pb {
                        if bytes[i + j] != *b {
                            ok = false;
                            break;
                        }
                    }
                }
                if ok {
                    matches.push(format!("{:#x}", seg_start + offset as u64 + i as u64));
                }
            }

            if remaining <= chunk_size {
                break;
            }
            offset += chunk_size;
        }

        if matches.len() >= max_results {
            break;
        }
    }

    Ok(json!({
        "pattern": pattern,
        "matches": matches,
        "count": matches.len()
    }))
}

pub fn handle_search_text(
    idb: &Option<IDB>,
    text: &str,
    max_results: usize,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let mut matches = Vec::new();
    for addr in db.find_text_iter(text) {
        matches.push(format!("{:#x}", addr));
        if matches.len() >= max_results {
            break;
        }
    }
    Ok(json!({ "matches": matches, "count": matches.len() }))
}

pub fn handle_search_imm(
    idb: &Option<IDB>,
    imm: u64,
    max_results: usize,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let imm32 = imm as u32;
    let mut matches = Vec::new();
    for addr in db.find_imm_iter(imm32) {
        matches.push(format!("{:#x}", addr));
        if matches.len() >= max_results {
            break;
        }
    }
    Ok(json!({ "matches": matches, "count": matches.len() }))
}

pub fn handle_find_insns(
    idb: &Option<IDB>,
    patterns: &[String],
    max_results: usize,
    case_insensitive: bool,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    if patterns.is_empty() {
        return Err(ToolError::InvalidParams("empty patterns".to_string()));
    }

    let patterns_norm: Vec<String> = if case_insensitive {
        patterns.iter().map(|p| p.to_ascii_lowercase()).collect()
    } else {
        patterns.to_vec()
    };
    let mut matches = Vec::new();

    for (_id, seg) in db.segments() {
        let seg_end = seg.end_address();
        let mut addr = seg.start_address();

        while addr < seg_end && matches.len() < max_results {
            if let Some(line) = generate_disasm_line(db, addr) {
                let (mnemonic, _operands, clean_line) = split_disasm_line(&line);
                if !mnemonic.is_empty() {
                    let mnemonic_cmp = if case_insensitive {
                        mnemonic.to_ascii_lowercase()
                    } else {
                        mnemonic.clone()
                    };
                    let line_cmp = if case_insensitive {
                        clean_line.to_ascii_lowercase()
                    } else {
                        clean_line.clone()
                    };
                    let first_pat = &patterns_norm[0];
                    let first_match = if first_pat.contains(' ') || first_pat.contains(',') {
                        line_cmp.contains(first_pat)
                    } else {
                        mnemonic_cmp.contains(first_pat)
                    };

                    if first_match {
                        if patterns_norm.len() == 1 {
                            matches.push(json!({
                                "address": format!("{:#x}", addr),
                                "mnemonic": mnemonic,
                                "line": clean_line
                            }));
                        } else {
                            let mut seq_addrs = vec![addr];
                            let mut current = addr;
                            let mut ok = true;
                            for pat in patterns_norm.iter().skip(1) {
                                let next = match next_addr(db, current) {
                                    Some(next) if next < seg_end => next,
                                    _ => {
                                        ok = false;
                                        break;
                                    }
                                };
                                let next_line = match generate_disasm_line(db, next) {
                                    Some(line) => line,
                                    None => {
                                        ok = false;
                                        break;
                                    }
                                };
                                let (next_mnemonic, _next_operands, next_clean) =
                                    split_disasm_line(&next_line);
                                if next_mnemonic.is_empty() {
                                    ok = false;
                                    break;
                                }
                                let next_mnemonic_cmp = if case_insensitive {
                                    next_mnemonic.to_ascii_lowercase()
                                } else {
                                    next_mnemonic.clone()
                                };
                                let next_line_cmp = if case_insensitive {
                                    next_clean.to_ascii_lowercase()
                                } else {
                                    next_clean.clone()
                                };
                                let pat_match = if pat.contains(' ') || pat.contains(',') {
                                    next_line_cmp.contains(pat)
                                } else {
                                    next_mnemonic_cmp.contains(pat)
                                };
                                if !pat_match {
                                    ok = false;
                                    break;
                                }
                                seq_addrs.push(next);
                                current = next;
                            }
                            if ok {
                                matches.push(json!({
                                    "address": format!("{:#x}", addr),
                                    "mnemonic": mnemonic,
                                    "line": clean_line,
                                    "sequence": seq_addrs.iter().map(|a| format!("{:#x}", a)).collect::<Vec<_>>()
                                }));
                            }
                        }
                    }
                }
            }

            match next_addr(db, addr) {
                Some(next) if next > addr => addr = next,
                _ => break,
            }
        }

        if matches.len() >= max_results {
            break;
        }
    }

    Ok(json!({
        "patterns": patterns,
        "case_insensitive": case_insensitive,
        "matches": matches,
        "count": matches.len()
    }))
}

pub fn handle_find_insn_operands(
    idb: &Option<IDB>,
    patterns: &[String],
    max_results: usize,
    case_insensitive: bool,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    if patterns.is_empty() {
        return Err(ToolError::InvalidParams("empty patterns".to_string()));
    }

    let patterns_norm: Vec<String> = if case_insensitive {
        patterns.iter().map(|p| p.to_ascii_lowercase()).collect()
    } else {
        patterns.to_vec()
    };
    let mut matches = Vec::new();

    for (_id, seg) in db.segments() {
        let seg_end = seg.end_address();
        let mut addr = seg.start_address();

        while addr < seg_end && matches.len() < max_results {
            if let Some(line) = generate_disasm_line(db, addr) {
                let (mnemonic, operands, clean_line) = split_disasm_line(&line);
                if !mnemonic.is_empty() {
                    let operands_cmp = if case_insensitive {
                        operands.to_ascii_lowercase()
                    } else {
                        operands.clone()
                    };
                    if patterns_norm
                        .iter()
                        .any(|pat| matches_pattern(&operands_cmp, pat, false))
                    {
                        matches.push(json!({
                            "address": format!("{:#x}", addr),
                            "mnemonic": mnemonic,
                            "operands": operands,
                            "line": clean_line
                        }));
                    }
                }
            }

            match next_addr(db, addr) {
                Some(next) if next > addr => addr = next,
                _ => break,
            }
        }

        if matches.len() >= max_results {
            break;
        }
    }

    Ok(json!({
        "patterns": patterns,
        "case_insensitive": case_insensitive,
        "matches": matches,
        "count": matches.len()
    }))
}

```

`src/ida/handlers/segments.rs`:

```rs
//! Segment-related handlers.

use crate::error::ToolError;
use crate::ida::types::SegmentInfo;
use idalib::IDB;

pub fn handle_segments(idb: &Option<IDB>) -> Result<Vec<SegmentInfo>, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let mut segments = Vec::new();
    for (_id, seg) in db.segments() {
        let perms = seg.permissions();
        let perm_str = format!(
            "{}{}{}",
            if perms.is_readable() { "r" } else { "-" },
            if perms.is_writable() { "w" } else { "-" },
            if perms.is_executable() { "x" } else { "-" }
        );

        segments.push(SegmentInfo {
            name: seg.name().unwrap_or_default(),
            start: format!("{:#x}", seg.start_address()),
            end: format!("{:#x}", seg.end_address()),
            size: seg.len(),
            permissions: perm_str,
            r#type: format!("{:?}", seg.r#type()),
            bitness: seg.bitness() as u32,
        });
    }

    Ok(segments)
}

```

`src/ida/handlers/strings.rs`:

```rs
//! String-related handlers.

use crate::error::ToolError;
use crate::ida::handlers::hex_encode;
use crate::ida::types::{StringInfo, StringListResult, StringXrefInfo, StringXrefsResult};
use idalib::xref::XRefQuery;
use idalib::IDB;
use serde_json::{json, Value};

pub fn handle_strings(
    idb: &Option<IDB>,
    offset: usize,
    limit: usize,
    filter: Option<&str>,
) -> Result<StringListResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let string_list = db.strings();
    let filter_lower = filter.map(|f| f.to_lowercase());
    let mut total = 0usize;
    let mut strings = Vec::new();

    for (addr, content) in string_list.iter() {
        // Apply filter if provided
        if let Some(f) = &filter_lower {
            if !content.to_lowercase().contains(f) {
                continue;
            }
        }

        total += 1;
        if total <= offset {
            continue;
        }
        if strings.len() >= limit {
            continue;
        }

        strings.push(StringInfo {
            address: format!("{:#x}", addr),
            content: content.clone(),
            length: content.len(),
        });
    }

    let next_offset = if offset.saturating_add(strings.len()) < total {
        Some(offset.saturating_add(strings.len()))
    } else {
        None
    };

    Ok(StringListResult {
        strings,
        total,
        next_offset,
    })
}

pub fn handle_analyze_strings(
    idb: &Option<IDB>,
    query: Option<&str>,
    offset: usize,
    limit: usize,
) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let filter_lower = query.map(|q| q.to_lowercase());

    let string_list = db.strings();
    let mut total = 0usize;
    let mut results = Vec::new();

    for (addr, content) in string_list.iter() {
        if let Some(f) = &filter_lower {
            if !content.to_lowercase().contains(f) {
                continue;
            }
        }

        total += 1;
        if total <= offset {
            continue;
        }
        if results.len() >= limit {
            continue;
        }

        let mut xrefs = Vec::new();
        let mut current = db.first_xref_to(addr, XRefQuery::ALL);
        while let Some(xref) = current {
            xrefs.push(format!("{:#x}", xref.from()));
            if xrefs.len() >= 64 {
                break;
            }
            current = xref.next_to();
        }

        results.push(json!({
            "address": format!("{:#x}", addr),
            "content": content,
            "length": content.len(),
            "xrefs": xrefs,
            "xref_count": xrefs.len(),
        }));
    }

    let next_offset = if offset.saturating_add(results.len()) < total {
        Some(offset.saturating_add(results.len()))
    } else {
        None
    };

    Ok(json!({
        "strings": results,
        "total": total,
        "next_offset": next_offset
    }))
}

pub fn handle_get_string(idb: &Option<IDB>, addr: u64, max_len: usize) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let max_len = max_len.min(0x10000);
    let bytes = db.get_bytes(addr, max_len);
    let len = bytes.iter().position(|b| *b == 0).unwrap_or(bytes.len());
    let s = String::from_utf8_lossy(&bytes[..len]).into_owned();

    Ok(json!({
        "address": format!("{:#x}", addr),
        "string": s,
        "length": len,
        "bytes": hex_encode(&bytes[..len]),
    }))
}

pub fn handle_find_string(
    idb: &Option<IDB>,
    query: &str,
    exact: bool,
    case_insensitive: bool,
    offset: usize,
    limit: usize,
) -> Result<StringListResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let query_norm = if case_insensitive {
        query.to_lowercase()
    } else {
        query.to_string()
    };

    let mut total = 0usize;
    let mut strings = Vec::new();

    for (addr, content) in db.strings().iter() {
        let hay = if case_insensitive {
            content.to_lowercase()
        } else {
            content.clone()
        };
        let matched = if exact {
            hay == query_norm
        } else {
            hay.contains(&query_norm)
        };
        if !matched {
            continue;
        }

        total += 1;
        if total <= offset {
            continue;
        }
        if strings.len() >= limit {
            continue;
        }

        strings.push(StringInfo {
            address: format!("{:#x}", addr),
            content: content.clone(),
            length: content.len(),
        });
    }

    let next_offset = if offset.saturating_add(strings.len()) < total {
        Some(offset.saturating_add(strings.len()))
    } else {
        None
    };

    Ok(StringListResult {
        strings,
        total,
        next_offset,
    })
}

pub fn handle_xrefs_to_string(
    idb: &Option<IDB>,
    query: &str,
    exact: bool,
    case_insensitive: bool,
    offset: usize,
    limit: usize,
    max_xrefs: usize,
) -> Result<StringXrefsResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let query_norm = if case_insensitive {
        query.to_lowercase()
    } else {
        query.to_string()
    };

    let mut total = 0usize;
    let mut strings = Vec::new();
    let max_xrefs = max_xrefs.clamp(1, 1024);

    for (addr, content) in db.strings().iter() {
        let hay = if case_insensitive {
            content.to_lowercase()
        } else {
            content.clone()
        };
        let matched = if exact {
            hay == query_norm
        } else {
            hay.contains(&query_norm)
        };
        if !matched {
            continue;
        }

        total += 1;
        if total <= offset {
            continue;
        }
        if strings.len() >= limit {
            continue;
        }

        let mut xrefs = Vec::new();
        let mut current = db.first_xref_to(addr, XRefQuery::ALL);
        while let Some(xref) = current {
            xrefs.push(format!("{:#x}", xref.from()));
            if xrefs.len() >= max_xrefs {
                break;
            }
            current = xref.next_to();
        }

        let xref_count = xrefs.len();
        strings.push(StringXrefInfo {
            address: format!("{:#x}", addr),
            content: content.clone(),
            length: content.len(),
            xrefs,
            xref_count,
        });
    }

    let next_offset = if offset.saturating_add(strings.len()) < total {
        Some(offset.saturating_add(strings.len()))
    } else {
        None
    };

    Ok(StringXrefsResult {
        strings,
        total,
        next_offset,
    })
}

```

`src/ida/handlers/structs.rs`:

```rs
//! Struct/UDT handlers.

use crate::error::ToolError;
use crate::ida::handlers::hex_encode;
use crate::ida::types::{
    StructInfo, StructListResult, StructMemberInfo, StructMemberValue, StructReadResult,
    StructSummary, XRefInfo, XrefsToFieldResult,
};
use idalib::xref::XRefQuery;
use idalib::IDB;

/// Find a struct by name in the database.
fn find_struct_by_name(db: &IDB, name: &str) -> Option<idalib::udt::UdtInfo> {
    let query = name.trim();
    let query_lower = query.to_lowercase();
    let mut fuzzy_match = None;
    let mut fuzzy_count = 0usize;
    let limit = db.udt_ordinal_limit();
    for ordinal in 1..limit {
        // Use match/continue to skip non-struct ordinals (typedefs, enums, deleted types)
        // The ? operator would cause early return on first None, breaking the search
        let info = match db.udt_info(ordinal) {
            Some(info) => info,
            None => continue,
        };
        let info_name = info.name.as_str();
        let normalized = info_name
            .strip_prefix("struct ")
            .or_else(|| info_name.strip_prefix("union "))
            .unwrap_or(info_name);
        let query_normalized = query
            .strip_prefix("struct ")
            .or_else(|| query.strip_prefix("union "))
            .unwrap_or(query);
        if info_name == query || normalized == query || normalized == query_normalized {
            return Some(info);
        }
        if info.name.to_lowercase().contains(&query_lower) {
            fuzzy_match = Some(info);
            fuzzy_count += 1;
        }
    }
    if fuzzy_count == 1 {
        fuzzy_match
    } else {
        None
    }
}

pub fn handle_structs(
    idb: &Option<IDB>,
    offset: usize,
    limit: usize,
    filter: Option<&str>,
) -> Result<StructListResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let filter_lower = filter.map(|f| f.to_lowercase());
    let mut total = 0usize;
    let mut structs = Vec::new();

    let ordinal_limit = db.udt_ordinal_limit();
    for ordinal in 1..ordinal_limit {
        let info = match db.udt_info(ordinal) {
            Some(info) => info,
            None => continue,
        };

        if let Some(f) = &filter_lower {
            if !info.name.to_lowercase().contains(f) {
                continue;
            }
        }

        total += 1;
        if total <= offset {
            continue;
        }
        if structs.len() >= limit {
            continue;
        }

        structs.push(StructSummary {
            ordinal: info.ordinal,
            name: info.name,
            size: info.size,
            is_union: info.is_union,
            member_count: info.member_count,
        });
    }

    let next_offset = if offset.saturating_add(structs.len()) < total {
        Some(offset.saturating_add(structs.len()))
    } else {
        None
    };

    Ok(StructListResult {
        structs,
        total,
        next_offset,
    })
}

pub fn handle_struct_info(
    idb: &Option<IDB>,
    ordinal: Option<u32>,
    name: Option<&str>,
) -> Result<StructInfo, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let info = match (ordinal, name) {
        (Some(ord), _) => db
            .udt_info(ord)
            .ok_or_else(|| ToolError::InvalidParams(format!("unknown struct ordinal: {ord}")))?,
        (None, Some(name)) => find_struct_by_name(db, name)
            .ok_or_else(|| ToolError::InvalidParams(format!("unknown struct name: {name}")))?,
        (None, None) => {
            return Err(ToolError::InvalidParams(
                "struct_info requires ordinal or name".to_string(),
            ))
        }
    };

    let mut members = Vec::new();
    for idx in 0..info.member_count {
        let member = match db.udt_member(info.ordinal, idx) {
            Some(member) => member,
            None => continue,
        };
        let offset = member.offset_bits / 8;
        let size = member.size_bits.div_ceil(8);
        members.push(StructMemberInfo {
            name: member.name,
            type_name: member.type_name,
            offset_bits: member.offset_bits,
            size_bits: member.size_bits,
            offset,
            size,
            is_bitfield: member.is_bitfield,
        });
    }

    Ok(StructInfo {
        ordinal: info.ordinal,
        name: info.name,
        size: info.size,
        is_union: info.is_union,
        member_count: info.member_count,
        members,
    })
}

pub fn handle_read_struct(
    idb: &Option<IDB>,
    addr: u64,
    ordinal: Option<u32>,
    name: Option<&str>,
) -> Result<StructReadResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let info = match (ordinal, name) {
        (Some(ord), _) => db
            .udt_info(ord)
            .ok_or_else(|| ToolError::InvalidParams(format!("unknown struct ordinal: {ord}")))?,
        (None, Some(name)) => find_struct_by_name(db, name)
            .ok_or_else(|| ToolError::InvalidParams(format!("unknown struct name: {name}")))?,
        (None, None) => {
            return Err(ToolError::InvalidParams(
                "read_struct requires ordinal or name".to_string(),
            ))
        }
    };

    let mut members = Vec::new();
    for idx in 0..info.member_count {
        let member = match db.udt_member(info.ordinal, idx) {
            Some(member) => member,
            None => continue,
        };
        let offset = member.offset_bits / 8;
        let size = member.size_bits.div_ceil(8);
        let read_len = usize::try_from(size).unwrap_or(0).min(0x10000);
        let bytes = if read_len == 0 {
            String::new()
        } else {
            hex_encode(&db.get_bytes(addr.saturating_add(offset), read_len))
        };

        members.push(StructMemberValue {
            name: member.name,
            type_name: member.type_name,
            offset_bits: member.offset_bits,
            size_bits: member.size_bits,
            offset,
            size,
            is_bitfield: member.is_bitfield,
            bytes,
        });
    }

    Ok(StructReadResult {
        address: format!("{:#x}", addr),
        ordinal: info.ordinal,
        name: info.name,
        size: info.size,
        members,
    })
}

pub fn handle_xrefs_to_field(
    idb: &Option<IDB>,
    ordinal: Option<u32>,
    name: Option<&str>,
    member_index: Option<u32>,
    member_name: Option<&str>,
    limit: usize,
) -> Result<XrefsToFieldResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let info = match (ordinal, name) {
        (Some(ord), _) => db
            .udt_info(ord)
            .ok_or_else(|| ToolError::InvalidParams(format!("unknown struct ordinal: {ord}")))?,
        (None, Some(name)) => find_struct_by_name(db, name)
            .ok_or_else(|| ToolError::InvalidParams(format!("unknown struct name: {name}")))?,
        (None, None) => {
            return Err(ToolError::InvalidParams(
                "xrefs_to_field requires struct ordinal or name".to_string(),
            ))
        }
    };

    let member_idx = match (member_index, member_name) {
        (Some(idx), _) => idx,
        (None, Some(name)) => {
            let mut found = None;
            for idx in 0..info.member_count {
                if let Some(member) = db.udt_member(info.ordinal, idx) {
                    if member.name == name {
                        found = Some(idx);
                        break;
                    }
                }
            }
            found.ok_or_else(|| {
                ToolError::InvalidParams(format!(
                    "unknown struct member name: {name} in {}",
                    info.name
                ))
            })?
        }
        (None, None) => {
            return Err(ToolError::InvalidParams(
                "xrefs_to_field requires member index or name".to_string(),
            ))
        }
    };

    if member_idx >= info.member_count {
        return Err(ToolError::InvalidParams(format!(
            "member index out of range: {member_idx} (member_count={})",
            info.member_count
        )));
    }

    let member = db
        .udt_member(info.ordinal, member_idx)
        .ok_or_else(|| ToolError::InvalidParams("failed to load struct member".to_string()))?;

    let tid = db
        .udt_member_tid(info.ordinal, member_idx)
        .ok_or_else(|| ToolError::InvalidParams("struct member has no TID".to_string()))?;

    let mut xrefs = Vec::new();
    let mut current = db.first_xref_to(tid, XRefQuery::TID);
    let mut truncated = false;
    while let Some(xref) = current {
        if xrefs.len() >= limit {
            truncated = true;
            break;
        }
        xrefs.push(XRefInfo {
            from: format!("{:#x}", xref.from()),
            to: format!("{:#x}", xref.to()),
            r#type: format!("{:?}", xref.type_()),
            is_code: xref.is_code(),
        });
        current = xref.next_to();
    }

    Ok(XrefsToFieldResult {
        struct_ordinal: info.ordinal,
        struct_name: info.name,
        member_index: member_idx,
        member_name: member.name,
        member_type: member.type_name,
        member_offset_bits: member.offset_bits,
        member_size_bits: member.size_bits,
        tid: format!("{:#x}", tid),
        xrefs,
        truncated,
    })
}

```

`src/ida/handlers/types.rs`:

```rs
//! Type handlers (local types).

use crate::error::ToolError;
use crate::ida::handlers::resolve_address;
use crate::ida::types::{
    ApplyTypeResult, DeclareTypeResult, DeclareTypesResult, FrameInfo, FrameMemberInfo, FrameRange,
    GuessTypeResult, LocalTypeInfo, LocalTypeListResult, StackVarResult,
};
use idalib::IDB;

pub fn handle_local_types(
    idb: &Option<IDB>,
    offset: usize,
    limit: usize,
    filter: Option<&str>,
) -> Result<LocalTypeListResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let filter_lower = filter.map(|f| f.to_lowercase());
    let mut total = 0usize;
    let mut types = Vec::new();

    let ordinal_limit = db.udt_ordinal_limit();
    for ordinal in 1..ordinal_limit {
        let info = match db.local_type_info(ordinal) {
            Some(info) => info,
            None => continue,
        };

        if let Some(f) = &filter_lower {
            if !info.name.to_lowercase().contains(f) {
                continue;
            }
        }

        total += 1;
        if total <= offset {
            continue;
        }
        if types.len() >= limit {
            continue;
        }

        types.push(LocalTypeInfo {
            ordinal: info.ordinal,
            name: info.name,
            decl: info.decl,
            kind: info.kind,
        });
    }

    let next_offset = if offset.saturating_add(types.len()) < total {
        Some(offset.saturating_add(types.len()))
    } else {
        None
    };

    Ok(LocalTypeListResult {
        types,
        total,
        next_offset,
    })
}

pub fn handle_stack_frame(idb: &Option<IDB>, addr: u64) -> Result<FrameInfo, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let info = db
        .frame_info(addr)
        .ok_or(ToolError::FunctionNotFound(addr))?;

    let mut members = Vec::new();
    for idx in 0..info.member_count {
        let member = match db.frame_member(addr, idx) {
            Some(member) => member,
            None => continue,
        };
        let offset = member.offset_bits / 8;
        let size = member.size_bits.div_ceil(8);
        members.push(FrameMemberInfo {
            name: member.name,
            type_name: member.type_name,
            offset_bits: member.offset_bits,
            size_bits: member.size_bits,
            offset,
            size,
            is_bitfield: member.is_bitfield,
            part: member.part,
        });
    }

    Ok(FrameInfo {
        address: format!("{:#x}", addr),
        frame_size: info.frame_size,
        ret_size: info.ret_size,
        frsize: info.frsize,
        frregs: info.frregs,
        argsize: info.argsize,
        fpd: info.fpd,
        args_range: FrameRange {
            start: format!("{:#x}", info.args_start),
            end: format!("{:#x}", info.args_end),
        },
        retaddr_range: FrameRange {
            start: format!("{:#x}", info.retaddr_start),
            end: format!("{:#x}", info.retaddr_end),
        },
        savregs_range: FrameRange {
            start: format!("{:#x}", info.savregs_start),
            end: format!("{:#x}", info.savregs_end),
        },
        locals_range: FrameRange {
            start: format!("{:#x}", info.locals_start),
            end: format!("{:#x}", info.locals_end),
        },
        member_count: info.member_count,
        members,
    })
}

pub fn handle_declare_type(
    idb: &Option<IDB>,
    decl: &str,
    relaxed: bool,
    replace: bool,
    multi: bool,
) -> Result<serde_json::Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    if multi {
        let errors = db.declare_types(decl, relaxed);
        return Ok(serde_json::to_value(DeclareTypesResult { errors })
            .unwrap_or_else(|_| serde_json::json!({ "errors": errors })));
    }

    let result = db.declare_type(decl, relaxed, replace);
    Ok(serde_json::to_value(DeclareTypeResult {
        code: result.code,
        name: result.name,
        decl: result.decl,
        kind: result.kind,
        replaced: replace,
    })
    .unwrap_or_else(|_| serde_json::json!({ "code": result.code })))
}

#[allow(clippy::too_many_arguments)]
pub fn handle_apply_types(
    idb: &Option<IDB>,
    addr: Option<u64>,
    name: Option<&str>,
    offset: u64,
    stack_offset: Option<i64>,
    stack_name: Option<&str>,
    decl: Option<&str>,
    type_name: Option<&str>,
    relaxed: bool,
    delay: bool,
    strict: bool,
) -> Result<serde_json::Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    if stack_offset.is_some() || stack_name.is_some() {
        let func_addr = resolve_address(idb, addr, name, offset)?;
        let decl = decl.ok_or_else(|| {
            ToolError::InvalidParams("apply_types for stack var requires decl".to_string())
        })?;
        let use_offset = stack_offset.is_some();
        let stack_off = stack_offset.unwrap_or(0);
        let result = db.set_stack_var_type(
            func_addr, stack_name, stack_off, use_offset, decl, relaxed, strict,
        );
        let status = if result.code == 0 { "ok" } else { "error" };
        let out = StackVarResult {
            function: format!("{:#x}", func_addr),
            name: result.name,
            offset: result.offset,
            code: result.code,
            status: status.to_string(),
        };
        return Ok(serde_json::to_value(out)
            .unwrap_or_else(|_| serde_json::json!({ "code": result.code })));
    }

    let address = resolve_address(idb, addr, name, offset)?;
    let (applied, source) = if let Some(decl) = decl {
        (
            db.apply_decl_type(address, decl, relaxed, delay, strict),
            "decl",
        )
    } else if let Some(type_name) = type_name {
        (db.apply_named_type(address, type_name), "named")
    } else {
        return Err(ToolError::InvalidParams(
            "apply_types requires decl or type_name".to_string(),
        ));
    };

    Ok(serde_json::to_value(ApplyTypeResult {
        address: format!("{:#x}", address),
        applied,
        source: source.to_string(),
    })
    .unwrap_or_else(|_| serde_json::json!({ "applied": applied })))
}

pub fn handle_infer_types(
    idb: &Option<IDB>,
    addr: Option<u64>,
    name: Option<&str>,
    offset: u64,
) -> Result<GuessTypeResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let address = resolve_address(idb, addr, name, offset)?;
    let guessed = db.guess_type(address);
    let status = match guessed.code {
        0 => "failed",
        1 => "trivial",
        2 => "ok",
        _ => "unknown",
    };
    Ok(GuessTypeResult {
        address: format!("{:#x}", address),
        code: guessed.code,
        status: status.to_string(),
        decl: guessed.decl,
        kind: guessed.kind,
    })
}

pub fn handle_declare_stack(
    idb: &Option<IDB>,
    addr: Option<u64>,
    name: Option<&str>,
    offset: i64,
    var_name: Option<&str>,
    decl: &str,
    relaxed: bool,
) -> Result<StackVarResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let func_addr = resolve_address(idb, addr, name, 0)?;
    let result = db.define_stack_var(func_addr, var_name, offset, decl, relaxed);
    let status = if result.code == 0 { "ok" } else { "error" };
    Ok(StackVarResult {
        function: format!("{:#x}", func_addr),
        name: result.name,
        offset: result.offset,
        code: result.code,
        status: status.to_string(),
    })
}

pub fn handle_delete_stack(
    idb: &Option<IDB>,
    addr: Option<u64>,
    name: Option<&str>,
    offset: Option<i64>,
    var_name: Option<&str>,
) -> Result<StackVarResult, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    if offset.is_none() && var_name.is_none() {
        return Err(ToolError::InvalidParams(
            "delete_stack requires offset or name".to_string(),
        ));
    }
    let func_addr = resolve_address(idb, addr, name, 0)?;
    let use_offset = offset.is_some();
    let off = offset.unwrap_or(0);
    let result = db.delete_stack_var(func_addr, var_name, off, use_offset);
    let status = if result.code == 0 { "ok" } else { "error" };
    Ok(StackVarResult {
        function: format!("{:#x}", func_addr),
        name: result.name,
        offset: result.offset,
        code: result.code,
        status: status.to_string(),
    })
}

```

`src/ida/handlers/xrefs.rs`:

```rs
//! Cross-reference handlers.

use crate::error::ToolError;
use crate::ida::types::XRefInfo;
use idalib::xref::XRefQuery;
use idalib::IDB;
use serde_json::{json, Value};
use std::collections::HashSet;

pub fn handle_xrefs_to(idb: &Option<IDB>, addr: u64) -> Result<Vec<XRefInfo>, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let mut xrefs = Vec::new();
    let mut current = db.first_xref_to(addr, XRefQuery::ALL);

    while let Some(xref) = current {
        xrefs.push(XRefInfo {
            from: format!("{:#x}", xref.from()),
            to: format!("{:#x}", xref.to()),
            r#type: format!("{:?}", xref.type_()),
            is_code: xref.is_code(),
        });
        current = xref.next_to();
    }

    Ok(xrefs)
}

pub fn handle_xrefs_from(idb: &Option<IDB>, addr: u64) -> Result<Vec<XRefInfo>, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;

    let mut xrefs = Vec::new();
    let mut current = db.first_xref_from(addr, XRefQuery::ALL);

    while let Some(xref) = current {
        xrefs.push(XRefInfo {
            from: format!("{:#x}", xref.from()),
            to: format!("{:#x}", xref.to()),
            r#type: format!("{:?}", xref.type_()),
            is_code: xref.is_code(),
        });
        current = xref.next_from();
    }

    Ok(xrefs)
}

pub fn handle_xref_matrix(idb: &Option<IDB>, addrs: &[u64]) -> Result<Value, ToolError> {
    let db = idb.as_ref().ok_or(ToolError::NoDatabaseOpen)?;
    let mut xref_map: std::collections::HashMap<u64, HashSet<u64>> =
        std::collections::HashMap::new();

    for &addr in addrs {
        let mut set = HashSet::new();
        let mut current = db.first_xref_from(addr, XRefQuery::ALL);
        while let Some(xref) = current {
            set.insert(xref.to());
            current = xref.next_from();
        }
        xref_map.insert(addr, set);
    }

    let matrix: Vec<Vec<bool>> = addrs
        .iter()
        .map(|from| {
            addrs
                .iter()
                .map(|to| xref_map.get(from).map(|s| s.contains(to)).unwrap_or(false))
                .collect()
        })
        .collect();

    Ok(json!({
        "addrs": addrs.iter().map(|a| format!("{:#x}", a)).collect::<Vec<_>>(),
        "matrix": matrix
    }))
}

```

`src/ida/lock.rs`:

```rs
//! MCP lock file helpers to prevent concurrent database access.

use crate::error::ToolError;
use idalib::IDAError;
use std::fs::{File, OpenOptions};
use std::io::{BufRead, BufReader, Seek, Write};
use std::path::{Path, PathBuf};
use tracing::{info, warn};

/// Lock file for an open IDA database to prevent concurrent access.
pub(crate) struct McpLock {
    file: File,
    path: PathBuf,
    /// Set to true when ownership is transferred to caller, preventing Drop cleanup
    transferred: bool,
}

impl McpLock {
    /// Transfer ownership of the lock file and path to the caller.
    /// After this call, Drop will not clean up the lock file.
    pub fn into_parts(mut self) -> (File, PathBuf) {
        self.transferred = true;
        // Use ManuallyDrop to prevent Drop from running, then extract fields
        let this = std::mem::ManuallyDrop::new(self);
        // SAFETY: We set transferred=true above, so Drop won't do cleanup.
        // We're extracting fields from ManuallyDrop which won't run Drop.
        // Each field is read exactly once and we never access `this` again.
        let file = unsafe { std::ptr::read(&this.file) };
        let path = unsafe { std::ptr::read(&this.path) };
        (file, path)
    }
}

impl Drop for McpLock {
    fn drop(&mut self) {
        if !self.transferred {
            // Lock was not transferred to caller (e.g., panic occurred) - clean up
            let _ = std::fs::remove_file(&self.path);
        }
    }
}

/// Acquire an MCP lock file for the given database path.
pub(crate) fn acquire_mcp_lock(db_path: &Path) -> Result<McpLock, ToolError> {
    let mut lock_path = db_path.to_path_buf();
    lock_path.set_extension("imcp");

    let mut file = OpenOptions::new()
        .read(true)
        .write(true)
        .create(true)
        .truncate(true)
        .open(&lock_path)
        .map_err(|e| ToolError::OpenFailed(format!("{}: {}", lock_path.display(), e)))?;

    if let Err(pid) = try_lock_file(&file) {
        let mut msg = format!("{}", lock_path.display());
        if pid > 0 {
            msg = format!("{} (locked by pid {})", lock_path.display(), pid);
        }
        return Err(ToolError::DatabaseLocked(msg));
    }

    let pid = std::process::id();
    let exe = std::env::current_exe()
        .ok()
        .map(|p| p.display().to_string())
        .unwrap_or_else(|| "unknown".to_string());
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map(|d| d.as_secs())
        .unwrap_or(0);
    let host = std::env::var("HOSTNAME")
        .or_else(|_| std::env::var("HOST"))
        .unwrap_or_else(|_| "unknown".to_string());

    let info = format!(
        "pid={}\nhost={}\nexe={}\nopened_at={}\n",
        pid, host, exe, now
    );
    let _ = file.set_len(0);
    let _ = file.seek(std::io::SeekFrom::Start(0));
    let _ = file.write_all(info.as_bytes());
    let _ = file.flush();

    Ok(McpLock {
        file,
        path: lock_path,
        transferred: false,
    })
}

/// Release an MCP lock using mutable references to the file and path options.
pub(crate) fn release_mcp_lock(lock_file: &mut Option<File>, lock_path: &mut Option<PathBuf>) {
    if let Some(path) = lock_path.take() {
        let _ = std::fs::remove_file(path);
    }
    *lock_file = None;
}

/// Release an MCP lock file directly.
pub(crate) fn release_mcp_lock_file(lock: McpLock) {
    let (_file, path) = lock.into_parts();
    let _ = std::fs::remove_file(path);
}

/// Information about a stale lock that was cleaned up.
#[derive(Debug)]
pub struct StaleLockInfo {
    pub path: PathBuf,
    pub pid: u32,
    pub reason: String,
}

/// Clean up stale MCP lock files for a database path.
/// Returns information about any stale locks that were removed.
pub(crate) fn clean_stale_mcp_lock(db_path: &Path) -> Option<StaleLockInfo> {
    let mut lock_path = db_path.to_path_buf();
    lock_path.set_extension("imcp");

    if !lock_path.exists() {
        return None;
    }

    // Try to read the lock file to get the PID
    let pid = match read_lock_file_pid(&lock_path) {
        Some(pid) => pid,
        None => {
            // Can't read PID, but file exists - try to acquire lock to check if stale
            if let Ok(file) = OpenOptions::new().read(true).write(true).open(&lock_path) {
                if try_lock_file(&file).is_ok() {
                    // We got the lock - file was stale (no process holding fcntl lock)
                    drop(file);
                    if std::fs::remove_file(&lock_path).is_ok() {
                        info!(path = %lock_path.display(), "Removed stale lock file (no valid PID, no fcntl lock)");
                        return Some(StaleLockInfo {
                            path: lock_path,
                            pid: 0,
                            reason: "no valid PID and no fcntl lock held".to_string(),
                        });
                    }
                }
            }
            return None;
        }
    };

    // Check if the process is still running
    if is_process_running(pid) {
        // Process is still alive - lock is valid
        return None;
    }

    // Process is dead - this is a stale lock
    info!(
        path = %lock_path.display(),
        pid = pid,
        "Found stale lock file from dead process"
    );

    // Remove the stale lock file
    if let Err(e) = std::fs::remove_file(&lock_path) {
        warn!(
            path = %lock_path.display(),
            error = %e,
            "Failed to remove stale lock file"
        );
        return None;
    }

    info!(path = %lock_path.display(), pid = pid, "Removed stale lock file");
    Some(StaleLockInfo {
        path: lock_path,
        pid,
        reason: format!("process {} is no longer running", pid),
    })
}

/// Read the PID from a lock file.
fn read_lock_file_pid(lock_path: &Path) -> Option<u32> {
    let file = File::open(lock_path).ok()?;
    let reader = BufReader::new(file);

    for line in reader.lines().map_while(Result::ok) {
        if let Some(pid_str) = line.strip_prefix("pid=") {
            return pid_str.trim().parse().ok();
        }
    }
    None
}

/// Check if a process with the given PID is still running.
#[cfg(unix)]
fn is_process_running(pid: u32) -> bool {
    // Send signal 0 to check if process exists
    // SAFETY: kill with signal 0 is safe - it doesn't actually send a signal,
    // just checks if the process exists and we have permission to signal it.
    let result = unsafe { libc::kill(pid as libc::pid_t, 0) };
    if result == 0 {
        return true;
    }
    // If kill returns -1, check errno
    // ESRCH means no such process
    // EPERM means process exists but we don't have permission (still running)
    let errno = std::io::Error::last_os_error().raw_os_error().unwrap_or(0);
    errno == libc::EPERM
}

#[cfg(not(unix))]
fn is_process_running(_pid: u32) -> bool {
    // On non-Unix platforms, assume process might be running
    // This is conservative - won't clean up locks that might be stale
    true
}

/// Detect if a database file is locked by another process.
/// Returns a descriptive message if locked, None otherwise.
pub(crate) fn detect_db_lock(path: &Path, _err: &IDAError) -> Option<String> {
    let mut candidates = Vec::new();
    candidates.push(path.to_path_buf());

    if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
        if ext == "i64" || ext == "idb" || ext == "id0" {
            if ext == "id0" {
                let mut i64_path = path.to_path_buf();
                i64_path.set_extension("i64");
                candidates.push(i64_path);
            }

            let mut id0 = path.to_path_buf();
            id0.set_extension("id0");
            candidates.push(id0);

            let mut id1 = path.to_path_buf();
            id1.set_extension("id1");
            candidates.push(id1);

            let mut nam = path.to_path_buf();
            nam.set_extension("nam");
            candidates.push(nam);
        }
    }

    let mut imcp = path.to_path_buf();
    imcp.set_extension("imcp");
    candidates.push(imcp);

    for candidate in candidates {
        if !candidate.exists() {
            continue;
        }
        if let Some(pid) = locked_by_pid(&candidate) {
            if pid == 0 {
                return Some(format!(
                    "{} (locked by another process)",
                    candidate.display()
                ));
            }
            return Some(format!("{} (locked by pid {})", candidate.display(), pid));
        }
    }

    None
}

// Platform-specific file locking implementation

#[cfg(unix)]
#[allow(clippy::unnecessary_cast)] // F_WRLCK is i32 on Linux, i16 on macOS
fn try_lock_file(file: &File) -> Result<(), u32> {
    use std::os::unix::io::AsRawFd;

    let mut fl = libc::flock {
        l_type: libc::F_WRLCK as i16,
        l_whence: libc::SEEK_SET as i16,
        l_start: 0,
        l_len: 0,
        l_pid: 0,
    };

    // SAFETY: `file` is a valid open File, so `as_raw_fd()` returns a valid descriptor.
    // `fl` is properly initialized per POSIX flock requirements. The descriptor remains
    // valid for the duration of this call since we hold a reference to `file`.
    let rc = unsafe { libc::fcntl(file.as_raw_fd(), libc::F_SETLK, &mut fl) };
    if rc == -1 {
        return Err(locked_by_pid_from_fd(file).unwrap_or(0));
    }
    Ok(())
}

#[cfg(not(unix))]
fn try_lock_file(_file: &File) -> Result<(), u32> {
    Ok(())
}

#[cfg(unix)]
#[allow(clippy::unnecessary_cast)] // F_WRLCK/F_UNLCK is i32 on Linux, i16 on macOS
fn locked_by_pid(path: &Path) -> Option<u32> {
    use std::os::unix::io::AsRawFd;

    let file = std::fs::OpenOptions::new()
        .read(true)
        .write(true)
        .open(path)
        .or_else(|_| std::fs::OpenOptions::new().read(true).open(path))
        .ok()?;

    let mut fl = libc::flock {
        l_type: libc::F_WRLCK as i16,
        l_whence: libc::SEEK_SET as i16,
        l_start: 0,
        l_len: 0,
        l_pid: 0,
    };

    // SAFETY: `file` is a valid open File, so `as_raw_fd()` returns a valid descriptor.
    // `fl` is properly initialized per POSIX flock requirements. The descriptor remains
    // valid for the duration of this call since we hold a reference to `file`.
    let rc = unsafe { libc::fcntl(file.as_raw_fd(), libc::F_GETLK, &mut fl) };
    if rc == -1 {
        return None;
    }
    if fl.l_type == libc::F_UNLCK as i16 {
        None
    } else {
        Some(fl.l_pid as u32)
    }
}

#[cfg(not(unix))]
fn locked_by_pid(_path: &Path) -> Option<u32> {
    None
}

#[cfg(unix)]
#[allow(clippy::unnecessary_cast)] // F_WRLCK/F_UNLCK is i32 on Linux, i16 on macOS
fn locked_by_pid_from_fd(file: &File) -> Option<u32> {
    use std::os::unix::io::AsRawFd;

    let mut fl = libc::flock {
        l_type: libc::F_WRLCK as i16,
        l_whence: libc::SEEK_SET as i16,
        l_start: 0,
        l_len: 0,
        l_pid: 0,
    };
    // SAFETY: `file` is a valid open File, so `as_raw_fd()` returns a valid descriptor.
    // `fl` is properly initialized per POSIX flock requirements. The descriptor remains
    // valid for the duration of this call since we hold a reference to `file`.
    let rc = unsafe { libc::fcntl(file.as_raw_fd(), libc::F_GETLK, &mut fl) };
    if rc == -1 {
        return None;
    }
    if fl.l_type == libc::F_UNLCK as i16 {
        None
    } else {
        Some(fl.l_pid as u32)
    }
}

```

`src/ida/loop_impl.rs`:

```rs
//! Main IDA worker loop.

use crate::ida::handlers::resolve_address;
use crate::ida::handlers::{
    address, analysis, annotations, controlflow, database, disasm, functions, globals, imports,
    memory, script, search, segments, strings, structs, types, xrefs,
};
use crate::ida::lock::release_mcp_lock;
use crate::ida::request::IdaRequest;
use idalib::IDB;
use std::fs::File;
use std::path::PathBuf;
use std::sync::mpsc;
use tracing::{debug, error, info, warn};

/// Log result with debug on success and warn on error.
macro_rules! log_result {
    ($result:expr, $ok_msg:literal, $err_msg:literal) => {
        match &$result {
            Ok(_) => debug!($ok_msg),
            Err(e) => warn!(error = %e, $err_msg),
        }
    };
}

/// Run the IDA worker loop on the current (main) thread.
/// This function blocks until Shutdown is received.
///
/// IDA library initialization is deferred until the first request
/// that needs it. This allows `open_dsc` to run `idat` without
/// license contention (idat needs its own license).
pub fn run_ida_loop(rx: mpsc::Receiver<IdaRequest>) {
    let mut idb: Option<IDB> = None;
    let mut lock_file: Option<File> = None;
    let mut lock_path: Option<PathBuf> = None;
    let mut lib_initialized = false;

    while let Ok(req) = rx.recv() {
        // Lazily initialize the IDA library on first use.
        // Must happen on the main thread (which this loop runs on).
        if !lib_initialized {
            info!("Initializing IDA library on main thread (deferred)");
            idalib::init_library();
            info!("IDA library initialized successfully");
            lib_initialized = true;
        }
        match req {
            IdaRequest::Open {
                path,
                load_debug_info,
                debug_info_path,
                debug_info_verbose,
                force,
                file_type,
                auto_analyse,
                extra_args,
                resp,
            } => {
                info!(path = %path, force, file_type = ?file_type, auto_analyse, "Opening database");
                let result = database::handle_open(
                    &mut idb,
                    &mut lock_file,
                    &mut lock_path,
                    &path,
                    load_debug_info,
                    debug_info_path.as_deref(),
                    debug_info_verbose,
                    force,
                    file_type.as_deref(),
                    auto_analyse,
                    &extra_args,
                );
                match &result {
                    Ok(info) => info!(
                        path = %info.path,
                        processor = %info.processor,
                        bits = info.bits,
                        functions = info.function_count,
                        "Database opened"
                    ),
                    Err(e) => error!(path = %path, error = %e, "Failed to open database"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::Close { resp } => {
                info!("Closing database");
                if let Some(ref db) = idb {
                    info!(path = %db.path().display(), "Dropping IDB (will call close_database_with(save))");
                }
                drop(idb.take());
                info!("IDB dropped, database should be packed");
                release_mcp_lock(&mut lock_file, &mut lock_path);
                let _ = resp.send(());
            }
            IdaRequest::LoadDebugInfo {
                path,
                verbose,
                resp,
            } => {
                debug!(path = ?path, verbose, "Loading debug info");
                let result = database::handle_load_debug_info(&idb, path.as_deref(), verbose);
                match &result {
                    Ok(v) => debug!(result = %v, "Loaded debug info"),
                    Err(e) => warn!(error = %e, "Failed to load debug info"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::AnalysisStatus { resp } => {
                debug!("Reporting analysis status");
                let result = analysis::handle_analysis_status(&idb);
                match &result {
                    Ok(status) => debug!(
                        auto_enabled = status.auto_enabled,
                        auto_is_ok = status.auto_is_ok,
                        auto_state = %status.auto_state,
                        "Analysis status reported"
                    ),
                    Err(e) => warn!(error = %e, "Failed to report analysis status"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::ListFunctions {
                offset,
                limit,
                filter,
                resp,
            } => {
                debug!(offset, limit, filter = ?filter, "Listing functions");
                let result =
                    functions::handle_list_functions(&idb, offset, limit, filter.as_deref());
                match &result {
                    Ok(r) => debug!(
                        count = r.functions.len(),
                        total = r.total,
                        "Listed functions"
                    ),
                    Err(e) => warn!(error = %e, "Failed to list functions"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::ResolveFunction { name, resp } => {
                debug!(name = %name, "Resolving function");
                let result = functions::handle_resolve_function(&idb, &name);
                match &result {
                    Ok(info) => {
                        debug!(name = %info.name, address = %info.address, "Resolved function")
                    }
                    Err(e) => warn!(name = %name, error = %e, "Failed to resolve function"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::DisasmByName { name, count, resp } => {
                debug!(name = %name, count, "Disassembling by name");
                let result = disasm::handle_disasm_by_name(&idb, &name, count);
                match &result {
                    Ok(text) => {
                        debug!(name = %name, lines = text.lines().count(), "Disassembly complete")
                    }
                    Err(e) => warn!(name = %name, error = %e, "Failed to disassemble"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::Disasm { addr, count, resp } => {
                debug!(address = format!("{:#x}", addr), count, "Disassembling");
                let result = disasm::handle_disasm(&idb, addr, count);
                match &result {
                    Ok(text) => debug!(lines = text.lines().count(), "Disassembly complete"),
                    Err(e) => {
                        warn!(address = format!("{:#x}", addr), error = %e, "Failed to disassemble")
                    }
                }
                let _ = resp.send(result);
            }
            IdaRequest::Decompile { addr, resp } => {
                debug!(address = format!("{:#x}", addr), "Decompiling");
                let result = disasm::handle_decompile(&idb, addr);
                match &result {
                    Ok(code) => debug!(lines = code.lines().count(), "Decompilation complete"),
                    Err(e) => {
                        warn!(address = format!("{:#x}", addr), error = %e, "Failed to decompile")
                    }
                }
                let _ = resp.send(result);
            }
            IdaRequest::Segments { resp } => {
                debug!("Listing segments");
                let result = segments::handle_segments(&idb);
                match &result {
                    Ok(segs) => debug!(count = segs.len(), "Listed segments"),
                    Err(e) => warn!(error = %e, "Failed to list segments"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::Strings {
                offset,
                limit,
                filter,
                resp,
            } => {
                debug!(offset, limit, filter = ?filter, "Listing strings");
                let result = strings::handle_strings(&idb, offset, limit, filter.as_deref());
                match &result {
                    Ok(r) => debug!(count = r.strings.len(), total = r.total, "Listed strings"),
                    Err(e) => warn!(error = %e, "Failed to list strings"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::LocalTypes {
                offset,
                limit,
                filter,
                resp,
            } => {
                debug!(offset, limit, filter = ?filter, "Listing local types");
                let result = types::handle_local_types(&idb, offset, limit, filter.as_deref());
                match &result {
                    Ok(r) => debug!(count = r.types.len(), total = r.total, "Listed local types"),
                    Err(e) => warn!(error = %e, "Failed to list local types"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::DeclareType {
                decl,
                relaxed,
                replace,
                multi,
                resp,
            } => {
                debug!(relaxed, replace, multi, "Declaring type");
                let result = types::handle_declare_type(&idb, &decl, relaxed, replace, multi);
                log_result!(result, "Declared type", "Failed to declare type");
                let _ = resp.send(result);
            }
            IdaRequest::ApplyTypes {
                addr,
                name,
                offset,
                stack_offset,
                stack_name,
                decl,
                type_name,
                relaxed,
                delay,
                strict,
                resp,
            } => {
                debug!(
                    address = ?addr,
                    name = ?name,
                    offset,
                    stack_offset = ?stack_offset,
                    stack_name = ?stack_name,
                    relaxed,
                    delay,
                    strict,
                    "Applying type"
                );
                let result = types::handle_apply_types(
                    &idb,
                    addr,
                    name.as_deref(),
                    offset,
                    stack_offset,
                    stack_name.as_deref(),
                    decl.as_deref(),
                    type_name.as_deref(),
                    relaxed,
                    delay,
                    strict,
                );
                log_result!(result, "Applied type", "Failed to apply type");
                let _ = resp.send(result);
            }
            IdaRequest::InferTypes {
                addr,
                name,
                offset,
                resp,
            } => {
                debug!(address = ?addr, name = ?name, offset, "Inferring type");
                let result = types::handle_infer_types(&idb, addr, name.as_deref(), offset);
                match &result {
                    Ok(res) => debug!(code = res.code, "Inferred type"),
                    Err(e) => warn!(error = %e, "Failed to infer type"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::AddrInfo {
                addr,
                name,
                offset,
                resp,
            } => {
                debug!(address = ?addr, name = ?name, offset, "Getting address info");
                let resolved = resolve_address(&idb, addr, name.as_deref(), offset);
                let result = resolved.and_then(|ea| address::handle_addr_info(&idb, ea));
                log_result!(result, "Got address info", "Failed to get address info");
                let _ = resp.send(result);
            }
            IdaRequest::FunctionAt {
                addr,
                name,
                offset,
                resp,
            } => {
                debug!(address = ?addr, name = ?name, offset, "Getting function at address");
                let resolved = resolve_address(&idb, addr, name.as_deref(), offset);
                let result = resolved.and_then(|ea| functions::handle_function_at(&idb, ea));
                log_result!(
                    result,
                    "Got function at address",
                    "Failed to get function at address"
                );
                let _ = resp.send(result);
            }
            IdaRequest::DisasmFunctionAt {
                addr,
                name,
                offset,
                count,
                resp,
            } => {
                debug!(
                    address = ?addr,
                    name = ?name,
                    offset,
                    count,
                    "Disassembling function at address"
                );
                let resolved = resolve_address(&idb, addr, name.as_deref(), offset);
                let result =
                    resolved.and_then(|ea| disasm::handle_disasm_function_at(&idb, ea, count));
                log_result!(
                    result,
                    "Disassembled function",
                    "Failed to disassemble function"
                );
                let _ = resp.send(result);
            }
            IdaRequest::DeclareStack {
                addr,
                name,
                offset,
                var_name,
                decl,
                relaxed,
                resp,
            } => {
                debug!(
                    address = ?addr,
                    name = ?name,
                    offset,
                    var_name = ?var_name,
                    relaxed,
                    "Declaring stack variable"
                );
                let result = types::handle_declare_stack(
                    &idb,
                    addr,
                    name.as_deref(),
                    offset,
                    var_name.as_deref(),
                    &decl,
                    relaxed,
                );
                match &result {
                    Ok(res) => debug!(code = res.code, "Declared stack variable"),
                    Err(e) => warn!(error = %e, "Failed to declare stack variable"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::DeleteStack {
                addr,
                name,
                offset,
                var_name,
                resp,
            } => {
                debug!(
                    address = ?addr,
                    name = ?name,
                    offset = ?offset,
                    var_name = ?var_name,
                    "Deleting stack variable"
                );
                let result = types::handle_delete_stack(
                    &idb,
                    addr,
                    name.as_deref(),
                    offset,
                    var_name.as_deref(),
                );
                match &result {
                    Ok(res) => debug!(code = res.code, "Deleted stack variable"),
                    Err(e) => warn!(error = %e, "Failed to delete stack variable"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::StackFrame { addr, resp } => {
                debug!(address = format!("{:#x}", addr), "Getting stack frame");
                let result = types::handle_stack_frame(&idb, addr);
                match &result {
                    Ok(r) => debug!(members = r.members.len(), "Got stack frame"),
                    Err(e) => warn!(error = %e, "Failed to get stack frame"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::Structs {
                offset,
                limit,
                filter,
                resp,
            } => {
                debug!(offset, limit, filter = ?filter, "Listing structs");
                let result = structs::handle_structs(&idb, offset, limit, filter.as_deref());
                match &result {
                    Ok(r) => debug!(count = r.structs.len(), total = r.total, "Listed structs"),
                    Err(e) => warn!(error = %e, "Failed to list structs"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::StructInfo {
                ordinal,
                name,
                resp,
            } => {
                debug!(ordinal = ?ordinal, name = ?name, "Getting struct info");
                let result = structs::handle_struct_info(&idb, ordinal, name.as_deref());
                match &result {
                    Ok(info) => {
                        debug!(name = %info.name, ordinal = info.ordinal, "Got struct info")
                    }
                    Err(e) => warn!(error = %e, "Failed to get struct info"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::ReadStruct {
                addr,
                ordinal,
                name,
                resp,
            } => {
                debug!(address = format!("{:#x}", addr), ordinal = ?ordinal, name = ?name, "Reading struct");
                let result = structs::handle_read_struct(&idb, addr, ordinal, name.as_deref());
                match &result {
                    Ok(info) => debug!(name = %info.name, ordinal = info.ordinal, "Read struct"),
                    Err(e) => warn!(error = %e, "Failed to read struct"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::XRefsTo { addr, resp } => {
                debug!(address = format!("{:#x}", addr), "Getting xrefs to");
                let result = xrefs::handle_xrefs_to(&idb, addr);
                match &result {
                    Ok(refs) => debug!(count = refs.len(), "Got xrefs to"),
                    Err(e) => warn!(error = %e, "Failed to get xrefs"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::XRefsFrom { addr, resp } => {
                debug!(address = format!("{:#x}", addr), "Getting xrefs from");
                let result = xrefs::handle_xrefs_from(&idb, addr);
                match &result {
                    Ok(refs) => debug!(count = refs.len(), "Got xrefs from"),
                    Err(e) => warn!(error = %e, "Failed to get xrefs"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::XRefsToField {
                ordinal,
                name,
                member_index,
                member_name,
                limit,
                resp,
            } => {
                debug!(
                    ordinal = ?ordinal,
                    name = ?name,
                    member_index = ?member_index,
                    member_name = ?member_name,
                    limit,
                    "Getting xrefs to struct field"
                );
                let result = structs::handle_xrefs_to_field(
                    &idb,
                    ordinal,
                    name.as_deref(),
                    member_index,
                    member_name.as_deref(),
                    limit,
                );
                match &result {
                    Ok(refs) => debug!(count = refs.xrefs.len(), "Got xrefs to struct field"),
                    Err(e) => warn!(error = %e, "Failed to get xrefs to struct field"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::Imports {
                offset,
                limit,
                resp,
            } => {
                debug!(offset, limit, "Listing imports");
                let result = imports::handle_imports(&idb, offset, limit);
                match &result {
                    Ok(imps) => debug!(count = imps.len(), "Listed imports"),
                    Err(e) => warn!(error = %e, "Failed to list imports"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::Exports {
                offset,
                limit,
                resp,
            } => {
                debug!(offset, limit, "Listing exports");
                let result = imports::handle_exports(&idb, offset, limit);
                match &result {
                    Ok(exps) => debug!(count = exps.len(), "Listed exports"),
                    Err(e) => warn!(error = %e, "Failed to list exports"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::Entrypoints { resp } => {
                debug!("Listing entrypoints");
                let result = imports::handle_entrypoints(&idb);
                match &result {
                    Ok(eps) => debug!(count = eps.len(), "Listed entrypoints"),
                    Err(e) => warn!(error = %e, "Failed to list entrypoints"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::GetBytes {
                addr,
                name,
                offset,
                size,
                resp,
            } => {
                let addr_log = addr
                    .map(|a| format!("{a:#x}"))
                    .unwrap_or_else(|| "none".to_string());
                debug!(
                    address = addr_log,
                    name = ?name,
                    offset,
                    size,
                    "Getting bytes"
                );
                let result = memory::handle_get_bytes(&idb, addr, name.as_deref(), offset, size);
                match &result {
                    Ok(b) => debug!(length = b.length, "Got bytes"),
                    Err(e) => warn!(error = %e, "Failed to get bytes"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::SetComments {
                addr,
                name,
                offset,
                comment,
                repeatable,
                resp,
            } => {
                let addr_log = addr
                    .map(|a| format!("{a:#x}"))
                    .unwrap_or_else(|| "none".to_string());
                debug!(
                    address = addr_log,
                    name = ?name,
                    offset,
                    repeatable,
                    "Setting comment"
                );
                let result = annotations::handle_set_comments(
                    &idb,
                    addr,
                    name.as_deref(),
                    offset,
                    &comment,
                    repeatable,
                );
                if let Err(e) = &result {
                    warn!(error = %e, "Failed to set comment");
                }
                let _ = resp.send(result);
            }
            IdaRequest::Rename {
                addr,
                current_name,
                new_name,
                flags,
                resp,
            } => {
                let addr_log = addr
                    .map(|a| format!("{a:#x}"))
                    .unwrap_or_else(|| "none".to_string());
                debug!(
                    address = addr_log,
                    current_name = ?current_name,
                    flags,
                    "Renaming symbol"
                );
                let result = annotations::handle_rename(
                    &idb,
                    addr,
                    current_name.as_deref(),
                    &new_name,
                    flags,
                );
                if let Err(e) = &result {
                    warn!(error = %e, "Failed to rename");
                }
                let _ = resp.send(result);
            }
            IdaRequest::PatchBytes {
                addr,
                name,
                offset,
                bytes,
                resp,
            } => {
                let addr_log = addr
                    .map(|a| format!("{a:#x}"))
                    .unwrap_or_else(|| "none".to_string());
                debug!(
                    address = addr_log,
                    name = ?name,
                    offset,
                    length = bytes.len(),
                    "Patching bytes"
                );
                let result =
                    memory::handle_patch_bytes(&idb, addr, name.as_deref(), offset, &bytes);
                if let Err(e) = &result {
                    warn!(error = %e, "Failed to patch bytes");
                }
                let _ = resp.send(result);
            }
            IdaRequest::PatchAsm {
                addr,
                name,
                offset,
                line,
                resp,
            } => {
                let addr_log = addr
                    .map(|a| format!("{a:#x}"))
                    .unwrap_or_else(|| "none".to_string());
                debug!(
                    address = addr_log,
                    name = ?name,
                    offset,
                    line = %line,
                    "Patching asm"
                );
                let result = memory::handle_patch_asm(&idb, addr, name.as_deref(), offset, &line);
                if let Err(e) = &result {
                    warn!(error = %e, "Failed to patch asm");
                }
                let _ = resp.send(result);
            }
            IdaRequest::BasicBlocks { addr, resp } => {
                debug!(address = format!("{:#x}", addr), "Getting basic blocks");
                let result = controlflow::handle_basic_blocks(&idb, addr);
                match &result {
                    Ok(bbs) => debug!(count = bbs.len(), "Got basic blocks"),
                    Err(e) => warn!(error = %e, "Failed to get basic blocks"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::Callees { addr, resp } => {
                debug!(address = format!("{:#x}", addr), "Getting callees");
                let result = controlflow::handle_callees(&idb, addr);
                match &result {
                    Ok(funcs) => debug!(count = funcs.len(), "Got callees"),
                    Err(e) => warn!(error = %e, "Failed to get callees"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::Callers { addr, resp } => {
                debug!(address = format!("{:#x}", addr), "Getting callers");
                let result = controlflow::handle_callers(&idb, addr);
                match &result {
                    Ok(funcs) => debug!(count = funcs.len(), "Got callers"),
                    Err(e) => warn!(error = %e, "Failed to get callers"),
                }
                let _ = resp.send(result);
            }
            IdaRequest::IdbMeta { resp } => {
                debug!("Getting IDB metadata");
                let result = globals::handle_idb_meta(&idb);
                let _ = resp.send(result);
            }
            IdaRequest::LookupFunctions { queries, resp } => {
                debug!(count = queries.len(), "Looking up functions");
                let result = functions::handle_lookup_funcs(&idb, &queries);
                let _ = resp.send(result);
            }
            IdaRequest::ListGlobals {
                query,
                offset,
                limit,
                resp,
            } => {
                debug!(offset, limit, query = ?query, "Listing globals");
                let result = globals::handle_list_globals(&idb, query.as_deref(), offset, limit);
                let _ = resp.send(result);
            }
            IdaRequest::AnalyzeStrings {
                query,
                offset,
                limit,
                resp,
            } => {
                debug!(offset, limit, query = ?query, "Analyzing strings");
                let result = strings::handle_analyze_strings(&idb, query.as_deref(), offset, limit);
                let _ = resp.send(result);
            }
            IdaRequest::FindString {
                query,
                exact,
                case_insensitive,
                offset,
                limit,
                resp,
            } => {
                debug!(
                    query = %query,
                    exact,
                    case_insensitive,
                    offset,
                    limit,
                    "Finding strings"
                );
                let result = strings::handle_find_string(
                    &idb,
                    &query,
                    exact,
                    case_insensitive,
                    offset,
                    limit,
                );
                let _ = resp.send(result);
            }
            IdaRequest::XrefsToString {
                query,
                exact,
                case_insensitive,
                offset,
                limit,
                max_xrefs,
                resp,
            } => {
                debug!(
                    query = %query,
                    exact,
                    case_insensitive,
                    offset,
                    limit,
                    max_xrefs,
                    "Getting xrefs to strings"
                );
                let result = strings::handle_xrefs_to_string(
                    &idb,
                    &query,
                    exact,
                    case_insensitive,
                    offset,
                    limit,
                    max_xrefs,
                );
                let _ = resp.send(result);
            }
            IdaRequest::AnalyzeFuncs { resp } => {
                debug!("Running auto-analysis");
                let result = functions::handle_analyze_funcs(&mut idb);
                let _ = resp.send(result);
            }
            IdaRequest::FindBytes {
                pattern,
                max_results,
                resp,
            } => {
                debug!(pattern = %pattern, max_results, "Finding bytes");
                let result = search::handle_find_bytes(&idb, &pattern, max_results);
                let _ = resp.send(result);
            }
            IdaRequest::SearchText {
                text,
                max_results,
                resp,
            } => {
                debug!(text = %text, max_results, "Searching text");
                let result = search::handle_search_text(&idb, &text, max_results);
                let _ = resp.send(result);
            }
            IdaRequest::SearchImm {
                imm,
                max_results,
                resp,
            } => {
                debug!(imm, max_results, "Searching immediate");
                let result = search::handle_search_imm(&idb, imm, max_results);
                let _ = resp.send(result);
            }
            IdaRequest::FindInsns {
                patterns,
                max_results,
                case_insensitive,
                resp,
            } => {
                debug!(
                    patterns = ?patterns,
                    max_results,
                    case_insensitive,
                    "Finding instruction sequences"
                );
                let result =
                    search::handle_find_insns(&idb, &patterns, max_results, case_insensitive);
                let _ = resp.send(result);
            }
            IdaRequest::FindInsnOperands {
                patterns,
                max_results,
                case_insensitive,
                resp,
            } => {
                debug!(
                    patterns = ?patterns,
                    max_results,
                    case_insensitive,
                    "Finding instruction operands"
                );
                let result = search::handle_find_insn_operands(
                    &idb,
                    &patterns,
                    max_results,
                    case_insensitive,
                );
                let _ = resp.send(result);
            }
            IdaRequest::ReadInt { addr, size, resp } => {
                debug!(address = format!("{:#x}", addr), size, "Reading int");
                let result = memory::handle_read_int(&idb, addr, size);
                let _ = resp.send(result);
            }
            IdaRequest::GetString {
                addr,
                max_len,
                resp,
            } => {
                debug!(address = format!("{:#x}", addr), max_len, "Reading string");
                let result = strings::handle_get_string(&idb, addr, max_len);
                let _ = resp.send(result);
            }
            IdaRequest::GetGlobalValue { query, resp } => {
                debug!(query = %query, "Getting global value");
                let result = globals::handle_get_global_value(&idb, &query);
                let _ = resp.send(result);
            }
            IdaRequest::FindPaths {
                start,
                end,
                max_paths,
                max_depth,
                resp,
            } => {
                debug!(
                    start = format!("{:#x}", start),
                    end = format!("{:#x}", end),
                    max_paths,
                    max_depth,
                    "Finding paths"
                );
                let result = controlflow::handle_find_paths(&idb, start, end, max_paths, max_depth);
                let _ = resp.send(result);
            }
            IdaRequest::CallGraph {
                addr,
                max_depth,
                max_nodes,
                resp,
            } => {
                debug!(
                    address = format!("{:#x}", addr),
                    max_depth, max_nodes, "Building call graph"
                );
                let result = controlflow::handle_callgraph(&idb, addr, max_depth, max_nodes);
                let _ = resp.send(result);
            }
            IdaRequest::XrefMatrix { addrs, resp } => {
                debug!(count = addrs.len(), "Building xref matrix");
                let result = xrefs::handle_xref_matrix(&idb, &addrs);
                let _ = resp.send(result);
            }
            IdaRequest::ExportFuncs {
                offset,
                limit,
                resp,
            } => {
                debug!(offset, limit, "Exporting functions");
                let result = functions::handle_list_functions(&idb, offset, limit, None);
                let _ = resp.send(result);
            }
            IdaRequest::PseudocodeAt {
                addr,
                end_addr,
                resp,
            } => {
                debug!(
                    address = format!("{:#x}", addr),
                    end_addr = end_addr.map(|a| format!("{:#x}", a)),
                    "Getting pseudocode at address"
                );
                let result = disasm::handle_pseudocode_at(&idb, addr, end_addr);
                match &result {
                    Ok(v) => debug!(
                        count = v
                            .get("statements")
                            .and_then(|s| s.as_array())
                            .map(|a| a.len())
                            .unwrap_or(0),
                        "Got pseudocode at address"
                    ),
                    Err(e) => {
                        warn!(address = format!("{:#x}", addr), error = %e, "Failed to get pseudocode")
                    }
                }
                let _ = resp.send(result);
            }
            IdaRequest::RunScript { code, resp } => {
                debug!(code_len = code.len(), "Running script");
                let started = std::time::Instant::now();
                let result = script::handle_run_script(&idb, &code);
                let elapsed_ms = started.elapsed().as_millis();
                match &result {
                    Ok(value) => {
                        let success = value.get("success").and_then(|v| v.as_bool()) == Some(true);
                        let stdout_len = value
                            .get("stdout")
                            .and_then(|v| v.as_str())
                            .map(|s| s.len())
                            .unwrap_or(0);
                        let stderr_len = value
                            .get("stderr")
                            .and_then(|v| v.as_str())
                            .map(|s| s.len())
                            .unwrap_or(0);
                        if success {
                            debug!(elapsed_ms, stdout_len, stderr_len, "Script executed");
                        } else {
                            let error = value.get("error").and_then(|v| v.as_str()).unwrap_or("");
                            warn!(
                                elapsed_ms,
                                stdout_len, stderr_len, error, "Script execution reported failure"
                            );
                        }
                    }
                    Err(e) => {
                        warn!(elapsed_ms, error = %e, "Failed to execute script");
                    }
                }
                let _ = resp.send(result);
            }
            IdaRequest::Shutdown => {
                info!("Worker shutting down");
                // Explicitly close database to ensure IDA packs it before exit
                if idb.is_some() {
                    info!("Closing database before shutdown");
                    drop(idb.take());
                }
                release_mcp_lock(&mut lock_file, &mut lock_path);
                break;
            }
        }
    }
}

```

`src/ida/mod.rs`:

```rs
//! IDA Pro integration module.
//!
//! This module provides a headless IDA Pro interface via the idalib crate.
//! It uses a channel-based worker pattern to ensure IDA operations run on the main thread
//! (IDA types are not thread-safe).

pub mod handlers;
pub mod lock;
mod loop_impl;
pub mod request;
pub mod types;
pub mod worker;

pub use loop_impl::run_ida_loop;
pub use request::IdaRequest;
pub use types::*;
pub use worker::IdaWorker;

```

`src/ida/request.rs`:

```rs
//! Request types for the IDA worker.

use crate::error::ToolError;
use crate::ida::types::*;
use serde_json::Value;
use tokio::sync::oneshot;

/// Request types for the IDA worker
pub enum IdaRequest {
    Open {
        path: String,
        load_debug_info: bool,
        debug_info_path: Option<String>,
        debug_info_verbose: bool,
        force: bool,
        file_type: Option<String>,
        auto_analyse: bool,
        extra_args: Vec<String>,
        resp: oneshot::Sender<Result<DbInfo, ToolError>>,
    },
    Close {
        resp: oneshot::Sender<()>,
    },
    LoadDebugInfo {
        path: Option<String>,
        verbose: bool,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    AnalysisStatus {
        resp: oneshot::Sender<Result<AnalysisStatus, ToolError>>,
    },
    ListFunctions {
        offset: usize,
        limit: usize,
        filter: Option<String>,
        resp: oneshot::Sender<Result<FunctionListResult, ToolError>>,
    },
    ResolveFunction {
        name: String,
        resp: oneshot::Sender<Result<FunctionInfo, ToolError>>,
    },
    DisasmByName {
        name: String,
        count: usize,
        resp: oneshot::Sender<Result<String, ToolError>>,
    },
    Disasm {
        addr: u64,
        count: usize,
        resp: oneshot::Sender<Result<String, ToolError>>,
    },
    Decompile {
        addr: u64,
        resp: oneshot::Sender<Result<String, ToolError>>,
    },
    Segments {
        resp: oneshot::Sender<Result<Vec<SegmentInfo>, ToolError>>,
    },
    Strings {
        offset: usize,
        limit: usize,
        filter: Option<String>,
        resp: oneshot::Sender<Result<StringListResult, ToolError>>,
    },
    LocalTypes {
        offset: usize,
        limit: usize,
        filter: Option<String>,
        resp: oneshot::Sender<Result<LocalTypeListResult, ToolError>>,
    },
    DeclareType {
        decl: String,
        relaxed: bool,
        replace: bool,
        multi: bool,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    ApplyTypes {
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        stack_offset: Option<i64>,
        stack_name: Option<String>,
        decl: Option<String>,
        type_name: Option<String>,
        relaxed: bool,
        delay: bool,
        strict: bool,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    InferTypes {
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        resp: oneshot::Sender<Result<GuessTypeResult, ToolError>>,
    },
    AddrInfo {
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        resp: oneshot::Sender<Result<AddressInfo, ToolError>>,
    },
    FunctionAt {
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        resp: oneshot::Sender<Result<FunctionRangeInfo, ToolError>>,
    },
    DisasmFunctionAt {
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        count: usize,
        resp: oneshot::Sender<Result<String, ToolError>>,
    },
    DeclareStack {
        addr: Option<u64>,
        name: Option<String>,
        offset: i64,
        var_name: Option<String>,
        decl: String,
        relaxed: bool,
        resp: oneshot::Sender<Result<StackVarResult, ToolError>>,
    },
    DeleteStack {
        addr: Option<u64>,
        name: Option<String>,
        offset: Option<i64>,
        var_name: Option<String>,
        resp: oneshot::Sender<Result<StackVarResult, ToolError>>,
    },
    StackFrame {
        addr: u64,
        resp: oneshot::Sender<Result<FrameInfo, ToolError>>,
    },
    Structs {
        offset: usize,
        limit: usize,
        filter: Option<String>,
        resp: oneshot::Sender<Result<StructListResult, ToolError>>,
    },
    StructInfo {
        ordinal: Option<u32>,
        name: Option<String>,
        resp: oneshot::Sender<Result<StructInfo, ToolError>>,
    },
    ReadStruct {
        addr: u64,
        ordinal: Option<u32>,
        name: Option<String>,
        resp: oneshot::Sender<Result<StructReadResult, ToolError>>,
    },
    XRefsTo {
        addr: u64,
        resp: oneshot::Sender<Result<Vec<XRefInfo>, ToolError>>,
    },
    XRefsFrom {
        addr: u64,
        resp: oneshot::Sender<Result<Vec<XRefInfo>, ToolError>>,
    },
    XRefsToField {
        ordinal: Option<u32>,
        name: Option<String>,
        member_index: Option<u32>,
        member_name: Option<String>,
        limit: usize,
        resp: oneshot::Sender<Result<XrefsToFieldResult, ToolError>>,
    },
    Imports {
        offset: usize,
        limit: usize,
        resp: oneshot::Sender<Result<Vec<ImportInfo>, ToolError>>,
    },
    Exports {
        offset: usize,
        limit: usize,
        resp: oneshot::Sender<Result<Vec<ExportInfo>, ToolError>>,
    },
    Entrypoints {
        resp: oneshot::Sender<Result<Vec<String>, ToolError>>,
    },
    GetBytes {
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        size: usize,
        resp: oneshot::Sender<Result<BytesResult, ToolError>>,
    },
    SetComments {
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        comment: String,
        repeatable: bool,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    Rename {
        addr: Option<u64>,
        current_name: Option<String>,
        new_name: String,
        flags: i32,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    PatchBytes {
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        bytes: Vec<u8>,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    PatchAsm {
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        line: String,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    BasicBlocks {
        addr: u64,
        resp: oneshot::Sender<Result<Vec<BasicBlockInfo>, ToolError>>,
    },
    Callees {
        addr: u64,
        resp: oneshot::Sender<Result<Vec<FunctionInfo>, ToolError>>,
    },
    Callers {
        addr: u64,
        resp: oneshot::Sender<Result<Vec<FunctionInfo>, ToolError>>,
    },
    IdbMeta {
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    LookupFunctions {
        queries: Vec<String>,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    ListGlobals {
        query: Option<String>,
        offset: usize,
        limit: usize,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    AnalyzeStrings {
        query: Option<String>,
        offset: usize,
        limit: usize,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    FindString {
        query: String,
        exact: bool,
        case_insensitive: bool,
        offset: usize,
        limit: usize,
        resp: oneshot::Sender<Result<StringListResult, ToolError>>,
    },
    XrefsToString {
        query: String,
        exact: bool,
        case_insensitive: bool,
        offset: usize,
        limit: usize,
        max_xrefs: usize,
        resp: oneshot::Sender<Result<StringXrefsResult, ToolError>>,
    },
    AnalyzeFuncs {
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    FindBytes {
        pattern: String,
        max_results: usize,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    SearchText {
        text: String,
        max_results: usize,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    SearchImm {
        imm: u64,
        max_results: usize,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    FindInsns {
        patterns: Vec<String>,
        max_results: usize,
        case_insensitive: bool,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    FindInsnOperands {
        patterns: Vec<String>,
        max_results: usize,
        case_insensitive: bool,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    ReadInt {
        addr: u64,
        size: usize,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    GetString {
        addr: u64,
        max_len: usize,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    GetGlobalValue {
        query: String,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    FindPaths {
        start: u64,
        end: u64,
        max_paths: usize,
        max_depth: usize,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    CallGraph {
        addr: u64,
        max_depth: usize,
        max_nodes: usize,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    XrefMatrix {
        addrs: Vec<u64>,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    ExportFuncs {
        offset: usize,
        limit: usize,
        resp: oneshot::Sender<Result<FunctionListResult, ToolError>>,
    },
    PseudocodeAt {
        addr: u64,
        end_addr: Option<u64>,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    RunScript {
        code: String,
        resp: oneshot::Sender<Result<Value, ToolError>>,
    },
    Shutdown,
}

```

`src/ida/types.rs`:

```rs
//! Response types for IDA worker operations.

use serde::Serialize;

/// Database info returned after opening
#[derive(Debug, Clone, Serialize)]
pub struct DbInfo {
    pub path: String,
    pub file_type: String,
    pub processor: String,
    pub bits: u32,
    pub function_count: usize,
    pub debug_info: Option<DebugInfoLoad>,
    pub analysis_status: AnalysisStatus,
}

#[derive(Debug, Clone, Serialize)]
pub struct DebugInfoLoad {
    pub path: String,
    pub loaded: bool,
    pub error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
pub struct AnalysisStatus {
    pub auto_enabled: bool,
    pub auto_is_ok: bool,
    pub auto_state: String,
    pub auto_state_id: i32,
    pub analysis_running: bool,
}

#[derive(Debug, Clone, Serialize)]
pub struct SymbolInfo {
    pub name: String,
    pub address: String,
    pub delta: i64,
    pub exact: bool,
    pub is_public: bool,
    pub is_weak: bool,
}

#[derive(Debug, Clone, Serialize)]
pub struct FunctionRangeInfo {
    pub address: String,
    pub name: String,
    pub start: String,
    pub end: String,
    pub size: usize,
}

#[derive(Debug, Clone, Serialize)]
pub struct AddressInfo {
    pub address: String,
    pub segment: Option<SegmentInfo>,
    pub function: Option<FunctionRangeInfo>,
    pub symbol: Option<SymbolInfo>,
}

/// Function info for listing
#[derive(Debug, Clone, Serialize)]
pub struct FunctionInfo {
    pub address: String,
    pub name: String,
    pub size: usize,
}

/// Paginated function list result
#[derive(Debug, Clone, Serialize)]
pub struct FunctionListResult {
    pub functions: Vec<FunctionInfo>,
    pub total: usize,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_offset: Option<usize>,
}

/// Segment info
#[derive(Debug, Clone, Serialize)]
pub struct SegmentInfo {
    pub name: String,
    pub start: String,
    pub end: String,
    pub size: usize,
    pub permissions: String,
    pub r#type: String,
    pub bitness: u32,
}

/// String info
#[derive(Debug, Clone, Serialize)]
pub struct StringInfo {
    pub address: String,
    pub content: String,
    pub length: usize,
}

/// String list result with pagination
#[derive(Debug, Clone, Serialize)]
pub struct StringListResult {
    pub strings: Vec<StringInfo>,
    pub total: usize,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_offset: Option<usize>,
}

#[derive(Debug, Clone, Serialize)]
pub struct StringXrefInfo {
    pub address: String,
    pub content: String,
    pub length: usize,
    pub xrefs: Vec<String>,
    pub xref_count: usize,
}

#[derive(Debug, Clone, Serialize)]
pub struct StringXrefsResult {
    pub strings: Vec<StringXrefInfo>,
    pub total: usize,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_offset: Option<usize>,
}

/// Local type info
#[derive(Debug, Clone, Serialize)]
pub struct LocalTypeInfo {
    pub ordinal: u32,
    pub name: String,
    pub decl: String,
    pub kind: String,
}

/// Local types list result with pagination
#[derive(Debug, Clone, Serialize)]
pub struct LocalTypeListResult {
    pub types: Vec<LocalTypeInfo>,
    pub total: usize,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_offset: Option<usize>,
}

/// Frame range info
#[derive(Debug, Clone, Serialize)]
pub struct FrameRange {
    pub start: String,
    pub end: String,
}

/// Stack frame member info
#[derive(Debug, Clone, Serialize)]
pub struct FrameMemberInfo {
    pub name: String,
    pub type_name: String,
    pub offset_bits: u64,
    pub size_bits: u64,
    pub offset: u64,
    pub size: u64,
    pub is_bitfield: bool,
    pub part: String,
}

/// Stack frame info
#[derive(Debug, Clone, Serialize)]
pub struct FrameInfo {
    pub address: String,
    pub frame_size: u64,
    pub ret_size: i32,
    pub frsize: u64,
    pub frregs: u16,
    pub argsize: u64,
    pub fpd: u64,
    pub args_range: FrameRange,
    pub retaddr_range: FrameRange,
    pub savregs_range: FrameRange,
    pub locals_range: FrameRange,
    pub member_count: u32,
    pub members: Vec<FrameMemberInfo>,
}

/// Struct summary info
#[derive(Debug, Clone, Serialize)]
pub struct StructSummary {
    pub ordinal: u32,
    pub name: String,
    pub size: u64,
    pub is_union: bool,
    pub member_count: u32,
}

/// Struct list result with pagination
#[derive(Debug, Clone, Serialize)]
pub struct StructListResult {
    pub structs: Vec<StructSummary>,
    pub total: usize,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_offset: Option<usize>,
}

/// Struct member info
#[derive(Debug, Clone, Serialize)]
pub struct StructMemberInfo {
    pub name: String,
    pub type_name: String,
    pub offset_bits: u64,
    pub size_bits: u64,
    pub offset: u64,
    pub size: u64,
    pub is_bitfield: bool,
}

/// Struct detailed info
#[derive(Debug, Clone, Serialize)]
pub struct StructInfo {
    pub ordinal: u32,
    pub name: String,
    pub size: u64,
    pub is_union: bool,
    pub member_count: u32,
    pub members: Vec<StructMemberInfo>,
}

/// Struct member value
#[derive(Debug, Clone, Serialize)]
pub struct StructMemberValue {
    pub name: String,
    pub type_name: String,
    pub offset_bits: u64,
    pub size_bits: u64,
    pub offset: u64,
    pub size: u64,
    pub is_bitfield: bool,
    pub bytes: String,
}

/// Struct read result
#[derive(Debug, Clone, Serialize)]
pub struct StructReadResult {
    pub address: String,
    pub ordinal: u32,
    pub name: String,
    pub size: u64,
    pub members: Vec<StructMemberValue>,
}

/// Cross-reference info
#[derive(Debug, Clone, Serialize)]
pub struct XRefInfo {
    pub from: String,
    pub to: String,
    pub r#type: String,
    pub is_code: bool,
}

/// Declared type result
#[derive(Debug, Clone, Serialize)]
pub struct DeclareTypeResult {
    pub code: i32,
    pub name: String,
    pub decl: String,
    pub kind: String,
    pub replaced: bool,
}

/// Declare multiple types result
#[derive(Debug, Clone, Serialize)]
pub struct DeclareTypesResult {
    pub errors: i32,
}

/// Applied type result
#[derive(Debug, Clone, Serialize)]
pub struct ApplyTypeResult {
    pub address: String,
    pub applied: bool,
    pub source: String,
}

/// Guess type result
#[derive(Debug, Clone, Serialize)]
pub struct GuessTypeResult {
    pub address: String,
    pub code: i32,
    pub status: String,
    pub decl: String,
    pub kind: String,
}

/// Stack variable operation result
#[derive(Debug, Clone, Serialize)]
pub struct StackVarResult {
    pub function: String,
    pub name: String,
    pub offset: i64,
    pub code: i32,
    pub status: String,
}

/// Xrefs to a struct field
#[derive(Debug, Clone, Serialize)]
pub struct XrefsToFieldResult {
    pub struct_ordinal: u32,
    pub struct_name: String,
    pub member_index: u32,
    pub member_name: String,
    pub member_type: String,
    pub member_offset_bits: u64,
    pub member_size_bits: u64,
    pub tid: String,
    pub xrefs: Vec<XRefInfo>,
    pub truncated: bool,
}

/// Import info
#[derive(Debug, Clone, Serialize)]
pub struct ImportInfo {
    pub address: String,
    pub name: String,
    pub ordinal: usize,
}

/// Export/Name info
#[derive(Debug, Clone, Serialize)]
pub struct ExportInfo {
    pub address: String,
    pub name: String,
    pub is_public: bool,
}

/// Global variable/name info
#[derive(Debug, Clone, Serialize)]
pub struct GlobalInfo {
    pub address: String,
    pub name: String,
    pub is_public: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_weak: Option<bool>,
}

/// Basic block info
#[derive(Debug, Clone, Serialize)]
pub struct BasicBlockInfo {
    pub start: String,
    pub end: String,
    pub size: usize,
    pub block_type: String,
    pub successors: Vec<String>,
    pub predecessors: Vec<String>,
}

/// Bytes result
#[derive(Debug, Clone, Serialize)]
pub struct BytesResult {
    pub address: String,
    pub bytes: String,
    pub length: usize,
}

```

`src/ida/worker.rs`:

```rs
//! IDA worker handle for async requests.

use crate::error::ToolError;
use crate::ida::request::IdaRequest;
use crate::ida::types::*;
use serde_json::Value;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::{mpsc, Arc, Mutex};
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::sync::oneshot;
use tokio::time::Instant;

/// Default timeout for IDA operations (2 minutes)
const DEFAULT_TIMEOUT_SECS: u64 = 120;
/// Maximum allowed timeout (10 minutes)
const MAX_TIMEOUT_SECS: u64 = 600;
/// Maximum time to retry enqueuing close requests when the queue is full.
const CLOSE_SEND_TIMEOUT_SECS: u64 = 5;
/// Backoff between control enqueue retries (milliseconds).
const CONTROL_SEND_BACKOFF_MS: u64 = 25;

/// Internal state for close token ownership.
#[derive(Debug)]
struct CloseTokenState {
    token: Mutex<Option<String>>,
    nonce: AtomicU64,
}

impl CloseTokenState {
    fn new() -> Self {
        Self {
            token: Mutex::new(None),
            nonce: AtomicU64::new(0),
        }
    }

    fn lock_token(&self) -> std::sync::MutexGuard<'_, Option<String>> {
        match self.token.lock() {
            Ok(guard) => guard,
            Err(poisoned) => poisoned.into_inner(),
        }
    }

    fn generate_token(&self) -> String {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map(|d| d.as_nanos())
            .unwrap_or(0);
        let nonce = self.nonce.fetch_add(1, Ordering::Relaxed);
        let pid = std::process::id();
        format!("{now:x}-{pid:x}-{nonce:x}")
    }

    fn issue_if_none(&self) -> Option<String> {
        let mut guard = self.lock_token();
        if guard.is_some() {
            return None;
        }
        let token = self.generate_token();
        *guard = Some(token.clone());
        Some(token)
    }

    fn matches(&self, token: Option<&str>) -> bool {
        let guard = self.lock_token();
        match (guard.as_deref(), token) {
            (Some(expected), Some(provided)) => expected == provided,
            _ => false,
        }
    }

    fn clear(&self) {
        let mut guard = self.lock_token();
        *guard = None;
    }
}

/// Handle for sending requests to the main thread IDA worker
#[derive(Clone)]
pub struct IdaWorker {
    tx: mpsc::SyncSender<IdaRequest>,
    close_token: Arc<CloseTokenState>,
}

impl IdaWorker {
    /// Create a new worker handle with the given sender.
    pub fn new(tx: mpsc::SyncSender<IdaRequest>) -> Self {
        Self {
            tx,
            close_token: Arc::new(CloseTokenState::new()),
        }
    }

    pub(crate) fn issue_close_token(&self) -> Option<String> {
        self.close_token.issue_if_none()
    }

    pub(crate) fn close_token_matches(&self, token: Option<&str>) -> bool {
        self.close_token.matches(token)
    }

    pub(crate) fn clear_close_token(&self) {
        self.close_token.clear();
    }

    fn try_send(&self, req: IdaRequest) -> Result<(), ToolError> {
        match self.tx.try_send(req) {
            Ok(()) => Ok(()),
            Err(mpsc::TrySendError::Full(_)) => Err(ToolError::Busy),
            Err(mpsc::TrySendError::Disconnected(_)) => Err(ToolError::WorkerClosed),
        }
    }

    async fn send_with_retry(
        &self,
        req: IdaRequest,
        max_wait: Option<Duration>,
    ) -> Result<(), ToolError> {
        let start = Instant::now();
        let mut pending = req;
        loop {
            match self.tx.try_send(pending) {
                Ok(()) => return Ok(()),
                Err(mpsc::TrySendError::Full(req)) => {
                    if let Some(max_wait) = max_wait {
                        if Instant::now().duration_since(start) >= max_wait {
                            return Err(ToolError::Busy);
                        }
                    }
                    pending = req;
                    tokio::time::sleep(Duration::from_millis(CONTROL_SEND_BACKOFF_MS)).await;
                }
                Err(mpsc::TrySendError::Disconnected(_)) => return Err(ToolError::WorkerClosed),
            }
        }
    }

    /// Helper to receive with optional timeout
    async fn recv_with_timeout<T>(
        rx: oneshot::Receiver<Result<T, ToolError>>,
        timeout_secs: Option<u64>,
    ) -> Result<T, ToolError> {
        let timeout = Duration::from_secs(
            timeout_secs
                .unwrap_or(DEFAULT_TIMEOUT_SECS)
                .min(MAX_TIMEOUT_SECS),
        );
        match tokio::time::timeout(timeout, rx).await {
            Ok(result) => result?,
            Err(_) => Err(ToolError::Timeout(timeout.as_secs())),
        }
    }

    /// Open an IDA database file.
    #[allow(clippy::too_many_arguments)]
    pub async fn open(
        &self,
        path: &str,
        load_debug_info: bool,
        debug_info_path: Option<String>,
        debug_info_verbose: bool,
        force: bool,
        file_type: Option<String>,
        auto_analyse: bool,
        extra_args: Vec<String>,
    ) -> Result<DbInfo, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Open {
            path: path.to_string(),
            load_debug_info,
            debug_info_path,
            debug_info_verbose,
            force,
            file_type,
            auto_analyse,
            extra_args,
            resp: tx,
        })?;
        rx.await?
    }

    /// Close the currently open database.
    pub async fn close(&self) -> Result<(), ToolError> {
        let (tx, rx) = oneshot::channel();
        self.send_with_retry(
            IdaRequest::Close { resp: tx },
            Some(Duration::from_secs(CLOSE_SEND_TIMEOUT_SECS)),
        )
        .await?;
        rx.await.map_err(|_| ToolError::WorkerClosed)
    }

    pub async fn close_for_shutdown(&self) -> Result<(), ToolError> {
        let (tx, rx) = oneshot::channel();
        self.send_with_retry(IdaRequest::Close { resp: tx }, None)
            .await?;
        rx.await.map_err(|_| ToolError::WorkerClosed)
    }

    /// Load external debug info (e.g., dSYM/DWARF) into the current database.
    pub async fn load_debug_info(
        &self,
        path: Option<String>,
        verbose: bool,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::LoadDebugInfo {
            path,
            verbose,
            resp: tx,
        })?;
        rx.await?
    }

    /// Report current auto-analysis status.
    pub async fn analysis_status(&self) -> Result<AnalysisStatus, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::AnalysisStatus { resp: tx })?;
        rx.await?
    }

    /// Shutdown the IDA worker loop.
    pub async fn shutdown(&self) -> Result<(), ToolError> {
        self.send_with_retry(IdaRequest::Shutdown, None).await
    }

    /// List functions in the database with pagination.
    pub async fn list_functions(
        &self,
        offset: usize,
        limit: usize,
        filter: Option<String>,
        timeout_secs: Option<u64>,
    ) -> Result<FunctionListResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::ListFunctions {
            offset,
            limit,
            filter,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Resolve a function by name (exact or partial match).
    pub async fn resolve_function(&self, name: &str) -> Result<FunctionInfo, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::ResolveFunction {
            name: name.to_string(),
            resp: tx,
        })?;
        rx.await?
    }

    /// Disassemble a function by name (exact or partial match).
    pub async fn disasm_by_name(&self, name: &str, count: usize) -> Result<String, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::DisasmByName {
            name: name.to_string(),
            count,
            resp: tx,
        })?;
        rx.await?
    }

    /// Get disassembly at an address.
    pub async fn disasm(&self, addr: u64, count: usize) -> Result<String, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Disasm {
            addr,
            count,
            resp: tx,
        })?;
        rx.await?
    }

    /// Decompile a function using Hex-Rays.
    pub async fn decompile(&self, addr: u64) -> Result<String, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Decompile { addr, resp: tx })?;
        rx.await?
    }

    /// List all segments.
    pub async fn segments(&self) -> Result<Vec<SegmentInfo>, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Segments { resp: tx })?;
        rx.await?
    }

    /// List strings with pagination and optional filter.
    pub async fn strings(
        &self,
        offset: usize,
        limit: usize,
        filter: Option<String>,
        timeout_secs: Option<u64>,
    ) -> Result<StringListResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Strings {
            offset,
            limit,
            filter,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// List local types with pagination and optional filter.
    pub async fn local_types(
        &self,
        offset: usize,
        limit: usize,
        filter: Option<String>,
        timeout_secs: Option<u64>,
    ) -> Result<LocalTypeListResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::LocalTypes {
            offset,
            limit,
            filter,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Declare a type (single or multi).
    pub async fn declare_type(
        &self,
        decl: String,
        relaxed: bool,
        replace: bool,
        multi: bool,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::DeclareType {
            decl,
            relaxed,
            replace,
            multi,
            resp: tx,
        })?;
        rx.await?
    }

    /// Apply a type to an address.
    #[allow(clippy::too_many_arguments)]
    pub async fn apply_types(
        &self,
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        stack_offset: Option<i64>,
        stack_name: Option<String>,
        decl: Option<String>,
        type_name: Option<String>,
        relaxed: bool,
        delay: bool,
        strict: bool,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::ApplyTypes {
            addr,
            name,
            offset,
            stack_offset,
            stack_name,
            decl,
            type_name,
            relaxed,
            delay,
            strict,
            resp: tx,
        })?;
        rx.await?
    }

    /// Infer/guess a type for an address.
    pub async fn infer_types(
        &self,
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
    ) -> Result<GuessTypeResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::InferTypes {
            addr,
            name,
            offset,
            resp: tx,
        })?;
        rx.await?
    }

    /// Get address context (segment, function, symbol).
    pub async fn addr_info(
        &self,
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
    ) -> Result<AddressInfo, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::AddrInfo {
            addr,
            name,
            offset,
            resp: tx,
        })?;
        rx.await?
    }

    /// Get function containing an address.
    pub async fn function_at(
        &self,
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
    ) -> Result<FunctionRangeInfo, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::FunctionAt {
            addr,
            name,
            offset,
            resp: tx,
        })?;
        rx.await?
    }

    /// Disassemble the function containing an address.
    pub async fn disasm_function_at(
        &self,
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        count: usize,
    ) -> Result<String, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::DisasmFunctionAt {
            addr,
            name,
            offset,
            count,
            resp: tx,
        })?;
        rx.await?
    }

    /// Declare a stack variable in a function frame.
    pub async fn declare_stack(
        &self,
        addr: Option<u64>,
        name: Option<String>,
        offset: i64,
        var_name: Option<String>,
        decl: String,
        relaxed: bool,
    ) -> Result<StackVarResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::DeclareStack {
            addr,
            name,
            offset,
            var_name,
            decl,
            relaxed,
            resp: tx,
        })?;
        rx.await?
    }

    /// Delete a stack variable from a function frame.
    pub async fn delete_stack(
        &self,
        addr: Option<u64>,
        name: Option<String>,
        offset: Option<i64>,
        var_name: Option<String>,
    ) -> Result<StackVarResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::DeleteStack {
            addr,
            name,
            offset,
            var_name,
            resp: tx,
        })?;
        rx.await?
    }

    /// Get stack frame info for a function at an address.
    pub async fn stack_frame(&self, addr: u64) -> Result<FrameInfo, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::StackFrame { addr, resp: tx })?;
        rx.await?
    }

    /// List structs with pagination and optional filter.
    pub async fn structs(
        &self,
        offset: usize,
        limit: usize,
        filter: Option<String>,
        timeout_secs: Option<u64>,
    ) -> Result<StructListResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Structs {
            offset,
            limit,
            filter,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Get struct info by ordinal or name.
    pub async fn struct_info(
        &self,
        ordinal: Option<u32>,
        name: Option<String>,
    ) -> Result<StructInfo, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::StructInfo {
            ordinal,
            name,
            resp: tx,
        })?;
        rx.await?
    }

    /// Read a struct instance at an address.
    pub async fn read_struct(
        &self,
        addr: u64,
        ordinal: Option<u32>,
        name: Option<String>,
    ) -> Result<StructReadResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::ReadStruct {
            addr,
            ordinal,
            name,
            resp: tx,
        })?;
        rx.await?
    }

    /// Get cross-references to an address.
    pub async fn xrefs_to(&self, addr: u64) -> Result<Vec<XRefInfo>, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::XRefsTo { addr, resp: tx })?;
        rx.await?
    }

    /// Get cross-references from an address.
    pub async fn xrefs_from(&self, addr: u64) -> Result<Vec<XRefInfo>, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::XRefsFrom { addr, resp: tx })?;
        rx.await?
    }

    /// Get xrefs to a struct field.
    pub async fn xrefs_to_field(
        &self,
        ordinal: Option<u32>,
        name: Option<String>,
        member_index: Option<u32>,
        member_name: Option<String>,
        limit: usize,
    ) -> Result<XrefsToFieldResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::XRefsToField {
            ordinal,
            name,
            member_index,
            member_name,
            limit,
            resp: tx,
        })?;
        rx.await?
    }

    /// List imports with pagination.
    pub async fn imports(&self, offset: usize, limit: usize) -> Result<Vec<ImportInfo>, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Imports {
            offset,
            limit,
            resp: tx,
        })?;
        rx.await?
    }

    /// List exports with pagination.
    pub async fn exports(&self, offset: usize, limit: usize) -> Result<Vec<ExportInfo>, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Exports {
            offset,
            limit,
            resp: tx,
        })?;
        rx.await?
    }

    /// Get entry points.
    pub async fn entrypoints(&self) -> Result<Vec<String>, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Entrypoints { resp: tx })?;
        rx.await?
    }

    /// Read bytes from an address.
    pub async fn get_bytes(
        &self,
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        size: usize,
    ) -> Result<BytesResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::GetBytes {
            addr,
            name,
            offset,
            size,
            resp: tx,
        })?;
        rx.await?
    }

    /// Set a comment at an address.
    pub async fn set_comments(
        &self,
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        comment: String,
        repeatable: bool,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::SetComments {
            addr,
            name,
            offset,
            comment,
            repeatable,
            resp: tx,
        })?;
        rx.await?
    }

    /// Rename a symbol at an address.
    pub async fn rename(
        &self,
        addr: Option<u64>,
        current_name: Option<String>,
        new_name: String,
        flags: i32,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Rename {
            addr,
            current_name,
            new_name,
            flags,
            resp: tx,
        })?;
        rx.await?
    }

    /// Patch bytes at an address.
    pub async fn patch_bytes(
        &self,
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        bytes: Vec<u8>,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::PatchBytes {
            addr,
            name,
            offset,
            bytes,
            resp: tx,
        })?;
        rx.await?
    }

    /// Patch instructions with assembly text at an address.
    pub async fn patch_asm(
        &self,
        addr: Option<u64>,
        name: Option<String>,
        offset: u64,
        line: String,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::PatchAsm {
            addr,
            name,
            offset,
            line,
            resp: tx,
        })?;
        rx.await?
    }

    /// Get basic blocks for a function.
    pub async fn basic_blocks(&self, addr: u64) -> Result<Vec<BasicBlockInfo>, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::BasicBlocks { addr, resp: tx })?;
        rx.await?
    }

    /// Get functions called by a function.
    pub async fn callees(&self, addr: u64) -> Result<Vec<FunctionInfo>, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Callees { addr, resp: tx })?;
        rx.await?
    }

    /// Get functions that call a function.
    pub async fn callers(&self, addr: u64) -> Result<Vec<FunctionInfo>, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::Callers { addr, resp: tx })?;
        rx.await?
    }

    /// Get IDB metadata.
    pub async fn idb_meta(&self) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::IdbMeta { resp: tx })?;
        rx.await?
    }

    /// Lookup functions by name or address (batch).
    pub async fn lookup_funcs(&self, queries: Vec<String>) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::LookupFunctions { queries, resp: tx })?;
        rx.await?
    }

    /// List globals (named addresses outside functions).
    pub async fn list_globals(
        &self,
        query: Option<String>,
        offset: usize,
        limit: usize,
        timeout_secs: Option<u64>,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::ListGlobals {
            query,
            offset,
            limit,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Analyze strings (with xrefs).
    pub async fn analyze_strings(
        &self,
        query: Option<String>,
        offset: usize,
        limit: usize,
        timeout_secs: Option<u64>,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::AnalyzeStrings {
            query,
            offset,
            limit,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Find strings matching a query.
    pub async fn find_string(
        &self,
        query: String,
        exact: bool,
        case_insensitive: bool,
        offset: usize,
        limit: usize,
        timeout_secs: Option<u64>,
    ) -> Result<StringListResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::FindString {
            query,
            exact,
            case_insensitive,
            offset,
            limit,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Get xrefs to strings matching a query.
    #[allow(clippy::too_many_arguments)]
    pub async fn xrefs_to_string(
        &self,
        query: String,
        exact: bool,
        case_insensitive: bool,
        offset: usize,
        limit: usize,
        max_xrefs: usize,
        timeout_secs: Option<u64>,
    ) -> Result<StringXrefsResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::XrefsToString {
            query,
            exact,
            case_insensitive,
            offset,
            limit,
            max_xrefs,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Run auto-analysis (functions) and wait for completion.
    pub async fn analyze_funcs(&self, timeout_secs: Option<u64>) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::AnalyzeFuncs { resp: tx })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Find byte pattern in the database.
    pub async fn find_bytes(
        &self,
        pattern: String,
        max_results: usize,
        timeout_secs: Option<u64>,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::FindBytes {
            pattern,
            max_results,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Search text in the database.
    pub async fn search_text(
        &self,
        text: String,
        max_results: usize,
        timeout_secs: Option<u64>,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::SearchText {
            text,
            max_results,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Search immediate values in the database.
    pub async fn search_imm(
        &self,
        imm: u64,
        max_results: usize,
        timeout_secs: Option<u64>,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::SearchImm {
            imm,
            max_results,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Find instruction sequences by mnemonic patterns.
    pub async fn find_insns(
        &self,
        patterns: Vec<String>,
        max_results: usize,
        case_insensitive: bool,
        timeout_secs: Option<u64>,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::FindInsns {
            patterns,
            max_results,
            case_insensitive,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Find instruction operands by operand substring patterns.
    pub async fn find_insn_operands(
        &self,
        patterns: Vec<String>,
        max_results: usize,
        case_insensitive: bool,
        timeout_secs: Option<u64>,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::FindInsnOperands {
            patterns,
            max_results,
            case_insensitive,
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Read integer value of size (1/2/4/8) at address.
    pub async fn read_int(&self, addr: u64, size: usize) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::ReadInt {
            addr,
            size,
            resp: tx,
        })?;
        rx.await?
    }

    /// Read string at address.
    pub async fn get_string(&self, addr: u64, max_len: usize) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::GetString {
            addr,
            max_len,
            resp: tx,
        })?;
        rx.await?
    }

    /// Get value for a global (by name or address).
    pub async fn get_global_value(&self, query: String) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::GetGlobalValue { query, resp: tx })?;
        rx.await?
    }

    /// Find paths between addresses (CFG).
    pub async fn find_paths(
        &self,
        start: u64,
        end: u64,
        max_paths: usize,
        max_depth: usize,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::FindPaths {
            start,
            end,
            max_paths,
            max_depth,
            resp: tx,
        })?;
        rx.await?
    }

    /// Build a call graph rooted at a function address.
    pub async fn callgraph(
        &self,
        addr: u64,
        max_depth: usize,
        max_nodes: usize,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::CallGraph {
            addr,
            max_depth,
            max_nodes,
            resp: tx,
        })?;
        rx.await?
    }

    /// Compute xref matrix for a set of addresses.
    pub async fn xref_matrix(&self, addrs: Vec<u64>) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::XrefMatrix { addrs, resp: tx })?;
        rx.await?
    }

    /// Export functions (paginated).
    pub async fn export_funcs(
        &self,
        offset: usize,
        limit: usize,
    ) -> Result<FunctionListResult, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::ExportFuncs {
            offset,
            limit,
            resp: tx,
        })?;
        rx.await?
    }

    /// Run a Python script via IDAPython in the open database.
    pub async fn run_script(
        &self,
        code: &str,
        timeout_secs: Option<u64>,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::RunScript {
            code: code.to_string(),
            resp: tx,
        })?;
        Self::recv_with_timeout(rx, timeout_secs).await
    }

    /// Get decompiled pseudocode at a specific address or address range.
    /// If end_addr is provided, returns pseudocode for the range [addr, end_addr).
    /// Otherwise returns pseudocode for statements at the single address.
    pub async fn pseudocode_at(
        &self,
        addr: u64,
        end_addr: Option<u64>,
    ) -> Result<Value, ToolError> {
        let (tx, rx) = oneshot::channel();
        self.try_send(IdaRequest::PseudocodeAt {
            addr,
            end_addr,
            resp: tx,
        })?;
        rx.await?
    }
}

```

`src/lib.rs`:

```rs
//! Headless IDA Pro MCP Server
//!
//! This library provides an MCP (Model Context Protocol) server for headless
//! IDA Pro access. It allows LLM agents to open IDA databases, list functions,
//! get disassembly, and decompile code.
//!
//! # Architecture
//!
//! IDA **must** run on the main thread. The architecture is:
//!
//! - **Main thread**: Runs the IDA worker loop (`ida::run_ida_loop`).
//!   All idalib operations happen here.
//!
//! - **Background thread**: Runs the tokio runtime with the async MCP server.
//!   Communicates with the main thread via channels.
//!
//! - **IdaWorker**: Handle for sending requests to the main thread.
//!
//! - **IdaMcpServer**: The MCP server that exposes tools for IDA operations.
//!   Uses the `rmcp` crate for MCP protocol handling.
//!
//! # Tools
//!
//! ## Database Management
//! - `open_idb`: Open an IDA database (.i64/.idb) or a raw binary (Mach-O/ELF/PE)
//! - `load_debug_info`: Load external debug info (e.g., dSYM/DWARF)
//! - `analysis_status`: Report auto-analysis status (auto_is_ok, auto_state)
//! - `close_idb`: Close the currently open database
//!
//! ## Function Analysis
//! - `list_functions`: List all functions (paginated)
//! - `list_funcs`: Alias for list_functions (ida-pro-mcp compatibility)
//! - `resolve_function`: Find a function by name
//! - `function_at`: Find the function containing an address
//! - `lookup_funcs`: Batch lookup by name/address (ida-pro-mcp compatibility)
//! - `disasm`: Get disassembly at an address
//! - `disasm_by_name`: Get disassembly for a function by name
//! - `disasm_function_at`: Disassemble the function containing an address
//! - `decompile`: Decompile a function using Hex-Rays
//! - `pseudocode_at`: Get decompiled pseudocode at an address or address range
//! - `list_globals`: List named globals (non-function symbols)
//! - `addr_info`: Resolve address to segment/function/symbol context
//!
//! ## Binary Structure
//! - `segments`: List all segments with permissions and types
//! - `strings`: List strings with optional filter
//! - `find_string`: Find strings matching a query
//! - `analyze_strings`: Strings plus xrefs (ida-pro-mcp compatibility)
//! - `imports`: List imported symbols
//! - `exports`: List exported/public symbols
//! - `export_funcs`: Export functions list (ida-pro-mcp compatibility)
//! - `entrypoints`: Get binary entry points
//!
//! ## Cross-References
//! - `xrefs_to`: Get references TO an address
//! - `xrefs_from`: Get references FROM an address
//! - `xrefs_to_string`: Find xrefs to strings matching a query
//!
//! ## Control/Call Flow
//! - `basic_blocks`: Get CFG basic blocks for a function
//! - `callees`: Get functions called by a function
//! - `callers`: Get functions that call a function
//! - `callgraph`: Build callgraph rooted at a function
//! - `find_paths`: Find CFG paths between addresses
//! - `xref_matrix`: Build xref adjacency matrix
//!
//! ## Memory
//! - `get_bytes`: Read raw bytes from an address
//! - `get_u8/get_u16/get_u32/get_u64`: Read integer values
//! - `get_string`: Read string at address
//! - `get_global_value`: Resolve global name/address and read value
//! - `find_bytes`: Find byte patterns
//! - `search`: Search text or immediates
//! - `int_convert`: Convert integers between bases
//!
//! ## Headless limitations
//! Debugger/UI/scripting features are not exposed in headless mode.

use std::path::PathBuf;

pub mod disasm;
pub mod dsc;
pub mod error;
pub mod ida;
pub mod server;
pub mod tool_registry;

pub use error::ToolError;
pub use ida::{
    run_ida_loop, AddressInfo, BasicBlockInfo, BytesResult, DbInfo, ExportInfo, FunctionInfo,
    FunctionListResult, FunctionRangeInfo, IdaRequest, IdaWorker, ImportInfo, SegmentInfo,
    StringInfo, StringListResult, StringXrefInfo, StringXrefsResult, SymbolInfo, XRefInfo,
};
pub use server::{IdaMcpServer, ServerMode};
pub use tool_registry::{ToolCategory, ToolInfo, TOOL_REGISTRY};

/// Expand `~/` prefix to the user's home directory.
pub fn expand_path(path: &str) -> PathBuf {
    path.strip_prefix("~/")
        .and_then(|stripped| std::env::var_os("HOME").map(|h| PathBuf::from(h).join(stripped)))
        .unwrap_or_else(|| PathBuf::from(path))
}

```

`src/main.rs`:

```rs
//! Headless IDA Pro MCP Server
//!
//! This binary runs an MCP server that provides headless IDA Pro access
//! via stdin/stdout transport.
//!
//! Architecture:
//! - Main thread: Runs IDA worker loop (IDA requires main thread)
//! - Background thread: Runs tokio runtime with async MCP server

use bytes::Bytes;
use clap::{Args, Parser, Subcommand};
use http_body_util::{combinators::BoxBody, BodyExt, Full};
use hyper::http::{header::ORIGIN, Request, Response, StatusCode};
use hyper::server::conn::http1;
use hyper_util::rt::TokioIo;
use hyper_util::service::TowerToHyperService;
use ida_mcp::{
    disasm::generate_disasm_line, expand_path, ida, DbInfo, FunctionInfo, IdaMcpServer, IdaWorker,
    ServerMode,
};
use idalib::{idb::IDBOpenOptions, Address, IDB};
use rmcp::transport::stdio;
use rmcp::transport::streamable_http_server::{
    session::local::LocalSessionManager, StreamableHttpServerConfig, StreamableHttpService,
};
use rmcp::ServiceExt;
use std::net::SocketAddr;
use std::path::PathBuf;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::mpsc;
use std::sync::Arc;
use std::thread;
use std::time::{Duration, Instant};
use tokio::sync::Notify;
use tower_service::Service;
use tracing::{error, info};
use tracing_subscriber::{fmt, prelude::*, EnvFilter};

const REQUEST_QUEUE_CAPACITY: usize = 64;

#[derive(Parser)]
#[command(name = "ida-mcp", version, about = "Headless IDA Pro MCP Server")]
struct Cli {
    #[command(subcommand)]
    command: Option<Command>,
}

#[derive(Subcommand)]
enum Command {
    /// Run the MCP server (default)
    Serve,
    /// Run the MCP server over Streamable HTTP (SSE)
    ServeHttp(ServeHttpArgs),
    /// Run a direct CLI probe to exercise idalib
    Probe(ProbeArgs),
}

#[derive(Args)]
struct ServeHttpArgs {
    /// Bind address (e.g., 127.0.0.1:8765)
    #[arg(long, default_value = "127.0.0.1:8765")]
    bind: String,
    /// SSE keep-alive interval in seconds (0 disables)
    #[arg(long, default_value_t = 15)]
    sse_keep_alive_secs: u64,
    /// Use stateless mode (POST only; no sessions)
    #[arg(long)]
    stateless: bool,
    /// Allowed Origin values (comma-separated). Defaults to localhost only.
    #[arg(
        long,
        value_delimiter = ',',
        default_value = "http://localhost,http://127.0.0.1"
    )]
    allow_origin: Vec<String>,
}

#[derive(Clone)]
struct OriginCheckService<S> {
    inner: S,
    allowed_origins: Arc<std::collections::HashSet<String>>,
}

impl<S> OriginCheckService<S> {
    fn new(inner: S, allowed_origins: Arc<std::collections::HashSet<String>>) -> Self {
        Self {
            inner,
            allowed_origins,
        }
    }
}

impl<B, S> Service<Request<B>> for OriginCheckService<S>
where
    B: http_body::Body + Send + 'static,
    B::Error: std::fmt::Display,
    S: Service<
            Request<B>,
            Response = Response<BoxBody<Bytes, std::convert::Infallible>>,
            Error = std::convert::Infallible,
        > + Clone
        + Send
        + 'static,
    S::Future: Send + 'static,
{
    type Response = Response<BoxBody<Bytes, std::convert::Infallible>>;
    type Error = std::convert::Infallible;
    type Future = std::pin::Pin<
        Box<dyn std::future::Future<Output = Result<Self::Response, Self::Error>> + Send>,
    >;

    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        let allowed_origins = self.allowed_origins.clone();
        let mut inner = self.inner.clone();
        Box::pin(async move {
            if let Some(origin) = req.headers().get(ORIGIN).and_then(|v| v.to_str().ok()) {
                if !allowed_origins.contains(origin) {
                    let resp = Response::builder()
                        .status(StatusCode::FORBIDDEN)
                        .body(Full::new(Bytes::from("Forbidden")).boxed())
                        .expect("valid response");
                    return Ok(resp);
                }
            }
            inner.call(req).await
        })
    }
}

#[derive(Args)]
struct ProbeArgs {
    /// Path to the .i64/.idb database
    #[arg(long)]
    path: String,
    /// Output .i64/.idb path when opening a raw binary (defaults to <path>.i64)
    #[arg(long)]
    idb_out: Option<String>,
    /// Force auto-analysis (default: on for raw binaries, off for .i64/.idb)
    #[arg(long)]
    auto_analyse: bool,
    /// List the first N functions (optional)
    #[arg(long)]
    list: Option<usize>,
    /// Resolve a function name (optional)
    #[arg(long)]
    resolve: Option<String>,
    /// Disassemble a function by name (optional)
    #[arg(long)]
    disasm_by_name: Option<String>,
    /// Disassemble at an address (hex 0x... or decimal, optional)
    #[arg(long)]
    disasm_addr: Option<String>,
    /// Decompile a function at an address (hex 0x... or decimal, optional)
    #[arg(long)]
    decompile_addr: Option<String>,
    /// Instruction count for disassembly (default: 20)
    #[arg(long, default_value_t = 20)]
    count: usize,
    /// Enable IDA console messages (may be verbose)
    #[arg(long)]
    ida_console: bool,
}

fn main() -> anyhow::Result<()> {
    // Initialize logging to stderr (stdout is used for MCP protocol)
    tracing_subscriber::registry()
        .with(fmt::layer().with_writer(std::io::stderr))
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("ida_mcp=info")))
        .init();

    let cli = Cli::parse();
    match cli.command.unwrap_or(Command::Serve) {
        Command::Serve => run_server(),
        Command::ServeHttp(args) => run_server_http(args),
        Command::Probe(args) => run_probe(args),
    }
}

// IDA library initialization is now deferred to the worker loop's first request.
// This avoids license contention when open_dsc needs to run idat first.

async fn wait_for_shutdown_signal() -> anyhow::Result<()> {
    #[cfg(unix)]
    {
        use tokio::signal::unix::{signal, SignalKind};

        let mut sigterm = signal(SignalKind::terminate())?;
        let mut sigint = signal(SignalKind::interrupt())?;
        let mut sigquit = signal(SignalKind::quit())?;
        tokio::select! {
            _ = sigterm.recv() => {},
            _ = sigint.recv() => {},
            _ = sigquit.recv() => {},
            _ = tokio::signal::ctrl_c() => {},
        }
    }

    #[cfg(not(unix))]
    {
        tokio::signal::ctrl_c().await?;
    }

    Ok(())
}

fn run_server() -> anyhow::Result<()> {
    info!("Starting IDA MCP Server (server mode)");

    // Create channel for IDA requests
    let (tx, rx) = mpsc::sync_channel(REQUEST_QUEUE_CAPACITY);
    let worker = IdaWorker::new(tx);

    // Spawn background thread for tokio runtime and MCP server
    let worker_for_server = worker.clone();
    let worker_for_shutdown = worker.clone();
    let server_handle = thread::spawn(move || {
        // Create tokio runtime on this background thread
        let rt = tokio::runtime::Builder::new_current_thread()
            .enable_all()
            .build()
            .expect("Failed to create tokio runtime");

        rt.block_on(async move {
            info!("MCP server listening on stdio");
            let server = IdaMcpServer::new(Arc::new(worker_for_server), ServerMode::Stdio);
            let sanitized = ida_mcp::server::SanitizedIdaServer(server);
            let mut service = Some(sanitized.serve(stdio()).await?);
            let shutdown_notify = Arc::new(Notify::new());
            let shutdown_signal = shutdown_notify.clone();

            let shutdown_worker = worker_for_shutdown.clone();
            tokio::spawn(async move {
                if wait_for_shutdown_signal().await.is_ok() {
                    info!("Shutdown signal received");
                    let _ = shutdown_worker.close_for_shutdown().await;
                    let _ = shutdown_worker.shutdown().await;
                    shutdown_signal.notify_one();
                } else {
                    info!("Shutdown signal handler failed; server will continue running");
                }
            });

            loop {
                tokio::select! {
                    _ = shutdown_notify.notified() => {
                        if let Some(mut running) = service.take() {
                            let _ = running.close().await?;
                        }
                        break;
                    }
                    _ = tokio::time::sleep(Duration::from_millis(200)) => {
                        if let Some(running) = service.as_ref() {
                            if running.is_transport_closed() {
                                if let Some(running) = service.take() {
                                    let _ = running.waiting().await?;
                                }
                                break;
                            }
                        }
                    }
                }
            }
            info!("MCP server shutting down");
            let _ = worker_for_shutdown.close_for_shutdown().await;
            let _ = worker_for_shutdown.shutdown().await;
            Ok::<_, anyhow::Error>(())
        })
    });

    // Run IDA worker loop on main thread (IDA is already initialized above)
    info!("Starting IDA worker loop");
    ida::run_ida_loop(rx);
    info!("IDA worker loop finished");

    // Wait for server thread to finish
    if let Err(e) = server_handle.join() {
        error!("Server thread panicked: {:?}", e);
    }

    info!("Server stopped");
    Ok(())
}

fn run_server_http(args: ServeHttpArgs) -> anyhow::Result<()> {
    info!("Starting IDA MCP Server (streamable HTTP mode)");

    let bind_addr: SocketAddr = args
        .bind
        .parse()
        .map_err(|e| anyhow::anyhow!("invalid bind address: {e}"))?;

    let (tx, rx) = mpsc::sync_channel(REQUEST_QUEUE_CAPACITY);
    let worker = Arc::new(IdaWorker::new(tx));

    let worker_for_factory = worker.clone();
    let worker_for_shutdown = worker.clone();
    let server_handle = thread::spawn(move || {
        let rt = tokio::runtime::Builder::new_multi_thread()
            .enable_all()
            .build()
            .expect("Failed to create tokio runtime");

        let result = rt.block_on(async move {
            let session_manager = Arc::new(LocalSessionManager::default());
            let cancel = tokio_util::sync::CancellationToken::new();
            let cancel_for_config = cancel.clone();
            let config = StreamableHttpServerConfig {
                sse_keep_alive: if args.sse_keep_alive_secs == 0 {
                    None
                } else {
                    Some(Duration::from_secs(args.sse_keep_alive_secs))
                },
                sse_retry: None,
                stateful_mode: !args.stateless,
                cancellation_token: cancel_for_config,
            };

            let service = StreamableHttpService::new(
                move || {
                    Ok(ida_mcp::server::SanitizedIdaServer(IdaMcpServer::new(
                        worker_for_factory.clone(),
                        ServerMode::Http,
                    )))
                },
                session_manager,
                config,
            );
            let allowed_origins: std::collections::HashSet<String> = args
                .allow_origin
                .iter()
                .map(|s| s.trim().to_string())
                .filter(|s| !s.is_empty())
                .collect();
            let allowed_origins = Arc::new(allowed_origins);
            let service = OriginCheckService::new(service, allowed_origins);

            let listener = tokio::net::TcpListener::bind(bind_addr)
                .await
                .map_err(|e| anyhow::anyhow!("bind failed: {e}"))?;
            info!("MCP HTTP server listening on http://{bind_addr}");

            let shutdown_worker = worker_for_shutdown.clone();
            let cancel_for_shutdown = cancel.clone();
            tokio::spawn(async move {
                if wait_for_shutdown_signal().await.is_ok() {
                    info!("Shutdown signal received");
                    let _ = shutdown_worker.close_for_shutdown().await;
                    let _ = shutdown_worker.shutdown().await;
                    cancel_for_shutdown.cancel();
                }
            });

            loop {
                tokio::select! {
                    _ = cancel.cancelled() => {
                        info!("HTTP server shutting down");
                        break;
                    }
                    res = listener.accept() => {
                        let (stream, _) = res.map_err(|e| anyhow::anyhow!("accept failed: {e}"))?;
                        let svc = service.clone();
                        tokio::spawn(async move {
                            let io = TokioIo::new(stream);
                            let conn = http1::Builder::new().serve_connection(
                                io,
                                TowerToHyperService::new(svc),
                            );
                            if let Err(err) = conn.await {
                                tracing::error!("http connection error: {err}");
                            }
                        });
                    }
                }
            }
            #[allow(unreachable_code)]
            Ok::<_, anyhow::Error>(())
        });
        if let Err(err) = result {
            error!("HTTP server error: {err}");
        }
    });

    info!("Starting IDA worker loop");
    ida::run_ida_loop(rx);
    info!("IDA worker loop finished");

    if let Err(e) = server_handle.join() {
        error!("Server thread panicked: {:?}", e);
    }

    info!("Server stopped");
    Ok(())
}

fn run_probe(args: ProbeArgs) -> anyhow::Result<()> {
    info!("Starting IDA MCP Server (probe mode)");
    if let Ok(idadir) = std::env::var("IDADIR") {
        info!("IDADIR={}", idadir);
    }
    info!("Initializing IDA library on main thread");
    idalib::init_library();
    info!("IDA library initialized successfully");
    if let Ok(ver) = idalib::version() {
        info!(
            "IDA version {}.{}.{}",
            ver.major(),
            ver.minor(),
            ver.build()
        );
    }
    if args.ida_console {
        idalib::enable_console_messages(true);
        info!("IDA console messages enabled");
    }

    let path = expand_path(&args.path);
    info!("Opening database: {}", path.display());

    let done = Arc::new(AtomicBool::new(false));
    let done_clone = done.clone();
    let path_display = path.display().to_string();
    let ticker = thread::spawn(move || {
        let start = Instant::now();
        loop {
            thread::sleep(Duration::from_secs(10));
            if done_clone.load(Ordering::Relaxed) {
                break;
            }
            info!(
                path = %path_display,
                elapsed = start.elapsed().as_secs(),
                "Still opening database..."
            );
        }
    });

    let open_start = Instant::now();
    let db = open_db_for_probe(&path, &args);
    done.store(true, Ordering::Relaxed);
    let _ = ticker.join();
    let db =
        db.map_err(|e| anyhow::anyhow!("Failed to open database: {}: {}", path.display(), e))?;

    let meta = db.meta();
    let info = DbInfo {
        path: path.display().to_string(),
        file_type: format!("{:?}", meta.filetype()),
        processor: db.processor().long_name(),
        bits: if meta.is_64bit() {
            64
        } else if meta.is_32bit_exactly() {
            32
        } else {
            16
        },
        function_count: db.function_count(),
        debug_info: None,
        analysis_status: ida::handlers::analysis::build_analysis_status(&db),
    };
    info!("Database opened in {}s", open_start.elapsed().as_secs());
    println!("{}", serde_json::to_string_pretty(&info)?);

    if let Some(limit) = args.list {
        let list = list_functions(&db, 0, limit);
        println!("{}", serde_json::to_string_pretty(&list)?);
    }

    if let Some(name) = args.resolve.as_deref() {
        let func = resolve_function(&db, name)?;
        println!("{}", serde_json::to_string_pretty(&func)?);
    }

    if let Some(name) = args.disasm_by_name.as_deref() {
        let text = disasm_by_name(&db, name, args.count)?;
        println!("{}", text);
    }

    if let Some(addr_str) = args.disasm_addr.as_deref() {
        let addr = parse_address(addr_str)?;
        let text = disasm_at(&db, addr, args.count)?;
        println!("{}", text);
    }

    if let Some(addr_str) = args.decompile_addr.as_deref() {
        let addr = parse_address(addr_str)?;
        let func = db
            .function_at(addr)
            .ok_or_else(|| anyhow::anyhow!("Function not found at address {:#x}", addr))?;
        if !db.decompiler_available() {
            return Err(anyhow::anyhow!("Decompiler not available"));
        }
        let cfunc = db
            .decompile(&func)
            .map_err(|e| anyhow::anyhow!("Decompile failed: {}", e))?;
        println!("{}", cfunc.pseudocode());
    }

    info!("Probe completed");
    Ok(())
}

fn open_db_for_probe(path: &PathBuf, args: &ProbeArgs) -> Result<IDB, idalib::IDAError> {
    let ext = path
        .extension()
        .and_then(|e| e.to_str())
        .unwrap_or("")
        .to_ascii_lowercase();
    let is_idb = ext == "i64" || ext == "idb";

    if is_idb {
        if args.auto_analyse {
            info!("Opening existing IDB with auto-analysis enabled");
            IDB::open_with(path, true, true) // auto_analyse=true, save=true to pack on close
        } else {
            IDB::open_with(path, false, true) // save=true to pack on close
        }
    } else {
        let mut opts = IDBOpenOptions::new();
        opts.auto_analyse(true);
        let out_path = if let Some(out) = args.idb_out.as_deref() {
            PathBuf::from(out)
        } else {
            path.with_extension("i64")
        };
        info!(
            "Opening raw binary with auto-analysis (idb_out={})",
            out_path.display()
        );
        opts.idb(&out_path).save(true).open(path)
    }
}

fn parse_address(s: &str) -> anyhow::Result<u64> {
    let s = s.trim();
    if s.starts_with("0x") || s.starts_with("0X") {
        u64::from_str_radix(&s[2..], 16)
            .map_err(|_| anyhow::anyhow!("Invalid address format: {}", s))
    } else {
        s.parse::<u64>()
            .map_err(|_| anyhow::anyhow!("Invalid address format: {}", s))
    }
}

fn list_functions(db: &IDB, offset: usize, limit: usize) -> ida_mcp::FunctionListResult {
    let total = db.function_count();
    let mut functions = Vec::with_capacity(limit.min(total.saturating_sub(offset)));

    for (idx, (_id, func)) in db.functions().enumerate() {
        if idx < offset {
            continue;
        }
        if functions.len() >= limit {
            break;
        }

        let addr = func.start_address();
        let name = func.name().unwrap_or_else(|| format!("sub_{:x}", addr));
        let size = func.len();

        functions.push(FunctionInfo {
            address: format!("{:#x}", addr),
            name,
            size,
        });
    }

    let next_offset = if offset + functions.len() < total {
        Some(offset + functions.len())
    } else {
        None
    };

    ida_mcp::FunctionListResult {
        functions,
        total,
        next_offset,
    }
}

fn resolve_function(db: &IDB, name: &str) -> anyhow::Result<FunctionInfo> {
    for (_id, func) in db.functions() {
        if let Some(func_name) = func.name() {
            if func_name == name || func_name.contains(name) {
                let addr = func.start_address();
                let size = func.len();
                return Ok(FunctionInfo {
                    address: format!("{:#x}", addr),
                    name: func_name,
                    size,
                });
            }
        }
    }

    Err(anyhow::anyhow!("Function not found: {}", name))
}

fn disasm_by_name(db: &IDB, name: &str, count: usize) -> anyhow::Result<String> {
    let func = resolve_function(db, name)?;
    let addr = parse_address(&func.address)?;
    disasm_at(db, addr, count)
}

fn disasm_at(db: &IDB, addr: Address, count: usize) -> anyhow::Result<String> {
    let mut lines = Vec::with_capacity(count);
    let mut current_addr: Address = addr;

    for _ in 0..count {
        if let Some(line) = generate_disasm_line(db, current_addr) {
            lines.push(format!("{:#x}:\t{}", current_addr, line));
        } else {
            break;
        }

        if let Some(insn) = db.insn_at(current_addr) {
            current_addr += insn.len() as u64;
        } else if let Some(next) = db.next_head(current_addr) {
            if next <= current_addr {
                break;
            }
            current_addr = next;
        } else {
            break;
        }
    }

    if lines.is_empty() {
        return Err(anyhow::anyhow!("Address out of range: {:#x}", addr));
    }

    Ok(lines.join("\n"))
}

```

`src/server/mod.rs`:

```rs
//! MCP server implementation with IDA Pro tools.

mod requests;
pub mod task;

pub use requests::*;

use crate::error::ToolError;
use crate::ida::IdaWorker;
use crate::tool_registry::{self, ToolCategory};
use rmcp::{
    handler::server::{router::tool::ToolRouter, tool::ToolCallContext, wrapper::Parameters},
    model::{CallToolResult, Content, ServerCapabilities, ServerInfo, Tool},
    schemars::{schema_for, JsonSchema},
    tool, tool_handler, tool_router, ErrorData as McpError, ServerHandler,
};
use serde_json::{json, Value};
use std::sync::Arc;
use tracing::{debug, info, instrument, warn};

/// MCP server for IDA Pro analysis
#[derive(Clone)]
pub struct IdaMcpServer {
    worker: Arc<IdaWorker>,
    tool_mux: ToolMux<IdaMcpServer>,
    mode: ServerMode,
    task_registry: task::TaskRegistry,
}

#[derive(Clone, Copy, Debug)]
pub enum ServerMode {
    Stdio,
    Http,
}

#[derive(Clone)]
struct ToolMux<S> {
    call_router: ToolRouter<S>,
}

impl<S> ToolMux<S>
where
    S: Send + Sync + 'static,
{
    fn new(call_router: ToolRouter<S>) -> Self {
        Self { call_router }
    }

    async fn call(
        &self,
        context: ToolCallContext<'_, S>,
    ) -> Result<CallToolResult, rmcp::ErrorData> {
        self.call_router.call(context).await
    }

    fn list_all(&self) -> Vec<Tool> {
        let mut tools = Vec::new();
        for info in tool_registry::all_tools() {
            if let Some(route) = self.call_router.map.get(info.name) {
                tools.push(route.attr.clone());
            }
        }
        tools
    }

    fn get(&self, name: &str) -> Option<&Tool> {
        self.call_router.map.get(name).map(|route| &route.attr)
    }
}

/// Parameters for the background DSC loading task.
struct DscBackgroundCtx {
    idat: std::path::PathBuf,
    idat_args: Vec<String>,
    script_path: std::path::PathBuf,
    log_path: Option<std::path::PathBuf>,
    out_i64: std::path::PathBuf,
    module: String,
    frameworks: Vec<String>,
}

impl IdaMcpServer {
    pub fn new(worker: Arc<IdaWorker>, mode: ServerMode) -> Self {
        info!("Creating IDA MCP server");
        let call_router = Self::tool_router();
        Self {
            worker,
            tool_mux: ToolMux::new(call_router),
            mode,
            task_registry: task::TaskRegistry::new(),
        }
    }

    fn close_hint(&self) -> &'static str {
        match self.mode {
            ServerMode::Stdio => {
                "Call close_idb when done to release locks for other sessions."
            }
            ServerMode::Http => {
                "In multi-client (HTTP/SSE) mode, close_idb requires the close_token returned by open_idb; only the opener should close."
            }
        }
    }

    fn instructions(&self) -> String {
        format!(
            "IDA Pro headless analysis server for reverse engineering binaries. \
                 \n\nWorkflow: \
                 \n1. open_idb: Open a .i64/.idb file or a raw binary (Mach-O/ELF/PE). Large DBs may take 30+ seconds. \
                 \n   load_debug_info: Optional for existing .i64 to load DWARF/dSYM \
                 \n2. tool_catalog: Discover tools for your task (e.g., 'find callers', 'decompile') \
                 \n3. tool_help: Get full docs for a specific tool \
                 \n4. Use the discovered tools to analyze the binary \
                 \n5. close_idb: Optionally close when done \
                 \n\nNote: tools/list exposes the full tool set by default; use tool_catalog/tool_help to discover usage. \
                 \n{close_hint} \
                 \n\nTool Categories: \
                 \n- core: open/close/discover (open_idb, close_idb, tool_catalog, tool_help, idb_meta) \
                 \n- functions: list, resolve, lookup functions \
                 \n- disassembly: disasm at addresses \
                 \n- decompile: Hex-Rays pseudocode \
                 \n- xrefs: cross-reference analysis \
                 \n- control_flow: CFG, callgraph, paths \
                 \n- memory: read bytes, strings, values \
                 \n- search: find patterns, strings \
                 \n- metadata: segments, imports, exports \
                 \n- types: declare_type, apply_types (addr/stack), infer_types, local_types, stack_frame, declare_stack, delete_stack, structs (list/info/read) \
                \n- editing: comments/rename/patch/patch_asm \
                 \n- scripting: run_script (execute IDAPython code) \
                 \n\nTip: Use tool_catalog(query='what you want to do') to find the right tool. \
                 \nTip: If xrefs/decompile look incomplete, call analysis_status to check auto-analysis.",
            close_hint = self.close_hint()
        )
    }

    fn validate_path(path: &str) -> bool {
        let path = path.trim();
        let expanded = if let Some(stripped) = path.strip_prefix("~/") {
            if let Some(home) = std::env::var_os("HOME") {
                std::path::PathBuf::from(home).join(stripped)
            } else {
                return false;
            }
        } else {
            std::path::PathBuf::from(path)
        };
        let p = expanded.as_path();
        // Check: exists, is file, no path traversal
        // IDA can open many formats: .i64, .idb, ELF, Mach-O, PE, raw binaries, etc.
        p.exists() && p.is_file() && !path.contains("..")
    }

    fn parse_address(s: &str) -> Result<u64, ToolError> {
        let mut s = s.trim().to_string();
        s.retain(|c| c != '_');
        if s.starts_with("0x") || s.starts_with("0X") {
            u64::from_str_radix(&s[2..], 16).map_err(|_| ToolError::InvalidAddress(s))
        } else if s.starts_with("0b") || s.starts_with("0B") {
            u64::from_str_radix(&s[2..], 2).map_err(|_| ToolError::InvalidAddress(s))
        } else if s.starts_with("0o") || s.starts_with("0O") {
            u64::from_str_radix(&s[2..], 8).map_err(|_| ToolError::InvalidAddress(s))
        } else {
            s.parse()
                .map_err(|_| ToolError::InvalidAddress(s.to_string()))
        }
    }

    fn value_to_strings(value: &Value) -> Result<Vec<String>, ToolError> {
        match value {
            Value::String(s) => {
                if s.contains(',') {
                    Ok(s.split(',')
                        .map(|t| t.trim())
                        .filter(|t| !t.is_empty())
                        .map(|t| t.to_string())
                        .collect())
                } else if s.trim().is_empty() {
                    Err(ToolError::IdaError("empty string".to_string()))
                } else {
                    Ok(vec![s.to_string()])
                }
            }
            Value::Number(n) => Ok(vec![n.to_string()]),
            Value::Array(arr) => {
                let mut out = Vec::with_capacity(arr.len());
                for v in arr {
                    match v {
                        Value::String(s) => out.push(s.to_string()),
                        Value::Number(n) => out.push(n.to_string()),
                        _ => {
                            return Err(ToolError::IdaError(
                                "expected string or number".to_string(),
                            ))
                        }
                    }
                }
                Ok(out)
            }
            _ => Err(ToolError::IdaError(
                "expected string, number, or array".to_string(),
            )),
        }
    }

    fn value_to_addresses(value: &Value) -> Result<Vec<u64>, ToolError> {
        let strings = Self::value_to_strings(value)?;
        if strings.is_empty() {
            return Err(ToolError::InvalidAddress(
                "no addresses provided".to_string(),
            ));
        }
        strings.iter().map(|s| Self::parse_address(s)).collect()
    }

    fn value_to_single_address(value: &Value) -> Result<u64, ToolError> {
        let addrs = Self::value_to_addresses(value)?;
        addrs
            .into_iter()
            .next()
            .ok_or_else(|| ToolError::InvalidAddress("empty address list".to_string()))
    }

    fn value_to_bytes(value: &Value) -> Result<Vec<u8>, ToolError> {
        match value {
            Value::String(s) => {
                let mut cleaned = String::with_capacity(s.len());
                for c in s.chars() {
                    if c.is_ascii_hexdigit() {
                        cleaned.push(c);
                    } else if c.is_ascii_whitespace()
                        || matches!(c, ',' | '_' | ':' | '-')
                        || c == 'x'
                        || c == 'X'
                    {
                        continue;
                    } else {
                        return Err(ToolError::InvalidParams(format!(
                            "invalid hex character: {c}"
                        )));
                    }
                }
                if cleaned.is_empty() {
                    return Err(ToolError::InvalidParams("no bytes provided".to_string()));
                }
                if !cleaned.len().is_multiple_of(2) {
                    return Err(ToolError::InvalidParams(
                        "hex string has odd length".to_string(),
                    ));
                }
                let mut out = Vec::with_capacity(cleaned.len() / 2);
                for i in (0..cleaned.len()).step_by(2) {
                    let byte = u8::from_str_radix(&cleaned[i..i + 2], 16)
                        .map_err(|_| ToolError::InvalidParams("invalid hex byte".to_string()))?;
                    out.push(byte);
                }
                Ok(out)
            }
            Value::Array(arr) => {
                let mut out = Vec::with_capacity(arr.len());
                for v in arr {
                    match v {
                        Value::Number(n) => {
                            let byte = n.as_u64().ok_or_else(|| {
                                ToolError::InvalidParams("invalid byte".to_string())
                            })?;
                            if byte > u8::MAX as u64 {
                                return Err(ToolError::InvalidParams(
                                    "byte value out of range".to_string(),
                                ));
                            }
                            out.push(byte as u8);
                        }
                        Value::String(s) => {
                            let val = Self::parse_address(s)?;
                            if val > u8::MAX as u64 {
                                return Err(ToolError::InvalidParams(
                                    "byte value out of range".to_string(),
                                ));
                            }
                            out.push(val as u8);
                        }
                        _ => {
                            return Err(ToolError::InvalidParams(
                                "bytes must be numbers or strings".to_string(),
                            ))
                        }
                    }
                }
                if out.is_empty() {
                    Err(ToolError::InvalidParams("no bytes provided".to_string()))
                } else {
                    Ok(out)
                }
            }
            Value::Number(n) => {
                let byte = n
                    .as_u64()
                    .ok_or_else(|| ToolError::InvalidParams("invalid byte".to_string()))?;
                if byte > u8::MAX as u64 {
                    return Err(ToolError::InvalidParams(
                        "byte value out of range".to_string(),
                    ));
                }
                Ok(vec![byte as u8])
            }
            _ => Err(ToolError::InvalidParams(
                "expected hex string or array of bytes".to_string(),
            )),
        }
    }

    /// Open an existing DSC .i64 synchronously and return db_info.
    async fn open_dsc_i64(
        &self,
        out_i64: &std::path::Path,
        module: &str,
        frameworks: &[String],
    ) -> Result<CallToolResult, McpError> {
        info!(out_i64 = %out_i64.display(), "Opening existing DSC .i64");

        let i64_str = out_i64.display().to_string();
        let open_result = self
            .worker
            .open(&i64_str, false, None, false, false, None, true, Vec::new())
            .await;

        let db_info = match open_result {
            Ok(info) => info,
            Err(e) => return Ok(e.to_tool_result()),
        };

        let close_token = if matches!(self.mode, ServerMode::Http) {
            self.worker.issue_close_token()
        } else {
            None
        };

        let mut value = match serde_json::to_value(&db_info) {
            Ok(v) => v,
            Err(_) => {
                return Ok(CallToolResult::success(vec![Content::text(format!(
                    "{db_info:?}"
                ))]))
            }
        };
        if let Value::Object(map) = &mut value {
            map.insert("module".to_string(), json!(module));
            if !frameworks.is_empty() {
                map.insert("frameworks_loaded".to_string(), json!(frameworks));
            }
            map.insert("close_hint".to_string(), json!(self.close_hint()));
            if let Some(token) = close_token {
                map.insert("close_token".to_string(), json!(token));
            }
        }

        Ok(CallToolResult::success(vec![Content::text(
            serde_json::to_string_pretty(&value).unwrap_or_else(|_| format!("{value:?}")),
        )]))
    }

    /// Background task: run idat, then open the resulting .i64 with idalib.
    async fn run_dsc_background(
        task_id: String,
        registry: task::TaskRegistry,
        worker: Arc<IdaWorker>,
        mode: ServerMode,
        ctx: DscBackgroundCtx,
    ) {
        let DscBackgroundCtx {
            idat,
            idat_args,
            script_path,
            log_path,
            out_i64,
            module,
            frameworks,
        } = ctx;

        // Phase 1: run idat subprocess
        info!(task_id = %task_id, "Background: running idat");
        registry.update_message(&task_id, "Running idat to create .i64...");

        let idat_bin = idat;
        let module_env = module.clone();
        let out_i64_clone = out_i64.clone();
        let log_path_clone = log_path.clone();

        let spawn_result = tokio::task::spawn_blocking(move || {
            let mut cmd = std::process::Command::new(&idat_bin);
            cmd.args(&idat_args);
            // Remove env vars that cause license conflicts when our
            // process links idalib and also spawns idat.
            cmd.env_remove("IDADIR");
            cmd.env_remove("DYLD_LIBRARY_PATH");
            cmd.env("IDA_DYLD_CACHE_MODULE", &module_env);
            cmd.stdout(std::process::Stdio::piped());
            cmd.stderr(std::process::Stdio::piped());

            let output = cmd.output();

            match output {
                Ok(out) => {
                    let code = out.status.code().unwrap_or(-1);
                    let stderr = String::from_utf8_lossy(&out.stderr);
                    (code, stderr.to_string(), out_i64_clone, log_path_clone)
                }
                Err(e) => (
                    -1,
                    format!("Failed to spawn idat: {e}"),
                    out_i64_clone,
                    log_path_clone,
                ),
            }
        })
        .await;

        let (exit_code, stderr, out_path, log_out) = match spawn_result {
            Ok(tuple) => tuple,
            Err(e) => {
                let _ = std::fs::remove_file(&script_path);
                registry.fail(&task_id, &format!("idat task panicked: {e}"));
                return;
            }
        };

        // Clean up the temporary load script (idat is done with it).
        let _ = std::fs::remove_file(&script_path);

        if exit_code != 0 || !out_path.exists() {
            let log_tail = log_out
                .as_ref()
                .and_then(|p| std::fs::read_to_string(p).ok())
                .map(|s| {
                    let lines: Vec<&str> = s.lines().collect();
                    let start = lines.len().saturating_sub(20);
                    lines[start..].join("\n")
                });

            let mut msg = format!("idat exited with code {exit_code}.\nstderr: {stderr}");
            if let Some(tail) = log_tail {
                msg.push_str(&format!("\nlog (last 20 lines):\n{tail}"));
            }
            warn!(exit_code, task_id = %task_id, "idat failed");
            registry.fail(&task_id, &msg);
            return;
        }

        info!(task_id = %task_id, "idat completed, opening .i64");
        registry.update_message(&task_id, "Opening database with idalib...");

        // Phase 2: open the .i64 with idalib
        let i64_str = out_i64.display().to_string();
        let open_result = worker
            .open(&i64_str, false, None, false, false, None, true, Vec::new())
            .await;

        let db_info = match open_result {
            Ok(info) => info,
            Err(e) => {
                registry.fail(&task_id, &e.to_string());
                return;
            }
        };

        let close_token = if matches!(mode, ServerMode::Http) {
            worker.issue_close_token()
        } else {
            None
        };

        let mut value = serde_json::to_value(&db_info)
            .unwrap_or_else(|_| json!({"info": format!("{db_info:?}")}));
        if let Value::Object(map) = &mut value {
            map.insert("module".to_string(), json!(module));
            if !frameworks.is_empty() {
                map.insert("frameworks_loaded".to_string(), json!(frameworks));
            }
            if let Some(token) = close_token {
                map.insert("close_token".to_string(), json!(token));
            }
        }

        info!(task_id = %task_id, "DSC background task completed");
        registry.complete(&task_id, value);
    }
}

// Tool implementations using the #[tool_router] attribute

#[tool_router]
impl IdaMcpServer {
    #[tool(
        description = "Open an IDA Pro database (.i64/.idb) or a raw binary (Mach-O/ELF/PE). \
        Raw binaries are auto-analyzed and saved as .i64 alongside the input. \
        If opening a raw binary with no existing .i64 and a sibling .dSYM is present, \
        its DWARF debug info is loaded automatically. \
        Set load_debug_info=true to force loading external debug info after open \
        (optionally specify debug_info_path). \
        Call close_idb when finished to release database locks; in multi-client servers, coordinate before closing. \
        In HTTP/SSE mode, open_idb returns a close_token that must be provided to close_idb. \
        NOTE: Opening large databases (like dyld_shared_cache) can take 30+ seconds. \
        The database stays open until close_idb is called, so you can make multiple \
        queries (list_functions, disasm, decompile, etc.) without reopening."
    )]
    #[instrument(skip(self), fields(path = %req.path))]
    async fn open_idb(
        &self,
        Parameters(req): Parameters<OpenIdbRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: open_idb");
        // Validate path (prevent directory traversal, check extension)
        if !Self::validate_path(&req.path) {
            return Ok(ToolError::InvalidPath(req.path).to_tool_result());
        }

        match self
            .worker
            .open(
                &req.path,
                req.load_debug_info.unwrap_or(false),
                req.debug_info_path.clone(),
                req.debug_info_verbose.unwrap_or(false),
                req.force.unwrap_or(false),
                req.file_type.clone(),
                true,
                Vec::new(),
            )
            .await
        {
            Ok(info) => {
                let close_token = if matches!(self.mode, ServerMode::Http) {
                    self.worker.issue_close_token()
                } else {
                    None
                };
                let mut value = match serde_json::to_value(&info) {
                    Ok(v) => v,
                    Err(_) => {
                        return Ok(CallToolResult::success(vec![Content::text(format!(
                            "{info:?}"
                        ))]))
                    }
                };
                if let Value::Object(map) = &mut value {
                    map.insert(
                        "quick_tools".to_string(),
                        json!([
                            "list_functions",
                            "resolve_function",
                            "disasm_by_name",
                            "decompile",
                            "xrefs_to",
                            "strings",
                            "close_idb"
                        ]),
                    );
                    map.insert("close_hint".to_string(), json!(self.close_hint()));
                    if let Some(token) = close_token {
                        map.insert("close_token".to_string(), json!(token));
                    }
                }
                Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&value).unwrap_or_else(|_| format!("{value:?}")),
                )]))
            }
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(
        description = "Load external debug info (e.g., DWARF/dSYM) into the current database. \
        If path is omitted, attempts to locate a sibling .dSYM for the currently-open database."
    )]
    #[instrument(skip(self))]
    async fn load_debug_info(
        &self,
        Parameters(req): Parameters<LoadDebugInfoRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: load_debug_info");
        match self
            .worker
            .load_debug_info(req.path, req.verbose.unwrap_or(false))
            .await
        {
            Ok(info) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&info).unwrap_or_else(|_| format!("{info:?}")),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Report auto-analysis status (auto_is_ok, auto_state). \
        Use this to check whether analysis-dependent tools (xrefs, decompile) are fully ready.")]
    #[instrument(skip(self))]
    async fn analysis_status(&self) -> Result<CallToolResult, McpError> {
        debug!("Tool call: analysis_status");
        match self.worker.analysis_status().await {
            Ok(status) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&status).unwrap_or_else(|_| format!("{status:?}")),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Close the currently open IDA database. \
        Call this when you're done analyzing to free resources. \
        In HTTP/SSE mode, provide the close_token returned by open_idb. \
        The database can also be left open for the duration of the session.")]
    #[instrument(skip(self))]
    async fn close_idb(
        &self,
        Parameters(req): Parameters<CloseIdbRequest>,
    ) -> Result<CallToolResult, McpError> {
        info!("Tool call: close_idb received");
        if matches!(self.mode, ServerMode::Http)
            && !self.worker.close_token_matches(req.token.as_deref())
        {
            info!("close_idb ignored: owner token required");
            return Ok(CallToolResult::success(vec![Content::text(
                "close_idb ignored: owner token required",
            )]));
        }
        match self.worker.close().await {
            Ok(()) => {
                self.worker.clear_close_token();
                info!("Tool call: close_idb completed successfully");
                Ok(CallToolResult::success(vec![Content::text(
                    "Database closed",
                )]))
            }
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Discover available tools by query or category. \
        Use this to find the right tool for your task before calling tool_help for full details.")]
    #[instrument(skip(self))]
    async fn tool_catalog(
        &self,
        Parameters(req): Parameters<ToolCatalogRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: tool_catalog");
        let limit = req.limit.unwrap_or(7).min(15);

        // If category specified, list tools in that category
        if let Some(cat_str) = &req.category {
            if let Ok(cat) = cat_str.parse::<ToolCategory>() {
                let tools: Vec<_> = tool_registry::tools_by_category(cat)
                    .take(limit)
                    .map(|t| {
                        json!({
                            "name": t.name,
                            "description": t.short_desc,
                            "category": t.category.as_str(),
                        })
                    })
                    .collect();

                return Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&json!({
                        "category": cat.as_str(),
                        "category_description": cat.description(),
                        "tools": tools,
                        "hint": "Use tool_help(name) for full documentation and examples"
                    }))
                    .unwrap(),
                )]));
            }
        }

        // If query specified, search for matching tools
        if let Some(query) = &req.query {
            let results = tool_registry::search_tools(query, limit);
            let tools: Vec<_> = results
                .iter()
                .map(|(t, keywords)| {
                    json!({
                        "name": t.name,
                        "description": t.short_desc,
                        "category": t.category.as_str(),
                        "matched": keywords,
                    })
                })
                .collect();

            return Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({
                    "query": query,
                    "tools": tools,
                    "hint": "Use tool_help(name) for full documentation and examples"
                }))
                .unwrap(),
            )]));
        }

        // No query or category - list all categories
        let categories: Vec<_> = ToolCategory::all()
            .iter()
            .map(|c| {
                let count = tool_registry::tools_by_category(*c).count();
                json!({
                    "category": c.as_str(),
                    "description": c.description(),
                    "tool_count": count,
                })
            })
            .collect();

        Ok(CallToolResult::success(vec![Content::text(
            serde_json::to_string_pretty(&json!({
                "categories": categories,
                "hint": "Use tool_catalog(category='...') to list tools in a category, or tool_catalog(query='...') to search. tools/list already includes all tools."
            }))
            .unwrap(),
        )]))
    }

    #[tool(
        description = "Get full documentation for a tool including description, parameters schema, and example."
    )]
    #[instrument(skip(self))]
    async fn tool_help(
        &self,
        Parameters(req): Parameters<ToolHelpRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: tool_help for {}", req.name);

        if let Some(tool) = tool_registry::get_tool(&req.name) {
            let params = tool_params_schema(&req.name);
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({
                    "name": tool.name,
                    "category": tool.category.as_str(),
                    "description": tool.full_desc,
                    "parameters": params,
                    "example": tool.example,
                    "keywords": tool.keywords,
                }))
                .unwrap(),
            )]))
        } else {
            // Suggest similar tools
            let suggestions = tool_registry::search_tools(&req.name, 3);
            let suggestion_names: Vec<_> = suggestions.iter().map(|(t, _)| t.name).collect();

            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({
                    "error": format!("Tool '{}' not found", req.name),
                    "suggestions": suggestion_names,
                    "hint": "Use tool_catalog to discover available tools"
                }))
                .unwrap(),
            )]))
        }
    }

    #[tool(description = "List all functions in the database (paginated). \
        For large databases, consider setting timeout_secs (default: 120, max: 600).")]
    #[instrument(skip(self), fields(offset = req.offset, limit = req.limit))]
    async fn list_functions(
        &self,
        Parameters(req): Parameters<ListFunctionsRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: list_functions");
        // Clamp limit to prevent excessive responses
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);
        let filter = req.filter.clone();

        match self
            .worker
            .list_functions(offset, limit, filter, req.timeout_secs)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "List functions (ida-pro-mcp compatible alias). \
        For large databases, consider setting timeout_secs (default: 120, max: 600).")]
    #[instrument(skip(self), fields(offset = req.offset, limit = req.limit, filter = ?req.filter))]
    async fn list_funcs(
        &self,
        Parameters(req): Parameters<ListFunctionsRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: list_funcs");
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);
        let filter = req.filter.clone();

        match self
            .worker
            .list_functions(offset, limit, filter, req.timeout_secs)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Resolve a function name to its address")]
    #[instrument(skip(self), fields(name = %req.name))]
    async fn resolve_function(
        &self,
        Parameters(req): Parameters<ResolveFunctionRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: resolve_function");
        match self.worker.resolve_function(&req.name).await {
            Ok(info) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&info).unwrap_or_else(|_| format!("{:?}", info)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Get address context (segment, function, nearest symbol)")]
    async fn addr_info(
        &self,
        Parameters(req): Parameters<AddrInfoRequest>,
    ) -> Result<CallToolResult, McpError> {
        let addr = match req.address.as_ref() {
            Some(val) => match Self::value_to_single_address(val) {
                Ok(v) => Some(v),
                Err(e) => return Ok(e.to_tool_result()),
            },
            None => None,
        };
        let offset = req.offset.unwrap_or(0);
        match self
            .worker
            .addr_info(addr, req.target_name.clone(), offset)
            .await
        {
            Ok(info) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&info).unwrap_or_else(|_| format!("{:?}", info)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Get the function that contains an address")]
    async fn function_at(
        &self,
        Parameters(req): Parameters<FunctionAtRequest>,
    ) -> Result<CallToolResult, McpError> {
        let addr = match req.address.as_ref() {
            Some(val) => match Self::value_to_single_address(val) {
                Ok(v) => Some(v),
                Err(e) => return Ok(e.to_tool_result()),
            },
            None => None,
        };
        let offset = req.offset.unwrap_or(0);
        match self
            .worker
            .function_at(addr, req.target_name.clone(), offset)
            .await
        {
            Ok(info) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&info).unwrap_or_else(|_| format!("{:?}", info)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Get disassembly at an address")]
    #[instrument(skip(self), fields(address = %req.address, count = req.count))]
    async fn disasm(
        &self,
        Parameters(req): Parameters<DisasmRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: disasm");
        // Clamp instruction count
        let count = req.count.unwrap_or(10).min(1000);
        let addrs = match Self::value_to_addresses(&req.address) {
            Ok(a) => a,
            Err(e) => return Ok(e.to_tool_result()),
        };

        if addrs.len() == 1 {
            match self.worker.disasm(addrs[0], count).await {
                Ok(text) => Ok(CallToolResult::success(vec![Content::text(text)])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for addr in addrs {
                match self.worker.disasm(addr, count).await {
                    Ok(text) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "disasm": text
                    })),
                    Err(e) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(description = "Get disassembly for a function by name")]
    #[instrument(skip(self), fields(name = %req.name, count = req.count))]
    async fn disasm_by_name(
        &self,
        Parameters(req): Parameters<DisasmByNameRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: disasm_by_name");
        let count = req.count.unwrap_or(10).min(1000);

        match self.worker.disasm_by_name(&req.name, count).await {
            Ok(text) => Ok(CallToolResult::success(vec![Content::text(text)])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Disassemble the function containing an address")]
    async fn disasm_function_at(
        &self,
        Parameters(req): Parameters<DisasmFunctionAtRequest>,
    ) -> Result<CallToolResult, McpError> {
        let addr = match req.address.as_ref() {
            Some(val) => match Self::value_to_single_address(val) {
                Ok(v) => Some(v),
                Err(e) => return Ok(e.to_tool_result()),
            },
            None => None,
        };
        let offset = req.offset.unwrap_or(0);
        let count = req.count.unwrap_or(200).min(5000);
        match self
            .worker
            .disasm_function_at(addr, req.target_name.clone(), offset, count)
            .await
        {
            Ok(text) => Ok(CallToolResult::success(vec![Content::text(text)])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Decompile a function using Hex-Rays (if available)")]
    #[instrument(skip(self), fields(address = %req.address))]
    async fn decompile(
        &self,
        Parameters(req): Parameters<DecompileRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: decompile");
        let addrs = match Self::value_to_addresses(&req.address) {
            Ok(a) => a,
            Err(e) => return Ok(e.to_tool_result()),
        };

        if addrs.len() == 1 {
            match self.worker.decompile(addrs[0]).await {
                Ok(code) => Ok(CallToolResult::success(vec![Content::text(code)])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for addr in addrs {
                match self.worker.decompile(addr).await {
                    Ok(code) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "decompile": code
                    })),
                    Err(e) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(
        description = "Get decompiled pseudocode at a specific address or address range. \
        Unlike 'decompile' which returns the full function, this returns only the statements \
        that correspond to the given address(es). Useful for getting pseudocode for a basic block \
        or specific instruction. If end_address is provided, returns statements covering the range."
    )]
    #[instrument(skip(self), fields(address = %req.address, end_address = ?req.end_address))]
    async fn pseudocode_at(
        &self,
        Parameters(req): Parameters<PseudocodeAtRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: pseudocode_at");
        let addrs = match Self::value_to_addresses(&req.address) {
            Ok(a) => a,
            Err(e) => return Ok(e.to_tool_result()),
        };

        let end_addr = if let Some(ref end_str) = req.end_address {
            match Self::parse_address(end_str) {
                Ok(a) => Some(a),
                Err(e) => return Ok(e.to_tool_result()),
            }
        } else {
            None
        };

        if addrs.len() == 1 {
            match self.worker.pseudocode_at(addrs[0], end_addr).await {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for addr in addrs {
                match self.worker.pseudocode_at(addr, end_addr).await {
                    Ok(result) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "pseudocode": result
                    })),
                    Err(e) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(description = "List all segments in the database with their permissions and types")]
    #[instrument(skip(self))]
    async fn segments(&self) -> Result<CallToolResult, McpError> {
        debug!("Tool call: segments");
        match self.worker.segments().await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(
        description = "List strings in the database with pagination and optional filter. \
        For large databases, consider setting timeout_secs (default: 120, max: 600)."
    )]
    #[instrument(skip(self), fields(offset = req.offset, limit = req.limit, filter = ?req.filter))]
    async fn strings(
        &self,
        Parameters(req): Parameters<StringsRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: strings");
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);

        match self
            .worker
            .strings(offset, limit, req.filter, req.timeout_secs)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(
        description = "Find strings matching a query (supports exact/case-insensitive options). \
        For large databases, consider setting timeout_secs (default: 120, max: 600)."
    )]
    async fn find_string(
        &self,
        Parameters(req): Parameters<FindStringRequest>,
    ) -> Result<CallToolResult, McpError> {
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);
        let exact = req.exact.unwrap_or(false);
        let case_insensitive = req.case_insensitive.unwrap_or(true);
        match self
            .worker
            .find_string(
                req.query.clone(),
                exact,
                case_insensitive,
                offset,
                limit,
                req.timeout_secs,
            )
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Find strings and return xrefs to each match. \
        For large databases, consider setting timeout_secs (default: 120, max: 600).")]
    async fn xrefs_to_string(
        &self,
        Parameters(req): Parameters<XrefsToStringRequest>,
    ) -> Result<CallToolResult, McpError> {
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);
        let exact = req.exact.unwrap_or(false);
        let case_insensitive = req.case_insensitive.unwrap_or(true);
        let max_xrefs = req.max_xrefs.unwrap_or(64);
        match self
            .worker
            .xrefs_to_string(
                req.query.clone(),
                exact,
                case_insensitive,
                offset,
                limit,
                max_xrefs,
                req.timeout_secs,
            )
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Get cross-references TO an address (who references this address)")]
    #[instrument(skip(self), fields(address = %req.address))]
    async fn xrefs_to(
        &self,
        Parameters(req): Parameters<AddressRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: xrefs_to");
        let addrs = match Self::value_to_addresses(&req.address) {
            Ok(a) => a,
            Err(e) => return Ok(e.to_tool_result()),
        };

        if addrs.len() == 1 {
            match self.worker.xrefs_to(addrs[0]).await {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for addr in addrs {
                match self.worker.xrefs_to(addr).await {
                    Ok(result) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "xrefs": result
                    })),
                    Err(e) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(description = "Get cross-references FROM an address (what this address references)")]
    #[instrument(skip(self), fields(address = %req.address))]
    async fn xrefs_from(
        &self,
        Parameters(req): Parameters<AddressRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: xrefs_from");
        let addrs = match Self::value_to_addresses(&req.address) {
            Ok(a) => a,
            Err(e) => return Ok(e.to_tool_result()),
        };

        if addrs.len() == 1 {
            match self.worker.xrefs_from(addrs[0]).await {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for addr in addrs {
                match self.worker.xrefs_from(addr).await {
                    Ok(result) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "xrefs": result
                    })),
                    Err(e) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(description = "List imports (external symbols) with pagination")]
    #[instrument(skip(self), fields(offset = req.offset, limit = req.limit))]
    async fn imports(
        &self,
        Parameters(req): Parameters<PaginatedRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: imports");
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);

        match self.worker.imports(offset, limit).await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "List exports/names (public symbols) with pagination")]
    #[instrument(skip(self), fields(offset = req.offset, limit = req.limit))]
    async fn exports(
        &self,
        Parameters(req): Parameters<PaginatedRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: exports");
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);

        match self.worker.exports(offset, limit).await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Get entry point addresses of the binary")]
    #[instrument(skip(self))]
    async fn entrypoints(&self) -> Result<CallToolResult, McpError> {
        debug!("Tool call: entrypoints");
        match self.worker.entrypoints().await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Read raw bytes from an address as hex string")]
    #[instrument(skip(self), fields(size = req.size))]
    async fn get_bytes(
        &self,
        Parameters(req): Parameters<GetBytesRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: get_bytes");
        let size = req.size.unwrap_or(256).min(0x10000);
        if let Some(addr_value) = req.address.as_ref() {
            let addrs = match Self::value_to_addresses(addr_value) {
                Ok(a) => a,
                Err(e) => return Ok(e.to_tool_result()),
            };

            if addrs.len() == 1 {
                match self.worker.get_bytes(Some(addrs[0]), None, 0, size).await {
                    Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                        serde_json::to_string_pretty(&result)
                            .unwrap_or_else(|_| format!("{:?}", result)),
                    )])),
                    Err(e) => Ok(e.to_tool_result()),
                }
            } else {
                let mut results = Vec::new();
                for addr in addrs {
                    match self.worker.get_bytes(Some(addr), None, 0, size).await {
                        Ok(result) => results.push(json!({
                            "address": format!("{:#x}", addr),
                            "bytes": result
                        })),
                        Err(e) => results.push(json!({
                            "address": format!("{:#x}", addr),
                            "error": e.to_string()
                        })),
                    }
                }
                Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&json!({ "results": results }))
                        .unwrap_or_else(|_| format!("{:?}", results)),
                )]))
            }
        } else if let Some(name) = req.target_name.as_ref() {
            let offset = req.offset.unwrap_or(0);
            match self
                .worker
                .get_bytes(None, Some(name.clone()), offset, size)
                .await
            {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            Ok(ToolError::InvalidParams("address or name required".to_string()).to_tool_result())
        }
    }

    #[tool(description = "Get basic blocks of a function (control flow graph nodes)")]
    #[instrument(skip(self), fields(address = %req.address))]
    async fn basic_blocks(
        &self,
        Parameters(req): Parameters<AddressRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: basic_blocks");
        let addrs = match Self::value_to_addresses(&req.address) {
            Ok(a) => a,
            Err(e) => return Ok(e.to_tool_result()),
        };

        if addrs.len() == 1 {
            match self.worker.basic_blocks(addrs[0]).await {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for addr in addrs {
                match self.worker.basic_blocks(addr).await {
                    Ok(result) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "basic_blocks": result
                    })),
                    Err(e) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(description = "Get functions called BY a function (callees/children in call graph)")]
    #[instrument(skip(self), fields(address = %req.address))]
    async fn callees(
        &self,
        Parameters(req): Parameters<AddressRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: callees");
        let addrs = match Self::value_to_addresses(&req.address) {
            Ok(a) => a,
            Err(e) => return Ok(e.to_tool_result()),
        };

        if addrs.len() == 1 {
            match self.worker.callees(addrs[0]).await {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for addr in addrs {
                match self.worker.callees(addr).await {
                    Ok(result) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "callees": result
                    })),
                    Err(e) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(description = "Get functions that CALL a function (callers/parents in call graph)")]
    #[instrument(skip(self), fields(address = %req.address))]
    async fn callers(
        &self,
        Parameters(req): Parameters<AddressRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: callers");
        let addrs = match Self::value_to_addresses(&req.address) {
            Ok(a) => a,
            Err(e) => return Ok(e.to_tool_result()),
        };

        if addrs.len() == 1 {
            match self.worker.callers(addrs[0]).await {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for addr in addrs {
                match self.worker.callers(addr).await {
                    Ok(result) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "callers": result
                    })),
                    Err(e) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(description = "Get IDB metadata (ida-pro-mcp compatibility)")]
    #[instrument(skip(self))]
    async fn idb_meta(&self) -> Result<CallToolResult, McpError> {
        debug!("Tool call: idb_meta");
        match self.worker.idb_meta().await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Lookup functions by name or address (batch)")]
    #[instrument(skip(self))]
    async fn lookup_funcs(
        &self,
        Parameters(req): Parameters<LookupFuncsRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: lookup_funcs");
        let queries = match Self::value_to_strings(&req.queries) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };
        match self.worker.lookup_funcs(queries).await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "List global names (non-function symbols). \
        For large databases, consider setting timeout_secs (default: 120, max: 600).")]
    #[instrument(skip(self), fields(offset = req.offset, limit = req.limit, query = ?req.query))]
    async fn list_globals(
        &self,
        Parameters(req): Parameters<ListGlobalsRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: list_globals");
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);
        match self
            .worker
            .list_globals(req.query.clone(), offset, limit, req.timeout_secs)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(
        description = "Analyze strings with xrefs (ida-pro-mcp compatibility). \
        For large databases, consider setting timeout_secs (default: 120, max: 600)."
    )]
    #[instrument(skip(self), fields(offset = req.offset, limit = req.limit, query = ?req.query))]
    async fn analyze_strings(
        &self,
        Parameters(req): Parameters<AnalyzeStringsRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: analyze_strings");
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);
        match self
            .worker
            .analyze_strings(req.query.clone(), offset, limit, req.timeout_secs)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Find byte patterns (ida-pro-mcp compatibility). \
        For large databases, consider setting timeout_secs (default: 120, max: 600).")]
    #[instrument(skip(self))]
    async fn find_bytes(
        &self,
        Parameters(req): Parameters<FindBytesRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: find_bytes");
        let patterns = match Self::value_to_strings(&req.patterns) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);
        let timeout_secs = req.timeout_secs;
        let mut results = Vec::new();

        for pattern in patterns {
            let max_results = (offset + limit).min(20000);
            match self
                .worker
                .find_bytes(pattern.clone(), max_results, timeout_secs)
                .await
            {
                Ok(value) => {
                    let matches = value
                        .get("matches")
                        .and_then(|m| m.as_array())
                        .cloned()
                        .unwrap_or_default();
                    let total = matches.len();
                    let sliced = matches
                        .into_iter()
                        .skip(offset)
                        .take(limit)
                        .collect::<Vec<_>>();
                    let next_offset = if offset + limit < total {
                        Some(offset + limit)
                    } else {
                        None
                    };
                    results.push(json!({
                        "pattern": pattern,
                        "matches": sliced,
                        "total": total,
                        "next_offset": next_offset
                    }));
                }
                Err(e) => results.push(json!({
                    "pattern": pattern,
                    "error": e.to_string()
                })),
            }
        }

        Ok(CallToolResult::success(vec![Content::text(
            serde_json::to_string_pretty(&json!({ "results": results }))
                .unwrap_or_else(|_| format!("{:?}", results)),
        )]))
    }

    #[tool(
        description = "Search for text or immediates (ida-pro-mcp compatibility). \
        For large databases, consider setting timeout_secs (default: 120, max: 600)."
    )]
    #[instrument(skip(self))]
    async fn search(
        &self,
        Parameters(req): Parameters<SearchRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: search");
        let targets = match Self::value_to_strings(&req.targets) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);
        let timeout_secs = req.timeout_secs;
        let kind = req.kind.as_deref().unwrap_or("auto").to_lowercase();

        let mut results = Vec::new();
        for target in targets {
            let max_results = (offset + limit).min(20000);
            let search_result = if kind == "imm" || kind == "immediate" {
                match Self::parse_address(&target) {
                    Ok(val) => self.worker.search_imm(val, max_results, timeout_secs).await,
                    Err(e) => {
                        results.push(json!({
                            "target": target,
                            "error": e.to_string()
                        }));
                        continue;
                    }
                }
            } else if kind == "text" || kind == "string" {
                self.worker
                    .search_text(target.clone(), max_results, timeout_secs)
                    .await
            } else if let Ok(val) = Self::parse_address(&target) {
                self.worker.search_imm(val, max_results, timeout_secs).await
            } else {
                self.worker
                    .search_text(target.clone(), max_results, timeout_secs)
                    .await
            };

            match search_result {
                Ok(value) => {
                    let matches = value
                        .get("matches")
                        .and_then(|m| m.as_array())
                        .cloned()
                        .unwrap_or_default();
                    let total = matches.len();
                    let sliced = matches
                        .into_iter()
                        .skip(offset)
                        .take(limit)
                        .collect::<Vec<_>>();
                    let next_offset = if offset + limit < total {
                        Some(offset + limit)
                    } else {
                        None
                    };
                    results.push(json!({
                        "target": target,
                        "matches": sliced,
                        "total": total,
                        "next_offset": next_offset
                    }));
                }
                Err(e) => results.push(json!({
                    "target": target,
                    "error": e.to_string()
                })),
            }
        }

        Ok(CallToolResult::success(vec![Content::text(
            serde_json::to_string_pretty(&json!({ "results": results }))
                .unwrap_or_else(|_| format!("{:?}", results)),
        )]))
    }

    #[tool(description = "Read u8 values at address(es)")]
    #[instrument(skip(self))]
    async fn get_u8(
        &self,
        Parameters(req): Parameters<AddressRequest>,
    ) -> Result<CallToolResult, McpError> {
        get_int_values(&self.worker, req.address, 1).await
    }

    #[tool(description = "Read u16 values at address(es)")]
    #[instrument(skip(self))]
    async fn get_u16(
        &self,
        Parameters(req): Parameters<AddressRequest>,
    ) -> Result<CallToolResult, McpError> {
        get_int_values(&self.worker, req.address, 2).await
    }

    #[tool(description = "Read u32 values at address(es)")]
    #[instrument(skip(self))]
    async fn get_u32(
        &self,
        Parameters(req): Parameters<AddressRequest>,
    ) -> Result<CallToolResult, McpError> {
        get_int_values(&self.worker, req.address, 4).await
    }

    #[tool(description = "Read u64 values at address(es)")]
    #[instrument(skip(self))]
    async fn get_u64(
        &self,
        Parameters(req): Parameters<AddressRequest>,
    ) -> Result<CallToolResult, McpError> {
        get_int_values(&self.worker, req.address, 8).await
    }

    #[tool(description = "Read string(s) at address(es)")]
    #[instrument(skip(self))]
    async fn get_string(
        &self,
        Parameters(req): Parameters<GetStringRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: get_string");
        let addrs = match Self::value_to_addresses(&req.address) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };
        let max_len = req.max_len.unwrap_or(256).min(0x10000);

        if addrs.len() == 1 {
            match self.worker.get_string(addrs[0], max_len).await {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for addr in addrs {
                match self.worker.get_string(addr, max_len).await {
                    Ok(result) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "string": result
                    })),
                    Err(e) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(description = "Get global value(s) by name or address")]
    #[instrument(skip(self))]
    async fn get_global_value(
        &self,
        Parameters(req): Parameters<GetGlobalValueRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: get_global_value");
        let queries = match Self::value_to_strings(&req.query) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };

        if queries.len() == 1 {
            match self.worker.get_global_value(queries[0].clone()).await {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for query in queries {
                match self.worker.get_global_value(query.clone()).await {
                    Ok(result) => results.push(json!({
                        "query": query,
                        "value": result
                    })),
                    Err(e) => results.push(json!({
                        "query": query,
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(description = "Find paths between two addresses (CFG)")]
    #[instrument(skip(self))]
    async fn find_paths(
        &self,
        Parameters(req): Parameters<FindPathsRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: find_paths");
        let start = match Self::value_to_single_address(&req.start) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };
        let end = match Self::value_to_single_address(&req.end) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };
        let max_paths = req.max_paths.unwrap_or(8).min(128);
        let max_depth = req.max_depth.unwrap_or(64).min(2048);

        match self
            .worker
            .find_paths(start, end, max_paths, max_depth)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Build a callgraph rooted at an address")]
    #[instrument(skip(self))]
    async fn callgraph(
        &self,
        Parameters(req): Parameters<CallGraphRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: callgraph");
        let roots = match Self::value_to_addresses(&req.roots) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };
        let max_depth = req.max_depth.unwrap_or(2).min(16);
        let max_nodes = req.max_nodes.unwrap_or(256).min(10000);

        if roots.len() == 1 {
            match self.worker.callgraph(roots[0], max_depth, max_nodes).await {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for root in roots {
                match self.worker.callgraph(root, max_depth, max_nodes).await {
                    Ok(result) => results.push(json!({
                        "root": format!("{:#x}", root),
                        "callgraph": result
                    })),
                    Err(e) => results.push(json!({
                        "root": format!("{:#x}", root),
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(description = "Compute xref matrix for a set of addresses")]
    #[instrument(skip(self))]
    async fn xref_matrix(
        &self,
        Parameters(req): Parameters<XrefMatrixRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: xref_matrix");
        let addrs = match Self::value_to_addresses(&req.addrs) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };
        match self.worker.xref_matrix(addrs).await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Export functions (ida-pro-mcp compatibility)")]
    #[instrument(skip(self), fields(offset = req.offset, limit = req.limit))]
    async fn export_funcs(
        &self,
        Parameters(req): Parameters<ExportFuncsRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: export_funcs");
        if let Some(fmt) = req.format.as_deref() {
            if fmt.to_lowercase() != "json" {
                return Ok(ToolError::NotSupported(format!(
                    "format {} not supported (only json)",
                    fmt
                ))
                .to_tool_result());
            }
        }
        if let Some(addrs) = req.addrs {
            let queries = match Self::value_to_strings(&addrs) {
                Ok(v) => v,
                Err(e) => return Ok(e.to_tool_result()),
            };
            match self.worker.lookup_funcs(queries).await {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let limit = req.limit.unwrap_or(100).min(10000);
            let offset = req.offset.unwrap_or(0);
            match self.worker.export_funcs(offset, limit).await {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        }
    }

    #[tool(description = "Convert integers between bases")]
    #[instrument(skip(self))]
    async fn int_convert(
        &self,
        Parameters(req): Parameters<IntConvertRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: int_convert");
        let inputs = match Self::value_to_strings(&req.inputs) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };

        let mut results = Vec::new();
        for input in inputs {
            match Self::parse_address(&input) {
                Ok(value) => {
                    let le = value.to_le_bytes();
                    let be = value.to_be_bytes();
                    let le_trim = trim_bytes_le(&le);
                    let be_trim = trim_bytes_be(&be);
                    results.push(json!({
                        "input": input,
                        "value": value,
                        "dec": value.to_string(),
                        "hex": format!("0x{:x}", value),
                        "bin": format!("0b{:b}", value),
                        "bytes_le": hex_encode(&le_trim),
                        "bytes_be": hex_encode(&be_trim),
                        "ascii": bytes_to_ascii(&le_trim),
                    }));
                }
                Err(e) => results.push(json!({
                    "input": input,
                    "error": e.to_string()
                })),
            }
        }

        Ok(CallToolResult::success(vec![Content::text(
            serde_json::to_string_pretty(&json!({ "results": results }))
                .unwrap_or_else(|_| format!("{:?}", results)),
        )]))
    }

    #[tool(description = "List local types")]
    async fn local_types(
        &self,
        Parameters(req): Parameters<LocalTypesRequest>,
    ) -> Result<CallToolResult, McpError> {
        let offset = req.offset.unwrap_or(0);
        let limit = req.limit.unwrap_or(100);
        match self
            .worker
            .local_types(offset, limit, req.filter.clone(), req.timeout_secs)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Get xrefs to a struct field")]
    async fn xrefs_to_field(
        &self,
        Parameters(req): Parameters<XrefsToFieldRequest>,
    ) -> Result<CallToolResult, McpError> {
        let limit = req.limit.unwrap_or(1000).min(10000);
        match self
            .worker
            .xrefs_to_field(
                req.ordinal,
                req.name.clone(),
                req.member_index,
                req.member_name.clone(),
                limit,
            )
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Set comments at an address")]
    async fn set_comments(
        &self,
        Parameters(req): Parameters<SetCommentsRequest>,
    ) -> Result<CallToolResult, McpError> {
        let repeatable = req.repeatable.unwrap_or(false);
        let offset = req.offset.unwrap_or(0);
        let addr = match req.address.as_ref() {
            Some(val) => match Self::value_to_single_address(val) {
                Ok(v) => Some(v),
                Err(e) => return Ok(e.to_tool_result()),
            },
            None => None,
        };
        match self
            .worker
            .set_comments(
                addr,
                req.target_name.clone(),
                offset,
                req.comment.clone(),
                repeatable,
            )
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Patch instructions with assembly text")]
    async fn patch_asm(
        &self,
        Parameters(req): Parameters<PatchAsmRequest>,
    ) -> Result<CallToolResult, McpError> {
        let offset = req.offset.unwrap_or(0);
        let addr = match req.address.as_ref() {
            Some(val) => match Self::value_to_single_address(val) {
                Ok(v) => Some(v),
                Err(e) => return Ok(e.to_tool_result()),
            },
            None => None,
        };
        match self
            .worker
            .patch_asm(addr, req.target_name.clone(), offset, req.line.clone())
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Declare a type in the local type library")]
    async fn declare_type(
        &self,
        Parameters(req): Parameters<DeclareTypeRequest>,
    ) -> Result<CallToolResult, McpError> {
        let relaxed = req.relaxed.unwrap_or(false);
        let replace = req.replace.unwrap_or(false);
        let multi = req.multi.unwrap_or(false);
        match self
            .worker
            .declare_type(req.decl.clone(), relaxed, replace, multi)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Get stack frame info")]
    async fn stack_frame(
        &self,
        Parameters(req): Parameters<AddressRequest>,
    ) -> Result<CallToolResult, McpError> {
        let addr = match Self::value_to_single_address(&req.address) {
            Ok(addr) => addr,
            Err(e) => return Ok(e.to_tool_result()),
        };
        match self.worker.stack_frame(addr).await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Declare a stack variable in a function frame")]
    async fn declare_stack(
        &self,
        Parameters(req): Parameters<DeclareStackRequest>,
    ) -> Result<CallToolResult, McpError> {
        let addr = match req.address.as_ref() {
            Some(val) => match Self::value_to_single_address(val) {
                Ok(v) => Some(v),
                Err(e) => return Ok(e.to_tool_result()),
            },
            None => None,
        };
        let relaxed = req.relaxed.unwrap_or(false);
        match self
            .worker
            .declare_stack(
                addr,
                req.target_name.clone(),
                req.offset,
                req.var_name.clone(),
                req.decl.clone(),
                relaxed,
            )
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Delete a stack variable from a function frame")]
    async fn delete_stack(
        &self,
        Parameters(req): Parameters<DeleteStackRequest>,
    ) -> Result<CallToolResult, McpError> {
        let addr = match req.address.as_ref() {
            Some(val) => match Self::value_to_single_address(val) {
                Ok(v) => Some(v),
                Err(e) => return Ok(e.to_tool_result()),
            },
            None => None,
        };
        match self
            .worker
            .delete_stack(
                addr,
                req.target_name.clone(),
                req.offset,
                req.var_name.clone(),
            )
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(
        description = "List structs in the database with pagination and optional filter. \
        For large databases, consider setting timeout_secs (default: 120, max: 600)."
    )]
    #[instrument(skip(self), fields(offset = req.offset, limit = req.limit, filter = ?req.filter))]
    async fn structs(
        &self,
        Parameters(req): Parameters<StructsRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: structs");
        let limit = req.limit.unwrap_or(100).min(10000);
        let offset = req.offset.unwrap_or(0);

        match self
            .worker
            .structs(offset, limit, req.filter, req.timeout_secs)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Get info about a struct by ordinal or name")]
    #[instrument(skip(self), fields(ordinal = req.ordinal, name = ?req.name))]
    async fn struct_info(
        &self,
        Parameters(req): Parameters<StructInfoRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: struct_info");
        match self.worker.struct_info(req.ordinal, req.name).await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Read values of a struct instance at an address")]
    #[instrument(skip(self), fields(address = %req.address, ordinal = req.ordinal, name = ?req.name))]
    async fn read_struct(
        &self,
        Parameters(req): Parameters<ReadStructRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: read_struct");
        let addrs = match Self::value_to_addresses(&req.address) {
            Ok(a) => a,
            Err(e) => return Ok(e.to_tool_result()),
        };

        if addrs.len() == 1 {
            match self
                .worker
                .read_struct(addrs[0], req.ordinal, req.name)
                .await
            {
                Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )])),
                Err(e) => Ok(e.to_tool_result()),
            }
        } else {
            let mut results = Vec::new();
            for addr in addrs {
                match self
                    .worker
                    .read_struct(addr, req.ordinal, req.name.clone())
                    .await
                {
                    Ok(result) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "struct": result
                    })),
                    Err(e) => results.push(json!({
                        "address": format!("{:#x}", addr),
                        "error": e.to_string()
                    })),
                }
            }
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&json!({ "results": results }))
                    .unwrap_or_else(|_| format!("{:?}", results)),
            )]))
        }
    }

    #[tool(description = "Search structs by name")]
    async fn search_structs(
        &self,
        Parameters(req): Parameters<StructsRequest>,
    ) -> Result<CallToolResult, McpError> {
        let offset = req.offset.unwrap_or(0);
        let limit = req.limit.unwrap_or(100);
        match self
            .worker
            .structs(offset, limit, req.filter.clone(), req.timeout_secs)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Find instruction sequences by mnemonic")]
    async fn find_insns(
        &self,
        Parameters(req): Parameters<FindInsnsRequest>,
    ) -> Result<CallToolResult, McpError> {
        let patterns = match Self::value_to_strings(&req.patterns) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };
        if patterns.is_empty() {
            return Ok(ToolError::InvalidParams("empty patterns".to_string()).to_tool_result());
        }
        let max_results = req.limit.unwrap_or(100);
        let case_insensitive = req.case_insensitive.unwrap_or(false);
        match self
            .worker
            .find_insns(patterns, max_results, case_insensitive, req.timeout_secs)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Find instruction operands")]
    async fn find_insn_operands(
        &self,
        Parameters(req): Parameters<FindInsnOperandsRequest>,
    ) -> Result<CallToolResult, McpError> {
        let patterns = match Self::value_to_strings(&req.patterns) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };
        if patterns.is_empty() {
            return Ok(ToolError::InvalidParams("empty patterns".to_string()).to_tool_result());
        }
        let max_results = req.limit.unwrap_or(100);
        let case_insensitive = req.case_insensitive.unwrap_or(false);
        match self
            .worker
            .find_insn_operands(patterns, max_results, case_insensitive, req.timeout_secs)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Apply a type to an address")]
    async fn apply_types(
        &self,
        Parameters(req): Parameters<ApplyTypesRequest>,
    ) -> Result<CallToolResult, McpError> {
        let addr = match req.address.as_ref() {
            Some(val) => match Self::value_to_single_address(val) {
                Ok(v) => Some(v),
                Err(e) => return Ok(e.to_tool_result()),
            },
            None => None,
        };
        let offset = req.offset.unwrap_or(0);
        let relaxed = req.relaxed.unwrap_or(false);
        let delay = req.delay.unwrap_or(false);
        let strict = req.strict.unwrap_or(false);
        match self
            .worker
            .apply_types(
                addr,
                req.target_name.clone(),
                offset,
                req.stack_offset,
                req.stack_name.clone(),
                req.decl.clone(),
                req.type_name.clone(),
                relaxed,
                delay,
                strict,
            )
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Infer/guess type at an address")]
    async fn infer_types(
        &self,
        Parameters(req): Parameters<InferTypesRequest>,
    ) -> Result<CallToolResult, McpError> {
        let addr = match req.address.as_ref() {
            Some(val) => match Self::value_to_single_address(val) {
                Ok(v) => Some(v),
                Err(e) => return Ok(e.to_tool_result()),
            },
            None => None,
        };
        let offset = req.offset.unwrap_or(0);
        match self
            .worker
            .infer_types(addr, req.target_name.clone(), offset)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Analyze functions (not supported)")]
    async fn analyze_funcs(
        &self,
        Parameters(req): Parameters<AnalyzeFuncsRequest>,
    ) -> Result<CallToolResult, McpError> {
        match self.worker.analyze_funcs(req.timeout_secs).await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Rename symbols")]
    async fn rename(
        &self,
        Parameters(req): Parameters<RenameRequest>,
    ) -> Result<CallToolResult, McpError> {
        let addr = match req.address.as_ref() {
            Some(val) => match Self::value_to_single_address(val) {
                Ok(v) => Some(v),
                Err(e) => return Ok(e.to_tool_result()),
            },
            None => None,
        };
        let flags = req.flags.unwrap_or(0);
        match self
            .worker
            .rename(addr, req.current_name.clone(), req.name.clone(), flags)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(description = "Patch bytes at an address")]
    async fn patch(
        &self,
        Parameters(req): Parameters<PatchRequest>,
    ) -> Result<CallToolResult, McpError> {
        let addr = match req.address.as_ref() {
            Some(val) => match Self::value_to_single_address(val) {
                Ok(v) => Some(v),
                Err(e) => return Ok(e.to_tool_result()),
            },
            None => None,
        };
        let offset = req.offset.unwrap_or(0);
        let bytes = match Self::value_to_bytes(&req.bytes) {
            Ok(v) => v,
            Err(e) => return Ok(e.to_tool_result()),
        };
        match self
            .worker
            .patch_bytes(addr, req.target_name.clone(), offset, bytes)
            .await
        {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    }

    #[tool(
        description = "Open a dyld_shared_cache file and load a single module (dylib) for analysis. \
        If the .i64 database already exists, opens it immediately and returns db_info. \
        If the .i64 must be created (first time), spawns idat in the background and returns \
        a task_id immediately. Poll task_status(task_id) to check progress — when completed, \
        the database is already open and ready for analysis tools. \
        Use this instead of open_idb when working with Apple's dyld_shared_cache files. \
        The module parameter specifies which dylib to extract (e.g. '/usr/lib/libobjc.A.dylib'). \
        Additional frameworks can be loaded to resolve cross-module references."
    )]
    #[instrument(skip(self), fields(path = %req.path, arch = %req.arch, module = %req.module))]
    async fn open_dsc(
        &self,
        Parameters(req): Parameters<OpenDscRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: open_dsc");

        if !Self::validate_path(&req.path) {
            return Ok(ToolError::InvalidPath(req.path).to_tool_result());
        }

        let ida_version = req.ida_version.unwrap_or(9);
        if ida_version != 8 && ida_version != 9 {
            return Ok(
                ToolError::InvalidParams("ida_version must be 8 or 9".into()).to_tool_result(),
            );
        }

        let file_type = crate::dsc::dsc_file_type(&req.arch, ida_version);
        let frameworks = req.frameworks.unwrap_or_default();
        let dsc_path = std::path::Path::new(&req.path);
        let out_i64 = dsc_path.with_extension("i64");

        // If .i64 already exists, open synchronously (fast path).
        if out_i64.exists() {
            return self.open_dsc_i64(&out_i64, &req.module, &frameworks).await;
        }

        // .i64 doesn't exist — need to run idat, which takes minutes.
        // Validate idat exists and write the load script before spawning.
        let idat = match crate::dsc::find_idat() {
            Ok(path) => path,
            Err(e) => return Ok(e.to_tool_result()),
        };

        let script = crate::dsc::dsc_load_script(&req.module, &frameworks);
        let script_dir = dsc_path.parent().unwrap_or(std::path::Path::new("/tmp"));
        let script_path = script_dir.join("ida_mcp_dsc_load.py");
        if let Err(e) = std::fs::write(&script_path, &script) {
            return Ok(
                ToolError::InvalidParams(format!("Failed to write DSC load script: {e}"))
                    .to_tool_result(),
            );
        }

        let log_path = req.log_path.map(std::path::PathBuf::from);
        if let Some(ref lp) = log_path {
            if lp.to_string_lossy().contains("..") {
                return Ok(ToolError::InvalidParams(
                    "log_path must not contain '..' path traversal".into(),
                )
                .to_tool_result());
            }
        }
        let idat_args = crate::dsc::idat_dsc_args(
            dsc_path,
            &out_i64,
            &script_path,
            &file_type,
            log_path.as_deref(),
        );

        // Create a background task and return immediately.
        // Use the .i64 path as dedup key to prevent concurrent idat
        // processes writing the same output file.
        let dedup_key = out_i64.display().to_string();
        let task_id = match self
            .task_registry
            .create_keyed(&dedup_key, "Running idat to create .i64 from DSC...")
        {
            Ok(id) => id,
            Err(existing_id) => {
                return Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&json!({
                        "status": "already_running",
                        "task_id": existing_id,
                        "message": "A DSC loading task for this path is already in progress. Poll task_status(task_id) for progress.",
                    }))
                    .unwrap_or_default(),
                )]));
            }
        };

        info!(
            task_id = %task_id,
            idat = %idat.display(),
            module = %req.module,
            "Spawning background idat for DSC loading"
        );

        let registry = self.task_registry.clone();
        let worker = Arc::clone(&self.worker);
        let mode = self.mode;
        let module = req.module.clone();
        let tid = task_id.clone();

        let ctx = DscBackgroundCtx {
            idat,
            idat_args,
            script_path,
            log_path,
            out_i64,
            module,
            frameworks,
        };

        let handle = tokio::spawn(async move {
            Self::run_dsc_background(tid, registry, worker, mode, ctx).await;
        });
        self.task_registry.set_handle(&task_id, handle);

        Ok(CallToolResult::success(vec![Content::text(
            serde_json::to_string_pretty(&json!({
                "status": "started",
                "task_id": task_id,
                "message": "DSC loading started in background. Poll task_status(task_id) for progress.",
            }))
            .unwrap_or_default(),
        )]))
    }

    #[tool(
        description = "Check the status of a background task (e.g. DSC loading). \
        Returns the current status: 'running' (with a progress message), \
        'completed' (with the result — database is already open), \
        'failed' (with an error message), or 'cancelled'. \
        Use the task_id returned by open_dsc."
    )]
    #[instrument(skip(self), fields(task_id = %req.task_id))]
    async fn task_status(
        &self,
        Parameters(req): Parameters<TaskStatusRequest>,
    ) -> Result<CallToolResult, McpError> {
        debug!("Tool call: task_status");

        let state = match self.task_registry.get(&req.task_id) {
            Some(s) => s,
            None => {
                return Ok(
                    ToolError::InvalidParams(format!("Unknown task_id: {}", req.task_id))
                        .to_tool_result(),
                );
            }
        };

        let elapsed = state.created_at.elapsed().as_secs();
        let status_str = match state.status {
            task::TaskStatus::Running => "running",
            task::TaskStatus::Completed => "completed",
            task::TaskStatus::Failed => "failed",
            task::TaskStatus::Cancelled => "cancelled",
        };

        let mut response = json!({
            "task_id": state.id,
            "status": status_str,
            "message": state.message,
            "elapsed_secs": elapsed,
        });

        if let Some(result) = &state.result {
            if let Value::Object(map) = &mut response {
                map.insert("result".to_string(), result.clone());
            }
        }

        Ok(CallToolResult::success(vec![Content::text(
            serde_json::to_string_pretty(&response).unwrap_or_default(),
        )]))
    }

    #[tool(
        description = "Execute a Python script via IDAPython in the open database. \
        Has full access to all ida_* modules, idc, idautils. \
        stdout and stderr are captured and returned. \
        Provide either 'code' (inline Python) or 'file' (path to a .py file), not both. \
        Use this for custom analysis that goes beyond the built-in tools. \
        API reference: https://python.docs.hex-rays.com"
    )]
    #[instrument(skip(self))]
    async fn run_script(
        &self,
        Parameters(req): Parameters<RunScriptRequest>,
    ) -> Result<CallToolResult, McpError> {
        let code = match (req.code, req.file) {
            (Some(code), None) => code,
            (None, Some(path)) => {
                if !Self::validate_path(&path) {
                    return Ok(ToolError::InvalidPath(path).to_tool_result());
                }
                match std::fs::read_to_string(&path) {
                    Ok(contents) => contents,
                    Err(e) => {
                        return Ok(ToolError::InvalidPath(format!(
                            "Failed to read script file '{}': {}",
                            path, e
                        ))
                        .to_tool_result());
                    }
                }
            }
            (Some(_), Some(_)) => {
                return Ok(ToolError::InvalidParams(
                    "Provide either 'code' or 'file', not both".into(),
                )
                .to_tool_result());
            }
            (None, None) => {
                return Ok(ToolError::InvalidParams(
                    "Provide either 'code' (inline Python) or 'file' (path to .py)".into(),
                )
                .to_tool_result());
            }
        };
        let timeout = req.timeout_secs.map(|t| t.min(600));
        match self.worker.run_script(&code, timeout).await {
            Ok(result) => {
                if !run_script_succeeded(&result) {
                    let message = run_script_failure_message(&result);
                    warn!(code_len = code.len(), error = %message, "run_script failed");
                    return Ok(ToolError::IdaError(message).to_tool_result());
                }
                Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string_pretty(&result)
                        .unwrap_or_else(|_| format!("{:?}", result)),
                )]))
            }
            Err(ToolError::Timeout(timeout_secs)) => {
                let message = run_script_timeout_message(timeout_secs, &code);
                warn!(timeout_secs, code_len = code.len(), "run_script timed out");
                Ok(ToolError::IdaError(message).to_tool_result())
            }
            Err(e) => Ok(e.to_tool_result()),
        }
    }
}

const RUN_SCRIPT_PREVIEW_CHARS: usize = 220;
const RUN_SCRIPT_TAIL_LINES: usize = 12;
const RUN_SCRIPT_TAIL_CHARS: usize = 1600;

fn run_script_succeeded(result: &Value) -> bool {
    result.get("success").and_then(Value::as_bool) == Some(true)
}

fn run_script_field<'a>(result: &'a Value, field: &str) -> Option<&'a str> {
    result.get(field).and_then(Value::as_str)
}

fn run_script_last_non_empty_line(text: &str) -> Option<&str> {
    text.lines().rev().find_map(|line| {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            None
        } else {
            Some(trimmed)
        }
    })
}

fn run_script_truncate_chars(input: &str, max_chars: usize) -> String {
    let mut out = String::new();
    for (count, ch) in input.chars().enumerate() {
        if count >= max_chars {
            out.push_str("...");
            return out;
        }
        out.push(ch);
    }
    out
}

fn run_script_tail_lines(text: &str, max_lines: usize) -> String {
    let lines: Vec<&str> = text.lines().collect();
    let start = lines.len().saturating_sub(max_lines);
    lines[start..].join("\n")
}

fn run_script_error_hint(error_details: &str) -> Option<&'static str> {
    let lowered = error_details.to_ascii_lowercase();
    if lowered.contains("syntaxerror") || lowered.contains("invalid syntax") {
        return Some("Python syntax error detected. Regenerate valid Python and retry.");
    }
    if lowered.contains("nameerror") {
        return Some("NameError detected. Check variable/module names before rerunning.");
    }
    if lowered.contains("attributeerror") {
        return Some("AttributeError detected. Verify IDA API object names/methods.");
    }
    if lowered.contains("importerror") || lowered.contains("modulenotfounderror") {
        return Some("Import failure detected. Ensure the required module exists in IDAPython.");
    }
    if lowered.contains("failed to execute wrapper") {
        return Some(
            "IDAPython wrapper execution failed before user code completed. Check stderr for details.",
        );
    }
    None
}

fn run_script_failure_message(result: &Value) -> String {
    let stderr = run_script_field(result, "stderr").unwrap_or_default();
    let stdout = run_script_field(result, "stdout").unwrap_or_default();
    let summary = run_script_field(result, "error_summary")
        .or_else(|| run_script_field(result, "error"))
        .or_else(|| run_script_last_non_empty_line(stderr))
        .unwrap_or("Unknown IDAPython script failure (no error details captured)");

    let stderr_tail = run_script_truncate_chars(
        &run_script_tail_lines(stderr, RUN_SCRIPT_TAIL_LINES),
        RUN_SCRIPT_TAIL_CHARS,
    );
    let stdout_tail = run_script_truncate_chars(
        &run_script_tail_lines(stdout, RUN_SCRIPT_TAIL_LINES),
        RUN_SCRIPT_TAIL_CHARS,
    );

    let mut parts = vec![format!("IDAPython script execution failed: {summary}")];
    if let Some(kind) = run_script_field(result, "error_kind") {
        parts.push(format!("Error kind: {kind}"));
    }
    if !stderr_tail.is_empty() {
        parts.push(format!("stderr (tail):\n{stderr_tail}"));
    }
    if !stdout_tail.is_empty() {
        parts.push(format!("stdout (tail):\n{stdout_tail}"));
    }
    let combined_details = format!("{summary}\n{stderr_tail}");
    if let Some(hint) = run_script_error_hint(&combined_details) {
        parts.push(format!("Hint: {hint}"));
    }
    parts.join("\n\n")
}

fn run_script_timeout_message(timeout_secs: u64, code: &str) -> String {
    let compact_preview = code
        .lines()
        .map(str::trim)
        .filter(|line| !line.is_empty())
        .collect::<Vec<_>>()
        .join(" ");
    let preview = if compact_preview.is_empty() {
        "<empty script>".to_string()
    } else {
        run_script_truncate_chars(&compact_preview, RUN_SCRIPT_PREVIEW_CHARS)
    };
    format!(
        "run_script timed out after {timeout_secs} seconds.\n\
         The script may be blocked in a long-running loop or waiting on IDA state.\n\
         Script preview: {preview}\n\
         Hint: while iterating with LLM-generated code, use a smaller timeout_secs and avoid scripts that block indefinitely."
    )
}

async fn get_int_values(
    worker: &IdaWorker,
    address: Value,
    size: usize,
) -> Result<CallToolResult, McpError> {
    let addrs = match IdaMcpServer::value_to_addresses(&address) {
        Ok(v) => v,
        Err(e) => return Ok(e.to_tool_result()),
    };

    if addrs.len() == 1 {
        match worker.read_int(addrs[0], size).await {
            Ok(result) => Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string_pretty(&result).unwrap_or_else(|_| format!("{:?}", result)),
            )])),
            Err(e) => Ok(e.to_tool_result()),
        }
    } else {
        let mut results = Vec::new();
        for addr in addrs {
            match worker.read_int(addr, size).await {
                Ok(result) => results.push(json!({
                    "address": format!("{:#x}", addr),
                    "value": result
                })),
                Err(e) => results.push(json!({
                    "address": format!("{:#x}", addr),
                    "error": e.to_string()
                })),
            }
        }
        Ok(CallToolResult::success(vec![Content::text(
            serde_json::to_string_pretty(&json!({ "results": results }))
                .unwrap_or_else(|_| format!("{:?}", results)),
        )]))
    }
}

fn hex_encode(bytes: &[u8]) -> String {
    bytes.iter().map(|b| format!("{:02x}", b)).collect()
}

fn trim_bytes_le(bytes: &[u8]) -> Vec<u8> {
    let mut out = bytes.to_vec();
    while out.len() > 1 && out.last() == Some(&0) {
        out.pop();
    }
    out
}

fn trim_bytes_be(bytes: &[u8]) -> Vec<u8> {
    let mut start = 0usize;
    while start + 1 < bytes.len() && bytes[start] == 0 {
        start += 1;
    }
    bytes[start..].to_vec()
}

fn bytes_to_ascii(bytes: &[u8]) -> String {
    bytes
        .iter()
        .map(|b| {
            let c = *b as char;
            if c.is_ascii_graphic() || c == ' ' {
                c
            } else {
                '.'
            }
        })
        .collect()
}

fn tool_params_schema(name: &str) -> Option<Value> {
    fn schema<T: JsonSchema>() -> Value {
        serde_json::to_value(schema_for!(T)).unwrap_or_else(|_| json!({}))
    }

    match name {
        // Core
        "open_idb" => Some(schema::<OpenIdbRequest>()),
        "open_dsc" => Some(schema::<OpenDscRequest>()),
        "close_idb" => Some(schema::<CloseIdbRequest>()),
        "load_debug_info" => Some(schema::<LoadDebugInfoRequest>()),
        "analysis_status" => Some(schema::<EmptyParams>()),
        "tool_catalog" => Some(schema::<ToolCatalogRequest>()),
        "tool_help" => Some(schema::<ToolHelpRequest>()),
        "idb_meta" => Some(schema::<EmptyParams>()),

        // Functions
        "list_functions" | "list_funcs" => Some(schema::<ListFunctionsRequest>()),
        "resolve_function" => Some(schema::<ResolveFunctionRequest>()),
        "addr_info" => Some(schema::<AddrInfoRequest>()),
        "function_at" => Some(schema::<FunctionAtRequest>()),
        "lookup_funcs" => Some(schema::<LookupFuncsRequest>()),
        "analyze_funcs" => Some(schema::<AnalyzeFuncsRequest>()),

        // Disassembly / Decompile
        "disasm" => Some(schema::<DisasmRequest>()),
        "disasm_by_name" => Some(schema::<DisasmByNameRequest>()),
        "disasm_function_at" => Some(schema::<DisasmFunctionAtRequest>()),
        "decompile" => Some(schema::<DecompileRequest>()),
        "pseudocode_at" => Some(schema::<PseudocodeAtRequest>()),

        // Xrefs / Control flow
        "xrefs_to" | "xrefs_from" => Some(schema::<AddressRequest>()),
        "xref_matrix" => Some(schema::<XrefMatrixRequest>()),
        "basic_blocks" | "callers" | "callees" => Some(schema::<AddressRequest>()),
        "find_paths" => Some(schema::<FindPathsRequest>()),
        "callgraph" => Some(schema::<CallGraphRequest>()),

        // Memory / Search / Metadata
        "get_bytes" => Some(schema::<GetBytesRequest>()),
        "get_string" => Some(schema::<GetStringRequest>()),
        "get_u8" | "get_u16" | "get_u32" | "get_u64" => Some(schema::<AddressRequest>()),
        "get_global_value" => Some(schema::<GetGlobalValueRequest>()),
        "strings" => Some(schema::<StringsRequest>()),
        "find_string" => Some(schema::<FindStringRequest>()),
        "analyze_strings" => Some(schema::<AnalyzeStringsRequest>()),
        "xrefs_to_string" => Some(schema::<XrefsToStringRequest>()),
        "find_bytes" => Some(schema::<FindBytesRequest>()),
        "search" => Some(schema::<SearchRequest>()),
        "find_insns" => Some(schema::<FindInsnsRequest>()),
        "find_insn_operands" => Some(schema::<FindInsnOperandsRequest>()),
        "segments" => Some(schema::<EmptyParams>()),
        "imports" | "exports" => Some(schema::<PaginatedRequest>()),
        "export_funcs" => Some(schema::<ExportFuncsRequest>()),
        "entrypoints" => Some(schema::<EmptyParams>()),
        "list_globals" => Some(schema::<ListGlobalsRequest>()),
        "int_convert" => Some(schema::<IntConvertRequest>()),

        // Editing
        "set_comments" => Some(schema::<SetCommentsRequest>()),
        "rename" => Some(schema::<RenameRequest>()),
        "patch" => Some(schema::<PatchRequest>()),
        "patch_asm" => Some(schema::<PatchAsmRequest>()),

        // Types
        "structs" => Some(schema::<StructsRequest>()),
        "struct_info" => Some(schema::<StructInfoRequest>()),
        "read_struct" => Some(schema::<ReadStructRequest>()),
        "search_structs" => Some(schema::<StructsRequest>()),
        "local_types" => Some(schema::<LocalTypesRequest>()),
        "xrefs_to_field" => Some(schema::<XrefsToFieldRequest>()),
        "stack_frame" => Some(schema::<AddressRequest>()),
        "declare_type" => Some(schema::<DeclareTypeRequest>()),
        "apply_types" => Some(schema::<ApplyTypesRequest>()),
        "infer_types" => Some(schema::<InferTypesRequest>()),
        "declare_stack" => Some(schema::<DeclareStackRequest>()),
        "delete_stack" => Some(schema::<DeleteStackRequest>()),

        // Scripting
        "run_script" => Some(schema::<RunScriptRequest>()),

        _ => None,
    }
}

use rmcp::model::*;
use rmcp::service::{RequestContext, RoleServer};

/// Convert our internal `TaskState` to the rmcp `Task` model.
fn task_state_to_mcp(state: &task::TaskState) -> rmcp::model::Task {
    let status = match state.status {
        task::TaskStatus::Running => rmcp::model::TaskStatus::Working,
        task::TaskStatus::Completed => rmcp::model::TaskStatus::Completed,
        task::TaskStatus::Failed => rmcp::model::TaskStatus::Failed,
        task::TaskStatus::Cancelled => rmcp::model::TaskStatus::Cancelled,
    };
    rmcp::model::Task {
        task_id: state.id.clone(),
        status,
        status_message: Some(state.message.clone()),
        created_at: state.created_at_iso.clone(),
        last_updated_at: None,
        ttl: None,
        poll_interval: Some(5000),
    }
}

#[tool_handler(router = self.tool_mux)]
impl ServerHandler for IdaMcpServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .enable_tasks_with(rmcp::model::TasksCapability::server_default())
                .build(),
            instructions: Some(self.instructions()),
            ..Default::default()
        }
    }

    async fn enqueue_task(
        &self,
        request: CallToolRequestParams,
        context: RequestContext<RoleServer>,
    ) -> Result<CreateTaskResult, McpError> {
        // Delegate to the regular tool handler and wrap the result
        // into the task protocol.  For most tools the call completes
        // inline.  For `open_dsc`, the tool creates a background
        // task and returns a task_id — we re-use that ID.
        let result = self.call_tool(request, context).await?;

        // Check if the result contains a task_id from open_dsc.
        let task_id = result
            .content
            .first()
            .and_then(|c| c.as_text())
            .and_then(|t| serde_json::from_str::<Value>(&t.text).ok())
            .and_then(|v| v.get("task_id")?.as_str().map(String::from));

        if let Some(tid) = task_id {
            let state = self
                .task_registry
                .get(&tid)
                .ok_or_else(|| McpError::internal_error(format!("Task {tid} disappeared"), None))?;
            Ok(CreateTaskResult {
                task: task_state_to_mcp(&state),
            })
        } else {
            // Inline completion — no background work.
            let now = task::iso_now();
            let id = format!("inline-{now}");
            Ok(CreateTaskResult {
                task: rmcp::model::Task {
                    task_id: id,
                    status: rmcp::model::TaskStatus::Completed,
                    status_message: Some("Completed".into()),
                    created_at: now,
                    last_updated_at: None,
                    ttl: None,
                    poll_interval: None,
                },
            })
        }
    }

    async fn list_tasks(
        &self,
        _request: Option<PaginatedRequestParams>,
        _context: RequestContext<RoleServer>,
    ) -> Result<ListTasksResult, McpError> {
        let tasks: Vec<rmcp::model::Task> = self
            .task_registry
            .list_all()
            .iter()
            .map(task_state_to_mcp)
            .collect();
        Ok(ListTasksResult {
            tasks,
            next_cursor: None,
            total: None,
        })
    }

    async fn get_task_info(
        &self,
        request: GetTaskInfoParams,
        _context: RequestContext<RoleServer>,
    ) -> Result<GetTaskInfoResult, McpError> {
        let task = self
            .task_registry
            .get(&request.task_id)
            .map(|s| task_state_to_mcp(&s));
        Ok(GetTaskInfoResult { task })
    }

    async fn get_task_result(
        &self,
        request: GetTaskResultParams,
        _context: RequestContext<RoleServer>,
    ) -> Result<rmcp::model::TaskResult, McpError> {
        let state = self.task_registry.get(&request.task_id);
        match state {
            Some(s) if s.status == task::TaskStatus::Completed => Ok(rmcp::model::TaskResult {
                content_type: "application/json".into(),
                value: s.result.unwrap_or(Value::Null),
                summary: Some("DSC loading completed".into()),
            }),
            Some(s) if s.status == task::TaskStatus::Failed => {
                Err(McpError::internal_error(s.message, None))
            }
            Some(s) if s.status == task::TaskStatus::Cancelled => {
                Err(McpError::internal_error("Task was cancelled", None))
            }
            Some(_) => Err(McpError::internal_error(
                "Task is still running; poll tasks/get first",
                None,
            )),
            None => Err(McpError::invalid_params(
                "Unknown task_id",
                Some(json!({ "task_id": request.task_id })),
            )),
        }
    }

    async fn cancel_task(
        &self,
        request: CancelTaskParams,
        _context: RequestContext<RoleServer>,
    ) -> Result<(), McpError> {
        if self.task_registry.cancel(&request.task_id) {
            Ok(())
        } else {
            Err(McpError::invalid_params(
                "Task not found or not running",
                Some(json!({ "task_id": request.task_id })),
            ))
        }
    }
}

/// Wrapper that sanitizes tool schemas by removing `$schema` fields.
///
/// Some MCP clients (like Claude Desktop) choke on the JSON Schema `$schema` field.
/// This wrapper intercepts `list_tools` to remove these fields while delegating
/// all other methods to the inner server.
pub struct SanitizedIdaServer<S>(pub S);

impl<S> std::ops::Deref for SanitizedIdaServer<S> {
    type Target = S;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

/// Tools that support task-based invocation (SEP-1686).
const TASK_CAPABLE_TOOLS: &[&str] = &["open_dsc"];

/// Strips `$schema` keys from tool input schemas and annotates
/// task-capable tools with `execution.taskSupport = "optional"`.
fn sanitize_tool_schemas(result: &mut ListToolsResult) {
    for tool in &mut result.tools {
        let schema_arc = &mut tool.input_schema;
        if let Some(map) = std::sync::Arc::get_mut(schema_arc) {
            map.remove("$schema");
        } else {
            let mut map = (**schema_arc).clone();
            map.remove("$schema");
            *schema_arc = std::sync::Arc::new(map);
        }

        if TASK_CAPABLE_TOOLS.contains(&&*tool.name) {
            tool.execution = Some(
                rmcp::model::ToolExecution::new()
                    .with_task_support(rmcp::model::TaskSupport::Optional),
            );
        }
    }
}

/// Patch a single tool definition with task support if applicable.
fn annotate_task_support(mut tool: Tool) -> Tool {
    if TASK_CAPABLE_TOOLS.contains(&&*tool.name) {
        tool.execution = Some(
            rmcp::model::ToolExecution::new().with_task_support(rmcp::model::TaskSupport::Optional),
        );
    }
    tool
}

impl<S: ServerHandler + Send + Sync> ServerHandler for SanitizedIdaServer<S> {
    async fn initialize(
        &self,
        params: InitializeRequestParams,
        ctx: RequestContext<RoleServer>,
    ) -> Result<InitializeResult, McpError> {
        self.0.initialize(params, ctx).await
    }

    async fn list_tools(
        &self,
        params: Option<PaginatedRequestParams>,
        ctx: RequestContext<RoleServer>,
    ) -> Result<ListToolsResult, McpError> {
        let mut result = self.0.list_tools(params, ctx).await?;
        sanitize_tool_schemas(&mut result);
        Ok(result)
    }

    async fn call_tool(
        &self,
        params: CallToolRequestParams,
        ctx: RequestContext<RoleServer>,
    ) -> Result<CallToolResult, McpError> {
        self.0.call_tool(params, ctx).await
    }

    fn get_info(&self) -> ServerInfo {
        self.0.get_info()
    }

    fn get_tool(&self, name: &str) -> Option<Tool> {
        self.0.get_tool(name).map(annotate_task_support)
    }

    async fn enqueue_task(
        &self,
        request: CallToolRequestParams,
        ctx: RequestContext<RoleServer>,
    ) -> Result<CreateTaskResult, McpError> {
        self.0.enqueue_task(request, ctx).await
    }

    async fn list_tasks(
        &self,
        request: Option<PaginatedRequestParams>,
        ctx: RequestContext<RoleServer>,
    ) -> Result<ListTasksResult, McpError> {
        self.0.list_tasks(request, ctx).await
    }

    async fn get_task_info(
        &self,
        request: GetTaskInfoParams,
        ctx: RequestContext<RoleServer>,
    ) -> Result<GetTaskInfoResult, McpError> {
        self.0.get_task_info(request, ctx).await
    }

    async fn get_task_result(
        &self,
        request: GetTaskResultParams,
        ctx: RequestContext<RoleServer>,
    ) -> Result<rmcp::model::TaskResult, McpError> {
        self.0.get_task_result(request, ctx).await
    }

    async fn cancel_task(
        &self,
        request: CancelTaskParams,
        ctx: RequestContext<RoleServer>,
    ) -> Result<(), McpError> {
        self.0.cancel_task(request, ctx).await
    }
}

#[cfg(test)]
mod tests {
    use super::{
        run_script_failure_message, run_script_succeeded, run_script_timeout_message,
        run_script_truncate_chars,
    };
    use serde_json::json;

    #[test]
    fn run_script_succeeded_only_for_explicit_true() {
        assert!(run_script_succeeded(&json!({ "success": true })));
        assert!(!run_script_succeeded(&json!({ "success": false })));
        assert!(!run_script_succeeded(&json!({})));
    }

    #[test]
    fn run_script_failure_message_adds_syntax_hint() {
        let value = json!({
            "success": false,
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"<string>\", line 1\nSyntaxError: invalid syntax",
            "error": "invalid syntax"
        });
        let message = run_script_failure_message(&value);
        assert!(message.contains("IDAPython script execution failed"));
        assert!(message.contains("SyntaxError"));
        assert!(message.contains("Hint: Python syntax error detected"));
    }

    #[test]
    fn run_script_timeout_message_includes_preview() {
        let code = "import idaapi\nfor _ in range(1000000000):\n    pass\n";
        let message = run_script_timeout_message(120, code);
        assert!(message.contains("run_script timed out after 120 seconds"));
        assert!(message.contains("Script preview: import idaapi for _ in range(1000000000): pass"));
    }

    #[test]
    fn run_script_truncate_chars_appends_ellipsis() {
        let truncated = run_script_truncate_chars("abcdef", 3);
        assert_eq!(truncated, "abc...");
        let unchanged = run_script_truncate_chars("abc", 10);
        assert_eq!(unchanged, "abc");
    }
}

```

`src/server/requests.rs`:

```rs
//! MCP tool request types.
//!
//! These structs define the parameters for each MCP tool exposed by the server.

use rmcp::schemars::JsonSchema;
use serde::Deserialize;
use serde_json::Value;

#[derive(Debug, Deserialize, JsonSchema)]
pub struct OpenIdbRequest {
    #[schemars(
        description = "Path to an IDA database (.i64/.idb) or raw binary. Call close_idb when finished to release locks; in multi-client mode coordinate before closing."
    )]
    pub path: String,
    #[schemars(description = "If true, load external debug info (dSYM/DWARF) after open")]
    #[serde(alias = "load_dsym")]
    pub load_debug_info: Option<bool>,
    #[schemars(
        description = "Optional debug info path (dSYM DWARF). If omitted, tries sibling .dSYM"
    )]
    #[serde(alias = "dsym_path")]
    pub debug_info_path: Option<String>,
    #[schemars(description = "Verbose debug-info loading (default: false)")]
    pub debug_info_verbose: Option<bool>,
    #[schemars(
        description = "If true, clean up stale lock files from crashed sessions before opening. \
        Use this when a previous ida-mcp session crashed and left behind lock files."
    )]
    #[serde(alias = "recover")]
    pub force: Option<bool>,
    #[schemars(
        description = "IDA file type selector (-T flag). Used to choose a specific loader, \
        e.g. 'Apple DYLD cache for arm64e (single module(s))'. Only applies to raw binaries."
    )]
    pub file_type: Option<String>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct CloseIdbRequest {
    #[schemars(description = "Ownership token returned by open_idb (required for HTTP/SSE).")]
    #[serde(alias = "close_token", alias = "owner_token")]
    pub token: Option<String>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct LoadDebugInfoRequest {
    #[schemars(
        description = "Path to debug info file (e.g., dSYM DWARF). If omitted, tries sibling .dSYM for the current database."
    )]
    pub path: Option<String>,
    #[schemars(description = "Whether to emit verbose load status (default: false)")]
    pub verbose: Option<bool>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct EmptyParams {}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct ListFunctionsRequest {
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Maximum functions to return (1-10000, default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Optional filter - only return functions containing this text")]
    #[serde(alias = "query", alias = "queries", alias = "filter")]
    pub filter: Option<String>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct AnalyzeFuncsRequest {
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct ResolveFunctionRequest {
    #[schemars(description = "Function name to resolve (exact or partial match)")]
    pub name: String,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct AddrInfoRequest {
    #[schemars(description = "Address (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Function or symbol name (alternative to address)")]
    #[serde(alias = "name", alias = "symbol")]
    pub target_name: Option<String>,
    #[schemars(description = "Offset added to resolved name address (default: 0)")]
    pub offset: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct FunctionAtRequest {
    #[schemars(description = "Address (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Function or symbol name (alternative to address)")]
    #[serde(alias = "name", alias = "symbol")]
    pub target_name: Option<String>,
    #[schemars(description = "Offset added to resolved name address (default: 0)")]
    pub offset: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct DisasmFunctionAtRequest {
    #[schemars(description = "Address (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Function or symbol name (alternative to address)")]
    #[serde(alias = "name", alias = "symbol")]
    pub target_name: Option<String>,
    #[schemars(description = "Offset added to resolved name address (default: 0)")]
    pub offset: Option<u64>,
    #[schemars(description = "Number of instructions (1-5000, default: 200)")]
    pub count: Option<usize>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct DisasmRequest {
    #[schemars(description = "Address(es) to disassemble (string/number or array)")]
    #[serde(alias = "addrs", alias = "addr", alias = "addresses")]
    pub address: Value,
    #[schemars(description = "Number of instructions (1-1000, default: 10)")]
    pub count: Option<usize>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct DisasmByNameRequest {
    #[schemars(description = "Function name to disassemble (exact or partial match)")]
    pub name: String,
    #[schemars(description = "Number of instructions (1-1000, default: 10)")]
    pub count: Option<usize>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct DecompileRequest {
    #[schemars(description = "Address(es) of function to decompile (string/number or array)")]
    #[serde(alias = "addrs", alias = "addr", alias = "addresses")]
    pub address: Value,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct StringsRequest {
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Maximum strings to return (1-10000, default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Optional filter - only return strings containing this text")]
    #[serde(alias = "query")]
    pub filter: Option<String>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct FindStringRequest {
    #[schemars(description = "String to search for")]
    pub query: String,
    #[schemars(description = "Exact match (default: false)")]
    pub exact: Option<bool>,
    #[schemars(description = "Case-insensitive match (default: true)")]
    pub case_insensitive: Option<bool>,
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Maximum strings to return (1-10000, default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct XrefsToStringRequest {
    #[schemars(description = "String to search for")]
    pub query: String,
    #[schemars(description = "Exact match (default: false)")]
    pub exact: Option<bool>,
    #[schemars(description = "Case-insensitive match (default: true)")]
    pub case_insensitive: Option<bool>,
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Maximum strings to return (1-10000, default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Maximum xrefs per string (default: 64, max: 1024)")]
    pub max_xrefs: Option<usize>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct LocalTypesRequest {
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Maximum types to return (1-10000, default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Optional filter - only return types containing this text")]
    #[serde(alias = "query")]
    pub filter: Option<String>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct DeclareTypeRequest {
    #[schemars(description = "C declaration(s) to add to the local type library")]
    pub decl: String,
    #[schemars(description = "Relaxed parsing (allow unknown namespaces)")]
    pub relaxed: Option<bool>,
    #[schemars(description = "Replace existing type if it already exists")]
    pub replace: Option<bool>,
    #[schemars(description = "Parse multiple declarations in one input string")]
    pub multi: Option<bool>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct StructsRequest {
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Maximum structs to return (1-10000, default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Optional filter - only return structs containing this text")]
    #[serde(alias = "query")]
    pub filter: Option<String>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct StructInfoRequest {
    #[schemars(description = "Struct ordinal (numeric)")]
    pub ordinal: Option<u32>,
    #[schemars(description = "Struct name (exact match)")]
    #[serde(alias = "struct_name", alias = "type_name")]
    pub name: Option<String>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct ReadStructRequest {
    #[schemars(description = "Address of struct instance (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Value,
    #[schemars(description = "Struct ordinal (numeric)")]
    pub ordinal: Option<u32>,
    #[schemars(description = "Struct name (exact match)")]
    #[serde(alias = "struct_name", alias = "type_name")]
    pub name: Option<String>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct ApplyTypesRequest {
    #[schemars(description = "Address to apply type (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Function or symbol name (alternative to address)")]
    #[serde(alias = "name", alias = "symbol")]
    pub target_name: Option<String>,
    #[schemars(description = "Offset added to resolved name address (default: 0)")]
    pub offset: Option<u64>,
    #[schemars(description = "Stack variable offset (negative for locals)")]
    pub stack_offset: Option<i64>,
    #[schemars(description = "Stack variable name (when applying to stack var)")]
    pub stack_name: Option<String>,
    #[schemars(description = "Named type to apply")]
    pub type_name: Option<String>,
    #[schemars(description = "C declaration to parse and apply")]
    pub decl: Option<String>,
    #[schemars(description = "Relaxed parsing for decl")]
    pub relaxed: Option<bool>,
    #[schemars(description = "Delay function creation if missing")]
    pub delay: Option<bool>,
    #[schemars(description = "Strict application (no type conversion)")]
    pub strict: Option<bool>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct InferTypesRequest {
    #[schemars(description = "Address to infer type (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Function or symbol name (alternative to address)")]
    #[serde(alias = "name", alias = "symbol")]
    pub target_name: Option<String>,
    #[schemars(description = "Offset added to resolved name address (default: 0)")]
    pub offset: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct DeclareStackRequest {
    #[schemars(description = "Function address (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Function name (alternative to address)")]
    #[serde(alias = "function", alias = "name")]
    pub target_name: Option<String>,
    #[schemars(description = "Stack offset in bytes (negative for locals, positive for args)")]
    pub offset: i64,
    #[schemars(description = "Stack variable name (optional)")]
    pub var_name: Option<String>,
    #[schemars(description = "C declaration for the variable type")]
    pub decl: String,
    #[schemars(description = "Relaxed parsing for decl")]
    pub relaxed: Option<bool>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct DeleteStackRequest {
    #[schemars(description = "Function address (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Function name (alternative to address)")]
    #[serde(alias = "function", alias = "name")]
    pub target_name: Option<String>,
    #[schemars(description = "Stack offset in bytes (negative for locals, positive for args)")]
    pub offset: Option<i64>,
    #[schemars(description = "Stack variable name (optional)")]
    pub var_name: Option<String>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct XrefsToFieldRequest {
    #[schemars(description = "Struct ordinal (numeric)")]
    pub ordinal: Option<u32>,
    #[schemars(description = "Struct name (exact match)")]
    #[serde(alias = "struct_name", alias = "type_name")]
    pub name: Option<String>,
    #[schemars(description = "Struct member index (0-based)")]
    pub member_index: Option<u32>,
    #[schemars(description = "Struct member name (exact match)")]
    #[serde(alias = "member", alias = "field", alias = "field_name")]
    pub member_name: Option<String>,
    #[schemars(description = "Maximum xrefs to return (default: 1000, max: 10000)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct AddressRequest {
    #[schemars(description = "Address(es) (string/number or array)")]
    #[serde(alias = "addrs", alias = "addr", alias = "addresses")]
    pub address: Value,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct GetBytesRequest {
    #[schemars(description = "Address(es) to read from (string/number or array)")]
    #[serde(alias = "addrs", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Function or symbol name to read from (alternative to address)")]
    #[serde(alias = "name", alias = "symbol")]
    pub target_name: Option<String>,
    #[schemars(description = "Offset added to resolved name address (default: 0)")]
    pub offset: Option<u64>,
    #[schemars(description = "Number of bytes to read (1-65536, default: 256)")]
    #[serde(alias = "count")]
    pub size: Option<usize>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct SetCommentsRequest {
    #[schemars(description = "Address to comment (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Function or symbol name to comment (alternative to address)")]
    #[serde(alias = "name", alias = "symbol")]
    pub target_name: Option<String>,
    #[schemars(description = "Offset added to resolved name address (default: 0)")]
    pub offset: Option<u64>,
    #[schemars(description = "Comment text (empty string clears comment)")]
    #[serde(alias = "text", alias = "comment")]
    pub comment: String,
    #[schemars(description = "Repeatable comment (default: false)")]
    #[serde(alias = "rptble", alias = "repeatable")]
    pub repeatable: Option<bool>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct RenameRequest {
    #[schemars(description = "Address to rename (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Current name to resolve (alternative to address)")]
    #[serde(alias = "current", alias = "old_name", alias = "from")]
    pub current_name: Option<String>,
    #[schemars(description = "New name for the symbol")]
    #[serde(alias = "new_name", alias = "name")]
    pub name: String,
    #[schemars(description = "IDA set_name flags (optional)")]
    pub flags: Option<i32>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct PatchRequest {
    #[schemars(description = "Address to patch (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Function or symbol name to patch (alternative to address)")]
    #[serde(alias = "name", alias = "symbol")]
    pub target_name: Option<String>,
    #[schemars(description = "Offset added to resolved name address (default: 0)")]
    pub offset: Option<u64>,
    #[schemars(
        description = "Bytes to patch (hex string like '90 90' or array of ints/hex strings)"
    )]
    #[serde(alias = "data", alias = "bytes")]
    pub bytes: Value,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct PatchAsmRequest {
    #[schemars(description = "Address to patch (string/number)")]
    #[serde(alias = "ea", alias = "addr", alias = "addresses")]
    pub address: Option<Value>,
    #[schemars(description = "Function or symbol name to patch (alternative to address)")]
    #[serde(alias = "name", alias = "symbol")]
    pub target_name: Option<String>,
    #[schemars(description = "Offset added to resolved name address (default: 0)")]
    pub offset: Option<u64>,
    #[schemars(description = "Assembly text to assemble and patch")]
    #[serde(alias = "asm", alias = "instruction")]
    pub line: String,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct PaginatedRequest {
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Maximum items to return (default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct LookupFuncsRequest {
    #[schemars(description = "Function queries (string/number or array)")]
    #[serde(alias = "query", alias = "queries", alias = "names")]
    pub queries: Value,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct ListGlobalsRequest {
    #[schemars(description = "Optional filter for globals")]
    #[serde(alias = "filter")]
    pub query: Option<String>,
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Maximum globals to return (default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct AnalyzeStringsRequest {
    #[schemars(description = "Optional filter for strings")]
    #[serde(alias = "filter")]
    pub query: Option<String>,
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Maximum strings to return (default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct FindBytesRequest {
    #[schemars(description = "Pattern(s) to search for (string or array)")]
    #[serde(alias = "pattern", alias = "patterns")]
    pub patterns: Value,
    #[schemars(description = "Maximum matches to return (default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct SearchRequest {
    #[schemars(description = "Targets to search for (string/number or array)")]
    #[serde(alias = "query", alias = "queries", alias = "targets")]
    pub targets: Value,
    #[schemars(description = "Search type: text or imm (optional)")]
    #[serde(alias = "type")]
    pub kind: Option<String>,
    #[schemars(description = "Maximum matches to return (default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct FindInsnsRequest {
    #[schemars(description = "Instruction mnemonic(s) or sequence (string/number or array)")]
    #[serde(
        alias = "pattern",
        alias = "patterns",
        alias = "query",
        alias = "queries",
        alias = "mnemonic",
        alias = "mnemonics"
    )]
    pub patterns: Value,
    #[schemars(description = "Maximum matches to return (default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Case-insensitive match (default: false)")]
    pub case_insensitive: Option<bool>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct FindInsnOperandsRequest {
    #[schemars(description = "Operand substring(s) to match (string/number or array)")]
    #[serde(
        alias = "pattern",
        alias = "patterns",
        alias = "query",
        alias = "queries",
        alias = "operands"
    )]
    pub patterns: Value,
    #[schemars(description = "Maximum matches to return (default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Case-insensitive match (default: false)")]
    pub case_insensitive: Option<bool>,
    #[schemars(description = "Timeout in seconds for this operation (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct FindPathsRequest {
    #[schemars(description = "Start address (string/number)")]
    pub start: Value,
    #[schemars(description = "End address (string/number)")]
    pub end: Value,
    #[schemars(description = "Maximum paths to return (default: 8)")]
    pub max_paths: Option<usize>,
    #[schemars(description = "Maximum path depth (default: 64)")]
    pub max_depth: Option<usize>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct CallGraphRequest {
    #[schemars(description = "Root function address(es) (string/number or array)")]
    #[serde(
        alias = "root",
        alias = "roots",
        alias = "addr",
        alias = "address",
        alias = "addrs"
    )]
    pub roots: Value,
    #[schemars(description = "Maximum depth (default: 2)")]
    pub max_depth: Option<usize>,
    #[schemars(description = "Maximum nodes (default: 256)")]
    pub max_nodes: Option<usize>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct XrefMatrixRequest {
    #[schemars(description = "Addresses to include in matrix (string/number or array)")]
    #[serde(alias = "addr", alias = "address", alias = "addresses")]
    pub addrs: Value,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct ExportFuncsRequest {
    #[schemars(description = "Function address(es) to export (optional)")]
    #[serde(
        alias = "addrs",
        alias = "addr",
        alias = "address",
        alias = "functions"
    )]
    pub addrs: Option<Value>,
    #[schemars(description = "Offset for pagination (default: 0)")]
    pub offset: Option<usize>,
    #[schemars(description = "Maximum functions to return (default: 100)")]
    #[serde(alias = "count")]
    pub limit: Option<usize>,
    #[schemars(description = "Export format (only json supported)")]
    pub format: Option<String>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct GetStringRequest {
    #[schemars(description = "Address(es) to read string from (string/number or array)")]
    #[serde(alias = "addrs", alias = "addr", alias = "addresses")]
    pub address: Value,
    #[schemars(description = "Maximum length to read (default: 256)")]
    pub max_len: Option<usize>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct GetGlobalValueRequest {
    #[schemars(description = "Global name(s) or address(es) (string/number or array)")]
    #[serde(alias = "query", alias = "queries", alias = "names", alias = "addrs")]
    pub query: Value,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct IntConvertRequest {
    #[schemars(description = "Values to convert (string/number or array)")]
    #[serde(alias = "input", alias = "inputs")]
    pub inputs: Value,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct PseudocodeAtRequest {
    #[schemars(description = "Address(es) to get pseudocode for (string/number or array)")]
    #[serde(alias = "addrs", alias = "addr", alias = "addresses")]
    pub address: Value,
    #[schemars(description = "Optional end address for range query (for basic blocks)")]
    pub end_address: Option<String>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct ToolCatalogRequest {
    #[schemars(
        description = "What you're trying to accomplish (e.g., 'find all callers of a function')"
    )]
    pub query: Option<String>,
    #[schemars(
        description = "Filter by category: core, functions, disassembly, decompile, xrefs, control_flow, memory, search, metadata, types, editing, debug, ui, scripting"
    )]
    pub category: Option<String>,
    #[schemars(description = "Maximum number of tools to return (default: 7)")]
    pub limit: Option<usize>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct ToolHelpRequest {
    #[schemars(description = "Name of the tool to get help for")]
    pub name: String,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct RunScriptRequest {
    #[schemars(
        description = "Python code to execute via IDAPython. Has full access to ida_* modules, \
        idc, idautils. stdout/stderr are captured and returned. \
        Provide either 'code' (inline) or 'file' (path to .py), not both."
    )]
    pub code: Option<String>,
    #[schemars(description = "Path to a .py file to execute via IDAPython. \
        Alternative to 'code' for longer scripts. The file is read server-side.")]
    pub file: Option<String>,
    #[schemars(description = "Execution timeout in seconds (default: 120, max: 600)")]
    pub timeout_secs: Option<u64>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct TaskStatusRequest {
    #[schemars(description = "Task ID returned by open_dsc (e.g. 'dsc-abc123')")]
    pub task_id: String,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct OpenDscRequest {
    #[schemars(description = "Path to the dyld_shared_cache file")]
    pub path: String,
    #[schemars(description = "CPU architecture (e.g. 'arm64e', 'arm64', 'x86_64h')")]
    pub arch: String,
    #[schemars(description = "Primary dylib to load (e.g. '/usr/lib/libobjc.A.dylib')")]
    pub module: String,
    #[schemars(description = "Additional frameworks to load after opening \
        (e.g. ['/System/Library/Frameworks/Foundation.framework/Foundation'])")]
    pub frameworks: Option<Vec<String>>,
    #[schemars(description = "IDA version: 8 or 9. Determines the -T format string. Default: 9")]
    pub ida_version: Option<u8>,
    #[schemars(description = "Path to write idat's log file (-L flag). \
        If omitted, no log is created. Useful for debugging DSC loading failures.")]
    pub log_path: Option<String>,
}

```

`src/server/task.rs`:

```rs
//! Lightweight in-process task registry for background operations.
//!
//! Serves two consumers:
//! - The custom `task_status` MCP tool (universal fallback for all clients)
//! - The native MCP Tasks protocol (SEP-1686) via `ServerHandler` methods

use serde_json::Value;
use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::{Arc, Mutex};
use std::time::Instant;
use tokio::task::JoinHandle;

/// Task status in its lifecycle.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TaskStatus {
    Running,
    Completed,
    Failed,
    Cancelled,
}

/// Snapshot of a background task's state (cloneable, no handles).
#[derive(Debug, Clone)]
pub struct TaskState {
    pub id: String,
    pub status: TaskStatus,
    pub message: String,
    pub result: Option<Value>,
    pub created_at: Instant,
    /// ISO-8601 creation timestamp for the MCP protocol.
    pub created_at_iso: String,
    /// Deduplication key (e.g. the output .i64 path).
    pub key: Option<String>,
}

/// Internal entry that owns the abort handle.
struct TaskEntry {
    state: TaskState,
    handle: Option<JoinHandle<()>>,
}

/// Thread-safe registry of background tasks.
#[derive(Clone)]
pub struct TaskRegistry {
    inner: Arc<Mutex<HashMap<String, TaskEntry>>>,
}

impl Default for TaskRegistry {
    fn default() -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

impl TaskRegistry {
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a task with a deduplication key. If a running task with
    /// the same key already exists, returns `Err(existing_task_id)`.
    pub fn create_keyed(&self, key: &str, message: &str) -> Result<String, String> {
        let mut entries = self.inner.lock().unwrap_or_else(|e| e.into_inner());

        for entry in entries.values() {
            if entry.state.status == TaskStatus::Running {
                if let Some(existing_key) = &entry.state.key {
                    if existing_key == key {
                        return Err(entry.state.id.clone());
                    }
                }
            }
        }

        let id = next_task_id();
        let state = TaskState {
            id: id.clone(),
            status: TaskStatus::Running,
            message: message.to_string(),
            result: None,
            created_at: Instant::now(),
            created_at_iso: iso_now(),
            key: Some(key.to_string()),
        };
        entries.insert(
            id.clone(),
            TaskEntry {
                state,
                handle: None,
            },
        );
        Ok(id)
    }

    /// Store the `JoinHandle` for a task so it can be cancelled.
    pub fn set_handle(&self, id: &str, handle: JoinHandle<()>) {
        let mut entries = self.inner.lock().unwrap_or_else(|e| e.into_inner());
        if let Some(entry) = entries.get_mut(id) {
            entry.handle = Some(handle);
        }
    }

    /// Get a cloneable snapshot of a task's current state.
    pub fn get(&self, id: &str) -> Option<TaskState> {
        let entries = self.inner.lock().unwrap_or_else(|e| e.into_inner());
        entries.get(id).map(|e| e.state.clone())
    }

    /// List all tasks (snapshots only).
    pub fn list_all(&self) -> Vec<TaskState> {
        let entries = self.inner.lock().unwrap_or_else(|e| e.into_inner());
        entries.values().map(|e| e.state.clone()).collect()
    }

    /// Update the progress message on a running task.
    pub fn update_message(&self, id: &str, message: &str) {
        let mut entries = self.inner.lock().unwrap_or_else(|e| e.into_inner());
        if let Some(entry) = entries.get_mut(id) {
            entry.state.message = message.to_string();
        }
    }

    /// Mark a task as completed with a JSON result.
    pub fn complete(&self, id: &str, result: Value) {
        let mut entries = self.inner.lock().unwrap_or_else(|e| e.into_inner());
        if let Some(entry) = entries.get_mut(id) {
            entry.state.status = TaskStatus::Completed;
            entry.state.message = "Completed".to_string();
            entry.state.result = Some(result);
            entry.handle = None;
        }
    }

    /// Mark a task as failed with an error message.
    pub fn fail(&self, id: &str, error: &str) {
        let mut entries = self.inner.lock().unwrap_or_else(|e| e.into_inner());
        if let Some(entry) = entries.get_mut(id) {
            entry.state.status = TaskStatus::Failed;
            entry.state.message = error.to_string();
            entry.handle = None;
        }
    }

    /// Cancel a running task. Returns `true` if the task was running
    /// and has been aborted.
    pub fn cancel(&self, id: &str) -> bool {
        let mut entries = self.inner.lock().unwrap_or_else(|e| e.into_inner());
        if let Some(entry) = entries.get_mut(id) {
            if entry.state.status == TaskStatus::Running {
                if let Some(handle) = entry.handle.take() {
                    handle.abort();
                }
                entry.state.status = TaskStatus::Cancelled;
                entry.state.message = "Cancelled by client".to_string();
                return true;
            }
        }
        false
    }
}

/// Generate a unique task ID using an atomic counter.
fn next_task_id() -> String {
    static COUNTER: AtomicU64 = AtomicU64::new(1);
    let n = COUNTER.fetch_add(1, Ordering::Relaxed);
    format!("dsc-{n}")
}

/// ISO-8601 timestamp for the current time (UTC).
pub fn iso_now() -> String {
    use std::time::SystemTime;
    let duration = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap_or_default();
    let secs = duration.as_secs();
    // Manual UTC formatting to avoid adding chrono dependency.
    // Good enough for task timestamps.
    let days = secs / 86400;
    let time_secs = secs % 86400;
    let hours = time_secs / 3600;
    let minutes = (time_secs % 3600) / 60;
    let seconds = time_secs % 60;

    // Days since epoch to Y-M-D (simplified leap year handling)
    let (year, month, day) = epoch_days_to_ymd(days);
    format!("{year:04}-{month:02}-{day:02}T{hours:02}:{minutes:02}:{seconds:02}Z")
}

fn epoch_days_to_ymd(days: u64) -> (u64, u64, u64) {
    // Algorithm from Howard Hinnant's date library
    let z = days + 719_468;
    let era = z / 146_097;
    let doe = z - era * 146_097;
    let yoe = (doe - doe / 1460 + doe / 36524 - doe / 146_096) / 365;
    let y = yoe + era * 400;
    let doy = doe - (365 * yoe + yoe / 4 - yoe / 100);
    let mp = (5 * doy + 2) / 153;
    let d = doy - (153 * mp + 2) / 5 + 1;
    let m = if mp < 10 { mp + 3 } else { mp - 9 };
    let year = if m <= 2 { y + 1 } else { y };
    (year, m, d)
}

#[cfg(test)]
mod tests {
    use crate::server::task::{TaskRegistry, TaskStatus};
    use serde_json::json;

    #[test]
    fn create_and_get() {
        let registry = TaskRegistry::new();
        let id = registry
            .create_keyed("test-key", "Starting")
            .expect("should succeed");
        let state = registry.get(&id).expect("task should exist");
        assert_eq!(state.status, TaskStatus::Running);
        assert_eq!(state.message, "Starting");
        assert!(state.result.is_none());
        assert!(!state.created_at_iso.is_empty());
    }

    #[test]
    fn update_message() {
        let registry = TaskRegistry::new();
        let id = registry
            .create_keyed("k1", "Phase 1")
            .expect("should succeed");
        registry.update_message(&id, "Phase 2");
        let state = registry.get(&id).expect("task should exist");
        assert_eq!(state.message, "Phase 2");
    }

    #[test]
    fn complete_task() {
        let registry = TaskRegistry::new();
        let id = registry
            .create_keyed("k2", "Working")
            .expect("should succeed");
        let result = json!({"db": "opened"});
        registry.complete(&id, result.clone());
        let state = registry.get(&id).expect("task should exist");
        assert_eq!(state.status, TaskStatus::Completed);
        assert_eq!(state.result, Some(result));
    }

    #[test]
    fn fail_task() {
        let registry = TaskRegistry::new();
        let id = registry
            .create_keyed("k3", "Working")
            .expect("should succeed");
        registry.fail(&id, "idat exited with code 4");
        let state = registry.get(&id).expect("task should exist");
        assert_eq!(state.status, TaskStatus::Failed);
        assert_eq!(state.message, "idat exited with code 4");
    }

    #[test]
    fn get_nonexistent() {
        let registry = TaskRegistry::new();
        assert!(registry.get("dsc-nope").is_none());
    }

    #[test]
    fn keyed_dedup_prevents_duplicate() {
        let registry = TaskRegistry::new();
        let id1 = registry
            .create_keyed("/path/to/dsc.i64", "First")
            .expect("first should succeed");
        let dup = registry.create_keyed("/path/to/dsc.i64", "Second");
        assert_eq!(dup, Err(id1.clone()));

        // After completing, a new task with the same key can be created.
        registry.complete(&id1, json!({}));
        let id2 = registry
            .create_keyed("/path/to/dsc.i64", "Third")
            .expect("should succeed after first completed");
        assert_ne!(id1, id2);
    }

    #[test]
    fn cancel_running_task() {
        let registry = TaskRegistry::new();
        let id = registry
            .create_keyed("k4", "Working")
            .expect("should succeed");
        assert!(registry.cancel(&id));
        let state = registry.get(&id).expect("task should exist");
        assert_eq!(state.status, TaskStatus::Cancelled);

        // Cancelling again returns false.
        assert!(!registry.cancel(&id));
    }

    #[test]
    fn list_all_tasks() {
        let registry = TaskRegistry::new();
        let _ = registry.create_keyed("a", "Task A");
        let _ = registry.create_keyed("b", "Task B");
        assert_eq!(registry.list_all().len(), 2);
    }

    #[test]
    fn iso_timestamp_format() {
        let registry = TaskRegistry::new();
        let id = registry
            .create_keyed("ts", "Timestamp test")
            .expect("should succeed");
        let state = registry.get(&id).expect("task should exist");
        // Should match YYYY-MM-DDTHH:MM:SSZ
        assert!(
            state.created_at_iso.len() == 20,
            "unexpected ISO length: {}",
            state.created_at_iso
        );
        assert!(state.created_at_iso.ends_with('Z'));
    }
}

```

`src/tool_registry.rs`:

```rs
//! Tool registry for dynamic tool discovery.
//!
//! All tools are exposed in tools/list by default to support MCP clients that only
//! register tools at connection time. `tool_catalog` is still recommended for discovery.

use serde::{Deserialize, Serialize};
use std::str::FromStr;

/// Tool category for grouping related tools
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ToolCategory {
    /// Core database operations (always available)
    Core,
    /// Function navigation and discovery
    Functions,
    /// Disassembly tools
    Disassembly,
    /// Decompilation tools (requires Hex-Rays)
    Decompile,
    /// Cross-reference analysis
    Xrefs,
    /// Control flow and call graph analysis
    ControlFlow,
    /// Memory and data reading
    Memory,
    /// Search and pattern matching
    Search,
    /// Metadata and structure info
    Metadata,
    /// Type/struct/stack information and type application
    Types,
    /// Editing and patching operations
    Editing,
    /// Debugger operations
    Debug,
    /// UI/cursor helpers
    Ui,
    /// Scripting/eval helpers
    Scripting,
}

impl ToolCategory {
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Core => "core",
            Self::Functions => "functions",
            Self::Disassembly => "disassembly",
            Self::Decompile => "decompile",
            Self::Xrefs => "xrefs",
            Self::ControlFlow => "control_flow",
            Self::Memory => "memory",
            Self::Search => "search",
            Self::Metadata => "metadata",
            Self::Types => "types",
            Self::Editing => "editing",
            Self::Debug => "debug",
            Self::Ui => "ui",
            Self::Scripting => "scripting",
        }
    }

    pub fn description(&self) -> &'static str {
        match self {
            Self::Core => "Database open/close and discovery tools",
            Self::Functions => "List, search, and resolve functions",
            Self::Disassembly => "Disassemble code at addresses",
            Self::Decompile => "Decompile functions to pseudocode (requires Hex-Rays)",
            Self::Xrefs => "Cross-reference analysis (xrefs to/from)",
            Self::ControlFlow => "Basic blocks, call graphs, control flow",
            Self::Memory => "Read bytes, strings, and data",
            Self::Search => "Search for bytes, strings, patterns",
            Self::Metadata => "Database info, segments, imports, exports",
            Self::Types => "Types, structs, and stack variable info",
            Self::Editing => "Patching, renaming, and comment editing",
            Self::Debug => "Debugger operations (headless unsupported)",
            Self::Ui => "UI/cursor helpers (headless unsupported)",
            Self::Scripting => "Execute Python scripts via IDAPython",
        }
    }

    pub fn all() -> &'static [ToolCategory] {
        &[
            Self::Core,
            Self::Functions,
            Self::Disassembly,
            Self::Decompile,
            Self::Xrefs,
            Self::ControlFlow,
            Self::Memory,
            Self::Search,
            Self::Metadata,
            Self::Types,
            Self::Editing,
            Self::Debug,
            Self::Ui,
            Self::Scripting,
        ]
    }
}

impl FromStr for ToolCategory {
    type Err = ();

    fn from_str(input: &str) -> Result<Self, Self::Err> {
        let normalized = input.trim().to_lowercase().replace(['-', ' '], "_");
        match normalized.as_str() {
            "core" => Ok(Self::Core),
            "functions" | "function" => Ok(Self::Functions),
            "disassembly" | "disasm" => Ok(Self::Disassembly),
            "decompile" | "decompiler" => Ok(Self::Decompile),
            "xrefs" | "xref" | "references" => Ok(Self::Xrefs),
            "control_flow" | "controlflow" | "cfg" => Ok(Self::ControlFlow),
            "memory" | "data" => Ok(Self::Memory),
            "search" => Ok(Self::Search),
            "metadata" | "meta" | "info" => Ok(Self::Metadata),
            "types" | "type" | "structs" => Ok(Self::Types),
            "editing" | "edit" => Ok(Self::Editing),
            "debug" | "debugger" => Ok(Self::Debug),
            "ui" => Ok(Self::Ui),
            "scripting" | "script" | "eval" => Ok(Self::Scripting),
            _ => Err(()),
        }
    }
}

/// Metadata for a single tool
#[derive(Debug, Clone)]
pub struct ToolInfo {
    pub name: &'static str,
    pub category: ToolCategory,
    /// Short description (1 line, <100 chars) - used in tool_catalog results
    pub short_desc: &'static str,
    /// Full description with usage details - used in tool_help
    pub full_desc: &'static str,
    /// Example invocation (JSON)
    pub example: &'static str,
    /// Whether this tool is in the default (core) set
    pub default: bool,
    /// Keywords for semantic search
    pub keywords: &'static [&'static str],
}

/// Static registry of all tools
pub static TOOL_REGISTRY: &[ToolInfo] = &[
    // === CORE (always available) ===
    ToolInfo {
        name: "open_idb",
        category: ToolCategory::Core,
        short_desc: "Open an IDA database or raw binary",
        full_desc: "Open an IDA Pro database file or a raw binary for analysis. \
                    Supports .i64 (64-bit) and .idb (32-bit) databases, as well as raw binaries \
                    like Mach-O/ELF/PE. Raw binaries are auto-analyzed and saved as .i64 alongside the input. \
                    If opening a raw binary with no existing .i64 and a sibling .dSYM is present, \
                    its DWARF debug info is loaded automatically. \
                    Set load_debug_info=true to force loading external debug info after open \
                    (optionally specify debug_info_path). \
                    The database must be opened before using any other analysis tools. \
                    Call close_idb when finished to release database locks; in multi-client servers, coordinate before closing. \
                    In HTTP/SSE mode, open_idb returns a close_token that must be provided to close_idb. \
                    Returns metadata about the binary: file type, processor, bitness, function count.",
        example: r#"{"path": "/path/to/binary", "load_debug_info": true}"#,
        default: true,
        keywords: &["open", "load", "database", "binary", "idb", "i64", "macho", "elf", "pe"],
    },
    ToolInfo {
        name: "open_dsc",
        category: ToolCategory::Core,
        short_desc: "Open a dyld_shared_cache and load a single module",
        full_desc: "Open an Apple dyld_shared_cache file and extract a single dylib for analysis. \
                    Handles DSC-specific loader selection and dscu plugin orchestration automatically. \
                    After opening, runs ObjC type and block analysis on the loaded module. \
                    Use this instead of open_idb when working with dyld_shared_cache files. \
                    Optionally load additional frameworks to resolve cross-module references.",
        example: r#"{"path": "/path/to/dyld_shared_cache_arm64e", "arch": "arm64e", "module": "/usr/lib/libobjc.A.dylib", "frameworks": ["/System/Library/Frameworks/Foundation.framework/Foundation"]}"#,
        default: false,
        keywords: &["open", "dsc", "dyld", "shared", "cache", "dylib", "module", "apple", "macos", "ios"],
    },
    ToolInfo {
        name: "load_debug_info",
        category: ToolCategory::Core,
        short_desc: "Load external debug info (e.g., dSYM/DWARF)",
        full_desc: "Load external debug info (e.g., DWARF from a dSYM) into the current database. \
                    If path is omitted, attempts to locate a sibling .dSYM for the currently-open database. \
                    Returns whether the load succeeded.",
        example: r#"{"path": "/path/to/binary.dSYM/Contents/Resources/DWARF/binary"}"#,
        default: false,
        keywords: &["debug", "dwarf", "dsym", "symbols", "load"],
    },
    ToolInfo {
        name: "analysis_status",
        category: ToolCategory::Core,
        short_desc: "Report auto-analysis status",
        full_desc: "Report auto-analysis status (auto_is_ok, auto_state) so clients can \
                    determine whether analysis-dependent tools like xrefs or decompile are fully ready.",
        example: r#"{}"#,
        default: true,
        keywords: &["analysis", "autoanalysis", "status", "xrefs", "decompile"],
    },
    ToolInfo {
        name: "close_idb",
        category: ToolCategory::Core,
        short_desc: "Close the current database (release locks)",
        full_desc: "Close the currently open IDA database, releasing resources. \
                    Call this when done with analysis or before opening a different database. \
                    In multi-client servers, coordinate before closing to avoid interrupting others. \
                    In HTTP/SSE mode, provide the close_token returned by open_idb.",
        example: r#"{"close_token": "token-from-open-idb"}"#,
        default: true,
        keywords: &["close", "unload", "database"],
    },
    ToolInfo {
        name: "tool_catalog",
        category: ToolCategory::Core,
        short_desc: "Discover available tools by query or category",
        full_desc: "Search for relevant tools based on what you're trying to accomplish. \
                    Returns tool names with short descriptions and relevance reasons. \
                    Use this to find the right tool before calling tool_help for full details.",
        example: r#"{"query": "find all callers of a function"}"#,
        default: true,
        keywords: &["discover", "find", "search", "tools", "help", "catalog"],
    },
    ToolInfo {
        name: "tool_help",
        category: ToolCategory::Core,
        short_desc: "Get full documentation for a tool",
        full_desc: "Returns complete documentation for a specific tool including: \
                    full description, parameter schema, and example invocation. \
                    Use tool_catalog first to find the tool name.",
        example: r#"{"name": "list_functions"}"#,
        default: true,
        keywords: &["help", "docs", "documentation", "schema", "usage"],
    },
    ToolInfo {
        name: "task_status",
        category: ToolCategory::Core,
        short_desc: "Check status of a background task (e.g. DSC loading)",
        full_desc: "Check the status of a background task started by open_dsc. \
                    Returns 'running' (with progress message), 'completed' (with db_info — \
                    database is already open and ready for analysis), or 'failed' (with error). \
                    Use the task_id returned by open_dsc when a new .i64 must be created.",
        example: r#"{"task_id": "dsc-abc123"}"#,
        default: true,
        keywords: &["task", "status", "poll", "background", "dsc", "progress"],
    },
    ToolInfo {
        name: "idb_meta",
        category: ToolCategory::Core,
        short_desc: "Get database metadata and summary",
        full_desc: "Returns metadata about the currently open database: \
                    file type, processor architecture, bitness, entry points, \
                    segment count, function count, and other summary info.",
        example: r#"{}"#,
        default: true,
        keywords: &["info", "metadata", "summary", "database", "binary"],
    },

    // === FUNCTIONS ===
    ToolInfo {
        name: "list_functions",
        category: ToolCategory::Functions,
        short_desc: "List functions with pagination and filtering",
        full_desc: "List all functions in the database with optional name filtering. \
                    Supports pagination via offset/limit. Returns function address, name, and size. \
                    Use filter parameter to search by substring in function name.",
        example: r#"{"offset": 0, "limit": 100, "filter": "init"}"#,
        default: false,
        keywords: &["functions", "list", "enumerate", "find", "filter", "subroutines"],
    },
    ToolInfo {
        name: "list_funcs",
        category: ToolCategory::Functions,
        short_desc: "Alias of list_functions",
        full_desc: "Alias of list_functions. Lists all functions in the database with pagination \
                    and optional name filtering.",
        example: r#"{"offset": 0, "limit": 100, "filter": "init"}"#,
        default: false,
        keywords: &["functions", "list", "alias"],
    },
    ToolInfo {
        name: "resolve_function",
        category: ToolCategory::Functions,
        short_desc: "Find function address by name",
        full_desc: "Resolve a function name to its address. Supports exact names and demangled names. \
                    Returns the function's address, full name, and size if found.",
        example: r#"{"name": "main"}"#,
        default: false,
        keywords: &["resolve", "find", "lookup", "function", "name", "address"],
    },
    ToolInfo {
        name: "function_at",
        category: ToolCategory::Functions,
        short_desc: "Find the function containing an address",
        full_desc: "Return the function that contains the given address, including start/end and size. \
                    Useful for mapping PC/LR to a function.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["function", "address", "pc", "lr", "containing"],
    },
    ToolInfo {
        name: "lookup_funcs",
        category: ToolCategory::Functions,
        short_desc: "Batch lookup multiple functions by name",
        full_desc: "Look up multiple function names at once. Returns address and size for each found function. \
                    More efficient than multiple resolve_function calls.",
        example: r#"{"names": ["main", "printf", "malloc"]}"#,
        default: false,
        keywords: &["lookup", "batch", "multiple", "functions", "names"],
    },
    ToolInfo {
        name: "analyze_funcs",
        category: ToolCategory::Functions,
        short_desc: "Run auto-analysis and wait for completion",
        full_desc: "Run IDA auto-analysis and wait for completion. \
                    Returns whether analysis completed and current function count.",
        example: r#"{"timeout_secs": 120}"#,
        default: false,
        keywords: &["analyze", "functions", "analysis", "auto"],
    },

    // === DISASSEMBLY ===
    ToolInfo {
        name: "disasm",
        category: ToolCategory::Disassembly,
        short_desc: "Disassemble instructions at an address",
        full_desc: "Disassemble machine code starting at the given address. \
                    Returns assembly instructions with addresses and opcodes. \
                    Specify count to control how many instructions to disassemble.",
        example: r#"{"address": "0x1000", "count": 20}"#,
        default: false,
        keywords: &["disassemble", "disasm", "assembly", "instructions", "code"],
    },
    ToolInfo {
        name: "disasm_by_name",
        category: ToolCategory::Disassembly,
        short_desc: "Disassemble a function by name",
        full_desc: "Disassemble a function given its name. Resolves the name to an address \
                    and disassembles the specified number of instructions.",
        example: r#"{"name": "main", "count": 50}"#,
        default: false,
        keywords: &["disassemble", "function", "name", "assembly"],
    },
    ToolInfo {
        name: "disasm_function_at",
        category: ToolCategory::Disassembly,
        short_desc: "Disassemble the function containing an address",
        full_desc: "Disassemble the function that contains the provided address. \
                    Useful when you only have a PC/LR.",
        example: r#"{"address": "0x1000", "count": 200}"#,
        default: false,
        keywords: &["disassemble", "function", "address", "pc", "lr"],
    },

    // === DECOMPILE ===
    ToolInfo {
        name: "decompile",
        category: ToolCategory::Decompile,
        short_desc: "Decompile function to C pseudocode",
        full_desc: "Decompile a function using Hex-Rays decompiler (if available). \
                    Returns C-like pseudocode. Accepts address or function name.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["decompile", "pseudocode", "c", "source", "hex-rays"],
    },
    ToolInfo {
        name: "pseudocode_at",
        category: ToolCategory::Decompile,
        short_desc: "Get pseudocode for specific address/range",
        full_desc: "Get decompiled pseudocode for a specific address or address range (e.g., a basic block). \
                    Unlike decompile which returns the full function, this returns only statements \
                    corresponding to the given address(es).",
        example: r#"{"address": "0x1000", "end_address": "0x1020"}"#,
        default: false,
        keywords: &["pseudocode", "decompile", "block", "range", "statement"],
    },

    // === XREFS ===
    ToolInfo {
        name: "xrefs_to",
        category: ToolCategory::Xrefs,
        short_desc: "Find all references TO an address",
        full_desc: "Find all cross-references pointing to the given address. \
                    Shows what code/data references this location. \
                    Useful for finding callers, data usage, etc.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["xrefs", "references", "to", "callers", "usage"],
    },
    ToolInfo {
        name: "xrefs_from",
        category: ToolCategory::Xrefs,
        short_desc: "Find all references FROM an address",
        full_desc: "Find all cross-references originating from the given address. \
                    Shows what this instruction/data references. \
                    Useful for finding callees, data accesses, etc.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["xrefs", "references", "from", "callees", "targets"],
    },
    ToolInfo {
        name: "xrefs_to_string",
        category: ToolCategory::Xrefs,
        short_desc: "Find xrefs to strings matching a query",
        full_desc: "Find strings that match a query and return xrefs to each match. \
                    Useful for 'xref to cstring' workflows.",
        example: r#"{"query": "value=%d", "limit": 10}"#,
        default: false,
        keywords: &["xrefs", "strings", "cstring", "references", "usage"],
    },
    ToolInfo {
        name: "xref_matrix",
        category: ToolCategory::Xrefs,
        short_desc: "Build xref matrix between addresses",
        full_desc: "Build a cross-reference matrix showing relationships between multiple addresses. \
                    Returns a boolean matrix indicating which addresses reference which others.",
        example: r#"{"addresses": ["0x1000", "0x2000", "0x3000"]}"#,
        default: false,
        keywords: &["xrefs", "matrix", "relationships", "graph"],
    },

    // === CONTROL FLOW ===
    ToolInfo {
        name: "basic_blocks",
        category: ToolCategory::ControlFlow,
        short_desc: "Get basic blocks of a function",
        full_desc: "Get the control flow graph basic blocks for a function. \
                    Returns block addresses, sizes, and successor relationships.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["basic", "blocks", "cfg", "control", "flow", "graph"],
    },
    ToolInfo {
        name: "callers",
        category: ToolCategory::ControlFlow,
        short_desc: "Find all callers of a function",
        full_desc: "Find all functions that call the specified function. \
                    Returns caller addresses and names.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["callers", "called", "by", "references", "xrefs"],
    },
    ToolInfo {
        name: "callees",
        category: ToolCategory::ControlFlow,
        short_desc: "Find all functions called by a function",
        full_desc: "Find all functions that are called by the specified function. \
                    Returns callee addresses and names.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["callees", "calls", "targets", "functions"],
    },
    ToolInfo {
        name: "callgraph",
        category: ToolCategory::ControlFlow,
        short_desc: "Build call graph from a function",
        full_desc: "Build a call graph starting from a function, exploring callers/callees \
                    up to the specified depth. Returns nodes and edges.",
        example: r#"{"roots": "0x1000", "max_depth": 2, "max_nodes": 256}"#,
        default: false,
        keywords: &["callgraph", "call", "graph", "depth", "tree"],
    },
    ToolInfo {
        name: "find_paths",
        category: ToolCategory::ControlFlow,
        short_desc: "Find control-flow paths between two addresses",
        full_desc: "Find control-flow paths between two addresses within the same function. \
                    Returns all paths up to max_depth. Both addresses must be in the same function.",
        example: r#"{"start": "0x1000", "end": "0x2000", "max_depth": 5}"#,
        default: false,
        keywords: &["paths", "route", "flow", "between", "reach"],
    },

    // === MEMORY ===
    ToolInfo {
        name: "get_bytes",
        category: ToolCategory::Memory,
        short_desc: "Read raw bytes from an address",
        full_desc: "Read raw bytes from the database at the specified address. \
                    Returns bytes as hex string. Useful for examining data. \
                    You can also supply a symbol/function name with an optional offset.",
        example: r#"{"name": "interesting_function", "offset": 0, "size": 32}"#,
        default: false,
        keywords: &["bytes", "read", "memory", "data", "raw", "hex"],
    },
    ToolInfo {
        name: "get_string",
        category: ToolCategory::Memory,
        short_desc: "Read string at an address",
        full_desc: "Read a null-terminated string at the specified address. \
                    Supports C strings and other string types recognized by IDA.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["string", "read", "text", "ascii", "data"],
    },
    ToolInfo {
        name: "get_u8",
        category: ToolCategory::Memory,
        short_desc: "Read 8-bit value",
        full_desc: "Read an unsigned 8-bit value (byte) at the specified address.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["byte", "u8", "read", "value"],
    },
    ToolInfo {
        name: "get_u16",
        category: ToolCategory::Memory,
        short_desc: "Read 16-bit value",
        full_desc: "Read an unsigned 16-bit value (word) at the specified address.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["word", "u16", "read", "value"],
    },
    ToolInfo {
        name: "get_u32",
        category: ToolCategory::Memory,
        short_desc: "Read 32-bit value",
        full_desc: "Read an unsigned 32-bit value (dword) at the specified address.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["dword", "u32", "read", "value"],
    },
    ToolInfo {
        name: "get_u64",
        category: ToolCategory::Memory,
        short_desc: "Read 64-bit value",
        full_desc: "Read an unsigned 64-bit value (qword) at the specified address.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["qword", "u64", "read", "value"],
    },
    ToolInfo {
        name: "get_global_value",
        category: ToolCategory::Memory,
        short_desc: "Read global value by name or address",
        full_desc: "Read a global value by name or address. Returns value and raw bytes.",
        example: r#"{"query": "g_flag"}"#,
        default: false,
        keywords: &["global", "value", "read", "symbol", "data"],
    },
    ToolInfo {
        name: "int_convert",
        category: ToolCategory::Memory,
        short_desc: "Convert integers between bases",
        full_desc: "Convert integers between decimal/hex/binary and show ASCII bytes when possible.",
        example: r#"{"inputs": ["0x41424344", 1234]}"#,
        default: false,
        keywords: &["int", "convert", "hex", "decimal", "ascii"],
    },

    // === SEARCH ===
    ToolInfo {
        name: "find_bytes",
        category: ToolCategory::Search,
        short_desc: "Search for byte pattern",
        full_desc: "Search for a byte pattern in the database. Supports wildcards. \
                    Returns all matching addresses up to the limit.",
        example: r#"{"pattern": "48 89 5C 24", "limit": 100}"#,
        default: false,
        keywords: &["find", "search", "bytes", "pattern", "hex"],
    },
    ToolInfo {
        name: "search",
        category: ToolCategory::Search,
        short_desc: "Search for text or immediate values",
        full_desc: "General search tool. Searches for text strings or immediate values \
                    in instructions. Use find_bytes for byte-pattern searches.",
        example: r#"{"targets": "password", "kind": "text"}"#,
        default: false,
        keywords: &["search", "find", "text", "string", "immediate"],
    },
    ToolInfo {
        name: "strings",
        category: ToolCategory::Search,
        short_desc: "List all strings in the database",
        full_desc: "List strings found in the database with pagination and optional \
                    substring filter (filter/query). Returns address and content.",
        example: r#"{"offset": 0, "limit": 100, "filter": "http"}"#,
        default: false,
        keywords: &["strings", "list", "text", "data"],
    },
    ToolInfo {
        name: "find_string",
        category: ToolCategory::Search,
        short_desc: "Find strings matching a query",
        full_desc: "Find strings that match a query (substring by default, optional exact match). \
                    Supports pagination.",
        example: r#"{"query": "value=%d", "limit": 20}"#,
        default: false,
        keywords: &["strings", "find", "search", "text"],
    },
    ToolInfo {
        name: "analyze_strings",
        category: ToolCategory::Search,
        short_desc: "Analyze strings with filtering",
        full_desc: "List strings with optional substring filter and pagination. \
                    Useful for finding specific string patterns like URLs or paths.",
        example: r#"{"query": "http", "offset": 0, "limit": 100}"#,
        default: false,
        keywords: &["strings", "analyze", "filter", "pattern"],
    },
    ToolInfo {
        name: "find_insns",
        category: ToolCategory::Search,
        short_desc: "Find instruction sequences by mnemonic",
        full_desc: "Search for instruction mnemonic patterns. If patterns is an array, matches \
                    contiguous sequences. Each pattern matches the mnemonic substring unless it \
                    contains whitespace or commas (then full line match).",
        example: r#"{"patterns": ["mov", "bl"], "limit": 5}"#,
        default: false,
        keywords: &["find", "instructions", "sequence", "pattern"],
    },
    ToolInfo {
        name: "find_insn_operands",
        category: ToolCategory::Search,
        short_desc: "Find instructions by operand substring",
        full_desc: "Search for instructions whose operand text matches any provided substring. \
                    Returns address, mnemonic, operands, and disasm line.",
        example: r#"{"patterns": ["sp", "0x10"], "limit": 5}"#,
        default: false,
        keywords: &["find", "operands", "instructions", "pattern"],
    },

    // === METADATA ===
    ToolInfo {
        name: "segments",
        category: ToolCategory::Metadata,
        short_desc: "List all segments",
        full_desc: "List all segments in the database with their addresses, sizes, \
                    names, and permissions (read/write/execute).",
        example: r#"{}"#,
        default: false,
        keywords: &["segments", "sections", "memory", "layout"],
    },
    ToolInfo {
        name: "addr_info",
        category: ToolCategory::Metadata,
        short_desc: "Resolve address to segment/function/symbol",
        full_desc: "Return address context including segment info, containing function, \
                    and nearest named symbol.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["address", "segment", "function", "symbol", "context"],
    },
    ToolInfo {
        name: "imports",
        category: ToolCategory::Metadata,
        short_desc: "List imported functions",
        full_desc: "List all imported external symbols with their addresses and names.",
        example: r#"{"offset": 0, "limit": 100}"#,
        default: false,
        keywords: &["imports", "external", "libraries", "api"],
    },
    ToolInfo {
        name: "exports",
        category: ToolCategory::Metadata,
        short_desc: "List exported functions",
        full_desc: "List all exported functions/symbols with their addresses and names.",
        example: r#"{"offset": 0, "limit": 100}"#,
        default: false,
        keywords: &["exports", "symbols", "public", "api"],
    },
    ToolInfo {
        name: "export_funcs",
        category: ToolCategory::Metadata,
        short_desc: "Export functions (JSON)",
        full_desc: "Export functions in JSON format. If addrs is provided, only export those functions.",
        example: r#"{"addrs": ["0x1000", "0x2000"], "format": "json"}"#,
        default: false,
        keywords: &["export", "functions", "json", "dump"],
    },
    ToolInfo {
        name: "entrypoints",
        category: ToolCategory::Metadata,
        short_desc: "List entry points",
        full_desc: "List all entry points in the binary (main, DllMain, etc.).",
        example: r#"{}"#,
        default: false,
        keywords: &["entry", "start", "main", "entrypoint"],
    },
    ToolInfo {
        name: "list_globals",
        category: ToolCategory::Metadata,
        short_desc: "List global variables",
        full_desc: "List global variables and data items with their addresses, names, and types.",
        example: r#"{"offset": 0, "limit": 100}"#,
        default: false,
        keywords: &["globals", "variables", "data", "symbols"],
    },

    // === TYPES / STRUCTS ===
    ToolInfo {
        name: "local_types",
        category: ToolCategory::Types,
        short_desc: "List local types",
        full_desc: "List local types (typedefs, enums, structs, etc.) with pagination and optional filter.",
        example: r#"{"query": "struct", "limit": 50}"#,
        default: false,
        keywords: &["types", "local", "typedef"],
    },
    ToolInfo {
        name: "xrefs_to_field",
        category: ToolCategory::Xrefs,
        short_desc: "Xrefs to a struct field",
        full_desc: "Get cross-references to a struct field by struct name/ordinal and member name/index.",
        example: r#"{"name": "Outer", "member_name": "inner", "limit": 25}"#,
        default: false,
        keywords: &["xrefs", "struct", "field", "member"],
    },
    ToolInfo {
        name: "declare_type",
        category: ToolCategory::Types,
        short_desc: "Declare a type in the local type library",
        full_desc: "Parse a C declaration and store it in the local type library (optionally replacing existing).",
        example: r#"{"decl": "typedef int mcp_int_t;", "replace": true}"#,
        default: false,
        keywords: &["type", "declare", "typedef"],
    },
    ToolInfo {
        name: "apply_types",
        category: ToolCategory::Types,
        short_desc: "Apply a type to an address or stack variable",
        full_desc: "Apply a named type or C declaration to an address/symbol. \
                    For stack vars, provide stack_offset or stack_name plus decl.",
        example: r#"{"name": "interesting_function", "stack_offset": -16, "decl": "int mcp_local;"}"#,
        default: false,
        keywords: &["types", "apply", "annotations"],
    },
    ToolInfo {
        name: "infer_types",
        category: ToolCategory::Types,
        short_desc: "Infer/guess type at an address",
        full_desc: "Guess a type for an address or symbol using IDA's heuristics.",
        example: r#"{"name": "interesting_function"}"#,
        default: false,
        keywords: &["types", "infer", "analysis"],
    },
    ToolInfo {
        name: "stack_frame",
        category: ToolCategory::Types,
        short_desc: "Get stack frame info",
        full_desc: "Get stack frame layout for the function at an address, including \
                    args/locals ranges and per-member type info.",
        example: r#"{"address": "0x1000"}"#,
        default: false,
        keywords: &["stack", "frame", "locals"],
    },
    ToolInfo {
        name: "declare_stack",
        category: ToolCategory::Types,
        short_desc: "Declare a stack variable",
        full_desc: "Define a stack variable in a function frame using a C declaration. \
                    Provide function address/name and stack offset (negative for locals).",
        example: r#"{"name": "interesting_function", "offset": -16, "var_name": "mcp_local", "decl": "int mcp_local;"}"#,
        default: false,
        keywords: &["stack", "declare", "variable"],
    },
    ToolInfo {
        name: "delete_stack",
        category: ToolCategory::Types,
        short_desc: "Delete a stack variable",
        full_desc: "Delete a stack variable by name or offset in a function frame.",
        example: r#"{"name": "interesting_function", "offset": -16}"#,
        default: false,
        keywords: &["stack", "delete", "variable"],
    },
    ToolInfo {
        name: "structs",
        category: ToolCategory::Types,
        short_desc: "List structs with pagination",
        full_desc: "List structs (UDTs) in the database with optional name filtering.",
        example: r#"{"limit": 50, "filter": "objc"}"#,
        default: false,
        keywords: &["structs", "types", "list"],
    },
    ToolInfo {
        name: "struct_info",
        category: ToolCategory::Types,
        short_desc: "Get struct info by name or ordinal",
        full_desc: "Get struct details including member layout and sizes.",
        example: r#"{"name": "MyStruct"}"#,
        default: false,
        keywords: &["struct", "info", "types"],
    },
    ToolInfo {
        name: "read_struct",
        category: ToolCategory::Types,
        short_desc: "Read a struct instance at an address",
        full_desc: "Read raw bytes for each struct member at a given address.",
        example: r#"{"address": "0x1000", "name": "MyStruct"}"#,
        default: false,
        keywords: &["struct", "read", "values"],
    },
    ToolInfo {
        name: "search_structs",
        category: ToolCategory::Types,
        short_desc: "Search structs by name",
        full_desc: "Search for structs by name with optional filter and pagination. \
                    Returns the same structure list output as structs.",
        example: r#"{"query": "my_struct", "limit": 20}"#,
        default: false,
        keywords: &["struct", "search", "types"],
    },

    // === EDITING / PATCHING ===
    ToolInfo {
        name: "set_comments",
        category: ToolCategory::Editing,
        short_desc: "Set comments at an address",
        full_desc: "Set a non-repeatable or repeatable comment at an address. \
                    Empty string clears the comment. You can also supply a symbol/function name \
                    with an optional offset.",
        example: r#"{"name": "interesting_function", "comment": "note", "repeatable": false}"#,
        default: false,
        keywords: &["comments", "set", "annotate"],
    },
    ToolInfo {
        name: "patch_asm",
        category: ToolCategory::Editing,
        short_desc: "Patch instructions with assembly text",
        full_desc: "Assemble a single instruction line at the target address and patch the bytes. \
                    Requires a processor module with assembler support; may fail on some targets. \
                    You can supply an address or a symbol name with an optional offset.",
        example: r#"{"name": "interesting_function", "offset": 0, "line": "nop"}"#,
        default: false,
        keywords: &["patch", "asm", "edit", "modify"],
    },
    ToolInfo {
        name: "patch",
        category: ToolCategory::Editing,
        short_desc: "Patch bytes at an address",
        full_desc: "Patch bytes in the database at the given address. \
                    You can also supply a symbol/function name with an optional offset.",
        example: r#"{"name": "interesting_function", "offset": 0, "bytes": "1f 20 03 d5"}"#,
        default: false,
        keywords: &["patch", "bytes", "edit", "modify"],
    },
    ToolInfo {
        name: "rename",
        category: ToolCategory::Editing,
        short_desc: "Rename symbols",
        full_desc: "Rename a symbol at an address. Optional flags map to IDA set_name flags. \
                    You can also supply the current name instead of an address.",
        example: r#"{"current_name": "interesting_function", "name": "interesting_function_renamed", "flags": 0}"#,
        default: false,
        keywords: &["rename", "symbol", "edit"],
    },

    // === SCRIPTING ===
    ToolInfo {
        name: "run_script",
        category: ToolCategory::Scripting,
        short_desc: "Execute Python code via IDAPython",
        full_desc: "Execute a Python script via IDAPython in the currently open database. \
                    Provide either 'code' (inline Python) or 'file' (path to a .py file). \
                    Has full access to all ida_* modules (ida_funcs, ida_bytes, ida_segment, etc.), \
                    idc, and idautils. stdout and stderr are captured and returned. \
                    Use this for custom analysis that goes beyond the built-in tools. \
                    Requires that the IDAPython plugin is loaded (available by default in IDA Pro). \
                    API reference: https://python.docs.hex-rays.com",
        example: r#"{"code": "import idautils\nfor f in idautils.Functions():\n    print(hex(f))"}"#,
        default: false,
        keywords: &["script", "python", "execute", "eval", "idapython", "run", "code", "file"],
    },
];

/// Get tools in the default (core) set
pub fn default_tools() -> impl Iterator<Item = &'static ToolInfo> {
    TOOL_REGISTRY.iter().filter(|t| t.default)
}

/// Get all tools
pub fn all_tools() -> impl Iterator<Item = &'static ToolInfo> {
    TOOL_REGISTRY.iter()
}

/// Get tool by name
pub fn get_tool(name: &str) -> Option<&'static ToolInfo> {
    TOOL_REGISTRY.iter().find(|t| t.name == name)
}

/// Get tools by category
pub fn tools_by_category(category: ToolCategory) -> impl Iterator<Item = &'static ToolInfo> {
    TOOL_REGISTRY.iter().filter(move |t| t.category == category)
}

/// Search tools by query (simple keyword matching)
pub fn search_tools(query: &str, limit: usize) -> Vec<(&'static ToolInfo, Vec<&'static str>)> {
    let query_lower = query.to_lowercase();
    let query_words: Vec<&str> = query_lower.split_whitespace().collect();

    let mut results: Vec<(&'static ToolInfo, Vec<&'static str>, usize)> = Vec::new();

    for tool in TOOL_REGISTRY.iter() {
        let mut matched_keywords = Vec::new();
        let mut score = 0usize;

        // Check tool name
        let name_lower = tool.name.to_lowercase();
        for word in &query_words {
            if name_lower.contains(word) {
                score += 10;
                matched_keywords.push("name match");
            }
        }

        // Check short description
        let desc_lower = tool.short_desc.to_lowercase();
        for word in &query_words {
            if desc_lower.contains(word) {
                score += 5;
            }
        }

        // Check keywords
        for keyword in tool.keywords {
            let kw_lower = keyword.to_lowercase();
            for word in &query_words {
                if kw_lower.contains(word) || word.contains(&kw_lower) {
                    score += 3;
                    if !matched_keywords.contains(keyword) {
                        matched_keywords.push(keyword);
                    }
                }
            }
        }

        // Check category
        let cat_str = tool.category.as_str().to_lowercase();
        for word in &query_words {
            if cat_str.contains(word) {
                score += 2;
                matched_keywords.push(tool.category.as_str());
            }
        }

        if score > 0 {
            results.push((tool, matched_keywords, score));
        }
    }

    // Sort by score descending
    results.sort_by(|a, b| b.2.cmp(&a.2));

    // Return top results
    results
        .into_iter()
        .take(limit)
        .map(|(tool, keywords, _)| (tool, keywords))
        .collect()
}

#[cfg(test)]
mod tests {
    use crate::tool_registry::*;

    #[test]
    fn test_default_tools() {
        let defaults: Vec<_> = default_tools().collect();
        assert!(defaults.iter().any(|t| t.name == "open_idb"));
        assert!(defaults.iter().any(|t| t.name == "tool_catalog"));
        assert!(defaults.iter().any(|t| t.name == "tool_help"));
        assert!(defaults.iter().any(|t| t.name == "idb_meta"));
    }

    #[test]
    fn test_search_tools() {
        let results = search_tools("find callers function", 5);
        assert!(!results.is_empty());
        // Should find "callers" tool
        assert!(results.iter().any(|(t, _)| t.name == "callers"));
    }

    #[test]
    fn test_get_tool() {
        assert!(get_tool("disasm").is_some());
        assert!(get_tool("nonexistent").is_none());
    }
}

```

`test/README.md`:

```md
# Tests

Integration tests for ida-mcp using a minimal `mini.c` fixture.

## Prerequisites

- `curl` (for HTTP tests)

## Build the fixture

```bash
make fixture
```

Compiles `fixtures/mini.c` to `fixtures/mini`. IDA analyzes raw binaries directly on first open.

## Run tests

```bash
make test       # Stdio JSONL test
make test-http  # HTTP/SSE test
```

## Clean

```bash
make clean
```

```

`test/http_integration.sh`:

```sh
#!/usr/bin/env bash
set -euo pipefail

PORT="${PORT:-8765}"
BIN="${MCP_HTTP_BIN:-./target/release/ida-mcp}"
ORIGIN="${MCP_HTTP_ORIGIN:-http://localhost}"
IDB_PATH="${IDB_PATH:-fixtures/mini}"

if ! command -v curl >/dev/null 2>&1; then
  echo "curl is required" >&2
  exit 1
fi

if [[ ! -x "$BIN" ]]; then
  echo "missing server binary: $BIN" >&2
  exit 1
fi

tmpdir="$(mktemp -d)"
headers_file="$tmpdir/headers.log"
body_file="$tmpdir/body.log"
server_log="$tmpdir/server.log"

cleanup() {
  if [[ -n "${server_pid:-}" ]]; then
    kill "$server_pid" >/dev/null 2>&1 || true
  fi
  rm -rf "$tmpdir"
}
trap cleanup EXIT INT TERM

"$BIN" serve-http --bind "127.0.0.1:$PORT" --allow-origin "http://localhost,http://127.0.0.1" >"$server_log" 2>&1 &
server_pid=$!

init_payload='{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","clientInfo":{"name":"test","version":"0.1"},"capabilities":{}}}'

session_id=""
for _ in {1..100}; do
  if curl -sS -D "$headers_file" -o "$body_file" \
    -H "Content-Type: application/json" \
    -H "Accept: application/json, text/event-stream" \
    -H "Origin: $ORIGIN" \
    -d "$init_payload" \
    "http://127.0.0.1:$PORT/" >/dev/null 2>/dev/null; then
    session_id="$(awk -F': ' 'tolower($1)=="mcp-session-id" {print $2}' "$headers_file" | tr -d '\r')"
    if [[ -n "$session_id" ]]; then
      break
    fi
  fi
  if ! kill -0 "$server_pid" 2>/dev/null; then
    break
  fi
  sleep 0.1
done

if [[ -z "$session_id" ]]; then
  echo "failed to obtain Mcp-Session-Id" >&2
  if [[ -s "$server_log" ]]; then
    echo "server output:" >&2
    cat "$server_log" >&2
  fi
  exit 1
fi

# Send notifications/initialized
curl -sS \
  -H "Content-Type: application/json" \
  -H "Accept: application/json, text/event-stream" \
  -H "Origin: $ORIGIN" \
  -H "Mcp-Session-Id: $session_id" \
  -d '{"jsonrpc":"2.0","method":"notifications/initialized","params":{}}' \
  "http://127.0.0.1:$PORT/" >/dev/null

# tools/list should include core tools and analysis tools
list_resp=$(curl -sS \
  -H "Content-Type: application/json" \
  -H "Accept: application/json, text/event-stream" \
  -H "Origin: $ORIGIN" \
  -H "Mcp-Session-Id: $session_id" \
  -d '{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}' \
  "http://127.0.0.1:$PORT/")

echo "$list_resp" | grep -q '"open_idb"' || {
  echo "tools/list missing open_idb" >&2
  exit 1
}

echo "$list_resp" | grep -q '"xrefs_to"' || {
  echo "tools/list missing xrefs_to" >&2
  exit 1
}

# Open mini fixture and verify functions list
open_resp=$(curl -sS \
  -H "Content-Type: application/json" \
  -H "Accept: application/json, text/event-stream" \
  -H "Origin: $ORIGIN" \
  -H "Mcp-Session-Id: $session_id" \
  -d "{\"jsonrpc\":\"2.0\",\"id\":5,\"method\":\"tools/call\",\"params\":{\"name\":\"open_idb\",\"arguments\":{\"path\":\"$IDB_PATH\"}}}" \
  "http://127.0.0.1:$PORT/")

echo "$open_resp" | grep -q "function_count" || {
  echo "open_idb failed" >&2
  echo "$open_resp" >&2
  exit 1
}

func_resp=$(curl -sS \
  -H "Content-Type: application/json" \
  -H "Accept: application/json, text/event-stream" \
  -H "Origin: $ORIGIN" \
  -H "Mcp-Session-Id: $session_id" \
  -d '{"jsonrpc":"2.0","id":6,"method":"tools/call","params":{"name":"list_functions","arguments":{"limit":10}}}' \
  "http://127.0.0.1:$PORT/")

echo "$func_resp" | grep -q "interesting_function" || {
  echo "list_functions missing interesting_function" >&2
  echo "$func_resp" >&2
  exit 1
}

close_token="$(echo "$open_resp" | sed -n 's/.*\\\"close_token\\\"[[:space:]]*:[[:space:]]*\\\"\\([^\\\"]*\\)\\\".*/\\1/p')"
if [[ -n "$close_token" ]]; then
  close_args="{\"close_token\":\"$close_token\"}"
else
  close_args="{}"
fi

curl -sS \
  -H "Content-Type: application/json" \
  -H "Accept: application/json, text/event-stream" \
  -H "Origin: $ORIGIN" \
  -H "Mcp-Session-Id: $session_id" \
  -d "{\"jsonrpc\":\"2.0\",\"id\":7,\"method\":\"tools/call\",\"params\":{\"name\":\"close_idb\",\"arguments\":$close_args}}" \
  "http://127.0.0.1:$PORT/" >/dev/null

echo "HTTP integration test passed"

```

`test/justfile`:

```
# Test justfile for ida-mcp

cc := env_var_or_default("CC", "cc")
cflags := env_var_or_default("CFLAGS", "-O0 -g -fno-omit-frame-pointer")
test_src := "fixtures/mini.c"
test_bin := "fixtures/mini"
test_lock := "fixtures/mini.imcp"
server_bin := env_var_or_default("SERVER_BIN", "../target/release/ida-mcp")
rust_log := env_var_or_default("RUST_LOG", "ida_mcp=trace")

# Show available recipes
default:
    @just --list

# Build test fixture
fixture:
    {{ cc }} {{ cflags }} -o "{{ test_bin }}" "{{ test_src }}"

# Run stdio integration test
test: fixture
    #!/usr/bin/env bash
    set -euo pipefail
    if [ ! -x "{{ server_bin }}" ]; then
        echo "Server binary not found: {{ server_bin }}"
        echo "Run 'cargo build --release' first"
        exit 1
    fi
    LOCK="{{ test_lock }}"
    if [ -f "$LOCK" ]; then
        pid=$(awk -F= '$1=="pid"{print $2}' "$LOCK" | tr -d '\r')
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "Lock file $LOCK is held by pid $pid; close that server first." >&2
            exit 1
        else
            rm -f "$LOCK"
        fi
    fi
    echo "🧪 Running stdio integration test..."
    tmp="$(mktemp)"
    # Keep stdin open long enough for open_idb auto-analysis (~10s for raw binaries)
    (cat payloads/mini.jsonl; sleep 30) | RUST_LOG="{{ rust_log }}" "{{ server_bin }}" >"$tmp" 2>&1 || true
    cat "$tmp"
    # Known expected errors:
    # - patch_asm on ARM (no assembler support)
    # - stack_frame at non-function address
    error_count="$(rg -c '"isError"\s*:\s*true' "$tmp" || echo 0)"
    if [ "$error_count" -gt 2 ]; then
        echo "❌ Expected at most 2 known errors, got $error_count"
        rm -f "$tmp"
        exit 1
    fi
    rm -f "$tmp"
    echo "✅ Stdio test passed"

# Run HTTP integration test
test-http: fixture
    #!/usr/bin/env bash
    set -euo pipefail
    if [ ! -x "{{ server_bin }}" ]; then
        echo "Server binary not found: {{ server_bin }}"
        echo "Run 'cargo build --release' first"
        exit 1
    fi
    LOCK="{{ test_lock }}"
    if [ -f "$LOCK" ]; then
        pid=$(awk -F= '$1=="pid"{print $2}' "$LOCK" | tr -d '\r')
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "Lock file $LOCK is held by pid $pid; close that server first." >&2
            exit 1
        else
            rm -f "$LOCK"
        fi
    fi
    echo "🧪 Running HTTP integration test..."
    RUST_LOG="{{ rust_log }}" IDB_PATH="{{ test_bin }}" MCP_HTTP_BIN="{{ server_bin }}" ./http_integration.sh
    echo "✅ HTTP test passed"

# Run IDAPython script integration test
test-script: fixture
    #!/usr/bin/env bash
    set -euo pipefail
    if [ ! -x "{{ server_bin }}" ]; then
        echo "Server binary not found: {{ server_bin }}"
        echo "Run 'cargo build --release' first"
        exit 1
    fi
    LOCK="{{ test_lock }}"
    if [ -f "$LOCK" ]; then
        pid=$(awk -F= '$1=="pid"{print $2}' "$LOCK" | tr -d '\r')
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "Lock file $LOCK is held by pid $pid; close that server first." >&2
            exit 1
        else
            rm -f "$LOCK"
        fi
    fi
    echo "🧪 Running IDAPython script test..."
    tmp="$(mktemp)"
    # Keep stdin open long enough for open_idb auto-analysis (~10s for raw binaries)
    (cat payloads/script.jsonl; sleep 30) | RUST_LOG="{{ rust_log }}" "{{ server_bin }}" >"$tmp" 2>&1 || true
    cat "$tmp"

    # Verify simple inline script execution (id=3)
    if ! rg -q 'inline_simple_ok function_count=' "$tmp"; then
        echo "❌ Simple inline script output missing"
        rm -f "$tmp"
        exit 1
    fi

    # Verify file-based script execution (id=4)
    if ! rg -q 'total_functions=' "$tmp"; then
        echo "❌ File-based script (fixtures/test_analysis.py) output missing"
        rm -f "$tmp"
        exit 1
    fi

    # Verify complex inline script execution (id=5)
    if ! rg -q 'complex_ok total=' "$tmp"; then
        echo "❌ Complex inline script output missing"
        rm -f "$tmp"
        exit 1
    fi

    # Verify syntax error surfaced as MCP-level error (id=6)
    error_count="$( (rg -o '"isError"\s*:\s*true' "$tmp" || true) | wc -l | tr -d ' ' )"
    if [ "$error_count" != "1" ]; then
        echo "❌ Expected exactly one MCP-level error response, got $error_count"
        rm -f "$tmp"
        exit 1
    fi
    if ! rg -q 'SyntaxError' "$tmp"; then
        echo "❌ SyntaxError details missing for invalid script case"
        rm -f "$tmp"
        exit 1
    fi
    if ! rg -q 'IDAPython script execution failed' "$tmp"; then
        echo "❌ Script failure summary missing for invalid script case"
        rm -f "$tmp"
        exit 1
    fi

    rm -f "$tmp"
    echo "✅ Script test passed"

# Run dyld_shared_cache (DSC) integration test

# Handles both sync (pre-existing .i64) and async (background task) paths.
test-dsc dsc_path:
    #!/usr/bin/env bash
    set -euo pipefail
    if [ ! -x "{{ server_bin }}" ]; then
        echo "Server binary not found: {{ server_bin }}"
        echo "Run 'cargo build --release' first"
        exit 1
    fi
    if ! command -v jq &>/dev/null; then
        echo "jq is required for DSC test (brew install jq)"
        exit 1
    fi
    echo "🧪 Running DSC integration test..."
    echo "   DSC: {{ dsc_path }}"

    fifo_in="$(mktemp -u).fifo"
    mkfifo "$fifo_in"
    log="$(mktemp)"

    # Start server with fifo as stdin
    RUST_LOG="{{ rust_log }}" "{{ server_bin }}" < "$fifo_in" > "$log" 2>&1 &
    server_pid=$!
    # Open the write end of fifo (keeps it open so server doesn't see EOF)
    exec 3>"$fifo_in"

    cleanup() {
        exec 3>&- 2>/dev/null || true
        rm -f "$fifo_in"
        kill "$server_pid" 2>/dev/null || true
        wait "$server_pid" 2>/dev/null || true
    }
    trap cleanup EXIT

    send() { echo "$1" >&3; }

    # Wait for a JSON-RPC response with the given id.
    # Reads from the log file, skipping log lines (which start with a timestamp).
    wait_response() {
        local target_id="$1"
        local timeout="${2:-300}"
        local elapsed=0
        while [ "$elapsed" -lt "$timeout" ]; do
            # Look for a JSON line with matching id
            local line
            line=$(grep -m1 "\"id\":${target_id}[,}]" "$log" 2>/dev/null | grep '"jsonrpc"' || true)
            if [ -n "$line" ]; then
                echo "$line"
                return 0
            fi
            sleep 1
            elapsed=$((elapsed + 1))
        done
        echo "Timeout waiting for response id=$target_id" >&2
        return 1
    }

    # Phase 1: Initialize
    send '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","clientInfo":{"name":"dsc-test","version":"0.1"},"capabilities":{}}}'
    send '{"jsonrpc":"2.0","method":"notifications/initialized","params":{}}'
    wait_response 1 10 >/dev/null
    echo "   Initialized"

    # Phase 2: open_dsc
    payload=$(sed "s|DSC_PATH|{{ dsc_path }}|g" <<< '{"jsonrpc":"2.0","id":2,"method":"tools/call","params":{"name":"open_dsc","arguments":{"path":"DSC_PATH","arch":"arm64e","module":"/System/Library/PrivateFrameworks/LockdownMode.framework/LockdownMode"}}}')
    send "$payload"
    resp=$(wait_response 2 30)
    echo "   open_dsc responded"

    # Check if we got a task_id (async) or direct db_info (sync)
    content_text=$(echo "$resp" | jq -r '.result.content[0].text // empty')
    task_id=$(echo "$content_text" | jq -r '.task_id // empty')

    if [ -n "$task_id" ]; then
        echo "   Background task: $task_id — polling task_status..."
        poll_id=10
        while true; do
            send "{\"jsonrpc\":\"2.0\",\"id\":${poll_id},\"method\":\"tools/call\",\"params\":{\"name\":\"task_status\",\"arguments\":{\"task_id\":\"${task_id}\"}}}"
            poll_resp=$(wait_response "$poll_id" 30)
            poll_text=$(echo "$poll_resp" | jq -r '.result.content[0].text // empty')
            status=$(echo "$poll_text" | jq -r '.status // empty')
            message=$(echo "$poll_text" | jq -r '.message // empty')
            elapsed_s=$(echo "$poll_text" | jq -r '.elapsed_secs // empty')
            echo "   [$elapsed_s s] status=$status message=$message"

            if [ "$status" = "completed" ]; then
                echo "   Task completed"
                # Verify db_info is present in the result
                fc=$(echo "$poll_text" | jq -r '.result.function_count // empty')
                if [ -z "$fc" ] || [ "$fc" = "0" ]; then
                    echo "❌ No function_count in completed task result"
                    cat "$log"
                    exit 1
                fi
                echo "   function_count=$fc"
                break
            elif [ "$status" = "failed" ]; then
                echo "❌ Task failed: $message"
                cat "$log"
                exit 1
            fi

            poll_id=$((poll_id + 1))
            sleep 5
        done
    else
        # Sync path — check for isError
        is_error=$(echo "$resp" | jq -r '.result.isError // false')
        if [ "$is_error" = "true" ]; then
            echo "❌ open_dsc returned error: $content_text"
            cat "$log"
            exit 1
        fi
        fc=$(echo "$content_text" | jq -r '.function_count // empty')
        echo "   Opened synchronously, function_count=$fc"
    fi

    # Phase 3: list_functions to verify DB is usable
    send '{"jsonrpc":"2.0","id":100,"method":"tools/call","params":{"name":"list_functions","arguments":{"limit":5}}}'
    lf_resp=$(wait_response 100 30)
    lf_error=$(echo "$lf_resp" | jq -r '.result.isError // false')
    if [ "$lf_error" = "true" ]; then
        echo "❌ list_functions failed after open"
        echo "$lf_resp" | jq .
        cat "$log"
        exit 1
    fi
    echo "   list_functions OK"

    # Phase 4: close
    send '{"jsonrpc":"2.0","id":101,"method":"tools/call","params":{"name":"close_idb","arguments":{}}}'
    wait_response 101 10 >/dev/null
    echo "   close_idb OK"

    echo "✅ DSC test passed"

# Clean test artifacts
clean:
    rm -f "{{ test_bin }}"
    rm -rf fixtures/mini.dSYM
    rm -f fixtures/*.i64 fixtures/*.idb
    rm -f fixtures/*.id0 fixtures/*.id1 fixtures/*.id2 fixtures/*.nam fixtures/*.til fixtures/*.imcp

```

`test/payloads/dsc.jsonl`:

```jsonl
JSONL Schema (1 sample line):
Fields: id, jsonrpc, method, params
Sample: {"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","clientInfo":{"name":"dsc-test","version":"0.1"},"capabilities":{}}}
... [2 more lines omitted]

```

`test/payloads/mini.jsonl`:

```jsonl
JSONL Schema (1 sample line):
Fields: id, jsonrpc, method, params
Sample: {"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","clientInfo":{"name":"test","version":"0.1"},"capabilities":{}}}
... [39 more lines omitted]

```

`test/payloads/script.jsonl`:

```jsonl
JSONL Schema (1 sample line):
Fields: id, jsonrpc, method, params
Sample: {"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","clientInfo":{"name":"script-test","version":"0.1"},"capabilities":{}}}
... [7 more lines omitted]

```