Project Path: arc_CyberSecurityUP_DriverVuln-Analyzer-IDA-Plugin_ungedvpm

Source Tree:

```txt
arc_CyberSecurityUP_DriverVuln-Analyzer-IDA-Plugin_ungedvpm
├── README.md
├── driver_vuln_analyzer_ida-v2.py
├── driver_vuln_analyzer_ida.py
└── plugin.json

```

`README.md`:

```md
# Driver Vuln Analyzer

Static triage for Windows drivers: heuristically extracts & decodes IOCTLs, highlights suspicious APIs, surfaces device names, and writes a JSON report. Works as:

* **IDA plugin/script** (`driver_vuln_analyzer_ida.py`)
* (Optional) **Ghidra script** counterpart if you add it later

## Features

* IOCTL discovery from immediates and **CTL_CODE** decoding (DeviceType, Function, Method, Access)
* Flags **METHOD_NEITHER** occurrences (pointer/buffer validation risk)
* Highlights sensitive kernel APIs (e.g., `RtlCopyMemory`, `ProbeForRead/Write`, `MmMapIoSpace`, `ZwMapViewOfSection`, …)
* Collects device/interface strings (`\Device\...`, `\DosDevices\...`, `\??\...`)
* Exports consolidated **JSON report**

## Folder structure

```
driver-vuln-analyzer/
├─ ida-plugin.json
├─ driver_vuln_analyzer_ida.py
└─ assets/
   └─ logo.png
```

## Requirements

* **IDA 9.0+** (Python 3)
* No external Python deps required for the basic flow

## Install (IDA)

1. Copy the folder to your IDA user plugins dir, e.g.

   * Windows: `C:\Users\<you>\AppData\Roaming\Hex-Rays\IDA Pro\plugins\driver-vuln-analyzer\`
   * Linux/macOS: `~/.idapro/plugins/driver-vuln-analyzer/`
2. Ensure `ida-plugin.json` and `driver_vuln_analyzer_ida.py` are side by side.
3. Restart IDA.

## Usage (IDA)

* Open the target **.sys** in IDA and let analysis finish.
* Run via **Edit → Plugins → Driver Vuln Analyzer**.
* A summary prints to the IDA output; a JSON report is written to your IDA user folder:

  ```
  driver_vuln_report_<input-filename>.json
  ```

### Printscreen


<img width="1711" height="739" alt="image" src="https://github.com/user-attachments/assets/906fb463-995a-4668-870e-a5ee086d867c" />

<img width="540" height="376" alt="image" src="https://github.com/user-attachments/assets/d52695da-fdbe-4bd5-b6cb-bbcd079c5b93" />


### Hotkeys

* (Registered in menu action) Suggested: `Ctrl+Alt+9` to start via menu binding.
* You can also run the script directly: **File → Script file… (Alt+F7)**.

## Output

* `driver_vuln_report_<file>.json` includes:

  * `device_strings`: discovered device/interface strings
  * `functions`: per-function IOCTLs, call sites, suspicious API hits, red flags
  * `ioctls_flat`: unique IOCTLs with frequency and where they appear
  * `summary`: counts and METHOD_NEITHER presence

## Notes & heuristics

* IOCTL enumeration is **heuristic** (immediate values in code). For precise control-flow mapping of dispatchers, integrate with deeper analysis (e.g., identify `IRP_MJ_DEVICE_CONTROL` handlers).
* “Suspicious” APIs are hints, not proof of a vulnerability.

## Roadmap (ideas)

* Lightweight dataflow for IRP buffers
* Automatic detection of `DriverObject->MajorFunction` assignments
* HTML/CSV report export
* Risk scoring

## Credits

Inspired by community work around Windows driver analysis and IOCTL decoding (e.g., DriverBuddy-style workflows).

```

`driver_vuln_analyzer_ida-v2.py`:

```py
# -*- coding: utf-8 -*-
# driver_vuln_analyzer_ida.py
#
# IDA Plugin — Driver Vuln Analyzer: collect IOCTLs heuristically, decode CTL_CODE,
# highlight sensitive calls and device names, and generate a JSON report.
#
# Adds device/symlink name recovery via RtlInitUnicodeString + IoCreateDevice/IoCreateSymbolicLink analysis.
#
import json
import os
import time

import idaapi
import idautils
import idc
import ida_bytes
import ida_search
import ida_nalt
import ida_kernwin

PLUGIN_NAME = "Driver Vuln Analyzer"
HOTKEY = "Ctrl-Alt-9"

METHODS = {
    0: "METHOD_BUFFERED",
    1: "METHOD_IN_DIRECT",
    2: "METHOD_OUT_DIRECT",
    3: "METHOD_NEITHER",
}
ACCESS = {
    0: "FILE_ANY_ACCESS (0)",
    1: "FILE_READ_ACCESS (0x1)",
    2: "FILE_WRITE_ACCESS (0x2)",
    3: "FILE_READ|WRITE (0x3)",
}
DEVICE_TYPES = {
    0x01: "FILE_DEVICE_BEEP", 0x02: "FILE_DEVICE_CD_ROM", 0x03: "FILE_DEVICE_CD_ROM_FILE_SYSTEM",
    0x04: "FILE_DEVICE_CONTROLLER", 0x05: "FILE_DEVICE_DATALINK", 0x06: "FILE_DEVICE_DFS",
    0x07: "FILE_DEVICE_DISK", 0x08: "FILE_DEVICE_DISK_FILE_SYSTEM", 0x09: "FILE_DEVICE_FILE_SYSTEM",
    0x0B: "FILE_DEVICE_KEYBOARD", 0x0F: "FILE_DEVICE_MOUSE", 0x11: "FILE_DEVICE_NAMED_PIPE",
    0x12: "FILE_DEVICE_NETWORK", 0x14: "FILE_DEVICE_NETWORK_FILE_SYSTEM", 0x15: "FILE_DEVICE_NULL",
    0x17: "FILE_DEVICE_PHYSICAL_NETCARD", 0x18: "FILE_DEVICE_PRINTER", 0x1B: "FILE_DEVICE_SERIAL_PORT",
    0x1D: "FILE_DEVICE_SOUND", 0x21: "FILE_DEVICE_TRANSPORT", 0x22: "FILE_DEVICE_UNKNOWN",
    0x23: "FILE_DEVICE_VIDEO", 0x24: "FILE_DEVICE_VIRTUAL_DISK", 0x29: "FILE_DEVICE_BATTERY",
    0x2D: "FILE_DEVICE_MASS_STORAGE", 0x2F: "FILE_DEVICE_KS", 0x31: "FILE_DEVICE_SMARTCARD",
    0x33: "FILE_DEVICE_DVD", 0x37: "FILE_DEVICE_SERENUM", 0x39: "FILE_DEVICE_KSEC",
}
SUSPICIOUS_APIS = {
    "MmMapIoSpace","MmUnmapIoSpace","MmGetSystemRoutineAddress","MmMapLockedPagesSpecifyCache",
    "MmGetPhysicalAddress","ZwMapViewOfSection","ZwCreateSection","ZwOpenProcess","ZwWriteVirtualMemory",
    "ObReferenceObjectByName","ObOpenObjectByPointer","IoCreateDevice","IoCreateSymbolicLink",
    "IoBuildDeviceIoControlRequest","ProbeForRead","ProbeForWrite","RtlCopyMemory","memcpy","memmove",
    "strcpy","sprintf","KeStackAttachProcess","KeAttachProcess","KeRaiseIrql","KeLowerIrql","PsCreateSystemThread",
    "READ_MSR","WRMSR","rdmsr","wrmsr","rdpmc"
}

# ---------------- IOCTL helpers ----------------

def decode_ioctl(value):
    device = (value >> 16) & 0xFFFF
    access = (value >> 14) & 0x3
    function = (value >> 2) & 0xFFF
    method = value & 0x3
    return {
        "hex": "0x%08X" % value,
        "device_raw": device,
        "device": DEVICE_TYPES.get(device, "UNKNOWN_DEVICE(0x%X)" % device),
        "access_raw": access,
        "access": ACCESS.get(access, "UNKNOWN_ACCESS(%d)" % access),
        "function": int(function),
        "method_raw": method,
        "method": METHODS.get(method, "UNKNOWN_METHOD(%d)" % method),
    }

def likely_ioctl(dword):
    method = dword & 0x3
    access = (dword >> 14) & 0x3
    function = (dword >> 2) & 0xFFF
    device = (dword >> 16) & 0xFFFF
    if method not in METHODS or access not in ACCESS:
        return False
    if function == 0:
        return False
    if device not in DEVICE_TYPES and device != 0x22:  # allow common UNKNOWN
        return False
    return True

# ---------------- Device name collection ----------------

def collect_device_strings(minlen=5, limit=2000):
    """Fallback: harvest literal strings that look like NT object names."""
    devs = []
    try:
        s = idautils.Strings()
        s.setup(minlen)
        for st in s:
            if st is None:
                continue
            val = str(st)
            if val.startswith("\\Device\\") or val.startswith("\\DosDevices\\") or val.startswith("\\??\\"):
                devs.append(val)
                if len(devs) >= limit:
                    break
    except Exception:
        pass
    return sorted(set(devs))

def _get_wstring(addr):
    """Try to read a wide string literal at 'addr'."""
    if addr == idc.BADADDR:
        return None
    try:
        # STRTYPE_C_16 == C-style UTF-16 (wide)
        s = ida_bytes.get_strlit_contents(addr, 0, ida_nalt.STRTYPE_C_16)
        if s:
            try:
                return s.decode("utf-16le")
            except Exception:
                # get_strlit_contents may already return a Python bytes/str depending on IDA version
                return str(s)
    except Exception:
        pass
    return None

def _is_64bit():
    inf = idaapi.get_inf_structure()
    return inf.is_64bit()

def _walk_back(insn_ea, limit=30):
    """Yield previous instruction EAs (backwards) up to 'limit' within same function."""
    func = idaapi.get_func(insn_ea)
    if not func:
        return
    ea = insn_ea
    count = 0
    while count < limit:
        prev = idc.prev_head(ea, func.start_ea)
        if prev == idc.BADADDR or prev < func.start_ea:
            break
        yield prev
        ea = prev
        count += 1

def _backtrack_reg_value(call_ea, regname):
    """
    Very light backtracking for x64: look for last 'lea reg, X' or 'mov reg, imm/offset' before call_ea.
    Returns an address (immediate) if found; else None.
    """
    regname = regname.lower()
    for ea in _walk_back(call_ea, limit=40):
        mnem = idc.print_insn_mnem(ea).lower()
        # simple patterns: lea r8, xxx / mov r8, imm / mov r8, offset xxx
        if mnem in ("lea", "mov"):
            dst = idc.print_operand(ea, 0).lower()
            if dst == regname:
                # grab src immediate/offset
                if idc.get_operand_type(ea, 1) in (idc.o_imm, idc.o_mem, idc.o_far, idc.o_near):
                    return idc.get_operand_value(ea, 1)
    return None

def _backtrack_stack_args_x86(call_ea, nargs=4):
    """
    For stdcall x86: collect last 'push' immediates before call, up to nargs.
    Returns list like [argN, argN-1, ...] (right-to-left as pushed), so arg[0] is last pushed.
    We'll reverse as needed by caller to get the correct ordinal.
    """
    pushes = []
    for ea in _walk_back(call_ea, limit=40):
        mnem = idc.print_insn_mnem(ea).lower()
        if mnem == "push":
            if idc.get_operand_type(ea, 0) in (idc.o_imm, idc.o_mem, idc.o_far, idc.o_near):
                pushes.append(idc.get_operand_value(ea, 0))
                if len(pushes) >= nargs:
                    break
        elif mnem == "call":
            # stop on previous call
            break
    return pushes  # note: in push order (right-to-left)

def _resolve_unicode_from_arg_ptr(ptr_ea, rtl_map):
    """
    Try to resolve PUNICODE_STRING argument to actual string:
    - If ptr_ea matches a key in rtl_map (dest of RtlInitUnicodeString), return that mapped string.
    - Else, try to interpret ptr_ea as address of a UNICODE_STRING struct and read its Buffer pointer.
    - Else, try to treat ptr_ea directly as wide-string literal.
    """
    if ptr_ea is None or ptr_ea == idc.BADADDR:
        return None

    # 1) mapped via RtlInitUnicodeString
    if ptr_ea in rtl_map:
        return rtl_map[ptr_ea]

    # 2) read UNICODE_STRING struct: USHORT Length; USHORT MaximumLength; PWSTR Buffer;
    try:
        if _is_64bit():
            bufptr = ida_bytes.get_qword(ptr_ea + 8)
        else:
            bufptr = ida_bytes.get_wide_dword(ptr_ea + 8)
        if bufptr and bufptr != idc.BADADDR:
            s = _get_wstring(bufptr)
            if s:
                return s
    except Exception:
        pass

    # 3) fallback: maybe the arg directly points to a wide string literal
    s2 = _get_wstring(ptr_ea)
    if s2:
        return s2

    return None

def collect_device_names():
    """
    Walks the program to recover device/symlink names via:
      - RtlInitUnicodeString(dest, L"...")  → build map dest→string
      - IoCreateDevice*(..., PUNICODE_STRING DeviceName, ...) → device name
      - IoCreateSymbolicLink(PUNICODE_STRING LinkName, PUNICODE_STRING DeviceName) → link name
    Returns a list of dicts: {kind, api, name, site}
    """
    results = []
    is64 = _is_64bit()

    # Build a map: destUS_addr -> literal string from RtlInitUnicodeString(dest, source)
    rtl_map = {}

    target_rtl = {"RtlInitUnicodeString"}
    target_device_apis = {"IoCreateDevice", "IoCreateDeviceSecure"}
    target_symlink_apis = {"IoCreateSymbolicLink"}

    # Utility: resolve callee name from call site
    def callee_name(call_ea):
        callee = idc.get_operand_value(call_ea, 0)
        nm = idc.get_name(callee, idaapi.GN_VISIBLE)
        return nm or ""

    for f_ea in idautils.Functions():
        fn = idaapi.get_func(f_ea)
        if not fn:
            continue

        for ea in idautils.FuncItems(f_ea):
            if not idc.is_code(idc.get_full_flags(ea)):
                continue
            if not idc.print_insn_mnem(ea).lower() == "call":
                continue

            name = callee_name(ea)
            if not name:
                continue
            short = name.split("::")[-1]

            # --- RtlInitUnicodeString(dest, source) ---
            if short in target_rtl:
                if is64:
                    # RCX=dest, RDX=source
                    dest = _backtrack_reg_value(ea, "rcx")
                    src = _backtrack_reg_value(ea, "rdx")
                else:
                    # pushes: source (2nd), dest (1st) → right-to-left
                    pushes = _backtrack_stack_args_x86(ea, nargs=2)
                    # pushes list is [last_pushed,...]; for stdcall, second push is first arg
                    dest = pushes[1] if len(pushes) >= 2 else None
                    src = pushes[0] if len(pushes) >= 1 else None

                s = _get_wstring(src) if src else None
                if dest and s:
                    rtl_map[dest] = s

            # --- IoCreateDevice*(..., DeviceName, ...) ---
            elif short in target_device_apis:
                if is64:
                    # IoCreateDevice(..., RCX, RDX, R8=DeviceName, R9, ...)
                    arg_ptr = _backtrack_reg_value(ea, "r8")
                else:
                    # stdcall: args pushed right-to-left; DeviceName is 3rd param from right
                    # signature: DriverObject, DeviceExtensionSize, DeviceName, DeviceType, ...
                    pushes = _backtrack_stack_args_x86(ea, nargs=7)
                    arg_ptr = pushes[4] if len(pushes) >= 3 else (pushes[2] if len(pushes) >= 3 else None)  # safer fallback

                    # Better explicit: last pushes list order example:
                    # [last_push, ..., first_push]; we want 3rd from last_push index 2
                    if len(pushes) >= 3:
                        arg_ptr = pushes[2]

                name_str = _resolve_unicode_from_arg_ptr(arg_ptr, rtl_map)
                if name_str and (name_str.startswith("\\Device\\") or name_str.startswith("\\??\\")):
                    results.append({"kind": "device", "api": short, "name": name_str, "site": "0x%X" % ea})

            # --- IoCreateSymbolicLink(LinkName, DeviceName) ---
            elif short in target_symlink_apis:
                if is64:
                    link_ptr = _backtrack_reg_value(ea, "rcx")  # first arg
                    # dev_ptr  = _backtrack_reg_value(ea, "rdx")  # second arg (could be used later if needed)
                else:
                    pushes = _backtrack_stack_args_x86(ea, nargs=2)
                    # 2 pushes → [DeviceName, LinkName] (right-to-left)
                    link_ptr = pushes[1] if len(pushes) >= 2 else None

                link_str = _resolve_unicode_from_arg_ptr(link_ptr, rtl_map)
                if link_str and (link_str.startswith("\\DosDevices\\") or link_str.startswith("\\??\\")):
                    results.append({"kind": "symlink", "api": short, "name": link_str, "site": "0x%X" % ea})

    # de-duplicate by (kind, name)
    uniq = {}
    out = []
    for r in results:
        k = (r["kind"], r["name"])
        if k in uniq:
            continue
        uniq[k] = True
        out.append(r)
    return out

# ---------------- Per-function scan (IOCTLs/APIs) ----------------

def function_name(ea):
    n = idc.get_func_name(ea)
    return n if n else "sub_%X" % ea

def scan_function_for_ioctls(func_ea):
    ioctls = {}
    calls = set()
    for ea in idautils.FuncItems(func_ea):
        mnem = idc.print_insn_mnem(ea).lower()
        # immediates
        for op in (0, 1):
            if idc.get_operand_type(ea, op) == idc.o_imm:
                val = idc.get_operand_value(ea, op) & 0xFFFFFFFF
                if likely_ioctl(val):
                    ioctls.setdefault(val, []).append(ea)
        # calls → suspicious APIs
        if mnem == "call":
            callee = idc.get_operand_value(ea, 0)
            name = idc.get_name(callee, idaapi.GN_VISIBLE)
            if name:
                short = name.split("::")[-1]
                if short in SUSPICIOUS_APIS or name in SUSPICIOUS_APIS:
                    calls.add(short)
    return ioctls, sorted(calls)

# ---------------- Main analysis & plugin boilerplate ----------------

def analyze_all():
    print("[*] %s — starting..." % PLUGIN_NAME)
    report = {
        "input": idaapi.get_root_filename(),
        "time_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "device_strings": collect_device_strings(),
        "device_names": [],  # <=== NEW: recovered via API+RtlInitUnicodeString
        "functions": [],
        "ioctls_flat": [],
        "summary": {"functions_with_ioctl": 0, "unique_ioctls": 0, "method_neither_present": False}
    }

    # Recover device/symlink names via code analysis
    try:
        report["device_names"] = collect_device_names()
    except Exception as e:
        print("[-] device_names collection failed: %s" % e)

    ioctl_global = {}
    funcs_with_ioctl = 0

    for f_ea in idautils.Functions():
        fn = idaapi.get_func(f_ea)
        if not fn:
            continue
        fn_name = function_name(f_ea)
        ioctls, calls = scan_function_for_ioctls(f_ea)
        if ioctls:
            funcs_with_ioctl += 1
        fn_entry = {
            "name": fn_name,
            "start_ea": "0x%X" % fn.start_ea,
            "end_ea": "0x%X" % fn.end_ea,
            "ioctls": [],
            "suspicious_calls": calls,
            "red_flags": []
        }
        meth_neither_in_fn = False
        for val, eas in ioctls.items():
            dec = decode_ioctl(val)
            if dec["method_raw"] == 3:
                meth_neither_in_fn = True
            fn_entry["ioctls"].append({
                "value": dec["hex"],
                "device": dec["device"],
                "function": dec["function"],
                "method": dec["method"],
                "access": dec["access"],
                "sites": ["0x%X" % ea for ea in eas],
            })
            # global aggregation
            G = ioctl_global.setdefault(val, {"count": 0, "where": set(), "dec": dec})
            G["count"] += len(eas)
            G["where"].add(fn_name)
        if meth_neither_in_fn:
            fn_entry["red_flags"].append("IOCTL METHOD_NEITHER detected (validate buffers/pointers carefully)")
        # heuristic: memory copy without ProbeForRead/Write
        if any(x in calls for x in ("RtlCopyMemory", "memcpy", "memmove", "strcpy", "sprintf")) and \
           not any(x in calls for x in ("ProbeForRead", "ProbeForWrite")):
            fn_entry["red_flags"].append("Memory copy observed without ProbeForRead/Write")
        report["functions"].append(fn_entry)

    # flat IOCTLs
    for val, info in sorted(ioctl_global.items(), key=lambda kv: (-kv[1]["count"], kv[0])):
        report["ioctls_flat"].append({
            "value": info["dec"]["hex"],
            "device": info["dec"]["device"],
            "function": info["dec"]["function"],
            "method": info["dec"]["method"],
            "access": info["dec"]["access"],
            "frequency": info["count"],
            "functions": sorted(list(info["where"]))
        })

    report["summary"]["functions_with_ioctl"] = funcs_with_ioctl
    report["summary"]["unique_ioctls"] = len(ioctls := ioctl_global)
    report["summary"]["method_neither_present"] = any(x["dec"]["method_raw"] == 3 for x in ioctl_global.values())

    # output
    outdir = idaapi.get_user_idadir() or os.getcwd()
    outpath = os.path.join(outdir, "driver_vuln_report_%s.json" % idaapi.get_root_filename())
    with open(outpath, "w", encoding="utf-8") as f:
        json.dump(report, f, indent=2, ensure_ascii=False)
    print("\n=== Driver Vuln Analyzer / summary ===")
    print("Input: %s" % report["input"])
    print("Functions with IOCTLs: %d | Unique IOCTLs: %d | METHOD_NEITHER?: %s" % (
        report["summary"]["functions_with_ioctl"],
        report["summary"]["unique_ioctls"],
        report["summary"]["method_neither_present"]))
    if report["device_names"]:
        preview = ", ".join(sorted({d['name'] for d in report['device_names']})[:6])
        print("Device/Symlink names: %s%s" % (preview, " ..." if len(report["device_names"]) > 6 else ""))
    elif report["device_strings"]:
        preview = ", ".join(report["device_strings"][:6])
        print("Device strings (literal scan): %s%s" % (preview, " ..." if len(report["device_strings"]) > 6 else ""))
    print("JSON report saved to: %s" % outpath)
    idaapi.info("Driver Vuln Analyzer finished.\nJSON: %s" % outpath)

class driver_vuln_plugin_t(idaapi.plugin_t):
    flags = idaapi.PLUGIN_KEEP
    comment = "Analyze IOCTLs and common Windows driver vulnerability hotspots"
    help = "Scans for IOCTL constants, suspicious APIs, device names"
    wanted_name = PLUGIN_NAME
    wanted_hotkey = ""

    def init(self):
        # register menu action
        self.action_name = "driver_vuln:run"
        desc = idaapi.action_desc_t(
            self.action_name, PLUGIN_NAME, idaapi.simple_action_handler_t(self.run), "Ctrl+Alt-9", PLUGIN_NAME, 0
        )
        idaapi.register_action(desc)
        idaapi.attach_action_to_menu("Edit/Plugins/", self.action_name, idaapi.SETMENU_APP)
        return idaapi.PLUGIN_OK

    def run(self, arg=0):
        analyze_all()

    def term(self):
        try:
            idaapi.detach_action_from_menu("Edit/Plugins/", self.action_name)
            idaapi.unregister_action(self.action_name)
        except Exception:
            pass

def PLUGIN_ENTRY():
    return driver_vuln_plugin_t()

if __name__ == "__main__":
    analyze_all()

```

`driver_vuln_analyzer_ida.py`:

```py
# -*- coding: utf-8 -*-
# driver_vuln_analyzer_ida.py
#
# IDA Plugin — Driver Vuln Analyzer: collect IOCTLs heuristically, decode CTL_CODE,
# highlight sensitive calls and device names, and generate a JSON report.
#
# Usage:
#  - As a plugin: Edit → Plugins → Driver Vuln Analyzer (or the hotkey below).
#  - As a script: Alt+F7 and run this file.
#
import json
import os
import time

import idaapi
import idautils
import idc

PLUGIN_NAME = "Driver Vuln Analyzer"
HOTKEY = "Ctrl-Alt-9"

METHODS = {
    0: "METHOD_BUFFERED",
    1: "METHOD_IN_DIRECT",
    2: "METHOD_OUT_DIRECT",
    3: "METHOD_NEITHER",
}
ACCESS = {
    0: "FILE_ANY_ACCESS (0)",
    1: "FILE_READ_ACCESS (0x1)",
    2: "FILE_WRITE_ACCESS (0x2)",
    3: "FILE_READ|WRITE (0x3)",
}
DEVICE_TYPES = {
    0x01: "FILE_DEVICE_BEEP", 0x02: "FILE_DEVICE_CD_ROM", 0x03: "FILE_DEVICE_CD_ROM_FILE_SYSTEM",
    0x04: "FILE_DEVICE_CONTROLLER", 0x05: "FILE_DEVICE_DATALINK", 0x06: "FILE_DEVICE_DFS",
    0x07: "FILE_DEVICE_DISK", 0x08: "FILE_DEVICE_DISK_FILE_SYSTEM", 0x09: "FILE_DEVICE_FILE_SYSTEM",
    0x0B: "FILE_DEVICE_KEYBOARD", 0x0F: "FILE_DEVICE_MOUSE", 0x11: "FILE_DEVICE_NAMED_PIPE",
    0x12: "FILE_DEVICE_NETWORK", 0x14: "FILE_DEVICE_NETWORK_FILE_SYSTEM", 0x15: "FILE_DEVICE_NULL",
    0x17: "FILE_DEVICE_PHYSICAL_NETCARD", 0x18: "FILE_DEVICE_PRINTER", 0x1B: "FILE_DEVICE_SERIAL_PORT",
    0x1D: "FILE_DEVICE_SOUND", 0x21: "FILE_DEVICE_TRANSPORT", 0x22: "FILE_DEVICE_UNKNOWN",
    0x23: "FILE_DEVICE_VIDEO", 0x24: "FILE_DEVICE_VIRTUAL_DISK", 0x29: "FILE_DEVICE_BATTERY",
    0x2D: "FILE_DEVICE_MASS_STORAGE", 0x2F: "FILE_DEVICE_KS", 0x31: "FILE_DEVICE_SMARTCARD",
    0x33: "FILE_DEVICE_DVD", 0x37: "FILE_DEVICE_SERENUM", 0x39: "FILE_DEVICE_KSEC",
}
SUSPICIOUS_APIS = {
    "MmMapIoSpace","MmUnmapIoSpace","MmGetSystemRoutineAddress","MmMapLockedPagesSpecifyCache",
    "MmGetPhysicalAddress","ZwMapViewOfSection","ZwCreateSection","ZwOpenProcess","ZwWriteVirtualMemory",
    "ObReferenceObjectByName","ObOpenObjectByPointer","IoCreateDevice","IoCreateSymbolicLink",
    "IoBuildDeviceIoControlRequest","ProbeForRead","ProbeForWrite","RtlCopyMemory","memcpy","memmove",
    "strcpy","sprintf","KeStackAttachProcess","KeAttachProcess","KeRaiseIrql","KeLowerIrql","PsCreateSystemThread",
    "READ_MSR","WRMSR","rdmsr","wrmsr","rdpmc"
}

def decode_ioctl(value):
    device = (value >> 16) & 0xFFFF
    access = (value >> 14) & 0x3
    function = (value >> 2) & 0xFFF
    method = value & 0x3
    return {
        "hex": "0x%08X" % value,
        "device_raw": device,
        "device": DEVICE_TYPES.get(device, "UNKNOWN_DEVICE(0x%X)" % device),
        "access_raw": access,
        "access": ACCESS.get(access, "UNKNOWN_ACCESS(%d)" % access),
        "function": int(function),
        "method_raw": method,
        "method": METHODS.get(method, "UNKNOWN_METHOD(%d)" % method),
    }

def likely_ioctl(dword):
    method = dword & 0x3
    access = (dword >> 14) & 0x3
    function = (dword >> 2) & 0xFFF
    device = (dword >> 16) & 0xFFFF
    if method not in METHODS or access not in ACCESS: return False
    if function == 0: return False
    if device not in DEVICE_TYPES and device != 0x22: return False  # allow common UNKNOWN
    return True

def collect_device_strings(minlen=5, limit=2000):
    devs = []
    try:
        s = idautils.Strings()
        s.setup(minlen)
        for st in s:
            if st is None: continue
            val = str(st)
            if val.startswith("\\Device\\") or val.startswith("\\DosDevices\\") or val.startswith("\\??\\"):
                devs.append(val)
                if len(devs) >= limit: break
    except Exception:
        pass
    return sorted(set(devs))

def function_name(ea):
    n = idc.get_func_name(ea)
    return n if n else "sub_%X" % ea

def scan_function_for_ioctls(func_ea):
    ioctls = {}
    calls = set()
    for ea in idautils.FuncItems(func_ea):
        mnem = idc.print_insn_mnem(ea).lower()
        # immediates
        for op in (0,1):
            if idc.get_operand_type(ea, op) == idc.o_imm:
                val = idc.get_operand_value(ea, op) & 0xFFFFFFFF
                if likely_ioctl(val):
                    ioctls.setdefault(val, []).append(ea)
        # calls → suspicious APIs
        if mnem == "call":
            callee = idc.get_operand_value(ea, 0)
            name = idc.get_name(callee, idaapi.GN_VISIBLE)
            if name:
                short = name.split("::")[-1]
                if short in SUSPICIOUS_APIS or name in SUSPICIOUS_APIS:
                    calls.add(short)
    return ioctls, sorted(calls)

def analyze_all():
    print("[*] %s — starting..." % PLUGIN_NAME)
    report = {
        "input": idaapi.get_root_filename(),
        "time_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "device_strings": collect_device_strings(),
        "functions": [],
        "ioctls_flat": [],
        "summary": {"functions_with_ioctl": 0, "unique_ioctls": 0, "method_neither_present": False}
    }

    ioctl_global = {}
    funcs_with_ioctl = 0

    for f_ea in idautils.Functions():
        fn = idaapi.get_func(f_ea)
        if not fn: continue
        fn_name = function_name(f_ea)
        ioctls, calls = scan_function_for_ioctls(f_ea)
        if ioctls:
            funcs_with_ioctl += 1
        fn_entry = {
            "name": fn_name,
            "start_ea": "0x%X" % fn.start_ea,
            "end_ea": "0x%X" % fn.end_ea,
            "ioctls": [],
            "suspicious_calls": calls,
            "red_flags": []
        }
        meth_neither_in_fn = False
        for val, eas in ioctls.items():
            dec = decode_ioctl(val)
            if dec["method_raw"] == 3:
                meth_neither_in_fn = True
            fn_entry["ioctls"].append({
                "value": dec["hex"],
                "device": dec["device"],
                "function": dec["function"],
                "method": dec["method"],
                "access": dec["access"],
                "sites": ["0x%X" % ea for ea in eas],
            })
            # global aggregation
            G = ioctl_global.setdefault(val, {"count": 0, "where": set(), "dec": dec})
            G["count"] += len(eas)
            G["where"].add(fn_name)
        if meth_neither_in_fn:
            fn_entry["red_flags"].append("IOCTL METHOD_NEITHER detected (validate buffers/pointers carefully)")
        # heuristic: memory copy without ProbeForRead/Write
        if any(x in calls for x in ("RtlCopyMemory","memcpy","memmove","strcpy","sprintf")) and \
           not any(x in calls for x in ("ProbeForRead","ProbeForWrite")):
            fn_entry["red_flags"].append("Memory copy observed without ProbeForRead/Write")
        report["functions"].append(fn_entry)

    # flat IOCTLs
    for val, info in sorted(ioctl_global.items(), key=lambda kv: (-kv[1]["count"], kv[0])):
        report["ioctls_flat"].append({
            "value": info["dec"]["hex"],
            "device": info["dec"]["device"],
            "function": info["dec"]["function"],
            "method": info["dec"]["method"],
            "access": info["dec"]["access"],
            "frequency": info["count"],
            "functions": sorted(list(info["where"]))
        })

    report["summary"]["functions_with_ioctl"] = funcs_with_ioctl
    report["summary"]["unique_ioctls"] = len(ioctl_global)
    report["summary"]["method_neither_present"] = any(x["dec"]["method_raw"] == 3 for x in ioctl_global.values())

    # output
    outdir = idaapi.get_user_idadir() or os.getcwd()
    outpath = os.path.join(outdir, "driver_vuln_report_%s.json" % idaapi.get_root_filename())
    with open(outpath, "w", encoding="utf-8") as f:
        json.dump(report, f, indent=2, ensure_ascii=False)
    print("\n=== Driver Vuln Analyzer / summary ===")
    print("Input: %s" % report["input"])
    print("Functions with IOCTLs: %d | Unique IOCTLs: %d | METHOD_NEITHER?: %s" % (
        report["summary"]["functions_with_ioctl"],
        report["summary"]["unique_ioctls"],
        report["summary"]["method_neither_present"]))
    if report["device_strings"]:
        print("Devices: %s" % (", ".join(report["device_strings"][:6]) + (" ..." if len(report["device_strings"])>6 else "")))
    print("JSON report saved to: %s" % outpath)
    idaapi.info("Driver Vuln Analyzer finished.\nJSON: %s" % outpath)

class driver_vuln_plugin_t(idaapi.plugin_t):
    flags = idaapi.PLUGIN_KEEP
    comment = "Analyze IOCTLs and common Windows driver vulnerability hotspots"
    help = "Scans for IOCTL constants, suspicious APIs, device names"
    wanted_name = PLUGIN_NAME
    wanted_hotkey = ""

    def init(self):
        # register menu action
        self.action_name = "driver_vuln:run"
        desc = idaapi.action_desc_t(
            self.action_name, PLUGIN_NAME, idaapi.simple_action_handler_t(self.run), "Ctrl+Alt-9", PLUGIN_NAME, 0
        )
        idaapi.register_action(desc)
        idaapi.attach_action_to_menu("Edit/Plugins/", self.action_name, idaapi.SETMENU_APP)
        return idaapi.PLUGIN_OK

    def run(self, arg=0):
        analyze_all()

    def term(self):
        try:
            idaapi.detach_action_from_menu("Edit/Plugins/", self.action_name)
            idaapi.unregister_action(self.action_name)
        except Exception:
            pass

def PLUGIN_ENTRY():
    return driver_vuln_plugin_t()

# Allow running as a plain script
if __name__ == "__main__":
    analyze_all()

```

`plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "Driver Vuln Analyzer",
    "entryPoint": "driver_vuln_analyzer_ida.py",
    "categories": [
      "vulnerability-research-and-exploit-development",
      "malware-analysis",
      "api-scripting-and-automation"
    ],
    "logoPath": "assets/logo.png",
    "idaVersions": ">=9.0",
    "description": "Windows driver triage: IOCTL extraction/decoding, sensitive API hits, METHOD_NEITHER detection, device names, and JSON report.",
    "version": "0.1.0",
    "author": "Joas Antonio dos Santos",
    "url": "https://github.com/CyberSecurityUP/DriverVuln-Analyzer-IDA-Plugin",
    "license": "MIT"
  }
}

```