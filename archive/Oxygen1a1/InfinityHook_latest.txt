Project Path: arc_Oxygen1a1_InfinityHook_latest_wm830a12

Source Tree:

```txt
arc_Oxygen1a1_InfinityHook_latest_wm830a12
├── ETWHOOK WIN11兼容版.assets
│   ├── 77cd8914ea73abf464a9e0352ac255b0.png
│   ├── image-20240119153903903.png
│   ├── image-20240419102113440.png
│   ├── image-20240419102337381.png
│   ├── image-20240420200101609.png
│   ├── image-20240420200338164-1713614621292-3.png
│   ├── image-20240420200338164.png
│   └── image-20240420213841614.png
├── etw_hook
│   ├── etw_hook.vcxproj
│   ├── etw_hook.vcxproj.filters
│   ├── include
│   │   ├── etwhook_base.hpp
│   │   ├── etwhook_init.hpp
│   │   ├── etwhook_manager.hpp
│   │   ├── etwhook_utils.hpp
│   │   ├── kstl
│   │   │   ├── karray.hpp
│   │   │   ├── kautolock.hpp
│   │   │   ├── kavl.hpp
│   │   │   ├── kcallback.hpp
│   │   │   ├── kcrypt.hpp
│   │   │   ├── kfile.hpp
│   │   │   ├── kfilter.hpp
│   │   │   ├── kfunctional.hpp
│   │   │   ├── khash_table.hpp
│   │   │   ├── khook.hpp
│   │   │   ├── kioctl.hpp
│   │   │   ├── klist.hpp
│   │   │   ├── klog.hpp
│   │   │   ├── kmemory.hpp
│   │   │   ├── knet.hpp
│   │   │   ├── kpe_parse.hpp
│   │   │   ├── kref.hpp
│   │   │   ├── kstring.hpp
│   │   │   ├── ksystem_info.hpp
│   │   │   └── kvector.hpp
│   │   └── refs.hpp
│   └── src
│       ├── etwhook_init.cpp
│       ├── etwhook_main.cpp
│       ├── etwhook_manager.cpp
│       └── etwhook_utils.cpp
├── etw_hook.sln
└── readme.md

```

`etw_hook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.34301.259
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "etw_hook", "etw_hook\etw_hook.vcxproj", "{6782D26C-67E7-4A07-BAC0-16E505338328}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|ARM.ActiveCfg = Debug|ARM
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|ARM.Build.0 = Debug|ARM
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|ARM.Deploy.0 = Debug|ARM
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|ARM64.Build.0 = Debug|ARM64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|x64.ActiveCfg = Debug|x64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|x64.Build.0 = Debug|x64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|x64.Deploy.0 = Debug|x64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|x86.ActiveCfg = Debug|Win32
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|x86.Build.0 = Debug|Win32
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Debug|x86.Deploy.0 = Debug|Win32
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|ARM.ActiveCfg = Release|ARM
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|ARM.Build.0 = Release|ARM
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|ARM.Deploy.0 = Release|ARM
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|ARM64.ActiveCfg = Release|ARM64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|ARM64.Build.0 = Release|ARM64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|ARM64.Deploy.0 = Release|ARM64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|x64.ActiveCfg = Release|x64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|x64.Build.0 = Release|x64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|x64.Deploy.0 = Release|x64
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|x86.ActiveCfg = Release|Win32
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|x86.Build.0 = Release|Win32
		{6782D26C-67E7-4A07-BAC0-16E505338328}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A24098EA-884F-4535-9681-5ADA8FE0F5D5}
	EndGlobalSection
EndGlobal

```

`etw_hook/etw_hook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{6782D26C-67E7-4A07-BAC0-16E505338328}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>etw_hook</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)outputs\$(Platform)\$(ConfigurationName)\</OutDir>
    <IntDir>$(SolutionDir)objs\$(Platform)\$(ConfigurationName)\</IntDir>
    <ReferencePath>$(ReferencePath)</ReferencePath>
    <IncludePath>$(projectDir)include\;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)outputs\$(Platform)\$(ConfigurationName)\</OutDir>
    <IntDir>$(SolutionDir)objs\$(Platform)\$(ConfigurationName)\</IntDir>
    <ReferencePath>$(ReferencePath)</ReferencePath>
    <IncludePath>$(projectDir)include\;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include\etwhook_base.hpp" />
    <ClInclude Include="include\etwhook_init.hpp" />
    <ClInclude Include="include\etwhook_manager.hpp" />
    <ClInclude Include="include\etwhook_utils.hpp" />
    <ClInclude Include="include\kstl\karray.hpp" />
    <ClInclude Include="include\kstl\kautolock.hpp" />
    <ClInclude Include="include\kstl\kavl.hpp" />
    <ClInclude Include="include\kstl\kcallback.hpp" />
    <ClInclude Include="include\kstl\kcrypt.hpp" />
    <ClInclude Include="include\kstl\kfile.hpp" />
    <ClInclude Include="include\kstl\kfilter.hpp" />
    <ClInclude Include="include\kstl\kfunctional.hpp" />
    <ClInclude Include="include\kstl\khash_table.hpp" />
    <ClInclude Include="include\kstl\khook.hpp" />
    <ClInclude Include="include\kstl\kioctl.hpp" />
    <ClInclude Include="include\kstl\klist.hpp" />
    <ClInclude Include="include\kstl\klog.hpp" />
    <ClInclude Include="include\kstl\kmemory.hpp" />
    <ClInclude Include="include\kstl\knet.hpp" />
    <ClInclude Include="include\kstl\kpe_parse.hpp" />
    <ClInclude Include="include\kstl\kref.hpp" />
    <ClInclude Include="include\kstl\kstring.hpp" />
    <ClInclude Include="include\kstl\ksystem_info.hpp" />
    <ClInclude Include="include\kstl\kvector.hpp" />
    <ClInclude Include="include\refs.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\etwhook_init.cpp" />
    <ClCompile Include="src\etwhook_main.cpp" />
    <ClCompile Include="src\etwhook_manager.cpp" />
    <ClCompile Include="src\etwhook_utils.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`etw_hook/etw_hook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include\refs.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\karray.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kautolock.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kavl.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kcallback.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kcrypt.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kfile.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kfilter.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kfunctional.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\khash_table.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\khook.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kioctl.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\klist.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\klog.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kmemory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\knet.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kpe_parse.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kref.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kstring.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\ksystem_info.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\kstl\kvector.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\etwhook_init.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\etwhook_base.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\etwhook_manager.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\etwhook_utils.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\etwhook_main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\etwhook_init.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\etwhook_manager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\etwhook_utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`etw_hook/include/etwhook_base.hpp`:

```hpp
#pragma once
#ifndef _ETWHOOK_BASE_
#define _ETWHOOK_BASE_
#include <refs.hpp>

/*类基类*/
template <POOL_TYPE pool_type,ULONG pool_tag>
class _EtwBase {
public:
	void* operator new(size_t size);
	void  operator delete(void* p, size_t size);
};


template<POOL_TYPE pool_type, ULONG pool_tag>
inline void* _EtwBase<pool_type, pool_tag>::operator new(size_t size)
{
	return kalloc<char>(pool_type, size, pool_tag);
}

template<POOL_TYPE pool_type, ULONG pool_tag>
inline void _EtwBase<pool_type, pool_tag>::operator delete(void* p, size_t size) 
{
	UNREFERENCED_PARAMETER(size);
	return ExFreePool(p);
}

using EtwBase = _EtwBase<NonPagedPool, 'ewth'>;

#endif
```

`etw_hook/include/etwhook_init.hpp`:

```hpp
#pragma once
#ifndef _ETWHOOK_INIT_

#define _ETWHOOK_INIT_

#include <etwhook_base.hpp>


class EtwInitilizer :public EtwBase 
{
public:

	EtwInitilizer();

	~EtwInitilizer();

	NTSTATUS start_syscall_trace();
	NTSTATUS end_syscall_trace();

	/*打开这个 才会去HalPmcCounter函数执行*/
	NTSTATUS open_pmc_counter();


	unsigned char* get_EtwpMaxPmcCounter();

public:
	UINT_PTR* HalPrivateDispatchTable;
private:
	
	bool __is_open;
};

#endif
```

`etw_hook/include/etwhook_manager.hpp`:

```hpp
#pragma once
#include <refs.hpp>
#include <etwhook_base.hpp>
#include <etwhook_init.hpp>
#include <kstl/kavl.hpp>

class EtwHookManager  : public EtwBase
{
private:
	struct HookMap {
		void* org_func;
		void* detour_func;

		bool operator==(const HookMap& rhs) const { return this->org_func == rhs.org_func; }
		bool operator< (const HookMap& rhs) const { return this->org_func < rhs.org_func; }
		bool operator> (const HookMap& rhs) const { return this->org_func > rhs.org_func; }
	};

public:
	//单例
	static EtwHookManager* get_instance();

	NTSTATUS init();

	NTSTATUS destory();

	NTSTATUS add_hook(void* org_syscall,void* detour_routine);

	NTSTATUS remove_hook(void* org_syscall);

private:

	EtwHookManager();

	~EtwHookManager();

	static void hk_halcollectpmccounters(void* ctx, unsigned long long trace_buffer_end);

	void stack_trace_to_syscall();

	void record_syscall(void** call_routine);

private:
	
	kstd::kavl<HookMap> __hookmaps;

	EtwInitilizer __initilizer;

	static EtwHookManager* __instance;

	static void(*__orghalcollectpmccounters)(void*, unsigned long long);

	const ULONG  __halcollectpmccounters_idx = 73;

	void* __nt_img;
	ULONG __nt_size;
	ULONG_PTR __KiSystemServiceRepeat;


};
```

`etw_hook/include/etwhook_utils.hpp`:

```hpp
#pragma once
#ifndef _DM_UTILS_H_
#define _DM_UTILS_H_


NTSTATUS w2s(const wchar_t* src, char* dest, size_t destSize);
NTSTATUS s2w(const char* src, wchar_t* dest, size_t destSize);
void breakOnlyDebug();
auto find_module_base(const wchar_t* w_module_name, ULONG* size) -> void*;
bool _memcpy(PVOID address, PVOID target_address, ULONG length);
kstd::kwstring getModuleNameByPtr(PVOID p,PVOID* base=nullptr,size_t* size=nullptr);

#endif
```

`etw_hook/include/kstl/karray.hpp`:

```hpp
#pragma once
#include <fltKernel.h>

/// <summary>
/// 自己实现类似std::array 
/// 不需要构造函数 里面的成员是唯一的
/// </summary>
namespace kstd {

	template<class _Tp,size_t _N>
	struct KArray {
		
		using iterator = _Tp*;
		using pointer = _Tp*;
		using const_iterator = _Tp const*;

	public:

		_Tp& operator[](size_t i) {
			return __element[i];
		}

		_Tp const& operator[](size_t i) const {
			return __element[i];
		}
		//STL内部都有 既有const版本的 也有非const版本的
		_Tp & at(size_t i) {
			return __element[i];
		}

		_Tp const & at(size_t i) const {
			return __element[i];
		}

		void fill(const _Tp& value) {
			for (size_t i = 0; i < _N; i++) {
				__element[i] = value;
			}
		}

		_Tp& front() {
			return __element[0];
		}

		_Tp const& front() const {
			return __element[0];
		}

		_Tp& back() {
			return __element[_N-1];
		}

		_Tp const& back()const  {
			return __element[_N-1];
		}

		constexpr size_t size()  const {
			return _N;
		}

		_Tp* data() const {
			return __element;
		}

		_Tp const * cdata() const {
			return __element;
		}

		_Tp*  begin() {
			return __element;
		}

		_Tp* end() {
			return __element + _N;
		}

	//必须要是public 因为可以直接{1,23,5}使用这种列表初始化 否则不行
		_Tp __element[_N];

	};

}
```

`etw_hook/include/kstl/kautolock.hpp`:

```hpp
#pragma once
#include <fltKernel.h>


/// <summary>
/// author:oxygen
/// 一些自动的锁,基于RAII基质,把锁的指针(SpinLock Mutex EROUSE等等)填入进去,即可在一个作用域内进行自动枷锁解锁
/// </summary>
namespace kstd {

	//通过ERESOURCE进行同步
	class Resource {
	public:
		Resource(ERESOURCE* res) :__res(res) {}
		void acquire() {

			KeEnterCriticalRegion();
			ExAcquireResourceExclusiveLite(__res, TRUE);
		}

		void release() {

			ExReleaseResourceLite(__res);
			KeLeaveCriticalRegion();
		}
	private:
		ERESOURCE* __res;
	};

	class SpinLock {
	public:
		SpinLock(KSPIN_LOCK* lock):__spin_lock(lock),__irql(PASSIVE_LEVEL){}
		void acquire() {
			KeAcquireSpinLock(__spin_lock, &__irql);
		}
		void release() {
			KeReleaseSpinLock(__spin_lock, __irql);
		}
	private:
		KIRQL __irql;
		KSPIN_LOCK* __spin_lock;
	};
	//互斥体会让出时间片(调用KeWait)
	class Mutex {
	public:
		Mutex(KMUTEX* mutex):__mutex(mutex){}
		void acquire() {
			KeWaitForSingleObject(__mutex, Executive, KernelMode, false, NULL);

		}
		void release() {
			KeReleaseMutex(__mutex, false);
		}
	private:
		KMUTEX* __mutex;
	};
	//不能递归调用

	class FastMutex {
	public:
		FastMutex(FAST_MUTEX* f_mutex) :__fast_mutex(f_mutex){}
		void acquire() {
			ExAcquireFastMutex(__fast_mutex);

		}
		void release() {
			ExReleaseFastMutex(__fast_mutex);
		}
	private:
		FAST_MUTEX* __fast_mutex;
		//KIRQL __irql;
	};

	template<typename T>
	class AutoLock {
	public:
		AutoLock(const T& obj) : __obj(obj){
			__obj.acquire();
		}
		~AutoLock() {
			__obj.release();

		}
	private:
		T __obj;
	};
}
```

`etw_hook/include/kstl/kavl.hpp`:

```hpp
#pragma once
#define RTL_USE_AVL_TABLES 0
#include <fltKernel.h>

namespace kstd{

	//if you want to use this container,must add this MICRO in your class
#define MUSTADDED 		void operator delete(void* p, size_t s) { \
	p,s; \
	KeBugCheckEx(1, 1, 1, 1, 1); \
	} \


	template<typename T>
	class kavl {
	private:
		static const unsigned pool_tag = 'Kavl';
		static PVOID avlAlloc(RTL_AVL_TABLE* table, CLONG size);
		static VOID avlFree(RTL_AVL_TABLE* table, PVOID buf);
		static RTL_GENERIC_COMPARE_RESULTS avmCmpDefault(RTL_AVL_TABLE* table, PVOID first, PVOID second);
	private:
		T&& move(T& v) const { return static_cast<T&&>(v); }
	public:
		bool init(PRTL_AVL_COMPARE_ROUTINE cmp_func=kavl::avmCmpDefault);
		bool destory(void(*free_callback)(const T* item)=nullptr);

		bool insert(const T& item);
		bool insert(T&& item);

		T* find(const T& item);
		void remove(T* item);

		ULONG size();

		//只能通过下标遍历
		T& operator[](ULONG idx);

		//没有拷贝构造，移动语义 移动赋值 赋值 如果有需要 以后再加
		kavl() = default;
		~kavl() = default;
		kavl(const T& rhs) = delete;
		kavl(T&& rhs) = delete;
		kavl& operator=(const T& rhs) = delete;
		kavl& operator=(T&& rhs) = delete;
	private:
		PERESOURCE __lock;
		PRTL_AVL_TABLE __avl_table;
	};







	template<typename T>
	inline PVOID kavl<T>::avlAlloc(RTL_AVL_TABLE* table, CLONG size)
	{
		UNREFERENCED_PARAMETER(table);

		return ExAllocatePoolWithTag(NonPagedPool,size,pool_tag);
	}

	template<typename T>
	inline VOID kavl<T>::avlFree(RTL_AVL_TABLE* table, PVOID buf)
	{
		UNREFERENCED_PARAMETER(table);

		return ExFreePool(buf);
	}

	template<typename T>
	inline RTL_GENERIC_COMPARE_RESULTS kavl<T>::avmCmpDefault(RTL_AVL_TABLE* table, PVOID first, PVOID second)
	{
		UNREFERENCED_PARAMETER(table);

		if (*reinterpret_cast<T*>(first) == *reinterpret_cast<T*>(second)) return GenericEqual;
		else if (*reinterpret_cast<T*>(first) < *reinterpret_cast<T*>(second)) return GenericLessThan;
		else return GenericGreaterThan;
		
	}


	template<typename T>
	inline bool kavl<T>::init(PRTL_AVL_COMPARE_ROUTINE cmp_func)
	{
		
		__lock = reinterpret_cast<PERESOURCE>(ExAllocatePoolWithTag(NonPagedPool, sizeof ERESOURCE, pool_tag));
		if (!__lock) return false;
		__avl_table = reinterpret_cast<PRTL_AVL_TABLE>(ExAllocatePoolWithTag(NonPagedPool, sizeof RTL_AVL_TABLE, pool_tag));
		if (!__avl_table) {
			ExFreePool(__lock);
			return false;
		}

		RtlInitializeGenericTableAvl(__avl_table, cmp_func, avlAlloc, avlFree, nullptr);
		ExInitializeResourceLite(__lock);
		return true;
	}

	template<typename T>
	inline bool kavl<T>::destory(void(*free_callback)(const T* item))
	{
		KeEnterCriticalRegion();
		ExAcquireResourceExclusiveLite(__lock, true);

		auto cnt = RtlNumberGenericTableElementsAvl(__avl_table);

		for (auto i = 0ul; i < cnt; i++) {
			auto node = RtlGetElementGenericTableAvl(__avl_table, 0);
			if (node) {
				if (free_callback != nullptr) {
					//use user manual free callback
					free_callback((const T*)node);
				}
				else {
					//directly call dtor
					reinterpret_cast<T*>(node)->~T();
				}

				RtlDeleteElementGenericTableAvl(__avl_table, node);
			}
			
		}
		ExReleaseResourceLite(__lock);
		KeLeaveCriticalRegion();

		ExDeleteResourceLite(__lock);
		if (this->__avl_table != nullptr) {
			ExFreePool(__avl_table);
			__avl_table = nullptr;
		}
		if (this->__lock != nullptr) {
			ExFreePool(__lock);
			__lock = nullptr;
		}

		return true;
	}

	template<typename T>
	inline bool kavl<T>::insert(const T& item)
	{
		bool suc = false;
		KeEnterCriticalRegion();
		ExAcquireResourceExclusiveLite(__lock, true);

		auto ret = (T*)RtlInsertElementGenericTableAvl(__avl_table, (PVOID)&item, sizeof(T), nullptr);
		//这个函数是浅拷贝,一定要自己手动拷贝一下
		if (ret != nullptr) {
			memset(ret, 0, sizeof(T));
			*ret = item;
			suc = true;
		}

		ExReleaseResourceLite(__lock);
		KeLeaveCriticalRegion();
		return suc;
	}

	template<typename T>
	inline bool kavl<T>::insert(T&& item)
	{
		bool suc = false;
		KeEnterCriticalRegion();
		ExAcquireResourceExclusiveLite(__lock, true);

		auto ret = (T*)RtlInsertElementGenericTableAvl(__avl_table, (PVOID)&item, sizeof(T), nullptr);
		//这个函数是浅拷贝,一定要自己手动拷贝一下
		if (ret != nullptr) {
			memset(ret, 0, sizeof(T));
			*ret = move(item);
			suc = true;
		}

		ExReleaseResourceLite(__lock);
		KeLeaveCriticalRegion();
		return suc;
	}


	template<typename T>
	inline T* kavl<T>::find(const T& item)
	{
		KeEnterCriticalRegion();
		ExAcquireResourceExclusiveLite(__lock, true);
		
		auto f = reinterpret_cast<T*>(RtlLookupElementGenericTableAvl(__avl_table, (PVOID)&item));

		ExReleaseResourceLite(__lock);
		KeLeaveCriticalRegion();

		return f;
	}

	template<typename T>
	inline void kavl<T>::remove(T* item)
	{
		KeEnterCriticalRegion();
		ExAcquireResourceExclusiveLite(__lock, true);

		if (MmIsAddressValid(item)) {
			//执行析构函数
			item->~T();
			RtlDeleteElementGenericTableAvl(__avl_table, item);
		}
			

		ExReleaseResourceLite(__lock);
		KeLeaveCriticalRegion();
	}


	template<typename T>
	inline ULONG kavl<T>::size()
	{
		return RtlNumberGenericTableElementsAvl(__avl_table);
	}

	template<typename T>
	inline T& kavl<T>::operator[](ULONG idx)
	{
		T* p = nullptr;
		KeEnterCriticalRegion();
		ExAcquireResourceExclusiveLite(__lock, true);

		p = (T*)RtlGetElementGenericTableAvl(__avl_table, idx);

		ExReleaseResourceLite(__lock);
		KeLeaveCriticalRegion();

		if (MmIsAddressValid(p)) return *p;
		else {
			//Bug Check
			KeBugCheckEx(IRQL_NOT_GREATER_OR_EQUAL, 0x1111, 0x2222, 0x3333,0X1111);
		}
	}

}
```

`etw_hook/include/kstl/kcallback.hpp`:

```hpp
#pragma once
#include <fltKernel.h>


/// <summary>
///provide various callback type like apc dpc ipi pmi and so on 
///
/// </summary>
namespace kstd {


	
	class Apc {


	};

	class Dpc {


	};

	class Ipi {


	};

	class Nmi {


	};

	class Pmi {


	};

	template<typename CallbackType>
	class CallBack {


	};



}
```

`etw_hook/include/kstl/kcrypt.hpp`:

```hpp
#pragma once

//就抄之前开源github的kcrypt就行

namespace kstd {




}
```

`etw_hook/include/kstl/kfile.hpp`:

```hpp
#pragma once
#include <fltKernel.h>

/// <summary>
/// author:oxygen
/// 智能文件对象,类似C++提供的file对象 记得填写nt路径 而不是dos路径
/// </summary>
namespace kstd {

class Kfile
		{
		public:
			static const constexpr  int rdonly = 1;
			static const constexpr int wronly = 2;
			static const constexpr int rdwr = 4;
			static const constexpr int cretae = 8;/*不存在就创建*/
			static const constexpr int append = 0x10;/*追加*/
			static const constexpr int isdir = 0x100;/*是目录*/
			
		public:
			Kfile(const wchar_t* path, int open_mode,ULONG share_access=0);
			Kfile(const PUNICODE_STRING u_path, int open_mode, ULONG share_access=0);
			Kfile(const Kfile& rhs);/*拷贝构造 记得深拷贝*/
			Kfile& operator=(const Kfile& rhs);
			~Kfile();
			
		public:
			UNICODE_STRING getFileUPath()const { return __u_path; }
			wchar_t* getFilePath() const { return __p; }
			HANDLE getFileHandle() const { return __handle; }

			void seekg(const ULONG offset) { __offset = offset; }
			ULONG tellg() const { return __offset; }
			void close();
			bool read(void* buf, ULONG read_size);
			ULONG write(void* buf, ULONG buf_size);/*返回实际独到的*/
		private:
			bool open(ULONG share_acess = 0);
		private:
			static NTSTATUS createDirIter(const PUNICODE_STRING u_path);/*迭代地创建文件*/
			static NTSTATUS createDir(const PUNICODE_STRING u_path,HANDLE* h_file=nullptr);/*非迭代的创建*/
		private:
			HANDLE __handle;/*文件句柄*/
			wchar_t* __p;/*alloc申请 记得释放*/
			UNICODE_STRING __u_path;
			int __open_mode;
			ULONG __offset;
			ULONG __file_size;
			ULONG __share_access;
		};

		inline Kfile::Kfile(const wchar_t* path, const int open_mode,ULONG share_access):
		__handle(nullptr),__p(nullptr),__u_path({}), __open_mode(open_mode), __offset(0), __share_access(share_access)
		{
			const auto alloc_size = (wcslen(path) + 1) * sizeof(wchar_t);

			do
			{
				__p = reinterpret_cast<wchar_t*>(ExAllocatePoolWithTag(NonPagedPool, alloc_size, 'file'));
				if (__p == nullptr) break;

				memset(__p, 0, alloc_size);

				wcscpy(__p, path);
				RtlInitUnicodeString(&__u_path, __p);

				/*内部直接open 不放外部了*/
				open(__share_access);
			} while (false);
		}

		inline Kfile::Kfile(const PUNICODE_STRING u_path, int open_mode, ULONG share_access):
		__handle(nullptr), __p(nullptr), __u_path({}), __open_mode(open_mode), __offset(0),__share_access(share_access)
		{
			const auto alloc_size = (wcslen(u_path->Buffer) + 1) * sizeof(wchar_t);

			do
			{
				__p = reinterpret_cast<wchar_t*>(ExAllocatePoolWithTag(NonPagedPool, alloc_size, 'file'));
				if (__p == nullptr) break;

				memset(__p, 0, alloc_size);

				wcscpy(__p, u_path->Buffer);
				RtlInitUnicodeString(&__u_path, __p);

				/*内部直接open 不放外部了*/
				open(__share_access);
			} while (false);
		}

		inline Kfile::Kfile(const Kfile& rhs) :
			__handle(nullptr), __p(nullptr), __u_path({}), __open_mode(rhs.__open_mode),__offset(0),__share_access(rhs.__share_access)
		{
			if (rhs.__p == nullptr) return;

			const auto alloc_size = (wcslen(rhs.__p) + 1) * sizeof(wchar_t);

			do
			{
				
				__p = reinterpret_cast<wchar_t*>(ExAllocatePoolWithTag(NonPagedPool, alloc_size, 'file'));
				if (__p == nullptr) break;

				memset(__p, 0, alloc_size);

				wcscpy(__p, rhs.__p);
				RtlInitUnicodeString(&__u_path, __p);

				open(__share_access);
			} while (false);
		}


		inline Kfile& Kfile::operator=(const Kfile& rhs)
		{
			__handle = nullptr;
			__p = nullptr;
			__u_path = {};
			__open_mode = rhs.__open_mode;
			__offset = 0;
			__share_access = rhs.__share_access;

			if (rhs.__p == nullptr || &rhs==this/*self assign*/) return *this;

			const auto alloc_size = (wcslen(rhs.__p) + 1) * sizeof(wchar_t);

			do
			{

				__p = reinterpret_cast<wchar_t*>(ExAllocatePoolWithTag(NonPagedPool, alloc_size, 'file'));
				if (__p == nullptr) break;

				memset(__p, 0, alloc_size);

				wcscpy(__p, rhs.__p);
				RtlInitUnicodeString(&__u_path, __p);

				open(__share_access);
			} while (false);

			return *this;
		}

		inline Kfile::~Kfile()
		{
			if(__p!=nullptr)
			{
				ExFreePool(__p);
				__p = nullptr;

			}
			if(__handle!=nullptr)
			{
				ZwClose(__handle);
				__handle = nullptr;
			}
		}

		inline void Kfile::close()
		{
			if(__handle!=nullptr)
				ZwClose(__handle);
			__handle = nullptr;
		}

		inline bool Kfile::read(void* buf, ULONG read_size)
		{
			auto ret = false;
			if (read_size > __file_size - __offset || buf==nullptr) return false;

			IO_STATUS_BLOCK isb{};
			LARGE_INTEGER offset{ __offset };

			auto status = ZwReadFile(__handle, nullptr, nullptr, nullptr, &isb, buf, read_size, &offset, 0);
			if(NT_SUCCESS(status))
			{
				ret = true;
				__offset += read_size;
			}

			return ret;
		}

		inline ULONG Kfile::write(void* buf, ULONG buf_size)
		{
			auto ret = false;
			IO_STATUS_BLOCK isb{};
			LARGE_INTEGER offset{ __offset };
			auto status = ZwWriteFile(__handle, nullptr, nullptr,
				nullptr, &isb, buf, buf_size, &offset, 0);
			ZwFlushBuffersFile(__handle, &isb);
			
			if (NT_SUCCESS(status))
			{
				ret = true;
				__offset += buf_size;
			}

			return ret;
		}

		inline bool Kfile::open(ULONG share_access)
		{
			auto ret = false;
			auto access_flags = 0ul;
			auto create_disp_flags = 0ul;
			OBJECT_ATTRIBUTES oa{};
			IO_STATUS_BLOCK isb{};
			InitializeObjectAttributes(&oa, &this->__u_path, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, 0, 0);

			do
			{
				//先检查一下是否参数正确
				if (((__open_mode & Kfile::rdonly) && (__open_mode & Kfile::wronly)) ||
					((__open_mode & Kfile::rdonly) && (__open_mode & Kfile::append))
					) break;


				//处理目录
				if (__open_mode & Kfile::isdir)
				{
					if (__open_mode & Kfile::cretae)
					{
						//那么需要先创建一下
						Kfile::createDirIter(&this->__u_path);
					}
					//然后再打开这个目录
					if (NT_SUCCESS(Kfile::createDir(&this->__u_path, &__handle)))
					{
						ret = true;
						break;
					}
					else break;
				}

				//处理可读文件
				if (__open_mode & Kfile::rdonly)
				{
					access_flags |= GENERIC_READ;
				}
				if (__open_mode & Kfile::wronly)
				{
					access_flags |= GENERIC_WRITE;
				}
				if (__open_mode & Kfile::rdwr)
				{
					access_flags |= GENERIC_ALL;
				}
				if (__open_mode & Kfile::cretae)
				{
					if (__open_mode & Kfile::append) create_disp_flags |= FILE_OPEN_IF;
					else create_disp_flags |= FILE_OVERWRITE_IF;
				}
				else
				{
					create_disp_flags |= FILE_OPEN;
				}

				
				if (!NT_SUCCESS(ZwCreateFile(&this->__handle, access_flags, &oa, &isb,
					nullptr, FILE_ATTRIBUTE_NORMAL,
					share_access, create_disp_flags, 0, 0, 0))) break;

				FILE_STANDARD_INFORMATION file_info{};
				//开始询问文件大小
				if(!NT_SUCCESS(ZwQueryInformationFile(__handle, &isb, 
					&file_info, sizeof(file_info), FileStandardInformation)))
				{
					ZwClose(__handle);
					__handle=nullptr;
					ret=false;
					break;
				}

				//打开成功
				ret=true;
				__file_size=file_info.EndOfFile.LowPart;
				if (__open_mode & Kfile::append) __offset = __file_size;

			} while (false);

			return ret;
		}


		inline NTSTATUS Kfile::createDirIter(const PUNICODE_STRING u_path)
		{
			auto status = STATUS_UNSUCCESSFUL;

			if (u_path != nullptr)
			{

				for (auto i = 0ul; i < u_path->Length / sizeof(wchar_t); i++)
				{
					if (u_path->Buffer[i] == L'\\')
					{
						//find division
						//\\??\\C:\\lala\\haha
						auto tmp_path = reinterpret_cast<wchar_t*>(ExAllocatePoolWithTag(NonPagedPool,
							(i + 1) * sizeof(wchar_t), 'tmp'));
						auto u_tmp_path = UNICODE_STRING{};
						if (tmp_path != nullptr)
						{
							memset(tmp_path, 0, (i + 1) * sizeof(wchar_t));
							memcpy(tmp_path, u_path->Buffer, i * sizeof(wchar_t));
							RtlInitUnicodeString(&u_tmp_path, tmp_path);
							createDir(&u_tmp_path);
							ExFreePool(tmp_path);
						}
						else
						{

							break;
						}


					}


				}

				status = STATUS_SUCCESS;

			}

			return status;
		}

		inline NTSTATUS Kfile::createDir(const PUNICODE_STRING u_path, HANDLE* p_h_file)
		{
			
			auto status = STATUS_SUCCESS;
			auto h_file = HANDLE{};
			OBJECT_ATTRIBUTES oa{};
			IO_STATUS_BLOCK isb{};

			InitializeObjectAttributes(&oa, u_path, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, 0, 0);



			if (NT_SUCCESS(
				status = ZwCreateFile(&h_file, GENERIC_READ | GENERIC_WRITE, &oa, &isb, nullptr,
					FILE_ATTRIBUTE_DIRECTORY,
					FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
					FILE_OPEN_IF, FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
					0, 0)
			)
				)
			{
				if (p_h_file != nullptr) *p_h_file = h_file;
				else status = ZwClose(h_file);

			}

			return status;
			
		}

}
```

`etw_hook/include/kstl/kfilter.hpp`:

```hpp
#pragma once
#include <fltKernel.h>


//minifilterºÍwpfºÍNDIS
namespace kstd {


}

```

`etw_hook/include/kstl/kfunctional.hpp`:

```hpp
#pragma once
//author :oxygen

namespace kstd {
#pragma warning(disable : 4996)
	static const long pool_tag = 'func';

	template<typename T>
	struct always_false {
	public:
		static constexpr bool value = false;
	};

	//上面的always_false就是为了让他返回失败 这个是默认的模板funtion类,默认一定是错误的，因为我们需要的是模板特化
	template<typename FuncSig>
	struct kfunction {

		static_assert(always_false<FuncSig>::value, "invalid function sig!");

	};

	//对于kfunction的特化
	template<typename Ret, typename... Args>
	struct kfunction<Ret(Args...)/*这个类型才不会触发静态断言*/> {

	private:
		/*提供接口,隐藏FuncType这个类型在上面的模板*/
		struct FuncBase {
			virtual Ret call(Args... args) = 0;
			virtual ~FuncBase() = default;
			void operator delete (void* p,size_t size) {
				//必须定义 因为FuncIpml会调用这个 内核没有全局delete!! 我们啥都不用干 因为这个类没有用重载new
				//但是必须得实现! 为什么呢? 因为我们保存的是这个玩意的指针,所以他会调用这个函数，但是这是个纯虚类,最终会
				//调用虚表到FuncImpl!
				__debugbreak();
				UNREFERENCED_PARAMETER(p);
				UNREFERENCED_PARAMETER(size);
			}
		};

		/*多态*/
		template<typename FuncType>
		struct FuncImpl : FuncBase {
		public:
			FuncImpl(FuncType func) : __func(func){}

			virtual Ret call(Args... args) override {
				
				return __func(args...);/*这里不考虑完美转发 内核没有std::forward*/
				
			}
			
			/*内部重载new*/
			void* operator new(size_t size) {
				return ExAllocatePoolWithTag(NonPagedPool, size, pool_tag);
			}
			
			void operator delete(void* p, size_t size) {
				
				if (p != nullptr && size != 0) {
					ExFreePool(p);
				}
			}

			FuncType __func;

		};

	public:

		kfunction():__fb(nullptr){}

		template<typename FuncType>
		kfunction(FuncType ft) : kfunction() {

			__fb = new FuncImpl<FuncType>(ft);
		}

		Ret operator()(Args&&... args) {
			if (__fb != nullptr)
				return __fb->call(args...);
			else return Ret();
		}

		~kfunction() {
			
			if (__fb) {
				delete __fb;
				__fb = nullptr;
			}
				
		}
	private:
		FuncBase* __fb;
	};

#pragma warning(default : 4996)
}
```

`etw_hook/include/kstl/khash_table.hpp`:

```hpp
#pragma once
#include <fltKernel.h>

namespace kstd {



}
```

`etw_hook/include/kstl/khook.hpp`:

```hpp
#pragma once
#include <fltKernel.h>
#include <intrin.h>
#include <ntimage.h>

//a simple kernel hook lib
//current contain driver object hook and kernel inline hook
namespace kstd {

	extern "C" {

		VOID KeGenericCallDpc(__in PKDEFERRED_ROUTINE Routine, __in_opt PVOID Context);

		VOID KeSignalCallDpcDone(__in PVOID SystemArgument1);

		LOGICAL KeSignalCallDpcSynchronize(__in PVOID SystemArgument2);

	}
	

#pragma warning(disable : 4996)
	// h disassambly engine
	namespace hde_inner {
		/* __cdecl */
		typedef INT8   int8_t;
		typedef INT16  int16_t;
		typedef INT32  int32_t;
		typedef INT64  int64_t;
		typedef UINT8  uint8_t;
		typedef UINT16 uint16_t;
		typedef UINT32 uint32_t;
		typedef UINT64 uint64_t;

#pragma pack(push,1)
		typedef struct {
			uint8_t len;
			uint8_t p_rep;
			uint8_t p_lock;
			uint8_t p_seg;
			uint8_t p_66;
			uint8_t p_67;
			uint8_t rex;
			uint8_t rex_w;
			uint8_t rex_r;
			uint8_t rex_x;
			uint8_t rex_b;
			uint8_t opcode;
			uint8_t opcode2;
			uint8_t modrm;
			uint8_t modrm_mod;
			uint8_t modrm_reg;
			uint8_t modrm_rm;
			uint8_t sib;
			uint8_t sib_scale;
			uint8_t sib_index;
			uint8_t sib_base;
			union {
				uint8_t imm8;
				uint16_t imm16;
				uint32_t imm32;
				uint64_t imm64;
			} imm;
			union {
				uint8_t disp8;
				uint16_t disp16;
				uint32_t disp32;
			} disp;
			uint32_t flags;
		} hde64s;
#pragma pack(pop)
		unsigned int hde64_disasm(const void* code, hde64s* hs);



	}



	class DrvObjHookManager {
	private:
		struct DrvObjInfo {

			void* base;
			void* entry_point;
			PDRIVER_OBJECT drv;
			void(*drvunload_callback)(PDRIVER_OBJECT, void* context);
			NTSTATUS(*drventry_callback)(PDRIVER_OBJECT, PUNICODE_STRING, void* context);
			LIST_ENTRY links;
			void* entry_context;
			void* unload_context;
			PDRIVER_UNLOAD org_unload;
			unsigned char org_bytes[14];
			bool is_exit;

		};

	public:

		static DrvObjHookManager* getInstance();

		//must called at img call back routine
		static NTSTATUS addDrvObjHook(void* img_base,
			NTSTATUS(*drventry_callback)(PDRIVER_OBJECT, PUNICODE_STRING, void* context),
			void(*drvunload_callback)(PDRIVER_OBJECT, void* context),
			void* entry_context=nullptr,void* unload_context=nullptr);

		//call this,it's will cancel drv unload hook
		static void removeDrvObjHook(void* img_base);

		//call this func will cancel all the drv unload hook and will clean up this instance
		static void destory();

	private:

		//helper function
		static void* getEntryPoint(void* img);
		static void* mapAddrByMdl(void* addr, size_t map_size, PMDL* mdl);
		static void unmapAddrByMdl(PMDL mdl);

		static DrvObjInfo* findDrvInfoByBase(void* entry_point);
		static NTSTATUS defaultDrvEntry(PDRIVER_OBJECT drv,PUNICODE_STRING u);
		static void defaultDrvUnload(PDRIVER_OBJECT drv);

	private:
		inline static bool __inited;
		inline static constexpr unsigned pool_tag = 'drvH';
		inline static LIST_ENTRY __head;
		inline static KSPIN_LOCK __lock;
		inline static DrvObjHookManager* __instance;
	};
	//driver object hook
	//can hook dispatch func,driver entry,driver unload, must init at 
	//you can exalloate memory and call init,can not call ctor or dtor!(it's only use at a ptr)
	
	//inline hook manager
	class InlineHookManager {
	public:
		// what callback sync memory
		enum class HookType {
			Dpc,
			Ipi,
		};
	private:
		typedef struct HookInfo {
			LIST_ENTRY links;
			void* hook_addr;
			void* trampline;
			unsigned char originalBytes[14];
			HookType type;
		}*pHookInfo;

		typedef struct IpiContext {
			unsigned char* modify_buf;
			unsigned char* modify_content;
			size_t modify_size;
			void* org_addr; /*hook addr org*/
			void** hk_addr;/*should modify this value in dpc or ipi callback*/
			void* tramp_line;
			volatile LONG done_cpu_count;
		}*pIpiContext;
		inline static constexpr int cover_size = 14/* inline hook cover 14 bytes*/;
	public:
		
		InlineHookManager() = delete;
		~InlineHookManager() = delete;
		static InlineHookManager* getInstance();
		static NTSTATUS init();
		static NTSTATUS inlinehook(void* target_addr, void** hk_addr,HookType hk_type=HookType::Dpc);
		static NTSTATUS destory();
		static NTSTATUS remove(void* target_addr);
		
	private:
		static NTSTATUS remove(pHookInfo hook_info);
		static void* mapAddrByMdl(void* addr, size_t map_size, PMDL* mdl);
		static void unmapAddrByMdl(PMDL mdl);
		static pHookInfo getHookInfoByAddr(void* target_addr);
		static ULONG_PTR ipiCallback(ULONG_PTR context);
		static void dpcCallback(_In_ struct _KDPC* Dpc,
			_In_opt_ PVOID DeferredContext,
			_In_opt_ PVOID SystemArgument1,
			_In_opt_ PVOID SystemArgument2);

	private:
		inline /*must define as inline*/ static InlineHookManager* __instance;
		inline static ULONG __cpu_count;
		inline static KSPIN_LOCK __spinlock;
		inline static LIST_ENTRY __head;
		inline static constexpr unsigned pool_tag = 0;
		inline static unsigned char __jmpcode[14] = { 0xff,0x25,0x00,0x00,0x00,0x00,0,0,0,0,0,0,0,0 };
		inline static bool __inited;
		inline static  void* __alloc_old;
		inline static void* __alloc_new;
	};

	namespace hde_inner {

		/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

		static unsigned char hde64_table[] = {
		  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
		  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
		  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
		  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
		  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
		  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
		  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
		  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
		  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
		  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
		  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
		  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
		  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
		  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
		  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
		  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
		  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
		  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
		  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
		  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
		  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
		  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
		  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
		  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
		  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
		  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
		  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
		  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
		  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
		  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
		  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
		  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
		  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
		  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
		  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
		  0x00,0xf0,0x02,0x00
		};


#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67



		/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */
 // Integer types for HDE.
#if defined(_M_X64) || defined(__x86_64__)
#pragma warning(push, 0)
#pragma warning(disable: 4701 4706 26451)

		inline unsigned int hde64_disasm(const void* code, hde64s* hs)
		{
			uint8_t x, c, * p = (uint8_t*)code, cflags, opcode, pref = 0;
			uint8_t* ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
			uint8_t op64 = 0;

			// Avoid using memset to reduce the footprint.
			memset(hs, 0, sizeof(hde64s));

			for (x = 16; x; x--)
				switch (c = *p++) {
				case 0xf3:
					hs->p_rep = c;
					pref |= PRE_F3;
					break;
				case 0xf2:
					hs->p_rep = c;
					pref |= PRE_F2;
					break;
				case 0xf0:
					hs->p_lock = c;
					pref |= PRE_LOCK;
					break;
				case 0x26: case 0x2e: case 0x36:
				case 0x3e: case 0x64: case 0x65:
					hs->p_seg = c;
					pref |= PRE_SEG;
					break;
				case 0x66:
					hs->p_66 = c;
					pref |= PRE_66;
					break;
				case 0x67:
					hs->p_67 = c;
					pref |= PRE_67;
					break;
				default:
					goto pref_done;
				}
		pref_done:

			hs->flags = (uint32_t)pref << 23;

			if (!pref)
				pref |= PRE_NONE;

			if ((c & 0xf0) == 0x40) {
				hs->flags |= F_PREFIX_REX;
				if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
					op64++;
				hs->rex_r = (c & 7) >> 2;
				hs->rex_x = (c & 3) >> 1;
				hs->rex_b = c & 1;
				if (((c = *p++) & 0xf0) == 0x40) {
					opcode = c;
					goto error_opcode;
				}
			}

			if ((hs->opcode = c) == 0x0f) {
				hs->opcode2 = c = *p++;
				ht += DELTA_OPCODES;
			}
			else if (c >= 0xa0 && c <= 0xa3) {
				op64++;
				if (pref & PRE_67)
					pref |= PRE_66;
				else
					pref &= ~PRE_66;
			}

			opcode = c;
			cflags = ht[ht[opcode / 4] + (opcode % 4)];

			if (cflags == C_ERROR) {
			error_opcode:
				hs->flags |= F_ERROR | F_ERROR_OPCODE;
				cflags = 0;
				if ((opcode & -3) == 0x24)
					cflags++;
			}

			x = 0;
			if (cflags & C_GROUP) {
				uint16_t t;
				t = *(uint16_t*)(ht + (cflags & 0x7f));
				cflags = (uint8_t)t;
				x = (uint8_t)(t >> 8);
			}

			if (hs->opcode2) {
				ht = hde64_table + DELTA_PREFIXES;
				if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
					hs->flags |= F_ERROR | F_ERROR_OPCODE;
			}

			if (cflags & C_MODRM) {
				hs->flags |= F_MODRM;
				hs->modrm = c = *p++;
				hs->modrm_mod = m_mod = c >> 6;
				hs->modrm_rm = m_rm = c & 7;
				hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

				if (x && ((x << m_reg) & 0x80))
					hs->flags |= F_ERROR | F_ERROR_OPCODE;

				if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
					uint8_t t = opcode - 0xd9;
					if (m_mod == 3) {
						ht = hde64_table + DELTA_FPU_MODRM + t * 8;
						t = ht[m_reg] << m_rm;
					}
					else {
						ht = hde64_table + DELTA_FPU_REG;
						t = ht[t] << m_reg;
					}
					if (t & 0x80)
						hs->flags |= F_ERROR | F_ERROR_OPCODE;
				}

				if (pref & PRE_LOCK) {
					if (m_mod == 3) {
						hs->flags |= F_ERROR | F_ERROR_LOCK;
					}
					else {
						uint8_t* table_end, op = opcode;
						if (hs->opcode2) {
							ht = hde64_table + DELTA_OP2_LOCK_OK;
							table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
						}
						else {
							ht = hde64_table + DELTA_OP_LOCK_OK;
							table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
							op &= -2;
						}
						for (; ht != table_end; ht++)
							if (*ht++ == op) {
								if (!((*ht << m_reg) & 0x80))
									goto no_lock_error;
								else
									break;
							}
						hs->flags |= F_ERROR | F_ERROR_LOCK;
					no_lock_error:
						;
					}
				}

				if (hs->opcode2) {
					switch (opcode) {
					case 0x20: case 0x22:
						m_mod = 3;
						if (m_reg > 4 || m_reg == 1)
							goto error_operand;
						else
							goto no_error_operand;
					case 0x21: case 0x23:
						m_mod = 3;
						if (m_reg == 4 || m_reg == 5)
							goto error_operand;
						else
							goto no_error_operand;
					}
				}
				else {
					switch (opcode) {
					case 0x8c:
						if (m_reg > 5)
							goto error_operand;
						else
							goto no_error_operand;
					case 0x8e:
						if (m_reg == 1 || m_reg > 5)
							goto error_operand;
						else
							goto no_error_operand;
					}
				}

				if (m_mod == 3) {
					uint8_t* table_end;
					if (hs->opcode2) {
						ht = hde64_table + DELTA_OP2_ONLY_MEM;
						table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
					}
					else {
						ht = hde64_table + DELTA_OP_ONLY_MEM;
						table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
					}
					for (; ht != table_end; ht += 2)
						if (*ht++ == opcode) {
							if (*ht++ & pref && !((*ht << m_reg) & 0x80))
								goto error_operand;
							else
								break;
						}
					goto no_error_operand;
				}
				else if (hs->opcode2) {
					switch (opcode) {
					case 0x50: case 0xd7: case 0xf7:
						if (pref & (PRE_NONE | PRE_66))
							goto error_operand;
						break;
					case 0xd6:
						if (pref & (PRE_F2 | PRE_F3))
							goto error_operand;
						break;
					case 0xc5:
						goto error_operand;
					}
					goto no_error_operand;
				}
				else
					goto no_error_operand;

			error_operand:
				hs->flags |= F_ERROR | F_ERROR_OPERAND;
			no_error_operand:

				c = *p++;
				if (m_reg <= 1) {
					if (opcode == 0xf6)
						cflags |= C_IMM8;
					else if (opcode == 0xf7)
						cflags |= C_IMM_P66;
				}

				switch (m_mod) {
				case 0:
					if (pref & PRE_67) {
						if (m_rm == 6)
							disp_size = 2;
					}
					else
						if (m_rm == 5)
							disp_size = 4;
					break;
				case 1:
					disp_size = 1;
					break;
				case 2:
					disp_size = 2;
					if (!(pref & PRE_67))
						disp_size <<= 1;
				}

				if (m_mod != 3 && m_rm == 4) {
					hs->flags |= F_SIB;
					p++;
					hs->sib = c;
					hs->sib_scale = c >> 6;
					hs->sib_index = (c & 0x3f) >> 3;
					if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
						disp_size = 4;
				}

				p--;
				switch (disp_size) {
				case 1:
					hs->flags |= F_DISP8;
					hs->disp.disp8 = *p;
					break;
				case 2:
					hs->flags |= F_DISP16;
					hs->disp.disp16 = *(uint16_t*)p;
					break;
				case 4:
					hs->flags |= F_DISP32;
					hs->disp.disp32 = *(uint32_t*)p;
				}
				p += disp_size;
			}
			else if (pref & PRE_LOCK)
				hs->flags |= F_ERROR | F_ERROR_LOCK;

			if (cflags & C_IMM_P66) {
				if (cflags & C_REL32) {
					if (pref & PRE_66) {
						hs->flags |= F_IMM16 | F_RELATIVE;
						hs->imm.imm16 = *(uint16_t*)p;
						p += 2;
						goto disasm_done;
					}
					goto rel32_ok;
				}
				if (op64) {
					hs->flags |= F_IMM64;
					hs->imm.imm64 = *(uint64_t*)p;
					p += 8;
				}
				else if (!(pref & PRE_66)) {
					hs->flags |= F_IMM32;
					hs->imm.imm32 = *(uint32_t*)p;
					p += 4;
				}
				else
					goto imm16_ok;
			}

			if (cflags & C_IMM16) {
			imm16_ok:
				hs->flags |= F_IMM16;
				hs->imm.imm16 = *(uint16_t*)p;
				p += 2;
			}
			if (cflags & C_IMM8) {
				hs->flags |= F_IMM8;
				hs->imm.imm8 = *p++;
			}

			if (cflags & C_REL32) {
			rel32_ok:
				hs->flags |= F_IMM32 | F_RELATIVE;
				hs->imm.imm32 = *(uint32_t*)p;
				p += 4;
			}
			else if (cflags & C_REL8) {
				hs->flags |= F_IMM8 | F_RELATIVE;
				hs->imm.imm8 = *p++;
			}

		disasm_done:

			if ((hs->len = (uint8_t)(p - (uint8_t*)code)) > 15) {
				hs->flags |= F_ERROR | F_ERROR_LENGTH;
				hs->len = 15;
			}

			return (unsigned int)hs->len;
		}
#pragma warning(pop)
#endif // defined(_M_X64) || defined(__x86_64__)

	}

	inline InlineHookManager* InlineHookManager::getInstance()
	{
		if (__instance == nullptr) {

			__instance = reinterpret_cast<InlineHookManager*>(ExAllocatePoolWithTag(NonPagedPoolNx, sizeof InlineHookManager, InlineHookManager::pool_tag));
		}
		
		return __instance;
	}

	inline NTSTATUS InlineHookManager::init()
	{
		auto status = STATUS_SUCCESS;

		if (__instance == nullptr) {
			status = STATUS_UNSUCCESSFUL;
			return status;
		}

		if (__inited == true) {
			status = STATUS_SUCCESS;
			return status;/*if has inited,return success directly*/
		}

		InitializeListHead(&__head);
		KeInitializeSpinLock(&__spinlock);

		__cpu_count = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);


		__inited = true;

		return status;
	}

	inline NTSTATUS InlineHookManager::inlinehook(void* target_addr, void** hk_addr /*this value should modify in ipi or dpc callback*/
	,HookType hk_type
	)
	{
		PMDL mdl = nullptr;
		auto status = STATUS_SUCCESS;
		pIpiContext ipi_context = nullptr;
		unsigned char* modify_content = nullptr;
		void* tramp_line = nullptr;
		ULONG copy_bytes_count = 0;
		hde_inner::hde64s hde{};
		unsigned char org_bytes[cover_size]{};
		KIRQL irql{};
		pHookInfo entry = nullptr;/* if failed  clean this */

		if (target_addr == nullptr || hk_addr == nullptr || *hk_addr == nullptr) {
			return STATUS_INVALID_PARAMETER;
		}
		
		if (__inited != true) {
			status = STATUS_ACPI_NOT_INITIALIZED;
			return status;
		}
		

		do {


			//map hook addr to write 
			auto modify_buf = mapAddrByMdl(target_addr, cover_size, &mdl);
			if (modify_buf == nullptr) {
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}



			//then exallcoatepool for trampline
			tramp_line = ExAllocatePoolWithTag(NonPagedPoolExecute, PAGE_SIZE, pool_tag);
			if (tramp_line == nullptr) {
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}


			//calcuate how many bytes copied to trampline and copy to the page
			while (copy_bytes_count < cover_size) {

				auto inst_len=hde_inner::hde64_disasm(reinterpret_cast<const void*>((UINT_PTR)target_addr + copy_bytes_count), &hde);
				if (inst_len == 0) break;
				copy_bytes_count += inst_len;
			}
			if (copy_bytes_count < cover_size) {
				status = STATUS_INSTRUCTION_MISALIGNMENT;
				break;
			}


			//set modify content(copy jmp code to this)
			modify_content = reinterpret_cast<unsigned char*>(ExAllocatePoolWithTag(NonPagedPoolNx, cover_size, pool_tag));
			if (modify_content == nullptr) {
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}


			::memcpy(modify_content, __jmpcode, sizeof __jmpcode);
			*((void**)(modify_content + 6)) = *hk_addr;


			//set trampline content
			::memcpy(tramp_line, target_addr, copy_bytes_count);
			::memcpy((unsigned char*)tramp_line + copy_bytes_count, __jmpcode, sizeof __jmpcode);
			RtlFillMemoryUlonglong((unsigned char*)tramp_line + copy_bytes_count + 6, 8, (UINT_PTR)target_addr + copy_bytes_count);

			//save org bytes
			::memcpy(org_bytes, target_addr, sizeof org_bytes);

			//alloate entry
			entry = reinterpret_cast<pHookInfo>(ExAllocatePoolWithTag(NonPagedPoolNx, sizeof(HookInfo), pool_tag));
			if (entry == nullptr) {
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			
			//alloate modify_content buffer, and alloate ipi_context,then tragger ipi to sync the write
			ipi_context = reinterpret_cast<pIpiContext>(ExAllocatePoolWithTag(NonPagedPoolNx, sizeof(IpiContext), pool_tag));
			if (!ipi_context) {
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			
			ipi_context->done_cpu_count = 0;
			ipi_context->modify_buf = (unsigned char*)modify_buf;
			ipi_context->modify_size = cover_size;
			ipi_context->modify_content = modify_content;
			ipi_context->org_addr = target_addr;/*this address we should __invlpg*/
			ipi_context->hk_addr = hk_addr;
			ipi_context->tramp_line = tramp_line;

			//generate ipi or dpc
			
			if (hk_type == HookType::Dpc) {
				KeGenericCallDpc(dpcCallback, ipi_context);
			}
			else {
				KeIpiGenericCall(ipiCallback, (ULONG_PTR)(ipi_context));
			}
			
			//finally insert the entry to the list tail,there is no possible be failed
			//*hk_addr = tramp_line; this will do in dpc or ipi callback

			entry->hook_addr = target_addr;
			entry->trampline = tramp_line;
			entry->type = hk_type;

			::memcpy(&entry->originalBytes, org_bytes, sizeof org_bytes);

			KeAcquireSpinLock(&__spinlock, &irql);
			InsertTailList(&__head,&entry->links);
			KeReleaseSpinLock(&__spinlock, irql);

		} while (false);

		//clean up;


		if (mdl != nullptr) {
			unmapAddrByMdl(mdl);
		}


		if (ipi_context != nullptr) {
			ExFreePool(ipi_context);
		}

		if (modify_content != nullptr) {
			ExFreePool(modify_content);
		}

		if (!NT_SUCCESS(status)) {
			if (entry != nullptr) {
				ExFreePool(entry);
			}
			if (tramp_line != nullptr) {
				ExFreePool(tramp_line);
			}
		}


		return status;
	}

	inline NTSTATUS InlineHookManager::destory()
	{
		auto status = STATUS_SUCCESS;
		auto irql = KIRQL{};

		if (__instance == nullptr || __inited == false) {
			status = STATUS_ACPI_NOT_INITIALIZED;
			return status;
		}

		KeAcquireSpinLock(&__spinlock, &irql);

		//traverse the list and remove it
		while (!IsListEmpty(&__head)) {
			auto link = RemoveHeadList(&__head);
			pHookInfo entry = CONTAINING_RECORD(link, HookInfo, links);

			InlineHookManager::remove(entry);
		}

		KeReleaseSpinLock(&__spinlock, irql);

		//clean instance
		if (__instance) {
			ExFreePool(__instance);
			__instance = nullptr;
		}

		__inited = false;
		return status;
	}

	//
	inline NTSTATUS InlineHookManager::remove(void* target_addr)
	{
		auto status = STATUS_ENTRYPOINT_NOT_FOUND;

		if (__inited == false) {
			status = STATUS_ACPI_NOT_INITIALIZED;
			return status;
		}

		auto irql = KIRQL{};
		
		auto hook_info = getHookInfoByAddr(target_addr);


		if (hook_info) {
			KeAcquireSpinLock(&__spinlock, &irql);

			RemoveEntryList(&hook_info->links);

			KeReleaseSpinLock(&__spinlock, irql);

			remove(hook_info);

			status = STATUS_SUCCESS;
		}

		return status;
	}

	//before call this func,makesure that you have unlinked the entry from the list;
	//this is a private func,user need to use remove(void*)
	inline NTSTATUS InlineHookManager::remove(pHookInfo hook_info)
	{
		auto status = STATUS_SUCCESS;
		IpiContext* ipi_context = nullptr;
		unsigned char* modify_content = nullptr;
		PMDL mdl = nullptr;
		if (__inited == false) {
			status = STATUS_ACPI_NOT_INITIALIZED;
			return status;
		}

		if (hook_info == nullptr) {
			status = STATUS_HASH_NOT_PRESENT;
			return status;
		}

		
		do {
			//alloc memory for ipi_context 
			ipi_context = reinterpret_cast<IpiContext*>(ExAllocatePoolWithTag(NonPagedPoolNx, sizeof(IpiContext), pool_tag));

			if (ipi_context == nullptr) {
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}


			//alloc memory for moidfy_content
			modify_content = reinterpret_cast<unsigned char*>(ExAllocatePoolWithTag(NonPagedPoolNx, cover_size, pool_tag));
			if (modify_content == nullptr) {
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}
			//set modify content
			::memcpy(modify_content,hook_info->originalBytes ,cover_size);

			//map addr by mdl
			auto modify_buf = mapAddrByMdl(hook_info->hook_addr, cover_size, &mdl);
			if (modify_buf == nullptr) {
				status = STATUS_UNSUCCESSFUL;
				break;
			}

			
			//fill ipi_context and generate an ipi
			ipi_context->done_cpu_count = 0;
			ipi_context->modify_content = modify_content;
			ipi_context->modify_size = cover_size;
			ipi_context->modify_buf = (unsigned char*)modify_buf;
			ipi_context->hk_addr = nullptr;
			ipi_context->tramp_line = nullptr;

			if (hook_info->type == HookType::Dpc) {

				KeGenericCallDpc(dpcCallback, ipi_context);

			}
			else {
				KeIpiGenericCall(ipiCallback, (ULONG_PTR)ipi_context);
			}

			//do not need to unlink the entry from the list
			//clean mem in innner
			if(hook_info->trampline!=nullptr)
				ExFreePool(hook_info->trampline);

			ExFreePool(hook_info);

		} while (false);

		//clean up
		if (ipi_context != nullptr) {
			ExFreePool(ipi_context);
		}
		if (modify_content != nullptr) {
			ExFreePool(modify_content);
		}
		if (mdl != nullptr) {
			unmapAddrByMdl(mdl);
		}

		return status;
	}



	inline void* InlineHookManager::mapAddrByMdl(void* addr, size_t map_size, PMDL* mdl)
	{
		void* map_buf = nullptr;
		PMDL _mdl = nullptr;

		if (addr == nullptr || map_size == 0 || mdl == nullptr || !MmIsAddressValid(addr)) {
			//DbgPrintEx(77, 0, "[+]check error addr -> %p\r\n", addr);
			return nullptr;
		}

		do {
			//DbgPrintEx(77, 0, "[+]addr ->%p\r\n",addr);

			_mdl = IoAllocateMdl(addr, (ULONG)map_size, 0, 0, nullptr);
			if (_mdl == nullptr) break;

			__try {

				MmProbeAndLockPages(_mdl, KernelMode, IoReadAccess);
				map_buf = MmGetSystemAddressForMdlSafe(_mdl, NormalPagePriority);
			}
			__except (EXCEPTION_EXECUTE_HANDLER) {
				map_buf = nullptr;
			}

			if (map_buf == nullptr) break;

			*mdl = _mdl;
			return map_buf;

		} while (false);
		
		//if can run here,failed

		if (map_buf != nullptr) {
			MmUnlockPages(_mdl);
		}
		if (_mdl) {
			IoFreeMdl(_mdl);
		}

		return nullptr;
	}

	inline void InlineHookManager::unmapAddrByMdl(PMDL mdl)
	{
		if (mdl != nullptr) {
			MmUnlockPages(mdl);
			IoFreeMdl(mdl);
		}
	}



	inline InlineHookManager::pHookInfo InlineHookManager::getHookInfoByAddr(void* target_addr)
	{
		pHookInfo ret = nullptr;
		KIRQL irql = {};
		//acuire the spin lock
		KeAcquireSpinLock(&__spinlock, &irql);
		//traverse all the entry from list and get hookinfo by addr

		for (auto link = __head.Flink; link != &__head; link = link->Flink) {

			auto entry = CONTAINING_RECORD(link, HookInfo, links);
			if (entry->hook_addr == target_addr) {
				ret = entry;
				break;
			}
		}

		//release the spin lock
		KeReleaseSpinLock(&__spinlock, irql);


		return ret;
	}


	// cpu idx==0的进行hook,一个cpu进来+1,hook的cpu hook完之后再+1 直到所有cpu+1,==cpu count之后,函数返回
	inline ULONG_PTR InlineHookManager::ipiCallback(ULONG_PTR context)
	{
		auto cur_cpu_idx = KeGetCurrentProcessorNumberEx(0);
		auto ipi_context = reinterpret_cast<pIpiContext>(context);
		auto done_cpu_value = 0;


		//single processor
		if (__cpu_count == 1) {

			::memcpy(ipi_context->modify_buf, ipi_context->modify_content, ipi_context->modify_size);
			if (MmIsAddressValid(ipi_context->hk_addr) || ipi_context->tramp_line != nullptr) {
				*ipi_context->hk_addr = ipi_context->tramp_line;
			}

			return 0;
		}

		if (cur_cpu_idx == 0) {
			//do hook
			//wait all the processor enter
			while (InterlockedCompareExchange(&ipi_context->done_cpu_count, __cpu_count - 1, __cpu_count - 1) != (LONG)__cpu_count - 1) {
				KeStallExecutionProcessor(25);
			}
			//all the processor enter ipi callback excpet current cpu,then modify mem
			::memcpy(ipi_context->modify_buf, ipi_context->modify_content, ipi_context->modify_size);


			if (MmIsAddressValid(ipi_context->hk_addr) || ipi_context->tramp_line != nullptr) {
				*ipi_context->hk_addr = ipi_context->tramp_line;
			}

			_InlineInterlockedAdd(&ipi_context->done_cpu_count, 1);
		}
		else {
			done_cpu_value = _InlineInterlockedAdd(&ipi_context->done_cpu_count, 1);


			//wait all the processor done
			while (InterlockedCompareExchange(&ipi_context->done_cpu_count, __cpu_count, __cpu_count) != (LONG)__cpu_count) {
				KeStallExecutionProcessor(25);
			}
		}

		//invaild tlb
		__invlpg(ipi_context->org_addr);
		return 0;
	}

	inline void InlineHookManager::dpcCallback(_In_ struct _KDPC* Dpc,
			_In_opt_ PVOID DeferredContext,
			_In_opt_ PVOID SystemArgument1,
			_In_opt_ PVOID SystemArgument2)
	{
		UNREFERENCED_PARAMETER(Dpc);

		auto cur_cpu_idx = KeGetCurrentProcessorNumberEx(0);
		auto ipi_context = reinterpret_cast<pIpiContext>(DeferredContext);
		auto done_cpu_value = 0;

		
		//single processor
		if (__cpu_count == 1) {

			::memcpy(ipi_context->modify_buf, ipi_context->modify_content, ipi_context->modify_size);
			if (MmIsAddressValid(ipi_context->hk_addr) || ipi_context->tramp_line!=nullptr) {
				*ipi_context->hk_addr = ipi_context->tramp_line;
			}

			return;
		}

		if (cur_cpu_idx == 0) {
			//do hook
			//wait all the processor enter
			while (InterlockedCompareExchange(&ipi_context->done_cpu_count, __cpu_count - 1, __cpu_count - 1) != (LONG)__cpu_count - 1) {
				KeStallExecutionProcessor(25);
			}
			//all the processor enter ipi callback excpet current cpu,then modify mem
			::memcpy(ipi_context->modify_buf, ipi_context->modify_content, ipi_context->modify_size);

			
			if (MmIsAddressValid(ipi_context->hk_addr) || ipi_context->tramp_line != nullptr) {
				*ipi_context->hk_addr = ipi_context->tramp_line;
			}

			_InlineInterlockedAdd(&ipi_context->done_cpu_count, 1);
		}
		else {
			done_cpu_value = _InlineInterlockedAdd(&ipi_context->done_cpu_count, 1);

			
			//wait all the processor done
			while (InterlockedCompareExchange(&ipi_context->done_cpu_count, __cpu_count, __cpu_count) != (LONG)__cpu_count) {
				KeStallExecutionProcessor(25);
			}
		}

		//invaild tlb
		__invlpg(ipi_context->org_addr);

		KeSignalCallDpcSynchronize(SystemArgument2);
		KeSignalCallDpcDone(SystemArgument1);

	}


	inline DrvObjHookManager* DrvObjHookManager::getInstance()
	{
		if (__instance == nullptr) {
			__instance = reinterpret_cast<DrvObjHookManager*>(ExAllocatePoolWithTag(NonPagedPoolNx, sizeof DrvObjHookManager, pool_tag));
			if (__instance) {

				KeInitializeSpinLock(&__lock);
				InitializeListHead(&__head);
				__inited = true;
			}
		}
		return __instance;
	}

	inline NTSTATUS DrvObjHookManager::addDrvObjHook(void* img_base, 
		NTSTATUS(*drventry_callback)(PDRIVER_OBJECT, PUNICODE_STRING, void* context), 
		void(*drvunload_callback)(PDRIVER_OBJECT, void* context), 
		void* entry_context,
		void* unload_context
	)
	{
		auto mdl = PMDL{};
		DrvObjInfo* entry = nullptr;
		auto status = STATUS_SUCCESS;
		auto irql = KIRQL{};

		if (img_base == nullptr || drventry_callback==nullptr || drvunload_callback==nullptr || __instance==nullptr) {
			status = STATUS_UNSUCCESSFUL;
			return status;
		}


		do {
			//alloate memory
			entry = reinterpret_cast<DrvObjInfo*>(ExAllocatePoolWithTag(NonPagedPoolNx, sizeof DrvObjInfo, pool_tag));
			if (!entry) {
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}
			memset(entry, 0, sizeof DrvObjInfo);

			unsigned char jmp_code[14] = { 0xff,0x25,0,0,0,0 };
			//hook driver entry and save org_bytes
			auto modify_buf = mapAddrByMdl(getEntryPoint(img_base), sizeof jmp_code, &mdl);
			if (!modify_buf) {
				status = STATUS_MAPPED_FILE_SIZE_ZERO;
				break;
			}

			memcpy(entry->org_bytes, getEntryPoint(img_base), sizeof entry->org_bytes);
			*reinterpret_cast<UINT64*>(jmp_code + 6) = (UINT64)defaultDrvEntry;
			memcpy(modify_buf, jmp_code, sizeof jmp_code);//hook

			//insert it to list
			entry->base = img_base;
			entry->drventry_callback = drventry_callback;
			entry->drvunload_callback = drvunload_callback;
			entry->unload_context = unload_context;
			entry->entry_context = entry_context;
			entry->entry_point = getEntryPoint(img_base);

			KeAcquireSpinLock(&__lock, &irql);

			InsertTailList(&__head, &entry->links);

			KeReleaseSpinLock(&__lock, irql);

		} while (0);

		//clean up
		if (mdl != nullptr) {
			unmapAddrByMdl(mdl);
		}

		if (!NT_SUCCESS(status)) {
			if(entry!=nullptr)
				ExFreePool(entry);
		}

		return status;
	}

	inline void DrvObjHookManager::removeDrvObjHook(void* img_base)
	{
		KIRQL irql = {};
		
		auto drvobj_info = findDrvInfoByBase(img_base);
		if (drvobj_info != nullptr) {
			KeAcquireSpinLock(&__lock, &irql);

			//must resume unload hook at driver does not unload
			if(!drvobj_info->is_exit)
				drvobj_info->drv->DriverUnload = drvobj_info->org_unload;
			 
			RemoveEntryList(&drvobj_info->links);

			KeReleaseSpinLock(&__lock, irql);

			ExFreePool(drvobj_info);
		}
	}


	inline void DrvObjHookManager::destory()
	{
		KIRQL irql = {};

		if (__instance && MmIsAddressValid(__instance)) {
			ExFreePool(__instance);
			
			KeAcquireSpinLock(&__lock, &irql);
			while (!IsListEmpty(&__head)) {

				auto link = RemoveEntryList(&__head);
				auto entry = CONTAINING_RECORD(link,DrvObjInfo, links);

				entry->drv->DriverUnload = entry->org_unload;
				ExFreePool(entry);
			}
			KeReleaseSpinLock(&__lock, irql);

			__inited = false;
			__instance = nullptr;
		}
	}

	inline void* DrvObjHookManager::getEntryPoint(void* img)
	{
		void* ret = nullptr;

		do {

			if (img == nullptr) break;

			auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(img);

			if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) break;

			auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>((UINT64)(img)+dos_header->e_lfanew);

			if (nt_headers->Signature != IMAGE_NT_SIGNATURE) break;

			ret = reinterpret_cast<void*>((UINT64)img + nt_headers->OptionalHeader.AddressOfEntryPoint);

		} while (0);

		return ret;
	}

	inline void* DrvObjHookManager::mapAddrByMdl(void* addr, size_t map_size, PMDL* mdl)
	{
		void* map_buf = nullptr;
		PMDL _mdl = nullptr;

		if (addr == nullptr || map_size == 0 || mdl == nullptr || !MmIsAddressValid(addr)) {
			return nullptr;
		}

		do {

			_mdl = IoAllocateMdl(addr, (ULONG)map_size, 0, 0, nullptr);
			if (_mdl == nullptr) break;

			__try {

				MmProbeAndLockPages(_mdl, KernelMode, IoReadAccess);
				map_buf = MmGetSystemAddressForMdlSafe(_mdl, NormalPagePriority);
			}
			__except (EXCEPTION_EXECUTE_HANDLER) {
				map_buf = nullptr;
			}

			if (map_buf == nullptr) break;

			*mdl = _mdl;
			return map_buf;

		} while (false);

		//if can run here,failed

		if (map_buf != nullptr) {
			MmUnlockPages(_mdl);
		}
		if (_mdl) {
			IoFreeMdl(_mdl);
		}

		return nullptr;
	}

	inline void DrvObjHookManager::unmapAddrByMdl(PMDL mdl)
	{
		if (mdl != nullptr) {
			MmUnlockPages(mdl);
			IoFreeMdl(mdl);
		}
	}

	inline DrvObjHookManager::DrvObjInfo* DrvObjHookManager::findDrvInfoByBase(void* img_base)
	{
		KIRQL irql = {  };
		DrvObjInfo* ret = nullptr;

		KeAcquireSpinLock(&__lock, &irql);
		
		for (auto link=__head.Flink;link!=&__head;link=link->Flink) {
			auto entry = CONTAINING_RECORD(link, DrvObjInfo, links);

			if (entry->base == img_base) {
				ret = entry;
				break;
			}
		}

		KeReleaseSpinLock(&__lock, irql);

		return ret;
	}

	inline NTSTATUS DrvObjHookManager::defaultDrvEntry(PDRIVER_OBJECT drv, PUNICODE_STRING u)
	{
		auto status = STATUS_SUCCESS;
		auto mdl = PMDL{};
		auto drvobj_info = findDrvInfoByBase(drv->DriverStart);

		if (drvobj_info == nullptr) {
			//fatal error
			return STATUS_UNSUCCESSFUL;
		}

		drvobj_info->drv = drv;

		do {

			//then resume hook bytes
			auto modify_buf = mapAddrByMdl(drvobj_info->entry_point, sizeof drvobj_info->org_bytes, &mdl);
			if (modify_buf == nullptr) {
				status = STATUS_MAPPED_FILE_SIZE_ZERO;
				break;
			}
			memcpy(modify_buf,drvobj_info->org_bytes ,sizeof drvobj_info->org_bytes);

			//call hook func
			status=drvobj_info->drventry_callback(drv, u, drvobj_info->entry_context);
			if (!NT_SUCCESS(status)) break;

			//call org func
			auto org_entry = reinterpret_cast<NTSTATUS(*)(PDRIVER_OBJECT, PUNICODE_STRING)>(drvobj_info->entry_point);
			status = org_entry(drv,u);
			if (!NT_SUCCESS(status)) {
				break;
			}


			//then hook driver unload and save org driver unload
			drvobj_info->org_unload = drv->DriverUnload;
			drv->DriverUnload = defaultDrvUnload;

		} while (0);


		//clean up
		if (mdl != nullptr) {
			unmapAddrByMdl(mdl);
		}

		//the driver will exit so clean entry from list
		if (!NT_SUCCESS(status)) {

			defaultDrvUnload(drv);

		}

		return status;
	}

	inline void DrvObjHookManager::defaultDrvUnload(PDRIVER_OBJECT drv)
	{
		auto drvobj_info = findDrvInfoByBase(drv->DriverStart);
		if (!drvobj_info) {
			//fatal error
			return;
		}

		//call hook driver unload
		drvobj_info->drvunload_callback(drv, drvobj_info->unload_context);

		drvobj_info->is_exit = true;

		auto org_unload = drvobj_info->org_unload;
		//clean this entry from list
		removeDrvObjHook(drvobj_info->base);

		//call org driver unload
		//if org_unload==nullptr maybe the driverentry return value is not success
		//so we should check the org_unload
		if(org_unload!=nullptr)
			org_unload(drv);
	}



#pragma warning(default : 4996)
}



```

`etw_hook/include/kstl/kioctl.hpp`:

```hpp
#pragma once
#include <fltKernel.h>
namespace kstd {


}
```

`etw_hook/include/kstl/klist.hpp`:

```hpp
#pragma once
#include <fltKernel.h>

/// <summary>
/// author :oxygen
/// 这个是线程安全的  必须先初始化
/// this is thread-safty list,but must init first
/// </summary>




namespace kstd {

	//有些东西必须自己实现,加个命名空间,不影响其他使用
	namespace list_inner {
		template<typename T, typename U>
		struct is_same {
			static constexpr bool value = false;
		};

		template<typename T>
		struct is_same<T, T> {
			static constexpr bool value = true;
		};

		template<typename T, typename U>
		constexpr bool is_same_v = is_same<T, U>::value;


	}

#define MUSTADDED 		void operator delete(void* p, size_t s) { \
	p,s; \
	KeBugCheckEx(1, 1, 1, 1, 1); \
	} \

#define POOL_TAG 'klst'
		enum class InsertType {
			head,
			tail
		};

		template<typename T>
		class Klist {
		private:
			class iterator {
			public:
				iterator(T* ptr,void* listHead) :__node(ptr), __listhead(listHead){}
				T& operator*() const { return *__node; }
				T* operator->() const { return __node; }
				iterator& operator++() {
					
					if (__node != nullptr) {

						auto tmp = __node->link.Flink;
						if (tmp == __listhead) {
							__node = nullptr;
						}
						else {
							__node = CONTAINING_RECORD(tmp, T, link);
						}
					}
			
					return *this;
				}
				bool operator==(const iterator& other)const { return other.__node == this->__node; }
				bool operator!=(const iterator& other)const { return other.__node != this->__node; }
			private:
				T* __node;
				void* __listhead;
			};
		public:
			void init();
			template<typename DestoryFunc>
			void destory(DestoryFunc func=nullptr);
			bool insert(const T& target,InsertType type);
			bool insert(T&& target, InsertType type);

			template<typename CompareFunc>
			T* find(const T& target,CompareFunc func);

			template<typename CompareFunc>
			void remove(const T& target, CompareFunc func);

			//从设计上 是不支持拷贝构造的 如果真的需要 以后再加 只不过以后需要大改
			Klist& operator=(const Klist& rhs)=delete;
			Klist(const Klist& rhs) = delete;

			//从设计上 是不支持移动语义的
			Klist& operator=(Klist&& rhs) = delete;
			Klist(Klist&& rhs) = delete;

			Klist() = default;
			ULONG size() const { return __size; }
			iterator begin();
			iterator end();
		private:
			LIST_ENTRY __listHead;
			KSPIN_LOCK __spinLock;
			ULONG __size;
			bool __inited;
		private:
			T&& move(T& v) const { return static_cast<T&&>(v); }
#pragma warning(disable : 4996)
			T* _alloc()const { 
				auto ret= (T*)ExAllocatePoolWithTag(NonPagedPool, sizeof(T), POOL_TAG);
				if (ret) memset(ret, 0, sizeof(T));
				return ret;
			};
#pragma warning(default : 4996)
			void _free(T* buf) const { ExFreePool(buf); };
		};


		template<typename T>
		inline void Klist<T>::init()
		{
			__inited = true;
			__size = 0;
			InitializeListHead(&__listHead);
			KeInitializeSpinLock(&__spinLock);
		}

		//移动语义支持
		template<typename T>
		inline bool Klist<T>::insert(T&& target, InsertType type) {
			
			auto ret = true;
			auto irql = KIRQL{};
			do {
				auto node = _alloc();
				if (node == nullptr) {
					ret = false;
					break;
				}

				*node = move(target);
				KeAcquireSpinLock(&__spinLock, &irql);
				switch (type)
				{
				case kstd::InsertType::head:
					InsertHeadList(&this->__listHead, &node->link);
					break;
				case kstd::InsertType::tail:
					InsertTailList(&this->__listHead, &node->link);
					break;
				default:
					ret = false;
					break;

				}
				KeReleaseSpinLock(&__spinLock, irql);
			} while (false);
			if (ret) __size++;

			return ret;
		}

		template<typename T>
		inline bool Klist<T>::insert(const T& target, InsertType type)
		{
			auto ret = true;
			auto irql = KIRQL{};
			do {
				auto node = _alloc();
				if (node == nullptr) {
					ret = false;
					break;
				}
				*node = target;
				KeAcquireSpinLock(&__spinLock,&irql);
				switch (type)
				{
				case kstd::InsertType::head:
					InsertHeadList(&this->__listHead, &node->link);
					break;
				case kstd::InsertType::tail:
					InsertTailList(&this->__listHead, &node->link);
					break;
				default:
					ret = false;
					break;

				}
				KeReleaseSpinLock(&__spinLock, irql);
			} while (false);
			if (ret) __size++;

			return ret;
		}


		template<typename T>
		inline typename Klist<T>::iterator Klist<T>::begin()
		{
			auto entry = CONTAINING_RECORD(&__listHead.Flink, T, link);

			return iterator(entry,(void*)&__listHead);
		}

		template<typename T>
		inline typename Klist<T>::iterator Klist<T>::end()
		{
			return iterator(nullptr,(void*)&__listHead);
		}



		template<typename T>
		template<typename DestoryFunc>
		inline void Klist<T>::destory(DestoryFunc func)
		{
			using namespace list_inner;

			auto irql = KIRQL{};
			KeAcquireSpinLock(&__spinLock, &irql);
			while (!IsListEmpty(&__listHead)) {

				auto head = RemoveHeadList(&__listHead);
				auto entry = CONTAINING_RECORD(head, T, link);
			
				if constexpr (list_inner::is_same_v<DestoryFunc, std::nullptr_t>) {
					//注意 msvc编译器如果显示调用析构函数，实际上是调用的
					entry->~T();
				}
				else {
					func(entry);
				}

				_free(entry);
			}
			KeReleaseSpinLock(&__spinLock, irql);
		}

		template<typename T>
		template<typename CompareFunc>
		inline T* Klist<T>::find(const T& compare, CompareFunc func)
		{
			T* ret=nullptr;
			auto irql = KIRQL{};

			KeAcquireSpinLock(&__spinLock, &irql);
			for (auto i=__listHead.Flink;i!=&__listHead;i=i->Flink) {
				auto entry = CONTAINING_RECORD(i, T, link/*必须具有这个字段 而且还得是LIST_ENTRY*/);
				if (func(compare,*entry)==true) {
					//find
					ret = entry;
					break;
				}

			}
			KeReleaseSpinLock(&__spinLock, irql);
			//not find
			return ret;
		}

		template<typename T>
		template<typename CompareFunc>
		inline void Klist<T>::remove(const T& target, CompareFunc func)
		{
			using namespace list_inner;

			auto f = find(target, func);
			if (f == nullptr) return;

			RemoveEntryList(&f->link);
			f->~T();/*调用析构函数*/
			_free(f);
			__size--;
			

			return;
		}

}
/// <summary>
/// author :oxygen
/// </summary>
```

`etw_hook/include/kstl/klog.hpp`:

```hpp
#pragma once
#ifndef _KLOG_H_
#define  _KLOG_H_

//a very simple log lib
//author:oxygen

#include <fltKernel.h>
#include <ntstrsafe.h>
#pragma prefast(disable : 30030)
#pragma warning(disable: 4996)

namespace kstd {

	//只LOG到内核DebugPrint
#define LOG_DEBUG(format,...) \
	kstd::Logger::logPrint(kstd::Logger::LogLevel::Debug,__FUNCTION__,format,__VA_ARGS__)
#define LOG_INFO(format,...) \
	kstd::Logger::logPrint(kstd::Logger::LogLevel::Info,__FUNCTION__,format,__VA_ARGS__)
#define LOG_ERROR(format,...) \
	kstd::Logger::logPrint(kstd::Logger::LogLevel::Error,__FUNCTION__,format,__VA_ARGS__)

	//可以记录到文件
#define FLOG_INFO(format,...) \
	kstd::Logger::logPrint((kstd::Logger::LogLevel)(kstd::Logger::LogLevel::Info | kstd::Logger::LogLevel::ToFile),__FUNCTION__,format,__VA_ARGS__)
#define FLOG_DEBUG(format,...) \
	kstd::Logger::logPrint((kstd::Logger::LogLevel)(kstd::Logger::LogLevel::Debug | kstd::Logger::LogLevel::ToFile),__FUNCTION__,format,__VA_ARGS__)
#define FLOG_ERROR(format,...) \
	kstd::Logger::logPrint((kstd::Logger::LogLevel)(kstd::Logger::LogLevel::Error | kstd::Logger::LogLevel::ToFile),__FUNCTION__,format,__VA_ARGS__)
	
	//只记录到文件	
#define FLOG(format,...) \
	kstd::Logger::logPrint((kstd::Logger::LogLevel)(kstd::Logger::LogLevel::ToFile),__FUNCTION__,format,__VA_ARGS__)


	class Logger {
	public:
		enum LogLevel {
			Debug=1,
			Info=2,
			Error=4,
			ToFile=8,/*写到文件中*/
		};
	public:
		static void init(const char* info, const wchar_t* log_file_name);
		static void destory();
		static NTSTATUS logPrint(LogLevel log_level, const char* function_name,const char* format, ...);
		static void getCurSystemTime(char* buf, size_t size);
	private:
		inline static char __info[100];
		inline static HANDLE __hfile;
		inline static ULONG __offset;
	};

	inline void Logger::init(const char* info,const wchar_t* nt_log_file_path/*nt path,不要是dos path*/)
	{
		auto oa = OBJECT_ATTRIBUTES{};
		auto isb = IO_STATUS_BLOCK{};
		auto u_path = UNICODE_STRING{};

		RtlInitUnicodeString(&u_path, nt_log_file_path);
		InitializeObjectAttributes(&oa, &u_path, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, 0, 0);

		memcpy_s(__info, sizeof __info,info,strlen(info)+1);
		

		ZwCreateFile(&__hfile, GENERIC_WRITE, &oa, &isb, nullptr, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF, 0, 0, 0);

	}

	inline void Logger::destory()
	{
		if (__hfile) {
			ZwClose(__hfile);
			__hfile = nullptr;
		}
	}

	NTSTATUS inline Logger::logPrint(LogLevel log_level, const char* function_name, const char* format, ...)
	{
		auto status = STATUS_SUCCESS;
		char log_message[412]{};
		char time[100]{};
		va_list args{};
		va_start(args, format);

		status = RtlStringCchVPrintfA(log_message, sizeof log_message, format, args);

		va_end(args);

		getCurSystemTime(time, sizeof time);

		char full_log_message[512] = {};
		RtlStringCchPrintfA(full_log_message, sizeof full_log_message, "%s\t[tid %d]\t[%s]\t", time, PsGetCurrentThreadId(), __info);

		if (NT_SUCCESS(status)) {
			if (log_level & LogLevel::Debug) {
				RtlStringCchCatA(full_log_message, sizeof full_log_message, "[debug]\tfunction name:\t");
				RtlStringCchCatA(full_log_message, sizeof full_log_message, function_name);
				RtlStringCchCatA(full_log_message, sizeof full_log_message, "\t");
			}
			else if (log_level & LogLevel::Error) {
				RtlStringCchCatA(full_log_message, sizeof full_log_message, "[error]\t");
			}
			else if (log_level & LogLevel::Info) {
				RtlStringCchCatA(full_log_message, sizeof full_log_message, "[Info]\t");
			}

			RtlStringCchCatA(full_log_message, sizeof full_log_message, log_message);

			if (log_level & LogLevel::ToFile && KeGetCurrentIrql()==PASSIVE_LEVEL) {
				IO_STATUS_BLOCK ioStatusBlock;
				LARGE_INTEGER offset;
				offset.QuadPart = __offset;

				ANSI_STRING logAnsiStr;
				RtlInitAnsiString(&logAnsiStr, full_log_message);

				UNICODE_STRING logUnicodeStr;
				RtlAnsiStringToUnicodeString(&logUnicodeStr, &logAnsiStr, TRUE);

				status = ZwWriteFile(__hfile, NULL, NULL, NULL, &ioStatusBlock, logUnicodeStr.Buffer, logUnicodeStr.Length, &offset, NULL);
				if (NT_SUCCESS(status)) {
					__offset += (ULONG)logUnicodeStr.Length;
				}

				RtlFreeUnicodeString(&logUnicodeStr);
			}

			DbgPrintEx(77, 0, full_log_message);
		}

		return status;
	}

	inline void Logger::getCurSystemTime(char* buf, size_t size)
	{
		LARGE_INTEGER sys_time{}, loacal_time{};
		TIME_FIELDS time_fields{};

		KeQuerySystemTime(&sys_time.QuadPart);
		ExSystemTimeToLocalTime(&sys_time, &loacal_time);
		RtlTimeToTimeFields(&loacal_time, &time_fields);
		sprintf_s(buf, size, "[%4d-%2d-%2d %2d:%2d:%2d.%3d]", time_fields.Year, time_fields.Month, time_fields.Day,
			time_fields.Hour, time_fields.Minute, time_fields.Second, time_fields.Milliseconds);

	}



}

#pragma warning(default : 4996)

#endif // !_KLOG_H_



```

`etw_hook/include/kstl/kmemory.hpp`:

```hpp
#pragma once
#include <fltKernel.h>

/// <summary>
/// 实现类似stl的<memory> 多了个自己实现的kstd::move 用于移动语义!!
/// </summary>
namespace kstd {
#pragma warning(disable : 4996)
	static constexpr unsigned long km_pool_tag = 'Uptr';

	template<typename T>
	T&& move(T& v) {
		return static_cast<T&&>(v);
	}


	/*在这个里面自己实现new 和 delete 但是不是全局的 所以造成的缺点就是无法new 数组?*/
	namespace inner{
		template<typename T,typename... Args>
		T* __new(Args&&... args) {
			auto p = reinterpret_cast<T*>(ExAllocatePoolWithTag(NonPagedPool, sizeof(T), km_pool_tag));
			if (p != nullptr) {
				*p =T(args...);/*这个本身就是将亡值 因此自动触发移动语义?*/
			}
			return p;
		}

		template<typename T>
		void __delete(T* p)
		{
			if (p != nullptr) {
				ExFreePool(p);
			}
		}
	}

	template<typename T>
	struct DefaultDeleter {
		void operator() (T* p) {
			inner::__delete(p);
		}
	};

	template<class T, class Deleter = DefaultDeleter<T>>
	struct unique_ptr {


	public:
		unique_ptr() : __p(nullptr) {}

		unique_ptr(T* p) :__p(p) {}

		unique_ptr(const unique_ptr& rhs) = delete;/*普通的拷贝构造必须删除*/
		unique_ptr& operator= (const unique_ptr& rhs) = delete;

		//移动构造
		unique_ptr(unique_ptr&& rhs) {
			if (&rhs != this) {
				if (__p) {
					reset();/*先重置掉原先有的*/
				}
				this->__p = rhs.release();
			}
		}

		//移动复制
		unique_ptr& operator=  (unique_ptr&& rhs) {
			if (&rhs != this) {
				if (__p) {
					reset();/*先重置掉原先有的*/
				}
				this->__p = rhs.release();
			}

			return *this;
		}

		//DTOR
		~unique_ptr() {
			if (__p)
				Deleter{}(__p);
		}

		/*获取当前存储的资源*/
		T* get() const { return __p; }

		/*转移当前存储的资源*/
		T* release() {
			auto tmp = __p;
			__p = nullptr;
			return tmp;
		}

		/*释放当前存储的资源*/
		void reset(T* p = nullptr) {
			if (__p)
				Deleter{}(__p);
			__p = p;
		}

		//重载-> 和 * 描述符 这是每个智能智能必备的
		T& operator*() const {
			return *__p;
		}

		T* operator-> () const {
			return __p;
		}

	private:
		T* __p;
	};


	//make unique_ptr 也是必备的
	template<typename T, typename... Args>
	unique_ptr<T> make_unique(Args&&... args) {
		return unique_ptr<T>(inner::__new<T>(args...));
	}

#pragma warning(default : 4996)
}
```

`etw_hook/include/kstl/kpe_parse.hpp`:

```hpp
#pragma once
#ifndef _KPE_PARSE_
#define _KPE_PARSE_

#include <fltKernel.h>
#include <ntstrsafe.h>
#include <ntimage.h>
//author oxygen & hambaga
/*用于解析存储在磁盘上的文件或者是已经在内存中的文件*/
/*提供
1.枚举导出表 √
2.枚举导入表 √
3.枚举签名信息 ×
4.枚举函数异常表 √
5.枚举这个PE文件起始地址 √
6.rva to va √
7.va to rva √
8.map to memory(拉伸PE并且修复)√
9.get sections √
10.get entry point √
11.pattern find in pe √
*/
namespace kstd {


	//注意 很多函数只支持x64！
	//提供最基础的函数  给其他东西继承
	//注意 这个类函数一定只能使用内存 不能使用路径和句柄
	//目前不知道是否拉伸了PE和不拉伸有无区别? 其实是有区别的,这里只针对拉伸过的(拉伸过的是指对各节区拉伸,不然还得rav to foa foa to rva)
	//但是各个数据目录表用的都是rva 所以得拉伸
	//所有这个类的所有成员函数的第一个成员base都是拉伸到内存的PE文件
	class PeParseBaisc {
	public:
		enum class OperType {
			r0,
			r3
		};

		typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
			DWORD32 BeginAddress;
			DWORD32 EndAddress;
			union {
				DWORD32 UnwindInfoAddress;
				DWORD32 UnwindData;
			} DUMMYUNIONNAME;

		} RUNTIME_FUNCTION, * PRUNTIME_FUNCTION, _IMAGE_RUNTIME_FUNCTION_ENTRY, * _PIMAGE_RUNTIME_FUNCTION_ENTRY;
	public:
		//和R3的GetProcAddres一样
		UINT_PTR getProcAddress(void* module_base,char* func_name,bool is_ordinal);

	public:

		//枚举该PE文件的所有IAT
		NTSTATUS enumrateIat(
			void* base, 
			void(*callback)(UINT_PTR* iat, UINT_PTR* _int, char* dllname, bool is_ordinal, char* func_name, void* context), 
			void* context
		);

		//枚举PE文件的函数起始地址和结束地址 通过异常表枚举
		NTSTATUS enumrateFuncs(void* base, void(*callback)(ULONG start_rva, ULONG end_rva, void* context), void* context);

		//枚举PE文件的导出表
		NTSTATUS enumrateExportTable(void* base, void(*callback)(char* name,
			int index,/*这个是name在nametable的顺序,需要通过ordtable转换成funtable的位置*/
			PSHORT ord_table ,
			PULONG func_table,
			void* context), void* context);

		//枚举PE文件的异常表
		NTSTATUS enumrateExceptionTable(void* base, void(*callback)(PRUNTIME_FUNCTION runtime_func,void* context), void* context);

		//base是拉伸之后的
		ULONG rva2foa(void* base, ULONG rva);
		ULONG foa2rva(void* base,ULONG foa);

		//base是经过拉伸之后的
		NTSTATUS mapToMemory(void* base, void* map_addr, size_t map_size,OperType map_type=OperType::r0);


		PIMAGE_SECTION_HEADER getSections(void* base,ULONG* size_of_sections=nullptr);
		
		ULONG getEntryPointRva(void* base);

		//在内核获取PE文件的签名信息 未实现
		char* getIssuerName(void* base);
		char* getSubjectName(void* base);

		//模式匹配 
		//pattern k_utils::find_pattern_image(ntoskrnl, "\x00\x00\x2c\x08\x04\x38\x0c", "??xxxxx", ".text");
		UINT_PTR patternFind(unsigned long long addr, unsigned long size, const char* pattern, const char* mask);

		UINT_PTR patternFindSections(unsigned long long base, const char* pattern, const char* mask, const char* name);

		bool isValidX64PE(char* base);
	private:
		static const DWORD X64 = 0x8664;
		bool patternCheck(const char* data, const char* pattern, const char* mask);

		void* getModuleBase(char* module_name, OperType type = OperType::r0,ULONG* size=nullptr);

		static void reloc(void* base);
	
	public:
	};


	inline NTSTATUS PeParseBaisc::enumrateExceptionTable(
		void* base, 
		void(*callback)(PeParseBaisc::PRUNTIME_FUNCTION runtime_func, void* context),
		void* context)
	{
		if (!isValidX64PE((char*)base)) return STATUS_INVALID_PARAMETER;

		auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(base);
		auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>((UINT_PTR)base + dos_header->e_lfanew);
		auto opt_header = nt_headers->OptionalHeader;
		auto datadir = opt_header.DataDirectory;
		if (datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size == 0) return STATUS_SUCCESS;

		auto exception_table= reinterpret_cast<_IMAGE_RUNTIME_FUNCTION_ENTRY*>((UINT_PTR)base + datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress);
		
		//开始遍历
		for (auto table = exception_table;
			(uintptr_t)table < (uintptr_t)exception_table + datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size
			; table++) {

			callback(table, context);

		}

		return STATUS_SUCCESS;
	}

	inline ULONG PeParseBaisc::rva2foa(void* base, ULONG rva)
	{
		auto foa = 0ul;
		auto count_sections = 0ul;
		auto sections = getSections(base,&count_sections);
		if (sections == nullptr) return foa;

		for (auto i=0ul;i<count_sections;i++) {
			auto sec = sections[i];

			if (rva >= sec.VirtualAddress || rva <= sec.VirtualAddress + sec.Misc.VirtualSize) {
				//find
				foa = rva - sec.VirtualAddress + sec.PointerToRawData;
				break;
			}

		}

		return foa;
	}

	inline ULONG PeParseBaisc::foa2rva(void* base, ULONG foa)
	{
		auto rva = 0ul;
		auto count_sections = 0ul;
		auto sections = getSections(base, &count_sections);
		if (sections == nullptr) return rva;

		for (auto i = 0ul; i < count_sections; i++) {
			auto sec = sections[i];

			if (foa >= sec.PointerToRawData || foa <= sec.PointerToRawData + sec.SizeOfRawData) {

				rva = foa - sec.PointerToRawData + sec.VirtualAddress;
				break;
			}
		}

		return rva;
	}

	//必须是已经拉伸过的!
	inline NTSTATUS PeParseBaisc::mapToMemory(void* base, void* map_addr, size_t map_size, OperType map_type)
	{
		//判断是不是有效的重定位表项
#define RELOC_FLAG64(RelInfo) ((RelInfo >> 0x0C) == IMAGE_REL_BASED_DIR64)
#define RELOC_FLAG RELOC_FLAG64

		auto status = STATUS_SUCCESS;
		if (map_type == OperType::r3) {
			status = STATUS_NOT_SUPPORTED;
			return status;
		}

		if (!isValidX64PE((char*)base) || !MmIsAddressValid(map_addr)) {
			status = STATUS_INVALID_PARAMETER;
			return status;
		}
		
		//复制这块内存到map_addr
		memcpy(map_addr, base, map_size);
		//开始修复iat

		struct Input_t {
			PeParseBaisc* _this;
			PeParseBaisc::OperType type;
		};

		auto input = Input_t{ this,map_type };

		if (!NT_SUCCESS(
			enumrateIat(
				map_addr,
				[](UINT_PTR* iat, UINT_PTR* _int, char* dllname, bool is_ordinal, char* func_name, void* context) {
					UNREFERENCED_PARAMETER(_int);
					auto input = reinterpret_cast<Input_t*>(context);

					//*iat = getProcAddress();
					auto dll_base = input->_this->getModuleBase(dllname, input->type);
					if (MmIsAddressValid(iat)) {
						*iat = input->_this->getProcAddress(dll_base, func_name, is_ordinal);
					}
				},
				&input
			)
		)) {
			//failed
			return STATUS_UNSUCCESSFUL;
		}

		reloc(map_addr);
		return status;
	}

	inline UINT_PTR PeParseBaisc::getProcAddress(void* module_base, char* func_name, bool is_ordinal)
	{
		if (!MmIsAddressValid((void*)func_name) && !is_ordinal) return 0;

		if (!isValidX64PE((char*)module_base)) return 0;

		struct Input_t {
			char* func_name;
			bool is_ordinal;
			void* module_base;
			UINT_PTR find_addr;
		};

		auto input = Input_t{ func_name,is_ordinal,module_base,0 };
		//调用函数遍历export
		enumrateExportTable(module_base,
		[](char* name, int index, PSHORT ord_table, PULONG func_table, void* context){
			auto input = reinterpret_cast<Input_t*>(context);
			if (!input->is_ordinal) {

				if (strcmp(name,input->func_name) != 0) return;
				//find
				input->find_addr= func_table[ord_table[index]]+(UINT_PTR)input->module_base;
				return;
			}
			else {

				auto ord = (unsigned long long)(input->func_name)-1;
				input->find_addr = func_table[ord] + (UINT_PTR)input->module_base;

			}
		},
		(void*)&input//context
		);


		return input.find_addr;
	}

	//sync function
	inline NTSTATUS PeParseBaisc::enumrateIat(
		void* base, 
		void(*callback)(UINT_PTR* iat, UINT_PTR* _int, char* dllname, bool is_ordinal,char* func_name, void* context), 
		void* context
	) {
		if(!isValidX64PE((char*)base)) return STATUS_INVALID_PARAMETER;

		auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(base);
		auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>((UINT_PTR)base+dos_header->e_lfanew);
		auto opt_header = nt_headers->OptionalHeader;
		auto datadir=opt_header.DataDirectory;
		if (datadir[IMAGE_DIRECTORY_ENTRY_IMPORT].Size == 0) return STATUS_SUCCESS;

		auto import_descr = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>((UINT_PTR)base+datadir[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
		

		while (import_descr->Name) {

			auto iat = reinterpret_cast<ULONG_PTR*>(import_descr->FirstThunk + (UINT_PTR)(base));
			auto _int = reinterpret_cast<ULONG_PTR*>(import_descr->OriginalFirstThunk + (UINT_PTR)(base));
			if (_int == nullptr) _int = iat;

			for (; *iat; ++iat, ++_int) {


				if (IMAGE_SNAP_BY_ORDINAL(*_int)) {
					callback(iat, _int, (char*)((UINT_PTR)base + import_descr->Name), true, (char*)*_int, context);

				}
				else {
					callback(iat, _int, (char*)((UINT_PTR)base + import_descr->Name), false, 
						((IMAGE_IMPORT_BY_NAME*)((UINT_PTR)base + *_int))->Name,
						context);
				}

			}

			import_descr++;
		}

		return STATUS_SUCCESS;
	}

	inline NTSTATUS PeParseBaisc::enumrateFuncs(void* base, void(*callback)(ULONG start_rva,ULONG end_rva, void* context), void* context)
	{
		if (!isValidX64PE((char*)base)) return STATUS_INVALID_PARAMETER;

		auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(base);
		auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>((UINT_PTR)base + dos_header->e_lfanew);
		auto opt_header = nt_headers->OptionalHeader;
		auto datadir = opt_header.DataDirectory;
		if (datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size == 0) return STATUS_SUCCESS;

		auto exception_table = reinterpret_cast<_IMAGE_RUNTIME_FUNCTION_ENTRY*>((UINT_PTR)base + datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress);

		//开始遍历
		for (auto table = exception_table;
			(uintptr_t)table < (uintptr_t)exception_table + datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size
			; table++) {

			callback(table->BeginAddress,table->EndAddress,context);

		}

		return STATUS_SUCCESS;
	}

	inline NTSTATUS PeParseBaisc::enumrateExportTable(void* base, void(*callback)(char* name, int index, PSHORT ord_table, PULONG func_table, void* context), void* context)
	{
		if (!isValidX64PE((char*)base)) return STATUS_INVALID_PARAMETER;

		auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(base);
		auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>((UINT_PTR)base + dos_header->e_lfanew);
		auto opt_header = nt_headers->OptionalHeader;
		auto datadir = opt_header.DataDirectory;

		if (datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0) return STATUS_SUCCESS;

		auto export_table = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>((UINT_PTR)base + datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

		//nameTable存的是函数名的RVA
		auto name_table = (PULONG)(export_table->AddressOfNames + (PUCHAR)base);
		//索引到funcTable索引转换需要这个
		auto ordinal_table = (PSHORT)(export_table->AddressOfNameOrdinals + (PUCHAR)base);
		auto func_table = (PULONG)(export_table->AddressOfFunctions + (PUCHAR)base);


		for (unsigned i=0;i<export_table->NumberOfNames;i++) {
			auto name = (char*)(name_table[i] + (ULONG_PTR)base);
			callback(name, i, ordinal_table, func_table, context);
		}

		return STATUS_SUCCESS;
	}

	inline PIMAGE_SECTION_HEADER PeParseBaisc::getSections(void* base, ULONG* size_of_sections)
	{
		if(!isValidX64PE((char*)base)) return nullptr;

		auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<PIMAGE_DOS_HEADER>(base)->e_lfanew + (UINT_PTR)(base));
		if (MmIsAddressValid(size_of_sections)) {

			*size_of_sections = nt_headers->FileHeader.NumberOfSections;
		}

		return IMAGE_FIRST_SECTION(nt_headers);
	}

	inline ULONG PeParseBaisc::getEntryPointRva(void* base)
	{
		if (!isValidX64PE((char*)base)) return 0;

		auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(base);
		auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>((UINT_PTR)base + dos_header->e_lfanew);
		auto opt_header = nt_headers->OptionalHeader;

		return opt_header.AddressOfEntryPoint;

	}

	inline UINT_PTR PeParseBaisc::patternFind(unsigned long long addr, unsigned long size, const char* pattern, const char* mask)
	{
		size -= (unsigned long)strlen(mask);

		for (unsigned long i = 0; i < size; i++)
		{
			if (patternCheck((const char*)addr + i, pattern, mask))
				return addr + i;
		}

		return 0;
	}

	inline UINT_PTR PeParseBaisc::patternFindSections(unsigned long long base, const char* pattern, const char* mask, const char* name)
	{
		PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)base;
		if (dos->e_magic != IMAGE_DOS_SIGNATURE) return 0;

		PIMAGE_NT_HEADERS64 nt = (PIMAGE_NT_HEADERS64)(base + dos->e_lfanew);
		if (nt->Signature != IMAGE_NT_SIGNATURE) return 0;

		PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(nt);
		for (unsigned short i = 0; i < nt->FileHeader.NumberOfSections; i++)
		{
			PIMAGE_SECTION_HEADER p = &section[i];

			if (strstr((const char*)p->Name, name))
			{
				unsigned long long result = patternFind(base + p->VirtualAddress, p->Misc.VirtualSize, pattern, mask);
				if (result) return result;
			}
		}

		return 0;
	}

	inline bool PeParseBaisc::patternCheck(const char* data, const char* pattern, const char* mask)
	{
		size_t len = strlen(mask);

		for (size_t i = 0; i < len; i++)
		{
			if (data[i] == pattern[i] || mask[i] == '?')
				continue;
			else
				return false;
		}

		return true;
	}


	typedef enum _SYSTEM_INFORMATION_CLASS {
		SystemModuleInformation = 0xb,
		SystemKernelDebuggerInformation = 0x23,
		SystemFirmwareTableInformation = 0x4c
	} SYSTEM_INFORMATION_CLASS;

	extern "C" {
		NTKERNELAPI NTSTATUS NTAPI ZwQuerySystemInformation(
			SYSTEM_INFORMATION_CLASS SystemInformationClass,
			PVOID SystemInformation,
			ULONG SystemInformationLength,
			PULONG ReturnLength);
	};

	inline bool PeParseBaisc::isValidX64PE(char* base)
	{
		if (!MmIsAddressValid(base)) return false;

		auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(base);
		if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) return false;

		auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>((UINT_PTR)base + dos_header->e_lfanew);
		if (nt_headers->FileHeader.Machine != X64) return false;

		return true;
	}

	inline void* PeParseBaisc::getModuleBase(char* module_name, OperType type, ULONG* size)
	{

#define MAXIMUM_FILENAME_LENGTH 256

		typedef struct _MY_SYSTEM_MODULE_ENTRY
		{
#ifdef _WIN64
			ULONGLONG Unknown1;
			ULONGLONG Unknown2;
#else
			ULONG Unknown1;
			ULONG Unknown2;
#endif
			PVOID BaseAddress;
			ULONG Size;
			ULONG Flags;
			ULONG EntryIndex;
			USHORT NameLength;  // Length of module name not including the path, this field contains valid value only for NTOSKRNL module
			USHORT PathLength;  // Length of 'directory path' part of modulename
			CHAR Name[MAXIMUM_FILENAME_LENGTH];
		} MY_SYSTEM_MODULE_ENTRY;

		typedef struct _MY_SYSTEM_MODULE_INFORMATION
		{
			ULONG Count;
#ifdef _WIN64
			ULONG Unknown1;
#endif
			MY_SYSTEM_MODULE_ENTRY Module[1];
		} MY_SYSTEM_MODULE_INFORMATION;




		// now not support r3 
		if (type == OperType::r3) return nullptr;

		ULONG needSize = 0;
		ZwQuerySystemInformation(SystemModuleInformation, nullptr, 0, &needSize);
		needSize *= 2;
		void* findBase = nullptr;

		auto info = reinterpret_cast<MY_SYSTEM_MODULE_INFORMATION*>(
			ExAllocatePoolWithTag(NonPagedPool, needSize, 'temp'));

		if (info == nullptr) {
			return nullptr;
		}

		do {

			if (!NT_SUCCESS(
				ZwQuerySystemInformation(SystemModuleInformation, info, needSize, &needSize))) {
				break;

			}

			for (size_t i = 0; i < info->Count; i++) {
				MY_SYSTEM_MODULE_ENTRY* module_entry = &info->Module[i];
				if (strstr(module_entry->Name, module_name) != nullptr) {
					findBase = module_entry->BaseAddress;
					if (MmIsAddressValid(size)) {

						*size = module_entry->Size;
					}
				}
			}

		} while (false);

		ExFreePool(info);
		return findBase;
	}

	inline void PeParseBaisc::reloc(void* base)
	{
		//修复reloc table
		char* pBase = (char*)base;
		auto* pOpt = &reinterpret_cast<IMAGE_NT_HEADERS*>(pBase + reinterpret_cast<IMAGE_DOS_HEADER*>((uintptr_t)pBase)->e_lfanew)->OptionalHeader;
		char* LocationDelta = pBase - pOpt->ImageBase;
		if (LocationDelta) {
			if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) {
				auto* pRelocData = reinterpret_cast<IMAGE_BASE_RELOCATION*>(pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
				const auto* pRelocEnd = reinterpret_cast<IMAGE_BASE_RELOCATION*>(reinterpret_cast<uintptr_t>(pRelocData) + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
				while (pRelocData < pRelocEnd && pRelocData->SizeOfBlock) {
					//重定位表有很多个
					//重定位的个数不包括IMAGE_BASE_RELOCATION这个地方
					//重定位的偏移的大小是WORD
					UINT64 AmountOfEntries = (pRelocData->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(short);
					//指向重定位的偏移
					//typedef struct _IMAGE_BASE_RELOCATION {
					//	DWORD   VirtualAddress; //重定位表起始地址的RVA
					//	DWORD   SizeOfBlock;
					//	//  WORD    TypeOffset[1];
					//Windows重定位表是按页涉及的
					//相近的地址,都放在了这一个RVA里面.
					//TypeOffset中高4位是这个重定表项的类型
					//低12位 表示在这个一页(4KB)的偏移
					unsigned short* pRelativeInfo = reinterpret_cast<unsigned short*>(pRelocData + 1);

					for (UINT64 i = 0; i != AmountOfEntries; ++i, ++pRelativeInfo) {
						//遍历重定表的TypeOffset
						if (RELOC_FLAG(*pRelativeInfo)) {
							//判断高4位 是否需要重定位

							//只有直接寻址才需要重定位
							//pBase+RVA==需要重定位页面
							//页面+0xfff & TypeOffset 就是要重定位的地址(一个直接地址)
							UINT_PTR* pPatch = reinterpret_cast<UINT_PTR*>(pBase + pRelocData->VirtualAddress + ((*pRelativeInfo) & 0xFFF));
							//所以我们要把这个地址加上真正装载地址减去ImageBase
							*pPatch += reinterpret_cast<UINT_PTR>(LocationDelta);
						}
					}
					//下一个重定位表(毕竟不止一个页面需要重定位)
					pRelocData = reinterpret_cast<IMAGE_BASE_RELOCATION*>(reinterpret_cast<char*>(pRelocData) + pRelocData->SizeOfBlock);
				}
			}
		}
	}


	//只是构造参数不同,构造函数是一个文件路径/已经在内存的指针 用于给Baisc提供
	class ParsePE : public PeParseBaisc {
	public:
		ParsePE(const wchar_t* file_path);
		ParsePE(const UNICODE_STRING& u_file_path);//nt path 或者dos path均可

		ParsePE(unsigned char* base, size_t size);
		ParsePE(void* base,size_t size):ParsePE((unsigned char*)(base),size){ }

		~ParsePE();

		//重载移动语义/拷贝构造
		ParsePE& operator= (const ParsePE& rhs);
		ParsePE& operator= (ParsePE&& rhs);

		ParsePE(const ParsePE& rhs);
		ParsePE(ParsePE&& rhs);

		void setBase();
	public:
		static bool isNtPath(const wchar_t* path);
	private:
		HANDLE __h_file;
		size_t __size;//pe file size
	private:
		static const unsigned pool_tag = 'Prpe';

	private:
		void* __base;//read pe file in memory  一定要分清楚到底用哪个!
		void* __noclean_base;//from memory do not need to clean memory
	public:
		void* _base;
	};


	inline ParsePE::ParsePE(const wchar_t* file_path):__h_file(0),__base(0),__size(0),__noclean_base(0),_base(0)
	{
		const unsigned MAX_PATH = 560;
		wchar_t file_full_path[MAX_PATH] = {};
		bool failed = true;
		UNICODE_STRING u_full_path = {};
		OBJECT_ATTRIBUTES oa{};
		IO_STATUS_BLOCK isb{};
		void* pe_buf = nullptr;

		//不考虑分页内存了
		if (file_path == nullptr || !MmIsAddressValid((void*)file_path)) return;

		if (!isNtPath(file_path)) {
			//tansfrom dos path to nt path
			wcscpy(file_full_path, L"\\??\\");
			wcscat(file_full_path, file_path);
		}
		else {
			wcscpy(file_full_path, file_path);
		}

		RtlInitUnicodeString(&u_full_path, file_full_path);

		do {

			InitializeObjectAttributes(&oa, &u_full_path, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, 0, 0);
			//create file
			if (!NT_SUCCESS(
				ZwCreateFile(&__h_file, GENERIC_ALL, &oa, &isb, nullptr, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, 0, 0, 0)
			)) {
				break;
			}

			FILE_STANDARD_INFORMATION file_info{};
			LARGE_INTEGER offset{ 0 };
			//get file size
			if (!NT_SUCCESS(ZwQueryInformationFile(__h_file, &isb,
				&file_info, sizeof(file_info), FileStandardInformation)))
			{
				break;
			}

			__size = file_info.EndOfFile.LowPart;
			
			//因为PEBaisc全是接受的是map过的 所以这里得先把内存map一下
			pe_buf = ExAllocatePoolWithTag(NonPagedPool, __size, pool_tag);
			if (pe_buf == nullptr) {
				break;
			}

			if (!NT_SUCCESS(ZwReadFile(__h_file, 0, 0, 0, &isb, pe_buf, (ULONG)__size, &offset, 0))) {
				break;
			}

			if (!NT_SUCCESS(ZwFlushBuffersFile(__h_file, &isb))) {
				break;
			}

			if(!isValidX64PE((char*)pe_buf)) break;

			auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(pe_buf);
			auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>((UINT_PTR)pe_buf + dos_header->e_lfanew);
			auto opt_header = nt_headers->OptionalHeader;
			//开始map
			__base = ExAllocatePoolWithTag(NonPagedPool, opt_header.SizeOfImage, pool_tag);
			if (!__base) {
				break;
			}

			auto section = IMAGE_FIRST_SECTION(nt_headers);

			//别忘记复制了PE头
			memcpy(__base, pe_buf, PAGE_SIZE);

			for (USHORT i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
				if (!section[i].SizeOfRawData) continue;
				memcpy((PUCHAR)__base + section[i].VirtualAddress,(PUCHAR)pe_buf+section[i].PointerToRawData , section[i].SizeOfRawData);
			}

			failed = false;

		} while (false);



		//clean up
		if (pe_buf) {
			ExFreePool(pe_buf);
		}
		if (failed) {
			if (__h_file != 0) {
				ZwClose(__h_file);
				__h_file = 0;
			}
			if (__base != nullptr) {
				ExFreePool(__base);
				__base = nullptr;
			}
		}

		setBase();
	}

	//只需要代理一下
	inline ParsePE::ParsePE(const UNICODE_STRING& u_file_path) : ParsePE(u_file_path.Buffer)
	{
	}

	inline ParsePE::ParsePE(unsigned char* base, size_t size) : __noclean_base(0),__base(0),__h_file(0),__size(0), _base(0)
	{
		if (!MmIsAddressValid(base) || size == 0) return;

		__noclean_base = base;
		__size = size;

		setBase();
	}

	//dtor 只clean 需要clean的
	inline ParsePE::~ParsePE()
	{
		if (MmIsAddressValid(__base)) {
			ExFreePool(__base);
			__base = nullptr;
		}
		if (__h_file) {
			ZwClose(__h_file);
			__h_file = nullptr;
		}
	}

	//赋值构造
	inline ParsePE& ParsePE::operator=(const ParsePE& rhs)
	{
		_base = nullptr;
		//判断一下是通过memory的方式构造的还是通过路径+readfile方式构造的
		if (MmIsAddressValid(rhs.__base)) {
			//这里直接省略h_file,我不复制了,直接复制__base
			__base = ExAllocatePoolWithTag(NonPagedPool, rhs.__size, pool_tag);
			if (__base) {
				memcpy(__base, rhs.__base, rhs.__size);
			}
		}
		else if (MmIsAddressValid(rhs.__noclean_base)) {
			//这个直接复制就行了
			__noclean_base = rhs.__noclean_base;
		}
		else {
			//不知道是啥构造的 应该是出错了
		}

		setBase();
		return *this;
	}

	//移动赋值 把原来的内容复制过去就行
	inline ParsePE& ParsePE::operator=(ParsePE&& rhs)
	{
		_base = nullptr;
		//判断一下是通过memory的方式构造的还是通过路径+readfile方式构造的
		if (MmIsAddressValid(rhs.__base)) {
			__base = rhs.__base;
			__h_file = rhs.__h_file;

			//清空原来的内容 不清理
			rhs.__base = nullptr;
			rhs.__h_file = 0;
			
		}
		else if (MmIsAddressValid(rhs.__noclean_base)) {
			//这个直接复制就行了
			__noclean_base = rhs.__noclean_base;
		}
		else {
			//不知道是啥构造的 应该是出错了
		}

		setBase();
		return *this;
	}

	//拷贝构造
	inline ParsePE::ParsePE(const ParsePE& rhs)
	{
		this->operator=(rhs);
	}

	//移动构造
	inline ParsePE::ParsePE(ParsePE&& rhs):__h_file(0), __base(0), __size(0), __noclean_base(0)
	{
		_base = nullptr;
		//判断一下是通过memory的方式构造的还是通过路径+readfile方式构造的
		if (MmIsAddressValid(rhs.__base)) {
			__base = rhs.__base;
			__h_file = rhs.__h_file;

			//清空原来的内容 不清理
			rhs.__base = nullptr;
			rhs.__h_file = 0;

		}
		else if (MmIsAddressValid(rhs.__noclean_base)) {
			//这个直接复制就行了
			__noclean_base = rhs.__noclean_base;
		}
		else {
			//不知道是啥构造的 应该是出错了
		}

		setBase();
	}

	inline void ParsePE::setBase()
	{
		_base = (__base) ? __base : __noclean_base;
	}

	inline bool ParsePE::isNtPath(const wchar_t* path)
	{
		auto ret = false;
		if (MmIsAddressValid((void*)path)) {

			if (wcsstr(path, L"\\??\\") != nullptr || wcsstr(path, L"\\DosDevice\\") != nullptr) {

				ret = true;
			}
		}
		return ret;
	}

}



#endif
```

`etw_hook/include/kstl/kref.hpp`:

```hpp
#pragma once

#include <fltKernel.h>

/// <summary>
/// author:oxygen
/// 更方便的通过 tid pid hProces hThread引用对象 并且不用解引用,同时可以ScopeAttach
/// </summary>
namespace kstd {
	class KScopeRefByProcessByHandle {
	public:
		void* get() const { return __process; }
		NTSTATUS retStatus() const { return __status; }

		KScopeRefByProcessByHandle() = default;
		KScopeRefByProcessByHandle(HANDLE h_process):KScopeRefByProcessByHandle() {
			__handle = h_process;
			__status = ObReferenceObjectByHandle(__handle, PROCESS_ALL_ACCESS, *PsProcessType, KernelMode,
				&__process, 0);
		}
		void deref() {
			if (__process != nullptr) {
				ObDereferenceObject(__process);
			}
		}
	private:
		HANDLE __handle;
		void* __process;
		NTSTATUS __status;
	};

	class KScopeRefByThreadByHandle {
	public:
		void* get() const { return __thread; }
		NTSTATUS retStatus() const { return __status; }
		KScopeRefByThreadByHandle():__handle(0),__thread(0),__status(0){}

		KScopeRefByThreadByHandle(HANDLE h_process) :KScopeRefByThreadByHandle(){
		
			__handle = h_process;
			__status = ObReferenceObjectByHandle(__handle, PROCESS_ALL_ACCESS, *PsThreadType, KernelMode,
				&__thread, 0);
		}
		void deref() {
			if (__thread != nullptr) {
				ObDereferenceObject(__thread);
			}
		}
	private:
		HANDLE __handle;
		void* __thread;
		NTSTATUS __status;

	};
	class KScopeRefProcessByPid {
	public:
		KScopeRefProcessByPid(HANDLE pid):__pid(pid),__obj(nullptr){
			do {
				if (!NT_SUCCESS(__status = PsLookupProcessByProcessId(__pid,
					(PEPROCESS*)&__obj))) {
					break;

				}

			} while (false);
		
		}
		void* get()const  {
			return __obj;
		}
		void deref() {
			if(__obj)
				ObDereferenceObject(__obj);
		}
		NTSTATUS retStatus() const { return __status; }
	private:
		HANDLE __pid;
		void* __obj;
		NTSTATUS __status;
	};

	class KScopeRefThreadByTid {
	public:
		KScopeRefThreadByTid(HANDLE tid) :__tid(tid), __obj(nullptr) {
			do {
				if (!NT_SUCCESS(__status = PsLookupThreadByThreadId(__tid,
					(PETHREAD*)&__obj))) {
					break;

				}

			} while (false);

		}

		void* get()const {
			return __obj;
		}
		void deref() {
			if (__obj)
				ObDereferenceObject(__obj);
		}
		NTSTATUS retStatus() const { return __status; }
	private:
		HANDLE __tid;
		void* __obj;
		NTSTATUS __status;


	};

	class KScopeAttch {
	public:
		KScopeAttch(PEPROCESS process) :__process(process), __apc{},__need_def(0){
			//这种方式不需要obdef
			KeStackAttachProcess(__process, &__apc);
		}
		KScopeAttch(HANDLE pid) :__apc{}, __process{},__need_def(0) {
			__status = PsLookupProcessByProcessId(pid, &__process);
			if (NT_SUCCESS(__status)) {
				KeStackAttachProcess(__process, &__apc);
				//ObDereferenceObject(__process);
				__need_def = true;
			}
		}
		void* get() const { return __process; }
		NTSTATUS retStatus() const { return __status; }
		void deref() {
			if (__process && __need_def) {
				KeUnstackDetachProcess(&__apc);
				if(__need_def)
					ObDereferenceObject(__process);
			}
				

		}
	private:
		PEPROCESS __process;
		bool __need_def;
		KAPC_STATE __apc;
		NTSTATUS __status;
	};


	template<typename T>
	class KScopeRef {
	public:
		//必须让他发生隐式转换
		KScopeRef(const T& _ref) :__ref(_ref) {
			
		}
		~KScopeRef() {
			__ref.deref();
		}
		void* get() const { return __ref.get(); }
		NTSTATUS status() const { return __ref.status(); }
	private:
		T __ref;

	};

}
```

`etw_hook/include/kstl/kstring.hpp`:

```hpp
#pragma once
#include <fltKernel.h>
#include <ntstrsafe.h>

/// <summary>
/// author :oxygen
/// </summary>
/// 
namespace kstd {


	template<typename T>
	class basic_string {
	public:
		union UNDEFINE_STRING
		{
			UNICODE_STRING us;
			ANSI_STRING as;
		};
		static const size_t npos = MAXULONG64;/*对比stl的npos*/
	public:
		basic_string() : __data(0), __size(0) {};
		basic_string(const T* str);
		basic_string(const basic_string& rhs);
		~basic_string();
	private:
		T* __data;
		size_t __size;/*以字节为单位*/
	public:
		//find函数
		size_t find(const T& c);
		size_t find(const basic_string& rhs);
		size_t find(const T* str);
		
		//rfind
		size_t rfind(const T& c);
		size_t rfind(const basic_string& rhs); //还未实现
		size_t rfind(const T* str);

		basic_string substr(size_t startPos, size_t endPos = npos/*如果这样,就一直到末尾*/);

		const T* c_str() const { return __data; }
		size_t size() const { return __size; }
		size_t length() const { return __size / sizeof(T) - 1; } //字符串长度 不包括\0
		T& operator[](int idx);
		basic_string& operator+=(const basic_string& rhs);
		basic_string& operator+=(const T* str);
		bool operator==(const basic_string& rhs) const;
		bool operator==(const T* str) const;

		basic_string& operator=(const basic_string& rhs);/*不考虑移动语义了*/

		basic_string& operator=(const T* str);
		UNDEFINE_STRING getXXString();/*特色功能*/
	private:
		T* __alloc(size_t bytes);
		void __free(T*);
	};

	
	template<typename T>
	inline basic_string<T>& kstd::basic_string<T>::operator=(const basic_string& rhs) {
		
		//清空原来的,防止内存泄露
		if (MmIsAddressValid(__data)) {
			__free(__data);
		}
		//不考虑移动语义
		__data = nullptr;
		__size = 0;

		auto p = __alloc(rhs.__size);
		if (!p) return *this;

		memset(p, 0, rhs.__size);
		memcpy(p, rhs.__data, rhs.__size);

		this->__size = rhs.__size;
		this->__data = p;

		return *this;
	}
	template<typename T>
	inline basic_string<T>& kstd::basic_string<T>::operator+=(const basic_string& rhs)
	{
	}


	template<typename T>
	inline basic_string<T>& kstd::basic_string<T>::operator+=(const T* str)
	{
		return operator+=(basic_string(str));
	}

	
	template<>
	inline basic_string<char>& kstd::basic_string<char>::operator+=(const basic_string& rhs) {
		auto newSize = __size + rhs.__size - sizeof(char);
		auto newPtr = __alloc(newSize);
		if (newPtr != nullptr) {
			memset(newPtr, 0, newSize);
			if(__size!=0)
				strcpy(newPtr, __data);
			if(rhs.__size!=0)
				strcat(newPtr, rhs.__data);
			__size = newSize;
			__free(__data);
			__data = newPtr;
		}

		return *this;

	}
	template<>
	inline basic_string<wchar_t>& kstd::basic_string<wchar_t>::operator+=(const basic_string& rhs) {
		auto newSize = __size + rhs.__size - sizeof(wchar_t);
		auto newPtr = __alloc(newSize);
		if (newPtr != nullptr) {
			memset(newPtr, 0, newSize);
			if (__size != 0)
				wcscpy(newPtr, __data);
			if (rhs.__size != 0)
				wcscat(newPtr, rhs.__data);
			__size = newSize;
			__free(__data);
			__data = newPtr;
		}

		return *this;
	}




	template<typename T>
	inline bool basic_string<T>::operator==(const basic_string& rhs) const
	{
		auto ret = false;
		do {

			if (&rhs == this) {
				ret = true;
				break;
			}
			if (rhs.size() != this->size()) {
				ret = false;
				break;
			}
			if (!MmIsAddressValid((PVOID)this->c_str()) || !MmIsAddressValid((PVOID)rhs.c_str())) {
				ret = false;
				break;
			}

			if (RtlCompareMemory(rhs.c_str(), this->c_str(), this->__size) == this->__size) {

				ret = true;
				break;
			}
			else {
				ret = false;
				break;
			}	

		} while (false);

		return ret;
		
	}

	template<typename T>
	inline bool basic_string<T>::operator==(const T* str) const
	{

		auto rhs = basic_string(str);
		return operator==(rhs);
	}

	template<typename T>
	inline T* basic_string<T>::__alloc(size_t bytes)
	{
		return reinterpret_cast<T*>(
			ExAllocatePoolWithTag(NonPagedPool, bytes, 'kstr')
			);
	}
	
	template<typename T>
	inline void basic_string<T>::__free(T* buf)
	{
		if(MmIsAddressValid(buf))
			ExFreePool(reinterpret_cast<void*>(buf));
	}


	template<typename T>
	inline T& kstd::basic_string<T>::operator[](int idx)
	{
		return __data[idx];
	}


	template<typename T>
	inline kstd::basic_string<T>::basic_string(const basic_string& rhs):__data(0), __size(0)
	{
		auto p=__alloc(rhs.__size);
		if (p == nullptr) {
			return;
		}
		memcpy(p, rhs.__data, rhs.__size);
		this->__size = rhs.__size;
		this->__data = p;
	}

	template<typename T>
	inline basic_string<T>::~basic_string()
	{
		if (MmIsAddressValid(__data)) __free(__data);
		__size = 0;
	}

	template<typename T>
	inline size_t basic_string<T>::find(const T& c)
	{
		
		auto ret = npos;
		for (auto i = 0ull; i < __size; i++) {
			if (__data[i] == c) {
				ret = i;
				break;
			}
		}
		return ret;
	}


	template<typename T>
	inline size_t basic_string<T>::find(const T* str)
	{
		return find(basic_string(str));
	}

	template<typename T>
	inline size_t basic_string<T>::rfind(const T& c)
	{
		auto ret = npos;
		for (auto i = __size-1; i >=0; i--) {
			if (__data[i] == c) {
				ret = i;
				break;
			}
		}
		return ret;
	}

	template<typename T>
	inline basic_string<T> basic_string<T>::substr(size_t startPos, size_t endPos)
	{
		do {
			auto idxMax = __size / sizeof(T) - 1/*这个idxMax是指向字符串的哪个\n字符*/;
			
			if (endPos == npos) {
				endPos = idxMax;
			}

			if (startPos > idxMax || endPos<startPos || endPos>idxMax) {
				break;
			}
		
			auto str = this->c_str();
			auto allocSize = (endPos - startPos + 1) * sizeof(T);
			auto p = __alloc(allocSize);
			if (p == nullptr) {
				break;
			}

			memset(p, 0, allocSize);
			memcpy(p, str + startPos, (endPos - startPos) * sizeof(T));
			auto ret = basic_string(p);
			__free(p);
			return ret;
		} while (false);

		//走到这就是失败
		return basic_string{};
	}




	template<>
	inline size_t basic_string<char>::find(const basic_string& rhs)
	{
		size_t ret = npos;
		do {
			if (rhs.__size == 0 || __size == 0) {
				break;
			}

			auto pos=strstr(this->__data, rhs.__data);
			if (pos == nullptr) {
				break;
			}

			auto interval = pos - this->__data;
			ret = interval;
		} while (false);
	
		return ret;
	}

	template<>
	inline size_t basic_string<wchar_t>::find(const basic_string& rhs)
	{
		size_t ret = npos;
		do {
			if (rhs.__size == 0 || __size == 0) {
				break;
			}

			auto pos = wcsstr(this->__data, rhs.__data);
			if (pos == nullptr) {
				break;
			}

			auto interval = pos - this->__data;
			ret = interval;
		} while (false);

		return ret;
	}

	/// <summary>
	/// 模板特化 
	/// </summary>
	/// <param name="str"></param>
	template<>
	inline basic_string<char>::basic_string(const char* str):__data(0),__size(0)
	{
		if (!MmIsAddressValid((PVOID)str)) return;

		auto len=strlen(str);
		auto p=__alloc(len*sizeof(char) + sizeof(char));
		if (p == nullptr) {
			//failed to alloc memory
			return;
		}
		__size = len * sizeof(char) + sizeof(char);
		memset(p, 0, __size);
		strcpy(p, str);
		__data = p;
	}

	/// <summary>
	/// 模板特化
	/// </summary>
	/// <param name="str"></param>
	template<>
	inline basic_string<wchar_t>::basic_string(const wchar_t* str) :__data(0), __size(0) {
		if (!MmIsAddressValid((PVOID)str)) return;

		auto len = wcslen(str);
		auto p = __alloc(len * sizeof(wchar_t) + sizeof(wchar_t));
		if (p == nullptr) {
			//failed to alloc memory
			return;
		}
		__size = len * sizeof(wchar_t) + sizeof(wchar_t);
		memset(p, 0, __size);
		wcscpy(p,str);
		__data = p;
	}






	template<typename T>
	inline basic_string<T>::basic_string(const T* str)
	{
	}



	template<>
	inline typename basic_string<char>::UNDEFINE_STRING basic_string<char>::getXXString()
	{
		UNDEFINE_STRING undefineS{};
		
		if (this->__data != nullptr) {
			RtlInitAnsiString(&undefineS.as, this->__data);
		}
		
		return undefineS;
	}
	
	template<>
	inline typename basic_string<wchar_t>::UNDEFINE_STRING basic_string<wchar_t>::getXXString()
	{
		UNDEFINE_STRING undefineS{};

		if (this->__data != nullptr) {
			RtlInitUnicodeString(&undefineS.us, this->__data);
		}

		return undefineS;
		
	}
	/// <summary>
	/// 模板偏特化
	/// </summary>
	/// <param name="str"></param>
	/// <returns></returns>
	template<>
	inline basic_string<wchar_t>& kstd::basic_string<wchar_t>::operator=(const wchar_t* str)
	{
		if (!MmIsAddressValid((PVOID)str)) return *this;

		__size = 0;
		if(MmIsAddressValid(__data))
			__free(__data);
		__data = 0;
		
		auto size = (wcslen(str) + 1) * sizeof(wchar_t);
		auto p = __alloc(size);
		if (p != nullptr) {
			memset(p, 0, size);
			wcscpy(p, str);
			__size = size;
			__data = p;
		}
		else {
			//failed to alloc memory
		}
		return *this;
	}

	template<>
	inline basic_string<char>& kstd::basic_string<char>::operator=(const char* str)
	{
		if (!MmIsAddressValid((PVOID)str)) return*this;

		__size = 0;
		if(MmIsAddressValid(__data))
			__free(__data);
		__data = 0;

		auto size = (strlen(str) + 1) * sizeof(char);
		auto p = __alloc(size);
		if (p != nullptr) {
			memset(p, 0, size);
			strcpy(p, str);
			__size = size;
			__data = p;
		}
		else {
			//failed to alloc memory
		}
		return *this;

	}



	using kstring = basic_string<char>;
	using kwstring = basic_string<wchar_t>;

}
```

`etw_hook/include/kstl/ksystem_info.hpp`:

```hpp
#pragma once
#include <fltKernel.h>
/// <summary>
/// in this head file you can get 
///some windows kernel global var address or some system tools like bypass sign check and so on
///  author : oxygen
/// 
/// </summary>
namespace kstd {


	

#ifndef _WIN64
#define KDDEBUGGER_DATA_OFFSET 0x1068
#else
#define KDDEBUGGER_DATA_OFFSET 0x2080
#endif


	static const unsigned poolTag = 'sysi';
	class SysInfoManager {
	public:
		typedef struct _DBGKD_DEBUG_DATA_HEADER64 {
			LIST_ENTRY64 List;
			ULONG           OwnerTag;
			ULONG           Size;
		} DBGKD_DEBUG_DATA_HEADER64, * PDBGKD_DEBUG_DATA_HEADER64;
		typedef struct _KDDEBUGGER_DATA64 {

			DBGKD_DEBUG_DATA_HEADER64 Header;

			//
			// Base address of kernel image
			//

			ULONG64   KernBase;

			//
			// DbgBreakPointWithStatus is a function which takes an argument
			// and hits a breakpoint.  This field contains the address of the
			// breakpoint instruction.  When the debugger sees a breakpoint
			// at this address, it may retrieve the argument from the first
			// argument register, or on x86 the eax register.
			//

			ULONG64   BreakpointWithStatus;       // address of breakpoint

			//
			// Address of the saved context record during a bugcheck
			//
			// N.B. This is an automatic in KeBugcheckEx's frame, and
			// is only valid after a bugcheck.
			//

			ULONG64   SavedContext;

			//
			// help for walking stacks with user callbacks:
			//

			//
			// The address of the thread structure is provided in the
			// WAIT_STATE_CHANGE packet.  This is the offset from the base of
			// the thread structure to the pointer to the kernel stack frame
			// for the currently active usermode callback.
			//

			USHORT  ThCallbackStack;            // offset in thread data

			//
			// these values are offsets into that frame:
			//

			USHORT  NextCallback;               // saved pointer to next callback frame
			USHORT  FramePointer;               // saved frame pointer

			//
			// pad to a quad boundary
			//
			USHORT  PaeEnabled;

			//
			// Address of the kernel callout routine.
			//

			ULONG64   KiCallUserMode;             // kernel routine

			//
			// Address of the usermode entry point for callbacks.
			//

			ULONG64   KeUserCallbackDispatcher;   // address in ntdll


			//
			// Addresses of various kernel data structures and lists
			// that are of interest to the kernel debugger.
			//

			ULONG64   PsLoadedModuleList;
			ULONG64   PsActiveProcessHead;
			ULONG64   PspCidTable;

			ULONG64   ExpSystemResourcesList;
			ULONG64   ExpPagedPoolDescriptor;
			ULONG64   ExpNumberOfPagedPools;

			ULONG64   KeTimeIncrement;
			ULONG64   KeBugCheckCallbackListHead;
			ULONG64   KiBugcheckData;

			ULONG64   IopErrorLogListHead;

			ULONG64   ObpRootDirectoryObject;
			ULONG64   ObpTypeObjectType;

			ULONG64   MmSystemCacheStart;
			ULONG64   MmSystemCacheEnd;
			ULONG64   MmSystemCacheWs;

			ULONG64   MmPfnDatabase;
			ULONG64   MmSystemPtesStart;
			ULONG64   MmSystemPtesEnd;
			ULONG64   MmSubsectionBase;
			ULONG64   MmNumberOfPagingFiles;

			ULONG64   MmLowestPhysicalPage;
			ULONG64   MmHighestPhysicalPage;
			ULONG64   MmNumberOfPhysicalPages;

			ULONG64   MmMaximumNonPagedPoolInBytes;
			ULONG64   MmNonPagedSystemStart;
			ULONG64   MmNonPagedPoolStart;
			ULONG64   MmNonPagedPoolEnd;

			ULONG64   MmPagedPoolStart;
			ULONG64   MmPagedPoolEnd;
			ULONG64   MmPagedPoolInformation;
			ULONG64   MmPageSize;

			ULONG64   MmSizeOfPagedPoolInBytes;

			ULONG64   MmTotalCommitLimit;
			ULONG64   MmTotalCommittedPages;
			ULONG64   MmSharedCommit;
			ULONG64   MmDriverCommit;
			ULONG64   MmProcessCommit;
			ULONG64   MmPagedPoolCommit;
			ULONG64   MmExtendedCommit;

			ULONG64   MmZeroedPageListHead;
			ULONG64   MmFreePageListHead;
			ULONG64   MmStandbyPageListHead;
			ULONG64   MmModifiedPageListHead;
			ULONG64   MmModifiedNoWritePageListHead;
			ULONG64   MmAvailablePages;
			ULONG64   MmResidentAvailablePages;

			ULONG64   PoolTrackTable;
			ULONG64   NonPagedPoolDescriptor;

			ULONG64   MmHighestUserAddress;
			ULONG64   MmSystemRangeStart;
			ULONG64   MmUserProbeAddress;

			ULONG64   KdPrintCircularBuffer;
			ULONG64   KdPrintCircularBufferEnd;
			ULONG64   KdPrintWritePointer;
			ULONG64   KdPrintRolloverCount;

			ULONG64   MmLoadedUserImageList;

			// NT 5.1 Addition

			ULONG64   NtBuildLab;
			ULONG64   KiNormalSystemCall;

			// NT 5.0 hotfix addition

			ULONG64   KiProcessorBlock;
			ULONG64   MmUnloadedDrivers;
			ULONG64   MmLastUnloadedDriver;
			ULONG64   MmTriageActionTaken;
			ULONG64   MmSpecialPoolTag;
			ULONG64   KernelVerifier;
			ULONG64   MmVerifierData;
			ULONG64   MmAllocatedNonPagedPool;
			ULONG64   MmPeakCommitment;
			ULONG64   MmTotalCommitLimitMaximum;
			ULONG64   CmNtCSDVersion;

			// NT 5.1 Addition

			ULONG64   MmPhysicalMemoryBlock;
			ULONG64   MmSessionBase;
			ULONG64   MmSessionSize;
			ULONG64   MmSystemParentTablePage;

			// Server 2003 addition

			ULONG64   MmVirtualTranslationBase;

			USHORT    OffsetKThreadNextProcessor;
			USHORT    OffsetKThreadTeb;
			USHORT    OffsetKThreadKernelStack;
			USHORT    OffsetKThreadInitialStack;

			USHORT    OffsetKThreadApcProcess;
			USHORT    OffsetKThreadState;
			USHORT    OffsetKThreadBStore;
			USHORT    OffsetKThreadBStoreLimit;

			USHORT    SizeEProcess;
			USHORT    OffsetEprocessPeb;
			USHORT    OffsetEprocessParentCID;
			USHORT    OffsetEprocessDirectoryTableBase;

			USHORT    SizePrcb;
			USHORT    OffsetPrcbDpcRoutine;
			USHORT    OffsetPrcbCurrentThread;
			USHORT    OffsetPrcbMhz;

			USHORT    OffsetPrcbCpuType;
			USHORT    OffsetPrcbVendorString;
			USHORT    OffsetPrcbProcStateContext;
			USHORT    OffsetPrcbNumber;

			USHORT    SizeEThread;

			ULONG64   KdPrintCircularBufferPtr;
			ULONG64   KdPrintBufferSize;

			ULONG64   KeLoaderBlock;

			USHORT    SizePcr;
			USHORT    OffsetPcrSelfPcr;
			USHORT    OffsetPcrCurrentPrcb;
			USHORT    OffsetPcrContainedPrcb;

			USHORT    OffsetPcrInitialBStore;
			USHORT    OffsetPcrBStoreLimit;
			USHORT    OffsetPcrInitialStack;
			USHORT    OffsetPcrStackLimit;

			USHORT    OffsetPrcbPcrPage;
			USHORT    OffsetPrcbProcStateSpecialReg;
			USHORT    GdtR0Code;
			USHORT    GdtR0Data;

			USHORT    GdtR0Pcr;
			USHORT    GdtR3Code;
			USHORT    GdtR3Data;
			USHORT    GdtR3Teb;

			USHORT    GdtLdt;
			USHORT    GdtTss;
			USHORT    Gdt64R3CmCode;
			USHORT    Gdt64R3CmTeb;

			ULONG64   IopNumTriageDumpDataBlocks;
			ULONG64   IopTriageDumpDataBlocks;

			// Longhorn addition

			ULONG64   VfCrashDataBlock;
			ULONG64   MmBadPagesDetected;
			ULONG64   MmZeroedPageSingleBitErrorsDetected;

			// Windows 7 addition

			ULONG64   EtwpDebuggerData;
			USHORT    OffsetPrcbContext;

			// Windows 8 addition

			USHORT    OffsetPrcbMaxBreakpoints;
			USHORT    OffsetPrcbMaxWatchpoints;

			ULONG     OffsetKThreadStackLimit;
			ULONG     OffsetKThreadStackBase;
			ULONG     OffsetKThreadQueueListEntry;
			ULONG     OffsetEThreadIrpList;

			USHORT    OffsetPrcbIdleThread;
			USHORT    OffsetPrcbNormalDpcState;
			USHORT    OffsetPrcbDpcStack;
			USHORT    OffsetPrcbIsrStack;

			USHORT    SizeKDPC_STACK_FRAME;

			// Windows 8.1 Addition

			USHORT    OffsetKPriQueueThreadListHead;
			USHORT    OffsetKThreadWaitReason;

			// Windows 10 RS1 Addition

			USHORT    Padding;
			ULONG64   PteBase;

			// Windows 10 RS5 Addition

			ULONG64 RetpolineStubFunctionTable;
			ULONG RetpolineStubFunctionTableSize;
			ULONG RetpolineStubOffset;
			ULONG RetpolineStubSize;

		} KDDEBUGGER_DATA64, * PKDDEBUGGER_DATA64;


	public:
		static SysInfoManager* getInstance();
		static void destory();
		static void byPassSignCheck(PDRIVER_OBJECT drv);
	public:
		KDDEBUGGER_DATA64* getSysInfo() const { return	&__dumpHeader; }
		ULONG getBuildNumber();
	public:
		inline static SysInfoManager* __instance;
		inline static KDDEBUGGER_DATA64 __dumpHeader;
	};



	inline SysInfoManager* kstd::SysInfoManager::getInstance(){

		UNICODE_STRING u_func_name = RTL_CONSTANT_STRING(L"KeCapturePersistentThreadState");
		char* tmp = nullptr;

		do {
			if (__instance != nullptr) break;
			__instance = reinterpret_cast<SysInfoManager*>(ExAllocatePoolWithTag(NonPagedPool,
				sizeof SysInfoManager,
				poolTag));
		
			if(__instance==nullptr) break;

#define DUMP_BLOCK_SIZE 0X40000

			tmp = reinterpret_cast<char*>(ExAllocatePoolWithTag(NonPagedPool, DUMP_BLOCK_SIZE, 'sysI'));
			if (tmp == nullptr) {
				break;
			}
			CONTEXT context = { 0 };
			context.ContextFlags = CONTEXT_FULL;
			RtlCaptureContext(&context);
			
			auto func = reinterpret_cast<void(*)(CONTEXT*, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, void*)>(
				MmGetSystemRoutineAddress(&u_func_name));
			if (func == nullptr) break;

			func(&context, 0, 0, 0, 0, 0, 0, tmp);

			memcpy(&__dumpHeader, tmp + KDDEBUGGER_DATA_OFFSET, sizeof __dumpHeader);

			if (tmp) ExFreePool(tmp);
			return __instance;

		} while (false);


		if (__instance != nullptr) {
			ExFreePool(__instance);
			__instance = nullptr;
		}

		if (tmp) ExFreePool(tmp);
		
		return nullptr;
	}

	inline void SysInfoManager::destory()
	{
		if (__instance != nullptr) {
			ExFreePool(__instance);
		}
	}

	inline void SysInfoManager::byPassSignCheck(PDRIVER_OBJECT drv)
	{
		//STRUCT FOR WIN64
		typedef struct _LDR_DATA                         			// 24 elements, 0xE0 bytes (sizeof)
		{
			struct _LIST_ENTRY InLoadOrderLinks;                     // 2 elements, 0x10 bytes (sizeof)
			struct _LIST_ENTRY InMemoryOrderLinks;                   // 2 elements, 0x10 bytes (sizeof)
			struct _LIST_ENTRY InInitializationOrderLinks;           // 2 elements, 0x10 bytes (sizeof)
			VOID* DllBase;
			VOID* EntryPoint;
			ULONG32 SizeOfImage;
			UINT8 _PADDING0_[0x4];
			struct _UNICODE_STRING FullDllName;                      // 3 elements, 0x10 bytes (sizeof)
			struct _UNICODE_STRING BaseDllName;                      // 3 elements, 0x10 bytes (sizeof)
			ULONG32 Flags;
		} LDR_DATA, * PLDR_DATA;
		PLDR_DATA ldr;
		ldr = (PLDR_DATA)(drv->DriverSection);
		ldr->Flags |= 0x20;
	}

	inline ULONG SysInfoManager::getBuildNumber()
	{
		RTL_OSVERSIONINFOW ver({});
		ULONG ret = 0xffffffff;

		if (NT_SUCCESS(RtlGetVersion(&ver))) {
			ret = ver.dwBuildNumber;
		}

		return ret;
	}




	
}
```

`etw_hook/include/refs.hpp`:

```hpp
#pragma once
#ifndef _REFS_H_

#define _REFS_H_

#include <fltKernel.h>
#include <ntimage.h>
#include <intrin.h>
#include <kstl/klog.hpp>
#include <kstl/kstring.hpp>

/*不报警告地申请内核内存 可以替换ExAlloatePoolWithTag*/
template<typename T>
static inline T* kalloc(POOL_TYPE pool_type, SIZE_T size = 0, ULONG tag = 'refs') {

	auto func_name = UNICODE_STRING{};
	auto func = (void*)(nullptr);
	auto ret = (void*)(nullptr);

	RtlInitUnicodeString(&func_name, L"ExAllocatePoolZero");
	func = MmGetSystemRoutineAddress(&func_name);
	if (size == 0) {
		size = sizeof(T);
	}

	if (func) {

		auto f = reinterpret_cast<void* (*)(POOL_TYPE, SIZE_T, ULONG)>(func);

		ret = f(pool_type, size, tag);
	}
	else {
		/*低版本windows*/
		RtlInitUnicodeString(&func_name, L"ExAllocatePoolWithTag");
		func = MmGetSystemRoutineAddress(&func_name);

		auto f = reinterpret_cast<void* (*)(POOL_TYPE, SIZE_T, ULONG)>(func);

		/*如果连这个函数找不到蓝屏是正常的*/
		ret = f(pool_type, size, tag);
	}

	return reinterpret_cast<T*>(ret);
}


typedef struct LDR_DATA_TABLE_ENTRY {

	struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0
	VOID* ExceptionTable;                                                   //0x10
	ULONG ExceptionTableSize;                                               //0x18
	VOID* GpValue;                                                          //0x20
	void* NonPagedDebugInfo;                        //0x28
	VOID* DllBase;                                                          //0x30
	VOID* EntryPoint;                                                       //0x38
	ULONG SizeOfImage;                                                      //0x40
	struct _UNICODE_STRING FullDllName;                                     //0x48
	struct _UNICODE_STRING BaseDllName;                                     //0x58
	ULONG Flags;                                                            //0x68
	USHORT LoadCount;                                                       //0x6c
	union
	{
		USHORT SignatureLevel : 4;                                            //0x6e
		USHORT SignatureType : 3;                                             //0x6e
		USHORT Unused : 9;                                                    //0x6e
		USHORT EntireField;                                                 //0x6e
	} u1;                                                                   //0x6e
	VOID* SectionPointer;                                                   //0x70
	ULONG CheckSum;                                                         //0x78
	ULONG CoverageSectionSize;                                              //0x7c
	VOID* CoverageSection;                                                  //0x80
	VOID* LoadedImports;                                                    //0x88
	VOID* Spare;                                                            //0x90
	ULONG SizeOfImageNotRounded;                                            //0x98
	ULONG TimeDateStamp;                                                    //0x9c
	char padding[0x78];														//兼容WIN7 WIN8


}*PLDR_DATA_TABLE_ENTRY;


#define MAXIMUM_FILENAME_LENGTH 256

typedef struct _SYSTEM_MODULE_ENTRY
{
#ifdef _WIN64
	ULONGLONG Unknown1;
	ULONGLONG Unknown2;
#else
	ULONG Unknown1;
	ULONG Unknown2;
#endif
	PVOID BaseAddress;
	ULONG Size;
	ULONG Flags;
	ULONG EntryIndex;
	USHORT NameLength;  // Length of module name not including the path, this field contains valid value only for NTOSKRNL module
	USHORT PathLength;  // Length of 'directory path' part of modulename
	CHAR Name[MAXIMUM_FILENAME_LENGTH];
} SYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG Count;
#ifdef _WIN64
	ULONG Unknown1;
#endif
	SYSTEM_MODULE_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemModuleInformation = 0xb,
	SystemKernelDebuggerInformation = 0x23,
	SystemFirmwareTableInformation = 0x4c
} SYSTEM_INFORMATION_CLASS;

extern "C" {
	NTKERNELAPI NTSTATUS NTAPI ZwQuerySystemInformation(
		SYSTEM_INFORMATION_CLASS SystemInformationClass,
		PVOID SystemInformation,
		ULONG SystemInformationLength,
		PULONG ReturnLength);
	NTKERNELAPI NTSTATUS NTAPI NtQuerySystemInformation(
		IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
		OUT PVOID SystemInformation,
		IN ULONG SystemInformationLength,
		OUT PULONG ReturnLength OPTIONAL);

	NTKERNELAPI PVOID RtlPcToFileHeader(PVOID pc, PVOID* base);
};

#endif // _REFS_H_

```

`etw_hook/src/etwhook_init.cpp`:

```cpp
#include <etwhook_init.hpp>
#include <kstl/ksystem_info.hpp>
#include <etwhook_utils.hpp>
#include <kstl/kpe_parse.hpp>

#pragma warning(disable : 4201)

#define EtwpStartTrace		1
#define EtwpStopTrace		2
#define EtwpQueryTrace		3
#define EtwpUpdateTrace		4
#define EtwpFlushTrace		5

#define WNODE_FLAG_TRACED_GUID			0x00020000  // denotes a trace
#define EVENT_TRACE_BUFFERING_MODE      0x00000400  // Buffering mode only
#define EVENT_TRACE_FLAG_SYSTEMCALL     0x00000080  // system calls

typedef struct _WNODE_HEADER
{
	ULONG BufferSize;        // Size of entire buffer inclusive of this ULONG
	ULONG ProviderId;    // Provider Id of driver returning this buffer
	union
	{
		ULONG64 HistoricalContext;  // Logger use
		struct
		{
			ULONG Version;           // Reserved
			ULONG Linkage;           // Linkage field reserved for WMI
		} DUMMYSTRUCTNAME;
	} DUMMYUNIONNAME;

	union
	{
		ULONG CountLost;         // Reserved
		HANDLE KernelHandle;     // Kernel handle for data block
		LARGE_INTEGER TimeStamp; // Timestamp as returned in units of 100ns
								 // since 1/1/1601
	} DUMMYUNIONNAME2;
	GUID Guid;                  // Guid for data block returned with results
	ULONG ClientContext;
	ULONG Flags;             // Flags, see below
} WNODE_HEADER, * PWNODE_HEADER;

typedef struct _EVENT_TRACE_PROPERTIES {
	WNODE_HEADER	Wnode;
	ULONG			BufferSize;
	ULONG			MinimumBuffers;
	ULONG			MaximumBuffers;
	ULONG			MaximumFileSize;
	ULONG			LogFileMode;
	ULONG			FlushTimer;
	ULONG			EnableFlags;
	LONG			AgeLimit;
	ULONG			NumberOfBuffers;
	ULONG			FreeBuffers;
	ULONG			EventsLost;
	ULONG			BuffersWritten;
	ULONG			LogBuffersLost;
	ULONG			RealTimeBuffersLost;
	HANDLE			LoggerThreadId;
	ULONG			LogFileNameOffset;
	ULONG			LoggerNameOffset;
} EVENT_TRACE_PROPERTIES, * PEVENT_TRACE_PROPERTIES;

/* 54dea73a-ed1f-42a4-af713e63d056f174 */
const GUID CkclSessionGuid = { 0x54dea73a, 0xed1f, 0x42a4, { 0xaf, 0x71, 0x3e, 0x63, 0xd0, 0x56, 0xf1, 0x74 } };

/*这个是Nt kernel Logger 的 guid 其实设置谁都一样！*/
const GUID session_guid = { 0x9E814AAD, 0x3204, 0x11D2, { 0x9A, 0x82, 0x0, 0x60, 0x8, 0xA8, 0x69, 0x39 } };

typedef struct _CKCL_TRACE_PROPERIES : EVENT_TRACE_PROPERTIES
{
	ULONG64					Unknown[3];
	UNICODE_STRING			ProviderName;
} CKCL_TRACE_PROPERTIES, * PCKCL_TRACE_PROPERTIES;

EXTERN_C
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTraceControl(
	_In_ ULONG FunctionCode,
	_In_reads_bytes_opt_(InBufferLen) PVOID InBuffer,
	_In_ ULONG InBufferLen,
	_Out_writes_bytes_opt_(OutBufferLen) PVOID OutBuffer,
	_In_ ULONG OutBufferLen,
	_Out_ PULONG ReturnLength
);

EXTERN_C
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemInformation(ULONG info_class,void* buf,ULONG length);

typedef enum _EVENT_TRACE_INFORMATION_CLASS {
	EventTraceKernelVersionInformation,
	EventTraceGroupMaskInformation,
	EventTracePerformanceInformation,
	EventTraceTimeProfileInformation,
	EventTraceSessionSecurityInformation,
	EventTraceSpinlockInformation,
	EventTraceStackTracingInformation,
	EventTraceExecutiveResourceInformation,
	EventTraceHeapTracingInformation,
	EventTraceHeapSummaryTracingInformation,
	EventTracePoolTagFilterInformation,
	EventTracePebsTracingInformation,
	EventTraceProfileConfigInformation,
	EventTraceProfileSourceListInformation,
	EventTraceProfileEventListInformation,
	EventTraceProfileCounterListInformation,
	EventTraceStackCachingInformation,
	EventTraceObjectTypeFilterInformation,
	MaxEventTraceInfoClass
} EVENT_TRACE_INFORMATION_CLASS;

typedef struct _EVENT_TRACE_PROFILE_COUNTER_INFORMATION
{
	EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
	HANDLE TraceHandle;
	ULONG ProfileSource[1];
} EVENT_TRACE_PROFILE_COUNTER_INFORMATION, * PEVENT_TRACE_PROFILE_COUNTER_INFORMATION;

typedef struct _EVENT_TRACE_SYSTEM_EVENT_INFORMATION
{
	EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
	HANDLE TraceHandle;
	ULONG HookId[1];
} EVENT_TRACE_SYSTEM_EVENT_INFORMATION, * PEVENT_TRACE_SYSTEM_EVENT_INFORMATION;

const ULONG SystemPerformanceTraceInformation = 31;



EtwInitilizer::EtwInitilizer() : __is_open(false)
{
	
	UNICODE_STRING func_name = {};

	RtlInitUnicodeString(&func_name, L"HalPrivateDispatchTable");
	HalPrivateDispatchTable = reinterpret_cast<UINT_PTR*>(MmGetSystemRoutineAddress(&func_name));
	
	if (HalPrivateDispatchTable == nullptr) {
		LOG_ERROR("failed to get HalPrivateDispatchTable");
	}

}


EtwInitilizer::~EtwInitilizer()
{
	/*如果开启着，那么需要关闭*/
	if (__is_open) end_syscall_trace();
}

NTSTATUS EtwInitilizer::start_syscall_trace()
{
	auto status = STATUS_UNSUCCESSFUL;
	auto ckcl_property = (PCKCL_TRACE_PROPERTIES)(nullptr);
	auto returnlen = 0ul;

	do {

		ckcl_property = kalloc<CKCL_TRACE_PROPERTIES>(NonPagedPool,PAGE_SIZE);
		if (!ckcl_property) {
			LOG_ERROR("failed to alloc memory for etw property!\r\n");
			status = STATUS_MEMORY_NOT_ALLOCATED;
			break;
		}

		memset(ckcl_property, 0, PAGE_SIZE);
		ckcl_property->Wnode.BufferSize = PAGE_SIZE;
		ckcl_property->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
		//ckcl_property->ProviderName = RTL_CONSTANT_STRING(L"NT Kernel Logger");
		//ckcl_property->Wnode.Guid = session_guid;
		ckcl_property->ProviderName = RTL_CONSTANT_STRING(L"Circular Kernel Context Logger");
		ckcl_property->Wnode.Guid = CkclSessionGuid;
		ckcl_property->Wnode.ClientContext = 1;
		ckcl_property->BufferSize = sizeof(ULONG);
		ckcl_property->MinimumBuffers = ckcl_property->MaximumBuffers = 2;
		ckcl_property->LogFileMode = EVENT_TRACE_BUFFERING_MODE;
		
		//enable kernel logger etw trace
		status = ZwTraceControl(EtwpStartTrace, ckcl_property, PAGE_SIZE, ckcl_property, PAGE_SIZE, &returnlen);
		
		//sometimes may return value is STATUS_OBJECT_NAME_COLLISION
		if (!NT_SUCCESS(status) && status!= STATUS_OBJECT_NAME_COLLISION) {
			LOG_ERROR("failed to enable kernel loggger etw trace,errcode=%x\r\n", status);
			break;
		}

		//start syscall etw
		ckcl_property->EnableFlags = EVENT_TRACE_FLAG_SYSTEMCALL;

		status=  ZwTraceControl(EtwpUpdateTrace, ckcl_property, PAGE_SIZE, ckcl_property, PAGE_SIZE, &returnlen);
		if (!NT_SUCCESS(status)) {
			LOG_ERROR("failed to enable syscall etw,errcode=%x\r\n", status);
			end_syscall_trace();
			break;
		}

	} while (false);

	//clean up

	if (ckcl_property) ExFreePool(ckcl_property);
	
	//if fail
	//to do
	
	//if success clean
	if (NT_SUCCESS(status)) __is_open = true;
	
	return status;
}

NTSTATUS EtwInitilizer::end_syscall_trace()
{
	auto status = STATUS_UNSUCCESSFUL;
	auto ckcl_property = (PCKCL_TRACE_PROPERTIES)(nullptr);
	auto returnlen = 0ul;

	do {

		ckcl_property = kalloc<CKCL_TRACE_PROPERTIES>(NonPagedPool, PAGE_SIZE);
		if (!ckcl_property) {
			LOG_ERROR("failed to alloc memory for etw property!\r\n");
			status = STATUS_MEMORY_NOT_ALLOCATED;
			break;
		}

		

		memset(ckcl_property, 0, PAGE_SIZE);
		ckcl_property->Wnode.BufferSize = PAGE_SIZE;
		ckcl_property->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
		//ckcl_property->ProviderName = RTL_CONSTANT_STRING(L"NT Kernel Logger");
		//ckcl_property->Wnode.Guid = session_guid;
		ckcl_property->ProviderName = RTL_CONSTANT_STRING(L"Circular Kernel Context Logger");
		ckcl_property->Wnode.Guid = CkclSessionGuid;
		ckcl_property->Wnode.ClientContext = 1;
		ckcl_property->BufferSize = sizeof(ULONG);
		ckcl_property->MinimumBuffers = ckcl_property->MaximumBuffers = 2;
		ckcl_property->LogFileMode = EVENT_TRACE_BUFFERING_MODE;

		//enable kernel logger etw trace
		status = ZwTraceControl(EtwpStopTrace, ckcl_property, PAGE_SIZE, ckcl_property, PAGE_SIZE, &returnlen);

		if (!NT_SUCCESS(status)) {
			LOG_ERROR("failed to stop kernel loggger etw trace,errcode=%x\r\n", status);
			break;
		}


	} while (false);

	//clean up
	if (ckcl_property) ExFreePool(ckcl_property);
	
	if (NT_SUCCESS(status)) __is_open = false;

	return status;
}

/*其实这个要调用ZwSetSystemInfomation，但是没有找到合适的文档化和文章，故只能手动逆向windows，最终得出结果*/
NTSTATUS EtwInitilizer::open_pmc_counter()
{
	auto status = STATUS_SUCCESS;
	auto pmc_count_info = (PEVENT_TRACE_PROFILE_COUNTER_INFORMATION)(nullptr);
	auto pmc_event_info=(PEVENT_TRACE_SYSTEM_EVENT_INFORMATION)(nullptr);
	constexpr auto syscall_hookid = 0xf33ul;



	if (!__is_open) return STATUS_FLT_NOT_INITIALIZED;

	do {

		/*获取ckcl_context的loggerid*/
		auto EtwpDebuggerData=reinterpret_cast<ULONG***>( \
			kstd::SysInfoManager::getInstance()->getSysInfo()->EtwpDebuggerData);
		
		if (!EtwpDebuggerData) {
			status = STATUS_NOT_SUPPORTED;
			LOG_ERROR("failed to get EtwpDebuggerData!\r\n");
		}
		
		/*这个可以参考第一版的ETW HOOK，这里简写了*/
		auto logger_id = EtwpDebuggerData[2][2][0];

		pmc_count_info = kalloc<EVENT_TRACE_PROFILE_COUNTER_INFORMATION>(NonPagedPool);
		if (!pmc_count_info) {
			LOG_ERROR("failed to alloc memory for pmc_count!\r\n");
			status = STATUS_MEMORY_NOT_ALLOCATED;
			break;
		}
		//先设置PMC Count 我们只关心一个hookid 那就是syscall的hookid 0xf33 profile source 随便设置
		pmc_count_info->EventTraceInformationClass = EventTraceProfileCounterListInformation;
		pmc_count_info->TraceHandle = ULongToHandle(logger_id)/*这个其实就是loggerid*/;
		pmc_count_info->ProfileSource[0] = 1;/*随便填写*/

		auto EtwpMaxPmcCounter=get_EtwpMaxPmcCounter();

		auto org = (unsigned char)0;

		if (MmIsAddressValid(EtwpMaxPmcCounter)) {

			org = *EtwpMaxPmcCounter;

			if (org <= 1) *EtwpMaxPmcCounter = 2;

		}

		status=ZwSetSystemInformation(SystemPerformanceTraceInformation, pmc_count_info, sizeof EVENT_TRACE_PROFILE_COUNTER_INFORMATION);
		if (!NT_SUCCESS(status)) {
			LOG_ERROR("failed to configure pmc counter,errcode=%x\r\n", status);
			break;
		}


		if (MmIsAddressValid(EtwpMaxPmcCounter)) {
			if (org <= 1) *EtwpMaxPmcCounter = org;
		}

		//然后设置PMC Event hookid只需要一个就行
		pmc_event_info = kalloc<EVENT_TRACE_SYSTEM_EVENT_INFORMATION>(NonPagedPool);
		if (!pmc_event_info) {
			LOG_ERROR("failed to alloc memory for pmc_event_info!\r\n");
			status = STATUS_MEMORY_NOT_ALLOCATED;
			break;
		}

		pmc_event_info->EventTraceInformationClass = EventTraceProfileEventListInformation;
		pmc_event_info->TraceHandle = ULongToHandle(logger_id);
		pmc_event_info->HookId[0] = syscall_hookid;/*必须0xf33*/


		status = ZwSetSystemInformation(SystemPerformanceTraceInformation, pmc_event_info, sizeof EVENT_TRACE_SYSTEM_EVENT_INFORMATION);
		if (!NT_SUCCESS(status)) {
			LOG_ERROR("failed to configure pmc event,errcode=%x\r\n", status);
			break;
		}

		

	} while (false);

	//clean up
	if (pmc_count_info) ExFreePool(pmc_count_info);
	if (pmc_event_info) ExFreePool(pmc_event_info);

	return status;
}

unsigned char* EtwInitilizer::get_EtwpMaxPmcCounter()
{
	auto ret = nullptr;
	auto nt_img = (void*)nullptr;
	auto nt_size = 0ul;

	//PAGE:00000001409DB8DE 44 3B 05 57 57 37 00                          cmp     r8d, cs:EtwpMaxPmcCounter
	//PAGE : 00000001409DB8E5 0F 87 EC 00 00 00                           ja      loc_1409DB9D7
	//PAGE : 00000001409DB8EB 83 B9 2C 01 00 00 01                        cmp     dword ptr[rcx + 12Ch], 1
	//PAGE:00000001409DB8F2 0F 84 DF 00 00 00                             jz      loc_1409DB9D7
	//PAGE : 00000001409DB8F8 48 83 B9 F8 03 00 00 00                     cmp     qword ptr[rcx + 3F8h], 0
	//PAGE:00000001409DB900 75 0D                                         jnz     short loc_1409DB90F

	//windows 18362开始有的
	if (kstd::SysInfoManager::getInstance()->getBuildNumber() < 18362) return ret;

	nt_img = find_module_base(L"ntoskrnl.exe", &nt_size);

	kstd::ParsePE ntos(nt_img, nt_size);

	auto p = reinterpret_cast<unsigned char*>(ntos.patternFindSections((unsigned long long)nt_img, \
		"\x44\x3b\x05\x00\x00\x00\x00\x0f\x87\x00\x00\x00\x00\x83\xb9\x00\x00\x00\x00\x01\x0f\x84\x00\x00\x00\x00\x48\x83\xb9\x00\x00\x00\x00\x00\x75\x00", \
		"xxx????xx????xx????xxx????xxx????xx?", "PAGE"));


	if (MmIsAddressValid(p)) {
		auto offset = *reinterpret_cast<PLONG>(p + 3);
		return p + 7 + offset;
	}
	else return nullptr;
	

	
}

#pragma warning(default : 4201)
```

`etw_hook/src/etwhook_main.cpp`:

```cpp
#include <refs.hpp>
#include <etwhook_init.hpp>
#include <etwhook_manager.hpp>

#include <kstl/ksystem_info.hpp>

NTSTATUS detour_NtCreateFile(
	_Out_ PHANDLE FileHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_opt_ PLARGE_INTEGER AllocationSize,
	_In_ ULONG FileAttributes,
	_In_ ULONG ShareAccess,
	_In_ ULONG CreateDisposition,
	_In_ ULONG CreateOptions,
	_In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
	_In_ ULONG EaLength) {

	if (ObjectAttributes &&
		ObjectAttributes->ObjectName &&
		ObjectAttributes->ObjectName->Buffer)
	{
		wchar_t* name = (wchar_t*)ExAllocatePoolWithTag(NonPagedPool, ObjectAttributes->ObjectName->Length + sizeof(wchar_t),'lala');
		
		if (name)
		{
			RtlZeroMemory(name, ObjectAttributes->ObjectName->Length + sizeof(wchar_t));
			RtlCopyMemory(name, ObjectAttributes->ObjectName->Buffer, ObjectAttributes->ObjectName->Length);

			if (wcsstr(name, L"oxygen.txt"))
			{
				ExFreePool(name);
				return STATUS_ACCESS_DENIED;
			}

			ExFreePool(name);
		}
	}


	return NtCreateFile(FileHandle, DesiredAccess, ObjectAttributes, \
		IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, \
		CreateDisposition, CreateOptions, EaBuffer, EaLength);
}


NTSTATUS detour_NtClose(HANDLE h) {

	//LOG_INFO("ZwClose was Caguth\r\n");

	return NtClose(h);

}

EXTERN_C NTSTATUS DriverEntry(PDRIVER_OBJECT drv,PUNICODE_STRING) 
{
	auto status = STATUS_SUCCESS;
	
	drv->DriverUnload = [](PDRIVER_OBJECT) {

		EtwHookManager::get_instance()->destory();
	};
	
	kstd::Logger::init("etw_hook", nullptr);

	LOG_INFO("init...\r\n");

	
	status=EtwHookManager::get_instance()->init();

	

	EtwHookManager::get_instance()->add_hook(NtCreateFile, detour_NtCreateFile);
	EtwHookManager::get_instance()->add_hook(NtClose, detour_NtClose);

	return status;
}
```

`etw_hook/src/etwhook_manager.cpp`:

```cpp
#include <etwhook_manager.hpp>
#include <kstl/ksystem_info.hpp>
#include <kstl/kpe_parse.hpp>
#include <etwhook_utils.hpp>
#include <intrin.h>


EtwHookManager* EtwHookManager::__instance;

void(* EtwHookManager::__orghalcollectpmccounters)(void*, unsigned long long);

EtwHookManager* EtwHookManager::get_instance()
{
	if (!__instance) __instance = new EtwHookManager;
	return __instance;
}

NTSTATUS EtwHookManager::init()
{
	auto status = STATUS_UNSUCCESSFUL;

	/*检查是否分配单例的内存了*/
	if (!__instance) return STATUS_MEMORY_NOT_ALLOCATED;

	/*这种方法不支持win7*/
	auto info_instance=kstd::SysInfoManager::getInstance();
	if (info_instance == nullptr) return STATUS_INSUFFICIENT_RESOURCES;
	if (info_instance->getBuildNumber() <= 7601) 
	{
		LOG_ERROR("current os version is not supported!\r\n");
		return STATUS_NOT_SUPPORTED;
	}


	do {
		status = this->__initilizer.start_syscall_trace();
		if (!NT_SUCCESS(status)) break;

		/*set value above 1*/

		status = this->__initilizer.open_pmc_counter();
		if(!NT_SUCCESS(status)) break;


		if (this->__initilizer.HalPrivateDispatchTable == nullptr) {
			status = STATUS_UNSUCCESSFUL;
			LOG_ERROR("failed to get HalPrivateDispatchTable address!\r\n");
			break;
		}

		_disable();
		/*swap*/
		__orghalcollectpmccounters = reinterpret_cast<void(*)(void*, unsigned long long)> \
			(this->__initilizer.HalPrivateDispatchTable[__halcollectpmccounters_idx]);
	
		this->__initilizer.HalPrivateDispatchTable[__halcollectpmccounters_idx] = \
			reinterpret_cast<ULONG_PTR>(hk_halcollectpmccounters);

		_enable();


	} while (false);


	//clean up

	//if fail

	//if suc

	return status;
}

NTSTATUS EtwHookManager::destory()
{
	auto status = STATUS_UNSUCCESSFUL;

	if (!__instance) return STATUS_MEMORY_NOT_ALLOCATED;

	do {

		delete __instance;

		__instance = nullptr;

		status = STATUS_SUCCESS;

	} while (false);
	

	LARGE_INTEGER delay_time = {};
	delay_time.QuadPart = -10 * 1000000 * 2;
	KeDelayExecutionThread(KernelMode, false, &delay_time);


	return status;
}

NTSTATUS EtwHookManager::add_hook(void* org_syscall, void* detour_routine)
{
	if (!__instance) return STATUS_FLT_NOT_INITIALIZED;

	auto suc=__hookmaps.insert({ org_syscall,detour_routine });

	return suc ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

}

NTSTATUS EtwHookManager::remove_hook(void* org_syscall)
{
	if(!__instance) return STATUS_FLT_NOT_INITIALIZED;
	
	auto need_delete = __hookmaps.find({ org_syscall,nullptr });

	if (!need_delete) return STATUS_NOT_FOUND;

	__hookmaps.remove(need_delete);

	return STATUS_SUCCESS;
}

void EtwHookManager::hk_halcollectpmccounters(void* ctx, unsigned long long trace_buffer_end)
{
	//LOG_INFO("filter success! arg1->%llx,arg2->%llx\r\n", ctx, trace_buffer_end);
	
	/*有时候中断也会走这个函数，这里判断一下IRQL 好像必定是DPC_LEVEL? 大于这个不行*/
	if(KeGetCurrentIrql()<=DISPATCH_LEVEL)
		EtwHookManager::get_instance()->stack_trace_to_syscall();
	

	return __orghalcollectpmccounters(ctx, trace_buffer_end);
}



//sys_call_etw_entry
//48 83 EC 50                   sub     rsp, 50h
//48 89 4C 24 20                mov[rsp + 20h], rcx
//48 89 54 24 28                mov[rsp + 28h], rdx
//4C 89 44 24 30                mov[rsp + 30h], r8
//4C 89 4C 24 38                mov[rsp + 38h], r9
//4C 89 54 24 40                mov[rsp + 40h], r10
//49 8B CA                      mov     rcx, r10
//E8 54 A5 19 00                call    PerfInfoLogSysCallEntry
//48 8B 4C 24 20                mov     rcx, [rsp + 20h]
//48 8B 54 24 28                mov     rdx, [rsp + 28h]
//4C 8B 44 24 30                mov     r8, [rsp + 30h]
//4C 8B 4C 24 38                mov     r9, [rsp + 38h]
//4C 8B 54 24 40                mov     r10, [rsp + 40h]
//48 83 C4 50                   add     rsp, 50h
//49 8B C2                      mov     rax, r10
//FF D0                         call    rax
/*寻找方法是
1.先确定是不是有魔数字(看起来好像是不需要？因为这种方法只有系统调用会进入filter 函数)
2.确定KiSyscall64的起始和结束地址
3.栈遍历，遍历到之后，是否是位于起始和结束地址 如果是，说明栈目前位于

rsp->KiSyscall64.call    PerfInfoLogSysCallEntry
rsp+0x48==TargetSystemCall

*/

EtwHookManager::EtwHookManager() : __hookmaps() {

	__nt_img = find_module_base(L"ntoskrnl.exe", &__nt_size);

	kstd::ParsePE ntos(__nt_img, __nt_size);


	/*注意，这个方法并不严谨！没有直接readmsr IA32_LSTAR 然后使用反汇编引擎解析严谨*/
	//KiSystemServiceRepeat:
	//	4C 8D 15 85 6F 9F 00          lea     r10, KeServiceDescriptorTable
	//	4C 8D 1D FE 20 8F 00          lea     r11, KeServiceDescriptorTableShadow
	//	F7 43 78 80 00 00 00          test    dword ptr[rbx + 78h], 80h; GuiThread
	/*KiSystemServiceRepeat一定位于KiSystemCall64之中，这个直接进行特征码搜索*/

	__KiSystemServiceRepeat = ntos.patternFindSections((unsigned long long)__nt_img, \
		"\x4c\x8d\x15\x00\x00\x00\x00\x4c\x8d\x1d\x00\x00\x00\x00\xf7\x43", \
		"xxx????xxx????xx", ".text");

	/*初始化二叉树*/
	__hookmaps.init();
}

EtwHookManager::~EtwHookManager()
{
	/*关闭etw trace*/
	__initilizer.end_syscall_trace();

	/*恢复HalPrivateHook*/
	_disable();
	this->__initilizer.HalPrivateDispatchTable[__halcollectpmccounters_idx] = \
		reinterpret_cast<ULONG_PTR>(__orghalcollectpmccounters);
	_enable();

	/*销毁HookMap*/
	__hookmaps.destory();

}



void EtwHookManager::stack_trace_to_syscall()
{

	//if (ExGetPreviousMode() == KernelMode)
	//{
	//	return;
	//}

	////
	//// Extract the system call index (if you so desire).
	////
	////PKTHREAD CurrentThread = (PKTHREAD)__readgsqword(OFFSET_KPCR_CURRENT_THREAD);
	////unsigned int SystemCallIndex = *(unsigned int*)((uintptr_t)CurrentThread + OFFSET_KTHREAD_SYSTEM_CALL_NUMBER);

	//PVOID* StackMax = (PVOID*)__readgsqword(OFFSET_KPCR_RSP_BASE);


	//PVOID* StackFrame = (PVOID*)_AddressOfReturnAddress();

	////
	//// First walk backwards on the stack to find the 2 magic values.
	////
	//for (PVOID* StackCurrent = StackMax;
	//	StackCurrent > StackFrame;
	//	--StackCurrent)
	//{
	//	// 
	//	// This is intentionally being read as 4-byte magic on an 8
	//	// byte aligned boundary.
	//	//
	//	PULONG AsUlong = (PULONG)StackCurrent;
	//	if (*AsUlong != INFINITYHOOK_MAGIC_1)
	//	{
	//		continue;
	//	}

	//	// 
	//	// If the first magic is set, check for the second magic.
	//	//
	//	--StackCurrent;

	//	PUSHORT AsShort = (PUSHORT)StackCurrent;
	//	if (*AsShort != INFINITYHOOK_MAGIC_2)
	//	{
	//		continue;
	//	}

	//	//
	//	// Now we reverse the direction of the stack walk.
	//	//
	//	for (;
	//		StackCurrent < StackMax;
	//		++StackCurrent)
	//	{
	//		PULONGLONG AsUlonglong = (PULONGLONG)StackCurrent;

	//		if (((uintptr_t)(*AsUlonglong) >= (uintptr_t)__KiSystemServiceRepeat &&
	//			(uintptr_t)(*AsUlonglong) < (uintptr_t)((uintptr_t)__KiSystemServiceRepeat + (PAGE_SIZE * 2))))
	//		{
	//			record_syscall(StackCurrent);
	//			break;
	//			
	//		}

	//		//
	//		// If you want to "hook" this function, replace this stack memory 
	//		// with a pointer to your own function.
	//		//
	//		continue;
	//	}

	//	break;
	//}


	if (ExGetPreviousMode() == KernelMode)
	{
		return;
	}

	auto stack_max=(PVOID*)__readgsqword(0x1A8);

	auto cur_stack = (PVOID*)_AddressOfReturnAddress();
	constexpr auto magic1 = 0x501802ul;
	constexpr auto magic2 = 0xf33ul;

	do {

		if (!__KiSystemServiceRepeat) {
			LOG_ERROR("failed to find KiSystemServiceRepeat\r\n");
			break;
		}

		if (!__nt_img) {
			LOG_ERROR("failed to find ntoskrnl.exe");
			break;
		}

		//__debugbreak();

		/*
		* 
		*			max
					...
					...
		cur_stack->	xxx
					...
					magic_number
					...
					syscall   <-先从上面开始遍历
		*/

		/*开始遍历堆栈*/

		for (;cur_stack<stack_max;cur_stack++) {

			auto stack_as_ushort = reinterpret_cast<PUSHORT>(cur_stack);

			if(*stack_as_ushort != magic2) continue;

			cur_stack++;

			auto stack_as_ulong = reinterpret_cast<PULONG>(cur_stack);

			if(*stack_as_ulong != magic1) continue;

			/*开始遍历*/
			for (; cur_stack < stack_max; cur_stack++) {
				
				if ((ULONG_PTR)*cur_stack >= (ULONG_PTR)PAGE_ALIGN(__KiSystemServiceRepeat) \
					&&
					(ULONG_PTR)*cur_stack <= (ULONG_PTR)PAGE_ALIGN(__KiSystemServiceRepeat + PAGE_SIZE * 2)
					) {
					//find 注意!!! 这个cur_stck不能100%保证是syscall，因为sys_exit的时候也会走到这
					record_syscall(cur_stack);

					break;
				}

			}

			break;

		}


	} while (false);
	
}

void EtwHookManager::record_syscall(void** call_routine)
{

	auto hk_map=__hookmaps.find({ call_routine[9],nullptr });

	if (!hk_map) return;

	if (hk_map->detour_func) {

		call_routine[9] = hk_map->detour_func;
	}

}

```

`etw_hook/src/etwhook_utils.cpp`:

```cpp
#include <refs.hpp>
#include <etwhook_utils.hpp>

void breakOnlyDebug() {

	if (!*KdDebuggerNotPresent) __debugbreak();

}

//sometimes there will occurs a bsod!?
kstd::kwstring getModuleNameByPtr(PVOID p,PVOID* base,size_t* size) {
	kstd::kwstring find_name{L"unknow module"};
	ULONG needSize = 0;
	ZwQuerySystemInformation(SystemModuleInformation, nullptr, 0, &needSize);
	needSize += PAGE_SIZE;
	wchar_t* wstr = nullptr;

	const auto info = reinterpret_cast<SYSTEM_MODULE_INFORMATION*>(ExAllocatePoolWithTag(NonPagedPool, needSize, 'temp'));
	if (!MmIsAddressValid(info)) {
		LOG_ERROR("failed to alloa memory for sys infomation!\r\n");
		return find_name;
	}

	wstr = reinterpret_cast<wchar_t*>(ExAllocatePoolWithTag(NonPagedPool, 512*2, 'temp'));
	if (!MmIsAddressValid(wstr)) {
		LOG_ERROR("failed to alloa memory for str\r\n");
		return find_name;
	}

	do {

		if (!NT_SUCCESS(ZwQuerySystemInformation(SystemModuleInformation, info, needSize, &needSize))) {
			LOG_ERROR("failed to get system info!\r\n");
			break;
		}

		for (size_t i = 0; i < info->Count; i++) {
			SYSTEM_MODULE_ENTRY* module_entry = &(info->Module[i]);
		
			if ((ULONG_PTR)module_entry->BaseAddress <= (ULONG_PTR)(p) &&
				(UINT_PTR)module_entry->BaseAddress + module_entry->Size >= (ULONG_PTR)(p)) {
				

				s2w(module_entry->Name, wstr, 512);
				find_name = wstr;

				if (MmIsAddressValid(size)) *size = module_entry->Size;
				if (MmIsAddressValid(base)) *base = module_entry->BaseAddress;

				break;
			}
		}

	} while (false);

	//clean up
	if(MmIsAddressValid(info))
		ExFreePool(info);
	if (MmIsAddressValid(wstr))
		ExFreePool(wstr);
	return find_name;
}

NTSTATUS w2s(const wchar_t* src, char* dest, size_t destSize) {

	if (!src || !dest || destSize == 0)
	{
		return STATUS_INVALID_PARAMETER;
	}

	size_t i = 0;
	while (src[i] != L'\0' && i < destSize - 1)
	{
		if (src[i] <= 0x7F) 
		{
			dest[i] = (char)src[i];
		}
		else
		{
			
			dest[i] = '?';
		}
		++i;
	}

	dest[i] = '\0';
	return STATUS_SUCCESS;
}

NTSTATUS s2w(const char* src, wchar_t* dest, size_t destSize) {


	if (!src || !dest || destSize == 0)
	{
		return STATUS_INVALID_PARAMETER;
	}

	size_t i = 0;
	while (src[i] != '\0' && i < destSize - 1)
	{
		if (src[i] >= 0) 
		{
			dest[i] = (wchar_t)src[i];
		}
		else
		{
			
			dest[i] = L'?';
		}
		++i;
	}

	dest[i] = L'\0';

	return STATUS_SUCCESS;
}

auto find_module_base(const wchar_t* w_module_name, ULONG* size) -> void* {
	ULONG needSize = 0;
	ZwQuerySystemInformation(SystemModuleInformation, nullptr, 0, &needSize);
	needSize *= 2;
	void* findBase = nullptr;
	char module_name[256] = {};

	w2s(w_module_name, module_name, sizeof module_name);

	auto info = reinterpret_cast<SYSTEM_MODULE_INFORMATION*>(
		ExAllocatePoolWithTag(NonPagedPool, needSize, 'temp'));

	if (info == nullptr) {
		return nullptr;
	}

	do {

		if (!NT_SUCCESS(
			ZwQuerySystemInformation(SystemModuleInformation, info, needSize, &needSize))) {
			break;

		}

		for (size_t i = 0; i < info->Count; i++) {
			SYSTEM_MODULE_ENTRY* module_entry = &info->Module[i];
			char* last_slash = strrchr(module_entry->Name, '\\');
			if (last_slash != nullptr) {
				last_slash++; // Skip the slash
			}
			else {
				last_slash = module_entry->Name;
			}
			
			if (_strnicmp(last_slash, module_name,strlen(module_name)) ==0/*ingore char senstive*/) {
				findBase = module_entry->BaseAddress;
				if (MmIsAddressValid(size)) *size = module_entry->Size;
				break;
			}
		}

	} while (false);

	//clean up
	if(MmIsAddressValid(info))
		ExFreePool(info);
	return findBase;
}

//Force copy across pages 
bool _memcpy(PVOID address, PVOID target_address, ULONG length)
{
	
	auto skipPhyPages = ((((UINT_PTR)(address)+length) >> PAGE_SHIFT) - ((UINT_PTR)address >> PAGE_SHIFT));

	if (!skipPhyPages) {
		bool result = false;
		PHYSICAL_ADDRESS physicial_address;
		physicial_address = MmGetPhysicalAddress(address);
		if (physicial_address.QuadPart)
		{
			PVOID maped_mem = MmMapIoSpace(physicial_address, length, MmNonCached);
			if (maped_mem)
			{
				memcpy(maped_mem, target_address, length);
				MmUnmapIoSpace(maped_mem, length);
				result = true;
			}
		}
		return result;
	}
	else {// 0x200 0x2900 3100 800 1000 
		auto firstPageCopy = PAGE_SIZE - (UINT_PTR)address & 0xfff;
		
		for (int i = 0; i <= skipPhyPages; i++) {
			if (i == 0) {
				PHYSICAL_ADDRESS physicial_address;
				physicial_address = MmGetPhysicalAddress(address);
				if (physicial_address.QuadPart)
				{
					PUCHAR maped_mem = (PUCHAR)MmMapIoSpace(physicial_address, firstPageCopy, MmNonCached);
					if (maped_mem)
					{
						memcpy(maped_mem, target_address, firstPageCopy);
						MmUnmapIoSpace(maped_mem, firstPageCopy);
					}
				}
				else return false;
			}
			else if (i == skipPhyPages) {
				auto lastPageCopy = length - PAGE_SIZE * (i - 1) - firstPageCopy;

				PHYSICAL_ADDRESS physicial_address;
				physicial_address = MmGetPhysicalAddress((PVOID)((UINT_PTR)(PAGE_ALIGN(address)) + PAGE_SIZE * i));
				if (physicial_address.QuadPart)
				{
					PUCHAR maped_mem = (PUCHAR)MmMapIoSpace(physicial_address, lastPageCopy, MmNonCached);
					if (maped_mem)
					{
						memcpy(maped_mem,
							(PUCHAR)target_address + firstPageCopy + (i - 1) * PAGE_SIZE, lastPageCopy);
						MmUnmapIoSpace(maped_mem, lastPageCopy);
					}
				}
				else return false;

			}
			else {
				PHYSICAL_ADDRESS physicial_address;
				physicial_address = MmGetPhysicalAddress((PVOID)((UINT_PTR)(PAGE_ALIGN(address)) + PAGE_SIZE * i));
				if (physicial_address.QuadPart)
				{
					PUCHAR maped_mem = (PUCHAR)MmMapIoSpace(physicial_address, PAGE_SIZE, MmNonCached);
					if (maped_mem)
					{
						memcpy(maped_mem,
							(PUCHAR)target_address + firstPageCopy + (i - 1) * PAGE_SIZE, PAGE_SIZE);
						MmUnmapIoSpace(maped_mem, PAGE_SIZE);
					}
				}
				else return false;

			}
		}
	}

	return true;
}



```

`readme.md`:

```md
# 前言

ETW HOOK是一个经久不衰的话题了，本质上是微软的漏洞，再微软进行记录ETW时候系统调用的时候，被ETW相关组件拦截跑到记录的代码，因为涉及到的代码量实在太大，微软这里面老是会有一些函数指针的使用，从而可以把他替换成我们自己函数回调，而不会触发PG拦截系统调用(`无法拦截直接内核NtXXX`)。

## 早期的ETW HOOK实现概要

早期的ETW HOOK替换的一些HalPxx指针已经被PG监控

**https://github.com/everdox/InfinityHook**

到后来第二个版本的ETW，原理和EAC接管系统异常差不多，**这一版本的也是再ETW HOOK的必经之路上面修改函数指针**:

**原理是EAC通过修改`HalpStallCounter[0xE]`**的这个位置,以及`NtGlobalFlags`这个标志位。

HalpStallCounter[0xE] 函数原本是`HalpTscQueryCounterOrdered`,修改这个之后,一些异常(包括kernel mode)就会走到这从而被EAC接管;

下图是发生异常时候的调用栈

![image-20240119153903903](ETWHOOK%20WIN11%E5%85%BC%E5%AE%B9%E7%89%88.assets/image-20240119153903903.png)

从windbg可以看到,`EAC`修改了`HalpStallCounter`来进行接管异常

![77cd8914ea73abf464a9e0352ac255b0](ETWHOOK%20WIN11%E5%85%BC%E5%AE%B9%E7%89%88.assets/77cd8914ea73abf464a9e0352ac255b0.png)

## 可以兼容最新版 windows 的ETW HOOK

第二版的ETW Hook现在还可以用，但是用起来非常复杂，光是不同系统兼容、修栈就要耗费巨大精力。

因此这里参考国外的一个大佬文章，他提出了更新版本的ETW-HOOK，具体原理如下

WINDOWS的.data节一般是存放可以变的全局变量的，所谓的偷指针就是修改.data节区的指针。

而在这里，最好玩的是`HalPrivateDispatchTable`，这个是windows 的ntoskenl.exe为了方便使用HAL的导出函数，把他们存放在统一的地方。而HAL,用到的地方肯定很多，ETW 正是如此。

我们来看一下系统调用ETW的调用路径

![image-20240419102113440](ETWHOOK%20WIN11%E5%85%BC%E5%AE%B9%E7%89%88.assets/image-20240419102113440.png)

这里其实可以看到，`call rax`其实就是正常的系统调用，而再进入ETW系统调用之前，他把原始的系统调用存放在了栈上，这就导致我们拦截到ETW的时候，可以修改栈上的位置，来进行HOOK Syscall。

进入这个函数

![image-20240419102337381](ETWHOOK%20WIN11%E5%85%BC%E5%AE%B9%E7%89%88.assets/image-20240419102337381.png)

如果说之前无法定位，现在可以通过这个栈上面的`magic number`来定位syscall的地址，从而替换了。

继续跟到`EtwTraceSiloKernelEvent`里面，可以发现，无论参数怎么样，这个函数调用了`EtwpLogKernelEvent`

```C++
void __fastcall EtwTraceSiloKernelEvent(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        unsigned int a4,
        unsigned __int16 a5,
        int a6)
{
  unsigned __int64 v9; // rsi
  unsigned int v10; // ebx
  bool v11; // zf
  unsigned int v12; // ecx
  __int64 v13; // r8
  __int64 v14; // rcx
  __int64 v15; // rbx
  unsigned int v16; // edi
  __int64 v17; // rdx
  __int64 v18; // rcx
  unsigned int v19; // ecx

  v9 = a4;
  v10 = *(_DWORD *)(EtwpHostSiloState + 4224);
  while ( 1 )
  {
    v11 = !_BitScanForward(&v12, v10);
    if ( v11 )
      break;
    v10 &= v10 - 1;
    v13 = v12;
    v14 = 32i64 * v12 + EtwpHostSiloState + 4260;
    if ( v14 )
    {
      if ( ((unsigned int)v9 & *(_DWORD *)(v14 + 4 * (v9 >> 29)) & 0x1FFFFFFF) != 0 )
        EtwpLogKernelEvent(a2, EtwpHostSiloState, *(unsigned __int8 *)(EtwpHostSiloState + 2 * v13 + 4208), a3, a5, a6);
    }
  }
  if ( a1 )
  {
    v15 = *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 864i64);
    if ( v15 )
    {
      v16 = *(_DWORD *)(v15 + 4224);
      while ( 1 )
      {
        v11 = !_BitScanForward(&v19, v16);
        if ( v11 )
          break;
        v17 = v19;
        v16 &= v16 - 1;
        v18 = 32i64 * v19 + v15 + 4260;
        if ( v18 && ((unsigned int)v9 & *(_DWORD *)(v18 + 4 * (v9 >> 29)) & 0x1FFFFFFF) != 0 )
          EtwpLogKernelEvent(a2, v15, *(unsigned __int8 *)(v15 + 2 * v17 + 4208), a3, a5, a6);
      }
    }
  }
}
```

而`EtwpLogKernelEvent`就是这次事件的主角，关键部分代码为

```C++
     else
      {
        if ( (v32 & 0x800) == 0 )
          goto LABEL_17;
        v50 = 0;
        if ( !*(_DWORD *)(*(_QWORD *)(v14 + 1000) + 8i64) )
          goto LABEL_17;
        while ( 1 )
        {
          v51 = *(_QWORD *)(v14 + 1000);
          if ( *(_WORD *)(v51 + 2i64 * v50 + 12) == a5 )
            break;
          if ( ++v50 >= *(_DWORD *)(v51 + 8) )
            goto LABEL_17;
        }
        LODWORD(Flags) = a6;
        TimeStamp = &v58;
        v34 = (char *)EtwpReserveWithPmcCounters(v14, a5);// 正常设置Etw trace kernel 并不会走到这个地方！！要进行ETW配置
```

事实上，如果正常设置了ETW Logger syscall，就会走到这。这个函数的关键部分如下

```C++
mcData = LoggerContext->PmcData;
  v8 = *(_DWORD *)(PmcData + 20);
  v9 = 8 * (unsigned __int8)v8 + 16;
  v10 = v9 + AuxSize;
  CurrentIrql = KeGetCurrentIrql();
  if ( CurrentIrql < 2u )
  {
    v12 = KeGetCurrentIrql();
    __writecr8(2ui64);
    if ( KiIrqlFlags )
    {
      if ( (KiIrqlFlags & 1) != 0 && v12 <= 0xFu )
      {
        SchedulerAssist = KeGetCurrentPrcb()->SchedulerAssist;
        *(_DWORD *)(SchedulerAssist + 20) |= (-1 << (v12 + 1)) & 4;
      }
    }
  }
  v14 = EtwpReserveTraceBuffer((unsigned int *)LoggerContext, v10, (__int64)BufferHandle, TimeStamp, Flags);
  v15 = v14;
  if ( v14 )
  {
    *(LARGE_INTEGER *)(v14 + 8) = *TimeStamp;
    *(_WORD *)(v14 + 4) = v10;
    *(_WORD *)(v14 + 6) = HookId;
    *(_DWORD *)v14 = (unsigned __int8)Flags | ((unsigned __int8)v8 << 8) | 0xC0110000;
    v21 = *(struct _HAL_PMC_COUNTERS **)(PmcData + 8i64 * (unsigned int)KeGetPcr()->Prcb.Number + 24);
    if ( v21 )
      HalPrivateDispatchTable.HalCollectPmcCounters(v21, (unsigned __int64 *)(v14 + 16));
    else
      memset((void *)(v14 + 16), 0, 8i64 * (unsigned __int8)v8);
```

这个地方`HalPrivateDispatchTable.HalCollectPmcCounters(v21, (unsigned __int64 *)(v14 + 16));`就是可以替换的，也就是我们要替换`HalPrivateDispatchTable`的`HalCollectPmcCounters`.从而可以正常地接管syscall而不触发PG。

# 具体实现

具体实现上其实很简单，就是调用`ZwTraceControl`开启配置`NT Kernel Logger`，这些代码都很简单，大概步骤是

1. 偷指针，替换
2. 配置Nt Kernel Logger，开启ETW
3. **最麻烦的一步，如何设置PMCCounter开启，从而走到EtwpReserveWithPmcCounters**
4. 栈查找定位Syscall Routine
5. 替换你想HOOK的系统调用

上述所有步骤基本再第一版的`etw hook`里面都有代码，除了第三步。

而参考文章[1]中，对于这部分的描述是`the code has been omitted from this article.`，因此只能根据他给的寥寥信息逆向。好在最终逆出来了。

如果正常开启ETW,可以发现，`EtwpReserveWithPmcCounters`无法进入。我们可以看一下相关的判断：

![image-20240420200101609](ETWHOOK%20WIN11%E5%85%BC%E5%AE%B9%E7%89%88.assets/image-20240420200101609.png)

因此需要设置的是相关的位。这个位设置需要用到`NtSetSystemInfomation`(需要自己逆向)。

具体需要逆向的是部分在`EtwSetPerformanceTraceInformation`函数中的如下部分

![image-20240420200338164](ETWHOOK%20WIN11%E5%85%BC%E5%AE%B9%E7%89%88.assets/image-20240420200338164-1713614621292-3.png)

`EtwpUpdatePmcCounters`这个函数是分配`PmcData`同时开启`flag`;

`EtwpUpdatePmcEvents`是设置开启哪些hookid，比如syscall就是`0xf33`。最后可以用如下代码设置PmcCounter

```C++
/*其实这个要调用ZwSetSystemInfomation，但是没有找到合适的文档化和文章，故只能手动逆向windows，最终得出结果*/
NTSTATUS EtwInitilizer::open_pmc_counter()
{
	auto status = STATUS_SUCCESS;
	auto pmc_count_info = (PEVENT_TRACE_PROFILE_COUNTER_INFORMATION)(nullptr);
	auto pmc_event_info=(PEVENT_TRACE_SYSTEM_EVENT_INFORMATION)(nullptr);
	constexpr auto syscall_hookid = 0xf33ul;



	if (!__is_open) return STATUS_FLT_NOT_INITIALIZED;

	do {

		/*获取ckcl_context的loggerid*/
		auto EtwpDebuggerData=reinterpret_cast<ULONG***>( \
			kstd::SysInfoManager::getInstance()->getSysInfo()->EtwpDebuggerData);
		
		if (!EtwpDebuggerData) {
			status = STATUS_NOT_SUPPORTED;
			LOG_ERROR("failed to get EtwpDebuggerData!\r\n");
		}
		
		/*这个可以参考第一版的ETW HOOK，这里简写了*/
		auto logger_id = EtwpDebuggerData[2][2][0];

		pmc_count_info = kalloc<EVENT_TRACE_PROFILE_COUNTER_INFORMATION>(NonPagedPool);
		if (!pmc_count_info) {
			LOG_ERROR("failed to alloc memory for pmc_count!\r\n");
			status = STATUS_MEMORY_NOT_ALLOCATED;
			break;
		}
		//先设置PMC Count 我们只关心一个hookid 那就是syscall的hookid 0xf33 profile source 随便设置
		pmc_count_info->EventTraceInformationClass = EventTraceProfileCounterListInformation;
		pmc_count_info->TraceHandle = ULongToHandle(logger_id)/*这个其实就是loggerid*/;
		pmc_count_info->ProfileSource[0] = 1;/*随便填写*/

		status=ZwSetSystemInformation(SystemPerformanceTraceInformation, pmc_count_info, sizeof EVENT_TRACE_PROFILE_COUNTER_INFORMATION);
		if (!NT_SUCCESS(status)) {
			LOG_ERROR("failed to configure pmc counter,errcode=%x\r\n", status);
			break;
		}


		//然后设置PMC Event hookid只需要一个就行
		pmc_event_info = kalloc<EVENT_TRACE_SYSTEM_EVENT_INFORMATION>(NonPagedPool);
		if (!pmc_event_info) {
			LOG_ERROR("failed to alloc memory for pmc_event_info!\r\n");
			status = STATUS_MEMORY_NOT_ALLOCATED;
			break;
		}

		pmc_event_info->EventTraceInformationClass = EventTraceProfileEventListInformation;
		pmc_event_info->TraceHandle = ULongToHandle(logger_id);
		pmc_event_info->HookId[0] = syscall_hookid;/*必须0xf33*/


		status = ZwSetSystemInformation(SystemPerformanceTraceInformation, pmc_event_info, sizeof EVENT_TRACE_SYSTEM_EVENT_INFORMATION);
		if (!NT_SUCCESS(status)) {
			LOG_ERROR("failed to configure pmc event,errcode=%x\r\n", status);
			break;
		}

		
	} while (false);

	//clean up
	if (pmc_count_info) ExFreePool(pmc_count_info);
	if (pmc_event_info) ExFreePool(pmc_event_info);

	return status;
}
```

**这里还有个坑**，就是`EtwpUpdatePmcCounters`这个部分的代码如下

```C++
__int64 __fastcall EtwpUpdatePmcCounters(
        _WMI_LOGGER_CONTEXT *wmi_context,
        _KPROFILE_SOURCE *profile_array,
        unsigned int count)
{
  unsigned int v6; // r12d
  __int64 result; // rax
  _ETW_PMC_SUPPORT *PmcData; // r14
  __int64 i; // r8
  unsigned int v10; // r15d
  unsigned int cpu_idx; // edi
  __int64 j; // rsi
  signed __int32 unk_struct[22]; // [rsp+0h] [rbp-58h] BYREF

  v6 = KeNumberProcessors_0;
  if ( !count || count > EtwpMaxPmcCounter || wmi_context->PoolType == 1 )// 不能是PagedPool
    return 0xC000000Di64;
  if ( wmi_context->PmcData || (result = EtwpAllocatePmcData((__int64)wmi_context), !(_DWORD)result) )// 分配成功
  {
```

`count > EtwpMaxPmcCounter`这一个必须成立，我的虚拟机这个是1，也就是必须得强制改动这个值。

但是观察，我的物理机又是>1，这个全局变量比较难定位。暂时没有处理。

## 效果

最后效果如下

![image-20240420213841614](ETWHOOK%20WIN11%E5%85%BC%E5%AE%B9%E7%89%88.assets/image-20240420213841614.png)

# 参考

[1] Fun With Another PG-Compliant Hook https://revers.engineering/fun-with-pg-compliant-hook/

[2] 仿照EAC的全局异常Hook https://bbs.kanxue.com/thread-278475.htm
```