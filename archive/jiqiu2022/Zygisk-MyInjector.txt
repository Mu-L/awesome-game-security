Project Path: arc_jiqiu2022_Zygisk-MyInjector_dpzac4o4

Source Tree:

```txt
arc_jiqiu2022_Zygisk-MyInjector_dpzac4o4
├── LICENSE
├── README.md
├── assets
│   ├── CleanShot_2025_06_26_at_20_33_37-20250626203353-mvarjy3.png
│   ├── CleanShot_2025_06_26_at_20_36_35-20250626203644-vum10yb.png
│   ├── CleanShot_2025_06_26_at_20_37_10-20250626203718-fx50ptc.png
│   ├── CleanShot_2025_06_26_at_20_38_42-20250626203859-532f217.png
│   ├── CleanShot_2025_06_26_at_20_39_38-20250626204000-p3oe63m.png
│   ├── CleanShot_2025_06_26_at_20_40_50-20250626204056-cn1613i.png
│   ├── CleanShot_2025_06_26_at_20_41_17-20250626204121-6k6wqym.png
│   ├── CleanShot_2025_06_26_at_20_42_17-20250626204224-gylrvtd.png
│   ├── CleanShot_2025_06_26_at_20_43_27-20250626204331-wse9zyb.png
│   ├── CleanShot_2025_06_26_at_20_44_09-20250626204414-lov146o.png
│   ├── CleanShot_2025_06_26_at_20_44_19-20250626204426-2ubkjyi.png
│   ├── CleanShot_2025_06_26_at_20_46_07-20250626204610-d2o279q.png
│   ├── CleanShot_2025_06_26_at_20_46_45-20250626204649-sj0w84k.png
│   ├── CleanShot_2025_06_26_at_20_47_19-20250626204724-7dtm624.png
│   ├── CleanShot_2025_06_26_at_20_47_34-20250626204744-v9hdf53.png
│   └── auto_config.record.mp4
├── build.gradle
├── build_all.sh
├── configapp
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       ├── androidTest
│       │   └── java
│       │       └── com
│       │           └── jiqiu
│       │               └── configapp
│       │                   └── ExampleInstrumentedTest.java
│       ├── main
│       │   ├── AndroidManifest.xml
│       │   ├── java
│       │   │   └── com
│       │   │       └── jiqiu
│       │   │           └── configapp
│       │   │               ├── AppInfo.java
│       │   │               ├── AppListAdapter.java
│       │   │               ├── AppListFragment.java
│       │   │               ├── ConfigApplication.java
│       │   │               ├── ConfigApplyReceiver.java
│       │   │               ├── ConfigManager.java
│       │   │               ├── FileBrowserActivity.java
│       │   │               ├── FileUtils.java
│       │   │               ├── GadgetConfigDialog.java
│       │   │               ├── MainActivity.java
│       │   │               ├── SettingsFragment.java
│       │   │               ├── SoListAdapter.java
│       │   │               └── SoManagerFragment.java
│       │   └── res
│       │       ├── drawable
│       │       │   ├── ic_launcher_background.xml
│       │       │   ├── ic_launcher_foreground.xml
│       │       │   └── system_app_badge.xml
│       │       ├── layout
│       │       │   ├── activity_app_so_config.xml
│       │       │   ├── activity_file_browser.xml
│       │       │   ├── activity_main.xml
│       │       │   ├── dialog_app_config.xml
│       │       │   ├── dialog_gadget_config.xml
│       │       │   ├── dialog_input.xml
│       │       │   ├── fragment_app_list.xml
│       │       │   ├── fragment_settings.xml
│       │       │   ├── fragment_so_manager.xml
│       │       │   ├── item_app.xml
│       │       │   ├── item_file.xml
│       │       │   ├── item_so_file.xml
│       │       │   └── item_so_selection.xml
│       │       ├── menu
│       │       │   └── bottom_nav_menu.xml
│       │       ├── mipmap-anydpi-v26
│       │       │   ├── ic_launcher.xml
│       │       │   └── ic_launcher_round.xml
│       │       ├── mipmap-hdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-mdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xxhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xxxhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── values
│       │       │   ├── colors.xml
│       │       │   ├── strings.xml
│       │       │   └── themes.xml
│       │       └── values-night
│       │           └── themes.xml
│       └── test
│           └── java
│               └── com
│                   └── jiqiu
│                       └── configapp
│                           └── ExampleUnitTest.java
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── module
│   ├── build.gradle
│   ├── service.sh
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           └── cpp
│               ├── CMakeLists.txt
│               ├── config.cpp
│               ├── config.h
│               ├── game.h
│               ├── hack.cpp
│               ├── hack.h
│               ├── hack_new.cpp
│               ├── log.h
│               ├── main.cpp
│               ├── mylinker
│               │   ├── CMakeLists.txt
│               │   ├── elf_loader.cpp
│               │   ├── elf_reader.cpp
│               │   ├── include
│               │   │   ├── common.h
│               │   │   ├── elf_loader.h
│               │   │   ├── elf_reader.h
│               │   │   ├── memory_manager.h
│               │   │   ├── mylinker.h
│               │   │   ├── relocator.h
│               │   │   ├── soinfo_manager.h
│               │   │   └── utils.h
│               │   ├── main.cpp
│               │   ├── memory_manager.cpp
│               │   ├── mylinker.cpp
│               │   ├── relocator.cpp
│               │   ├── soinfo_manager.cpp
│               │   └── utils.cpp
│               ├── newriruhide.cpp
│               ├── newriruhide.h
│               ├── pmparser.cpp
│               ├── pmparser.h
│               ├── xdl
│               │   ├── include
│               │   │   └── xdl.h
│               │   ├── xdl.c
│               │   ├── xdl_iterate.c
│               │   ├── xdl_iterate.h
│               │   ├── xdl_linker.c
│               │   ├── xdl_linker.h
│               │   ├── xdl_lzma.c
│               │   ├── xdl_lzma.h
│               │   ├── xdl_util.c
│               │   └── xdl_util.h
│               └── zygisk.hpp
├── module.gradle
├── scripts
│   ├── README.md
│   └── auto_config.py
├── settings.gradle
└── template
    └── magisk_module
        ├── META-INF
        │   └── com
        │       └── google
        │           └── android
        │               ├── update-binary
        │               └── updater-script
        └── module.prop

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Rikka

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Zygisk注入器 - 动动手指轻松注入并隐藏你的SO文件

## 前言

作者在去年发布了[Zygisk注入模块的实现](https://bbs.kanxue.com/thread-283790.htm)，成功实现了模块的自动注入和Riru隐藏功能。

然而，每次更换目标应用都需要重新编译，操作繁琐，导致用户采用率不高。为了解决这个问题，作者对项目进行了全面重构，带来了以下改进：

- **图形化界面**：告别命令行，操作更直观
- **一键安装**：面具模块快速部署
- **配套管理APP**：轻松管理注入配置

项目已完全开源，包含面具模块、管理APP以及所有打包脚本，并配置了GitHub CI自动构建。欢迎各位开发者贡献代码，提交PR。

### 版本规划&更新记录
版本规划:
- **v1.x**：专注功能添加，暂不考虑反检测
- **v2.x**：实现各种检测绕过，达到100%无痕注入
  
更新记录:
- **v1.2**: 增加gadget配置的自动生成，支持脚本和server模式，解决了若干bug，增加了全局注入延迟设置

## 致谢
**项目地址**：[https://github.com/jiqiu2022/Zygisk-MyInjector](https://github.com/jiqiu2022/Zygisk-MyInjector)

特别感谢以下项目和开发者（按时间顺序）：

- [Zygisk-Il2CppDumper](https://github.com/Perfare/Zygisk-Il2CppDumper) - 提供最原始的注入思路
- Riru - 提供隐藏思路
- 小佳大佬 - 提供App界面化的思路
- [soLoader](https://github.com/SoyBeanMilkx/soLoader) - 提供自定义linker注入的全部逻辑，期待认识作者和作者一起继续完善

如果对自定义linker感兴趣的大佬，推荐soLoader作者的文章https://yuuki.cool/2025/06/15/CustomLinker/

## 使用教程

### 步骤一：下载并安装面具模块

1. 前往 [GitHub Release](https://github.com/jiqiu2022/Zygisk-MyInjector/tags) 页面下载最新版本的面具模块
   
   本教程以 [v1.1.0](https://github.com/jiqiu2022/Zygisk-MyInjector/releases/tag/v1.1.0) 版本为例

2. 下载模块文件（如下图所示）：

   ![CleanShot_2025_06_26_at_20_33_37](assets/CleanShot_2025_06_26_at_20_33_37-20250626203353-mvarjy3.png)

3. 安装到手机，支持所有面具模块相关的APP（如 KernelSU、APatch 等）

> **注意**：如果您的APP不支持Zygisk注入，请额外安装 Zygisk-Next 模块，否则可能导致注入失败。

### 步骤二：准备SO文件并配置

#### 1. 添加SO文件

进入"SO文件管理"，点击"增加SO文件"：

![CleanShot_2025_06_26_at_20_36_35](assets/CleanShot_2025_06_26_at_20_36_35-20250626203644-vum10yb.png)

选择要注入的SO文件：

![CleanShot_2025_06_26_at_20_37_10](assets/CleanShot_2025_06_26_at_20_37_10-20250626203718-fx50ptc.png)

本教程使用以下两个SO文件进行测试：
- `libmylib.so`（全注入测试）
- `libgadget.so`（普通注入方式）

> **提示**：后文将解释为什么自定义linker无法注入 `libgadget.so`。

#### 2. 处理原文件

选择SO后，系统会询问是否删除原文件：

![CleanShot_2025_06_26_at_20_38_42](assets/CleanShot_2025_06_26_at_20_38_42-20250626203859-532f217.png)

> **设计理念**：此功能可防止某些APP扫描tmp目录中的SO文件进行风控检测。

添加成功后，SO管理界面会显示已添加的文件：

![CleanShot_2025_06_26_at_20_39_38](assets/CleanShot_2025_06_26_at_20_39_38-20250626204000-p3oe63m.png)

### 步骤三：配置目标APP

本教程以珍惜大佬的Hunter为例演示配置过程。

1. 点击空白处，配置注入参数：

   ![CleanShot_2025_06_26_at_20_40_50](assets/CleanShot_2025_06_26_at_20_40_50-20250626204056-cn1613i.png)

2. 保存配置后，开启注入开关：

   ![CleanShot_2025_06_26_at_20_41_17](assets/CleanShot_2025_06_26_at_20_41_17-20250626204121-6k6wqym.png)

### 步骤四：验证注入效果

打开目标APP，查看日志输出：

![CleanShot_2025_06_26_at_20_42_17](assets/CleanShot_2025_06_26_at_20_42_17-20250626204224-gylrvtd.png)

成功打印"我已经成功加载"，表明注入成功。

#### 测试Gadget注入

切换到gadget进行测试：

![CleanShot_2025_06_26_at_20_43_27](assets/CleanShot_2025_06_26_at_20_43_27-20250626204331-wse9zyb.png)

> **特性**：本注入模块支持同时注入多个SO文件。

![CleanShot_2025_06_26_at_20_44_09](assets/CleanShot_2025_06_26_at_20_44_09-20250626204414-lov146o.png)

注入成功：

![CleanShot_2025_06_26_at_20_44_19](assets/CleanShot_2025_06_26_at_20_44_19-20250626204426-2ubkjyi.png)

> **说明**：由于使用的Hunter版本较旧，可能无法检测到注入。建议使用新版本进行测试。

#### 测试其他注入方式

测试Riru Hide功能：

![CleanShot_2025_06_26_at_20_46_07](assets/CleanShot_2025_06_26_at_20_46_07-20250626204610-d2o279q.png)

> **提示**：修改配置后，建议先关闭再开启注入开关，确保新配置生效。

![CleanShot_2025_06_26_at_20_46_45](assets/CleanShot_2025_06_26_at_20_46_45-20250626204649-sj0w84k.png)

Riru Hide成功生效。

测试自定义Linker加载：

![CleanShot_2025_06_26_at_20_47_19](assets/CleanShot_2025_06_26_at_20_47_19-20250626204724-7dtm624.png)

加载成功：

![CleanShot_2025_06_26_at_20_47_34](assets/CleanShot_2025_06_26_at_20_47_34-20250626204744-v9hdf53.png)

### 自动化注入

[脚本](./scripts/auto_config.py) 实现了针对 libgadget.so 的自动注入

```bash
# 1. 运行自动配置脚本（会自动检查并设置 SELinux）
cd scripts
./auto_config.py

# 2. 按提示选择设备、应用和配置（全部使用默认值即可）
#    脚本会自动完成：
#    - 生成配置文件
#    - 推送到设备
#    - 应用配置
#    - 重启应用
#    - 端口转发
#    - 快速测试

# 3. 如果测试成功，直接使用 Frida 连接
frida -H 127.0.0.1:27042 Gadget -l your_script.js
```

见 [视频](assets/auto_config.record.mp4)

## 编译指南

### 自动编译

参考项目中的 [CI配置文件](https://github.com/jiqiu2022/Zygisk-MyInjector/blob/main/.github/workflows/ci.yml)。

如果您fork了本项目，只需在本地修改代码并push，云端将自动编译。

### 本地编译

使用项目提供的 `build_all.sh` 脚本进行编译。

> **环境要求**：需要Java 17环境。

## 工作原理

### 注入流程详解

1. **SO文件管理**
   - 用户选择SO文件后，APP自动将其复制到 `/data/adb/modules/module-name` 目录下进行统一管理
2. **配置生成**
   - 完成APP配置后，管理器在 `/data/adb/modules/module-name` 下创建config文件
   - 面具模块启动时读取此配置，执行SO加载
3. **注入激活**
   - 开启注入时：APP将管理器中的SO复制到目标APP目录，并将config状态设置为开启
   - 关闭注入时：APP自动删除已复制的SO文件，将config状态设置为关闭
## 为什么自定义linker不能注入gadget

```
frida_KjnwyG_detect_location: assertion failed: (our_range != null)
Bail out! Frida:ERROR:../lib/KjnwyG/KjnwyG.vala:809:frida_KjnwyG_detect_location: assertion failed: (our_range != null)
Aborted
```

因为gadget的init_array里面其中有一个函数，尝试使用maps和soinfo获取到自己模块的信息，防止递归调用。

但是自定义linker的soinfo和内存段都是自己分配的，导致gadget找不到自己，发生了断言失败，我们可以简单的去掉断言，但是可能造成其他bug，后续作者会和小佳一起修复。

当然还有一种复杂的方法，就是用注入的so的soinfo，替换成要注入的so的，多见于360等壳子，等后续作者会实现。



## 后续更新计划

- **深度隐藏**：联动内核模块，提供maps等更深层次的隐藏功能
- **用户体验优化**：
  - 增加gadget配置一键生成功能
  - 提供更友好的界面交互
  - 支持批量配置管理

---

欢迎关注项目进展，期待您的贡献！

```

`build.gradle`:

```gradle
apply plugin: 'idea'

idea.module {
    excludeDirs += file('out')
    resourceDirs += file('template')
    resourceDirs += file('scripts')
}

buildscript {
    repositories {
        mavenCentral()
        google()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:7.4.2'
    }
}

allprojects {
    repositories {
        mavenCentral()
        google()
        maven { url 'https://jitpack.io' }
    }
}

ext {
    minSdkVersion = 23
    targetSdkVersion = 32

    outDir = file("$rootDir/out")
}

task clean(type: Delete) {
    delete rootProject.buildDir, outDir
}

```

`build_all.sh`:

```sh
#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 模块信息
MODULE_ID="zygisk-myinjector"
MODULE_VERSION="1.0"
MODULE_VERSION_CODE="100"

echo -e "${GREEN}========================================${NC}"
echo -e "${GREEN}  Zygisk MyInjector 构建脚本${NC}"
echo -e "${GREEN}========================================${NC}"

# 清理之前的构建
echo -e "\n${YELLOW}[1/5] 清理旧构建文件...${NC}"
rm -rf build/magisk_module
rm -f build/*.zip
mkdir -p build

# 构建 ConfigApp
echo -e "\n${YELLOW}[2/5] 构建 ConfigApp...${NC}"
cd configapp
if ../gradlew assembleDebug; then
    echo -e "${GREEN}✓ ConfigApp 构建成功${NC}"
    cd ..
else
    echo -e "${RED}✗ ConfigApp 构建失败${NC}"
    cd ..
    exit 1
fi

# 构建 Magisk 模块
echo -e "\n${YELLOW}[3/5] 构建 Magisk 模块原生库...${NC}"
cd module
if ../gradlew assembleRelease; then
    echo -e "${GREEN}✓ 模块原生库构建成功${NC}"
    cd ..
else
    echo -e "${RED}✗ 模块原生库构建失败${NC}"
    cd ..
    exit 1
fi

# 准备打包
echo -e "\n${YELLOW}[4/5] 准备打包文件...${NC}"

# 创建临时目录
TEMP_DIR="build/magisk_module"
mkdir -p $TEMP_DIR

# 创建 module.prop
cat > $TEMP_DIR/module.prop << EOF
id=$MODULE_ID
name=Zygisk MyInjector
version=v$MODULE_VERSION
versionCode=$MODULE_VERSION_CODE
author=jiqiu
description=A Zygisk module for dynamic library injection with ConfigApp
EOF
echo -e "  ${GREEN}✓ 创建 module.prop${NC}"

# 复制 service.sh
if [ -f "module/service.sh" ]; then
    cp module/service.sh $TEMP_DIR/
    chmod 755 $TEMP_DIR/service.sh
    echo -e "  ${GREEN}✓ 复制 service.sh${NC}"
else
    echo -e "  ${RED}✗ 未找到 service.sh${NC}"
fi

# 创建 zygisk 目录并复制 so 文件
mkdir -p $TEMP_DIR/zygisk
SO_COUNT=0

# 查找并复制 so 文件
for arch in armeabi-v7a arm64-v8a x86 x86_64; do
    SO_PATH="module/build/intermediates/stripped_native_libs/release/out/lib/$arch/libmyinjector.so"
    if [ -f "$SO_PATH" ]; then
        cp "$SO_PATH" "$TEMP_DIR/zygisk/$arch.so"
        echo -e "  ${GREEN}✓ 复制 $arch.so${NC}"
        ((SO_COUNT++))
    fi
done

if [ $SO_COUNT -eq 0 ]; then
    echo -e "  ${RED}✗ 未找到任何 SO 文件${NC}"
    exit 1
fi

# 复制 ConfigApp APK
APK_PATH="configapp/build/outputs/apk/debug/configapp-debug.apk"
if [ -f "$APK_PATH" ]; then
    cp "$APK_PATH" "$TEMP_DIR/configapp.apk"
    echo -e "  ${GREEN}✓ 复制 ConfigApp APK${NC}"
    
    # 显示 APK 信息
    APK_SIZE=$(du -h "$APK_PATH" | cut -f1)
    echo -e "    APK 大小: $APK_SIZE"
else
    echo -e "  ${RED}✗ 未找到 ConfigApp APK${NC}"
    exit 1
fi

# 复制 META-INF 目录（Magisk 需要）
if [ -d "template/magisk_module/META-INF" ]; then
    cp -r template/magisk_module/META-INF $TEMP_DIR/
    echo -e "  ${GREEN}✓ 复制 META-INF${NC}"
else
    echo -e "  ${RED}✗ 未找到 META-INF 模板${NC}"
    exit 1
fi

# 打包
echo -e "\n${YELLOW}[5/5] 打包模块...${NC}"
ZIP_NAME="${MODULE_ID}-${MODULE_VERSION}.zip"
cd $TEMP_DIR
zip -r ../$ZIP_NAME * -x "*.DS_Store" > /dev/null 2>&1
cd ../..

# 显示结果
echo -e "\n${GREEN}========================================${NC}"
echo -e "${GREEN}✓ 构建完成！${NC}"
echo -e "${GREEN}========================================${NC}"
echo -e "\n模块文件: ${GREEN}build/$ZIP_NAME${NC}"

# 显示模块内容
echo -e "\n模块内容:"
unzip -l build/$ZIP_NAME | grep -E "(\.so|\.apk|\.prop|\.sh)" | while read line; do
    echo -e "  $line"
done

# 显示模块大小
MODULE_SIZE=$(du -h build/$ZIP_NAME | cut -f1)
echo -e "\n模块大小: ${GREEN}$MODULE_SIZE${NC}"

# 安装说明
echo -e "\n${YELLOW}安装方法:${NC}"
echo -e "  1. 将模块传输到手机:"
echo -e "     ${GREEN}adb push build/$ZIP_NAME /sdcard/${NC}"
echo -e "  2. 在 Magisk Manager 中安装模块"
echo -e "  3. 重启手机"
echo -e "\n${YELLOW}验证安装:${NC}"
echo -e "  ${GREEN}adb shell pm list packages | grep com.jiqiu.configapp${NC}"
echo -e "  ${GREEN}adb shell cat /data/local/tmp/myinjector_install.log${NC}"

# 可选：直接安装到设备
if [ "$1" == "--install" ]; then
    echo -e "\n${YELLOW}正在安装到设备...${NC}"
    adb push build/$ZIP_NAME /data/local/tmp/
    adb shell su -c "magisk --install-module /data/local/tmp/$ZIP_NAME"
    echo -e "${GREEN}✓ 安装完成，请重启设备${NC}"
fi
```

`configapp/build.gradle`:

```gradle
plugins {
    id 'com.android.application'
}

android {
    namespace 'com.jiqiu.configapp'
    compileSdk 34

    packagingOptions {
        jniLibs {
            useLegacyPackaging = true
        }
    }

    defaultConfig {
        applicationId "com.jiqiu.configapp"
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
        coreLibraryDesugaringEnabled false
    }
}

dependencies {

    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.10.0'
    implementation 'androidx.activity:activity:1.8.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'

    // Fragment and Navigation dependencies
    implementation 'androidx.fragment:fragment:1.6.2'
    implementation 'androidx.navigation:navigation-fragment:2.7.5'
    implementation 'androidx.navigation:navigation-ui:2.7.5'

    // RecyclerView for app list
    implementation 'androidx.recyclerview:recyclerview:1.3.2'
    
    // Root access library
    implementation 'com.github.topjohnwu.libsu:core:6.0.0'
    
    // JSON parsing
    implementation 'com.google.code.gson:gson:2.10.1'

    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
}
```

`configapp/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

`configapp/src/androidTest/java/com/jiqiu/configapp/ExampleInstrumentedTest.java`:

```java
package com.jiqiu.configapp;

import android.content.Context;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import static org.junit.Assert.*;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Test
    public void useAppContext() {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
        assertEquals("com.jiqiu.configapp", appContext.getPackageName());
    }
}
```

`configapp/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- 查询已安装应用的权限 -->
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES" />

    <application
        android:name=".ConfigApplication"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.ZygiskMyInjector">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        
        <activity
            android:name=".FileBrowserActivity"
            android:parentActivityName=".MainActivity" />
    </application>

</manifest>

```

`configapp/src/main/java/com/jiqiu/configapp/AppInfo.java`:

```java
package com.jiqiu.configapp;

import android.graphics.drawable.Drawable;

/**
 * 应用程序信息数据模型
 */
public class AppInfo {
    private String appName;        // 应用名称
    private String packageName;    // 包名
    private Drawable appIcon;      // 应用图标
    private boolean isSystemApp;   // 是否为系统应用
    private boolean isEnabled;     // 是否启用注入

    public AppInfo(String appName, String packageName, Drawable appIcon, boolean isSystemApp) {
        this.appName = appName;
        this.packageName = packageName;
        this.appIcon = appIcon;
        this.isSystemApp = isSystemApp;
        this.isEnabled = false; // 默认不启用注入
    }

    // Getter 和 Setter 方法
    public String getAppName() {
        return appName;
    }

    public void setAppName(String appName) {
        this.appName = appName;
    }

    public String getPackageName() {
        return packageName;
    }

    public void setPackageName(String packageName) {
        this.packageName = packageName;
    }

    public Drawable getAppIcon() {
        return appIcon;
    }

    public void setAppIcon(Drawable appIcon) {
        this.appIcon = appIcon;
    }

    public boolean isSystemApp() {
        return isSystemApp;
    }

    public void setSystemApp(boolean systemApp) {
        isSystemApp = systemApp;
    }

    public boolean isEnabled() {
        return isEnabled;
    }

    public void setEnabled(boolean enabled) {
        isEnabled = enabled;
    }

    @Override
    public String toString() {
        return "AppInfo{" +
                "appName='" + appName + '\'' +
                ", packageName='" + packageName + '\'' +
                ", isSystemApp=" + isSystemApp +
                ", isEnabled=" + isEnabled +
                '}';
    }
}

```

`configapp/src/main/java/com/jiqiu/configapp/AppListAdapter.java`:

```java
package com.jiqiu.configapp;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.google.android.material.switchmaterial.SwitchMaterial;

import java.util.ArrayList;
import java.util.List;

/**
 * 应用列表适配器
 */
public class AppListAdapter extends RecyclerView.Adapter<AppListAdapter.AppViewHolder> {
    
    private List<AppInfo> appList;
    private List<AppInfo> filteredAppList;
    private OnAppToggleListener onAppToggleListener;
    private OnAppClickListener onAppClickListener;
    
    public interface OnAppToggleListener {
        void onAppToggle(AppInfo appInfo, boolean isEnabled);
    }
    
    public interface OnAppClickListener {
        void onAppClick(AppInfo appInfo);
    }
    
    public AppListAdapter() {
        this.appList = new ArrayList<>();
        this.filteredAppList = new ArrayList<>();
    }
    
    public void setAppList(List<AppInfo> appList) {
        this.appList = appList;
        this.filteredAppList = new ArrayList<>(appList);
        notifyDataSetChanged();
    }
    
    public void setOnAppToggleListener(OnAppToggleListener listener) {
        this.onAppToggleListener = listener;
    }
    
    public void setOnAppClickListener(OnAppClickListener listener) {
        this.onAppClickListener = listener;
    }
    
    public void filterApps(String query, boolean hideSystemApps) {
        filteredAppList.clear();
        
        for (AppInfo app : appList) {
            // 过滤系统应用
            if (hideSystemApps && app.isSystemApp()) {
                continue;
            }
            
            // 搜索过滤
            if (query == null || query.isEmpty() || 
                app.getAppName().toLowerCase().contains(query.toLowerCase()) ||
                app.getPackageName().toLowerCase().contains(query.toLowerCase())) {
                filteredAppList.add(app);
            }
        }
        
        notifyDataSetChanged();
    }
    
    @NonNull
    @Override
    public AppViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_app, parent, false);
        return new AppViewHolder(view);
    }
    
    @Override
    public void onBindViewHolder(@NonNull AppViewHolder holder, int position) {
        AppInfo appInfo = filteredAppList.get(position);
        holder.bind(appInfo);
    }
    
    @Override
    public int getItemCount() {
        return filteredAppList.size();
    }
    
    class AppViewHolder extends RecyclerView.ViewHolder {
        private ImageView appIcon;
        private TextView appName;
        private TextView packageName;
        private TextView systemAppLabel;
        private SwitchMaterial switchEnable;
        
        public AppViewHolder(@NonNull View itemView) {
            super(itemView);
            appIcon = itemView.findViewById(R.id.app_icon);
            appName = itemView.findViewById(R.id.app_name);
            packageName = itemView.findViewById(R.id.package_name);
            systemAppLabel = itemView.findViewById(R.id.system_app_label);
            switchEnable = itemView.findViewById(R.id.switch_enable);
        }
        
        public void bind(AppInfo appInfo) {
            appIcon.setImageDrawable(appInfo.getAppIcon());
            appName.setText(appInfo.getAppName());
            packageName.setText(appInfo.getPackageName());
            
            // 显示系统应用标签
            if (appInfo.isSystemApp()) {
                systemAppLabel.setVisibility(View.VISIBLE);
            } else {
                systemAppLabel.setVisibility(View.GONE);
            }
            
            // 设置开关状态
            switchEnable.setOnCheckedChangeListener(null); // 清除之前的监听器
            switchEnable.setChecked(appInfo.isEnabled());
            
            // 设置开关监听器
            switchEnable.setOnCheckedChangeListener((buttonView, isChecked) -> {
                appInfo.setEnabled(isChecked);
                if (onAppToggleListener != null) {
                    onAppToggleListener.onAppToggle(appInfo, isChecked);
                }
            });
            
            // 设置整个item的点击监听器
            itemView.setOnClickListener(v -> {
                if (onAppClickListener != null) {
                    onAppClickListener.onAppClick(appInfo);
                }
            });
        }
    }
}

```

`configapp/src/main/java/com/jiqiu/configapp/AppListFragment.java`:

```java
package com.jiqiu.configapp;

import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.AsyncTask;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ProgressBar;
import android.app.Dialog;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.google.android.material.textfield.TextInputEditText;
import com.google.android.material.dialog.MaterialAlertDialogBuilder;
import com.google.android.material.switchmaterial.SwitchMaterial;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/**
 * 应用列表Fragment
 */
public class AppListFragment extends Fragment implements AppListAdapter.OnAppToggleListener, AppListAdapter.OnAppClickListener {
    
    private RecyclerView recyclerView;
    private AppListAdapter adapter;
    private TextInputEditText searchEditText;
    private ProgressBar progressBar;
    
    private List<AppInfo> allApps;
    private boolean hideSystemApps = false;
    private ConfigManager configManager;
    
    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, 
                           @Nullable Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_app_list, container, false);
    }
    
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        
        configManager = new ConfigManager(requireContext());
        // Ensure module directories exist
        configManager.ensureModuleDirectories();
        
        initViews(view);
        setupRecyclerView();
        setupSearchView();
        loadApps();
    }
    
    private void initViews(View view) {
        recyclerView = view.findViewById(R.id.recycler_view_apps);
        searchEditText = view.findViewById(R.id.search_edit_text);
        progressBar = view.findViewById(R.id.progress_bar);
    }
    
    private void setupRecyclerView() {
        adapter = new AppListAdapter();
        adapter.setOnAppToggleListener(this);
        adapter.setOnAppClickListener(this);
        recyclerView.setLayoutManager(new LinearLayoutManager(getContext()));
        recyclerView.setAdapter(adapter);
    }
    
    private void setupSearchView() {
        searchEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
            
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
                filterApps(s.toString());
            }
            
            @Override
            public void afterTextChanged(Editable s) {}
        });
    }
    
    private void loadApps() {
        progressBar.setVisibility(View.VISIBLE);
        recyclerView.setVisibility(View.GONE);
        
        new LoadAppsTask().execute();
    }
    
    private void filterApps(String query) {
        if (adapter != null) {
            adapter.filterApps(query, hideSystemApps);
        }
    }
    
    public void setHideSystemApps(boolean hideSystemApps) {
        this.hideSystemApps = hideSystemApps;
        filterApps(searchEditText.getText().toString());
    }
    
    @Override
    public void onAppToggle(AppInfo appInfo, boolean isEnabled) {
        // 保存应用的启用状态到配置文件
        configManager.setAppEnabled(appInfo.getPackageName(), isEnabled);
        android.util.Log.d("AppListFragment", 
            "App " + appInfo.getAppName() + " toggle: " + isEnabled);
    }
    
    @Override
    public void onAppClick(AppInfo appInfo) {
        showAppConfigDialog(appInfo);
    }
    
    private void showAppConfigDialog(AppInfo appInfo) {
        View dialogView = LayoutInflater.from(getContext()).inflate(R.layout.dialog_app_config, null);
        
        // Set app info
        ImageView appIcon = dialogView.findViewById(R.id.appIcon);
        TextView appName = dialogView.findViewById(R.id.appName);
        TextView packageName = dialogView.findViewById(R.id.packageName);
        RecyclerView soListRecyclerView = dialogView.findViewById(R.id.soListRecyclerView);
        TextView emptyText = dialogView.findViewById(R.id.emptyText);
        RadioGroup injectionMethodGroup = dialogView.findViewById(R.id.injectionMethodGroup);
        RadioButton radioStandardInjection = dialogView.findViewById(R.id.radioStandardInjection);
        RadioButton radioRiruInjection = dialogView.findViewById(R.id.radioRiruInjection);
        RadioButton radioCustomLinkerInjection = dialogView.findViewById(R.id.radioCustomLinkerInjection);
        RadioGroup gadgetConfigGroup = dialogView.findViewById(R.id.gadgetConfigGroup);
        RadioButton radioNoGadget = dialogView.findViewById(R.id.radioNoGadget);
        RadioButton radioUseGlobalGadget = dialogView.findViewById(R.id.radioUseGlobalGadget);
        RadioButton radioUseCustomGadget = dialogView.findViewById(R.id.radioUseCustomGadget);
        TextView tvGlobalGadgetInfo = dialogView.findViewById(R.id.tvGlobalGadgetInfo);
        com.google.android.material.button.MaterialButton btnConfigureGadget = dialogView.findViewById(R.id.btnConfigureGadget);
        
        appIcon.setImageDrawable(appInfo.getAppIcon());
        appName.setText(appInfo.getAppName());
        packageName.setText(appInfo.getPackageName());
        
        // Load current config
        String injectionMethod = configManager.getAppInjectionMethod(appInfo.getPackageName());
        if ("custom_linker".equals(injectionMethod)) {
            radioCustomLinkerInjection.setChecked(true);
        } else if ("riru".equals(injectionMethod)) {
            radioRiruInjection.setChecked(true);
        } else {
            radioStandardInjection.setChecked(true);
        }
        
        // Load gadget config
        boolean useGlobalGadget = configManager.getAppUseGlobalGadget(appInfo.getPackageName());
        ConfigManager.GadgetConfig appSpecificGadget = configManager.getAppGadgetConfig(appInfo.getPackageName());
        ConfigManager.GadgetConfig globalGadget = configManager.getGlobalGadgetConfig();
        
        // Update global gadget info
        if (globalGadget != null) {
            String info = "全局: " + globalGadget.gadgetName;
            if (globalGadget.mode.equals("server")) {
                info += " (端口: " + globalGadget.port + ")";
            }
            tvGlobalGadgetInfo.setText(info);
        } else {
            tvGlobalGadgetInfo.setText("未配置全局Gadget");
        }
        
        // Set initial radio selection
        if (!useGlobalGadget && appSpecificGadget != null) {
            radioUseCustomGadget.setChecked(true);
            btnConfigureGadget.setVisibility(View.VISIBLE);
            btnConfigureGadget.setEnabled(true);
        } else if (useGlobalGadget && globalGadget != null) {
            radioUseGlobalGadget.setChecked(true);
            btnConfigureGadget.setVisibility(View.GONE);
        } else {
            radioNoGadget.setChecked(true);
            btnConfigureGadget.setVisibility(View.GONE);
        }
        
        // Setup gadget radio group listener
        gadgetConfigGroup.setOnCheckedChangeListener((group, checkedId) -> {
            if (checkedId == R.id.radioNoGadget) {
                btnConfigureGadget.setVisibility(View.GONE);
                configManager.setAppUseGlobalGadget(appInfo.getPackageName(), false);
                configManager.setAppGadgetConfig(appInfo.getPackageName(), null);
            } else if (checkedId == R.id.radioUseGlobalGadget) {
                btnConfigureGadget.setVisibility(View.GONE);
                configManager.setAppUseGlobalGadget(appInfo.getPackageName(), true);
                configManager.setAppGadgetConfig(appInfo.getPackageName(), null);
            } else if (checkedId == R.id.radioUseCustomGadget) {
                btnConfigureGadget.setVisibility(View.VISIBLE);
                btnConfigureGadget.setEnabled(true);
                configManager.setAppUseGlobalGadget(appInfo.getPackageName(), false);
            }
        });
        
        // Configure button listener
        btnConfigureGadget.setOnClickListener(v -> {
            ConfigManager.GadgetConfig currentConfig = null;
            if (!useGlobalGadget) {
                currentConfig = configManager.getAppGadgetConfig(appInfo.getPackageName());
            }
            if (currentConfig == null) {
                currentConfig = new ConfigManager.GadgetConfig();
            }
            
            GadgetConfigDialog dialog = new GadgetConfigDialog(
                getContext(),
                "配置" + appInfo.getAppName() + "的Gadget",
                currentConfig,
                config -> {
                    configManager.setAppUseGlobalGadget(appInfo.getPackageName(), false);
                    configManager.setAppGadgetConfig(appInfo.getPackageName(), config);
                }
            );
            dialog.show();
        });
        
        // Setup SO list
        List<ConfigManager.SoFile> globalSoFiles = configManager.getAllSoFiles();
        List<ConfigManager.SoFile> appSoFiles = configManager.getAppSoFiles(appInfo.getPackageName());
        
        if (globalSoFiles.isEmpty()) {
            emptyText.setVisibility(View.VISIBLE);
            soListRecyclerView.setVisibility(View.GONE);
        } else {
            emptyText.setVisibility(View.GONE);
            soListRecyclerView.setVisibility(View.VISIBLE);
            
            SoSelectionAdapter soAdapter = new SoSelectionAdapter(globalSoFiles, appSoFiles);
            soListRecyclerView.setLayoutManager(new LinearLayoutManager(getContext()));
            soListRecyclerView.setAdapter(soAdapter);
        }
        
        // Create dialog
        MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder(getContext())
                .setTitle("配置注入")
                .setView(dialogView)
                .setPositiveButton("保存", (dialog, which) -> {
                    // Save injection method
                    String selectedMethod;
                    if (radioCustomLinkerInjection.isChecked()) {
                        selectedMethod = "custom_linker";
                    } else if (radioRiruInjection.isChecked()) {
                        selectedMethod = "riru";
                    } else {
                        selectedMethod = "standard";
                    }
                    configManager.setAppInjectionMethod(appInfo.getPackageName(), selectedMethod);
                    
                    // Save SO selection
                    if (soListRecyclerView.getAdapter() != null) {
                        SoSelectionAdapter adapter = (SoSelectionAdapter) soListRecyclerView.getAdapter();
                        List<ConfigManager.SoFile> selectedSoFiles = adapter.getSelectedSoFiles();
                        
                        // Clear existing SO files for this app
                        for (ConfigManager.SoFile existingSo : appSoFiles) {
                            configManager.removeSoFileFromApp(appInfo.getPackageName(), existingSo);
                        }
                        
                        // Add selected SO files
                        for (ConfigManager.SoFile soFile : selectedSoFiles) {
                            configManager.addSoFileToApp(appInfo.getPackageName(), soFile);
                        }
                    }
                })
                .setNegativeButton("取消", null);
        
        builder.show();
    }
    
    // Inner class for SO selection adapter
    private static class SoSelectionAdapter extends RecyclerView.Adapter<SoSelectionAdapter.ViewHolder> {
        private List<ConfigManager.SoFile> globalSoFiles;
        private List<ConfigManager.SoFile> selectedSoFiles;
        
        public SoSelectionAdapter(List<ConfigManager.SoFile> globalSoFiles, List<ConfigManager.SoFile> appSoFiles) {
            this.globalSoFiles = globalSoFiles;
            this.selectedSoFiles = new ArrayList<>(appSoFiles);
        }
        
        public List<ConfigManager.SoFile> getSelectedSoFiles() {
            return new ArrayList<>(selectedSoFiles);
        }
        
        @NonNull
        @Override
        public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
            View view = LayoutInflater.from(parent.getContext())
                    .inflate(R.layout.item_so_selection, parent, false);
            return new ViewHolder(view);
        }
        
        @Override
        public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
            ConfigManager.SoFile soFile = globalSoFiles.get(position);
            holder.bind(soFile, selectedSoFiles);
        }
        
        @Override
        public int getItemCount() {
            return globalSoFiles.size();
        }
        
        class ViewHolder extends RecyclerView.ViewHolder {
            CheckBox checkBox;
            TextView nameText;
            TextView pathText;
            
            ViewHolder(@NonNull View itemView) {
                super(itemView);
                checkBox = itemView.findViewById(R.id.checkBox);
                nameText = itemView.findViewById(R.id.textName);
                pathText = itemView.findViewById(R.id.textPath);
            }
            
            void bind(ConfigManager.SoFile soFile, List<ConfigManager.SoFile> selectedList) {
                nameText.setText(soFile.name);
                pathText.setText(soFile.originalPath);
                
                // Check if this SO is selected
                boolean isSelected = false;
                for (ConfigManager.SoFile selected : selectedList) {
                    if (selected.storedPath.equals(soFile.storedPath)) {
                        isSelected = true;
                        break;
                    }
                }
                
                checkBox.setOnCheckedChangeListener(null);
                checkBox.setChecked(isSelected);
                
                checkBox.setOnCheckedChangeListener((buttonView, isChecked) -> {
                    if (isChecked) {
                        selectedList.add(soFile);
                    } else {
                        selectedList.removeIf(s -> s.storedPath.equals(soFile.storedPath));
                    }
                });
                
                itemView.setOnClickListener(v -> checkBox.toggle());
            }
        }
    }
    
    /**
     * 异步加载应用列表
     */
    private class LoadAppsTask extends AsyncTask<Void, Void, List<AppInfo>> {
        
        @Override
        protected List<AppInfo> doInBackground(Void... voids) {
            List<AppInfo> apps = new ArrayList<>();
            PackageManager pm = getContext().getPackageManager();
            
            List<ApplicationInfo> installedApps = pm.getInstalledApplications(PackageManager.GET_META_DATA);
            
            for (ApplicationInfo appInfo : installedApps) {
                try {
                    String appName = pm.getApplicationLabel(appInfo).toString();
                    String packageName = appInfo.packageName;
                    boolean isSystemApp = (appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
                    
                    AppInfo app = new AppInfo(
                        appName,
                        packageName,
                        pm.getApplicationIcon(appInfo),
                        isSystemApp
                    );
                    
                    // 从配置中加载启用状态
                    app.setEnabled(configManager.isAppEnabled(packageName));
                    
                    apps.add(app);
                } catch (Exception e) {
                    // 忽略无法获取信息的应用
                    e.printStackTrace();
                }
            }
            
            // 按应用名称排序
            Collections.sort(apps, new Comparator<AppInfo>() {
                @Override
                public int compare(AppInfo o1, AppInfo o2) {
                    return o1.getAppName().compareToIgnoreCase(o2.getAppName());
                }
            });
            
            return apps;
        }
        
        @Override
        protected void onPostExecute(List<AppInfo> apps) {
            allApps = apps;
            adapter.setAppList(apps);
            
            progressBar.setVisibility(View.GONE);
            recyclerView.setVisibility(View.VISIBLE);
            
            // 应用当前的过滤设置
            filterApps(searchEditText.getText().toString());
        }
    }
}

```

`configapp/src/main/java/com/jiqiu/configapp/ConfigApplication.java`:

```java
package com.jiqiu.configapp;

import android.annotation.SuppressLint;
import android.app.Application;
import android.content.Context;
import android.content.IntentFilter;
import android.os.Build;
import android.util.Log;

/**
 * Application class for dynamic receiver registration
 * 动态注册 BroadcastReceiver，避免被第三方 app 发现
 */
public class ConfigApplication extends Application {
    private static final String TAG = "ConfigApplication";
    private static final String ACTION_APPLY_CONFIG = "com.jiqiu.configapp.APPLY_CONFIG";
    
    private ConfigApplyReceiver configReceiver;
    
    @SuppressLint("UnspecifiedRegisterReceiverFlag")
    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "Application onCreate - registering receiver dynamically");
        
        // 动态注册 ConfigApplyReceiver
        configReceiver = new ConfigApplyReceiver();
        IntentFilter filter = new IntentFilter(ACTION_APPLY_CONFIG);
        
        // 使用 RECEIVER_NOT_EXPORTED 标志，明确表示不导出
        if (Build.VERSION.SDK_INT >= 33) {
            registerReceiver(configReceiver, filter, Context.RECEIVER_NOT_EXPORTED);
        } else {
            registerReceiver(configReceiver, filter);
        }
        Log.d(TAG, "Receiver registered dynamically (UID check: shell/root only)");
        Log.i(TAG, "ConfigApplyReceiver registered dynamically - invisible to third-party apps");
    }
    
    @Override
    public void onTerminate() {
        super.onTerminate();
        
        // 注销 receiver（注意：onTerminate 在真实设备上通常不会被调用，仅在模拟器中）
        if (configReceiver != null) {
            try {
                unregisterReceiver(configReceiver);
                Log.d(TAG, "Receiver unregistered");
            } catch (IllegalArgumentException e) {
                Log.w(TAG, "Receiver was not registered or already unregistered");
            }
        }
    }
}

```

`configapp/src/main/java/com/jiqiu/configapp/ConfigApplyReceiver.java`:

```java
package com.jiqiu.configapp;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Binder;
import android.os.Process;
import android.util.Log;

import com.topjohnwu.superuser.Shell;

/**
 * BroadcastReceiver to apply configurations pushed from ADB
 * 接收来自 ADB shell 的广播以应用配置
 * 
 * 安全机制：动态注册 + UID 权限检查，只允许 shell(2000) 或 root(0) 调用
 */
public class ConfigApplyReceiver extends BroadcastReceiver {
    private static final String TAG = "ConfigApplyReceiver";
    
    // UID constants
    private static final int SHELL_UID = 2000;  // ADB shell user
    private static final int ROOT_UID = 0;       // Root user
    
    @Override
    public void onReceive(Context context, Intent intent) {
        // 权限检查：只允许 shell 或 root 用户发送广播
        int callingUid = Binder.getCallingUid();
        if (callingUid != SHELL_UID && callingUid != ROOT_UID) {
            Log.w(TAG, "Unauthorized broadcast attempt from UID: " + callingUid);
            Log.w(TAG, "Only shell (2000) or root (0) can send this broadcast");
            return;
        }
        
        Log.i(TAG, "Received config apply broadcast from authorized UID: " + callingUid);
        
        String action = intent.getAction();
        if (!"com.jiqiu.configapp.APPLY_CONFIG".equals(action)) {
            Log.w(TAG, "Unknown action: " + action);
            return;
        }
        
        // 获取广播参数
        String packageName = intent.getStringExtra("package_name");
        String tmpConfigPath = intent.getStringExtra("tmp_config_path");
        String tmpGadgetConfigPath = intent.getStringExtra("tmp_gadget_config_path");
        boolean deployOnly = intent.getBooleanExtra("deploy_only", false);
        
        Log.i(TAG, "Processing config for package: " + packageName);
        Log.i(TAG, "Config path: " + tmpConfigPath);
        Log.i(TAG, "Gadget config path: " + tmpGadgetConfigPath);
        Log.i(TAG, "Deploy only: " + deployOnly);
        
        if (packageName == null || packageName.isEmpty()) {
            Log.e(TAG, "Package name is required");
            return;
        }
        
        // 在后台线程处理，避免阻塞主线程
        new Thread(() -> {
            try {
                ConfigManager configManager = new ConfigManager(context);
                
                // 确保目录存在
                configManager.ensureModuleDirectories();
                
                // 如果提供了配置文件路径，复制到模块目录
                if (tmpConfigPath != null && !tmpConfigPath.isEmpty()) {
                    Shell.Result checkResult = Shell.cmd("test -f \"" + tmpConfigPath + "\" && echo 'exists'").exec();
                    if (checkResult.isSuccess() && !checkResult.getOut().isEmpty()) {
                        Log.i(TAG, "Copying main config: " + tmpConfigPath + " -> " + ConfigManager.CONFIG_FILE);
                        Shell.Result copyResult = Shell.cmd(
                            "cp \"" + tmpConfigPath + "\" \"" + ConfigManager.CONFIG_FILE + "\"",
                            "chmod 644 \"" + ConfigManager.CONFIG_FILE + "\""
                        ).exec();
                        
                        if (copyResult.isSuccess()) {
                            Log.i(TAG, "Main config copied successfully");
                            // 重新加载配置
                            configManager.reloadConfig();
                        } else {
                            Log.e(TAG, "Failed to copy main config: " + String.join("\n", copyResult.getErr()));
                        }
                    } else {
                        Log.w(TAG, "Main config file not found at: " + tmpConfigPath);
                    }
                }
                
                // 如果提供了 Gadget 配置文件，复制到应用数据目录
                if (tmpGadgetConfigPath != null && !tmpGadgetConfigPath.isEmpty()) {
                    Shell.Result checkResult = Shell.cmd("test -f \"" + tmpGadgetConfigPath + "\" && echo 'exists'").exec();
                    if (checkResult.isSuccess() && !checkResult.getOut().isEmpty()) {
                        String filesDir = "/data/data/" + packageName + "/files";
                        
                        // 从路径中提取文件名
                        String gadgetConfigFileName = tmpGadgetConfigPath.substring(tmpGadgetConfigPath.lastIndexOf('/') + 1);
                        String targetPath = filesDir + "/" + gadgetConfigFileName;
                        
                        Log.i(TAG, "Copying gadget config: " + tmpGadgetConfigPath + " -> " + targetPath);
                        
                        // 创建目录
                        Shell.cmd("mkdir -p \"" + filesDir + "\"").exec();
                        
                        Shell.Result copyResult = Shell.cmd(
                            "cp \"" + tmpGadgetConfigPath + "\" \"" + targetPath + "\"",
                            "chmod 644 \"" + targetPath + "\""
                        ).exec();
                        
                        if (copyResult.isSuccess()) {
                            Log.i(TAG, "Gadget config copied successfully");
                            
                            // 设置正确的所有权
                            Shell.Result uidResult = Shell.cmd("stat -c %u /data/data/" + packageName).exec();
                            if (uidResult.isSuccess() && !uidResult.getOut().isEmpty()) {
                                String uid = uidResult.getOut().get(0).trim();
                                Shell.cmd("chown " + uid + ":" + uid + " \"" + targetPath + "\"").exec();
                                Shell.cmd("chcon u:object_r:app_data_file:s0 \"" + targetPath + "\"").exec();
                            }
                        } else {
                            Log.e(TAG, "Failed to copy gadget config: " + String.join("\n", copyResult.getErr()));
                        }
                    } else {
                        Log.w(TAG, "Gadget config file not found at: " + tmpGadgetConfigPath);
                    }
                }
                
                // 如果不是仅部署模式，或者没有提供配置文件，执行部署
                if (!deployOnly || (tmpConfigPath == null && tmpGadgetConfigPath == null)) {
                    Log.i(TAG, "Deploying SO files for package: " + packageName);
                    configManager.deployForPackage(packageName);
                    Log.i(TAG, "Deployment completed for: " + packageName);
                } else {
                    Log.i(TAG, "Config updated, skipping deployment (deploy_only=true)");
                }
                
                // 清理临时文件
                if (tmpConfigPath != null && !tmpConfigPath.isEmpty()) {
                    Shell.cmd("rm -f \"" + tmpConfigPath + "\"").exec();
                }
                if (tmpGadgetConfigPath != null && !tmpGadgetConfigPath.isEmpty()) {
                    Shell.cmd("rm -f \"" + tmpGadgetConfigPath + "\"").exec();
                }
                
                Log.i(TAG, "Config application completed successfully");
                
            } catch (Exception e) {
                Log.e(TAG, "Error applying config", e);
            }
        }).start();
    }
}

```

`configapp/src/main/java/com/jiqiu/configapp/ConfigManager.java`:

```java
package com.jiqiu.configapp;

import android.content.Context;
import android.util.Log;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.topjohnwu.superuser.Shell;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ConfigManager {
    private static final String TAG = "ConfigManager";
    public static final String MODULE_PATH = "/data/adb/modules/zygisk-myinjector";
    public static final String CONFIG_FILE = MODULE_PATH + "/config.json";
    public static final String SO_STORAGE_DIR = MODULE_PATH + "/so_files";
    
    private final Context context;
    private final Gson gson;
    private ModuleConfig config;
    
    static {
        // Configure Shell to use root
        Shell.enableVerboseLogging = BuildConfig.DEBUG;
        Shell.setDefaultBuilder(Shell.Builder.create()
                .setFlags(Shell.FLAG_REDIRECT_STDERR | Shell.FLAG_MOUNT_MASTER)
                .setTimeout(30));
    }
    
    public ConfigManager(Context context) {
        this.context = context;
        this.gson = new GsonBuilder().setPrettyPrinting().create();
        
        // Ensure we get root shell on creation
        Shell.getShell();
        
        loadConfig();
    }
    
    public boolean isRootAvailable() {
        return Shell.getShell().isRoot();
    }
    
    public void ensureModuleDirectories() {
        // Check root access first
        if (!isRootAvailable()) {
            Log.e(TAG, "Root access not available!");
            return;
        }
        
        // Create module directories
        Shell.Result result1 = Shell.cmd("mkdir -p " + MODULE_PATH).exec();
        if (!result1.isSuccess()) {
            Log.e(TAG, "Failed to create module directory: " + MODULE_PATH);
        }
        
        Shell.Result result2 = Shell.cmd("mkdir -p " + SO_STORAGE_DIR).exec();
        if (!result2.isSuccess()) {
            Log.e(TAG, "Failed to create SO storage directory: " + SO_STORAGE_DIR);
        }
        
        // Set permissions
        Shell.cmd("chmod 755 " + MODULE_PATH).exec();
        Shell.cmd("chmod 755 " + SO_STORAGE_DIR).exec();
        
        // Verify directories exist
        Shell.Result verify = Shell.cmd("ls -la " + MODULE_PATH).exec();
        if (verify.isSuccess()) {
            Log.i(TAG, "Module directory ready: " + String.join("\n", verify.getOut()));
        }
    }
    
    private void loadConfig() {
        Shell.Result result = Shell.cmd("cat " + CONFIG_FILE).exec();
        if (result.isSuccess() && !result.getOut().isEmpty()) {
            String json = String.join("\n", result.getOut());
            try {
                config = gson.fromJson(json, ModuleConfig.class);
            } catch (Exception e) {
                Log.e(TAG, "Failed to parse config", e);
                config = new ModuleConfig();
            }
        } else {
            config = new ModuleConfig();
        }
    }
    
    /**
     * Public method to reload configuration from file
     * 从文件重新加载配置（用于外部更新配置后）
     */
    public void reloadConfig() {
        loadConfig();
        Log.i(TAG, "Configuration reloaded");
    }
    
    public void saveConfig() {
        String json = gson.toJson(config);
        // Write to temp file first
        String tempFile = context.getCacheDir() + "/config.json";
        try {
            java.io.FileWriter writer = new java.io.FileWriter(tempFile);
            writer.write(json);
            writer.close();
            
            // Copy to module directory with root
            Shell.cmd("cp " + tempFile + " " + CONFIG_FILE).exec();
            Shell.cmd("chmod 644 " + CONFIG_FILE).exec();
            
            // Clean up temp file
            new File(tempFile).delete();
        } catch (Exception e) {
            Log.e(TAG, "Failed to save config", e);
        }
    }
    
    public boolean isAppEnabled(String packageName) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        return appConfig != null && appConfig.enabled;
    }
    
    public void setAppEnabled(String packageName, boolean enabled) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null) {
            appConfig = new AppConfig();
            config.perAppConfig.put(packageName, appConfig);
        }
        appConfig.enabled = enabled;
        saveConfig();
        
        // 自动部署或清理 SO 文件
        if (enabled) {
            deploySoFilesToApp(packageName);
        } else {
            cleanupAppSoFiles(packageName);
        }
    }
    
    public List<SoFile> getAppSoFiles(String packageName) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null) {
            return new ArrayList<>();
        }
        return new ArrayList<>(appConfig.soFiles);
    }
    
    public List<SoFile> getAllSoFiles() {
        if (config.globalSoFiles == null) {
            config.globalSoFiles = new ArrayList<>();
        }
        return new ArrayList<>(config.globalSoFiles);
    }
    
    public void addGlobalSoFile(String originalPath, boolean deleteOriginal) {
        if (config.globalSoFiles == null) {
            config.globalSoFiles = new ArrayList<>();
        }
        
        // Keep original filename
        String fileName = new File(originalPath).getName();
        String storedPath = SO_STORAGE_DIR + "/" + fileName;
        
        // Check if file already exists with same name
        for (SoFile existing : config.globalSoFiles) {
            if (existing.name.equals(fileName)) {
                Log.w(TAG, "SO file with same name already exists: " + fileName);
                return;
            }
        }
        
        // Ensure SO storage directory exists
        Shell.cmd("mkdir -p " + SO_STORAGE_DIR).exec();
        Shell.cmd("chmod 755 " + SO_STORAGE_DIR).exec();
        
        // Copy SO file to our storage
        Log.i(TAG, "Copying SO file from: " + originalPath + " to: " + storedPath);
        Shell.Result result = Shell.cmd("cp \"" + originalPath + "\" \"" + storedPath + "\"").exec();
        
        if (result.isSuccess()) {
            // Verify the file was actually copied
            Shell.Result verifyResult = Shell.cmd("test -f \"" + storedPath + "\" && echo 'exists'").exec();
            if (!verifyResult.isSuccess() || verifyResult.getOut().isEmpty()) {
                Log.e(TAG, "File copy appeared successful but file not found at: " + storedPath);
                return;
            }
            
            // Set proper permissions for SO file (readable and executable)
            Shell.Result chmodResult = Shell.cmd("chmod 755 \"" + storedPath + "\"").exec();
            if (!chmodResult.isSuccess()) {
                Log.e(TAG, "Failed to set permissions on SO file: " + String.join("\n", chmodResult.getErr()));
            }
            
            SoFile soFile = new SoFile();
            soFile.name = fileName;
            soFile.storedPath = storedPath;
            soFile.originalPath = originalPath;
            config.globalSoFiles.add(soFile);
            
            Log.i(TAG, "Successfully added SO file: " + fileName + " to storage");
            
            if (deleteOriginal) {
                Shell.cmd("rm \"" + originalPath + "\"").exec();
                Log.i(TAG, "Deleted original file: " + originalPath);
            }
            
            saveConfig();
        } else {
            Log.e(TAG, "Failed to copy SO file: " + String.join("\n", result.getErr()));
        }
    }
    
    public void removeGlobalSoFile(SoFile soFile) {
        if (config.globalSoFiles == null) return;
        
        config.globalSoFiles.remove(soFile);
        // Delete the stored file
        Shell.cmd("rm \"" + soFile.storedPath + "\"").exec();
        saveConfig();
    }
    
    public void addSoFileToApp(String packageName, SoFile globalSoFile) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null) {
            appConfig = new AppConfig();
            config.perAppConfig.put(packageName, appConfig);
        }
        
        // Check if already added
        for (SoFile existing : appConfig.soFiles) {
            if (existing.storedPath.equals(globalSoFile.storedPath)) {
                return; // Already added
            }
        }
        
        // Add reference to the global SO file
        appConfig.soFiles.add(globalSoFile);
        saveConfig();
        
        // If app is enabled, deploy the new SO file
        if (appConfig.enabled) {
            deploySoFilesToApp(packageName);
        }
    }
    
    public void removeSoFileFromApp(String packageName, SoFile soFile) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null) return;
        
        appConfig.soFiles.removeIf(s -> s.storedPath.equals(soFile.storedPath));
        saveConfig();
        
        // If app is enabled, re-deploy to update SO files
        if (appConfig.enabled) {
            deploySoFilesToApp(packageName);
        }
    }
    
    public boolean getHideInjection() {
        return config.hideInjection;
    }
    
    public void setHideInjection(boolean hide) {
        config.hideInjection = hide;
        saveConfig();
    }
    
    public String getAppInjectionMethod(String packageName) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null) {
            return "standard"; // Default to standard
        }
        return appConfig.injectionMethod != null ? appConfig.injectionMethod : "standard";
    }
    
    public void setAppInjectionMethod(String packageName, String method) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null) {
            appConfig = new AppConfig();
            config.perAppConfig.put(packageName, appConfig);
        }
        appConfig.injectionMethod = method;
        saveConfig();
    }
    
    public int getInjectionDelay() {
        return config.injectionDelay;
    }
    
    public void setInjectionDelay(int delay) {
        config.injectionDelay = delay;
        saveConfig();
    }
    
    public GadgetConfig getAppGadgetConfig(String packageName) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null) {
            // If no app config, return global gadget config
            return config.globalGadgetConfig;
        }
        
        // If app is set to use global gadget, return global config
        if (appConfig.useGlobalGadget) {
            return config.globalGadgetConfig;
        }
        
        // Otherwise return app-specific gadget config
        return appConfig.gadgetConfig;
    }
    
    public GadgetConfig getGlobalGadgetConfig() {
        return config.globalGadgetConfig;
    }
    
    public void setGlobalGadgetConfig(GadgetConfig gadgetConfig) {
        config.globalGadgetConfig = gadgetConfig;
        saveConfig();
    }
    
    public boolean getAppUseGlobalGadget(String packageName) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null) {
            return true; // Default to use global
        }
        return appConfig.useGlobalGadget;
    }
    
    public void setAppUseGlobalGadget(String packageName, boolean useGlobal) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null) {
            appConfig = new AppConfig();
            config.perAppConfig.put(packageName, appConfig);
        }
        appConfig.useGlobalGadget = useGlobal;
        saveConfig();
    }
    
    public void setAppGadgetConfig(String packageName, GadgetConfig gadgetConfig) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null) {
            appConfig = new AppConfig();
            config.perAppConfig.put(packageName, appConfig);
        }
        
        // Remove old gadget from SO list if exists
        if (appConfig.gadgetConfig != null) {
            String oldGadgetName = appConfig.gadgetConfig.gadgetName;
            appConfig.soFiles.removeIf(soFile -> soFile.name.equals(oldGadgetName));
        }
        
        appConfig.gadgetConfig = gadgetConfig;
        
        // Add new gadget to SO list if configured
        if (gadgetConfig != null) {
            // Check if gadget SO file exists in global storage
            String gadgetPath = SO_STORAGE_DIR + "/" + gadgetConfig.gadgetName;
            Shell.Result checkResult = Shell.cmd("test -f \"" + gadgetPath + "\" && echo 'exists'").exec();
            
            if (checkResult.isSuccess() && !checkResult.getOut().isEmpty()) {
                // Add gadget as a SO file
                SoFile gadgetSoFile = new SoFile();
                gadgetSoFile.name = gadgetConfig.gadgetName;
                gadgetSoFile.storedPath = gadgetPath;
                gadgetSoFile.originalPath = gadgetPath;
                
                // Check if already in list
                boolean alreadyExists = false;
                for (SoFile soFile : appConfig.soFiles) {
                    if (soFile.name.equals(gadgetSoFile.name)) {
                        alreadyExists = true;
                        break;
                    }
                }
                
                if (!alreadyExists) {
                    appConfig.soFiles.add(gadgetSoFile);
                    Log.i(TAG, "Added gadget SO to app's SO list: " + gadgetSoFile.name);
                }
            } else {
                Log.w(TAG, "Gadget SO file not found in storage: " + gadgetPath);
                Log.w(TAG, "Please ensure " + gadgetConfig.gadgetName + " is added to SO library");
            }
        }
        
        saveConfig();
        
        // If app is enabled, deploy both gadget SO and config file
        if (appConfig.enabled) {
            if (gadgetConfig != null) {
                deployGadgetConfigFile(packageName, gadgetConfig);
            }
            // Re-deploy all SO files including gadget
            deploySoFilesToApp(packageName);
        }
    }
    
    private void deployGadgetConfigFile(String packageName, GadgetConfig gadgetConfig) {
        try {
            // Create gadget config JSON
            String configJson;
            if ("script".equals(gadgetConfig.mode)) {
                configJson = String.format(
                    "{\n" +
                    "  \"interaction\": {\n" +
                    "    \"type\": \"script\",\n" +
                    "    \"path\": \"%s\"\n" +
                    "  }\n" +
                    "}",
                    gadgetConfig.scriptPath
                );
            } else {
                configJson = String.format(
                    "{\n" +
                    "  \"interaction\": {\n" +
                    "    \"type\": \"listen\",\n" +
                    "    \"address\": \"%s\",\n" +
                    "    \"port\": %d,\n" +
                    "    \"on_port_conflict\": \"%s\",\n" +
                    "    \"on_load\": \"%s\"\n" +
                    "  }\n" +
                    "}",
                    gadgetConfig.address,
                    gadgetConfig.port,
                    gadgetConfig.onPortConflict,
                    gadgetConfig.onLoad
                );
            }
            
            // Write to temp file
            String tempFile = context.getCacheDir() + "/" + gadgetConfig.gadgetName + ".config";
            java.io.FileWriter writer = new java.io.FileWriter(tempFile);
            writer.write(configJson);
            writer.close();
            
            // Copy to app's files directory
            String filesDir = "/data/data/" + packageName + "/files";
            String gadgetConfigName = gadgetConfig.gadgetName.replace(".so", ".config.so");
            String targetPath = filesDir + "/" + gadgetConfigName;
            
            Shell.Result copyResult = Shell.cmd("cp " + tempFile + " " + targetPath).exec();
            if (copyResult.isSuccess()) {
                // Set permissions
                Shell.cmd("chmod 644 " + targetPath).exec();
                Log.i(TAG, "Deployed gadget config to: " + targetPath);
            } else {
                Log.e(TAG, "Failed to deploy gadget config: " + String.join("\n", copyResult.getErr()));
            }
            
            // Clean up temp file
            new java.io.File(tempFile).delete();
        } catch (Exception e) {
            Log.e(TAG, "Failed to create gadget config file", e);
        }
    }
    
    // Copy SO files directly to app's data directory
    private void deploySoFilesToApp(String packageName) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null || appConfig.soFiles.isEmpty()) {
            Log.w(TAG, "No SO files to deploy for: " + packageName);
            return;
        }
        
        // First check if we have root access
        if (!Shell.getShell().isRoot()) {
            Log.e(TAG, "No root access available!");
            return;
        }
        
        // Create files directory in app's data dir
        String filesDir = "/data/data/" + packageName + "/files";
        
        Log.i(TAG, "Deploying SO files to: " + filesDir);
        
        // Create directory without su -c for better compatibility
        Shell.Result mkdirResult = Shell.cmd("mkdir -p " + filesDir).exec();
        if (!mkdirResult.isSuccess()) {
            Log.e(TAG, "Failed to create directory: " + filesDir);
            Log.e(TAG, "Error: " + String.join("\n", mkdirResult.getErr()));
            return;
        }
        
        // Set proper permissions and ownership for the files directory
        Shell.cmd("chmod 771 " + filesDir).exec();
        
        // Get UID and GID for the package
        Shell.Result uidResult = Shell.cmd("stat -c %u /data/data/" + packageName).exec();
        String uid = "";
        if (uidResult.isSuccess() && !uidResult.getOut().isEmpty()) {
            uid = uidResult.getOut().get(0).trim();
            Log.i(TAG, "Package UID: " + uid);
            
            // Set ownership of files directory to match app
            Shell.Result chownDirResult = Shell.cmd("chown " + uid + ":" + uid + " \"" + filesDir + "\"").exec();
            if (!chownDirResult.isSuccess()) {
                Log.e(TAG, "Failed to set directory ownership: " + String.join("\n", chownDirResult.getErr()));
            }
            
            // Set SELinux context for the directory
            Shell.cmd("chcon u:object_r:app_data_file:s0 \"" + filesDir + "\"").exec();
        } else {
            Log.e(TAG, "Failed to get package UID");
        }
        
        // Copy each SO file configured for this app
        for (SoFile soFile : appConfig.soFiles) {
            // Use original filename
            String destPath = filesDir + "/" + soFile.name;
            
            // Check if source file exists
            Shell.Result checkResult = Shell.cmd("test -f \"" + soFile.storedPath + "\" && echo 'exists'").exec();
            if (!checkResult.isSuccess() || checkResult.getOut().isEmpty()) {
                Log.e(TAG, "Source SO file not found: " + soFile.storedPath);
                // Log more details about the missing file
                Shell.Result lsResult = Shell.cmd("ls -la \"" + SO_STORAGE_DIR + "\"").exec();
                Log.e(TAG, "Contents of SO storage dir: " + String.join("\n", lsResult.getOut()));
                continue;
            }
            
            Log.i(TAG, "Copying: " + soFile.storedPath + " to " + destPath);
            
            // First, ensure the destination directory exists and has proper permissions
            Shell.cmd("mkdir -p \"" + filesDir + "\"").exec();
            Shell.cmd("chmod 755 \"" + filesDir + "\"").exec();
            
            // Copy file using cp with force flag
            Shell.Result result = Shell.cmd("cp -f \"" + soFile.storedPath + "\" \"" + destPath + "\"").exec();
            
            if (!result.isSuccess()) {
                Log.e(TAG, "Failed with cp, trying cat method");
                Log.e(TAG, "cp error: " + String.join("\n", result.getErr()));
                // Fallback to cat method
                result = Shell.cmd("cat \"" + soFile.storedPath + "\" > \"" + destPath + "\"").exec();
                
                if (!result.isSuccess()) {
                    Log.e(TAG, "Also failed with cat method");
                    Log.e(TAG, "cat error: " + String.join("\n", result.getErr()));
                }
            }
            
            // Set permissions - SO files need to be readable and executable
            Shell.Result chmodResult = Shell.cmd("chmod 755 \"" + destPath + "\"").exec();
            if (!chmodResult.isSuccess()) {
                Log.e(TAG, "Failed to set permissions: " + String.join("\n", chmodResult.getErr()));
            }
            
            // Set ownership to match the app's UID
            if (!uid.isEmpty()) {
                Shell.Result chownResult = Shell.cmd("chown " + uid + ":" + uid + " \"" + destPath + "\"").exec();
                if (!chownResult.isSuccess()) {
                    Log.e(TAG, "Failed to set ownership: " + String.join("\n", chownResult.getErr()));
                    // Try alternative method
                    Shell.cmd("chown " + uid + ".app_" + uid + " \"" + destPath + "\"").exec();
                }
            }
            
            // Set SELinux context to match app's data files
            Shell.Result contextResult = Shell.cmd("chcon u:object_r:app_data_file:s0 \"" + destPath + "\"").exec();
            if (!contextResult.isSuccess()) {
                Log.w(TAG, "Failed to set SELinux context (this may be normal on some devices)");
            }
            
            // Verify the file was copied with correct permissions
            Shell.Result verifyResult = Shell.cmd("ls -laZ \"" + destPath + "\" 2>/dev/null").exec();
            if (verifyResult.isSuccess() && !verifyResult.getOut().isEmpty()) {
                Log.i(TAG, "Successfully deployed: " + String.join(" ", verifyResult.getOut()));
            } else {
                // Fallback verification without SELinux context
                verifyResult = Shell.cmd("ls -la \"" + destPath + "\" 2>/dev/null").exec();
                if (verifyResult.isSuccess() && !verifyResult.getOut().isEmpty()) {
                    Log.i(TAG, "Successfully deployed: " + String.join(" ", verifyResult.getOut()));
                } else {
                    Log.e(TAG, "Failed to verify SO file copy: " + destPath);
                }
            }
        }
        
        Log.i(TAG, "Deployment complete for: " + packageName);
        
        // Deploy gadget config if configured
        ConfigManager.GadgetConfig gadgetToUse = getAppGadgetConfig(packageName);
        if (gadgetToUse != null) {
            deployGadgetConfigFile(packageName, gadgetToUse);
        }
    }
    
    // Clean up deployed SO files when app is disabled
    private void cleanupAppSoFiles(String packageName) {
        AppConfig appConfig = config.perAppConfig.get(packageName);
        if (appConfig == null || appConfig.soFiles.isEmpty()) {
            Log.w(TAG, "No SO files to clean up for: " + packageName);
            return;
        }
        
        // First check if we have root access
        if (!Shell.getShell().isRoot()) {
            Log.e(TAG, "No root access available!");
            return;
        }
        
        String filesDir = "/data/data/" + packageName + "/files";
        
        // Only delete the SO files we deployed, not the entire directory
        for (SoFile soFile : appConfig.soFiles) {
            // Use original filename
            String filePath = filesDir + "/" + soFile.name;
            
            Log.i(TAG, "Cleaning up: " + filePath);
            
            // Check if file exists before trying to delete
            Shell.Result checkResult = Shell.cmd("test -f \"" + filePath + "\" && echo 'exists'").exec();
            if (checkResult.isSuccess() && !checkResult.getOut().isEmpty()) {
                // Try to remove the file
                Shell.Result result = Shell.cmd("rm -f \"" + filePath + "\"").exec();
                
                // Verify deletion
                Shell.Result verifyResult = Shell.cmd("test -f \"" + filePath + "\" && echo 'still_exists'").exec();
                if (!verifyResult.isSuccess() || verifyResult.getOut().isEmpty()) {
                    Log.i(TAG, "Successfully deleted SO file: " + filePath);
                } else {
                    Log.e(TAG, "Failed to delete SO file: " + filePath);
                    // Try with su -c
                    Shell.cmd("su -c 'rm -f \"" + filePath + "\"'").exec();
                }
            } else {
                Log.w(TAG, "SO file not found for cleanup: " + filePath);
            }
        }
        
        // Clean up gadget config file if exists
        ConfigManager.GadgetConfig gadgetToUse = getAppGadgetConfig(packageName);
        if (gadgetToUse != null) {
            String gadgetConfigName = gadgetToUse.gadgetName.replace(".so", ".config.so");
            String configPath = filesDir + "/" + gadgetConfigName;
            
            Shell.Result checkConfigResult = Shell.cmd("test -f \"" + configPath + "\" && echo 'exists'").exec();
            if (checkConfigResult.isSuccess() && !checkConfigResult.getOut().isEmpty()) {
                Shell.Result deleteResult = Shell.cmd("rm -f \"" + configPath + "\"").exec();
                if (deleteResult.isSuccess()) {
                    Log.i(TAG, "Deleted gadget config: " + configPath);
                } else {
                    // Try with su -c
                    Shell.cmd("su -c 'rm -f \"" + configPath + "\"'").exec();
                }
            }
        }
        
        Log.i(TAG, "Cleanup complete for: " + packageName);
    }
    
    // Deploy SO files for all enabled apps
    public void deployAllSoFiles() {
        for (Map.Entry<String, AppConfig> entry : config.perAppConfig.entrySet()) {
            if (entry.getValue().enabled) {
                deploySoFilesToApp(entry.getKey());
            }
        }
    }
    
    /**
     * Public method to deploy SO files for a specific package
     * 为指定包名部署 SO 文件（外部调用）
     * @param packageName Target package name
     */
    public void deployForPackage(String packageName) {
        if (packageName == null || packageName.isEmpty()) {
            Log.e(TAG, "Package name cannot be null or empty");
            return;
        }
        deploySoFilesToApp(packageName);
    }
    
    // Data classes
    public static class ModuleConfig {
        public boolean enabled = true;
        public boolean hideInjection = false;
        public int injectionDelay = 2; // Default 2 seconds
        public List<SoFile> globalSoFiles = new ArrayList<>();
        public Map<String, AppConfig> perAppConfig = new HashMap<>();
        public GadgetConfig globalGadgetConfig = null; // Global gadget configuration
    }
    
    public static class AppConfig {
        public boolean enabled = false;
        public List<SoFile> soFiles = new ArrayList<>();
        public String injectionMethod = "standard"; // "standard", "riru" or "custom_linker"
        public GadgetConfig gadgetConfig = null;
        public boolean useGlobalGadget = true; // Whether to use global gadget settings
    }
    
    public static class SoFile {
        public String name;
        public String storedPath;
        public String originalPath;
        
        @Override
        public boolean equals(Object obj) {
            if (obj instanceof SoFile) {
                return storedPath.equals(((SoFile) obj).storedPath);
            }
            return false;
        }
    }
    
    public static class GadgetConfig {
        public String mode = "server"; // "server" or "script"
        // Server mode config
        public String address = "0.0.0.0";
        public int port = 27042;
        public String onPortConflict = "fail";
        public String onLoad = "wait";
        // Script mode config
        public String scriptPath = "/data/local/tmp/script.js";
        // Common config
        public String gadgetName = "libgadget.so";
    }
}
```

`configapp/src/main/java/com/jiqiu/configapp/FileBrowserActivity.java`:

```java
package com.jiqiu.configapp;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.Toolbar;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.topjohnwu.superuser.Shell;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class FileBrowserActivity extends AppCompatActivity {
    
    private static final String TAG = "FileBrowser";
    public static final String EXTRA_START_PATH = "start_path";
    public static final String EXTRA_FILE_FILTER = "file_filter";
    public static final String EXTRA_SELECTED_PATH = "selected_path";
    
    private RecyclerView recyclerView;
    private TextView currentPathText;
    private View emptyView;
    private FileListAdapter adapter;
    
    private String currentPath;
    private String fileFilter = ".so";
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_file_browser);
        
        Toolbar toolbar = findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        getSupportActionBar().setTitle("选择SO文件");
        
        currentPathText = findViewById(R.id.currentPath);
        recyclerView = findViewById(R.id.recyclerView);
        emptyView = findViewById(R.id.emptyView);
        
        adapter = new FileListAdapter();
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        recyclerView.setAdapter(adapter);
        
        // Get start path from intent
        String startPath = getIntent().getStringExtra(EXTRA_START_PATH);
        if (startPath == null) {
            startPath = "/data/local/tmp";
        }
        fileFilter = getIntent().getStringExtra(EXTRA_FILE_FILTER);
        if (fileFilter == null) {
            fileFilter = ".so";
        }
        
        // Check if we have root access
        if (!Shell.getShell().isRoot()) {
            Toast.makeText(this, "需要Root权限才能浏览文件", Toast.LENGTH_LONG).show();
            Log.e(TAG, "No root access");
        }
        
        currentPath = startPath;
        loadFiles();
    }
    
    private void loadFiles() {
        currentPathText.setText(currentPath);
        
        List<FileItem> items = new ArrayList<>();
        
        // Add parent directory if not root
        if (!"/".equals(currentPath)) {
            items.add(new FileItem("..", true, true));
        }
        
        // List files using root
        Log.d(TAG, "Loading files from: " + currentPath);
        Shell.Result result = Shell.cmd("ls -la " + currentPath + " 2>/dev/null").exec();
        Log.d(TAG, "ls command success: " + result.isSuccess() + ", output lines: " + result.getOut().size());
        
        if (result.isSuccess()) {
            for (String line : result.getOut()) {
                // Skip empty lines, total line, and symbolic links
                if (line.trim().isEmpty() || line.startsWith("total") || line.contains("->")) {
                    continue;
                }
                
                // Try to parse ls output - handle different formats
                String name = null;
                boolean isDirectory = false;
                boolean isReadable = true;
                
                // Check if line starts with permissions (drwxr-xr-x format)
                if (line.matches("^[dlrwxst-]{10}.*")) {
                    String[] parts = line.split("\\s+", 9);
                    if (parts.length >= 9) {
                        String permissions = parts[0];
                        name = parts[parts.length - 1];
                        isDirectory = permissions.startsWith("d");
                        isReadable = permissions.length() > 1 && permissions.charAt(1) == 'r';
                    }
                } else {
                    // Simple format, just the filename
                    name = line.trim();
                    // Check if it's a directory by trying to list it
                    Shell.Result dirCheck = Shell.cmd("test -d \"" + currentPath + "/" + name + "\" && echo 'dir'").exec();
                    isDirectory = dirCheck.isSuccess() && !dirCheck.getOut().isEmpty();
                }
                
                if (name != null && !".".equals(name) && !"..".equals(name)) {
                    // Filter files by extension
                    if (!isDirectory && fileFilter != null && !name.endsWith(fileFilter)) {
                        continue;
                    }
                    
                    items.add(new FileItem(name, isDirectory, isReadable));
                }
            }
        } else {
            // If ls fails, try a simpler approach
            Shell.Result simpleResult = Shell.cmd("cd " + currentPath + " && for f in *; do echo \"$f\"; done").exec();
            if (simpleResult.isSuccess()) {
                for (String name : simpleResult.getOut()) {
                    if (!name.trim().isEmpty() && !"*".equals(name)) {
                        Shell.Result dirCheck = Shell.cmd("test -d \"" + currentPath + "/" + name + "\" && echo 'dir'").exec();
                        boolean isDirectory = dirCheck.isSuccess() && !dirCheck.getOut().isEmpty();
                        
                        // Filter files by extension
                        if (!isDirectory && fileFilter != null && !name.endsWith(fileFilter)) {
                            continue;
                        }
                        
                        items.add(new FileItem(name, isDirectory, true));
                    }
                }
            }
        }
        
        // If still no items and not root, add some common directories to try
        if (items.size() <= 1 && "/data/local/tmp".equals(currentPath)) {
            // Try to create a test file to verify access
            Shell.cmd("touch /data/local/tmp/test_access.tmp && rm /data/local/tmp/test_access.tmp").exec();
            
            // Add any .so files we can find
            Shell.Result findResult = Shell.cmd("find " + currentPath + " -maxdepth 1 -name '*.so' -type f 2>/dev/null").exec();
            if (findResult.isSuccess()) {
                for (String path : findResult.getOut()) {
                    if (!path.trim().isEmpty()) {
                        String name = path.substring(path.lastIndexOf('/') + 1);
                        items.add(new FileItem(name, false, true));
                    }
                }
            }
        }
        
        Collections.sort(items, (a, b) -> {
            if (a.isDirectory != b.isDirectory) {
                return a.isDirectory ? -1 : 1;
            }
            return a.name.compareToIgnoreCase(b.name);
        });
        
        adapter.setItems(items);
        emptyView.setVisibility(items.isEmpty() || (items.size() == 1 && "..".equals(items.get(0).name)) ? View.VISIBLE : View.GONE);
    }
    
    @Override
    public boolean onSupportNavigateUp() {
        onBackPressed();
        return true;
    }
    
    class FileItem {
        String name;
        boolean isDirectory;
        boolean isReadable;
        
        FileItem(String name, boolean isDirectory, boolean isReadable) {
            this.name = name;
            this.isDirectory = isDirectory;
            this.isReadable = isReadable;
        }
    }
    
    class FileListAdapter extends RecyclerView.Adapter<FileListAdapter.ViewHolder> {
        private List<FileItem> items = new ArrayList<>();
        
        void setItems(List<FileItem> items) {
            this.items = items;
            notifyDataSetChanged();
        }
        
        @NonNull
        @Override
        public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
            View view = LayoutInflater.from(parent.getContext())
                    .inflate(R.layout.item_file, parent, false);
            return new ViewHolder(view);
        }
        
        @Override
        public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
            holder.bind(items.get(position));
        }
        
        @Override
        public int getItemCount() {
            return items.size();
        }
        
        class ViewHolder extends RecyclerView.ViewHolder {
            ImageView icon;
            TextView name;
            TextView info;
            
            ViewHolder(@NonNull View itemView) {
                super(itemView);
                icon = itemView.findViewById(R.id.fileIcon);
                name = itemView.findViewById(R.id.fileName);
                info = itemView.findViewById(R.id.fileInfo);
            }
            
            void bind(FileItem item) {
                name.setText(item.name);
                
                if (item.isDirectory) {
                    icon.setImageResource(android.R.drawable.ic_menu_agenda);
                    info.setText("文件夹");
                } else {
                    icon.setImageResource(android.R.drawable.ic_menu_save);
                    info.setText("SO文件");
                }
                
                if (!item.isReadable) {
                    itemView.setAlpha(0.5f);
                } else {
                    itemView.setAlpha(1.0f);
                }
                
                itemView.setOnClickListener(v -> {
                    if ("..".equals(item.name)) {
                        // Go to parent directory
                        int lastSlash = currentPath.lastIndexOf('/');
                        if (lastSlash > 0) {
                            currentPath = currentPath.substring(0, lastSlash);
                        } else {
                            currentPath = "/";
                        }
                        loadFiles();
                    } else if (item.isDirectory) {
                        if (!item.isReadable) {
                            Toast.makeText(FileBrowserActivity.this, 
                                    "没有权限访问此目录", Toast.LENGTH_SHORT).show();
                            return;
                        }
                        if ("/".equals(currentPath)) {
                            currentPath = "/" + item.name;
                        } else {
                            currentPath = currentPath + "/" + item.name;
                        }
                        loadFiles();
                    } else {
                        // File selected
                        String selectedPath = currentPath + "/" + item.name;
                        Intent resultIntent = new Intent();
                        resultIntent.putExtra(EXTRA_SELECTED_PATH, selectedPath);
                        setResult(Activity.RESULT_OK, resultIntent);
                        finish();
                    }
                });
            }
        }
    }
}
```

`configapp/src/main/java/com/jiqiu/configapp/FileUtils.java`:

```java
package com.jiqiu.configapp;

import android.content.ContentResolver;
import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.provider.OpenableColumns;
import android.util.Log;

import com.topjohnwu.superuser.Shell;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class FileUtils {
    private static final String TAG = "FileUtils";
    
    /**
     * Get real file path from URI, handling both file:// and content:// URIs
     * @param context Context
     * @param uri The URI to resolve
     * @return The real file path, or null if unable to resolve
     */
    public static String getRealPathFromUri(Context context, Uri uri) {
        if (uri == null) return null;
        
        String scheme = uri.getScheme();
        if (scheme == null) return null;
        
        // Handle file:// URIs
        if ("file".equals(scheme)) {
            return uri.getPath();
        }
        
        // Handle content:// URIs
        if ("content".equals(scheme)) {
            // For content URIs, we need to copy the file to a temporary location
            return copyFileFromContentUri(context, uri);
        }
        
        // Try direct path extraction as fallback
        String path = uri.getPath();
        if (path != null) {
            // Some file managers return paths like /external_files/...
            // Try to resolve these to actual paths
            if (path.contains(":")) {
                String[] parts = path.split(":");
                if (parts.length == 2) {
                    String type = parts[0];
                    String relativePath = parts[1];
                    
                    // Common storage locations
                    if (type.endsWith("/primary")) {
                        return "/storage/emulated/0/" + relativePath;
                    } else if (type.contains("external")) {
                        return "/storage/emulated/0/" + relativePath;
                    }
                }
            }
            
            // Remove any file:// prefix
            if (path.startsWith("file://")) {
                path = path.substring(7);
            }
            
            // Check if the path exists
            Shell.Result result = Shell.cmd("test -f \"" + path + "\" && echo 'exists'").exec();
            if (result.isSuccess() && !result.getOut().isEmpty()) {
                return path;
            }
        }
        
        return null;
    }
    
    /**
     * Copy a file from content URI to temporary location
     * @param context Context
     * @param uri Content URI
     * @return Path to copied file, or null on failure
     */
    private static String copyFileFromContentUri(Context context, Uri uri) {
        ContentResolver resolver = context.getContentResolver();
        String fileName = getFileName(context, uri);
        
        if (fileName == null || !fileName.endsWith(".so")) {
            fileName = "temp_" + System.currentTimeMillis() + ".so";
        }
        
        // Create temp directory
        File tempDir = new File(context.getCacheDir(), "so_temp");
        if (!tempDir.exists()) {
            tempDir.mkdirs();
        }
        
        File tempFile = new File(tempDir, fileName);
        
        try (InputStream inputStream = resolver.openInputStream(uri);
             OutputStream outputStream = new FileOutputStream(tempFile)) {
            
            if (inputStream == null) {
                Log.e(TAG, "Unable to open input stream for URI: " + uri);
                return null;
            }
            
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
            }
            
            // Make file readable
            tempFile.setReadable(true, false);
            
            // First copy to /data/local/tmp as a temporary location
            String tempTargetPath = "/data/local/tmp/" + fileName;
            Shell.Result result = Shell.cmd(
                "cp \"" + tempFile.getAbsolutePath() + "\" \"" + tempTargetPath + "\"",
                "chmod 644 \"" + tempTargetPath + "\""
            ).exec();
            
            // Clean up temp file
            tempFile.delete();
            
            if (result.isSuccess()) {
                // Return the temporary path - it will be moved to the proper location by addGlobalSoFile
                return tempTargetPath;
            } else {
                Log.e(TAG, "Failed to copy file to /data/local/tmp/");
                return null;
            }
            
        } catch (IOException e) {
            Log.e(TAG, "Error copying file from content URI", e);
            return null;
        }
    }
    
    /**
     * Get file name from URI
     * @param context Context
     * @param uri URI to get name from
     * @return File name or null
     */
    private static String getFileName(Context context, Uri uri) {
        String fileName = null;
        
        if ("content".equals(uri.getScheme())) {
            try (Cursor cursor = context.getContentResolver().query(
                    uri, null, null, null, null)) {
                if (cursor != null && cursor.moveToFirst()) {
                    int nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);
                    if (nameIndex >= 0) {
                        fileName = cursor.getString(nameIndex);
                    }
                }
            } catch (Exception e) {
                Log.e(TAG, "Error getting file name from URI", e);
            }
        }
        
        if (fileName == null) {
            fileName = uri.getLastPathSegment();
        }
        
        return fileName;
    }
}
```

`configapp/src/main/java/com/jiqiu/configapp/GadgetConfigDialog.java`:

```java
package com.jiqiu.configapp;

import android.app.Dialog;
import android.content.Context;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.EditText;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.LinearLayout;
import android.content.Intent;
import android.net.Uri;
import android.provider.DocumentsContract;
import android.content.ContentResolver;
import android.database.Cursor;
import android.widget.Toast;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.fragment.app.DialogFragment;

import com.google.android.material.dialog.MaterialAlertDialogBuilder;

import org.json.JSONException;
import org.json.JSONObject;

public class GadgetConfigDialog extends DialogFragment {
    
    // UI elements
    private RadioGroup modeRadioGroup;
    private RadioButton radioModeServer;
    private RadioButton radioModeScript;
    private LinearLayout serverModeLayout;
    private LinearLayout scriptModeLayout;
    private RadioGroup addressRadioGroup;
    private RadioButton radioAddressAll;
    private RadioButton radioAddressLocal;
    private RadioButton radioAddressCustom;
    private EditText editCustomAddress;
    private EditText editPort;
    private RadioGroup portConflictRadioGroup;
    private RadioButton radioConflictFail;
    private RadioButton radioConflictPickNext;
    private RadioGroup onLoadRadioGroup;
    private RadioButton radioLoadWait;
    private RadioButton radioLoadResume;
    private EditText editScriptPath;
    private EditText editGadgetName;
    private EditText editJsonPreview;
    
    // Configuration data
    private ConfigManager.GadgetConfig config;
    private OnGadgetConfigListener listener;
    private String customTitle;
    
    // Flag to prevent recursive updates
    private boolean isUpdatingUI = false;
    
    // Activity result launchers
    private ActivityResultLauncher<Intent> fileBrowserLauncher;
    private ActivityResultLauncher<Intent> filePickerLauncher;
    
    public interface OnGadgetConfigListener {
        void onGadgetConfigSaved(ConfigManager.GadgetConfig config);
    }
    
    public static GadgetConfigDialog newInstance(ConfigManager.GadgetConfig config) {
        GadgetConfigDialog dialog = new GadgetConfigDialog();
        dialog.config = config != null ? config : new ConfigManager.GadgetConfig();
        return dialog;
    }
    
    // Constructor for non-fragment usage
    public GadgetConfigDialog(Context context, String title, ConfigManager.GadgetConfig config, OnGadgetConfigListener listener) {
        // This constructor is for compatibility with direct dialog creation
        // The actual dialog will be created in show() method
        this.savedContext = context;
        this.customTitle = title;
        this.config = config != null ? config : new ConfigManager.GadgetConfig();
        this.listener = listener;
    }
    
    // Default constructor required for DialogFragment
    public GadgetConfigDialog() {
        // Empty constructor required
    }
    
    public void setOnGadgetConfigListener(OnGadgetConfigListener listener) {
        this.listener = listener;
    }
    
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // Initialize file browser launcher
        fileBrowserLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            result -> {
                if (result.getResultCode() == android.app.Activity.RESULT_OK && result.getData() != null) {
                    String selectedPath = result.getData().getStringExtra("selected_path");
                    if (selectedPath != null) {
                        editScriptPath.setText(selectedPath);
                        config.scriptPath = selectedPath;
                        updateJsonPreview();
                    }
                }
            }
        );
        
        // Initialize file picker launcher
        filePickerLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            result -> {
                if (result.getResultCode() == android.app.Activity.RESULT_OK && result.getData() != null) {
                    Uri uri = result.getData().getData();
                    if (uri != null) {
                        String path = getPathFromUri(uri);
                        if (path != null) {
                            editScriptPath.setText(path);
                            config.scriptPath = path;
                            updateJsonPreview();
                        } else {
                            Toast.makeText(getContext(), "无法获取文件路径", Toast.LENGTH_SHORT).show();
                        }
                    }
                }
            }
        );
    }
    
    @NonNull
    @Override
    public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) {
        View view = LayoutInflater.from(getContext()).inflate(R.layout.dialog_gadget_config, null);
        
        initViews(view);
        loadConfig();
        setupListeners();
        updateJsonPreview();
        
        String title = customTitle != null ? customTitle : "Gadget 配置";
        
        return new MaterialAlertDialogBuilder(getContext())
                .setTitle(title)
                .setView(view)
                .setPositiveButton("保存", (dialog, which) -> saveConfig())
                .setNegativeButton("取消", null)
                .create();
    }
    
    private void initViews(View view) {
        modeRadioGroup = view.findViewById(R.id.modeRadioGroup);
        radioModeServer = view.findViewById(R.id.radioModeServer);
        radioModeScript = view.findViewById(R.id.radioModeScript);
        serverModeLayout = view.findViewById(R.id.serverModeLayout);
        scriptModeLayout = view.findViewById(R.id.scriptModeLayout);
        addressRadioGroup = view.findViewById(R.id.addressRadioGroup);
        radioAddressAll = view.findViewById(R.id.radioAddressAll);
        radioAddressLocal = view.findViewById(R.id.radioAddressLocal);
        radioAddressCustom = view.findViewById(R.id.radioAddressCustom);
        editCustomAddress = view.findViewById(R.id.editCustomAddress);
        editPort = view.findViewById(R.id.editPort);
        portConflictRadioGroup = view.findViewById(R.id.portConflictRadioGroup);
        radioConflictFail = view.findViewById(R.id.radioConflictFail);
        radioConflictPickNext = view.findViewById(R.id.radioConflictPickNext);
        onLoadRadioGroup = view.findViewById(R.id.onLoadRadioGroup);
        radioLoadWait = view.findViewById(R.id.radioLoadWait);
        radioLoadResume = view.findViewById(R.id.radioLoadResume);
        editScriptPath = view.findViewById(R.id.editScriptPath);
        editGadgetName = view.findViewById(R.id.editGadgetName);
        editJsonPreview = view.findViewById(R.id.editJsonPreview);
        
        // File select button
        View btnSelectScript = view.findViewById(R.id.btnSelectScript);
        if (btnSelectScript != null) {
            btnSelectScript.setOnClickListener(v -> selectScriptFile());
        }
    }
    
    private void loadConfig() {
        isUpdatingUI = true;
        
        // Load mode
        if ("script".equals(config.mode)) {
            radioModeScript.setChecked(true);
            serverModeLayout.setVisibility(View.GONE);
            scriptModeLayout.setVisibility(View.VISIBLE);
        } else {
            radioModeServer.setChecked(true);
            serverModeLayout.setVisibility(View.VISIBLE);
            scriptModeLayout.setVisibility(View.GONE);
        }
        
        // Load address
        if ("127.0.0.1".equals(config.address)) {
            radioAddressLocal.setChecked(true);
        } else if ("0.0.0.0".equals(config.address)) {
            radioAddressAll.setChecked(true);
        } else {
            radioAddressCustom.setChecked(true);
            editCustomAddress.setText(config.address);
            editCustomAddress.setEnabled(true);
        }
        
        // Load port
        editPort.setText(String.valueOf(config.port));
        
        // Load port conflict handling
        if ("pick-next".equals(config.onPortConflict)) {
            radioConflictPickNext.setChecked(true);
        } else {
            radioConflictFail.setChecked(true);
        }
        
        // Load on load handling
        if ("resume".equals(config.onLoad)) {
            radioLoadResume.setChecked(true);
        } else {
            radioLoadWait.setChecked(true);
        }
        
        // Load script path
        editScriptPath.setText(config.scriptPath);
        
        // Load gadget name
        editGadgetName.setText(config.gadgetName);
        
        isUpdatingUI = false;
    }
    
    private void setupListeners() {
        // Mode radio group listener
        modeRadioGroup.setOnCheckedChangeListener((group, checkedId) -> {
            if (!isUpdatingUI) {
                if (checkedId == R.id.radioModeScript) {
                    config.mode = "script";
                    serverModeLayout.setVisibility(View.GONE);
                    scriptModeLayout.setVisibility(View.VISIBLE);
                } else {
                    config.mode = "server";
                    serverModeLayout.setVisibility(View.VISIBLE);
                    scriptModeLayout.setVisibility(View.GONE);
                }
                updateJsonPreview();
            }
        });
        
        // Address radio group listener
        addressRadioGroup.setOnCheckedChangeListener((group, checkedId) -> {
            if (!isUpdatingUI) {
                if (checkedId == R.id.radioAddressCustom) {
                    editCustomAddress.setEnabled(true);
                    editCustomAddress.requestFocus();
                } else {
                    editCustomAddress.setEnabled(false);
                    if (checkedId == R.id.radioAddressAll) {
                        config.address = "0.0.0.0";
                    } else if (checkedId == R.id.radioAddressLocal) {
                        config.address = "127.0.0.1";
                    }
                    updateJsonPreview();
                }
            }
        });
        
        // Custom address text watcher
        editCustomAddress.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
            
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {}
            
            @Override
            public void afterTextChanged(Editable s) {
                if (!isUpdatingUI && radioAddressCustom.isChecked()) {
                    config.address = s.toString().trim();
                    updateJsonPreview();
                }
            }
        });
        
        // Port text watcher
        editPort.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
            
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {}
            
            @Override
            public void afterTextChanged(Editable s) {
                if (!isUpdatingUI) {
                    try {
                        int port = Integer.parseInt(s.toString());
                        if (port >= 1 && port <= 65535) {
                            config.port = port;
                            updateJsonPreview();
                        }
                    } catch (NumberFormatException e) {
                        // Ignore invalid input
                    }
                }
            }
        });
        
        // Port conflict radio group listener
        portConflictRadioGroup.setOnCheckedChangeListener((group, checkedId) -> {
            if (!isUpdatingUI) {
                config.onPortConflict = (checkedId == R.id.radioConflictPickNext) ? "pick-next" : "fail";
                updateJsonPreview();
            }
        });
        
        // On load radio group listener
        onLoadRadioGroup.setOnCheckedChangeListener((group, checkedId) -> {
            if (!isUpdatingUI) {
                config.onLoad = (checkedId == R.id.radioLoadResume) ? "resume" : "wait";
                updateJsonPreview();
            }
        });
        
        // Script path text watcher
        editScriptPath.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
            
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {}
            
            @Override
            public void afterTextChanged(Editable s) {
                if (!isUpdatingUI) {
                    config.scriptPath = s.toString().trim();
                    updateJsonPreview();
                }
            }
        });
        
        // Gadget name text watcher
        editGadgetName.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
            
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {}
            
            @Override
            public void afterTextChanged(Editable s) {
                if (!isUpdatingUI) {
                    config.gadgetName = s.toString().trim();
                }
            }
        });
        
        // JSON preview text watcher
        editJsonPreview.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
            
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {}
            
            @Override
            public void afterTextChanged(Editable s) {
                if (!isUpdatingUI) {
                    parseJsonAndUpdateUI(s.toString());
                }
            }
        });
    }
    
    private void updateJsonPreview() {
        if (isUpdatingUI) return;
        
        try {
            JSONObject root = new JSONObject();
            JSONObject interaction = new JSONObject();
            
            if ("script".equals(config.mode)) {
                interaction.put("type", "script");
                interaction.put("path", config.scriptPath);
            } else {
                interaction.put("type", "listen");
                interaction.put("address", config.address);
                interaction.put("port", config.port);
                interaction.put("on_port_conflict", config.onPortConflict);
                interaction.put("on_load", config.onLoad);
            }
            
            root.put("interaction", interaction);
            
            isUpdatingUI = true;
            editJsonPreview.setText(root.toString(2));
            isUpdatingUI = false;
        } catch (JSONException e) {
            // Should not happen
            e.printStackTrace();
        }
    }
    
    private void parseJsonAndUpdateUI(String json) {
        try {
            JSONObject root = new JSONObject(json);
            JSONObject interaction = root.getJSONObject("interaction");
            
            isUpdatingUI = true;
            
            // Update mode
            String type = interaction.getString("type");
            if ("script".equals(type)) {
                config.mode = "script";
                radioModeScript.setChecked(true);
                serverModeLayout.setVisibility(View.GONE);
                scriptModeLayout.setVisibility(View.VISIBLE);
                
                // Update script path
                if (interaction.has("path")) {
                    config.scriptPath = interaction.getString("path");
                    editScriptPath.setText(config.scriptPath);
                }
            } else {
                config.mode = "server";
                radioModeServer.setChecked(true);
                serverModeLayout.setVisibility(View.VISIBLE);
                scriptModeLayout.setVisibility(View.GONE);
                
            // Update address
            String address = interaction.getString("address");
            config.address = address;
            if ("0.0.0.0".equals(address)) {
                radioAddressAll.setChecked(true);
                editCustomAddress.setEnabled(false);
            } else if ("127.0.0.1".equals(address)) {
                radioAddressLocal.setChecked(true);
                editCustomAddress.setEnabled(false);
            } else {
                radioAddressCustom.setChecked(true);
                editCustomAddress.setText(address);
                editCustomAddress.setEnabled(true);
            }
            
            // Update port
            config.port = interaction.getInt("port");
            editPort.setText(String.valueOf(config.port));
            
            // Update port conflict
            String onPortConflict = interaction.getString("on_port_conflict");
            config.onPortConflict = onPortConflict;
            if ("pick-next".equals(onPortConflict)) {
                radioConflictPickNext.setChecked(true);
            } else {
                radioConflictFail.setChecked(true);
            }
            
            // Update on load
            String onLoad = interaction.getString("on_load");
            config.onLoad = onLoad;
            if ("resume".equals(onLoad)) {
                radioLoadResume.setChecked(true);
            } else {
                radioLoadWait.setChecked(true);
            }
            }
            
            isUpdatingUI = false;
        } catch (JSONException e) {
            // Invalid JSON, ignore
        }
    }
    
    private void saveConfig() {
        if (listener != null) {
            // Ensure gadget name is not empty
            if (config.gadgetName == null || config.gadgetName.trim().isEmpty()) {
                config.gadgetName = "libgadget.so";
            }
            listener.onGadgetConfigSaved(config);
        }
    }
    
    private void selectScriptFile() {
        String[] options = {"浏览文件系统", "从外部文件管理器选择", "手动输入路径"};
        
        new MaterialAlertDialogBuilder(requireContext())
                .setTitle("选择 Script 文件")
                .setItems(options, (dialog, which) -> {
                    if (which == 0) {
                        openFileBrowser();
                    } else if (which == 1) {
                        openFilePicker();
                    } else {
                        showPathInputDialog();
                    }
                })
                .show();
    }
    
    private void openFileBrowser() {
        // Show path selection dialog first
        String[] paths = {
            "/data/local/tmp",
            "/sdcard",
            "/sdcard/Download",
            "/storage/emulated/0",
            "自定义路径..."
        };
        
        new MaterialAlertDialogBuilder(requireContext())
                .setTitle("选择起始目录")
                .setItems(paths, (dialog, which) -> {
                    if (which == paths.length - 1) {
                        // Custom path
                        showCustomPathDialog();
                    } else {
                        Intent intent = new Intent(getContext(), FileBrowserActivity.class);
                        intent.putExtra(FileBrowserActivity.EXTRA_START_PATH, paths[which]);
                        intent.putExtra(FileBrowserActivity.EXTRA_FILE_FILTER, ".js");
                        fileBrowserLauncher.launch(intent);
                    }
                })
                .show();
    }
    
    private void showCustomPathDialog() {
        View view = getLayoutInflater().inflate(R.layout.dialog_input, null);
        android.widget.EditText editText = view.findViewById(android.R.id.edit);
        editText.setText("/");
        editText.setHint("输入起始路径");
        
        new MaterialAlertDialogBuilder(requireContext())
                .setTitle("自定义起始路径")
                .setView(view)
                .setPositiveButton("确定", (dialog, which) -> {
                    String path = editText.getText().toString().trim();
                    if (!path.isEmpty()) {
                        Intent intent = new Intent(getContext(), FileBrowserActivity.class);
                        intent.putExtra(FileBrowserActivity.EXTRA_START_PATH, path);
                        intent.putExtra(FileBrowserActivity.EXTRA_FILE_FILTER, ".js");
                        fileBrowserLauncher.launch(intent);
                    }
                })
                .setNegativeButton("取消", null)
                .show();
    }
    
    private void openFilePicker() {
        Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
        intent.setType("*/*");
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        // Add MIME types that might help filter JS files
        String[] mimeTypes = {"text/javascript", "application/javascript", "text/plain", "*/*"};
        intent.putExtra(Intent.EXTRA_MIME_TYPES, mimeTypes);
        // Suggest starting location
        intent.putExtra("android.provider.extra.INITIAL_URI", 
            android.net.Uri.parse("content://com.android.externalstorage.documents/document/primary%3ADownload"));
        filePickerLauncher.launch(intent);
    }
    
    private void showPathInputDialog() {
        View view = getLayoutInflater().inflate(R.layout.dialog_input, null);
        android.widget.EditText editText = view.findViewById(android.R.id.edit);
        editText.setText("/data/local/tmp/");
        editText.setHint("/data/local/tmp/script.js");
        
        new MaterialAlertDialogBuilder(requireContext())
                .setTitle("输入 Script 文件路径")
                .setView(view)
                .setPositiveButton("确定", (dialog, which) -> {
                    String path = editText.getText().toString().trim();
                    if (!path.isEmpty()) {
                        editScriptPath.setText(path);
                        config.scriptPath = path;
                        updateJsonPreview();
                    }
                })
                .setNegativeButton("取消", null)
                .show();
    }
    
    // Show method for non-fragment usage
    public void show() {
        if (getContext() == null) {
            throw new IllegalStateException("Context is required for non-fragment usage");
        }
        
        View view = LayoutInflater.from(getContext()).inflate(R.layout.dialog_gadget_config, null);
        initViews(view);
        
        // Initialize config if null
        if (config == null) {
            config = new ConfigManager.GadgetConfig();
        }
        
        loadConfig();
        setupListeners();
        updateJsonPreview();
        
        String title = customTitle != null ? customTitle : "Gadget 配置";
        
        new MaterialAlertDialogBuilder(getContext())
                .setTitle(title)
                .setView(view)
                .setPositiveButton("保存", (dialog, which) -> saveConfig())
                .setNegativeButton("取消", null)
                .show();
    }
    
    private Context savedContext;
    
    @Override
    public Context getContext() {
        Context context = super.getContext();
        if (context == null) {
            return savedContext;
        }
        return context;
    }
    
    // Constructor for non-fragment usage needs to save context
    public void setContext(Context context) {
        this.savedContext = context;
    }
    
    private String getPathFromUri(Uri uri) {
        String path = null;
        
        // Try to get path from MediaStore
        if ("content".equals(uri.getScheme())) {
            try {
                ContentResolver resolver = getContext().getContentResolver();
                try (Cursor cursor = resolver.query(uri, new String[]{"_data"}, null, null, null)) {
                    if (cursor != null && cursor.moveToFirst()) {
                        int columnIndex = cursor.getColumnIndex("_data");
                        if (columnIndex != -1) {
                            path = cursor.getString(columnIndex);
                        }
                    }
                }
            } catch (Exception e) {
                // Ignore
            }
            
            // Try DocumentsContract if MediaStore fails
            if (path == null && DocumentsContract.isDocumentUri(getContext(), uri)) {
                try {
                    String docId = DocumentsContract.getDocumentId(uri);
                    if (uri.getAuthority().equals("com.android.externalstorage.documents")) {
                        String[] split = docId.split(":");
                        if (split.length >= 2) {
                            String type = split[0];
                            if ("primary".equalsIgnoreCase(type)) {
                                path = "/storage/emulated/0/" + split[1];
                            } else {
                                path = "/storage/" + type + "/" + split[1];
                            }
                        }
                    }
                } catch (Exception e) {
                    // Ignore
                }
            }
        } else if ("file".equals(uri.getScheme())) {
            path = uri.getPath();
        }
        
        return path;
    }
}
```

`configapp/src/main/java/com/jiqiu/configapp/MainActivity.java`:

```java
package com.jiqiu.configapp;

import android.os.Bundle;

import androidx.activity.EdgeToEdge;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentManager;
import androidx.fragment.app.FragmentTransaction;

import com.google.android.material.bottomnavigation.BottomNavigationView;

public class MainActivity extends AppCompatActivity implements SettingsFragment.OnSettingsChangeListener {

    private BottomNavigationView bottomNavigationView;
    private AppListFragment appListFragment;
    private SettingsFragment settingsFragment;
    private SoManagerFragment soManagerFragment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        EdgeToEdge.enable(this);
        setContentView(R.layout.activity_main);
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -> {
            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
            return insets;
        });

        initViews();
        setupBottomNavigation();

        // 默认显示应用列表
        if (savedInstanceState == null) {
            showAppListFragment();
        }
    }

    private void initViews() {
        bottomNavigationView = findViewById(R.id.bottom_navigation);
    }

    private void setupBottomNavigation() {
        bottomNavigationView.setOnItemSelectedListener(item -> {
            int itemId = item.getItemId();
            if (itemId == R.id.navigation_apps) {
                showAppListFragment();
                return true;
            } else if (itemId == R.id.navigation_so_manager) {
                showSoManagerFragment();
                return true;
            } else if (itemId == R.id.navigation_settings) {
                showSettingsFragment();
                return true;
            }
            return false;
        });
    }

    private void showAppListFragment() {
        if (appListFragment == null) {
            appListFragment = new AppListFragment();
        }
        showFragment(appListFragment);
    }

    private void showSoManagerFragment() {
        if (soManagerFragment == null) {
            soManagerFragment = new SoManagerFragment();
        }
        showFragment(soManagerFragment);
    }

    private void showSettingsFragment() {
        if (settingsFragment == null) {
            settingsFragment = new SettingsFragment();
            settingsFragment.setOnSettingsChangeListener(this);
        }
        showFragment(settingsFragment);
    }

    private void showFragment(Fragment fragment) {
        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction transaction = fragmentManager.beginTransaction();
        transaction.replace(R.id.nav_host_fragment, fragment);
        transaction.commit();
    }

    @Override
    public void onHideSystemAppsChanged(boolean hideSystemApps) {
        // 当设置改变时，通知应用列表Fragment更新过滤
        if (appListFragment != null) {
            appListFragment.setHideSystemApps(hideSystemApps);
        }
    }
}
```

`configapp/src/main/java/com/jiqiu/configapp/SettingsFragment.java`:

```java
package com.jiqiu.configapp;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.EditText;
import android.text.TextWatcher;
import android.text.Editable;
import android.widget.TextView;
import android.widget.Button;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;

/**
 * 设置Fragment
 */
public class SettingsFragment extends Fragment {
    
    private static final String PREFS_NAME = "MyInjectorSettings";
    private static final String KEY_HIDE_SYSTEM_APPS = "hide_system_apps";
    
    private RadioGroup radioGroupFilter;
    private RadioButton radioShowAll;
    private RadioButton radioHideSystem;
    private EditText editInjectionDelay;
    private TextView tvGlobalGadgetStatus;
    private Button btnConfigureGlobalGadget;
    private ConfigManager configManager;
    
    private SharedPreferences sharedPreferences;
    private OnSettingsChangeListener settingsChangeListener;
    
    public interface OnSettingsChangeListener {
        void onHideSystemAppsChanged(boolean hideSystemApps);
    }
    
    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, 
                           @Nullable Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_settings, container, false);
    }
    
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        
        initViews(view);
        initSharedPreferences();
        loadSettings();
        setupListeners();
    }
    
    private void initViews(View view) {
        radioGroupFilter = view.findViewById(R.id.radio_group_filter);
        radioShowAll = view.findViewById(R.id.radio_show_all);
        radioHideSystem = view.findViewById(R.id.radio_hide_system);
        editInjectionDelay = view.findViewById(R.id.editInjectionDelay);
        tvGlobalGadgetStatus = view.findViewById(R.id.tvGlobalGadgetStatus);
        btnConfigureGlobalGadget = view.findViewById(R.id.btnConfigureGlobalGadget);
        
        configManager = new ConfigManager(getContext());
    }
    
    private void initSharedPreferences() {
        sharedPreferences = getContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
    }
    
    private void loadSettings() {
        boolean hideSystemApps = sharedPreferences.getBoolean(KEY_HIDE_SYSTEM_APPS, false);
        
        if (hideSystemApps) {
            radioHideSystem.setChecked(true);
        } else {
            radioShowAll.setChecked(true);
        }
        
        // Load injection delay
        int injectionDelay = configManager.getInjectionDelay();
        editInjectionDelay.setText(String.valueOf(injectionDelay));
        
        // Load global gadget status
        updateGlobalGadgetStatus();
    }
    
    private void setupListeners() {
        radioGroupFilter.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(RadioGroup group, int checkedId) {
                boolean hideSystemApps = (checkedId == R.id.radio_hide_system);
                
                // 保存设置
                SharedPreferences.Editor editor = sharedPreferences.edit();
                editor.putBoolean(KEY_HIDE_SYSTEM_APPS, hideSystemApps);
                editor.apply();
                
                // 通知设置变化
                if (settingsChangeListener != null) {
                    settingsChangeListener.onHideSystemAppsChanged(hideSystemApps);
                }
            }
        });
        
        // Injection delay listener
        editInjectionDelay.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {}

            @Override
            public void afterTextChanged(Editable s) {
                String text = s.toString().trim();
                if (!text.isEmpty()) {
                    try {
                        int delay = Integer.parseInt(text);
                        // Limit delay between 0 and 60 seconds
                        if (delay < 0) delay = 0;
                        if (delay > 60) delay = 60;
                        
                        configManager.setInjectionDelay(delay);
                    } catch (NumberFormatException e) {
                        // Ignore invalid input
                    }
                }
            }
        });
        
        // Global gadget configuration button
        btnConfigureGlobalGadget.setOnClickListener(v -> {
            showGlobalGadgetConfigDialog();
        });
    }
    
    public void setOnSettingsChangeListener(OnSettingsChangeListener listener) {
        this.settingsChangeListener = listener;
    }
    
    public boolean isHideSystemApps() {
        return sharedPreferences.getBoolean(KEY_HIDE_SYSTEM_APPS, false);
    }
    
    private void updateGlobalGadgetStatus() {
        ConfigManager.GadgetConfig globalGadget = configManager.getGlobalGadgetConfig();
        if (globalGadget != null) {
            String status = "已配置: " + globalGadget.gadgetName;
            if (globalGadget.mode.equals("server")) {
                status += " (Server模式, 端口: " + globalGadget.port + ")";
            } else {
                status += " (Script模式)";
            }
            tvGlobalGadgetStatus.setText(status);
        } else {
            tvGlobalGadgetStatus.setText("未配置");
        }
    }
    
    private void showGlobalGadgetConfigDialog() {
        // Use existing GadgetConfigDialog
        GadgetConfigDialog dialog = new GadgetConfigDialog(
            getContext(),
            "全局Gadget配置",
            configManager.getGlobalGadgetConfig(),
            gadgetConfig -> {
                // Save global gadget configuration
                configManager.setGlobalGadgetConfig(gadgetConfig);
                updateGlobalGadgetStatus();
            }
        );
        dialog.show();
    }
}

```

`configapp/src/main/java/com/jiqiu/configapp/SoListAdapter.java`:

```java
package com.jiqiu.configapp;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageButton;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import java.util.ArrayList;
import java.util.List;

public class SoListAdapter extends RecyclerView.Adapter<SoListAdapter.ViewHolder> {
    
    private List<ConfigManager.SoFile> soFiles = new ArrayList<>();
    private OnSoFileActionListener listener;
    
    public interface OnSoFileActionListener {
        void onDeleteClick(ConfigManager.SoFile soFile);
    }
    
    public void setSoFiles(List<ConfigManager.SoFile> files) {
        this.soFiles = files;
        notifyDataSetChanged();
    }
    
    public void setOnSoFileActionListener(OnSoFileActionListener listener) {
        this.listener = listener;
    }
    
    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_so_file, parent, false);
        return new ViewHolder(view);
    }
    
    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        ConfigManager.SoFile soFile = soFiles.get(position);
        holder.bind(soFile);
    }
    
    @Override
    public int getItemCount() {
        return soFiles.size();
    }
    
    class ViewHolder extends RecyclerView.ViewHolder {
        private TextView textFileName;
        private TextView textFilePath;
        private ImageButton buttonDelete;
        
        public ViewHolder(@NonNull View itemView) {
            super(itemView);
            textFileName = itemView.findViewById(R.id.textFileName);
            textFilePath = itemView.findViewById(R.id.textFilePath);
            buttonDelete = itemView.findViewById(R.id.buttonDelete);
        }
        
        public void bind(ConfigManager.SoFile soFile) {
            textFileName.setText(soFile.name);
            textFilePath.setText(soFile.originalPath);
            
            buttonDelete.setOnClickListener(v -> {
                if (listener != null) {
                    listener.onDeleteClick(soFile);
                }
            });
        }
    }
}
```

`configapp/src/main/java/com/jiqiu/configapp/SoManagerFragment.java`:

```java
package com.jiqiu.configapp;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.LinearLayout;
import android.widget.Toast;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.fragment.app.Fragment;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.google.android.material.dialog.MaterialAlertDialogBuilder;
import com.google.android.material.floatingactionbutton.FloatingActionButton;
import com.topjohnwu.superuser.Shell;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class SoManagerFragment extends Fragment {
    
    private RecyclerView recyclerView;
    private LinearLayout emptyView;
    private SoListAdapter adapter;
    private ConfigManager configManager;
    private List<ConfigManager.SoFile> globalSoFiles = new ArrayList<>();
    
    private ActivityResultLauncher<Intent> filePickerLauncher;
    private ActivityResultLauncher<Intent> fileBrowserLauncher;
    
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        configManager = new ConfigManager(requireContext());
        // Ensure module directories exist
        configManager.ensureModuleDirectories();
        
        // Initialize file picker
        filePickerLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            result -> {
                if (result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
                    Uri uri = result.getData().getData();
                    if (uri != null) {
                        handleFileSelection(uri);
                    }
                }
            }
        );
        
        // Initialize file browser
        fileBrowserLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            result -> {
                if (result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
                    String path = result.getData().getStringExtra(FileBrowserActivity.EXTRA_SELECTED_PATH);
                    if (path != null) {
                        showDeleteOriginalDialog(path);
                    }
                }
            }
        );
    }
    
    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
                             @Nullable Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_so_manager, container, false);
    }
    
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        
        recyclerView = view.findViewById(R.id.recyclerView);
        emptyView = view.findViewById(R.id.emptyView);
        FloatingActionButton fabAdd = view.findViewById(R.id.fabAdd);
        
        // Setup RecyclerView
        adapter = new SoListAdapter();
        recyclerView.setLayoutManager(new LinearLayoutManager(getContext()));
        recyclerView.setAdapter(adapter);
        
        adapter.setOnSoFileActionListener(this::showDeleteConfirmation);
        
        // Setup FAB
        fabAdd.setOnClickListener(v -> showAddSoDialog());
        
        // Check root access
        if (!configManager.isRootAvailable()) {
            Toast.makeText(getContext(), "需要Root权限", Toast.LENGTH_LONG).show();
        } else {
            configManager.ensureModuleDirectories();
            // Also ensure common directories exist
            Shell.cmd("mkdir -p /data/local/tmp").exec();
            Shell.cmd("chmod 777 /data/local/tmp").exec();
            loadSoFiles();
        }
    }
    
    private void loadSoFiles() {
        // Load global SO files from config
        globalSoFiles = configManager.getAllSoFiles();
        updateUI();
    }
    
    private void updateUI() {
        if (globalSoFiles.isEmpty()) {
            emptyView.setVisibility(View.VISIBLE);
            recyclerView.setVisibility(View.GONE);
        } else {
            emptyView.setVisibility(View.GONE);
            recyclerView.setVisibility(View.VISIBLE);
            adapter.setSoFiles(globalSoFiles);
        }
    }
    
    private void showAddSoDialog() {
        String[] options = {"浏览文件系统", "从外部文件管理器选择", "手动输入路径"};
        
        new MaterialAlertDialogBuilder(requireContext())
                .setTitle("添加SO文件")
                .setItems(options, (dialog, which) -> {
                    if (which == 0) {
                        openFileBrowser();
                    } else if (which == 1) {
                        openFilePicker();
                    } else {
                        showPathInputDialog();
                    }
                })
                .show();
    }
    
    private void openFileBrowser() {
        // Show path selection dialog first
        String[] paths = {
            "/data/local/tmp",
            "/sdcard",
            "/sdcard/Download",
            "/storage/emulated/0",
            "自定义路径..."
        };
        
        new MaterialAlertDialogBuilder(requireContext())
                .setTitle("选择起始目录")
                .setItems(paths, (dialog, which) -> {
                    if (which == paths.length - 1) {
                        // Custom path
                        showCustomPathDialog();
                    } else {
                        Intent intent = new Intent(getContext(), FileBrowserActivity.class);
                        intent.putExtra(FileBrowserActivity.EXTRA_START_PATH, paths[which]);
                        intent.putExtra(FileBrowserActivity.EXTRA_FILE_FILTER, ".so");
                        fileBrowserLauncher.launch(intent);
                    }
                })
                .show();
    }
    
    private void showCustomPathDialog() {
        View view = getLayoutInflater().inflate(R.layout.dialog_input, null);
        android.widget.EditText editText = view.findViewById(android.R.id.edit);
        editText.setText("/");
        editText.setHint("输入起始路径");
        
        new MaterialAlertDialogBuilder(requireContext())
                .setTitle("自定义起始路径")
                .setView(view)
                .setPositiveButton("确定", (dialog, which) -> {
                    String path = editText.getText().toString().trim();
                    if (!path.isEmpty()) {
                        Intent intent = new Intent(getContext(), FileBrowserActivity.class);
                        intent.putExtra(FileBrowserActivity.EXTRA_START_PATH, path);
                        intent.putExtra(FileBrowserActivity.EXTRA_FILE_FILTER, ".so");
                        fileBrowserLauncher.launch(intent);
                    }
                })
                .setNegativeButton("取消", null)
                .show();
    }
    
    private void openFilePicker() {
        Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
        intent.setType("*/*");
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        // Add MIME types that might help filter SO files
        String[] mimeTypes = {"application/octet-stream", "application/x-sharedlib", "*/*"};
        intent.putExtra(Intent.EXTRA_MIME_TYPES, mimeTypes);
        // Suggest starting location
        intent.putExtra("android.provider.extra.INITIAL_URI", 
            android.net.Uri.parse("content://com.android.externalstorage.documents/document/primary%3ADownload"));
        filePickerLauncher.launch(intent);
    }
    
    private void showPathInputDialog() {
        View view = getLayoutInflater().inflate(R.layout.dialog_input, null);
        android.widget.EditText editText = view.findViewById(android.R.id.edit);
        editText.setText("/data/local/tmp/");
        editText.setHint("/data/local/tmp/example.so");
        
        new MaterialAlertDialogBuilder(requireContext())
                .setTitle("输入SO文件路径")
                .setView(view)
                .setPositiveButton("添加", (dialog, which) -> {
                    String path = editText.getText().toString().trim();
                    if (!path.isEmpty()) {
                        showDeleteOriginalDialog(path);
                    }
                })
                .setNegativeButton("取消", null)
                .show();
    }
    
    private void handleFileSelection(Uri uri) {
        // Get real path from URI using proper URI handling
        String path = FileUtils.getRealPathFromUri(requireContext(), uri);
        if (path != null) {
            showDeleteOriginalDialog(path);
        } else {
            Toast.makeText(getContext(), "无法获取文件路径，请尝试其他方式", Toast.LENGTH_SHORT).show();
        }
    }
    
    private void showDeleteOriginalDialog(String path) {
        new MaterialAlertDialogBuilder(requireContext())
                .setTitle("删除原文件")
                .setMessage("是否删除原始SO文件？\n\n文件路径：" + path)
                .setPositiveButton("删除原文件", (dialog, which) -> {
                    addSoFile(path, true);
                })
                .setNegativeButton("保留原文件", (dialog, which) -> {
                    addSoFile(path, false);
                })
                .setNeutralButton("取消", null)
                .show();
    }
    
    private void addSoFile(String path, boolean deleteOriginal) {
        // Verify file exists
        Shell.Result result = Shell.cmd("test -f \"" + path + "\" && echo 'exists'").exec();
        if (!result.isSuccess() || result.getOut().isEmpty()) {
            Toast.makeText(getContext(), "文件不存在: " + path, Toast.LENGTH_SHORT).show();
            return;
        }
        
        // Add to global SO files
        configManager.addGlobalSoFile(path, deleteOriginal);
        
        // Reload the list
        loadSoFiles();
        Toast.makeText(getContext(), "SO文件已添加", Toast.LENGTH_SHORT).show();
    }
    
    private void showDeleteConfirmation(ConfigManager.SoFile soFile) {
        new MaterialAlertDialogBuilder(requireContext())
                .setTitle("删除SO文件")
                .setMessage("确定要删除 " + soFile.name + " 吗？")
                .setPositiveButton("删除", (dialog, which) -> {
                    deleteSoFile(soFile);
                })
                .setNegativeButton("取消", null)
                .show();
    }
    
    private void deleteSoFile(ConfigManager.SoFile soFile) {
        configManager.removeGlobalSoFile(soFile);
        loadSoFiles();
        Toast.makeText(getContext(), "SO文件已删除", Toast.LENGTH_SHORT).show();
    }
}
```

`configapp/src/main/res/drawable/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#3DDC84"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>

```

`configapp/src/main/res/drawable/ic_launcher_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>
```

`configapp/src/main/res/drawable/system_app_badge.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#FF9800" />
    <corners android:radius="12dp" />
</shape>

```

`configapp/src/main/res/layout/activity_app_so_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize" />

    </com.google.android.material.appbar.AppBarLayout>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/recyclerView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:clipToPadding="false"
            android:padding="8dp" />

        <TextView
            android:id="@+id/emptyView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:gravity="center"
            android:text="暂无可用的SO文件\n请先在SO库管理中添加"
            android:textSize="16sp"
            android:textColor="?android:attr/textColorSecondary"
            android:visibility="gone" />

    </FrameLayout>

</LinearLayout>
```

`configapp/src/main/res/layout/activity_file_browser.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize" />

    </com.google.android.material.appbar.AppBarLayout>

    <TextView
        android:id="@+id/currentPath"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="?attr/colorSurfaceVariant"
        android:padding="12dp"
        android:text="/data/local/tmp"
        android:textSize="14sp"
        android:fontFamily="monospace"
        android:textColor="?attr/colorOnSurfaceVariant" />

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/recyclerView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:clipToPadding="false"
            android:padding="4dp" />

        <LinearLayout
            android:id="@+id/emptyView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:gravity="center"
            android:orientation="vertical"
            android:visibility="gone">

            <ImageView
                android:layout_width="96dp"
                android:layout_height="96dp"
                android:alpha="0.3"
                android:src="@android:drawable/ic_menu_search" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:text="此目录为空"
                android:textSize="18sp"
                android:textColor="?android:attr/textColorSecondary" />

        </LinearLayout>

    </FrameLayout>

</LinearLayout>
```

`configapp/src/main/res/layout/activity_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <!-- Fragment容器 -->
    <androidx.fragment.app.FragmentContainerView
        android:id="@+id/nav_host_fragment"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/bottom_navigation"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <!-- 底部导航栏 -->
    <com.google.android.material.bottomnavigation.BottomNavigationView
        android:id="@+id/bottom_navigation"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginStart="0dp"
        android:layout_marginEnd="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:menu="@menu/bottom_nav_menu" />

</androidx.constraintlayout.widget.ConstraintLayout>
```

`configapp/src/main/res/layout/dialog_app_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">
    
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="24dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:layout_marginBottom="16dp">

        <ImageView
            android:id="@+id/appIcon"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:layout_marginEnd="16dp"
            android:src="@drawable/ic_launcher_foreground" />

        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical">

            <TextView
                android:id="@+id/appName"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textSize="18sp"
                android:textStyle="bold"
                android:text="应用名称" />

            <TextView
                android:id="@+id/packageName"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textSize="12sp"
                android:textColor="?android:attr/textColorSecondary"
                android:text="com.example.app" />

        </LinearLayout>

    </LinearLayout>

    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="?android:attr/listDivider"
        android:layout_marginBottom="16dp" />

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="选择要注入的SO文件"
        android:textSize="14sp"
        android:textColor="?android:attr/textColorSecondary"
        android:layout_marginBottom="8dp" />

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/soListRecyclerView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:nestedScrollingEnabled="false"
        android:layout_marginBottom="16dp" />

    <TextView
        android:id="@+id/emptyText"
        android:layout_width="match_parent"
        android:layout_height="100dp"
        android:gravity="center"
        android:text="暂无可用的SO文件\n请先在SO库管理中添加"
        android:textSize="14sp"
        android:textColor="?android:attr/textColorTertiary"
        android:visibility="gone" />

    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="?android:attr/listDivider"
        android:layout_marginTop="16dp"
        android:layout_marginBottom="16dp" />

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Gadget 配置"
        android:textSize="14sp"
        android:textColor="?android:attr/textColorSecondary"
        android:layout_marginBottom="8dp" />

    <RadioGroup
        android:id="@+id/gadgetConfigGroup"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:layout_marginBottom="8dp">

        <RadioButton
            android:id="@+id/radioNoGadget"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="不使用Gadget"
            android:checked="true" />

        <RadioButton
            android:id="@+id/radioUseGlobalGadget"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="使用全局Gadget配置" />

        <TextView
            android:id="@+id/tvGlobalGadgetInfo"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="32dp"
            android:layout_marginBottom="4dp"
            android:text="未配置全局Gadget"
            android:textColor="?android:attr/textColorSecondary"
            android:textSize="12sp" />

        <RadioButton
            android:id="@+id/radioUseCustomGadget"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="自定义Gadget配置" />

    </RadioGroup>

    <com.google.android.material.button.MaterialButton
        android:id="@+id/btnConfigureGadget"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="配置Gadget"
        android:textSize="14sp"
        style="@style/Widget.MaterialComponents.Button.OutlinedButton"
        android:enabled="false"
        android:visibility="gone"
        android:layout_marginBottom="8dp" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Gadget可用于Frida调试，可配置监听地址和端口"
        android:textSize="12sp"
        android:textColor="?android:attr/textColorSecondary"
        android:layout_marginBottom="16dp" />

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="注入方式"
        android:textSize="14sp"
        android:textColor="?android:attr/textColorSecondary"
        android:layout_marginBottom="8dp" />

    <RadioGroup
        android:id="@+id/injectionMethodGroup"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <RadioButton
            android:id="@+id/radioStandardInjection"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="标准注入"
            android:checked="true" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="32dp"
            android:layout_marginBottom="8dp"
            android:text="使用标准dlopen方式注入"
            android:textColor="?android:attr/textColorSecondary"
            android:textSize="12sp" />

        <RadioButton
            android:id="@+id/radioRiruInjection"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Riru注入" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="使用Riru Hide隐藏注入的SO文件"
            android:textSize="12sp"
            android:textColor="?android:attr/textColorSecondary"
            android:layout_marginStart="32dp"
            android:layout_marginBottom="8dp" />

        <RadioButton
            android:id="@+id/radioCustomLinkerInjection"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="自定义Linker注入" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="使用自定义ELF加载器进行注入"
            android:textSize="12sp"
            android:textColor="?android:attr/textColorSecondary"
            android:layout_marginStart="32dp" />

    </RadioGroup>
    
    </LinearLayout>

</ScrollView>
```

`configapp/src/main/res/layout/dialog_gadget_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="24dp">

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Gadget 配置"
            android:textSize="18sp"
            android:textStyle="bold"
            android:layout_marginBottom="8dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="提示：请确保对应的 gadget SO 文件已添加到 SO 库中"
            android:textSize="12sp"
            android:textColor="?android:attr/textColorSecondary"
            android:layout_marginBottom="16dp" />

        <!-- 模式选择 -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Gadget 模式"
            android:textSize="14sp"
            android:textColor="?android:attr/textColorSecondary"
            android:layout_marginBottom="8dp" />

        <RadioGroup
            android:id="@+id/modeRadioGroup"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="16dp">

            <RadioButton
                android:id="@+id/radioModeServer"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="Server 模式"
                android:checked="true" />

            <RadioButton
                android:id="@+id/radioModeScript"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="Script 模式" />

        </RadioGroup>

        <!-- Server 模式配置区域 -->
        <LinearLayout
            android:id="@+id/serverModeLayout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

        <!-- 监听地址配置 -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="监听地址"
            android:textSize="14sp"
            android:textColor="?android:attr/textColorSecondary"
            android:layout_marginBottom="8dp" />

        <RadioGroup
            android:id="@+id/addressRadioGroup"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:layout_marginBottom="8dp">

            <RadioButton
                android:id="@+id/radioAddressAll"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="0.0.0.0 (监听所有接口)"
                android:checked="true" />

            <RadioButton
                android:id="@+id/radioAddressLocal"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="127.0.0.1 (仅本地)" />

            <RadioButton
                android:id="@+id/radioAddressCustom"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="自定义" />

        </RadioGroup>

        <EditText
            android:id="@+id/editCustomAddress"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="输入自定义地址"
            android:inputType="text"
            android:enabled="false"
            android:layout_marginBottom="16dp" />

        <!-- 端口配置 -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="监听端口"
            android:textSize="14sp"
            android:textColor="?android:attr/textColorSecondary"
            android:layout_marginBottom="8dp" />

        <EditText
            android:id="@+id/editPort"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:inputType="number"
            android:text="27042"
            android:hint="1-65535"
            android:layout_marginBottom="16dp" />

        <!-- 端口冲突处理 -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="端口冲突处理"
            android:textSize="14sp"
            android:textColor="?android:attr/textColorSecondary"
            android:layout_marginBottom="8dp" />

        <RadioGroup
            android:id="@+id/portConflictRadioGroup"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:layout_marginBottom="16dp">

            <RadioButton
                android:id="@+id/radioConflictFail"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="fail (启动失败)"
                android:checked="true" />

            <RadioButton
                android:id="@+id/radioConflictPickNext"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="pick-next (尝试下一个端口)" />

        </RadioGroup>

        <!-- 加载处理方式 -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="加载时处理方式"
            android:textSize="14sp"
            android:textColor="?android:attr/textColorSecondary"
            android:layout_marginBottom="8dp" />

        <RadioGroup
            android:id="@+id/onLoadRadioGroup"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:layout_marginBottom="16dp">

            <RadioButton
                android:id="@+id/radioLoadWait"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="wait (等待连接)"
                android:checked="true" />

            <RadioButton
                android:id="@+id/radioLoadResume"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="resume (立即继续)" />

        </RadioGroup>

        </LinearLayout>

        <!-- Script 模式配置区域 -->
        <LinearLayout
            android:id="@+id/scriptModeLayout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:visibility="gone">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Script 文件路径"
                android:textSize="14sp"
                android:textColor="?android:attr/textColorSecondary"
                android:layout_marginBottom="8dp" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_vertical"
                android:layout_marginBottom="16dp">

                <EditText
                    android:id="@+id/editScriptPath"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:hint="/data/local/tmp/script.js"
                    android:inputType="text"
                    android:layout_marginEnd="8dp" />

                <com.google.android.material.button.MaterialButton
                    android:id="@+id/btnSelectScript"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="选择"
                    android:textSize="12sp"
                    style="@style/Widget.MaterialComponents.Button.OutlinedButton" />

            </LinearLayout>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="提示：Script 模式下，Gadget 会在程序入口点执行前自动加载并运行指定的脚本文件"
                android:textSize="12sp"
                android:textColor="?android:attr/textColorSecondary"
                android:layout_marginBottom="16dp" />

        </LinearLayout>

        <!-- Gadget 名称 -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Gadget 文件名"
            android:textSize="14sp"
            android:textColor="?android:attr/textColorSecondary"
            android:layout_marginBottom="8dp" />

        <EditText
            android:id="@+id/editGadgetName"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="libgadget.so"
            android:hint="例如: libgadget.so"
            android:layout_marginBottom="16dp" />

        <!-- JSON 预览区域 -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="配置预览 (可直接编辑)"
            android:textSize="14sp"
            android:textColor="?android:attr/textColorSecondary"
            android:layout_marginBottom="8dp" />

        <com.google.android.material.card.MaterialCardView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:cardElevation="2dp"
            app:cardCornerRadius="4dp">

            <EditText
                android:id="@+id/editJsonPreview"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="150dp"
                android:gravity="top"
                android:padding="12dp"
                android:background="?android:attr/selectableItemBackground"
                android:fontFamily="monospace"
                android:textSize="12sp"
                android:inputType="textMultiLine"
                android:scrollbars="vertical"
                android:overScrollMode="always" />

        </com.google.android.material.card.MaterialCardView>

    </LinearLayout>

</ScrollView>
```

`configapp/src/main/res/layout/dialog_input.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="24dp">

    <EditText
        android:id="@android:id/edit"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:inputType="textUri"
        android:singleLine="true" />

</LinearLayout>
```

`configapp/src/main/res/layout/fragment_app_list.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp"
    tools:context=".AppListFragment">

    <!-- 搜索框 -->
    <com.google.android.material.textfield.TextInputLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="16dp"
        android:hint="@string/search_apps">

        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/search_edit_text"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:inputType="text"
            android:maxLines="1" />

    </com.google.android.material.textfield.TextInputLayout>

    <!-- 应用列表 -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_view_apps"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:scrollbars="vertical" />

    <!-- 加载进度条 -->
    <ProgressBar
        android:id="@+id/progress_bar"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:visibility="gone" />

</LinearLayout>

```

`configapp/src/main/res/layout/fragment_settings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".SettingsFragment">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp">

        <!-- 全局设置标题 -->
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/global_settings"
            android:textSize="18sp"
            android:textStyle="bold"
            android:layout_marginBottom="16dp" />

        <!-- 过滤系统应用设置 -->
        <com.google.android.material.card.MaterialCardView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="16dp">

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/filter_system_apps"
                    android:textSize="16sp"
                    android:textStyle="bold"
                    android:layout_marginBottom="8dp" />

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/filter_system_apps_desc"
                    android:textSize="14sp"
                    android:textColor="@android:color/darker_gray"
                    android:layout_marginBottom="12dp" />

                <RadioGroup
                    android:id="@+id/radio_group_filter"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content">

                    <RadioButton
                        android:id="@+id/radio_show_all"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="@string/show_all_apps"
                        android:checked="true" />

                    <RadioButton
                        android:id="@+id/radio_hide_system"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="@string/hide_system_apps" />

                </RadioGroup>

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

        <!-- 注入延迟时间设置 -->
        <com.google.android.material.card.MaterialCardView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="16dp">

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="注入延迟时间"
                    android:textSize="16sp"
                    android:textStyle="bold"
                    android:layout_marginBottom="8dp" />

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="设置SO文件注入前的等待时间，以确保应用完全初始化"
                    android:textSize="14sp"
                    android:textColor="@android:color/darker_gray"
                    android:layout_marginBottom="12dp" />

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:gravity="center_vertical">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="延迟时间（秒）："
                        android:textSize="14sp"
                        android:layout_marginEnd="8dp" />

                    <EditText
                        android:id="@+id/editInjectionDelay"
                        android:layout_width="80dp"
                        android:layout_height="wrap_content"
                        android:inputType="number"
                        android:text="2"
                        android:textAlignment="center"
                        android:hint="0-60"
                        android:layout_marginEnd="8dp" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="秒"
                        android:textSize="14sp" />

                </LinearLayout>

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="建议值：2-5秒。某些应用可能需要更长时间。"
                    android:textSize="12sp"
                    android:textColor="@android:color/darker_gray"
                    android:layout_marginTop="8dp" />

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

        <!-- 全局Gadget配置 -->
        <com.google.android.material.card.MaterialCardView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="16dp">

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="全局Gadget配置"
                    android:textSize="16sp"
                    android:textStyle="bold"
                    android:layout_marginBottom="8dp" />

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="配置全局默认的Gadget设置，应用可以选择使用或覆盖"
                    android:textSize="14sp"
                    android:textColor="@android:color/darker_gray"
                    android:layout_marginBottom="12dp" />

                <TextView
                    android:id="@+id/tvGlobalGadgetStatus"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="未配置"
                    android:textSize="14sp"
                    android:layout_marginBottom="8dp" />

                <com.google.android.material.button.MaterialButton
                    android:id="@+id/btnConfigureGlobalGadget"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="配置全局Gadget"
                    style="@style/Widget.MaterialComponents.Button.OutlinedButton" />

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

        <!-- 其他设置可以在这里添加 -->
        <com.google.android.material.card.MaterialCardView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="16dp">

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/about"
                    android:textSize="16sp"
                    android:textStyle="bold"
                    android:layout_marginBottom="8dp" />

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/app_description"
                    android:textSize="14sp"
                    android:textColor="@android:color/darker_gray" />

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

    </LinearLayout>

</ScrollView>

```

`configapp/src/main/res/layout/fragment_so_manager.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">

        <com.google.android.material.appbar.AppBarLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <com.google.android.material.appbar.MaterialToolbar
                android:id="@+id/toolbar"
                android:layout_width="match_parent"
                android:layout_height="?attr/actionBarSize"
                app:title="SO文件管理" />

        </com.google.android.material.appbar.AppBarLayout>

        <FrameLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent">

            <LinearLayout
                android:id="@+id/emptyView"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:gravity="center"
                android:orientation="vertical"
                android:padding="32dp"
                android:visibility="gone">

                <ImageView
                    android:layout_width="96dp"
                    android:layout_height="96dp"
                    android:alpha="0.3"
                    android:src="@drawable/ic_launcher_foreground" />

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="16dp"
                    android:text="暂无SO文件"
                    android:textSize="18sp"
                    android:textColor="?android:attr/textColorSecondary" />

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="8dp"
                    android:text="点击右下角按钮添加SO文件"
                    android:textSize="14sp"
                    android:textColor="?android:attr/textColorTertiary" />

            </LinearLayout>

            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/recyclerView"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:clipToPadding="false"
                android:paddingBottom="88dp"
                android:padding="8dp" />

        </FrameLayout>

    </LinearLayout>

    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/fabAdd"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom|end"
        android:layout_margin="16dp"
        android:src="@android:drawable/ic_input_add"
        app:tint="@android:color/white" />

</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

`configapp/src/main/res/layout/item_app.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="4dp"
    app:cardCornerRadius="8dp"
    app:cardElevation="2dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="12dp"
        android:gravity="center_vertical">

        <!-- 应用图标 -->
        <ImageView
            android:id="@+id/app_icon"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:layout_marginEnd="12dp"
            android:scaleType="centerCrop" />

        <!-- 应用信息 -->
        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical">

            <TextView
                android:id="@+id/app_name"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:textStyle="bold"
                android:maxLines="1"
                android:ellipsize="end" />

            <TextView
                android:id="@+id/package_name"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="12sp"
                android:textColor="@android:color/darker_gray"
                android:maxLines="1"
                android:ellipsize="end"
                android:layout_marginTop="2dp" />

            <!-- 系统应用标签 -->
            <TextView
                android:id="@+id/system_app_label"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/system_app"
                android:textSize="10sp"
                android:textColor="@android:color/white"
                android:background="@drawable/system_app_badge"
                android:padding="4dp"
                android:layout_marginTop="4dp"
                android:visibility="gone" />

        </LinearLayout>

        <!-- 启用开关 -->
        <com.google.android.material.switchmaterial.SwitchMaterial
            android:id="@+id/switch_enable"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp" />

    </LinearLayout>

</com.google.android.material.card.MaterialCardView>

```

`configapp/src/main/res/layout/item_file.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="16dp"
    android:gravity="center_vertical"
    android:background="?attr/selectableItemBackground">

    <ImageView
        android:id="@+id/fileIcon"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:padding="8dp"
        android:src="@android:drawable/ic_menu_save"
        android:tint="?attr/colorPrimary" />

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:layout_marginStart="16dp"
        android:orientation="vertical">

        <TextView
            android:id="@+id/fileName"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:text="example.so"
            android:singleLine="true"
            android:ellipsize="middle" />

        <TextView
            android:id="@+id/fileInfo"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="12sp"
            android:textColor="?android:attr/textColorSecondary"
            android:text="SO文件" />

    </LinearLayout>

</LinearLayout>
```

`configapp/src/main/res/layout/item_so_file.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="4dp"
    app:cardElevation="2dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical">

            <ImageView
                android:layout_width="40dp"
                android:layout_height="40dp"
                android:padding="8dp"
                android:src="@android:drawable/ic_menu_save"
                android:tint="?attr/colorPrimary" />

            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:layout_marginStart="16dp"
                android:orientation="vertical">

                <TextView
                    android:id="@+id/textFileName"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textSize="16sp"
                    android:textStyle="bold"
                    android:text="example.so" />

                <TextView
                    android:id="@+id/textFilePath"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="2dp"
                    android:textSize="12sp"
                    android:textColor="?android:attr/textColorSecondary"
                    android:text="/data/local/tmp/example.so"
                    android:ellipsize="middle"
                    android:singleLine="true" />

            </LinearLayout>

            <ImageButton
                android:id="@+id/buttonDelete"
                android:layout_width="48dp"
                android:layout_height="48dp"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:src="@android:drawable/ic_menu_delete"
                android:tint="?attr/colorError" />

        </LinearLayout>

        <LinearLayout
            android:id="@+id/layoutApps"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:orientation="horizontal"
            android:visibility="gone">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="使用此SO的应用: "
                android:textSize="12sp"
                android:textColor="?android:attr/textColorSecondary" />

            <TextView
                android:id="@+id/textAppCount"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="0"
                android:textSize="12sp"
                android:textColor="?attr/colorPrimary" />

        </LinearLayout>

    </LinearLayout>

</com.google.android.material.card.MaterialCardView>
```

`configapp/src/main/res/layout/item_so_selection.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="16dp"
    android:gravity="center_vertical"
    android:background="?attr/selectableItemBackground">

    <CheckBox
        android:id="@+id/checkBox"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginEnd="16dp" />

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:orientation="vertical">

        <TextView
            android:id="@+id/textName"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:textStyle="bold"
            android:text="example.so" />

        <TextView
            android:id="@+id/textPath"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="12sp"
            android:textColor="?android:attr/textColorSecondary"
            android:text="/data/local/tmp/example.so"
            android:singleLine="true"
            android:ellipsize="middle" />

    </LinearLayout>

</LinearLayout>
```

`configapp/src/main/res/menu/bottom_nav_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:id="@+id/navigation_apps"
        android:icon="@android:drawable/ic_menu_view"
        android:title="@string/title_apps" />

    <item
        android:id="@+id/navigation_so_manager"
        android:icon="@android:drawable/ic_menu_save"
        android:title="@string/title_so_manager" />
        
    <item
        android:id="@+id/navigation_settings"
        android:icon="@android:drawable/ic_menu_preferences"
        android:title="@string/title_settings" />
</menu>

```

`configapp/src/main/res/mipmap-anydpi-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`configapp/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`configapp/src/main/res/values-night/themes.xml`:

```xml
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Base.Theme.ZygiskMyInjector" parent="Theme.Material3.DayNight.NoActionBar">
        <!-- Customize your dark theme here. -->
        <!-- <item name="colorPrimary">@color/my_dark_primary</item> -->
    </style>
</resources>
```

`configapp/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
</resources>
```

`configapp/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name">MyInjector Config</string>

    <!-- 底部导航 -->
    <string name="title_apps">应用列表</string>
    <string name="title_so_manager">SO库管理</string>
    <string name="title_settings">全局设置</string>

    <!-- 应用列表 -->
    <string name="search_apps">搜索应用</string>
    <string name="system_app">系统应用</string>
    <string name="loading_apps">正在加载应用列表...</string>

    <!-- 设置页面 -->
    <string name="global_settings">全局设置</string>
    <string name="filter_system_apps">过滤系统应用</string>
    <string name="filter_system_apps_desc">选择是否在应用列表中显示系统应用</string>
    <string name="show_all_apps">显示所有应用</string>
    <string name="hide_system_apps">隐藏系统应用</string>

    <!-- 关于 -->
    <string name="about">关于</string>
    <string name="app_description">MyInjector 配置应用，用于管理注入设置</string>
</resources>
```

`configapp/src/main/res/values/themes.xml`:

```xml
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Base.Theme.ZygiskMyInjector" parent="Theme.Material3.DayNight.NoActionBar">
        <!-- Customize your light theme here. -->
        <!-- <item name="colorPrimary">@color/my_light_primary</item> -->
    </style>

    <style name="Theme.ZygiskMyInjector" parent="Base.Theme.ZygiskMyInjector" />
</resources>
```

`configapp/src/test/java/com/jiqiu/configapp/ExampleUnitTest.java`:

```java
package com.jiqiu.configapp;

import org.junit.Test;

import static org.junit.Assert.*;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() {
        assertEquals(4, 2 + 2);
    }
}
```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app"s APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Automatically convert third-party libraries to use AndroidX
android.enableJetifier=true
# Fix TLS handshake issues
systemProp.https.protocols=TLSv1.2,TLSv1.3

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Mon May 22 11:22:38 CST 2023
distributionBase=GRADLE_USER_HOME
distributionUrl=https\://services.gradle.org/distributions/gradle-7.5-bin.zip
distributionPath=wrapper/dists
zipStorePath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME

```

`gradlew`:

```
#!/usr/bin/env sh

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=$(save "$@")

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
  cd "$(dirname "$0")"
fi

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windows variants

if not "%OS%" == "Windows_NT" goto win9xME_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`module.gradle`:

```gradle
ext {
    moduleLibraryName = "myinjector"
    magiskModuleId = "zygisk_myinjector"
    moduleName = "myinjector"
    moduleAuthor = "jiqiu2021"
    moduleDescription = "注入任意SO到指定APP内"
    moduleVersion = "v0.01"
    moduleVersionCode = 1
}

```

`module/build.gradle`:

```gradle
import org.apache.tools.ant.filters.FixCrLfFilter

import java.nio.file.Paths
import java.nio.file.Files

apply plugin: 'com.android.library'
apply from: file(rootProject.file('module.gradle'))

android {
    compileSdkVersion rootProject.ext.targetSdkVersion
    ndkVersion '25.2.9519653'
    defaultConfig {
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        externalNativeBuild {
            cmake {
                arguments "-DMODULE_NAME:STRING=$moduleLibraryName"
            }
        }
    }
    buildFeatures {
        prefab true
    }
    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.22.1"
        }
    }
}

repositories {
    mavenLocal()
}

afterEvaluate {
    android.libraryVariants.forEach { variant ->
        def variantCapped = variant.name.capitalize()
        def variantLowered = variant.name.toLowerCase()

        def zipName = "${magiskModuleId.replace('_', '-')}-${moduleVersion}-${variantLowered}.zip"
        def magiskDir = file("$outDir/magisk_module_$variantLowered")

        task("prepareMagiskFiles${variantCapped}", type: Sync) {
            dependsOn("assemble$variantCapped")

            def templatePath = "$rootDir/template/magisk_module"

            into magiskDir
            from(templatePath) {
                exclude 'module.prop'
            }
            from(templatePath) {
                include 'module.prop'
                expand([
                        id         : magiskModuleId,
                        name       : moduleName,
                        version    : moduleVersion,
                        versionCode: moduleVersionCode.toString(),
                        author     : moduleAuthor,
                        description: moduleDescription,
                ])
                filter(FixCrLfFilter.class,
                        eol: FixCrLfFilter.CrLf.newInstance("lf"))
            }
            from("$buildDir/intermediates/stripped_native_libs/$variantLowered/out/lib") {
                into 'lib'
            }
            // Copy service.sh
            from("$projectDir") {
                include 'service.sh'
            }
            // Copy ConfigApp APK if it exists
            def apkFile = file("$rootDir/configapp/build/outputs/apk/debug/configapp-debug.apk")
            if (apkFile.exists()) {
                from(apkFile) {
                    rename { 'configapp.apk' }
                }
            }
            doLast {
                file("$magiskDir/zygisk").mkdir()
                fileTree("$magiskDir/lib").visit { f ->
                    if (!f.directory) return
                    def srcPath = Paths.get("${f.file.absolutePath}/lib${moduleLibraryName}.so")
                    def dstPath = Paths.get("$magiskDir/zygisk/${f.path}.so")
                    Files.move(srcPath, dstPath)
                }
                new File("$magiskDir/lib").deleteDir()
            }
        }

        task("zip${variantCapped}", type: Zip) {
            dependsOn("prepareMagiskFiles${variantCapped}")
            from magiskDir
            archiveFileName.set(zipName)
            destinationDirectory.set(outDir)
        }

        task("push${variantCapped}", type: Exec) {
            dependsOn("zip${variantCapped}")
            workingDir outDir
            commandLine android.adbExecutable, "push", zipName, "/data/local/tmp/"
        }

        task("flash${variantCapped}", type: Exec) {
            dependsOn("push${variantCapped}")
            commandLine android.adbExecutable, "shell", "su", "-c",
                    "magisk --install-module /data/local/tmp/${zipName}"
        }

        task("flashAndReboot${variantCapped}", type: Exec) {
            dependsOn("flash${variantCapped}")
            commandLine android.adbExecutable, "shell", "reboot"
        }

        variant.assembleProvider.get().finalizedBy("zip${variantCapped}")
    }
}

```

`module/service.sh`:

```sh
#!/system/bin/sh
MODDIR=${0%/*}

# 确保路径定义
export PATH=/system/bin:/system/xbin:$PATH

# 定义日志函数
log() {
    echo "[MyInjector] $(date '+%Y-%m-%d %H:%M:%S') $1" >> /data/local/tmp/myinjector_install.log
}

# APK 文件路径
APK_PATH="$MODDIR/configapp.apk"

# 检查 APK 是否存在
if [ ! -f "$APK_PATH" ]; then
    log "APK 文件不存在: $APK_PATH"
    exit 1
fi

# 等待系统完全启动
log "等待系统启动完成"
while [ "$(getprop sys.boot_completed)" != "1" ]; do
    sleep 1
done
sleep 5 # 额外等待，确保服务启动完成

# 检查 pm 是否可用
log "检查 pm 命令状态"
while ! pm list packages >/dev/null 2>&1; do
    sleep 1
done

# 检查是否已安装
INSTALLED=$(pm list packages com.jiqiu.configapp 2>/dev/null)
if [ -n "$INSTALLED" ]; then
    log "ConfigApp 已安装，检查版本"
    # 可以在这里添加版本检查逻辑
else
    log "ConfigApp 未安装，开始安装"
fi

# 获取系统版本
SDK_VERSION=$(getprop ro.build.version.sdk)
log "检测到系统版本: SDK $SDK_VERSION"

# 根据系统版本选择安装方法
if [ "$SDK_VERSION" -ge 29 ]; then
    # 高版本 Android（SDK >= 29）
    log "使用高版本安装逻辑"
    {
        INSTALL_SESSION=$(pm install-create -r)
        if [ $? -ne 0 ]; then
            log "创建安装会话失败"
            exit 1
        fi
        log "安装会话创建成功: $INSTALL_SESSION"

        pm install-write "$INSTALL_SESSION" 0 "$APK_PATH"
        if [ $? -ne 0 ]; then
            log "写入 APK 文件失败"
            log "降级，使用低版本安装逻辑"
            pm install -r "$APK_PATH" >> /data/local/tmp/myinjector_install.log 2>&1
            if [ $? -ne 0 ]; then
                log "APK 安装失败"
                exit 1
            fi
            log "APK 安装完成"
            exit 0
        fi
        log "APK 写入成功"

        pm install-commit "$INSTALL_SESSION"
        if [ $? -ne 0 ]; then
            log "提交安装会话失败"
            exit 1
        fi
        log "APK 安装完成"
    } >> /data/local/tmp/myinjector_install.log 2>&1
else
    # 低版本 Android（SDK < 29）
    log "使用低版本安装逻辑"
    pm install -r "$APK_PATH" >> /data/local/tmp/myinjector_install.log 2>&1
    if [ $? -ne 0 ]; then
        log "APK 安装失败"
        exit 1
    fi
    log "APK 安装完成"
fi

# 确保模块目录权限正确
chmod -R 755 /data/adb/modules/zygisk-myinjector
chown -R root:root /data/adb/modules/zygisk-myinjector

log "ConfigApp 安装脚本执行完成"

# 脚本完成
exit 0
```

`module/src/main/AndroidManifest.xml`:

```xml
<manifest package="zygisk.il2cppdumper" />

```

`module/src/main/cpp/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.18.1)

if (NOT DEFINED MODULE_NAME)
    message(FATAL_ERROR "MODULE_NAME is not set")
else ()
    project(${MODULE_NAME})
endif ()

message("Build type: ${CMAKE_BUILD_TYPE}")

set(CMAKE_CXX_STANDARD 20)

set(LINKER_FLAGS "-ffixed-x18 -Wl,--hash-style=both")
set(C_FLAGS "-Werror=format -fdata-sections -ffunction-sections")
set(CXX_FLAGS "${CXX_FLAGS} -fno-exceptions -fno-rtti")

if (NOT CMAKE_BUILD_TYPE STREQUAL "Debug")
    set(C_FLAGS "${C_FLAGS} -O2 -fvisibility=hidden -fvisibility-inlines-hidden")
    set(LINKER_FLAGS "${LINKER_FLAGS} -Wl,-exclude-libs,ALL -Wl,--gc-sections -Wl,--strip-all")
else ()
    set(C_FLAGS "${C_FLAGS} -O0")
endif ()

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${C_FLAGS}")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${C_FLAGS} ${CXX_FLAGS}")

set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${LINKER_FLAGS}")
set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} ${LINKER_FLAGS}")

include_directories(
        xdl/include
        mylinker/include
)

aux_source_directory(xdl xdl-src)

# Build mylinker as a subdirectory
add_subdirectory(mylinker)

add_library(${MODULE_NAME} SHARED
        main.cpp
        hack_new.cpp
        config.cpp
        newriruhide.cpp
        pmparser.cpp
        ${xdl-src})
target_link_libraries(${MODULE_NAME} log mylinker)

if (NOT CMAKE_BUILD_TYPE STREQUAL "Debug")
    add_custom_command(TARGET ${MODULE_NAME} POST_BUILD
            COMMAND ${CMAKE_STRIP} --strip-all --remove-section=.comment "${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/lib${MODULE_NAME}.so")
endif ()

```

`module/src/main/cpp/config.cpp`:

```cpp
#include "config.h"
#include <fstream>
#include <sstream>
#include <android/log.h>

#define LOG_TAG "MyInjector"
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

namespace Config {
    
    static ModuleConfig g_config;
    static bool g_configLoaded = false;
    
    // Simple JSON parser for our specific format
    std::string extractValue(const std::string& json, const std::string& key) {
        size_t keyPos = json.find("\"" + key + "\"");
        if (keyPos == std::string::npos) return "";
        
        size_t colonPos = json.find(":", keyPos);
        if (colonPos == std::string::npos) return "";
        
        size_t valueStart = json.find_first_not_of(" \t\n", colonPos + 1);
        if (valueStart == std::string::npos) return "";
        
        if (json[valueStart] == '"') {
            // String value
            size_t valueEnd = json.find('"', valueStart + 1);
            if (valueEnd == std::string::npos) return "";
            return json.substr(valueStart + 1, valueEnd - valueStart - 1);
        } else if (json[valueStart] == 't' || json[valueStart] == 'f') {
            // Boolean value
            return (json.substr(valueStart, 4) == "true") ? "true" : "false";
        } else {
            // Number value
            size_t valueEnd = json.find_first_of(",} \t\n", valueStart);
            if (valueEnd == std::string::npos) {
                return json.substr(valueStart);
            }
            return json.substr(valueStart, valueEnd - valueStart);
        }
        
        return "";
    }
    
    void parseAppConfig(const std::string& packageName, const std::string& appJson) {
        AppConfig appConfig;
        
        // Parse enabled
        std::string enabledStr = extractValue(appJson, "enabled");
        appConfig.enabled = (enabledStr == "true");
        
        // Parse injection method
        std::string methodStr = extractValue(appJson, "injectionMethod");
        if (methodStr == "2" || methodStr == "custom_linker") {
            appConfig.injectionMethod = InjectionMethod::CUSTOM_LINKER;
        } else if (methodStr == "1" || methodStr == "riru") {
            appConfig.injectionMethod = InjectionMethod::RIRU;
        } else {
            appConfig.injectionMethod = InjectionMethod::STANDARD;
        }
        
        // Parse soFiles array
        size_t soFilesPos = appJson.find("\"soFiles\"");
        if (soFilesPos != std::string::npos) {
            size_t arrayStart = appJson.find("[", soFilesPos);
            size_t arrayEnd = appJson.find("]", arrayStart);
            
            if (arrayStart != std::string::npos && arrayEnd != std::string::npos) {
                std::string soFilesArray = appJson.substr(arrayStart + 1, arrayEnd - arrayStart - 1);
                
                // Parse each SO file object
                size_t objStart = 0;
                while ((objStart = soFilesArray.find("{", objStart)) != std::string::npos) {
                    size_t objEnd = soFilesArray.find("}", objStart);
                    if (objEnd == std::string::npos) break;
                    
                    std::string soFileObj = soFilesArray.substr(objStart, objEnd - objStart + 1);
                    
                    SoFile soFile;
                    soFile.name = extractValue(soFileObj, "name");
                    soFile.storedPath = extractValue(soFileObj, "storedPath");
                    soFile.originalPath = extractValue(soFileObj, "originalPath");
                    
                    if (!soFile.storedPath.empty()) {
                        appConfig.soFiles.push_back(soFile);
                        LOGD("Added SO file: %s at %s", soFile.name.c_str(), soFile.storedPath.c_str());
                    }
                    
                    objStart = objEnd + 1;
                }
            }
        }
        
        // Parse gadgetConfig if exists
        size_t gadgetPos = appJson.find("\"gadgetConfig\"");
        if (gadgetPos != std::string::npos) {
            size_t gadgetObjStart = appJson.find("{", gadgetPos);
            size_t gadgetObjEnd = appJson.find("}", gadgetObjStart);
            
            if (gadgetObjStart != std::string::npos && gadgetObjEnd != std::string::npos) {
                std::string gadgetObj = appJson.substr(gadgetObjStart, gadgetObjEnd - gadgetObjStart + 1);
                
                GadgetConfig* gadgetConfig = new GadgetConfig();
                
                std::string address = extractValue(gadgetObj, "address");
                if (!address.empty()) gadgetConfig->address = address;
                
                std::string portStr = extractValue(gadgetObj, "port");
                if (!portStr.empty()) gadgetConfig->port = std::stoi(portStr);
                
                std::string onPortConflict = extractValue(gadgetObj, "onPortConflict");
                if (!onPortConflict.empty()) gadgetConfig->onPortConflict = onPortConflict;
                
                std::string onLoad = extractValue(gadgetObj, "onLoad");
                if (!onLoad.empty()) gadgetConfig->onLoad = onLoad;
                
                std::string gadgetName = extractValue(gadgetObj, "gadgetName");
                if (!gadgetName.empty()) gadgetConfig->gadgetName = gadgetName;
                
                appConfig.gadgetConfig = gadgetConfig;
                LOGD("Loaded gadget config: %s:%d, name: %s", 
                     gadgetConfig->address.c_str(), gadgetConfig->port, gadgetConfig->gadgetName.c_str());
            }
        }
        
        g_config.perAppConfig[packageName] = appConfig;
        const char* methodName = appConfig.injectionMethod == InjectionMethod::CUSTOM_LINKER ? "custom_linker" :
                                 appConfig.injectionMethod == InjectionMethod::RIRU ? "riru" : "standard";
        LOGD("Loaded config for app: %s, enabled: %d, method: %s, SO files: %zu, gadget: %s", 
             packageName.c_str(), appConfig.enabled, methodName, appConfig.soFiles.size(),
             appConfig.gadgetConfig ? "yes" : "no");
    }
    
    ModuleConfig readConfig() {
        if (g_configLoaded) {
            return g_config;
        }
        
        const char* configPath = "/data/adb/modules/zygisk-myinjector/config.json";
        std::ifstream file(configPath);
        
        if (!file.is_open()) {
            LOGE("Failed to open config file: %s", configPath);
            g_configLoaded = true;
            return g_config;
        }
        
        std::stringstream buffer;
        buffer << file.rdbuf();
        std::string json = buffer.str();
        file.close();
        
        // Parse global settings
        std::string enabledStr = extractValue(json, "enabled");
        g_config.enabled = (enabledStr != "false");
        
        std::string hideStr = extractValue(json, "hideInjection");
        g_config.hideInjection = (hideStr == "true");
        
        std::string delayStr = extractValue(json, "injectionDelay");
        if (!delayStr.empty()) {
            g_config.injectionDelay = std::stoi(delayStr);
        }
        
        LOGD("Module enabled: %d, hide injection: %d, injection delay: %d", 
             g_config.enabled, g_config.hideInjection, g_config.injectionDelay);
        
        // Parse perAppConfig
        size_t perAppPos = json.find("\"perAppConfig\"");
        if (perAppPos != std::string::npos) {
            size_t objStart = json.find("{", perAppPos + 14);
            size_t objEnd = json.rfind("}");
            
            if (objStart != std::string::npos && objEnd != std::string::npos) {
                std::string perAppObj = json.substr(objStart + 1, objEnd - objStart - 1);
                
                // Find each package config
                size_t pos = 0;
                while (pos < perAppObj.length()) {
                    // Find package name
                    size_t pkgStart = perAppObj.find("\"", pos);
                    if (pkgStart == std::string::npos) break;
                    
                    size_t pkgEnd = perAppObj.find("\"", pkgStart + 1);
                    if (pkgEnd == std::string::npos) break;
                    
                    std::string packageName = perAppObj.substr(pkgStart + 1, pkgEnd - pkgStart - 1);
                    
                    // Find app config object
                    size_t appObjStart = perAppObj.find("{", pkgEnd);
                    if (appObjStart == std::string::npos) break;
                    
                    // Find matching closing brace
                    int braceCount = 1;
                    size_t appObjEnd = appObjStart + 1;
                    while (appObjEnd < perAppObj.length() && braceCount > 0) {
                        if (perAppObj[appObjEnd] == '{') braceCount++;
                        else if (perAppObj[appObjEnd] == '}') braceCount--;
                        appObjEnd++;
                    }
                    
                    if (braceCount == 0) {
                        std::string appConfigStr = perAppObj.substr(appObjStart, appObjEnd - appObjStart);
                        parseAppConfig(packageName, appConfigStr);
                    }
                    
                    pos = appObjEnd;
                }
            }
        }
        
        g_configLoaded = true;
        return g_config;
    }
    
    bool isAppEnabled(const std::string& packageName) {
        if (!g_configLoaded) {
            readConfig();
        }
        
        auto it = g_config.perAppConfig.find(packageName);
        if (it != g_config.perAppConfig.end()) {
            return it->second.enabled;
        }
        return false;
    }
    
    std::vector<SoFile> getAppSoFiles(const std::string& packageName) {
        if (!g_configLoaded) {
            readConfig();
        }
        
        auto it = g_config.perAppConfig.find(packageName);
        if (it != g_config.perAppConfig.end()) {
            LOGD("Found app config for %s with %zu SO files", packageName.c_str(), it->second.soFiles.size());
            return it->second.soFiles;
        }
        LOGD("No app config found for %s", packageName.c_str());
        return {};
    }
    
    bool shouldHideInjection() {
        if (!g_configLoaded) {
            readConfig();
        }
        return g_config.hideInjection;
    }
    
    InjectionMethod getAppInjectionMethod(const std::string& packageName) {
        if (!g_configLoaded) {
            readConfig();
        }
        
        auto it = g_config.perAppConfig.find(packageName);
        if (it != g_config.perAppConfig.end()) {
            return it->second.injectionMethod;
        }
        return InjectionMethod::STANDARD;
    }
    
    int getInjectionDelay() {
        if (!g_configLoaded) {
            readConfig();
        }
        return g_config.injectionDelay;
    }
}
```

`module/src/main/cpp/config.h`:

```h
#ifndef CONFIG_H
#define CONFIG_H

#include <string>
#include <vector>
#include <unordered_map>

namespace Config {
    
    struct SoFile {
        std::string name;
        std::string storedPath;
        std::string originalPath;
    };
    
    enum class InjectionMethod {
        STANDARD = 0,
        RIRU = 1,
        CUSTOM_LINKER = 2
    };
    
    struct GadgetConfig {
        std::string address = "0.0.0.0";
        int port = 27042;
        std::string onPortConflict = "fail";
        std::string onLoad = "wait";
        std::string gadgetName = "libgadget.so";
    };
    
    struct AppConfig {
        bool enabled = false;
        InjectionMethod injectionMethod = InjectionMethod::STANDARD;
        std::vector<SoFile> soFiles;
        GadgetConfig* gadgetConfig = nullptr;
    };
    
    struct ModuleConfig {
        bool enabled = true;
        bool hideInjection = false;
        int injectionDelay = 2; // Default 2 seconds
        std::unordered_map<std::string, AppConfig> perAppConfig;
    };
    
    // Read configuration from file
    ModuleConfig readConfig();
    
    // Check if app is enabled for injection
    bool isAppEnabled(const std::string& packageName);
    
    // Get SO files for specific app
    std::vector<SoFile> getAppSoFiles(const std::string& packageName);
    
    // Get hide injection setting
    bool shouldHideInjection();
    
    // Get injection method for specific app
    InjectionMethod getAppInjectionMethod(const std::string& packageName);
    
    // Get injection delay in seconds
    int getInjectionDelay();
}

#endif // CONFIG_H
```

`module/src/main/cpp/game.h`:

```h
//
// Created by Perfare on 2020/7/4.
//

#ifndef ZYGISK_IL2CPPDUMPER_GAME_H
#define ZYGISK_IL2CPPDUMPER_GAME_H

#define AimPackageName "com.tencent.mobileqq"

#endif //ZYGISK_IL2CPPDUMPER_GAME_H

```

`module/src/main/cpp/hack.cpp`:

```cpp
//
// Created by Perfare on 2020/7/4.
//

#include "hack.h"
#include "log.h"
#include "xdl.h"
#include <cstring>
#include <cstdio>
#include <unistd.h>
#include <sys/system_properties.h>
#include <dlfcn.h>
#include <jni.h>
#include <thread>
#include <sys/mman.h>
#include <linux/unistd.h>
#include <array>
#include <sys/stat.h>
//#include <asm-generic/fcntl.h>
#include <fcntl.h>
#include "newriruhide.h"
void load_so(const char *game_data_dir, JavaVM *vm, const char *soname) {
    bool load = false;
    LOGI("hack_start %s", game_data_dir);

    // 构建新文件路径，使用传入的 soname 参数
    char new_so_path[256];
    snprintf(new_so_path, sizeof(new_so_path), "%s/files/%s.so", game_data_dir, soname);

    // 构建源文件路径
    char src_path[256];
    snprintf(src_path, sizeof(src_path), "/data/local/tmp/%s.so", soname);

    // 打开源文件
    int src_fd = open(src_path, O_RDONLY);
    if (src_fd < 0) {
        LOGE("Failed to open %s: %s (errno: %d)", src_path, strerror(errno), errno);
        return;
    }

    // 打开目标文件
    int dest_fd = open(new_so_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (dest_fd < 0) {
        LOGE("Failed to open %s", new_so_path);
        close(src_fd);
        return;
    }

    // 复制文件内容
    char buffer[4096];
    ssize_t bytes;
    while ((bytes = read(src_fd, buffer, sizeof(buffer))) > 0) {
        if (write(dest_fd, buffer, bytes) != bytes) {
            LOGE("Failed to write to %s", new_so_path);
            close(src_fd);
            close(dest_fd);
            return;
        }
    }

    // 关闭文件描述符
    close(src_fd);
    close(dest_fd);

    // 修改文件权限
    if (chmod(new_so_path, 0755) != 0) {
        LOGE("Failed to change permissions on %s: %s (errno: %d)", new_so_path, strerror(errno), errno);
        return;
    } else {
        LOGI("Successfully changed permissions to 755 on %s", new_so_path);
    }

    // 加载 .so 文件
    void *handle;
    for (int i = 0; i < 10; i++) {
        handle = dlopen(new_so_path, RTLD_NOW | RTLD_LOCAL);
        if (handle) {
            LOGI("Successfully loaded %s", new_so_path);
            load = true;
            char new_soname[256];
            sprintf(new_soname, "%s.so", soname);
            riru_hide(new_soname);
            break;
        } else {
            LOGE("Failed to load %s: %s", new_so_path, dlerror());
            sleep(1);
        }
    }

    // 如果加载失败
    if (!load) {
        LOGI("%s.so not found in thread %d", soname, gettid());
    }

    // 查找 JNI_OnLoad 并调用
//    void (*setupSignalHandler)();
//    *(void **) (&setupSignalHandler) = dlsym(handle, "setupSignalHandler");
//
//    if (setupSignalHandler) {
//        LOGI("setupSignalHandler symbol found, calling setupSignalHandler.");
//        setupSignalHandler();  // 调用找到的函数
//    } else {
//        LOGE("setupSignalHandler symbol not found in %s", new_so_path);
//    }
}
void hack_start(const char *game_data_dir,JavaVM *vm) {
    load_so(game_data_dir,vm,"test");
    //如果要注入多个so，那么就在这里不断的添加load_so函数即可
}

std::string GetLibDir(JavaVM *vms) {
    JNIEnv *env = nullptr;
    vms->AttachCurrentThread(&env, nullptr);
    jclass activity_thread_clz = env->FindClass("android/app/ActivityThread");
    if (activity_thread_clz != nullptr) {
        jmethodID currentApplicationId = env->GetStaticMethodID(activity_thread_clz,
                                                                "currentApplication",
                                                                "()Landroid/app/Application;");
        if (currentApplicationId) {
            jobject application = env->CallStaticObjectMethod(activity_thread_clz,
                                                              currentApplicationId);
            jclass application_clazz = env->GetObjectClass(application);
            if (application_clazz) {
                jmethodID get_application_info = env->GetMethodID(application_clazz,
                                                                  "getApplicationInfo",
                                                                  "()Landroid/content/pm/ApplicationInfo;");
                if (get_application_info) {
                    jobject application_info = env->CallObjectMethod(application,
                                                                     get_application_info);
                    jfieldID native_library_dir_id = env->GetFieldID(
                            env->GetObjectClass(application_info), "nativeLibraryDir",
                            "Ljava/lang/String;");
                    if (native_library_dir_id) {
                        auto native_library_dir_jstring = (jstring) env->GetObjectField(
                                application_info, native_library_dir_id);
                        auto path = env->GetStringUTFChars(native_library_dir_jstring, nullptr);
                        LOGI("lib dir %s", path);
                        std::string lib_dir(path);
                        env->ReleaseStringUTFChars(native_library_dir_jstring, path);
                        return lib_dir;
                    } else {
                        LOGE("nativeLibraryDir not found");
                    }
                } else {
                    LOGE("getApplicationInfo not found");
                }
            } else {
                LOGE("application class not found");
            }
        } else {
            LOGE("currentApplication not found");
        }
    } else {
        LOGE("ActivityThread not found");
    }
    return {};
}

static std::string GetNativeBridgeLibrary() {
    auto value = std::array<char, PROP_VALUE_MAX>();
    __system_property_get("ro.dalvik.vm.native.bridge", value.data());
    return {value.data()};
}

struct NativeBridgeCallbacks {
    uint32_t version;
    void *initialize;

    void *(*loadLibrary)(const char *libpath, int flag);

    void *(*getTrampoline)(void *handle, const char *name, const char *shorty, uint32_t len);

    void *isSupported;
    void *getAppEnv;
    void *isCompatibleWith;
    void *getSignalHandler;
    void *unloadLibrary;
    void *getError;
    void *isPathSupported;
    void *initAnonymousNamespace;
    void *createNamespace;
    void *linkNamespaces;

    void *(*loadLibraryExt)(const char *libpath, int flag, void *ns);
};

bool NativeBridgeLoad(const char *game_data_dir, int api_level, void *data, size_t length) {
    //TODO 等待houdini初始化
    sleep(5);

    auto libart = dlopen("libart.so", RTLD_NOW);
    auto JNI_GetCreatedJavaVMs = (jint (*)(JavaVM **, jsize, jsize *)) dlsym(libart,
                                                                             "JNI_GetCreatedJavaVMs");
    LOGI("JNI_GetCreatedJavaVMs %p", JNI_GetCreatedJavaVMs);
    JavaVM *vms_buf[1];
    JavaVM *vms;
    jsize num_vms;
    jint status = JNI_GetCreatedJavaVMs(vms_buf, 1, &num_vms);
    if (status == JNI_OK && num_vms > 0) {
        vms = vms_buf[0];
    } else {
        LOGE("GetCreatedJavaVMs error");
        return false;
    }

    auto lib_dir = GetLibDir(vms);
    if (lib_dir.empty()) {
        LOGE("GetLibDir error");
        return false;
    }
    if (lib_dir.find("/lib/x86") != std::string::npos) {
        LOGI("no need NativeBridge");
        munmap(data, length);
        return false;
    }

    auto nb = dlopen("libhoudini.so", RTLD_NOW);
    if (!nb) {
        auto native_bridge = GetNativeBridgeLibrary();
        LOGI("native bridge: %s", native_bridge.data());
        nb = dlopen(native_bridge.data(), RTLD_NOW);
    }
    if (nb) {
        LOGI("nb %p", nb);
        auto callbacks = (NativeBridgeCallbacks *) dlsym(nb, "NativeBridgeItf");
        if (callbacks) {
            LOGI("NativeBridgeLoadLibrary %p", callbacks->loadLibrary);
            LOGI("NativeBridgeLoadLibraryExt %p", callbacks->loadLibraryExt);
            LOGI("NativeBridgeGetTrampoline %p", callbacks->getTrampoline);
            int fd = syscall(__NR_memfd_create, "anon", MFD_CLOEXEC);
            ftruncate(fd, (off_t) length);
            void *mem = mmap(nullptr, length, PROT_WRITE, MAP_SHARED, fd, 0);
            memcpy(mem, data, length);
            munmap(mem, length);
            munmap(data, length);
            char path[PATH_MAX];
            snprintf(path, PATH_MAX, "/proc/self/fd/%d", fd);
            LOGI("arm path %s", path);

            void *arm_handle;
            if (api_level >= 26) {
                arm_handle = callbacks->loadLibraryExt(path, RTLD_NOW, (void *) 3);
            } else {
                arm_handle = callbacks->loadLibrary(path, RTLD_NOW);
            }
            if (arm_handle) {
                LOGI("arm handle %p", arm_handle);
                auto init = (void (*)(JavaVM *, void *)) callbacks->getTrampoline(arm_handle,
                                                                                  "JNI_OnLoad",
                                                                                  nullptr, 0);
                LOGI("JNI_OnLoad %p", init);
                init(vms, (void *) game_data_dir);
                return true;
            }
            close(fd);
        }
    }
    return false;
}

void hack_prepare(const char *_data_dir, void *data, size_t length) {
    LOGI("hack thread: %d", gettid());
    int api_level = android_get_device_api_level();
    LOGI("api level: %d", api_level);

#if defined(__i386__) || defined(__x86_64__)
    if (!NativeBridgeLoad(_data_dir, api_level, data, length)) {
#endif
        hack_start(_data_dir, nullptr);
#if defined(__i386__) || defined(__x86_64__)
    }
#endif
}

#if defined(__arm__) || defined(__aarch64__)

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {
    auto game_data_dir = (const char *) reserved;
    std::thread hack_thread(hack_start, game_data_dir,vm);
    hack_thread.detach();
    return JNI_VERSION_1_6;
}

#endif
```

`module/src/main/cpp/hack.h`:

```h
//
// Created by Perfare on 2020/7/4.
//

#ifndef ZYGISK_IL2CPPDUMPER_HACK_H
#define ZYGISK_IL2CPPDUMPER_HACK_H

#include <stddef.h>
#include <jni.h>

void hack_prepare(const char *game_data_dir, const char *package_name, void *data, size_t length, JavaVM *vm);

#endif //ZYGISK_IL2CPPDUMPER_HACK_H

```

`module/src/main/cpp/hack_new.cpp`:

```cpp
#include "hack.h"
#include "config.h"
#include "log.h"
#include "mylinker.h"
#include <cstring>
#include <thread>
#include <dlfcn.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <errno.h>
#include <jni.h>

// External function from newriruhide.cpp
extern "C" void riru_hide(const char *name);

void load_so_file_standard(const char *game_data_dir, const Config::SoFile &soFile) {
    // Use original filename
    char so_path[512];
    snprintf(so_path, sizeof(so_path), "%s/files/%s", game_data_dir, soFile.name.c_str());
    
    // Check if file exists
    if (access(so_path, F_OK) != 0) {
        LOGE("SO file not found: %s", so_path);
        return;
    }
    
    // Load the SO file using standard dlopen (no hiding)
    void *handle = dlopen(so_path, RTLD_NOW | RTLD_LOCAL);
    if (handle) {
        LOGI("Successfully loaded SO via standard dlopen: %s", soFile.name.c_str());
    } else {
        LOGE("Failed to load SO via standard dlopen: %s - %s", so_path, dlerror());
    }
}

void load_so_file_riru(const char *game_data_dir, const Config::SoFile &soFile) {
    // Use original filename
    char so_path[512];
    snprintf(so_path, sizeof(so_path), "%s/files/%s", game_data_dir, soFile.name.c_str());
    
    // Check if file exists
    if (access(so_path, F_OK) != 0) {
        LOGE("SO file not found: %s", so_path);
        return;
    }
    
    // Load the SO file using dlopen (Riru method)
    void *handle = dlopen(so_path, RTLD_NOW | RTLD_LOCAL);
    if (handle) {
        LOGI("Successfully loaded SO via Riru: %s", soFile.name.c_str());
        
        // Hide if configured
        if (Config::shouldHideInjection()) {
            // Hide using the original name
            riru_hide(soFile.name.c_str());
            LOGI("Applied riru_hide to: %s", soFile.name.c_str());
        }
    } else {
        LOGE("Failed to load SO via Riru: %s - %s", so_path, dlerror());
    }
}

void load_so_file_custom_linker(const char *game_data_dir, const Config::SoFile &soFile, JavaVM *vm) {
    // Use original filename
    char so_path[512];
    snprintf(so_path, sizeof(so_path), "%s/files/%s", game_data_dir, soFile.name.c_str());
    
    // Check if file exists
    if (access(so_path, F_OK) != 0) {
        LOGE("SO file not found: %s", so_path);
        return;
    }
    
    // Load the SO file using custom linker
    if (mylinker_load_library(so_path, vm)) {
        LOGI("Successfully loaded SO via custom linker: %s", soFile.name.c_str());
        
        // Custom linker doesn't appear in maps, so no need to hide
        if (Config::shouldHideInjection()) {
            LOGI("Custom linker injection is inherently hidden");
        }
    } else {
        LOGE("Failed to load SO via custom linker: %s", so_path);
    }
}

void hack_thread_func(const char *game_data_dir, const char *package_name, JavaVM *vm) {
    LOGI("Hack thread started for package: %s", package_name);
    
    // Note: Delay is now handled in main thread before this thread is created
    LOGI("Starting injection immediately (delay already applied in main thread)");
    
    // Get injection method for this app
    Config::InjectionMethod method = Config::getAppInjectionMethod(package_name);
    const char* methodName = method == Config::InjectionMethod::CUSTOM_LINKER ? "Custom Linker" :
                             method == Config::InjectionMethod::RIRU ? "Riru" : "Standard";
    LOGI("Using injection method: %s", methodName);
    
    // Get SO files for this app
    auto soFiles = Config::getAppSoFiles(package_name);
    LOGI("Found %zu SO files to load", soFiles.size());
    
    // Load each SO file using the configured method
    for (const auto &soFile : soFiles) {
        // Skip config files
        if (soFile.name.find(".config.so") != std::string::npos) {
            LOGI("Skipping config file: %s", soFile.name.c_str());
            continue;
        }
        
        LOGI("Loading SO: %s (stored as: %s)", soFile.name.c_str(), soFile.storedPath.c_str());
        
        if (method == Config::InjectionMethod::CUSTOM_LINKER) {
            load_so_file_custom_linker(game_data_dir, soFile, vm);
        } else if (method == Config::InjectionMethod::RIRU) {
            load_so_file_riru(game_data_dir, soFile);
        } else {
            load_so_file_standard(game_data_dir, soFile);
        }
    }
    
    // Cleanup custom linker resources when done (if used)
    if (method == Config::InjectionMethod::CUSTOM_LINKER) {
        // Keep libraries loaded, don't cleanup
        LOGI("Custom linker injection completed, libraries remain loaded");
    }
}

void hack_prepare(const char *game_data_dir, const char *package_name, void *data, size_t length, JavaVM *vm) {
    LOGI("hack_prepare called for package: %s, dir: %s", package_name, game_data_dir);
    
    std::thread hack_thread(hack_thread_func, game_data_dir, package_name, vm);
    hack_thread.join();
}
```

`module/src/main/cpp/log.h`:

```h
//
// Created by Perfare on 2020/7/4.
//

#ifndef ZYGISK_IL2CPPDUMPER_LOG_H
#define ZYGISK_IL2CPPDUMPER_LOG_H

#include <android/log.h>

#define LOG_TAG "myinjector"
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define PLOGE(fmt, args...) LOGE(fmt " failed with %d: %s", ##args, errno, strerror(errno))
#endif //ZYGISK_IL2CPPDUMPER_LOG_H

```

`module/src/main/cpp/main.cpp`:

```cpp
#include <cstring>
#include <thread>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <cinttypes>
#include <dirent.h>
#include <errno.h>
#include <time.h>
#include "hack.h"
#include "zygisk.hpp"
#include "game.h"
#include "log.h"
#include "dlfcn.h"
#include "config.h"
using zygisk::Api;
using zygisk::AppSpecializeArgs;
using zygisk::ServerSpecializeArgs;

class MyModule : public zygisk::ModuleBase {
public:
    void onLoad(Api *api, JNIEnv *env) override {
        this->api = api;
        this->env = env;
        enable_hack = false;
    }

    void preAppSpecialize(AppSpecializeArgs *args) override {
        auto package_name = env->GetStringUTFChars(args->nice_name, nullptr);
        auto app_data_dir = env->GetStringUTFChars(args->app_data_dir, nullptr);
//        if (strcmp(package_name, AimPackageName) == 0){
//            args->runtime_flags=8451;
//        }
        LOGI("preAppSpecialize %s %s %d", package_name, app_data_dir,args->runtime_flags);

        preSpecialize(package_name, app_data_dir);
        env->ReleaseStringUTFChars(args->nice_name, package_name);
        env->ReleaseStringUTFChars(args->app_data_dir, app_data_dir);
    }

    void postAppSpecialize(const AppSpecializeArgs *) override {
        if (enable_hack) {
            // Get JavaVM
            JavaVM *vm = nullptr;
            if (env->GetJavaVM(&vm) == JNI_OK) {
                // Get injection delay from config
                int delay = Config::getInjectionDelay();
                LOGI("Main thread blocking for %d seconds before injection", delay);
                
                // Block main thread for the delay period
                sleep(delay);
                
                // Then start hack thread with JavaVM
                std::thread hack_thread(hack_prepare, _data_dir, _package_name, data, length, vm);
                hack_thread.detach();
            } else {
                LOGE("Failed to get JavaVM");
            }
        }
    }

private:
    Api *api;
    JNIEnv *env;
    bool enable_hack;
    char *_data_dir;
    char *_package_name;
    void *data;
    size_t length;
    
    void preSpecialize(const char *package_name, const char *app_data_dir) {
        // Read configuration
        Config::readConfig();
        
        // Check if this app is enabled for injection
        if (Config::isAppEnabled(package_name)) {
            LOGI("成功注入目标进程: %s", package_name);
            enable_hack = true;
            _data_dir = new char[strlen(app_data_dir) + 1];
            strcpy(_data_dir, app_data_dir);
            _package_name = new char[strlen(package_name) + 1];
            strcpy(_package_name, package_name);
            
            // ConfigApp is responsible for copying SO files
            // We just need to load them

#if defined(__i386__)
            auto path = "zygisk/armeabi-v7a.so";
#endif
#if defined(__x86_64__)
            auto path = "zygisk/arm64-v8a.so";
#endif
#if defined(__i386__) || defined(__x86_64__)
            int dirfd = api->getModuleDir();
            int fd = openat(dirfd, path, O_RDONLY);
            if (fd != -1) {
                struct stat sb{};
                fstat(fd, &sb);
                length = sb.st_size;
                data = mmap(nullptr, length, PROT_READ, MAP_PRIVATE, fd, 0);
                close(fd);
            } else {
                LOGW("Unable to open arm file");
            }
#endif
        } else {
            api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);
        }
    }
};

REGISTER_ZYGISK_MODULE(MyModule)
```

`module/src/main/cpp/mylinker/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.18.1)
project(ElfLoader)

set(CMAKE_CXX_STANDARD 17)

include_directories(include)

set(SOURCES
        mylinker.cpp
        elf_loader.cpp
        elf_reader.cpp
        memory_manager.cpp
        relocator.cpp
        soinfo_manager.cpp
        utils.cpp
)

find_library(log-lib log)

# Build as static library to be linked into main module
add_library(mylinker STATIC ${SOURCES})

target_link_libraries(mylinker ${log-lib})

# Only build executable for standalone testing
if(CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
    add_executable(elf_loader_test main.cpp elf_loader.cpp elf_reader.cpp memory_manager.cpp relocator.cpp soinfo_manager.cpp utils.cpp)
    target_link_libraries(elf_loader_test ${log-lib})
endif()

```

`module/src/main/cpp/mylinker/elf_loader.cpp`:

```cpp
#include "elf_loader.h"

ElfLoader::ElfLoader() : loaded_si_(nullptr) {
    reader_ = std::make_unique<ElfReader>();
    memory_manager_ = std::make_unique<MemoryManager>();
    soinfo_manager_ = std::make_unique<SoinfoManager>();
    relocator_ = std::make_unique<Relocator>();
}

ElfLoader::~ElfLoader() {
}

bool ElfLoader::LoadLibrary(const char* path) {
    LOGI("Loading library: %s", path);

    if (!reader_->Open(path)) {
        LOGE("Failed to open %s", path);
        return false;
    }

    if (!reader_->Read()) {
        LOGE("Failed to read ELF file");
        return false;
    }

    if (!memory_manager_->ReserveAddressSpace(reader_->GetProgramHeaders(),
                                              reader_->GetProgramHeaderCount())) {
        LOGE("Failed to reserve address space");
        return false;
    }

    if (!memory_manager_->LoadSegments(reader_->GetProgramHeaders(),
                                       reader_->GetProgramHeaderCount(),
                                       reader_->GetMappedAddr(),
                                       reader_->GetFileSize())) {
        LOGE("Failed to load segments");
        return false;
    }

    if (!memory_manager_->FindPhdr(reader_->GetProgramHeaders(),
                                   reader_->GetProgramHeaderCount())) {
        LOGE("Failed to find program headers");
        return false;
    }

    const char* basename = strrchr(path, '/');
    basename = basename ? basename + 1 : path;
    loaded_si_ = soinfo_manager_->GetOrCreateSoinfo(basename);

    if (!soinfo_manager_->UpdateSoinfo(loaded_si_, memory_manager_.get(), reader_.get())) {
        LOGE("Failed to update soinfo");
        return false;
    }

    if (!soinfo_manager_->PrelinkImage(loaded_si_)) {
        LOGE("Failed to prelink image");
        return false;
    }

    if (!memory_manager_->ProtectSegments(reader_->GetProgramHeaders(),
                                          reader_->GetProgramHeaderCount())) {
        LOGE("Failed to protect segments");
        return false;
    }

    if (!relocator_->LinkImage(loaded_si_)) {
        LOGE("Failed to link image");
        return false;
    }

    reader_->Close();

    LOGI("Successfully loaded %s", path);
    return true;
}

void ElfLoader::CallConstructors() {
    if (loaded_si_ == nullptr) {
        return;
    }

    LOGD("Constructors already called during linking");
}

void* ElfLoader::GetSymbol(const char* name) {
    if (loaded_si_ == nullptr) {
        LOGE("loaded_si_ is null");
        return nullptr;
    }

    if (name == nullptr) {
        LOGE("Symbol name is null");
        return nullptr;
    }

    LOGD("Looking for symbol: %s", name);
    LOGD("soinfo state: symtab=%p, strtab=%p, gnu_bucket=%p, bucket=%p",
         loaded_si_->symtab, loaded_si_->strtab, loaded_si_->gnu_bucket, loaded_si_->bucket);

    if (loaded_si_->symtab != nullptr) {
        if (loaded_si_->gnu_bucket != nullptr) {
            LOGD("Trying GNU hash lookup for %s", name);
            uint32_t hash = relocator_->gnu_hash(name);
            LOGD("GNU hash for %s: 0x%x", name, hash);

            ElfW(Sym)* sym = relocator_->gnu_lookup(hash, name, loaded_si_);
            if (sym != nullptr && sym->st_shndx != SHN_UNDEF) {
                ElfW(Addr) addr = sym->st_value + loaded_si_->load_bias;
                LOGD("Found symbol %s via GNU hash: st_value=0x%llx, load_bias=0x%llx, final_addr=0x%llx",
                     name, (unsigned long long)sym->st_value, (unsigned long long)loaded_si_->load_bias, (unsigned long long)addr);

                if (addr >= loaded_si_->base && addr < loaded_si_->base + loaded_si_->size) {
                    return reinterpret_cast<void*>(addr);
                } else {
                    LOGE("Symbol %s address 0x%llx out of range [0x%llx, 0x%llx)",
                         name, (unsigned long long)addr, (unsigned long long)loaded_si_->base, 
                         (unsigned long long)(loaded_si_->base + loaded_si_->size));
                }
            } else {
                LOGD("Symbol %s not found via GNU hash", name);
            }
        }

        if (loaded_si_->bucket != nullptr) {
            LOGD("Trying ELF hash lookup for %s", name);
            unsigned hash = relocator_->elf_hash(name);
            LOGD("ELF hash for %s: 0x%x", name, hash);

            ElfW(Sym)* sym = relocator_->elf_lookup(hash, name, loaded_si_);
            if (sym != nullptr && sym->st_shndx != SHN_UNDEF) {
                ElfW(Addr) addr = sym->st_value + loaded_si_->load_bias;
                LOGD("Found symbol %s via ELF hash: st_value=0x%llx, load_bias=0x%llx, final_addr=0x%llx",
                     name, (unsigned long long)sym->st_value, (unsigned long long)loaded_si_->load_bias, (unsigned long long)addr);

                if (addr >= loaded_si_->base && addr < loaded_si_->base + loaded_si_->size) {
                    return reinterpret_cast<void*>(addr);
                } else {
                    LOGE("Symbol %s address 0x%llx out of range [0x%llx, 0x%llx)",
                         name, (unsigned long long)addr, (unsigned long long)loaded_si_->base, 
                         (unsigned long long)(loaded_si_->base + loaded_si_->size));
                }
            } else {
                LOGD("Symbol %s not found via ELF hash", name);
            }
        }

        if (loaded_si_->gnu_bucket == nullptr && loaded_si_->bucket == nullptr) {
            LOGD("No hash tables available, trying linear search");

            if (loaded_si_->strtab != nullptr) {
                size_t sym_count = 0;
                if (loaded_si_->nchain > 0) {
                    sym_count = loaded_si_->nchain;
                } else {
                    LOGD("Cannot determine symbol table size");
                    return nullptr;
                }

                LOGD("Trying linear search with %zu symbols", sym_count);
                for (size_t i = 0; i < sym_count; ++i) {
                    ElfW(Sym)* sym = &loaded_si_->symtab[i];
                    if (sym->st_name != 0 && sym->st_shndx != SHN_UNDEF) {
                        const char* sym_name = loaded_si_->strtab + sym->st_name;
                        if (strcmp(sym_name, name) == 0) {
                            ElfW(Addr) addr = sym->st_value + loaded_si_->load_bias;
                            LOGD("Found symbol %s via linear search: st_value=0x%llx, load_bias=0x%llx, final_addr=0x%llx",
                                 name, (unsigned long long)sym->st_value, (unsigned long long)loaded_si_->load_bias, (unsigned long long)addr);

                            if (addr >= loaded_si_->base && addr < loaded_si_->base + loaded_si_->size) {
                                return reinterpret_cast<void*>(addr);
                            } else {
                                LOGE("Symbol %s address 0x%llx out of range [0x%llx, 0x%llx)",
                                     name, (unsigned long long)addr, (unsigned long long)loaded_si_->base, (unsigned long long)(loaded_si_->base + loaded_si_->size));
                            }
                        }
                    }
                }
                LOGD("Symbol %s not found via linear search", name);
            }
        }
    } else {
        LOGE("Symbol table is null");
    }

    LOGE("Symbol %s not found in any method", name);
    return nullptr;
}
```

`module/src/main/cpp/mylinker/elf_reader.cpp`:

```cpp
#include "elf_reader.h"
#include <sys/types.h>

ElfReader::ElfReader() : fd_(-1), file_size_(0), file_offset_(0),
                         mapped_file_(nullptr), phdr_table_(nullptr), phdr_num_(0) {
    memset(&header_, 0, sizeof(header_));
}

ElfReader::~ElfReader() {
    Close();
}

bool ElfReader::Open(const char* path) {
    path_ = path;

    struct stat sb;
    fd_ = open(path, O_RDONLY | O_CLOEXEC);
    if (fd_ < 0) {
        LOGE("Cannot open %s: %s", path, strerror(errno));
        return false;
    }

    if (fstat(fd_, &sb) < 0) {
        LOGE("Cannot stat %s: %s", path, strerror(errno));
        close(fd_);
        fd_ = -1;
        return false;
    }

    file_size_ = sb.st_size;

    // 映射整个文件到内存
    mapped_file_ = mmap(nullptr, file_size_, PROT_READ, MAP_PRIVATE, fd_, 0);
    if (mapped_file_ == MAP_FAILED) {
        LOGE("Cannot mmap %s: %s", path, strerror(errno));
        close(fd_);
        fd_ = -1;
        return false;
    }

    return true;
}

bool ElfReader::Read() {
    if (!ReadElfHeader()) {
        return false;
    }

    if (!VerifyElfHeader()) {
        return false;
    }

    if (!ReadProgramHeaders()) {
        return false;
    }

    return true;
}

void ElfReader::Close() {
    if (mapped_file_ != nullptr && mapped_file_ != MAP_FAILED) {
        munmap(mapped_file_, file_size_);
        mapped_file_ = nullptr;
    }

    if (fd_ >= 0) {
        close(fd_);
        fd_ = -1;
    }

    if (phdr_table_ != nullptr) {
        free(phdr_table_);
        phdr_table_ = nullptr;
    }
}

bool ElfReader::ReadElfHeader() {
    if (file_size_ < sizeof(ElfW(Ehdr))) {
        LOGE("File too small for ELF header");
        return false;
    }

    memcpy(&header_, mapped_file_, sizeof(header_));
    return true;
}

bool ElfReader::VerifyElfHeader() {
    if (memcmp(header_.e_ident, ELFMAG, SELFMAG) != 0) {
        LOGE("Invalid ELF magic");
        return false;
    }

    if (header_.e_ident[EI_CLASS] != ELFCLASS64) {
        LOGE("Not a 64-bit ELF file");
        return false;
    }

    if (header_.e_machine != EM_AARCH64) {
        LOGE("Not an ARM64 ELF file");
        return false;
    }

    if (header_.e_version != EV_CURRENT) {
        LOGE("Invalid ELF version");
        return false;
    }

    if (header_.e_type != ET_DYN) {
        LOGE("Not a shared object");
        return false;
    }

    LOGD("ELF Header: type=%d, machine=%d, entry=0x%llx, phoff=0x%llx, phnum=%d",
         header_.e_type, header_.e_machine, (unsigned long long)header_.e_entry,
         (unsigned long long)header_.e_phoff, header_.e_phnum);

    return true;
}

bool ElfReader::ReadProgramHeaders() {
    phdr_num_ = header_.e_phnum;

    if (phdr_num_ == 0) {
        LOGE("No program headers");
        return false;
    }

    if (header_.e_phentsize != sizeof(ElfW(Phdr))) {
        LOGE("Invalid program header size");
        return false;
    }

    size_t size = phdr_num_ * sizeof(ElfW(Phdr));

    if (header_.e_phoff + size > file_size_) {
        LOGE("Program headers out of file bounds");
        return false;
    }

    phdr_table_ = static_cast<ElfW(Phdr)*>(malloc(size));
    if (phdr_table_ == nullptr) {
        LOGE("Cannot allocate memory for program headers");
        return false;
    }

    memcpy(phdr_table_, static_cast<char*>(mapped_file_) + header_.e_phoff, size);

    return true;
}

```

`module/src/main/cpp/mylinker/include/common.h`:

```h
#pragma once

#include <android/log.h>
#include <elf.h>
#include <link.h>
#include <dlfcn.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <cerrno>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <cstdint>

#include <string>
#include <vector>
#include <unordered_map>
#include <memory>

#define LOG_TAG "CustomLinker"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

#if defined(__LP64__)
#define ELFW(what) ELF64_ ## what
#else
#define ELFW(what) ELF32_ ## what
#endif

#define PAGE_SIZE 4096
#define PAGE_MASK (~(PAGE_SIZE - 1))
#define PAGE_START(addr) ((addr) & PAGE_MASK)
#define PAGE_END(addr) PAGE_START((addr) + PAGE_SIZE - 1)
#define PAGE_OFFSET(addr) ((addr) & (PAGE_SIZE - 1))

// 权限标志转换
#define PFLAGS_TO_PROT(x) (((x) & PF_R) ? PROT_READ : 0) | \
                          (((x) & PF_W) ? PROT_WRITE : 0) | \
                          (((x) & PF_X) ? PROT_EXEC : 0)

struct soinfo;
class ElfReader;
class MemoryManager;
class Relocator;
```

`module/src/main/cpp/mylinker/include/elf_loader.h`:

```h
#pragma once

#include "common.h"
#include "elf_reader.h"
#include "memory_manager.h"
#include "soinfo_manager.h"
#include "relocator.h"

class ElfLoader {
public:
    ElfLoader();
    ~ElfLoader();

    bool LoadLibrary(const char* path);

    void CallConstructors();

    void* GetSymbol(const char* name);

private:
    std::unique_ptr<ElfReader> reader_;
    std::unique_ptr<MemoryManager> memory_manager_;
    std::unique_ptr<SoinfoManager> soinfo_manager_;
    std::unique_ptr<Relocator> relocator_;

    soinfo* loaded_si_;
};
```

`module/src/main/cpp/mylinker/include/elf_reader.h`:

```h
#pragma once

#include "common.h"

class ElfReader {
public:
    ElfReader();
    ~ElfReader();

    bool Open(const char* path);
    bool Read();
    void Close();

    const ElfW(Ehdr)* GetHeader() const { return &header_; }
    const ElfW(Phdr)* GetProgramHeaders() const { return phdr_table_; }
    size_t GetProgramHeaderCount() const { return phdr_num_; }

    const char* GetPath() const { return path_.c_str(); }
    int GetFd() const { return fd_; }
    size_t GetFileSize() const { return file_size_; }
    void* GetMappedAddr() const { return mapped_file_; }

private:
    bool ReadElfHeader();
    bool ReadProgramHeaders();
    bool VerifyElfHeader();

    std::string path_;
    int fd_;
    size_t file_size_;
    off64_t file_offset_;

    void* mapped_file_; 

    ElfW(Ehdr) header_;
    ElfW(Phdr)* phdr_table_;
    size_t phdr_num_;
};

```

`module/src/main/cpp/mylinker/include/memory_manager.h`:

```h
#pragma once

#include "common.h"

class MemoryManager {
public:
    MemoryManager();
    ~MemoryManager();

    bool ReserveAddressSpace(const ElfW(Phdr)* phdr_table, size_t phdr_num);

    bool LoadSegments(const ElfW(Phdr)* phdr_table, size_t phdr_num,
                      void* mapped_file, size_t file_size);

    bool FindPhdr(const ElfW(Phdr)* phdr_table, size_t phdr_num);

    bool ProtectSegments(const ElfW(Phdr)* phdr_table, size_t phdr_num);

    void* GetLoadStart() const { return load_start_; }
    size_t GetLoadSize() const { return load_size_; }
    ElfW(Addr) GetLoadBias() const { return load_bias_; }
    const ElfW(Phdr)* GetLoadedPhdr() const { return loaded_phdr_; }

private:
    bool CheckPhdr(ElfW(Addr) loaded, const ElfW(Phdr)* phdr_table, size_t phdr_num);
    size_t phdr_table_get_load_size(const ElfW(Phdr)* phdr_table,
                                    size_t phdr_count,
                                    ElfW(Addr)* min_vaddr);

    void* load_start_;
    size_t load_size_;
    ElfW(Addr) load_bias_;
    const ElfW(Phdr)* loaded_phdr_;
};

```

`module/src/main/cpp/mylinker/include/mylinker.h`:

```h
#pragma once

#include <jni.h>

#ifdef __cplusplus
extern "C" {
#endif

__attribute__((visibility("default"))) bool mylinker_load_library(const char* library_path, JavaVM* vm);

__attribute__((visibility("default"))) void* mylinker_get_symbol(const char* library_path, const char* symbol_name);

__attribute__((visibility("default"))) void mylinker_cleanup();

#ifdef __cplusplus
}
#endif
```

`module/src/main/cpp/mylinker/include/relocator.h`:

```h
#pragma once

#include "common.h"
#include "soinfo_manager.h"

class Relocator {
public:
    Relocator();
    ~Relocator();

    bool RelocateImage(soinfo* si);

    bool LinkImage(soinfo* si);

    uint32_t gnu_hash(const char* name);
    unsigned elf_hash(const char* name);

    ElfW(Sym)* gnu_lookup(uint32_t hash, const char* name, soinfo* si);
    ElfW(Sym)* elf_lookup(unsigned hash, const char* name, soinfo* si);

private:
    bool ProcessRelaRelocation(soinfo* si, const ElfW(Rela)* rela);

    ElfW(Addr) FindSymbolAddress(const char* name, soinfo* si);
};
```

`module/src/main/cpp/mylinker/include/soinfo_manager.h`:

```h
#pragma once

#include "common.h"

// soinfo结构体定义(简化版)
struct soinfo {
    const char* name;
    ElfW(Addr) base;
    size_t size;
    ElfW(Addr) load_bias;

    const ElfW(Phdr)* phdr;
    size_t phnum;

    ElfW(Addr) entry;

    // Dynamic段信息
    ElfW(Dyn)* dynamic;
    size_t dynamic_count;

    // 符号表相关
    const char* strtab;
    ElfW(Sym)* symtab;
    size_t nbucket;
    size_t nchain;
    uint32_t* bucket;
    uint32_t* chain;

    // 重定位相关
    ElfW(Rela)* plt_rela;
    size_t plt_rela_count;
    ElfW(Rela)* rela;
    size_t rela_count;

    // GNU hash
    size_t gnu_nbucket;
    uint32_t* gnu_bucket;
    uint32_t* gnu_chain;
    uint32_t gnu_maskwords;
    uint32_t gnu_shift2;
    ElfW(Addr)* gnu_bloom_filter;

    // 初始化函数
    void (*init_func)();
    void (**init_array)();
    size_t init_array_count;
    void (**fini_array)();
    size_t fini_array_count;

    // 依赖库
    std::vector<std::string> needed_libs;

    uint32_t flags;
};

class SoinfoManager {
public:
    SoinfoManager();
    ~SoinfoManager();

    soinfo* GetOrCreateSoinfo(const char* name);

    bool UpdateSoinfo(soinfo* si, MemoryManager* mm, ElfReader* reader);

    bool PrelinkImage(soinfo* si);

    soinfo* FindSoinfo(const char* name);
    soinfo* GetCurrentSoinfo();

private:
    bool ParseDynamic(soinfo* si);
    void ApplyRelaSections(soinfo* si);

    std::unordered_map<std::string, std::unique_ptr<soinfo>> soinfo_map_;
};

```

`module/src/main/cpp/mylinker/include/utils.h`:

```h
#pragma once

#include "common.h"

namespace Utils {
    bool safe_add(off64_t* out, off64_t a, size_t b);

    soinfo* get_soinfo(const char* so_name);

    void* getMapData(int fd, off64_t base_offset, size_t elf_offset, size_t size);

    ElfW(Addr) get_export_func(const char* path, const char* func_name);

    inline size_t page_start(size_t addr) {
        return addr & ~(PAGE_SIZE - 1);
    }

    inline size_t page_offset(size_t addr) {
        return addr & (PAGE_SIZE - 1);
    }
}
```

`module/src/main/cpp/mylinker/main.cpp`:

```cpp
#include "elf_loader.h"

int (*yuuki_test_func) (int, int) = nullptr;

int main(int argc, char* argv[]) {

    if (argc < 2) {
        printf("Usage: %s <so_file_path>\n", argv[0]);
        return 1;
    }

    LOGI("Starting custom linker for: %s", argv[1]);

    // 检查文件是否存在
    if (access(argv[1], F_OK) != 0) {
        LOGE("File does not exist: %s", argv[1]);
        return 1;
    }

    if (access(argv[1], R_OK) != 0) {
        LOGE("File is not readable: %s", argv[1]);
        return 1;
    }

    ElfLoader loader;
    if (loader.LoadLibrary(argv[1])) {
        printf("Successfully loaded %s\n", argv[1]);

        void* test_func = loader.GetSymbol("yuuki_test");
        if (test_func) {
            printf("Found yuuki_test function at %p\n", test_func);
            yuuki_test_func = (int (*)(int, int)) test_func;

            // 测试函数调用
            printf("Testing function call: 1 + 1 = %d\n", yuuki_test_func(1, 1));
            printf("Testing function call: 5 + 3 = %d\n", yuuki_test_func(5, 3));
        } else {
            printf("Failed to find yuuki_test function\n");
        }

        return 0;
    } else {
        printf("Failed to load %s\n", argv[1]);
        return 1;
    }
}
// logcat | grep "CustomLinker"
// logcat | grep "TEST_SO"
// ./data/local/tmp/elf_loader /storage/emulated/0/yuuki/test.so
```

`module/src/main/cpp/mylinker/memory_manager.cpp`:

```cpp
#include "memory_manager.h"

MemoryManager::MemoryManager() : load_start_(nullptr), load_size_(0),
                                 load_bias_(0), loaded_phdr_(nullptr) {
}

MemoryManager::~MemoryManager() {
}

bool MemoryManager::ReserveAddressSpace(const ElfW(Phdr)* phdr_table, size_t phdr_num) {
    ElfW(Addr) min_vaddr;
    load_size_ = phdr_table_get_load_size(phdr_table, phdr_num, &min_vaddr);

    if (load_size_ == 0) {
        LOGE("No loadable segments");
        return false;
    }

    LOGD("Load size: 0x%zx, min_vaddr: 0x%llx", load_size_, (unsigned long long)min_vaddr);

    void* start = mmap(nullptr, load_size_, PROT_NONE,
                       MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (start == MAP_FAILED) {
        LOGE("Cannot reserve %zu bytes: %s", load_size_, strerror(errno));
        return false;
    }

    load_start_ = start;
    load_bias_ = reinterpret_cast<ElfW(Addr)>(start) - min_vaddr;

    LOGD("Reserved address space at %p, bias: 0x%llx", start, (unsigned long long)load_bias_);

    return true;
}

bool MemoryManager::LoadSegments(const ElfW(Phdr)* phdr_table, size_t phdr_num,
                                 void* mapped_file, size_t file_size) {
    LOGD("Starting LoadSegments: phdr_num=%zu, file_size=%zu", phdr_num, file_size);

    for (size_t i = 0; i < phdr_num; ++i) {
        const ElfW(Phdr)* phdr = &phdr_table[i];

        if (phdr->p_type != PT_LOAD) {
            continue;
        }

        LOGD("Processing LOAD segment %zu: vaddr=0x%llx, memsz=0x%llx, filesz=0x%llx, offset=0x%llx",
             i, (unsigned long long)phdr->p_vaddr, (unsigned long long)phdr->p_memsz, 
             (unsigned long long)phdr->p_filesz, (unsigned long long)phdr->p_offset);

        ElfW(Addr) seg_start = phdr->p_vaddr + load_bias_;
        ElfW(Addr) seg_end = seg_start + phdr->p_memsz;

        ElfW(Addr) seg_page_start = PAGE_START(seg_start);
        ElfW(Addr) seg_page_end = PAGE_END(seg_end);

        ElfW(Addr) seg_file_end = seg_start + phdr->p_filesz;

        ElfW(Addr) file_start = phdr->p_offset;
        ElfW(Addr) file_end = file_start + phdr->p_filesz;

        ElfW(Addr) file_page_start = PAGE_START(file_start);

        if (file_end > file_size) {
            LOGE("Invalid file size: file_end=0x%llx > file_size=0x%zx", (unsigned long long)file_end, file_size);
            return false;
        }

        if (phdr->p_filesz > 0) {
            void* seg_addr = reinterpret_cast<void*>(seg_page_start);
            size_t seg_size = seg_page_end - seg_page_start;

            if (mprotect(seg_addr, seg_size, PROT_READ | PROT_WRITE) < 0) {
                LOGE("Cannot mprotect for loading: %s", strerror(errno));
                return false;
            }

            void* src = static_cast<char*>(mapped_file) + phdr->p_offset;
            void* dst = reinterpret_cast<void*>(seg_start);

            LOGD("Copying segment %zu: src=%p (offset=0x%llx), dst=%p, size=0x%llx",
                 i, src, (unsigned long long)phdr->p_offset, dst, (unsigned long long)phdr->p_filesz);

            if (static_cast<char*>(src) + phdr->p_filesz > static_cast<char*>(mapped_file) + file_size) {
                LOGE("Source copy would exceed file bounds");
                return false;
            }

            if (reinterpret_cast<ElfW(Addr)>(dst) + phdr->p_filesz > seg_page_end) {
                LOGE("Destination copy would exceed segment bounds");
                return false;
            }

            memcpy(dst, src, phdr->p_filesz);

            LOGD("Successfully copied segment %zu", i);
        }

        if (phdr->p_memsz > phdr->p_filesz) {
            ElfW(Addr) bss_start = seg_start + phdr->p_filesz;
            ElfW(Addr) bss_end = seg_start + phdr->p_memsz;
            size_t bss_size = bss_end - bss_start;

            LOGD("Zeroing BSS: start=0x%llx, size=0x%zx", (unsigned long long)bss_start, bss_size);
            memset(reinterpret_cast<void*>(bss_start), 0, bss_size);
        }

        ElfW(Addr) aligned_file_end = PAGE_END(seg_file_end);
        if (seg_page_end > aligned_file_end) {
            size_t zeromap_size = seg_page_end - aligned_file_end;
            void* zeromap = mmap(reinterpret_cast<void*>(aligned_file_end),
                                 zeromap_size,
                                 PROT_READ | PROT_WRITE,  
                                 MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE,
                                 -1, 0);
            if (zeromap == MAP_FAILED) {
                LOGE("Cannot zero fill gap: %s", strerror(errno));
                return false;
            }
            LOGD("Zero-filled gap: addr=%p, size=0x%zx", zeromap, zeromap_size);
        }
    }

    LOGD("LoadSegments complete");
    return true;
}

bool MemoryManager::FindPhdr(const ElfW(Phdr)* phdr_table, size_t phdr_num) {
    const ElfW(Phdr)* phdr_limit = phdr_table + phdr_num;

    for (const ElfW(Phdr)* phdr = phdr_table; phdr < phdr_limit; ++phdr) {
        if (phdr->p_type == PT_PHDR) {
            return CheckPhdr(load_bias_ + phdr->p_vaddr, phdr_table, phdr_num);
        }
    }

    for (const ElfW(Phdr)* phdr = phdr_table; phdr < phdr_limit; ++phdr) {
        if (phdr->p_type == PT_LOAD) {
            if (phdr->p_offset == 0) {
                ElfW(Addr) elf_addr = load_bias_ + phdr->p_vaddr;
                const ElfW(Ehdr)* ehdr = reinterpret_cast<const ElfW(Ehdr)*>(elf_addr);
                ElfW(Addr) offset = ehdr->e_phoff;
                return CheckPhdr(reinterpret_cast<ElfW(Addr)>(ehdr) + offset, phdr_table, phdr_num);
            }
            break;
        }
    }

    LOGD("Using original phdr_table as loaded_phdr");
    loaded_phdr_ = phdr_table;
    return true;
}

bool MemoryManager::ProtectSegments(const ElfW(Phdr)* phdr_table, size_t phdr_num) {
    for (size_t i = 0; i < phdr_num; ++i) {
        const ElfW(Phdr)* phdr = &phdr_table[i];

        if (phdr->p_type != PT_LOAD) {
            continue;
        }

        ElfW(Addr) seg_start = phdr->p_vaddr + load_bias_;
        ElfW(Addr) seg_page_start = PAGE_START(seg_start);
        ElfW(Addr) seg_page_end = PAGE_END(seg_start + phdr->p_memsz);

        int prot = PFLAGS_TO_PROT(phdr->p_flags);

        if (mprotect(reinterpret_cast<void*>(seg_page_start),
                     seg_page_end - seg_page_start, prot) < 0) {
            LOGE("Cannot protect segment %zu: %s", i, strerror(errno));
            return false;
        }

        LOGD("Protected segment %zu: 0x%llx-0x%llx, prot: %d",
             i, (unsigned long long)seg_page_start, (unsigned long long)seg_page_end, prot);
    }

    return true;
}

bool MemoryManager::CheckPhdr(ElfW(Addr) loaded, const ElfW(Phdr)* phdr_table, size_t phdr_num) {
    const ElfW(Phdr)* phdr_limit = phdr_table + phdr_num;
    ElfW(Addr) loaded_end = loaded + (phdr_num * sizeof(ElfW(Phdr)));

    for (const ElfW(Phdr)* phdr = phdr_table; phdr < phdr_limit; ++phdr) {
        if (phdr->p_type != PT_LOAD) {
            continue;
        }

        ElfW(Addr) seg_start = phdr->p_vaddr + load_bias_;
        ElfW(Addr) seg_end = phdr->p_filesz + seg_start;

        if (seg_start <= loaded && loaded_end <= seg_end) {
            loaded_phdr_ = reinterpret_cast<const ElfW(Phdr)*>(loaded);
            return true;
        }
    }

    LOGE("Loaded phdr %p not in loadable segment", reinterpret_cast<void*>(loaded));
    return false;
}

size_t MemoryManager::phdr_table_get_load_size(const ElfW(Phdr)* phdr_table,
                                               size_t phdr_count,
                                               ElfW(Addr)* min_vaddr) {
    ElfW(Addr) min_addr = UINTPTR_MAX;
    ElfW(Addr) max_addr = 0;

    bool found_pt_load = false;

    for (size_t i = 0; i < phdr_count; ++i) {
        const ElfW(Phdr)* phdr = &phdr_table[i];

        if (phdr->p_type != PT_LOAD) {
            continue;
        }

        found_pt_load = true;

        if (phdr->p_vaddr < min_addr) {
            min_addr = phdr->p_vaddr;
        }

        if (phdr->p_vaddr + phdr->p_memsz > max_addr) {
            max_addr = phdr->p_vaddr + phdr->p_memsz;
        }
    }

    if (!found_pt_load) {
        return 0;
    }

    min_addr = PAGE_START(min_addr);
    max_addr = PAGE_END(max_addr);

    if (min_vaddr != nullptr) {
        *min_vaddr = min_addr;
    }

    return max_addr - min_addr;
}
```

`module/src/main/cpp/mylinker/mylinker.cpp`:

```cpp
#include "mylinker.h"
#include "elf_loader.h"
#include "common.h"
#include <unordered_map>
#include <memory>
#include <string>

static std::unordered_map<std::string, std::unique_ptr<ElfLoader>> loaded_libraries;

bool mylinker_load_library(const char* library_path, JavaVM* vm) {
    if (!library_path) {
        LOGE("Invalid library path");
        return false;
    }

    std::string path(library_path);
    
    if (loaded_libraries.find(path) != loaded_libraries.end()) {
        LOGI("Library already loaded: %s", library_path);
        return true;
    }

    auto loader = std::make_unique<ElfLoader>();
    if (!loader->LoadLibrary(library_path)) {
        LOGE("Failed to load library: %s", library_path);
        return false;
    }

    JNIEnv* env = nullptr;
    if (vm && vm->GetEnv((void**)&env, JNI_VERSION_1_6) == JNI_OK) {
        typedef jint (*JNI_OnLoad_t)(JavaVM*, void*);
        auto jni_onload = reinterpret_cast<JNI_OnLoad_t>(loader->GetSymbol("JNI_OnLoad"));
        if (jni_onload) {
            LOGI("Calling JNI_OnLoad");
            jni_onload(vm, nullptr);
        }
    }

    loaded_libraries[path] = std::move(loader);
    LOGI("Successfully loaded library: %s", library_path);
    return true;
}

void* mylinker_get_symbol(const char* library_path, const char* symbol_name) {
    if (!library_path || !symbol_name) {
        return nullptr;
    }

    auto it = loaded_libraries.find(library_path);
    if (it == loaded_libraries.end()) {
        LOGE("Library not loaded: %s", library_path);
        return nullptr;
    }

    return it->second->GetSymbol(symbol_name);
}

void mylinker_cleanup() {
    loaded_libraries.clear();
    LOGI("Cleaned up all loaded libraries");
}
```

`module/src/main/cpp/mylinker/relocator.cpp`:

```cpp
#include "relocator.h"

// Only define if not already defined
#ifndef R_AARCH64_NONE
#define R_AARCH64_NONE            0
#endif
#ifndef R_AARCH64_ABS64
#define R_AARCH64_ABS64         257
#endif
#ifndef R_AARCH64_GLOB_DAT
#define R_AARCH64_GLOB_DAT      1025
#endif
#ifndef R_AARCH64_JUMP_SLOT
#define R_AARCH64_JUMP_SLOT     1026
#endif
#ifndef R_AARCH64_RELATIVE
#define R_AARCH64_RELATIVE      1027
#endif
#ifndef R_AARCH64_TLS_TPREL64
#define R_AARCH64_TLS_TPREL64   1030
#endif
#ifndef R_AARCH64_TLS_DTPREL32
#define R_AARCH64_TLS_DTPREL32  1031
#endif
#ifndef R_AARCH64_IRELATIVE
#define R_AARCH64_IRELATIVE     1032
#endif

Relocator::Relocator() {
}

Relocator::~Relocator() {
}

bool Relocator::RelocateImage(soinfo* si) {
    LOGD("Starting relocation for %s", si->name);

    if (!si) {
        LOGE("soinfo is null");
        return false;
    }

    if (si->rela != nullptr && si->rela_count > 0) {
        LOGD("Processing %zu RELA relocations", si->rela_count);

        if (si->rela_count > 100000) {
            LOGE("RELA count too large: %zu", si->rela_count);
            return false;
        }

        for (size_t i = 0; i < si->rela_count; ++i) {
            if (!ProcessRelaRelocation(si, &si->rela[i])) {
                LOGE("Failed to process RELA relocation %zu", i);
                // 继续处理其他重定位，不要因为一个失败就退出
                // return false;
            }
        }
    } else {
        LOGD("No RELA relocations to process");
    }

    if (si->plt_rela != nullptr && si->plt_rela_count > 0) {
        LOGD("Processing %zu PLT RELA relocations", si->plt_rela_count);

        if (si->plt_rela_count > 10000) {
            LOGE("PLT RELA count too large: %zu", si->plt_rela_count);
            return false;
        }

        for (size_t i = 0; i < si->plt_rela_count; ++i) {
            if (!ProcessRelaRelocation(si, &si->plt_rela[i])) {
                LOGE("Failed to process PLT RELA relocation %zu", i);
                // 继续处理其他重定位
                // return false;
            }
        }
    } else {
        LOGD("No PLT RELA relocations to process");
    }

    LOGD("Relocation complete for %s", si->name);
    return true;
}

bool Relocator::LinkImage(soinfo* si) {
    if (!si) {
        LOGE("soinfo is null in LinkImage");
        return false;
    }

    if (!RelocateImage(si)) {
        LOGE("Failed to relocate image");
        return false;
    }

    if (si->init_func != nullptr) {
        LOGD("Calling init function at %p", si->init_func);
        si->init_func();
    }

    if (si->init_array != nullptr && si->init_array_count > 0) {
        LOGD("Calling %zu init_array functions", si->init_array_count);

        if (si->init_array_count > 1000) {
            LOGE("init_array_count too large: %zu", si->init_array_count);
            return false;
        }

        for (size_t i = 0; i < si->init_array_count; ++i) {
            void (*func)() = si->init_array[i];
            if (func != nullptr) {
                LOGD("Calling init_array[%zu] at %p", i, func);
                func();
            }
        }
    }

    return true;
}

bool Relocator::ProcessRelaRelocation(soinfo* si, const ElfW(Rela)* rela) {
    if (!si || !rela) {
        LOGE("Invalid parameters in ProcessRelaRelocation");
        return false;
    }

    ElfW(Addr) reloc = static_cast<ElfW(Addr)>(rela->r_offset + si->load_bias);
    ElfW(Word) type = ELFW(R_TYPE)(rela->r_info);
    ElfW(Word) sym = ELFW(R_SYM)(rela->r_info);

    LOGD("Processing relocation: offset=0x%llx, type=%d, sym=%d, addend=0x%llx",
         (unsigned long long)rela->r_offset, type, sym, (long long)rela->r_addend);

    if (reloc < si->base || reloc >= si->base + si->size) {
        LOGE("Relocation address 0x%llx out of range [0x%llx, 0x%llx)",
             (unsigned long long)reloc, (unsigned long long)si->base, (unsigned long long)(si->base + si->size));
        return false;
    }

    ElfW(Addr) sym_addr = 0;
    const char* sym_name = nullptr;

    if (sym != 0) {
        if (!si->symtab) {
            LOGE("Symbol table is null");
            return false;
        }

        const ElfW(Sym)* s = &si->symtab[sym];

        if (si->strtab && s->st_name != 0) {
            sym_name = si->strtab + s->st_name;
            LOGD("Symbol name: %s", sym_name);
        }

        if (s->st_shndx != SHN_UNDEF) {
            sym_addr = s->st_value + si->load_bias;
            LOGD("Local symbol: addr=0x%llx", (unsigned long long)sym_addr);
        } else if (sym_name) {
            sym_addr = FindSymbolAddress(sym_name, si);
            if (sym_addr == 0) {
                LOGD("Cannot find symbol: %s (may be optional)", sym_name);
            }
        }
    }

    void* page_start = reinterpret_cast<void*>(PAGE_START(reloc));
    size_t page_size = PAGE_SIZE;

    int old_prot = PROT_READ | PROT_WRITE;
    if (mprotect(page_start, page_size, old_prot) != 0) {
        LOGD("mprotect failed for relocation, trying anyway: %s", strerror(errno));
    }

    switch (type) {
        case R_AARCH64_NONE:
            LOGD("R_AARCH64_NONE");
            break;

        case R_AARCH64_ABS64:
            LOGD("R_AARCH64_ABS64: writing 0x%llx to 0x%llx", 
                 (unsigned long long)(sym_addr + rela->r_addend), (unsigned long long)reloc);
            *reinterpret_cast<ElfW(Addr)*>(reloc) = sym_addr + rela->r_addend;
            break;

        case R_AARCH64_GLOB_DAT:
            LOGD("R_AARCH64_GLOB_DAT: writing 0x%llx to 0x%llx", 
                 (unsigned long long)(sym_addr + rela->r_addend), (unsigned long long)reloc);
            *reinterpret_cast<ElfW(Addr)*>(reloc) = sym_addr + rela->r_addend;
            break;

        case R_AARCH64_JUMP_SLOT:
            LOGD("R_AARCH64_JUMP_SLOT: writing 0x%llx to 0x%llx", 
                 (unsigned long long)(sym_addr + rela->r_addend), (unsigned long long)reloc);
            *reinterpret_cast<ElfW(Addr)*>(reloc) = sym_addr + rela->r_addend;
            break;

        case R_AARCH64_RELATIVE:
            LOGD("R_AARCH64_RELATIVE: writing 0x%llx to 0x%llx", 
                 (unsigned long long)(si->load_bias + rela->r_addend), (unsigned long long)reloc);
            *reinterpret_cast<ElfW(Addr)*>(reloc) = si->load_bias + rela->r_addend;
            break;

        case R_AARCH64_IRELATIVE:
        {
            ElfW(Addr) resolver = si->load_bias + rela->r_addend;
            LOGD("R_AARCH64_IRELATIVE: resolver at 0x%llx", (unsigned long long)resolver);

            if (resolver < si->base || resolver >= si->base + si->size) {
                LOGE("Invalid resolver address: 0x%llx", (unsigned long long)resolver);
                return false;
            }

            ElfW(Addr) resolved = ((ElfW(Addr) (*)())resolver)();
            *reinterpret_cast<ElfW(Addr)*>(reloc) = resolved;
            LOGD("R_AARCH64_IRELATIVE: resolved to 0x%llx", (unsigned long long)resolved);
        }
            break;

        default:
            LOGD("Unknown relocation type %d, skipping", type);
            break;
    }

    return true;
}

ElfW(Addr) Relocator::FindSymbolAddress(const char* name, soinfo* si) {
    if (!name || !si) {
        return 0;
    }

    if (si->symtab != nullptr) {
        if (si->gnu_bucket != nullptr) {
            uint32_t hash = gnu_hash(name);
            ElfW(Sym)* sym = gnu_lookup(hash, name, si);
            if (sym != nullptr && sym->st_shndx != SHN_UNDEF) {
                ElfW(Addr) addr = sym->st_value + si->load_bias;
                LOGD("Found symbol %s in current SO at 0x%llx", name, (unsigned long long)addr);
                return addr;
            }
        }

        if (si->bucket != nullptr) {
            unsigned hash = elf_hash(name);
            ElfW(Sym)* sym = elf_lookup(hash, name, si);
            if (sym != nullptr && sym->st_shndx != SHN_UNDEF) {
                ElfW(Addr) addr = sym->st_value + si->load_bias;
                LOGD("Found symbol %s in current SO at 0x%llx", name, (unsigned long long)addr);
                return addr;
            }
        }
    }

    for (const auto& lib : si->needed_libs) {
        void* handle = dlopen(lib.c_str(), RTLD_NOW | RTLD_NOLOAD);
        if (handle != nullptr) {
            void* addr = dlsym(handle, name);
            if (addr != nullptr) {
                LOGD("Found symbol %s in %s at %p", name, lib.c_str(), addr);
                dlclose(handle);
                return reinterpret_cast<ElfW(Addr)>(addr);
            }
            dlclose(handle);
        }
    }

    void* addr = dlsym(RTLD_DEFAULT, name);
    if (addr != nullptr) {
        LOGD("Found symbol %s globally at %p", name, addr);
        return reinterpret_cast<ElfW(Addr)>(addr);
    }

    LOGD("Symbol %s not found", name);
    return 0;
}

ElfW(Sym)* Relocator::gnu_lookup(uint32_t hash, const char* name, soinfo* si) {
    if (!si->gnu_bucket || !si->gnu_chain || !si->symtab || !si->strtab) {
        return nullptr;
    }

    uint32_t h2 = hash >> si->gnu_shift2;

    uint32_t bloom_mask_bits = sizeof(ElfW(Addr)) * 8;
    uint32_t word_num = (hash / bloom_mask_bits) & si->gnu_maskwords;
    ElfW(Addr) bloom_word = si->gnu_bloom_filter[word_num];

    if ((1 & (bloom_word >> (hash % bloom_mask_bits)) &
         (bloom_word >> (h2 % bloom_mask_bits))) == 0) {
        return nullptr;
    }

    uint32_t n = si->gnu_bucket[hash % si->gnu_nbucket];

    if (n == 0) {
        return nullptr;
    }

    do {
        ElfW(Sym)* s = si->symtab + n;
        if (((si->gnu_chain[n] ^ hash) >> 1) == 0 &&
            strcmp(si->strtab + s->st_name, name) == 0) {
            return s;
        }
    } while ((si->gnu_chain[n++] & 1) == 0);

    return nullptr;
}

ElfW(Sym)* Relocator::elf_lookup(unsigned hash, const char* name, soinfo* si) {
    if (!si->bucket || !si->chain || !si->symtab || !si->strtab) {
        return nullptr;
    }

    for (unsigned n = si->bucket[hash % si->nbucket]; n != 0; n = si->chain[n]) {
        ElfW(Sym)* s = si->symtab + n;
        if (s->st_name != 0 && strcmp(si->strtab + s->st_name, name) == 0) {
            return s;
        }
    }
    return nullptr;
}

uint32_t Relocator::gnu_hash(const char* name) {
    uint32_t h = 5381;
    for (const uint8_t* c = reinterpret_cast<const uint8_t*>(name); *c != '\0'; c++) {
        h += (h << 5) + *c;
    }
    return h;
}

unsigned Relocator::elf_hash(const char* name) {
    unsigned h = 0, g;
    for (const unsigned char* p = reinterpret_cast<const unsigned char*>(name); *p; p++) {
        h = (h << 4) + *p;
        g = h & 0xf0000000;
        h ^= g;
        h ^= g >> 24;
    }
    return h;
}
```

`module/src/main/cpp/mylinker/soinfo_manager.cpp`:

```cpp
#include "soinfo_manager.h"
#include "utils.h"
#include "memory_manager.h"
#include "elf_reader.h"

SoinfoManager::SoinfoManager() {
}

SoinfoManager::~SoinfoManager() {
}

soinfo* SoinfoManager::GetOrCreateSoinfo(const char* name) {
    auto it = soinfo_map_.find(name);
    if (it != soinfo_map_.end()) {
        return it->second.get();
    }

    auto si = std::make_unique<soinfo>();
    memset(si.get(), 0, sizeof(soinfo));
    si->name = strdup(name);

    soinfo* result = si.get();
    soinfo_map_[name] = std::move(si);

    return result;
}

bool SoinfoManager::UpdateSoinfo(soinfo* si, MemoryManager* mm, ElfReader* reader) {
    if (!si || !mm || !reader) {
        return false;
    }

    si->base = reinterpret_cast<ElfW(Addr)>(mm->GetLoadStart());
    si->size = mm->GetLoadSize();
    si->load_bias = mm->GetLoadBias();

    const ElfW(Phdr)* loaded_phdr = mm->GetLoadedPhdr();
    if (loaded_phdr != nullptr) {
        si->phdr = loaded_phdr;
    } else {
        si->phdr = reader->GetProgramHeaders();
        LOGD("Using original program headers");
    }

    si->phnum = reader->GetProgramHeaderCount();

    const ElfW(Ehdr)* header = reader->GetHeader();
    si->entry = si->load_bias + header->e_entry;

    LOGD("Updated soinfo: base=0x%llx, size=0x%zx, bias=0x%llx, entry=0x%llx, phdr=%p",
         (unsigned long long)si->base, si->size, (unsigned long long)si->load_bias, 
         (unsigned long long)si->entry, si->phdr);

    return true;
}

bool SoinfoManager::PrelinkImage(soinfo* si) {
    LOGD("Starting PrelinkImage for %s", si->name);

    if (!ParseDynamic(si)) {
        LOGE("Failed to parse dynamic section");
        return false;
    }

    if (si->strtab != nullptr && si->dynamic != nullptr) {
        for (ElfW(Dyn)* d = si->dynamic; d->d_tag != DT_NULL; ++d) {
            if (d->d_tag == DT_NEEDED && si->needed_libs.empty()) {
                const char* needed = si->strtab + d->d_un.d_val;
                si->needed_libs.push_back(needed);
                LOGD("Processing deferred DT_NEEDED: %s", needed);
            }
        }
    }

    ApplyRelaSections(si);

    LOGD("PrelinkImage complete for %s", si->name);
    return true;
}

soinfo* SoinfoManager::FindSoinfo(const char* name) {
    auto it = soinfo_map_.find(name);
    if (it != soinfo_map_.end()) {
        return it->second.get();
    }
    return nullptr;
}

soinfo* SoinfoManager::GetCurrentSoinfo() {
    return Utils::get_soinfo("libcustom_linker.so");
}

bool SoinfoManager::ParseDynamic(soinfo* si) {
    if (!si || !si->phdr) {
        LOGE("Invalid soinfo or phdr is null");
        return false;
    }

    LOGD("Starting ParseDynamic: phdr=%p, phnum=%zu", si->phdr, si->phnum);

    const ElfW(Phdr)* phdr_limit = si->phdr + si->phnum;
    bool found_dynamic = false;

    for (const ElfW(Phdr)* phdr = si->phdr; phdr < phdr_limit; ++phdr) {
        if (phdr->p_type == PT_DYNAMIC) {
            si->dynamic = reinterpret_cast<ElfW(Dyn)*>(si->load_bias + phdr->p_vaddr);
            si->dynamic_count = phdr->p_memsz / sizeof(ElfW(Dyn));
            found_dynamic = true;
            LOGD("Found PT_DYNAMIC at vaddr=0x%llx, memsz=0x%llx", 
                 (unsigned long long)phdr->p_vaddr, (unsigned long long)phdr->p_memsz);
            break;
        }
    }

    if (!found_dynamic || !si->dynamic) {
        LOGE("No PT_DYNAMIC segment found");
        return false;
    }

    LOGD("Dynamic section at %p, count=%zu", si->dynamic, si->dynamic_count);

    if (si->dynamic_count == 0 || si->dynamic_count > 1000) {
        LOGE("Invalid dynamic count: %zu", si->dynamic_count);
        return false;
    }

    size_t dyn_count = 0;
    for (ElfW(Dyn)* d = si->dynamic; d->d_tag != DT_NULL && dyn_count < si->dynamic_count; ++d, ++dyn_count) {

        LOGD("Processing dynamic entry %zu: tag=0x%llx, val/ptr=0x%llx",
             dyn_count, (unsigned long long)d->d_tag, (unsigned long long)d->d_un.d_val);

        switch (d->d_tag) {
            case DT_SYMTAB:
                si->symtab = reinterpret_cast<ElfW(Sym)*>(si->load_bias + d->d_un.d_ptr);
                LOGD("DT_SYMTAB: raw_ptr=0x%llx, final_addr=%p",
                     (unsigned long long)d->d_un.d_ptr, si->symtab);
                break;

            case DT_STRTAB:
                si->strtab = reinterpret_cast<const char*>(si->load_bias + d->d_un.d_ptr);
                LOGD("DT_STRTAB: raw_ptr=0x%llx, final_addr=%p",
                     (unsigned long long)d->d_un.d_ptr, si->strtab);
                break;

            case DT_STRSZ:
                LOGD("DT_STRSZ: %lu", (unsigned long)d->d_un.d_val);
                break;

            case DT_HASH: {
                uint32_t* hash = reinterpret_cast<uint32_t*>(si->load_bias + d->d_un.d_ptr);
                si->nbucket = hash[0];
                si->nchain = hash[1];
                si->bucket = hash + 2;
                si->chain = si->bucket + si->nbucket;
                LOGD("DT_HASH: raw_ptr=0x%llx, nbucket=%zu, nchain=%zu",
                     (unsigned long long)d->d_un.d_ptr, si->nbucket, si->nchain);
                break;
            }

            case DT_GNU_HASH: {
                uint32_t* hash = reinterpret_cast<uint32_t*>(si->load_bias + d->d_un.d_ptr);
                si->gnu_nbucket = hash[0];
                uint32_t symbias = hash[1];
                si->gnu_maskwords = hash[2];
                si->gnu_shift2 = hash[3];
                si->gnu_bloom_filter = reinterpret_cast<ElfW(Addr)*>(hash + 4);
                si->gnu_bucket = reinterpret_cast<uint32_t*>(si->gnu_bloom_filter + si->gnu_maskwords);
                si->gnu_chain = si->gnu_bucket + si->gnu_nbucket - symbias;
                LOGD("DT_GNU_HASH: raw_ptr=0x%llx, nbucket=%zu, symbias=%u",
                     (unsigned long long)d->d_un.d_ptr, si->gnu_nbucket, symbias);
                break;
            }

            case DT_JMPREL:
                si->plt_rela = reinterpret_cast<ElfW(Rela)*>(si->load_bias + d->d_un.d_ptr);
                LOGD("DT_JMPREL: raw_ptr=0x%llx, final_addr=%p",
                     (unsigned long long)d->d_un.d_ptr, si->plt_rela);
                break;

            case DT_PLTRELSZ:
                si->plt_rela_count = d->d_un.d_val / sizeof(ElfW(Rela));
                LOGD("DT_PLTRELSZ: raw_val=%lu, count=%zu",
                     (unsigned long)d->d_un.d_val, si->plt_rela_count);
                break;

            case DT_PLTREL:
                LOGD("DT_PLTREL: %lu", (unsigned long)d->d_un.d_val);
                break;

            case DT_RELA:
                si->rela = reinterpret_cast<ElfW(Rela)*>(si->load_bias + d->d_un.d_ptr);
                LOGD("DT_RELA: raw_ptr=0x%llx, final_addr=%p",
                     (unsigned long long)d->d_un.d_ptr, si->rela);
                break;

            case DT_RELASZ:
                si->rela_count = d->d_un.d_val / sizeof(ElfW(Rela));
                LOGD("DT_RELASZ: raw_val=%lu, count=%zu",
                     (unsigned long)d->d_un.d_val, si->rela_count);
                break;

            case DT_RELAENT:
                LOGD("DT_RELAENT: %lu", (unsigned long)d->d_un.d_val);
                break;

            case DT_INIT:
                si->init_func = reinterpret_cast<void (*)()>(si->load_bias + d->d_un.d_ptr);
                LOGD("DT_INIT: raw_ptr=0x%llx, final_addr=%p",
                     (unsigned long long)d->d_un.d_ptr, si->init_func);
                break;

            case DT_INIT_ARRAY:
                si->init_array = reinterpret_cast<void (**)()>(si->load_bias + d->d_un.d_ptr);
                LOGD("DT_INIT_ARRAY: raw_ptr=0x%llx, final_addr=%p",
                     (unsigned long long)d->d_un.d_ptr, si->init_array);
                break;

            case DT_INIT_ARRAYSZ:
                si->init_array_count = d->d_un.d_val / sizeof(void*);
                LOGD("DT_INIT_ARRAYSZ: raw_val=%lu, count=%zu",
                     (unsigned long)d->d_un.d_val, si->init_array_count);
                break;

            case DT_FINI:
                LOGD("DT_FINI: 0x%llx", (unsigned long long)d->d_un.d_ptr);
                break;

            case DT_FINI_ARRAY:
                si->fini_array = reinterpret_cast<void (**)()>(si->load_bias + d->d_un.d_ptr);
                LOGD("DT_FINI_ARRAY: raw_ptr=0x%llx, final_addr=%p",
                     (unsigned long long)d->d_un.d_ptr, si->fini_array);
                break;

            case DT_FINI_ARRAYSZ:
                si->fini_array_count = d->d_un.d_val / sizeof(void*);
                LOGD("DT_FINI_ARRAYSZ: raw_val=%lu, count=%zu",
                     (unsigned long)d->d_un.d_val, si->fini_array_count);
                break;

            case DT_FLAGS:
                si->flags = d->d_un.d_val;
                LOGD("DT_FLAGS: 0x%x", si->flags);
                break;

            case DT_FLAGS_1:
                LOGD("DT_FLAGS_1: 0x%llx", (unsigned long long)d->d_un.d_val);
                break;

            case DT_SONAME:
                LOGD("DT_SONAME: offset=%lu", (unsigned long)d->d_un.d_val);
                break;

            case DT_RUNPATH:
                LOGD("DT_RUNPATH: offset=%lu", (unsigned long)d->d_un.d_val);
                break;

            case DT_NEEDED:
                // 跳过，稍后处理
                LOGD("DT_NEEDED: offset=%lu (deferred)", (unsigned long)d->d_un.d_val);
                break;

            default:
                LOGD("Unknown dynamic tag: 0x%llx, value=0x%llx",
                     (unsigned long long)d->d_tag, (unsigned long long)d->d_un.d_val);
                break;
        }

        // 添加安全检查，防止无限循环
        if (dyn_count > si->dynamic_count) {
            LOGE("Dynamic parsing exceeded expected count");
            break;
        }
    }

    if (si->symtab == nullptr) {
        LOGD("Warning: DT_SYMTAB not found or is null");
    }

    if (si->strtab == nullptr) {
        LOGD("Warning: DT_STRTAB not found or is null");
    }

    if (si->strtab != nullptr) {
        dyn_count = 0;
        for (ElfW(Dyn)* d = si->dynamic; d->d_tag != DT_NULL && dyn_count < si->dynamic_count; ++d, ++dyn_count) {
            if (d->d_tag == DT_NEEDED) {
                if (d->d_un.d_val < 65536) {
                    const char* needed = si->strtab + d->d_un.d_val;
                    if (strlen(needed) > 0 && strlen(needed) < 256) {
                        si->needed_libs.push_back(needed);
                        LOGD("DT_NEEDED: %s", needed);
                    } else {
                        LOGD("DT_NEEDED: invalid string at offset %lu", (unsigned long)d->d_un.d_val);
                    }
                } else {
                    LOGD("DT_NEEDED: offset too large: %lu", (unsigned long)d->d_un.d_val);
                }
            }
        }
    }

    LOGD("Dynamic parsing complete: symtab=%p, strtab=%p, needed_libs=%zu",
         si->symtab, si->strtab, si->needed_libs.size());

    return true;
}

void SoinfoManager::ApplyRelaSections(soinfo* si) {
    LOGD("RELA sections: rela_count=%zu, plt_rela_count=%zu",
         si->rela_count, si->plt_rela_count);
}
```

`module/src/main/cpp/mylinker/utils.cpp`:

```cpp
#include "utils.h"

namespace Utils {

    bool safe_add(off64_t* out, off64_t a, size_t b) {
        if (a < 0 || __builtin_add_overflow(a, b, out)) {
            return false;
        }
        return true;
    }

    soinfo* get_soinfo(const char* so_name) {
        typedef soinfo* (*FunctionPtr)(ElfW(Addr));

        char line[1024];
        ElfW(Addr) linker_base = 0;
        ElfW(Addr) so_addr = 0;

        FILE* fp = fopen("/proc/self/maps", "r");
        if (!fp) {
            LOGE("Cannot open /proc/self/maps");
            return nullptr;
        }

        while (fgets(line, sizeof(line), fp)) {
            if (strstr(line, "linker64") && !linker_base) {
                char* addr = strtok(line, "-");
                linker_base = strtoull(addr, nullptr, 16);
            } else if (strstr(line, so_name) && !so_addr) {
                char* addr = strtok(line, "-");
                so_addr = strtoull(addr, nullptr, 16);
            }

            if (linker_base && so_addr) {
                break;
            }
        }

        fclose(fp);

        if (!linker_base || !so_addr) {
            LOGE("Cannot find addresses");
            return nullptr;
        }

        ElfW(Addr) func_offset = get_export_func("/system/bin/linker64", "find_containing_library");
        if (!func_offset) {
            LOGE("Cannot find find_containing_library");
            return nullptr;
        }

        ElfW(Addr) find_containing_library_addr = linker_base + func_offset;
        FunctionPtr find_containing_library = reinterpret_cast<FunctionPtr>(find_containing_library_addr);

        return find_containing_library(so_addr);
    }

    void* getMapData(int fd, off64_t base_offset, size_t elf_offset, size_t size) {
        off64_t offset;
        if (!safe_add(&offset, base_offset, elf_offset)) {
            return nullptr;
        }

        off64_t page_min = page_start(offset);
        off64_t end_offset;
        if (!safe_add(&end_offset, offset, size)) {
            return nullptr;
        }
        if (!safe_add(&end_offset, end_offset, page_offset(offset))) {
            return nullptr;
        }

        size_t map_size = static_cast<size_t>(end_offset - page_min);

        uint8_t* map_start = static_cast<uint8_t*>(
                mmap(nullptr, map_size, PROT_READ, MAP_PRIVATE, fd, page_min));

        if (map_start == MAP_FAILED) {
            return nullptr;
        }

        return map_start + page_offset(offset);
    }

    ElfW(Addr) get_export_func(const char* path, const char* func_name) {
        struct stat sb;
        int fd = open(path, O_RDONLY);
        if (fd < 0) {
            return 0;
        }

        if (fstat(fd, &sb) < 0) {
            close(fd);
            return 0;
        }

        void* base = mmap(nullptr, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
        if (base == MAP_FAILED) {
            close(fd);
            return 0;
        }

        ElfW(Ehdr) header;
        memcpy(&header, base, sizeof(header));

        size_t shdr_size = header.e_shnum * sizeof(ElfW(Shdr));
        ElfW(Shdr)* shdr_table = static_cast<ElfW(Shdr)*>(malloc(shdr_size));
        memcpy(shdr_table, static_cast<char*>(base) + header.e_shoff, shdr_size);

        char* shstrtab = static_cast<char*>(base) + shdr_table[header.e_shstrndx].sh_offset;

        void* symtab = nullptr;
        char* strtab = nullptr;
        uint32_t symtab_size = 0;

        for (size_t i = 0; i < header.e_shnum; ++i) {
            const ElfW(Shdr)* shdr = &shdr_table[i];
            char* section_name = shstrtab + shdr->sh_name;

            if (strcmp(section_name, ".symtab") == 0) {
                symtab = static_cast<char*>(base) + shdr->sh_offset;
                symtab_size = shdr->sh_size;
            }
            if (strcmp(section_name, ".strtab") == 0) {
                strtab = static_cast<char*>(base) + shdr->sh_offset;
            }

            if (strtab && symtab) {
                break;
            }
        }

        ElfW(Addr) result = 0;

        if (symtab && strtab) {
            ElfW(Sym)* sym_table = static_cast<ElfW(Sym)*>(symtab);
            int sym_num = symtab_size / sizeof(ElfW(Sym));

            for (int i = 0; i < sym_num; i++) {
                const ElfW(Sym)* sym = &sym_table[i];
                char* sym_name = strtab + sym->st_name;

                if (strstr(sym_name, func_name)) {
                    result = sym->st_value;
                    break;
                }
            }
        }

        free(shdr_table);
        munmap(base, sb.st_size);
        close(fd);

        return result;
    }

} 
```

`module/src/main/cpp/newriruhide.cpp`:

```cpp
//
// Created by Mac on 2024/11/15.
//
// 给riru修复了内存泄漏的问题

#include "newriruhide.h"

/**
 * Magic to hide from /proc/###/maps, the idea is from Haruue Icymoon (https://github.com/haruue)
 */


extern "C" {
int riru_hide(const char *name) ;
}

#ifdef __LP64__
#define LIB_PATH "/system/lib64/"
#else
#define LIB_PATH "/system/lib/"
#endif

struct hide_struct {
    procmaps_struct *original;
    uintptr_t backup_address;
};

static int get_prot(const procmaps_struct *procstruct) {
    int prot = 0;
    if (procstruct->is_r) {
        prot |= PROT_READ;
    }
    if (procstruct->is_w) {
        prot |= PROT_WRITE;
    }
    if (procstruct->is_x) {
        prot |= PROT_EXEC;
    }
    return prot;
}

#define FAILURE_RETURN(exp, failure_value) ({   \
    __typeof__(exp) _rc;                    \
    _rc = (exp);                            \
    if (_rc == failure_value) {             \
        PLOGE(#exp);                        \
        return 1;                           \
    }                                       \
    _rc; })

static int do_hide(hide_struct *data) {
    auto procstruct = data->original;
    auto start = (uintptr_t) procstruct->addr_start;
    auto end = (uintptr_t) procstruct->addr_end;
    auto length = end - start;
    int prot = get_prot(procstruct);

    // backup
    data->backup_address = (uintptr_t) FAILURE_RETURN(
            mmap(nullptr, length, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0),
            MAP_FAILED);
    LOGD("%" PRIxPTR"-%" PRIxPTR" %s %ld %s is backup to %" PRIxPTR, start, end, procstruct->perm,
         procstruct->offset,
         procstruct->pathname, data->backup_address);

    if (procstruct->is_r || procstruct->is_x) { // If readable or executable
        LOGD("memcpy -> backup");
        memcpy((void *) data->backup_address, (void *) start, length);

        // Unmap original memory region
        LOGD("munmap original");
        FAILURE_RETURN(munmap((void *) start, length), -1);

        // Remap backup memory to original location
        LOGD("mmap original with backup");
        FAILURE_RETURN(mmap((void *) start, length, prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0),
                       MAP_FAILED);
    }

    return 0;
}

int riru_hide(const char *name) {
    procmaps_iterator *maps = pmparser_parse(-1);
    if (maps == nullptr) {
        LOGE("cannot parse the memory map");
        return false;
    }

    char buf[PATH_MAX];
    hide_struct *data = nullptr;
    size_t data_count = 0;
    procmaps_struct *maps_tmp;
    while ((maps_tmp = pmparser_next(maps)) != nullptr) {
        bool matched = false;
#ifdef DEBUG_APP
        matched = strstr(maps_tmp->pathname, "libriru.so");
#endif
        matched = strstr(maps_tmp->pathname, name) != nullptr;

        // Match the memory regions we want to hide
        if (!matched) continue;
        LOGI("matched %s", maps_tmp->pathname);
        auto start = (uintptr_t) maps_tmp->addr_start;
        auto end = (uintptr_t) maps_tmp->addr_end;
        if (maps_tmp->is_r || maps_tmp->is_x) {  // If memory is readable or executable
            if (data) {
                data = (hide_struct *) realloc(data, sizeof(hide_struct) * (data_count + 1));
            } else {
                data = (hide_struct *) malloc(sizeof(hide_struct));
            }
            data[data_count].original = maps_tmp;
            data_count += 1;
        }
        LOGD("%" PRIxPTR"-%" PRIxPTR" %s %ld %s", start, end, maps_tmp->perm, maps_tmp->offset,
             maps_tmp->pathname);
    }

    for (int i = 0; i < data_count; ++i) {
        LOGI("do_hide %d", i);
        do_hide(&data[i]);
    }

    // Free backup memory to avoid leaks
    for (int i = 0; i < data_count; ++i) {
        FAILURE_RETURN(munmap((void *) data[i].backup_address,
                              (uintptr_t) data[i].original->addr_end - (uintptr_t) data[i].original->addr_start), -1);
    }


    if (data) free(data);
    pmparser_free(maps);
    return 0;
}

```

`module/src/main/cpp/newriruhide.h`:

```h
//
// Created by Mac on 2024/11/15.
//

#ifndef ZYGISK_MYINJECTOR_NEWRIRUHIDE_H
#define ZYGISK_MYINJECTOR_NEWRIRUHIDE_H
#define EXPORT __attribute__((visibility("default"))) __attribute__((used))
#include <cinttypes>
#include <sys/mman.h>
#include <set>
#include <string_view>
#include "pmparser.h"
#include "android/log.h"
#include "log.h"
extern "C" {
int riru_hide(const char *name) EXPORT;
}

#endif //ZYGISK_MYINJECTOR_NEWRIRUHIDE_H

```

`module/src/main/cpp/pmparser.cpp`:

```cpp
/*
 @Author	: ouadimjamal@gmail.com
 @date		: December 2015

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  No representations are made about the suitability of this
software for any purpose.  It is provided "as is" without express or
implied warranty.
*/

#include "pmparser.h"
#include "log.h"

/**
 * gobal variables
 */
//procmaps_struct* g_last_head=NULL;
//procmaps_struct* g_current=NULL;



procmaps_iterator* pmparser_parse(int pid){
    LOGI("pmparser_parse called with pid: %d", pid);

    procmaps_iterator* maps_it = (procmaps_iterator *)malloc(sizeof(procmaps_iterator));
    if (!maps_it) {
        LOGI("Failed to allocate memory for procmaps_iterator");
        return NULL;
    }
    LOGI("Allocated memory for procmaps_iterator: %p", maps_it);

    char maps_path[500];
    if(pid >= 0 ){
        snprintf(maps_path, sizeof(maps_path), "/proc/%d/maps", pid);
        LOGI("Constructed maps_path for pid: %s", maps_path);
    } else {
        snprintf(maps_path, sizeof(maps_path), "/proc/self/maps");
        LOGI("Constructed maps_path for self: %s", maps_path);
    }

    FILE* file = fopen(maps_path, "r");
    if(!file){
        LOGI("pmparser: cannot open the memory maps, %s", strerror(errno));
        free(maps_it);
        return NULL;
    }
    LOGI("Opened maps file: %s", maps_path);

    int ind = 0;
    char buf[PROCMAPS_LINE_MAX_LENGTH];
    procmaps_struct* list_maps = NULL;
    procmaps_struct* tmp;
    procmaps_struct* current_node = NULL;
    char addr1[20], addr2[20], perm[8], offset[20], dev[10], inode[30], pathname[PATH_MAX];

    while (fgets(buf, PROCMAPS_LINE_MAX_LENGTH, file)) {
        LOGI("Read line %d: %s", ind + 1, buf);

        // 分配一个新的节点
        tmp = (procmaps_struct*)malloc(sizeof(procmaps_struct));
        if (!tmp) {
            LOGI("Failed to allocate memory for procmaps_struct at line %d", ind + 1);
            fclose(file);
            // 需要释放已分配的节点，避免内存泄漏
            procmaps_struct* iter = list_maps;
            while (iter) {
                procmaps_struct* next = iter->next;
                free(iter);
                iter = next;
            }
            free(maps_it);
            return NULL;
        }
        LOGI("Allocated memory for procmaps_struct: %p", tmp);

        // 填充节点
        _pmparser_split_line(buf, addr1, addr2, perm, offset, dev, inode, pathname);
        LOGI("Parsed line %d - addr1: %s, addr2: %s, perm: %s, offset: %s, dev: %s, inode: %s, pathname: %s",
             ind + 1, addr1, addr2, perm, offset, dev, inode, pathname);

        // 使用临时变量解析地址
        unsigned long tmp_addr_start_ul, tmp_addr_end_ul;
        if (sscanf(addr1, "%lx", &tmp_addr_start_ul) != 1) {
            LOGI("Failed to parse addr_start at line %d", ind + 1);
            free(tmp);
            continue;
        }
        if (sscanf(addr2, "%lx", &tmp_addr_end_ul) != 1) {
            LOGI("Failed to parse addr_end at line %d", ind + 1);
            free(tmp);
            continue;
        }
        LOGI("Parsed addresses - addr_start: 0x%lx, addr_end: 0x%lx", tmp_addr_start_ul, tmp_addr_end_ul);

        tmp->addr_start = (void*)tmp_addr_start_ul;
        tmp->addr_end = (void*)tmp_addr_end_ul;

        // size
        tmp->length = (unsigned long)((char*)tmp->addr_end - (char*)tmp->addr_start);
        LOGI("Calculated length: %lu", tmp->length);

        // perm
        strncpy(tmp->perm, perm, sizeof(tmp->perm) - 1);
        tmp->perm[sizeof(tmp->perm) - 1] = '\0';
        tmp->is_r = (perm[0] == 'r');
        tmp->is_w = (perm[1] == 'w');
        tmp->is_x = (perm[2] == 'x');
        tmp->is_p = (perm[3] == 'p');
        LOGI("Permissions - is_r: %d, is_w: %d, is_x: %d, is_p: %d", tmp->is_r, tmp->is_w, tmp->is_x, tmp->is_p);

        // offset
        if (sscanf(offset, "%lx", &tmp->offset) != 1) {
            LOGI("Failed to parse offset at line %d", ind + 1);
            free(tmp);
            continue;
        }
        LOGI("Parsed offset: 0x%lx", tmp->offset);

        // device
        strncpy(tmp->dev, dev, sizeof(tmp->dev) - 1);
        tmp->dev[sizeof(tmp->dev) - 1] = '\0';
        LOGI("Device: %s", tmp->dev);

        // inode
        tmp->inode = atoi(inode);
        LOGI("Inode: %d", tmp->inode);

        // pathname
        strncpy(tmp->pathname, pathname, sizeof(tmp->pathname) - 1);
        tmp->pathname[sizeof(tmp->pathname) - 1] = '\0';
        LOGI("Pathname: %s", tmp->pathname);

        tmp->next = NULL;

        // 连接节点到链表
        if(ind == 0){
            list_maps = tmp;
            current_node = list_maps;
            LOGI("Initialized list_maps with first node: %p", list_maps);
        }
        else{
            current_node->next = tmp;
            current_node = tmp;
            LOGI("Appended node to list_maps: %p", tmp);
        }
        ind++;
    }

    if (ferror(file)) {
        LOGI("Error occurred while reading the maps file");
        // 释放已分配的节点和 maps_it
        procmaps_struct* iter = list_maps;
        while (iter) {
            procmaps_struct* next = iter->next;
            free(iter);
            iter = next;
        }
        fclose(file);
        free(maps_it);
        return NULL;
    }

    // 关闭文件
    fclose(file);
    LOGI("Closed maps file: %s", maps_path);

    // 设置迭代器
    maps_it->head = list_maps;
    maps_it->current = list_maps;
    LOGI("Initialized procmaps_iterator - head: %p, current: %p", maps_it->head, maps_it->current);

    return maps_it;
}

procmaps_struct* pmparser_next(procmaps_iterator* p_procmaps_it){
    if(p_procmaps_it->current == NULL)
        return NULL;
    procmaps_struct* p_current = p_procmaps_it->current;
    p_procmaps_it->current = p_procmaps_it->current->next;
    return p_current;
    /*
    if(g_current==NULL){
        g_current=g_last_head;
    }else
        g_current=g_current->next;

    return g_current;
    */
}



void pmparser_free(procmaps_iterator* p_procmaps_it){
    procmaps_struct* maps_list = p_procmaps_it->head;
    if(maps_list==NULL) return ;
    procmaps_struct* act=maps_list;
    procmaps_struct* nxt=act->next;
    while(act!=NULL){
        free(act);
        act=nxt;
        if(nxt!=NULL)
            nxt=nxt->next;
    }
    free(p_procmaps_it);
}


void _pmparser_split_line(
        char*buf,char*addr1,char*addr2,
        char*perm,char* offset,char* device,char*inode,
        char* pathname){
    //
    int orig=0;
    int i=0;
    //addr1
    while(buf[i]!='-'){
        addr1[i-orig]=buf[i];
        i++;
    }
    addr1[i]='\0';
    i++;
    //addr2
    orig=i;
    while(buf[i]!='\t' && buf[i]!=' '){
        addr2[i-orig]=buf[i];
        i++;
    }
    addr2[i-orig]='\0';

    //perm
    while(buf[i]=='\t' || buf[i]==' ')
        i++;
    orig=i;
    while(buf[i]!='\t' && buf[i]!=' '){
        perm[i-orig]=buf[i];
        i++;
    }
    perm[i-orig]='\0';
    //offset
    while(buf[i]=='\t' || buf[i]==' ')
        i++;
    orig=i;
    while(buf[i]!='\t' && buf[i]!=' '){
        offset[i-orig]=buf[i];
        i++;
    }
    offset[i-orig]='\0';
    //dev
    while(buf[i]=='\t' || buf[i]==' ')
        i++;
    orig=i;
    while(buf[i]!='\t' && buf[i]!=' '){
        device[i-orig]=buf[i];
        i++;
    }
    device[i-orig]='\0';
    //inode
    while(buf[i]=='\t' || buf[i]==' ')
        i++;
    orig=i;
    while(buf[i]!='\t' && buf[i]!=' '){
        inode[i-orig]=buf[i];
        i++;
    }
    inode[i-orig]='\0';
    //pathname
    pathname[0]='\0';
    while(buf[i]=='\t' || buf[i]==' ')
        i++;
    orig=i;
    while(buf[i]!='\t' && buf[i]!=' ' && buf[i]!='\n'){
        pathname[i-orig]=buf[i];
        i++;
    }
    pathname[i-orig]='\0';

}

void pmparser_print(procmaps_struct* map, int order){

    procmaps_struct* tmp=map;
    int id=0;
    if(order<0) order=-1;
    while(tmp!=NULL){
        //(unsigned long) tmp->addr_start;
        if(order==id || order==-1){
            printf("Backed by:\t%s\n",strlen(tmp->pathname)==0?"[anonym*]":tmp->pathname);
            printf("Range:\t\t%p-%p\n",tmp->addr_start,tmp->addr_end);
            printf("Length:\t\t%ld\n",tmp->length);
            printf("Offset:\t\t%ld\n",tmp->offset);
            printf("Permissions:\t%s\n",tmp->perm);
            printf("Inode:\t\t%d\n",tmp->inode);
            printf("Device:\t\t%s\n",tmp->dev);
        }
        if(order!=-1 && id>order)
            tmp=NULL;
        else if(order==-1){
            printf("#################################\n");
            tmp=tmp->next;
        }else tmp=tmp->next;

        id++;
    }
}
```

`module/src/main/cpp/pmparser.h`:

```h
/*
 @Author	: ouadimjamal@gmail.com
 @date		: December 2015

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  No representations are made about the suitability of this
software for any purpose.  It is provided "as is" without express or
implied warranty.

 */

#ifndef H_PMPARSER
#define H_PMPARSER
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <linux/limits.h>

//maximum line length in a procmaps file
#define PROCMAPS_LINE_MAX_LENGTH  (PATH_MAX + 100)
/**
 * procmaps_struct
 * @desc hold all the information about an area in the process's  VM
 */
typedef struct procmaps_struct{
    void* addr_start; 	//< start address of the area
    void* addr_end; 	//< end address
    unsigned long length; //< size of the range

    char perm[5];		//< permissions rwxp
    short is_r;			//< rewrote of perm with short flags
    short is_w;
    short is_x;
    short is_p;

    long offset;	//< offset
    char dev[12];	//< dev major:minor
    int inode;		//< inode of the file that backs the area

    char pathname[600];		//< the path of the file that backs the area
    //chained list
    struct procmaps_struct* next;		//<handler of the chinaed list
} procmaps_struct;

/**
 * procmaps_iterator
 * @desc holds iterating information
 */
typedef struct procmaps_iterator{
    procmaps_struct* head;
    procmaps_struct* current;
} procmaps_iterator;
/**
 * pmparser_parse
 * @param pid the process id whose memory map to be parser. the current process if pid<0
 * @return an iterator over all the nodes
 */
procmaps_iterator* pmparser_parse(int pid);

/**
 * pmparser_next
 * @description move between areas
 * @param p_procmaps_it the iterator to move on step in the chained list
 * @return a procmaps structure filled with information about this VM area
 */
procmaps_struct* pmparser_next(procmaps_iterator* p_procmaps_it);
/**
 * pmparser_free
 * @description should be called at the end to free the resources
 * @param p_procmaps_it the iterator structure returned by pmparser_parse
 */
void pmparser_free(procmaps_iterator* p_procmaps_it);

/**
 * _pmparser_split_line
 * @description internal usage
 */
void _pmparser_split_line(char*buf,char*addr1,char*addr2,char*perm, char* offset, char* device,char*inode,char* pathname);

/**
 * pmparser_print
 * @param map the head of the list
 * @order the order of the area to print, -1 to print everything
 */
void pmparser_print(procmaps_struct* map,int order);





#endif
```

`module/src/main/cpp/xdl/include/xdl.h`:

```h
// Copyright (c) 2020-2021 HexHacking Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Created by caikelun on 2020-10-04.

//
// xDL version: 1.2.1
//
// xDL is an enhanced implementation of the Android DL series functions.
// For more information, documentation, and the latest version please check:
// https://github.com/hexhacking/xDL
//

#ifndef IO_HEXHACKING_XDL
#define IO_HEXHACKING_XDL

#include <dlfcn.h>
#include <link.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
  // same as Dl_info:
  const char *dli_fname;  // Pathname of shared object that contains address.
  void *dli_fbase;        // Address at which shared object is loaded.
  const char *dli_sname;  // Name of nearest symbol with address lower than addr.
  void *dli_saddr;        // Exact address of symbol named in dli_sname.
  // added by xDL:
  size_t dli_ssize;             // Symbol size of nearest symbol with address lower than addr.
  const ElfW(Phdr) *dlpi_phdr;  // Pointer to array of ELF program headers for this object.
  size_t dlpi_phnum;            // Number of items in dlpi_phdr.
} xdl_info_t;

//
// Default value for flags in both xdl_open() and xdl_iterate_phdr().
//
#define XDL_DEFAULT 0x00

//
// Enhanced dlopen() / dlclose() / dlsym().
//
#define XDL_TRY_FORCE_LOAD    0x01
#define XDL_ALWAYS_FORCE_LOAD 0x02
void *xdl_open(const char *filename, int flags);
void *xdl_close(void *handle);
void *xdl_sym(void *handle, const char *symbol, size_t *symbol_size);
void *xdl_dsym(void *handle, const char *symbol, size_t *symbol_size);

//
// Enhanced dladdr().
//
int xdl_addr(void *addr, xdl_info_t *info, void **cache);
void xdl_addr_clean(void **cache);

//
// Enhanced dl_iterate_phdr().
//
#define XDL_FULL_PATHNAME 0x01
int xdl_iterate_phdr(int (*callback)(struct dl_phdr_info *, size_t, void *), void *data, int flags);

//
// Custom dlinfo().
//
#define XDL_DI_DLINFO 1  // type of info: xdl_info_t
int xdl_info(void *handle, int request, void *info);

#ifdef __cplusplus
}
#endif

#endif

```

`module/src/main/cpp/xdl/xdl.c`:

```c
// Copyright (c) 2020-2021 HexHacking Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Created by caikelun on 2020-10-04.

#include "xdl.h"

#include <android/api-level.h>
#include <elf.h>
#include <fcntl.h>
#include <inttypes.h>
#include <link.h>
#include <pthread.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/auxv.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include "xdl_iterate.h"
#include "xdl_linker.h"
#include "xdl_lzma.h"
#include "xdl_util.h"

#ifndef __LP64__
#define XDL_LIB_PATH "/system/lib"
#else
#define XDL_LIB_PATH "/system/lib64"
#endif

#define XDL_DYNSYM_IS_EXPORT_SYM(shndx) (SHN_UNDEF != (shndx))
#define XDL_SYMTAB_IS_EXPORT_SYM(shndx) \
  (SHN_UNDEF != (shndx) && !((shndx) >= SHN_LORESERVE && (shndx) <= SHN_HIRESERVE))

extern __attribute((weak)) unsigned long int getauxval(unsigned long int);

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"

typedef struct xdl {
  char *pathname;
  uintptr_t load_bias;
  const ElfW(Phdr) *dlpi_phdr;
  ElfW(Half) dlpi_phnum;

  struct xdl *next;     // to next xdl obj for cache in xdl_addr()
  void *linker_handle;  // hold handle returned by xdl_linker_load()

  //
  // (1) for searching symbols from .dynsym
  //

  bool dynsym_try_load;
  ElfW(Sym) *dynsym;   // .dynsym
  const char *dynstr;  // .dynstr

  // .hash (SYSV hash for .dynstr)
  struct {
    const uint32_t *buckets;
    uint32_t buckets_cnt;
    const uint32_t *chains;
    uint32_t chains_cnt;
  } sysv_hash;

  // .gnu.hash (GNU hash for .dynstr)
  struct {
    const uint32_t *buckets;
    uint32_t buckets_cnt;
    const uint32_t *chains;
    uint32_t symoffset;
    const ElfW(Addr) *bloom;
    uint32_t bloom_cnt;
    uint32_t bloom_shift;
  } gnu_hash;

  //
  // (2) for searching symbols from .symtab
  //

  bool symtab_try_load;
  uintptr_t base;

  ElfW(Sym) *symtab;  // .symtab
  size_t symtab_cnt;
  char *strtab;  // .strtab
  size_t strtab_sz;
} xdl_t;

#pragma clang diagnostic pop

// load from memory
static int xdl_dynsym_load(xdl_t *self) {
  // find the dynamic segment
  ElfW(Dyn) *dynamic = NULL;
  for (size_t i = 0; i < self->dlpi_phnum; i++) {
    const ElfW(Phdr) *phdr = &(self->dlpi_phdr[i]);
    if (PT_DYNAMIC == phdr->p_type) {
      dynamic = (ElfW(Dyn) *)(self->load_bias + phdr->p_vaddr);
      break;
    }
  }
  if (NULL == dynamic) return -1;

  // iterate the dynamic segment
  for (ElfW(Dyn) *entry = dynamic; entry && entry->d_tag != DT_NULL; entry++) {
    switch (entry->d_tag) {
      case DT_SYMTAB:  //.dynsym
        self->dynsym = (ElfW(Sym) *)(self->load_bias + entry->d_un.d_ptr);
        break;
      case DT_STRTAB:  //.dynstr
        self->dynstr = (const char *)(self->load_bias + entry->d_un.d_ptr);
        break;
      case DT_HASH:  //.hash
        self->sysv_hash.buckets_cnt = ((const uint32_t *)(self->load_bias + entry->d_un.d_ptr))[0];
        self->sysv_hash.chains_cnt = ((const uint32_t *)(self->load_bias + entry->d_un.d_ptr))[1];
        self->sysv_hash.buckets = &(((const uint32_t *)(self->load_bias + entry->d_un.d_ptr))[2]);
        self->sysv_hash.chains = &(self->sysv_hash.buckets[self->sysv_hash.buckets_cnt]);
        break;
      case DT_GNU_HASH:  //.gnu.hash
        self->gnu_hash.buckets_cnt = ((const uint32_t *)(self->load_bias + entry->d_un.d_ptr))[0];
        self->gnu_hash.symoffset = ((const uint32_t *)(self->load_bias + entry->d_un.d_ptr))[1];
        self->gnu_hash.bloom_cnt = ((const uint32_t *)(self->load_bias + entry->d_un.d_ptr))[2];
        self->gnu_hash.bloom_shift = ((const uint32_t *)(self->load_bias + entry->d_un.d_ptr))[3];
        self->gnu_hash.bloom = (const ElfW(Addr) *)(self->load_bias + entry->d_un.d_ptr + 16);
        self->gnu_hash.buckets = (const uint32_t *)(&(self->gnu_hash.bloom[self->gnu_hash.bloom_cnt]));
        self->gnu_hash.chains = (const uint32_t *)(&(self->gnu_hash.buckets[self->gnu_hash.buckets_cnt]));
        break;
      default:
        break;
    }
  }

  if (NULL == self->dynsym || NULL == self->dynstr ||
      (0 == self->sysv_hash.buckets_cnt && 0 == self->gnu_hash.buckets_cnt)) {
    self->dynsym = NULL;
    self->dynstr = NULL;
    self->sysv_hash.buckets_cnt = 0;
    self->gnu_hash.buckets_cnt = 0;
    return -1;
  }

  return 0;
}

static void *xdl_read_file_to_heap(int file_fd, size_t file_sz, size_t data_offset, size_t data_len) {
  if (0 == data_len) return NULL;
  if (data_offset >= file_sz) return NULL;
  if (data_offset + data_len > file_sz) return NULL;

  if (data_offset != (size_t)lseek(file_fd, (off_t)data_offset, SEEK_SET)) return NULL;

  void *data = malloc(data_len);
  if (NULL == data) return NULL;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgnu-statement-expression"
  if ((ssize_t)data_len != XDL_UTIL_TEMP_FAILURE_RETRY(read(file_fd, data, data_len)))
#pragma clang diagnostic pop
  {
    free(data);
    return NULL;
  }

  return data;
}

static void *xdl_read_file_to_heap_by_section(int file_fd, size_t file_sz, ElfW(Shdr) *shdr) {
  return xdl_read_file_to_heap(file_fd, file_sz, (size_t)shdr->sh_offset, shdr->sh_size);
}

static void *xdl_read_memory_to_heap(void *mem, size_t mem_sz, size_t data_offset, size_t data_len) {
  if (0 == data_len) return NULL;
  if (data_offset >= mem_sz) return NULL;
  if (data_offset + data_len > mem_sz) return NULL;

  void *data = malloc(data_len);
  if (NULL == data) return NULL;

  memcpy(data, (void *)((uintptr_t)mem + data_offset), data_len);
  return data;
}

static void *xdl_read_memory_to_heap_by_section(void *mem, size_t mem_sz, ElfW(Shdr) *shdr) {
  return xdl_read_memory_to_heap(mem, mem_sz, (size_t)shdr->sh_offset, shdr->sh_size);
}

static void *xdl_get_memory(void *mem, size_t mem_sz, size_t data_offset, size_t data_len) {
  if (0 == data_len) return NULL;
  if (data_offset >= mem_sz) return NULL;
  if (data_offset + data_len > mem_sz) return NULL;

  return (void *)((uintptr_t)mem + data_offset);
}

static void *xdl_get_memory_by_section(void *mem, size_t mem_sz, ElfW(Shdr) *shdr) {
  return xdl_get_memory(mem, mem_sz, (size_t)shdr->sh_offset, shdr->sh_size);
}

// load from disk and memory
static int xdl_symtab_load_from_debugdata(xdl_t *self, int file_fd, size_t file_sz,
                                          ElfW(Shdr) *shdr_debugdata) {
  void *debugdata = NULL;
  ElfW(Shdr) *shdrs = NULL;
  int r = -1;

  // get zipped .gnu_debugdata
  uint8_t *debugdata_zip = (uint8_t *)xdl_read_file_to_heap_by_section(file_fd, file_sz, shdr_debugdata);
  if (NULL == debugdata_zip) return -1;

  // get unzipped .gnu_debugdata
  size_t debugdata_sz;
  if (0 != xdl_lzma_decompress(debugdata_zip, shdr_debugdata->sh_size, (uint8_t **)&debugdata, &debugdata_sz))
    goto end;

  // get ELF header
  ElfW(Ehdr) *ehdr = (ElfW(Ehdr) *)debugdata;
  if (0 == ehdr->e_shnum || ehdr->e_shentsize != sizeof(ElfW(Shdr))) goto end;

  // get section headers
  shdrs = (ElfW(Shdr) *)xdl_read_memory_to_heap(debugdata, debugdata_sz, (size_t)ehdr->e_shoff,
                                                ehdr->e_shentsize * ehdr->e_shnum);
  if (NULL == shdrs) goto end;

  // get .shstrtab
  if (SHN_UNDEF == ehdr->e_shstrndx || ehdr->e_shstrndx >= ehdr->e_shnum) goto end;
  char *shstrtab = (char *)xdl_get_memory_by_section(debugdata, debugdata_sz, shdrs + ehdr->e_shstrndx);
  if (NULL == shstrtab) goto end;

  // find .symtab & .strtab
  for (ElfW(Shdr) *shdr = shdrs; shdr < shdrs + ehdr->e_shnum; shdr++) {
    char *shdr_name = shstrtab + shdr->sh_name;

    if (SHT_SYMTAB == shdr->sh_type && 0 == strcmp(".symtab", shdr_name)) {
      // get & check associated .strtab section
      if (shdr->sh_link >= ehdr->e_shnum) continue;
      ElfW(Shdr) *shdr_strtab = shdrs + shdr->sh_link;
      if (SHT_STRTAB != shdr_strtab->sh_type) continue;

      // get .symtab & .strtab
      ElfW(Sym) *symtab = (ElfW(Sym) *)xdl_read_memory_to_heap_by_section(debugdata, debugdata_sz, shdr);
      if (NULL == symtab) continue;
      char *strtab = (char *)xdl_read_memory_to_heap_by_section(debugdata, debugdata_sz, shdr_strtab);
      if (NULL == strtab) {
        free(symtab);
        continue;
      }

      // OK
      self->symtab = symtab;
      self->symtab_cnt = shdr->sh_size / shdr->sh_entsize;
      self->strtab = strtab;
      self->strtab_sz = shdr_strtab->sh_size;
      r = 0;
      break;
    }
  }

end:
  free(debugdata_zip);
  if (NULL != debugdata) free(debugdata);
  if (NULL != shdrs) free(shdrs);
  return r;
}

// load from disk and memory
static int xdl_symtab_load(xdl_t *self) {
  if ('[' == self->pathname[0]) return -1;

  int r = -1;
  ElfW(Shdr) *shdrs = NULL;
  char *shstrtab = NULL;

  // get base address
  uintptr_t vaddr_min = UINTPTR_MAX;
  for (size_t i = 0; i < self->dlpi_phnum; i++) {
    const ElfW(Phdr) *phdr = &(self->dlpi_phdr[i]);
    if (PT_LOAD == phdr->p_type) {
      if (vaddr_min > phdr->p_vaddr) vaddr_min = phdr->p_vaddr;
    }
  }
  if (UINTPTR_MAX == vaddr_min) return -1;
  self->base = self->load_bias + vaddr_min;

  // open file
  int flags = O_RDONLY | O_CLOEXEC;
  int file_fd;
  if ('/' == self->pathname[0]) {
    file_fd = open(self->pathname, flags);
  } else {
    char full_pathname[1024];
    // try the fast method
    snprintf(full_pathname, sizeof(full_pathname), "%s/%s", XDL_LIB_PATH, self->pathname);
    file_fd = open(full_pathname, flags);
    if (file_fd < 0) {
      // try the slow method
      if (0 != xdl_iterate_get_full_pathname(self->base, full_pathname, sizeof(full_pathname))) return -1;
      file_fd = open(full_pathname, flags);
    }
  }
  if (file_fd < 0) return -1;
  struct stat st;
  if (0 != fstat(file_fd, &st)) goto end;
  size_t file_sz = (size_t)st.st_size;

  // get ELF header
  ElfW(Ehdr) *ehdr = (ElfW(Ehdr) *)self->base;
  if (0 == ehdr->e_shnum || ehdr->e_shentsize != sizeof(ElfW(Shdr))) goto end;

  // get section headers
  shdrs = (ElfW(Shdr) *)xdl_read_file_to_heap(file_fd, file_sz, (size_t)ehdr->e_shoff,
                                              ehdr->e_shentsize * ehdr->e_shnum);
  if (NULL == shdrs) goto end;

  // get .shstrtab
  if (SHN_UNDEF == ehdr->e_shstrndx || ehdr->e_shstrndx >= ehdr->e_shnum) goto end;
  shstrtab = (char *)xdl_read_file_to_heap_by_section(file_fd, file_sz, shdrs + ehdr->e_shstrndx);
  if (NULL == shstrtab) goto end;

  // find .symtab & .strtab
  for (ElfW(Shdr) *shdr = shdrs; shdr < shdrs + ehdr->e_shnum; shdr++) {
    char *shdr_name = shstrtab + shdr->sh_name;

    if (SHT_SYMTAB == shdr->sh_type && 0 == strcmp(".symtab", shdr_name)) {
      // get & check associated .strtab section
      if (shdr->sh_link >= ehdr->e_shnum) continue;
      ElfW(Shdr) *shdr_strtab = shdrs + shdr->sh_link;
      if (SHT_STRTAB != shdr_strtab->sh_type) continue;

      // get .symtab & .strtab
      ElfW(Sym) *symtab = (ElfW(Sym) *)xdl_read_file_to_heap_by_section(file_fd, file_sz, shdr);
      if (NULL == symtab) continue;
      char *strtab = (char *)xdl_read_file_to_heap_by_section(file_fd, file_sz, shdr_strtab);
      if (NULL == strtab) {
        free(symtab);
        continue;
      }

      // OK
      self->symtab = symtab;
      self->symtab_cnt = shdr->sh_size / shdr->sh_entsize;
      self->strtab = strtab;
      self->strtab_sz = shdr_strtab->sh_size;
      r = 0;
      break;
    } else if (SHT_PROGBITS == shdr->sh_type && 0 == strcmp(".gnu_debugdata", shdr_name)) {
      if (0 == xdl_symtab_load_from_debugdata(self, file_fd, file_sz, shdr)) {
        // OK
        r = 0;
        break;
      }
    }
  }

end:
  close(file_fd);
  if (NULL != shdrs) free(shdrs);
  if (NULL != shstrtab) free(shstrtab);
  return r;
}

static xdl_t *xdl_find_from_auxv(unsigned long type, const char *pathname) {
  if (NULL == getauxval) return NULL;

  uintptr_t val = (uintptr_t)getauxval(type);
  if (0 == val) return NULL;

  // get base
  uintptr_t base = (AT_PHDR == type ? (val & (~0xffful)) : val);
  if (0 != memcmp((void *)base, ELFMAG, SELFMAG)) return NULL;

  // ELF info
  ElfW(Ehdr) *ehdr = (ElfW(Ehdr) *)base;
  const ElfW(Phdr) *dlpi_phdr = (const ElfW(Phdr) *)(base + ehdr->e_phoff);
  ElfW(Half) dlpi_phnum = ehdr->e_phnum;

  // get bias
  uintptr_t min_vaddr = UINTPTR_MAX;
  for (size_t i = 0; i < dlpi_phnum; i++) {
    const ElfW(Phdr) *phdr = &(dlpi_phdr[i]);
    if (PT_LOAD == phdr->p_type) {
      if (min_vaddr > phdr->p_vaddr) min_vaddr = phdr->p_vaddr;
    }
  }
  if (UINTPTR_MAX == min_vaddr || base < min_vaddr) return NULL;
  uintptr_t load_bias = base - min_vaddr;

  // create xDL object
  xdl_t *self;
  if (NULL == (self = calloc(1, sizeof(xdl_t)))) return NULL;
  if (NULL == (self->pathname = strdup(pathname))) {
    free(self);
    return NULL;
  }
  self->load_bias = load_bias;
  self->dlpi_phdr = dlpi_phdr;
  self->dlpi_phnum = dlpi_phnum;
  self->dynsym_try_load = false;
  self->symtab_try_load = false;
  return self;
}

static int xdl_find_iterate_cb(struct dl_phdr_info *info, size_t size, void *arg) {
  (void)size;

  uintptr_t *pkg = (uintptr_t *)arg;
  xdl_t **self = (xdl_t **)*pkg++;
  const char *filename = (const char *)*pkg;

  // check load_bias
  if (0 == info->dlpi_addr || NULL == info->dlpi_name) return 0;

  // check pathname
  if ('[' == filename[0]) {
    if (0 != strcmp(info->dlpi_name, filename)) return 0;
  } else if ('/' == filename[0]) {
    if ('/' == info->dlpi_name[0]) {
      if (0 != strcmp(info->dlpi_name, filename)) return 0;
    } else {
      if (!xdl_util_ends_with(filename, info->dlpi_name)) return 0;
    }
  } else {
    if ('/' == info->dlpi_name[0]) {
      if (!xdl_util_ends_with(info->dlpi_name, filename)) return 0;
    } else {
      if (0 != strcmp(info->dlpi_name, filename)) return 0;
    }
  }

  // found the target ELF
  if (NULL == ((*self) = calloc(1, sizeof(xdl_t)))) return 1;  // return failed
  if (NULL == ((*self)->pathname = strdup(info->dlpi_name))) {
    free(*self);
    *self = NULL;
    return 1;  // return failed
  }
  (*self)->load_bias = info->dlpi_addr;
  (*self)->dlpi_phdr = info->dlpi_phdr;
  (*self)->dlpi_phnum = info->dlpi_phnum;
  (*self)->dynsym_try_load = false;
  (*self)->symtab_try_load = false;
  return 1;  // return OK
}

static xdl_t *xdl_find(const char *filename) {
  // from auxv (linker, vDSO)
  xdl_t *self = NULL;
  if (xdl_util_ends_with(filename, XDL_UTIL_LINKER_BASENAME))
    self = xdl_find_from_auxv(AT_BASE, XDL_UTIL_LINKER_PATHNAME);
  else if (xdl_util_ends_with(filename, XDL_UTIL_VDSO_BASENAME))
    self = xdl_find_from_auxv(AT_SYSINFO_EHDR, XDL_UTIL_VDSO_BASENAME);

  // from auxv (app_process)
  const char *basename, *pathname;
#if (defined(__arm__) || defined(__i386__)) && __ANDROID_API__ < __ANDROID_API_L__
  if (xdl_util_get_api_level() < __ANDROID_API_L__) {
    basename = XDL_UTIL_APP_PROCESS_BASENAME_K;
    pathname = XDL_UTIL_APP_PROCESS_PATHNAME_K;
  } else
#endif
  {
    basename = XDL_UTIL_APP_PROCESS_BASENAME;
    pathname = XDL_UTIL_APP_PROCESS_PATHNAME;
  }
  if (xdl_util_ends_with(filename, basename)) self = xdl_find_from_auxv(AT_PHDR, pathname);

  if (NULL != self) return self;

  // from dl_iterate_phdr
  uintptr_t pkg[2] = {(uintptr_t)&self, (uintptr_t)filename};
  xdl_iterate_phdr(xdl_find_iterate_cb, pkg, XDL_DEFAULT);
  return self;
}

static void *xdl_open_always_force(const char *filename) {
  // always force dlopen()
  void *linker_handle = xdl_linker_load(filename);
  if (NULL == linker_handle) return NULL;

  // find
  xdl_t *self = xdl_find(filename);
  if (NULL == self)
    dlclose(linker_handle);
  else
    self->linker_handle = linker_handle;

  return (void *)self;
}

static void *xdl_open_try_force(const char *filename) {
  // find
  xdl_t *self = xdl_find(filename);
  if (NULL != self) return (void *)self;

  // try force dlopen()
  void *linker_handle = xdl_linker_load(filename);
  if (NULL == linker_handle) return NULL;

  // find again
  self = xdl_find(filename);
  if (NULL == self)
    dlclose(linker_handle);
  else
    self->linker_handle = linker_handle;

  return (void *)self;
}

void *xdl_open(const char *filename, int flags) {
  if (NULL == filename) return NULL;

  if (flags & XDL_ALWAYS_FORCE_LOAD)
    return xdl_open_always_force(filename);
  else if (flags & XDL_TRY_FORCE_LOAD)
    return xdl_open_try_force(filename);
  else
    return xdl_find(filename);
}

void *xdl_close(void *handle) {
  if (NULL == handle) return NULL;

  xdl_t *self = (xdl_t *)handle;
  if (NULL != self->pathname) free(self->pathname);
  if (NULL != self->symtab) free(self->symtab);
  if (NULL != self->strtab) free(self->strtab);

  void *linker_handle = self->linker_handle;
  free(self);
  return linker_handle;
}

static uint32_t xdl_sysv_hash(const uint8_t *name) {
  uint32_t h = 0, g;

  while (*name) {
    h = (h << 4) + *name++;
    g = h & 0xf0000000;
    h ^= g;
    h ^= g >> 24;
  }
  return h;
}

static uint32_t xdl_gnu_hash(const uint8_t *name) {
  uint32_t h = 5381;

  while (*name) {
    h += (h << 5) + *name++;
  }
  return h;
}

static ElfW(Sym) *xdl_dynsym_find_symbol_use_sysv_hash(xdl_t *self, const char *sym_name) {
  uint32_t hash = xdl_sysv_hash((const uint8_t *)sym_name);

  for (uint32_t i = self->sysv_hash.buckets[hash % self->sysv_hash.buckets_cnt]; 0 != i;
       i = self->sysv_hash.chains[i]) {
    ElfW(Sym) *sym = self->dynsym + i;
    if (0 != strcmp(self->dynstr + sym->st_name, sym_name)) continue;
    return sym;
  }

  return NULL;
}

static ElfW(Sym) *xdl_dynsym_find_symbol_use_gnu_hash(xdl_t *self, const char *sym_name) {
  uint32_t hash = xdl_gnu_hash((const uint8_t *)sym_name);

  static uint32_t elfclass_bits = sizeof(ElfW(Addr)) * 8;
  size_t word = self->gnu_hash.bloom[(hash / elfclass_bits) % self->gnu_hash.bloom_cnt];
  size_t mask = 0 | (size_t)1 << (hash % elfclass_bits) |
                (size_t)1 << ((hash >> self->gnu_hash.bloom_shift) % elfclass_bits);

  // if at least one bit is not set, this symbol is surely missing
  if ((word & mask) != mask) return NULL;

  // ignore STN_UNDEF
  uint32_t i = self->gnu_hash.buckets[hash % self->gnu_hash.buckets_cnt];
  if (i < self->gnu_hash.symoffset) return NULL;

  // loop through the chain
  while (1) {
    ElfW(Sym) *sym = self->dynsym + i;
    uint32_t sym_hash = self->gnu_hash.chains[i - self->gnu_hash.symoffset];

    if ((hash | (uint32_t)1) == (sym_hash | (uint32_t)1)) {
      if (0 == strcmp(self->dynstr + sym->st_name, sym_name)) {
        return sym;
      }
    }

    // chain ends with an element with the lowest bit set to 1
    if (sym_hash & (uint32_t)1) break;

    i++;
  }

  return NULL;
}

void *xdl_sym(void *handle, const char *symbol, size_t *symbol_size) {
  if (NULL == handle || NULL == symbol) return NULL;
  if (NULL != symbol_size) *symbol_size = 0;

  xdl_t *self = (xdl_t *)handle;

  // load .dynsym only once
  if (!self->dynsym_try_load) {
    self->dynsym_try_load = true;
    if (0 != xdl_dynsym_load(self)) return NULL;
  }

  // find symbol
  if (NULL == self->dynsym) return NULL;
  ElfW(Sym) *sym = NULL;
  if (self->gnu_hash.buckets_cnt > 0) {
    // use GNU hash (.gnu.hash -> .dynsym -> .dynstr), O(x) + O(1) + O(1)
    sym = xdl_dynsym_find_symbol_use_gnu_hash(self, symbol);
  }
  if (NULL == sym && self->sysv_hash.buckets_cnt > 0) {
    // use SYSV hash (.hash -> .dynsym -> .dynstr), O(x) + O(1) + O(1)
    sym = xdl_dynsym_find_symbol_use_sysv_hash(self, symbol);
  }
  if (NULL == sym || !XDL_DYNSYM_IS_EXPORT_SYM(sym->st_shndx)) return NULL;

  if (NULL != symbol_size) *symbol_size = sym->st_size;
  return (void *)(self->load_bias + sym->st_value);
}

void *xdl_dsym(void *handle, const char *symbol, size_t *symbol_size) {
  if (NULL == handle || NULL == symbol) return NULL;
  if (NULL != symbol_size) *symbol_size = 0;

  xdl_t *self = (xdl_t *)handle;

  // load .symtab only once
  if (!self->symtab_try_load) {
    self->symtab_try_load = true;
    if (0 != xdl_symtab_load(self)) return NULL;
  }

  // find symbol
  if (NULL == self->symtab) return NULL;
  for (size_t i = 0; i < self->symtab_cnt; i++) {
    ElfW(Sym) *sym = self->symtab + i;

    if (!XDL_SYMTAB_IS_EXPORT_SYM(sym->st_shndx)) continue;
    if (0 != strncmp(self->strtab + sym->st_name, symbol, self->strtab_sz - sym->st_name)) continue;

    if (NULL != symbol_size) *symbol_size = sym->st_size;
    return (void *)(self->load_bias + sym->st_value);
  }

  return NULL;
}

static bool xdl_elf_is_match(uintptr_t load_bias, const ElfW(Phdr) *dlpi_phdr, ElfW(Half) dlpi_phnum,
                             uintptr_t addr) {
  if (addr < load_bias) return false;

  uintptr_t vaddr = addr - load_bias;
  for (size_t i = 0; i < dlpi_phnum; i++) {
    const ElfW(Phdr) *phdr = &(dlpi_phdr[i]);
    if (PT_LOAD != phdr->p_type) continue;

    if (phdr->p_vaddr <= vaddr && vaddr < phdr->p_vaddr + phdr->p_memsz) return true;
  }

  return false;
}

static int xdl_open_by_addr_iterate_cb(struct dl_phdr_info *info, size_t size, void *arg) {
  (void)size;

  uintptr_t *pkg = (uintptr_t *)arg;
  xdl_t **self = (xdl_t **)*pkg++;
  uintptr_t addr = *pkg;

  if (xdl_elf_is_match(info->dlpi_addr, info->dlpi_phdr, info->dlpi_phnum, addr)) {
    // found the target ELF
    if (NULL == ((*self) = calloc(1, sizeof(xdl_t)))) return 1;  // failed
    if (NULL == ((*self)->pathname = strdup(info->dlpi_name))) {
      free(*self);
      *self = NULL;
      return 1;  // failed
    }
    (*self)->load_bias = info->dlpi_addr;
    (*self)->dlpi_phdr = info->dlpi_phdr;
    (*self)->dlpi_phnum = info->dlpi_phnum;
    (*self)->dynsym_try_load = false;
    (*self)->symtab_try_load = false;
    return 1;  // OK
  }

  return 0;  // mismatch
}

static void *xdl_open_by_addr(void *addr) {
  if (NULL == addr) return NULL;

  xdl_t *self = NULL;
  uintptr_t pkg[2] = {(uintptr_t)&self, (uintptr_t)addr};
  xdl_iterate_phdr(xdl_open_by_addr_iterate_cb, pkg, XDL_DEFAULT);

  return (void *)self;
}

static bool xdl_sym_is_match(ElfW(Sym) *sym, uintptr_t offset, bool is_symtab) {
  if (is_symtab) {
    if (!XDL_SYMTAB_IS_EXPORT_SYM(sym->st_shndx)) false;
  } else {
    if (!XDL_DYNSYM_IS_EXPORT_SYM(sym->st_shndx)) false;
  }

  return ELF_ST_TYPE(sym->st_info) != STT_TLS && offset >= sym->st_value &&
         offset < sym->st_value + sym->st_size;
}

static ElfW(Sym) *xdl_sym_by_addr(void *handle, void *addr) {
  xdl_t *self = (xdl_t *)handle;

  // load .dynsym only once
  if (!self->dynsym_try_load) {
    self->dynsym_try_load = true;
    if (0 != xdl_dynsym_load(self)) return NULL;
  }

  // find symbol
  if (NULL == self->dynsym) return NULL;
  uintptr_t offset = (uintptr_t)addr - self->load_bias;
  if (self->gnu_hash.buckets_cnt > 0) {
    const uint32_t *chains_all = self->gnu_hash.chains - self->gnu_hash.symoffset;
    for (size_t i = 0; i < self->gnu_hash.buckets_cnt; i++) {
      uint32_t n = self->gnu_hash.buckets[i];
      if (n < self->gnu_hash.symoffset) continue;
      do {
        ElfW(Sym) *sym = self->dynsym + n;
        if (xdl_sym_is_match(sym, offset, false)) return sym;
      } while ((chains_all[n++] & 1) == 0);
    }
  } else if (self->sysv_hash.chains_cnt > 0) {
    for (size_t i = 0; i < self->sysv_hash.chains_cnt; i++) {
      ElfW(Sym) *sym = self->dynsym + i;
      if (xdl_sym_is_match(sym, offset, false)) return sym;
    }
  }

  return NULL;
}

static ElfW(Sym) *xdl_dsym_by_addr(void *handle, void *addr) {
  xdl_t *self = (xdl_t *)handle;

  // load .symtab only once
  if (!self->symtab_try_load) {
    self->symtab_try_load = true;
    if (0 != xdl_symtab_load(self)) return NULL;
  }

  // find symbol
  if (NULL == self->symtab) return NULL;
  uintptr_t offset = (uintptr_t)addr - self->load_bias;
  for (size_t i = 0; i < self->symtab_cnt; i++) {
    ElfW(Sym) *sym = self->symtab + i;
    if (xdl_sym_is_match(sym, offset, true)) return sym;
  }

  return NULL;
}

int xdl_addr(void *addr, xdl_info_t *info, void **cache) {
  if (NULL == addr || NULL == info || NULL == cache) return 0;

  memset(info, 0, sizeof(Dl_info));

  // find handle from cache
  xdl_t *handle = NULL;
  for (handle = *((xdl_t **)cache); NULL != handle; handle = handle->next)
    if (xdl_elf_is_match(handle->load_bias, handle->dlpi_phdr, handle->dlpi_phnum, (uintptr_t)addr)) break;

  // create new handle, save handle to cache
  if (NULL == handle) {
    handle = (xdl_t *)xdl_open_by_addr(addr);
    if (NULL == handle) return 0;
    handle->next = *(xdl_t **)cache;
    *(xdl_t **)cache = handle;
  }

  // we have at least: load_bias, pathname, dlpi_phdr, dlpi_phnum
  info->dli_fbase = (void *)handle->load_bias;
  info->dli_fname = handle->pathname;
  info->dli_sname = NULL;
  info->dli_saddr = 0;
  info->dli_ssize = 0;
  info->dlpi_phdr = handle->dlpi_phdr;
  info->dlpi_phnum = (size_t)handle->dlpi_phnum;

  // keep looking for: symbol name, symbol offset, symbol size
  ElfW(Sym) *sym;
  if (NULL != (sym = xdl_sym_by_addr((void *)handle, addr))) {
    info->dli_sname = handle->dynstr + sym->st_name;
    info->dli_saddr = (void *)(handle->load_bias + sym->st_value);
    info->dli_ssize = sym->st_size;
  } else if (NULL != (sym = xdl_dsym_by_addr((void *)handle, addr))) {
    info->dli_sname = handle->strtab + sym->st_name;
    info->dli_saddr = (void *)(handle->load_bias + sym->st_value);
    info->dli_ssize = sym->st_size;
  }

  return 1;
}

void xdl_addr_clean(void **cache) {
  if (NULL == cache) return;

  xdl_t *handle = *((xdl_t **)cache);
  while (NULL != handle) {
    xdl_t *tmp = handle;
    handle = handle->next;
    xdl_close(tmp);
  }
  *cache = NULL;
}

int xdl_iterate_phdr(int (*callback)(struct dl_phdr_info *, size_t, void *), void *data, int flags) {
  if (NULL == callback) return 0;

  return xdl_iterate_phdr_impl(callback, data, flags);
}

int xdl_info(void *handle, int request, void *info) {
  if (NULL == handle || XDL_DI_DLINFO != request || NULL == info) return -1;

  xdl_t *self = (xdl_t *)handle;
  xdl_info_t *dlinfo = (xdl_info_t *)info;

  dlinfo->dli_fbase = (void *)self->load_bias;
  dlinfo->dli_fname = self->pathname;
  dlinfo->dli_sname = NULL;
  dlinfo->dli_saddr = 0;
  dlinfo->dli_ssize = 0;
  dlinfo->dlpi_phdr = self->dlpi_phdr;
  dlinfo->dlpi_phnum = (size_t)self->dlpi_phnum;
  return 0;
}

```

`module/src/main/cpp/xdl/xdl_iterate.c`:

```c
// Copyright (c) 2020-2021 HexHacking Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Created by caikelun on 2020-10-04.

#include "xdl_iterate.h"

#include <android/api-level.h>
#include <ctype.h>
#include <dlfcn.h>
#include <elf.h>
#include <inttypes.h>
#include <link.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <sys/auxv.h>

#include "xdl.h"
#include "xdl_linker.h"
#include "xdl_util.h"

/*
 * =========================================================================================================
 * API-LEVEL  ANDROID-VERSION  SOLUTION
 * =========================================================================================================
 * 16         4.1              /proc/self/maps
 * 17         4.2              /proc/self/maps
 * 18         4.3              /proc/self/maps
 * 19         4.4              /proc/self/maps
 * 20         4.4W             /proc/self/maps
 * ---------------------------------------------------------------------------------------------------------
 * 21         5.0              dl_iterate_phdr() + __dl__ZL10g_dl_mutex + linker/linker64 from getauxval(3)
 * 22         5.1              dl_iterate_phdr() + __dl__ZL10g_dl_mutex + linker/linker64 from getauxval(3)
 * ---------------------------------------------------------------------------------------------------------
 * 23         >= 6.0           dl_iterate_phdr() + linker/linker64 from getauxval(3)
 * =========================================================================================================
 */

extern __attribute((weak)) int dl_iterate_phdr(int (*)(struct dl_phdr_info *, size_t, void *), void *);
extern __attribute((weak)) unsigned long int getauxval(unsigned long int);

static uintptr_t xdl_iterate_get_min_vaddr(struct dl_phdr_info *info) {
  uintptr_t min_vaddr = UINTPTR_MAX;
  for (size_t i = 0; i < info->dlpi_phnum; i++) {
    const ElfW(Phdr) *phdr = &(info->dlpi_phdr[i]);
    if (PT_LOAD == phdr->p_type) {
      if (min_vaddr > phdr->p_vaddr) min_vaddr = phdr->p_vaddr;
    }
  }
  return min_vaddr;
}

static int xdl_iterate_open_or_rewind_maps(FILE **maps) {
  if (NULL == *maps) {
    *maps = fopen("/proc/self/maps", "r");
    if (NULL == *maps) return -1;
  } else
    rewind(*maps);

  return 0;
}

static int xdl_iterate_get_pathname_from_maps(uintptr_t base, char *buf, size_t buf_len, FILE **maps) {
  // open or rewind maps-file
  if (0 != xdl_iterate_open_or_rewind_maps(maps)) return -1;  // failed

  char line[1024];
  while (fgets(line, sizeof(line), *maps)) {
    // check base address
    uintptr_t start, end;
    if (2 != sscanf(line, "%" SCNxPTR "-%" SCNxPTR " r", &start, &end)) continue;
    if (base < start) break;  // failed
    if (base >= end) continue;

    // get pathname
    char *pathname = strchr(line, '/');
    if (NULL == pathname) break;  // failed
    xdl_util_trim_ending(pathname);

    // found it
    strlcpy(buf, pathname, buf_len);
    return 0;  // OK
  }

  return -1;  // failed
}

static int xdl_iterate_by_linker_cb(struct dl_phdr_info *info, size_t size, void *arg) {
  uintptr_t *pkg = (uintptr_t *)arg;
  xdl_iterate_phdr_cb_t cb = (xdl_iterate_phdr_cb_t)*pkg++;
  void *cb_arg = (void *)*pkg++;
  FILE **maps = (FILE **)*pkg++;
  uintptr_t linker_load_bias = *pkg++;
  int flags = (int)*pkg;

  // ignore invalid ELF
  if (0 == info->dlpi_addr || NULL == info->dlpi_name || '\0' == info->dlpi_name[0]) return 0;

  // ignore linker if we have returned it already
  if (linker_load_bias == info->dlpi_addr) return 0;

  struct dl_phdr_info info_fixed;
  info_fixed.dlpi_addr = info->dlpi_addr;
  info_fixed.dlpi_name = info->dlpi_name;
  info_fixed.dlpi_phdr = info->dlpi_phdr;
  info_fixed.dlpi_phnum = info->dlpi_phnum;
  info = &info_fixed;

  // fix dlpi_phdr & dlpi_phnum (from memory)
  if (NULL == info->dlpi_phdr || 0 == info->dlpi_phnum) {
    ElfW(Ehdr) *ehdr = (ElfW(Ehdr) *)info->dlpi_addr;
    info->dlpi_phdr = (ElfW(Phdr) *)(info->dlpi_addr + ehdr->e_phoff);
    info->dlpi_phnum = ehdr->e_phnum;
  }

  // fix dlpi_name (from /proc/self/maps)
  if ('/' != info->dlpi_name[0] && '[' != info->dlpi_name[0] && (0 != (flags & XDL_FULL_PATHNAME))) {
    // get base address
    uintptr_t min_vaddr = xdl_iterate_get_min_vaddr(info);
    if (UINTPTR_MAX == min_vaddr) return 0;  // ignore this ELF
    uintptr_t base = (uintptr_t)(info->dlpi_addr + min_vaddr);

    char buf[1024];
    if (0 != xdl_iterate_get_pathname_from_maps(base, buf, sizeof(buf), maps)) return 0;  // ignore this ELF

    info->dlpi_name = (const char *)buf;
  }

  // callback
  return cb(info, size, cb_arg);
}

static uintptr_t xdl_iterate_get_linker_base(void) {
  if (NULL == getauxval) return 0;

  uintptr_t base = (uintptr_t)getauxval(AT_BASE);
  if (0 == base) return 0;
  if (0 != memcmp((void *)base, ELFMAG, SELFMAG)) return 0;

  return base;
}

static int xdl_iterate_do_callback(xdl_iterate_phdr_cb_t cb, void *cb_arg, uintptr_t base,
                                   const char *pathname, uintptr_t *load_bias) {
  ElfW(Ehdr) *ehdr = (ElfW(Ehdr) *)base;

  struct dl_phdr_info info;
  info.dlpi_name = pathname;
  info.dlpi_phdr = (const ElfW(Phdr) *)(base + ehdr->e_phoff);
  info.dlpi_phnum = ehdr->e_phnum;

  // get load bias
  uintptr_t min_vaddr = xdl_iterate_get_min_vaddr(&info);
  if (UINTPTR_MAX == min_vaddr) return 0;  // ignore invalid ELF
  info.dlpi_addr = (ElfW(Addr))(base - min_vaddr);
  if (NULL != load_bias) *load_bias = info.dlpi_addr;

  return cb(&info, sizeof(struct dl_phdr_info), cb_arg);
}

static int xdl_iterate_by_linker(xdl_iterate_phdr_cb_t cb, void *cb_arg, int flags) {
  if (NULL == dl_iterate_phdr) return 0;

  int api_level = xdl_util_get_api_level();
  FILE *maps = NULL;
  int r;

  // dl_iterate_phdr(3) does NOT contain linker/linker64 when Android version < 8.1 (API level 27).
  // Here we always try to get linker base address from auxv.
  uintptr_t linker_load_bias = 0;
  uintptr_t linker_base = xdl_iterate_get_linker_base();
  if (0 != linker_base) {
    if (0 !=
        (r = xdl_iterate_do_callback(cb, cb_arg, linker_base, XDL_UTIL_LINKER_PATHNAME, &linker_load_bias)))
      return r;
  }

  // for other ELF
  uintptr_t pkg[5] = {(uintptr_t)cb, (uintptr_t)cb_arg, (uintptr_t)&maps, linker_load_bias, (uintptr_t)flags};
  if (__ANDROID_API_L__ == api_level || __ANDROID_API_L_MR1__ == api_level) xdl_linker_lock();
  r = dl_iterate_phdr(xdl_iterate_by_linker_cb, pkg);
  if (__ANDROID_API_L__ == api_level || __ANDROID_API_L_MR1__ == api_level) xdl_linker_unlock();

  if (NULL != maps) fclose(maps);
  return r;
}

#if (defined(__arm__) || defined(__i386__)) && __ANDROID_API__ < __ANDROID_API_L__
static int xdl_iterate_by_maps(xdl_iterate_phdr_cb_t cb, void *cb_arg) {
  FILE *maps = fopen("/proc/self/maps", "r");
  if (NULL == maps) return 0;

  int r = 0;
  char buf1[1024], buf2[1024];
  char *line = buf1;
  uintptr_t prev_base = 0;
  bool try_next_line = false;

  while (fgets(line, sizeof(buf1), maps)) {
    // Try to find an ELF which loaded by linker.
    uintptr_t base, offset;
    char exec;
    if (3 != sscanf(line, "%" SCNxPTR "-%*" SCNxPTR " r%*c%cp %" SCNxPTR " ", &base, &exec, &offset)) goto clean;

    if ('-' == exec && 0 == offset) {
      // r--p
      prev_base = base;
      line = (line == buf1 ? buf2 : buf1);
      try_next_line = true;
      continue;
    }
    else if (exec == 'x') {
      // r-xp
      char *pathname = NULL;
      if (try_next_line && 0 != offset) {
        char *prev = (line == buf1 ? buf2 : buf1);
        char *prev_pathname = strchr(prev, '/');
        if (NULL == prev_pathname) goto clean;

        pathname = strchr(line, '/');
        if (NULL == pathname) goto clean;

        xdl_util_trim_ending(prev_pathname);
        xdl_util_trim_ending(pathname);
        if (0 != strcmp(prev_pathname, pathname)) goto clean;

        // we found the line with r-xp in the next line
        base = prev_base;
        offset = 0;
      }

      if (0 != offset) goto clean;

      // get pathname
      if (NULL == pathname) {
        pathname = strchr(line, '/');
        if (NULL == pathname) goto clean;
        xdl_util_trim_ending(pathname);
      }

      if (0 != memcmp((void *)base, ELFMAG, SELFMAG)) goto clean;
      ElfW(Ehdr) *ehdr = (ElfW(Ehdr) *)base;
      struct dl_phdr_info info;
      info.dlpi_name = pathname;
      info.dlpi_phdr = (const ElfW(Phdr) *)(base + ehdr->e_phoff);
      info.dlpi_phnum = ehdr->e_phnum;

      // callback
      if (0 != (r = xdl_iterate_do_callback(cb, cb_arg, base, pathname, NULL))) break;
    }

 clean:
    try_next_line = false;
  }

  fclose(maps);
  return r;
}
#endif

int xdl_iterate_phdr_impl(xdl_iterate_phdr_cb_t cb, void *cb_arg, int flags) {
  // iterate by /proc/self/maps in Android 4.x (Android 4.x only supports arm32 and x86)
#if (defined(__arm__) || defined(__i386__)) && __ANDROID_API__ < __ANDROID_API_L__
  if (xdl_util_get_api_level() < __ANDROID_API_L__) return xdl_iterate_by_maps(cb, cb_arg);
#endif

  // iterate by dl_iterate_phdr()
  return xdl_iterate_by_linker(cb, cb_arg, flags);
}

int xdl_iterate_get_full_pathname(uintptr_t base, char *buf, size_t buf_len) {
  FILE *maps = NULL;
  int r = xdl_iterate_get_pathname_from_maps(base, buf, buf_len, &maps);
  if (NULL != maps) fclose(maps);
  return r;
}

```

`module/src/main/cpp/xdl/xdl_iterate.h`:

```h
// Copyright (c) 2020-2021 HexHacking Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Created by caikelun on 2020-10-04.

#ifndef IO_HEXHACKING_XDL_ITERATE
#define IO_HEXHACKING_XDL_ITERATE

#include <link.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef int (*xdl_iterate_phdr_cb_t)(struct dl_phdr_info *info, size_t size, void *arg);
int xdl_iterate_phdr_impl(xdl_iterate_phdr_cb_t cb, void *cb_arg, int flags);

int xdl_iterate_get_full_pathname(uintptr_t base, char *buf, size_t buf_len);

#ifdef __cplusplus
}
#endif

#endif

```

`module/src/main/cpp/xdl/xdl_linker.c`:

```c
// Copyright (c) 2020-2021 HexHacking Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Created by caikelun on 2021-02-21.

#include "xdl_linker.h"

#include <dlfcn.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdio.h>

#include "xdl.h"
#include "xdl_iterate.h"
#include "xdl_util.h"

#define XDL_LINKER_SYM_MUTEX           "__dl__ZL10g_dl_mutex"
#define XDL_LINKER_SYM_DLOPEN_EXT_N    "__dl__ZL10dlopen_extPKciPK17android_dlextinfoPv"
#define XDL_LINKER_SYM_DO_DLOPEN_N     "__dl__Z9do_dlopenPKciPK17android_dlextinfoPv"
#define XDL_LINKER_SYM_DLOPEN_O        "__dl__Z8__dlopenPKciPKv"
#define XDL_LINKER_SYM_LOADER_DLOPEN_P "__loader_dlopen"

typedef void *(*xdl_linker_dlopen_n_t)(const char *, int, const void *, void *);
typedef void *(*xdl_linker_dlopen_o_t)(const char *, int, const void *);

static pthread_mutex_t *xdl_linker_mutex = NULL;
static void *xdl_linker_dlopen = NULL;

static void *xdl_linker_caller_addr[] = {
    NULL,  // default
    NULL,  // art
    NULL   // vendor
};

#ifndef __LP64__
#define XDL_LINKER_LIB "lib"
#else
#define XDL_LINKER_LIB "lib64"
#endif
static const char *xdl_linker_vendor_path[] = {
    // order is important
    "/vendor/" XDL_LINKER_LIB "/egl/",     "/vendor/" XDL_LINKER_LIB "/hw/",
    "/vendor/" XDL_LINKER_LIB "/",         "/odm/" XDL_LINKER_LIB "/",
    "/vendor/" XDL_LINKER_LIB "/vndk-sp/", "/odm/" XDL_LINKER_LIB "/vndk-sp/"};

static void xdl_linker_init(void) {
  static bool inited = false;
  if (inited) return;
  inited = true;

  void *handle = xdl_open(XDL_UTIL_LINKER_BASENAME, XDL_DEFAULT);
  if (NULL == handle) return;

  int api_level = xdl_util_get_api_level();
  if (__ANDROID_API_L__ == api_level || __ANDROID_API_L_MR1__ == api_level) {
    // == Android 5.x
    xdl_linker_mutex = (pthread_mutex_t *)xdl_dsym(handle, XDL_LINKER_SYM_MUTEX, NULL);
  } else if (__ANDROID_API_N__ == api_level || __ANDROID_API_N_MR1__ == api_level) {
    // == Android 7.x
    xdl_linker_dlopen = xdl_dsym(handle, XDL_LINKER_SYM_DLOPEN_EXT_N, NULL);
    if (NULL == xdl_linker_dlopen) {
      xdl_linker_dlopen = xdl_dsym(handle, XDL_LINKER_SYM_DO_DLOPEN_N, NULL);
      xdl_linker_mutex = (pthread_mutex_t *)xdl_dsym(handle, XDL_LINKER_SYM_MUTEX, NULL);
    }
  } else if (__ANDROID_API_O__ == api_level || __ANDROID_API_O_MR1__ == api_level) {
    // == Android 8.x
    xdl_linker_dlopen = xdl_dsym(handle, XDL_LINKER_SYM_DLOPEN_O, NULL);
  } else if (api_level >= __ANDROID_API_P__) {
    // >= Android 9.0
    xdl_linker_dlopen = xdl_sym(handle, XDL_LINKER_SYM_LOADER_DLOPEN_P, NULL);
  }

  xdl_close(handle);
}

void xdl_linker_lock(void) {
  xdl_linker_init();

  if (NULL != xdl_linker_mutex) pthread_mutex_lock(xdl_linker_mutex);
}

void xdl_linker_unlock(void) {
  if (NULL != xdl_linker_mutex) pthread_mutex_unlock(xdl_linker_mutex);
}

static void *xdl_linker_get_caller_addr(struct dl_phdr_info *info) {
  for (size_t i = 0; i < info->dlpi_phnum; i++) {
    const ElfW(Phdr) *phdr = &(info->dlpi_phdr[i]);
    if (PT_LOAD == phdr->p_type) {
      return (void *)(info->dlpi_addr + phdr->p_vaddr);
    }
  }
  return NULL;
}

static int xdl_linker_get_caller_addr_cb(struct dl_phdr_info *info, size_t size, void *arg) {
  (void)size;

  size_t *vendor_match = (size_t *)arg;

  if (0 == info->dlpi_addr || NULL == info->dlpi_name) return 0;  // continue

  if (NULL == xdl_linker_caller_addr[0] && xdl_util_ends_with(info->dlpi_name, "/libc.so"))
    xdl_linker_caller_addr[0] = xdl_linker_get_caller_addr(info);

  if (NULL == xdl_linker_caller_addr[1] && xdl_util_ends_with(info->dlpi_name, "/libart.so"))
    xdl_linker_caller_addr[1] = xdl_linker_get_caller_addr(info);

  if (0 != *vendor_match) {
    for (size_t i = 0; i < *vendor_match; i++) {
      if (xdl_util_starts_with(info->dlpi_name, xdl_linker_vendor_path[i])) {
        void *caller_addr = xdl_linker_get_caller_addr(info);
        if (NULL != caller_addr) {
          xdl_linker_caller_addr[2] = caller_addr;
          *vendor_match = i;
        }
      }
    }
  }

  if (NULL != xdl_linker_caller_addr[0] && NULL != xdl_linker_caller_addr[1] && 0 == *vendor_match) {
    return 1;  // finish
  } else {
    return 0;  // continue
  }
}

static void xdl_linker_load_caller_addr(void) {
  if (NULL == xdl_linker_caller_addr[0]) {
    size_t vendor_match = sizeof(xdl_linker_vendor_path) / sizeof(xdl_linker_vendor_path[0]);
    xdl_iterate_phdr_impl(xdl_linker_get_caller_addr_cb, &vendor_match, XDL_DEFAULT);
  }
}

void *xdl_linker_load(const char *filename) {
  int api_level = xdl_util_get_api_level();

  if (api_level <= __ANDROID_API_M__) {
    // <= Android 6.0
    return dlopen(filename, RTLD_NOW);
  } else {
    xdl_linker_init();
    if (NULL == xdl_linker_dlopen) return NULL;
    xdl_linker_load_caller_addr();

    void *handle = NULL;
    if (__ANDROID_API_N__ == api_level || __ANDROID_API_N_MR1__ == api_level) {
      // == Android 7.x
      xdl_linker_lock();
      for (size_t i = 0; i < sizeof(xdl_linker_caller_addr) / sizeof(xdl_linker_caller_addr[0]); i++) {
        if (NULL != xdl_linker_caller_addr[i]) {
          handle =
              ((xdl_linker_dlopen_n_t)xdl_linker_dlopen)(filename, RTLD_NOW, NULL, xdl_linker_caller_addr[i]);
          if (NULL != handle) break;
        }
      }
      xdl_linker_unlock();
    } else {
      // >= Android 8.0
      for (size_t i = 0; i < sizeof(xdl_linker_caller_addr) / sizeof(xdl_linker_caller_addr[0]); i++) {
        if (NULL != xdl_linker_caller_addr[i]) {
          handle = ((xdl_linker_dlopen_o_t)xdl_linker_dlopen)(filename, RTLD_NOW, xdl_linker_caller_addr[i]);
          if (NULL != handle) break;
        }
      }
    }
    return handle;
  }
}

```

`module/src/main/cpp/xdl/xdl_linker.h`:

```h
// Copyright (c) 2020-2021 HexHacking Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Created by caikelun on 2021-02-21.

#ifndef IO_HEXHACKING_XDL_LINKER
#define IO_HEXHACKING_XDL_LINKER

#ifdef __cplusplus
extern "C" {
#endif

void xdl_linker_lock(void);
void xdl_linker_unlock(void);

void *xdl_linker_load(const char *filename);

#ifdef __cplusplus
}
#endif

#endif

```

`module/src/main/cpp/xdl/xdl_lzma.c`:

```c
// Copyright (c) 2020-2021 HexHacking Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Created by caikelun on 2020-11-08.

#include "xdl_lzma.h"

#include <ctype.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xdl.h"
#include "xdl_util.h"

// LZMA library pathname & symbol names
#ifndef __LP64__
#define XDL_LZMA_PATHNAME "/system/lib/liblzma.so"
#else
#define XDL_LZMA_PATHNAME "/system/lib64/liblzma.so"
#endif
#define XDL_LZMA_SYM_CRCGEN     "CrcGenerateTable"
#define XDL_LZMA_SYM_CRC64GEN   "Crc64GenerateTable"
#define XDL_LZMA_SYM_CONSTRUCT  "XzUnpacker_Construct"
#define XDL_LZMA_SYM_ISFINISHED "XzUnpacker_IsStreamWasFinished"
#define XDL_LZMA_SYM_FREE       "XzUnpacker_Free"
#define XDL_LZMA_SYM_CODE       "XzUnpacker_Code"

// LZMA data type definition
#define SZ_OK 0
typedef struct ISzAlloc ISzAlloc;
typedef const ISzAlloc *ISzAllocPtr;
struct ISzAlloc {
  void *(*Alloc)(ISzAllocPtr p, size_t size);
  void (*Free)(ISzAllocPtr p, void *address); /* address can be 0 */
};
typedef enum {
  CODER_STATUS_NOT_SPECIFIED,      /* use main error code instead */
  CODER_STATUS_FINISHED_WITH_MARK, /* stream was finished with end mark. */
  CODER_STATUS_NOT_FINISHED,       /* stream was not finished */
  CODER_STATUS_NEEDS_MORE_INPUT    /* you must provide more input bytes */
} ECoderStatus;
typedef enum {
  CODER_FINISH_ANY, /* finish at any point */
  CODER_FINISH_END  /* block must be finished at the end */
} ECoderFinishMode;

// LZMA function type definition
typedef void (*xdl_lzma_crcgen_t)(void);
typedef void (*xdl_lzma_crc64gen_t)(void);
typedef void (*xdl_lzma_construct_t)(void *, ISzAllocPtr);
typedef int (*xdl_lzma_isfinished_t)(const void *);
typedef void (*xdl_lzma_free_t)(void *);
typedef int (*xdl_lzma_code_t)(void *, uint8_t *, size_t *, const uint8_t *, size_t *, ECoderFinishMode,
                               ECoderStatus *);
typedef int (*xdl_lzma_code_q_t)(void *, uint8_t *, size_t *, const uint8_t *, size_t *, int,
                                 ECoderFinishMode, ECoderStatus *);

// LZMA function pointor
static xdl_lzma_construct_t xdl_lzma_construct = NULL;
static xdl_lzma_isfinished_t xdl_lzma_isfinished = NULL;
static xdl_lzma_free_t xdl_lzma_free = NULL;
static void *xdl_lzma_code = NULL;

// LZMA init
static void xdl_lzma_init() {
  void *lzma = xdl_open(XDL_LZMA_PATHNAME, XDL_TRY_FORCE_LOAD);
  if (NULL == lzma) return;

  xdl_lzma_crcgen_t crcgen = NULL;
  xdl_lzma_crc64gen_t crc64gen = NULL;
  if (NULL == (crcgen = (xdl_lzma_crcgen_t)xdl_sym(lzma, XDL_LZMA_SYM_CRCGEN, NULL))) goto end;
  if (NULL == (crc64gen = (xdl_lzma_crc64gen_t)xdl_sym(lzma, XDL_LZMA_SYM_CRC64GEN, NULL))) goto end;
  if (NULL == (xdl_lzma_construct = (xdl_lzma_construct_t)xdl_sym(lzma, XDL_LZMA_SYM_CONSTRUCT, NULL)))
    goto end;
  if (NULL == (xdl_lzma_isfinished = (xdl_lzma_isfinished_t)xdl_sym(lzma, XDL_LZMA_SYM_ISFINISHED, NULL)))
    goto end;
  if (NULL == (xdl_lzma_free = (xdl_lzma_free_t)xdl_sym(lzma, XDL_LZMA_SYM_FREE, NULL))) goto end;
  if (NULL == (xdl_lzma_code = xdl_sym(lzma, XDL_LZMA_SYM_CODE, NULL))) goto end;
  crcgen();
  crc64gen();

end:
  xdl_close(lzma);
}

// LZMA internal alloc / free
static void *xdl_lzma_internal_alloc(ISzAllocPtr p, size_t size) {
  (void)p;
  return malloc(size);
}
static void xdl_lzma_internal_free(ISzAllocPtr p, void *address) {
  (void)p;
  free(address);
}

int xdl_lzma_decompress(uint8_t *src, size_t src_size, uint8_t **dst, size_t *dst_size) {
  size_t src_offset = 0;
  size_t dst_offset = 0;
  size_t src_remaining;
  size_t dst_remaining;
  ISzAlloc alloc = {.Alloc = xdl_lzma_internal_alloc, .Free = xdl_lzma_internal_free};
  long long state[4096 / sizeof(long long)];  // must be enough, 8-bit aligned
  ECoderStatus status;
  int api_level = xdl_util_get_api_level();

  // init and check
  static bool inited = false;
  if (!inited) {
    xdl_lzma_init();
    inited = true;
  }
  if (NULL == xdl_lzma_code) return -1;

  xdl_lzma_construct(&state, &alloc);

  *dst_size = 2 * src_size;
  *dst = NULL;
  do {
    *dst_size *= 2;
    if (NULL == (*dst = realloc(*dst, *dst_size))) {
      xdl_lzma_free(&state);
      return -1;
    }

    src_remaining = src_size - src_offset;
    dst_remaining = *dst_size - dst_offset;

    int result;
    if (api_level >= __ANDROID_API_Q__) {
      xdl_lzma_code_q_t lzma_code_q = (xdl_lzma_code_q_t)xdl_lzma_code;
      result = lzma_code_q(&state, *dst + dst_offset, &dst_remaining, src + src_offset, &src_remaining, 1,
                           CODER_FINISH_ANY, &status);
    } else {
      xdl_lzma_code_t lzma_code = (xdl_lzma_code_t)xdl_lzma_code;
      result = lzma_code(&state, *dst + dst_offset, &dst_remaining, src + src_offset, &src_remaining,
                         CODER_FINISH_ANY, &status);
    }
    if (SZ_OK != result) {
      free(*dst);
      xdl_lzma_free(&state);
      return -1;
    }

    src_offset += src_remaining;
    dst_offset += dst_remaining;
  } while (status == CODER_STATUS_NOT_FINISHED);

  xdl_lzma_free(&state);

  if (!xdl_lzma_isfinished(&state)) {
    free(*dst);
    return -1;
  }

  *dst_size = dst_offset;
  *dst = realloc(*dst, *dst_size);
  return 0;
}

```

`module/src/main/cpp/xdl/xdl_lzma.h`:

```h
// Copyright (c) 2020-2021 HexHacking Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Created by caikelun on 2020-11-08.

#ifndef IO_HEXHACKING_XDL_LZMA
#define IO_HEXHACKING_XDL_LZMA

#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

int xdl_lzma_decompress(uint8_t *src, size_t src_size, uint8_t **dst, size_t *dst_size);

#ifdef __cplusplus
}
#endif

#endif

```

`module/src/main/cpp/xdl/xdl_util.c`:

```c
// Copyright (c) 2020-2021 HexHacking Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Created by caikelun on 2020-10-04.

#include "xdl_util.h"

#include <android/api-level.h>
#include <ctype.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

bool xdl_util_starts_with(const char *str, const char *start) {
  while (*str && *str == *start) {
    str++;
    start++;
  }

  return '\0' == *start;
}

bool xdl_util_ends_with(const char *str, const char *ending) {
  size_t str_len = strlen(str);
  size_t ending_len = strlen(ending);

  if (ending_len > str_len) return false;

  return 0 == strcmp(str + (str_len - ending_len), ending);
}

size_t xdl_util_trim_ending(char *start) {
  char *end = start + strlen(start);
  while (start < end && isspace((int)(*(end - 1)))) {
    end--;
    *end = '\0';
  }
  return (size_t)(end - start);
}

static int xdl_util_get_api_level_from_build_prop(void) {
  char buf[128];
  int api_level = -1;

  FILE *fp = fopen("/system/build.prop", "r");
  if (NULL == fp) goto end;

  while (fgets(buf, sizeof(buf), fp)) {
    if (xdl_util_starts_with(buf, "ro.build.version.sdk=")) {
      api_level = atoi(buf + 21);
      break;
    }
  }
  fclose(fp);

end:
  return (api_level > 0) ? api_level : -1;
}

int xdl_util_get_api_level(void) {
  static int xdl_util_api_level = -1;

  if (xdl_util_api_level < 0) {
    int api_level = android_get_device_api_level();
    if (api_level < 0)
      api_level = xdl_util_get_api_level_from_build_prop();  // compatible with unusual models
    if (api_level < __ANDROID_API_J__) api_level = __ANDROID_API_J__;

    __atomic_store_n(&xdl_util_api_level, api_level, __ATOMIC_SEQ_CST);
  }

  return xdl_util_api_level;
}

```

`module/src/main/cpp/xdl/xdl_util.h`:

```h
// Copyright (c) 2020-2021 HexHacking Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Created by caikelun on 2020-10-04.

#ifndef IO_HEXHACKING_XDL_UTIL
#define IO_HEXHACKING_XDL_UTIL

#include <errno.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef __LP64__
#define XDL_UTIL_LINKER_BASENAME        "linker"
#define XDL_UTIL_LINKER_PATHNAME        "/system/bin/linker"
#define XDL_UTIL_APP_PROCESS_BASENAME   "app_process32"
#define XDL_UTIL_APP_PROCESS_PATHNAME   "/system/bin/app_process32"
#define XDL_UTIL_APP_PROCESS_BASENAME_K "app_process"
#define XDL_UTIL_APP_PROCESS_PATHNAME_K "/system/bin/app_process"
#else
#define XDL_UTIL_LINKER_BASENAME      "linker64"
#define XDL_UTIL_LINKER_PATHNAME      "/system/bin/linker64"
#define XDL_UTIL_APP_PROCESS_BASENAME "app_process64"
#define XDL_UTIL_APP_PROCESS_PATHNAME "/system/bin/app_process64"
#endif
#define XDL_UTIL_VDSO_BASENAME "[vdso]"

#define XDL_UTIL_TEMP_FAILURE_RETRY(exp)   \
  ({                                       \
    __typeof__(exp) _rc;                   \
    do {                                   \
      errno = 0;                           \
      _rc = (exp);                         \
    } while (_rc == -1 && errno == EINTR); \
    _rc;                                   \
  })

#ifdef __cplusplus
extern "C" {
#endif

bool xdl_util_starts_with(const char *str, const char *start);
bool xdl_util_ends_with(const char *str, const char *ending);

size_t xdl_util_trim_ending(char *start);

int xdl_util_get_api_level(void);

#ifdef __cplusplus
}
#endif

#endif

```

`module/src/main/cpp/zygisk.hpp`:

```hpp
// This is the public API for Zygisk modules.
// DO NOT MODIFY ANY CODE IN THIS HEADER.

#pragma once

#include <jni.h>

#define ZYGISK_API_VERSION 2

/*

Define a class and inherit zygisk::ModuleBase to implement the functionality of your module.
Use the macro REGISTER_ZYGISK_MODULE(className) to register that class to Zygisk.

Please note that modules will only be loaded after zygote has forked the child process.
THIS MEANS ALL OF YOUR CODE RUNS IN THE APP/SYSTEM SERVER PROCESS, NOT THE ZYGOTE DAEMON!

Example code:

static jint (*orig_logger_entry_max)(JNIEnv *env);
static jint my_logger_entry_max(JNIEnv *env) { return orig_logger_entry_max(env); }

static void example_handler(int socket) { ... }

class ExampleModule : public zygisk::ModuleBase {
public:
    void onLoad(zygisk::Api *api, JNIEnv *env) override {
        this->api = api;
        this->env = env;
    }
    void preAppSpecialize(zygisk::AppSpecializeArgs *args) override {
        JNINativeMethod methods[] = {
            { "logger_entry_max_payload_native", "()I", (void*) my_logger_entry_max },
        };
        api->hookJniNativeMethods(env, "android/util/Log", methods, 1);
        *(void **) &orig_logger_entry_max = methods[0].fnPtr;
    }
private:
    zygisk::Api *api;
    JNIEnv *env;
};

REGISTER_ZYGISK_MODULE(ExampleModule)

REGISTER_ZYGISK_COMPANION(example_handler)

*/

namespace zygisk {

struct Api;
struct AppSpecializeArgs;
struct ServerSpecializeArgs;

class ModuleBase {
public:

    // This function is called when the module is loaded into the target process.
    // A Zygisk API handle will be sent as an argument; call utility functions or interface
    // with Zygisk through this handle.
    virtual void onLoad([[maybe_unused]] Api *api, [[maybe_unused]] JNIEnv *env) {}

    // This function is called before the app process is specialized.
    // At this point, the process just got forked from zygote, but no app specific specialization
    // is applied. This means that the process does not have any sandbox restrictions and
    // still runs with the same privilege of zygote.
    //
    // All the arguments that will be sent and used for app specialization is passed as a single
    // AppSpecializeArgs object. You can read and overwrite these arguments to change how the app
    // process will be specialized.
    //
    // If you need to run some operations as superuser, you can call Api::connectCompanion() to
    // get a socket to do IPC calls with a root companion process.
    // See Api::connectCompanion() for more info.
    virtual void preAppSpecialize([[maybe_unused]] AppSpecializeArgs *args) {}

    // This function is called after the app process is specialized.
    // At this point, the process has all sandbox restrictions enabled for this application.
    // This means that this function runs as the same privilege of the app's own code.
    virtual void postAppSpecialize([[maybe_unused]] const AppSpecializeArgs *args) {}

    // This function is called before the system server process is specialized.
    // See preAppSpecialize(args) for more info.
    virtual void preServerSpecialize([[maybe_unused]] ServerSpecializeArgs *args) {}

    // This function is called after the system server process is specialized.
    // At this point, the process runs with the privilege of system_server.
    virtual void postServerSpecialize([[maybe_unused]] const ServerSpecializeArgs *args) {}
};

struct AppSpecializeArgs {
    // Required arguments. These arguments are guaranteed to exist on all Android versions.
    jint &uid;
    jint &gid;
    jintArray &gids;
    jint &runtime_flags;
    jint &mount_external;
    jstring &se_info;
    jstring &nice_name;
    jstring &instruction_set;
    jstring &app_data_dir;

    // Optional arguments. Please check whether the pointer is null before de-referencing
    jboolean *const is_child_zygote;
    jboolean *const is_top_app;
    jobjectArray *const pkg_data_info_list;
    jobjectArray *const whitelisted_data_info_list;
    jboolean *const mount_data_dirs;
    jboolean *const mount_storage_dirs;

    AppSpecializeArgs() = delete;
};

struct ServerSpecializeArgs {
    jint &uid;
    jint &gid;
    jintArray &gids;
    jint &runtime_flags;
    jlong &permitted_capabilities;
    jlong &effective_capabilities;

    ServerSpecializeArgs() = delete;
};

namespace internal {
struct api_table;
template <class T> void entry_impl(api_table *, JNIEnv *);
}

// These values are used in Api::setOption(Option)
enum Option : int {
    // Force Magisk's denylist unmount routines to run on this process.
    //
    // Setting this option only makes sense in preAppSpecialize.
    // The actual unmounting happens during app process specialization.
    //
    // Set this option to force all Magisk and modules' files to be unmounted from the
    // mount namespace of the process, regardless of the denylist enforcement status.
    FORCE_DENYLIST_UNMOUNT = 0,

    // When this option is set, your module's library will be dlclose-ed after post[XXX]Specialize.
    // Be aware that after dlclose-ing your module, all of your code will be unmapped from memory.
    // YOU MUST NOT ENABLE THIS OPTION AFTER HOOKING ANY FUNCTIONS IN THE PROCESS.
    DLCLOSE_MODULE_LIBRARY = 1,
};

// Bit masks of the return value of Api::getFlags()
enum StateFlag : uint32_t {
    // The user has granted root access to the current process
    PROCESS_GRANTED_ROOT = (1u << 0),

    // The current process was added on the denylist
    PROCESS_ON_DENYLIST = (1u << 1),
};

// All API functions will stop working after post[XXX]Specialize as Zygisk will be unloaded
// from the specialized process afterwards.
struct Api {

    // Connect to a root companion process and get a Unix domain socket for IPC.
    //
    // This API only works in the pre[XXX]Specialize functions due to SELinux restrictions.
    //
    // The pre[XXX]Specialize functions run with the same privilege of zygote.
    // If you would like to do some operations with superuser permissions, register a handler
    // function that would be called in the root process with REGISTER_ZYGISK_COMPANION(func).
    // Another good use case for a companion process is that if you want to share some resources
    // across multiple processes, hold the resources in the companion process and pass it over.
    //
    // The root companion process is ABI aware; that is, when calling this function from a 32-bit
    // process, you will be connected to a 32-bit companion process, and vice versa for 64-bit.
    //
    // Returns a file descriptor to a socket that is connected to the socket passed to your
    // module's companion request handler. Returns -1 if the connection attempt failed.
    int connectCompanion();

    // Get the file descriptor of the root folder of the current module.
    //
    // This API only works in the pre[XXX]Specialize functions.
    // Accessing the directory returned is only possible in the pre[XXX]Specialize functions
    // or in the root companion process (assuming that you sent the fd over the socket).
    // Both restrictions are due to SELinux and UID.
    //
    // Returns -1 if errors occurred.
    int getModuleDir();

    // Set various options for your module.
    // Please note that this function accepts one single option at a time.
    // Check zygisk::Option for the full list of options available.
    void setOption(Option opt);

    // Get information about the current process.
    // Returns bitwise-or'd zygisk::StateFlag values.
    uint32_t getFlags();

    // Hook JNI native methods for a class
    //
    // Lookup all registered JNI native methods and replace it with your own functions.
    // The original function pointer will be saved in each JNINativeMethod's fnPtr.
    // If no matching class, method name, or signature is found, that specific JNINativeMethod.fnPtr
    // will be set to nullptr.
    void hookJniNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *methods, int numMethods);

    // For ELFs loaded in memory matching `regex`, replace function `symbol` with `newFunc`.
    // If `oldFunc` is not nullptr, the original function pointer will be saved to `oldFunc`.
    void pltHookRegister(const char *regex, const char *symbol, void *newFunc, void **oldFunc);

    // For ELFs loaded in memory matching `regex`, exclude hooks registered for `symbol`.
    // If `symbol` is nullptr, then all symbols will be excluded.
    void pltHookExclude(const char *regex, const char *symbol);

    // Commit all the hooks that was previously registered.
    // Returns false if an error occurred.
    bool pltHookCommit();

private:
    internal::api_table *impl;
    template <class T> friend void internal::entry_impl(internal::api_table *, JNIEnv *);
};

// Register a class as a Zygisk module

#define REGISTER_ZYGISK_MODULE(clazz) \
void zygisk_module_entry(zygisk::internal::api_table *table, JNIEnv *env) { \
    zygisk::internal::entry_impl<clazz>(table, env);                        \
}

// Register a root companion request handler function for your module
//
// The function runs in a superuser daemon process and handles a root companion request from
// your module running in a target process. The function has to accept an integer value,
// which is a socket that is connected to the target process.
// See Api::connectCompanion() for more info.
//
// NOTE: the function can run concurrently on multiple threads.
// Be aware of race conditions if you have a globally shared resource.

#define REGISTER_ZYGISK_COMPANION(func) \
void zygisk_companion_entry(int client) { func(client); }

/************************************************************************************
 * All the code after this point is internal code used to interface with Zygisk
 * and guarantee ABI stability. You do not have to understand what it is doing.
 ************************************************************************************/

namespace internal {

struct module_abi {
    long api_version;
    ModuleBase *_this;

    void (*preAppSpecialize)(ModuleBase *, AppSpecializeArgs *);
    void (*postAppSpecialize)(ModuleBase *, const AppSpecializeArgs *);
    void (*preServerSpecialize)(ModuleBase *, ServerSpecializeArgs *);
    void (*postServerSpecialize)(ModuleBase *, const ServerSpecializeArgs *);

    module_abi(ModuleBase *module) : api_version(ZYGISK_API_VERSION), _this(module) {
        preAppSpecialize = [](auto self, auto args) { self->preAppSpecialize(args); };
        postAppSpecialize = [](auto self, auto args) { self->postAppSpecialize(args); };
        preServerSpecialize = [](auto self, auto args) { self->preServerSpecialize(args); };
        postServerSpecialize = [](auto self, auto args) { self->postServerSpecialize(args); };
    }
};

struct api_table {
    // These first 2 entries are permanent, shall never change
    void *_this;
    bool (*registerModule)(api_table *, module_abi *);

    // Utility functions
    void (*hookJniNativeMethods)(JNIEnv *, const char *, JNINativeMethod *, int);
    void (*pltHookRegister)(const char *, const char *, void *, void **);
    void (*pltHookExclude)(const char *, const char *);
    bool (*pltHookCommit)();

    // Zygisk functions
    int  (*connectCompanion)(void * /* _this */);
    void (*setOption)(void * /* _this */, Option);
    int  (*getModuleDir)(void * /* _this */);
    uint32_t (*getFlags)(void * /* _this */);
};

template <class T>
void entry_impl(api_table *table, JNIEnv *env) {
    ModuleBase *module = new T();
    if (!table->registerModule(table, new module_abi(module)))
        return;
    auto api = new Api();
    api->impl = table;
    module->onLoad(api, env);
}

} // namespace internal

inline int Api::connectCompanion() {
    return impl->connectCompanion ? impl->connectCompanion(impl->_this) : -1;
}
inline int Api::getModuleDir() {
    return impl->getModuleDir ? impl->getModuleDir(impl->_this) : -1;
}
inline void Api::setOption(Option opt) {
    if (impl->setOption) impl->setOption(impl->_this, opt);
}
inline uint32_t Api::getFlags() {
    return impl->getFlags ? impl->getFlags(impl->_this) : 0;
}
inline void Api::hookJniNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *methods, int numMethods) {
    if (impl->hookJniNativeMethods) impl->hookJniNativeMethods(env, className, methods, numMethods);
}
inline void Api::pltHookRegister(const char *regex, const char *symbol, void *newFunc, void **oldFunc) {
    if (impl->pltHookRegister) impl->pltHookRegister(regex, symbol, newFunc, oldFunc);
}
inline void Api::pltHookExclude(const char *regex, const char *symbol) {
    if (impl->pltHookExclude) impl->pltHookExclude(regex, symbol);
}
inline bool Api::pltHookCommit() {
    return impl->pltHookCommit != nullptr && impl->pltHookCommit();
}

} // namespace zygisk

[[gnu::visibility("default")]] [[gnu::used]]
extern "C" void zygisk_module_entry(zygisk::internal::api_table *, JNIEnv *);

[[gnu::visibility("default")]] [[gnu::used]]
extern "C" void zygisk_companion_entry(int);

```

`scripts/README.md`:

```md
# Auto Config Tool for Zygisk-MyInjector

自动配置工具，通过交互式命令行快速配置应用注入。

## 功能特性

- 🎯 交互式设备选择（支持多设备）
- 🔍 Tab 自动补全选择应用包名（支持模糊搜索）
- ⚙️ 交互式 Gadget 配置（Server/Script 模式）
- 📦 自动下载 Frida Gadget 16.0.7（自动检测设备架构）
- 📦 自动生成配置文件
- 🚀 一键推送并应用配置

## 安装依赖

```bash
pip install prompt_toolkit
```

## 使用方法

### 基本用法

```bash
./auto_config.py
```

### 工作流程

1. **设备选择**
   - 自动检测连接的设备
   - 单设备时自动选择
   - 多设备时交互式选择

2. **应用选择**
   - 可选是否包含系统应用（默认仅第三方应用）
   - 使用 Tab 键自动补全包名
   - 支持模糊搜索过滤

3. **Gadget 配置**
   - 指定 Gadget 名称（默认 libgadget.so）
   - **Server 模式**：监听端口等待 Frida 连接
     - 监听地址（默认 0.0.0.0）
     - 监听端口（默认 27042）
     - 端口冲突处理（fail/ignore/close，默认 fail）
     - 加载行为（resume/wait，默认 resume）
   
   - **Script 模式**：执行本地脚本
     - 脚本路径（默认 /data/local/tmp/script.js）

4. **Frida Gadget 检查与安装**
   - 自动检查设备上是否已安装 Gadget
   - 如未安装，自动下载 Frida Gadget 16.0.7
   - 根据设备架构选择正确版本（arm64/arm/x86/x86_64）
   - 自动解压并安装到模块 SO 库

5. **配置部署**
   - 自动生成 config.json 和 gadget 配置文件
   - 推送到设备 /data/local/tmp
   - 发送广播触发应用配置

## 示例会话

```
============================================================
Zygisk-MyInjector Auto Config Tool
============================================================

Using device: 192.168.1.100:5555 (OnePlus)

=== Loading app packages ===
Include system apps? (y/N): n
Found 156 packages

=== Select Target App ===
Tip: Use Tab for auto-completion, type to filter
Package name: com.example.app
Selected: com.example.app

=== Gadget Configuration ===
Gadget SO name (default: libgadget.so): 
libgadget.so

Select mode:
1. Server mode (listen for connections)
2. Script mode (execute script)
Mode (1/2, default: 1): 1

Listen address (default: 0.0.0.0): 
Listen port (default: 27042): 

Port conflict behavior:
1. fail - Exit if port is in use
2. ignore - Continue anyway
3. close - Close existing connection
On port conflict (1/2/3, default: 1): 1

On load behavior:
1. resume - Continue immediately (recommended)
2. wait - Wait for connection (for debugging)
On load (1/2, default: 1): 1

=== Generating Configuration Files ===
...

✓ Configuration applied successfully!

The app 'com.example.app' has been configured.
You can now use Frida to connect to the app:
  frida -H 0.0.0.0:27042 -n <process-name>
```

## 生成的文件

脚本会生成以下文件：

1. **config.json**
   - 模块主配置文件
   - 存储位置：`/data/adb/modules/zygisk-myinjector/config.json`

2. **gadget 配置文件**
   - 格式：`libgadget.config.so`
   - 存储位置：`/data/data/<package>/files/libgadget.config.so`

## 广播接收器

配置通过广播接收器应用：

**注意**：ConfigApplyReceiver 现在使用**动态注册**方式，第三方 app 无法通过 PackageManager 发现其存在。
同时增加了 UID 权限检查，只允许 shell (2000) 或 root (0) 发送广播。

```bash
# 手动发送广播示例
adb shell am broadcast \
  -n com.jiqiu.configapp/.ConfigApplyReceiver \
  -a com.jiqiu.configapp.APPLY_CONFIG \
  --es package_name "com.example.app" \
  --es tmp_config_path "/data/local/tmp/zygisk_config.json" \
  --es tmp_gadget_config_path "/data/local/tmp/libgadget.config.so"
```

## 调试

查看日志：

```bash
adb logcat -s ConfigApplyReceiver:* ConfigManager:*
```

## 故障排除

### prompt_toolkit 未安装

```
Error: prompt_toolkit is required. Install it with:
  pip install prompt_toolkit
```

**解决方案**：运行 `pip install prompt_toolkit`

### 没有设备连接

```
Error: No devices found. Please connect a device and enable USB debugging.
```

**解决方案**：
1. 通过 USB 或 WiFi 连接设备
2. 确保已启用 USB 调试
3. 运行 `adb devices` 确认设备已连接

### 广播发送失败

**解决方案**：
1. 确保 configapp 已安装
2. 确保设备已 root
3. 检查 logcat 日志获取详细错误信息

## 高级用法

### 仅生成配置不部署

修改广播命令添加 `deploy_only` 参数：

```bash
adb shell am broadcast \
  -n com.jiqiu.configapp/.ConfigApplyReceiver \
  -a com.jiqiu.configapp.APPLY_CONFIG \
  --es package_name "com.example.app" \
  --es tmp_config_path "/data/local/tmp/zygisk_config.json" \
  --ez deploy_only true
```

## 注意事项

1. ⚠️ 设备必须已 root
2. ⚠️ configapp 必须已安装
3. ✓ **SELinux 会自动检查并设置为 Permissive 模式**（脚本会自动处理）
4. ⚠️ 首次使用会自动下载 Frida Gadget 16.0.7（需要网络连接）
5. ⚠️ 配置完成后需要重启目标应用才能生效
6. ⚠️ 需要安装 `xz` 工具用于解压（macOS 通过 `brew install xz` 安装）

### SELinux 问题

Zygisk 模块需要读取 `/data/adb/modules/zygisk-myinjector/config.json`，但 SELinux 默认会阻止 zygote 进程访问。

**自动处理**：
`auto_config.py` 脚本会自动检查 SELinux 状态，如果处于 Enforcing 模式会提示设置为 Permissive。

**手动设置**（重启后需重新设置）：
```bash
adb shell "su -c 'setenforce 0'"
```

**永久解决方案**（需要 Magisk 模块）：
创建 SELinux 策略或修改模块实现方式。

## 完整工作流程

```bash
# 1. 运行自动配置脚本（会自动检查并设置 SELinux）
cd scripts
./auto_config.py

# 2. 按提示选择设备、应用和配置（全部使用默认值即可）
#    脚本会自动完成：
#    - 生成配置文件
#    - 推送到设备
#    - 应用配置
#    - 重启应用
#    - 端口转发
#    - 快速测试

# 3. 如果测试成功，直接使用 Frida 连接
frida -H 127.0.0.1:27042 Gadget -l your_script.js
```

### 快速测试示例

```bash
# 测试连接
frida -H 127.0.0.1:27042 Gadget -e "console.log('Connected! PID:', Process.id)"

# 列举模块
frida -H 127.0.0.1:27042 Gadget -e "Process.enumerateModules().forEach(m => console.log(m.name))"
```

```

`scripts/auto_config.py`:

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Auto Config Script for Zygisk-MyInjector
通过交互式命令行快速配置应用注入

完整工作流程:
  1. 运行自动配置脚本（会自动检查并设置 SELinux）
     cd scripts
     ./auto_config.py
  
  2. 按提示选择设备、应用和配置（全部使用默认值即可）
     脚本会自动完成：
     - 生成配置文件
     - 推送到设备
     - 应用配置
     - 重启应用
     - 端口转发
     - 快速测试
  
  3. 如果测试成功，直接使用 Frida 连接
     frida -H 127.0.0.1:27042 Gadget -l your_script.js

快速测试:
  # 测试连接
  frida -H 127.0.0.1:27042 Gadget -e "console.log('Connected! PID:', Process.id)"
  
  # 列举模块
  frida -H 127.0.0.1:27042 Gadget -e "Process.enumerateModules().forEach(m => console.log(m.name))"
"""

import subprocess
import json
import sys
import os
import tempfile
import shutil
import argparse
from typing import List, Dict, Optional
from pathlib import Path

try:
    from prompt_toolkit import prompt
    from prompt_toolkit.completion import FuzzyWordCompleter
    from prompt_toolkit.styles import Style
except ImportError:
    print("Error: prompt_toolkit is required. Install it with:")
    print("  pip install prompt_toolkit")
    sys.exit(1)


# Define style for prompts
style = Style.from_dict({
    'prompt': 'ansicyan bold',
})

# Frida Gadget version
FRIDA_VERSION = "16.0.7"
MODULE_PATH = "/data/adb/modules/zygisk-myinjector"
SO_STORAGE_DIR = f"{MODULE_PATH}/so_files"

# Default ports
DEFAULT_PORTS = [27042, 65320]

# Local cache directory for downloaded gadgets
SCRIPT_DIR = Path(__file__).parent
CACHE_DIR = SCRIPT_DIR / '.cache' / 'frida-gadgets'


class ADBHelper:
    """ADB helper class for device and package operations"""
    
    def __init__(self, device_id: Optional[str] = None):
        self.device_id = device_id
        self.base_cmd = ['adb']
        if device_id:
            self.base_cmd.extend(['-s', device_id])
    
    def run(self, args: List[str], check=True) -> subprocess.CompletedProcess:
        """Run adb command"""
        cmd = self.base_cmd + args
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=check)
            return result
        except subprocess.CalledProcessError as e:
            print(f"Error running command: {' '.join(cmd)}")
            print(f"Error: {e.stderr}")
            if check:
                raise
            return e
    
    @staticmethod
    def get_devices() -> List[Dict[str, str]]:
        """Get list of connected devices"""
        result = subprocess.run(['adb', 'devices', '-l'], capture_output=True, text=True)
        lines = result.stdout.strip().split('\n')[1:]  # Skip header
        devices = []
        
        for line in lines:
            if not line.strip():
                continue
            parts = line.split()
            if len(parts) >= 2:
                device_id = parts[0]
                status = parts[1]
                
                # Parse device info
                model = ''
                product = ''
                for part in parts[2:]:
                    if part.startswith('model:'):
                        model = part.split(':', 1)[1]
                    elif part.startswith('product:'):
                        product = part.split(':', 1)[1]
                
                devices.append({
                    'id': device_id,
                    'status': status,
                    'model': model,
                    'product': product
                })
        
        return devices
    
    def get_packages(self, include_system: bool = False) -> List[str]:
        """Get list of installed packages"""
        args = ['shell', 'pm', 'list', 'packages']
        if not include_system:
            args.append('-3')  # Third-party apps only
        
        result = self.run(args)
        packages = []
        for line in result.stdout.strip().split('\n'):
            if line.startswith('package:'):
                pkg = line.split(':', 1)[1].strip()
                packages.append(pkg)
        
        return sorted(packages)
    
    def push_file(self, local_path: str, remote_path: str) -> bool:
        """Push file to device"""
        result = self.run(['push', local_path, remote_path], check=False)
        return result.returncode == 0
    
    def send_broadcast(self, action: str, component: str, extras: Dict[str, str]) -> bool:
        """Send broadcast with extras"""
        args = ['shell', 'am', 'broadcast', '-n', component, '-a', action]
        
        for key, value in extras.items():
            args.extend(['--es', key, value])
        
        result = self.run(args, check=False)
        if result.returncode == 0:
            print(f"Broadcast sent successfully")
            print(result.stdout)
            return True
        else:
            print(f"Failed to send broadcast")
            print(result.stderr)
            return False
    
    def get_arch(self) -> str:
        """Get device CPU architecture"""
        result = self.run(['shell', 'getprop', 'ro.product.cpu.abi'])
        arch = result.stdout.strip()
        return arch
    
    def file_exists(self, path: str) -> bool:
        """Check if file exists on device"""
        result = self.run(['shell', f'su -c "test -f {path} && echo exists"'], check=False)
        return 'exists' in result.stdout


def select_device() -> Optional[str]:
    """Interactive device selection"""
    devices = ADBHelper.get_devices()
    
    if not devices:
        print("Error: No devices found. Please connect a device and enable USB debugging.")
        return None
    
    if len(devices) == 1:
        device = devices[0]
        print(f"Using device: {device['id']} ({device['model'] or device['product']})")
        return device['id']
    
    print("\n=== Connected Devices ===")
    for idx, device in enumerate(devices, 1):
        model_info = device['model'] or device['product'] or 'Unknown'
        print(f"{idx}. {device['id']} - {model_info} [{device['status']}]")
    
    while True:
        try:
            choice = input(f"\nSelect device (1-{len(devices)}): ").strip()
            idx = int(choice) - 1
            if 0 <= idx < len(devices):
                selected = devices[idx]
                print(f"Selected: {selected['id']} ({selected['model'] or selected['product']})")
                return selected['id']
            else:
                print(f"Invalid choice. Please enter 1-{len(devices)}")
        except (ValueError, KeyboardInterrupt):
            print("\nDevice selection cancelled")
            return None


def select_package(adb: ADBHelper) -> Optional[str]:
    """Interactive package selection with fuzzy completion"""
    print("\n=== Loading app packages ===")
    
    # Ask if include system apps
    while True:
        choice = input("Include system apps? (y/N): ").strip().lower()
        if choice in ['', 'n', 'no']:
            include_system = False
            break
        elif choice in ['y', 'yes']:
            include_system = True
            break
        else:
            print("Please enter 'y' or 'n'")
    
    packages = adb.get_packages(include_system=include_system)
    
    if not packages:
        print("Error: No packages found")
        return None
    
    print(f"Found {len(packages)} packages")
    
    # Create fuzzy completer
    completer = FuzzyWordCompleter(packages)
    
    print("\n=== Select Target App ===")
    print("Tip: Use Tab for auto-completion, type to filter")
    
    try:
        package = prompt(
            'Package name: ',
            completer=completer,
            style=style
        ).strip()
        
        if package and package in packages:
            print(f"Selected: {package}")
            return package
        elif package:
            print(f"Warning: '{package}' not found in package list, using anyway")
            return package
        else:
            print("No package selected")
            return None
    except KeyboardInterrupt:
        print("\nSelection cancelled")
        return None


def configure_gadget(preset_port: Optional[int] = None) -> Optional[Dict]:
    """Interactive gadget configuration"""
    print("\n=== Gadget Configuration ===")
    
    gadget_config = {}
    
    # Gadget name
    gadget_name = input("Gadget SO name (default: libgadget.so): ").strip()
    gadget_config['gadgetName'] = gadget_name or 'libgadget.so'
    
    # Mode selection
    print("\nSelect mode:")
    print("1. Server mode (listen for connections)")
    print("2. Script mode (execute script)")
    
    while True:
        choice = input("Mode (1/2, default: 1): ").strip()
        if choice in ['', '1']:
            gadget_config['mode'] = 'server'
            break
        elif choice == '2':
            gadget_config['mode'] = 'script'
            break
        else:
            print("Invalid choice. Please enter 1 or 2")
    
    if gadget_config['mode'] == 'server':
        # Server mode configuration
        address = input("Listen address (default: 0.0.0.0): ").strip()
        gadget_config['address'] = address or '0.0.0.0'
        
        # Use preset port if provided
        if preset_port:
            gadget_config['port'] = preset_port
            print(f"\nUsing preset port: {preset_port}")
        else:
            print(f"\nAvailable ports: {', '.join(map(str, DEFAULT_PORTS))}")
            port = input(f"Listen port (default: {DEFAULT_PORTS[0]}): ").strip()
            try:
                gadget_config['port'] = int(port) if port else DEFAULT_PORTS[0]
            except ValueError:
                print(f"Invalid port, using default {DEFAULT_PORTS[0]}")
                gadget_config['port'] = DEFAULT_PORTS[0]
        
        print("\nPort conflict behavior:")
        print("1. fail - Exit if port is in use")
        print("2. ignore - Continue anyway")
        print("3. close - Close existing connection")
        conflict = input("On port conflict (1/2/3, default: 1): ").strip()
        conflict_map = {'1': 'fail', '2': 'ignore', '3': 'close', '': 'fail'}
        gadget_config['onPortConflict'] = conflict_map.get(conflict, 'fail')
        
        print("\nOn load behavior:")
        print("1. resume - Continue immediately (recommended)")
        print("2. wait - Wait for connection (for debugging)")
        load = input("On load (1/2, default: 1): ").strip()
        load_map = {'1': 'resume', '2': 'wait', '': 'resume'}
        gadget_config['onLoad'] = load_map.get(load, 'resume')
        
    else:
        # Script mode configuration
        script_path = input("Script path (default: /data/local/tmp/script.js): ").strip()
        gadget_config['scriptPath'] = script_path or '/data/local/tmp/script.js'
    
    return gadget_config


def download_frida_gadget(arch: str) -> Optional[str]:
    """Download Frida Gadget for specified architecture (with local caching)"""
    # Map Android arch to Frida naming
    arch_map = {
        'arm64-v8a': 'arm64',
        'armeabi-v7a': 'arm',
        'x86': 'x86',
        'x86_64': 'x86_64'
    }
    
    frida_arch = arch_map.get(arch)
    if not frida_arch:
        print(f"Unsupported architecture: {arch}")
        return None
    
    # Check local cache first
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    cached_file = CACHE_DIR / f"frida-gadget-{FRIDA_VERSION}-android-{frida_arch}.so"
    
    if cached_file.exists():
        print(f"\n✓ Using cached Frida Gadget {FRIDA_VERSION} for {arch}")
        print(f"  Cache: {cached_file}")
        # Copy to temp location for consistent behavior
        temp_dir = tempfile.mkdtemp(prefix='frida_gadget_')
        temp_file = os.path.join(temp_dir, 'libgadget.so')
        shutil.copy2(str(cached_file), temp_file)
        return temp_file
    
    # Download if not in cache
    url = f"https://github.com/frida/frida/releases/download/{FRIDA_VERSION}/frida-gadget-{FRIDA_VERSION}-android-{frida_arch}.so.xz"
    
    print(f"\nDownloading Frida Gadget {FRIDA_VERSION} for {arch}...")
    print(f"URL: {url}")
    
    # Create temp directory
    temp_dir = tempfile.mkdtemp(prefix='frida_gadget_')
    xz_file = os.path.join(temp_dir, f'frida-gadget.so.xz')
    so_file = os.path.join(temp_dir, 'libgadget.so')
    
    try:
        # Download
        result = subprocess.run(['curl', '-L', '-o', xz_file, url], 
                              capture_output=True, text=True, check=False)
        if result.returncode != 0:
            print(f"Failed to download: {result.stderr}")
            shutil.rmtree(temp_dir)
            return None
        
        print("✓ Downloaded")
        
        # Decompress
        print("Decompressing...")
        result = subprocess.run(['xz', '-d', xz_file], 
                              capture_output=True, text=True, check=False)
        if result.returncode != 0:
            print(f"Failed to decompress: {result.stderr}")
            shutil.rmtree(temp_dir)
            return None
        
        # Rename
        decompressed = xz_file.replace('.xz', '')
        os.rename(decompressed, so_file)
        
        print("✓ Decompressed")
        
        # Save to cache for future use
        try:
            shutil.copy2(so_file, str(cached_file))
            print(f"✓ Cached for future use: {cached_file}")
        except Exception as e:
            print(f"Warning: Failed to cache gadget: {e}")
        
        return so_file
        
    except Exception as e:
        print(f"Error downloading Frida Gadget: {e}")
        if os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)
        return None


def ensure_gadget_installed(adb: ADBHelper, gadget_name: str = 'libgadget.so') -> bool:
    """Ensure Frida Gadget is installed on device"""
    gadget_path = f"{SO_STORAGE_DIR}/{gadget_name}"
    
    print(f"\n=== Checking Frida Gadget ===")
    
    # Check if gadget already exists
    if adb.file_exists(gadget_path):
        print(f"✓ Gadget found: {gadget_path}")
        return True
    
    print(f"Gadget not found in: {gadget_path}")
    print("Need to download and install Frida Gadget")
    
    # Get device architecture
    arch = adb.get_arch()
    print(f"Device architecture: {arch}")
    
    # Download gadget
    local_gadget = download_frida_gadget(arch)
    if not local_gadget:
        print("Failed to download Frida Gadget")
        return False
    
    try:
        # Push to device temp location
        print("\nPushing to device...")
        if not adb.push_file(local_gadget, '/data/local/tmp/libgadget.so'):
            print("Failed to push gadget to device")
            return False
        
        print("✓ Pushed to device")
        
        # Copy to SO storage with root
        print(f"Installing to {gadget_path}...")
        result = adb.run(['shell', f'su -c "mkdir -p {SO_STORAGE_DIR}"'], check=False)
        result = adb.run(['shell', 
                         f'su -c "cp /data/local/tmp/libgadget.so {gadget_path}"'], 
                        check=False)
        
        if result.returncode != 0:
            print(f"Failed to install gadget: {result.stderr}")
            return False
        
        # Set permissions
        adb.run(['shell', f'su -c "chmod 755 {gadget_path}"'], check=False)
        
        # Verify
        if adb.file_exists(gadget_path):
            print(f"✓ Gadget installed successfully: {gadget_path}")
            # Clean up temp file on device
            adb.run(['shell', 'rm -f /data/local/tmp/libgadget.so'], check=False)
            return True
        else:
            print("Failed to verify gadget installation")
            return False
            
    finally:
        # Clean up local temp file
        temp_dir = os.path.dirname(local_gadget)
        if os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)


def generate_config_files(package_name: str, gadget_config: Dict) -> tuple:
    """Generate config.json and gadget config content"""
    
    # Prepare SO file reference for gadget
    gadget_name = gadget_config['gadgetName']
    gadget_so_ref = {
        "name": gadget_name,
        "storedPath": f"{SO_STORAGE_DIR}/{gadget_name}",
        "originalPath": f"{SO_STORAGE_DIR}/{gadget_name}"
    }
    
    # Generate main module config.json
    module_config = {
        "enabled": True,
        "hideInjection": False,
        "injectionDelay": 2,
        "globalSoFiles": [],
        "perAppConfig": {
            package_name: {
                "enabled": True,
                "soFiles": [gadget_so_ref],  # Include gadget SO file
                "injectionMethod": "standard",
                "gadgetConfig": gadget_config,
                "useGlobalGadget": False
            }
        },
        "globalGadgetConfig": None
    }
    
    # Generate gadget config content based on mode
    if gadget_config['mode'] == 'server':
        gadget_config_content = {
            "interaction": {
                "type": "listen",
                "address": gadget_config['address'],
                "port": gadget_config['port'],
                "on_port_conflict": gadget_config['onPortConflict'],
                "on_load": gadget_config['onLoad']
            }
        }
    else:  # script mode
        gadget_config_content = {
            "interaction": {
                "type": "script",
                "path": gadget_config['scriptPath']
            }
        }
    
    return (
        json.dumps(module_config, indent=2, ensure_ascii=False),
        json.dumps(gadget_config_content, indent=2, ensure_ascii=False)
    )


def quick_test(adb: ADBHelper, port: int = 27042):
    """Quick test connectivity after configuration"""
    print("\n=== Quick Test ===")
    print("Testing Frida connectivity...\n")
    
    # Check if frida is installed
    result = subprocess.run(['which', 'frida'], capture_output=True, text=True)
    if result.returncode != 0:
        print("⚠️  Frida CLI not found. Please install it with:")
        print("    pip install frida-tools")
        return False
    
    # Test 1: Basic connection test
    print("Test 1: Basic connection...")
    # 使用 stdin 输入命令和 exit，避免交互式 REPL 导致超时
    test_input = "console.log('Connected! PID:', Process.id)\nexit\n"
    test_cmd = ['frida', '-H', f'127.0.0.1:{port}', 'Gadget']
    
    result = subprocess.run(test_cmd, input=test_input, capture_output=True, text=True, timeout=10)
    if result.returncode == 0 and 'Connected!' in result.stdout:
        print("✓ Connection successful!")
        # 提取并显示 PID
        for line in result.stdout.split('\n'):
            if 'Connected! PID:' in line:
                print(f"  {line.strip()}")
                break
    else:
        print("✗ Connection failed")
        print(f"  Error: {result.stderr.strip() if result.stderr else 'Unknown error'}")
        print("\nTroubleshooting:")
        print("  1. Check if the target app is running")
        print("  2. Verify port forwarding: adb forward tcp:{} tcp:{}".format(port, port))
        print("  3. Check logcat for errors: adb logcat -s Gadget:*")
        return False
    
    # Test 2: Enumerate modules
    print("\nTest 2: Enumerate loaded modules...")
    test_input = "Process.enumerateModules().slice(0, 5).forEach(m => console.log('  -', m.name))\nexit\n"
    test_cmd = ['frida', '-H', f'127.0.0.1:{port}', 'Gadget']
    
    result = subprocess.run(test_cmd, input=test_input, capture_output=True, text=True, timeout=10)
    if result.returncode == 0:
        print("✓ Modules enumerated:")
        # 提取并显示模块列表
        in_output = False
        for line in result.stdout.split('\n'):
            if '  -' in line:
                in_output = True
                print(line)
            elif in_output and line.strip() == '':
                break
    else:
        print("✗ Failed to enumerate modules")
        print(f"  Error: {result.stderr.strip()}")
    
    return True


def setup_port_forward(adb: ADBHelper, port: int) -> bool:
    """Setup ADB port forwarding"""
    print(f"\n=== Setting up port forwarding ===")
    print(f"Forwarding local port {port} to device port {port}...")
    
    result = adb.run(['forward', f'tcp:{port}', f'tcp:{port}'], check=False)
    if result.returncode == 0:
        print(f"✓ Port forwarding established: tcp:{port} -> tcp:{port}")
        return True
    else:
        print(f"✗ Failed to setup port forwarding")
        print(f"  Error: {result.stderr}")
        return False


def check_and_set_selinux(adb: ADBHelper) -> bool:
    """Check SELinux status and set to Permissive if needed"""
    print("\n=== Checking SELinux Status ===")
    
    # Check current SELinux status
    result = adb.run(['shell', 'getenforce'], check=False)
    if result.returncode != 0:
        print("⚠️  Failed to check SELinux status")
        return True  # Continue anyway
    
    status = result.stdout.strip()
    print(f"Current SELinux mode: {status}")
    
    if status == 'Permissive':
        print("✓ SELinux is already in Permissive mode")
        return True
    elif status == 'Enforcing':
        print("\n⚠️  SELinux is in Enforcing mode")
        print("   Zygisk modules cannot read config files when SELinux is Enforcing.")
        print("   We need to set it to Permissive mode.")
        
        # Ask user for confirmation
        while True:
            choice = input("\nSet SELinux to Permissive? (Y/n): ").strip().lower()
            if choice in ['', 'y', 'yes']:
                break
            elif choice in ['n', 'no']:
                print("\nWarning: Continuing with SELinux Enforcing may cause injection to fail.")
                print("You can manually set it later with: adb shell \"su -c 'setenforce 0'\"")
                return True
            else:
                print("Please enter 'y' or 'n'")
        
        # Set SELinux to Permissive
        print("\nSetting SELinux to Permissive...")
        result = adb.run(['shell', 'su', '-c', 'setenforce 0'], check=False)
        
        if result.returncode == 0:
            print("✓ SELinux set to Permissive mode")
            print("  Note: This setting will reset after reboot")
            return True
        else:
            print("✗ Failed to set SELinux to Permissive")
            print(f"  Error: {result.stderr.strip()}")
            print("\nPlease manually run: adb shell \"su -c 'setenforce 0'\"")
            return False
    else:
        print(f"Unknown SELinux status: {status}")
        return True


def restart_app(adb: ADBHelper, package_name: str):
    """Restart the target application"""
    print(f"\n=== Restarting Application ===")
    
    # Force stop
    print(f"Stopping {package_name}...")
    result = adb.run(['shell', 'am', 'force-stop', package_name], check=False)
    if result.returncode == 0:
        print("✓ App stopped")
    else:
        print("⚠️  Failed to stop app")
    
    # Get main activity
    print(f"\nGetting launch activity...")
    result = adb.run(['shell', 'pm', 'dump', package_name, '|', 'grep', '-A', '1', 'android.intent.action.MAIN'], check=False)
    
    # Try to start the app
    print(f"Starting {package_name}...")
    result = adb.run(['shell', 'monkey', '-p', package_name, '-c', 'android.intent.category.LAUNCHER', '1'], check=False)
    
    if result.returncode == 0:
        print("✓ App started")
        print("  Note: The app should now load with Frida Gadget injected")
        return True
    else:
        print("⚠️  Failed to start app automatically")
        print("  Please start the app manually from the device")
        return False


def main():
    """Main entry point"""
    # Parse command line arguments
    parser = argparse.ArgumentParser(
        description='Zygisk-MyInjector Auto Config Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        '-p', '--port',
        type=int,
        choices=DEFAULT_PORTS,
        help=f'Preset Gadget port (choices: {", ".join(map(str, DEFAULT_PORTS))})'
    )
    args = parser.parse_args()
    
    print("=" * 60)
    print("Zygisk-MyInjector Auto Config Tool")
    print("=" * 60)
    
    # Step 1: Select device
    device_id = select_device()
    if not device_id:
        sys.exit(1)
    
    adb = ADBHelper(device_id)
    
    # Step 2: Check and set SELinux
    if not check_and_set_selinux(adb):
        print("\nError: Failed to configure SELinux")
        print("The injection may fail. Please fix SELinux manually and try again.")
        sys.exit(1)
    
    # Step 3: Select package
    package_name = select_package(adb)
    if not package_name:
        sys.exit(1)
    
    # Step 4: Configure gadget
    gadget_config = configure_gadget(preset_port=args.port)
    if not gadget_config:
        sys.exit(1)
    
    # Step 5: Ensure Frida Gadget is installed
    if not ensure_gadget_installed(adb, gadget_config['gadgetName']):
        print("\nError: Failed to install Frida Gadget")
        print("Please manually download and install libgadget.so")
        sys.exit(1)
    
    # Step 6: Generate config files
    print("\n=== Generating Configuration Files ===")
    config_json, gadget_config_json = generate_config_files(package_name, gadget_config)
    
    print("\nGenerated config.json:")
    print(config_json)
    print("\nGenerated gadget config:")
    print(gadget_config_json)
    
    # Step 7: Save to temp files
    temp_dir = tempfile.mkdtemp(prefix='frida_gadget_config_')
    
    config_file = os.path.join(temp_dir, 'config.json')
    gadget_name = gadget_config['gadgetName'].replace('.so', '.config.so')
    gadget_config_file = os.path.join(temp_dir, gadget_name)
    
    with open(config_file, 'w', encoding='utf-8') as f:
        f.write(config_json)
    
    with open(gadget_config_file, 'w', encoding='utf-8') as f:
        f.write(gadget_config_json)
    
    print(f"\nConfig files saved to: {temp_dir}")
    
    # Step 8: Push to device
    print("\n=== Pushing Files to Device ===")
    
    remote_config = '/data/local/tmp/zygisk_config.json'
    remote_gadget_config = f'/data/local/tmp/{gadget_name}'
    
    if not adb.push_file(config_file, remote_config):
        print("Error: Failed to push config.json")
        sys.exit(1)
    print(f"✓ Pushed config.json -> {remote_config}")
    
    if not adb.push_file(gadget_config_file, remote_gadget_config):
        print("Error: Failed to push gadget config")
        sys.exit(1)
    print(f"✓ Pushed gadget config -> {remote_gadget_config}")
    
    # Step 9: Send broadcast
    print("\n=== Sending Broadcast to Apply Config ===")
    
    success = adb.send_broadcast(
        action='com.jiqiu.configapp.APPLY_CONFIG',
        component='com.jiqiu.configapp/.ConfigApplyReceiver',
        extras={
            'package_name': package_name,
            'tmp_config_path': remote_config,
            'tmp_gadget_config_path': remote_gadget_config
        }
    )
    
    if success:
        print("\n✓ Configuration applied successfully!")
        print(f"\nThe app '{package_name}' has been configured.")
        
        # 自动完成工作流程
        print("\n=== Completing Workflow ===")
        
        # Step 1: Restart app
        restart_app(adb, package_name)
        
        # Step 2: Setup port forwarding
        port = gadget_config.get('port', 27042)
        if setup_port_forward(adb, port):
            # Step 3: Quick test
            import time
            print("\nWaiting 3 seconds for app to initialize...")
            time.sleep(3)
            
            try:
                test_success = quick_test(adb, port)
                if test_success:
                    # 彩色打印 frida 命令
                    print("\n" + "="*60)
                    print("\033[1;32m✓ All tests passed!\033[0m\n")
                    print("\033[1;36mYou can now use Frida with the following commands:\033[0m\n")
                    
                    # Interactive mode
                    print("\033[1;33m# Interactive REPL:\033[0m")
                    print(f"\033[1;32mfrida -H 127.0.0.1:{port} Gadget\033[0m\n")
                    
                    # Execute script
                    print("\033[1;33m# Execute JavaScript code:\033[0m")
                    print(f"\033[1;32mfrida -H 127.0.0.1:{port} Gadget -e 'YOUR_CODE_HERE'\033[0m\n")
                    
                    # Load script file
                    print("\033[1;33m# Load script file:\033[0m")
                    print(f"\033[1;32mfrida -H 127.0.0.1:{port} Gadget -l your_script.js\033[0m\n")
                    
                    print("="*60)
            except Exception as e:
                print(f"\n⚠️  Test failed: {e}")
                print("\nYou can manually test with:")
                if gadget_config['mode'] == 'server':
                    print(f"\033[1;32mfrida -H 127.0.0.1:{port} Gadget -l your_script.js\033[0m")
    else:
        print("\n✗ Failed to apply configuration")
        print("Please check logcat for details:")
        print(f"  adb -s {device_id} logcat -s ConfigApplyReceiver:* ConfigManager:*")
        sys.exit(1)
    
    # Clean up temp directory
    try:
        shutil.rmtree(temp_dir)
    except Exception:
        pass  # Ignore cleanup errors


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nOperation cancelled by user")
        sys.exit(130)

```

`settings.gradle`:

```gradle
include ':module'

import org.apache.tools.ant.DirectoryScanner

DirectoryScanner.removeDefaultExclude('**/.gitattributes')
include ':configapp'

```

`template/magisk_module/META-INF/com/google/android/update-binary`:

```
#!/sbin/sh

#################
# Initialization
#################

umask 022

# echo before loading util_functions
ui_print() { echo "$1"; }

require_new_magisk() {
  ui_print "*******************************"
  ui_print " Please install Magisk v20.4+! "
  ui_print "*******************************"
  exit 1
}

#########################
# Load util_functions.sh
#########################

OUTFD=$2
ZIPFILE=$3

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
. /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 20400 ] && require_new_magisk

install_module
exit 0

```

`template/magisk_module/META-INF/com/google/android/updater-script`:

```
#MAGISK

```

`template/magisk_module/module.prop`:

```prop
id=${id}
name=${name}
version=${version}
versionCode=${versionCode}
author=${author}
description=${description}

```