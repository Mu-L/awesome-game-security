Project Path: arc_topjohnwu_Magisk_au_z95o_

Source Tree:

```txt
arc_topjohnwu_Magisk_au_z95o_
├── LICENSE
├── README.MD
├── app
│   ├── apk
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   └── src
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           ├── java
│   │           │   └── com
│   │           │       └── topjohnwu
│   │           │           └── magisk
│   │           │               ├── arch
│   │           │               │   ├── AsyncLoadViewModel.kt
│   │           │               │   ├── BaseFragment.kt
│   │           │               │   ├── BaseViewModel.kt
│   │           │               │   ├── NavigationActivity.kt
│   │           │               │   ├── UIActivity.kt
│   │           │               │   ├── ViewEvent.kt
│   │           │               │   └── ViewModelHolder.kt
│   │           │               ├── databinding
│   │           │               │   ├── DataBindingAdapters.kt
│   │           │               │   ├── DiffObservableList.kt
│   │           │               │   ├── MergeObservableList.kt
│   │           │               │   ├── ObservableHost.kt
│   │           │               │   ├── RecyclerViewItems.kt
│   │           │               │   └── RvItemAdapter.kt
│   │           │               ├── dialog
│   │           │               │   ├── DarkThemeDialog.kt
│   │           │               │   ├── EnvFixDialog.kt
│   │           │               │   ├── LocalModuleInstallDialog.kt
│   │           │               │   ├── ManagerInstallDialog.kt
│   │           │               │   ├── MarkDownDialog.kt
│   │           │               │   ├── OnlineModuleInstallDialog.kt
│   │           │               │   ├── SecondSlotWarningDialog.kt
│   │           │               │   ├── SuperuserRevokeDialog.kt
│   │           │               │   └── UninstallDialog.kt
│   │           │               ├── events
│   │           │               │   └── ViewEvents.kt
│   │           │               ├── ui
│   │           │               │   ├── MainActivity.kt
│   │           │               │   ├── deny
│   │           │               │   │   ├── AppProcessInfo.kt
│   │           │               │   │   ├── DenyListFragment.kt
│   │           │               │   │   ├── DenyListRvItem.kt
│   │           │               │   │   └── DenyListViewModel.kt
│   │           │               │   ├── flash
│   │           │               │   │   ├── ConsoleItem.kt
│   │           │               │   │   ├── FlashFragment.kt
│   │           │               │   │   └── FlashViewModel.kt
│   │           │               │   ├── home
│   │           │               │   │   ├── DeveloperItem.kt
│   │           │               │   │   ├── HomeFragment.kt
│   │           │               │   │   ├── HomeViewModel.kt
│   │           │               │   │   └── RebootMenu.kt
│   │           │               │   ├── install
│   │           │               │   │   ├── InstallFragment.kt
│   │           │               │   │   └── InstallViewModel.kt
│   │           │               │   ├── log
│   │           │               │   │   ├── LogFragment.kt
│   │           │               │   │   ├── LogRvItem.kt
│   │           │               │   │   ├── LogViewModel.kt
│   │           │               │   │   └── SuLogRvItem.kt
│   │           │               │   ├── module
│   │           │               │   │   ├── ActionFragment.kt
│   │           │               │   │   ├── ActionViewModel.kt
│   │           │               │   │   ├── ModuleFragment.kt
│   │           │               │   │   ├── ModuleRvItem.kt
│   │           │               │   │   └── ModuleViewModel.kt
│   │           │               │   ├── settings
│   │           │               │   │   ├── BaseSettingsItem.kt
│   │           │               │   │   ├── SettingsFragment.kt
│   │           │               │   │   ├── SettingsItems.kt
│   │           │               │   │   └── SettingsViewModel.kt
│   │           │               │   ├── superuser
│   │           │               │   │   ├── PolicyRvItem.kt
│   │           │               │   │   ├── SuperuserFragment.kt
│   │           │               │   │   └── SuperuserViewModel.kt
│   │           │               │   ├── surequest
│   │           │               │   │   ├── SuRequestActivity.kt
│   │           │               │   │   └── SuRequestViewModel.kt
│   │           │               │   └── theme
│   │           │               │       ├── Theme.kt
│   │           │               │       ├── ThemeFragment.kt
│   │           │               │       └── ThemeViewModel.kt
│   │           │               ├── utils
│   │           │               │   ├── AccessibilityUtils.kt
│   │           │               │   ├── MotionRevealHelper.kt
│   │           │               │   └── TextHolder.kt
│   │           │               ├── view
│   │           │               │   ├── MagiskDialog.kt
│   │           │               │   ├── TappableHeadlineItem.kt
│   │           │               │   └── TextItem.kt
│   │           │               └── widget
│   │           │                   └── ConcealableBottomNavigationView.java
│   │           └── res
│   │               ├── anim
│   │               │   ├── fragment_enter.xml
│   │               │   ├── fragment_enter_pop.xml
│   │               │   ├── fragment_exit.xml
│   │               │   └── fragment_exit_pop.xml
│   │               ├── color
│   │               │   ├── color_card_background_color_selector.xml
│   │               │   ├── color_error_transient.xml
│   │               │   ├── color_menu_tint.xml
│   │               │   ├── color_on_primary_transient.xml
│   │               │   ├── color_primary_error_transient.xml
│   │               │   ├── color_primary_transient.xml
│   │               │   ├── color_state_primary_transient.xml
│   │               │   └── color_text_transient.xml
│   │               ├── drawable
│   │               │   ├── avd_bug_from_filled.xml
│   │               │   ├── avd_bug_to_filled.xml
│   │               │   ├── avd_circle_check_from_filled.xml
│   │               │   ├── avd_circle_check_to_filled.xml
│   │               │   ├── avd_home_from_filled.xml
│   │               │   ├── avd_home_to_filled.xml
│   │               │   ├── avd_module_from_filled.xml
│   │               │   ├── avd_module_to_filled.xml
│   │               │   ├── avd_settings_from_filled.xml
│   │               │   ├── avd_settings_to_filled.xml
│   │               │   ├── avd_superuser_from_filled.xml
│   │               │   ├── avd_superuser_to_filled.xml
│   │               │   ├── bg_line_bottom_rounded.xml
│   │               │   ├── bg_line_top_rounded.xml
│   │               │   ├── bg_selection_circle_green.xml
│   │               │   ├── ic_action_md2.xml
│   │               │   ├── ic_back_md2.xml
│   │               │   ├── ic_bug_filled_md2.xml
│   │               │   ├── ic_bug_md2.xml
│   │               │   ├── ic_bug_outlined_md2.xml
│   │               │   ├── ic_check_circle_checked_md2.xml
│   │               │   ├── ic_check_circle_md2.xml
│   │               │   ├── ic_check_circle_unchecked_md2.xml
│   │               │   ├── ic_check_md2.xml
│   │               │   ├── ic_close_md2.xml
│   │               │   ├── ic_day.xml
│   │               │   ├── ic_day_night.xml
│   │               │   ├── ic_delete_md2.xml
│   │               │   ├── ic_download_md2.xml
│   │               │   ├── ic_folder_list.xml
│   │               │   ├── ic_forth_md2.xml
│   │               │   ├── ic_home_filled_md2.xml
│   │               │   ├── ic_home_md2.xml
│   │               │   ├── ic_home_outlined_md2.xml
│   │               │   ├── ic_install.xml
│   │               │   ├── ic_manager.xml
│   │               │   ├── ic_module_filled_md2.xml
│   │               │   ├── ic_module_md2.xml
│   │               │   ├── ic_module_outlined_md2.xml
│   │               │   ├── ic_module_storage_md2.xml
│   │               │   ├── ic_night.xml
│   │               │   ├── ic_notifications_md2.xml
│   │               │   ├── ic_paint.xml
│   │               │   ├── ic_restart.xml
│   │               │   ├── ic_save_md2.xml
│   │               │   ├── ic_search_md2.xml
│   │               │   ├── ic_settings_filled_md2.xml
│   │               │   ├── ic_settings_md2.xml
│   │               │   ├── ic_settings_outlined_md2.xml
│   │               │   ├── ic_superuser_filled_md2.xml
│   │               │   ├── ic_superuser_md2.xml
│   │               │   ├── ic_superuser_outlined_md2.xml
│   │               │   └── ic_update_md2.xml
│   │               ├── layout
│   │               │   ├── activity_main_md2.xml
│   │               │   ├── activity_request.xml
│   │               │   ├── dialog_magisk_base.xml
│   │               │   ├── dialog_settings_app_name.xml
│   │               │   ├── dialog_settings_download_path.xml
│   │               │   ├── dialog_settings_update_channel.xml
│   │               │   ├── fragment_action_md2.xml
│   │               │   ├── fragment_deny_md2.xml
│   │               │   ├── fragment_flash_md2.xml
│   │               │   ├── fragment_home_md2.xml
│   │               │   ├── fragment_install_md2.xml
│   │               │   ├── fragment_log_md2.xml
│   │               │   ├── fragment_module_md2.xml
│   │               │   ├── fragment_settings_md2.xml
│   │               │   ├── fragment_superuser_md2.xml
│   │               │   ├── fragment_theme_md2.xml
│   │               │   ├── include_home_magisk.xml
│   │               │   ├── include_home_manager.xml
│   │               │   ├── include_log_magisk.xml
│   │               │   ├── include_log_superuser.xml
│   │               │   ├── item_console_md2.xml
│   │               │   ├── item_developer.xml
│   │               │   ├── item_hide_md2.xml
│   │               │   ├── item_hide_process_md2.xml
│   │               │   ├── item_icon_link.xml
│   │               │   ├── item_list_single_line.xml
│   │               │   ├── item_log_access_md2.xml
│   │               │   ├── item_log_textview.xml
│   │               │   ├── item_log_track_md2.xml
│   │               │   ├── item_module_download.xml
│   │               │   ├── item_module_md2.xml
│   │               │   ├── item_policy_md2.xml
│   │               │   ├── item_settings.xml
│   │               │   ├── item_settings_section.xml
│   │               │   ├── item_spinner.xml
│   │               │   ├── item_tappable_headline.xml
│   │               │   ├── item_text.xml
│   │               │   ├── item_theme.xml
│   │               │   ├── item_theme_container.xml
│   │               │   └── markdown_window_md2.xml
│   │               ├── menu
│   │               │   ├── menu_bottom_nav.xml
│   │               │   ├── menu_deny_md2.xml
│   │               │   ├── menu_flash.xml
│   │               │   ├── menu_home_md2.xml
│   │               │   ├── menu_log_md2.xml
│   │               │   └── menu_reboot.xml
│   │               ├── navigation
│   │               │   └── main.xml
│   │               ├── values
│   │               │   ├── attrs.xml
│   │               │   ├── dimens.xml
│   │               │   ├── ids.xml
│   │               │   ├── styles_md2.xml
│   │               │   ├── styles_md2_appearance.xml
│   │               │   ├── styles_md2_impl.xml
│   │               │   ├── styles_view_md2.xml
│   │               │   ├── theme_overlay.xml
│   │               │   ├── themes.xml
│   │               │   ├── themes_md2.xml
│   │               │   └── themes_override.xml
│   │               ├── values-night
│   │               │   ├── styles_md2.xml
│   │               │   └── themes_md2.xml
│   │               └── values-v27
│   │                   └── themes.xml
│   ├── build.gradle.kts
│   ├── buildSrc
│   │   ├── build.gradle.kts
│   │   ├── settings.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── java
│   │               ├── AddCommentTask.kt
│   │               ├── DesugarClassVisitorFactory.kt
│   │               ├── Plugin.kt
│   │               ├── Setup.kt
│   │               └── Stub.kt
│   ├── core
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   └── src
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           ├── aidl
│   │           │   └── com
│   │           │       └── topjohnwu
│   │           │           └── magisk
│   │           │               └── core
│   │           │                   └── utils
│   │           │                       └── IRootUtils.aidl
│   │           ├── java
│   │           │   └── com
│   │           │       └── topjohnwu
│   │           │           └── magisk
│   │           │               ├── core
│   │           │               │   ├── App.kt
│   │           │               │   ├── AppContext.kt
│   │           │               │   ├── Config.kt
│   │           │               │   ├── Const.kt
│   │           │               │   ├── Hacks.kt
│   │           │               │   ├── Info.kt
│   │           │               │   ├── JobService.kt
│   │           │               │   ├── Provider.kt
│   │           │               │   ├── Receiver.kt
│   │           │               │   ├── Service.kt
│   │           │               │   ├── base
│   │           │               │   │   ├── BaseActivity.kt
│   │           │               │   │   ├── BaseJobService.kt
│   │           │               │   │   ├── BaseProvider.kt
│   │           │               │   │   ├── BaseReceiver.kt
│   │           │               │   │   ├── BaseService.kt
│   │           │               │   │   └── SplashScreen.kt
│   │           │               │   ├── data
│   │           │               │   │   ├── RetrofitInterfaces.kt
│   │           │               │   │   ├── SuLogDao.kt
│   │           │               │   │   └── magiskdb
│   │           │               │   │       ├── MagiskDB.kt
│   │           │               │   │       ├── PolicyDao.kt
│   │           │               │   │       ├── SettingsDao.kt
│   │           │               │   │       └── StringDao.kt
│   │           │               │   ├── di
│   │           │               │   │   ├── Networking.kt
│   │           │               │   │   └── ServiceLocator.kt
│   │           │               │   ├── download
│   │           │               │   │   ├── DownloadEngine.kt
│   │           │               │   │   ├── DownloadProcessor.kt
│   │           │               │   │   ├── Interfaces.kt
│   │           │               │   │   └── Subject.kt
│   │           │               │   ├── ktx
│   │           │               │   │   ├── XAndroid.kt
│   │           │               │   │   ├── XJVM.kt
│   │           │               │   │   └── XSU.kt
│   │           │               │   ├── model
│   │           │               │   │   ├── UpdateInfo.kt
│   │           │               │   │   ├── module
│   │           │               │   │   │   ├── LocalModule.kt
│   │           │               │   │   │   ├── Module.kt
│   │           │               │   │   │   └── OnlineModule.kt
│   │           │               │   │   └── su
│   │           │               │   │       ├── SuLog.kt
│   │           │               │   │       └── SuPolicy.kt
│   │           │               │   ├── repository
│   │           │               │   │   ├── DBConfig.kt
│   │           │               │   │   ├── LogRepository.kt
│   │           │               │   │   ├── NetworkService.kt
│   │           │               │   │   └── PreferenceConfig.kt
│   │           │               │   ├── signing
│   │           │               │   │   ├── ApkSignerV2.java
│   │           │               │   │   ├── ByteArrayStream.java
│   │           │               │   │   ├── JarMap.java
│   │           │               │   │   ├── SignApk.java
│   │           │               │   │   └── ZipUtils.java
│   │           │               │   ├── su
│   │           │               │   │   ├── SuCallbackHandler.kt
│   │           │               │   │   └── SuRequestHandler.kt
│   │           │               │   ├── tasks
│   │           │               │   │   ├── AppMigration.kt
│   │           │               │   │   ├── FlashZip.kt
│   │           │               │   │   └── MagiskInstaller.kt
│   │           │               │   ├── utils
│   │           │               │   │   ├── AXML.kt
│   │           │               │   │   ├── Desugar.java
│   │           │               │   │   ├── DummyList.kt
│   │           │               │   │   ├── Keygen.kt
│   │           │               │   │   ├── LocaleSetting.kt
│   │           │               │   │   ├── MediaStoreUtils.kt
│   │           │               │   │   ├── NetworkObserver.kt
│   │           │               │   │   ├── ProgressInputStream.kt
│   │           │               │   │   ├── RequestAuthentication.kt
│   │           │               │   │   ├── RequestInstall.kt
│   │           │               │   │   ├── RootUtils.kt
│   │           │               │   │   └── ShellInit.kt
│   │           │               │   └── view
│   │           │               │       ├── Notifications.kt
│   │           │               │       └── Shortcuts.kt
│   │           │               └── test
│   │           │                   ├── AdditionalTest.kt
│   │           │                   ├── BaseTest.kt
│   │           │                   ├── Environment.kt
│   │           │                   └── MagiskAppTest.kt
│   │           └── res
│   │               ├── drawable
│   │               │   ├── ic_extension.xml
│   │               │   ├── ic_favorite.xml
│   │               │   ├── ic_fingerprint.xml
│   │               │   ├── ic_github.xml
│   │               │   ├── ic_logo.xml
│   │               │   ├── ic_magisk.xml
│   │               │   ├── ic_magisk_outline.xml
│   │               │   ├── ic_magisk_padded.xml
│   │               │   ├── ic_more.xml
│   │               │   ├── ic_patreon.xml
│   │               │   ├── ic_paypal.xml
│   │               │   ├── ic_superuser.xml
│   │               │   ├── ic_twitter.xml
│   │               │   ├── sc_extension.xml
│   │               │   └── sc_superuser.xml
│   │               ├── drawable-v26
│   │               │   ├── ic_launcher.xml
│   │               │   ├── sc_extension.xml
│   │               │   └── sc_superuser.xml
│   │               ├── values
│   │               │   ├── arrays.xml
│   │               │   ├── colors.xml
│   │               │   ├── resources.xml
│   │               │   ├── strings.xml
│   │               │   └── themes.xml
│   │               ├── values-ar
│   │               │   └── strings.xml
│   │               ├── values-ast
│   │               │   └── strings.xml
│   │               ├── values-az
│   │               │   └── strings.xml
│   │               ├── values-b+sr+Latn
│   │               │   └── strings.xml
│   │               ├── values-be
│   │               │   └── strings.xml
│   │               ├── values-bg
│   │               │   └── strings.xml
│   │               ├── values-bn
│   │               │   └── strings.xml
│   │               ├── values-ca
│   │               │   └── strings.xml
│   │               ├── values-cs
│   │               │   └── strings.xml
│   │               ├── values-de
│   │               │   └── strings.xml
│   │               ├── values-el
│   │               │   └── strings.xml
│   │               ├── values-es
│   │               │   └── strings.xml
│   │               ├── values-et
│   │               │   └── strings.xml
│   │               ├── values-fa
│   │               │   └── strings.xml
│   │               ├── values-fr
│   │               │   └── strings.xml
│   │               ├── values-hi
│   │               │   └── strings.xml
│   │               ├── values-hn
│   │               │   └── strings.xml
│   │               ├── values-hr
│   │               │   └── strings.xml
│   │               ├── values-hu
│   │               │   └── strings.xml
│   │               ├── values-in
│   │               │   └── strings.xml
│   │               ├── values-it
│   │               │   └── strings.xml
│   │               ├── values-iw
│   │               │   └── strings.xml
│   │               ├── values-ja
│   │               │   └── strings.xml
│   │               ├── values-ka
│   │               │   └── strings.xml
│   │               ├── values-kk
│   │               │   └── strings.xml
│   │               ├── values-ko
│   │               │   └── strings.xml
│   │               ├── values-ku
│   │               │   └── strings.xml
│   │               ├── values-lt
│   │               │   └── strings.xml
│   │               ├── values-mk
│   │               │   └── strings.xml
│   │               ├── values-ml
│   │               │   └── strings.xml
│   │               ├── values-nb
│   │               │   └── strings.xml
│   │               ├── values-night
│   │               │   └── colors.xml
│   │               ├── values-nl
│   │               │   └── strings.xml
│   │               ├── values-pa
│   │               │   └── strings.xml
│   │               ├── values-pl
│   │               │   └── strings.xml
│   │               ├── values-pt-rBR
│   │               │   └── strings.xml
│   │               ├── values-pt-rPT
│   │               │   └── strings.xml
│   │               ├── values-ro
│   │               │   └── strings.xml
│   │               ├── values-ru
│   │               │   └── strings.xml
│   │               ├── values-sk
│   │               │   └── strings.xml
│   │               ├── values-sq
│   │               │   └── strings.xml
│   │               ├── values-sr
│   │               │   └── strings.xml
│   │               ├── values-sv
│   │               │   └── strings.xml
│   │               ├── values-sw
│   │               │   └── strings.xml
│   │               ├── values-ta
│   │               │   └── strings.xml
│   │               ├── values-th
│   │               │   └── strings.xml
│   │               ├── values-tr
│   │               │   └── strings.xml
│   │               ├── values-uk
│   │               │   └── strings.xml
│   │               ├── values-ur
│   │               │   └── strings.xml
│   │               ├── values-v31
│   │               │   └── themes.xml
│   │               ├── values-v34
│   │               │   └── resources.xml
│   │               ├── values-vi
│   │               │   └── strings.xml
│   │               ├── values-zh-rCN
│   │               │   └── strings.xml
│   │               ├── values-zh-rTW
│   │               │   └── strings.xml
│   │               └── xml
│   │                   └── locale_config.xml
│   ├── gradle
│   │   ├── libs.versions.toml
│   │   └── wrapper
│   │       ├── gradle-wrapper.jar
│   │       └── gradle-wrapper.properties
│   ├── gradle.properties
│   ├── gradlew
│   ├── gradlew.bat
│   ├── settings.gradle.kts
│   ├── shared
│   │   ├── build.gradle.kts
│   │   └── src
│   │       ├── debug
│   │       │   └── AndroidManifest.xml
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           └── java
│   │               └── com
│   │                   └── topjohnwu
│   │                       └── magisk
│   │                           ├── ProviderInstaller.java
│   │                           ├── StubApk.java
│   │                           └── utils
│   │                               ├── APKInstall.java
│   │                               ├── CompoundEnumeration.java
│   │                               └── DynamicClassLoader.java
│   ├── stub
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   └── src
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           ├── java
│   │           │   └── com
│   │           │       └── topjohnwu
│   │           │           └── magisk
│   │           │               ├── ClassLoaders.java
│   │           │               ├── DelegateComponentFactory.java
│   │           │               ├── DownloadActivity.java
│   │           │               ├── DynLoad.java
│   │           │               ├── StubApplication.java
│   │           │               ├── StubRootService.java
│   │           │               ├── dummy
│   │           │               │   ├── DummyProvider.java
│   │           │               │   ├── DummyReceiver.java
│   │           │               │   └── DummyService.java
│   │           │               └── net
│   │           │                   ├── BadRequest.java
│   │           │                   ├── ErrorHandler.java
│   │           │                   ├── Networking.java
│   │           │                   ├── Request.java
│   │           │                   └── ResponseListener.java
│   │           └── res
│   │               ├── values
│   │               │   └── strings.xml
│   │               ├── values-ar
│   │               │   └── strings.xml
│   │               ├── values-ast
│   │               │   └── strings.xml
│   │               ├── values-az
│   │               │   └── strings.xml
│   │               ├── values-b+sr+Latn
│   │               │   └── strings.xml
│   │               ├── values-be
│   │               │   └── strings.xml
│   │               ├── values-bg
│   │               │   └── strings.xml
│   │               ├── values-ca
│   │               │   └── strings.xml
│   │               ├── values-cs
│   │               │   └── strings.xml
│   │               ├── values-de
│   │               │   └── strings.xml
│   │               ├── values-el
│   │               │   └── strings.xml
│   │               ├── values-es
│   │               │   └── strings.xml
│   │               ├── values-et
│   │               │   └── strings.xml
│   │               ├── values-fa
│   │               │   └── strings.xml
│   │               ├── values-fr
│   │               │   └── strings.xml
│   │               ├── values-hi
│   │               │   └── strings.xml
│   │               ├── values-hn
│   │               │   └── strings.xml
│   │               ├── values-hr
│   │               │   └── strings.xml
│   │               ├── values-hu
│   │               │   └── strings.xml
│   │               ├── values-in
│   │               │   └── strings.xml
│   │               ├── values-it
│   │               │   └── strings.xml
│   │               ├── values-iw
│   │               │   └── strings.xml
│   │               ├── values-ja
│   │               │   └── strings.xml
│   │               ├── values-ka
│   │               │   └── strings.xml
│   │               ├── values-kk
│   │               │   └── strings.xml
│   │               ├── values-ko
│   │               │   └── strings.xml
│   │               ├── values-ku
│   │               │   └── strings.xml
│   │               ├── values-lt
│   │               │   └── strings.xml
│   │               ├── values-mk
│   │               │   └── strings.xml
│   │               ├── values-ml
│   │               │   └── strings.xml
│   │               ├── values-nb
│   │               │   └── strings.xml
│   │               ├── values-nl
│   │               │   └── strings.xml
│   │               ├── values-pa
│   │               │   └── strings.xml
│   │               ├── values-pl
│   │               │   └── strings.xml
│   │               ├── values-pt-rBR
│   │               │   └── strings.xml
│   │               ├── values-pt-rPT
│   │               │   └── strings.xml
│   │               ├── values-ro
│   │               │   └── strings.xml
│   │               ├── values-ru
│   │               │   └── strings.xml
│   │               ├── values-sk
│   │               │   └── strings.xml
│   │               ├── values-sq
│   │               │   └── strings.xml
│   │               ├── values-sr
│   │               │   └── strings.xml
│   │               ├── values-sv
│   │               │   └── strings.xml
│   │               ├── values-sw
│   │               │   └── strings.xml
│   │               ├── values-ta
│   │               │   └── strings.xml
│   │               ├── values-th
│   │               │   └── strings.xml
│   │               ├── values-tr
│   │               │   └── strings.xml
│   │               ├── values-uk
│   │               │   └── strings.xml
│   │               ├── values-vi
│   │               │   └── strings.xml
│   │               ├── values-zh-rCN
│   │               │   └── strings.xml
│   │               └── values-zh-rTW
│   │                   └── strings.xml
│   └── test
│       ├── build.gradle.kts
│       ├── proguard-rules.pro
│       └── src
│           └── main
│               ├── AndroidManifest.xml
│               └── java
│                   └── com
│                       └── topjohnwu
│                           └── magisk
│                               └── test
│                                   ├── AppMigrationTest.kt
│                                   └── Runners.kt
├── build.py
├── config.prop.sample
├── docs
│   ├── README.md
│   ├── app_changes.md
│   ├── boot.md
│   ├── build.md
│   ├── changes.md
│   ├── details.md
│   ├── faq.md
│   ├── guides.md
│   ├── images
│   │   ├── device_info.png
│   │   ├── disable_auto_ota.png
│   │   ├── install_inactive_slot.png
│   │   ├── logo.png
│   │   ├── manager_reboot.png
│   │   ├── ota_done.png
│   │   └── restore_img.png
│   ├── install.md
│   ├── ota.md
│   └── tools.md
├── native
│   └── src
│       ├── Android-rs.mk
│       ├── Android.mk
│       ├── Application.mk
│       ├── Cargo.lock
│       ├── Cargo.toml
│       ├── base
│       │   ├── Android.mk
│       │   ├── Cargo.toml
│       │   ├── argh.rs
│       │   ├── base.cpp
│       │   ├── build.rs
│       │   ├── cstr.rs
│       │   ├── cxx_extern.rs
│       │   ├── derive
│       │   │   ├── Cargo.toml
│       │   │   ├── argh
│       │   │   │   ├── errors.rs
│       │   │   │   ├── mod.rs
│       │   │   │   └── parse_attrs.rs
│       │   │   ├── decodable.rs
│       │   │   └── lib.rs
│       │   ├── dir.rs
│       │   ├── files.rs
│       │   ├── include
│       │   │   ├── base.hpp
│       │   │   └── rust
│       │   │       └── cxx.h
│       │   ├── lib.rs
│       │   ├── logging.rs
│       │   ├── misc.rs
│       │   ├── mount.rs
│       │   ├── result.rs
│       │   └── xwrap.rs
│       ├── boot
│       │   ├── Cargo.toml
│       │   ├── bootimg.cpp
│       │   ├── bootimg.hpp
│       │   ├── build.rs
│       │   ├── cli.rs
│       │   ├── compress.rs
│       │   ├── cpio.rs
│       │   ├── dtb.rs
│       │   ├── format.rs
│       │   ├── lib.rs
│       │   ├── magiskboot.hpp
│       │   ├── patch.rs
│       │   ├── payload.rs
│       │   ├── proto
│       │   │   └── update_metadata.proto
│       │   └── sign.rs
│       ├── core
│       │   ├── Cargo.toml
│       │   ├── applet_stub.cpp
│       │   ├── applets.cpp
│       │   ├── bootstages.rs
│       │   ├── build.rs
│       │   ├── daemon.rs
│       │   ├── db.rs
│       │   ├── deny
│       │   │   ├── cli.cpp
│       │   │   ├── deny.hpp
│       │   │   ├── logcat.cpp
│       │   │   └── utils.cpp
│       │   ├── include
│       │   │   ├── core.hpp
│       │   │   └── sqlite.hpp
│       │   ├── lib.rs
│       │   ├── logging.rs
│       │   ├── magisk.rs
│       │   ├── module.rs
│       │   ├── mount.rs
│       │   ├── package.rs
│       │   ├── resetprop
│       │   │   ├── cli.rs
│       │   │   ├── mod.rs
│       │   │   ├── persist.rs
│       │   │   ├── proto
│       │   │   │   └── persistent_properties.proto
│       │   │   └── sys.cpp
│       │   ├── scripting.cpp
│       │   ├── selinux.rs
│       │   ├── socket.rs
│       │   ├── sqlite.cpp
│       │   ├── su
│       │   │   ├── connect.rs
│       │   │   ├── daemon.rs
│       │   │   ├── db.rs
│       │   │   ├── mod.rs
│       │   │   ├── pts.rs
│       │   │   └── su.cpp
│       │   ├── thread.rs
│       │   ├── utils.cpp
│       │   └── zygisk
│       │       ├── api.hpp
│       │       ├── daemon.rs
│       │       ├── entry.cpp
│       │       ├── gen_jni_hooks.py
│       │       ├── hook.cpp
│       │       ├── jni_hooks.hpp
│       │       ├── mod.rs
│       │       ├── module.cpp
│       │       ├── module.hpp
│       │       └── zygisk.hpp
│       ├── exported_sym.txt
│       ├── external
│       │   ├── Android.mk
│       │   ├── crt0
│       │   ├── cxx-rs
│       │   ├── libcxx
│       │   ├── lsplt
│       │   ├── lz4
│       │   ├── lz4-sys
│       │   │   ├── Cargo.toml
│       │   │   └── src
│       │   │       ├── lib.rs
│       │   │       └── wasm_shim.rs
│       │   ├── selinux
│       │   ├── system_properties
│       │   ├── xz-embedded
│       │   │   ├── xz.h
│       │   │   ├── xz_config.h
│       │   │   ├── xz_crc32.c
│       │   │   ├── xz_dec_lzma2.c
│       │   │   ├── xz_dec_stream.c
│       │   │   ├── xz_lzma2.h
│       │   │   ├── xz_private.h
│       │   │   └── xz_stream.h
│       │   └── xz_config
│       │       └── config.h
│       ├── include
│       │   ├── codegen.rs
│       │   ├── consts.hpp
│       │   └── consts.rs
│       ├── init
│       │   ├── Cargo.toml
│       │   ├── build.rs
│       │   ├── getinfo.cpp
│       │   ├── getinfo.rs
│       │   ├── init.hpp
│       │   ├── init.rs
│       │   ├── lib.rs
│       │   ├── logging.rs
│       │   ├── mount.cpp
│       │   ├── mount.rs
│       │   ├── preload.c
│       │   ├── rootdir.cpp
│       │   ├── rootdir.rs
│       │   ├── selinux.rs
│       │   └── twostage.rs
│       ├── rustfmt.toml
│       └── sepolicy
│           ├── Cargo.toml
│           ├── api.cpp
│           ├── build.rs
│           ├── cli.rs
│           ├── include
│           │   └── sepolicy.hpp
│           ├── lib.rs
│           ├── policy.hpp
│           ├── policydb.cpp
│           ├── rules.rs
│           ├── sepolicy.cpp
│           └── statement.rs
├── scripts
│   ├── addon.d.sh
│   ├── app_functions.sh
│   ├── avd.sh
│   ├── boot_patch.sh
│   ├── cuttlefish.sh
│   ├── flash_script.sh
│   ├── host_patch.sh
│   ├── live_setup.sh
│   ├── module_installer.sh
│   ├── release.sh
│   ├── test_common.sh
│   ├── uninstaller.sh
│   ├── update_binary.sh
│   └── util_functions.sh
└── tools
    ├── bootctl
    ├── bootctl.patch
    ├── elf-cleaner
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    ├── futility
    ├── keys
    │   ├── kernel.keyblock
    │   ├── kernel_data_key.vbprivk
    │   ├── verity.pk8
    │   └── verity.x509.pem
    └── rustup-wrapper
        ├── Cargo.lock
        ├── Cargo.toml
        └── src
            └── main.rs

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    {one line to give the program's name and a brief idea of what it does.}
    Copyright (C) {year}  {name of author}

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    {project}  Copyright (C) {year}  {fullname}
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

```

`README.MD`:

```MD
![](docs/images/logo.png)

[![Downloads](https://img.shields.io/badge/dynamic/json?color=green&label=Downloads&query=totalString&url=https%3A%2F%2Fraw.githubusercontent.com%2Ftopjohnwu%2Fmagisk-files%2Fcount%2Fcount.json&cacheSeconds=1800)](https://raw.githubusercontent.com/topjohnwu/magisk-files/count/count.json)

#### This is not an officially supported Google product

## Introduction

Magisk is a suite of open source software for customizing Android, supporting devices higher than Android 6.0.<br>
Some highlight features:

- **MagiskSU**: Provide root access for applications
- **Magisk Modules**: Modify read-only partitions by installing modules
- **MagiskBoot**: The most complete tool for unpacking and repacking Android boot images
- **Zygisk**: Run code in every Android applications' processes

## Downloads

[Github](https://github.com/topjohnwu/Magisk/releases) is the only source where you can get official Magisk information and downloads.

## Useful Links

- [Installation Instruction](https://topjohnwu.github.io/Magisk/install.html)
- [Building and Development](https://topjohnwu.github.io/Magisk/build.html)
- [Magisk Documentation](https://topjohnwu.github.io/Magisk/)
- [Zygisk module sample](https://github.com/topjohnwu/zygisk-module-sample)

## Bug Reports

**Only bug reports from Debug builds will be accepted.**

For installation issues, upload both boot image and install logs.<br>
For Magisk issues, upload boot logcat or dmesg.<br>
For Magisk app crashes, record and upload the logcat when the crash occurs.

## Translation Contributions

Default string resources for the Magisk app and its stub APK are located here:

- `app/core/src/main/res/values/strings.xml`
- `app/stub/src/main/res/values/strings.xml`

Translate each and place them in the respective locations (`[module]/src/main/res/values-[lang]/strings.xml`).

## License

    Magisk, including all git submodules are free software:
    you can redistribute it and/or modify it under the terms of the
    GNU General Public License as published by the Free Software Foundation,
    either version 3 of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

```

`app/apk/build.gradle.kts`:

```kts
plugins {
    id("com.android.application")
    kotlin("plugin.parcelize")
    id("com.android.legacy-kapt")
    id("androidx.navigation.safeargs.kotlin")
}

setupMainApk()

kapt {
    correctErrorTypes = true
    useBuildCache = true
    mapDiagnosticLocations = true
    javacOptions {
        option("-Xmaxerrs", "1000")
    }
}

android {
    buildFeatures {
        dataBinding = true
    }

    compileOptions {
        isCoreLibraryDesugaringEnabled = true
    }

    defaultConfig {
        proguardFile("proguard-rules.pro")
    }

    buildTypes {
        release {
            isMinifyEnabled = true
            isShrinkResources = true
        }
    }
}

dependencies {
    implementation(project(":core"))
    coreLibraryDesugaring(libs.jdk.libs)

    implementation(libs.indeterminate.checkbox)
    implementation(libs.rikka.layoutinflater)
    implementation(libs.rikka.insets)
    implementation(libs.rikka.recyclerview)

    implementation(libs.navigation.fragment.ktx)
    implementation(libs.navigation.ui.ktx)

    implementation(libs.constraintlayout)
    implementation(libs.swiperefreshlayout)
    implementation(libs.recyclerview)
    implementation(libs.transition)
    implementation(libs.fragment.ktx)
    implementation(libs.appcompat)
    implementation(libs.material)

    // Make sure kapt runs with a proper kotlin-stdlib
    kapt(kotlin("stdlib"))
}

```

`app/apk/proguard-rules.pro`:

```pro
# Excessive obfuscation
-flattenpackagehierarchy
-allowaccessmodification

```

`app/apk/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application android:localeConfig="@xml/locale_config">
        <activity
            android:name=".ui.MainActivity"
            android:exported="true"
            android:theme="@style/SplashTheme">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.APPLICATION_PREFERENCES" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>

        <activity
            android:name=".ui.surequest.SuRequestActivity"
            android:directBootAware="true"
            android:exported="false"
            android:taskAffinity=""
            tools:ignore="AppLinkUrlError">
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
    </application>

</manifest>

```

`app/apk/src/main/java/com/topjohnwu/magisk/arch/AsyncLoadViewModel.kt`:

```kt
package com.topjohnwu.magisk.arch

import androidx.annotation.MainThread
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch

abstract class AsyncLoadViewModel : BaseViewModel() {

    private var loadingJob: Job? = null

    @MainThread
    fun startLoading() {
        if (loadingJob?.isActive == true) {
            // Prevent multiple jobs from running at the same time
            return
        }
        loadingJob = viewModelScope.launch { doLoadWork() }
    }

    protected abstract suspend fun doLoadWork()
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/arch/BaseFragment.kt`:

```kt
package com.topjohnwu.magisk.arch

import android.os.Bundle
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.MenuProvider
import androidx.databinding.DataBindingUtil
import androidx.databinding.OnRebindCallback
import androidx.databinding.ViewDataBinding
import androidx.fragment.app.Fragment
import androidx.lifecycle.Lifecycle
import androidx.navigation.NavDirections
import com.topjohnwu.magisk.BR

abstract class BaseFragment<Binding : ViewDataBinding> : Fragment(), ViewModelHolder {

    val activity get() = getActivity() as? NavigationActivity<*>
    protected lateinit var binding: Binding
    protected abstract val layoutRes: Int

    private val navigation get() = activity?.navigation
    open val snackbarView: View? get() = null
    open val snackbarAnchorView: View? get() = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        startObserveLiveData()
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        binding = DataBindingUtil.inflate<Binding>(inflater, layoutRes, container, false).also {
            it.setVariable(BR.viewModel, viewModel)
            it.lifecycleOwner = viewLifecycleOwner
        }
        if (this is MenuProvider) {
            activity?.addMenuProvider(this, viewLifecycleOwner, Lifecycle.State.STARTED)
        }
        savedInstanceState?.let { viewModel.onRestoreState(it) }
        return binding.root
    }

    override fun onSaveInstanceState(outState: Bundle) {
        viewModel.onSaveState(outState)
    }

    override fun onStart() {
        super.onStart()
        activity?.supportActionBar?.subtitle = null
    }

    override fun onEventDispatched(event: ViewEvent) = when(event) {
        is ContextExecutor -> event(requireContext())
        is ActivityExecutor -> activity?.let { event(it) } ?: Unit
        is FragmentExecutor -> event(this)
        else -> Unit
    }

    open fun onKeyEvent(event: KeyEvent): Boolean {
        return false
    }

    open fun onBackPressed(): Boolean = false


    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.addOnRebindCallback(object : OnRebindCallback<Binding>() {
            override fun onPreBind(binding: Binding): Boolean {
                this@BaseFragment.onPreBind(binding)
                return true
            }
        })
    }

    override fun onResume() {
        super.onResume()
        viewModel.let {
            if (it is AsyncLoadViewModel)
                it.startLoading()
        }
    }

    protected open fun onPreBind(binding: Binding) {
        (binding.root as? ViewGroup)?.startAnimations()
    }

    fun NavDirections.navigate() {
        navigation?.currentDestination?.getAction(actionId)?.let { navigation!!.navigate(this) }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/arch/BaseViewModel.kt`:

```kt
package com.topjohnwu.magisk.arch

import android.Manifest.permission.POST_NOTIFICATIONS
import android.Manifest.permission.REQUEST_INSTALL_PACKAGES
import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
import android.annotation.SuppressLint
import android.os.Bundle
import androidx.databinding.PropertyChangeRegistry
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.navigation.NavDirections
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.databinding.ObservableHost
import com.topjohnwu.magisk.events.BackPressEvent
import com.topjohnwu.magisk.events.DialogBuilder
import com.topjohnwu.magisk.events.DialogEvent
import com.topjohnwu.magisk.events.NavigationEvent
import com.topjohnwu.magisk.events.PermissionEvent
import com.topjohnwu.magisk.events.SnackbarEvent

abstract class BaseViewModel : ViewModel(), ObservableHost {

    override var callbacks: PropertyChangeRegistry? = null

    private val _viewEvents = MutableLiveData<ViewEvent>()
    val viewEvents: LiveData<ViewEvent> get() = _viewEvents

    open fun onSaveState(state: Bundle) {}
    open fun onRestoreState(state: Bundle) {}
    open fun onNetworkChanged(network: Boolean) {}

    fun withPermission(permission: String, callback: (Boolean) -> Unit) {
        PermissionEvent(permission, callback).publish()
    }

    inline fun withExternalRW(crossinline callback: () -> Unit) {
        withPermission(WRITE_EXTERNAL_STORAGE) {
            if (!it) {
                SnackbarEvent(R.string.external_rw_permission_denied).publish()
            } else {
                callback()
            }
        }
    }

    @SuppressLint("InlinedApi")
    inline fun withInstallPermission(crossinline callback: () -> Unit) {
        withPermission(REQUEST_INSTALL_PACKAGES) {
            if (!it) {
                SnackbarEvent(R.string.install_unknown_denied).publish()
            } else {
                callback()
            }
        }
    }

    @SuppressLint("InlinedApi")
    inline fun withPostNotificationPermission(crossinline callback: () -> Unit) {
        withPermission(POST_NOTIFICATIONS) {
            if (!it) {
                SnackbarEvent(R.string.post_notifications_denied).publish()
            } else {
                callback()
            }
        }
    }

    fun back() = BackPressEvent().publish()

    fun ViewEvent.publish() {
        _viewEvents.postValue(this)
    }

    fun DialogBuilder.show() {
        DialogEvent(this).publish()
    }

    fun NavDirections.navigate(pop: Boolean = false) {
        _viewEvents.postValue(NavigationEvent(this, pop))
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/arch/NavigationActivity.kt`:

```kt
package com.topjohnwu.magisk.arch

import android.content.ContentResolver
import android.view.KeyEvent
import androidx.databinding.ViewDataBinding
import androidx.navigation.NavController
import androidx.navigation.NavDirections
import androidx.navigation.fragment.NavHostFragment
import androidx.navigation.navOptions
import com.topjohnwu.magisk.utils.AccessibilityUtils

abstract class NavigationActivity<Binding : ViewDataBinding> : UIActivity<Binding>() {

    abstract val navHostId: Int

    private val navHostFragment by lazy {
        supportFragmentManager.findFragmentById(navHostId) as NavHostFragment
    }

    protected val currentFragment get() =
        navHostFragment.childFragmentManager.fragments.getOrNull(0) as? BaseFragment<*>

    val navigation: NavController get() = navHostFragment.navController

    override fun dispatchKeyEvent(event: KeyEvent): Boolean {
        return if (binded && currentFragment?.onKeyEvent(event) == true) true else super.dispatchKeyEvent(event)
    }

    override fun onBackPressed() {
        if (binded) {
            if (currentFragment?.onBackPressed() == false) {
                super.onBackPressed()
            }
        }
    }

    companion object {
        fun navigate(directions: NavDirections, navigation: NavController, cr: ContentResolver) {
            if (AccessibilityUtils.isAnimationEnabled(cr)) {
                navigation.navigate(directions)
            } else {
                navigation.navigate(directions, navOptions {})
            }
        }
    }

    fun NavDirections.navigate() {
        navigate(this, navigation, contentResolver)
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/arch/UIActivity.kt`:

```kt
package com.topjohnwu.magisk.arch

import android.content.Context
import android.content.res.Resources
import android.graphics.Color
import android.os.Build
import android.os.Bundle
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.app.AppCompatDelegate
import androidx.core.content.res.use
import androidx.core.view.WindowCompat
import androidx.databinding.DataBindingUtil
import androidx.databinding.ViewDataBinding
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import androidx.transition.AutoTransition
import androidx.transition.TransitionManager
import com.google.android.material.snackbar.Snackbar
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.base.ActivityExtension
import com.topjohnwu.magisk.core.base.IActivityExtension
import com.topjohnwu.magisk.core.isRunningAsStub
import com.topjohnwu.magisk.core.ktx.reflectField
import com.topjohnwu.magisk.core.wrap
import rikka.insets.WindowInsetsHelper
import rikka.layoutinflater.view.LayoutInflaterFactory

abstract class UIActivity<Binding : ViewDataBinding>
    : AppCompatActivity(), ViewModelHolder, IActivityExtension {

    protected lateinit var binding: Binding
    protected abstract val layoutRes: Int
    override val extension = ActivityExtension(this)

    protected val binded get() = ::binding.isInitialized

    open val snackbarView get() = binding.root
    open val snackbarAnchorView: View? get() = null

    init {
        AppCompatDelegate.setDefaultNightMode(Config.darkTheme)
    }

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base.wrap())
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        layoutInflater.factory2 = LayoutInflaterFactory(delegate)
            .addOnViewCreatedListener(WindowInsetsHelper.LISTENER)

        extension.onCreate(savedInstanceState)
        if (isRunningAsStub) {
            // Overwrite private members to avoid nasty "false" stack traces being logged
            val delegate = delegate
            val clz = delegate.javaClass
            clz.reflectField("mActivityHandlesConfigFlagsChecked").set(delegate, true)
            clz.reflectField("mActivityHandlesConfigFlags").set(delegate, 0)
        }

        super.onCreate(savedInstanceState)

        startObserveLiveData()

        // We need to set the window background explicitly since for whatever reason it's not
        // propagated upstream
        obtainStyledAttributes(intArrayOf(android.R.attr.windowBackground))
            .use { it.getDrawable(0) }
            .also { window.setBackgroundDrawable(it) }

        WindowCompat.setDecorFitsSystemWindows(window, false)

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            window?.decorView?.post {
                // If navigation bar is short enough (gesture navigation enabled), make it transparent
                if ((window.decorView.rootWindowInsets?.systemWindowInsetBottom
                        ?: 0) < Resources.getSystem().displayMetrics.density * 40) {
                    window.navigationBarColor = Color.TRANSPARENT
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                        window.navigationBarDividerColor = Color.TRANSPARENT
                    }
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        window.isNavigationBarContrastEnforced = false
                        window.isStatusBarContrastEnforced = false
                    }
                }
            }
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        extension.onSaveInstanceState(outState)
    }

    fun setContentView() {
        binding = DataBindingUtil.setContentView<Binding>(this, layoutRes).also {
            it.setVariable(BR.viewModel, viewModel)
            it.lifecycleOwner = this
        }
    }

    fun setAccessibilityDelegate(delegate: View.AccessibilityDelegate?) {
        binding.root.rootView.accessibilityDelegate = delegate
    }

    fun showSnackbar(
        message: CharSequence,
        length: Int = Snackbar.LENGTH_SHORT,
        builder: Snackbar.() -> Unit = {}
    ) = Snackbar.make(snackbarView, message, length)
        .setAnchorView(snackbarAnchorView).apply(builder).show()

    override fun onResume() {
        super.onResume()
        viewModel.let {
            if (it is AsyncLoadViewModel)
                it.startLoading()
        }
    }

    override fun onEventDispatched(event: ViewEvent) = when (event) {
        is ContextExecutor -> event(this)
        is ActivityExecutor -> event(this)
        else -> Unit
    }
}

fun ViewGroup.startAnimations() {
    val transition = AutoTransition()
        .setInterpolator(FastOutSlowInInterpolator())
        .setDuration(400)
        .excludeTarget(R.id.main_toolbar, true)
    TransitionManager.beginDelayedTransition(
        this,
        transition
    )
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/arch/ViewEvent.kt`:

```kt
package com.topjohnwu.magisk.arch

import android.content.Context

/**
 * Class for passing events from ViewModels to Activities/Fragments
 * (see https://medium.com/google-developers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150)
 */
abstract class ViewEvent

interface ContextExecutor {
    operator fun invoke(context: Context)
}

interface ActivityExecutor {
    operator fun invoke(activity: UIActivity<*>)
}

interface FragmentExecutor {
    operator fun invoke(fragment: BaseFragment<*>)
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/arch/ViewModelHolder.kt`:

```kt
package com.topjohnwu.magisk.arch

import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.ViewModelStoreOwner
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.ui.home.HomeViewModel
import com.topjohnwu.magisk.ui.install.InstallViewModel
import com.topjohnwu.magisk.ui.log.LogViewModel
import com.topjohnwu.magisk.ui.superuser.SuperuserViewModel
import com.topjohnwu.magisk.ui.surequest.SuRequestViewModel

interface ViewModelHolder : LifecycleOwner, ViewModelStoreOwner {

    val viewModel: BaseViewModel

    fun startObserveLiveData() {
        viewModel.viewEvents.observe(this, this::onEventDispatched)
        Info.isConnected.observe(this, viewModel::onNetworkChanged)
    }

    /**
     * Called for all [ViewEvent]s published by associated viewModel.
     */
    fun onEventDispatched(event: ViewEvent) {}
}

object VMFactory : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        return when (modelClass) {
            HomeViewModel::class.java -> HomeViewModel(ServiceLocator.networkService)
            LogViewModel::class.java -> LogViewModel(ServiceLocator.logRepo)
            SuperuserViewModel::class.java -> SuperuserViewModel(ServiceLocator.policyDB)
            InstallViewModel::class.java ->
                InstallViewModel(ServiceLocator.networkService, ServiceLocator.markwon)
            SuRequestViewModel::class.java ->
                SuRequestViewModel(ServiceLocator.policyDB, ServiceLocator.timeoutPrefs)
            else -> modelClass.newInstance()
        } as T
    }
}

inline fun <reified VM : ViewModel> ViewModelHolder.viewModel() =
    lazy(LazyThreadSafetyMode.NONE) {
        ViewModelProvider(this, VMFactory)[VM::class.java]
    }

```

`app/apk/src/main/java/com/topjohnwu/magisk/databinding/DataBindingAdapters.kt`:

```kt
package com.topjohnwu.magisk.databinding

import android.animation.ValueAnimator
import android.content.res.ColorStateList
import android.graphics.Paint
import android.graphics.drawable.Drawable
import android.text.Spanned
import android.util.TypedValue
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.ImageView
import android.widget.ProgressBar
import android.widget.Spinner
import android.widget.TextView
import androidx.annotation.DrawableRes
import androidx.appcompat.widget.Toolbar
import androidx.cardview.widget.CardView
import androidx.core.view.isGone
import androidx.core.view.isInvisible
import androidx.core.view.updateLayoutParams
import androidx.core.widget.ImageViewCompat
import androidx.databinding.BindingAdapter
import androidx.databinding.InverseBindingAdapter
import androidx.databinding.InverseBindingListener
import androidx.databinding.InverseMethod
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import androidx.recyclerview.widget.StaggeredGridLayoutManager
import com.google.android.material.button.MaterialButton
import com.google.android.material.card.MaterialCardView
import com.google.android.material.chip.Chip
import com.google.android.material.slider.Slider
import com.google.android.material.textfield.TextInputLayout
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.core.model.su.SuPolicy
import com.topjohnwu.magisk.utils.TextHolder
import com.topjohnwu.superuser.internal.UiThreadHandler
import com.topjohnwu.widget.IndeterminateCheckBox
import kotlin.math.roundToInt

@BindingAdapter("gone")
fun setGone(view: View, gone: Boolean) {
    view.isGone = gone
}

@BindingAdapter("invisible")
fun setInvisible(view: View, invisible: Boolean) {
    view.isInvisible = invisible
}

@BindingAdapter("goneUnless")
fun setGoneUnless(view: View, goneUnless: Boolean) {
    setGone(view, goneUnless.not())
}

@BindingAdapter("invisibleUnless")
fun setInvisibleUnless(view: View, invisibleUnless: Boolean) {
    setInvisible(view, invisibleUnless.not())
}

@BindingAdapter("markdownText")
fun setMarkdownText(tv: TextView, markdown: Spanned) {
    ServiceLocator.markwon.setParsedMarkdown(tv, markdown)
}

@BindingAdapter("onNavigationClick")
fun setOnNavigationClickedListener(view: Toolbar, listener: View.OnClickListener) {
    view.setNavigationOnClickListener(listener)
}

@BindingAdapter("srcCompat")
fun setImageResource(view: ImageView, @DrawableRes resId: Int) {
    view.setImageResource(resId)
}

@BindingAdapter("srcCompat")
fun setImageResource(view: ImageView, drawable: Drawable) {
    view.setImageDrawable(drawable)
}

@BindingAdapter("onTouch")
fun setOnTouchListener(view: View, listener: View.OnTouchListener) {
    view.setOnTouchListener(listener)
}

@BindingAdapter("scrollToLast")
fun setScrollToLast(view: RecyclerView, shouldScrollToLast: Boolean) {

    fun scrollToLast() = UiThreadHandler.handler.postDelayed({
        view.scrollToPosition(view.adapter?.itemCount?.minus(1) ?: 0)
    }, 30)

    fun wait(callback: () -> Unit) {
        UiThreadHandler.handler.postDelayed(callback, 1000)
    }

    fun RecyclerView.Adapter<*>.setListener() {
        val observer = object : RecyclerView.AdapterDataObserver() {
            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {
                scrollToLast()
            }
        }
        registerAdapterDataObserver(observer)
        view.setTag(R.id.recyclerScrollListener, observer)
    }

    fun RecyclerView.Adapter<*>.removeListener() {
        val observer =
            view.getTag(R.id.recyclerScrollListener) as? RecyclerView.AdapterDataObserver ?: return
        unregisterAdapterDataObserver(observer)
    }

    fun trySetListener(): Unit = view.adapter?.setListener() ?: wait { trySetListener() }

    if (shouldScrollToLast) {
        trySetListener()
    } else {
        view.adapter?.removeListener()
    }
}

@BindingAdapter("isEnabled")
fun setEnabled(view: View, isEnabled: Boolean) {
    view.isEnabled = isEnabled
}

@BindingAdapter("error")
fun TextInputLayout.setErrorString(error: String) {
    val newError = error.let { if (it.isEmpty()) null else it }
    if (this.error == null && newError == null) return
    this.error = newError
}

// md2

@BindingAdapter(
    "android:layout_marginLeft",
    "android:layout_marginTop",
    "android:layout_marginRight",
    "android:layout_marginBottom",
    "android:layout_marginStart",
    "android:layout_marginEnd",
    requireAll = false
)
fun View.setMargins(
    marginLeft: Int?,
    marginTop: Int?,
    marginRight: Int?,
    marginBottom: Int?,
    marginStart: Int?,
    marginEnd: Int?
) = updateLayoutParams<ViewGroup.MarginLayoutParams> {
    marginLeft?.let { leftMargin = it }
    marginTop?.let { topMargin = it }
    marginRight?.let { rightMargin = it }
    marginBottom?.let { bottomMargin = it }
    marginStart?.let { this.marginStart = it }
    marginEnd?.let { this.marginEnd = it }
}

@BindingAdapter("nestedScrollingEnabled")
fun RecyclerView.setNestedScrolling(enabled: Boolean) {
    isNestedScrollingEnabled = enabled
}

@BindingAdapter("isSelected")
fun View.isSelected(isSelected: Boolean) {
    this.isSelected = isSelected
}

@BindingAdapter("dividerVertical", "dividerHorizontal", requireAll = false)
fun RecyclerView.setDividers(dividerVertical: Drawable?, dividerHorizontal: Drawable?) {
    if (dividerHorizontal != null) {
        DividerItemDecoration(context, LinearLayoutManager.HORIZONTAL).apply {
            setDrawable(dividerHorizontal)
        }.let { addItemDecoration(it) }
    }
    if (dividerVertical != null) {
        DividerItemDecoration(context, LinearLayoutManager.VERTICAL).apply {
            setDrawable(dividerVertical)
        }.let { addItemDecoration(it) }
    }
}

@BindingAdapter("icon")
fun Button.setIconRes(res: Int) {
    (this as MaterialButton).setIconResource(res)
}

@BindingAdapter("icon")
fun Button.setIcon(drawable: Drawable) {
    (this as MaterialButton).icon = drawable
}

@BindingAdapter("strokeWidth")
fun MaterialCardView.setCardStrokeWidthBound(stroke: Float) {
    strokeWidth = stroke.roundToInt()
}

@BindingAdapter("onMenuClick")
fun Toolbar.setOnMenuClickListener(listener: Toolbar.OnMenuItemClickListener) {
    setOnMenuItemClickListener(listener)
}

@BindingAdapter("onCloseClicked")
fun Chip.setOnCloseClickedListenerBinding(listener: View.OnClickListener) {
    setOnCloseIconClickListener(listener)
}

@BindingAdapter("progressAnimated")
fun ProgressBar.setProgressAnimated(newProgress: Int) {
    val animator = tag as? ValueAnimator
    animator?.cancel()

    ValueAnimator.ofInt(progress, newProgress).apply {
        interpolator = FastOutSlowInInterpolator()
        addUpdateListener { progress = it.animatedValue as Int }
        tag = this
    }.start()
}

@BindingAdapter("android:text")
fun TextView.setTextSafe(text: Int) {
    if (text == 0) this.text = null else setText(text)
}

@BindingAdapter("android:onLongClick")
fun View.setOnLongClickListenerBinding(listener: () -> Unit) {
    setOnLongClickListener {
        listener()
        true
    }
}

@BindingAdapter("strikeThrough")
fun TextView.setStrikeThroughEnabled(useStrikeThrough: Boolean) {
    paintFlags = if (useStrikeThrough) {
        paintFlags or Paint.STRIKE_THRU_TEXT_FLAG
    } else {
        paintFlags and Paint.STRIKE_THRU_TEXT_FLAG.inv()
    }
}

@BindingAdapter("spanCount")
fun RecyclerView.setSpanCount(count: Int) {
    when (val lama = layoutManager) {
        is GridLayoutManager -> lama.spanCount = count
        is StaggeredGridLayoutManager -> lama.spanCount = count
    }
}

@BindingAdapter("state")
fun setState(view: IndeterminateCheckBox, state: Boolean?) {
    if (view.state != state)
        view.state = state
}

@InverseBindingAdapter(attribute = "state")
fun getState(view: IndeterminateCheckBox) = view.state

@BindingAdapter("stateAttrChanged")
fun setListeners(
    view: IndeterminateCheckBox,
    attrChange: InverseBindingListener
) {
    view.setOnStateChangedListener { _, _ ->
        attrChange.onChange()
    }
}

@BindingAdapter("cardBackgroundColorAttr")
fun CardView.setCardBackgroundColorAttr(attr: Int) {
    val tv = TypedValue()
    context.theme.resolveAttribute(attr, tv, true)
    setCardBackgroundColor(tv.data)
}

@BindingAdapter("tint")
fun ImageView.setTint(color: Int) {
    ImageViewCompat.setImageTintList(this, ColorStateList.valueOf(color))
}

@BindingAdapter("tintAttr")
fun ImageView.setTintAttr(attr: Int) {
    val tv = TypedValue()
    context.theme.resolveAttribute(attr, tv, true)
    ImageViewCompat.setImageTintList(this, ColorStateList.valueOf(tv.data))
}

@BindingAdapter("textColorAttr")
fun TextView.setTextColorAttr(attr: Int) {
    val tv = TypedValue()
    context.theme.resolveAttribute(attr, tv, true)
    setTextColor(tv.data)
}

@BindingAdapter("android:text")
fun TextView.setText(text: TextHolder) {
    this.text = text.getText(context.resources)
}

@BindingAdapter("items", "layout")
fun Spinner.setAdapter(items: Array<Any>, layoutRes: Int) {
    adapter = ArrayAdapter(context, layoutRes, items)
}

@BindingAdapter("labelFormatter")
fun Slider.setLabelFormatter(formatter: (Float) -> Int) {
    setLabelFormatter { value -> resources.getString(formatter(value)) }
}

@InverseBindingAdapter(attribute = "android:value")
fun Slider.getValueBinding() = value

@BindingAdapter("android:valueAttrChanged")
fun Slider.setListener(attrChange: InverseBindingListener) {
    addOnSliderTouchListener(object : Slider.OnSliderTouchListener {
        override fun onStartTrackingTouch(slider: Slider) = Unit
        override fun onStopTrackingTouch(slider: Slider) = attrChange.onChange()
    })
}

@InverseMethod("sliderValueToPolicy")
fun policyToSliderValue(policy: Int): Float {
    return when (policy) {
        SuPolicy.DENY -> 1f
        SuPolicy.RESTRICT -> 2f
        SuPolicy.ALLOW -> 3f
        else -> 1f
    }
}

fun sliderValueToPolicy(value: Float): Int {
    return when (value) {
        1f -> SuPolicy.DENY
        2f -> SuPolicy.RESTRICT
        3f -> SuPolicy.ALLOW
        else -> SuPolicy.DENY
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/databinding/DiffObservableList.kt`:

```kt
package com.topjohnwu.magisk.databinding

import androidx.annotation.MainThread
import androidx.annotation.WorkerThread
import androidx.databinding.ListChangeRegistry
import androidx.databinding.ObservableList
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListUpdateCallback
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.AbstractList

// Only expose the immutable List types
interface DiffList<T : DiffItem<*>> : List<T> {
    fun calculateDiff(newItems: List<T>): DiffUtil.DiffResult

    @MainThread
    fun update(newItems: List<T>, diffResult: DiffUtil.DiffResult)

    @WorkerThread
    suspend fun update(newItems: List<T>)
}

interface FilterList<T : DiffItem<*>> : List<T> {
    fun filter(filter: (T) -> Boolean)

    @MainThread
    fun set(newItems: List<T>)
}

fun <T : DiffItem<*>> diffList(): DiffList<T> = DiffObservableList()

fun <T : DiffItem<*>> filterList(scope: CoroutineScope): FilterList<T> =
    FilterableDiffObservableList(scope)

private open class DiffObservableList<T : DiffItem<*>>
    : AbstractList<T>(), ObservableList<T>, DiffList<T>, ListUpdateCallback {

    protected var list: List<T> = emptyList()
    private val listeners = ListChangeRegistry()

    override val size: Int get() = list.size

    override fun get(index: Int) = list[index]

    override fun calculateDiff(newItems: List<T>): DiffUtil.DiffResult {
        return doCalculateDiff(list, newItems)
    }

    protected fun doCalculateDiff(oldItems: List<T>, newItems: List<T>): DiffUtil.DiffResult {
        return DiffUtil.calculateDiff(object : DiffUtil.Callback() {
            override fun getOldListSize() = oldItems.size

            override fun getNewListSize() = newItems.size

            @Suppress("UNCHECKED_CAST")
            override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
                val oldItem = oldItems[oldItemPosition]
                val newItem = newItems[newItemPosition]
                return (oldItem as DiffItem<Any>).itemSameAs(newItem)
            }

            @Suppress("UNCHECKED_CAST")
            override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
                val oldItem = oldItems[oldItemPosition]
                val newItem = newItems[newItemPosition]
                return (oldItem as DiffItem<Any>).contentSameAs(newItem)
            }
        }, true)
    }

    @MainThread
    override fun update(newItems: List<T>, diffResult: DiffUtil.DiffResult) {
        list = ArrayList(newItems)
        diffResult.dispatchUpdatesTo(this)
    }

    @WorkerThread
    override suspend fun update(newItems: List<T>) {
        val diffResult = calculateDiff(newItems)
        withContext(Dispatchers.Main) {
            update(newItems, diffResult)
        }
    }

    override fun addOnListChangedCallback(listener: ObservableList.OnListChangedCallback<out ObservableList<T>>) {
        listeners.add(listener)
    }

    override fun removeOnListChangedCallback(listener: ObservableList.OnListChangedCallback<out ObservableList<T>>) {
        listeners.remove(listener)
    }

    override fun onChanged(position: Int, count: Int, payload: Any?) {
        listeners.notifyChanged(this, position, count)
    }

    override fun onMoved(fromPosition: Int, toPosition: Int) {
        listeners.notifyMoved(this, fromPosition, toPosition, 1)
    }

    override fun onInserted(position: Int, count: Int) {
        modCount += 1
        listeners.notifyInserted(this, position, count)
    }

    override fun onRemoved(position: Int, count: Int) {
        modCount += 1
        listeners.notifyRemoved(this, position, count)
    }
}

private class FilterableDiffObservableList<T : DiffItem<*>>(
    private val scope: CoroutineScope
) : DiffObservableList<T>(), FilterList<T> {

    private var sublist: List<T> = emptyList()
    private var job: Job? = null
    private var lastFilter: ((T) -> Boolean)? = null

    // ---

    override fun filter(filter: (T) -> Boolean) {
        lastFilter = filter
        job?.cancel()
        job = scope.launch(Dispatchers.Default) {
            val oldList = sublist
            val newList = list.filter(filter)
            val diff = doCalculateDiff(oldList, newList)
            withContext(Dispatchers.Main) {
                sublist = newList
                diff.dispatchUpdatesTo(this@FilterableDiffObservableList)
            }
        }
    }

    // ---

    override fun get(index: Int): T {
        return sublist[index]
    }

    override val size: Int
        get() = sublist.size

    @MainThread
    override fun set(newItems: List<T>) {
        onRemoved(0, sublist.size)
        list = newItems
        sublist = emptyList()
        lastFilter?.let { filter(it) }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/databinding/MergeObservableList.kt`:

```kt
package com.topjohnwu.magisk.databinding

import androidx.databinding.ListChangeRegistry
import androidx.databinding.ObservableList
import androidx.databinding.ObservableList.OnListChangedCallback
import java.util.AbstractList

@Suppress("UNCHECKED_CAST")
class MergeObservableList<T> : AbstractList<T>(), ObservableList<T> {

    private val lists: MutableList<List<T>> = mutableListOf()
    private val listeners = ListChangeRegistry()
    private val callback = Callback<T>()

    override fun addOnListChangedCallback(callback: OnListChangedCallback<out ObservableList<T>>) {
        listeners.add(callback)
    }

    override fun removeOnListChangedCallback(callback: OnListChangedCallback<out ObservableList<T>>) {
        listeners.remove(callback)
    }

    override fun get(index: Int): T {
        if (index < 0)
            throw IndexOutOfBoundsException()
        var idx = index
        for (list in lists) {
            val size = list.size
            if (idx < size) {
                return list[idx]
            }
            idx -= size
        }
        throw IndexOutOfBoundsException()
    }

    override val size: Int
        get() = lists.fold(0) { i, it -> i + it.size }


    fun insertItem(obj: T): MergeObservableList<T> {
        val idx = size
        lists.add(listOf(obj))
        ++modCount
        listeners.notifyInserted(this, idx, 1)
        return this
    }

    fun insertList(list: List<T>): MergeObservableList<T> {
        val idx = size
        lists.add(list)
        ++modCount
        (list as? ObservableList<T>)?.addOnListChangedCallback(callback)
        if (list.isNotEmpty())
            listeners.notifyInserted(this, idx, list.size)
        return this
    }

    fun removeItem(obj: T): Boolean {
        var idx = 0
        for ((i, list) in lists.withIndex()) {
            if (list !is ObservableList<*>) {
                if (obj == list[0]) {
                    lists.removeAt(i)
                    ++modCount
                    listeners.notifyRemoved(this, idx, 1)
                    return true
                }
            }
            idx += list.size
        }
        return false
    }

    fun removeList(listToRemove: List<T>): Boolean {
        var idx = 0
        for ((i, list) in lists.withIndex()) {
            if (listToRemove === list) {
                (list as? ObservableList<T>)?.removeOnListChangedCallback(callback)
                lists.removeAt(i)
                ++modCount
                listeners.notifyRemoved(this, idx, list.size)
                return true
            }
            idx += list.size
        }
        return false
    }

    override fun clear() {
        val sz = size
        for (list in lists) {
            if (list is ObservableList) {
                list.removeOnListChangedCallback(callback)
            }
        }
        ++modCount
        lists.clear()
        if (sz > 0)
            listeners.notifyRemoved(this, 0, sz)
    }

    private fun subIndexToIndex(subList: List<*>, index: Int): Int {
        if (index < 0)
            throw IndexOutOfBoundsException()
        var idx = 0
        for (list in lists) {
            if (subList === list) {
                return idx + index
            }
            idx += list.size
        }
        throw IllegalArgumentException()
    }

    inner class Callback<T> : OnListChangedCallback<ObservableList<T>>() {
        override fun onChanged(sender: ObservableList<T>) {
            ++modCount
            listeners.notifyChanged(this@MergeObservableList)
        }

        override fun onItemRangeChanged(
            sender: ObservableList<T>,
            positionStart: Int,
            itemCount: Int
        ) {
            listeners.notifyChanged(this@MergeObservableList,
                subIndexToIndex(sender, positionStart), itemCount)
        }

        override fun onItemRangeInserted(
            sender: ObservableList<T>,
            positionStart: Int,
            itemCount: Int
        ) {
            ++modCount
            listeners.notifyInserted(this@MergeObservableList,
                subIndexToIndex(sender, positionStart), itemCount)
        }

        override fun onItemRangeMoved(
            sender: ObservableList<T>,
            fromPosition: Int,
            toPosition: Int,
            itemCount: Int
        ) {
            val idx = subIndexToIndex(sender, 0)
            listeners.notifyMoved(this@MergeObservableList,
                idx + fromPosition, idx + toPosition, itemCount)
        }

        override fun onItemRangeRemoved(
            sender: ObservableList<T>,
            positionStart: Int,
            itemCount: Int
        ) {
            ++modCount
            listeners.notifyRemoved(this@MergeObservableList,
                subIndexToIndex(sender, positionStart), itemCount)
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/databinding/ObservableHost.kt`:

```kt
package com.topjohnwu.magisk.databinding

import androidx.databinding.Observable
import androidx.databinding.PropertyChangeRegistry

/**
 * Modified from https://github.com/skoumalcz/teanity/blob/1.2/core/src/main/java/com/skoumal/teanity/observable/Notifyable.kt
 *
 * Interface that allows user to be observed via DataBinding or manually by assigning listeners.
 *
 * @see [androidx.databinding.Observable]
 * */
interface ObservableHost : Observable {

    var callbacks: PropertyChangeRegistry?

    /**
     * Notifies all observers that something has changed. By default implementation this method is
     * synchronous, hence observers will never be notified in undefined order. Observers might
     * choose to refresh the view completely, which is beyond the scope of this function.
     * */
    fun notifyChange() {
        synchronized(this) {
            callbacks ?: return
        }.notifyCallbacks(this, 0, null)
    }

    /**
     * Notifies all observers about field with [fieldId] has been changed. This will happen
     * synchronously before or after [notifyChange] has been called. It will never be called during
     * the execution of aforementioned method.
     * */
    fun notifyPropertyChanged(fieldId: Int) {
        synchronized(this) {
            callbacks ?: return
        }.notifyCallbacks(this, fieldId, null)
    }

    override fun addOnPropertyChangedCallback(callback: Observable.OnPropertyChangedCallback) {
        synchronized(this) {
            callbacks ?: PropertyChangeRegistry().also { callbacks = it }
        }.add(callback)
    }

    override fun removeOnPropertyChangedCallback(callback: Observable.OnPropertyChangedCallback) {
        synchronized(this) {
            callbacks ?: return
        }.remove(callback)
    }
}

fun ObservableHost.addOnPropertyChangedCallback(
    fieldId: Int,
    removeAfterChanged: Boolean = false,
    callback: () -> Unit
) {
    addOnPropertyChangedCallback(object : Observable.OnPropertyChangedCallback() {
        override fun onPropertyChanged(sender: Observable?, propertyId: Int) {
            if (fieldId == propertyId) {
                callback()
                if (removeAfterChanged)
                    removeOnPropertyChangedCallback(this)
            }
        }
    })
}

/**
 * Injects boilerplate implementation for {@literal @}[androidx.databinding.Bindable] field setters.
 *
 * # Examples:
 * ```kotlin
 * @get:Bindable
 * var myField = defaultValue
 *     set(value) = set(value, field, { field = it }, BR.myField) {
 *         doSomething(it)
 *     }
 * ```
 * */

inline fun <reified T> ObservableHost.set(
    new: T, old: T, setter: (T) -> Unit, fieldId: Int, afterChanged: (T) -> Unit = {}) {
    if (old != new) {
        setter(new)
        notifyPropertyChanged(fieldId)
        afterChanged(new)
    }
}

inline fun <reified T> ObservableHost.set(
    new: T, old: T, setter: (T) -> Unit, vararg fieldIds: Int, afterChanged: (T) -> Unit = {}) {
    if (old != new) {
        setter(new)
        fieldIds.forEach { notifyPropertyChanged(it) }
        afterChanged(new)
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/databinding/RecyclerViewItems.kt`:

```kt
package com.topjohnwu.magisk.databinding

import androidx.databinding.PropertyChangeRegistry
import androidx.databinding.ViewDataBinding
import androidx.recyclerview.widget.RecyclerView

abstract class RvItem {
    abstract val layoutRes: Int
}

abstract class ObservableRvItem : RvItem(), ObservableHost {
    override var callbacks: PropertyChangeRegistry? = null
}

interface ItemWrapper<E> {
    val item: E
}

interface ViewAwareItem {
    fun onBind(binding: ViewDataBinding, recyclerView: RecyclerView)
}

interface DiffItem<T : Any> {

    fun itemSameAs(other: T): Boolean {
        if (this === other) return true
        return when (this) {
            is ItemWrapper<*> -> item == (other as ItemWrapper<*>).item
            is Comparable<*> -> compareValues(this, other as Comparable<*>) == 0
            else -> this == other
        }
    }

    fun contentSameAs(other: T) = true
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/databinding/RvItemAdapter.kt`:

```kt
package com.topjohnwu.magisk.databinding

import android.annotation.SuppressLint
import android.util.SparseArray
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.databinding.BindingAdapter
import androidx.databinding.DataBindingUtil
import androidx.databinding.ObservableList
import androidx.databinding.ObservableList.OnListChangedCallback
import androidx.databinding.ViewDataBinding
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.findViewTreeLifecycleOwner
import androidx.recyclerview.widget.RecyclerView
import com.topjohnwu.magisk.BR

class RvItemAdapter<T: RvItem>(
    val items: List<T>,
    val extraBindings: SparseArray<*>?
) : RecyclerView.Adapter<RvItemAdapter.ViewHolder>() {

    private var lifecycleOwner: LifecycleOwner? = null
    private var recyclerView: RecyclerView? = null
    private val observer by lazy(LazyThreadSafetyMode.NONE) { ListObserver<T>() }

    override fun onAttachedToRecyclerView(rv: RecyclerView) {
        lifecycleOwner = rv.findViewTreeLifecycleOwner()
        recyclerView = rv
        if (items is ObservableList)
            items.addOnListChangedCallback(observer)
    }

    override fun onDetachedFromRecyclerView(rv: RecyclerView) {
        lifecycleOwner = null
        recyclerView = null
        if (items is ObservableList)
            items.removeOnListChangedCallback(observer)
    }

    override fun onCreateViewHolder(parent: ViewGroup, layoutRes: Int): ViewHolder {
        val inflator = LayoutInflater.from(parent.context)
        return ViewHolder(DataBindingUtil.inflate(inflator, layoutRes, parent, false))
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val item = items[position]
        holder.binding.setVariable(BR.item, item)
        extraBindings?.let {
            for (i in 0 until it.size()) {
                holder.binding.setVariable(it.keyAt(i), it.valueAt(i))
            }
        }
        holder.binding.lifecycleOwner = lifecycleOwner
        holder.binding.executePendingBindings()
        recyclerView?.let {
            if (item is ViewAwareItem)
                item.onBind(holder.binding, it)
        }
    }

    override fun getItemCount() = items.size

    override fun getItemViewType(position: Int) = items[position].layoutRes

    class ViewHolder(val binding: ViewDataBinding) : RecyclerView.ViewHolder(binding.root)

    inner class ListObserver<T: RvItem> : OnListChangedCallback<ObservableList<T>>() {

        @SuppressLint("NotifyDataSetChanged")
        override fun onChanged(sender: ObservableList<T>) {
            notifyDataSetChanged()
        }

        override fun onItemRangeChanged(
            sender: ObservableList<T>,
            positionStart: Int,
            itemCount: Int
        ) {
            notifyItemRangeChanged(positionStart, itemCount)
        }

        override fun onItemRangeInserted(
            sender: ObservableList<T>?,
            positionStart: Int,
            itemCount: Int
        ) {
            notifyItemRangeInserted(positionStart, itemCount)
        }

        override fun onItemRangeMoved(
            sender: ObservableList<T>?,
            fromPosition: Int,
            toPosition: Int,
            itemCount: Int
        ) {
            for (i in 0 until itemCount) {
                notifyItemMoved(fromPosition + i, toPosition + i)
            }
        }

        override fun onItemRangeRemoved(
            sender: ObservableList<T>?,
            positionStart: Int,
            itemCount: Int
        ) {
            notifyItemRangeRemoved(positionStart, itemCount)
        }
    }
}

inline fun bindExtra(body: (SparseArray<Any?>) -> Unit) = SparseArray<Any?>().also(body)

@BindingAdapter("items", "extraBindings", requireAll = false)
fun <T: RvItem> RecyclerView.setAdapter(items: List<T>?, extraBindings: SparseArray<*>?) {
    if (items != null) {
        val rva = (adapter as? RvItemAdapter<*>)
        if (rva == null || rva.items !== items || rva.extraBindings !== extraBindings) {
            adapter = RvItemAdapter(items, extraBindings)
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/dialog/DarkThemeDialog.kt`:

```kt
package com.topjohnwu.magisk.dialog

import android.app.Activity
import androidx.appcompat.app.AppCompatDelegate
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.UIActivity
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.events.DialogBuilder
import com.topjohnwu.magisk.view.MagiskDialog
import com.topjohnwu.magisk.core.R as CoreR

class DarkThemeDialog : DialogBuilder {

    override fun build(dialog: MagiskDialog) {
        val activity = dialog.ownerActivity!!
        dialog.apply {
            setTitle(CoreR.string.settings_dark_mode_title)
            setMessage(CoreR.string.settings_dark_mode_message)
            setButton(MagiskDialog.ButtonType.POSITIVE) {
                text = CoreR.string.settings_dark_mode_light
                icon = R.drawable.ic_day
                onClick { selectTheme(AppCompatDelegate.MODE_NIGHT_NO, activity) }
            }
            setButton(MagiskDialog.ButtonType.NEUTRAL) {
                text = CoreR.string.settings_dark_mode_system
                icon = R.drawable.ic_day_night
                onClick { selectTheme(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM, activity) }
            }
            setButton(MagiskDialog.ButtonType.NEGATIVE) {
                text = CoreR.string.settings_dark_mode_dark
                icon = R.drawable.ic_night
                onClick { selectTheme(AppCompatDelegate.MODE_NIGHT_YES, activity) }
            }
        }
    }

    private fun selectTheme(mode: Int, activity: Activity) {
        Config.darkTheme = mode
        (activity as UIActivity<*>).delegate.localNightMode = mode
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/dialog/EnvFixDialog.kt`:

```kt
package com.topjohnwu.magisk.dialog

import android.widget.Toast
import androidx.core.os.postDelayed
import androidx.lifecycle.lifecycleScope
import com.topjohnwu.magisk.core.BuildConfig
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.ktx.reboot
import com.topjohnwu.magisk.core.ktx.toast
import com.topjohnwu.magisk.core.tasks.MagiskInstaller
import com.topjohnwu.magisk.events.DialogBuilder
import com.topjohnwu.magisk.ui.home.HomeViewModel
import com.topjohnwu.magisk.view.MagiskDialog
import com.topjohnwu.superuser.internal.UiThreadHandler
import kotlinx.coroutines.launch

class EnvFixDialog(private val vm: HomeViewModel, private val code: Int) : DialogBuilder {

    override fun build(dialog: MagiskDialog) {
        dialog.apply {
            setTitle(R.string.env_fix_title)
            setMessage(R.string.env_fix_msg)
            setButton(MagiskDialog.ButtonType.POSITIVE) {
                text = android.R.string.ok
                doNotDismiss = true
                onClick {
                    dialog.apply {
                        setTitle(R.string.setup_title)
                        setMessage(R.string.setup_msg)
                        resetButtons()
                        setCancelable(false)
                    }
                    dialog.activity.lifecycleScope.launch {
                        MagiskInstaller.FixEnv().exec { success ->
                            dialog.dismiss()
                            context.toast(
                                if (success) R.string.reboot_delay_toast else R.string.setup_fail,
                                Toast.LENGTH_LONG
                            )
                            if (success)
                                UiThreadHandler.handler.postDelayed(5000) { reboot() }
                        }
                    }
                }
            }
            setButton(MagiskDialog.ButtonType.NEGATIVE) {
                text = android.R.string.cancel
            }
        }

        if (code == 2 || // No rules block, module policy not loaded
            Info.env.versionCode != BuildConfig.APP_VERSION_CODE ||
            Info.env.versionString != BuildConfig.APP_VERSION_NAME) {
            dialog.setMessage(R.string.env_full_fix_msg)
            dialog.setButton(MagiskDialog.ButtonType.POSITIVE) {
                text = android.R.string.ok
                onClick {
                    vm.onMagiskPressed()
                    dialog.dismiss()
                }
            }
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/dialog/LocalModuleInstallDialog.kt`:

```kt
package com.topjohnwu.magisk.dialog

import android.net.Uri
import com.topjohnwu.magisk.MainDirections
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.events.DialogBuilder
import com.topjohnwu.magisk.ui.module.ModuleViewModel
import com.topjohnwu.magisk.view.MagiskDialog

class LocalModuleInstallDialog(
    private val viewModel: ModuleViewModel,
    private val uri: Uri,
    private val displayName: String
) : DialogBuilder {
    override fun build(dialog: MagiskDialog) {
        dialog.apply {
            setTitle(R.string.confirm_install_title)
            setMessage(context.getString(R.string.confirm_install, displayName))
            setButton(MagiskDialog.ButtonType.POSITIVE) {
                text = android.R.string.ok
                onClick {
                    viewModel.apply {
                        MainDirections.actionFlashFragment(Const.Value.FLASH_ZIP, uri).navigate()
                    }
                }
            }
            setButton(MagiskDialog.ButtonType.NEGATIVE) {
                text = android.R.string.cancel
            }
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/dialog/ManagerInstallDialog.kt`:

```kt
package com.topjohnwu.magisk.dialog

import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.download.DownloadEngine
import com.topjohnwu.magisk.core.download.Subject
import com.topjohnwu.magisk.view.MagiskDialog
import java.io.File

class ManagerInstallDialog : MarkDownDialog() {

    override suspend fun getMarkdownText(): String {
        val text = Info.update.note
        // Cache the changelog
        File(AppContext.cacheDir, "${Info.update.versionCode}.md").writeText(text)
        return text
    }

    override fun build(dialog: MagiskDialog) {
        super.build(dialog)
        dialog.apply {
            setCancelable(true)
            setButton(MagiskDialog.ButtonType.POSITIVE) {
                text = R.string.install
                onClick { DownloadEngine.startWithActivity(activity, Subject.App()) }
            }
            setButton(MagiskDialog.ButtonType.NEGATIVE) {
                text = android.R.string.cancel
            }
        }
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/dialog/MarkDownDialog.kt`:

```kt
package com.topjohnwu.magisk.dialog

import android.view.LayoutInflater
import android.widget.TextView
import androidx.annotation.CallSuper
import androidx.lifecycle.lifecycleScope
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.events.DialogBuilder
import com.topjohnwu.magisk.view.MagiskDialog
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.io.IOException
import com.topjohnwu.magisk.core.R as CoreR

abstract class MarkDownDialog : DialogBuilder {

    abstract suspend fun getMarkdownText(): String

    @CallSuper
    override fun build(dialog: MagiskDialog) {
        with(dialog) {
            val view = LayoutInflater.from(context).inflate(R.layout.markdown_window_md2, null)
            setView(view)
            val tv = view.findViewById<TextView>(R.id.md_txt)
            activity.lifecycleScope.launch {
                try {
                    val text = withContext(Dispatchers.IO) { getMarkdownText() }
                    ServiceLocator.markwon.setMarkdown(tv, text)
                } catch (e: IOException) {
                    Timber.e(e)
                    tv.setText(CoreR.string.download_file_error)
                }
            }
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/dialog/OnlineModuleInstallDialog.kt`:

```kt
package com.topjohnwu.magisk.dialog

import android.content.Context
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.core.download.DownloadEngine
import com.topjohnwu.magisk.core.download.Subject
import com.topjohnwu.magisk.core.model.module.OnlineModule
import com.topjohnwu.magisk.ui.flash.FlashFragment
import com.topjohnwu.magisk.view.MagiskDialog
import com.topjohnwu.magisk.view.Notifications
import kotlinx.parcelize.Parcelize

class OnlineModuleInstallDialog(private val item: OnlineModule) : MarkDownDialog() {

    private val svc get() = ServiceLocator.networkService

    override suspend fun getMarkdownText(): String {
        val str = svc.fetchString(item.changelog)
        return if (str.length > 1000) str.substring(0, 1000) else str
    }

    @Parcelize
    class Module(
        override val module: OnlineModule,
        override val autoLaunch: Boolean,
        override val notifyId: Int = Notifications.nextId()
    ) : Subject.Module() {
        override fun pendingIntent(context: Context) = FlashFragment.installIntent(context, file)
    }

    override fun build(dialog: MagiskDialog) {
        super.build(dialog)
        dialog.apply {

            fun download(install: Boolean) {
                DownloadEngine.startWithActivity(activity, Module(item, install))
            }

            val title = context.getString(R.string.repo_install_title,
                item.name, item.version, item.versionCode)

            setTitle(title)
            setCancelable(true)
            setButton(MagiskDialog.ButtonType.NEGATIVE) {
                text = R.string.download
                onClick { download(false) }
            }
            setButton(MagiskDialog.ButtonType.POSITIVE) {
                text = R.string.install
                onClick { download(true) }
            }
            setButton(MagiskDialog.ButtonType.NEUTRAL) {
                text = android.R.string.cancel
            }
        }
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/dialog/SecondSlotWarningDialog.kt`:

```kt
package com.topjohnwu.magisk.dialog

import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.events.DialogBuilder
import com.topjohnwu.magisk.view.MagiskDialog

class SecondSlotWarningDialog : DialogBuilder {

    override fun build(dialog: MagiskDialog) {
        dialog.apply {
            setTitle(android.R.string.dialog_alert_title)
            setMessage(R.string.install_inactive_slot_msg)
            setButton(MagiskDialog.ButtonType.POSITIVE) {
                text = android.R.string.ok
            }
            setCancelable(true)
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/dialog/SuperuserRevokeDialog.kt`:

```kt
package com.topjohnwu.magisk.dialog

import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.events.DialogBuilder
import com.topjohnwu.magisk.view.MagiskDialog

class SuperuserRevokeDialog(
    private val appName: String,
    private val onSuccess: () -> Unit
) : DialogBuilder {

    override fun build(dialog: MagiskDialog) {
        dialog.apply {
            setTitle(R.string.su_revoke_title)
            setMessage(R.string.su_revoke_msg, appName)
            setButton(MagiskDialog.ButtonType.POSITIVE) {
                text = android.R.string.ok
                onClick { onSuccess() }
            }
            setButton(MagiskDialog.ButtonType.NEGATIVE) {
                text = android.R.string.cancel
            }
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/dialog/UninstallDialog.kt`:

```kt
package com.topjohnwu.magisk.dialog

import android.app.ProgressDialog
import android.widget.Toast
import androidx.lifecycle.lifecycleScope
import com.topjohnwu.magisk.arch.NavigationActivity
import com.topjohnwu.magisk.arch.UIActivity
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.ktx.toast
import com.topjohnwu.magisk.core.tasks.MagiskInstaller
import com.topjohnwu.magisk.events.DialogBuilder
import com.topjohnwu.magisk.ui.flash.FlashFragment
import com.topjohnwu.magisk.view.MagiskDialog
import kotlinx.coroutines.launch

class UninstallDialog : DialogBuilder {

    override fun build(dialog: MagiskDialog) {
        dialog.apply {
            setTitle(R.string.uninstall_magisk_title)
            setMessage(R.string.uninstall_magisk_msg)
            setButton(MagiskDialog.ButtonType.POSITIVE) {
                text = R.string.restore_img
                onClick { restore(dialog.activity) }
            }
            setButton(MagiskDialog.ButtonType.NEGATIVE) {
                text = R.string.complete_uninstall
                onClick { completeUninstall(dialog) }
            }
        }
    }

    @Suppress("DEPRECATION")
    private fun restore(activity: UIActivity<*>) {
        val dialog = ProgressDialog(activity).apply {
            setMessage(activity.getString(R.string.restore_img_msg))
            show()
        }

        activity.lifecycleScope.launch {
            MagiskInstaller.Restore().exec { success ->
                dialog.dismiss()
                if (success) {
                    activity.toast(R.string.restore_done, Toast.LENGTH_SHORT)
                } else {
                    activity.toast(R.string.restore_fail, Toast.LENGTH_LONG)
                }
            }
        }
    }

    private fun completeUninstall(dialog: MagiskDialog) {
        (dialog.ownerActivity as NavigationActivity<*>)
            .navigation.navigate(FlashFragment.uninstall())
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/events/ViewEvents.kt`:

```kt
package com.topjohnwu.magisk.events

import android.content.Context
import android.view.View
import androidx.annotation.StringRes
import androidx.navigation.NavDirections
import com.google.android.material.snackbar.Snackbar
import com.topjohnwu.magisk.arch.ActivityExecutor
import com.topjohnwu.magisk.arch.ContextExecutor
import com.topjohnwu.magisk.arch.NavigationActivity
import com.topjohnwu.magisk.arch.UIActivity
import com.topjohnwu.magisk.arch.ViewEvent
import com.topjohnwu.magisk.core.base.ContentResultCallback
import com.topjohnwu.magisk.core.base.relaunch
import com.topjohnwu.magisk.utils.TextHolder
import com.topjohnwu.magisk.utils.asText
import com.topjohnwu.magisk.view.MagiskDialog
import com.topjohnwu.magisk.view.Shortcuts

class PermissionEvent(
    private val permission: String,
    private val callback: (Boolean) -> Unit
) : ViewEvent(), ActivityExecutor {

    override fun invoke(activity: UIActivity<*>) =
        activity.withPermission(permission, callback)
}

class BackPressEvent : ViewEvent(), ActivityExecutor {
    override fun invoke(activity: UIActivity<*>) {
        activity.onBackPressed()
    }
}

class DieEvent : ViewEvent(), ActivityExecutor {
    override fun invoke(activity: UIActivity<*>) {
        activity.finish()
    }
}

class ShowUIEvent(private val delegate: View.AccessibilityDelegate?)
    : ViewEvent(), ActivityExecutor {
    override fun invoke(activity: UIActivity<*>) {
        activity.setContentView()
        activity.setAccessibilityDelegate(delegate)
    }
}

class RecreateEvent : ViewEvent(), ActivityExecutor {
    override fun invoke(activity: UIActivity<*>) {
        activity.relaunch()
    }
}

class AuthEvent(
    private val callback: () -> Unit
) : ViewEvent(), ActivityExecutor {

    override fun invoke(activity: UIActivity<*>) {
        activity.withAuthentication { if (it) callback() }
    }
}

class GetContentEvent(
    private val type: String,
    private val callback: ContentResultCallback
) : ViewEvent(), ActivityExecutor {
    override fun invoke(activity: UIActivity<*>) {
        activity.getContent(type, callback)
    }
}

class NavigationEvent(
    private val directions: NavDirections,
    private val pop: Boolean
) : ViewEvent(), ActivityExecutor {
    override fun invoke(activity: UIActivity<*>) {
        (activity as? NavigationActivity<*>)?.apply {
            if (pop) navigation.popBackStack()
            directions.navigate()
        }
    }
}

class AddHomeIconEvent : ViewEvent(), ContextExecutor {
    override fun invoke(context: Context) {
        Shortcuts.addHomeIcon(context)
    }
}

class SnackbarEvent(
    private val msg: TextHolder,
    private val length: Int = Snackbar.LENGTH_SHORT,
    private val builder: Snackbar.() -> Unit = {}
) : ViewEvent(), ActivityExecutor {

    constructor(
        @StringRes res: Int,
        length: Int = Snackbar.LENGTH_SHORT,
        builder: Snackbar.() -> Unit = {}
    ) : this(res.asText(), length, builder)

    constructor(
        msg: String,
        length: Int = Snackbar.LENGTH_SHORT,
        builder: Snackbar.() -> Unit = {}
    ) : this(msg.asText(), length, builder)

    override fun invoke(activity: UIActivity<*>) {
        activity.showSnackbar(msg.getText(activity.resources), length, builder)
    }
}

class DialogEvent(
    private val builder: DialogBuilder
) : ViewEvent(), ActivityExecutor {
    override fun invoke(activity: UIActivity<*>) {
        MagiskDialog(activity).apply(builder::build).show()
    }
}

interface DialogBuilder {
    fun build(dialog: MagiskDialog)
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/MainActivity.kt`:

```kt
package com.topjohnwu.magisk.ui

import android.Manifest
import android.Manifest.permission.REQUEST_INSTALL_PACKAGES
import android.annotation.SuppressLint
import android.content.Intent
import android.content.pm.ApplicationInfo
import android.os.Bundle
import android.view.MenuItem
import android.view.View
import android.view.WindowManager
import android.widget.Toast
import androidx.core.content.pm.ShortcutManagerCompat
import androidx.core.view.forEach
import androidx.core.view.isGone
import androidx.core.view.isVisible
import androidx.lifecycle.lifecycleScope
import androidx.navigation.NavDirections
import com.topjohnwu.magisk.MainDirections
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseViewModel
import com.topjohnwu.magisk.arch.NavigationActivity
import com.topjohnwu.magisk.arch.startAnimations
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.base.SplashController
import com.topjohnwu.magisk.core.base.SplashScreenHost
import com.topjohnwu.magisk.core.isRunningAsStub
import com.topjohnwu.magisk.core.ktx.toast
import com.topjohnwu.magisk.core.model.module.LocalModule
import com.topjohnwu.magisk.core.tasks.AppMigration
import com.topjohnwu.magisk.databinding.ActivityMainMd2Binding
import com.topjohnwu.magisk.ui.home.HomeFragmentDirections
import com.topjohnwu.magisk.ui.theme.Theme
import com.topjohnwu.magisk.view.MagiskDialog
import com.topjohnwu.magisk.view.Shortcuts
import kotlinx.coroutines.launch
import java.io.File
import com.topjohnwu.magisk.core.R as CoreR

class MainViewModel : BaseViewModel()

class MainActivity : NavigationActivity<ActivityMainMd2Binding>(), SplashScreenHost {

    override val layoutRes = R.layout.activity_main_md2
    override val viewModel by viewModel<MainViewModel>()
    override val navHostId: Int = R.id.main_nav_host
    override val splashController = SplashController(this)
    override val snackbarView: View
        get() {
            val fragmentOverride = currentFragment?.snackbarView
            return fragmentOverride ?: super.snackbarView
        }
    override val snackbarAnchorView: View?
        get() {
            val fragmentAnchor = currentFragment?.snackbarAnchorView
            return when {
                fragmentAnchor?.isVisible == true -> fragmentAnchor
                binding.mainNavigation.isVisible -> return binding.mainNavigation
                else -> null
            }
        }

    private var isRootFragment = true

    override fun onCreate(savedInstanceState: Bundle?) {
        setTheme(Theme.selected.themeRes)
        splashController.preOnCreate()
        super.onCreate(savedInstanceState)
        splashController.onCreate(savedInstanceState)
    }

    override fun onResume() {
        super.onResume()
        splashController.onResume()
    }

    @SuppressLint("InlinedApi")
    override fun onCreateUi(savedInstanceState: Bundle?) {
        setContentView()
        showUnsupportedMessage()
        askForHomeShortcut()

        // Ask permission to post notifications for background update check
        if (Config.checkUpdate) {
            withPermission(Manifest.permission.POST_NOTIFICATIONS) {
                Config.checkUpdate = it
            }
        }

        window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE)

        navigation.addOnDestinationChangedListener { _, destination, _ ->
            isRootFragment = when (destination.id) {
                R.id.homeFragment,
                R.id.modulesFragment,
                R.id.superuserFragment,
                R.id.logFragment -> true
                else -> false
            }

            setDisplayHomeAsUpEnabled(!isRootFragment)
            requestNavigationHidden(!isRootFragment)

            binding.mainNavigation.menu.forEach {
                if (it.itemId == destination.id) {
                    it.isChecked = true
                }
            }
        }

        setSupportActionBar(binding.mainToolbar)

        binding.mainNavigation.setOnItemSelectedListener {
            getScreen(it.itemId)?.navigate()
            true
        }
        binding.mainNavigation.setOnItemReselectedListener {
            // https://issuetracker.google.com/issues/124538620
        }
        binding.mainNavigation.menu.apply {
            findItem(R.id.superuserFragment)?.isEnabled = Info.showSuperUser
            findItem(R.id.modulesFragment)?.isEnabled = Info.env.isActive && LocalModule.loaded()
        }

        val section =
            if (intent.action == Intent.ACTION_APPLICATION_PREFERENCES)
                Const.Nav.SETTINGS
            else
                intent.getStringExtra(Const.Key.OPEN_SECTION)

        getScreen(section)?.navigate()

        if (!isRootFragment) {
            requestNavigationHidden(requiresAnimation = savedInstanceState == null)
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            android.R.id.home -> onBackPressed()
            else -> return super.onOptionsItemSelected(item)
        }
        return true
    }

    fun setDisplayHomeAsUpEnabled(isEnabled: Boolean) {
        binding.mainToolbar.startAnimations()
        when {
            isEnabled -> binding.mainToolbar.setNavigationIcon(R.drawable.ic_back_md2)
            else -> binding.mainToolbar.navigationIcon = null
        }
    }

    internal fun requestNavigationHidden(hide: Boolean = true, requiresAnimation: Boolean = true) {
        val bottomView = binding.mainNavigation
        if (requiresAnimation) {
            bottomView.isVisible = true
            bottomView.isHidden = hide
        } else {
            bottomView.isGone = hide
        }
    }

    fun invalidateToolbar() {
        //binding.mainToolbar.startAnimations()
        binding.mainToolbar.invalidate()
    }

    private fun getScreen(name: String?): NavDirections? {
        return when (name) {
            Const.Nav.SUPERUSER -> MainDirections.actionSuperuserFragment()
            Const.Nav.MODULES -> MainDirections.actionModuleFragment()
            Const.Nav.SETTINGS -> HomeFragmentDirections.actionHomeFragmentToSettingsFragment()
            else -> null
        }
    }

    private fun getScreen(id: Int): NavDirections? {
        return when (id) {
            R.id.homeFragment -> MainDirections.actionHomeFragment()
            R.id.modulesFragment -> MainDirections.actionModuleFragment()
            R.id.superuserFragment -> MainDirections.actionSuperuserFragment()
            R.id.logFragment -> MainDirections.actionLogFragment()
            else -> null
        }
    }

    @SuppressLint("InlinedApi")
    override fun showInvalidStateMessage(): Unit = runOnUiThread {
        MagiskDialog(this).apply {
            setTitle(CoreR.string.unsupport_nonroot_stub_title)
            setMessage(CoreR.string.unsupport_nonroot_stub_msg)
            setButton(MagiskDialog.ButtonType.POSITIVE) {
                text = CoreR.string.install
                onClick {
                    withPermission(REQUEST_INSTALL_PACKAGES) {
                        if (!it) {
                            toast(CoreR.string.install_unknown_denied, Toast.LENGTH_SHORT)
                            showInvalidStateMessage()
                        } else {
                            lifecycleScope.launch {
                                AppMigration.restore(this@MainActivity)
                            }
                        }
                    }
                }
            }
            setCancelable(false)
            show()
        }
    }

    private fun showUnsupportedMessage() {
        if (Info.env.isUnsupported) {
            MagiskDialog(this).apply {
                setTitle(CoreR.string.unsupport_magisk_title)
                setMessage(CoreR.string.unsupport_magisk_msg, Const.Version.MIN_VERSION)
                setButton(MagiskDialog.ButtonType.POSITIVE) { text = android.R.string.ok }
                setCancelable(false)
            }.show()
        }

        if (!Info.isEmulator && Info.env.isActive && System.getenv("PATH")
                ?.split(':')
                ?.filterNot { File("$it/magisk").exists() }
                ?.any { File("$it/su").exists() } == true) {
            MagiskDialog(this).apply {
                setTitle(CoreR.string.unsupport_general_title)
                setMessage(CoreR.string.unsupport_other_su_msg)
                setButton(MagiskDialog.ButtonType.POSITIVE) { text = android.R.string.ok }
                setCancelable(false)
            }.show()
        }

        if (applicationInfo.flags and ApplicationInfo.FLAG_SYSTEM != 0) {
            MagiskDialog(this).apply {
                setTitle(CoreR.string.unsupport_general_title)
                setMessage(CoreR.string.unsupport_system_app_msg)
                setButton(MagiskDialog.ButtonType.POSITIVE) { text = android.R.string.ok }
                setCancelable(false)
            }.show()
        }

        if (applicationInfo.flags and ApplicationInfo.FLAG_EXTERNAL_STORAGE != 0) {
            MagiskDialog(this).apply {
                setTitle(CoreR.string.unsupport_general_title)
                setMessage(CoreR.string.unsupport_external_storage_msg)
                setButton(MagiskDialog.ButtonType.POSITIVE) { text = android.R.string.ok }
                setCancelable(false)
            }.show()
        }
    }

    private fun askForHomeShortcut() {
        if (isRunningAsStub && !Config.askedHome &&
            ShortcutManagerCompat.isRequestPinShortcutSupported(this)) {
            // Ask and show dialog
            Config.askedHome = true
            MagiskDialog(this).apply {
                setTitle(CoreR.string.add_shortcut_title)
                setMessage(CoreR.string.add_shortcut_msg)
                setButton(MagiskDialog.ButtonType.NEGATIVE) {
                    text = android.R.string.cancel
                }
                setButton(MagiskDialog.ButtonType.POSITIVE) {
                    text = android.R.string.ok
                    onClick {
                        Shortcuts.addHomeIcon(this@MainActivity)
                    }
                }
                setCancelable(true)
            }.show()
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/deny/AppProcessInfo.kt`:

```kt
package com.topjohnwu.magisk.ui.deny

import android.annotation.SuppressLint
import android.content.pm.ApplicationInfo
import android.content.pm.ComponentInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.GET_ACTIVITIES
import android.content.pm.PackageManager.GET_PROVIDERS
import android.content.pm.PackageManager.GET_RECEIVERS
import android.content.pm.PackageManager.GET_SERVICES
import android.content.pm.PackageManager.MATCH_DISABLED_COMPONENTS
import android.content.pm.PackageManager.MATCH_UNINSTALLED_PACKAGES
import android.content.pm.ServiceInfo
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Build.VERSION.SDK_INT
import androidx.core.os.ProcessCompat
import com.topjohnwu.magisk.core.ktx.getLabel
import java.util.Locale
import java.util.TreeSet

class CmdlineListItem(line: String) {
    val packageName: String
    val process: String

    init {
        val split = line.split(Regex("\\|"), 2)
        packageName = split[0]
        process = split.getOrElse(1) { packageName }
    }
}

const val ISOLATED_MAGIC = "isolated"

@SuppressLint("InlinedApi")
class AppProcessInfo(
    private val info: ApplicationInfo,
    pm: PackageManager,
    denyList: List<CmdlineListItem>
) : Comparable<AppProcessInfo> {

    private val denyList = denyList.filter {
        it.packageName == info.packageName || it.packageName == ISOLATED_MAGIC
    }

    val label = info.getLabel(pm)
    val iconImage: Drawable = runCatching { info.loadIcon(pm) }.getOrDefault(pm.defaultActivityIcon)
    val packageName: String get() = info.packageName
    val processes = fetchProcesses(pm)

    override fun compareTo(other: AppProcessInfo) = comparator.compare(this, other)

    fun isSystemApp() = info.flags and ApplicationInfo.FLAG_SYSTEM != 0

    fun isApp() = ProcessCompat.isApplicationUid(info.uid)

    private fun createProcess(name: String, pkg: String = info.packageName) =
        ProcessInfo(name, pkg, denyList.any { it.process == name && it.packageName == pkg })

    private fun ComponentInfo.getProcName(): String = processName
        ?: applicationInfo.processName
        ?: applicationInfo.packageName

    private val ServiceInfo.isIsolated get() = (flags and ServiceInfo.FLAG_ISOLATED_PROCESS) != 0
    private val ServiceInfo.useAppZygote get() = (flags and ServiceInfo.FLAG_USE_APP_ZYGOTE) != 0

    private fun Array<out ComponentInfo>?.toProcessList() =
        orEmpty().map { createProcess(it.getProcName()) }

    private fun Array<ServiceInfo>?.toProcessList() = orEmpty().map {
        if (it.isIsolated) {
            if (it.useAppZygote) {
                val proc = info.processName ?: info.packageName
                createProcess("${proc}_zygote")
            } else {
                val proc = if (SDK_INT >= Build.VERSION_CODES.Q)
                    "${it.getProcName()}:${it.name}" else it.getProcName()
                createProcess(proc, ISOLATED_MAGIC)
            }
        } else {
            createProcess(it.getProcName())
        }
    }

    private fun fetchProcesses(pm: PackageManager): Collection<ProcessInfo> {
        val flag = MATCH_DISABLED_COMPONENTS or MATCH_UNINSTALLED_PACKAGES or
            GET_ACTIVITIES or GET_SERVICES or GET_RECEIVERS or GET_PROVIDERS
        val packageInfo = try {
            pm.getPackageInfo(info.packageName, flag)
        } catch (e: Exception) {
            // Exceed binder data transfer limit, parse the package locally
            pm.getPackageArchiveInfo(info.sourceDir, flag) ?: return emptyList()
        }

        val processSet = TreeSet<ProcessInfo>(compareBy({ it.name }, { it.isIsolated }))
        processSet += packageInfo.activities.toProcessList()
        processSet += packageInfo.services.toProcessList()
        processSet += packageInfo.receivers.toProcessList()
        processSet += packageInfo.providers.toProcessList()
        return processSet
    }

    companion object {
        private val comparator = compareBy<AppProcessInfo>(
            { it.label.lowercase(Locale.ROOT) },
            { it.info.packageName }
        )
    }
}

data class ProcessInfo(
    val name: String,
    val packageName: String,
    var isEnabled: Boolean
) {
    val isIsolated = packageName == ISOLATED_MAGIC
    val isAppZygote = name.endsWith("_zygote")
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/deny/DenyListFragment.kt`:

```kt
package com.topjohnwu.magisk.ui.deny

import android.os.Bundle
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import androidx.appcompat.widget.SearchView
import androidx.core.view.MenuProvider
import androidx.recyclerview.widget.RecyclerView
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseFragment
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.core.ktx.hideKeyboard
import com.topjohnwu.magisk.databinding.FragmentDenyMd2Binding
import rikka.recyclerview.addEdgeSpacing
import rikka.recyclerview.addItemSpacing
import rikka.recyclerview.fixEdgeEffect
import com.topjohnwu.magisk.core.R as CoreR

class DenyListFragment : BaseFragment<FragmentDenyMd2Binding>(), MenuProvider {

    override val layoutRes = R.layout.fragment_deny_md2
    override val viewModel by viewModel<DenyListViewModel>()

    private lateinit var searchView: SearchView

    override fun onStart() {
        super.onStart()
        activity?.setTitle(CoreR.string.denylist)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        binding.appList.addOnScrollListener(object : RecyclerView.OnScrollListener() {
            override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {
                if (newState != RecyclerView.SCROLL_STATE_IDLE) activity?.hideKeyboard()
            }
        })

        binding.appList.apply {
            addEdgeSpacing(top = R.dimen.l_50, bottom = R.dimen.l1)
            addItemSpacing(R.dimen.l1, R.dimen.l_50, R.dimen.l1)
            fixEdgeEffect()
        }
    }

    override fun onPreBind(binding: FragmentDenyMd2Binding) = Unit

    override fun onBackPressed(): Boolean {
        if (searchView.isIconfiedByDefault && !searchView.isIconified) {
            searchView.isIconified = true
            return true
        }
        return super.onBackPressed()
    }

    override fun onCreateMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.menu_deny_md2, menu)
        searchView = menu.findItem(R.id.action_search).actionView as SearchView
        searchView.queryHint = searchView.context.getString(CoreR.string.hide_filter_hint)
        searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {
            override fun onQueryTextSubmit(query: String?): Boolean {
                viewModel.query = query ?: ""
                return true
            }

            override fun onQueryTextChange(newText: String?): Boolean {
                viewModel.query = newText ?: ""
                return true
            }
        })
    }

    override fun onMenuItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.action_show_system -> {
                val check = !item.isChecked
                viewModel.isShowSystem = check
                item.isChecked = check
                return true
            }
            R.id.action_show_OS -> {
                val check = !item.isChecked
                viewModel.isShowOS = check
                item.isChecked = check
                return true
            }
        }
        return super.onOptionsItemSelected(item)
    }

    override fun onPrepareMenu(menu: Menu) {
        val showSystem = menu.findItem(R.id.action_show_system)
        val showOS = menu.findItem(R.id.action_show_OS)
        showOS.isEnabled = showSystem.isChecked
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/deny/DenyListRvItem.kt`:

```kt
package com.topjohnwu.magisk.ui.deny

import android.view.View
import android.view.ViewGroup
import androidx.databinding.Bindable
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.startAnimations
import com.topjohnwu.magisk.databinding.DiffItem
import com.topjohnwu.magisk.databinding.ObservableRvItem
import com.topjohnwu.magisk.databinding.addOnPropertyChangedCallback
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.superuser.Shell
import kotlin.math.roundToInt

class DenyListRvItem(
    val info: AppProcessInfo
) : ObservableRvItem(), DiffItem<DenyListRvItem>, Comparable<DenyListRvItem> {

    override val layoutRes get() = R.layout.item_hide_md2

    val processes = info.processes.map { ProcessRvItem(it) }

    @get:Bindable
    var isExpanded = false
        set(value) = set(value, field, { field = it }, BR.expanded)

    var itemsChecked = 0
        set(value) = set(value, field, { field = it }, BR.checkedPercent)

    val isChecked get() = itemsChecked != 0

    @get:Bindable
    val checkedPercent get() = (itemsChecked.toFloat() / processes.size * 100).roundToInt()

    private var _state: Boolean? = false
        set(value) = set(value, field, { field = it }, BR.state)

    @get:Bindable
    var state: Boolean?
        get() = _state
        set(value) = set(value, _state, { _state = it }, BR.state) {
            if (value == true) {
                processes
                    .filterNot { it.isEnabled }
                    .filter { isExpanded || it.defaultSelection }
                    .forEach { it.toggle() }
            } else {
                Shell.cmd("magisk --denylist rm ${info.packageName}").submit()
                processes.filter { it.isEnabled }.forEach {
                    if (it.process.isIsolated) {
                        it.toggle()
                    } else {
                        it.isEnabled = !it.isEnabled
                        notifyPropertyChanged(BR.enabled)
                    }
                }
            }
        }

    init {
        processes.forEach { it.addOnPropertyChangedCallback(BR.enabled) { recalculateChecked() } }
        addOnPropertyChangedCallback(BR.expanded) { recalculateChecked() }
        recalculateChecked()
    }

    fun toggleExpand(v: View) {
        (v.parent as? ViewGroup)?.startAnimations()
        isExpanded = !isExpanded
    }

    private fun recalculateChecked() {
        itemsChecked = processes.count { it.isEnabled }
        _state = if (isExpanded) {
            when (itemsChecked) {
                0 -> false
                processes.size -> true
                else -> null
            }
        } else {
            val defaultProcesses = processes.filter { it.defaultSelection }
            when (defaultProcesses.count { it.isEnabled }) {
                0 -> false
                defaultProcesses.size -> true
                else -> null
            }
        }
    }

    override fun compareTo(other: DenyListRvItem) = comparator.compare(this, other)

    companion object {
        private val comparator = compareBy<DenyListRvItem>(
            { it.itemsChecked == 0 },
            { it.info }
        )
    }

}

class ProcessRvItem(
    val process: ProcessInfo
) : ObservableRvItem(), DiffItem<ProcessRvItem> {

    override val layoutRes get() = R.layout.item_hide_process_md2

    val displayName = if (process.isIsolated) "(isolated) ${process.name}" else process.name

    @get:Bindable
    var isEnabled
        get() = process.isEnabled
        set(value) = set(value, process.isEnabled, { process.isEnabled = it }, BR.enabled) {
            val arg = if (it) "add" else "rm"
            val (name, pkg) = process
            Shell.cmd("magisk --denylist $arg $pkg \'$name\'").submit()
        }

    fun toggle() {
        isEnabled = !isEnabled
    }

    val defaultSelection get() =
        process.isIsolated || process.isAppZygote || process.name == process.packageName

    override fun itemSameAs(other: ProcessRvItem) =
        process.name == other.process.name && process.packageName == other.process.packageName

    override fun contentSameAs(other: ProcessRvItem) =
        process.isEnabled == other.process.isEnabled
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/deny/DenyListViewModel.kt`:

```kt
package com.topjohnwu.magisk.ui.deny

import android.annotation.SuppressLint
import android.content.pm.PackageManager.MATCH_UNINSTALLED_PACKAGES
import androidx.databinding.Bindable
import androidx.lifecycle.viewModelScope
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.arch.AsyncLoadViewModel
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.ktx.concurrentMap
import com.topjohnwu.magisk.databinding.bindExtra
import com.topjohnwu.magisk.databinding.filterList
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.flow.toCollection
import kotlinx.coroutines.withContext

class DenyListViewModel : AsyncLoadViewModel() {

    var isShowSystem = false
        set(value) {
            field = value
            doQuery(query)
        }

    var isShowOS = false
        set(value) {
            field = value
            doQuery(query)
        }

    var query = ""
        set(value) {
            field = value
            doQuery(value)
        }

    val items = filterList<DenyListRvItem>(viewModelScope)
    val extraBindings = bindExtra {
        it.put(BR.viewModel, this)
    }

    @get:Bindable
    var loading = true
        private set(value) = set(value, field, { field = it }, BR.loading)

    @SuppressLint("InlinedApi")
    override suspend fun doLoadWork() {
        loading = true
        val apps = withContext(Dispatchers.Default) {
            val pm = AppContext.packageManager
            val denyList = Shell.cmd("magisk --denylist ls").exec().out
                .map { CmdlineListItem(it) }
            val apps = pm.getInstalledApplications(MATCH_UNINSTALLED_PACKAGES).run {
                asFlow()
                    .filter { AppContext.packageName != it.packageName }
                    .concurrentMap { AppProcessInfo(it, pm, denyList) }
                    .filter { it.processes.isNotEmpty() }
                    .concurrentMap { DenyListRvItem(it) }
                    .toCollection(ArrayList(size))
            }
            apps.sort()
            apps
        }
        items.set(apps)
        doQuery(query)
    }

    private fun doQuery(s: String) {
        items.filter {
            fun filterSystem() = isShowSystem || !it.info.isSystemApp()

            fun filterOS() = (isShowSystem && isShowOS) || it.info.isApp()

            fun filterQuery(): Boolean {
                fun inName() = it.info.label.contains(s, true)
                fun inPackage() = it.info.packageName.contains(s, true)
                fun inProcesses() = it.processes.any { p -> p.process.name.contains(s, true) }
                return inName() || inPackage() || inProcesses()
            }

            (it.isChecked || (filterSystem() && filterOS())) && filterQuery()
        }
        loading = false
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/flash/ConsoleItem.kt`:

```kt
package com.topjohnwu.magisk.ui.flash

import android.view.View
import android.widget.TextView
import androidx.core.view.updateLayoutParams
import androidx.databinding.ViewDataBinding
import androidx.recyclerview.widget.RecyclerView
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.databinding.DiffItem
import com.topjohnwu.magisk.databinding.ItemWrapper
import com.topjohnwu.magisk.databinding.RvItem
import com.topjohnwu.magisk.databinding.ViewAwareItem
import kotlin.math.max

class ConsoleItem(
    override val item: String
) : RvItem(), ViewAwareItem, DiffItem<ConsoleItem>, ItemWrapper<String> {
    override val layoutRes = R.layout.item_console_md2

    private var parentWidth = -1

    override fun onBind(binding: ViewDataBinding, recyclerView: RecyclerView) {
        if (parentWidth < 0)
            parentWidth = (recyclerView.parent as View).width

        val view = binding.root as TextView
        view.measure(0, 0)

        // We want our recyclerView at least as wide as screen
        val desiredWidth = max(view.measuredWidth, parentWidth)

        view.updateLayoutParams { width = desiredWidth }

        if (recyclerView.width < desiredWidth) {
            recyclerView.requestLayout()
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/flash/FlashFragment.kt`:

```kt
package com.topjohnwu.magisk.ui.flash

import android.annotation.SuppressLint
import android.content.Context
import android.content.pm.ActivityInfo
import android.net.Uri
import android.os.Bundle
import android.view.KeyEvent
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import androidx.core.view.MenuProvider
import androidx.core.view.isVisible
import androidx.navigation.NavDeepLinkBuilder
import com.topjohnwu.magisk.MainDirections
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseFragment
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.cmp
import com.topjohnwu.magisk.databinding.FragmentFlashMd2Binding
import com.topjohnwu.magisk.ui.MainActivity
import com.topjohnwu.magisk.core.R as CoreR

class FlashFragment : BaseFragment<FragmentFlashMd2Binding>(), MenuProvider {

    override val layoutRes = R.layout.fragment_flash_md2
    override val viewModel by viewModel<FlashViewModel>()
    override val snackbarView: View get() = binding.snackbarContainer
    override val snackbarAnchorView: View?
        get() = if (binding.restartBtn.isShown) binding.restartBtn else super.snackbarAnchorView

    private var defaultOrientation = -1

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        viewModel.args = FlashFragmentArgs.fromBundle(requireArguments())
    }

    override fun onStart() {
        super.onStart()
        activity?.setTitle(CoreR.string.flash_screen_title)

        viewModel.state.observe(this) {
            activity?.supportActionBar?.setSubtitle(
                when (it) {
                    FlashViewModel.State.FLASHING -> CoreR.string.flashing
                    FlashViewModel.State.SUCCESS -> CoreR.string.done
                    FlashViewModel.State.FAILED -> CoreR.string.failure
                }
            )
            if (it == FlashViewModel.State.SUCCESS && viewModel.showReboot) {
                binding.restartBtn.apply {
                    if (!this.isVisible) this.show()
                    if (!this.isFocused) this.requestFocus()
                }
            }
        }
    }

    override fun onCreateMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.menu_flash, menu)
    }

    override fun onMenuItemSelected(item: MenuItem): Boolean {
        return viewModel.onMenuItemClicked(item)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        defaultOrientation = activity?.requestedOrientation ?: -1
        activity?.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LOCKED
        if (savedInstanceState == null) {
            viewModel.startFlashing()
        }
    }

    @SuppressLint("WrongConstant")
    override fun onDestroyView() {
        if (defaultOrientation != -1) {
            activity?.requestedOrientation = defaultOrientation
        }
        super.onDestroyView()
    }

    override fun onKeyEvent(event: KeyEvent): Boolean {
        return when (event.keyCode) {
            KeyEvent.KEYCODE_VOLUME_UP,
            KeyEvent.KEYCODE_VOLUME_DOWN -> true
            else -> false
        }
    }

    override fun onBackPressed(): Boolean {
        if (viewModel.flashing.value == true)
            return true
        return super.onBackPressed()
    }

    override fun onPreBind(binding: FragmentFlashMd2Binding) = Unit

    companion object {

        private fun createIntent(context: Context, args: FlashFragmentArgs) =
            NavDeepLinkBuilder(context)
                .setGraph(R.navigation.main)
                .setComponentName(MainActivity::class.java.cmp(context.packageName))
                .setDestination(R.id.flashFragment)
                .setArguments(args.toBundle())
                .createPendingIntent()

        private fun flashType(isSecondSlot: Boolean) =
            if (isSecondSlot) Const.Value.FLASH_INACTIVE_SLOT else Const.Value.FLASH_MAGISK

        /* Flashing is understood as installing / flashing magisk itself */

        fun flash(isSecondSlot: Boolean) = MainDirections.actionFlashFragment(
            action = flashType(isSecondSlot)
        )

        /* Patching is understood as injecting img files with magisk */

        fun patch(uri: Uri) = MainDirections.actionFlashFragment(
            action = Const.Value.PATCH_FILE,
            additionalData = uri
        )

        /* Uninstalling is understood as removing magisk entirely */

        fun uninstall() = MainDirections.actionFlashFragment(
            action = Const.Value.UNINSTALL
        )

        /* Installing is understood as flashing modules / zips */

        fun installIntent(context: Context, file: Uri) = FlashFragmentArgs(
            action = Const.Value.FLASH_ZIP,
            additionalData = file,
        ).let { createIntent(context, it) }

        fun install(file: Uri) = MainDirections.actionFlashFragment(
            action = Const.Value.FLASH_ZIP,
            additionalData = file,
        )
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/flash/FlashViewModel.kt`:

```kt
package com.topjohnwu.magisk.ui.flash

import android.view.MenuItem
import androidx.databinding.Bindable
import androidx.databinding.ObservableArrayList
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.map
import androidx.lifecycle.viewModelScope
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseViewModel
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.ktx.reboot
import com.topjohnwu.magisk.core.ktx.synchronized
import com.topjohnwu.magisk.core.ktx.timeFormatStandard
import com.topjohnwu.magisk.core.ktx.toTime
import com.topjohnwu.magisk.core.tasks.FlashZip
import com.topjohnwu.magisk.core.tasks.MagiskInstaller
import com.topjohnwu.magisk.core.utils.MediaStoreUtils
import com.topjohnwu.magisk.core.utils.MediaStoreUtils.outputStream
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.events.SnackbarEvent
import com.topjohnwu.superuser.CallbackList
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class FlashViewModel : BaseViewModel() {

    enum class State {
        FLASHING, SUCCESS, FAILED
    }

    private val _state = MutableLiveData(State.FLASHING)
    val state: LiveData<State> get() = _state
    val flashing = state.map { it == State.FLASHING }

    @get:Bindable
    var showReboot = Info.isRooted
        set(value) = set(value, field, { field = it }, BR.showReboot)

    val items = ObservableArrayList<ConsoleItem>()
    lateinit var args: FlashFragmentArgs

    private val logItems = mutableListOf<String>().synchronized()
    private val outItems = object : CallbackList<String>() {
        override fun onAddElement(e: String?) {
            e ?: return
            items.add(ConsoleItem(e))
            logItems.add(e)
        }
    }

    fun startFlashing() {
        val (action, uri) = args

        viewModelScope.launch {
            val result = when (action) {
                Const.Value.FLASH_ZIP -> {
                    uri ?: return@launch
                    FlashZip(uri, outItems, logItems).exec()
                }
                Const.Value.UNINSTALL -> {
                    showReboot = false
                    MagiskInstaller.Uninstall(outItems, logItems).exec()
                }
                Const.Value.FLASH_MAGISK -> {
                    if (Info.isEmulator)
                        MagiskInstaller.Emulator(outItems, logItems).exec()
                    else
                        MagiskInstaller.Direct(outItems, logItems).exec()
                }
                Const.Value.FLASH_INACTIVE_SLOT -> {
                    showReboot = false
                    MagiskInstaller.SecondSlot(outItems, logItems).exec()
                }
                Const.Value.PATCH_FILE -> {
                    uri ?: return@launch
                    showReboot = false
                    MagiskInstaller.Patch(uri, outItems, logItems).exec()
                }
                else -> {
                    back()
                    return@launch
                }
            }
            onResult(result)
        }
    }

    private fun onResult(success: Boolean) {
        _state.value = if (success) State.SUCCESS else State.FAILED
    }

    fun onMenuItemClicked(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.action_save -> savePressed()
        }
        return true
    }

    private fun savePressed() = withExternalRW {
        viewModelScope.launch(Dispatchers.IO) {
            val name = "magisk_install_log_%s.log".format(
                System.currentTimeMillis().toTime(timeFormatStandard)
            )
            val file = MediaStoreUtils.getFile(name)
            file.uri.outputStream().bufferedWriter().use { writer ->
                synchronized(logItems) {
                    logItems.forEach {
                        writer.write(it)
                        writer.newLine()
                    }
                }
            }
            SnackbarEvent(file.toString()).publish()
        }
    }

    fun restartPressed() = reboot()
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/home/DeveloperItem.kt`:

```kt
package com.topjohnwu.magisk.ui.home

import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.databinding.RvItem
import com.topjohnwu.magisk.core.R as CoreR

interface Dev {
    val name: String
}

private interface JohnImpl : Dev {
    override val name get() = "topjohnwu"
}

private interface VvbImpl : Dev {
    override val name get() = "vvb2060"
}

private interface YUImpl : Dev {
    override val name get() = "yujincheng08"
}

private interface RikkaImpl : Dev {
    override val name get() = "RikkaW"
}

private interface CanyieImpl : Dev {
    override val name get() = "canyie"
}

sealed class DeveloperItem : Dev {

    abstract val items: List<IconLink>
    val handle get() = "@${name}"

    object John : DeveloperItem(), JohnImpl {
        override val items =
            listOf(
                object : IconLink.Twitter(), JohnImpl {},
                IconLink.Github.Project
            )
    }

    object Vvb : DeveloperItem(), VvbImpl {
        override val items =
            listOf<IconLink>(
                object : IconLink.Twitter(), VvbImpl {},
                object : IconLink.Github.User(), VvbImpl {}
            )
    }

    object YU : DeveloperItem(), YUImpl {
        override val items =
            listOf<IconLink>(
                object : IconLink.Twitter() { override val name = "shanasaimoe" },
                object : IconLink.Github.User(), YUImpl {},
                object : IconLink.Sponsor(), YUImpl {}
            )
    }

    object Rikka : DeveloperItem(), RikkaImpl {
        override val items =
            listOf<IconLink>(
                object : IconLink.Twitter() { override val name = "rikkawww" },
                object : IconLink.Github.User(), RikkaImpl {}
            )
    }

    object Canyie : DeveloperItem(), CanyieImpl {
        override val items =
            listOf<IconLink>(
                object : IconLink.Twitter() { override val name = "canyie2977" },
                object : IconLink.Github.User(), CanyieImpl {}
            )
    }
}

sealed class IconLink : RvItem() {

    abstract val icon: Int
    abstract val title: Int
    abstract val link: String

    override val layoutRes get() = R.layout.item_icon_link

    abstract class PayPal : IconLink(), Dev {
        override val icon get() = CoreR.drawable.ic_paypal
        override val title get() = CoreR.string.paypal
        override val link get() = "https://paypal.me/$name"

        object Project : PayPal() {
            override val name: String get() = "magiskdonate"
        }
    }

    object Patreon : IconLink() {
        override val icon get() = CoreR.drawable.ic_patreon
        override val title get() = CoreR.string.patreon
        override val link get() = Const.Url.PATREON_URL
    }

    abstract class Twitter : IconLink(), Dev {
        override val icon get() = CoreR.drawable.ic_twitter
        override val title get() = CoreR.string.twitter
        override val link get() = "https://twitter.com/$name"
    }

    abstract class Github : IconLink() {
        override val icon get() = CoreR.drawable.ic_github
        override val title get() = CoreR.string.github

        abstract class User : Github(), Dev {
            override val link get() = "https://github.com/$name"
        }

        object Project : Github() {
            override val link get() = Const.Url.SOURCE_CODE_URL
        }
    }

    abstract class Sponsor : IconLink(), Dev {
        override val icon get() = CoreR.drawable.ic_favorite
        override val title get() = CoreR.string.github
        override val link get() = "https://github.com/sponsors/$name"
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/home/HomeFragment.kt`:

```kt
package com.topjohnwu.magisk.ui.home

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.core.view.MenuProvider
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseFragment
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.download.DownloadEngine
import com.topjohnwu.magisk.databinding.FragmentHomeMd2Binding
import com.topjohnwu.magisk.core.R as CoreR
import androidx.navigation.findNavController
import com.topjohnwu.magisk.arch.NavigationActivity

class HomeFragment : BaseFragment<FragmentHomeMd2Binding>(), MenuProvider {

    override val layoutRes = R.layout.fragment_home_md2
    override val viewModel by viewModel<HomeViewModel>()

    override fun onStart() {
        super.onStart()
        activity?.setTitle(CoreR.string.section_home)
        DownloadEngine.observeProgress(this, viewModel::onProgressUpdate)
    }

    private fun checkTitle(text: TextView, icon: ImageView) {
        text.post {
            if (text.layout?.getEllipsisCount(0) != 0) {
                with (icon) {
                    layoutParams.width = 0
                    layoutParams.height = 0
                    requestLayout()
                }
            }
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        super.onCreateView(inflater, container, savedInstanceState)

        // If titles are squished, hide icons
        with(binding.homeMagiskWrapper) {
            checkTitle(homeMagiskTitle, homeMagiskIcon)
        }
        with(binding.homeManagerWrapper) {
            checkTitle(homeManagerTitle, homeManagerIcon)
        }

        return binding.root
    }

    override fun onCreateMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.menu_home_md2, menu)
        if (!Info.isRooted)
            menu.removeItem(R.id.action_reboot)
    }

    override fun onMenuItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.action_settings ->
                activity?.let {
                    NavigationActivity.navigate(
                        HomeFragmentDirections.actionHomeFragmentToSettingsFragment(),
                        it.findNavController(R.id.main_nav_host),
                        it.contentResolver,
                    )
                }
            R.id.action_reboot -> activity?.let { RebootMenu.inflate(it).show() }
            else -> return super.onOptionsItemSelected(item)
        }
        return true
    }

    override fun onResume() {
        super.onResume()
        viewModel.stateManagerProgress = 0
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/home/HomeViewModel.kt`:

```kt
package com.topjohnwu.magisk.ui.home

import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.widget.Toast
import androidx.core.net.toUri
import androidx.databinding.Bindable
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.ActivityExecutor
import com.topjohnwu.magisk.arch.AsyncLoadViewModel
import com.topjohnwu.magisk.arch.ContextExecutor
import com.topjohnwu.magisk.arch.UIActivity
import com.topjohnwu.magisk.arch.ViewEvent
import com.topjohnwu.magisk.core.BuildConfig
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.download.Subject
import com.topjohnwu.magisk.core.download.Subject.App
import com.topjohnwu.magisk.core.ktx.await
import com.topjohnwu.magisk.core.ktx.toast
import com.topjohnwu.magisk.core.repository.NetworkService
import com.topjohnwu.magisk.databinding.bindExtra
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.dialog.EnvFixDialog
import com.topjohnwu.magisk.dialog.ManagerInstallDialog
import com.topjohnwu.magisk.dialog.UninstallDialog
import com.topjohnwu.magisk.events.SnackbarEvent
import com.topjohnwu.magisk.utils.asText
import com.topjohnwu.superuser.Shell
import kotlin.math.roundToInt
import com.topjohnwu.magisk.core.R as CoreR

class HomeViewModel(
    private val svc: NetworkService
) : AsyncLoadViewModel() {

    enum class State {
        LOADING, INVALID, OUTDATED, UP_TO_DATE
    }

    val magiskTitleBarrierIds =
        intArrayOf(R.id.home_magisk_icon, R.id.home_magisk_title, R.id.home_magisk_button)
    val appTitleBarrierIds =
        intArrayOf(R.id.home_manager_icon, R.id.home_manager_title, R.id.home_manager_button)

    @get:Bindable
    var isNoticeVisible = Config.safetyNotice
        set(value) = set(value, field, { field = it }, BR.noticeVisible)

    val magiskState
        get() = when {
            Info.isRooted && Info.env.isUnsupported -> State.OUTDATED
            !Info.env.isActive -> State.INVALID
            Info.env.versionCode < BuildConfig.APP_VERSION_CODE -> State.OUTDATED
            else -> State.UP_TO_DATE
        }

    @get:Bindable
    var appState = State.LOADING
        set(value) = set(value, field, { field = it }, BR.appState)

    val magiskInstalledVersion
        get() = Info.env.run {
            if (isActive)
                ("$versionString ($versionCode)" + if (isDebug) " (D)" else "").asText()
            else
                CoreR.string.not_available.asText()
        }

    @get:Bindable
    var managerRemoteVersion = CoreR.string.loading.asText()
        set(value) = set(value, field, { field = it }, BR.managerRemoteVersion)

    val managerInstalledVersion
        get() = "${BuildConfig.APP_VERSION_NAME} (${BuildConfig.APP_VERSION_CODE})" +
            if (BuildConfig.DEBUG) " (D)" else ""

    @get:Bindable
    var stateManagerProgress = 0
        set(value) = set(value, field, { field = it }, BR.stateManagerProgress)

    val extraBindings = bindExtra {
        it.put(BR.viewModel, this)
    }

    companion object {
        private var checkedEnv = false
    }

    override suspend fun doLoadWork() {
        appState = State.LOADING
        Info.fetchUpdate(svc)?.apply {
            appState = when {
                BuildConfig.APP_VERSION_CODE < versionCode -> State.OUTDATED
                else -> State.UP_TO_DATE
            }

            val isDebug = Config.updateChannel == Config.Value.DEBUG_CHANNEL
            managerRemoteVersion =
                ("$version (${versionCode})" + if (isDebug) " (D)" else "").asText()
        } ?: run {
            appState = State.INVALID
            managerRemoteVersion = CoreR.string.not_available.asText()
        }
        ensureEnv()
    }

    override fun onNetworkChanged(network: Boolean) = startLoading()

    fun onProgressUpdate(progress: Float, subject: Subject) {
        if (subject is App)
            stateManagerProgress = progress.times(100f).roundToInt()
    }

    fun onLinkPressed(link: String) = object : ViewEvent(), ContextExecutor {
        override fun invoke(context: Context) {
            val intent = Intent(Intent.ACTION_VIEW, link.toUri())
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            try {
                context.startActivity(intent)
            } catch (e: ActivityNotFoundException) {
                context.toast(CoreR.string.open_link_failed_toast, Toast.LENGTH_SHORT)
            }
        }
    }.publish()

    fun onDeletePressed() = UninstallDialog().show()

    fun onManagerPressed() = when (appState) {
        State.LOADING -> SnackbarEvent(CoreR.string.loading).publish()
        State.INVALID -> SnackbarEvent(CoreR.string.no_connection).publish()
        else -> withExternalRW {
            withInstallPermission {
                ManagerInstallDialog().show()
            }
        }
    }

    fun onMagiskPressed() = withExternalRW {
        HomeFragmentDirections.actionHomeFragmentToInstallFragment().navigate()
    }

    fun hideNotice() {
        Config.safetyNotice = false
        isNoticeVisible = false
    }

    private suspend fun ensureEnv() {
        if (magiskState == State.INVALID || checkedEnv) return
        val cmd = "env_check ${Info.env.versionString} ${Info.env.versionCode}"
        val code = Shell.cmd(cmd).await().code
        if (code != 0) {
            EnvFixDialog(this, code).show()
        }
        checkedEnv = true
    }

    val showTest = false
    fun onTestPressed() = object : ViewEvent(), ActivityExecutor {
        override fun invoke(activity: UIActivity<*>) {
            /* Entry point to trigger test events within the app */
        }
    }.publish()
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/home/RebootMenu.kt`:

```kt
package com.topjohnwu.magisk.ui.home

import android.app.Activity
import android.os.Build
import android.os.PowerManager
import android.view.ContextThemeWrapper
import android.view.MenuItem
import android.widget.PopupMenu
import androidx.core.content.getSystemService
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.ktx.reboot as systemReboot

object RebootMenu {

    private fun reboot(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.action_reboot_normal -> systemReboot()
            R.id.action_reboot_userspace -> systemReboot("userspace")
            R.id.action_reboot_bootloader -> systemReboot("bootloader")
            R.id.action_reboot_download -> systemReboot("download")
            R.id.action_reboot_edl -> systemReboot("edl")
            R.id.action_reboot_recovery -> systemReboot("recovery")
            R.id.action_reboot_safe_mode -> {
                val status = !item.isChecked
                item.isChecked = status
                Config.bootloop = if (status) 2 else 0
            }
            else -> Unit
        }
        return true
    }

    fun inflate(activity: Activity): PopupMenu {
        val themeWrapper = ContextThemeWrapper(activity, R.style.Foundation_PopupMenu)
        val menu = PopupMenu(themeWrapper, activity.findViewById(R.id.action_reboot))
        activity.menuInflater.inflate(R.menu.menu_reboot, menu.menu)
        menu.setOnMenuItemClickListener(RebootMenu::reboot)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R &&
            activity.getSystemService<PowerManager>()?.isRebootingUserspaceSupported == true) {
            menu.menu.findItem(R.id.action_reboot_userspace).isVisible = true
        }
        if (Const.Version.atLeast_28_0()) {
            menu.menu.findItem(R.id.action_reboot_safe_mode).isChecked = Config.bootloop >= 2
        } else {
            menu.menu.findItem(R.id.action_reboot_safe_mode).isVisible = false
        }
        return menu
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/install/InstallFragment.kt`:

```kt
package com.topjohnwu.magisk.ui.install

import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseFragment
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.databinding.FragmentInstallMd2Binding
import com.topjohnwu.magisk.core.R as CoreR

class InstallFragment : BaseFragment<FragmentInstallMd2Binding>() {

    override val layoutRes = R.layout.fragment_install_md2
    override val viewModel by viewModel<InstallViewModel>()

    override fun onStart() {
        super.onStart()
        requireActivity().setTitle(CoreR.string.install)
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/install/InstallViewModel.kt`:

```kt
package com.topjohnwu.magisk.ui.install

import android.net.Uri
import android.os.Bundle
import android.os.Parcelable
import android.text.Spanned
import android.text.SpannedString
import android.widget.Toast
import androidx.databinding.Bindable
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.viewModelScope
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseViewModel
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.BuildConfig.APP_VERSION_CODE
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.base.ContentResultCallback
import com.topjohnwu.magisk.core.ktx.toast
import com.topjohnwu.magisk.core.repository.NetworkService
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.dialog.SecondSlotWarningDialog
import com.topjohnwu.magisk.events.GetContentEvent
import com.topjohnwu.magisk.ui.flash.FlashFragment
import io.noties.markwon.Markwon
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.parcelize.Parcelize
import timber.log.Timber
import java.io.File
import java.io.IOException
import com.topjohnwu.magisk.core.R as CoreR

class InstallViewModel(svc: NetworkService, markwon: Markwon) : BaseViewModel() {

    val isRooted get() = Info.isRooted
    val skipOptions = Info.isEmulator || (Info.isSAR && !Info.isFDE && Info.ramdisk)
    val noSecondSlot = !isRooted || !Info.isAB || Info.isEmulator

    @get:Bindable
    var step = if (skipOptions) 1 else 0
        set(value) = set(value, field, { field = it }, BR.step)

    private var methodId = -1

    @get:Bindable
    var method
        get() = methodId
        set(value) = set(value, methodId, { methodId = it }, BR.method) {
            when (it) {
                R.id.method_patch -> {
                    GetContentEvent("*/*", UriCallback()).publish()
                }
                R.id.method_inactive_slot -> {
                    SecondSlotWarningDialog().show()
                }
            }
        }

    val data: LiveData<Uri?> get() = uri

    @get:Bindable
    var notes: Spanned = SpannedString("")
        set(value) = set(value, field, { field = it }, BR.notes)

    init {
        viewModelScope.launch(Dispatchers.IO) {
            try {
                val noteFile = File(AppContext.cacheDir, "${APP_VERSION_CODE}.md")
                val noteText = when {
                    noteFile.exists() -> noteFile.readText()
                    else -> {
                        val note = svc.fetchUpdate(APP_VERSION_CODE)?.note.orEmpty()
                        if (note.isEmpty()) return@launch
                        noteFile.writeText(note)
                        note
                    }
                }
                val spanned = markwon.toMarkdown(noteText)
                withContext(Dispatchers.Main) {
                    notes = spanned
                }
            } catch (e: IOException) {
                Timber.e(e)
            }
        }
    }

    fun install() {
        when (method) {
            R.id.method_patch -> FlashFragment.patch(data.value!!).navigate(true)
            R.id.method_direct -> FlashFragment.flash(false).navigate(true)
            R.id.method_inactive_slot -> FlashFragment.flash(true).navigate(true)
            else -> error("Unknown value")
        }
    }

    override fun onSaveState(state: Bundle) {
        state.putParcelable(
            INSTALL_STATE_KEY, InstallState(
                methodId,
                step,
                Config.keepVerity,
                Config.keepEnc,
                Config.recovery
            )
        )
    }

    override fun onRestoreState(state: Bundle) {
        state.getParcelable<InstallState>(INSTALL_STATE_KEY)?.let {
            methodId = it.method
            step = it.step
            Config.keepVerity = it.keepVerity
            Config.keepEnc = it.keepEnc
            Config.recovery = it.recovery
        }
    }

    @Parcelize
    class UriCallback : ContentResultCallback {
        override fun onActivityLaunch() {
            AppContext.toast(CoreR.string.patch_file_msg, Toast.LENGTH_LONG)
        }

        override fun onActivityResult(result: Uri) {
            uri.value = result
        }
    }

    @Parcelize
    class InstallState(
        val method: Int,
        val step: Int,
        val keepVerity: Boolean,
        val keepEnc: Boolean,
        val recovery: Boolean,
    ) : Parcelable

    companion object {
        private const val INSTALL_STATE_KEY = "install_state"
        private val uri = MutableLiveData<Uri?>()
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/log/LogFragment.kt`:

```kt
package com.topjohnwu.magisk.ui.log

import android.os.Bundle
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.widget.HorizontalScrollView
import androidx.core.view.MenuProvider
import androidx.core.view.isVisible
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseFragment
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.databinding.FragmentLogMd2Binding
import com.topjohnwu.magisk.ui.MainActivity
import com.topjohnwu.magisk.utils.AccessibilityUtils
import com.topjohnwu.magisk.utils.MotionRevealHelper
import rikka.recyclerview.addEdgeSpacing
import rikka.recyclerview.addItemSpacing
import rikka.recyclerview.fixEdgeEffect
import com.topjohnwu.magisk.core.R as CoreR

class LogFragment : BaseFragment<FragmentLogMd2Binding>(), MenuProvider {

    override val layoutRes = R.layout.fragment_log_md2
    override val viewModel by viewModel<LogViewModel>()
    override val snackbarView: View?
        get() = if (isMagiskLogVisible) binding.logFilterSuperuser.snackbarContainer
                else super.snackbarView
    override val snackbarAnchorView get() = binding.logFilterToggle

    private var actionSave: MenuItem? = null
    private var isMagiskLogVisible
        get() = binding.logFilter.isVisible
        set(value) {
            MotionRevealHelper.withViews(binding.logFilter, binding.logFilterToggle, value)
            actionSave?.isVisible = !value
            with(activity as MainActivity) {
                invalidateToolbar()
                requestNavigationHidden(value)
                setDisplayHomeAsUpEnabled(value)
            }
        }

    override fun onStart() {
        super.onStart()
        activity?.setTitle(CoreR.string.logs)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.logFilterToggle.setOnClickListener {
            isMagiskLogVisible = true
        }

        binding.logFilterSuperuser.logSuperuser.apply {
            addEdgeSpacing(bottom = R.dimen.l1)
            addItemSpacing(R.dimen.l1, R.dimen.l_50, R.dimen.l1)
            fixEdgeEffect()
        }

        if (!AccessibilityUtils.isAnimationEnabled(requireContext().contentResolver)) {
            val scrollView = view.findViewById<HorizontalScrollView>(R.id.log_scroll_magisk)
            scrollView.setOverScrollMode(View.OVER_SCROLL_NEVER)
        }
    }


    override fun onCreateMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.menu_log_md2, menu)
        actionSave = menu.findItem(R.id.action_save)?.also {
            it.isVisible = !isMagiskLogVisible
        }
    }

    override fun onMenuItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.action_save -> viewModel.saveMagiskLog()
            R.id.action_clear ->
                if (!isMagiskLogVisible) viewModel.clearMagiskLog()
                else viewModel.clearLog()
        }
        return super.onOptionsItemSelected(item)
    }


    override fun onPreBind(binding: FragmentLogMd2Binding) = Unit

    override fun onBackPressed(): Boolean {
        if (binding.logFilter.isVisible) {
            isMagiskLogVisible = false
            return true
        }
        return super.onBackPressed()
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/log/LogRvItem.kt`:

```kt
package com.topjohnwu.magisk.ui.log

import androidx.databinding.ViewDataBinding
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.textview.MaterialTextView
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.databinding.DiffItem
import com.topjohnwu.magisk.databinding.ItemWrapper
import com.topjohnwu.magisk.databinding.ObservableRvItem
import com.topjohnwu.magisk.databinding.ViewAwareItem

class LogRvItem(
    override val item: String
) : ObservableRvItem(), DiffItem<LogRvItem>, ItemWrapper<String>, ViewAwareItem {

    override val layoutRes = R.layout.item_log_textview

    override fun onBind(binding: ViewDataBinding, recyclerView: RecyclerView) {
        val view = binding.root as MaterialTextView
        view.measure(0, 0)
        val desiredWidth = view.measuredWidth
        val layoutParams = view.layoutParams
        layoutParams.width = desiredWidth
        if (recyclerView.width < desiredWidth) {
            recyclerView.requestLayout()
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/log/LogViewModel.kt`:

```kt
package com.topjohnwu.magisk.ui.log

import android.system.Os
import androidx.databinding.Bindable
import androidx.lifecycle.viewModelScope
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.arch.AsyncLoadViewModel
import com.topjohnwu.magisk.core.BuildConfig
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.ktx.timeFormatStandard
import com.topjohnwu.magisk.core.ktx.toTime
import com.topjohnwu.magisk.core.repository.LogRepository
import com.topjohnwu.magisk.core.utils.MediaStoreUtils
import com.topjohnwu.magisk.core.utils.MediaStoreUtils.outputStream
import com.topjohnwu.magisk.databinding.bindExtra
import com.topjohnwu.magisk.databinding.diffList
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.events.SnackbarEvent
import com.topjohnwu.magisk.view.TextItem
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.FileInputStream

class LogViewModel(
    private val repo: LogRepository
) : AsyncLoadViewModel() {
    @get:Bindable
    var loading = true
        private set(value) = set(value, field, { field = it }, BR.loading)

    // --- empty view

    val itemEmpty = TextItem(R.string.log_data_none)
    val itemMagiskEmpty = TextItem(R.string.log_data_magisk_none)

    // --- su log

    val items = diffList<SuLogRvItem>()
    val extraBindings = bindExtra {
        it.put(BR.viewModel, this)
    }

    // --- magisk log
    val logs = diffList<LogRvItem>()
    var magiskLogRaw = " "

    override suspend fun doLoadWork() {
        loading = true

        val (suLogs, suDiff) = withContext(Dispatchers.Default) {
            magiskLogRaw = repo.fetchMagiskLogs()
            val newLogs = magiskLogRaw.split('\n').map { LogRvItem(it) }
            logs.update(newLogs)
            val suLogs = repo.fetchSuLogs().map { SuLogRvItem(it) }
            suLogs to items.calculateDiff(suLogs)
        }

        items.firstOrNull()?.isTop = false
        items.lastOrNull()?.isBottom = false
        items.update(suLogs, suDiff)
        items.firstOrNull()?.isTop = true
        items.lastOrNull()?.isBottom = true
        loading = false
    }

    fun saveMagiskLog() = withExternalRW {
        viewModelScope.launch(Dispatchers.IO) {
            val filename = "magisk_log_%s.log".format(
                System.currentTimeMillis().toTime(timeFormatStandard))
            val logFile = MediaStoreUtils.getFile(filename)
            logFile.uri.outputStream().bufferedWriter().use { file ->
                file.write("---Detected Device Info---\n\n")
                file.write("isAB=${Info.isAB}\n")
                file.write("isSAR=${Info.isSAR}\n")
                file.write("ramdisk=${Info.ramdisk}\n")
                val uname = Os.uname()
                file.write("kernel=${uname.sysname} ${uname.machine} ${uname.release} ${uname.version}\n")

                file.write("\n\n---System Properties---\n\n")
                ProcessBuilder("getprop").start()
                    .inputStream.reader().use { it.copyTo(file) }

                file.write("\n\n---Environment Variables---\n\n")
                System.getenv().forEach { (key, value) -> file.write("${key}=${value}\n") }

                file.write("\n\n---System MountInfo---\n\n")
                FileInputStream("/proc/self/mountinfo").reader().use { it.copyTo(file) }

                file.write("\n---Magisk Logs---\n")
                file.write("${Info.env.versionString} (${Info.env.versionCode})\n\n")
                if (Info.env.isActive) file.write(magiskLogRaw)

                file.write("\n---Manager Logs---\n")
                file.write("${BuildConfig.APP_VERSION_NAME} (${BuildConfig.APP_VERSION_CODE})\n\n")
                ProcessBuilder("logcat", "-d").start()
                    .inputStream.reader().use { it.copyTo(file) }
            }
            SnackbarEvent(logFile.toString()).publish()
        }
    }

    fun clearMagiskLog() = repo.clearMagiskLogs {
        SnackbarEvent(R.string.logs_cleared).publish()
        startLoading()
    }

    fun clearLog() = viewModelScope.launch {
        repo.clearLogs()
        SnackbarEvent(R.string.logs_cleared).publish()
        startLoading()
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/log/SuLogRvItem.kt`:

```kt
package com.topjohnwu.magisk.ui.log

import androidx.databinding.Bindable
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.ktx.timeDateFormat
import com.topjohnwu.magisk.core.ktx.toTime
import com.topjohnwu.magisk.core.model.su.SuLog
import com.topjohnwu.magisk.databinding.DiffItem
import com.topjohnwu.magisk.databinding.ObservableRvItem
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.core.R as CoreR

class SuLogRvItem(val log: SuLog) : ObservableRvItem(), DiffItem<SuLogRvItem> {

    override val layoutRes = R.layout.item_log_access_md2

    val info = genInfo()

    @get:Bindable
    var isTop = false
        set(value) = set(value, field, { field = it }, BR.top)

    @get:Bindable
    var isBottom = false
        set(value) = set(value, field, { field = it }, BR.bottom)

    override fun itemSameAs(other: SuLogRvItem) = log.appName == other.log.appName

    private fun genInfo(): String {
        val res = AppContext.resources
        val sb = StringBuilder()
        val date = log.time.toTime(timeDateFormat)
        val toUid = res.getString(CoreR.string.target_uid, log.toUid)
        val fromPid = res.getString(CoreR.string.pid, log.fromPid)
        sb.append("$date\n$toUid  $fromPid")
        if (log.target != -1) {
            val pid = if (log.target == 0) "magiskd" else log.target.toString()
            val target = res.getString(CoreR.string.target_pid, pid)
            sb.append("  $target")
        }
        if (log.context.isNotEmpty()) {
            val context = res.getString(CoreR.string.selinux_context, log.context)
            sb.append("\n$context")
        }
        if (log.gids.isNotEmpty()) {
            val gids = res.getString(CoreR.string.supp_group, log.gids)
            sb.append("\n$gids")
        }
        sb.append("\n${log.command}")
        return sb.toString()
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/module/ActionFragment.kt`:

```kt
package com.topjohnwu.magisk.ui.module

import android.annotation.SuppressLint
import android.content.pm.ActivityInfo
import android.os.Bundle
import android.view.KeyEvent
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewTreeObserver
import android.widget.Toast
import androidx.core.view.MenuProvider
import androidx.core.view.isVisible
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseFragment
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.core.ktx.toast
import com.topjohnwu.magisk.databinding.FragmentActionMd2Binding
import com.topjohnwu.magisk.core.R as CoreR

class ActionFragment : BaseFragment<FragmentActionMd2Binding>(), MenuProvider {

    override val layoutRes = R.layout.fragment_action_md2
    override val viewModel by viewModel<ActionViewModel>()
    override val snackbarView: View get() = binding.snackbarContainer

    private var defaultOrientation = -1

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        viewModel.args = ActionFragmentArgs.fromBundle(requireArguments())
    }

    override fun onStart() {
        super.onStart()
        activity?.setTitle(viewModel.args.name)
        binding.closeBtn.setOnClickListener {
            activity?.onBackPressed()
        }

        viewModel.state.observe(this) {
            if (it != ActionViewModel.State.RUNNING) {
                binding.closeBtn.apply {
                    if (!this.isVisible) this.show()
                    if (!this.isFocused) this.requestFocus()
                }
            }
            if (it != ActionViewModel.State.SUCCESS) return@observe
            view?.viewTreeObserver?.addOnWindowFocusChangeListener(
                object : ViewTreeObserver.OnWindowFocusChangeListener {
                    override fun onWindowFocusChanged(hasFocus: Boolean) {
                        if (hasFocus) return
                        view?.viewTreeObserver?.removeOnWindowFocusChangeListener(this)
                        view?.context?.apply {
                            toast(
                                getString(CoreR.string.done_action, viewModel.args.name),
                                Toast.LENGTH_SHORT
                            )
                        }
                        viewModel.back()
                    }
                }
            )
        }
    }

    override fun onCreateMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.menu_flash, menu)
    }

    override fun onMenuItemSelected(item: MenuItem): Boolean {
        return viewModel.onMenuItemClicked(item)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        defaultOrientation = activity?.requestedOrientation ?: -1
        activity?.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LOCKED
        if (savedInstanceState == null) {
            viewModel.startRunAction()
        }
    }

    @SuppressLint("WrongConstant")
    override fun onDestroyView() {
        if (defaultOrientation != -1) {
            activity?.requestedOrientation = defaultOrientation
        }
        super.onDestroyView()
    }

    override fun onKeyEvent(event: KeyEvent): Boolean {
        return when (event.keyCode) {
            KeyEvent.KEYCODE_VOLUME_UP, KeyEvent.KEYCODE_VOLUME_DOWN -> true

            else -> false
        }
    }

    override fun onBackPressed(): Boolean {
        if (viewModel.state.value == ActionViewModel.State.RUNNING) return true
        return super.onBackPressed()
    }

    override fun onPreBind(binding: FragmentActionMd2Binding) = Unit
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/module/ActionViewModel.kt`:

```kt
package com.topjohnwu.magisk.ui.module

import android.view.MenuItem
import androidx.databinding.ObservableArrayList
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.viewModelScope
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseViewModel
import com.topjohnwu.magisk.core.ktx.synchronized
import com.topjohnwu.magisk.core.ktx.timeFormatStandard
import com.topjohnwu.magisk.core.ktx.toTime
import com.topjohnwu.magisk.core.utils.MediaStoreUtils
import com.topjohnwu.magisk.core.utils.MediaStoreUtils.outputStream
import com.topjohnwu.magisk.events.SnackbarEvent
import com.topjohnwu.magisk.ui.flash.ConsoleItem
import com.topjohnwu.superuser.CallbackList
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.io.IOException

class ActionViewModel : BaseViewModel() {

    enum class State {
        RUNNING, SUCCESS, FAILED
    }

    private val _state = MutableLiveData(State.RUNNING)
    val state: LiveData<State> get() = _state

    val items = ObservableArrayList<ConsoleItem>()
    lateinit var args: ActionFragmentArgs

    private val logItems = mutableListOf<String>().synchronized()
    private val outItems = object : CallbackList<String>() {
        override fun onAddElement(e: String?) {
            e ?: return
            items.add(ConsoleItem(e))
            logItems.add(e)
        }
    }

    fun startRunAction() = viewModelScope.launch {
        onResult(withContext(Dispatchers.IO) {
            try {
                Shell.cmd("run_action \'${args.id}\'")
                    .to(outItems, logItems)
                    .exec().isSuccess
            } catch (e: IOException) {
                Timber.e(e)
                false
            }
        })
    }

    private fun onResult(success: Boolean) {
        _state.value = if (success) State.SUCCESS else State.FAILED
    }

    fun onMenuItemClicked(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.action_save -> savePressed()
        }
        return true
    }

    private fun savePressed() = withExternalRW {
        viewModelScope.launch(Dispatchers.IO) {
            val name = "%s_action_log_%s.log".format(
                args.name,
                System.currentTimeMillis().toTime(timeFormatStandard)
            )
            val file = MediaStoreUtils.getFile(name)
            file.uri.outputStream().bufferedWriter().use { writer ->
                synchronized(logItems) {
                    logItems.forEach {
                        writer.write(it)
                        writer.newLine()
                    }
                }
            }
            SnackbarEvent(file.toString()).publish()
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/module/ModuleFragment.kt`:

```kt
package com.topjohnwu.magisk.ui.module

import android.os.Bundle
import android.view.View
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseFragment
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.core.utils.MediaStoreUtils.displayName
import com.topjohnwu.magisk.databinding.FragmentModuleMd2Binding
import rikka.recyclerview.addEdgeSpacing
import rikka.recyclerview.addInvalidateItemDecorationsObserver
import rikka.recyclerview.addItemSpacing
import rikka.recyclerview.fixEdgeEffect
import com.topjohnwu.magisk.core.R as CoreR

class ModuleFragment : BaseFragment<FragmentModuleMd2Binding>() {

    override val layoutRes = R.layout.fragment_module_md2
    override val viewModel by viewModel<ModuleViewModel>()

    override fun onStart() {
        super.onStart()
        activity?.title = resources.getString(CoreR.string.modules)
        viewModel.data.observe(this) {
            it ?: return@observe
            val displayName = runCatching { it.displayName }.getOrNull() ?: return@observe
            viewModel.requestInstallLocalModule(it, displayName)
            viewModel.data.value = null
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        binding.moduleList.apply {
            addEdgeSpacing(top = R.dimen.l_50, bottom = R.dimen.l1)
            addItemSpacing(R.dimen.l1, R.dimen.l_50, R.dimen.l1)
            fixEdgeEffect()
            post { addInvalidateItemDecorationsObserver() }
        }
    }

    override fun onPreBind(binding: FragmentModuleMd2Binding) = Unit

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/module/ModuleRvItem.kt`:

```kt
package com.topjohnwu.magisk.ui.module

import androidx.databinding.Bindable
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.model.module.LocalModule
import com.topjohnwu.magisk.databinding.DiffItem
import com.topjohnwu.magisk.databinding.ItemWrapper
import com.topjohnwu.magisk.databinding.ObservableRvItem
import com.topjohnwu.magisk.databinding.RvItem
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.utils.TextHolder
import com.topjohnwu.magisk.utils.asText
import com.topjohnwu.magisk.core.R as CoreR

object InstallModule : RvItem(), DiffItem<InstallModule> {
    override val layoutRes = R.layout.item_module_download
}

class LocalModuleRvItem(
    override val item: LocalModule
) : ObservableRvItem(), DiffItem<LocalModuleRvItem>, ItemWrapper<LocalModule> {

    override val layoutRes = R.layout.item_module_md2

    val showNotice: Boolean
    val showAction: Boolean
    val noticeText: TextHolder

    init {
        val isZygisk = item.isZygisk
        val isRiru = item.isRiru
        val zygiskUnloaded = isZygisk && item.zygiskUnloaded

        showNotice = zygiskUnloaded ||
            (Info.isZygiskEnabled && isRiru) ||
            (!Info.isZygiskEnabled && isZygisk)
        showAction = item.hasAction && !showNotice
        noticeText =
            when {
                zygiskUnloaded -> CoreR.string.zygisk_module_unloaded.asText()
                isRiru -> CoreR.string.suspend_text_riru.asText(CoreR.string.zygisk.asText())
                else -> CoreR.string.suspend_text_zygisk.asText(CoreR.string.zygisk.asText())
            }
    }

    @get:Bindable
    var isEnabled = item.enable
        set(value) = set(value, field, { field = it }, BR.enabled, BR.updateReady) {
            item.enable = value
        }

    @get:Bindable
    var isRemoved = item.remove
        set(value) = set(value, field, { field = it }, BR.removed, BR.updateReady) {
            item.remove = value
        }

    @get:Bindable
    val showUpdate get() = item.updateInfo != null

    @get:Bindable
    val updateReady get() = item.outdated && !isRemoved && isEnabled

    val isUpdated = item.updated

    fun fetchedUpdateInfo() {
        notifyPropertyChanged(BR.showUpdate)
        notifyPropertyChanged(BR.updateReady)
    }

    fun delete() {
        isRemoved = !isRemoved
    }

    override fun itemSameAs(other: LocalModuleRvItem): Boolean = item.id == other.item.id
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/module/ModuleViewModel.kt`:

```kt
package com.topjohnwu.magisk.ui.module

import android.net.Uri
import androidx.databinding.Bindable
import androidx.lifecycle.MutableLiveData
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.MainDirections
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.AsyncLoadViewModel
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.base.ContentResultCallback
import com.topjohnwu.magisk.core.model.module.LocalModule
import com.topjohnwu.magisk.core.model.module.OnlineModule
import com.topjohnwu.magisk.databinding.MergeObservableList
import com.topjohnwu.magisk.databinding.RvItem
import com.topjohnwu.magisk.databinding.bindExtra
import com.topjohnwu.magisk.databinding.diffList
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.dialog.LocalModuleInstallDialog
import com.topjohnwu.magisk.dialog.OnlineModuleInstallDialog
import com.topjohnwu.magisk.events.GetContentEvent
import com.topjohnwu.magisk.events.SnackbarEvent
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.parcelize.Parcelize
import com.topjohnwu.magisk.core.R as CoreR

class ModuleViewModel : AsyncLoadViewModel() {

    val bottomBarBarrierIds = intArrayOf(R.id.module_update, R.id.module_remove)

    private val itemsInstalled = diffList<LocalModuleRvItem>()

    val items = MergeObservableList<RvItem>()
    val extraBindings = bindExtra {
        it.put(BR.viewModel, this)
    }

    val data get() = uri

    @get:Bindable
    var loading = true
        private set(value) = set(value, field, { field = it }, BR.loading)

    override suspend fun doLoadWork() {
        loading = true
        val moduleLoaded = Info.env.isActive &&
                withContext(Dispatchers.IO) { LocalModule.loaded() }
        if (moduleLoaded) {
            loadInstalled()
            if (items.isEmpty()) {
                items.insertItem(InstallModule)
                    .insertList(itemsInstalled)
            }
        }
        loading = false
        loadUpdateInfo()
    }

    override fun onNetworkChanged(network: Boolean) = startLoading()

    private suspend fun loadInstalled() {
        withContext(Dispatchers.Default) {
            val installed = LocalModule.installed().map { LocalModuleRvItem(it) }
            itemsInstalled.update(installed)
        }
    }

    private suspend fun loadUpdateInfo() {
        withContext(Dispatchers.IO) {
            itemsInstalled.forEach {
                if (it.item.fetch())
                    it.fetchedUpdateInfo()
            }
        }
    }

    fun downloadPressed(item: OnlineModule?) =
        if (item != null && Info.isConnected.value == true) {
            withExternalRW { OnlineModuleInstallDialog(item).show() }
        } else {
            SnackbarEvent(CoreR.string.no_connection).publish()
        }

    fun installPressed() = withExternalRW {
        GetContentEvent("application/zip", UriCallback()).publish()
    }

    fun requestInstallLocalModule(uri: Uri, displayName: String) {
        LocalModuleInstallDialog(this, uri, displayName).show()
    }

    @Parcelize
    class UriCallback : ContentResultCallback {
        override fun onActivityResult(result: Uri) {
            uri.value = result
        }
    }

    fun runAction(id: String, name: String) {
        MainDirections.actionActionFragment(id, name).navigate()
    }

    companion object {
        private val uri = MutableLiveData<Uri?>()
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/settings/BaseSettingsItem.kt`:

```kt
package com.topjohnwu.magisk.ui.settings

import android.content.Context
import android.content.res.Resources
import android.view.View
import androidx.databinding.Bindable
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.core.ktx.activity
import com.topjohnwu.magisk.databinding.ObservableRvItem
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.utils.TextHolder
import com.topjohnwu.magisk.view.MagiskDialog

sealed class BaseSettingsItem : ObservableRvItem() {

    interface Handler {
        fun onItemPressed(view: View, item: BaseSettingsItem, andThen: () -> Unit)
        fun onItemAction(view: View, item: BaseSettingsItem)
    }

    override val layoutRes get() = R.layout.item_settings

    open val icon: Int get() = 0
    open val title: TextHolder get() = TextHolder.EMPTY
    @get:Bindable
    open val description: TextHolder get() = TextHolder.EMPTY
    @get:Bindable
    var isEnabled = true
        set(value) = set(value, field, { field = it }, BR.enabled, BR.description)

    open fun onPressed(view: View, handler: Handler) {
        handler.onItemPressed(view, this) {
            handler.onItemAction(view, this)
        }
    }
    open fun refresh() {}

    // Only for toggle
    open val showSwitch get() = false
    @get:Bindable
    open val isChecked get() = false
    fun onToggle(view: View, handler: Handler, checked: Boolean) =
        set(checked, isChecked, { onPressed(view, handler) })

    abstract class Value<T> : BaseSettingsItem() {

        /**
         * Represents last agreed-upon value by the validation process and the user for current
         * child. Be very aware that this shouldn't be **set** unless both sides agreed that _that_
         * is the new value.
         * */
        abstract var value: T
            protected set
    }

    abstract class Toggle : Value<Boolean>() {

        override val showSwitch get() = true
        override val isChecked get() = value

        override fun onPressed(view: View, handler: Handler) {
            // Make sure the checked state is synced
            notifyPropertyChanged(BR.checked)
            handler.onItemPressed(view, this) {
                value = !value
                notifyPropertyChanged(BR.checked)
                handler.onItemAction(view, this)
            }
        }
    }

    abstract class Input : Value<String>() {

        @get:Bindable
        abstract val inputResult: String?

        override fun onPressed(view: View, handler: Handler) {
            handler.onItemPressed(view, this) {
                MagiskDialog(view.activity).apply {
                    setTitle(title.getText(view.resources))
                    setView(getView(view.context))
                    setButton(MagiskDialog.ButtonType.POSITIVE) {
                        text = android.R.string.ok
                        onClick {
                            inputResult?.let { result ->
                                doNotDismiss = false
                                value = result
                                handler.onItemAction(view, this@Input)
                                return@onClick
                            }
                            doNotDismiss = true
                        }
                    }
                    setButton(MagiskDialog.ButtonType.NEGATIVE) {
                        text = android.R.string.cancel
                    }
                }.show()
            }
        }

        abstract fun getView(context: Context): View
    }

    abstract class Selector : Value<Int>() {

        open val entryRes get() = -1
        open val descriptionRes get() = entryRes
        open fun entries(res: Resources) = res.getArrayOrEmpty(entryRes)
        open fun descriptions(res: Resources) = res.getArrayOrEmpty(descriptionRes)

        override val description = object : TextHolder() {
            override fun getText(resources: Resources): CharSequence {
                return descriptions(resources).getOrElse(value) { "" }
            }
        }

        private fun Resources.getArrayOrEmpty(id: Int): Array<String> =
            runCatching { getStringArray(id) }.getOrDefault(emptyArray())

        override fun onPressed(view: View, handler: Handler) {
            handler.onItemPressed(view, this) {
                MagiskDialog(view.activity).apply {
                    setTitle(title.getText(view.resources))
                    setButton(MagiskDialog.ButtonType.NEGATIVE) {
                        text = android.R.string.cancel
                    }
                    setListItems(entries(view.resources)) {
                        if (value != it) {
                            value = it
                            notifyPropertyChanged(BR.description)
                            handler.onItemAction(view, this@Selector)
                        }
                    }
                }.show()
            }
        }
    }

    abstract class Blank : BaseSettingsItem()

    abstract class Section : BaseSettingsItem() {
        override val layoutRes = R.layout.item_settings_section
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/settings/SettingsFragment.kt`:

```kt
package com.topjohnwu.magisk.ui.settings

import android.os.Bundle
import android.view.View
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseFragment
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.databinding.FragmentSettingsMd2Binding
import rikka.recyclerview.addEdgeSpacing
import rikka.recyclerview.addItemSpacing
import rikka.recyclerview.fixEdgeEffect
import com.topjohnwu.magisk.core.R as CoreR

class SettingsFragment : BaseFragment<FragmentSettingsMd2Binding>() {

    override val layoutRes = R.layout.fragment_settings_md2
    override val viewModel by viewModel<SettingsViewModel>()
    override val snackbarView: View get() = binding.snackbarContainer

    override fun onStart() {
        super.onStart()

        activity?.title = resources.getString(CoreR.string.settings)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.settingsList.apply {
            addEdgeSpacing(bottom = R.dimen.l1)
            addItemSpacing(R.dimen.l1, R.dimen.l_50, R.dimen.l1)
            fixEdgeEffect()
        }
    }

    override fun onResume() {
        super.onResume()
        viewModel.items.forEach { it.refresh() }
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/settings/SettingsItems.kt`:

```kt
package com.topjohnwu.magisk.ui.settings

import android.content.Context
import android.content.res.Resources
import android.os.Build
import android.view.LayoutInflater
import android.view.View
import androidx.databinding.Bindable
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.core.BuildConfig
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.ktx.activity
import com.topjohnwu.magisk.core.tasks.AppMigration
import com.topjohnwu.magisk.core.utils.LocaleSetting
import com.topjohnwu.magisk.core.utils.MediaStoreUtils
import com.topjohnwu.magisk.databinding.DialogSettingsAppNameBinding
import com.topjohnwu.magisk.databinding.DialogSettingsDownloadPathBinding
import com.topjohnwu.magisk.databinding.DialogSettingsUpdateChannelBinding
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.utils.TextHolder
import com.topjohnwu.magisk.utils.asText
import com.topjohnwu.magisk.view.MagiskDialog
import com.topjohnwu.superuser.Shell
import com.topjohnwu.magisk.core.R as CoreR

// --- Customization

object Customization : BaseSettingsItem.Section() {
    override val title = CoreR.string.settings_customization.asText()
}

object Language : BaseSettingsItem.Selector() {
    private val names: Array<String> get() = LocaleSetting.available.names
    private val tags: Array<String> get() = LocaleSetting.available.tags

    override var value
        get() = tags.indexOf(Config.locale)
        set(value) {
            Config.locale = tags[value]
        }

    override val title = CoreR.string.language.asText()

    override fun entries(res: Resources) = names
    override fun descriptions(res: Resources) = names
}

object LanguageSystem : BaseSettingsItem.Blank() {
    override val title = CoreR.string.language.asText()
    override val description: TextHolder
        get() {
            val locale = LocaleSetting.instance.appLocale
            return locale?.getDisplayName(locale)?.asText() ?: CoreR.string.system_default.asText()
        }
}

object Theme : BaseSettingsItem.Blank() {
    override val icon = R.drawable.ic_paint
    override val title = CoreR.string.section_theme.asText()
}

// --- App

object AppSettings : BaseSettingsItem.Section() {
    override val title = CoreR.string.home_app_title.asText()
}

object Hide : BaseSettingsItem.Input() {
    override val title = CoreR.string.settings_hide_app_title.asText()
    override val description = CoreR.string.settings_hide_app_summary.asText()
    override var value = ""

    override val inputResult
        get() = if (isError) null else result

    @get:Bindable
    var result = "Settings"
        set(value) = set(value, field, { field = it }, BR.result, BR.error)

    val maxLength
        get() = AppMigration.MAX_LABEL_LENGTH

    @get:Bindable
    val isError
        get() = result.length > maxLength || result.isBlank()

    override fun getView(context: Context) = DialogSettingsAppNameBinding
        .inflate(LayoutInflater.from(context)).also { it.data = this }.root
}

object Restore : BaseSettingsItem.Blank() {
    override val title = CoreR.string.settings_restore_app_title.asText()
    override val description = CoreR.string.settings_restore_app_summary.asText()

    override fun onPressed(view: View, handler: Handler) {
        handler.onItemPressed(view, this) {
            MagiskDialog(view.activity).apply {
                setTitle(CoreR.string.settings_restore_app_title)
                setMessage(CoreR.string.restore_app_confirmation)
                setButton(MagiskDialog.ButtonType.POSITIVE) {
                    text = android.R.string.ok
                    onClick {
                        handler.onItemAction(view, this@Restore)
                    }
                }
                setButton(MagiskDialog.ButtonType.NEGATIVE) {
                    text = android.R.string.cancel
                }
                setCancelable(true)
                show()
            }
        }
    }
}

object AddShortcut : BaseSettingsItem.Blank() {
    override val title = CoreR.string.add_shortcut_title.asText()
    override val description = CoreR.string.setting_add_shortcut_summary.asText()
}

object DownloadPath : BaseSettingsItem.Input() {
    override var value
        get() = Config.downloadDir
        set(value) {
            Config.downloadDir = value
            notifyPropertyChanged(BR.description)
        }

    override val title = CoreR.string.settings_download_path_title.asText()
    override val description get() = MediaStoreUtils.fullPath(value).asText()

    override var inputResult: String = value
        set(value) = set(value, field, { field = it }, BR.inputResult, BR.path)

    @get:Bindable
    val path get() = MediaStoreUtils.fullPath(inputResult)

    override fun getView(context: Context) = DialogSettingsDownloadPathBinding
        .inflate(LayoutInflater.from(context)).also { it.data = this }.root
}

object UpdateChannel : BaseSettingsItem.Selector() {
    override var value
        get() = Config.updateChannel
        set(value) {
            Config.updateChannel = value
            Info.resetUpdate()
        }

    override val title = CoreR.string.settings_update_channel_title.asText()
    override val entryRes = CoreR.array.update_channel
}

object UpdateChannelUrl : BaseSettingsItem.Input() {
    override val title = CoreR.string.settings_update_custom.asText()
    override val description get() = value.asText()
    override var value
        get() = Config.customChannelUrl
        set(value) {
            Config.customChannelUrl = value
            Info.resetUpdate()
            notifyPropertyChanged(BR.description)
        }

    override var inputResult: String = value
        set(value) = set(value, field, { field = it }, BR.inputResult)

    override fun refresh() {
        isEnabled = UpdateChannel.value == Config.Value.CUSTOM_CHANNEL
    }

    override fun getView(context: Context) = DialogSettingsUpdateChannelBinding
        .inflate(LayoutInflater.from(context)).also { it.data = this }.root
}

object UpdateChecker : BaseSettingsItem.Toggle() {
    override val title = CoreR.string.settings_check_update_title.asText()
    override val description = CoreR.string.settings_check_update_summary.asText()
    override var value by Config::checkUpdate
}

object DoHToggle : BaseSettingsItem.Toggle() {
    override val title = CoreR.string.settings_doh_title.asText()
    override val description = CoreR.string.settings_doh_description.asText()
    override var value by Config::doh
}

object SystemlessHosts : BaseSettingsItem.Blank() {
    override val title = CoreR.string.settings_hosts_title.asText()
    override val description = CoreR.string.settings_hosts_summary.asText()
}

object RandNameToggle : BaseSettingsItem.Toggle() {
    override val title = CoreR.string.settings_random_name_title.asText()
    override val description = CoreR.string.settings_random_name_description.asText()
    override var value by Config::randName
}

// --- Magisk

object Magisk : BaseSettingsItem.Section() {
    override val title = CoreR.string.magisk.asText()
}

object Zygisk : BaseSettingsItem.Toggle() {
    override val title = CoreR.string.zygisk.asText()
    override val description get() =
        if (mismatch) CoreR.string.reboot_apply_change.asText()
        else CoreR.string.settings_zygisk_summary.asText()
    override var value
        get() = Config.zygisk
        set(value) {
            Config.zygisk = value
            notifyPropertyChanged(BR.description)
        }
    val mismatch get() = value != Info.isZygiskEnabled
}

object DenyList : BaseSettingsItem.Toggle() {
    override val title = CoreR.string.settings_denylist_title.asText()
    override val description get() = CoreR.string.settings_denylist_summary.asText()

    override var value = Config.denyList
        set(value) {
            field = value
            val cmd = if (value) "enable" else "disable"
            Shell.cmd("magisk --denylist $cmd").submit { result ->
                if (result.isSuccess) {
                    Config.denyList = value
                } else {
                    field = !value
                    notifyPropertyChanged(BR.checked)
                }
            }
        }
}

object DenyListConfig : BaseSettingsItem.Blank() {
    override val title = CoreR.string.settings_denylist_config_title.asText()
    override val description = CoreR.string.settings_denylist_config_summary.asText()
}

// --- Superuser

object Tapjack : BaseSettingsItem.Toggle() {
    override val title = CoreR.string.settings_su_tapjack_title.asText()
    override val description = CoreR.string.settings_su_tapjack_summary.asText()
    override var value by Config::suTapjack
}

object Authentication : BaseSettingsItem.Toggle() {
    override val title = CoreR.string.settings_su_auth_title.asText()
    override var description = CoreR.string.settings_su_auth_summary.asText()
    override var value by Config::suAuth

    override fun refresh() {
        isEnabled = Info.isDeviceSecure
        if (!isEnabled) {
            description = CoreR.string.settings_su_auth_insecure.asText()
        }
    }
}

object Superuser : BaseSettingsItem.Section() {
    override val title = CoreR.string.superuser.asText()
}

object AccessMode : BaseSettingsItem.Selector() {
    override val title = CoreR.string.superuser_access.asText()
    override val entryRes = CoreR.array.su_access
    override var value by Config::rootMode
}

object MultiuserMode : BaseSettingsItem.Selector() {
    override val title = CoreR.string.multiuser_mode.asText()
    override val entryRes = CoreR.array.multiuser_mode
    override val descriptionRes = CoreR.array.multiuser_summary
    override var value by Config::suMultiuserMode

    override fun refresh() {
        isEnabled = Const.USER_ID == 0
    }
}

object MountNamespaceMode : BaseSettingsItem.Selector() {
    override val title = CoreR.string.mount_namespace_mode.asText()
    override val entryRes = CoreR.array.namespace
    override val descriptionRes = CoreR.array.namespace_summary
    override var value by Config::suMntNamespaceMode
}

object AutomaticResponse : BaseSettingsItem.Selector() {
    override val title = CoreR.string.auto_response.asText()
    override val entryRes = CoreR.array.auto_response
    override var value by Config::suAutoResponse
}

object RequestTimeout : BaseSettingsItem.Selector() {
    override val title = CoreR.string.request_timeout.asText()
    override val entryRes = CoreR.array.request_timeout

    private val entryValues = listOf(10, 15, 20, 30, 45, 60)
    override var value = entryValues.indexOfFirst { it == Config.suDefaultTimeout }
        set(value) {
            field = value
            Config.suDefaultTimeout = entryValues[value]
        }
}

object SUNotification : BaseSettingsItem.Selector() {
    override val title = CoreR.string.superuser_notification.asText()
    override val entryRes = CoreR.array.su_notification
    override var value by Config::suNotification
}

object Reauthenticate : BaseSettingsItem.Toggle() {
    override val title = CoreR.string.settings_su_reauth_title.asText()
    override val description = CoreR.string.settings_su_reauth_summary.asText()
    override var value by Config::suReAuth

    override fun refresh() {
        isEnabled = Build.VERSION.SDK_INT < Build.VERSION_CODES.O
    }
}

object Restrict : BaseSettingsItem.Toggle() {
    override val title = CoreR.string.settings_su_restrict_title.asText()
    override val description = CoreR.string.settings_su_restrict_summary.asText()
    override var value by Config::suRestrict
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/settings/SettingsViewModel.kt`:

```kt
package com.topjohnwu.magisk.ui.settings

import android.app.Activity
import android.content.Intent
import android.net.Uri
import android.os.Build
import android.provider.Settings
import android.view.View
import android.widget.Toast
import androidx.core.content.pm.ShortcutManagerCompat
import androidx.lifecycle.viewModelScope
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.arch.BaseViewModel
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.BuildConfig
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.isRunningAsStub
import com.topjohnwu.magisk.core.ktx.activity
import com.topjohnwu.magisk.core.ktx.toast
import com.topjohnwu.magisk.core.tasks.AppMigration
import com.topjohnwu.magisk.core.utils.LocaleSetting
import com.topjohnwu.magisk.core.utils.RootUtils
import com.topjohnwu.magisk.databinding.bindExtra
import com.topjohnwu.magisk.events.AddHomeIconEvent
import com.topjohnwu.magisk.events.AuthEvent
import com.topjohnwu.magisk.events.SnackbarEvent
import kotlinx.coroutines.launch

class SettingsViewModel : BaseViewModel(), BaseSettingsItem.Handler {

    val items = createItems()
    val extraBindings = bindExtra {
        it.put(BR.handler, this)
    }

    private fun createItems(): List<BaseSettingsItem> {
        val context = AppContext
        val hidden = context.packageName != BuildConfig.APP_PACKAGE_NAME

        // Customization
        val list = mutableListOf(
            Customization,
            Theme, if (LocaleSetting.useLocaleManager) LanguageSystem else Language
        )
        if (isRunningAsStub && ShortcutManagerCompat.isRequestPinShortcutSupported(context))
            list.add(AddShortcut)

        // Manager
        list.addAll(listOf(
            AppSettings,
            UpdateChannel, UpdateChannelUrl, DoHToggle, UpdateChecker, DownloadPath, RandNameToggle
        ))
        if (Info.env.isActive && Const.USER_ID == 0) {
            if (hidden) list.add(Restore) else list.add(Hide)
        }

        // Magisk
        if (Info.env.isActive) {
            list.addAll(listOf(
                Magisk,
                SystemlessHosts
            ))
            if (Const.Version.atLeast_24_0()) {
                list.addAll(listOf(Zygisk, DenyList, DenyListConfig))
            }
        }

        // Superuser
        if (Info.showSuperUser) {
            list.addAll(listOf(
                Superuser,
                Tapjack, Authentication, AccessMode, MultiuserMode, MountNamespaceMode,
                AutomaticResponse, RequestTimeout, SUNotification
            ))
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
                // Re-authenticate is not feasible on 8.0+
                list.add(Reauthenticate)
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                // Can hide overlay windows on 12.0+
                list.remove(Tapjack)
            }
            if (Const.Version.atLeast_30_1()) {
                list.add(Restrict)
            }
        }

        return list
    }

    override fun onItemPressed(view: View, item: BaseSettingsItem, doAction: () -> Unit) {
        when (item) {
            DownloadPath -> withExternalRW(doAction)
            UpdateChecker -> withPostNotificationPermission(doAction)
            Authentication -> AuthEvent(doAction).publish()
            AutomaticResponse -> if (Config.suAuth) AuthEvent(doAction).publish() else doAction()
            else -> doAction()
        }
    }

    override fun onItemAction(view: View, item: BaseSettingsItem) {
        when (item) {
            Theme -> SettingsFragmentDirections.actionSettingsFragmentToThemeFragment().navigate()
            LanguageSystem -> view.activity.startActivity(LocaleSetting.localeSettingsIntent)
            AddShortcut -> AddHomeIconEvent().publish()
            SystemlessHosts -> createHosts()
            DenyListConfig -> SettingsFragmentDirections.actionSettingsFragmentToDenyFragment().navigate()
            UpdateChannel -> openUrlIfNecessary(view)
            is Hide -> viewModelScope.launch { AppMigration.hide(view.activity, item.value) }
            Restore -> viewModelScope.launch { AppMigration.restore(view.activity) }
            Zygisk -> if (Zygisk.mismatch) SnackbarEvent(R.string.reboot_apply_change).publish()
            else -> Unit
        }
    }

    private fun openUrlIfNecessary(view: View) {
        UpdateChannelUrl.refresh()
        if (UpdateChannelUrl.isEnabled && UpdateChannelUrl.value.isBlank()) {
            UpdateChannelUrl.onPressed(view, this)
        }
    }

    private fun createHosts() {
        viewModelScope.launch {
            RootUtils.addSystemlessHosts()
            AppContext.toast(R.string.settings_hosts_toast, Toast.LENGTH_SHORT)
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/superuser/PolicyRvItem.kt`:

```kt
package com.topjohnwu.magisk.ui.superuser

import android.graphics.drawable.Drawable
import androidx.databinding.Bindable
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.model.su.SuPolicy
import com.topjohnwu.magisk.databinding.DiffItem
import com.topjohnwu.magisk.databinding.ItemWrapper
import com.topjohnwu.magisk.databinding.ObservableRvItem
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.core.R as CoreR

class PolicyRvItem(
    private val viewModel: SuperuserViewModel,
    override val item: SuPolicy,
    val packageName: String,
    private val isSharedUid: Boolean,
    val icon: Drawable,
    val appName: String
) : ObservableRvItem(), DiffItem<PolicyRvItem>, ItemWrapper<SuPolicy> {

    override val layoutRes = R.layout.item_policy_md2

    val title get() = if (isSharedUid) "[SharedUID] $appName" else appName

    private inline fun <reified T> setImpl(new: T, old: T, setter: (T) -> Unit) {
        if (old != new) {
            setter(new)
        }
    }

    @get:Bindable
    var isExpanded = false
        set(value) = set(value, field, { field = it }, BR.expanded)

    val showSlider = Config.suRestrict || item.policy == SuPolicy.RESTRICT

    @get:Bindable
    var isEnabled
        get() = item.policy >= SuPolicy.ALLOW
        set(value) = setImpl(value, isEnabled) {
            notifyPropertyChanged(BR.enabled)
            viewModel.updatePolicy(this, if (it) SuPolicy.ALLOW else SuPolicy.DENY)
        }

    @get:Bindable
    var sliderValue
        get() = item.policy
        set(value) = setImpl(value, sliderValue) {
            notifyPropertyChanged(BR.sliderValue)
            notifyPropertyChanged(BR.enabled)
            viewModel.updatePolicy(this, it)
        }

    val sliderValueToPolicyString: (Float) -> Int = { value ->
        when (value.toInt()) {
            1 -> CoreR.string.deny
            2 -> CoreR.string.restrict
            3 -> CoreR.string.grant
            else -> CoreR.string.deny
        }
    }

    @get:Bindable
    var shouldNotify
        get() = item.notification
        private set(value) = setImpl(value, shouldNotify) {
            item.notification = it
            viewModel.updateNotify(this)
        }

    @get:Bindable
    var shouldLog
        get() = item.logging
        private set(value) = setImpl(value, shouldLog) {
            item.logging = it
            viewModel.updateLogging(this)
        }

    fun toggleExpand() {
        isExpanded = !isExpanded
    }

    fun toggleNotify() {
        shouldNotify = !shouldNotify
    }

    fun toggleLog() {
        shouldLog = !shouldLog
    }

    fun revoke() {
        viewModel.deletePressed(this)
    }

    override fun itemSameAs(other: PolicyRvItem) = packageName == other.packageName

    override fun contentSameAs(other: PolicyRvItem) = item.policy == other.item.policy

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/superuser/SuperuserFragment.kt`:

```kt
package com.topjohnwu.magisk.ui.superuser

import android.os.Bundle
import android.view.View
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseFragment
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.databinding.FragmentSuperuserMd2Binding
import rikka.recyclerview.addEdgeSpacing
import rikka.recyclerview.addItemSpacing
import rikka.recyclerview.fixEdgeEffect
import com.topjohnwu.magisk.core.R as CoreR

class SuperuserFragment : BaseFragment<FragmentSuperuserMd2Binding>() {

    override val layoutRes = R.layout.fragment_superuser_md2
    override val viewModel by viewModel<SuperuserViewModel>()

    override fun onStart() {
        super.onStart()
        activity?.title = resources.getString(CoreR.string.superuser)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        binding.superuserList.apply {
            addEdgeSpacing(top = R.dimen.l_50, bottom = R.dimen.l1)
            addItemSpacing(R.dimen.l1, R.dimen.l_50, R.dimen.l1)
            fixEdgeEffect()
        }
    }

    override fun onPreBind(binding: FragmentSuperuserMd2Binding) {}

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/superuser/SuperuserViewModel.kt`:

```kt
package com.topjohnwu.magisk.ui.superuser

import android.annotation.SuppressLint
import android.content.pm.PackageManager
import android.content.pm.PackageManager.MATCH_UNINSTALLED_PACKAGES
import android.os.Process
import androidx.databinding.Bindable
import androidx.databinding.ObservableArrayList
import androidx.lifecycle.viewModelScope
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.arch.AsyncLoadViewModel
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.data.magiskdb.PolicyDao
import com.topjohnwu.magisk.core.ktx.getLabel
import com.topjohnwu.magisk.core.model.su.SuPolicy
import com.topjohnwu.magisk.databinding.MergeObservableList
import com.topjohnwu.magisk.databinding.RvItem
import com.topjohnwu.magisk.databinding.bindExtra
import com.topjohnwu.magisk.databinding.diffList
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.dialog.SuperuserRevokeDialog
import com.topjohnwu.magisk.events.AuthEvent
import com.topjohnwu.magisk.events.SnackbarEvent
import com.topjohnwu.magisk.utils.asText
import com.topjohnwu.magisk.view.TextItem
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.Locale

class SuperuserViewModel(
    private val db: PolicyDao
) : AsyncLoadViewModel() {

    private val itemNoData = TextItem(R.string.superuser_policy_none)

    private val itemsHelpers = ObservableArrayList<TextItem>()
    private val itemsPolicies = diffList<PolicyRvItem>()

    val items = MergeObservableList<RvItem>()
        .insertList(itemsHelpers)
        .insertList(itemsPolicies)
    val extraBindings = bindExtra {
        it.put(BR.listener, this)
    }

    @get:Bindable
    var loading = true
        private set(value) = set(value, field, { field = it }, BR.loading)

    @SuppressLint("InlinedApi")
    override suspend fun doLoadWork() {
        if (!Info.showSuperUser) {
            loading = false
            return
        }
        loading = true
        withContext(Dispatchers.IO) {
            db.deleteOutdated()
            db.delete(AppContext.applicationInfo.uid)
            val policies = ArrayList<PolicyRvItem>()
            val pm = AppContext.packageManager
            for (policy in db.fetchAll()) {
                val pkgs =
                    if (policy.uid == Process.SYSTEM_UID) arrayOf("android")
                    else pm.getPackagesForUid(policy.uid)
                if (pkgs == null) {
                    db.delete(policy.uid)
                    continue
                }
                val map = pkgs.mapNotNull { pkg ->
                    try {
                        val info = pm.getPackageInfo(pkg, MATCH_UNINSTALLED_PACKAGES)
                        PolicyRvItem(
                            this@SuperuserViewModel, policy,
                            info.packageName,
                            info.sharedUserId != null,
                            info.applicationInfo?.loadIcon(pm) ?: pm.defaultActivityIcon,
                            info.applicationInfo?.getLabel(pm) ?: info.packageName
                        )
                    } catch (e: PackageManager.NameNotFoundException) {
                        null
                    }
                }
                if (map.isEmpty()) {
                    db.delete(policy.uid)
                    continue
                }
                policies.addAll(map)
            }
            policies.sortWith(compareBy(
                { it.appName.lowercase(Locale.ROOT) },
                { it.packageName }
            ))
            itemsPolicies.update(policies)
        }
        if (itemsPolicies.isNotEmpty())
            itemsHelpers.clear()
        else if (itemsHelpers.isEmpty())
            itemsHelpers.add(itemNoData)
        loading = false
    }

    // ---

    fun deletePressed(item: PolicyRvItem) {
        fun updateState() = viewModelScope.launch {
            db.delete(item.item.uid)
            val list = ArrayList(itemsPolicies)
            list.removeAll { it.item.uid == item.item.uid }
            itemsPolicies.update(list)
            if (list.isEmpty() && itemsHelpers.isEmpty()) {
                itemsHelpers.add(itemNoData)
            }
        }

        if (Config.suAuth) {
            AuthEvent { updateState() }.publish()
        } else {
            SuperuserRevokeDialog(item.title) { updateState() }.show()
        }
    }

    fun updateNotify(item: PolicyRvItem) {
        viewModelScope.launch {
            db.update(item.item)
            val res = when {
                item.item.notification -> R.string.su_snack_notif_on
                else -> R.string.su_snack_notif_off
            }
            itemsPolicies.forEach {
                if (it.item.uid == item.item.uid) {
                    it.notifyPropertyChanged(BR.shouldNotify)
                }
            }
            SnackbarEvent(res.asText(item.appName)).publish()
        }
    }

    fun updateLogging(item: PolicyRvItem) {
        viewModelScope.launch {
            db.update(item.item)
            val res = when {
                item.item.logging -> R.string.su_snack_log_on
                else -> R.string.su_snack_log_off
            }
            itemsPolicies.forEach {
                if (it.item.uid == item.item.uid) {
                    it.notifyPropertyChanged(BR.shouldLog)
                }
            }
            SnackbarEvent(res.asText(item.appName)).publish()
        }
    }

    fun updatePolicy(item: PolicyRvItem, policy: Int) {
        val items = itemsPolicies.filter { it.item.uid == item.item.uid }
        fun updateState() {
            viewModelScope.launch {
                val res = if (policy >= SuPolicy.ALLOW) R.string.su_snack_grant else R.string.su_snack_deny
                item.item.policy = policy
                db.update(item.item)
                items.forEach {
                    it.notifyPropertyChanged(BR.enabled)
                    it.notifyPropertyChanged(BR.sliderValue)
                }
                SnackbarEvent(res.asText(item.appName)).publish()
            }
        }

        if (Config.suAuth) {
            AuthEvent { updateState() }.publish()
        } else {
            updateState()
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/surequest/SuRequestActivity.kt`:

```kt
package com.topjohnwu.magisk.ui.surequest

import android.content.Intent
import android.content.pm.ActivityInfo
import android.content.res.Resources
import android.os.Build
import android.os.Bundle
import android.view.Window
import android.view.WindowManager
import androidx.lifecycle.lifecycleScope
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.UIActivity
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.core.base.UntrackedActivity
import com.topjohnwu.magisk.core.su.SuCallbackHandler
import com.topjohnwu.magisk.core.su.SuCallbackHandler.REQUEST
import com.topjohnwu.magisk.databinding.ActivityRequestBinding
import com.topjohnwu.magisk.ui.theme.Theme
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

open class SuRequestActivity : UIActivity<ActivityRequestBinding>(), UntrackedActivity {

    override val layoutRes: Int = R.layout.activity_request
    override val viewModel: SuRequestViewModel by viewModel()

    override fun onCreate(savedInstanceState: Bundle?) {
        supportRequestWindowFeature(Window.FEATURE_NO_TITLE)
        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LOCKED
        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        window.addFlags(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            window.setHideOverlayWindows(true)
        }
        setTheme(Theme.selected.themeRes)
        super.onCreate(savedInstanceState)

        if (intent.action == Intent.ACTION_VIEW) {
            val action = intent.getStringExtra("action")
            if (action == REQUEST) {
                viewModel.handleRequest(intent)
            } else {
                lifecycleScope.launch {
                    withContext(Dispatchers.IO) {
                        SuCallbackHandler.run(this@SuRequestActivity, action, intent.extras)
                    }
                    finish()
                }
            }
        } else {
            finish()
        }
    }

    override fun getTheme(): Resources.Theme {
        val theme = super.getTheme()
        theme.applyStyle(R.style.Foundation_Floating, true)
        return theme
    }

    override fun onBackPressed() {
        viewModel.denyPressed()
    }

    override fun finish() {
        super.finishAndRemoveTask()
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/surequest/SuRequestViewModel.kt`:

```kt
package com.topjohnwu.magisk.ui.surequest

import android.annotation.SuppressLint
import android.content.Intent
import android.content.SharedPreferences
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.os.CountDownTimer
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.view.accessibility.AccessibilityEvent
import android.view.accessibility.AccessibilityNodeInfo
import android.view.accessibility.AccessibilityNodeProvider
import android.widget.Toast
import androidx.databinding.Bindable
import androidx.lifecycle.viewModelScope
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.arch.BaseViewModel
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.data.magiskdb.PolicyDao
import com.topjohnwu.magisk.core.ktx.getLabel
import com.topjohnwu.magisk.core.ktx.toast
import com.topjohnwu.magisk.core.model.su.SuPolicy.Companion.ALLOW
import com.topjohnwu.magisk.core.model.su.SuPolicy.Companion.DENY
import com.topjohnwu.magisk.core.su.SuRequestHandler
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.events.AuthEvent
import com.topjohnwu.magisk.events.DieEvent
import com.topjohnwu.magisk.events.ShowUIEvent
import com.topjohnwu.magisk.utils.TextHolder
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.util.concurrent.TimeUnit.SECONDS

class SuRequestViewModel(
    policyDB: PolicyDao,
    private val timeoutPrefs: SharedPreferences
) : BaseViewModel() {

    lateinit var icon: Drawable
    lateinit var title: String
    lateinit var packageName: String

    @get:Bindable
    val denyText = DenyText()

    @get:Bindable
    var selectedItemPosition = 0
        set(value) = set(value, field, { field = it }, BR.selectedItemPosition)

    @get:Bindable
    var grantEnabled = false
        set(value) = set(value, field, { field = it }, BR.grantEnabled)

    @SuppressLint("ClickableViewAccessibility")
    val grantTouchListener = View.OnTouchListener { _: View, event: MotionEvent ->
        // Filter obscured touches by consuming them.
        if (event.flags and MotionEvent.FLAG_WINDOW_IS_OBSCURED != 0
            || event.flags and MotionEvent.FLAG_WINDOW_IS_PARTIALLY_OBSCURED != 0) {
            if (event.action == MotionEvent.ACTION_UP) {
                AppContext.toast(R.string.touch_filtered_warning, Toast.LENGTH_SHORT)
            }
            return@OnTouchListener Config.suTapjack
        }
        false
    }

    private val handler = SuRequestHandler(AppContext.packageManager, policyDB)
    private val millis = SECONDS.toMillis(Config.suDefaultTimeout.toLong())
    private var timer = SuTimer(millis, 1000)
    private var initialized = false

    fun grantPressed() {
        cancelTimer()
        if (Config.suAuth) {
            AuthEvent { respond(ALLOW) }.publish()
        } else {
            respond(ALLOW)
        }
    }

    fun denyPressed() {
        respond(DENY)
    }

    fun spinnerTouched(): Boolean {
        cancelTimer()
        return false
    }

    fun handleRequest(intent: Intent) {
        viewModelScope.launch(Dispatchers.Default) {
            if (handler.start(intent))
                showDialog()
            else
                DieEvent().publish()
        }
    }

    private fun showDialog() {
        val pm = handler.pm
        val info = handler.pkgInfo
        val app = info.applicationInfo

        if (app == null) {
            // The request is not coming from an app process, and the UID is a
            // shared UID. We have no way to know where this request comes from.
            icon = pm.defaultActivityIcon
            title = "[SharedUID] ${info.sharedUserId}"
            packageName = info.sharedUserId.toString()
        } else {
            val prefix = if (info.sharedUserId == null) "" else "[SharedUID] "
            icon = app.loadIcon(pm)
            title = "$prefix${app.getLabel(pm)}"
            packageName = info.packageName
        }

        selectedItemPosition = timeoutPrefs.getInt(packageName, 0)

        // Set timer
        timer.start()

        // Actually show the UI
        ShowUIEvent(if (Config.suTapjack) EmptyAccessibilityDelegate else null).publish()
        initialized = true
    }

    private fun respond(action: Int) {
        if (!initialized) {
            // ignore the response until showDialog done
            return
        }

        timer.cancel()

        val pos = selectedItemPosition
        timeoutPrefs.edit().putInt(packageName, pos).apply()

        viewModelScope.launch {
            handler.respond(action, Config.Value.TIMEOUT_LIST[pos])
            // Kill activity after response
            DieEvent().publish()
        }
    }

    private fun cancelTimer() {
        timer.cancel()
        denyText.seconds = 0
    }

    private inner class SuTimer(
        private val millis: Long,
        interval: Long
    ) : CountDownTimer(millis, interval) {

        override fun onTick(remains: Long) {
            if (!grantEnabled && remains <= millis - 1000) {
                grantEnabled = true
            }
            denyText.seconds = (remains / 1000).toInt() + 1
        }

        override fun onFinish() {
            denyText.seconds = 0
            respond(DENY)
        }

    }

    inner class DenyText : TextHolder() {
        var seconds = 0
            set(value) = set(value, field, { field = it }, BR.denyText)

        override fun getText(resources: Resources): CharSequence {
            return if (seconds != 0)
                "${resources.getString(R.string.deny)} ($seconds)"
            else
                resources.getString(R.string.deny)
        }
    }

    // Invisible for accessibility services
    object EmptyAccessibilityDelegate : View.AccessibilityDelegate() {
        override fun sendAccessibilityEvent(host: View, eventType: Int) {}
        override fun performAccessibilityAction(host: View, action: Int, args: Bundle?) = true
        override fun sendAccessibilityEventUnchecked(host: View, event: AccessibilityEvent) {}
        override fun dispatchPopulateAccessibilityEvent(host: View, event: AccessibilityEvent) = true
        override fun onPopulateAccessibilityEvent(host: View, event: AccessibilityEvent) {}
        override fun onInitializeAccessibilityEvent(host: View, event: AccessibilityEvent) {}
        override fun onInitializeAccessibilityNodeInfo(host: View, info: AccessibilityNodeInfo) {}
        override fun addExtraDataToAccessibilityNodeInfo(host: View, info: AccessibilityNodeInfo, extraDataKey: String, arguments: Bundle?) {}
        override fun onRequestSendAccessibilityEvent(host: ViewGroup, child: View, event: AccessibilityEvent): Boolean = false
        override fun getAccessibilityNodeProvider(host: View): AccessibilityNodeProvider? = null
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/theme/Theme.kt`:

```kt
package com.topjohnwu.magisk.ui.theme

import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.core.Config

enum class Theme(
    val themeName: String,
    val themeRes: Int
) {

    Piplup(
        themeName = "Piplup",
        themeRes = R.style.ThemeFoundationMD2_Piplup
    ),
    PiplupAmoled(
        themeName = "AMOLED",
        themeRes = R.style.ThemeFoundationMD2_Amoled
    ),
    Rayquaza(
        themeName = "Rayquaza",
        themeRes = R.style.ThemeFoundationMD2_Rayquaza
    ),
    Zapdos(
        themeName = "Zapdos",
        themeRes = R.style.ThemeFoundationMD2_Zapdos
    ),
    Charmeleon(
        themeName = "Charmeleon",
        themeRes = R.style.ThemeFoundationMD2_Charmeleon
    ),
    Mew(
        themeName = "Mew",
        themeRes = R.style.ThemeFoundationMD2_Mew
    ),
    Salamence(
        themeName = "Salamence",
        themeRes = R.style.ThemeFoundationMD2_Salamence
    ),
    Fraxure(
        themeName = "Fraxure (Legacy)",
        themeRes = R.style.ThemeFoundationMD2_Fraxure
    );

    val isSelected get() = Config.themeOrdinal == ordinal

    companion object {
        val selected get() = values().getOrNull(Config.themeOrdinal) ?: Piplup
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/theme/ThemeFragment.kt`:

```kt
package com.topjohnwu.magisk.ui.theme

import android.os.Bundle
import android.view.ContextThemeWrapper
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.FrameLayout
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.BaseFragment
import com.topjohnwu.magisk.arch.viewModel
import com.topjohnwu.magisk.databinding.FragmentThemeMd2Binding
import com.topjohnwu.magisk.databinding.ItemThemeBindingImpl
import com.topjohnwu.magisk.core.R as CoreR

class ThemeFragment : BaseFragment<FragmentThemeMd2Binding>() {

    override val layoutRes = R.layout.fragment_theme_md2
    override val viewModel by viewModel<ThemeViewModel>()

    private fun <T> Array<T>.paired(): List<Pair<T, T?>> {
        val iterator = iterator()
        if (!iterator.hasNext()) return emptyList()
        val result = mutableListOf<Pair<T, T?>>()
        while (iterator.hasNext()) {
            val a = iterator.next()
            val b = if (iterator.hasNext()) iterator.next() else null
            result.add(a to b)
        }
        return result
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        super.onCreateView(inflater, container, savedInstanceState)

        for ((a, b) in Theme.values().paired()) {
            val c = inflater.inflate(R.layout.item_theme_container, null, false)
            val left = c.findViewById<FrameLayout>(R.id.left)
            val right = c.findViewById<FrameLayout>(R.id.right)

            for ((theme, view) in listOf(a to left, b to right)) {
                theme ?: continue
                val themed = ContextThemeWrapper(activity, theme.themeRes)
                ItemThemeBindingImpl.inflate(LayoutInflater.from(themed), view, true).also {
                    it.setVariable(BR.viewModel, viewModel)
                    it.setVariable(BR.theme, theme)
                    it.lifecycleOwner = viewLifecycleOwner
                }
            }

            binding.themeContainer.addView(c)
        }

        return binding.root
    }

    override fun onStart() {
        super.onStart()

        activity?.title = getString(CoreR.string.section_theme)
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/ui/theme/ThemeViewModel.kt`:

```kt
package com.topjohnwu.magisk.ui.theme

import com.topjohnwu.magisk.arch.BaseViewModel
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.dialog.DarkThemeDialog
import com.topjohnwu.magisk.events.RecreateEvent
import com.topjohnwu.magisk.view.TappableHeadlineItem

class ThemeViewModel : BaseViewModel(), TappableHeadlineItem.Listener {

    val themeHeadline = TappableHeadlineItem.ThemeMode

    override fun onItemPressed(item: TappableHeadlineItem) = when (item) {
        is TappableHeadlineItem.ThemeMode -> DarkThemeDialog().show()
    }

    fun saveTheme(theme: Theme) {
        if (!theme.isSelected) {
            Config.themeOrdinal = theme.ordinal
            RecreateEvent().publish()
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/utils/AccessibilityUtils.kt`:

```kt
package com.topjohnwu.magisk.utils

import android.content.ContentResolver
import android.provider.Settings

class AccessibilityUtils {
    companion object {
        fun isAnimationEnabled(cr: ContentResolver): Boolean {
            return !(Settings.Global.getFloat(cr, Settings.Global.ANIMATOR_DURATION_SCALE, 1.0f) == 0.0f
                && Settings.Global.getFloat(cr, Settings.Global.TRANSITION_ANIMATION_SCALE, 1.0f) == 0.0f
                && Settings.Global.getFloat(cr, Settings.Global.WINDOW_ANIMATION_SCALE, 1.0f) == 0.0f)
        }
    }
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/utils/MotionRevealHelper.kt`:

```kt
package com.topjohnwu.magisk.utils

import android.animation.Animator
import android.animation.AnimatorSet
import android.animation.ObjectAnimator
import android.view.View
import androidx.core.animation.addListener
import androidx.core.text.layoutDirection
import androidx.core.view.isInvisible
import androidx.core.view.isVisible
import androidx.core.view.marginBottom
import androidx.core.view.marginEnd
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import com.google.android.material.circularreveal.CircularRevealCompat
import com.google.android.material.circularreveal.CircularRevealWidget
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.topjohnwu.magisk.core.utils.LocaleSetting
import kotlin.math.hypot

object MotionRevealHelper {

    fun <CV> withViews(
        revealable: CV,
        fab: FloatingActionButton,
        expanded: Boolean
    ) where CV : CircularRevealWidget, CV : View {
        revealable.revealInfo = revealable.createRevealInfo(!expanded)

        val revealInfo = revealable.createRevealInfo(expanded)
        val revealAnim = revealable.createRevealAnim(revealInfo)
        val moveAnim = fab.createMoveAnim(revealInfo)

        AnimatorSet().also {
            if (expanded) {
                it.play(revealAnim).after(moveAnim)
            } else {
                it.play(moveAnim).after(revealAnim)
            }
        }.start()
    }

    private fun <CV> CV.createRevealAnim(
        revealInfo: CircularRevealWidget.RevealInfo
    ): Animator where CV : CircularRevealWidget, CV : View =
        CircularRevealCompat.createCircularReveal(
            this,
            revealInfo.centerX,
            revealInfo.centerY,
            revealInfo.radius
        ).apply {
            addListener(onStart = {
                isVisible = true
            }, onEnd = {
                if (revealInfo.radius == 0f) {
                    isInvisible = true
                }
            })
        }

    private fun FloatingActionButton.createMoveAnim(
        revealInfo: CircularRevealWidget.RevealInfo
    ): Animator = AnimatorSet().also {
        it.interpolator = FastOutSlowInInterpolator()
        it.addListener(onStart = { show() }, onEnd = { if (revealInfo.radius != 0f) hide() })

        val rtlMod =
            if (LocaleSetting.instance.currentLocale.layoutDirection == View.LAYOUT_DIRECTION_RTL)
                1f else -1f
        val maxX = revealInfo.centerX - marginEnd - measuredWidth / 2f
        val targetX = if (revealInfo.radius == 0f) 0f else maxX * rtlMod
        val moveX = ObjectAnimator.ofFloat(this, View.TRANSLATION_X, targetX)

        val maxY = revealInfo.centerY - marginBottom - measuredHeight / 2f
        val targetY = if (revealInfo.radius == 0f) 0f else -maxY
        val moveY = ObjectAnimator.ofFloat(this, View.TRANSLATION_Y, targetY)

        it.playTogether(moveX, moveY)
    }

    private fun View.createRevealInfo(expanded: Boolean): CircularRevealWidget.RevealInfo {
        val cX = measuredWidth / 2f
        val cY = measuredHeight / 2f - paddingBottom
        return CircularRevealWidget.RevealInfo(cX, cY, if (expanded) hypot(cX, cY) else 0f)
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/utils/TextHolder.kt`:

```kt
package com.topjohnwu.magisk.utils

import android.content.res.Resources

abstract class TextHolder {

    open val isEmpty: Boolean get() = false
    abstract fun getText(resources: Resources): CharSequence

    // ---

    class String(
        private val value: CharSequence
    ) : TextHolder() {
        override val isEmpty get() = value.isEmpty()
        override fun getText(resources: Resources) = value
    }

    open class Resource(
        protected val value: Int
    ) : TextHolder() {
        override val isEmpty get() = value == 0
        override fun getText(resources: Resources) = resources.getString(value)
    }

    class ResourceArgs(
        value: Int,
        private vararg val params: Any
    ) : Resource(value) {
        override fun getText(resources: Resources): kotlin.String {
            // Replace TextHolder with strings
            val args = params.map { if (it is TextHolder) it.getText(resources) else it }
            return resources.getString(value, *args.toTypedArray())
        }
    }

    // ---

    companion object {
        val EMPTY = String("")
    }
}

fun Int.asText(): TextHolder = TextHolder.Resource(this)
fun Int.asText(vararg params: Any): TextHolder = TextHolder.ResourceArgs(this, *params)
fun CharSequence.asText(): TextHolder = TextHolder.String(this)

```

`app/apk/src/main/java/com/topjohnwu/magisk/view/MagiskDialog.kt`:

```kt
package com.topjohnwu.magisk.view

import android.app.Activity
import android.content.DialogInterface
import android.content.res.ColorStateList
import android.graphics.drawable.Drawable
import android.graphics.drawable.InsetDrawable
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.appcompat.app.AppCompatDialog
import androidx.appcompat.content.res.AppCompatResources
import androidx.databinding.Bindable
import androidx.databinding.PropertyChangeRegistry
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.color.MaterialColors
import com.google.android.material.shape.MaterialShapeDrawable
import com.topjohnwu.magisk.BR
import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.arch.UIActivity
import com.topjohnwu.magisk.databinding.DialogMagiskBaseBinding
import com.topjohnwu.magisk.databinding.DiffItem
import com.topjohnwu.magisk.databinding.ItemWrapper
import com.topjohnwu.magisk.databinding.ObservableHost
import com.topjohnwu.magisk.databinding.RvItem
import com.topjohnwu.magisk.databinding.bindExtra
import com.topjohnwu.magisk.databinding.set
import com.topjohnwu.magisk.databinding.setAdapter
import com.topjohnwu.magisk.view.MagiskDialog.DialogClickListener

typealias DialogButtonClickListener = (DialogInterface) -> Unit

class MagiskDialog(
    context: Activity, theme: Int = 0
) : AppCompatDialog(context, theme) {

    private val binding: DialogMagiskBaseBinding =
        DialogMagiskBaseBinding.inflate(LayoutInflater.from(context))
    private val data = Data()

    val activity: UIActivity<*> get() = ownerActivity as UIActivity<*>

    init {
        binding.setVariable(BR.data, data)
        setCancelable(true)
        setOwnerActivity(context)
    }

    inner class Data : ObservableHost {
        override var callbacks: PropertyChangeRegistry? = null

        @get:Bindable
        var icon: Drawable? = null
            set(value) = set(value, field, { field = it }, BR.icon)

        @get:Bindable
        var title: CharSequence = ""
            set(value) = set(value, field, { field = it }, BR.title)

        @get:Bindable
        var message: CharSequence = ""
            set(value) = set(value, field, { field = it }, BR.message)

        val buttonPositive = ButtonViewModel()
        val buttonNeutral = ButtonViewModel()
        val buttonNegative = ButtonViewModel()
    }

    enum class ButtonType {
        POSITIVE, NEUTRAL, NEGATIVE
    }

    interface Button {
        var icon: Int
        var text: Any
        var isEnabled: Boolean
        var doNotDismiss: Boolean

        fun onClick(listener: DialogButtonClickListener)
    }

    inner class ButtonViewModel : Button, ObservableHost {
        override var callbacks: PropertyChangeRegistry? = null

        @get:Bindable
        override var icon = 0
            set(value) = set(value, field, { field = it }, BR.icon, BR.gone)

        @get:Bindable
        var message: String = ""
            set(value) = set(value, field, { field = it }, BR.message, BR.gone)

        override var text: Any
            get() = message
            set(value) {
                message = when (value) {
                    is Int -> context.getText(value)
                    else -> value
                }.toString()
            }

        @get:Bindable
        val gone get() = icon == 0 && message.isEmpty()

        @get:Bindable
        override var isEnabled = true
            set(value) = set(value, field, { field = it }, BR.enabled)

        override var doNotDismiss = false

        private var onClickAction: DialogButtonClickListener = {}

        override fun onClick(listener: DialogButtonClickListener) {
            onClickAction = listener
        }

        fun clicked() {
            onClickAction(this@MagiskDialog)
            if (!doNotDismiss) {
                dismiss()
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        super.setContentView(binding.root)

        val default = MaterialColors.getColor(context, com.google.android.material.R.attr.colorSurface, javaClass.canonicalName)
        val surfaceColor = MaterialColors.getColor(context, R.attr.colorSurfaceSurfaceVariant, default)
        val materialShapeDrawable = MaterialShapeDrawable(context, null, androidx.appcompat.R.attr.alertDialogStyle, com.google.android.material.R.style.MaterialAlertDialog_MaterialComponents)
        materialShapeDrawable.initializeElevationOverlay(context)
        materialShapeDrawable.fillColor = ColorStateList.valueOf(surfaceColor)
        materialShapeDrawable.elevation = context.resources.getDimension(R.dimen.margin_generic)
        materialShapeDrawable.setCornerSize(context.resources.getDimension(R.dimen.l_50))

        val inset = context.resources.getDimensionPixelSize(com.google.android.material.R.dimen.appcompat_dialog_background_inset)
        window?.apply {
            setBackgroundDrawable(InsetDrawable(materialShapeDrawable, inset, inset, inset, inset))
            setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        }
    }

    override fun setTitle(@StringRes titleId: Int) { data.title = context.getString(titleId) }

    override fun setTitle(title: CharSequence?) { data.title = title ?: "" }

    fun setMessage(@StringRes msgId: Int, vararg args: Any) {
        data.message = context.getString(msgId, *args)
    }

    fun setMessage(message: CharSequence) { data.message = message }

    fun setIcon(@DrawableRes drawableRes: Int) {
        data.icon = AppCompatResources.getDrawable(context, drawableRes)
    }

    fun setIcon(drawable: Drawable) { data.icon = drawable }

    fun setButton(buttonType: ButtonType, builder: Button.() -> Unit) {
        val button = when (buttonType) {
            ButtonType.POSITIVE -> data.buttonPositive
            ButtonType.NEUTRAL -> data.buttonNeutral
            ButtonType.NEGATIVE -> data.buttonNegative
        }
        button.apply(builder)
    }

    class DialogItem(
        override val item: CharSequence,
        val position: Int
    ) : RvItem(), DiffItem<DialogItem>, ItemWrapper<CharSequence> {
        override val layoutRes = R.layout.item_list_single_line
    }

    fun interface DialogClickListener {
        fun onClick(position: Int)
    }

    fun setListItems(
        list: Array<out CharSequence>,
        listener: DialogClickListener
    ) = setView(
        RecyclerView(context).also {
            it.isNestedScrollingEnabled = false
            it.layoutManager = LinearLayoutManager(context)

            val items = list.mapIndexed { i, cs -> DialogItem(cs, i) }
            val extraBindings = bindExtra { sa ->
                sa.put(BR.listener, DialogClickListener { pos ->
                    listener.onClick(pos)
                    dismiss()
                })
            }
            it.setAdapter(items, extraBindings)
        }
    )

    fun setView(view: View) {
        binding.dialogBaseContainer.removeAllViews()
        binding.dialogBaseContainer.addView(
            view,
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
        )
    }

    fun resetButtons() {
        ButtonType.values().forEach {
            setButton(it) {
                text = ""
                icon = 0
                isEnabled = true
                doNotDismiss = false
                onClick {}
            }
        }
    }

    // Prevent calling setContentView

    @Deprecated("Please use setView(view)", level = DeprecationLevel.ERROR)
    override fun setContentView(layoutResID: Int) {}
    @Deprecated("Please use setView(view)", level = DeprecationLevel.ERROR)
    override fun setContentView(view: View) {}
    @Deprecated("Please use setView(view)", level = DeprecationLevel.ERROR)
    override fun setContentView(view: View, params: ViewGroup.LayoutParams?) {}
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/view/TappableHeadlineItem.kt`:

```kt
package com.topjohnwu.magisk.view

import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.databinding.DiffItem
import com.topjohnwu.magisk.databinding.RvItem
import com.topjohnwu.magisk.core.R as CoreR

sealed class TappableHeadlineItem : RvItem(), DiffItem<TappableHeadlineItem> {

    abstract val title: Int
    abstract val icon: Int

    override val layoutRes = R.layout.item_tappable_headline

    // --- listener

    interface Listener {

        fun onItemPressed(item: TappableHeadlineItem)

    }

    // --- objects

    object ThemeMode : TappableHeadlineItem() {
        override val title = CoreR.string.settings_dark_mode_title
        override val icon = R.drawable.ic_day_night
    }

}

```

`app/apk/src/main/java/com/topjohnwu/magisk/view/TextItem.kt`:

```kt
package com.topjohnwu.magisk.view

import com.topjohnwu.magisk.R
import com.topjohnwu.magisk.databinding.DiffItem
import com.topjohnwu.magisk.databinding.ItemWrapper
import com.topjohnwu.magisk.databinding.RvItem

class TextItem(override val item: Int) : RvItem(), DiffItem<TextItem>, ItemWrapper<Int> {
    override val layoutRes = R.layout.item_text
}

```

`app/apk/src/main/java/com/topjohnwu/magisk/widget/ConcealableBottomNavigationView.java`:

```java
package com.topjohnwu.magisk.widget;

import android.animation.Animator;
import android.animation.ObjectAnimator;
import android.animation.StateListAnimator;
import android.content.Context;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.AttributeSet;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.customview.view.AbsSavedState;
import androidx.interpolator.view.animation.FastOutLinearInInterpolator;

import com.google.android.material.bottomnavigation.BottomNavigationView;
import com.topjohnwu.magisk.R;

public class ConcealableBottomNavigationView extends BottomNavigationView {

    private static final int[] STATE_SET = {
            R.attr.state_hidden
    };

    private boolean isHidden;
    public ConcealableBottomNavigationView(@NonNull Context context) {
        this(context, null);
    }

    public ConcealableBottomNavigationView(@NonNull Context context, @Nullable AttributeSet attrs) {
        this(context, attrs, com.google.android.material.R.attr.bottomNavigationStyle);
    }

    public ConcealableBottomNavigationView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        this(context, attrs, defStyleAttr, com.google.android.material.R.style.Widget_Design_BottomNavigationView);
    }

    public ConcealableBottomNavigationView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }

    private void recreateAnimator(int height) {
        Animator toHidden = ObjectAnimator.ofFloat(this, "translationY", height);
        toHidden.setDuration(175);
        toHidden.setInterpolator(new FastOutLinearInInterpolator());
        Animator toUnhidden = ObjectAnimator.ofFloat(this, "translationY", 0);
        toUnhidden.setDuration(225);
        toUnhidden.setInterpolator(new FastOutLinearInInterpolator());

        StateListAnimator animator = new StateListAnimator();

        animator.addState(STATE_SET, toHidden);
        animator.addState(new int[]{}, toUnhidden);

        setStateListAnimator(animator);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        recreateAnimator(getMeasuredHeight());
    }

    @Override
    protected int[] onCreateDrawableState(int extraSpace) {
        final int[] drawableState = super.onCreateDrawableState(extraSpace + 1);
        if (isHidden()) {
            mergeDrawableStates(drawableState, STATE_SET);
        }
        return drawableState;
    }

    public boolean isHidden() {
        return isHidden;
    }

    public void setHidden(boolean raised) {
        if (isHidden != raised) {
            isHidden = raised;
            refreshDrawableState();
        }
    }

    @NonNull
    @Override
    protected Parcelable onSaveInstanceState() {
        SavedState state = new SavedState(super.onSaveInstanceState());
        state.isHidden = isHidden();
        return state;
    }

    @Override
    protected void onRestoreInstanceState(Parcelable state) {
        final SavedState ss = (SavedState) state;
        super.onRestoreInstanceState(ss.getSuperState());

        if (ss.isHidden) {
            setHidden(isHidden);
        }
    }

    static class SavedState extends AbsSavedState {

        public boolean isHidden;

        public SavedState(Parcel source) {
            super(source, ConcealableBottomNavigationView.class.getClassLoader());
            isHidden = source.readByte() != 0;
        }

        public SavedState(Parcelable superState) {
            super(superState);
        }

        @Override
        public void writeToParcel(Parcel out, int flags) {
            super.writeToParcel(out, flags);
            out.writeByte(isHidden ? (byte) 1 : (byte) 0);
        }

        public static final Creator<SavedState> CREATOR = new Creator<>() {

            @Override
            public SavedState createFromParcel(Parcel source) {
                return new SavedState(source);
            }

            @Override
            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        };
    }
}

```

`app/apk/src/main/res/anim/fragment_enter.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <alpha
        android:duration="@android:integer/config_shortAnimTime"
        android:fromAlpha="0"
        android:toAlpha="1" />
    <scale
        android:duration="@android:integer/config_shortAnimTime"
        android:fromXScale="0.9"
        android:fromYScale="0.9"
        android:pivotX="50%p"
        android:pivotY="50%p"
        android:toXScale="1"
        android:toYScale="1" />
</set>
```

`app/apk/src/main/res/anim/fragment_enter_pop.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <alpha
        android:duration="@android:integer/config_shortAnimTime"
        android:fromAlpha="0"
        android:toAlpha="1" />
    <scale
        android:duration="@android:integer/config_shortAnimTime"
        android:fromXScale="1.1"
        android:fromYScale="1.1"
        android:pivotX="50%p"
        android:pivotY="50%p"
        android:toXScale="1"
        android:toYScale="1" />
</set>
```

`app/apk/src/main/res/anim/fragment_exit.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <alpha
        android:duration="@android:integer/config_shortAnimTime"
        android:fromAlpha="1"
        android:toAlpha="0" />
    <scale
        android:duration="@android:integer/config_shortAnimTime"
        android:fromXScale="1"
        android:fromYScale="1"
        android:pivotX="50%p"
        android:pivotY="50%p"
        android:toXScale="1.1"
        android:toYScale="1.1" />
</set>
```

`app/apk/src/main/res/anim/fragment_exit_pop.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <alpha
        android:duration="@android:integer/config_shortAnimTime"
        android:fromAlpha="1"
        android:toAlpha="0" />
    <scale
        android:duration="@android:integer/config_shortAnimTime"
        android:fromXScale="1"
        android:fromYScale="1"
        android:pivotX="50%p"
        android:pivotY="50%p"
        android:toXScale="0.9"
        android:toYScale="0.9" />
</set>
```

`app/apk/src/main/res/color/color_card_background_color_selector.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:color="?colorSurfaceVariant" android:state_enabled="true" />
    <item android:alpha="0.68" android:color="?colorSurfaceVariant" />
</selector>

```

`app/apk/src/main/res/color/color_error_transient.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:color="?colorDisabled" android:state_enabled="false" />
    <item android:color="?colorError" />
</selector>
```

`app/apk/src/main/res/color/color_menu_tint.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:color="?colorDisabledVariant" android:state_enabled="false" />
    <item android:color="?colorSecondary" android:state_checked="true" />
    <item android:color="?colorOnSurfaceVariant" />
</selector>
```

`app/apk/src/main/res/color/color_on_primary_transient.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:color="?colorDisabled" android:state_enabled="false" />
    <item android:color="?colorOnPrimary" />
</selector>
```

`app/apk/src/main/res/color/color_primary_error_transient.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:color="?colorError" android:state_selected="true" />
    <item android:color="?colorDisabled" android:state_enabled="false" />
    <item android:color="?colorPrimary" />
</selector>
```

`app/apk/src/main/res/color/color_primary_transient.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:color="?colorDisabled" android:state_enabled="false" />
    <item android:color="?colorPrimary" />
</selector>
```

`app/apk/src/main/res/color/color_state_primary_transient.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:color="?colorPrimary" android:state_selected="true" />
    <item android:color="?colorPrimary" android:state_checked="true" />
    <item android:color="?colorDisabled" android:state_enabled="false" />
    <item android:color="?colorOnSurfaceVariant" />
</selector>
```

`app/apk/src/main/res/color/color_text_transient.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:color="?colorDisabled" android:state_enabled="false" />
    <item android:color="?colorOnSurface" />
</selector>
```

`app/apk/src/main/res/drawable/avd_bug_from_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="path_1"
                android:fillColor="#000000"
                android:fillType="evenOdd"
                android:pathData="M 20 8 L 17.19 8 C 16.74 7.22 16.12 6.55 15.37 6.04 L 17 4.41 L 15.59 3 L 13.42 5.17 C 12.96 5.06 12.49 5 12 5 C 11.51 5 11.04 5.06 10.59 5.17 L 8.41 3 L 7 4.41 L 8.62 6.04 C 7.88 6.55 7.26 7.22 6.81 8 L 4 8 L 4 10 L 6.09 10 C 6.04 10.33 6 10.66 6 11 L 6 12 L 4 12 L 4 14 L 6 14 L 6 15 C 6 15.34 6.04 15.67 6.09 16 L 4 16 L 4 18 L 6.81 18 C 7.85 19.79 9.78 21 12 21 C 14.22 21 16.15 19.79 17.19 18 L 20 18 L 20 16 L 17.91 16 C 17.96 15.67 18 15.34 18 15 L 18 14 L 20 14 L 20 12 L 18 12 L 18 11 C 18 10.66 17.96 10.33 17.91 10 L 20 10 L 20 8 Z M 14 16 L 10 16 L 10 14 L 14 14 L 14 16 Z M 14 12 L 10 12 L 10 10 L 14 10 L 14 12 Z" />
        </vector>
    </aapt:attr>
    <target android:name="path_1">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="300"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 20 8 L 20 8 L 17.19 8 C 16.74 7.22 16.12 6.55 15.37 6.04 L 17 4.41 L 15.59 3 L 13.42 5.17 C 12.96 5.06 12.49 5 12 5 C 11.51 5 11.04 5.06 10.59 5.17 L 8.41 3 L 7 4.41 L 8.62 6.04 C 7.88 6.55 7.26 7.22 6.81 8 L 4 8 L 4 10 L 6.09 10 C 6.04 10.33 6 10.66 6 11 L 6 12 L 4 12 L 4 14 L 6 14 L 6 15 C 6 15.34 6.04 15.67 6.09 16 L 4 16 L 4 18 L 6.81 18 C 7.85 19.79 9.78 21 12 21 C 14.22 21 16.15 19.79 17.19 18 L 20 18 L 20 16 L 17.91 16 C 17.96 15.67 18 15.34 18 15 L 18 14 L 20 14 L 20 12 L 18 12 L 18 11 C 18 10.66 17.96 10.33 17.91 10 L 20 10 L 20 8 M 14 16 C 14 15.43 14 14.859 14 14.289 L 14 14 C 13.869 14 13.739 14 13.608 14 C 12.405 14 11.203 14 10 14 C 10 14.509 10 15.017 10 15.526 C 10 15.684 10 15.842 10 16 L 10.33 16 C 10.392 16 10.454 16 10.515 16 C 11.677 16 12.838 16 14 16 C 14 16 14 16 14 16 M 14 10 L 14 12 L 14 12 L 10 12 L 10 10 L 14 10 M 12 15 L 12 15 L 12 15 L 12 15 L 12 15 L 12 15"
                android:valueTo="M 20 8 L 18.595 8 L 17.19 8 C 16.74 7.2 16.12 6.5 15.37 6 L 17 4.41 L 15.59 3 L 13.42 5.17 C 12.96 5.06 12.5 5 12 5 C 11.5 5 11.05 5.06 10.59 5.17 L 8.41 3 L 7 4.41 L 8.62 6 C 7.87 6.5 7.26 7.21 6.81 8 L 4 8 L 4 10 L 6.09 10 C 6.03 10.33 6 10.66 6 11 L 6 12 L 4 12 L 4 14 L 6 14 L 6 15 C 6 15.34 6.03 15.67 6.09 16 L 4 16 L 4 18 L 6.81 18 C 8.47 20.87 12.14 21.84 15 20.18 C 15.91 19.66 16.67 18.9 17.19 18 L 20 18 L 20 16 L 17.91 16 C 17.97 15.67 18 15.34 18 15 L 18 14 L 20 14 L 20 12 L 18 12 L 18 11 C 18 10.66 17.97 10.33 17.91 10 L 20 10 L 20 8 M 14.828 17.828 C 15.578 17.079 16 16.06 16 15 L 16 11 C 16 9.94 15.578 8.921 14.828 8.172 C 14.079 7.422 13.06 7 12 7 C 10.94 7 9.921 7.422 9.172 8.172 C 8.422 8.921 8 9.94 8 11 L 8 15 C 8 16.06 8.422 17.079 9.172 17.828 C 9.921 18.578 10.94 19 12 19 C 13.06 19 14.079 18.578 14.828 17.828 M 14 10 L 14 11 L 14 12 L 10 12 L 10 10 L 14 10 M 10 14 L 14 14 L 14 16 L 10 16 L 10 14 L 10 14"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/avd_bug_to_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="path_1"
                android:fillColor="#000000"
                android:fillType="evenOdd"
                android:pathData="M 20 8 L 18.595 8 L 17.19 8 C 16.74 7.2 16.12 6.5 15.37 6 L 17 4.41 L 15.59 3 L 13.42 5.17 C 12.96 5.06 12.5 5 12 5 C 11.5 5 11.05 5.06 10.59 5.17 L 8.41 3 L 7 4.41 L 8.62 6 C 7.87 6.5 7.26 7.21 6.81 8 L 4 8 L 4 10 L 6.09 10 C 6.03 10.33 6 10.66 6 11 L 6 12 L 4 12 L 4 14 L 6 14 L 6 15 C 6 15.34 6.03 15.67 6.09 16 L 4 16 L 4 18 L 6.81 18 C 8.47 20.87 12.14 21.84 15 20.18 C 15.91 19.66 16.67 18.9 17.19 18 L 20 18 L 20 16 L 17.91 16 C 17.97 15.67 18 15.34 18 15 L 18 14 L 20 14 L 20 12 L 18 12 L 18 11 C 18 10.66 17.97 10.33 17.91 10 L 20 10 L 20 8 M 14.828 17.828 C 15.578 17.079 16 16.06 16 15 L 16 11 C 16 9.94 15.578 8.921 14.828 8.172 C 14.079 7.422 13.06 7 12 7 C 10.94 7 9.921 7.422 9.172 8.172 C 8.422 8.921 8 9.94 8 11 L 8 15 C 8 16.06 8.422 17.079 9.172 17.828 C 9.921 18.578 10.94 19 12 19 C 13.06 19 14.079 18.578 14.828 17.828 M 14 10 L 14 11 L 14 12 L 10 12 L 10 10 L 14 10 M 10 14 L 14 14 L 14 16 L 10 16 L 10 14 L 10 14" />
        </vector>
    </aapt:attr>
    <target android:name="path_1">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="300"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 20 8 L 18.595 8 L 17.19 8 C 16.74 7.2 16.12 6.5 15.37 6 L 17 4.41 L 15.59 3 L 13.42 5.17 C 12.96 5.06 12.5 5 12 5 C 11.5 5 11.05 5.06 10.59 5.17 L 8.41 3 L 7 4.41 L 8.62 6 C 7.87 6.5 7.26 7.21 6.81 8 L 4 8 L 4 10 L 6.09 10 C 6.03 10.33 6 10.66 6 11 L 6 12 L 4 12 L 4 14 L 6 14 L 6 15 C 6 15.34 6.03 15.67 6.09 16 L 4 16 L 4 18 L 6.81 18 C 8.47 20.87 12.14 21.84 15 20.18 C 15.91 19.66 16.67 18.9 17.19 18 L 20 18 L 20 16 L 17.91 16 C 17.97 15.67 18 15.34 18 15 L 18 14 L 20 14 L 20 12 L 18 12 L 18 11 C 18 10.66 17.97 10.33 17.91 10 L 20 10 L 20 8 M 14.828 17.828 C 15.578 17.079 16 16.06 16 15 L 16 11 C 16 9.94 15.578 8.921 14.828 8.172 C 14.079 7.422 13.06 7 12 7 C 10.94 7 9.921 7.422 9.172 8.172 C 8.422 8.921 8 9.94 8 11 L 8 15 C 8 16.06 8.422 17.079 9.172 17.828 C 9.921 18.578 10.94 19 12 19 C 13.06 19 14.079 18.578 14.828 17.828 M 14 10 L 14 11 L 14 12 L 10 12 L 10 10 L 14 10 M 10 14 L 14 14 L 14 16 L 10 16 L 10 14 L 10 14"
                android:valueTo="M 20 8 L 20 8 L 17.19 8 C 16.74 7.22 16.12 6.55 15.37 6.04 L 17 4.41 L 15.59 3 L 13.42 5.17 C 12.96 5.06 12.49 5 12 5 C 11.51 5 11.04 5.06 10.59 5.17 L 8.41 3 L 7 4.41 L 8.62 6.04 C 7.88 6.55 7.26 7.22 6.81 8 L 4 8 L 4 10 L 6.09 10 C 6.04 10.33 6 10.66 6 11 L 6 12 L 4 12 L 4 14 L 6 14 L 6 15 C 6 15.34 6.04 15.67 6.09 16 L 4 16 L 4 18 L 6.81 18 C 7.85 19.79 9.78 21 12 21 C 14.22 21 16.15 19.79 17.19 18 L 20 18 L 20 16 L 17.91 16 C 17.96 15.67 18 15.34 18 15 L 18 14 L 20 14 L 20 12 L 18 12 L 18 11 C 18 10.66 17.96 10.33 17.91 10 L 20 10 L 20 8 M 14 16 C 14 15.43 14 14.859 14 14.289 L 14 14 C 13.869 14 13.739 14 13.608 14 C 12.405 14 11.203 14 10 14 C 10 14.509 10 15.017 10 15.526 C 10 15.684 10 15.842 10 16 L 10.33 16 C 10.392 16 10.454 16 10.515 16 C 11.677 16 12.838 16 14 16 C 14 16 14 16 14 16 M 14 10 L 14 12 L 14 12 L 10 12 L 10 10 L 14 10 M 12 15 L 12 15 L 12 15 L 12 15 L 12 15 L 12 15"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/avd_circle_check_from_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="path"
                android:fillColor="#000000"
                android:pathData="M 12 2 C 6.5 2 2 6.5 2 12 C 2 17.5 6.5 22 12 22 C 17.5 22 22 17.5 22 12 C 22 6.5 17.5 2 12 2 M 12 20 C 7.59 20 4 16.41 4 12 C 4 7.59 7.59 4 12 4 C 16.41 4 20 7.59 20 12 C 20 16.41 16.41 20 12 20 M 16.59 7.58 L 10 14.17 L 7.41 11.59 L 6 13 L 10 17 L 18 9 L 16.59 7.58 Z" />
        </vector>
    </aapt:attr>
    <target android:name="path">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="500"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 12 2 C 9.217 2 6.689 3.152 4.872 5.004 C 3.098 6.811 2 9.283 2 12 C 2 14.744 3.12 17.24 4.927 19.052 C 6.74 20.87 9.244 22 12 22 C 13.911 22 15.701 21.457 17.224 20.517 C 18.628 19.651 19.804 18.448 20.638 17.024 C 21.503 15.545 22 13.828 22 12 C 22 10.2 21.518 8.507 20.677 7.044 C 19.755 5.441 18.402 4.114 16.779 3.224 C 15.357 2.444 13.728 2 12 2 M 12 20 C 7.59 20 4 16.41 4 12 C 4 7.59 7.59 4 12 4 C 16.41 4 20 7.59 20 12 C 20 16.41 16.41 20 12 20 M 6 13 L 10 17 L 18 9 L 16.59 7.58 L 16.59 7.58 L 10 14.17 L 7.41 11.59 L 6 13"
                android:valueTo="M 12 2 C 9.349 2 6.804 3.054 4.929 4.929 C 3.054 6.804 2 9.349 2 12 C 2 14.651 3.054 17.196 4.929 19.071 C 6.804 20.946 9.349 22 12 22 C 13.755 22 15.48 21.538 17 20.66 C 18.52 19.783 19.783 18.52 20.66 17 C 21.538 15.48 22 13.755 22 12 C 22 10.245 21.538 8.52 20.66 7 C 19.783 5.48 18.52 4.217 17 3.34 C 15.48 2.462 13.755 2 12 2 M 12 20 C 7.59 20 4 16.41 4 12 C 4 7.59 7.59 4 12 4 C 16.41 4 20 7.59 20 12 C 20 16.41 16.41 20 12 20 M 7 13 L 7 13 L 17 13 L 17 11 L 17 11 L 7 11 L 7 11 L 7 11"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/avd_circle_check_to_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="path_1"
                android:fillColor="#000000"
                android:pathData="M 12 20 C 7.59 20 4 16.41 4 12 C 4 7.59 7.59 4 12 4 C 16.41 4 20 7.59 20 12 C 20 16.41 16.41 20 12 20 M 12 2 C 9.349 2 6.804 3.054 4.929 4.929 C 3.054 6.804 2 9.349 2 12 C 2 14.651 3.054 17.196 4.929 19.071 C 6.804 20.946 9.349 22 12 22 C 13.755 22 15.48 21.538 17 20.66 C 18.52 19.783 19.783 18.52 20.66 17 C 21.538 15.48 22 13.755 22 12 C 22 10.245 21.538 8.52 20.66 7 C 19.783 5.48 18.52 4.217 17 3.34 C 15.48 2.462 13.755 2 12 2 M 7 13 L 17 13 L 17 11 L 7 11" />
        </vector>
    </aapt:attr>
    <target android:name="path_1">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="500"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 12 2 C 9.349 2 6.804 3.054 4.929 4.929 C 3.054 6.804 2 9.349 2 12 C 2 14.651 3.054 17.196 4.929 19.071 C 6.804 20.946 9.349 22 12 22 C 13.755 22 15.48 21.538 17 20.66 C 18.52 19.783 19.783 18.52 20.66 17 C 21.538 15.48 22 13.755 22 12 C 22 10.245 21.538 8.52 20.66 7 C 19.783 5.48 18.52 4.217 17 3.34 C 15.48 2.462 13.755 2 12 2 M 12 20 C 7.59 20 4 16.41 4 12 C 4 7.59 7.59 4 12 4 C 16.41 4 20 7.59 20 12 C 20 16.41 16.41 20 12 20 M 7 13 L 7 13 L 17 13 L 17 11 L 17 11 L 7 11 L 7 11 L 7 11"
                android:valueTo="M 12 2 C 9.217 2 6.689 3.152 4.872 5.004 C 3.098 6.811 2 9.283 2 12 C 2 14.856 3.213 17.442 5.149 19.268 C 6.942 20.96 9.356 22 12 22 C 14.061 22 15.982 21.368 17.578 20.288 C 19.114 19.249 20.349 17.796 21.119 16.092 C 21.685 14.841 22 13.456 22 12 C 22 10.122 21.475 8.361 20.566 6.856 C 19.691 5.408 18.46 4.197 16.997 3.347 C 15.524 2.491 13.817 2 12 2 M 12 20 C 7.59 20 4 16.41 4 12 C 4 7.59 7.59 4 12 4 C 16.41 4 20 7.59 20 12 C 20 16.41 16.41 20 12 20 M 6 13 L 10 17 L 18 9 L 16.59 7.58 L 16.59 7.58 L 10 14.17 L 7.41 11.59 L 6 13"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/avd_home_from_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="path_3"
                android:fillColor="#000"
                android:fillType="evenOdd"
                android:pathData="M 12 3 L 20 9 L 20 21 L 15 21 L 15 14 L 9 14 L 9 21 L 4 21 L 4 9 L 12 3 Z"
                android:strokeWidth="1" />
        </vector>
    </aapt:attr>
    <target android:name="path_3">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="300"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 9 14 L 9 21 L 4 21 L 4 9 L 12 3 L 12 3 L 20 9 L 20 21 L 15 21 L 15 14 L 9 14 M 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4"
                android:valueTo="M 9 13 L 9 19 L 6 19 L 6 10 L 12 5.5 L 15 7.75 L 18 10 L 18 19 L 15 19 L 15 13 L 9 13 M 4 21 L 4 9 L 12 3 L 20 9 L 20 21 L 4 21 L 4 21"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/avd_home_to_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="path_3"
                android:fillColor="#000"
                android:fillType="evenOdd"
                android:pathData="M 9 13 L 9 19 L 6 19 L 6 10 L 12 5.5 L 15 7.75 L 18 10 L 18 19 L 15 19 L 15 13 L 9 13 M 4 21 L 4 9 L 12 3 L 20 9 L 20 21 L 4 21 L 4 21"
                android:strokeWidth="1" />
        </vector>
    </aapt:attr>
    <target android:name="path_3">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="300"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 9 13 L 9 19 L 6 19 L 6 10 L 12 5.5 L 15 7.75 L 18 10 L 18 19 L 15 19 L 15 13 L 9 13 M 4 21 L 4 9 L 12 3 L 20 9 L 20 21 L 4 21 L 4 21"
                android:valueTo="M 9 14 L 9 21 L 4 21 L 4 9 L 12 3 L 12 3 L 20 9 L 20 21 L 15 21 L 15 14 L 9 14 M 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/avd_module_from_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="outlined"
                android:fillColor="#000000"
                android:fillType="evenOdd"
                android:pathData="M 23 13.5 C 23 14.163 22.736 14.799 22.268 15.268 C 21.799 15.736 21.163 16 20.5 16 C 20 16 19.5 16 19 16 L 19 20 C 19 20.53 18.789 21.039 18.414 21.414 C 18.039 21.789 17.53 22 17 22 L 15.1 22 L 13.2 22 C 13.2 21.5 13.2 21 13.2 20.5 C 13.2 19 12 17.8 10.5 17.8 C 9 17.8 7.8 19 7.8 20.5 L 7.8 22 L 4 22 C 3.47 22 2.961 21.789 2.586 21.414 C 2.211 21.039 2 20.53 2 20 L 2 16.2 L 3.5 16.2 C 5 16.2 6.2 15 6.2 13.5 C 6.2 12 5 10.8 3.5 10.8 L 2 10.8 L 2 7 C 2 6.47 2.211 5.961 2.586 5.586 C 2.961 5.211 3.47 5 4 5 L 8 5 C 8 4.5 8 4 8 3.5 C 8 2.837 8.264 2.201 8.732 1.732 C 9.201 1.264 9.837 1 10.5 1 C 11.163 1 11.799 1.264 12.268 1.732 C 12.736 2.201 13 2.837 13 3.5 C 13 4 13 4.5 13 5 L 17 5 C 17.55 5 18.05 5.223 18.413 5.584 C 18.775 5.945 19 6.445 19 7 L 19 11 C 19.5 11 20 11 20.5 11 C 20.5 11 20.5 11 20.5 11 C 21.163 11 21.799 11.264 22.268 11.732 C 22.736 12.201 23 12.837 23 13.5 M 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12" />
        </vector>
    </aapt:attr>
    <target android:name="outlined">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="300"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 23 13.5 C 23 14.163 22.736 14.799 22.268 15.268 C 21.799 15.736 21.163 16 20.5 16 C 20 16 19.5 16 19 16 L 19 20 C 19 20.53 18.789 21.039 18.414 21.414 C 18.039 21.789 17.53 22 17 22 L 15.1 22 L 13.2 22 C 13.2 21.5 13.2 21 13.2 20.5 C 13.2 19 12 17.8 10.5 17.8 C 9 17.8 7.8 19 7.8 20.5 L 7.8 22 L 4 22 C 3.47 22 2.961 21.789 2.586 21.414 C 2.211 21.039 2 20.53 2 20 L 2 16.2 L 3.5 16.2 C 5 16.2 6.2 15 6.2 13.5 C 6.2 12 5 10.8 3.5 10.8 L 2 10.8 L 2 7 C 2 6.47 2.211 5.961 2.586 5.586 C 2.961 5.211 3.47 5 4 5 L 8 5 C 8 4.5 8 4 8 3.5 C 8 2.837 8.264 2.201 8.732 1.732 C 9.201 1.264 9.837 1 10.5 1 C 11.163 1 11.799 1.264 12.268 1.732 C 12.736 2.201 13 2.837 13 3.5 C 13 4 13 4.5 13 5 L 17 5 C 17.55 5 18.05 5.223 18.413 5.584 C 18.775 5.945 19 6.445 19 7 L 19 11 C 19.5 11 20 11 20.5 11 C 20.5 11 20.5 11 20.5 11 C 21.163 11 21.799 11.264 22.268 11.732 C 22.736 12.201 23 12.837 23 13.5 M 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12"
                android:valueTo="M 22 13.5 C 22 14.087 21.856 14.64 21.6 15.126 C 21.344 15.612 20.978 16.03 20.533 16.347 C 20.089 16.664 19.567 16.88 19 16.96 L 19 20 C 19 20.53 18.789 21.039 18.414 21.414 C 18.039 21.789 17.53 22 17 22 L 13.2 22 L 13.2 21.7 C 13.2 20.984 12.915 20.297 12.409 19.791 C 11.903 19.285 11.216 19 10.5 19 C 9 19 7.8 20.21 7.8 21.7 L 7.8 22 L 4 22 C 3.47 22 2.961 21.789 2.586 21.414 C 2.211 21.039 2 20.53 2 20 L 2 16.2 L 2.3 16.2 C 3.79 16.2 5 15 5 13.5 C 5 12 3.79 10.8 2.3 10.8 L 2 10.8 L 2 7 C 2 6.47 2.211 5.961 2.586 5.586 C 2.961 5.211 3.47 5 4 5 L 7.04 5 C 7.12 4.433 7.336 3.911 7.653 3.467 C 7.97 3.022 8.388 2.656 8.874 2.4 C 9.36 2.144 9.913 2 10.5 2 C 11.087 2 11.64 2.144 12.126 2.4 C 12.612 2.656 13.03 3.022 13.347 3.467 C 13.664 3.911 13.88 4.433 13.96 5 L 17 5 C 17.53 5 18.039 5.211 18.414 5.586 C 18.789 5.961 19 6.47 19 7 L 19 10.04 C 19.425 10.1 19.825 10.236 20.186 10.434 C 20.547 10.633 20.869 10.893 21.137 11.2 C 21.406 11.508 21.622 11.863 21.77 12.251 C 21.919 12.639 22 13.06 22 13.5 M 17 12 L 18.5 12 C 18.898 12 19.279 12.158 19.561 12.439 C 19.842 12.721 20 13.102 20 13.5 C 20 13.898 19.842 14.279 19.561 14.561 C 19.279 14.842 18.898 15 18.5 15 L 17 15 L 17 15 L 17 20 L 14.88 20 C 14.2 18.25 12.5 17 10.5 17 C 8.5 17 6.8 18.25 6.12 20 L 4 20 L 4 17.88 C 5.75 17.2 7 15.5 7 13.5 C 7 11.5 5.76 9.8 4 9.12 L 4 7 L 9 7 L 9 5.5 C 9 5.102 9.158 4.721 9.439 4.439 C 9.721 4.158 10.102 4 10.5 4 C 10.898 4 11.279 4.158 11.561 4.439 C 11.842 4.721 12 5.102 12 5.5 L 12 7 L 17 7 L 17 12"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/avd_module_to_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="outlined"
                android:fillColor="#000000"
                android:fillType="evenOdd"
                android:pathData="M 22 13.5 C 22 15.26 20.7 16.72 19 16.96 L 19 20 C 19 20.53 18.789 21.039 18.414 21.414 C 18.039 21.789 17.53 22 17 22 L 13.2 22 L 13.2 21.7 C 13.2 20.984 12.915 20.297 12.409 19.791 C 11.903 19.285 11.216 19 10.5 19 C 9 19 7.8 20.21 7.8 21.7 L 7.8 22 L 4 22 C 3.47 22 2.961 21.789 2.586 21.414 C 2.211 21.039 2 20.53 2 20 L 2 16.2 L 2.3 16.2 C 3.79 16.2 5 15 5 13.5 C 5 12 3.79 10.8 2.3 10.8 L 2 10.8 L 2 7 C 2 6.47 2.211 5.961 2.586 5.586 C 2.961 5.211 3.47 5 4 5 L 7.04 5 C 7.28 3.3 8.74 2 10.5 2 C 12.26 2 13.72 3.3 13.96 5 L 17 5 C 17.53 5 18.039 5.211 18.414 5.586 C 18.789 5.961 19 6.47 19 7 L 19 10.04 C 20.7 10.28 22 11.74 22 13.5 M 17 15 L 18.5 15 C 18.898 15 19.279 14.842 19.561 14.561 C 19.842 14.279 20 13.898 20 13.5 C 20 13.102 19.842 12.721 19.561 12.439 C 19.279 12.158 18.898 12 18.5 12 L 17 12 L 17 7 L 12 7 L 12 5.5 C 12 5.102 11.842 4.721 11.561 4.439 C 11.279 4.158 10.898 4 10.5 4 C 10.102 4 9.721 4.158 9.439 4.439 C 9.158 4.721 9 5.102 9 5.5 L 9 7 L 4 7 L 4 9.12 C 5.76 9.8 7 11.5 7 13.5 C 7 15.5 5.75 17.2 4 17.88 L 4 20 L 6.12 20 C 6.8 18.25 8.5 17 10.5 17 C 12.5 17 14.2 18.25 14.88 20 L 17 20 L 17 15 Z" />
        </vector>
    </aapt:attr>
    <target android:name="outlined">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="300"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 22 13.5 C 22 14.087 21.856 14.64 21.6 15.126 C 21.344 15.612 20.978 16.03 20.533 16.347 C 20.089 16.664 19.567 16.88 19 16.96 L 19 20 C 19 20.53 18.789 21.039 18.414 21.414 C 18.039 21.789 17.53 22 17 22 L 13.2 22 L 13.2 21.7 C 13.2 20.984 12.915 20.297 12.409 19.791 C 11.903 19.285 11.216 19 10.5 19 C 9 19 7.8 20.21 7.8 21.7 L 7.8 22 L 4 22 C 3.47 22 2.961 21.789 2.586 21.414 C 2.211 21.039 2 20.53 2 20 L 2 16.2 L 2.3 16.2 C 3.79 16.2 5 15 5 13.5 C 5 12 3.79 10.8 2.3 10.8 L 2 10.8 L 2 7 C 2 6.47 2.211 5.961 2.586 5.586 C 2.961 5.211 3.47 5 4 5 L 7.04 5 C 7.12 4.433 7.336 3.911 7.653 3.467 C 7.97 3.022 8.388 2.656 8.874 2.4 C 9.36 2.144 9.913 2 10.5 2 C 11.087 2 11.64 2.144 12.126 2.4 C 12.612 2.656 13.03 3.022 13.347 3.467 C 13.664 3.911 13.88 4.433 13.96 5 L 17 5 C 17.53 5 18.039 5.211 18.414 5.586 C 18.789 5.961 19 6.47 19 7 L 19 10.04 C 19.425 10.1 19.825 10.236 20.186 10.434 C 20.547 10.633 20.869 10.893 21.137 11.2 C 21.406 11.508 21.622 11.863 21.77 12.251 C 21.919 12.639 22 13.06 22 13.5 M 17 12 L 18.5 12 C 18.898 12 19.279 12.158 19.561 12.439 C 19.842 12.721 20 13.102 20 13.5 C 20 13.898 19.842 14.279 19.561 14.561 C 19.279 14.842 18.898 15 18.5 15 L 17 15 L 17 15 L 17 20 L 14.88 20 C 14.2 18.25 12.5 17 10.5 17 C 8.5 17 6.8 18.25 6.12 20 L 4 20 L 4 17.88 C 5.75 17.2 7 15.5 7 13.5 C 7 11.5 5.76 9.8 4 9.12 L 4 7 L 9 7 L 9 5.5 C 9 5.102 9.158 4.721 9.439 4.439 C 9.721 4.158 10.102 4 10.5 4 C 10.898 4 11.279 4.158 11.561 4.439 C 11.842 4.721 12 5.102 12 5.5 L 12 7 L 17 7 L 17 12"
                android:valueTo="M 23 13.5 C 23 14.163 22.736 14.799 22.268 15.268 C 21.799 15.736 21.163 16 20.5 16 C 20 16 19.5 16 19 16 L 19 20 C 19 20.53 18.789 21.039 18.414 21.414 C 18.039 21.789 17.53 22 17 22 L 15.1 22 L 13.2 22 C 13.2 21.5 13.2 21 13.2 20.5 C 13.2 19 12 17.8 10.5 17.8 C 9 17.8 7.8 19 7.8 20.5 L 7.8 22 L 4 22 C 3.47 22 2.961 21.789 2.586 21.414 C 2.211 21.039 2 20.53 2 20 L 2 16.2 L 3.5 16.2 C 5 16.2 6.2 15 6.2 13.5 C 6.2 12 5 10.8 3.5 10.8 L 2 10.8 L 2 7 C 2 6.47 2.211 5.961 2.586 5.586 C 2.961 5.211 3.47 5 4 5 L 8 5 C 8 4.5 8 4 8 3.5 C 8 2.837 8.264 2.201 8.732 1.732 C 9.201 1.264 9.837 1 10.5 1 C 11.163 1 11.799 1.264 12.268 1.732 C 12.736 2.201 13 2.837 13 3.5 C 13 4 13 4.5 13 5 L 17 5 C 17.55 5 18.05 5.223 18.413 5.584 C 18.775 5.945 19 6.445 19 7 L 19 11 C 19.5 11 20 11 20.5 11 C 20.5 11 20.5 11 20.5 11 C 21.163 11 21.799 11.264 22.268 11.732 C 22.736 12.201 23 12.837 23 13.5 M 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/avd_settings_from_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="path"
                android:fillColor="#000000"
                android:fillType="evenOdd"
                android:pathData="M 12 15.5 C 11.072 15.5 10.181 15.131 9.525 14.475 C 8.869 13.819 8.5 12.928 8.5 12 C 8.5 11.072 8.869 10.181 9.525 9.525 C 10.181 8.869 11.072 8.5 12 8.5 C 12.614 8.5 13.218 8.662 13.75 8.969 C 14.282 9.276 14.724 9.718 15.031 10.25 C 15.338 10.782 15.5 11.386 15.5 12 C 15.5 12.614 15.338 13.218 15.031 13.75 C 14.724 14.282 14.282 14.724 13.75 15.031 C 13.218 15.338 12.614 15.5 12 15.5 M 19.43 12.97 C 19.47 12.65 19.5 12.33 19.5 12 C 19.5 11.67 19.47 11.34 19.43 11 L 21.54 9.37 C 21.73 9.22 21.78 8.95 21.66 8.73 L 19.66 5.27 C 19.54 5.05 19.27 4.96 19.05 5.05 L 16.56 6.05 C 16.04 5.66 15.5 5.32 14.87 5.07 L 14.5 2.42 C 14.46 2.18 14.25 2 14 2 L 10 2 C 9.75 2 9.54 2.18 9.5 2.42 L 9.13 5.07 C 8.5 5.32 7.96 5.66 7.44 6.05 L 4.95 5.05 C 4.73 4.96 4.46 5.05 4.34 5.27 L 2.34 8.73 C 2.21 8.95 2.27 9.22 2.46 9.37 L 4.57 11 C 4.53 11.34 4.5 11.67 4.5 12 C 4.5 12.33 4.53 12.65 4.57 12.97 L 2.46 14.63 C 2.27 14.78 2.21 15.05 2.34 15.27 L 4.34 18.73 C 4.46 18.95 4.73 19.03 4.95 18.95 L 7.44 17.94 C 7.96 18.34 8.5 18.68 9.13 18.93 L 9.5 21.58 C 9.54 21.82 9.75 22 10 22 L 14 22 C 14.25 22 14.46 21.82 14.5 21.58 L 14.87 18.93 C 15.5 18.67 16.04 18.34 16.56 17.94 L 19.05 18.95 C 19.27 19.03 19.54 18.95 19.66 18.73 L 21.66 15.27 C 21.78 15.05 21.73 14.78 21.54 14.63 L 19.43 12.97 Z" />
        </vector>
    </aapt:attr>
    <target android:name="path">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="300"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 14.87 5.07 L 14.5 2.42 C 14.46 2.18 14.25 2 14 2 L 10 2 C 9.75 2 9.54 2.18 9.5 2.42 L 9.13 5.07 C 8.5 5.32 7.96 5.66 7.44 6.05 L 4.95 5.05 C 4.73 4.96 4.46 5.05 4.34 5.27 L 2.34 8.73 C 2.21 8.95 2.27 9.22 2.46 9.37 L 4.57 11 C 4.53 11.34 4.5 11.67 4.5 12 C 4.5 12.33 4.53 12.65 4.57 12.97 L 2.46 14.63 C 2.27 14.78 2.21 15.05 2.34 15.27 L 4.34 18.73 C 4.46 18.95 4.73 19.03 4.95 18.95 L 7.44 17.94 C 7.96 18.34 8.5 18.68 9.13 18.93 L 9.5 21.58 C 9.54 21.82 9.75 22 10 22 L 14 22 C 14.25 22 14.46 21.82 14.5 21.58 L 14.87 18.93 C 15.5 18.67 16.04 18.34 16.56 17.94 L 19.05 18.95 C 19.27 19.03 19.54 18.95 19.66 18.73 L 21.66 15.27 C 21.78 15.05 21.73 14.78 21.54 14.63 L 19.43 12.97 L 19.43 12.97 C 19.47 12.65 19.5 12.33 19.5 12 C 19.5 11.67 19.47 11.34 19.43 11 L 21.54 9.37 C 21.73 9.22 21.78 8.95 21.66 8.73 L 19.66 5.27 C 19.54 5.05 19.27 4.96 19.05 5.05 L 16.56 6.05 C 16.04 5.66 15.5 5.32 14.87 5.07 M 12 8.5 C 12.614 8.5 13.218 8.662 13.75 8.969 C 14.282 9.276 14.724 9.718 15.031 10.25 C 15.338 10.782 15.5 11.386 15.5 12 C 15.5 12.614 15.338 13.218 15.031 13.75 C 14.724 14.282 14.282 14.724 13.75 15.031 C 13.218 15.338 12.614 15.5 12 15.5 C 11.072 15.5 10.181 15.131 9.525 14.475 C 8.869 13.819 8.5 12.928 8.5 12 C 8.5 11.072 8.869 10.181 9.525 9.525 C 10.181 8.869 11.072 8.5 12 8.5 M 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 M 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12"
                android:valueTo="M 14.87 5.07 L 14.5 2.42 C 14.46 2.18 14.25 2 14 2 L 10 2 C 9.75 2 9.54 2.18 9.5 2.42 L 9.13 5.07 C 8.5 5.32 7.96 5.66 7.44 6.05 L 4.95 5.05 C 4.73 4.96 4.46 5.05 4.34 5.27 L 2.34 8.73 C 2.21 8.95 2.27 9.22 2.46 9.37 L 4.57 11 C 4.547 11.333 4.523 11.667 4.5 12 C 4.523 12.323 4.547 12.647 4.57 12.97 L 2.46 14.63 C 2.27 14.78 2.21 15.05 2.34 15.27 L 4.34 18.73 C 4.46 18.95 4.73 19.03 4.95 18.95 L 7.44 17.94 C 7.96 18.34 8.5 18.68 9.13 18.93 L 9.5 21.58 C 9.54 21.82 9.75 22 10 22 L 14 22 C 14.25 22 14.46 21.82 14.5 21.58 L 14.87 18.93 C 15.5 18.68 16.04 18.34 16.56 17.95 L 19.05 18.95 C 19.27 19.04 19.54 18.95 19.66 18.73 L 21.66 15.27 C 21.79 15.05 21.73 14.78 21.54 14.63 L 19.43 13 L 19.465 12.499 C 19.477 12.333 19.488 12.166 19.5 12 C 19.477 11.667 19.453 11.333 19.43 11 L 21.54 9.37 C 21.73 9.22 21.79 8.95 21.66 8.73 L 19.66 5.27 C 19.54 5.05 19.27 4.96 19.05 5.05 L 16.56 6.05 C 16.04 5.66 15.5 5.32 14.87 5.07 M 12 8 C 12.53 8 13.05 8.105 13.531 8.305 C 14.011 8.504 14.454 8.797 14.828 9.172 C 15.578 9.921 16 10.94 16 12 C 16 12.53 15.895 13.05 15.695 13.531 C 15.496 14.011 15.203 14.454 14.828 14.828 C 14.079 15.578 13.06 16 12 16 C 10.94 16 9.921 15.578 9.172 14.828 C 8.422 14.079 8 13.06 8 12 C 8 10.94 8.422 9.921 9.172 9.172 C 9.921 8.422 10.94 8 12 8 M 12 10 C 11.912 10 11.824 10.006 11.737 10.017 C 11.651 10.029 11.565 10.046 11.481 10.069 C 11.397 10.091 11.315 10.119 11.235 10.152 C 11.155 10.186 11.077 10.224 11.001 10.267 C 10.926 10.311 10.854 10.359 10.784 10.412 C 10.715 10.466 10.649 10.524 10.586 10.586 C 10.524 10.649 10.466 10.715 10.412 10.784 C 10.359 10.854 10.311 10.926 10.267 11.001 C 10.224 11.077 10.186 11.155 10.152 11.235 C 10.119 11.315 10.091 11.397 10.069 11.481 C 10.046 11.565 10.029 11.651 10.017 11.737 C 10.006 11.824 10 11.912 10 12 C 10 12.088 10.006 12.176 10.017 12.263 C 10.029 12.349 10.046 12.435 10.069 12.519 C 10.091 12.603 10.119 12.685 10.152 12.765 C 10.186 12.845 10.224 12.923 10.267 12.999 C 10.311 13.074 10.359 13.146 10.412 13.216 C 10.466 13.285 10.524 13.351 10.586 13.414 C 10.649 13.476 10.715 13.534 10.784 13.588 C 10.854 13.641 10.926 13.689 11.001 13.733 C 11.077 13.776 11.155 13.814 11.235 13.848 C 11.315 13.881 11.397 13.909 11.481 13.931 C 11.565 13.954 11.651 13.971 11.737 13.983 C 11.824 13.994 11.912 14 12 14 C 12.53 14 13.039 13.789 13.414 13.414 C 13.468 13.36 13.518 13.304 13.565 13.245 C 13.611 13.187 13.655 13.126 13.694 13.062 C 13.734 12.999 13.77 12.934 13.802 12.867 C 13.834 12.8 13.863 12.731 13.887 12.661 C 13.912 12.591 13.933 12.519 13.949 12.447 C 13.966 12.374 13.979 12.3 13.987 12.226 C 13.996 12.151 14 12.076 14 12 C 14 11.912 13.994 11.824 13.983 11.737 C 13.971 11.651 13.954 11.565 13.931 11.481 C 13.909 11.397 13.881 11.315 13.848 11.235 C 13.814 11.155 13.776 11.077 13.733 11.001 C 13.689 10.926 13.641 10.854 13.588 10.784 C 13.534 10.715 13.476 10.649 13.414 10.586 C 13.039 10.211 12.53 10 12 10 M 11.25 4 L 11.25 4 L 12.75 4 L 13.12 6.62 C 14.32 6.86 15.38 7.5 16.15 8.39 L 18.56 7.35 L 19.31 8.65 L 17.2 10.2 C 17.6 11.37 17.6 12.64 17.2 13.81 L 19.32 15.36 L 18.57 16.66 L 16.14 15.62 C 15.37 16.5 14.32 17.14 13.13 17.39 L 12.76 20 L 11.24 20 L 10.87 17.38 C 9.68 17.14 8.63 16.5 7.86 15.62 L 5.43 16.66 L 4.68 15.36 L 6.8 13.8 C 6.4 12.64 6.4 11.37 6.8 10.2 L 4.69 8.65 L 5.44 7.35 L 7.85 8.39 C 8.62 7.5 9.68 6.86 10.88 6.61 L 11.25 4"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/avd_settings_to_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="path"
                android:fillColor="#000000"
                android:fillType="evenOdd"
                android:pathData="M 14.87 5.07 L 14.5 2.42 C 14.46 2.18 14.25 2 14 2 L 10 2 C 9.75 2 9.54 2.18 9.5 2.42 L 9.13 5.07 C 8.5 5.32 7.96 5.66 7.44 6.05 L 4.95 5.05 C 4.73 4.96 4.46 5.05 4.34 5.27 L 2.34 8.73 C 2.21 8.95 2.27 9.22 2.46 9.37 L 4.57 11 C 4.547 11.333 4.523 11.667 4.5 12 C 4.523 12.323 4.547 12.647 4.57 12.97 L 2.46 14.63 C 2.27 14.78 2.21 15.05 2.34 15.27 L 4.34 18.73 C 4.46 18.95 4.73 19.03 4.95 18.95 L 7.44 17.94 C 7.96 18.34 8.5 18.68 9.13 18.93 L 9.5 21.58 C 9.54 21.82 9.75 22 10 22 L 14 22 C 14.25 22 14.46 21.82 14.5 21.58 L 14.87 18.93 C 15.5 18.68 16.04 18.34 16.56 17.95 L 19.05 18.95 C 19.27 19.04 19.54 18.95 19.66 18.73 L 21.66 15.27 C 21.79 15.05 21.73 14.78 21.54 14.63 L 19.43 13 L 19.465 12.499 C 19.477 12.333 19.488 12.166 19.5 12 C 19.477 11.667 19.453 11.333 19.43 11 L 21.54 9.37 C 21.73 9.22 21.79 8.95 21.66 8.73 L 19.66 5.27 C 19.54 5.05 19.27 4.96 19.05 5.05 L 16.56 6.05 C 16.04 5.66 15.5 5.32 14.87 5.07 M 12 8 C 12.53 8 13.05 8.105 13.531 8.305 C 14.011 8.504 14.454 8.797 14.828 9.172 C 15.578 9.921 16 10.94 16 12 C 16 12.53 15.895 13.05 15.695 13.531 C 15.496 14.011 15.203 14.454 14.828 14.828 C 14.079 15.578 13.06 16 12 16 C 10.94 16 9.921 15.578 9.172 14.828 C 8.422 14.079 8 13.06 8 12 C 8 10.94 8.422 9.921 9.172 9.172 C 9.921 8.422 10.94 8 12 8 M 12 10 C 11.912 10 11.824 10.006 11.737 10.017 C 11.651 10.029 11.565 10.046 11.481 10.069 C 11.397 10.091 11.315 10.119 11.235 10.152 C 11.155 10.186 11.077 10.224 11.001 10.267 C 10.926 10.311 10.854 10.359 10.784 10.412 C 10.715 10.466 10.649 10.524 10.586 10.586 C 10.524 10.649 10.466 10.715 10.412 10.784 C 10.359 10.854 10.311 10.926 10.267 11.001 C 10.224 11.077 10.186 11.155 10.152 11.235 C 10.119 11.315 10.091 11.397 10.069 11.481 C 10.046 11.565 10.029 11.651 10.017 11.737 C 10.006 11.824 10 11.912 10 12 C 10 12.088 10.006 12.176 10.017 12.263 C 10.029 12.349 10.046 12.435 10.069 12.519 C 10.091 12.603 10.119 12.685 10.152 12.765 C 10.186 12.845 10.224 12.923 10.267 12.999 C 10.311 13.074 10.359 13.146 10.412 13.216 C 10.466 13.285 10.524 13.351 10.586 13.414 C 10.649 13.476 10.715 13.534 10.784 13.588 C 10.854 13.641 10.926 13.689 11.001 13.733 C 11.077 13.776 11.155 13.814 11.235 13.848 C 11.315 13.881 11.397 13.909 11.481 13.931 C 11.565 13.954 11.651 13.971 11.737 13.983 C 11.824 13.994 11.912 14 12 14 C 12.53 14 13.039 13.789 13.414 13.414 C 13.468 13.36 13.518 13.304 13.565 13.245 C 13.611 13.187 13.655 13.126 13.694 13.062 C 13.734 12.999 13.77 12.934 13.802 12.867 C 13.834 12.8 13.863 12.731 13.887 12.661 C 13.912 12.591 13.933 12.519 13.949 12.447 C 13.966 12.374 13.979 12.3 13.987 12.226 C 13.996 12.151 14 12.076 14 12 C 14 11.912 13.994 11.824 13.983 11.737 C 13.971 11.651 13.954 11.565 13.931 11.481 C 13.909 11.397 13.881 11.315 13.848 11.235 C 13.814 11.155 13.776 11.077 13.733 11.001 C 13.689 10.926 13.641 10.854 13.588 10.784 C 13.534 10.715 13.476 10.649 13.414 10.586 C 13.039 10.211 12.53 10 12 10 M 11.25 4 L 11.25 4 L 12.75 4 L 13.12 6.62 C 14.32 6.86 15.38 7.5 16.15 8.39 L 18.56 7.35 L 19.31 8.65 L 17.2 10.2 C 17.6 11.37 17.6 12.64 17.2 13.81 L 19.32 15.36 L 18.57 16.66 L 16.14 15.62 C 15.37 16.5 14.32 17.14 13.13 17.39 L 12.76 20 L 11.24 20 L 10.87 17.38 C 9.68 17.14 8.63 16.5 7.86 15.62 L 5.43 16.66 L 4.68 15.36 L 6.8 13.8 C 6.4 12.64 6.4 11.37 6.8 10.2 L 4.69 8.65 L 5.44 7.35 L 7.85 8.39 C 8.62 7.5 9.68 6.86 10.88 6.61 L 11.25 4" />
        </vector>
    </aapt:attr>
    <target android:name="path">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="300"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 14.87 5.07 L 14.5 2.42 C 14.46 2.18 14.25 2 14 2 L 10 2 C 9.75 2 9.54 2.18 9.5 2.42 L 9.13 5.07 C 8.5 5.32 7.96 5.66 7.44 6.05 L 4.95 5.05 C 4.73 4.96 4.46 5.05 4.34 5.27 L 2.34 8.73 C 2.21 8.95 2.27 9.22 2.46 9.37 L 4.57 11 C 4.547 11.333 4.523 11.667 4.5 12 C 4.523 12.323 4.547 12.647 4.57 12.97 L 2.46 14.63 C 2.27 14.78 2.21 15.05 2.34 15.27 L 4.34 18.73 C 4.46 18.95 4.73 19.03 4.95 18.95 L 7.44 17.94 C 7.96 18.34 8.5 18.68 9.13 18.93 L 9.5 21.58 C 9.54 21.82 9.75 22 10 22 L 14 22 C 14.25 22 14.46 21.82 14.5 21.58 L 14.87 18.93 C 15.5 18.68 16.04 18.34 16.56 17.95 L 19.05 18.95 C 19.27 19.04 19.54 18.95 19.66 18.73 L 21.66 15.27 C 21.79 15.05 21.73 14.78 21.54 14.63 L 19.43 13 L 19.465 12.499 C 19.477 12.333 19.488 12.166 19.5 12 C 19.477 11.667 19.453 11.333 19.43 11 L 21.54 9.37 C 21.73 9.22 21.79 8.95 21.66 8.73 L 19.66 5.27 C 19.54 5.05 19.27 4.96 19.05 5.05 L 16.56 6.05 C 16.04 5.66 15.5 5.32 14.87 5.07 M 12 8 C 12.53 8 13.05 8.105 13.531 8.305 C 14.011 8.504 14.454 8.797 14.828 9.172 C 15.578 9.921 16 10.94 16 12 C 16 12.53 15.895 13.05 15.695 13.531 C 15.496 14.011 15.203 14.454 14.828 14.828 C 14.079 15.578 13.06 16 12 16 C 10.94 16 9.921 15.578 9.172 14.828 C 8.422 14.079 8 13.06 8 12 C 8 10.94 8.422 9.921 9.172 9.172 C 9.921 8.422 10.94 8 12 8 M 12 10 C 11.912 10 11.824 10.006 11.737 10.017 C 11.651 10.029 11.565 10.046 11.481 10.069 C 11.397 10.091 11.315 10.119 11.235 10.152 C 11.155 10.186 11.077 10.224 11.001 10.267 C 10.926 10.311 10.854 10.359 10.784 10.412 C 10.715 10.466 10.649 10.524 10.586 10.586 C 10.524 10.649 10.466 10.715 10.412 10.784 C 10.359 10.854 10.311 10.926 10.267 11.001 C 10.224 11.077 10.186 11.155 10.152 11.235 C 10.119 11.315 10.091 11.397 10.069 11.481 C 10.046 11.565 10.029 11.651 10.017 11.737 C 10.006 11.824 10 11.912 10 12 C 10 12.088 10.006 12.176 10.017 12.263 C 10.029 12.349 10.046 12.435 10.069 12.519 C 10.091 12.603 10.119 12.685 10.152 12.765 C 10.186 12.845 10.224 12.923 10.267 12.999 C 10.311 13.074 10.359 13.146 10.412 13.216 C 10.466 13.285 10.524 13.351 10.586 13.414 C 10.649 13.476 10.715 13.534 10.784 13.588 C 10.854 13.641 10.926 13.689 11.001 13.733 C 11.077 13.776 11.155 13.814 11.235 13.848 C 11.315 13.881 11.397 13.909 11.481 13.931 C 11.565 13.954 11.651 13.971 11.737 13.983 C 11.824 13.994 11.912 14 12 14 C 12.53 14 13.039 13.789 13.414 13.414 C 13.468 13.36 13.518 13.304 13.565 13.245 C 13.611 13.187 13.655 13.126 13.694 13.062 C 13.734 12.999 13.77 12.934 13.802 12.867 C 13.834 12.8 13.863 12.731 13.887 12.661 C 13.912 12.591 13.933 12.519 13.949 12.447 C 13.966 12.374 13.979 12.3 13.987 12.226 C 13.996 12.151 14 12.076 14 12 C 14 11.912 13.994 11.824 13.983 11.737 C 13.971 11.651 13.954 11.565 13.931 11.481 C 13.909 11.397 13.881 11.315 13.848 11.235 C 13.814 11.155 13.776 11.077 13.733 11.001 C 13.689 10.926 13.641 10.854 13.588 10.784 C 13.534 10.715 13.476 10.649 13.414 10.586 C 13.039 10.211 12.53 10 12 10 M 11.25 4 L 11.25 4 L 12.75 4 L 13.12 6.62 C 14.32 6.86 15.38 7.5 16.15 8.39 L 18.56 7.35 L 19.31 8.65 L 17.2 10.2 C 17.6 11.37 17.6 12.64 17.2 13.81 L 19.32 15.36 L 18.57 16.66 L 16.14 15.62 C 15.37 16.5 14.32 17.14 13.13 17.39 L 12.76 20 L 11.24 20 L 10.87 17.38 C 9.68 17.14 8.63 16.5 7.86 15.62 L 5.43 16.66 L 4.68 15.36 L 6.8 13.8 C 6.4 12.64 6.4 11.37 6.8 10.2 L 4.69 8.65 L 5.44 7.35 L 7.85 8.39 C 8.62 7.5 9.68 6.86 10.88 6.61 L 11.25 4"
                android:valueTo="M 14.87 5.07 L 14.5 2.42 C 14.46 2.18 14.25 2 14 2 L 10 2 C 9.75 2 9.54 2.18 9.5 2.42 L 9.13 5.07 C 8.5 5.32 7.96 5.66 7.44 6.05 L 4.95 5.05 C 4.73 4.96 4.46 5.05 4.34 5.27 L 2.34 8.73 C 2.21 8.95 2.27 9.22 2.46 9.37 L 4.57 11 C 4.53 11.34 4.5 11.67 4.5 12 C 4.5 12.33 4.53 12.65 4.57 12.97 L 2.46 14.63 C 2.27 14.78 2.21 15.05 2.34 15.27 L 4.34 18.73 C 4.46 18.95 4.73 19.03 4.95 18.95 L 7.44 17.94 C 7.96 18.34 8.5 18.68 9.13 18.93 L 9.5 21.58 C 9.54 21.82 9.75 22 10 22 L 14 22 C 14.25 22 14.46 21.82 14.5 21.58 L 14.87 18.93 C 15.5 18.67 16.04 18.34 16.56 17.94 L 19.05 18.95 C 19.27 19.03 19.54 18.95 19.66 18.73 L 21.66 15.27 C 21.78 15.05 21.73 14.78 21.54 14.63 L 19.43 12.97 L 19.43 12.97 C 19.47 12.65 19.5 12.33 19.5 12 C 19.5 11.67 19.47 11.34 19.43 11 L 21.54 9.37 C 21.73 9.22 21.78 8.95 21.66 8.73 L 19.66 5.27 C 19.54 5.05 19.27 4.96 19.05 5.05 L 16.56 6.05 C 16.04 5.66 15.5 5.32 14.87 5.07 M 12 8.5 C 12.614 8.5 13.218 8.662 13.75 8.969 C 14.282 9.276 14.724 9.718 15.031 10.25 C 15.338 10.782 15.5 11.386 15.5 12 C 15.5 12.614 15.338 13.218 15.031 13.75 C 14.724 14.282 14.282 14.724 13.75 15.031 C 13.218 15.338 12.614 15.5 12 15.5 C 11.072 15.5 10.181 15.131 9.525 14.475 C 8.869 13.819 8.5 12.928 8.5 12 C 8.5 11.072 8.869 10.181 9.525 9.525 C 10.181 8.869 11.072 8.5 12 8.5 M 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 C 11.982 12 11.982 12 11.982 12 M 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12 L 12 12 L 12 12 C 12 12 12 12 12 12 L 12 12"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/avd_superuser_from_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="path"
                android:fillColor="#000000"
                android:fillType="evenOdd"
                android:pathData="M 12 1 L 3 5 L 3 11 C 3 16.55 6.84 21.74 12 23 C 17.16 21.74 21 16.55 21 11 L 21 5 L 12 1 Z" />
        </vector>
    </aapt:attr>
    <target android:name="path">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="300"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 21 11 C 21 16.55 17.16 21.74 12 23 C 6.84 21.74 3 16.55 3 11 L 3 5 L 12 1 L 12 1 L 21 5 L 21 11 M 12 10.18 L 12 10.18 C 12 10.18 12 10.18 12 10.18 L 12 10.18 L 12 10.18 L 12 10.18 L 12 10.18 C 12 10.18 12 10.18 12 10.18"
                android:valueTo="M 21 11 C 21 16.55 17.16 21.74 12 23 C 6.84 21.74 3 16.55 3 11 L 3 5 L 7.5 3 L 12 1 L 21 5 L 21 11 M 12 21 L 12 21 C 8.25 20 5 15.54 5 11.22 L 5 6.3 L 12 3.18 L 19 6.3 L 19 11.22 C 19 15.54 15.75 20 12 21"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/avd_superuser_to_filled.xml`:

```xml
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <path
                android:name="path"
                android:fillColor="#000000"
                android:fillType="evenOdd"
                android:pathData="M 21 11 C 21 16.55 17.16 21.74 12 23 C 6.84 21.74 3 16.55 3 11 L 3 5 L 7.5 3 L 12 1 L 21 5 L 21 11 M 12 21 L 12 21 C 8.25 20 5 15.54 5 11.22 L 5 6.3 L 12 3.18 L 19 6.3 L 19 11.22 C 19 15.54 15.75 20 12 21" />
        </vector>
    </aapt:attr>
    <target android:name="path">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:duration="300"
                android:interpolator="@android:interpolator/fast_out_slow_in"
                android:propertyName="pathData"
                android:valueFrom="M 21 11 C 21 16.55 17.16 21.74 12 23 C 6.84 21.74 3 16.55 3 11 L 3 5 L 7.5 3 L 12 1 L 21 5 L 21 11 M 12 21 L 12 21 C 8.25 20 5 15.54 5 11.22 L 5 6.3 L 12 3.18 L 19 6.3 L 19 11.22 C 19 15.54 15.75 20 12 21"
                android:valueTo="M 21 11 C 21 16.55 17.16 21.74 12 23 C 6.84 21.74 3 16.55 3 11 L 3 5 L 12 1 L 12 1 L 21 5 L 21 11 M 12 10.18 L 12 10.18 C 12 10.18 12 10.18 12 10.18 L 12 10.18 L 12 10.18 L 12 10.18 L 12 10.18 C 12 10.18 12 10.18 12 10.18"
                android:valueType="pathType" />
        </aapt:attr>
    </target>
</animated-vector>

```

`app/apk/src/main/res/drawable/bg_line_bottom_rounded.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item>
        <shape android:shape="rectangle">
            <solid android:color="@android:color/black" />
            <corners android:bottomLeftRadius="2dp" android:bottomRightRadius="2dp" />
        </shape>
    </item>

</selector>

```

`app/apk/src/main/res/drawable/bg_line_top_rounded.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item>
        <shape android:shape="rectangle">
            <solid android:color="@android:color/black" />
            <corners android:topLeftRadius="2dp" android:topRightRadius="2dp" />
        </shape>
    </item>

</selector>

```

`app/apk/src/main/res/drawable/bg_selection_circle_green.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <shape android:shape="oval">
            <solid android:color="#43A047" />
        </shape>
    </item>
</selector>
```

`app/apk/src/main/res/drawable/ic_action_md2.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">

    <path android:fillColor="@android:color/white" android:pathData="M8,5v14l11,-7z"/>

</vector>

```

`app/apk/src/main/res/drawable/ic_back_md2.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:autoMirrored="true"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M20,11H6.83l2.88,-2.88c0.39,-0.39 0.39,-1.02 0,-1.41 -0.39,-0.39 -1.02,-0.39 -1.41,0L3.71,11.3c-0.39,0.39 -0.39,1.02 0,1.41L8.3,17.3c0.39,0.39 1.02,0.39 1.41,0 0.39,-0.39 0.39,-1.02 0,-1.41L6.83,13H20c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1z" />
</vector>

```

`app/apk/src/main/res/drawable/ic_bug_filled_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M20,8h-2.81c-0.45,-0.78 -1.07,-1.45 -1.82,-1.96L17,4.41 15.59,3l-2.17,2.17C12.96,5.06 12.49,5 12,5c-0.49,0 -0.96,0.06 -1.41,0.17L8.41,3 7,4.41l1.62,1.63C7.88,6.55 7.26,7.22 6.81,8L4,8v2h2.09c-0.05,0.33 -0.09,0.66 -0.09,1v1L4,12v2h2v1c0,0.34 0.04,0.67 0.09,1L4,16v2h2.81c1.04,1.79 2.97,3 5.19,3s4.15,-1.21 5.19,-3L20,18v-2h-2.09c0.05,-0.33 0.09,-0.66 0.09,-1v-1h2v-2h-2v-1c0,-0.34 -0.04,-0.67 -0.09,-1L20,10L20,8zM14,16h-4v-2h4v2zM14,12h-4v-2h4v2z" />
</vector>

```

`app/apk/src/main/res/drawable/ic_bug_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<animated-selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/checked"
        android:drawable="@drawable/ic_bug_filled_md2"
        android:state_checked="true" />

    <item
        android:id="@+id/unchecked"
        android:drawable="@drawable/ic_bug_outlined_md2" />

    <transition
        android:drawable="@drawable/avd_bug_from_filled"
        android:fromId="@+id/checked"
        android:toId="@+id/unchecked" />

    <transition
        android:drawable="@drawable/avd_bug_to_filled"
        android:fromId="@+id/unchecked"
        android:toId="@id/checked" />

</animated-selector>

```

`app/apk/src/main/res/drawable/ic_bug_outlined_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M20,8H17.19C16.74,7.2 16.12,6.5 15.37,6L17,4.41L15.59,3L13.42,5.17C12.96,5.06 12.5,5 12,5C11.5,5 11.05,5.06 10.59,5.17L8.41,3L7,4.41L8.62,6C7.87,6.5 7.26,7.21 6.81,8H4V10H6.09C6.03,10.33 6,10.66 6,11V12H4V14H6V15C6,15.34 6.03,15.67 6.09,16H4V18H6.81C8.47,20.87 12.14,21.84 15,20.18C15.91,19.66 16.67,18.9 17.19,18H20V16H17.91C17.97,15.67 18,15.34 18,15V14H20V12H18V11C18,10.66 17.97,10.33 17.91,10H20V8M16,15A4,4 0 0,1 12,19A4,4 0 0,1 8,15V11A4,4 0 0,1 12,7A4,4 0 0,1 16,11V15M14,10V12H10V10H14M10,14H14V16H10V14Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_check_circle_checked_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M12 20C7.59 20 4 16.41 4 12S7.59 4 12 4 20 7.59 20 12 16.41 20 12 20M16.59 7.58L10 14.17L7.41 11.59L6 13L10 17L18 9L16.59 7.58Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_check_circle_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<animated-selector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    tools:ignore="NewApi">

    <item
        android:id="@+id/checked"
        android:drawable="@drawable/ic_check_circle_checked_md2"
        android:state_selected="true" />

    <item
        android:id="@+id/unchecked"
        android:drawable="@drawable/ic_check_circle_unchecked_md2" />

    <transition
        android:drawable="@drawable/avd_circle_check_from_filled"
        android:fromId="@+id/checked"
        android:toId="@+id/unchecked" />

    <transition
        android:drawable="@drawable/avd_circle_check_to_filled"
        android:fromId="@+id/unchecked"
        android:toId="@id/checked" />

</animated-selector>
```

`app/apk/src/main/res/drawable/ic_check_circle_unchecked_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M7,13H17V11H7" />
</vector>
```

`app/apk/src/main/res/drawable/ic_check_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"
        tools:fillColor="#000" />
</vector>
```

`app/apk/src/main/res/drawable/ic_close_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"
        tools:fillColor="#000" />
</vector>

```

`app/apk/src/main/res/drawable/ic_day.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M3.55,18.54L4.96,19.95L6.76,18.16L5.34,16.74M11,22.45C11.32,22.45 13,22.45 13,22.45V19.5H11M12,5.5A6,6 0 0,0 6,11.5A6,6 0 0,0 12,17.5A6,6 0 0,0 18,11.5C18,8.18 15.31,5.5 12,5.5M20,12.5H23V10.5H20M17.24,18.16L19.04,19.95L20.45,18.54L18.66,16.74M20.45,4.46L19.04,3.05L17.24,4.84L18.66,6.26M13,0.55H11V3.5H13M4,10.5H1V12.5H4M6.76,4.84L4.96,3.05L3.55,4.46L5.34,6.26L6.76,4.84Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_day_night.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M7.5,2C5.71,3.15 4.5,5.18 4.5,7.5C4.5,9.82 5.71,11.85 7.53,13C4.46,13 2,10.54 2,7.5A5.5,5.5 0 0,1 7.5,2M19.07,3.5L20.5,4.93L4.93,20.5L3.5,19.07L19.07,3.5M12.89,5.93L11.41,5L9.97,6L10.39,4.3L9,3.24L10.75,3.12L11.33,1.47L12,3.1L13.73,3.13L12.38,4.26L12.89,5.93M9.59,9.54L8.43,8.81L7.31,9.59L7.65,8.27L6.56,7.44L7.92,7.35L8.37,6.06L8.88,7.33L10.24,7.36L9.19,8.23L9.59,9.54M19,13.5A5.5,5.5 0 0,1 13.5,19C12.28,19 11.15,18.6 10.24,17.93L17.93,10.24C18.6,11.15 19,12.28 19,13.5M14.6,20.08L17.37,18.93L17.13,22.28L14.6,20.08M18.93,17.38L20.08,14.61L22.28,17.15L18.93,17.38M20.08,12.42L18.94,9.64L22.28,9.88L20.08,12.42M9.63,18.93L12.4,20.08L9.87,22.27L9.63,18.93Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_delete_md2.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
  <path
      android:fillColor="?colorOnSurface"
      android:pathData="M18,4h-2.5l-0.7,-0.7C14.6,3.2 14.4,3 14.1,3H9.9C9.6,3 9.4,3.2 9.2,3.3L8.5,4H6C5.4,4 5,4.5 5,5s0.4,1 1,1h12c0.5,0 1,-0.4 1,-1S18.5,4 18,4z" />
  <path
      android:fillColor="?colorOnSurface"
      android:pathData="M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2V9c0,-1.1 -0.9,-2 -2,-2H8C6.9,7 6,7.9 6,9V19z" />
</vector>

```

`app/apk/src/main/res/drawable/ic_download_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M13,5V11H14.17L12,13.17L9.83,11H11V5H13M15,3H9V9H5L12,16L19,9H15V3M19,18H5V20H19V18Z"
        tools:fillColor="#000" />
</vector>
```

`app/apk/src/main/res/drawable/ic_folder_list.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M20,18H4V8H20M20,6H12L10,4H4A2,2 0 0,0 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8A2,2 0 0,0 20,6M15,16H6V14H15V16M18,12H6V10H18V12Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_forth_md2.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">

    <group
        android:name="forth"
        android:pivotX="12"
        android:pivotY="12"
        android:rotation="180">
        <path
            android:fillColor="#000"
            android:pathData="M20,11H6.83l2.88,-2.88c0.39,-0.39 0.39,-1.02 0,-1.41 -0.39,-0.39 -1.02,-0.39 -1.41,0L3.71,11.3c-0.39,0.39 -0.39,1.02 0,1.41L8.3,17.3c0.39,0.39 1.02,0.39 1.41,0 0.39,-0.39 0.39,-1.02 0,-1.41L6.83,13H20c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1z" />
    </group>

</vector>

```

`app/apk/src/main/res/drawable/ic_home_filled_md2.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M 9 14 L 9 21 L 4 21 L 4 9 L 12 3 L 12 3 L 20 9 L 20 21 L 15 21 L 15 14 L 9 14 M 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4 L 12 13.4" />
</vector>

```

`app/apk/src/main/res/drawable/ic_home_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<animated-selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/checked"
        android:drawable="@drawable/ic_home_filled_md2"
        android:state_checked="true" />

    <item
        android:id="@+id/unchecked"
        android:drawable="@drawable/ic_home_outlined_md2" />

    <transition
        android:drawable="@drawable/avd_home_from_filled"
        android:fromId="@+id/checked"
        android:toId="@+id/unchecked" />

    <transition
        android:drawable="@drawable/avd_home_to_filled"
        android:fromId="@+id/unchecked"
        android:toId="@id/checked" />

</animated-selector>
```

`app/apk/src/main/res/drawable/ic_home_outlined_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:fillType="evenOdd"
        android:pathData="M 9 13 L 9 19 L 6 19 L 6 10 L 12 5.5 L 15 7.75 L 18 10 L 18 19 L 15 19 L 15 13 L 9 13 M 4 21 L 4 9 L 12 3 L 20 9 L 20 21 L 4 21 L 4 21" />
</vector>
```

`app/apk/src/main/res/drawable/ic_install.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M12,18L7,13H10V9H14V13H17L12,18M10,2H14A2,2 0 0,1 16,4V6H20A2,2 0 0,1 22,8V19A2,2 0 0,1 20,21H4C2.89,21 2,20.1 2,19V8C2,6.89 2.89,6 4,6H8V4C8,2.89 8.89,2 10,2M14,6V4H10V6H14M4,8V19H20V8H4Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_manager.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M7,3v2c0,0.55 0.45,1 1,1s1,-0.45 1,-1L9,4h10v16L9,20v-1c0,-0.55 -0.45,-1 -1,-1s-1,0.45 -1,1v2c0,1.1 0.9,2 2,2h10c1.1,0 2,-0.9 2,-2L21,3c0,-1.1 -0.9,-2 -2,-2L9,1c-1.1,0 -2,0.9 -2,2zM9.5,15.5c0.29,-0.12 0.55,-0.29 0.8,-0.48l-0.02,0.03 1.01,0.39c0.23,0.09 0.49,0 0.61,-0.22l0.84,-1.46c0.12,-0.21 0.07,-0.49 -0.12,-0.64l-0.85,-0.68 -0.02,0.03c0.02,-0.16 0.05,-0.32 0.05,-0.48s-0.03,-0.32 -0.05,-0.48l0.02,0.03 0.85,-0.68c0.19,-0.15 0.24,-0.43 0.12,-0.64l-0.84,-1.46c-0.12,-0.21 -0.38,-0.31 -0.61,-0.22l-1.01,0.39 0.02,0.03c-0.25,-0.17 -0.51,-0.34 -0.8,-0.46l-0.17,-1.08C9.3,7.18 9.09,7 8.84,7L7.16,7c-0.25,0 -0.46,0.18 -0.49,0.42L6.5,8.5c-0.29,0.12 -0.55,0.29 -0.8,0.48l0.02,-0.03 -1.02,-0.39c-0.23,-0.09 -0.49,0 -0.61,0.22l-0.84,1.46c-0.12,0.21 -0.07,0.49 0.12,0.64l0.85,0.68 0.02,-0.03c-0.02,0.15 -0.05,0.31 -0.05,0.47s0.03,0.32 0.05,0.48l-0.02,-0.03 -0.85,0.68c-0.19,0.15 -0.24,0.43 -0.12,0.64l0.84,1.46c0.12,0.21 0.38,0.31 0.61,0.22l1.01,-0.39 -0.01,-0.04c0.25,0.19 0.51,0.36 0.8,0.48l0.17,1.07c0.03,0.25 0.24,0.43 0.49,0.43h1.68c0.25,0 0.46,-0.18 0.49,-0.42l0.17,-1.08zM6,12c0,-1.1 0.9,-2 2,-2s2,0.9 2,2 -0.9,2 -2,2 -2,-0.9 -2,-2z" />
</vector>

```

`app/apk/src/main/res/drawable/ic_module_filled_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M20.5,11H19V7C19,5.89 18.1,5 17,5H13V3.5A2.5,2.5 0 0,0 10.5,1A2.5,2.5 0 0,0 8,3.5V5H4A2,2 0 0,0 2,7V10.8H3.5C5,10.8 6.2,12 6.2,13.5C6.2,15 5,16.2 3.5,16.2H2V20A2,2 0 0,0 4,22H7.8V20.5C7.8,19 9,17.8 10.5,17.8C12,17.8 13.2,19 13.2,20.5V22H17A2,2 0 0,0 19,20V16H20.5A2.5,2.5 0 0,0 23,13.5A2.5,2.5 0 0,0 20.5,11Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_module_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<animated-selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/checked"
        android:drawable="@drawable/ic_module_filled_md2"
        android:state_checked="true" />

    <item
        android:id="@+id/unchecked"
        android:drawable="@drawable/ic_module_outlined_md2" />

    <transition
        android:drawable="@drawable/avd_module_from_filled"
        android:fromId="@+id/checked"
        android:toId="@+id/unchecked" />

    <transition
        android:drawable="@drawable/avd_module_to_filled"
        android:fromId="@+id/unchecked"
        android:toId="@id/checked" />

</animated-selector>
```

`app/apk/src/main/res/drawable/ic_module_outlined_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M22,13.5C22,15.26 20.7,16.72 19,16.96V20A2,2 0 0,1 17,22H13.2V21.7A2.7,2.7 0 0,0 10.5,19C9,19 7.8,20.21 7.8,21.7V22H4A2,2 0 0,1 2,20V16.2H2.3C3.79,16.2 5,15 5,13.5C5,12 3.79,10.8 2.3,10.8H2V7A2,2 0 0,1 4,5H7.04C7.28,3.3 8.74,2 10.5,2C12.26,2 13.72,3.3 13.96,5H17A2,2 0 0,1 19,7V10.04C20.7,10.28 22,11.74 22,13.5M17,15H18.5A1.5,1.5 0 0,0 20,13.5A1.5,1.5 0 0,0 18.5,12H17V7H12V5.5A1.5,1.5 0 0,0 10.5,4A1.5,1.5 0 0,0 9,5.5V7H4V9.12C5.76,9.8 7,11.5 7,13.5C7,15.5 5.75,17.2 4,17.88V20H6.12C6.8,18.25 8.5,17 10.5,17C12.5,17 14.2,18.25 14.88,20H17V15Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_module_storage_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M2,10.96C1.5,10.68 1.35,10.07 1.63,9.59L3.13,7C3.24,6.8 3.41,6.66 3.6,6.58L11.43,2.18C11.59,2.06 11.79,2 12,2C12.21,2 12.41,2.06 12.57,2.18L20.47,6.62C20.66,6.72 20.82,6.88 20.91,7.08L22.36,9.6C22.64,10.08 22.47,10.69 22,10.96L21,11.54V16.5C21,16.88 20.79,17.21 20.47,17.38L12.57,21.82C12.41,21.94 12.21,22 12,22C11.79,22 11.59,21.94 11.43,21.82L3.53,17.38C3.21,17.21 3,16.88 3,16.5V10.96C2.7,11.13 2.32,11.14 2,10.96M12,4.15V4.15L12,10.85V10.85L17.96,7.5L12,4.15M5,15.91L11,19.29V12.58L5,9.21V15.91M19,15.91V12.69L14,15.59C13.67,15.77 13.3,15.76 13,15.6V19.29L19,15.91M13.85,13.36L20.13,9.73L19.55,8.72L13.27,12.35L13.85,13.36Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_night.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M17.75,4.09L15.22,6.03L16.13,9.09L13.5,7.28L10.87,9.09L11.78,6.03L9.25,4.09L12.44,4L13.5,1L14.56,4L17.75,4.09M21.25,11L19.61,12.25L20.2,14.23L18.5,13.06L16.8,14.23L17.39,12.25L15.75,11L17.81,10.95L18.5,9L19.19,10.95L21.25,11M18.97,15.95C19.8,15.87 20.69,17.05 20.16,17.8C19.84,18.25 19.5,18.67 19.08,19.07C15.17,23 8.84,23 4.94,19.07C1.03,15.17 1.03,8.83 4.94,4.93C5.34,4.53 5.76,4.17 6.21,3.85C6.96,3.32 8.14,4.21 8.06,5.04C7.79,7.9 8.75,10.87 10.95,13.06C13.14,15.26 16.1,16.22 18.97,15.95M17.33,17.97C14.5,17.81 11.7,16.64 9.53,14.5C7.36,12.31 6.2,9.5 6.04,6.68C3.23,9.82 3.34,14.64 6.35,17.66C9.37,20.67 14.19,20.78 17.33,17.97Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_notifications_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M16,17H7V10.5C7,8 9,6 11.5,6C14,6 16,8 16,10.5M18,16V10.5C18,7.43 15.86,4.86 13,4.18V3.5A1.5,1.5 0 0,0 11.5,2A1.5,1.5 0 0,0 10,3.5V4.18C7.13,4.86 5,7.43 5,10.5V16L3,18V19H20V18M11.5,22A2,2 0 0,0 13.5,20H9.5A2,2 0 0,0 11.5,22Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_paint.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M20.71,4.63L19.37,3.29C19,2.9 18.35,2.9 17.96,3.29L9,12.25L11.75,15L20.71,6.04C21.1,5.65 21.1,5 20.71,4.63M7,14A3,3 0 0,0 4,17C4,18.31 2.84,19 2,19C2.92,20.22 4.5,21 6,21A4,4 0 0,0 10,17A3,3 0 0,0 7,14Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_restart.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M12,4C14.1,4 16.1,4.8 17.6,6.3C20.7,9.4 20.7,14.5 17.6,17.6C15.8,19.5 13.3,20.2 10.9,19.9L11.4,17.9C13.1,18.1 14.9,17.5 16.2,16.2C18.5,13.9 18.5,10.1 16.2,7.7C15.1,6.6 13.5,6 12,6V10.6L7,5.6L12,0.6V4M6.3,17.6C3.7,15 3.3,11 5.1,7.9L6.6,9.4C5.5,11.6 5.9,14.4 7.8,16.2C8.3,16.7 8.9,17.1 9.6,17.4L9,19.4C8,19 7.1,18.4 6.3,17.6Z" />
</vector>

```

`app/apk/src/main/res/drawable/ic_save_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M17 3H5C3.89 3 3 3.9 3 5V19C3 20.1 3.89 21 5 21H19C20.1 21 21 20.1 21 19V7L17 3M19 19H5V5H16.17L19 7.83V19M12 12C10.34 12 9 13.34 9 15S10.34 18 12 18 15 16.66 15 15 13.66 12 12 12M6 6H15V10H6V6Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_search_md2.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M15.5,14h-0.79l-0.28,-0.27c1.2,-1.4 1.82,-3.31 1.48,-5.34 -0.47,-2.78 -2.79,-5 -5.59,-5.34 -4.23,-0.52 -7.79,3.04 -7.27,7.27 0.34,2.8 2.56,5.12 5.34,5.59 2.03,0.34 3.94,-0.28 5.34,-1.48l0.27,0.28v0.79l4.25,4.25c0.41,0.41 1.08,0.41 1.49,0 0.41,-0.41 0.41,-1.08 0,-1.49L15.5,14zM9.5,14C7.01,14 5,11.99 5,9.5S7.01,5 9.5,5 14,7.01 14,9.5 11.99,14 9.5,14z" />
</vector>

```

`app/apk/src/main/res/drawable/ic_settings_filled_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_settings_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<animated-selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/checked"
        android:drawable="@drawable/ic_settings_filled_md2"
        android:state_checked="true" />

    <item
        android:id="@+id/unchecked"
        android:drawable="@drawable/ic_settings_outlined_md2" />

    <transition
        android:drawable="@drawable/avd_settings_from_filled"
        android:fromId="@+id/checked"
        android:toId="@+id/unchecked" />

    <transition
        android:drawable="@drawable/avd_settings_to_filled"
        android:fromId="@+id/unchecked"
        android:toId="@id/checked" />

</animated-selector>
```

`app/apk/src/main/res/drawable/ic_settings_outlined_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16A4,4 0 0,1 8,12A4,4 0 0,1 12,8M12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12A2,2 0 0,0 12,10M10,22C9.75,22 9.54,21.82 9.5,21.58L9.13,18.93C8.5,18.68 7.96,18.34 7.44,17.94L4.95,18.95C4.73,19.03 4.46,18.95 4.34,18.73L2.34,15.27C2.21,15.05 2.27,14.78 2.46,14.63L4.57,12.97L4.5,12L4.57,11L2.46,9.37C2.27,9.22 2.21,8.95 2.34,8.73L4.34,5.27C4.46,5.05 4.73,4.96 4.95,5.05L7.44,6.05C7.96,5.66 8.5,5.32 9.13,5.07L9.5,2.42C9.54,2.18 9.75,2 10,2H14C14.25,2 14.46,2.18 14.5,2.42L14.87,5.07C15.5,5.32 16.04,5.66 16.56,6.05L19.05,5.05C19.27,4.96 19.54,5.05 19.66,5.27L21.66,8.73C21.79,8.95 21.73,9.22 21.54,9.37L19.43,11L19.5,12L19.43,13L21.54,14.63C21.73,14.78 21.79,15.05 21.66,15.27L19.66,18.73C19.54,18.95 19.27,19.04 19.05,18.95L16.56,17.95C16.04,18.34 15.5,18.68 14.87,18.93L14.5,21.58C14.46,21.82 14.25,22 14,22H10M11.25,4L10.88,6.61C9.68,6.86 8.62,7.5 7.85,8.39L5.44,7.35L4.69,8.65L6.8,10.2C6.4,11.37 6.4,12.64 6.8,13.8L4.68,15.36L5.43,16.66L7.86,15.62C8.63,16.5 9.68,17.14 10.87,17.38L11.24,20H12.76L13.13,17.39C14.32,17.14 15.37,16.5 16.14,15.62L18.57,16.66L19.32,15.36L17.2,13.81C17.6,12.64 17.6,11.37 17.2,10.2L19.31,8.65L18.56,7.35L16.15,8.39C15.38,7.5 14.32,6.86 13.12,6.62L12.75,4H11.25Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_superuser_filled_md2.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:height="24dp"
    android:width="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M12,1L3,5V11C3,16.55 6.84,21.74 12,23C17.16,21.74 21,16.55 21,11V5L12,1Z" />
</vector>

```

`app/apk/src/main/res/drawable/ic_superuser_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<animated-selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/checked"
        android:drawable="@drawable/ic_superuser_filled_md2"
        android:state_checked="true" />

    <item
        android:id="@+id/unchecked"
        android:drawable="@drawable/ic_superuser_outlined_md2" />

    <transition
        android:drawable="@drawable/avd_superuser_from_filled"
        android:fromId="@+id/checked"
        android:toId="@+id/unchecked" />

    <transition
        android:drawable="@drawable/avd_superuser_to_filled"
        android:fromId="@+id/unchecked"
        android:toId="@id/checked" />

</animated-selector>
```

`app/apk/src/main/res/drawable/ic_superuser_outlined_md2.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:height="24dp"
    android:width="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M21,11C21,16.55 17.16,21.74 12,23C6.84,21.74 3,16.55 3,11V5L12,1L21,5V11M12,21C15.75,20 19,15.54 19,11.22V6.3L12,3.18L5,6.3V11.22C5,15.54 8.25,20 12,21Z" />
</vector>
```

`app/apk/src/main/res/drawable/ic_update_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?colorOnSurface"
        android:pathData="M17,1H7A2,2 0 0,0 5,3V21A2,2 0 0,0 7,23H17A2,2 0 0,0 19,21V3A2,2 0 0,0 17,1M17,19H7V5H17V19M16,13H13V8H11V13H8L12,17L16,13Z" />
</vector>
```

`app/apk/src/main/res/layout/activity_main_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <androidx.coordinatorlayout.widget.CoordinatorLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        app:consumeSystemWindowsInsets="start|end"
        app:edgeToEdge="true"
        app:fitsSystemWindowsInsets="start|end"
        tools:ignore="RtlHardcoded">

        <androidx.fragment.app.FragmentContainerView
            android:id="@+id/main_nav_host"
            android:name="androidx.navigation.fragment.NavHostFragment"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            app:defaultNavHost="true"
            app:navGraph="@navigation/main" />

        <com.google.android.material.appbar.AppBarLayout
            android:id="@+id/main_toolbar_wrapper"
            style="@style/WidgetFoundation.Appbar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:fitsSystemWindowsInsets="top">

            <com.google.android.material.appbar.MaterialToolbar
                android:id="@+id/main_toolbar"
                style="@style/WidgetFoundation.Toolbar"
                android:layout_width="match_parent"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_scrollFlags="noScroll"
                tools:layout_marginTop="24dp"
                tools:title="Home" />

        </com.google.android.material.appbar.AppBarLayout>

        <com.topjohnwu.magisk.widget.ConcealableBottomNavigationView
            android:id="@+id/main_navigation"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="bottom|center_horizontal"
            android:fitsSystemWindows="false"
            android:paddingBottom="0dp"
            app:fitsSystemWindowsInsets="start|end|bottom"
            app:itemHorizontalTranslationEnabled="false"
            app:itemIconTint="@color/color_menu_tint"
            app:itemRippleColor="?colorPrimary"
            app:itemTextAppearanceActive="@style/AppearanceFoundation.Tiny.Bold"
            app:itemTextAppearanceInactive="@style/AppearanceFoundation.Tiny.Bold"
            app:itemTextColor="@color/color_menu_tint"
            app:labelVisibilityMode="labeled"
            app:menu="@menu/menu_bottom_nav" />

    </androidx.coordinatorlayout.widget.CoordinatorLayout>

</layout>

```

`app/apk/src/main/res/layout/activity_request.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.surequest.SuRequestViewModel" />

    </data>

    <com.google.android.material.card.MaterialCardView
        style="@style/WidgetFoundation.Card.Elevated"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center">

        <LinearLayout
            android:id="@+id/su_popup"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:minWidth="350dp"
            android:orientation="vertical">

            <TextView
                android:id="@+id/request_title"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:layout_marginTop="@dimen/l1"
                android:layout_marginBottom="@dimen/l_50"
                android:gravity="center_horizontal"
                android:text="@string/su_request_title"
                android:textAppearance="@style/AppearanceFoundation.Title" />

            <LinearLayout
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:layout_marginTop="@dimen/l_50"
                android:layout_marginBottom="@dimen/l_50"
                android:orientation="horizontal"
                android:paddingStart="10dp"
                android:paddingEnd="10dp">

                <ImageView
                    android:id="@+id/app_icon"
                    style="@style/WidgetFoundation.Icon"
                    android:layout_gravity="center_vertical"
                    android:layout_marginStart="@dimen/l_50"
                    android:layout_marginEnd="@dimen/l1"
                    android:layout_weight="0"
                    android:padding="0dp"
                    android:src="@{viewModel.icon}"
                    app:tint="@null"
                    tools:src="@drawable/ic_delete_md2" />

                <LinearLayout
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="center_vertical"
                    android:layout_weight="1"
                    android:gravity="center_vertical"
                    android:orientation="vertical">

                    <TextView
                        android:id="@+id/app_name"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:ellipsize="end"
                        android:maxWidth="300dp"
                        android:maxLines="1"
                        android:minWidth="200dp"
                        android:text="@{viewModel.title}"
                        android:textAppearance="@style/AppearanceFoundation.Body"
                        android:textStyle="bold"
                        tools:text="Magisk" />

                    <TextView
                        android:id="@+id/package_name"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:ellipsize="end"
                        android:maxWidth="300dp"
                        android:maxLines="1"
                        android:minWidth="200dp"
                        android:text="@{viewModel.packageName}"
                        android:textAppearance="@style/AppearanceFoundation.Caption.Variant"
                        tools:text="com.topjohnwu.magisk" />
                </LinearLayout>
            </LinearLayout>

            <Spinner
                android:id="@+id/timeout"
                onTouch="@{() -> viewModel.spinnerTouched()}"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:enabled="@{viewModel.grantEnabled}"
                app:items="@{@stringArray/allow_timeout}"
                app:layout="@{@layout/item_spinner}"
                android:selection="@={viewModel.selectedItemPosition}" />

            <TextView
                android:id="@+id/warning"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:layout_margin="@dimen/l1"
                android:gravity="center"
                android:text="@string/su_warning"
                android:textAppearance="@style/AppearanceFoundation.Body"
                android:textColor="?colorError"
                android:textStyle="bold"
                tools:text="@string/su_warning" />

            <LinearLayout
                style="?android:buttonBarStyle"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:gravity="bottom"
                android:orientation="horizontal"
                android:paddingStart="@dimen/l2"
                android:paddingEnd="@dimen/l2">

                <Button
                    android:id="@+id/deny_btn"
                    style="@style/WidgetFoundation.Button.Text"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:onClick="@{() -> viewModel.denyPressed()}"
                    android:text="@{viewModel.denyText}"
                    android:textColor="?colorOnSurfaceVariant"
                    tools:text="@string/deny" />

                <Button
                    android:id="@+id/grant_btn"
                    style="@style/WidgetFoundation.Button.Text"
                    onTouch="@{viewModel.grantTouchListener}"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:onClick="@{() -> viewModel.grantPressed()}"
                    android:enabled="@{viewModel.grantEnabled}"
                    android:text="@string/grant" />

                <requestFocus />
            </LinearLayout>

        </LinearLayout>

    </com.google.android.material.card.MaterialCardView>

</layout>

```

`app/apk/src/main/res/layout/dialog_magisk_base.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="data"
            type="com.topjohnwu.magisk.view.MagiskDialog.Data" />

    </data>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        tools:layout_width="match_parent">

        <androidx.constraintlayout.widget.Guideline
            android:id="@+id/dialog_base_start"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            app:layout_constraintGuide_begin="16dp" />

        <androidx.constraintlayout.widget.Guideline
            android:id="@+id/dialog_base_end"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            app:layout_constraintGuide_end="16dp" />

        <ImageView
            android:id="@+id/dialog_base_icon"
            style="@style/WidgetFoundation.Image.Big"
            gone="@{data.icon == null}"
            android:layout_gravity="center"
            android:layout_marginTop="@dimen/l1"
            android:src="@{data.icon}"
            app:layout_constraintBottom_toTopOf="@+id/dialog_base_title"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            tools:src="@drawable/ic_delete_md2" />

        <TextView
            android:id="@+id/dialog_base_title"
            gone="@{data.title.length == 0}"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginTop="@dimen/l1"
            android:gravity="center"
            android:text="@{data.title}"
            android:textAppearance="@style/AppearanceFoundation.Title"
            app:layout_constraintEnd_toEndOf="@+id/dialog_base_end"
            app:layout_constraintStart_toStartOf="@+id/dialog_base_start"
            app:layout_constraintTop_toBottomOf="@+id/dialog_base_icon"
            tools:lines="1"
            tools:text="@tools:sample/lorem/random" />

        <androidx.core.widget.NestedScrollView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginTop="@dimen/l_50"
            android:overScrollMode="ifContentScrolls"
            app:layout_constrainedHeight="true"
            app:layout_constraintBottom_toTopOf="@+id/dialog_base_space"
            app:layout_constraintEnd_toEndOf="@+id/dialog_base_end"
            app:layout_constraintStart_toStartOf="@+id/dialog_base_start"
            app:layout_constraintTop_toBottomOf="@+id/dialog_base_title">

            <FrameLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <TextView
                    android:id="@+id/dialog_base_message"
                    gone="@{data.message.length == 0}"
                    android:layout_width="match_parent"
                    android:layout_height="match_parent"
                    android:text="@{data.message}"
                    android:textAppearance="@style/AppearanceFoundation.Body"
                    tools:lines="3"
                    tools:text="@tools:sample/lorem/random" />

                <FrameLayout
                    android:id="@+id/dialog_base_container"
                    gone="@{data.message.length != 0}"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content" />

            </FrameLayout>

        </androidx.core.widget.NestedScrollView>

        <Space
            android:id="@+id/dialog_base_space"
            android:layout_width="wrap_content"
            android:layout_height="@dimen/l_50"
            app:layout_constraintBottom_toTopOf="@+id/dialog_base_buttons"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent" />

        <androidx.appcompat.widget.ButtonBarLayout
            android:id="@+id/dialog_base_buttons"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:gravity="bottom|center_horizontal"
            android:layoutDirection="locale"
            android:orientation="horizontal"
            android:paddingStart="12dp"
            android:paddingTop="4dp"
            android:paddingEnd="12dp"
            android:paddingBottom="4dp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent">

            <Button
                android:id="@+id/dialog_base_button_2"
                style="@style/WidgetFoundation.Button.Text"
                gone="@{data.buttonNeutral.gone}"
                isEnabled="@{data.buttonNeutral.isEnabled}"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:clickable="@{data.buttonNeutral.isEnabled}"
                android:focusable="@{data.buttonNeutral.isEnabled}"
                android:onClick="@{() -> data.buttonNeutral.clicked()}"
                android:text="@{data.buttonNeutral.message}"
                app:icon="@{data.buttonNeutral.icon}"
                app:iconGravity="textStart"
                tools:icon="@drawable/ic_bug_md2"
                tools:text="Button 1" />

            <Space
                android:id="@+id/spacer"
                android:layout_width="0dp"
                android:layout_height="0dp"
                android:layout_weight="1"
                android:visibility="invisible" />

            <Button
                android:id="@+id/dialog_base_button_3"
                style="@style/WidgetFoundation.Button.Text"
                gone="@{data.buttonNegative.gone}"
                isEnabled="@{data.buttonNegative.isEnabled}"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:clickable="@{data.buttonNegative.isEnabled}"
                android:focusable="@{data.buttonNegative.isEnabled}"
                android:onClick="@{() -> data.buttonNegative.clicked()}"
                android:text="@{data.buttonNegative.message}"
                app:icon="@{data.buttonNegative.icon}"
                tools:icon="@drawable/ic_bug_md2"
                tools:text="Button 1" />

            <Button
                android:id="@+id/dialog_base_button_1"
                style="@style/WidgetFoundation.Button.Text"
                gone="@{data.buttonPositive.gone}"
                isEnabled="@{data.buttonPositive.isEnabled}"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:clickable="@{data.buttonPositive.isEnabled}"
                android:focusable="@{data.buttonPositive.isEnabled}"
                android:onClick="@{() -> data.buttonPositive.clicked()}"
                android:text="@{data.buttonPositive.message}"
                app:icon="@{data.buttonPositive.icon}"
                app:iconGravity="textStart"
                tools:icon="@drawable/ic_bug_md2"
                tools:text="Button 1" />

        </androidx.appcompat.widget.ButtonBarLayout>

    </androidx.constraintlayout.widget.ConstraintLayout>

</layout>

```

`app/apk/src/main/res/layout/dialog_settings_app_name.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="data"
            type="com.topjohnwu.magisk.ui.settings.Hide" />

    </data>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="@dimen/margin_generic">

        <com.google.android.material.textfield.TextInputLayout
            style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox.Dense"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="@dimen/margin_generic"
            android:hint="@string/settings_app_name_hint"
            app:boxStrokeColor="?colorOnSurfaceVariant"
            app:counterEnabled="true"
            app:counterMaxLength="@{data.maxLength}"
            app:counterOverflowTextColor="?colorError"
            app:error="@{data.error ? @string/settings_app_name_error : @string/empty}"
            app:errorEnabled="true"
            app:errorTextColor="?colorError"
            app:helperText="@string/settings_app_name_helper"
            app:hintEnabled="true"
            app:hintTextAppearance="@style/AppearanceFoundation.Tiny"
            app:hintTextColor="?colorOnSurfaceVariant">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/dialog_custom_download_text"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="textCapWords"
                android:text="@={data.result}"
                android:textAppearance="@style/AppearanceFoundation.Body"
                android:textColor="?colorOnSurface"
                tools:text="@tools:sample/lorem" />

        </com.google.android.material.textfield.TextInputLayout>

    </LinearLayout>

</layout>

```

`app/apk/src/main/res/layout/dialog_settings_download_path.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="data"
            type="com.topjohnwu.magisk.ui.settings.DownloadPath" />

    </data>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="@dimen/margin_generic">

        <TextView
            android:id="@+id/dialog_custom_download_title"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@{@string/settings_download_path_message(data.path)}"
            android:textAppearance="@style/AppearanceFoundation.Caption"
            tools:text="@string/settings_download_path_message" />

        <com.google.android.material.textfield.TextInputLayout
            style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox.Dense"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="@dimen/margin_generic"
            android:hint="@string/settings_download_path_title"
            app:boxStrokeColor="?colorOnSurfaceVariant"
            app:errorTextColor="?colorError"
            app:hintEnabled="true"
            app:hintTextAppearance="@style/AppearanceFoundation.Tiny"
            app:hintTextColor="?colorOnSurfaceVariant">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/dialog_custom_download_text"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="textUri"
                android:text="@={data.inputResult}"
                android:textAppearance="@style/AppearanceFoundation.Body"
                android:textColor="?colorOnSurface"
                tools:text="@tools:sample/lorem" />

        </com.google.android.material.textfield.TextInputLayout>

    </LinearLayout>

</layout>

```

`app/apk/src/main/res/layout/dialog_settings_update_channel.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="data"
            type="com.topjohnwu.magisk.ui.settings.UpdateChannelUrl" />

    </data>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="@dimen/margin_generic">

        <com.google.android.material.textfield.TextInputLayout
            style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox.Dense"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="@dimen/margin_generic"
            android:hint="@string/settings_update_custom_msg"
            app:boxStrokeColor="?colorOnSurfaceVariant"
            app:errorTextColor="?colorError"
            app:hintEnabled="true"
            app:hintTextAppearance="@style/AppearanceFoundation.Tiny"
            app:hintTextColor="?colorOnSurfaceVariant">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/dialog_custom_download_text"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="textUri"
                android:text="@={data.inputResult}"
                android:textAppearance="@style/AppearanceFoundation.Body"
                android:textColor="?colorOnSurface"
                tools:text="@tools:sample/lorem" />

        </com.google.android.material.textfield.TextInputLayout>

    </LinearLayout>

</layout>

```

`app/apk/src/main/res/layout/fragment_action_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.module.ActionViewModel" />

    </data>

    <androidx.coordinatorlayout.widget.CoordinatorLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <HorizontalScrollView
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_marginTop="@dimen/internal_action_bar_size"
            app:layout_fitsSystemWindowsInsets="top"
            tools:layout_marginTop="@dimen/internal_action_bar_size">

            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/flash_content"
                scrollToLast="@{true}"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:clipToPadding="false"
                android:orientation="vertical"
                app:fitsSystemWindowsInsets="start|end|bottom"
                app:items="@{viewModel.items}"
                app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
                app:layout_behavior="@string/appbar_scrolling_view_behavior"
                tools:listitem="@layout/item_console_md2" />

        </HorizontalScrollView>

        <com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton
            android:id="@+id/close_btn"
            android:visibility="gone"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="bottom|end"
            android:layout_margin="@dimen/l1"
            android:layout_marginBottom="@dimen/l1"
            android:clickable="true"
            android:enabled="true"
            android:focusable="true"
            android:text="@string/close"
            android:textAllCaps="false"
            android:textColor="?colorOnPrimary"
            android:textStyle="bold"
            app:backgroundTint="?colorPrimary"
            app:icon="@drawable/ic_close_md2"
            app:iconTint="?colorOnPrimary"
            app:layout_fitsSystemWindowsInsets="bottom" />

        <androidx.coordinatorlayout.widget.CoordinatorLayout
            android:id="@+id/snackbar_container"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            app:fitsSystemWindowsInsets="top|bottom" />

    </androidx.coordinatorlayout.widget.CoordinatorLayout>

</layout>

```

`app/apk/src/main/res/layout/fragment_deny_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.deny.DenyListViewModel" />

    </data>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/app_list"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:clipToPadding="false"
            android:orientation="vertical"
            android:paddingTop="@dimen/internal_action_bar_size"
            app:fitsSystemWindowsInsets="top|bottom"
            app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
            app:invisible="@{viewModel.loading}"
            app:items="@{viewModel.items}"
            app:extraBindings="@{viewModel.extraBindings}"
            tools:listitem="@layout/item_hide_md2"
            tools:paddingTop="40dp" />

        <LinearLayout
            goneUnless="@{viewModel.loading}"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center"
            android:orientation="vertical"
            tools:visibility="gone">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/loading"
                android:textAppearance="@style/AppearanceFoundation.Title"
                android:textStyle="bold" />

            <ProgressBar
                style="@style/WidgetFoundation.ProgressBar.Indeterminate"
                android:layout_marginTop="@dimen/l1" />

        </LinearLayout>

    </FrameLayout>

</layout>

```

`app/apk/src/main/res/layout/fragment_flash_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.flash.FlashViewModel" />

    </data>

    <androidx.coordinatorlayout.widget.CoordinatorLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <HorizontalScrollView
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_marginTop="@dimen/internal_action_bar_size"
            app:layout_fitsSystemWindowsInsets="top"
            tools:layout_marginTop="@dimen/internal_action_bar_size">

            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/flash_content"
                scrollToLast="@{true}"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:clipToPadding="false"
                android:orientation="vertical"
                app:fitsSystemWindowsInsets="start|end|bottom"
                app:items="@{viewModel.items}"
                app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
                app:layout_behavior="@string/appbar_scrolling_view_behavior"
                tools:listitem="@layout/item_console_md2" />

        </HorizontalScrollView>

        <com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton
            android:id="@+id/restart_btn"
            android:visibility="gone"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="bottom|end"
            android:layout_margin="@dimen/l1"
            android:layout_marginBottom="@dimen/l1"
            android:clickable="@{!viewModel.flashing}"
            android:enabled="@{!viewModel.flashing}"
            android:focusable="true"
            android:onClick="@{() -> viewModel.restartPressed()}"
            android:text="@string/reboot"
            android:textAllCaps="false"
            android:textColor="?colorOnPrimary"
            android:textStyle="bold"
            app:backgroundTint="?colorPrimary"
            app:icon="@drawable/ic_restart"
            app:iconTint="?colorOnPrimary"
            app:layout_fitsSystemWindowsInsets="bottom" />

        <androidx.coordinatorlayout.widget.CoordinatorLayout
            android:id="@+id/snackbar_container"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            app:fitsSystemWindowsInsets="top|bottom" />

    </androidx.coordinatorlayout.widget.CoordinatorLayout>

</layout>

```

`app/apk/src/main/res/layout/fragment_home_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <import type="com.topjohnwu.magisk.core.Info" />

        <import type="com.topjohnwu.magisk.ui.home.DeveloperItem" />

        <import type="com.topjohnwu.magisk.ui.home.IconLink" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.home.HomeViewModel" />

    </data>

    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false"
        android:fillViewport="true"
        android:paddingTop="@dimen/internal_action_bar_size"
        android:paddingBottom="@dimen/l3"
        app:fitsSystemWindowsInsets="top|bottom"
        tools:layout_marginTop="24dp">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:clipToPadding="false"
            android:orientation="vertical"
            android:paddingTop="@dimen/l1">

            <Button
                style="@style/WidgetFoundation.Button"
                gone="@{!viewModel.showTest}"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:onClick="@{() -> viewModel.onTestPressed()}"
                android:text="TEST"
                android:textAllCaps="false"
                tools:visibility="gone" />

            <com.google.android.material.card.MaterialCardView
                style="@style/WidgetFoundation.Card.Primary"
                goneUnless="@{viewModel.noticeVisible}"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginStart="@dimen/l1"
                android:layout_marginEnd="@dimen/l1"
                android:layout_marginBottom="@dimen/l1"
                android:focusable="false">

                <androidx.constraintlayout.widget.ConstraintLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content">

                    <TextView
                        android:id="@+id/home_notice_content"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:padding="@dimen/l1"
                        android:text="@string/home_notice_content"
                        android:textAppearance="@style/AppearanceFoundation.Caption.OnPrimary"
                        app:layout_constraintEnd_toStartOf="@+id/home_notice_hide"
                        app:layout_constraintStart_toStartOf="parent"
                        app:layout_constraintTop_toTopOf="parent" />

                    <Button
                        android:id="@+id/home_notice_hide"
                        style="@style/WidgetFoundation.Button.Text.OnPrimary"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:onClick="@{() -> viewModel.hideNotice()}"
                        android:text="@string/hide"
                        android:textAllCaps="false"
                        app:layout_constraintBottom_toBottomOf="parent"
                        app:layout_constraintEnd_toEndOf="parent"
                        app:layout_constraintTop_toTopOf="parent" />

                </androidx.constraintlayout.widget.ConstraintLayout>

            </com.google.android.material.card.MaterialCardView>

            <include
                android:id="@+id/home_magisk_wrapper"
                layout="@layout/include_home_magisk"
                viewModel="@{viewModel}"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginStart="@dimen/l1"
                android:layout_marginEnd="@dimen/l1"
                app:layout_constraintTop_toBottomOf="@+id/home_device_wrapper" />

            <include
                android:id="@+id/home_manager_wrapper"
                layout="@layout/include_home_manager"
                viewModel="@{viewModel}"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginStart="@dimen/l1"
                android:layout_marginTop="@dimen/l1"
                android:layout_marginEnd="@dimen/l1"
                app:layout_constraintTop_toBottomOf="@+id/home_magisk_wrapper" />

            <Space
                goneUnless="@{Info.env.isActive}"
                android:layout_width="match_parent"
                android:layout_height="@dimen/l1" />

            <Button
                style="@style/WidgetFoundation.Button.Outlined.Error"
                goneUnless="@{Info.env.isActive}"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginStart="@dimen/l1"
                android:layout_marginEnd="@dimen/l1"
                android:onClick="@{() -> viewModel.onDeletePressed()}"
                android:text="@string/uninstall_magisk_title"
                android:textAllCaps="false"
                android:textSize="12sp"
                app:cornerRadius="@dimen/r1"
                app:icon="@drawable/ic_delete_md2" />

            <com.google.android.material.card.MaterialCardView
                style="@style/WidgetFoundation.Card"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="bottom"
                android:layout_marginStart="@dimen/l1"
                android:layout_marginEnd="@dimen/l1"
                android:layout_marginTop="@dimen/l1"
                android:focusable="false">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:paddingTop="@dimen/l1"
                    android:paddingBottom="@dimen/l1">

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:layout_marginStart="@dimen/l1"
                        android:layout_marginEnd="@dimen/l1"
                        android:text="@string/home_support_title"
                        android:textAppearance="@style/AppearanceFoundation.Title" />

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:layout_marginStart="@dimen/l1"
                        android:layout_marginTop="@dimen/l_50"
                        android:layout_marginEnd="@dimen/l1"
                        android:text="@string/home_support_content"
                        android:textAppearance="@style/AppearanceFoundation.Caption.Variant" />

                    <LinearLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal"
                        android:paddingTop="@dimen/l_50" >

                        <include
                            item="@{IconLink.Patreon.INSTANCE}"
                            layout="@layout/item_icon_link"
                            viewModel="@{viewModel}"
                            android:layout_width="wrap_content"
                            android:layout_height="wrap_content"
                            android:layout_weight="1" />

                        <include
                            item="@{IconLink.PayPal.Project.INSTANCE}"
                            layout="@layout/item_icon_link"
                            viewModel="@{viewModel}"
                            android:layout_width="wrap_content"
                            android:layout_height="wrap_content"
                            android:layout_weight="1" />

                    </LinearLayout>

                </LinearLayout>

            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                style="@style/WidgetFoundation.Card"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="bottom"
                android:layout_margin="@dimen/l1"
                android:focusable="false">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:paddingTop="@dimen/l1">

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:layout_marginStart="@dimen/l1"
                        android:layout_marginEnd="@dimen/l1"
                        android:text="@string/home_follow_title"
                        android:textAppearance="@style/AppearanceFoundation.Title" />

                    <include
                        item="@{DeveloperItem.John.INSTANCE}"
                        layout="@layout/item_developer"
                        viewModel="@{viewModel}"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="@dimen/l_50" />

                    <include
                        item="@{DeveloperItem.Vvb.INSTANCE}"
                        layout="@layout/item_developer"
                        viewModel="@{viewModel}"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="@dimen/l_50" />

                    <include
                        item="@{DeveloperItem.YU.INSTANCE}"
                        layout="@layout/item_developer"
                        viewModel="@{viewModel}"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="@dimen/l_50" />

                    <include
                        item="@{DeveloperItem.Rikka.INSTANCE}"
                        layout="@layout/item_developer"
                        viewModel="@{viewModel}"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="@dimen/l_50" />

                    <include
                        item="@{DeveloperItem.Canyie.INSTANCE}"
                        layout="@layout/item_developer"
                        viewModel="@{viewModel}"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="@dimen/l_50" />

                </LinearLayout>

            </com.google.android.material.card.MaterialCardView>

        </LinearLayout>

    </androidx.core.widget.NestedScrollView>

</layout>

```

`app/apk/src/main/res/layout/fragment_install_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <import type="com.topjohnwu.magisk.core.Info" />

        <import type="com.topjohnwu.magisk.core.Config" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.install.InstallViewModel" />

    </data>

    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false"
        android:fillViewport="true"
        android:paddingTop="@dimen/internal_action_bar_size"
        android:paddingBottom="@dimen/l2"
        app:fitsSystemWindowsInsets="top|bottom"
        tools:paddingTop="24dp">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:clipToPadding="false"
            android:orientation="vertical"
            android:paddingTop="@dimen/l_50">

            <com.google.android.material.card.MaterialCardView
                style="@style/WidgetFoundation.Card"
                gone="@{viewModel.skipOptions}"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginStart="@dimen/l1"
                android:layout_marginEnd="@dimen/l1"
                android:focusable="false">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical">

                    <LinearLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal">

                        <ImageView
                            style="@style/WidgetFoundation.Icon"
                            isSelected="@{viewModel.step > 0}"
                            android:layout_marginStart="@dimen/l_25"
                            app:srcCompat="@drawable/ic_check_circle_md2" />

                        <TextView
                            android:layout_width="0dp"
                            android:layout_height="match_parent"
                            android:layout_marginStart="@dimen/l1"
                            android:layout_weight="1"
                            android:gravity="center_vertical"
                            android:text="@string/install_options_title"
                            android:textAppearance="@style/AppearanceFoundation.Body"
                            android:textStyle="bold" />

                        <Button
                            style="@style/WidgetFoundation.Button.Text"
                            gone="@{viewModel.step != 0}"
                            android:layout_width="wrap_content"
                            android:layout_height="wrap_content"
                            android:onClick="@{() -> viewModel.setStep(1)}"
                            android:text="@string/install_next" />

                    </LinearLayout>

                    <LinearLayout
                        gone="@{viewModel.step != 0}"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:layout_marginStart="@dimen/l1"
                        android:layout_marginTop="@dimen/l_50"
                        android:layout_marginEnd="@dimen/l1"
                        android:layout_marginBottom="@dimen/l_50"
                        android:orientation="vertical"
                        android:paddingStart="3dp"
                        android:paddingEnd="3dp"
                        tools:layout_gravity="center">

                        <CheckBox
                            style="@style/WidgetFoundation.Checkbox"
                            gone="@{Info.isSAR}"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:checked="@={Config.keepVerity}"
                            android:text="@string/keep_dm_verity"
                            tools:checked="true" />

                        <CheckBox
                            style="@style/WidgetFoundation.Checkbox"
                            goneUnless="@{Info.isFDE}"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:checked="@={Config.keepEnc}"
                            android:text="@string/keep_force_encryption"
                            app:tint="?colorPrimary" />

                        <CheckBox
                            style="@style/WidgetFoundation.Checkbox"
                            gone="@{Info.ramdisk}"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:checked="@={Config.recovery}"
                            android:text="@string/recovery_mode"
                            app:tint="?colorPrimary" />

                    </LinearLayout>

                </LinearLayout>

            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                style="@style/WidgetFoundation.Card"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginStart="@dimen/l1"
                android:layout_marginTop="@dimen/l1"
                android:layout_marginEnd="@dimen/l1"
                android:focusable="false">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical">

                    <LinearLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal">

                        <ImageView
                            style="@style/WidgetFoundation.Icon"
                            isSelected="@{viewModel.step > 1}"
                            android:layout_marginStart="@dimen/l_25"
                            app:srcCompat="@drawable/ic_check_circle_md2" />

                        <TextView
                            android:layout_width="0dp"
                            android:layout_height="match_parent"
                            android:layout_marginStart="@dimen/l1"
                            android:layout_weight="1"
                            android:gravity="center_vertical"
                            android:text="@string/install_method_title"
                            android:textAppearance="@style/AppearanceFoundation.Body"
                            android:textStyle="bold" />

                        <Button
                            style="@style/WidgetFoundation.Button.Text"
                            gone="@{viewModel.step != 1}"
                            isEnabled="@{viewModel.method == @id/method_patch ? viewModel.data != null : viewModel.method != -1}"
                            android:layout_width="wrap_content"
                            android:layout_height="wrap_content"
                            android:onClick="@{() -> viewModel.install()}"
                            android:text="@string/install_start"
                            app:icon="@drawable/ic_forth_md2"
                            app:iconGravity="textEnd" />

                    </LinearLayout>

                    <RadioGroup
                        gone="@{viewModel.step != 1}"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:layout_marginStart="@dimen/l1"
                        android:layout_marginTop="@dimen/l_50"
                        android:layout_marginEnd="@dimen/l1"
                        android:layout_marginBottom="@dimen/l_50"
                        android:checkedButton="@={viewModel.method}"
                        android:paddingStart="3dp"
                        android:paddingEnd="3dp">

                        <RadioButton
                            android:id="@+id/method_patch"
                            style="@style/WidgetFoundation.RadioButton"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:text="@string/select_patch_file" />

                        <RadioButton
                            android:id="@+id/method_direct"
                            style="@style/WidgetFoundation.RadioButton"
                            gone="@{!viewModel.rooted}"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:text="@string/direct_install" />

                        <RadioButton
                            android:id="@+id/method_inactive_slot"
                            style="@style/WidgetFoundation.RadioButton"
                            gone="@{viewModel.noSecondSlot}"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:text="@string/install_inactive_slot" />

                    </RadioGroup>

                </LinearLayout>

            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                style="@style/WidgetFoundation.Card"
                gone="@{viewModel.notes.length == 0}"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginStart="@dimen/l1"
                android:layout_marginTop="@dimen/l1"
                android:layout_marginEnd="@dimen/l1"
                android:focusable="false">

                <TextView
                    android:id="@+id/release_notes"
                    markdownText="@{viewModel.notes}"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_margin="15dp"
                    android:breakStrategy="simple"
                    android:hyphenationFrequency="none"
                    android:textAppearance="@style/AppearanceFoundation.Caption"
                    tools:ignore="UnusedAttribute"
                    tools:maxLines="5"
                    tools:text="@tools:sample/lorem/random"
                    tools:visibility="visible" />

            </com.google.android.material.card.MaterialCardView>

        </LinearLayout>

    </androidx.core.widget.NestedScrollView>

</layout>

```

`app/apk/src/main/res/layout/fragment_log_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.log.LogViewModel" />

    </data>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <include
            android:id="@+id/log_filter_magisk"
            layout="@layout/include_log_magisk"
            viewModel="@{viewModel}"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />

        <com.google.android.material.floatingactionbutton.FloatingActionButton
            gone="@{viewModel.loading}"
            android:id="@+id/log_filter_toggle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="bottom|end"
            android:layout_marginStart="@dimen/l1"
            android:layout_marginEnd="@dimen/l1"
            android:layout_marginBottom="72dp"
            app:layout_fitsSystemWindowsInsets="bottom"
            app:backgroundTint="?colorSurfaceSurfaceVariant"
            app:srcCompat="@drawable/ic_folder_list"
            app:tint="?colorPrimary"
            tools:layout_marginBottom="64dp" />

        <com.google.android.material.circularreveal.cardview.CircularRevealCardView
            android:id="@+id/log_filter"
            style="@style/WidgetFoundation.Card"
            app:cardBackgroundColor="?colorSurface"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_gravity="bottom"
            android:visibility="invisible"
            app:cardCornerRadius="0dp">

            <include
                android:id="@+id/log_filter_superuser"
                layout="@layout/include_log_superuser"
                viewModel="@{viewModel}"
                android:layout_width="match_parent"
                android:layout_height="match_parent" />

        </com.google.android.material.circularreveal.cardview.CircularRevealCardView>

    </FrameLayout>

</layout>

```

`app/apk/src/main/res/layout/fragment_module_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.module.ModuleViewModel" />

    </data>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/module_list"
            gone="@{viewModel.loading}"
            app:items="@{viewModel.items}"
            app:extraBindings="@{viewModel.extraBindings}"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:clipToPadding="false"
            android:orientation="vertical"
            android:paddingTop="@dimen/internal_action_bar_size"
            android:paddingBottom="@dimen/internal_action_bar_size"
            app:fitsSystemWindowsInsets="top|bottom"
            app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
            tools:listitem="@layout/item_module_md2" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center"
            android:orientation="vertical">

            <TextView
                goneUnless="@{viewModel.loading}"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/loading"
                android:textAppearance="@style/AppearanceFoundation.Title"
                android:textStyle="bold" />

            <ProgressBar
                style="@style/WidgetFoundation.ProgressBar.Indeterminate"
                goneUnless="@{viewModel.loading}"
                android:layout_marginTop="@dimen/l1" />

            <TextView
                gone="@{viewModel.loading || viewModel.items.size() != 1 }"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/module_empty"
                android:textAppearance="@style/AppearanceFoundation.Title"
                android:textStyle="bold" />
        </LinearLayout>

    </FrameLayout>


</layout>

```

`app/apk/src/main/res/layout/fragment_settings_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.settings.SettingsViewModel" />

    </data>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <androidx.recyclerview.widget.RecyclerView
            app:items="@{viewModel.items}"
            app:extraBindings="@{viewModel.extraBindings}"
            android:id="@+id/settings_list"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:focusableInTouchMode="false"
            android:clipToPadding="false"
            android:orientation="vertical"
            android:paddingTop="@dimen/internal_action_bar_size"
            app:fitsSystemWindowsInsets="top|bottom"
            app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
            tools:layout_marginTop="24dp"
            tools:listitem="@layout/item_settings"
            tools:paddingTop="@dimen/l1" />

        <androidx.coordinatorlayout.widget.CoordinatorLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:id="@+id/snackbar_container"
            app:fitsSystemWindowsInsets="top|bottom"/>
    </FrameLayout>

</layout>

```

`app/apk/src/main/res/layout/fragment_superuser_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.superuser.SuperuserViewModel" />

    </data>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/superuser_list"
            gone="@{viewModel.loading}"
            app:items="@{viewModel.items}"
            app:extraBindings="@{viewModel.extraBindings}"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:clipToPadding="false"
            android:orientation="vertical"
            android:paddingTop="@dimen/internal_action_bar_size"
            android:paddingBottom="56dp"
            app:fitsSystemWindowsInsets="top|bottom"
            app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
            tools:listitem="@layout/item_policy_md2" />

        <LinearLayout
            goneUnless="@{viewModel.loading}"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center"
            android:orientation="vertical"
            tools:visibility="gone">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/loading"
                android:textAppearance="@style/AppearanceFoundation.Title"
                android:textStyle="bold" />

            <ProgressBar
                style="@style/WidgetFoundation.ProgressBar.Indeterminate"
                android:layout_marginTop="@dimen/l1" />

        </LinearLayout>

    </FrameLayout>

</layout>

```

`app/apk/src/main/res/layout/fragment_theme_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <data>

        <import type="com.topjohnwu.magisk.ui.theme.Theme" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.theme.ThemeViewModel" />

    </data>

    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false"
        android:fillViewport="true"
        android:paddingStart="@dimen/l1"
        android:paddingTop="@dimen/internal_action_bar_size"
        android:paddingEnd="@dimen/l1"
        android:paddingBottom="@dimen/l1"
        app:fitsSystemWindowsInsets="top|bottom">

        <LinearLayout
            android:id="@+id/theme_container"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingTop="@dimen/l1"
            android:useDefaultMargins="true">

            <include
                android:id="@+id/theme_card_dark"
                item="@{viewModel.themeHeadline}"
                layout="@layout/item_tappable_headline"
                listener="@{viewModel}" />

        </LinearLayout>

    </androidx.core.widget.NestedScrollView>

</layout>

```

`app/apk/src/main/res/layout/include_home_magisk.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <import type="com.topjohnwu.magisk.core.Info" />

        <import type="com.topjohnwu.magisk.ui.home.HomeViewModel.State" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.home.HomeViewModel" />

    </data>

    <com.google.android.material.card.MaterialCardView
        style="@style/WidgetFoundation.Card"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:focusable="false">

        <androidx.constraintlayout.widget.ConstraintLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:paddingStart="@dimen/l1"
            android:paddingTop="@dimen/l_50"
            android:paddingEnd="@dimen/l1"
            android:paddingBottom="@dimen/l_50"
            tools:layout_gravity="center">

            <ImageView
                android:id="@+id/home_magisk_icon"
                style="@style/WidgetFoundation.Icon.Primary"
                android:padding="@dimen/l_25"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:srcCompat="@drawable/ic_magisk_outline" />

            <TextView
                android:id="@+id/home_magisk_title"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_marginStart="@dimen/l1"
                android:text="@string/magisk"
                android:textAppearance="@style/AppearanceFoundation.Title"
                android:textColor="?colorPrimary"
                android:maxLines="1"
                android:ellipsize="end"
                app:layout_constraintBottom_toBottomOf="@+id/home_magisk_icon"
                app:layout_constraintEnd_toStartOf="@+id/home_magisk_button"
                app:layout_constraintStart_toEndOf="@+id/home_magisk_icon"
                app:layout_constraintTop_toTopOf="@+id/home_magisk_icon" />

            <FrameLayout
                android:id="@+id/home_magisk_button"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintBottom_toBottomOf="@+id/home_magisk_title"
                app:layout_constraintTop_toTopOf="@+id/home_magisk_title">

                <Button
                    style="@style/WidgetFoundation.Button"
                    gone="@{viewModel.magiskState != State.OUTDATED}"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:onClick="@{() -> viewModel.onMagiskPressed()}"
                    android:text="@string/update"
                    android:textAllCaps="false"
                    android:layout_gravity="end"
                    app:icon="@drawable/ic_update_md2" />

                <Button
                    style="@style/WidgetFoundation.Button.Text"
                    gone="@{viewModel.magiskState == State.OUTDATED}"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="end"
                    android:onClick="@{() -> viewModel.onMagiskPressed()}"
                    android:text="@string/install"
                    android:textAllCaps="false"
                    app:icon="@drawable/ic_install"/>

            </FrameLayout>

            <androidx.constraintlayout.widget.Barrier
                android:id="@+id/home_magisk_title_barrier"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                app:barrierDirection="bottom"
                app:referencedIds="@{viewModel.magiskTitleBarrierIds}"
                tools:constraint_referenced_ids="home_magisk_icon,home_magisk_title,home_magisk_button" />

            <HorizontalScrollView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:fadingEdgeLength="@dimen/l1"
                android:requiresFadingEdge="horizontal"
                android:scrollbars="none"
                app:layout_constraintTop_toBottomOf="@+id/home_magisk_title_barrier">

                <LinearLayout
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal">

                    <androidx.constraintlayout.widget.ConstraintLayout
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content">

                        <LinearLayout
                            android:id="@+id/home_magisk_installed_version"
                            style="@style/W.Home.Item.Top"
                            app:layout_constraintStart_toStartOf="parent"
                            app:layout_constraintTop_toTopOf="parent">

                            <TextView
                                style="@style/W.Home.ItemContent"
                                android:text="@string/home_installed_version" />

                            <TextView
                                style="@style/W.Home.ItemContent.Right"
                                android:text="@{viewModel.magiskInstalledVersion}"
                                tools:text="22.0 (22000)" />

                        </LinearLayout>

                        <LinearLayout
                            android:id="@+id/home_device_details_zygisk"
                            style="@style/W.Home.Item"
                            app:layout_constraintStart_toStartOf="@+id/home_magisk_installed_version"
                            app:layout_constraintTop_toBottomOf="@+id/home_magisk_installed_version">

                            <TextView
                                style="@style/W.Home.ItemContent"
                                android:text="@string/zygisk" />

                            <TextView
                                style="@style/W.Home.ItemContent.Right"
                                android:text="@{Info.isZygiskEnabled ? @string/yes : @string/no}"
                                tools:text="Yes" />

                        </LinearLayout>

                        <LinearLayout
                            android:id="@+id/home_device_details_ramdisk"
                            style="@style/W.Home.Item.Bottom"
                            app:layout_constraintStart_toStartOf="@+id/home_magisk_installed_version"
                            app:layout_constraintTop_toBottomOf="@+id/home_device_details_zygisk">

                            <TextView
                                style="@style/W.Home.ItemContent"
                                android:text="Ramdisk" />

                            <TextView
                                style="@style/W.Home.ItemContent.Right"
                                android:text="@{Info.ramdisk ? @string/yes : @string/no }"
                                tools:text="Yes" />

                        </LinearLayout>

                    </androidx.constraintlayout.widget.ConstraintLayout>

                </LinearLayout>

            </HorizontalScrollView>

        </androidx.constraintlayout.widget.ConstraintLayout>

    </com.google.android.material.card.MaterialCardView>

</layout>

```

`app/apk/src/main/res/layout/include_home_manager.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <import type="com.topjohnwu.magisk.ui.home.HomeViewModel.State" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.home.HomeViewModel" />

    </data>

    <com.google.android.material.card.MaterialCardView
        style="@style/WidgetFoundation.Card"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:focusable="false">

        <androidx.constraintlayout.widget.ConstraintLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:paddingStart="@dimen/l1"
            android:paddingTop="@dimen/l_50"
            android:paddingEnd="@dimen/l1"
            android:paddingBottom="@dimen/l_50"
            tools:layout_gravity="center">

            <ImageView
                android:id="@+id/home_manager_icon"
                style="@style/WidgetFoundation.Icon.Primary"
                android:padding="@dimen/l_50"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:srcCompat="@drawable/ic_manager" />

            <TextView
                android:id="@+id/home_manager_title"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_marginStart="@dimen/l1"
                android:text="@string/home_app_title"
                android:textAppearance="@style/AppearanceFoundation.Title"
                android:textColor="?colorPrimary"
                android:maxLines="1"
                android:ellipsize="end"
                app:layout_constraintBottom_toBottomOf="@+id/home_manager_icon"
                app:layout_constraintEnd_toStartOf="@+id/home_manager_button"
                app:layout_constraintStart_toEndOf="@+id/home_manager_icon"
                app:layout_constraintTop_toTopOf="parent"
                tools:text="@string/home_app_title" />

            <FrameLayout
                android:id="@+id/home_manager_button"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintBottom_toBottomOf="@+id/home_manager_title"
                app:layout_constraintTop_toTopOf="@+id/home_manager_title">

                <Button
                    style="@style/WidgetFoundation.Button"
                    gone="@{viewModel.appState != State.OUTDATED}"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:onClick="@{() -> viewModel.onManagerPressed()}"
                    android:text="@string/update"
                    android:textAllCaps="false"
                    android:layout_gravity="end"
                    app:icon="@drawable/ic_update_md2" />

                <Button
                    style="@style/WidgetFoundation.Button.Text"
                    gone="@{viewModel.appState != State.UP_TO_DATE}"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="end"
                    android:onClick="@{() -> viewModel.onManagerPressed()}"
                    android:text="@string/install"
                    android:textAllCaps="false"
                    app:icon="@drawable/ic_install"/>

            </FrameLayout>

            <androidx.constraintlayout.widget.Barrier
                android:id="@+id/home_manager_title_barrier"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                app:barrierDirection="bottom"
                app:referencedIds="@{viewModel.appTitleBarrierIds}"
                tools:constraint_referenced_ids="home_manager_icon,home_manager_title,home_manager_button" />

            <HorizontalScrollView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:fadingEdgeLength="@dimen/l1"
                android:requiresFadingEdge="horizontal"
                android:scrollbars="none"
                app:layout_constraintTop_toBottomOf="@+id/home_manager_title_barrier">

                <LinearLayout
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:orientation="vertical">

                    <androidx.constraintlayout.widget.ConstraintLayout
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content">

                        <LinearLayout
                            android:id="@+id/home_manager_latest_version"
                            style="@style/W.Home.Item.Top"
                            app:layout_constraintStart_toStartOf="parent"
                            app:layout_constraintTop_toTopOf="parent">

                            <TextView
                                style="@style/W.Home.ItemContent"
                                android:text="@string/home_latest_version" />

                            <TextView
                                style="@style/W.Home.ItemContent.Right"
                                android:text="@{viewModel.managerRemoteVersion}"
                                tools:text="22.0 (22000) (16)" />

                        </LinearLayout>

                        <LinearLayout
                            android:id="@+id/home_manager_installed_version"
                            style="@style/W.Home.Item"
                            app:layout_constraintStart_toStartOf="parent"
                            app:layout_constraintTop_toBottomOf="@+id/home_manager_latest_version">

                            <TextView
                                style="@style/W.Home.ItemContent"
                                android:text="@string/home_installed_version" />

                            <TextView
                                style="@style/W.Home.ItemContent.Right"
                                android:text="@{viewModel.managerInstalledVersion}"
                                tools:text="22.0 (22000) (16)" />

                        </LinearLayout>

                        <LinearLayout
                            android:id="@+id/home_manager_internal_connection"
                            style="@style/W.Home.Item.Bottom"
                            app:layout_constraintStart_toStartOf="parent"
                            app:layout_constraintTop_toBottomOf="@+id/home_manager_installed_version">

                            <TextView
                                style="@style/W.Home.ItemContent"
                                android:text="@string/home_package" />

                            <TextView
                                android:id="@+id/home_manager_extra_connection_value"
                                style="@style/W.Home.ItemContent.Right"
                                android:text="@{context.packageName}"
                                tools:text="com.topjohnwu.magisk" />

                        </LinearLayout>

                    </androidx.constraintlayout.widget.ConstraintLayout>

                    <ProgressBar
                        style="@style/WidgetFoundation.ProgressBar"
                        gone="@{viewModel.stateManagerProgress == 0 || viewModel.stateManagerProgress == 100}"
                        android:layout_width="match_parent"
                        android:layout_gravity="bottom"
                        android:max="100"
                        android:progress="@{viewModel.stateManagerProgress}" />

                </LinearLayout>

            </HorizontalScrollView>

        </androidx.constraintlayout.widget.ConstraintLayout>

    </com.google.android.material.card.MaterialCardView>

</layout>

```

`app/apk/src/main/res/layout/include_log_magisk.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.log.LogViewModel" />

    </data>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <HorizontalScrollView
            android:id="@+id/log_scroll_magisk"
            gone="@{viewModel.loading}"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:clipToPadding="false"
            android:fillViewport="true">

            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/log_magisk"
                app:items="@{viewModel.logs}"
                app:extraBindings="@{viewModel.extraBindings}"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:clipToPadding="false"
                android:orientation="vertical"
                android:paddingTop="@dimen/internal_action_bar_size"
                android:paddingBottom="@dimen/internal_action_bar_size"
                app:fitsSystemWindowsInsets="top|bottom"
                app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
                tools:listitem="@layout/item_log_textview"
                tools:paddingTop="24dp" />
        </HorizontalScrollView>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center"
            android:orientation="vertical">

            <TextView
                goneUnless="@{viewModel.loading}"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/loading"
                android:textAppearance="@style/AppearanceFoundation.Title"
                android:textStyle="bold" />

            <ProgressBar
                style="@style/WidgetFoundation.ProgressBar.Indeterminate"
                goneUnless="@{viewModel.loading}"
                android:layout_marginTop="@dimen/l1" />

            <FrameLayout
                gone="@{viewModel.loading || !viewModel.magiskLogRaw.empty}"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="center">

                <include
                    item="@{viewModel.itemMagiskEmpty}"
                    layout="@layout/item_text"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content" />

            </FrameLayout>
        </LinearLayout>
    </FrameLayout>

</layout>

```

`app/apk/src/main/res/layout/include_log_superuser.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.log.LogViewModel" />

    </data>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/log_superuser"
            app:items="@{viewModel.items}"
            app:extraBindings="@{viewModel.extraBindings}"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:clipToPadding="false"
            android:orientation="vertical"
            android:paddingTop="@dimen/internal_action_bar_size"
            app:fitsSystemWindowsInsets="top|bottom"
            app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
            tools:listitem="@layout/item_log_access_md2"
            tools:paddingTop="24dp" />

        <ProgressBar
            style="@style/WidgetFoundation.ProgressBar.Indeterminate"
            goneUnless="@{viewModel.loading}"
            android:layout_marginTop="@dimen/l1" />

        <FrameLayout
            gone="@{viewModel.loading || !viewModel.items.empty}"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center">

            <include
                item="@{viewModel.itemEmpty}"
                layout="@layout/item_text"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />

        </FrameLayout>

        <androidx.coordinatorlayout.widget.CoordinatorLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:id="@+id/snackbar_container"
            app:fitsSystemWindowsInsets="top|bottom"/>

    </FrameLayout>

</layout>

```

`app/apk/src/main/res/layout/item_console_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.flash.ConsoleItem" />

    </data>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:fontFamily="monospace"
        android:text="@{item.item}"
        android:textAppearance="@style/AppearanceFoundation.Caption"
        tools:text="@tools:sample/lorem/random" />

</layout>

```

`app/apk/src/main/res/layout/item_developer.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.home.DeveloperItem" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.home.HomeViewModel" />

    </data>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingStart="@dimen/l1"
        android:paddingEnd="@dimen/l1">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{item.handle}"
            android:textAppearance="@style/AppearanceFoundation.Caption"
            android:textStyle="bold"
            tools:text="\@topjohnwu" />

        <androidx.recyclerview.widget.RecyclerView
            app:items="@{item.items}"
            app:extraBindings="@{viewModel.extraBindings}"
            app:nestedScrollingEnabled="@{false}"
            android:overScrollMode="never"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:clipToPadding="false"
            android:fadingEdgeLength="@dimen/l1"
            android:orientation="horizontal"
            android:requiresFadingEdge="horizontal"
            app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
            tools:itemCount="3"
            tools:listitem="@layout/item_icon_link" />

    </LinearLayout>

</layout>

```

`app/apk/src/main/res/layout/item_hide_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <import type="com.topjohnwu.magisk.R" />

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.deny.DenyListRvItem" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.deny.DenyListViewModel" />

    </data>

    <com.google.android.material.card.MaterialCardView
        style="@style/WidgetFoundation.Card"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:focusable="false"
        tools:layout_gravity="center"
        tools:layout_marginBottom="@dimen/l1">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <androidx.constraintlayout.widget.ConstraintLayout
                android:id="@+id/hide_expand"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="?selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:nextFocusRight="@id/hide_expand_icon"
                android:onClick="@{item::toggleExpand}">

                <ImageView
                    android:id="@+id/hide_icon"
                    style="@style/WidgetFoundation.Image"
                    android:layout_margin="@dimen/l1"
                    android:src="@{item.info.iconImage}"
                    app:layout_constraintBottom_toBottomOf="parent"
                    app:layout_constraintStart_toStartOf="parent"
                    app:layout_constraintTop_toTopOf="parent"
                    app:layout_constraintVertical_bias="0"
                    tools:src="@drawable/ic_launcher" />

                <TextView
                    android:id="@+id/hide_name"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_marginStart="@dimen/l1"
                    android:ellipsize="middle"
                    android:singleLine="true"
                    android:text="@{item.info.label}"
                    android:textAppearance="@style/AppearanceFoundation.Body"
                    android:textStyle="bold"
                    app:layout_constraintBottom_toTopOf="@+id/hide_package"
                    app:layout_constraintEnd_toStartOf="@+id/hide_expand_icon"
                    app:layout_constraintStart_toEndOf="@+id/hide_icon"
                    app:layout_constraintTop_toTopOf="parent"
                    app:layout_constraintVertical_chainStyle="packed"
                    tools:text="@string/magisk" />

                <TextView
                    android:id="@+id/hide_package"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:text="@{item.info.packageName}"
                    android:textAppearance="@style/AppearanceFoundation.Caption.Variant"
                    app:layout_constraintBottom_toBottomOf="parent"
                    app:layout_constraintEnd_toEndOf="@+id/hide_name"
                    app:layout_constraintStart_toStartOf="@+id/hide_name"
                    app:layout_constraintTop_toBottomOf="@+id/hide_name"
                    tools:text="com.topjohnwu.magisk" />

                <com.topjohnwu.widget.IndeterminateCheckBox
                    android:id="@+id/hide_expand_icon"
                    state="@={item.state}"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_marginEnd="@dimen/l1"
                    android:minWidth="0dp"
                    android:minHeight="0dp"
                    android:nextFocusLeft="@id/hide_expand"
                    app:layout_constraintBottom_toBottomOf="parent"
                    app:layout_constraintEnd_toEndOf="parent"
                    app:layout_constraintTop_toTopOf="parent" />

            </androidx.constraintlayout.widget.ConstraintLayout>

            <androidx.recyclerview.widget.RecyclerView
                goneUnless="@{item.isExpanded}"
                app:items="@{item.processes}"
                app:extraBindings="@{viewModel.extraBindings}"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="?colorSurfaceVariant"
                android:orientation="vertical"
                app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
                tools:itemCount="2"
                tools:listitem="@layout/item_hide_process_md2" />

        </LinearLayout>

        <ProgressBar
            style="@style/WidgetFoundation.ProgressBar"
            gone="@{item.checkedPercent == 0}"
            android:layout_width="match_parent"
            android:layout_gravity="top"
            android:progress="@{item.checkedPercent}" />

    </com.google.android.material.card.MaterialCardView>

</layout>

```

`app/apk/src/main/res/layout/item_hide_process_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.deny.ProcessRvItem" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.deny.DenyListViewModel" />

    </data>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:alpha="@{item.enabled ? 1f : .7f}">

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="@dimen/l1"
            android:layout_marginTop="@dimen/l_75"
            android:layout_marginEnd="@dimen/l1"
            android:layout_marginBottom="@dimen/l_75"
            android:singleLine="true"
            android:ellipsize="middle"
            android:text="@{item.displayName}"
            android:textAppearance="@style/AppearanceFoundation.Caption.Variant"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toStartOf="@+id/hide_process_checkbox"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            tools:text="com.topjohnwu.magisk" />

        <com.google.android.material.switchmaterial.SwitchMaterial
            android:id="@+id/hide_process_checkbox"
            android:checked="@={item.enabled}"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginEnd="@dimen/l_50"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent" />

    </androidx.constraintlayout.widget.ConstraintLayout>

</layout>

```

`app/apk/src/main/res/layout/item_icon_link.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.home.IconLink" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.home.HomeViewModel" />

    </data>

    <FrameLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="?selectableItemBackground"
        android:clickable="true"
        android:focusable="true"
        android:minWidth="48dp"
        android:onClick="@{() -> viewModel.onLinkPressed(item.link)}"
        android:padding="@dimen/l_50"
        tools:layout_gravity="center">

        <ImageView
            android:id="@+id/developer_link"
            style="@style/WidgetFoundation.Image.Small"
            android:layout_gravity="center"
            app:srcCompat="@{item.icon}"
            app:tint="?colorOnSurface"
            tools:srcCompat="@drawable/ic_paypal" />

    </FrameLayout>

</layout>

```

`app/apk/src/main/res/layout/item_list_single_line.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="item"
            type="com.topjohnwu.magisk.view.MagiskDialog.DialogItem" />

        <variable
            name="listener"
            type="com.topjohnwu.magisk.view.MagiskDialog.DialogClickListener" />

    </data>

    <TextView
        android:id="@android:id/text1"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="?selectableItemBackground"
        android:clickable="true"
        android:focusable="true"
        android:onClick="@{() -> listener.onClick(item.position)}"
        android:paddingStart="@dimen/l1"
        android:paddingTop="@dimen/l_75"
        android:paddingEnd="@dimen/l1"
        android:paddingBottom="@dimen/l_75"
        android:text="@{item.item}"
        android:textAppearance="@style/AppearanceFoundation.Body"
        tools:text="@tools:sample/lorem" />

</layout>

```

`app/apk/src/main/res/layout/item_log_access_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <import type="com.topjohnwu.magisk.R" />

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.log.SuLogRvItem" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.log.LogViewModel" />

    </data>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:minHeight="?listPreferredItemHeightSmall"
        tools:layout_gravity="center">

        <include
            android:id="@+id/log_track_container"
            bullet="@{item.log.action >= 2 ? R.drawable.ic_check_md2 : R.drawable.ic_close_md2}"
            isBottom="@{item.isBottom}"
            isSelected="@{item.log.action != 2}"
            isTop="@{item.isTop}"
            layout="@layout/item_log_track_md2"
            android:layout_width="wrap_content"
            android:layout_height="0dp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent" />

        <androidx.constraintlayout.widget.ConstraintLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="@dimen/l1"
            android:paddingTop="@dimen/l_50"
            android:paddingBottom="@dimen/l_50"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toEndOf="@+id/log_track_container"
            app:layout_constraintTop_toTopOf="parent">

            <TextView
                android:id="@+id/log_app_name"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@{item.log.appName}"
                android:textAppearance="@style/AppearanceFoundation.Body"
                android:textStyle="bold"
                app:layout_constraintBottom_toTopOf="@+id/log_info"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                tools:text="@string/magisk" />

            <TextView
                android:id="@+id/log_info"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@{item.info}"
                android:textAppearance="@style/AppearanceFoundation.Caption.Variant"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintTop_toBottomOf="@+id/log_app_name"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintStart_toStartOf="parent" />

        </androidx.constraintlayout.widget.ConstraintLayout>

    </androidx.constraintlayout.widget.ConstraintLayout>

</layout>

```

`app/apk/src/main/res/layout/item_log_textview.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android">

    <data>

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.log.LogRvItem" />

    </data>


    <com.google.android.material.textview.MaterialTextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:fontFamily="monospace"
        android:textAppearance="@style/AppearanceFoundation.Caption"
        android:text="@{item.item}" />

</layout>

```

`app/apk/src/main/res/layout/item_log_track_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="isTop"
            type="Boolean" />

        <variable
            name="isBottom"
            type="Boolean" />

        <variable
            name="bullet"
            type="Integer" />

        <variable
            name="isSelected"
            type="Boolean" />

    </data>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        tools:layout_gravity="center"
        tools:minHeight="?listPreferredItemHeightSmall">

        <ImageView
            android:id="@+id/track_top"
            invisible="@{isTop}"
            android:layout_width="2dp"
            android:layout_height="0dp"
            android:layout_marginBottom="2dp"
            android:alpha=".3"
            app:tint="?colorSecondary"
            app:srcCompat="@drawable/bg_line_bottom_rounded"
            app:layout_constraintBottom_toTopOf="@+id/track_bullet"
            app:layout_constraintEnd_toEndOf="@+id/track_bullet"
            app:layout_constraintStart_toStartOf="@+id/track_bullet"
            app:layout_constraintTop_toTopOf="parent" />

        <ImageView
            android:id="@+id/track_bullet"
            style="@style/WidgetFoundation.Image.Small"
            isSelected="@{isSelected}"
            srcCompat="@{bullet}"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:tint="@color/color_primary_error_transient"
            tools:srcCompat="@drawable/ic_check_md2" />

        <ImageView
            android:id="@+id/track_bottom"
            invisible="@{isBottom}"
            android:layout_width="2dp"
            android:layout_height="0dp"
            android:layout_marginTop="2dp"
            android:alpha=".3"
            app:tint="?colorSecondary"
            app:srcCompat="@drawable/bg_line_top_rounded"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="@+id/track_bullet"
            app:layout_constraintStart_toStartOf="@+id/track_bullet"
            app:layout_constraintTop_toBottomOf="@+id/track_bullet" />

    </androidx.constraintlayout.widget.ConstraintLayout>

</layout>

```

`app/apk/src/main/res/layout/item_module_download.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <data>

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.module.InstallModule" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.module.ModuleViewModel" />

    </data>

    <Button
        style="@style/WidgetFoundation.Button.Outlined"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="@dimen/l_50"
        android:onClick="@{() -> viewModel.installPressed()}"
        android:text="@string/module_action_install_external"
        android:textAllCaps="false"
        android:textSize="12sp"
        app:cornerRadius="@dimen/r1"
        app:icon="@drawable/ic_module_storage_md2" />

</layout>

```

`app/apk/src/main/res/layout/item_module_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <import type="com.topjohnwu.magisk.R" />

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.module.LocalModuleRvItem" />

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.module.ModuleViewModel" />

    </data>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <com.google.android.material.card.MaterialCardView
            android:id="@+id/module"
            style="@style/WidgetFoundation.Card"
            isEnabled="@{!item.removed &amp;&amp; item.enabled &amp;&amp; !item.showNotice}"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:focusable="@{!item.removed &amp;&amp; item.enabled &amp;&amp; !item.showNotice}"
            android:nextFocusRight="@id/module_indicator"
            app:cardBackgroundColor="@color/color_card_background_color_selector"
            tools:isEnabled="false"
            tools:layout_gravity="center"
            tools:layout_margin="@dimen/l1">

            <ImageView
                android:id="@+id/module_state_icon"
                gone="@{!item.removed &amp;&amp; !item.updated}"
                srcCompat="@{item.removed ? R.drawable.ic_delete_md2 : (item.updated ? R.drawable.ic_update_md2 : 0)}"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:layout_gravity="center"
                android:adjustViewBounds="true"
                android:alpha=".05"
                android:background="@null"
                android:duplicateParentState="true"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintLeft_toLeftOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:tint="?colorOnSurface"
                tools:srcCompat="@drawable/ic_update_md2" />

            <androidx.constraintlayout.widget.ConstraintLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:animateLayoutChanges="true"
                android:duplicateParentState="true">

                <TextView
                    android:id="@+id/module_title"
                    strikeThrough="@{item.removed}"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_marginStart="@dimen/l1"
                    android:layout_marginTop="@dimen/l1"
                    android:layout_marginEnd="@dimen/l_50"
                    android:duplicateParentState="true"
                    android:text="@{item.item.name}"
                    android:textAppearance="@style/AppearanceFoundation.Body"
                    android:textColor="?android:textColorPrimary"
                    android:textStyle="bold"
                    app:layout_constraintEnd_toStartOf="@+id/module_indicator"
                    app:layout_constraintStart_toStartOf="parent"
                    app:layout_constraintTop_toTopOf="parent"
                    tools:text="@tools:sample/lorem" />

                <TextView
                    android:id="@+id/module_version_author"
                    strikeThrough="@{item.removed}"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:duplicateParentState="true"
                    android:text="@{@string/module_version_author(item.item.version, item.item.author)}"
                    android:textAppearance="@style/AppearanceFoundation.Caption.Variant"
                    android:textColor="?android:textColorSecondary"
                    app:layout_constraintEnd_toEndOf="@+id/module_title"
                    app:layout_constraintStart_toStartOf="@+id/module_title"
                    app:layout_constraintTop_toBottomOf="@+id/module_title"
                    tools:text="@tools:sample/lorem" />

                <com.google.android.material.switchmaterial.SwitchMaterial
                    android:id="@+id/module_indicator"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginEnd="@dimen/l_50"
                    android:checked="@={item.enabled}"
                    android:nextFocusLeft="@id/module"
                    app:layout_constraintBottom_toBottomOf="@+id/module_version_author"
                    app:layout_constraintEnd_toEndOf="parent"
                    app:layout_constraintHorizontal_bias="1"
                    app:layout_constraintStart_toEndOf="@+id/module_update"
                    app:layout_constraintTop_toTopOf="@+id/module_title" />

                <TextView
                    android:id="@+id/module_description"
                    gone="@{item.item.description.empty}"
                    strikeThrough="@{item.removed}"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_marginStart="@dimen/l1"
                    android:layout_marginTop="@dimen/l1"
                    android:layout_marginEnd="@dimen/l1"
                    android:duplicateParentState="true"
                    android:maxLines="5"
                    android:text="@{item.item.description}"
                    android:textAppearance="@style/AppearanceFoundation.Caption.Variant"
                    android:textColor="?android:textColorSecondary"
                    app:layout_constraintTop_toBottomOf="@+id/module_version_author"
                    tools:lines="4"
                    tools:text="@tools:sample/lorem/random" />

                <View
                    android:id="@+id/module_divider"
                    android:layout_width="match_parent"
                    android:layout_height="1dp"
                    android:layout_marginTop="@dimen/l1"
                    android:background="?colorSurfaceSurfaceVariant"
                    app:layout_constraintTop_toBottomOf="@+id/module_description" />

                <Button
                    android:id="@+id/module_update"
                    style="@style/WidgetFoundation.Button.Text"
                    goneUnless="@{item.showUpdate}"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:clickable="true"
                    android:enabled="@{item.updateReady}"
                    android:focusable="true"
                    android:onClick="@{() -> viewModel.downloadPressed(item.item.updateInfo)}"
                    android:text="@string/update"
                    android:textAllCaps="false"
                    app:icon="@drawable/ic_update_md2"
                    app:iconGravity="textEnd"
                    app:layout_constraintBottom_toBottomOf="@+id/module_remove"
                    app:layout_constraintEnd_toStartOf="@+id/module_remove"
                    app:layout_constraintTop_toTopOf="@+id/module_remove"
                    app:srcCompat="@drawable/ic_download_md2" />

                <Button
                    android:id="@+id/module_remove"
                    style="@style/WidgetFoundation.Button.Text"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:clickable="true"
                    android:enabled="@{!item.updated}"
                    android:focusable="true"
                    android:onClick="@{() -> item.delete()}"
                    android:text="@{item.removed ? @string/module_state_restore : @string/module_state_remove}"
                    android:textAllCaps="false"
                    android:theme="@style/ThemeOverlay.Button.Text.Secondary"
                    app:icon="@{item.removed ? @drawable/ic_restart : @drawable/ic_delete_md2}"
                    app:iconGravity="textEnd"
                    app:layout_constraintEnd_toEndOf="parent"
                    app:layout_constraintTop_toBottomOf="@+id/module_divider"
                    tools:icon="@drawable/ic_delete_md2"
                    tools:text="Remove" />

                <androidx.constraintlayout.widget.Barrier
                    android:id="@+id/bottom_bar_barrier"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    app:barrierDirection="start"
                    app:referencedIds="@{viewModel.bottomBarBarrierIds}"
                    tools:constraint_referenced_ids="module_update,module_remove" />

                <TextView
                    android:id="@+id/module_notice_text"
                    goneUnless="@{item.showNotice}"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_marginStart="@dimen/l1"
                    android:layout_marginEnd="@dimen/l_50"
                    android:fontFamily="sans-serif-medium"
                    android:text="@{item.noticeText}"
                    android:textAppearance="@style/AppearanceFoundation.Caption.Primary"
                    android:textColor="?colorError"
                    app:layout_constraintBottom_toBottomOf="@+id/module_remove"
                    app:layout_constraintEnd_toStartOf="@+id/bottom_bar_barrier"
                    app:layout_constraintStart_toEndOf="@id/module_config"
                    app:layout_constraintTop_toTopOf="@+id/module_remove"
                    tools:lines="2"
                    tools:text="@tools:sample/lorem/random"
                    tools:visibility="visible" />

                <Button
                    android:id="@+id/module_config"
                    style="@style/WidgetFoundation.Button.Text"
                    goneUnless="@{item.showAction}"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:clickable="true"
                    android:enabled="@{item.enabled}"
                    android:focusable="true"
                    android:onClick="@{() -> viewModel.runAction(item.item.id, item.item.name)}"
                    android:text="@string/module_action"
                    android:textAllCaps="false"
                    android:visibility="gone"
                    app:icon="@drawable/ic_action_md2"
                    app:iconGravity="textStart"
                    app:layout_constraintBottom_toBottomOf="@+id/module_remove"
                    app:layout_constraintTop_toTopOf="@+id/module_remove"
                    app:layout_constraintStart_toStartOf="parent"
                    app:srcCompat="@drawable/ic_download_md2" />

            </androidx.constraintlayout.widget.ConstraintLayout>

        </com.google.android.material.card.MaterialCardView>

    </FrameLayout>

</layout>

```

`app/apk/src/main/res/layout/item_policy_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <import type="com.topjohnwu.magisk.databinding.DataBindingAdaptersKt" />

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.superuser.PolicyRvItem" />

    </data>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center">

        <com.google.android.material.card.MaterialCardView
            android:id="@+id/policy"
            style="@style/WidgetFoundation.Card"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:alpha="@{item.enabled ? 1f : .5f}"
            android:focusable="true"
            android:nextFocusRight="@id/policy_indicator"
            android:onClick="@{() -> item.toggleExpand()}">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical">

                <androidx.constraintlayout.widget.ConstraintLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content">

                    <ImageView
                        android:id="@+id/policy_app_icon"
                        style="@style/WidgetFoundation.Image"
                        srcCompat="@{item.icon}"
                        android:layout_marginStart="@dimen/l1"
                        android:layout_marginTop="@dimen/l1"
                        android:layout_marginBottom="@dimen/l1"
                        app:layout_constraintBottom_toBottomOf="parent"
                        app:layout_constraintStart_toStartOf="parent"
                        app:layout_constraintTop_toTopOf="parent"
                        app:layout_constraintVertical_bias="0"
                        tools:srcCompat="@drawable/ic_logo" />

                    <TextView
                        android:id="@+id/policy_app_name"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_marginLeft="@dimen/margin_generic"
                        android:layout_marginRight="@dimen/margin_generic"
                        android:ellipsize="middle"
                        android:gravity="start"
                        android:maxLines="2"
                        android:text="@{item.title}"
                        android:textAppearance="@style/AppearanceFoundation.Body"
                        android:textIsSelectable="false"
                        android:textStyle="bold"
                        app:layout_constraintEnd_toStartOf="@+id/policy_indicator"
                        app:layout_constraintStart_toEndOf="@+id/policy_app_icon"
                        app:layout_constraintTop_toTopOf="@+id/policy_app_icon"
                        tools:text="@string/magisk" />

                    <TextView
                        android:id="@+id/policy_package_name"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_marginBottom="@dimen/l1"
                        android:ellipsize="middle"
                        android:gravity="start"
                        android:maxLines="2"
                        android:text="@{item.packageName}"
                        android:textAppearance="@style/AppearanceFoundation.Caption.Variant"
                        android:textColor="@android:color/tertiary_text_dark"
                        android:textIsSelectable="false"
                        app:layout_constraintBottom_toBottomOf="parent"
                        app:layout_constraintEnd_toEndOf="@id/policy_app_name"
                        app:layout_constraintStart_toStartOf="@id/policy_app_name"
                        app:layout_constraintTop_toBottomOf="@id/policy_app_name"
                        app:layout_constraintVertical_bias="0"
                        tools:text="com.topjohnwu.magisk" />

                    <FrameLayout
                        android:id="@+id/policy_indicator"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginEnd="@dimen/l1"
                        android:nextFocusLeft="@id/policy"
                        app:layout_constraintBottom_toBottomOf="parent"
                        app:layout_constraintEnd_toEndOf="parent"
                        app:layout_constraintTop_toTopOf="parent">

                        <com.google.android.material.switchmaterial.SwitchMaterial
                            gone="@{item.showSlider}"
                            android:layout_width="wrap_content"
                            android:layout_height="wrap_content"
                            android:checked="@={item.enabled}" />

                        <com.google.android.material.slider.Slider
                            goneUnless="@{item.showSlider}"
                            labelFormatter="@{item.sliderValueToPolicyString}"
                            android:layout_width="96dp"
                            android:layout_height="wrap_content"
                            android:stepSize="1"
                            android:value="@={DataBindingAdaptersKt.policyToSliderValue(item.sliderValue)}"
                            android:valueFrom="1"
                            android:valueTo="3" />
                    </FrameLayout>

                </androidx.constraintlayout.widget.ConstraintLayout>

                <LinearLayout
                    android:id="@+id/policy_expand_container"
                    gone="@{!item.isExpanded}"
                    android:layout_width="match_parent"
                    android:layout_height="match_parent"
                    android:background="?colorSurfaceVariant"
                    android:orientation="horizontal"
                    tools:visibility="visible">

                    <Button
                        android:id="@+id/policy_notify"
                        style="@style/WidgetFoundation.Button.Text"
                        isSelected="@{item.shouldNotify}"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:minHeight="24dp"
                        android:onClick="@{() -> item.toggleNotify()}"
                        android:text="@string/superuser_toggle_notification"
                        android:textAllCaps="false"
                        android:textAppearance="@style/AppearanceFoundation.Tiny"
                        android:textColor="@color/color_state_primary_transient"
                        app:icon="@drawable/ic_notifications_md2"
                        app:iconTint="@color/color_state_primary_transient"
                        app:tint="@color/color_state_primary_transient" />

                    <View
                        android:layout_width="1dp"
                        android:layout_height="match_parent"
                        android:layout_marginTop="@dimen/l_50"
                        android:layout_marginBottom="@dimen/l_50"
                        android:background="?colorSurfaceSurfaceVariant" />

                    <Button
                        android:id="@+id/policy_log"
                        style="@style/WidgetFoundation.Button.Text"
                        isSelected="@{item.shouldLog}"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:minHeight="24dp"
                        android:onClick="@{() -> item.toggleLog()}"
                        android:text="@string/logs"
                        android:textAllCaps="false"
                        android:textAppearance="@style/AppearanceFoundation.Tiny"
                        android:textColor="@color/color_state_primary_transient"
                        app:icon="@drawable/ic_bug_md2"
                        app:iconTint="@color/color_state_primary_transient"
                        app:tint="@color/color_state_primary_transient" />

                    <View
                        android:layout_width="1dp"
                        android:layout_height="match_parent"
                        android:layout_marginTop="@dimen/l_50"
                        android:layout_marginBottom="@dimen/l_50"
                        android:background="?colorSurfaceSurfaceVariant" />

                    <Button
                        android:id="@+id/policy_delete"
                        style="@style/WidgetFoundation.Button.Text"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:minHeight="24dp"
                        android:onClick="@{() -> item.revoke()}"
                        android:text="@string/superuser_toggle_revoke"
                        android:textAllCaps="false"
                        android:textColor="?colorError"
                        android:textSize="12sp"
                        app:icon="@drawable/ic_delete_md2"
                        app:iconTint="?colorError"
                        app:rippleColor="?colorError" />

                </LinearLayout>

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

    </FrameLayout>

</layout>

```

`app/apk/src/main/res/layout/item_settings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.settings.BaseSettingsItem" />

        <variable
            name="handler"
            type="com.topjohnwu.magisk.ui.settings.BaseSettingsItem.Handler" />

    </data>

    <com.google.android.material.card.MaterialCardView
        style="@style/WidgetFoundation.Card"
        isEnabled="@{item.enabled}"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:alpha="@{item.enabled ? 1f : .5f}"
        android:clickable="@{item.enabled}"
        android:focusable="@{item.enabled}"
        android:onClick="@{(view) -> item.onPressed(view, handler)}"
        tools:layout_gravity="center">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center_vertical"
            android:orientation="horizontal"
            android:paddingStart="@{item.icon == 0 ? @dimen/l1 : 0}"
            android:paddingEnd="@dimen/l1">

            <ImageView
                android:id="@+id/icon"
                style="@style/WidgetFoundation.Icon"
                gone="@{item.icon == 0}"
                android:background="@null"
                app:srcCompat="@{item.icon}"
                tools:srcCompat="@drawable/ic_fingerprint" />

            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:gravity="center_vertical"
                android:orientation="vertical"
                android:paddingTop="@dimen/l1"
                android:paddingBottom="@dimen/l1">

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_gravity="center"
                    android:gravity="start"
                    android:text="@{item.title}"
                    android:textAppearance="@style/AppearanceFoundation.Body"
                    android:textStyle="bold"
                    tools:lines="1"
                    tools:text="@tools:sample/lorem/random" />

                <TextView
                    gone="@{item.description.empty}"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@{item.description}"
                    android:textAppearance="@style/AppearanceFoundation.Tiny.Variant"
                    tools:lines="2"
                    tools:text="@tools:sample/lorem/random" />

            </LinearLayout>

            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/selector_indicator"
                goneUnless="@{item.showSwitch}"
                isEnabled="@{item.enabled}"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:checked="@{item.checked}"
                android:focusable="@{item.enabled}"
                android:onCheckedChanged="@{(v, c) -> item.onToggle(v, handler, c)}" />

        </LinearLayout>

    </com.google.android.material.card.MaterialCardView>

</layout>

```

`app/apk/src/main/res/layout/item_settings_section.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="item"
            type="com.topjohnwu.magisk.ui.settings.BaseSettingsItem" />

    </data>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingTop="@dimen/l1"
        android:paddingBottom="@dimen/l_50">

        <TextView
            gone="@{item.title.empty}"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@{item.title}"
            android:textAppearance="@style/AppearanceFoundation.Large.Secondary"
            android:textStyle="bold"
            tools:text="@tools:sample/lorem" />

        <TextView
            gone="@{item.description.empty}"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@{item.description}"
            android:textAppearance="@style/AppearanceFoundation.Tiny.Bold"
            tools:text="@tools:sample/lorem/random" />

    </LinearLayout>

</layout>

```

`app/apk/src/main/res/layout/item_spinner.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    style="?android:attr/spinnerItemStyle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:ellipsize="marquee"
    android:background="?colorSurfaceSurfaceVariant"
    android:textAppearance="@style/AppearanceFoundation.Caption"
    android:gravity="center_vertical"
    android:minHeight="?attr/listPreferredItemHeightSmall"
    android:singleLine="true"
    android:textAlignment="inherit"
    tools:text="Forever" />

```

`app/apk/src/main/res/layout/item_tappable_headline.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="item"
            type="com.topjohnwu.magisk.view.TappableHeadlineItem" />

        <variable
            name="listener"
            type="com.topjohnwu.magisk.view.TappableHeadlineItem.Listener" />

    </data>

    <com.google.android.material.card.MaterialCardView
        style="@style/WidgetFoundation.Card"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:onClick="@{() -> listener.onItemPressed(item)}"
        tools:layout_gravity="center">

        <androidx.constraintlayout.widget.ConstraintLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <ImageView
                android:id="@+id/tappable_icon"
                style="@style/WidgetFoundation.Icon"
                android:background="@null"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:srcCompat="@{item.icon}"
                tools:srcCompat="@drawable/ic_day_night" />

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:requiresFadingEdge="horizontal"
                android:singleLine="true"
                android:text="@{item.title}"
                android:textAppearance="@style/AppearanceFoundation.Body"
                android:textStyle="bold"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintEnd_toStartOf="@+id/headline_icon_pointer"
                app:layout_constraintStart_toEndOf="@+id/tappable_icon"
                app:layout_constraintTop_toTopOf="parent"
                tools:text="@string/settings_dark_mode_title" />

            <ImageView
                android:id="@+id/headline_icon_pointer"
                style="@style/WidgetFoundation.Icon"
                android:background="@null"
                android:rotation="180"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:srcCompat="@drawable/ic_back_md2" />

        </androidx.constraintlayout.widget.ConstraintLayout>

    </com.google.android.material.card.MaterialCardView>

</layout>

```

`app/apk/src/main/res/layout/item_text.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="item"
            type="com.topjohnwu.magisk.view.TextItem" />

    </data>

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:padding="@dimen/l1"
        android:text="@{item.item}"
        android:textAppearance="@style/AppearanceFoundation.Tiny.Variant"
        tools:text="@tools:sample/lorem/random" />

</layout>

```

`app/apk/src/main/res/layout/item_theme.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>

        <variable
            name="viewModel"
            type="com.topjohnwu.magisk.ui.theme.ThemeViewModel" />

        <variable
            name="theme"
            type="com.topjohnwu.magisk.ui.theme.Theme" />

    </data>

    <com.google.android.material.card.MaterialCardView
        style="@style/WidgetFoundation.Card"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:onClick="@{() -> viewModel.saveTheme(theme)}"
        app:cardBackgroundColor="@android:color/transparent"
        app:strokeColor="?colorPrimaryVariant"
        app:strokeWidth="1.5dp"
        tools:layout_gravity="center">

        <androidx.constraintlayout.widget.ConstraintLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="?colorSurface">

            <com.google.android.material.appbar.AppBarLayout
                android:id="@+id/theme_appbar"
                style="@style/WidgetFoundation.Appbar"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:layout_constraintTop_toTopOf="parent">

                <com.google.android.material.appbar.MaterialToolbar
                    style="@style/WidgetFoundation.Toolbar"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content">

                    <LinearLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="vertical">

                        <View
                            android:layout_width="100dp"
                            android:layout_height="17sp"
                            android:layout_gravity="center_vertical|start"
                            android:background="?colorOnSurface" />

                        <View
                            android:layout_width="70dp"
                            android:layout_height="12sp"
                            android:layout_gravity="center_vertical|start"
                            android:layout_marginTop="@dimen/l_25"
                            android:background="?colorOnSurfaceVariant" />

                    </LinearLayout>

                </com.google.android.material.appbar.MaterialToolbar>

            </com.google.android.material.appbar.AppBarLayout>

            <com.google.android.material.card.MaterialCardView
                android:id="@+id/theme_card_bottom"
                style="@style/WidgetFoundation.Card"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_marginStart="@dimen/l1"
                android:layout_marginTop="@dimen/l1"
                android:layout_marginEnd="@dimen/l1"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toBottomOf="@+id/theme_appbar">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="@dimen/l1">

                    <View
                        android:layout_width="match_parent"
                        android:layout_height="17sp"
                        android:background="?colorOnSurface" />

                    <View
                        android:layout_width="40dp"
                        android:layout_height="11sp"
                        android:layout_marginTop="@dimen/l_25"
                        android:background="?colorOnSurfaceVariant" />

                    <View
                        android:layout_width="30dp"
                        android:layout_height="11sp"
                        android:layout_marginTop="@dimen/l_25"
                        android:background="?colorOnSurfaceVariant" />

                </LinearLayout>

            </com.google.android.material.card.MaterialCardView>

            <LinearLayout
                android:id="@+id/theme_primary"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="@dimen/l1"
                android:background="?colorPrimary"
                android:orientation="vertical"
                android:padding="@dimen/l1"
                app:layout_constraintTop_toBottomOf="@+id/theme_card_bottom">

                <TextView
                    android:layout_width="125dp"
                    android:layout_height="wrap_content"
                    android:text="@{theme.themeName}"
                    android:textAppearance="@style/AppearanceFoundation.Title.OnPrimary"
                    android:textStyle="bold"
                    tools:text="Default" />

                <View
                    android:layout_width="match_parent"
                    android:layout_height="12sp"
                    android:background="?colorOnPrimaryVariant" />

                <View
                    android:layout_width="75dp"
                    android:layout_height="12sp"
                    android:layout_marginTop="@dimen/l_25"
                    android:background="?colorOnPrimaryVariant" />

            </LinearLayout>

            <com.google.android.material.card.MaterialCardView
                android:id="@+id/theme_navigation"
                style="@style/WidgetFoundation.Card.Elevated"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="@dimen/l1"
                android:layout_marginBottom="@dimen/l1"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toBottomOf="@+id/theme_primary">

                <LinearLayout
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:padding="@dimen/l1">

                    <View
                        style="@style/WidgetFoundation.Image.Small"
                        android:background="?colorSecondary" />

                    <View
                        style="@style/WidgetFoundation.Image.Small"
                        android:layout_marginStart="@dimen/l1"
                        android:background="?colorDisabled" />

                </LinearLayout>

            </com.google.android.material.card.MaterialCardView>

        </androidx.constraintlayout.widget.ConstraintLayout>

        <ImageView
            style="@style/WidgetFoundation.Icon.OnPrimary"
            gone="@{!theme.isSelected}"
            android:layout_gravity="end|top"
            android:layout_margin="@dimen/l_50"
            android:background="@drawable/bg_selection_circle_green"
            app:srcCompat="@drawable/ic_check_md2"
            app:tint="#fff" />

    </com.google.android.material.card.MaterialCardView>

</layout>

```

`app/apk/src/main/res/layout/item_theme_container.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    style="@style/W.Theme.Container">

    <FrameLayout
        android:id="@+id/left"
        style="@style/W.Theme.Left" />

    <FrameLayout
        android:id="@+id/right"
        style="@style/W.Theme.Right" />

</LinearLayout>

```

`app/apk/src/main/res/layout/markdown_window_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/md_txt"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginStart="15dp"
        android:layout_marginEnd="15dp"
        android:breakStrategy="simple"
        android:hyphenationFrequency="none"
        android:paddingTop="10dp"
        android:textAppearance="@style/AppearanceFoundation.Caption"
        tools:ignore="UnusedAttribute" />

</ScrollView>

```

`app/apk/src/main/res/menu/menu_bottom_nav.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <item
        android:id="@+id/homeFragment"
        android:icon="@drawable/ic_home_md2"
        android:title="@string/section_home"
        tools:showAsAction="always" />

    <item
        android:id="@+id/superuserFragment"
        android:icon="@drawable/ic_superuser_md2"
        android:title="@string/superuser"
        tools:showAsAction="always" />

    <item
        android:id="@+id/logFragment"
        android:icon="@drawable/ic_bug_md2"
        android:title="@string/logs"
        tools:showAsAction="always" />

    <item
        android:id="@+id/modulesFragment"
        android:icon="@drawable/ic_module_md2"
        android:title="@string/modules"
        tools:showAsAction="always" />

</menu>

```

`app/apk/src/main/res/menu/menu_deny_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
        android:id="@+id/action_search"
        android:icon="@drawable/ic_search_md2"
        android:title="@string/hide_search"
        app:actionViewClass="androidx.appcompat.widget.SearchView"
        app:showAsAction="ifRoom" />
    <item
        android:id="@+id/action_show_system"
        android:checkable="true"
        android:title="@string/show_system_app"
        app:showAsAction="never" />
    <item
        android:id="@+id/action_show_OS"
        android:checkable="true"
        android:title="@string/show_os_app"
        app:showAsAction="never" />
</menu>

```

`app/apk/src/main/res/menu/menu_flash.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
        android:id="@+id/action_save"
        android:icon="@drawable/ic_save_md2"
        android:title="@string/menuSaveLog"
        app:showAsAction="always" />
</menu>
```

`app/apk/src/main/res/menu/menu_home_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/action_reboot"
        android:icon="@drawable/ic_restart"
        android:title="@string/reboot"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/action_settings"
        android:icon="@drawable/ic_settings_md2"
        android:title="@string/settings"
        app:showAsAction="ifRoom" />

</menu>

```

`app/apk/src/main/res/menu/menu_log_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/action_save"
        android:icon="@drawable/ic_save_md2"
        android:title="@string/menuSaveLog"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/action_clear"
        android:icon="@drawable/ic_delete_md2"
        android:title="@string/menuClearLog"
        app:showAsAction="ifRoom" />

</menu>
```

`app/apk/src/main/res/menu/menu_reboot.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/action_reboot_normal"
        android:title="@string/reboot" />

    <item
        android:id="@+id/action_reboot_userspace"
        android:title="@string/reboot_userspace"
        android:visible="false" />

    <item
        android:id="@+id/action_reboot_recovery"
        android:title="@string/reboot_recovery" />

    <item
        android:id="@+id/action_reboot_bootloader"
        android:title="@string/reboot_bootloader" />

    <item
        android:id="@+id/action_reboot_download"
        android:title="@string/reboot_download" />

    <item
        android:id="@+id/action_reboot_edl"
        android:title="@string/reboot_edl" />

    <item
        android:id="@+id/action_reboot_safe_mode"
        android:checkable="true"
        android:title="@string/reboot_safe_mode" />

</menu>

```

`app/apk/src/main/res/navigation/main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    app:startDestination="@id/homeFragment">

    <fragment
        android:id="@+id/denyFragment"
        android:name="com.topjohnwu.magisk.ui.deny.DenyListFragment"
        android:label="DenyListFragment"
        tools:layout="@layout/fragment_deny_md2" />

    <fragment
        android:id="@+id/homeFragment"
        android:name="com.topjohnwu.magisk.ui.home.HomeFragment"
        android:label="HomeFragment"
        tools:layout="@layout/fragment_home_md2">

        <action
            android:id="@+id/action_homeFragment_to_settingsFragment"
            app:destination="@id/settingsFragment"
            app:enterAnim="@anim/fragment_enter"
            app:exitAnim="@anim/fragment_exit"
            app:popEnterAnim="@anim/fragment_enter_pop"
            app:popExitAnim="@anim/fragment_exit_pop" />

        <action
            android:id="@+id/action_homeFragment_to_installFragment"
            app:destination="@id/installFragment"
            app:enterAnim="@anim/fragment_enter"
            app:exitAnim="@anim/fragment_exit"
            app:popEnterAnim="@anim/fragment_enter_pop"
            app:popExitAnim="@anim/fragment_exit_pop" />

    </fragment>

    <fragment
        android:id="@+id/flashFragment"
        android:name="com.topjohnwu.magisk.ui.flash.FlashFragment"
        android:label="FlashFragment"
        tools:layout="@layout/fragment_flash_md2">

        <argument
            android:name="action"
            app:argType="string" />

        <argument
            android:name="additional_data"
            android:defaultValue="@null"
            app:argType="android.net.Uri"
            app:nullable="true" />

    </fragment>

    <fragment
        android:id="@+id/actionFragment"
        android:name="com.topjohnwu.magisk.ui.module.ActionFragment"
        android:label="ActionFragment"
        tools:layout="@layout/fragment_action_md2" >

        <argument
            android:name="id"
            app:argType="string" />

        <argument
            android:name="name"
            app:argType="string" />
    </fragment>

    <fragment
        android:id="@+id/installFragment"
        android:name="com.topjohnwu.magisk.ui.install.InstallFragment"
        android:label="InstallFragment"
        tools:layout="@layout/fragment_install_md2" />

    <fragment
        android:id="@+id/logFragment"
        android:name="com.topjohnwu.magisk.ui.log.LogFragment"
        android:label="LogFragment"
        tools:layout="@layout/fragment_log_md2" />

    <fragment
        android:id="@+id/modulesFragment"
        android:name="com.topjohnwu.magisk.ui.module.ModuleFragment"
        android:label="ModuleFragment"
        tools:layout="@layout/fragment_module_md2" />

    <fragment
        android:id="@+id/settingsFragment"
        android:name="com.topjohnwu.magisk.ui.settings.SettingsFragment"
        android:label="SettingsFragment"
        tools:layout="@layout/fragment_settings_md2">

        <action
            android:id="@+id/action_settingsFragment_to_themeFragment"
            app:destination="@id/themeFragment"
            app:enterAnim="@anim/fragment_enter"
            app:exitAnim="@anim/fragment_exit"
            app:popEnterAnim="@anim/fragment_enter_pop"
            app:popExitAnim="@anim/fragment_exit_pop" />

        <action
            android:id="@+id/action_settingsFragment_to_denyFragment"
            app:destination="@id/denyFragment"
            app:enterAnim="@anim/fragment_enter"
            app:exitAnim="@anim/fragment_exit"
            app:popEnterAnim="@anim/fragment_enter_pop"
            app:popExitAnim="@anim/fragment_exit_pop" />

    </fragment>

    <fragment
        android:id="@+id/superuserFragment"
        android:name="com.topjohnwu.magisk.ui.superuser.SuperuserFragment"
        android:label="SuperuserFragment"
        tools:layout="@layout/fragment_superuser_md2" />

    <fragment
        android:id="@+id/themeFragment"
        android:name="com.topjohnwu.magisk.ui.theme.ThemeFragment"
        android:label="ThemeFragment"
        tools:layout="@layout/fragment_theme_md2" />

    <action
        android:id="@+id/action_homeFragment"
        app:destination="@id/homeFragment"
        app:enterAnim="@anim/fragment_enter"
        app:exitAnim="@anim/fragment_exit"
        app:popEnterAnim="@anim/fragment_enter_pop"
        app:popExitAnim="@anim/fragment_exit_pop"
        app:popUpTo="@id/homeFragment"
        app:popUpToInclusive="true" />

    <action
        android:id="@+id/action_superuserFragment"
        app:destination="@id/superuserFragment"
        app:enterAnim="@anim/fragment_enter"
        app:exitAnim="@anim/fragment_exit"
        app:popEnterAnim="@anim/fragment_enter_pop"
        app:popExitAnim="@anim/fragment_exit_pop"
        app:popUpTo="@id/homeFragment" />

    <action
        android:id="@+id/action_logFragment"
        app:destination="@id/logFragment"
        app:enterAnim="@anim/fragment_enter"
        app:exitAnim="@anim/fragment_exit"
        app:popEnterAnim="@anim/fragment_enter_pop"
        app:popExitAnim="@anim/fragment_exit_pop"
        app:popUpTo="@id/homeFragment" />

    <action
        android:id="@+id/action_moduleFragment"
        app:destination="@id/modulesFragment"
        app:enterAnim="@anim/fragment_enter"
        app:exitAnim="@anim/fragment_exit"
        app:popEnterAnim="@anim/fragment_enter_pop"
        app:popExitAnim="@anim/fragment_exit_pop"
        app:popUpTo="@id/homeFragment" />

    <action
        android:id="@+id/action_flashFragment"
        app:destination="@id/flashFragment"
        app:enterAnim="@anim/fragment_enter"
        app:exitAnim="@anim/fragment_exit"
        app:popEnterAnim="@anim/fragment_enter_pop"
        app:popExitAnim="@anim/fragment_exit_pop" />

    <action
        android:id="@+id/action_actionFragment"
        app:destination="@id/actionFragment"
        app:enterAnim="@anim/fragment_enter"
        app:exitAnim="@anim/fragment_exit"
        app:popEnterAnim="@anim/fragment_enter_pop"
        app:popExitAnim="@anim/fragment_exit_pop" />

</navigation>

```

`app/apk/src/main/res/values-night/styles_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="Foundation" parent="Theme.Foundation" />

</resources>

```

`app/apk/src/main/res/values-night/themes_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!--1st party themes-->

    <style name="ThemeFoundationMD2.Piplup">
        <item name="colorPrimary">#4EAFF5</item>
        <item name="colorPrimaryVariant">#804EAFF5</item>
        <item name="colorSecondary">#3E78AF</item>
        <item name="colorSecondaryVariant">#803E78AF</item>
        <item name="colorSurface">#0D0D0D</item>
        <item name="colorSurfaceVariant">#171717</item>
        <item name="colorSurfaceSurfaceVariant">#292929</item>
        <item name="colorOnPrimary">#F9F9F9</item>
        <item name="colorOnPrimaryVariant">#D9E6E6E6</item>
        <item name="colorOnSecondary">#F9F9F9</item>
        <item name="colorOnBackground">?colorOnSurface</item>
        <item name="colorError">#EF8282</item>
        <item name="colorOnError">#0D0D0D</item>
        <item name="colorOnSurface">#D8D8D8</item>
        <item name="colorOnSurfaceVariant">#CCBABABA</item>
        <item name="colorDisabled">#808080</item>
        <item name="colorDisabledVariant">#66808080</item>
    </style>

    <style name="ThemeFoundationMD2.Amoled" parent="ThemeFoundationMD2.Piplup">
        <item name="colorSurface">#000</item>
        <item name="colorOnPrimary">#FFF</item>
        <item name="colorOnSecondary">#FFF</item>
        <item name="colorOnBackground">#000</item>
        <item name="colorOnError">#FFF</item>
    </style>

    <style name="ThemeFoundationMD2.Zapdos" parent="ThemeFoundationMD2.Zapdos.Base">
        <item name="colorPrimary">#FBD179</item>
        <item name="colorPrimaryVariant">#80FBD179</item>
    </style>

    <style name="ThemeFoundationMD2.Mew" parent="ThemeFoundationMD2.Mew.Base">
        <item name="colorPrimary">#D9ADB7</item>
        <item name="colorPrimaryVariant">#80E9BBC5</item>
        <item name="colorOnPrimary">#000000</item>
        <item name="colorOnPrimaryVariant">#D9222222</item>
    </style>

    <!--3rd party themes-->

</resources>
```

`app/apk/src/main/res/values-v27/themes.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="Base.V27.Theme.Foundation.Light" parent="Base.V23.Theme.Foundation.Light">
        <item name="android:navigationBarColor">#e0fafafa</item>
        <item name="android:navigationBarDividerColor">#1f000000</item>
        <item name="android:windowLightNavigationBar">true</item>
    </style>

    <style name="Base.V27.Theme.Foundation" parent="Base.V23.Theme.Foundation">
        <item name="android:navigationBarDividerColor">@android:color/transparent</item>
    </style>

    <style name="Theme.Foundation.Light" parent="Base.V27.Theme.Foundation.Light" />

    <style name="Theme.Foundation" parent="Base.V27.Theme.Foundation" />

</resources>

```

`app/apk/src/main/res/values/attrs.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!--region Deprecated-->
    <attr name="cardStyle" format="reference" />
    <attr name="colorAccentFallback" format="reference" />
    <attr name="imageColorTint" format="reference" />
    <attr name="colorControl" format="reference" />
    <!--endregion-->

    <!--region Colors-->

    <!--Static-->
    <attr name="colorDisabled" format="color" />
    <attr name="colorDisabledVariant" format="color" />
    <attr name="colorSurfaceVariant" format="color" />
    <attr name="colorOnPrimaryVariant" format="color" />
    <attr name="colorOnSurfaceVariant" format="color" />
    <attr name="colorSurfaceSurfaceVariant" format="color" />

    <!--endregion-->

    <declare-styleable name="ConcealableView">
        <attr name="state_hidden" format="boolean" />
    </declare-styleable>

</resources>

```

`app/apk/src/main/res/values/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <dimen name="margin_generic">16dp</dimen>

    <dimen name="l_125">2dp</dimen>
    <dimen name="l_25">4dp</dimen>
    <dimen name="l_50">8dp</dimen>
    <dimen name="l_75">12dp</dimen>
    <dimen name="l1">16dp</dimen>
    <dimen name="l2">32dp</dimen>
    <dimen name="l3">48dp</dimen>

    <dimen name="r1">8dp</dimen>

    <dimen name="internal_action_bar_size">56dp</dimen>
</resources>

```

`app/apk/src/main/res/values/ids.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item name="recyclerScrollListener" type="id" />
</resources>

```

`app/apk/src/main/res/values/styles_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="Foundation" parent="Theme.Foundation.Light" />

    <!--region Do not remove-->
    <style name="Empty" />

    <style name="WidgetFoundation" parent="android:Widget" />

    <!--endregion-->

    <style name="Foundation.PopupMenu" parent="Widget.MaterialComponents.PopupMenu">
        <item name="android:itemTextAppearance">@style/AppearanceFoundation.Caption</item>
        <item name="android:textStyle">bold</item>
    </style>

    <style name="Foundation.Default">
        <item name="android:includeFontPadding">false</item>
        <item name="actionBarSize">@dimen/internal_action_bar_size</item>
        <item name="popupMenuStyle">@style/Foundation.PopupMenu</item>
    </style>

    <style name="Foundation.Floating" parent="Empty">
        <item name="android:windowIsFloating">true</item>
        <item name="android:windowIsTranslucent">true</item>
        <item name="android:windowBackground">@android:color/transparent</item>
    </style>

</resources>

```

`app/apk/src/main/res/values/styles_md2_appearance.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!--region Display-->
    <style name="AppearanceFoundation.Large" parent="TextAppearance.AppCompat.Large">
        <item name="android:textColor">?attr/colorOnSurface</item>
    </style>

    <style name="AppearanceFoundation.Large.Secondary">
        <item name="android:textColor">?colorSecondary</item>
    </style>

    <!--endregion-->

    <!--region Title-->
    <style name="AppearanceFoundation.Title" parent="TextAppearance.AppCompat.Title">
        <item name="android:textColor">?attr/colorOnSurface</item>
        <item name="android:textStyle">bold</item>
    </style>

    <style name="AppearanceFoundation.Title.OnPrimary">
        <item name="android:textColor">?attr/colorOnPrimary</item>
    </style>

    <!--endregion-->

    <!--region Body-->
    <style name="AppearanceFoundation.Body" parent="TextAppearance.AppCompat.Body1">
        <item name="android:textColor">?attr/colorOnSurface</item>
    </style>

    <!--endregion-->

    <!--region Caption-->
    <style name="AppearanceFoundation.Caption" parent="TextAppearance.AppCompat.Caption">
        <item name="android:textColor">?attr/colorOnSurface</item>
    </style>

    <style name="AppearanceFoundation.Caption.Variant">
        <item name="android:textColor">?attr/colorOnSurfaceVariant</item>
    </style>

    <style name="AppearanceFoundation.Caption.Primary">
        <item name="android:textColor">?attr/colorPrimary</item>
    </style>

    <style name="AppearanceFoundation.Caption.OnPrimary">
        <item name="android:textColor">?attr/colorOnPrimary</item>
    </style>

    <!--endregion-->

    <!--region Tiny-->
    <style name="AppearanceFoundation.Tiny" parent="TextAppearance.AppCompat.Caption">
        <item name="android:textColor">?attr/colorOnSurface</item>
        <item name="android:textSize">11sp</item>
    </style>

    <style name="AppearanceFoundation.Tiny.Bold">
        <item name="android:textStyle">bold</item>
    </style>

    <style name="AppearanceFoundation.Tiny.Variant">
        <item name="android:textColor">?attr/colorOnSurfaceVariant</item>
    </style>

    <!--endregion-->

</resources>

```

`app/apk/src/main/res/values/styles_md2_impl.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="WidgetFoundation.Appbar" parent="Widget.MaterialComponents.AppBarLayout.Surface" />

    <style name="WidgetFoundation.Toolbar" parent="Widget.MaterialComponents.Toolbar.Surface">
        <item name="titleTextAppearance">@style/AppearanceFoundation.Title</item>
        <item name="titleTextColor">?colorOnSurface</item>
        <item name="subtitleTextAppearance">@style/AppearanceFoundation.Caption</item>
        <item name="subtitleTextColor">?colorOnSurfaceVariant</item>
        <item name="android:background">@android:color/transparent</item>
        <item name="contentInsetStartWithNavigation">0dp</item>
        <item name="android:layout_height">?actionBarSize</item>
        <item name="android:theme">@style/ThemeOverlay.MaterialComponents.ActionBar</item>
    </style>


    <style name="WidgetFoundation.Card" parent="Widget.MaterialComponents.CardView">
        <item name="android:focusable">auto</item>
        <item name="cardBackgroundColor">?colorSurfaceVariant</item>
        <item name="cardCornerRadius">@dimen/l_50</item>
        <item name="cardElevation">0dp</item>
        <item name="cardPreventCornerOverlap">false</item>
    </style>

    <style name="WidgetFoundation.Card.Primary">
        <item name="cardBackgroundColor">?colorPrimary</item>
    </style>

    <style name="WidgetFoundation.Card.Elevated">
        <item name="cardBackgroundColor">?colorSurfaceSurfaceVariant</item>
        <item name="cardCornerRadius">@dimen/l_50</item>
        <item name="cardElevation">@dimen/l_125</item>
    </style>


    <style name="WidgetFoundation.Button" parent="Widget.MaterialComponents.Button">
        <item name="android:textStyle">bold</item>
        <item name="iconGravity">textStart</item>
        <item name="iconPadding">@dimen/l_50</item>
    </style>

    <style name="WidgetFoundation.Button.Outlined" parent="Widget.MaterialComponents.Button.OutlinedButton">
        <item name="android:textStyle">bold</item>
        <item name="iconGravity">textStart</item>
        <item name="iconPadding">@dimen/l_50</item>
        <item name="strokeColor">?colorPrimary</item>
        <item name="android:textColor">?colorPrimary</item>
    </style>

    <style name="WidgetFoundation.Button.Outlined.Error">
        <item name="strokeColor">@color/color_error_transient</item>
        <item name="rippleColor">@color/color_error_transient</item>
        <item name="android:textColor">@color/color_error_transient</item>
        <item name="iconTint">@color/color_error_transient</item>
    </style>

    <style name="WidgetFoundation.Button.Text" parent="Widget.MaterialComponents.Button.TextButton">
        <item name="android:textStyle">bold</item>
        <item name="iconGravity">textStart</item>
        <item name="iconPadding">@dimen/l_50</item>
    </style>

    <style name="WidgetFoundation.Button.Text.OnPrimary">
        <item name="rippleColor">?colorOnPrimary</item>
        <item name="android:textColor">?colorOnPrimary</item>
        <item name="iconTint">?colorOnPrimary</item>
    </style>


    <style name="WidgetFoundation.Image">
        <item name="android:layout_width">32dp</item>
        <item name="android:layout_height">32dp</item>
    </style>

    <style name="WidgetFoundation.Image.Big">
        <item name="android:layout_width">48dp</item>
        <item name="android:layout_height">48dp</item>
    </style>

    <style name="WidgetFoundation.Image.Small">
        <item name="android:layout_width">24dp</item>
        <item name="android:layout_height">24dp</item>
    </style>


    <style name="WidgetFoundation.Icon" parent="WidgetFoundation.Image.Big">
        <item name="android:padding">@dimen/l_75</item>
        <item name="android:background">?selectableItemBackgroundBorderless</item>
        <item name="tint">@color/color_text_transient</item>
    </style>

    <style name="WidgetFoundation.Icon.Primary">
        <item name="tint">@color/color_primary_transient</item>
    </style>

    <style name="WidgetFoundation.Icon.OnPrimary">
        <item name="tint">@color/color_on_primary_transient</item>
    </style>

    <style name="WidgetFoundation.Checkbox" parent="Widget.AppCompat.CompoundButton.CheckBox">
        <item name="android:paddingStart">@dimen/l1</item>
        <item name="android:paddingEnd">@dimen/l1</item>
    </style>

    <style name="WidgetFoundation.RadioButton" parent="Widget.AppCompat.CompoundButton.RadioButton">
        <item name="android:paddingStart">@dimen/l1</item>
        <item name="android:paddingEnd">@dimen/l1</item>
    </style>

    <style name="WidgetFoundation.ProgressBar" parent="Widget.AppCompat.ProgressBar.Horizontal">
        <item name="android:indeterminate">false</item>
        <item name="android:layout_height">4dp</item>
    </style>

    <style name="WidgetFoundation.ProgressBar.Indeterminate" parent="Widget.AppCompat.ProgressBar.Horizontal">
        <item name="android:indeterminate">true</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_width">100dp</item>
        <item name="android:indeterminateTint">?colorPrimary</item>
    </style>

</resources>

```

`app/apk/src/main/res/values/styles_view_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="W" parent="android:Widget" />

    <!--region Home-->

    <style name="W.Home" />

    <style name="W.Home.Item">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:orientation">horizontal</item>
        <item name="android:paddingStart">@dimen/l1</item>
        <item name="android:paddingEnd">@dimen/l1</item>
    </style>

    <style name="W.Home.Item.Top">
        <item name="android:paddingTop">@dimen/l_75</item>
    </style>

    <style name="W.Home.Item.Bottom">
        <item name="android:paddingBottom">@dimen/l_75</item>
    </style>

    <style name="W.Home.ItemContent">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:includeFontPadding">false</item>
        <item name="android:textAppearance">@style/AppearanceFoundation.Caption.Variant</item>
    </style>

    <style name="W.Home.ItemContent.Right">
        <item name="android:layout_marginStart">@dimen/l_50</item>
        <item name="android:textStyle">bold</item>
        <item name="android:textAppearance">@style/AppearanceFoundation.Caption</item>
    </style>

    <!--endregion-->

    <!--region Themes-->

    <style name="W.Theme">
        <item name="android:layout_width">0dp</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_marginTop">@dimen/l1</item>
        <item name="android:layout_weight">1</item>
    </style>

    <style name="W.Theme.Left">
        <item name="android:layout_marginEnd">@dimen/l1</item>
    </style>

    <style name="W.Theme.Right" />

    <style name="W.Theme.Container" parent="Empty">
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_width">match_parent</item>
        <item name="android:orientation">horizontal</item>
        <item name="android:baselineAligned">false</item>
    </style>

    <!--endregion-->

</resources>

```

`app/apk/src/main/res/values/theme_overlay.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="ThemeOverlay.Button.Text.Secondary" parent="">
        <item name="colorPrimary">?colorSecondary</item>
    </style>

</resources>

```

`app/apk/src/main/res/values/themes.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="Base.V23.Theme.Foundation.Light" parent="Theme.MaterialComponents.Light.NoActionBar">
        <item name="android:windowBackground">?colorSurface</item>
        <item name="android:windowContentOverlay">@null</item>
        <item name="dialogTheme">@style/ThemeOverlay.Foundation.Dialog</item>
        <item name="android:statusBarColor">#40bdbdbd</item>
        <item name="android:navigationBarColor">#38000000</item>
        <item name="android:windowLightStatusBar">true</item>
    </style>

    <style name="Base.V23.Theme.Foundation" parent="Theme.MaterialComponents.NoActionBar">
        <item name="android:windowBackground">?colorSurface</item>
        <item name="android:windowContentOverlay">@null</item>
        <item name="dialogTheme">@style/ThemeOverlay.Foundation.Dialog</item>
        <item name="android:statusBarColor">#60000000</item>
        <item name="android:navigationBarColor">#60000000</item>
    </style>

    <style name="Theme.Foundation.Light" parent="Base.V23.Theme.Foundation.Light" />

    <style name="Theme.Foundation" parent="Base.V23.Theme.Foundation" />

    <style name="Base.V23.ThemeOverlay.Foundation.Dialog" parent="ThemeOverlay.MaterialComponents.Dialog">
        <item name="android:windowMinWidthMajor">@dimen/abc_dialog_min_width_major</item>
        <item name="android:windowMinWidthMinor">@dimen/abc_dialog_min_width_minor</item>
    </style>

    <style name="ThemeOverlay.Foundation.Dialog" parent="Base.V23.ThemeOverlay.Foundation.Dialog" />

</resources>

```

`app/apk/src/main/res/values/themes_md2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!--
    # Theme guide

    This should provide all the information you need to create new !color! themes.

    ## Inheritance

    You might want to inherit default values from "base" theme. You can do so implicitly by just
    writing `<style name="ThemeFoundationMD2.MySuperAwesomeTheme" parent="ThemeFoundationMD2.Piplup">`.
    With this approach you can only change values you (don't) like - such as `colorPrimary` or
    `colorSecondary`.

    ## Day / Night ? How do I define both in one theme?

    Define Theme here for "Day" theme and in `values-night` directory define theme with same name
    and parent if applicable. The framework will automatically switch between day/night themes based
    on user's requested configuration. (Always light, Always dark, Follow system)

    You might choose to define only "Day" theme with Dark colors to have dark theme regardless.
    That's super lazy approach and is discouraged but the framework permits it.

    ## What to theme

    Generally I'd suggest theming only `colorPrimary`, `colorSecondary` and their variants. Make
    sure that text is readable if displayed on primary or secondary color!

    You can check that very easily by visiting https://www.colorhexa.com/. After you put in your
    color hex, you can scroll down to "Preview" where it will compute whether dark/bright text
    should be displayed on top of it. Then you must edit respective `colorOn...`.

    Also check "Color Blindness Simulator". Primary and secondary colors must not match or be
    similar in type. Text on color must have enough contrast so it can be read by everyone!

    !! Themes that will not satisfy these requirements will be promptly deleted without further
    !! notice. In repeated attempts to push such themes you will be automatically blacklisted.
    -->

    <style name="ThemeFoundationMD2" parent="Foundation.Default" />

    <!--1st party themes-->

    <style name="ThemeFoundationMD2.Piplup">
        <item name="colorPrimary">#4EAFF5</item>
        <item name="colorPrimaryVariant">#804EAFF5</item>
        <item name="colorSecondary">#3E78AF</item>
        <item name="colorSecondaryVariant">#803E78AF</item>
        <item name="colorSurface">#F9F9F9</item>
        <item name="colorSurfaceVariant">#EEEEEE</item>
        <item name="colorSurfaceSurfaceVariant">?colorSurface</item>
        <item name="colorOnPrimary">#F9F9F9</item>
        <item name="colorOnPrimaryVariant">#D9E6E6E6</item>
        <item name="colorOnSecondary">#F9F9F9</item>
        <item name="colorOnBackground">?colorOnSurface</item>
        <item name="colorError">#CC0047</item>
        <item name="colorOnError">#F9F9F9</item>
        <item name="colorOnSurface">#444444</item>
        <item name="colorOnSurfaceVariant">#BF444444</item>
        <item name="colorDisabled">#808080</item>
        <item name="colorDisabledVariant">#66808080</item>
    </style>

    <style name="ThemeFoundationMD2.Amoled" parent="ThemeFoundationMD2.Piplup">
        <item name="colorSurface">#FFF</item>
        <item name="colorOnPrimary">#FFF</item>
        <item name="colorOnSecondary">#FFF</item>
        <item name="colorOnBackground">#FFF</item>
        <item name="colorOnError">#FFF</item>
    </style>

    <style name="ThemeFoundationMD2.Rayquaza" parent="ThemeFoundationMD2.Piplup">
        <item name="colorPrimary">#68A17F</item>
        <item name="colorPrimaryVariant">#8068A17F</item>
        <item name="colorSecondary">#2F6D43</item>
        <item name="colorSecondaryVariant">#802F6D43</item>
    </style>

    <style name="ThemeFoundationMD2.Zapdos.Base" parent="ThemeFoundationMD2.Piplup">
        <item name="colorSecondary">#B29667</item>
        <item name="colorSecondaryVariant">#80B29667</item>
        <item name="colorOnPrimary">#000000</item>
        <item name="colorOnPrimaryVariant">#D9222222</item>
    </style>

    <style name="ThemeFoundationMD2.Zapdos" parent="ThemeFoundationMD2.Zapdos.Base">
        <item name="colorPrimary">#F2B90D</item>
        <item name="colorPrimaryVariant">#80F2B90D</item>
    </style>

    <style name="ThemeFoundationMD2.Charmeleon" parent="ThemeFoundationMD2.Piplup">
        <item name="colorPrimary">#DB7366</item>
        <item name="colorPrimaryVariant">#80DB7366</item>
        <item name="colorSecondary">#B65247</item>
        <item name="colorSecondaryVariant">#80B65247</item>
        <item name="colorOnPrimary">#000000</item>
        <item name="colorOnPrimaryVariant">#D9222222</item>
    </style>

    <style name="ThemeFoundationMD2.Mew.Base" parent="ThemeFoundationMD2.Piplup">
        <item name="colorSecondary">#B5889B</item>
        <item name="colorSecondaryVariant">#80B5889B</item>
    </style>

    <style name="ThemeFoundationMD2.Mew" parent="ThemeFoundationMD2.Mew.Base">
        <item name="colorPrimary">#B3566C</item>
        <item name="colorPrimaryVariant">#80B3566C</item>
        <item name="colorOnPrimary">#F9F9F9</item>
        <item name="colorOnPrimaryVariant">#D9E6E6E6</item>
    </style>

    <style name="ThemeFoundationMD2.Salamence" parent="ThemeFoundationMD2.Piplup">
        <item name="colorPrimary">#70B2C6</item>
        <item name="colorPrimaryVariant">#8070B2C6</item>
        <item name="colorSecondary">#C06A75</item>
        <item name="colorSecondaryVariant">#80C06A75</item>
        <item name="colorOnPrimary">#000000</item>
        <item name="colorOnPrimaryVariant">#D9222222</item>
    </style>

    <style name="ThemeFoundationMD2.Fraxure" parent="ThemeFoundationMD2.Amoled">
        <item name="colorPrimary">#009688</item>
        <item name="colorPrimaryVariant">#8000796B</item>
        <item name="colorSecondary">?colorError</item>
        <item name="colorSecondaryVariant">#806D1111</item>
    </style>

    <!--3rd party themes-->

</resources>

```

`app/apk/src/main/res/values/themes_override.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools" tools:ignore="PrivateResource">

    <!-- Add android:colorControlNormal -->
    <style name="Base.ThemeOverlay.AppCompat.ActionBar" tools:override="true">
        <item name="android:colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="searchViewStyle">@style/Widget.AppCompat.SearchView.ActionBar</item>
    </style>

    <!-- Removes minimal size for MaterialComponents CheckBox and RadioButton,
         so that they will not have extra space in menus.
    -->
    <style name="Widget.MaterialComponents.CompoundButton.CheckBox" parent="Widget.AppCompat.CompoundButton.CheckBox" tools:override="true">
        <item name="enforceMaterialTheme">true</item>
        <item name="useMaterialThemeColors">true</item>
    </style>

    <style name="Widget.MaterialComponents.CompoundButton.RadioButton" parent="Widget.AppCompat.CompoundButton.RadioButton" tools:override="true">
        <item name="enforceMaterialTheme">true</item>
        <item name="useMaterialThemeColors">true</item>
    </style>

</resources>

```

`app/build.gradle.kts`:

```kts
plugins {
    id("MagiskPlugin")
}

tasks.register("clean", Delete::class) {
    delete(rootProject.layout.buildDirectory)

    subprojects.forEach {
        dependsOn(":${it.name}:clean")
    }
}

```

`app/buildSrc/build.gradle.kts`:

```kts
plugins {
    `kotlin-dsl`
}

repositories {
    google()
    mavenCentral()
}

gradlePlugin {
    plugins {
        register("MagiskPlugin") {
            id = "MagiskPlugin"
            implementationClass = "MagiskPlugin"
        }
    }
}

dependencies {
    implementation(kotlin("gradle-plugin", libs.versions.kotlin.get()))
    implementation(libs.android.gradle.plugin)
    implementation(libs.android.kapt.plugin)
    implementation(libs.ksp.plugin)
    implementation(libs.navigation.safe.args.plugin)
    implementation(libs.lsparanoid.plugin)
    implementation(libs.moshi.plugin)
    implementation(libs.jgit)
}

```

`app/buildSrc/settings.gradle.kts`:

```kts
dependencyResolutionManagement {
    versionCatalogs {
        create("libs") {
            from(files("../gradle/libs.versions.toml"))
        }
    }
}

```

`app/buildSrc/src/main/java/AddCommentTask.kt`:

```kt
import com.android.build.api.artifact.ArtifactTransformationRequest
import com.android.build.api.dsl.ApkSigningConfig
import com.android.builder.internal.packaging.IncrementalPackager
import com.android.tools.build.apkzlib.sign.SigningExtension
import com.android.tools.build.apkzlib.sign.SigningOptions
import com.android.tools.build.apkzlib.zfile.ZFiles
import com.android.tools.build.apkzlib.zip.ZFileOptions
import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.Internal
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import java.io.File
import java.security.KeyStore
import java.security.cert.X509Certificate
import java.util.jar.JarFile

abstract class AddCommentTask: DefaultTask() {
    @get:Input
    abstract val comment: Property<String>

    @get:Input
    abstract val signingConfig: Property<ApkSigningConfig>

    @get:InputFiles
    abstract val apkFolder: DirectoryProperty

    @get:OutputDirectory
    abstract val outFolder: DirectoryProperty

    @get:Internal
    abstract val transformationRequest: Property<ArtifactTransformationRequest<AddCommentTask>>

    @TaskAction
    fun taskAction() = transformationRequest.get().submit(this) { artifact ->
        val inFile = File(artifact.outputFile)
        val outFile = outFolder.file(inFile.name).get().asFile

        val privateKey = signingConfig.get().getPrivateKey()
        val signingOptions = SigningOptions.builder()
            .setMinSdkVersion(0)
            .setV1SigningEnabled(true)
            .setV2SigningEnabled(true)
            .setKey(privateKey.privateKey)
            .setCertificates(privateKey.certificate as X509Certificate)
            .setValidation(SigningOptions.Validation.ASSUME_INVALID)
            .build()
        val options = ZFileOptions().apply {
            noTimestamps = true
            autoSortFiles = true
        }
        outFile.parentFile?.mkdirs()
        inFile.copyTo(outFile, overwrite = true)
        ZFiles.apk(outFile, options).use {
            SigningExtension(signingOptions).register(it)
            it.eocdComment = comment.get().toByteArray()
            it.get(IncrementalPackager.APP_METADATA_ENTRY_PATH)?.delete()
            it.get(IncrementalPackager.VERSION_CONTROL_INFO_ENTRY_PATH)?.delete()
            it.get(JarFile.MANIFEST_NAME)?.delete()
        }

        outFile
    }

    private fun ApkSigningConfig.getPrivateKey(): KeyStore.PrivateKeyEntry {
        val keyStore = KeyStore.getInstance(storeType ?: KeyStore.getDefaultType())
        storeFile!!.inputStream().use {
            keyStore.load(it, storePassword!!.toCharArray())
        }
        val keyPwdArray = keyPassword!!.toCharArray()
        val entry = keyStore.getEntry(keyAlias!!, KeyStore.PasswordProtection(keyPwdArray))
        return entry as KeyStore.PrivateKeyEntry
    }
}
```

`app/buildSrc/src/main/java/DesugarClassVisitorFactory.kt`:

```kt
import com.android.build.api.instrumentation.AsmClassVisitorFactory
import com.android.build.api.instrumentation.ClassContext
import com.android.build.api.instrumentation.ClassData
import com.android.build.api.instrumentation.InstrumentationParameters
import org.objectweb.asm.ClassVisitor
import org.objectweb.asm.MethodVisitor
import org.objectweb.asm.Opcodes
import org.objectweb.asm.Opcodes.ASM9

private const val DESUGAR_CLASS_NAME = "com.topjohnwu.magisk.core.utils.Desugar"
private const val ZIP_ENTRY_CLASS_NAME = "java.util.zip.ZipEntry"
private const val ZIP_OUT_STREAM_CLASS_NAME = "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream"
private const val ZIP_UTIL_CLASS_NAME = "org/apache/commons/compress/archivers/zip/ZipUtil"
private const val ZIP_ENTRY_GET_TIME_DESC = "()Ljava/nio/file/attribute/FileTime;"
private const val DESUGAR_GET_TIME_DESC =
    "(Ljava/util/zip/ZipEntry;)Ljava/nio/file/attribute/FileTime;"

private fun ClassData.isTypeOf(name: String) = className == name || superClasses.contains(name)

abstract class DesugarClassVisitorFactory : AsmClassVisitorFactory<InstrumentationParameters.None> {
    override fun createClassVisitor(
        classContext: ClassContext,
        nextClassVisitor: ClassVisitor
    ): ClassVisitor {
        return if (classContext.currentClassData.className == ZIP_OUT_STREAM_CLASS_NAME) {
            ZipEntryPatcher(classContext, ZipOutputStreamPatcher(nextClassVisitor))
        } else {
            ZipEntryPatcher(classContext, nextClassVisitor)
        }
    }

    override fun isInstrumentable(classData: ClassData) = classData.className != DESUGAR_CLASS_NAME

    // Patch ALL references to ZipEntry#getXXXTime
    class ZipEntryPatcher(
        private val classContext: ClassContext,
        cv: ClassVisitor
    ) : ClassVisitor(ASM9, cv) {
        override fun visitMethod(
            access: Int,
            name: String?,
            descriptor: String?,
            signature: String?,
            exceptions: Array<out String>?
        ) = MethodPatcher(super.visitMethod(access, name, descriptor, signature, exceptions))

        inner class MethodPatcher(mv: MethodVisitor?) : MethodVisitor(ASM9, mv) {
            override fun visitMethodInsn(
                opcode: Int,
                owner: String,
                name: String,
                descriptor: String,
                isInterface: Boolean
            ) {
                if (!process(owner, name, descriptor)) {
                    super.visitMethodInsn(opcode, owner, name, descriptor, isInterface)
                }
            }

            private fun process(owner: String, name: String, descriptor: String): Boolean {
                val classData = classContext.loadClassData(owner.replace("/", ".")) ?: return false
                if (!classData.isTypeOf(ZIP_ENTRY_CLASS_NAME))
                    return false
                if (descriptor != ZIP_ENTRY_GET_TIME_DESC)
                    return false
                return when (name) {
                    "getLastModifiedTime", "getLastAccessTime", "getCreationTime" -> {
                        mv.visitMethodInsn(
                            Opcodes.INVOKESTATIC,
                            DESUGAR_CLASS_NAME.replace('.', '/'),
                            name,
                            DESUGAR_GET_TIME_DESC,
                            false
                        )
                        true
                    }
                    else -> false
                }
            }
        }
    }

    // Patch ZipArchiveOutputStream#copyFromZipInputStream
    class ZipOutputStreamPatcher(cv: ClassVisitor) : ClassVisitor(ASM9, cv) {
        override fun visitMethod(
            access: Int,
            name: String,
            descriptor: String,
            signature: String?,
            exceptions: Array<out String?>?
        ): MethodVisitor? {
            return if (name == "copyFromZipInputStream") {
                MethodPatcher(super.visitMethod(access, name, descriptor, signature, exceptions))
            } else {
                super.visitMethod(access, name, descriptor, signature, exceptions)
            }
        }

        class MethodPatcher(mv: MethodVisitor?) : MethodVisitor(ASM9, mv) {
            override fun visitMethodInsn(
                opcode: Int,
                owner: String,
                name: String,
                descriptor: String?,
                isInterface: Boolean
            ) {
                if (owner == ZIP_UTIL_CLASS_NAME && name == "checkRequestedFeatures") {
                    // Redirect
                    mv.visitMethodInsn(
                        Opcodes.INVOKESTATIC,
                        DESUGAR_CLASS_NAME.replace('.', '/'),
                        name,
                        descriptor,
                        false
                    )
                } else {
                    super.visitMethodInsn(opcode, owner, name, descriptor, isInterface)
                }
            }
        }
    }
}

```

`app/buildSrc/src/main/java/Plugin.kt`:

```kt

import org.eclipse.jgit.internal.storage.file.FileRepository
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.kotlin.dsl.provideDelegate
import java.io.File
import java.util.Properties
import java.util.Random

// Set non-zero value here to fix the random seed for reproducible builds
// CI builds are always reproducible
val RAND_SEED = if (System.getenv("CI") != null) 42 else 0
lateinit var RANDOM: Random

private val props = Properties()
private var commitHash = ""
private val supportAbis = setOf("armeabi-v7a", "x86", "arm64-v8a", "x86_64", "riscv64")
private val defaultAbis = setOf("armeabi-v7a", "x86", "arm64-v8a", "x86_64")

object Config {
    operator fun get(key: String): String? {
        val v = props[key] as? String ?: return null
        return v.ifBlank { null }
    }

    fun contains(key: String) = get(key) != null

    val version: String get() = get("version") ?: commitHash
    val versionCode: Int get() = get("magisk.versionCode")!!.toInt()
    val stubVersion: String get() = get("magisk.stubVersion")!!
    val abiList: Set<String> get() {
        val abiList = get("abiList") ?: return defaultAbis
        return abiList.split(Regex("\\s*,\\s*")).toSet() intersect supportAbis
    }
}

fun Project.rootFile(path: String): File {
    val file = File(path)
    return if (file.isAbsolute) file
    else File(rootProject.file(".."), path)
}

class MagiskPlugin : Plugin<Project> {
    override fun apply(project: Project) = project.applyPlugin()

    private fun Project.applyPlugin() {
        initRandom(rootProject.file("dict.txt"))
        props.clear()

        // Get gradle properties relevant to Magisk
        props.putAll(properties.filter { (key, _) -> key.startsWith("magisk.") })

        // Load config.prop
        val configPath: String? by this
        val configFile = rootFile(configPath ?: "config.prop")
        if (configFile.exists()) {
            configFile.inputStream().use {
                val config = Properties()
                config.load(it)
                // Remove properties that should be passed by commandline
                config.remove("abiList")
                props.putAll(config)
            }
        }

        // Commandline override
        findProperty("abiList")?.let { props.put("abiList", it) }

        val repo = FileRepository(rootFile(".git"))
        val refId = repo.refDatabase.exactRef("HEAD").objectId
        commitHash = repo.newObjectReader().abbreviate(refId, 8).name()
    }
}

```

`app/buildSrc/src/main/java/Setup.kt`:

```kt
import com.android.build.api.artifact.SingleArtifact
import com.android.build.api.dsl.ApplicationExtension
import com.android.build.api.dsl.CommonExtension
import com.android.build.api.instrumentation.FramesComputationMode.COMPUTE_FRAMES_FOR_INSTRUMENTED_METHODS
import com.android.build.api.instrumentation.InstrumentationScope
import com.android.build.api.variant.AndroidComponentsExtension
import com.android.build.api.variant.ApplicationAndroidComponentsExtension
import org.apache.tools.ant.filters.FixCrLfFilter
import org.gradle.api.Action
import org.gradle.api.JavaVersion
import org.gradle.api.Project
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.StopExecutionException
import org.gradle.api.tasks.Sync
import org.gradle.kotlin.dsl.assign
import org.gradle.kotlin.dsl.exclude
import org.gradle.kotlin.dsl.filter
import org.gradle.kotlin.dsl.get
import org.gradle.kotlin.dsl.register
import org.gradle.kotlin.dsl.withType
import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import java.io.File
import java.net.URI
import java.security.MessageDigest
import java.util.HexFormat

private fun Project.android(configure: Action<CommonExtension>) =
    extensions.configure("android", configure)

private fun Project.androidApp(configure: Action<ApplicationExtension>) =
    extensions.configure("android", configure)

internal val Project.androidApp: ApplicationExtension
    get() = extensions["android"] as ApplicationExtension

private fun Project.androidComponents(configure: Action<AndroidComponentsExtension<*, *, *>>) =
    extensions.configure(AndroidComponentsExtension::class.java, configure)

private val Project.androidComponents: AndroidComponentsExtension<*, *, *>
    get() = extensions["androidComponents"] as AndroidComponentsExtension<*, *, *>

internal fun Project.androidAppComponents(configure: Action<ApplicationAndroidComponentsExtension>) =
    extensions.configure(ApplicationAndroidComponentsExtension::class.java, configure)

fun Project.setupCommon() {
    android {
        compileSdk {
            version = release(36) {
                minorApiLevel = 1
            }
        }
        buildToolsVersion = "36.1.0"
        ndkPath = "${androidComponents.sdkComponents.sdkDirectory.get().asFile}/ndk/magisk"
        ndkVersion = "29.0.14206865"

        defaultConfig.apply {
            minSdk = 23
        }

        compileOptions.apply {
            sourceCompatibility = JavaVersion.VERSION_21
            targetCompatibility = JavaVersion.VERSION_21
        }

        packaging.apply {
            resources {
                excludes += arrayOf(
                    "/META-INF/*",
                    "/META-INF/androidx/**",
                    "/META-INF/versions/**",
                    "/org/bouncycastle/**",
                    "/org/apache/commons/**",
                    "/kotlin/**",
                    "/kotlinx/**",
                    "/okhttp3/**",
                    "/*.txt",
                    "/*.bin",
                    "/*.json",
                )
            }
        }
    }

    configurations.all {
        exclude("org.jetbrains.kotlin", "kotlin-stdlib-jdk7")
        exclude("org.jetbrains.kotlin", "kotlin-stdlib-jdk8")
    }

    tasks.withType<KotlinCompile> {
        compilerOptions {
            jvmTarget = JvmTarget.JVM_21
        }
    }
}

private fun Project.downloadFile(url: String, checksum: String): File {
    val file = layout.buildDirectory.file(checksum).get().asFile
    if (file.exists()) {
        val md = MessageDigest.getInstance("SHA-256")
        file.inputStream().use { md.update(it.readAllBytes()) }
        val hash = HexFormat.of().formatHex(md.digest())
        if (hash != checksum) {
            file.delete()
        }
    }
    if (!file.exists()) {
        file.parentFile.mkdirs()
        URI(url).toURL().openStream().use { dl ->
            file.outputStream().use {
                dl.copyTo(it)
            }
        }
    }
    return file
}

const val BUSYBOX_DOWNLOAD_URL =
    "https://github.com/topjohnwu/magisk-files/releases/download/files/busybox-1.36.1.1.zip"
const val BUSYBOX_ZIP_CHECKSUM =
    "b4d0551feabaf314e53c79316c980e8f66432e9fb91a69dbbf10a93564b40951"

private abstract class SyncWithDir : Sync() {
    @get:OutputDirectory
    abstract val outputFolder: DirectoryProperty
}

fun Project.setupCoreLib() {
    setupCommon()

    val abiList = Config.abiList

    androidComponents {
        onVariants { variant ->
            val variantName = variant.name
            val variantCapped = variantName.replaceFirstChar { it.uppercase() }

            val syncLibs = tasks.register("sync${variantCapped}JniLibs", SyncWithDir::class) {
                outputFolder.set(layout.buildDirectory.dir("$variantName/jniLibs"))
                into(outputFolder)

                for (abi in abiList) {
                    into(abi) {
                        from(rootFile("native/out/$abi")) {
                            include("magiskboot", "magiskinit", "magiskpolicy", "magisk", "libinit-ld.so")
                            rename { if (it.endsWith(".so")) it else "lib$it.so" }
                        }
                    }
                }
                from(zipTree(downloadFile(BUSYBOX_DOWNLOAD_URL, BUSYBOX_ZIP_CHECKSUM)))
                include(abiList.map { "$it/libbusybox.so" })
                onlyIf {
                    if (inputs.sourceFiles.files.size != abiList.size * 6)
                        throw StopExecutionException("Please build binaries first! (./build.py binary)")
                    true
                }
            }

            variant.sources.jniLibs?.let {
                it.addGeneratedSourceDirectory(syncLibs, SyncWithDir::outputFolder)
            }

            val syncResources = tasks.register("sync${variantCapped}Resources", SyncWithDir::class) {
                outputFolder.set(layout.buildDirectory.dir("$variantName/resources"))
                into(outputFolder)

                into("META-INF/com/google/android") {
                    from(rootFile("scripts/update_binary.sh")) {
                        rename { "update-binary" }
                    }
                    from(rootFile("scripts/flash_script.sh")) {
                        rename { "updater-script" }
                    }
                }
            }

            variant.sources.resources?.let {
                it.addGeneratedSourceDirectory(syncResources, SyncWithDir::outputFolder)
            }

            val stubTask = tasks.getByPath(":stub:comment$variantCapped")
            val syncAssets = tasks.register("sync${variantCapped}Assets", SyncWithDir::class) {
                outputFolder.set(layout.buildDirectory.dir("$variantName/assets"))
                into(outputFolder)

                inputs.property("version", Config.version)
                inputs.property("versionCode", Config.versionCode)
                from(rootFile("scripts")) {
                    include("util_functions.sh", "boot_patch.sh", "addon.d.sh",
                        "app_functions.sh", "uninstaller.sh", "module_installer.sh")
                }
                from(rootFile("tools/bootctl"))
                into("chromeos") {
                    from(rootFile("tools/futility"))
                    from(rootFile("tools/keys")) {
                        include("kernel_data_key.vbprivk", "kernel.keyblock")
                    }
                }
                from(stubTask) {
                    include { it.name.endsWith(".apk") }
                    rename { "stub.apk" }
                }
                filesMatching("**/util_functions.sh") {
                    filter {
                        it.replace(
                            "#MAGISK_VERSION_STUB",
                            "MAGISK_VER='${Config.version}'\nMAGISK_VER_CODE=${Config.versionCode}"
                        )
                    }
                    filter<FixCrLfFilter>("eol" to FixCrLfFilter.CrLf.newInstance("lf"))
                }
            }

            variant.sources.assets?.let {
                it.addGeneratedSourceDirectory(syncAssets, SyncWithDir::outputFolder)
            }
        }
    }
}

fun Project.setupAppCommon() {
    setupCommon()

    androidApp {
        signingConfigs {
            Config["keyStore"]?.also {
                create("config") {
                    storeFile = rootFile(it)
                    storePassword = Config["keyStorePass"]
                    keyAlias = Config["keyAlias"]
                    keyPassword = Config["keyPass"]
                }
            }
        }

        defaultConfig {
            targetSdk = 36
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt")
            )
        }

        buildTypes {
            val config = signingConfigs.findByName("config") ?: signingConfigs["debug"]
            debug {
                signingConfig = config
            }
            release {
                signingConfig = config
            }
        }

        lint {
            disable += "MissingTranslation"
            checkReleaseBuilds = false
        }

        dependenciesInfo {
            includeInApk = false
        }

        packaging {
            jniLibs {
                useLegacyPackaging = true
            }
        }
    }

    androidAppComponents {
        onVariants { variant ->
            val commentTask = tasks.register(
                "comment${variant.name.replaceFirstChar { it.uppercase() }}",
                AddCommentTask::class.java
            )
            val transformationRequest = variant.artifacts.use(commentTask)
                .wiredWithDirectories(AddCommentTask::apkFolder, AddCommentTask::outFolder)
                .toTransformMany(SingleArtifact.APK)
            val signingConfig = androidApp.buildTypes.getByName(variant.buildType!!).signingConfig
            commentTask.configure {
                this.transformationRequest = transformationRequest
                this.signingConfig = signingConfig
                this.comment = "version=${Config.version}\n" +
                        "versionCode=${Config.versionCode}\n" +
                        "stubVersion=${Config.stubVersion}\n"
                this.outFolder.set(layout.buildDirectory.dir("outputs/apk/${variant.name}"))
            }

        }
    }
}

fun Project.setupMainApk() {
    setupAppCommon()

    androidApp {
        namespace = "com.topjohnwu.magisk"

        defaultConfig {
            applicationId = "com.topjohnwu.magisk"
            vectorDrawables.useSupportLibrary = true
            versionName = Config.version
            versionCode = Config.versionCode
            ndk {
                abiFilters += listOf("armeabi-v7a", "arm64-v8a", "x86", "x86_64", "riscv64")
                debugSymbolLevel = "FULL"
            }
        }
    }

    androidComponents {
        onVariants { variant ->
            variant.instrumentation.apply {
                setAsmFramesComputationMode(COMPUTE_FRAMES_FOR_INSTRUMENTED_METHODS)
                transformClassesWith(
                    DesugarClassVisitorFactory::class.java, InstrumentationScope.ALL) {}
            }
        }
    }
}

const val LSPOSED_DOWNLOAD_URL =
    "https://github.com/LSPosed/LSPosed/releases/download/v1.9.2/LSPosed-v1.9.2-7024-zygisk-release.zip"
const val LSPOSED_CHECKSUM =
    "0ebc6bcb465d1c4b44b7220ab5f0252e6b4eb7fe43da74650476d2798bb29622"

const val SHAMIKO_DOWNLOAD_URL =
    "https://github.com/LSPosed/LSPosed.github.io/releases/download/shamiko-383/Shamiko-v1.2.1-383-release.zip"
const val SHAMIKO_CHECKSUM =
    "93754a038c2d8f0e985bad45c7303b96f70a93d8335060e50146f028d3a9b13f"

fun Project.setupTestApk() {
    setupAppCommon()

    androidComponents {
        onVariants { variant ->
            val variantName = variant.name
            val variantCapped = variantName.replaceFirstChar { it.uppercase() }

            val dlTask = tasks.register("download${variantCapped}Lsposed", SyncWithDir::class) {
                outputFolder.set(layout.buildDirectory.dir("$variantName/lsposed"))
                into(outputFolder)

                from(downloadFile(LSPOSED_DOWNLOAD_URL, LSPOSED_CHECKSUM)) {
                    rename { "lsposed.zip" }
                }
                from(downloadFile(SHAMIKO_DOWNLOAD_URL, SHAMIKO_CHECKSUM)) {
                    rename { "shamiko.zip" }
                }
            }

            variant.sources.assets?.let {
                it.addGeneratedSourceDirectory(dlTask, SyncWithDir::outputFolder)
            }
        }
    }
}

```

`app/buildSrc/src/main/java/Stub.kt`:

```kt
import com.android.build.api.artifact.SingleArtifact
import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.Delete
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction
import org.gradle.kotlin.dsl.assign
import org.gradle.kotlin.dsl.named
import org.gradle.kotlin.dsl.register
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.PrintStream
import java.security.SecureRandom
import java.util.Random
import java.util.zip.Deflater
import java.util.zip.DeflaterOutputStream
import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import java.util.zip.ZipOutputStream
import javax.crypto.Cipher
import javax.crypto.CipherOutputStream
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec
import kotlin.random.asKotlinRandom

private val kRANDOM get() = RANDOM.asKotlinRandom()

private val c1 = mutableListOf<String>()
private val c2 = mutableListOf<String>()
private val c3 = mutableListOf<String>()

fun initRandom(dict: File) {
    RANDOM = if (RAND_SEED != 0) Random(RAND_SEED.toLong()) else SecureRandom()
    c1.clear()
    c2.clear()
    c3.clear()
    for (a in chain('a'..'z', 'A'..'Z')) {
        if (a != 'a' && a != 'A') {
            c1.add("$a")
        }
        for (b in chain('a'..'z', 'A'..'Z', '0'..'9')) {
            c2.add("$a$b")
            for (c in chain('a'..'z', 'A'..'Z', '0'..'9')) {
                c3.add("$a$b$c")
            }
        }
    }
    c1.shuffle(RANDOM)
    c2.shuffle(RANDOM)
    c3.shuffle(RANDOM)
    PrintStream(dict).use {
        for (c in chain(c1, c2, c3)) {
            it.println(c)
        }
    }
}

private fun <T> chain(vararg iters: Iterable<T>) = sequence {
    iters.forEach { it.forEach { v -> yield(v) } }
}

private fun PrintStream.byteField(name: String, bytes: ByteArray) {
    println("public static byte[] $name() {")
    print("byte[] buf = {")
    print(bytes.joinToString(",") { it.toString() })
    println("};")
    println("return buf;")
    println("}")
}

@CacheableTask
private abstract class ManifestUpdater: DefaultTask() {
    @get:Input
    abstract val applicationId: Property<String>

    @get:Input
    abstract val factoryClass: Property<String>

    @get:Input
    abstract val appClass: Property<String>

    @get:InputFile
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val mergedManifest: RegularFileProperty

    @get:OutputFile
    abstract val outputManifest: RegularFileProperty

    @TaskAction
    fun taskAction() {
        fun String.ind(level: Int) = replaceIndentByMargin("    ".repeat(level))

        val cmpList = mutableListOf<String>()

        cmpList.add("""
            |<provider
            |    android:name="x.COMPONENT_PLACEHOLDER_0"
            |    android:authorities="${'$'}{applicationId}.provider"
            |    android:directBootAware="true"
            |    android:exported="false"
            |    android:grantUriPermissions="true" />""".ind(2)
        )

        cmpList.add("""
            |<receiver
            |    android:name="x.COMPONENT_PLACEHOLDER_1"
            |    android:exported="false">
            |    <intent-filter>
            |        <action android:name="android.intent.action.LOCALE_CHANGED" />
            |        <action android:name="android.intent.action.UID_REMOVED" />
            |        <action android:name="android.intent.action.MY_PACKAGE_REPLACED" />
            |    </intent-filter>
            |    <intent-filter>
            |        <action android:name="android.intent.action.PACKAGE_REPLACED" />
            |        <action android:name="android.intent.action.PACKAGE_FULLY_REMOVED" />
            |
            |        <data android:scheme="package" />
            |    </intent-filter>
            |</receiver>""".ind(2)
        )

        cmpList.add("""
            |<activity
            |    android:name="x.COMPONENT_PLACEHOLDER_2"
            |    android:exported="true">
            |    <intent-filter>
            |        <action android:name="android.intent.action.MAIN" />
            |        <category android:name="android.intent.category.LAUNCHER" />
            |    </intent-filter>
            |</activity>""".ind(2)
        )

        cmpList.add("""
            |<activity
            |    android:name="x.COMPONENT_PLACEHOLDER_3"
            |    android:directBootAware="true"
            |    android:exported="false"
            |    android:taskAffinity="">
            |    <intent-filter>
            |        <action android:name="android.intent.action.VIEW"/>
            |        <category android:name="android.intent.category.DEFAULT"/>
            |    </intent-filter>
            |</activity>""".ind(2)
        )

        cmpList.add("""
            |<service
            |    android:name="x.COMPONENT_PLACEHOLDER_4"
            |    android:exported="false"
            |    android:foregroundServiceType="dataSync" />""".ind(2)
        )

        cmpList.add("""
            |<service
            |    android:name="x.COMPONENT_PLACEHOLDER_5"
            |    android:exported="false"
            |    android:permission="android.permission.BIND_JOB_SERVICE" />""".ind(2)
        )

        // Shuffle the order of the components
        cmpList.shuffle(RANDOM)
        val components = cmpList.joinToString("\n\n")
            .replace("\${applicationId}", applicationId.get())
        val manifest = mergedManifest.asFile.get().readText().replace(Regex(".*\\<application"), """
            |<application
            |    android:appComponentFactory="${factoryClass.get()}"
            |    android:name="${appClass.get()}"""".ind(1)
        ).replace(Regex(".*\\<\\/application"), "$components\n    </application")
        outputManifest.get().asFile.writeText(manifest)
    }
}

private fun genStubClasses(outDir: File): Pair<String, String> {
    val classNameGenerator = sequence {
        fun notJavaKeyword(name: String) = when (name) {
            "do", "if", "for", "int", "new", "try" -> false
            else -> true
        }

        fun List<String>.process() = asSequence()
            .filter(::notJavaKeyword)
            // Distinct by lower case to support case insensitive file systems
            .distinctBy { it.lowercase() }

        val names = mutableListOf<String>()
        names.addAll(c1)
        names.addAll(c2.process().take(30))
        names.addAll(c3.process().take(30))
        names.shuffle(RANDOM)

        while (true) {
            val cls = StringBuilder()
            cls.append(names.random(kRANDOM))
            cls.append('.')
            cls.append(names.random(kRANDOM))
            // Old Android does not support capitalized package names
            // Check Android 7.0.0 PackageParser#buildClassName
            yield(cls.toString().replaceFirstChar { it.lowercase() })
        }
    }.distinct().iterator()

    fun genClass(type: String, outDir: File): String {
        val clzName = classNameGenerator.next()
        val (pkg, name) = clzName.split('.')
        val pkgDir = File(outDir, pkg)
        pkgDir.mkdirs()
        PrintStream(File(pkgDir, "$name.java")).use {
            it.println("package $pkg;")
            it.println("public class $name extends com.topjohnwu.magisk.$type {}")
        }
        return clzName
    }

    val factory = genClass("DelegateComponentFactory", outDir)
    val app = genClass("StubApplication", outDir)
    return Pair(factory, app)
}

private fun genEncryptedResources(res: ByteArray, outDir: File) {
    val mainPkgDir = File(outDir, "com/topjohnwu/magisk")
    mainPkgDir.mkdirs()

    // Generate iv and key
    val iv = ByteArray(16)
    val key = ByteArray(32)
    RANDOM.nextBytes(iv)
    RANDOM.nextBytes(key)

    val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
    cipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key, "AES"), IvParameterSpec(iv))
    val bos = ByteArrayOutputStream()

    ByteArrayInputStream(res).use {
        CipherOutputStream(bos, cipher).use { os ->
            it.transferTo(os)
        }
    }

    PrintStream(File(mainPkgDir, "Bytes.java")).use {
        it.println("package com.topjohnwu.magisk;")
        it.println("public final class Bytes {")

        it.byteField("key", key)
        it.byteField("iv", iv)
        it.byteField("res", bos.toByteArray())

        it.println("}")
    }
}

private abstract class TaskWithDir : DefaultTask() {
    @get:OutputDirectory
    abstract val outputFolder: DirectoryProperty
}

fun Project.setupStubApk() {
    setupAppCommon()

    androidAppComponents {
        onVariants { variant ->
            val variantName = variant.name
            val variantCapped = variantName.replaceFirstChar { it.uppercase() }
            val variantLowered = variantName.lowercase()

            val componentJavaOutDir = layout.buildDirectory
                .dir("generated/${variantLowered}/components").get().asFile

            val (factory, app) = genStubClasses(componentJavaOutDir)

            val manifestUpdater =
                project.tasks.register("${variantName}ManifestProducer", ManifestUpdater::class.java) {
                    applicationId = variant.applicationId
                    factoryClass.set(factory)
                    appClass.set(app)
                }
            variant.artifacts.use(manifestUpdater)
                .wiredWithFiles(
                    ManifestUpdater::mergedManifest,
                    ManifestUpdater::outputManifest)
                .toTransform(SingleArtifact.MERGED_MANIFEST)

            val aapt = sdkComponents.aapt2.get().executable.get().asFile
            val apk = layout.buildDirectory.file("intermediates/linked_resources_binary_format/" +
                    "${variantLowered}/process${variantCapped}Resources/" +
                    "linked-resources-binary-format-${variantLowered}.ap_").get().asFile

            val genResourcesTask = tasks.register("generate${variantCapped}BundledResources", TaskWithDir::class) {
                dependsOn("process${variantCapped}Resources")
                outputFolder.set(layout.buildDirectory.dir("generated/${variantLowered}/resources"))

                doLast {
                    val apkTmp = File("${apk}.tmp")
                    providers.exec {
                        commandLine(aapt, "optimize", "-o", apkTmp, "--collapse-resource-names", apk)
                    }.result.get()

                    val bos = ByteArrayOutputStream()
                    ZipFile(apkTmp).use { src ->
                        ZipOutputStream(apk.outputStream()).use {
                            it.setLevel(Deflater.BEST_COMPRESSION)
                            it.putNextEntry(ZipEntry("AndroidManifest.xml"))
                            src.getInputStream(src.getEntry("AndroidManifest.xml")).transferTo(it)
                            it.closeEntry()
                        }
                        DeflaterOutputStream(bos, Deflater(Deflater.BEST_COMPRESSION)).use {
                            src.getInputStream(src.getEntry("resources.arsc")).transferTo(it)
                        }
                    }
                    apkTmp.delete()
                    genEncryptedResources(bos.toByteArray(), outputFolder.get().asFile)
                }
            }

            variant.sources.java?.let {
                it.addStaticSourceDirectory(componentJavaOutDir.path)
                it.addGeneratedSourceDirectory(genResourcesTask, TaskWithDir::outputFolder)
            }
        }
    }

    // Override optimizeReleaseResources task
    val apk = layout.buildDirectory.file("intermediates/linked_resources_binary_format/" +
            "release/processReleaseResources/linked-resources-binary-format-release.ap_").get().asFile
    val optRes = layout.buildDirectory.file("intermediates/optimized_processed_res/" +
            "release/optimizeReleaseResources/resources-release-optimize.ap_").get().asFile
    afterEvaluate {
        tasks.named("optimizeReleaseResources") {
            doLast { apk.copyTo(optRes, true) }
        }
    }
    tasks.named<Delete>("clean") {
        delete.addAll(listOf("src/debug/AndroidManifest.xml", "src/release/AndroidManifest.xml"))
    }
}

```

`app/core/build.gradle.kts`:

```kts
plugins {
    id("com.android.library")
    kotlin("plugin.parcelize")
    id("dev.zacsweers.moshix")
    id("com.google.devtools.ksp")
}

setupCoreLib()

ksp {
    arg("room.generateKotlin", "true")
}

android {
    namespace = "com.topjohnwu.magisk.core"

    defaultConfig {
        buildConfigField("String", "APP_PACKAGE_NAME", "\"com.topjohnwu.magisk\"")
        buildConfigField("int", "APP_VERSION_CODE", "${Config.versionCode}")
        buildConfigField("String", "APP_VERSION_NAME", "\"${Config.version}\"")
        buildConfigField("int", "STUB_VERSION", Config.stubVersion)
        consumerProguardFile("proguard-rules.pro")
    }

    buildFeatures {
        aidl = true
        buildConfig = true
    }

    compileOptions {
        isCoreLibraryDesugaringEnabled = true
    }
}

dependencies {
    api(project(":shared"))
    coreLibraryDesugaring(libs.jdk.libs)

    api(libs.timber)
    api(libs.markwon.core)
    implementation(libs.bcpkix)
    implementation(libs.commons.compress)

    api(libs.libsu.core)
    api(libs.libsu.service)
    api(libs.libsu.nio)

    implementation(libs.retrofit)
    implementation(libs.retrofit.moshi)
    implementation(libs.retrofit.scalars)

    implementation(libs.okhttp)
    implementation(libs.okhttp.logging)
    implementation(libs.okhttp.dnsoverhttps)

    implementation(libs.room.runtime)
    implementation(libs.room.ktx)
    ksp(libs.room.compiler)

    implementation(libs.core.splashscreen)
    implementation(libs.core.ktx)
    implementation(libs.activity)
    implementation(libs.collection.ktx)
    implementation(libs.profileinstaller)

    // We also implement all our tests in this module.
    // However, we don't want to bundle test dependencies.
    // That's why we make it compileOnly.
    compileOnly(libs.test.junit)
    compileOnly(libs.test.uiautomator)
}

```

`app/core/proguard-rules.pro`:

```pro
# Parcelable
-keepclassmembers class * implements android.os.Parcelable {
    public static final ** CREATOR;
}

# Kotlin
-assumenosideeffects class kotlin.jvm.internal.Intrinsics {
	public static void check*(...);
	public static void throw*(...);
}
-assumenosideeffects class java.util.Objects {
    public static ** requireNonNull(...);
}
-assumenosideeffects public class kotlin.coroutines.jvm.internal.DebugMetadataKt {
   private static ** getDebugMetadataAnnotation(...) return null;
}

# Stub
-keep class com.topjohnwu.magisk.core.App { <init>(java.lang.Object); }
-keepclassmembers class androidx.appcompat.app.AppCompatDelegateImpl {
  boolean mActivityHandlesConfigFlagsChecked;
  int mActivityHandlesConfigFlags;
}

# Strip Timber verbose and debug logging
-assumenosideeffects class timber.log.Timber$Tree {
  public void v(**);
  public void d(**);
}

# With R8 full mode generic signatures are stripped for classes that are not
# kept. Suspend functions are wrapped in continuations where the type argument
# is used.
-keep,allowobfuscation,allowshrinking class kotlin.coroutines.Continuation

-dontwarn org.junit.**
-dontwarn org.apache.**

```

`app/core/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <permission
        android:name="${applicationId}.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"
        android:protectionLevel="signature"
        tools:node="remove" />

    <uses-permission
        android:name="${applicationId}.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"
        tools:node="remove" />

    <application
        android:name=".App"
        android:icon="@drawable/ic_launcher"
        tools:ignore="UnusedAttribute,GoogleAppIndexingWarning"
        tools:remove="android:appComponentFactory">

        <receiver
            android:name=".Receiver"
            android:exported="false">
            <intent-filter>
                <action android:name="android.intent.action.LOCALE_CHANGED" />
                <action android:name="android.intent.action.UID_REMOVED" />
                <action android:name="android.intent.action.MY_PACKAGE_REPLACED" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.PACKAGE_REPLACED" />
                <action android:name="android.intent.action.PACKAGE_FULLY_REMOVED" />

                <data android:scheme="package" />
            </intent-filter>
        </receiver>

        <service
            android:name=".Service"
            android:exported="false"
            android:enabled="@bool/enable_fg_service"
            android:foregroundServiceType="dataSync" />

        <service
            android:name=".JobService"
            android:exported="false"
            android:permission="android.permission.BIND_JOB_SERVICE" />

        <provider
            android:name=".Provider"
            android:authorities="${applicationId}.provider"
            android:directBootAware="true"
            android:exported="false"
            android:grantUriPermissions="true" />

        <!-- We don't invalidate Room -->
        <service
            android:name="androidx.room.MultiInstanceInvalidationService"
            tools:node="remove" />

        <!-- We handle initialization ourselves -->
        <provider
            android:name="androidx.startup.InitializationProvider"
            android:authorities="${applicationId}.androidx-startup"
            tools:node="remove" />

        <!-- We handle profile installation ourselves  -->
        <receiver
            android:name="androidx.profileinstaller.ProfileInstallReceiver"
            tools:node="remove" />

    </application>

</manifest>

```

`app/core/src/main/aidl/com/topjohnwu/magisk/core/utils/IRootUtils.aidl`:

```aidl
// IRootUtils.aidl
package com.topjohnwu.magisk.core.utils;

// Declare any non-default types here with import statements

interface IRootUtils {
    android.app.ActivityManager.RunningAppProcessInfo getAppProcess(int pid);
    IBinder getFileSystem();
    boolean addSystemlessHosts();
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/App.kt`:

```kt
package com.topjohnwu.magisk.core

import android.app.Application
import android.content.Context
import com.topjohnwu.magisk.StubApk
import com.topjohnwu.magisk.core.utils.RootUtils

open class App() : Application() {

    constructor(o: Any) : this() {
        val data = StubApk.Data(o)
        // Add the root service name mapping
        data.classToComponent[RootUtils::class.java.name] = data.rootService.name
        // Send back the actual root service class
        data.rootService = RootUtils::class.java
        Info.stub = data
    }

    override fun attachBaseContext(context: Context) {
        if (context is Application) {
            AppContext.attachApplication(context)
        } else {
            super.attachBaseContext(context)
            AppContext.attachApplication(this)
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/AppContext.kt`:

```kt
package com.topjohnwu.magisk.core

import android.app.Activity
import android.app.Application
import android.app.LocaleManager
import android.content.ComponentCallbacks2
import android.content.Context
import android.content.ContextWrapper
import android.content.res.Configuration
import android.os.Build
import android.os.Build.VERSION.SDK_INT
import android.os.Bundle
import android.system.Os
import androidx.profileinstaller.ProfileInstaller
import com.topjohnwu.magisk.StubApk
import com.topjohnwu.magisk.core.base.UntrackedActivity
import com.topjohnwu.magisk.core.utils.LocaleSetting
import com.topjohnwu.magisk.core.utils.NetworkObserver
import com.topjohnwu.magisk.core.utils.RootUtils
import com.topjohnwu.magisk.core.utils.ShellInit
import com.topjohnwu.superuser.Shell
import com.topjohnwu.superuser.internal.UiThreadHandler
import com.topjohnwu.superuser.ipc.RootService
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.asExecutor
import kotlinx.coroutines.launch
import timber.log.Timber
import java.lang.ref.WeakReference
import kotlin.system.exitProcess

lateinit var AppApkPath: String
    private set

object AppContext : ContextWrapper(null),
    Application.ActivityLifecycleCallbacks, ComponentCallbacks2 {

    val foregroundActivity: Activity? get() = ref.get()

    private var ref = WeakReference<Activity>(null)
    private lateinit var application: Application
    private lateinit var networkObserver: NetworkObserver

    init {
        // Always log full stack trace with Timber
        Timber.plant(Timber.DebugTree())
        Thread.setDefaultUncaughtExceptionHandler { _, e ->
            Timber.e(e)
            exitProcess(1)
        }

        Os.setenv("PATH", "${Os.getenv("PATH")}:/debug_ramdisk:/sbin", true)
    }

    override fun onConfigurationChanged(newConfig: Configuration) {
        LocaleSetting.instance.updateResource(resources)
    }

    override fun onActivityStarted(activity: Activity) {
        networkObserver.postCurrentState()
    }

    override fun onActivityResumed(activity: Activity) {
        if (activity is UntrackedActivity) return
        ref = WeakReference(activity)
    }

    override fun onActivityPaused(activity: Activity) {
        if (activity is UntrackedActivity) return
        ref.clear()
    }

    override fun getApplicationContext() = application

    fun attachApplication(app: Application) {
        application = app
        val base = app.baseContext
        attachBaseContext(base)
        app.registerActivityLifecycleCallbacks(this)
        app.registerComponentCallbacks(this)

        AppApkPath = if (isRunningAsStub) {
            StubApk.current(base).path
        } else {
            base.packageResourcePath
        }
        resources.patch()

        val shellBuilder = Shell.Builder.create()
            .setFlags(Shell.FLAG_MOUNT_MASTER)
            .setInitializers(ShellInit::class.java)
            .setContext(this)
            .setTimeout(2)
        Shell.setDefaultBuilder(shellBuilder)
        Shell.EXECUTOR = Dispatchers.IO.asExecutor()
        RootUtils.bindTask = RootService.bindOrTask(
            intent<RootUtils>(),
            UiThreadHandler.executor,
            RootUtils.Connection
        )
        // Pre-heat the shell ASAP
        Shell.getShell(null) {}

        if (SDK_INT >= 34 && isRunningAsStub) {
            // Send over the locale config manually
            val lm = getSystemService(LocaleManager::class.java)
            lm.overrideLocaleConfig = LocaleSetting.localeConfig
        }
        networkObserver = NetworkObserver.init(this)
        if (!BuildConfig.DEBUG && !isRunningAsStub) {
            GlobalScope.launch(Dispatchers.IO) {
                ProfileInstaller.writeProfile(this@AppContext)
            }
        }
    }

    override fun createDeviceProtectedStorageContext(): Context {
        return if (SDK_INT >= Build.VERSION_CODES.N) {
            super.createDeviceProtectedStorageContext()
        } else {
            this
        }
    }

    override fun onActivityCreated(activity: Activity, bundle: Bundle?) {}
    override fun onActivityStopped(activity: Activity) {}
    override fun onActivitySaveInstanceState(activity: Activity, bundle: Bundle) {}
    override fun onActivityDestroyed(activity: Activity) {}
    override fun onLowMemory() {}
    override fun onTrimMemory(level: Int) {}
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/Config.kt`:

```kt
package com.topjohnwu.magisk.core

import android.os.Bundle
import androidx.core.content.edit
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.core.repository.DBConfig
import com.topjohnwu.magisk.core.repository.PreferenceConfig
import com.topjohnwu.magisk.core.utils.LocaleSetting
import kotlinx.coroutines.GlobalScope

object Config : PreferenceConfig, DBConfig {

    override val stringDB get() = ServiceLocator.stringDB
    override val settingsDB get() = ServiceLocator.settingsDB
    override val context get() = ServiceLocator.deContext
    override val coroutineScope get() = GlobalScope

    object Key {
        // db configs
        const val ROOT_ACCESS = "root_access"
        const val SU_MULTIUSER_MODE = "multiuser_mode"
        const val SU_MNT_NS = "mnt_ns"
        const val SU_BIOMETRIC = "su_biometric"
        const val ZYGISK = "zygisk"
        const val BOOTLOOP = "bootloop"
        const val SU_MANAGER = "requester"
        const val KEYSTORE = "keystore"

        // prefs
        const val SU_REQUEST_TIMEOUT = "su_request_timeout"
        const val SU_AUTO_RESPONSE = "su_auto_response"
        const val SU_NOTIFICATION = "su_notification"
        const val SU_REAUTH = "su_reauth"
        const val SU_TAPJACK = "su_tapjack"
        const val SU_RESTRICT = "su_restrict"
        const val CHECK_UPDATES = "check_update"
        const val RELEASE_CHANNEL = "release_channel"
        const val CUSTOM_CHANNEL = "custom_channel"
        const val LOCALE = "locale"
        const val DARK_THEME = "dark_theme_extended"
        const val DOWNLOAD_DIR = "download_dir"
        const val SAFETY = "safety_notice"
        const val THEME_ORDINAL = "theme_ordinal"
        const val ASKED_HOME = "asked_home"
        const val DOH = "doh"
        const val RAND_NAME = "rand_name"

        val NO_MIGRATION = setOf(ASKED_HOME, SU_REQUEST_TIMEOUT,
            SU_AUTO_RESPONSE, SU_REAUTH, SU_TAPJACK)
    }

    object OldValue {
        // Update channels
        const val DEFAULT_CHANNEL = -1
        const val STABLE_CHANNEL = 0
        const val BETA_CHANNEL = 1
        const val CUSTOM_CHANNEL = 2
        const val CANARY_CHANNEL = 3
        const val DEBUG_CHANNEL = 4
    }

    object Value {
        // Update channels
        const val DEFAULT_CHANNEL = -1
        const val STABLE_CHANNEL = 0
        const val BETA_CHANNEL = 1
        const val DEBUG_CHANNEL = 2
        const val CUSTOM_CHANNEL = 3

        // root access mode
        const val ROOT_ACCESS_DISABLED = 0
        const val ROOT_ACCESS_APPS_ONLY = 1
        const val ROOT_ACCESS_ADB_ONLY = 2
        const val ROOT_ACCESS_APPS_AND_ADB = 3

        // su multiuser
        const val MULTIUSER_MODE_OWNER_ONLY = 0
        const val MULTIUSER_MODE_OWNER_MANAGED = 1
        const val MULTIUSER_MODE_USER = 2

        // su mnt ns
        const val NAMESPACE_MODE_GLOBAL = 0
        const val NAMESPACE_MODE_REQUESTER = 1
        const val NAMESPACE_MODE_ISOLATE = 2

        // su notification
        const val NO_NOTIFICATION = 0
        const val NOTIFICATION_TOAST = 1

        // su auto response
        const val SU_PROMPT = 0
        const val SU_AUTO_DENY = 1
        const val SU_AUTO_ALLOW = 2

        // su timeout
        val TIMEOUT_LIST = longArrayOf(0, -1, 10, 20, 30, 60)
    }

    @JvmField var keepVerity = false
    @JvmField var keepEnc = false
    @JvmField var recovery = false
    var denyList = false

    var askedHome by preference(Key.ASKED_HOME, false)
    var bootloop by dbSettings(Key.BOOTLOOP, 0)

    var safetyNotice by preference(Key.SAFETY, true)
    var darkTheme by preference(Key.DARK_THEME, -1)
    var themeOrdinal by preference(Key.THEME_ORDINAL, 0)

    private var checkUpdatePrefs by preference(Key.CHECK_UPDATES, true)
    private var localePrefs by preference(Key.LOCALE, "")
    var doh by preference(Key.DOH, false)
    var updateChannel by preference(Key.RELEASE_CHANNEL, Value.DEFAULT_CHANNEL)
    var customChannelUrl by preference(Key.CUSTOM_CHANNEL, "")
    var downloadDir by preference(Key.DOWNLOAD_DIR, "")
    var randName by preference(Key.RAND_NAME, true)
    var checkUpdate
        get() = checkUpdatePrefs
        set(value) {
            if (checkUpdatePrefs != value) {
                checkUpdatePrefs = value
                JobService.schedule(AppContext)
            }
        }
    var locale
        get() = localePrefs
        set(value) {
            localePrefs = value
            LocaleSetting.instance.setLocale(value)
        }

    var zygisk by dbSettings(Key.ZYGISK, Info.isEmulator)
    var suManager by dbStrings(Key.SU_MANAGER, "", true)
    var keyStoreRaw by dbStrings(Key.KEYSTORE, "", true)

    var suDefaultTimeout by preferenceStrInt(Key.SU_REQUEST_TIMEOUT, 10)
    var suAutoResponse by preferenceStrInt(Key.SU_AUTO_RESPONSE, Value.SU_PROMPT)
    var suNotification by preferenceStrInt(Key.SU_NOTIFICATION, Value.NOTIFICATION_TOAST)
    var rootMode by dbSettings(Key.ROOT_ACCESS, Value.ROOT_ACCESS_APPS_AND_ADB)
    var suMntNamespaceMode by dbSettings(Key.SU_MNT_NS, Value.NAMESPACE_MODE_REQUESTER)
    var suMultiuserMode by dbSettings(Key.SU_MULTIUSER_MODE, Value.MULTIUSER_MODE_OWNER_ONLY)
    private var suBiometric by dbSettings(Key.SU_BIOMETRIC, false)
    var suAuth
        get() = Info.isDeviceSecure && suBiometric
        set(value) {
            suBiometric = value
        }
    var suReAuth by preference(Key.SU_REAUTH, false)
    var suTapjack by preference(Key.SU_TAPJACK, true)
    var suRestrict by preference(Key.SU_RESTRICT, false)

    private const val SU_FINGERPRINT = "su_fingerprint"
    private const val UPDATE_CHANNEL = "update_channel"

    fun toBundle(): Bundle {
        val map = prefs.all - Key.NO_MIGRATION
        return Bundle().apply {
            for ((key, value) in map) {
                when (value) {
                    is String -> putString(key, value)
                    is Int -> putInt(key, value)
                    is Boolean -> putBoolean(key, value)
                }
            }
        }
    }

    @Suppress("DEPRECATION")
    private fun fromBundle(bundle: Bundle) {
        val keys = bundle.keySet().apply { removeAll(Key.NO_MIGRATION) }
        prefs.edit {
            for (key in keys) {
                when (val value = bundle.get(key)) {
                    is String -> putString(key, value)
                    is Int -> putInt(key, value)
                    is Boolean -> putBoolean(key, value)
                }
            }
        }
    }

    fun init(bundle: Bundle?) {
        // Only try to load prefs when fresh install
        if (bundle != null && prefs.all.isEmpty()) {
            fromBundle(bundle)
        }

        prefs.edit {
            // Migrate su_fingerprint
            if (prefs.getBoolean(SU_FINGERPRINT, false))
                suBiometric = true
            remove(SU_FINGERPRINT)

            // Migrate update_channel
            prefs.getString(UPDATE_CHANNEL, null)?.let {
                val channel = when (it.toInt()) {
                    OldValue.STABLE_CHANNEL -> Value.STABLE_CHANNEL
                    OldValue.CANARY_CHANNEL, OldValue.BETA_CHANNEL -> Value.BETA_CHANNEL
                    OldValue.DEBUG_CHANNEL -> Value.DEBUG_CHANNEL
                    OldValue.CUSTOM_CHANNEL -> Value.CUSTOM_CHANNEL
                    else -> Value.DEFAULT_CHANNEL
                }
                putInt(Key.RELEASE_CHANNEL, channel)
            }
            remove(UPDATE_CHANNEL)
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/Const.kt`:

```kt
package com.topjohnwu.magisk.core

import android.os.Build
import android.os.Process
import com.topjohnwu.magisk.core.BuildConfig.APP_VERSION_CODE

@Suppress("DEPRECATION")
object Const {

    val CPU_ABI: String get() = Build.SUPPORTED_ABIS[0]

    // Null if 32-bit only or 64-bit only
    val CPU_ABI_32 =
        if (Build.SUPPORTED_64_BIT_ABIS.isEmpty()) null
        else Build.SUPPORTED_32_BIT_ABIS.firstOrNull()

    // Paths
    const val MODULE_PATH  = "/data/adb/modules"
    const val TMPDIR = "/dev/tmp"
    const val MAGISK_LOG = "/cache/magisk.log"

    // Misc
    val USER_ID = Process.myUid() / 100000

    object Version {
        const val MIN_VERSION = "v22.0"
        const val MIN_VERCODE = 22000

        private fun isCanary() = (Info.env.versionCode % 100) != 0
        fun atLeast_24_0() = Info.env.versionCode >= 24000 || isCanary()
        fun atLeast_25_0() = Info.env.versionCode >= 25000 || isCanary()
        fun atLeast_28_0() = Info.env.versionCode >= 28000 || isCanary()
        fun atLeast_30_1() = Info.env.versionCode >= 30100 || isCanary()
    }

    object ID {
        const val DOWNLOAD_JOB_ID = 6
        const val CHECK_UPDATE_JOB_ID = 7
    }

    object Url {
        const val PATREON_URL = "https://www.patreon.com/topjohnwu"
        const val SOURCE_CODE_URL = "https://github.com/topjohnwu/Magisk"

        const val GITHUB_API_URL = "https://api.github.com/"
        const val GITHUB_PAGE_URL = "https://topjohnwu.github.io/magisk-files/"
        const val INVALID_URL = "https://example.com/"
    }

    object Key {
        // intents
        const val OPEN_SECTION = "section"
        const val PREV_CONFIG = "prev_config"
    }

    object Value {
        const val FLASH_ZIP = "flash"
        const val PATCH_FILE = "patch"
        const val FLASH_MAGISK = "magisk"
        const val FLASH_INACTIVE_SLOT = "slot"
        const val UNINSTALL = "uninstall"
    }

    object Nav {
        const val HOME = "home"
        const val SETTINGS = "settings"
        const val MODULES = "modules"
        const val SUPERUSER = "superuser"
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/Hacks.kt`:

```kt
@file:Suppress("DEPRECATION")

package com.topjohnwu.magisk.core

import android.content.ComponentName
import android.content.Context
import android.content.ContextWrapper
import android.content.Intent
import android.content.res.Configuration
import android.content.res.Resources
import com.topjohnwu.magisk.StubApk
import com.topjohnwu.magisk.core.ktx.unwrap
import com.topjohnwu.magisk.core.utils.LocaleSetting

fun Resources.addAssetPath(path: String) = StubApk.addAssetPath(this, path)

fun Resources.patch(): Resources {
    if (isRunningAsStub)
        addAssetPath(AppApkPath)
    LocaleSetting.instance.updateResource(this)
    return this
}

fun Context.patch(): Context {
    unwrap().resources.patch()
    return this
}

// Wrapping is only necessary for ContextThemeWrapper to support configuration overrides
fun Context.wrap(): Context {
    patch()
    return object : ContextWrapper(this) {
        override fun createConfigurationContext(config: Configuration): Context {
            return super.createConfigurationContext(config).wrap()
        }
    }
}

fun Class<*>.cmp(pkg: String) =
    ComponentName(pkg, Info.stub?.classToComponent?.get(name) ?: name)

inline fun <reified T> Context.intent() = Intent().setComponent(T::class.java.cmp(packageName))

// Keep a reference to these resources to prevent it from
// being removed when running "remove unused resources"
val shouldKeepResources = listOf(
    R.string.no_info_provided,
    R.string.release_notes,
    R.string.invalid_update_channel,
    R.string.update_available,
    R.string.app_changelog,
    R.string.home_item_source,
    R.drawable.ic_more,
    R.array.allow_timeout,
)

```

`app/core/src/main/java/com/topjohnwu/magisk/core/Info.kt`:

```kt
package com.topjohnwu.magisk.core

import android.app.KeyguardManager
import android.os.Build
import androidx.lifecycle.MutableLiveData
import com.topjohnwu.magisk.StubApk
import com.topjohnwu.magisk.core.ktx.getProperty
import com.topjohnwu.magisk.core.model.UpdateInfo
import com.topjohnwu.magisk.core.repository.NetworkService
import com.topjohnwu.superuser.CallbackList
import com.topjohnwu.superuser.Shell
import com.topjohnwu.superuser.ShellUtils.fastCmd
import com.topjohnwu.superuser.ShellUtils.fastCmdResult
import kotlinx.coroutines.Runnable

val isRunningAsStub get() = Info.stub != null

object Info {

    var stub: StubApk.Data? = null

    private val EMPTY_UPDATE = UpdateInfo()
    var update = EMPTY_UPDATE
        private set

    suspend fun fetchUpdate(svc: NetworkService): UpdateInfo? {
        return if (update === EMPTY_UPDATE) {
            svc.fetchUpdate()?.apply { update = this }
        } else update
    }

    fun resetUpdate() {
        update = EMPTY_UPDATE
    }

    var isRooted = false
    var noDataExec = false
    var patchBootVbmeta = false

    @JvmStatic var env = Env()
        private set
    @JvmStatic var isSAR = false
        private set
    var legacySAR = false
        private set
    var isAB = false
        private set
    var slot = ""
        private set
    var isVendorBoot = false
        private set
    @JvmField val isZygiskEnabled = System.getenv("ZYGISK_ENABLED") == "1"
    @JvmStatic val isFDE get() = crypto == "block"
    @JvmStatic var ramdisk = false
        private set
    private var crypto = ""

    val isEmulator =
        Build.DEVICE.contains("vsoc")
            || getProperty("ro.kernel.qemu", "0") == "1"
            || getProperty("ro.boot.qemu", "0") == "1"

    val isConnected = MutableLiveData(false)

    val showSuperUser: Boolean get() {
        return env.isActive && (Const.USER_ID == 0
                || Config.suMultiuserMode == Config.Value.MULTIUSER_MODE_USER)
    }

    val isDeviceSecure get() =
        AppContext.getSystemService(KeyguardManager::class.java).isDeviceSecure

    class Env(
        val versionString: String = "",
        val isDebug: Boolean = false,
        code: Int = -1
    ) {
        val versionCode = when {
            code < Const.Version.MIN_VERCODE -> -1
            isRooted -> code
            else -> -1
        }
        val isUnsupported = code > 0 && code < Const.Version.MIN_VERCODE
        val isActive = versionCode > 0
    }

    fun init(shell: Shell) {
        if (shell.isRoot) {
            val v = fastCmd(shell, "magisk -v").split(":")
            env = Env(
                v[0], v.size >= 3 && v[2] == "D",
                runCatching { fastCmd("magisk -V").toInt() }.getOrDefault(-1)
            )
            Config.denyList = fastCmdResult(shell, "magisk --denylist status")
        }

        val map = mutableMapOf<String, String>()
        val list = object : CallbackList<String>(Runnable::run) {
            override fun onAddElement(e: String) {
                val split = e.split("=")
                if (split.size >= 2) {
                    map[split[0]] = split[1]
                }
            }
        }
        shell.newJob().add("(app_init)").to(list).exec()

        fun getVar(name: String) = map[name] ?: ""
        fun getBool(name: String) = map[name].toBoolean()

        isSAR = getBool("SYSTEM_AS_ROOT")
        ramdisk = getBool("RAMDISKEXIST")
        isAB = getBool("ISAB")
        patchBootVbmeta = getBool("PATCHVBMETAFLAG")
        crypto = getVar("CRYPTOTYPE")
        slot = getVar("SLOT")
        legacySAR = getBool("LEGACYSAR")
        isVendorBoot = getBool("VENDORBOOT")

        // Default presets
        Config.recovery = getBool("RECOVERYMODE")
        Config.keepVerity = getBool("KEEPVERITY")
        Config.keepEnc = getBool("KEEPFORCEENCRYPT")
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/JobService.kt`:

```kt
package com.topjohnwu.magisk.core

import android.annotation.SuppressLint
import android.annotation.TargetApi
import android.app.Notification
import android.app.job.JobInfo
import android.app.job.JobParameters
import android.app.job.JobScheduler
import android.content.Context
import androidx.core.content.getSystemService
import com.topjohnwu.magisk.core.base.BaseJobService
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.core.download.DownloadEngine
import com.topjohnwu.magisk.core.download.DownloadSession
import com.topjohnwu.magisk.core.download.Subject
import com.topjohnwu.magisk.view.Notifications
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch
import java.util.concurrent.TimeUnit

class JobService : BaseJobService() {

    private var mSession: Session? = null

    @TargetApi(value = 34)
    inner class Session(
        private var params: JobParameters
    ) : DownloadSession {

        override val context get() = this@JobService
        val engine = DownloadEngine(this)

        fun updateParams(params: JobParameters) {
            this.params = params
            engine.reattach()
        }

        override fun attachNotification(id: Int, builder: Notification.Builder) {
            setNotification(params, id, builder.build(), JOB_END_NOTIFICATION_POLICY_REMOVE)
        }

        override fun onDownloadComplete() {
            jobFinished(params, false)
        }
    }

    @SuppressLint("NewApi")
    override fun onStartJob(params: JobParameters): Boolean {
        return when (params.jobId) {
            Const.ID.CHECK_UPDATE_JOB_ID -> checkUpdate(params)
            Const.ID.DOWNLOAD_JOB_ID -> downloadFile(params)
            else -> false
        }
    }

    override fun onStopJob(params: JobParameters?) = false

    @TargetApi(value = 34)
    private fun downloadFile(params: JobParameters): Boolean {
        params.transientExtras.classLoader = Subject::class.java.classLoader
        val subject = params.transientExtras
            .getParcelable(DownloadEngine.SUBJECT_KEY, Subject::class.java) ?:
            return false

        val session = mSession?.also {
            it.updateParams(params)
        } ?: run {
            Session(params).also { mSession = it }
        }

        session.engine.download(subject)
        return true
    }

    private fun checkUpdate(params: JobParameters): Boolean {
        GlobalScope.launch(Dispatchers.IO) {
            Info.fetchUpdate(ServiceLocator.networkService)?.let {
                if (Info.env.isActive && BuildConfig.APP_VERSION_CODE < it.versionCode)
                    Notifications.updateAvailable()
                jobFinished(params, false)
            }
        }
        return true
    }

    companion object {
        fun schedule(context: Context) {
            val scheduler = context.getSystemService<JobScheduler>() ?: return
            if (Config.checkUpdate) {
                val cmp = JobService::class.java.cmp(context.packageName)
                val info = JobInfo.Builder(Const.ID.CHECK_UPDATE_JOB_ID, cmp)
                    .setPeriodic(TimeUnit.HOURS.toMillis(12))
                    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)
                    .setRequiresDeviceIdle(true)
                    .build()
                scheduler.schedule(info)
            } else {
                scheduler.cancel(Const.ID.CHECK_UPDATE_JOB_ID)
            }
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/Provider.kt`:

```kt
package com.topjohnwu.magisk.core

import android.os.Bundle
import com.topjohnwu.magisk.core.base.BaseProvider
import com.topjohnwu.magisk.core.su.SuCallbackHandler

class Provider : BaseProvider() {

    override fun call(method: String, arg: String?, extras: Bundle?): Bundle? {
        return when (method) {
            SuCallbackHandler.LOG, SuCallbackHandler.NOTIFY -> {
                SuCallbackHandler.run(context!!, method, extras)
                Bundle.EMPTY
            }
            else -> Bundle.EMPTY
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/Receiver.kt`:

```kt
package com.topjohnwu.magisk.core

import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import androidx.core.content.IntentCompat
import com.topjohnwu.magisk.core.base.BaseReceiver
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.core.download.DownloadEngine
import com.topjohnwu.magisk.core.download.Subject
import com.topjohnwu.magisk.view.Notifications
import com.topjohnwu.magisk.view.Shortcuts
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch

open class Receiver : BaseReceiver() {

    private val policyDB get() = ServiceLocator.policyDB

    @SuppressLint("InlinedApi")
    private fun getPkg(intent: Intent): String? {
        val pkg = intent.getStringExtra(Intent.EXTRA_PACKAGE_NAME)
        return pkg ?: intent.data?.schemeSpecificPart
    }

    private fun getUid(intent: Intent): Int? {
        val uid = intent.getIntExtra(Intent.EXTRA_UID, -1)
        return if (uid == -1) null else uid
    }

    override fun onReceive(context: Context, intent: Intent?) {
        intent ?: return
        super.onReceive(context, intent)

        fun rmPolicy(uid: Int) = GlobalScope.launch {
            policyDB.delete(uid)
        }

        when (intent.action ?: return) {
            DownloadEngine.ACTION -> {
                IntentCompat.getParcelableExtra(
                    intent, DownloadEngine.SUBJECT_KEY, Subject::class.java)?.let {
                        DownloadEngine.start(context, it)
                    }
            }
            Intent.ACTION_PACKAGE_REPLACED -> {
                // This will only work pre-O
                if (Config.suReAuth)
                    getUid(intent)?.let { rmPolicy(it) }
            }
            Intent.ACTION_UID_REMOVED -> {
                getUid(intent)?.let { rmPolicy(it) }
            }
            Intent.ACTION_PACKAGE_FULLY_REMOVED -> {
                getPkg(intent)?.let { Shell.cmd("magisk --denylist rm $it").submit() }
            }
            Intent.ACTION_LOCALE_CHANGED -> Shortcuts.setupDynamic(context)
            Intent.ACTION_MY_PACKAGE_REPLACED -> {
                @Suppress("DEPRECATION")
                val installer = context.packageManager.getInstallerPackageName(context.packageName)
                if (installer == context.packageName) {
                    Notifications.updateDone()
                }
            }
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/Service.kt`:

```kt
package com.topjohnwu.magisk.core

import android.app.Notification
import android.content.Intent
import android.os.Build
import androidx.core.app.ServiceCompat
import androidx.core.content.IntentCompat
import com.topjohnwu.magisk.core.base.BaseService
import com.topjohnwu.magisk.core.download.DownloadEngine
import com.topjohnwu.magisk.core.download.DownloadSession
import com.topjohnwu.magisk.core.download.Subject

class Service : BaseService(), DownloadSession {

    private var mEngine: DownloadEngine? = null
    override val context get() = this

    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
        if (intent.action == DownloadEngine.ACTION) {
            IntentCompat
                .getParcelableExtra(intent, DownloadEngine.SUBJECT_KEY, Subject::class.java)
                ?.let { subject ->
                    val engine = mEngine ?: DownloadEngine(this).also { mEngine = it }
                    engine.download(subject)
                }
        }
        return START_NOT_STICKY
    }

    override fun attachNotification(id: Int, builder: Notification.Builder) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S)
            builder.setForegroundServiceBehavior(Notification.FOREGROUND_SERVICE_IMMEDIATE)
        startForeground(id, builder.build())
    }

    override fun onDownloadComplete() {
        ServiceCompat.stopForeground(this, ServiceCompat.STOP_FOREGROUND_REMOVE)
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/base/BaseActivity.kt`:

```kt
package com.topjohnwu.magisk.core.base

import android.Manifest.permission.POST_NOTIFICATIONS
import android.Manifest.permission.REQUEST_INSTALL_PACKAGES
import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
import android.app.Activity
import android.content.ActivityNotFoundException
import android.content.Intent
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Parcelable
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.result.ActivityResultCallback
import androidx.activity.result.contract.ActivityResultContracts.GetContent
import androidx.activity.result.contract.ActivityResultContracts.RequestPermission
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.ktx.reflectField
import com.topjohnwu.magisk.core.ktx.toast
import com.topjohnwu.magisk.core.utils.RequestAuthentication
import com.topjohnwu.magisk.core.utils.RequestInstall

interface ContentResultCallback: ActivityResultCallback<Uri>, Parcelable {
    fun onActivityLaunch() {}
    // Make the result type explicitly non-null
    override fun onActivityResult(result: Uri)
}

interface UntrackedActivity

interface IActivityExtension {
    val extension: ActivityExtension
    fun withPermission(permission: String, callback: (Boolean) -> Unit) {
        extension.withPermission(permission, callback)
    }
    fun withAuthentication(callback: (Boolean) -> Unit) {
        extension.withAuthentication(callback)
    }
    fun getContent(type: String, callback: ContentResultCallback) {
        extension.getContent(type, callback)
    }
}

class ActivityExtension(private val activity: ComponentActivity) {

    private var permissionCallback: ((Boolean) -> Unit)? = null
    private val requestPermission = activity.registerForActivityResult(RequestPermission()) {
        permissionCallback?.invoke(it)
        permissionCallback = null
    }

    private var installCallback: ((Boolean) -> Unit)? = null
    private val requestInstall = activity.registerForActivityResult(RequestInstall()) {
        installCallback?.invoke(it)
        installCallback = null
    }

    private var authenticateCallback: ((Boolean) -> Unit)? = null
    private val requestAuthenticate = activity.registerForActivityResult(RequestAuthentication()) {
        authenticateCallback?.invoke(it)
        authenticateCallback = null
    }

    private var contentCallback: ContentResultCallback? = null
    private val getContent = activity.registerForActivityResult(GetContent()) {
        if (it != null) contentCallback?.onActivityResult(it)
        contentCallback = null
    }

    fun onCreate(savedInstanceState: Bundle?) {
        contentCallback = if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {
            savedInstanceState?.getParcelable(CONTENT_CALLBACK_KEY)
        } else {
            savedInstanceState
                ?.getParcelable(CONTENT_CALLBACK_KEY, ContentResultCallback::class.java)
        }
    }

    fun onSaveInstanceState(outState: Bundle) {
        contentCallback?.let {
            outState.putParcelable(CONTENT_CALLBACK_KEY, it)
        }
    }

    fun withPermission(permission: String, callback: (Boolean) -> Unit) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R &&
            permission == WRITE_EXTERNAL_STORAGE) {
            // We do not need external rw on R+
            callback(true)
            return
        }
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU &&
            permission == POST_NOTIFICATIONS) {
            // All apps have notification permissions before T
            callback(true)
            return
        }
        if (permission == REQUEST_INSTALL_PACKAGES) {
            installCallback = callback
            requestInstall.launch(Unit)
        } else {
            permissionCallback = callback
            requestPermission.launch(permission)
        }
    }

    fun withAuthentication(callback: (Boolean) -> Unit) {
        authenticateCallback = callback
        requestAuthenticate.launch(Unit)
    }

    fun getContent(type: String, callback: ContentResultCallback) {
        contentCallback = callback
        try {
            getContent.launch(type)
            callback.onActivityLaunch()
        } catch (e: ActivityNotFoundException) {
            activity.toast(R.string.app_not_found, Toast.LENGTH_SHORT)
        }
    }

    companion object {
        private const val CONTENT_CALLBACK_KEY = "content_callback"
    }
}

val Activity.launchPackage: String? get() {
    return if (Build.VERSION.SDK_INT >= 34) {
        launchedFromPackage
    } else {
        Activity::class.java.reflectField("mReferrer").get(this) as String?
    }
}

fun Activity.relaunch() {
    startActivity(Intent(intent).setFlags(0))
    finish()
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/base/BaseJobService.kt`:

```kt
package com.topjohnwu.magisk.core.base

import android.app.job.JobService
import android.content.Context
import com.topjohnwu.magisk.core.patch

abstract class BaseJobService : JobService() {
    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base.patch())
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/base/BaseProvider.kt`:

```kt
package com.topjohnwu.magisk.core.base

import android.content.ContentProvider
import android.content.ContentValues
import android.content.Context
import android.content.pm.ProviderInfo
import android.database.Cursor
import android.net.Uri
import com.topjohnwu.magisk.core.patch

open class BaseProvider : ContentProvider() {
    override fun attachInfo(context: Context, info: ProviderInfo) {
        super.attachInfo(context.patch(), info)
    }
    override fun onCreate() = true
    override fun getType(uri: Uri): String? = null
    override fun insert(uri: Uri, values: ContentValues?): Uri? = null
    override fun delete(uri: Uri, selection: String?, selectionArgs: Array<out String>?) = 0
    override fun update(uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array<out String>?) = 0
    override fun query(uri: Uri, projection: Array<out String>?, selection: String?, selectionArgs: Array<out String>?, sortOrder: String?): Cursor? = null
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/base/BaseReceiver.kt`:

```kt
package com.topjohnwu.magisk.core.base

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import androidx.annotation.CallSuper
import com.topjohnwu.magisk.core.patch

abstract class BaseReceiver : BroadcastReceiver() {
    @CallSuper
    override fun onReceive(context: Context, intent: Intent?) {
        context.patch()
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/base/BaseService.kt`:

```kt
package com.topjohnwu.magisk.core.base

import android.app.Service
import android.content.Context
import android.content.Intent
import android.os.IBinder
import com.topjohnwu.magisk.core.patch

open class BaseService : Service() {
    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base.patch())
    }
    override fun onBind(intent: Intent?): IBinder? = null
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/base/SplashScreen.kt`:

```kt
package com.topjohnwu.magisk.core.base

import android.Manifest.permission.REQUEST_INSTALL_PACKAGES
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import com.topjohnwu.magisk.StubApk
import com.topjohnwu.magisk.core.BuildConfig
import com.topjohnwu.magisk.core.BuildConfig.APP_PACKAGE_NAME
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.JobService
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.core.isRunningAsStub
import com.topjohnwu.magisk.core.ktx.writeTo
import com.topjohnwu.magisk.core.tasks.AppMigration
import com.topjohnwu.magisk.core.utils.RootUtils
import com.topjohnwu.magisk.view.Notifications
import com.topjohnwu.magisk.view.Shortcuts
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.launch
import timber.log.Timber
import java.io.File
import java.io.IOException

interface SplashScreenHost : IActivityExtension {
    val splashController: SplashController<*>

    fun onCreateUi(savedInstanceState: Bundle?)
    fun showInvalidStateMessage()
}

class SplashController<T>(private val activity: T)
    where T : ComponentActivity, T: SplashScreenHost {

    companion object {
        private var splashShown = false
    }

    private var shouldCreateUiOnResume = false

    fun preOnCreate() {
        if (isRunningAsStub && !splashShown) {
            // Manually apply splash theme for stub
            activity.theme.applyStyle(R.style.StubSplashTheme, true)
        }
    }

    fun onCreate(savedInstanceState: Bundle?) {
        if (!isRunningAsStub) {
            val splashScreen = activity.installSplashScreen()
            splashScreen.setKeepOnScreenCondition { !splashShown }
        }

        if (splashShown) {
            doCreateUi(savedInstanceState)
        } else {
            Shell.getShell(Shell.EXECUTOR) {
                if (isRunningAsStub && !it.isRoot) {
                    activity.showInvalidStateMessage()
                    return@getShell
                }
                activity.initializeApp()
                activity.runOnUiThread {
                    splashShown = true
                    if (isRunningAsStub) {
                        // Re-launch main activity without splash theme
                        activity.relaunch()
                    } else {
                        if (activity.lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) {
                            doCreateUi(savedInstanceState)
                        } else {
                            shouldCreateUiOnResume = true
                        }
                    }
                }
            }
        }
    }

    fun onResume() {
        if (shouldCreateUiOnResume) {
            doCreateUi(null)
        }
    }

    private fun doCreateUi(savedInstanceState: Bundle?) {
        shouldCreateUiOnResume = false
        activity.onCreateUi(savedInstanceState)
    }

    private fun T.initializeApp() {
        val prevPkg = launchPackage
        val prevConfig = intent.getBundleExtra(Const.Key.PREV_CONFIG)
        val isPackageMigration = prevPkg != null && prevConfig != null

        Config.init(prevConfig)

        if (packageName != APP_PACKAGE_NAME) {
            runCatching {
                // Hidden, remove com.topjohnwu.magisk if exist as it could be malware
                packageManager.getApplicationInfo(APP_PACKAGE_NAME, 0)
                Shell.cmd("(pm uninstall $APP_PACKAGE_NAME)& >/dev/null 2>&1").exec()
            }
        } else {
            if (Config.suManager.isNotEmpty()) {
                Config.suManager = ""
            }
            if (isPackageMigration) {
                Shell.cmd("(pm uninstall $prevPkg)& >/dev/null 2>&1").exec()
            }
        }

        if (isPackageMigration) {
            runOnUiThread {
                // Relaunch the process after package migration
                StubApk.restartProcess(this)
            }
            return
        }

        // Validate stub APK
        if (isRunningAsStub && (
                // Version mismatch
                Info.stub!!.version != BuildConfig.STUB_VERSION ||
                // Not properly patched
                intent.component!!.className.contains(AppMigration.PLACEHOLDER))
        ) {
            withPermission(REQUEST_INSTALL_PACKAGES) { granted ->
                if (granted) {
                    lifecycleScope.launch {
                        val apk = File(cacheDir, "stub.apk")
                        try {
                            assets.open("stub.apk").writeTo(apk)
                            AppMigration.upgradeStub(activity, apk)?.let {
                                startActivity(it)
                            }
                        } catch (e: IOException) {
                            Timber.e(e)
                        }
                    }
                }
            }
            return
        }

        Notifications.setup()
        JobService.schedule(this)
        Shortcuts.setupDynamic(this)

        // Pre-fetch network services
        ServiceLocator.networkService

        // Wait for root service
        RootUtils.Connection.await()
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/data/RetrofitInterfaces.kt`:

```kt
package com.topjohnwu.magisk.core.data

import com.topjohnwu.magisk.core.model.ModuleJson
import com.topjohnwu.magisk.core.model.Release
import com.topjohnwu.magisk.core.model.UpdateJson
import okhttp3.ResponseBody
import retrofit2.Response
import retrofit2.http.GET
import retrofit2.http.Headers
import retrofit2.http.Path
import retrofit2.http.Query
import retrofit2.http.Streaming
import retrofit2.http.Url

interface RawUrl {

    @GET
    @Streaming
    suspend fun fetchFile(@Url url: String): ResponseBody

    @GET
    suspend fun fetchString(@Url url: String): String

    @GET
    suspend fun fetchModuleJson(@Url url: String): ModuleJson

    @GET
    suspend fun fetchUpdateJson(@Url url: String): UpdateJson
}

interface GithubApiServices {

    @GET("/repos/{owner}/{repo}/releases")
    @Headers("Accept: application/vnd.github+json")
    suspend fun fetchReleases(
        @Path("owner") owner: String = "topjohnwu",
        @Path("repo") repo: String = "Magisk",
        @Query("per_page") per: Int = 10,
        @Query("page") page: Int = 1,
    ): Response<MutableList<Release>>

    @GET("/repos/{owner}/{repo}/releases/latest")
    @Headers("Accept: application/vnd.github+json")
    suspend fun fetchLatestRelease(
        @Path("owner") owner: String = "topjohnwu",
        @Path("repo") repo: String = "Magisk",
    ): Release
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/data/SuLogDao.kt`:

```kt
package com.topjohnwu.magisk.core.data

import androidx.room.Dao
import androidx.room.Database
import androidx.room.Insert
import androidx.room.Query
import androidx.room.RoomDatabase
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import com.topjohnwu.magisk.core.model.su.SuLog
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.util.Calendar

@Database(version = 2, entities = [SuLog::class], exportSchema = false)
abstract class SuLogDatabase : RoomDatabase() {

    abstract fun suLogDao(): SuLogDao

    companion object {
        val MIGRATION_1_2 = object : Migration(1, 2) {
            override fun migrate(db: SupportSQLiteDatabase) = with(db) {
                execSQL("ALTER TABLE logs ADD COLUMN target INTEGER NOT NULL DEFAULT -1")
                execSQL("ALTER TABLE logs ADD COLUMN context TEXT NOT NULL DEFAULT ''")
                execSQL("ALTER TABLE logs ADD COLUMN gids TEXT NOT NULL DEFAULT ''")
            }
        }
    }
}

@Dao
abstract class SuLogDao(private val db: SuLogDatabase) {

    private val twoWeeksAgo =
        Calendar.getInstance().apply { add(Calendar.WEEK_OF_YEAR, -2) }.timeInMillis

    suspend fun deleteAll() = withContext(Dispatchers.IO) { db.clearAllTables() }

    suspend fun fetchAll(): MutableList<SuLog> {
        deleteOutdated()
        return fetch()
    }

    @Query("SELECT * FROM logs ORDER BY time DESC")
    protected abstract suspend fun fetch(): MutableList<SuLog>

    @Query("DELETE FROM logs WHERE time < :timeout")
    protected abstract suspend fun deleteOutdated(timeout: Long = twoWeeksAgo)

    @Insert
    abstract suspend fun insert(log: SuLog)

}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/data/magiskdb/MagiskDB.kt`:

```kt
package com.topjohnwu.magisk.core.data.magiskdb

import com.topjohnwu.magisk.core.ktx.await
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

open class MagiskDB {

    class Literal(
        val str: String
    )

    suspend inline fun <R> exec(
        query: String,
        crossinline mapper: (Map<String, String>) -> R
    ): List<R> {
        return withContext(Dispatchers.IO) {
            val out = Shell.cmd("magisk --sqlite '$query'").await().out
            out.map { line ->
                line.split("\\|".toRegex())
                    .map { it.split("=", limit = 2) }
                    .filter { it.size == 2 }
                    .associate { it[0] to it[1] }
                    .let(mapper)
            }
        }
    }

    suspend fun exec(query: String) {
        withContext(Dispatchers.IO) {
            Shell.cmd("magisk --sqlite '$query'").await()
        }
    }

    fun Map<String, Any>.toQuery(): String {
        val keys = this.keys.joinToString(",")
        val values = this.values.joinToString(",") {
            when (it) {
                is Boolean -> if (it) "1" else "0"
                is Number -> it.toString()
                is Literal -> it.str
                else -> "\"$it\""
            }
        }
        return "($keys) VALUES($values)"
    }

    object Table {
        const val POLICY = "policies"
        const val SETTINGS = "settings"
        const val STRINGS = "strings"
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/data/magiskdb/PolicyDao.kt`:

```kt
package com.topjohnwu.magisk.core.data.magiskdb

import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.model.su.SuPolicy

private const val SELECT_QUERY = "SELECT (until - strftime(\"%s\", \"now\")) AS remain, *"

class PolicyDao : MagiskDB() {

    suspend fun deleteOutdated() {
        val query = "DELETE FROM ${Table.POLICY} WHERE " +
            "(until > 0 AND until < strftime(\"%s\", \"now\")) OR until < 0"
        exec(query)
    }

    suspend fun delete(uid: Int) {
        val query = "DELETE FROM ${Table.POLICY} WHERE uid=$uid"
        exec(query)
    }

    suspend fun fetch(uid: Int): SuPolicy? {
        val query = "$SELECT_QUERY FROM ${Table.POLICY} WHERE uid=$uid LIMIT 1"
        return exec(query, ::toPolicy).firstOrNull()
    }

    suspend fun update(policy: SuPolicy) {
        val map = policy.toMap()
        if (!Const.Version.atLeast_25_0()) {
            // Put in package_name for old database
            map["package_name"] = AppContext.packageManager.getNameForUid(policy.uid)!!
        }
        val query = "REPLACE INTO ${Table.POLICY} ${map.toQuery()}"
        exec(query)
    }

    suspend fun fetchAll(): List<SuPolicy> {
        val query = "$SELECT_QUERY FROM ${Table.POLICY} WHERE uid/100000=${Const.USER_ID}"
        return exec(query, ::toPolicy).filterNotNull()
    }

    private fun toPolicy(map: Map<String, String>): SuPolicy? {
        val uid = map["uid"]?.toInt() ?: return null
        val policy = SuPolicy(uid)

        map["until"]?.toLong()?.let { until ->
            if (until <= 0) {
                policy.remain = until
            } else {
                map["remain"]?.toLong()?.let { policy.remain = it }
            }
        }

        map["policy"]?.toInt()?.let { policy.policy = it }
        map["logging"]?.toInt()?.let { policy.logging = it != 0 }
        map["notification"]?.toInt()?.let { policy.notification = it != 0 }
        return policy
    }

}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/data/magiskdb/SettingsDao.kt`:

```kt
package com.topjohnwu.magisk.core.data.magiskdb

class SettingsDao : MagiskDB() {

    suspend fun delete(key: String) {
        val query = "DELETE FROM ${Table.SETTINGS} WHERE key=\"$key\""
        exec(query)
    }

    suspend fun put(key: String, value: Int) {
        val kv = mapOf("key" to key, "value" to value)
        val query = "REPLACE INTO ${Table.SETTINGS} ${kv.toQuery()}"
        exec(query)
    }

    suspend fun fetch(key: String, default: Int = -1): Int {
        val query = "SELECT value FROM ${Table.SETTINGS} WHERE key=\"$key\" LIMIT 1"
        return exec(query) { it["value"]?.toInt() }.firstOrNull() ?: default
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/data/magiskdb/StringDao.kt`:

```kt
package com.topjohnwu.magisk.core.data.magiskdb

class StringDao : MagiskDB() {

    suspend fun delete(key: String) {
        val query = "DELETE FROM ${Table.STRINGS} WHERE key=\"$key\""
        exec(query)
    }

    suspend fun put(key: String, value: String) {
        val kv = mapOf("key" to key, "value" to value)
        val query = "REPLACE INTO ${Table.STRINGS} ${kv.toQuery()}"
        exec(query)
    }

    suspend fun fetch(key: String, default: String = ""): String {
        val query = "SELECT value FROM ${Table.STRINGS} WHERE key=\"$key\" LIMIT 1"
        return exec(query) { it["value"] }.firstOrNull() ?: default
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/di/Networking.kt`:

```kt
package com.topjohnwu.magisk.core.di

import android.content.Context
import com.squareup.moshi.Moshi
import com.topjohnwu.magisk.ProviderInstaller
import com.topjohnwu.magisk.core.BuildConfig
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.model.DateTimeAdapter
import com.topjohnwu.magisk.core.utils.LocaleSetting
import okhttp3.Cache
import okhttp3.ConnectionSpec
import okhttp3.Dns
import okhttp3.HttpUrl.Companion.toHttpUrl
import okhttp3.OkHttpClient
import okhttp3.dnsoverhttps.DnsOverHttps
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.moshi.MoshiConverterFactory
import retrofit2.converter.scalars.ScalarsConverterFactory
import java.io.File
import java.net.InetAddress
import java.net.UnknownHostException

private class DnsResolver(client: OkHttpClient) : Dns {

    private val doh by lazy {
        DnsOverHttps.Builder().client(client)
            .url("https://cloudflare-dns.com/dns-query".toHttpUrl())
            .bootstrapDnsHosts(listOf(
                InetAddress.getByName("162.159.36.1"),
                InetAddress.getByName("162.159.46.1"),
                InetAddress.getByName("1.1.1.1"),
                InetAddress.getByName("1.0.0.1"),
                InetAddress.getByName("2606:4700:4700::1111"),
                InetAddress.getByName("2606:4700:4700::1001"),
                InetAddress.getByName("2606:4700:4700::0064"),
                InetAddress.getByName("2606:4700:4700::6400")
            ))
            .resolvePrivateAddresses(true)  /* To make PublicSuffixDatabase never used */
            .build()
    }

    override fun lookup(hostname: String): List<InetAddress> {
        if (Config.doh) {
            try {
                return doh.lookup(hostname)
            } catch (e: UnknownHostException) {}
        }
        return Dns.SYSTEM.lookup(hostname)
    }
}


fun createOkHttpClient(context: Context): OkHttpClient {
    val appCache = Cache(File(context.cacheDir, "okhttp"), 10 * 1024 * 1024)
    val builder = OkHttpClient.Builder().cache(appCache)

    if (BuildConfig.DEBUG) {
        builder.addInterceptor(HttpLoggingInterceptor().apply {
            level = HttpLoggingInterceptor.Level.BASIC
        })
    } else {
        builder.connectionSpecs(listOf(ConnectionSpec.MODERN_TLS))
    }

    builder.dns(DnsResolver(builder.build()))

    builder.addInterceptor { chain ->
        val request = chain.request().newBuilder()
        request.header("User-Agent", "Magisk/${BuildConfig.APP_VERSION_CODE}")
        request.header("Accept-Language", LocaleSetting.instance.currentLocale.toLanguageTag())
        chain.proceed(request.build())
    }

    ProviderInstaller.install(context)

    return builder.build()
}

fun createMoshiConverterFactory(): MoshiConverterFactory {
    val moshi = Moshi.Builder().add(DateTimeAdapter()).build()
    return MoshiConverterFactory.create(moshi)
}

fun createRetrofit(okHttpClient: OkHttpClient): Retrofit.Builder {
    return Retrofit.Builder()
        .addConverterFactory(ScalarsConverterFactory.create())
        .addConverterFactory(createMoshiConverterFactory())
        .client(okHttpClient)
}

inline fun <reified T> createApiService(retrofitBuilder: Retrofit.Builder, baseUrl: String): T {
    return retrofitBuilder
        .baseUrl(baseUrl)
        .build()
        .create(T::class.java)
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/di/ServiceLocator.kt`:

```kt
package com.topjohnwu.magisk.core.di

import android.annotation.SuppressLint
import android.content.Context
import android.text.method.LinkMovementMethod
import androidx.room.Room
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.data.SuLogDatabase
import com.topjohnwu.magisk.core.data.magiskdb.PolicyDao
import com.topjohnwu.magisk.core.data.magiskdb.SettingsDao
import com.topjohnwu.magisk.core.data.magiskdb.StringDao
import com.topjohnwu.magisk.core.ktx.deviceProtectedContext
import com.topjohnwu.magisk.core.repository.LogRepository
import com.topjohnwu.magisk.core.repository.NetworkService
import io.noties.markwon.Markwon
import io.noties.markwon.utils.NoCopySpannableFactory

@SuppressLint("StaticFieldLeak")
object ServiceLocator {

    val deContext by lazy { AppContext.deviceProtectedContext }
    val timeoutPrefs by lazy { deContext.getSharedPreferences("su_timeout", 0) }

    // Database
    val policyDB = PolicyDao()
    val settingsDB = SettingsDao()
    val stringDB = StringDao()
    val sulogDB by lazy { createSuLogDatabase(deContext).suLogDao() }
    val logRepo by lazy { LogRepository(sulogDB) }

    // Networking
    val okhttp by lazy { createOkHttpClient(AppContext) }
    val retrofit by lazy { createRetrofit(okhttp) }
    val markwon by lazy { createMarkwon(AppContext) }
    val networkService by lazy {
        NetworkService(
            createApiService(retrofit, Const.Url.INVALID_URL),
            createApiService(retrofit, Const.Url.GITHUB_API_URL),
        )
    }
}

private fun createSuLogDatabase(context: Context) =
    Room.databaseBuilder(context, SuLogDatabase::class.java, "sulogs.db")
        .addMigrations(SuLogDatabase.MIGRATION_1_2)
        .fallbackToDestructiveMigration(true)
        .build()

private fun createMarkwon(context: Context) =
    Markwon.builder(context).textSetter { textView, spanned, bufferType, onComplete ->
        textView.apply {
            movementMethod = LinkMovementMethod.getInstance()
            setSpannableFactory(NoCopySpannableFactory.getInstance())
            setText(spanned, bufferType)
            onComplete.run()
        }
    }.build()

```

`app/core/src/main/java/com/topjohnwu/magisk/core/download/DownloadEngine.kt`:

```kt
package com.topjohnwu.magisk.core.download

import android.Manifest
import android.annotation.SuppressLint
import android.app.Notification
import android.app.PendingIntent
import android.app.job.JobInfo
import android.app.job.JobScheduler
import android.content.Context
import android.os.Build
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.collection.SparseArrayCompat
import androidx.collection.isNotEmpty
import androidx.core.content.getSystemService
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.MutableLiveData
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.JobService
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.base.IActivityExtension
import com.topjohnwu.magisk.core.cmp
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.core.intent
import com.topjohnwu.magisk.core.ktx.set
import com.topjohnwu.magisk.core.utils.ProgressInputStream
import com.topjohnwu.magisk.view.Notifications
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import okhttp3.ResponseBody
import timber.log.Timber
import java.io.InputStream

/**
 * This class drives the execution of file downloads and notification management.
 *
 * Each download engine instance has to be paired with a "session" that is managed by the operating
 * system. A session is an Android component that allows executing long lasting operations and
 * have its state tied to a notification to show progress.
 *
 * A session can only have one single notification representing its state, and the operating system
 * also uses the notification to manage the lifecycle of a session. One goal of this class is
 * to support concurrent download tasks using only one single session, so internally it manages
 * all active tasks and notifications and properly re-assign notifications to be attached to
 * the session to make sure all download operations can be completed without the operating system
 * killing the session.
 *
 * For API 23 - 33, we use a foreground service as a session.
 * For API 34 and higher, we use user-initiated job services as a session.
 */
class DownloadEngine(session: DownloadSession) : DownloadSession by session, DownloadNotifier {

    companion object {
        const val ACTION = "com.topjohnwu.magisk.DOWNLOAD"
        const val SUBJECT_KEY = "subject"
        private const val REQUEST_CODE = 1

        private val progressBroadcast = MutableLiveData<Pair<Float, Subject>?>()

        private fun broadcast(progress: Float, subject: Subject) {
            progressBroadcast.postValue(progress to subject)
        }

        fun observeProgress(owner: LifecycleOwner, callback: (Float, Subject) -> Unit) {
            progressBroadcast.value = null
            progressBroadcast.observe(owner) {
                val (progress, subject) = it ?: return@observe
                callback(progress, subject)
            }
        }

        private fun createBroadcastIntent(context: Context, subject: Subject) =
            context.intent<com.topjohnwu.magisk.core.Receiver>()
                .setAction(ACTION)
                .putExtra(SUBJECT_KEY, subject)

        private fun createServiceIntent(context: Context, subject: Subject) =
            context.intent<com.topjohnwu.magisk.core.Service>()
                .setAction(ACTION)
                .putExtra(SUBJECT_KEY, subject)

        @SuppressLint("InlinedApi")
        fun getPendingIntent(context: Context, subject: Subject): PendingIntent {
            val flag = PendingIntent.FLAG_IMMUTABLE or
                PendingIntent.FLAG_UPDATE_CURRENT or
                PendingIntent.FLAG_ONE_SHOT
            return if (Build.VERSION.SDK_INT >= 34) {
                // On API 34+, download tasks are handled with a user-initiated job.
                // However, there is no way to schedule a new job directly with a pending intent.
                // As a workaround, we send the subject to a broadcast receiver and have it
                // schedule the job for us.
                val intent = createBroadcastIntent(context, subject)
                PendingIntent.getBroadcast(context, REQUEST_CODE, intent, flag)
            } else {
                val intent = createServiceIntent(context, subject)
                if (Build.VERSION.SDK_INT >= 26) {
                    PendingIntent.getForegroundService(context, REQUEST_CODE, intent, flag)
                } else {
                    PendingIntent.getService(context, REQUEST_CODE, intent, flag)
                }
            }
        }

        @SuppressLint("InlinedApi")
        fun <T> startWithActivity(
            activity: T,
            subject: Subject
        ) where T : ComponentActivity, T : IActivityExtension {
            activity.withPermission(Manifest.permission.POST_NOTIFICATIONS) {
                // Always download regardless of notification permission status
                start(activity.applicationContext, subject)
            }
        }

        @SuppressLint("MissingPermission")
        fun start(context: Context, subject: Subject) {
            if (Build.VERSION.SDK_INT >= 34) {
                val scheduler = context.getSystemService<JobScheduler>()!!
                val cmp = JobService::class.java.cmp(context.packageName)
                val extras = Bundle()
                extras.putParcelable(SUBJECT_KEY, subject)
                val info = JobInfo.Builder(Const.ID.DOWNLOAD_JOB_ID, cmp)
                    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)
                    .setUserInitiated(true)
                    .setTransientExtras(extras)
                    .build()
                scheduler.schedule(info)
            } else {
                val intent = createServiceIntent(context, subject)
                if (Build.VERSION.SDK_INT >= 26) {
                    context.startForegroundService(intent)
                } else {
                    context.startService(intent)
                }
            }
        }
    }

    private val notifications = SparseArrayCompat<Notification.Builder>()
    private var attachedId = -1
    private val job = Job()
    private val processor = DownloadProcessor(this)
    private val network get() = ServiceLocator.networkService

    fun download(subject: Subject) {
        notifyUpdate(subject.notifyId)
        CoroutineScope(job + Dispatchers.IO).launch {
            try {
                val stream = network.fetchFile(subject.url).toProgressStream(subject)
                processor.handle(stream, subject)
                val activity = AppContext.foregroundActivity
                if (activity != null && subject.autoLaunch) {
                    notifyRemove(subject.notifyId)
                    subject.pendingIntent(activity)?.send()
                } else {
                    notifyFinish(subject)
                }
            } catch (e: Exception) {
                Timber.e(e)
                notifyFail(subject)
            }
        }
    }

    @Synchronized
    fun reattach() {
        val builder = notifications[attachedId] ?: return
        attachNotification(attachedId, builder)
    }

    private fun attach(id: Int, notification: Notification.Builder) {
        attachedId = id
        attachNotification(id, notification)
    }

    private fun finalNotify(id: Int, editor: (Notification.Builder) -> Unit): Int {
        val notification = notifyRemove(id)?.also(editor) ?: return -1
        val newId = Notifications.nextId()
        Notifications.mgr.notify(newId, notification.build())
        return newId
    }

    private fun notifyFail(subject: Subject) = finalNotify(subject.notifyId) {
        broadcast(-2f, subject)
        it.setContentText(context.getString(R.string.download_file_error))
            .setSmallIcon(android.R.drawable.stat_notify_error)
            .setOngoing(false)
    }

    private fun notifyFinish(subject: Subject) = finalNotify(subject.notifyId) {
        broadcast(1f, subject)
        it.setContentTitle(subject.title)
            .setContentText(context.getString(R.string.download_complete))
            .setSmallIcon(android.R.drawable.stat_sys_download_done)
            .setProgress(0, 0, false)
            .setOngoing(false)
            .setAutoCancel(true)
        subject.pendingIntent(context)?.let { intent -> it.setContentIntent(intent) }
    }

    @Synchronized
    override fun notifyUpdate(id: Int, editor: (Notification.Builder) -> Unit) {
        val notification = (notifications[id] ?: Notifications.startProgress("").also {
            notifications[id] = it
        }).apply(editor)

        if (attachedId < 0)
            attach(id, notification)
        else
            Notifications.mgr.notify(id, notification.build())
    }

    @Synchronized
    private fun notifyRemove(id: Int): Notification.Builder? {
        val idx = notifications.indexOfKey(id)
        var n: Notification.Builder? = null

        if (idx >= 0) {
            n = notifications.valueAt(idx)
            notifications.removeAt(idx)

            // The cancelled notification is the one attached to the session, need special handling
            if (attachedId == id) {
                if (notifications.isNotEmpty()) {
                    // There are still remaining notifications, pick one and attach to the session
                    val anotherId = notifications.keyAt(0)
                    val notification = notifications.valueAt(0)
                    attach(anotherId, notification)
                } else {
                    // No more notifications left, terminate the session
                    attachedId = -1
                    onDownloadComplete()
                }
            }
        }

        Notifications.mgr.cancel(id)
        return n
    }

    private fun ResponseBody.toProgressStream(subject: Subject): InputStream {
        val max = contentLength()
        val total = max.toFloat() / 1048576
        val id = subject.notifyId

        notifyUpdate(id) { it.setContentTitle(subject.title) }

        return ProgressInputStream(byteStream()) {
            val progress = it.toFloat() / 1048576
            notifyUpdate(id) { notification ->
                if (max > 0) {
                    broadcast(progress / total, subject)
                    notification
                        .setProgress(max.toInt(), it.toInt(), false)
                        .setContentText("%.2f / %.2f MB".format(progress, total))
                } else {
                    broadcast(-1f, subject)
                    notification.setContentText("%.2f MB / ??".format(progress))
                }
            }
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/download/DownloadProcessor.kt`:

```kt
package com.topjohnwu.magisk.core.download

import android.net.Uri
import com.topjohnwu.magisk.StubApk
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.isRunningAsStub
import com.topjohnwu.magisk.core.ktx.cachedFile
import com.topjohnwu.magisk.core.ktx.copyAll
import com.topjohnwu.magisk.core.ktx.copyAndClose
import com.topjohnwu.magisk.core.ktx.withInOut
import com.topjohnwu.magisk.core.ktx.writeTo
import com.topjohnwu.magisk.core.tasks.AppMigration
import com.topjohnwu.magisk.core.utils.MediaStoreUtils.outputStream
import com.topjohnwu.magisk.utils.APKInstall
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream
import org.apache.commons.compress.archivers.zip.ZipFile
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream

class DownloadProcessor(notifier: DownloadNotifier) : DownloadNotifier by notifier {

    suspend fun handle(stream: InputStream, subject: Subject) {
        when (subject) {
            is Subject.App -> handleApp(stream, subject)
            is Subject.Module -> handleModule(stream, subject.file)
            else -> stream.copyAndClose(subject.file.outputStream())
        }
    }

    suspend fun handleApp(stream: InputStream, subject: Subject.App) {
        val external = subject.file.outputStream()

        if (isRunningAsStub) {
            val updateApk = StubApk.update(context)
            try {
                // Download full APK to stub update path
                stream.copyAndClose(TeeOutputStream(external, updateApk.outputStream()))

                // Also upgrade stub
                notifyUpdate(subject.notifyId) {
                    it.setProgress(0, 0, true)
                        .setContentTitle(context.getString(R.string.hide_app_title))
                        .setContentText("")
                }

                // Extract stub
                val apk = context.cachedFile("stub.apk")
                ZipFile.Builder().setFile(updateApk).get().use { zf ->
                    apk.delete()
                    zf.getInputStream(zf.getEntry("assets/stub.apk")).writeTo(apk)
                }

                // Patch and install
                subject.intent = AppMigration.upgradeStub(context, apk)
                    ?: throw IOException("HideAPK patch error")
                apk.delete()
            } catch (e: Exception) {
                // If any error occurred, do not let stub load the new APK
                updateApk.delete()
                throw e
            }
        } else {
            val session = APKInstall.startSession(context)
            stream.copyAndClose(TeeOutputStream(external, session.openStream(context)))
            subject.intent = session.waitIntent()
        }
    }

    suspend fun handleModule(src: InputStream, file: Uri) {
        val tmp = context.cachedFile("module.zip")
        try {
            // First download the entire zip into cache so we can process it
            src.writeTo(tmp)

            val input = ZipFile.Builder().setFile(tmp).get()
            val output = ZipArchiveOutputStream(file.outputStream())
            withInOut(input, output) { zin, zout ->
                zout.putArchiveEntry(ZipArchiveEntry("META-INF/"))
                zout.closeArchiveEntry()
                zout.putArchiveEntry(ZipArchiveEntry("META-INF/com/"))
                zout.closeArchiveEntry()
                zout.putArchiveEntry(ZipArchiveEntry("META-INF/com/google/"))
                zout.closeArchiveEntry()
                zout.putArchiveEntry(ZipArchiveEntry("META-INF/com/google/android/"))
                zout.closeArchiveEntry()

                zout.putArchiveEntry(ZipArchiveEntry("META-INF/com/google/android/update-binary"))
                context.assets.open("module_installer.sh").use { it.copyAll(zout) }
                zout.closeArchiveEntry()

                zout.putArchiveEntry(ZipArchiveEntry("META-INF/com/google/android/updater-script"))
                zout.write("#MAGISK\n".toByteArray())
                zout.closeArchiveEntry()

                // Then simply copy all entries to output
                zin.copyRawEntries(zout) { entry -> !entry.name.startsWith("META-INF") }
            }
        } finally {
            tmp.delete()
        }
    }

    private class TeeOutputStream(
        private val o1: OutputStream,
        private val o2: OutputStream
    ) : OutputStream() {
        override fun write(b: Int) {
            o1.write(b)
            o2.write(b)
        }
        override fun write(b: ByteArray?, off: Int, len: Int) {
            o1.write(b, off, len)
            o2.write(b, off, len)
        }
        override fun close() {
            o1.close()
            o2.close()
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/download/Interfaces.kt`:

```kt
package com.topjohnwu.magisk.core.download

import android.app.Notification
import android.content.Context

interface DownloadSession {
    val context: Context
    fun attachNotification(id: Int, builder: Notification.Builder)
    fun onDownloadComplete()
}

interface DownloadNotifier {
    val context: Context
    fun notifyUpdate(id: Int, editor: (Notification.Builder) -> Unit = {})
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/download/Subject.kt`:

```kt
package com.topjohnwu.magisk.core.download

import android.annotation.SuppressLint
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Parcelable
import androidx.core.net.toUri
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.model.UpdateInfo
import com.topjohnwu.magisk.core.model.module.OnlineModule
import com.topjohnwu.magisk.core.utils.MediaStoreUtils
import com.topjohnwu.magisk.view.Notifications
import kotlinx.parcelize.IgnoredOnParcel
import kotlinx.parcelize.Parcelize
import java.io.File
import java.util.UUID

abstract class Subject : Parcelable {

    abstract val url: String
    abstract val file: Uri
    abstract val title: String
    abstract val notifyId: Int
    open val autoLaunch: Boolean get() = true

    open fun pendingIntent(context: Context): PendingIntent? = null

    abstract class Module : Subject() {
        abstract val module: OnlineModule
        final override val url: String get() = module.zipUrl
        final override val title: String get() = module.downloadFilename
        final override val file by lazy {
            MediaStoreUtils.getFile(title).uri
        }
    }

    @Parcelize
    class App(
        private val json: UpdateInfo = Info.update,
        override val notifyId: Int = Notifications.nextId()
    ) : Subject() {
        override val title: String get() = "Magisk-${json.version}(${json.versionCode})"
        override val url: String get() = json.link

        @IgnoredOnParcel
        override val file by lazy {
            MediaStoreUtils.getFile("${title}.apk").uri
        }

        @IgnoredOnParcel
        var intent: Intent? = null
        override fun pendingIntent(context: Context) = intent?.toPending(context)
    }

    @Parcelize
    class Test(
        override val notifyId: Int = Notifications.nextId(),
        override val title: String = UUID.randomUUID().toString().substring(0, 6)
    ) : Subject() {
        override val url get() = "https://link.testfile.org/250MB"
        override val file get() = File("/dev/null").toUri()
        override val autoLaunch get() = false
    }

    @SuppressLint("InlinedApi")
    protected fun Intent.toPending(context: Context): PendingIntent {
        return PendingIntent.getActivity(context, notifyId, this,
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_ONE_SHOT)
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/ktx/XAndroid.kt`:

```kt
package com.topjohnwu.magisk.core.ktx

import android.annotation.SuppressLint
import android.app.Activity
import android.content.BroadcastReceiver
import android.content.Context
import android.content.ContextWrapper
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.ApplicationInfo
import android.content.pm.PackageInfo
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.drawable.AdaptiveIconDrawable
import android.graphics.drawable.BitmapDrawable
import android.graphics.drawable.LayerDrawable
import android.os.Build
import android.os.Build.VERSION.SDK_INT
import android.os.Process
import android.view.View
import android.view.inputmethod.InputMethodManager
import android.widget.Toast
import androidx.core.content.getSystemService
import com.topjohnwu.magisk.core.utils.LocaleSetting
import com.topjohnwu.magisk.core.utils.RootUtils
import com.topjohnwu.magisk.utils.APKInstall
import com.topjohnwu.superuser.internal.UiThreadHandler
import java.io.File

fun Context.getBitmap(id: Int): Bitmap {
    var drawable = getDrawable(id)!!
    if (drawable is BitmapDrawable)
        return drawable.bitmap
    if (SDK_INT >= Build.VERSION_CODES.O && drawable is AdaptiveIconDrawable) {
        drawable = LayerDrawable(arrayOf(drawable.background, drawable.foreground))
    }
    val bitmap = Bitmap.createBitmap(
        drawable.intrinsicWidth, drawable.intrinsicHeight,
        Bitmap.Config.ARGB_8888
    )
    val canvas = Canvas(bitmap)
    drawable.setBounds(0, 0, canvas.width, canvas.height)
    drawable.draw(canvas)
    return bitmap
}

val Context.deviceProtectedContext: Context get() =
    if (SDK_INT >= Build.VERSION_CODES.N) {
        createDeviceProtectedStorageContext()
    } else { this }

fun Context.cachedFile(name: String) = File(cacheDir, name)

fun ApplicationInfo.getLabel(pm: PackageManager): String {
    runCatching {
        if (labelRes > 0) {
            val res = pm.getResourcesForApplication(this)
            LocaleSetting.instance.updateResource(res)
            return res.getString(labelRes)
        }
    }

    return loadLabel(pm).toString()
}

fun Context.unwrap(): Context {
    var context = this
    while (context is ContextWrapper)
        context = context.baseContext
    return context
}

fun Activity.hideKeyboard() {
    val view = currentFocus ?: return
    getSystemService<InputMethodManager>()
        ?.hideSoftInputFromWindow(view.windowToken, 0)
    view.clearFocus()
}

val View.activity: Activity get() {
    var context = context
    while(true) {
        if (context !is ContextWrapper)
            error("View is not attached to activity")
        if (context is Activity)
            return context
        context = context.baseContext
    }
}

@SuppressLint("PrivateApi")
fun getProperty(key: String, def: String): String {
    runCatching {
        val clazz = Class.forName("android.os.SystemProperties")
        val get = clazz.getMethod("get", String::class.java, String::class.java)
        return get.invoke(clazz, key, def) as String
    }
    return def
}

@SuppressLint("InlinedApi")
@Throws(PackageManager.NameNotFoundException::class)
fun PackageManager.getPackageInfo(uid: Int, pid: Int): PackageInfo? {
    val flag = PackageManager.MATCH_UNINSTALLED_PACKAGES
    val pkgs = getPackagesForUid(uid) ?: throw PackageManager.NameNotFoundException()
    if (pkgs.size > 1) {
        if (pid <= 0) {
            return null
        }
        // Try to find package name from PID
        val proc = RootUtils.getAppProcess(pid)
        if (proc == null) {
            if (uid == Process.SHELL_UID) {
                // It is possible that some apps installed are sharing UID with shell.
                // We will not be able to find a package from the active process list,
                // because the client is forked from ADB shell, not any app process.
                return getPackageInfo("com.android.shell", flag)
            }
        } else if (uid == proc.uid) {
            return getPackageInfo(proc.pkgList[0], flag)
        }

        return null
    }
    if (pkgs.size == 1) {
        return getPackageInfo(pkgs[0], flag)
    }
    throw PackageManager.NameNotFoundException()
}

fun Context.registerRuntimeReceiver(receiver: BroadcastReceiver, filter: IntentFilter) {
    APKInstall.registerReceiver(this, receiver, filter)
}

fun Context.selfLaunchIntent(): Intent {
    val pm = packageManager
    val intent = pm.getLaunchIntentForPackage(packageName)!!
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
    return intent
}

fun Context.toast(msg: CharSequence, duration: Int) {
    UiThreadHandler.run { Toast.makeText(this, msg, duration).show() }
}

fun Context.toast(resId: Int, duration: Int) {
    UiThreadHandler.run { Toast.makeText(this, resId, duration).show() }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/ktx/XJVM.kt`:

```kt
package com.topjohnwu.magisk.core.ktx

import androidx.collection.SparseArrayCompat
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flatMapMerge
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.isActive
import kotlinx.coroutines.withContext
import java.io.Closeable
import java.io.File
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream
import java.lang.reflect.Field
import java.time.Instant
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.time.format.FormatStyle
import java.util.Collections

inline fun <In : Closeable, Out : Closeable> withInOut(
    input: In,
    output: Out,
    withBoth: (In, Out) -> Unit
) {
    input.use { reader ->
        output.use { writer ->
            withBoth(reader, writer)
        }
    }
}

@Throws(IOException::class)
suspend fun InputStream.copyAll(
    out: OutputStream,
    bufferSize: Int = DEFAULT_BUFFER_SIZE,
    dispatcher: CoroutineDispatcher = Dispatchers.IO
): Long {
    return withContext(dispatcher) {
        var bytesCopied: Long = 0
        val buffer = ByteArray(bufferSize)
        var bytes = read(buffer)
        while (isActive && bytes >= 0) {
            out.write(buffer, 0, bytes)
            bytesCopied += bytes
            bytes = read(buffer)
        }
        bytesCopied
    }
}

@Throws(IOException::class)
suspend inline fun InputStream.copyAndClose(
    out: OutputStream,
    bufferSize: Int = DEFAULT_BUFFER_SIZE,
    dispatcher: CoroutineDispatcher = Dispatchers.IO
) = withInOut(this, out) { i, o -> i.copyAll(o, bufferSize, dispatcher) }

@Throws(IOException::class)
suspend inline fun InputStream.writeTo(
    file: File,
    bufferSize: Int = DEFAULT_BUFFER_SIZE,
    dispatcher: CoroutineDispatcher = Dispatchers.IO
) = copyAndClose(file.outputStream(), bufferSize, dispatcher)

operator fun <E> SparseArrayCompat<E>.set(key: Int, value: E) {
    put(key, value)
}

fun <T> MutableList<T>.synchronized(): MutableList<T> = Collections.synchronizedList(this)

fun <T> MutableSet<T>.synchronized(): MutableSet<T> = Collections.synchronizedSet(this)

fun <K, V> MutableMap<K, V>.synchronized(): MutableMap<K, V> = Collections.synchronizedMap(this)

fun Class<*>.reflectField(name: String): Field =
    getDeclaredField(name).apply { isAccessible = true }

inline fun <T, R> Flow<T>.concurrentMap(crossinline transform: suspend (T) -> R): Flow<R> {
    return flatMapMerge { value ->
        flow { emit(transform(value)) }
    }
}

fun Long.toTime(format: DateTimeFormatter): String = format.format(Instant.ofEpochMilli(this))

// Some devices don't allow filenames containing ":"
val timeFormatStandard: DateTimeFormatter by lazy {
    DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH.mm.ss").withZone(ZoneId.systemDefault())
}
val timeDateFormat: DateTimeFormatter by lazy {
    DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).withZone(ZoneId.systemDefault())
}
val dateFormat: DateTimeFormatter by lazy {
    DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT).withZone(ZoneId.systemDefault())
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/ktx/XSU.kt`:

```kt
package com.topjohnwu.magisk.core.ktx

import com.topjohnwu.magisk.core.Config
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

fun reboot(reason: String = if (Config.recovery) "recovery" else "") {
    if (reason == "recovery") {
        // KEYCODE_POWER = 26, hide incorrect "Factory data reset" message
        Shell.cmd("/system/bin/input keyevent 26").submit()
    }
    Shell.cmd("/system/bin/svc power reboot $reason || /system/bin/reboot $reason").submit()
}

suspend fun Shell.Job.await() = withContext(Dispatchers.IO) { exec() }

```

`app/core/src/main/java/com/topjohnwu/magisk/core/model/UpdateInfo.kt`:

```kt
package com.topjohnwu.magisk.core.model

import android.os.Parcelable
import com.squareup.moshi.FromJson
import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass
import com.squareup.moshi.JsonQualifier
import com.squareup.moshi.ToJson
import kotlinx.parcelize.Parcelize
import java.time.Instant

@JsonClass(generateAdapter = true)
class UpdateJson(
    val magisk: UpdateInfo = UpdateInfo(),
)

@Parcelize
@JsonClass(generateAdapter = true)
data class UpdateInfo(
    val version: String = "",
    val versionCode: Int = -1,
    val link: String = "",
    val note: String = ""
) : Parcelable

@JsonClass(generateAdapter = true)
data class ModuleJson(
    val version: String,
    val versionCode: Int,
    val zipUrl: String,
    val changelog: String,
)

@JsonClass(generateAdapter = true)
data class ReleaseAssets(
    val name: String,
    @param:Json(name = "browser_download_url") val url: String,
)

class DateTimeAdapter {
    @ToJson
    fun toJson(date: Instant): String {
        return date.toString()
    }

    @FromJson
    fun fromJson(date: String): Instant {
        return Instant.parse(date)
    }
}

@JsonClass(generateAdapter = true)
data class Release(
    @param:Json(name = "tag_name") val tag: String,
    val name: String,
    val prerelease: Boolean,
    val assets: List<ReleaseAssets>,
    val body: String,
    @param:Json(name = "created_at") val createdTime: Instant,
) {
    val versionCode: Int get() {
        return if (tag[0] == 'v') {
            (tag.drop(1).toFloat() * 1000).toInt()
        } else {
            tag.drop(7).toInt()
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/model/module/LocalModule.kt`:

```kt
package com.topjohnwu.magisk.core.model.module

import com.squareup.moshi.JsonDataException
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.core.utils.RootUtils
import com.topjohnwu.superuser.Shell
import com.topjohnwu.superuser.nio.ExtendedFile
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.io.IOException
import java.util.Locale

data class LocalModule(
    val base: ExtendedFile,
) : Module() {
    private val svc get() = ServiceLocator.networkService

    override var id: String = ""
    override var name: String = ""
    override var version: String = ""
    override var versionCode: Int = -1
    var author: String = ""
    var description: String = ""
    var updateInfo: OnlineModule? = null
    var outdated = false
    private var updateUrl: String = ""

    private val removeFile = base.getChildFile("remove")
    private val disableFile = base.getChildFile("disable")
    private val updateFile = base.getChildFile("update")
    val zygiskFolder = base.getChildFile("zygisk")

    val updated get() = updateFile.exists()
    val isRiru = (id == "riru-core") || base.getChildFile("riru").exists()
    val isZygisk = zygiskFolder.exists()
    val zygiskUnloaded = zygiskFolder.getChildFile("unloaded").exists()
    val hasAction = base.getChildFile("action.sh").exists()

    var enable: Boolean
        get() = !disableFile.exists()
        set(enable) {
            if (enable) {
                disableFile.delete()
                Shell.cmd("copy_preinit_files").submit()
            } else {
                !disableFile.createNewFile()
                Shell.cmd("copy_preinit_files").submit()
            }
        }

    var remove: Boolean
        get() = removeFile.exists()
        set(remove) {
            if (remove) {
                if (updateFile.exists()) return
                removeFile.createNewFile()
                Shell.cmd("copy_preinit_files").submit()
            } else {
                removeFile.delete()
                Shell.cmd("copy_preinit_files").submit()
            }
        }

    @Throws(NumberFormatException::class)
    private fun parseProps(props: List<String>) {
        for (line in props) {
            val prop = line.split("=".toRegex(), 2).map { it.trim() }
            if (prop.size != 2)
                continue

            val key = prop[0]
            val value = prop[1]
            if (key.isEmpty() || key[0] == '#')
                continue

            when (key) {
                "id" -> id = value
                "name" -> name = value
                "version" -> version = value
                "versionCode" -> versionCode = value.toInt()
                "author" -> author = value
                "description" -> description = value
                "updateJson" -> updateUrl = value
            }
        }
    }

    init {
        runCatching {
            parseProps(Shell.cmd("dos2unix < $base/module.prop").exec().out)
        }

        if (id.isEmpty()) {
            id = base.name
        }

        if (name.isEmpty()) {
            name = id
        }
    }

    suspend fun fetch(): Boolean {
        if (updateUrl.isEmpty())
            return false

        try {
            val json = svc.fetchModuleJson(updateUrl)
            updateInfo = OnlineModule(this, json)
            outdated = json.versionCode > versionCode
            return true
        } catch (e: IOException) {
            Timber.w(e)
        } catch (e: JsonDataException) {
            Timber.w(e)
        }

        return false
    }

    companion object {

        fun loaded() = RootUtils.fs.getFile(Const.MODULE_PATH).exists()

        suspend fun installed() = withContext(Dispatchers.IO) {
            RootUtils.fs.getFile(Const.MODULE_PATH)
                .listFiles()
                .orEmpty()
                .filter { !it.isFile && !it.isHidden }
                .map { LocalModule(it) }
                .sortedBy { it.name.lowercase(Locale.ROOT) }
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/model/module/Module.kt`:

```kt
package com.topjohnwu.magisk.core.model.module

abstract class Module : Comparable<Module> {
    abstract var id: String
        protected set
    abstract var name: String
        protected set
    abstract var version: String
        protected set
    abstract var versionCode: Int
        protected set

    override operator fun compareTo(other: Module) = id.compareTo(other.id)
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/model/module/OnlineModule.kt`:

```kt
package com.topjohnwu.magisk.core.model.module

import android.os.Parcelable
import com.topjohnwu.magisk.core.model.ModuleJson
import kotlinx.parcelize.Parcelize

@Parcelize
data class OnlineModule(
    override var id: String,
    override var name: String,
    override var version: String,
    override var versionCode: Int,
    val zipUrl: String,
    val changelog: String,
) : Module(), Parcelable {
    constructor(local: LocalModule, json: ModuleJson) :
        this(local.id, local.name, json.version, json.versionCode, json.zipUrl, json.changelog)

    val downloadFilename get() = "$name-$version($versionCode).zip".legalFilename()

    private fun String.legalFilename() = replace(" ", "_")
        .replace("'", "").replace("\"", "")
        .replace("$", "").replace("`", "")
        .replace("*", "").replace("/", "_")
        .replace("#", "").replace("@", "")
        .replace("\\", "_")
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/model/su/SuLog.kt`:

```kt
package com.topjohnwu.magisk.core.model.su

import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import androidx.room.Entity
import androidx.room.PrimaryKey
import com.topjohnwu.magisk.core.ktx.getLabel

@Entity(tableName = "logs")
class SuLog(
    val fromUid: Int,
    val toUid: Int,
    val fromPid: Int,
    val packageName: String,
    val appName: String,
    val command: String,
    val action: Int,
    val target: Int,
    val context: String,
    val gids: String,
    val time: Long = System.currentTimeMillis()
) {
    @PrimaryKey(autoGenerate = true) var id: Int = 0
}

fun PackageManager.createSuLog(
    info: ApplicationInfo,
    toUid: Int,
    fromPid: Int,
    command: String,
    policy: Int,
    target: Int,
    context: String,
    gids: String,
): SuLog {
    return SuLog(
        fromUid = info.uid,
        toUid = toUid,
        fromPid = fromPid,
        packageName = getNameForUid(info.uid)!!,
        appName = info.getLabel(this),
        command = command,
        action = policy,
        target = target,
        context = context,
        gids = gids,
    )
}

fun createSuLog(
    fromUid: Int,
    toUid: Int,
    fromPid: Int,
    command: String,
    policy: Int,
    target: Int,
    context: String,
    gids: String,
): SuLog {
    return SuLog(
        fromUid = fromUid,
        toUid = toUid,
        fromPid = fromPid,
        packageName = "[UID] $fromUid",
        appName = "[UID] $fromUid",
        command = command,
        action = policy,
        target = target,
        context = context,
        gids = gids,
    )
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/model/su/SuPolicy.kt`:

```kt
package com.topjohnwu.magisk.core.model.su

import com.topjohnwu.magisk.core.data.magiskdb.MagiskDB

class SuPolicy(
    val uid: Int,
    var policy: Int = QUERY,
    var remain: Long = -1L,
    var logging: Boolean = true,
    var notification: Boolean = true,
) {
    companion object {
        const val QUERY = 0
        const val DENY = 1
        const val ALLOW = 2
        const val RESTRICT = 3
    }

    fun toMap(): MutableMap<String, Any> {
        val until = if (remain <= 0) {
            remain
        } else {
            MagiskDB.Literal("(strftime(\"%s\", \"now\") + $remain)")
        }
        return mutableMapOf(
            "uid" to uid,
            "policy" to policy,
            "until" to until,
            "logging" to logging,
            "notification" to notification
        )
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/repository/DBConfig.kt`:

```kt
package com.topjohnwu.magisk.core.repository

import com.topjohnwu.magisk.core.data.magiskdb.SettingsDao
import com.topjohnwu.magisk.core.data.magiskdb.StringDao
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlin.properties.ReadWriteProperty
import kotlin.reflect.KProperty

interface DBConfig {
    val settingsDB: SettingsDao
    val stringDB: StringDao
    val coroutineScope: CoroutineScope

    fun dbSettings(
        name: String,
        default: Int
    ) = IntDBProperty(name, default)

    fun dbSettings(
        name: String,
        default: Boolean
    ) = BoolDBProperty(name, default)

    fun dbStrings(
        name: String,
        default: String,
        sync: Boolean = false
    ) = StringDBProperty(name, default, sync)

}

class IntDBProperty(
    private val name: String,
    private val default: Int
) : ReadWriteProperty<DBConfig, Int> {

    var value: Int? = null

    @Synchronized
    override fun getValue(thisRef: DBConfig, property: KProperty<*>): Int {
        if (value == null)
            value = runBlocking { thisRef.settingsDB.fetch(name, default) }
        return value as Int
    }

    override fun setValue(thisRef: DBConfig, property: KProperty<*>, value: Int) {
        synchronized(this) {
            this.value = value
        }
        thisRef.coroutineScope.launch {
            thisRef.settingsDB.put(name, value)
        }
    }
}

open class BoolDBProperty(
    name: String,
    default: Boolean
) : ReadWriteProperty<DBConfig, Boolean> {

    val base = IntDBProperty(name, if (default) 1 else 0)

    override fun getValue(thisRef: DBConfig, property: KProperty<*>): Boolean =
        base.getValue(thisRef, property) != 0

    override fun setValue(thisRef: DBConfig, property: KProperty<*>, value: Boolean) =
        base.setValue(thisRef, property, if (value) 1 else 0)
}

class StringDBProperty(
    private val name: String,
    private val default: String,
    private val sync: Boolean
) : ReadWriteProperty<DBConfig, String> {

    private var value: String? = null

    @Synchronized
    override fun getValue(thisRef: DBConfig, property: KProperty<*>): String {
        if (value == null)
            value = runBlocking {
                thisRef.stringDB.fetch(name, default)
            }
        return value!!
    }

    override fun setValue(thisRef: DBConfig, property: KProperty<*>, value: String) {
        synchronized(this) {
            this.value = value
        }
        if (value.isEmpty()) {
            if (sync) {
                runBlocking {
                    thisRef.stringDB.delete(name)
                }
            } else {
                thisRef.coroutineScope.launch {
                    thisRef.stringDB.delete(name)
                }
            }
        } else {
            if (sync) {
                runBlocking {
                    thisRef.stringDB.put(name, value)
                }
            } else {
                thisRef.coroutineScope.launch {
                    thisRef.stringDB.put(name, value)
                }
            }
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/repository/LogRepository.kt`:

```kt
package com.topjohnwu.magisk.core.repository

import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.data.SuLogDao
import com.topjohnwu.magisk.core.ktx.await
import com.topjohnwu.magisk.core.model.su.SuLog
import com.topjohnwu.superuser.Shell


class LogRepository(
    private val logDao: SuLogDao
) {

    suspend fun fetchSuLogs() = logDao.fetchAll()

    suspend fun fetchMagiskLogs(): String {
        val list = object : AbstractMutableList<String>() {
            val buf = StringBuilder()
            override val size get() = 0
            override fun get(index: Int): String = ""
            override fun removeAt(index: Int): String = ""
            override fun set(index: Int, element: String): String = ""
            override fun add(index: Int, element: String) {
                if (element.isNotEmpty()) {
                    buf.append(element)
                    buf.append('\n')
                }
            }
        }
        if (Info.env.isActive) {
            Shell.cmd("cat ${Const.MAGISK_LOG} || logcat -d -s Magisk").to(list).await()
        } else {
            Shell.cmd("logcat -d").to(list).await()
        }
        return list.buf.toString()
    }

    suspend fun clearLogs() = logDao.deleteAll()

    fun clearMagiskLogs(cb: (Shell.Result) -> Unit) =
        Shell.cmd("echo -n > ${Const.MAGISK_LOG}").submit(cb)

    suspend fun insert(log: SuLog) = logDao.insert(log)

}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/repository/NetworkService.kt`:

```kt
package com.topjohnwu.magisk.core.repository

import com.topjohnwu.magisk.core.BuildConfig
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Config.Value.BETA_CHANNEL
import com.topjohnwu.magisk.core.Config.Value.CUSTOM_CHANNEL
import com.topjohnwu.magisk.core.Config.Value.DEBUG_CHANNEL
import com.topjohnwu.magisk.core.Config.Value.DEFAULT_CHANNEL
import com.topjohnwu.magisk.core.Config.Value.STABLE_CHANNEL
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.data.GithubApiServices
import com.topjohnwu.magisk.core.data.RawUrl
import com.topjohnwu.magisk.core.ktx.dateFormat
import com.topjohnwu.magisk.core.model.Release
import com.topjohnwu.magisk.core.model.ReleaseAssets
import com.topjohnwu.magisk.core.model.UpdateInfo
import retrofit2.HttpException
import timber.log.Timber
import java.io.IOException

class NetworkService(
    private val raw: RawUrl,
    private val api: GithubApiServices,
) {
    suspend fun fetchUpdate() = safe {
        var info = when (Config.updateChannel) {
            DEFAULT_CHANNEL -> if (BuildConfig.DEBUG) fetchDebugUpdate() else fetchStableUpdate()
            STABLE_CHANNEL -> fetchStableUpdate()
            BETA_CHANNEL -> fetchBetaUpdate()
            DEBUG_CHANNEL -> fetchDebugUpdate()
            CUSTOM_CHANNEL -> fetchCustomUpdate(Config.customChannelUrl)
            else -> throw IllegalArgumentException()
        }
        if (info.versionCode < Info.env.versionCode &&
            Config.updateChannel == DEFAULT_CHANNEL &&
            !BuildConfig.DEBUG
        ) {
            Config.updateChannel = BETA_CHANNEL
            info = fetchBetaUpdate()
        }
        info
    }

    suspend fun fetchUpdate(version: Int) = safe {
        findRelease { it.versionCode == version }.asInfo()
    }

    // Keep going through all release pages until we find a match
    private suspend inline fun findRelease(predicate: (Release) -> Boolean): Release? {
        var page = 1
        while (true) {
            val response = api.fetchReleases(page = page)
            val releases = response.body() ?: throw HttpException(response)
            // Remove all non Magisk releases
            releases.removeAll { it.tag[0] != 'v' && !it.tag.startsWith("canary") }
            // Make sure it's sorted correctly
            releases.sortByDescending { it.createdTime }
            releases.find(predicate)?.let { return it }
            if (response.headers()["link"]?.contains("rel=\"next\"", ignoreCase = true) == true) {
                page += 1
            } else {
                return null
            }
        }
    }

    private inline fun Release?.asInfo(
        selector: (ReleaseAssets) -> Boolean = {
            // Default selector picks the non-debug APK
            it.name.run { endsWith(".apk") && !contains("debug") }
        }): UpdateInfo {
        return if (this == null) UpdateInfo()
        else if (tag[0] == 'v') asPublicInfo(selector)
        else asCanaryInfo(selector)
    }

    private inline fun Release.asPublicInfo(selector: (ReleaseAssets) -> Boolean): UpdateInfo {
        val version = tag.drop(1)
        val date = dateFormat.format(createdTime)
        return UpdateInfo(
            version = version,
            versionCode = versionCode,
            link = assets.find(selector)!!.url,
            note = "## $date $name\n\n$body"
        )
    }

    private inline fun Release.asCanaryInfo(selector: (ReleaseAssets) -> Boolean): UpdateInfo {
        return UpdateInfo(
            version = name.substring(8, 16),
            versionCode = versionCode,
            link = assets.find(selector)!!.url,
            note = "## $name\n\n$body"
        )
    }

    // Version number: debug == beta >= stable

    // Find the latest non-prerelease
    private suspend fun fetchStableUpdate() = api.fetchLatestRelease().asInfo()

    // Find the latest release, regardless whether it's prerelease
    private suspend fun fetchBetaUpdate() = findRelease { true }.asInfo()

    private suspend fun fetchDebugUpdate() =
        findRelease { true }.asInfo { it.name == "app-debug.apk" }

    private suspend fun fetchCustomUpdate(url: String): UpdateInfo {
        val info = raw.fetchUpdateJson(url).magisk
        return info.let { it.copy(note = raw.fetchString(it.note)) }
    }

    private inline fun <T> safe(factory: () -> T): T? {
        return try {
            if (Info.isConnected.value == true)
                factory()
            else
                null
        } catch (e: Exception) {
            Timber.e(e)
            null
        }
    }

    private inline fun <T> wrap(factory: () -> T): T {
        return try {
            factory()
        } catch (e: HttpException) {
            throw IOException(e)
        }
    }

    // Fetch files
    suspend fun fetchFile(url: String) = wrap { raw.fetchFile(url) }
    suspend fun fetchString(url: String) = wrap { raw.fetchString(url) }
    suspend fun fetchModuleJson(url: String) = wrap { raw.fetchModuleJson(url) }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/repository/PreferenceConfig.kt`:

```kt
package com.topjohnwu.magisk.core.repository

import android.content.Context
import android.content.SharedPreferences
import androidx.core.content.edit
import kotlin.properties.ReadWriteProperty
import kotlin.reflect.KProperty

interface PreferenceConfig {

    val context: Context

    val fileName: String
        get() = "${context.packageName}_preferences"

    val prefs: SharedPreferences
        get() = context.getSharedPreferences(fileName, Context.MODE_PRIVATE)

    fun preferenceStrInt(
        name: String,
        default: Int,
        commit: Boolean = false
    ) = object: ReadWriteProperty<PreferenceConfig, Int> {
        val base = StringProperty(name, default.toString(), commit)
        override fun getValue(thisRef: PreferenceConfig, property: KProperty<*>): Int =
                base.getValue(thisRef, property).toInt()

        override fun setValue(thisRef: PreferenceConfig, property: KProperty<*>, value: Int) =
                base.setValue(thisRef, property, value.toString())
    }

    fun preference(
        name: String,
        default: Boolean,
        commit: Boolean = false
    ) = BooleanProperty(name, default, commit)

    fun preference(
        name: String,
        default: Int,
        commit: Boolean = false
    ) = IntProperty(name, default, commit)

    fun preference(
        name: String,
        default: String,
        commit: Boolean = false
    ) = StringProperty(name, default, commit)
}

abstract class PreferenceProperty {

    fun SharedPreferences.Editor.put(name: String, value: Boolean) = putBoolean(name, value)
    fun SharedPreferences.Editor.put(name: String, value: Float) = putFloat(name, value)
    fun SharedPreferences.Editor.put(name: String, value: Int) = putInt(name, value)
    fun SharedPreferences.Editor.put(name: String, value: Long) = putLong(name, value)
    fun SharedPreferences.Editor.put(name: String, value: String) = putString(name, value)
    fun SharedPreferences.Editor.put(name: String, value: Set<String>) = putStringSet(name, value)

    fun SharedPreferences.get(name: String, value: Boolean) = getBoolean(name, value)
    fun SharedPreferences.get(name: String, value: Float) = getFloat(name, value)
    fun SharedPreferences.get(name: String, value: Int) = getInt(name, value)
    fun SharedPreferences.get(name: String, value: Long) = getLong(name, value)
    fun SharedPreferences.get(name: String, value: String) = getString(name, value) ?: value
    fun SharedPreferences.get(name: String, value: Set<String>) = getStringSet(name, value) ?: value

}

class BooleanProperty(
    private val name: String,
    private val default: Boolean,
    private val commit: Boolean
) : PreferenceProperty(), ReadWriteProperty<PreferenceConfig, Boolean> {

    override operator fun getValue(
        thisRef: PreferenceConfig,
        property: KProperty<*>
    ): Boolean {
        val prefName = name.ifBlank { property.name }
        return thisRef.prefs.get(prefName, default)
    }

    override operator fun setValue(
        thisRef: PreferenceConfig,
        property: KProperty<*>,
        value: Boolean
    ) {
        val prefName = name.ifBlank { property.name }
        thisRef.prefs.edit(commit) { put(prefName, value) }
    }
}

class IntProperty(
    private val name: String,
    private val default: Int,
    private val commit: Boolean
) : PreferenceProperty(), ReadWriteProperty<PreferenceConfig, Int> {

    override operator fun getValue(
        thisRef: PreferenceConfig,
        property: KProperty<*>
    ): Int {
        val prefName = name.ifBlank { property.name }
        return thisRef.prefs.get(prefName, default)
    }

    override operator fun setValue(
        thisRef: PreferenceConfig,
        property: KProperty<*>,
        value: Int
    ) {
        val prefName = name.ifBlank { property.name }
        thisRef.prefs.edit(commit) { put(prefName, value) }
    }
}

class StringProperty(
    private val name: String,
    private val default: String,
    private val commit: Boolean
) : PreferenceProperty(), ReadWriteProperty<PreferenceConfig, String> {

    override operator fun getValue(
        thisRef: PreferenceConfig,
        property: KProperty<*>
    ): String {
        val prefName = name.ifBlank { property.name }
        return thisRef.prefs.get(prefName, default)
    }

    override operator fun setValue(
        thisRef: PreferenceConfig,
        property: KProperty<*>,
        value: String
    ) {
        val prefName = name.ifBlank { property.name }
        thisRef.prefs.edit(commit) { put(prefName, value) }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/signing/ApkSignerV2.java`:

```java
package com.topjohnwu.magisk.core.signing;

import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.DigestException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.cert.CertificateEncodingException;
import java.security.cert.X509Certificate;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.MGF1ParameterSpec;
import java.security.spec.PSSParameterSpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * APK Signature Scheme v2 signer.
 *
 * <p>APK Signature Scheme v2 is a whole-file signature scheme which aims to protect every single
 * bit of the APK, as opposed to the JAR Signature Scheme which protects only the names and
 * uncompressed contents of ZIP entries.
 */
public abstract class ApkSignerV2 {
    /*
     * The two main goals of APK Signature Scheme v2 are:
     * 1. Detect any unauthorized modifications to the APK. This is achieved by making the signature
     *    cover every byte of the APK being signed.
     * 2. Enable much faster signature and integrity verification. This is achieved by requiring
     *    only a minimal amount of APK parsing before the signature is verified, thus completely
     *    bypassing ZIP entry decompression and by making integrity verification parallelizable by
     *    employing a hash tree.
     *
     * The generated signature block is wrapped into an APK Signing Block and inserted into the
     * original APK immediately before the start of ZIP Central Directory. This is to ensure that
     * JAR and ZIP parsers continue to work on the signed APK. The APK Signing Block is designed for
     * extensibility. For example, a future signature scheme could insert its signatures there as
     * well. The contract of the APK Signing Block is that all contents outside of the block must be
     * protected by signatures inside the block.
     */

    public static final int SIGNATURE_RSA_PSS_WITH_SHA256 = 0x0101;
    public static final int SIGNATURE_RSA_PSS_WITH_SHA512 = 0x0102;
    public static final int SIGNATURE_RSA_PKCS1_V1_5_WITH_SHA256 = 0x0103;
    public static final int SIGNATURE_RSA_PKCS1_V1_5_WITH_SHA512 = 0x0104;
    public static final int SIGNATURE_ECDSA_WITH_SHA256 = 0x0201;
    public static final int SIGNATURE_ECDSA_WITH_SHA512 = 0x0202;
    public static final int SIGNATURE_DSA_WITH_SHA256 = 0x0301;
    public static final int SIGNATURE_DSA_WITH_SHA512 = 0x0302;

    /**
     * {@code .SF} file header section attribute indicating that the APK is signed not just with
     * JAR signature scheme but also with APK Signature Scheme v2 or newer. This attribute
     * facilitates v2 signature stripping detection.
     *
     * <p>The attribute contains a comma-separated set of signature scheme IDs.
     */
    public static final String SF_ATTRIBUTE_ANDROID_APK_SIGNED_NAME = "X-Android-APK-Signed";
    public static final String SF_ATTRIBUTE_ANDROID_APK_SIGNED_VALUE = "2";

    private static final int CONTENT_DIGEST_CHUNKED_SHA256 = 0;
    private static final int CONTENT_DIGEST_CHUNKED_SHA512 = 1;

    private static final int CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES = 1024 * 1024;

    private static final byte[] APK_SIGNING_BLOCK_MAGIC =
          new byte[] {
              0x41, 0x50, 0x4b, 0x20, 0x53, 0x69, 0x67, 0x20,
              0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x34, 0x32,
          };
    private static final int APK_SIGNATURE_SCHEME_V2_BLOCK_ID = 0x7109871a;

    private ApkSignerV2() {}

    /**
     * Signer configuration.
     */
    public static final class SignerConfig {
        /** Private key. */
        public PrivateKey privateKey;

        /**
         * Certificates, with the first certificate containing the public key corresponding to
         * {@link #privateKey}.
         */
        public List<X509Certificate> certificates;

        /**
         * List of signature algorithms with which to sign (see {@code SIGNATURE_...} constants).
         */
        public List<Integer> signatureAlgorithms;
    }

    /**
     * Signs the provided APK using APK Signature Scheme v2 and returns the signed APK as a list of
     * consecutive chunks.
     *
     * <p>NOTE: To enable APK signature verifier to detect v2 signature stripping, header sections
     * of META-INF/*.SF files of APK being signed must contain the
     * {@code X-Android-APK-Signed: true} attribute.
     *
     * @param inputApk contents of the APK to be signed. The APK starts at the current position
     *        of the buffer and ends at the limit of the buffer.
     * @param signerConfigs signer configurations, one for each signer.
     *
     * @throws ApkParseException if the APK cannot be parsed.
     * @throws InvalidKeyException if a signing key is not suitable for this signature scheme or
     *         cannot be used in general.
     * @throws SignatureException if an error occurs when computing digests of generating
     *         signatures.
     */
    public static ByteBuffer[] sign(
            ByteBuffer inputApk,
            List<SignerConfig> signerConfigs)
                    throws ApkParseException, InvalidKeyException, SignatureException {
        // Slice/create a view in the inputApk to make sure that:
        // 1. inputApk is what's between position and limit of the original inputApk, and
        // 2. changes to position, limit, and byte order are not reflected in the original.
        ByteBuffer originalInputApk = inputApk;
        inputApk = originalInputApk.slice();
        inputApk.order(ByteOrder.LITTLE_ENDIAN);

        // Locate ZIP End of Central Directory (EoCD), Central Directory, and check that Central
        // Directory is immediately followed by the ZIP End of Central Directory.
        int eocdOffset = ZipUtils.findZipEndOfCentralDirectoryRecord(inputApk);
        if (eocdOffset == -1) {
            throw new ApkParseException("Failed to locate ZIP End of Central Directory");
        }
        if (ZipUtils.isZip64EndOfCentralDirectoryLocatorPresent(inputApk, eocdOffset)) {
            throw new ApkParseException("ZIP64 format not supported");
        }
        inputApk.position(eocdOffset);
        long centralDirSizeLong = ZipUtils.getZipEocdCentralDirectorySizeBytes(inputApk);
        if (centralDirSizeLong > Integer.MAX_VALUE) {
            throw new ApkParseException(
                    "ZIP Central Directory size out of range: " + centralDirSizeLong);
        }
        int centralDirSize = (int) centralDirSizeLong;
        long centralDirOffsetLong = ZipUtils.getZipEocdCentralDirectoryOffset(inputApk);
        if (centralDirOffsetLong > Integer.MAX_VALUE) {
            throw new ApkParseException(
                    "ZIP Central Directory offset in file out of range: " + centralDirOffsetLong);
        }
        int centralDirOffset = (int) centralDirOffsetLong;
        int expectedEocdOffset = centralDirOffset + centralDirSize;
        if (expectedEocdOffset < centralDirOffset) {
            throw new ApkParseException(
                    "ZIP Central Directory extent too large. Offset: " + centralDirOffset
                            + ", size: " + centralDirSize);
        }
        if (eocdOffset != expectedEocdOffset) {
            throw new ApkParseException(
                    "ZIP Central Directory not immeiately followed by ZIP End of"
                            + " Central Directory. CD end: " + expectedEocdOffset
                            + ", EoCD start: " + eocdOffset);
        }

        // Create ByteBuffers holding the contents of everything before ZIP Central Directory,
        // ZIP Central Directory, and ZIP End of Central Directory.
        inputApk.clear();
        ByteBuffer beforeCentralDir = getByteBuffer(inputApk, centralDirOffset);
        ByteBuffer centralDir = getByteBuffer(inputApk, eocdOffset - centralDirOffset);
        // Create a copy of End of Central Directory because we'll need modify its contents later.
        byte[] eocdBytes = new byte[inputApk.remaining()];
        inputApk.get(eocdBytes);
        ByteBuffer eocd = ByteBuffer.wrap(eocdBytes);
        eocd.order(inputApk.order());

        // Figure which which digests to use for APK contents.
        Set<Integer> contentDigestAlgorithms = new HashSet<>();
        for (SignerConfig signerConfig : signerConfigs) {
            for (int signatureAlgorithm : signerConfig.signatureAlgorithms) {
                contentDigestAlgorithms.add(
                        getSignatureAlgorithmContentDigestAlgorithm(signatureAlgorithm));
            }
        }

        // Compute digests of APK contents.
        Map<Integer, byte[]> contentDigests; // digest algorithm ID -> digest
        try {
            contentDigests =
                    computeContentDigests(
                            contentDigestAlgorithms,
                            new ByteBuffer[] {beforeCentralDir, centralDir, eocd});
        } catch (DigestException e) {
            throw new SignatureException("Failed to compute digests of APK", e);
        }

        // Sign the digests and wrap the signatures and signer info into an APK Signing Block.
        ByteBuffer apkSigningBlock =
                ByteBuffer.wrap(generateApkSigningBlock(signerConfigs, contentDigests));

        // Update Central Directory Offset in End of Central Directory Record. Central Directory
        // follows the APK Signing Block and thus is shifted by the size of the APK Signing Block.
        centralDirOffset += apkSigningBlock.remaining();
        eocd.clear();
        ZipUtils.setZipEocdCentralDirectoryOffset(eocd, centralDirOffset);

        // Follow the Java NIO pattern for ByteBuffer whose contents have been consumed.
        originalInputApk.position(originalInputApk.limit());

        // Reset positions (to 0) and limits (to capacity) in the ByteBuffers below to follow the
        // Java NIO pattern for ByteBuffers which are ready for their contents to be read by caller.
        // Contrary to the name, this does not clear the contents of these ByteBuffer.
        beforeCentralDir.clear();
        centralDir.clear();
        eocd.clear();

        // Insert APK Signing Block immediately before the ZIP Central Directory.
        return new ByteBuffer[] {
            beforeCentralDir,
            apkSigningBlock,
            centralDir,
            eocd,
        };
    }

    private static Map<Integer, byte[]> computeContentDigests(
            Set<Integer> digestAlgorithms,
            ByteBuffer[] contents) throws DigestException {
        // For each digest algorithm the result is computed as follows:
        // 1. Each segment of contents is split into consecutive chunks of 1 MB in size.
        //    The final chunk will be shorter iff the length of segment is not a multiple of 1 MB.
        //    No chunks are produced for empty (zero length) segments.
        // 2. The digest of each chunk is computed over the concatenation of byte 0xa5, the chunk's
        //    length in bytes (uint32 little-endian) and the chunk's contents.
        // 3. The output digest is computed over the concatenation of the byte 0x5a, the number of
        //    chunks (uint32 little-endian) and the concatenation of digests of chunks of all
        //    segments in-order.

        int chunkCount = 0;
        for (ByteBuffer input : contents) {
            chunkCount += getChunkCount(input.remaining(), CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);
        }

        final Map<Integer, byte[]> digestsOfChunks = new HashMap<>(digestAlgorithms.size());
        for (int digestAlgorithm : digestAlgorithms) {
            int digestOutputSizeBytes = getContentDigestAlgorithmOutputSizeBytes(digestAlgorithm);
            byte[] concatenationOfChunkCountAndChunkDigests =
                    new byte[5 + chunkCount * digestOutputSizeBytes];
            concatenationOfChunkCountAndChunkDigests[0] = 0x5a;
            setUnsignedInt32LittleEngian(
                    chunkCount, concatenationOfChunkCountAndChunkDigests, 1);
            digestsOfChunks.put(digestAlgorithm, concatenationOfChunkCountAndChunkDigests);
        }

        int chunkIndex = 0;
        byte[] chunkContentPrefix = new byte[5];
        chunkContentPrefix[0] = (byte) 0xa5;
        // Optimization opportunity: digests of chunks can be computed in parallel.
        for (ByteBuffer input : contents) {
            while (input.hasRemaining()) {
                int chunkSize =
                        Math.min(input.remaining(), CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);
                final ByteBuffer chunk = getByteBuffer(input, chunkSize);
                for (int digestAlgorithm : digestAlgorithms) {
                    String jcaAlgorithmName =
                            getContentDigestAlgorithmJcaDigestAlgorithm(digestAlgorithm);
                    MessageDigest md;
                    try {
                        md = MessageDigest.getInstance(jcaAlgorithmName);
                    } catch (NoSuchAlgorithmException e) {
                        throw new DigestException(
                                jcaAlgorithmName + " MessageDigest not supported", e);
                    }
                    // Reset position to 0 and limit to capacity. Position would've been modified
                    // by the preceding iteration of this loop. NOTE: Contrary to the method name,
                    // this does not modify the contents of the chunk.
                    chunk.clear();
                    setUnsignedInt32LittleEngian(chunk.remaining(), chunkContentPrefix, 1);
                    md.update(chunkContentPrefix);
                    md.update(chunk);
                    byte[] concatenationOfChunkCountAndChunkDigests =
                            digestsOfChunks.get(digestAlgorithm);
                    int expectedDigestSizeBytes =
                            getContentDigestAlgorithmOutputSizeBytes(digestAlgorithm);
                    int actualDigestSizeBytes =
                            md.digest(
                                    concatenationOfChunkCountAndChunkDigests,
                                    5 + chunkIndex * expectedDigestSizeBytes,
                                    expectedDigestSizeBytes);
                    if (actualDigestSizeBytes != expectedDigestSizeBytes) {
                        throw new DigestException(
                                "Unexpected output size of " + md.getAlgorithm()
                                        + " digest: " + actualDigestSizeBytes);
                    }
                }
                chunkIndex++;
            }
        }

        Map<Integer, byte[]> result = new HashMap<>(digestAlgorithms.size());
        for (Map.Entry<Integer, byte[]> entry : digestsOfChunks.entrySet()) {
            int digestAlgorithm = entry.getKey();
            byte[] concatenationOfChunkCountAndChunkDigests = entry.getValue();
            String jcaAlgorithmName = getContentDigestAlgorithmJcaDigestAlgorithm(digestAlgorithm);
            MessageDigest md;
            try {
                md = MessageDigest.getInstance(jcaAlgorithmName);
            } catch (NoSuchAlgorithmException e) {
                throw new DigestException(jcaAlgorithmName + " MessageDigest not supported", e);
            }
            result.put(digestAlgorithm, md.digest(concatenationOfChunkCountAndChunkDigests));
        }
        return result;
    }

    private static int getChunkCount(int inputSize, int chunkSize) {
        return (inputSize + chunkSize - 1) / chunkSize;
    }

    private static void setUnsignedInt32LittleEngian(int value, byte[] result, int offset) {
        result[offset] = (byte) (value & 0xff);
        result[offset + 1] = (byte) ((value >> 8) & 0xff);
        result[offset + 2] = (byte) ((value >> 16) & 0xff);
        result[offset + 3] = (byte) ((value >> 24) & 0xff);
    }

    private static byte[] generateApkSigningBlock(
            List<SignerConfig> signerConfigs,
            Map<Integer, byte[]> contentDigests) throws InvalidKeyException, SignatureException {
        byte[] apkSignatureSchemeV2Block =
                generateApkSignatureSchemeV2Block(signerConfigs, contentDigests);
        return generateApkSigningBlock(apkSignatureSchemeV2Block);
    }

    private static byte[] generateApkSigningBlock(byte[] apkSignatureSchemeV2Block) {
        // FORMAT:
        // uint64:  size (excluding this field)
        // repeated ID-value pairs:
        //     uint64:           size (excluding this field)
        //     uint32:           ID
        //     (size - 4) bytes: value
        // uint64:  size (same as the one above)
        // uint128: magic

        int resultSize =
                8 // size
                + 8 + 4 + apkSignatureSchemeV2Block.length // v2Block as ID-value pair
                + 8 // size
                + 16 // magic
                ;
        ByteBuffer result = ByteBuffer.allocate(resultSize);
        result.order(ByteOrder.LITTLE_ENDIAN);
        long blockSizeFieldValue = resultSize - 8;
        result.putLong(blockSizeFieldValue);

        long pairSizeFieldValue = 4 + apkSignatureSchemeV2Block.length;
        result.putLong(pairSizeFieldValue);
        result.putInt(APK_SIGNATURE_SCHEME_V2_BLOCK_ID);
        result.put(apkSignatureSchemeV2Block);

        result.putLong(blockSizeFieldValue);
        result.put(APK_SIGNING_BLOCK_MAGIC);

        return result.array();
    }

    private static byte[] generateApkSignatureSchemeV2Block(
            List<SignerConfig> signerConfigs,
            Map<Integer, byte[]> contentDigests) throws InvalidKeyException, SignatureException {
        // FORMAT:
        // * length-prefixed sequence of length-prefixed signer blocks.

        List<byte[]> signerBlocks = new ArrayList<>(signerConfigs.size());
        int signerNumber = 0;
        for (SignerConfig signerConfig : signerConfigs) {
            signerNumber++;
            byte[] signerBlock;
            try {
                signerBlock = generateSignerBlock(signerConfig, contentDigests);
            } catch (InvalidKeyException e) {
                throw new InvalidKeyException("Signer #" + signerNumber + " failed", e);
            } catch (SignatureException e) {
                throw new SignatureException("Signer #" + signerNumber + " failed", e);
            }
            signerBlocks.add(signerBlock);
        }

        return encodeAsSequenceOfLengthPrefixedElements(
                new byte[][] {
                    encodeAsSequenceOfLengthPrefixedElements(signerBlocks),
                });
    }

    private static byte[] generateSignerBlock(
            SignerConfig signerConfig,
            Map<Integer, byte[]> contentDigests) throws InvalidKeyException, SignatureException {
        if (signerConfig.certificates.isEmpty()) {
            throw new SignatureException("No certificates configured for signer");
        }
        PublicKey publicKey = signerConfig.certificates.get(0).getPublicKey();

        byte[] encodedPublicKey = encodePublicKey(publicKey);

        V2SignatureSchemeBlock.SignedData signedData = new V2SignatureSchemeBlock.SignedData();
        try {
            signedData.certificates = encodeCertificates(signerConfig.certificates);
        } catch (CertificateEncodingException e) {
            throw new SignatureException("Failed to encode certificates", e);
        }

        List<Pair<Integer, byte[]>> digests =
                new ArrayList<>(signerConfig.signatureAlgorithms.size());
        for (int signatureAlgorithm : signerConfig.signatureAlgorithms) {
            int contentDigestAlgorithm =
                    getSignatureAlgorithmContentDigestAlgorithm(signatureAlgorithm);
            byte[] contentDigest = contentDigests.get(contentDigestAlgorithm);
            if (contentDigest == null) {
                throw new RuntimeException(
                        getContentDigestAlgorithmJcaDigestAlgorithm(contentDigestAlgorithm)
                        + " content digest for "
                        + getSignatureAlgorithmJcaSignatureAlgorithm(signatureAlgorithm)
                        + " not computed");
            }
            digests.add(Pair.create(signatureAlgorithm, contentDigest));
        }
        signedData.digests = digests;

        V2SignatureSchemeBlock.Signer signer = new V2SignatureSchemeBlock.Signer();
        // FORMAT:
        // * length-prefixed sequence of length-prefixed digests:
        //   * uint32: signature algorithm ID
        //   * length-prefixed bytes: digest of contents
        // * length-prefixed sequence of certificates:
        //   * length-prefixed bytes: X.509 certificate (ASN.1 DER encoded).
        // * length-prefixed sequence of length-prefixed additional attributes:
        //   * uint32: ID
        //   * (length - 4) bytes: value
        signer.signedData = encodeAsSequenceOfLengthPrefixedElements(new byte[][] {
            encodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(signedData.digests),
            encodeAsSequenceOfLengthPrefixedElements(signedData.certificates),
            // additional attributes
            new byte[0],
        });
        signer.publicKey = encodedPublicKey;
        signer.signatures = new ArrayList<>();
        for (int signatureAlgorithm : signerConfig.signatureAlgorithms) {
            Pair<String, ? extends AlgorithmParameterSpec> signatureParams =
                    getSignatureAlgorithmJcaSignatureAlgorithm(signatureAlgorithm);
            String jcaSignatureAlgorithm = signatureParams.getFirst();
            AlgorithmParameterSpec jcaSignatureAlgorithmParams = signatureParams.getSecond();
            byte[] signatureBytes;
            try {
                Signature signature = Signature.getInstance(jcaSignatureAlgorithm);
                signature.initSign(signerConfig.privateKey);
                if (jcaSignatureAlgorithmParams != null) {
                    signature.setParameter(jcaSignatureAlgorithmParams);
                }
                signature.update(signer.signedData);
                signatureBytes = signature.sign();
            } catch (InvalidKeyException e) {
                throw new InvalidKeyException("Failed sign using " + jcaSignatureAlgorithm, e);
            } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException
                    | SignatureException e) {
                throw new SignatureException("Failed sign using " + jcaSignatureAlgorithm, e);
            }

            try {
                Signature signature = Signature.getInstance(jcaSignatureAlgorithm);
                signature.initVerify(publicKey);
                if (jcaSignatureAlgorithmParams != null) {
                    signature.setParameter(jcaSignatureAlgorithmParams);
                }
                signature.update(signer.signedData);
                if (!signature.verify(signatureBytes)) {
                    throw new SignatureException("Signature did not verify");
                }
            } catch (InvalidKeyException e) {
                throw new InvalidKeyException("Failed to verify generated " + jcaSignatureAlgorithm
                        + " signature using public key from certificate", e);
            } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException
                    | SignatureException e) {
                throw new SignatureException("Failed to verify generated " + jcaSignatureAlgorithm
                        + " signature using public key from certificate", e);
            }

            signer.signatures.add(Pair.create(signatureAlgorithm, signatureBytes));
        }

        // FORMAT:
        // * length-prefixed signed data
        // * length-prefixed sequence of length-prefixed signatures:
        //   * uint32: signature algorithm ID
        //   * length-prefixed bytes: signature of signed data
        // * length-prefixed bytes: public key (X.509 SubjectPublicKeyInfo, ASN.1 DER encoded)
        return encodeAsSequenceOfLengthPrefixedElements(
                new byte[][] {
                    signer.signedData,
                    encodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(
                            signer.signatures),
                    signer.publicKey,
                });
    }

    private static final class V2SignatureSchemeBlock {
        private static final class Signer {
            public byte[] signedData;
            public List<Pair<Integer, byte[]>> signatures;
            public byte[] publicKey;
        }

        private static final class SignedData {
            public List<Pair<Integer, byte[]>> digests;
            public List<byte[]> certificates;
        }
    }

    private static byte[] encodePublicKey(PublicKey publicKey) throws InvalidKeyException {
        byte[] encodedPublicKey = null;
        if ("X.509".equals(publicKey.getFormat())) {
            encodedPublicKey = publicKey.getEncoded();
        }
        if (encodedPublicKey == null) {
            try {
                encodedPublicKey =
                        KeyFactory.getInstance(publicKey.getAlgorithm())
                                .getKeySpec(publicKey, X509EncodedKeySpec.class)
                                .getEncoded();
            } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
                throw new InvalidKeyException(
                        "Failed to obtain X.509 encoded form of public key " + publicKey
                                + " of class " + publicKey.getClass().getName(),
                        e);
            }
        }
        if ((encodedPublicKey == null) || (encodedPublicKey.length == 0)) {
            throw new InvalidKeyException(
                    "Failed to obtain X.509 encoded form of public key " + publicKey
                            + " of class " + publicKey.getClass().getName());
        }
        return encodedPublicKey;
    }

    public static List<byte[]> encodeCertificates(List<X509Certificate> certificates)
            throws CertificateEncodingException {
        List<byte[]> result = new ArrayList<>();
        for (X509Certificate certificate : certificates) {
            result.add(certificate.getEncoded());
        }
        return result;
    }

    private static byte[] encodeAsSequenceOfLengthPrefixedElements(List<byte[]> sequence) {
        return encodeAsSequenceOfLengthPrefixedElements(
                sequence.toArray(new byte[sequence.size()][]));
    }

    private static byte[] encodeAsSequenceOfLengthPrefixedElements(byte[][] sequence) {
        int payloadSize = 0;
        for (byte[] element : sequence) {
            payloadSize += 4 + element.length;
        }
        ByteBuffer result = ByteBuffer.allocate(payloadSize);
        result.order(ByteOrder.LITTLE_ENDIAN);
        for (byte[] element : sequence) {
            result.putInt(element.length);
            result.put(element);
        }
        return result.array();
      }

    private static byte[] encodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(
            List<Pair<Integer, byte[]>> sequence) {
        int resultSize = 0;
        for (Pair<Integer, byte[]> element : sequence) {
            resultSize += 12 + element.getSecond().length;
        }
        ByteBuffer result = ByteBuffer.allocate(resultSize);
        result.order(ByteOrder.LITTLE_ENDIAN);
        for (Pair<Integer, byte[]> element : sequence) {
            byte[] second = element.getSecond();
            result.putInt(8 + second.length);
            result.putInt(element.getFirst());
            result.putInt(second.length);
            result.put(second);
        }
        return result.array();
    }

    /**
     * Relative <em>get</em> method for reading {@code size} number of bytes from the current
     * position of this buffer.
     *
     * <p>This method reads the next {@code size} bytes at this buffer's current position,
     * returning them as a {@code ByteBuffer} with start set to 0, limit and capacity set to
     * {@code size}, byte order set to this buffer's byte order; and then increments the position by
     * {@code size}.
     */
    private static ByteBuffer getByteBuffer(ByteBuffer source, int size) {
        if (size < 0) {
            throw new IllegalArgumentException("size: " + size);
        }
        int originalLimit = source.limit();
        int position = source.position();
        int limit = position + size;
        if ((limit < position) || (limit > originalLimit)) {
            throw new BufferUnderflowException();
        }
        source.limit(limit);
        try {
            ByteBuffer result = source.slice();
            result.order(source.order());
            source.position(limit);
            return result;
        } finally {
            source.limit(originalLimit);
        }
    }

    private static Pair<String, ? extends AlgorithmParameterSpec>
            getSignatureAlgorithmJcaSignatureAlgorithm(int sigAlgorithm) {
        switch (sigAlgorithm) {
            case SIGNATURE_RSA_PSS_WITH_SHA256:
                return Pair.create(
                        "SHA256withRSA/PSS",
                        new PSSParameterSpec(
                                "SHA-256", "MGF1", MGF1ParameterSpec.SHA256, 256 / 8, 1));
            case SIGNATURE_RSA_PSS_WITH_SHA512:
                return Pair.create(
                        "SHA512withRSA/PSS",
                        new PSSParameterSpec(
                                "SHA-512", "MGF1", MGF1ParameterSpec.SHA512, 512 / 8, 1));
            case SIGNATURE_RSA_PKCS1_V1_5_WITH_SHA256:
                return Pair.create("SHA256withRSA", null);
            case SIGNATURE_RSA_PKCS1_V1_5_WITH_SHA512:
                return Pair.create("SHA512withRSA", null);
            case SIGNATURE_ECDSA_WITH_SHA256:
                return Pair.create("SHA256withECDSA", null);
            case SIGNATURE_ECDSA_WITH_SHA512:
                return Pair.create("SHA512withECDSA", null);
            case SIGNATURE_DSA_WITH_SHA256:
                return Pair.create("SHA256withDSA", null);
            case SIGNATURE_DSA_WITH_SHA512:
                return Pair.create("SHA512withDSA", null);
            default:
                throw new IllegalArgumentException(
                        "Unknown signature algorithm: 0x"
                                + Long.toHexString(sigAlgorithm & 0xffffffff));
        }
    }

    private static int getSignatureAlgorithmContentDigestAlgorithm(int sigAlgorithm) {
        switch (sigAlgorithm) {
            case SIGNATURE_RSA_PSS_WITH_SHA256:
            case SIGNATURE_RSA_PKCS1_V1_5_WITH_SHA256:
            case SIGNATURE_ECDSA_WITH_SHA256:
            case SIGNATURE_DSA_WITH_SHA256:
                return CONTENT_DIGEST_CHUNKED_SHA256;
            case SIGNATURE_RSA_PSS_WITH_SHA512:
            case SIGNATURE_RSA_PKCS1_V1_5_WITH_SHA512:
            case SIGNATURE_ECDSA_WITH_SHA512:
            case SIGNATURE_DSA_WITH_SHA512:
                return CONTENT_DIGEST_CHUNKED_SHA512;
            default:
                throw new IllegalArgumentException(
                        "Unknown signature algorithm: 0x"
                                + Long.toHexString(sigAlgorithm & 0xffffffff));
        }
    }

    private static String getContentDigestAlgorithmJcaDigestAlgorithm(int digestAlgorithm) {
        switch (digestAlgorithm) {
            case CONTENT_DIGEST_CHUNKED_SHA256:
                return "SHA-256";
            case CONTENT_DIGEST_CHUNKED_SHA512:
                return "SHA-512";
            default:
                throw new IllegalArgumentException(
                        "Unknown content digest algorithm: " + digestAlgorithm);
        }
    }

    private static int getContentDigestAlgorithmOutputSizeBytes(int digestAlgorithm) {
        switch (digestAlgorithm) {
            case CONTENT_DIGEST_CHUNKED_SHA256:
                return 256 / 8;
            case CONTENT_DIGEST_CHUNKED_SHA512:
                return 512 / 8;
            default:
                throw new IllegalArgumentException(
                        "Unknown content digest algorithm: " + digestAlgorithm);
        }
    }

    /**
     * Indicates that APK file could not be parsed.
     */
    public static class ApkParseException extends Exception {
        private static final long serialVersionUID = 1L;

        public ApkParseException(String message) {
            super(message);
        }

        public ApkParseException(String message, Throwable cause) {
            super(message, cause);
        }
    }

    /**
     * Pair of two elements.
     */
    private static class Pair<A, B> {
        private final A mFirst;
        private final B mSecond;

        private Pair(A first, B second) {
            mFirst = first;
            mSecond = second;
        }

        public static <A, B> Pair<A, B> create(A first, B second) {
            return new Pair<>(first, second);
        }

        public A getFirst() {
            return mFirst;
        }

        public B getSecond() {
            return mSecond;
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + ((mFirst == null) ? 0 : mFirst.hashCode());
            result = prime * result + ((mSecond == null) ? 0 : mSecond.hashCode());
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            @SuppressWarnings("rawtypes")
            Pair other = (Pair) obj;
            if (mFirst == null) {
                if (other.mFirst != null) {
                    return false;
                }
            } else if (!mFirst.equals(other.mFirst)) {
                return false;
            }
            if (mSecond == null) {
                return other.mSecond == null;
            } else return mSecond.equals(other.mSecond);
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/signing/ByteArrayStream.java`:

```java
package com.topjohnwu.magisk.core.signing;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;

public class ByteArrayStream extends ByteArrayOutputStream {

    public synchronized void readFrom(InputStream is) {
        readFrom(is, Integer.MAX_VALUE);
    }

    public synchronized void readFrom(InputStream is, int len) {
        int read;
        byte buffer[] = new byte[4096];
        try {
            while ((read = is.read(buffer, 0, Math.min(len, buffer.length))) > 0) {
                write(buffer, 0, read);
                len -= read;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public ByteArrayInputStream getInputStream() {
        return new ByteArrayInputStream(buf, 0, count);
    }

    public ByteBuffer toByteBuffer() {
        return ByteBuffer.wrap(buf, 0, count);
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/signing/JarMap.java`:

```java
package com.topjohnwu.magisk.core.signing;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Collections;
import java.util.Enumeration;
import java.util.LinkedHashMap;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarInputStream;
import java.util.jar.Manifest;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public abstract class JarMap implements Closeable {

    LinkedHashMap<String, JarEntry> entryMap;

    public static JarMap open(File file, boolean verify) throws IOException {
        return new FileMap(file, verify, ZipFile.OPEN_READ);
    }

    public static JarMap open(InputStream is, boolean verify) throws IOException {
        return new StreamMap(is, verify);
    }

    public File getFile() {
        return null;
    }

    public abstract Manifest getManifest() throws IOException;

    public InputStream getInputStream(ZipEntry ze) throws IOException {
        JarMapEntry e = getMapEntry(ze.getName());
        return e != null ? e.data.getInputStream() : null;
    }

    public OutputStream getOutputStream(ZipEntry ze) {
        if (entryMap == null)
            entryMap = new LinkedHashMap<>();
        JarMapEntry e = new JarMapEntry(ze.getName());
        entryMap.put(ze.getName(), e);
        return e.data;
    }

    public byte[] getRawData(ZipEntry ze) throws IOException {
        JarMapEntry e = getMapEntry(ze.getName());
        return e != null ? e.data.toByteArray() : null;
    }

    public abstract Enumeration<JarEntry> entries();

    public final ZipEntry getEntry(String name) {
        return getJarEntry(name);
    }

    public JarEntry getJarEntry(String name) {
        return getMapEntry(name);
    }

    JarMapEntry getMapEntry(String name) {
        JarMapEntry e = null;
        if (entryMap != null)
            e = (JarMapEntry) entryMap.get(name);
        return e;
    }

    private static class FileMap extends JarMap {

        private JarFile jarFile;

        FileMap(File file, boolean verify, int mode) throws IOException {
            jarFile = new JarFile(file, verify, mode);
        }

        @Override
        public File getFile() {
            return new File(jarFile.getName());
        }

        @Override
        public Manifest getManifest() throws IOException {
            return jarFile.getManifest();
        }

        @Override
        public InputStream getInputStream(ZipEntry ze) throws IOException {
            InputStream is = super.getInputStream(ze);
            return is != null ? is : jarFile.getInputStream(ze);
        }

        @Override
        public byte[] getRawData(ZipEntry ze) throws IOException {
            byte[] b = super.getRawData(ze);
            if (b != null)
                return b;
            ByteArrayStream bytes = new ByteArrayStream();
            bytes.readFrom(jarFile.getInputStream(ze));
            return bytes.toByteArray();
        }

        @Override
        public Enumeration<JarEntry> entries() {
            return jarFile.entries();
        }

        @Override
        public JarEntry getJarEntry(String name) {
            JarEntry e = getMapEntry(name);
            return e != null ? e : jarFile.getJarEntry(name);
        }

        @Override
        public void close() throws IOException {
            jarFile.close();
        }
    }

    private static class StreamMap extends JarMap {

        private JarInputStream jis;

        StreamMap(InputStream is, boolean verify) throws IOException {
            jis = new JarInputStream(is, verify);
            entryMap = new LinkedHashMap<>();
            JarEntry entry;
            while ((entry = jis.getNextJarEntry()) != null) {
                entryMap.put(entry.getName(), new JarMapEntry(entry, jis));
            }
        }

        @Override
        public Manifest getManifest() {
            return jis.getManifest();
        }

        @Override
        public Enumeration<JarEntry> entries() {
            return Collections.enumeration(entryMap.values());
        }

        @Override
        public void close() throws IOException {
            jis.close();
        }
    }

    private static class JarMapEntry extends JarEntry {

        ByteArrayStream data;

        JarMapEntry(JarEntry je, InputStream is) {
            super(je);
            data = new ByteArrayStream();
            data.readFrom(is);
        }

        JarMapEntry(String s) {
            super(s);
            data = new ByteArrayStream();
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/signing/SignApk.java`:

```java
package com.topjohnwu.magisk.core.signing;

import org.bouncycastle.asn1.ASN1Encoding;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1OutputStream;
import org.bouncycastle.cert.jcajce.JcaCertStore;
import org.bouncycastle.cms.CMSException;
import org.bouncycastle.cms.CMSProcessableByteArray;
import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.cms.CMSSignedDataGenerator;
import org.bouncycastle.cms.CMSTypedData;
import org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder;
import org.bouncycastle.util.encoders.Base64;

import java.io.ByteArrayOutputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.nio.ByteBuffer;
import java.security.DigestOutputStream;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.CertificateEncodingException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;
import java.util.TreeMap;
import java.util.jar.Attributes;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
import java.util.regex.Pattern;

/*
 * Modified from AOSP
 * https://android.googlesource.com/platform/build/+/refs/tags/android-7.1.2_r39/tools/signapk/src/com/android/signapk/SignApk.java
 * */

public class SignApk {
    private static final String CERT_SF_NAME = "META-INF/CERT.SF";
    private static final String CERT_SIG_NAME = "META-INF/CERT.%s";
    private static final String CERT_SF_MULTI_NAME = "META-INF/CERT%d.SF";
    private static final String CERT_SIG_MULTI_NAME = "META-INF/CERT%d.%s";

    // bitmasks for which hash algorithms we need the manifest to include.
    private static final int USE_SHA1 = 1;
    private static final int USE_SHA256 = 2;

    /**
     * Digest algorithm used when signing the APK using APK Signature Scheme v2.
     */
    private static final String APK_SIG_SCHEME_V2_DIGEST_ALGORITHM = "SHA-256";
    // Files matching this pattern are not copied to the output.
    private static final Pattern stripPattern =
            Pattern.compile("^(META-INF/((.*)[.](SF|RSA|DSA|EC)|com/android/otacert))|(" +
                    Pattern.quote(JarFile.MANIFEST_NAME) + ")$");

    /**
     * Return one of USE_SHA1 or USE_SHA256 according to the signature
     * algorithm specified in the cert.
     */
    private static int getDigestAlgorithm(X509Certificate cert) {
        String sigAlg = cert.getSigAlgName().toUpperCase(Locale.US);
        if ("SHA1WITHRSA".equals(sigAlg) || "MD5WITHRSA".equals(sigAlg)) {
            return USE_SHA1;
        } else if (sigAlg.startsWith("SHA256WITH")) {
            return USE_SHA256;
        } else {
            throw new IllegalArgumentException("unsupported signature algorithm \"" + sigAlg +
                    "\" in cert [" + cert.getSubjectDN());
        }
    }

    /**
     * Returns the expected signature algorithm for this key type.
     */
    private static String getSignatureAlgorithm(X509Certificate cert) {
        String keyType = cert.getPublicKey().getAlgorithm().toUpperCase(Locale.US);
        if ("RSA".equalsIgnoreCase(keyType)) {
            if (getDigestAlgorithm(cert) == USE_SHA256) {
                return "SHA256withRSA";
            } else {
                return "SHA1withRSA";
            }
        } else if ("EC".equalsIgnoreCase(keyType)) {
            return "SHA256withECDSA";
        } else {
            throw new IllegalArgumentException("unsupported key type: " + keyType);
        }
    }

    /**
     * Add the hash(es) of every file to the manifest, creating it if
     * necessary.
     */
    private static Manifest addDigestsToManifest(JarMap jar, int hashes)
            throws IOException, GeneralSecurityException {
        Manifest input = jar.getManifest();
        Manifest output = new Manifest();
        Attributes main = output.getMainAttributes();
        if (input != null) {
            main.putAll(input.getMainAttributes());
        } else {
            main.putValue("Manifest-Version", "1.0");
            main.putValue("Created-By", "1.0 (Android SignApk)");
        }

        MessageDigest md_sha1 = null;
        MessageDigest md_sha256 = null;
        if ((hashes & USE_SHA1) != 0) {
            md_sha1 = MessageDigest.getInstance("SHA1");
        }
        if ((hashes & USE_SHA256) != 0) {
            md_sha256 = MessageDigest.getInstance("SHA256");
        }

        byte[] buffer = new byte[4096];
        int num;

        // We sort the input entries by name, and add them to the
        // output manifest in sorted order.  We expect that the output
        // map will be deterministic.

        TreeMap<String, JarEntry> byName = new TreeMap<>();

        for (Enumeration<JarEntry> e = jar.entries(); e.hasMoreElements(); ) {
            JarEntry entry = e.nextElement();
            byName.put(entry.getName(), entry);
        }

        for (JarEntry entry : byName.values()) {
            String name = entry.getName();
            if (!entry.isDirectory() && !stripPattern.matcher(name).matches()) {
                InputStream data = jar.getInputStream(entry);
                while ((num = data.read(buffer)) > 0) {
                    if (md_sha1 != null) md_sha1.update(buffer, 0, num);
                    if (md_sha256 != null) md_sha256.update(buffer, 0, num);
                }

                Attributes attr = null;
                if (input != null) attr = input.getAttributes(name);
                attr = attr != null ? new Attributes(attr) : new Attributes();
                // Remove any previously computed digests from this entry's attributes.
                for (Iterator<Object> i = attr.keySet().iterator(); i.hasNext(); ) {
                    Object key = i.next();
                    if (!(key instanceof Attributes.Name)) {
                        continue;
                    }
                    String attributeNameLowerCase =
                            key.toString().toLowerCase(Locale.US);
                    if (attributeNameLowerCase.endsWith("-digest")) {
                        i.remove();
                    }
                }
                // Add SHA-1 digest if requested
                if (md_sha1 != null) {
                    attr.putValue("SHA1-Digest",
                            new String(Base64.encode(md_sha1.digest()), "ASCII"));
                }
                // Add SHA-256 digest if requested
                if (md_sha256 != null) {
                    attr.putValue("SHA-256-Digest",
                            new String(Base64.encode(md_sha256.digest()), "ASCII"));
                }
                output.getEntries().put(name, attr);
            }
        }

        return output;
    }

    /**
     * Write a .SF file with a digest of the specified manifest.
     */
    private static void writeSignatureFile(Manifest manifest, OutputStream out,
                                           int hash)
            throws IOException, GeneralSecurityException {
        Manifest sf = new Manifest();
        Attributes main = sf.getMainAttributes();
        main.putValue("Signature-Version", "1.0");
        main.putValue("Created-By", "1.0 (Android SignApk)");
        // Add APK Signature Scheme v2 signature stripping protection.
        // This attribute indicates that this APK is supposed to have been signed using one or
        // more APK-specific signature schemes in addition to the standard JAR signature scheme
        // used by this code. APK signature verifier should reject the APK if it does not
        // contain a signature for the signature scheme the verifier prefers out of this set.
        main.putValue(
                ApkSignerV2.SF_ATTRIBUTE_ANDROID_APK_SIGNED_NAME,
                ApkSignerV2.SF_ATTRIBUTE_ANDROID_APK_SIGNED_VALUE);

        MessageDigest md = MessageDigest.getInstance(hash == USE_SHA256 ? "SHA256" : "SHA1");
        PrintStream print = new PrintStream(new DigestOutputStream(new ByteArrayOutputStream(), md),
                true, "UTF-8");

        // Digest of the entire manifest
        manifest.write(print);
        print.flush();
        main.putValue(hash == USE_SHA256 ? "SHA-256-Digest-Manifest" : "SHA1-Digest-Manifest",
                new String(Base64.encode(md.digest()), "ASCII"));

        Map<String, Attributes> entries = manifest.getEntries();
        for (Map.Entry<String, Attributes> entry : entries.entrySet()) {
            // Digest of the manifest stanza for this entry.
            print.print("Name: " + entry.getKey() + "\r\n");
            for (Map.Entry<Object, Object> att : entry.getValue().entrySet()) {
                print.print(att.getKey() + ": " + att.getValue() + "\r\n");
            }
            print.print("\r\n");
            print.flush();

            Attributes sfAttr = new Attributes();
            sfAttr.putValue(hash == USE_SHA256 ? "SHA-256-Digest" : "SHA1-Digest",
                    new String(Base64.encode(md.digest()), "ASCII"));
            sf.getEntries().put(entry.getKey(), sfAttr);
        }

        CountOutputStream cout = new CountOutputStream(out);
        sf.write(cout);

        // A bug in the java.util.jar implementation of Android platforms
        // up to version 1.6 will cause a spurious IOException to be thrown
        // if the length of the signature file is a multiple of 1024 bytes.
        // As a workaround, add an extra CRLF in this case.
        if ((cout.size() % 1024) == 0) {
            cout.write('\r');
            cout.write('\n');
        }
    }

    /**
     * Sign data and write the digital signature to 'out'.
     */
    private static void writeSignatureBlock(
            CMSTypedData data, X509Certificate publicKey, PrivateKey privateKey, OutputStream out)
            throws IOException,
            CertificateEncodingException,
            OperatorCreationException,
            CMSException {
        ArrayList<X509Certificate> certList = new ArrayList<>(1);
        certList.add(publicKey);
        JcaCertStore certs = new JcaCertStore(certList);

        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
        ContentSigner signer = new JcaContentSignerBuilder(getSignatureAlgorithm(publicKey))
                .build(privateKey);
        gen.addSignerInfoGenerator(
                new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().build())
                        .setDirectSignature(true)
                        .build(signer, publicKey)
        );
        gen.addCertificates(certs);
        CMSSignedData sigData = gen.generate(data, false);

        try (ASN1InputStream asn1 = new ASN1InputStream(sigData.getEncoded())) {
            ASN1OutputStream dos = ASN1OutputStream.create(out, ASN1Encoding.DER);
            dos.writeObject(asn1.readObject());
        }
    }

    /**
     * Copy all the files in a manifest from input to output.  We set
     * the modification times in the output to a fixed time, so as to
     * reduce variation in the output file and make incremental OTAs
     * more efficient.
     */
    private static void copyFiles(Manifest manifest, JarMap in, JarOutputStream out,
                                  long timestamp, int defaultAlignment) throws IOException {
        byte[] buffer = new byte[4096];
        int num;

        Map<String, Attributes> entries = manifest.getEntries();
        ArrayList<String> names = new ArrayList<>(entries.keySet());
        Collections.sort(names);

        boolean firstEntry = true;
        long offset = 0L;

        // We do the copy in two passes -- first copying all the
        // entries that are STORED, then copying all the entries that
        // have any other compression flag (which in practice means
        // DEFLATED).  This groups all the stored entries together at
        // the start of the file and makes it easier to do alignment
        // on them (since only stored entries are aligned).

        for (String name : names) {
            JarEntry inEntry = in.getJarEntry(name);
            JarEntry outEntry;
            if (inEntry.getMethod() != JarEntry.STORED) continue;
            // Preserve the STORED method of the input entry.
            outEntry = new JarEntry(inEntry);
            outEntry.setTime(timestamp);
            // Discard comment and extra fields of this entry to
            // simplify alignment logic below and for consistency with
            // how compressed entries are handled later.
            outEntry.setComment(null);
            outEntry.setExtra(null);

            // 'offset' is the offset into the file at which we expect
            // the file data to begin.  This is the value we need to
            // make a multiple of 'alignement'.
            offset += JarFile.LOCHDR + outEntry.getName().length();
            if (firstEntry) {
                // The first entry in a jar file has an extra field of
                // four bytes that you can't get rid of; any extra
                // data you specify in the JarEntry is appended to
                // these forced four bytes.  This is JAR_MAGIC in
                // JarOutputStream; the bytes are 0xfeca0000.
                offset += 4;
                firstEntry = false;
            }
            int alignment = getStoredEntryDataAlignment(name, defaultAlignment);
            if (alignment > 0 && (offset % alignment != 0)) {
                // Set the "extra data" of the entry to between 1 and
                // alignment-1 bytes, to make the file data begin at
                // an aligned offset.
                int needed = alignment - (int) (offset % alignment);
                outEntry.setExtra(new byte[needed]);
                offset += needed;
            }

            out.putNextEntry(outEntry);

            InputStream data = in.getInputStream(inEntry);
            while ((num = data.read(buffer)) > 0) {
                out.write(buffer, 0, num);
                offset += num;
            }
            out.flush();
        }

        // Copy all the non-STORED entries.  We don't attempt to
        // maintain the 'offset' variable past this point; we don't do
        // alignment on these entries.

        for (String name : names) {
            JarEntry inEntry = in.getJarEntry(name);
            JarEntry outEntry;
            if (inEntry.getMethod() == JarEntry.STORED) continue;
            // Create a new entry so that the compressed len is recomputed.
            outEntry = new JarEntry(name);
            outEntry.setTime(timestamp);
            out.putNextEntry(outEntry);

            InputStream data = in.getInputStream(inEntry);
            while ((num = data.read(buffer)) > 0) {
                out.write(buffer, 0, num);
            }
            out.flush();
        }
    }

    /**
     * Returns the multiple (in bytes) at which the provided {@code STORED} entry's data must start
     * relative to start of file or {@code 0} if alignment of this entry's data is not important.
     */
    private static int getStoredEntryDataAlignment(String entryName, int defaultAlignment) {
        if (defaultAlignment <= 0) {
            return 0;
        }

        if (entryName.endsWith(".so")) {
            // Align .so contents to memory page boundary to enable memory-mapped
            // execution.
            return 4096;
        } else {
            return defaultAlignment;
        }
    }

    private static void signFile(Manifest manifest,
                                 X509Certificate[] publicKey, PrivateKey[] privateKey,
                                 long timestamp, JarOutputStream outputJar) throws Exception {
        // MANIFEST.MF
        JarEntry je = new JarEntry(JarFile.MANIFEST_NAME);
        je.setTime(timestamp);
        outputJar.putNextEntry(je);
        manifest.write(outputJar);

        int numKeys = publicKey.length;
        for (int k = 0; k < numKeys; ++k) {
            // CERT.SF / CERT#.SF
            je = new JarEntry(numKeys == 1 ? CERT_SF_NAME :
                    (String.format(Locale.US, CERT_SF_MULTI_NAME, k)));
            je.setTime(timestamp);
            outputJar.putNextEntry(je);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            writeSignatureFile(manifest, baos, getDigestAlgorithm(publicKey[k]));
            byte[] signedData = baos.toByteArray();
            outputJar.write(signedData);

            // CERT.{EC,RSA} / CERT#.{EC,RSA}
            final String keyType = publicKey[k].getPublicKey().getAlgorithm();
            je = new JarEntry(numKeys == 1 ? (String.format(CERT_SIG_NAME, keyType)) :
                    (String.format(Locale.US, CERT_SIG_MULTI_NAME, k, keyType)));
            je.setTime(timestamp);
            outputJar.putNextEntry(je);
            writeSignatureBlock(new CMSProcessableByteArray(signedData),
                    publicKey[k], privateKey[k], outputJar);
        }
    }

    /**
     * Converts the provided lists of private keys, their X.509 certificates, and digest algorithms
     * into a list of APK Signature Scheme v2 {@code SignerConfig} instances.
     */
    private static List<ApkSignerV2.SignerConfig> createV2SignerConfigs(
            PrivateKey[] privateKeys, X509Certificate[] certificates, String[] digestAlgorithms)
            throws InvalidKeyException {
        if (privateKeys.length != certificates.length) {
            throw new IllegalArgumentException(
                    "The number of private keys must match the number of certificates: "
                            + privateKeys.length + " vs" + certificates.length);
        }
        List<ApkSignerV2.SignerConfig> result = new ArrayList<>(privateKeys.length);
        for (int i = 0; i < privateKeys.length; i++) {
            PrivateKey privateKey = privateKeys[i];
            X509Certificate certificate = certificates[i];
            PublicKey publicKey = certificate.getPublicKey();
            String keyAlgorithm = privateKey.getAlgorithm();
            if (!keyAlgorithm.equalsIgnoreCase(publicKey.getAlgorithm())) {
                throw new InvalidKeyException(
                        "Key algorithm of private key #" + (i + 1) + " does not match key"
                                + " algorithm of public key #" + (i + 1) + ": " + keyAlgorithm
                                + " vs " + publicKey.getAlgorithm());
            }
            ApkSignerV2.SignerConfig signerConfig = new ApkSignerV2.SignerConfig();
            signerConfig.privateKey = privateKey;
            signerConfig.certificates = Collections.singletonList(certificate);
            List<Integer> signatureAlgorithms = new ArrayList<>(digestAlgorithms.length);
            for (String digestAlgorithm : digestAlgorithms) {
                try {
                    signatureAlgorithms.add(getV2SignatureAlgorithm(keyAlgorithm, digestAlgorithm));
                } catch (IllegalArgumentException e) {
                    throw new InvalidKeyException(
                            "Unsupported key and digest algorithm combination for signer #"
                                    + (i + 1), e);
                }
            }
            signerConfig.signatureAlgorithms = signatureAlgorithms;
            result.add(signerConfig);
        }
        return result;
    }

    private static int getV2SignatureAlgorithm(String keyAlgorithm, String digestAlgorithm) {
        if ("SHA-256".equalsIgnoreCase(digestAlgorithm)) {
            if ("RSA".equalsIgnoreCase(keyAlgorithm)) {
                // Use RSASSA-PKCS1-v1_5 signature scheme instead of RSASSA-PSS to guarantee
                // deterministic signatures which make life easier for OTA updates (fewer files
                // changed when deterministic signature schemes are used).
                return ApkSignerV2.SIGNATURE_RSA_PKCS1_V1_5_WITH_SHA256;
            } else if ("EC".equalsIgnoreCase(keyAlgorithm)) {
                return ApkSignerV2.SIGNATURE_ECDSA_WITH_SHA256;
            } else if ("DSA".equalsIgnoreCase(keyAlgorithm)) {
                return ApkSignerV2.SIGNATURE_DSA_WITH_SHA256;
            } else {
                throw new IllegalArgumentException("Unsupported key algorithm: " + keyAlgorithm);
            }
        } else if ("SHA-512".equalsIgnoreCase(digestAlgorithm)) {
            if ("RSA".equalsIgnoreCase(keyAlgorithm)) {
                // Use RSASSA-PKCS1-v1_5 signature scheme instead of RSASSA-PSS to guarantee
                // deterministic signatures which make life easier for OTA updates (fewer files
                // changed when deterministic signature schemes are used).
                return ApkSignerV2.SIGNATURE_RSA_PKCS1_V1_5_WITH_SHA512;
            } else if ("EC".equalsIgnoreCase(keyAlgorithm)) {
                return ApkSignerV2.SIGNATURE_ECDSA_WITH_SHA512;
            } else if ("DSA".equalsIgnoreCase(keyAlgorithm)) {
                return ApkSignerV2.SIGNATURE_DSA_WITH_SHA512;
            } else {
                throw new IllegalArgumentException("Unsupported key algorithm: " + keyAlgorithm);
            }
        } else {
            throw new IllegalArgumentException("Unsupported digest algorithm: " + digestAlgorithm);
        }
    }

    public static void sign(X509Certificate cert, PrivateKey key,
                            JarMap inputJar, OutputStream outputStream) throws Exception {
        int alignment = 4;
        int hashes = 0;

        X509Certificate[] publicKey = new X509Certificate[1];
        publicKey[0] = cert;
        hashes |= getDigestAlgorithm(publicKey[0]);

        // Set all ZIP file timestamps to Jan 1 2009 00:00:00.
        long timestamp = 1230768000000L;
        // The Java ZipEntry API we're using converts milliseconds since epoch into MS-DOS
        // timestamp using the current timezone. We thus adjust the milliseconds since epoch
        // value to end up with MS-DOS timestamp of Jan 1 2009 00:00:00.
        timestamp -= TimeZone.getDefault().getOffset(timestamp);

        PrivateKey[] privateKey = new PrivateKey[1];
        privateKey[0] = key;

        // Generate, in memory, an APK signed using standard JAR Signature Scheme.
        ByteArrayStream v1SignedApkBuf = new ByteArrayStream();
        JarOutputStream outputJar = new JarOutputStream(v1SignedApkBuf);
        // Use maximum compression for compressed entries because the APK lives forever on
        // the system partition.
        outputJar.setLevel(9);
        Manifest manifest = addDigestsToManifest(inputJar, hashes);
        copyFiles(manifest, inputJar, outputJar, timestamp, alignment);
        signFile(manifest, publicKey, privateKey, timestamp, outputJar);
        outputJar.close();
        ByteBuffer v1SignedApk = v1SignedApkBuf.toByteBuffer();

        ByteBuffer[] outputChunks;
        List<ApkSignerV2.SignerConfig> signerConfigs = createV2SignerConfigs(privateKey, publicKey,
                new String[]{APK_SIG_SCHEME_V2_DIGEST_ALGORITHM});
        outputChunks = ApkSignerV2.sign(v1SignedApk, signerConfigs);

        // This assumes outputChunks are array-backed. To avoid this assumption, the
        // code could be rewritten to use FileChannel.
        for (ByteBuffer outputChunk : outputChunks) {
            outputStream.write(outputChunk.array(),
                    outputChunk.arrayOffset() + outputChunk.position(), outputChunk.remaining());
            outputChunk.position(outputChunk.limit());
        }
    }

    /**
     * Write to another stream and track how many bytes have been
     * written.
     */
    private static class CountOutputStream extends FilterOutputStream {
        private int mCount;

        public CountOutputStream(OutputStream out) {
            super(out);
            mCount = 0;
        }

        @Override
        public void write(int b) throws IOException {
            super.write(b);
            mCount++;
        }

        @Override
        public void write(byte[] b, int off, int len) throws IOException {
            super.write(b, off, len);
            mCount += len;
        }

        public int size() {
            return mCount;
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/signing/ZipUtils.java`:

```java
package com.topjohnwu.magisk.core.signing;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Assorted ZIP format helpers.
 *
 * <p>NOTE: Most helper methods operating on {@code ByteBuffer} instances expect that the byte
 * order of these buffers is little-endian.
 */
public abstract class ZipUtils {

    private static final int ZIP_EOCD_REC_MIN_SIZE = 22;
    private static final int ZIP_EOCD_REC_SIG = 0x06054b50;
    private static final int ZIP_EOCD_CENTRAL_DIR_SIZE_FIELD_OFFSET = 12;
    private static final int ZIP_EOCD_CENTRAL_DIR_OFFSET_FIELD_OFFSET = 16;
    private static final int ZIP_EOCD_COMMENT_LENGTH_FIELD_OFFSET = 20;

    private static final int ZIP64_EOCD_LOCATOR_SIZE = 20;
    private static final int ZIP64_EOCD_LOCATOR_SIG = 0x07064b50;

    private static final int UINT16_MAX_VALUE = 0xffff;

    private ZipUtils() {
    }

    /**
     * Returns the position at which ZIP End of Central Directory record starts in the provided
     * buffer or {@code -1} if the record is not present.
     *
     * <p>NOTE: Byte order of {@code zipContents} must be little-endian.
     */
    public static int findZipEndOfCentralDirectoryRecord(ByteBuffer zipContents) {
        assertByteOrderLittleEndian(zipContents);

        // ZIP End of Central Directory (EOCD) record is located at the very end of the ZIP archive.
        // The record can be identified by its 4-byte signature/magic which is located at the very
        // beginning of the record. A complication is that the record is variable-length because of
        // the comment field.
        // The algorithm for locating the ZIP EOCD record is as follows. We search backwards from
        // end of the buffer for the EOCD record signature. Whenever we find a signature, we check
        // the candidate record's comment length is such that the remainder of the record takes up
        // exactly the remaining bytes in the buffer. The search is bounded because the maximum
        // size of the comment field is 65535 bytes because the field is an unsigned 16-bit number.

        int archiveSize = zipContents.capacity();
        if (archiveSize < ZIP_EOCD_REC_MIN_SIZE) {
            return -1;
        }
        int maxCommentLength = Math.min(archiveSize - ZIP_EOCD_REC_MIN_SIZE, UINT16_MAX_VALUE);
        int eocdWithEmptyCommentStartPosition = archiveSize - ZIP_EOCD_REC_MIN_SIZE;
        for (int expectedCommentLength = 0; expectedCommentLength < maxCommentLength; expectedCommentLength++) {
            int eocdStartPos = eocdWithEmptyCommentStartPosition - expectedCommentLength;
            if (zipContents.getInt(eocdStartPos) == ZIP_EOCD_REC_SIG) {
                int actualCommentLength = getUnsignedInt16(zipContents, eocdStartPos + ZIP_EOCD_COMMENT_LENGTH_FIELD_OFFSET);
                if (actualCommentLength == expectedCommentLength) {
                    return eocdStartPos;
                }
            }
        }

        return -1;
    }

    /**
     * Returns {@code true} if the provided buffer contains a ZIP64 End of Central Directory
     * Locator.
     *
     * <p>NOTE: Byte order of {@code zipContents} must be little-endian.
     */
    public static boolean isZip64EndOfCentralDirectoryLocatorPresent(ByteBuffer zipContents, int zipEndOfCentralDirectoryPosition) {
        assertByteOrderLittleEndian(zipContents);

        // ZIP64 End of Central Directory Locator immediately precedes the ZIP End of Central
        // Directory Record.

        int locatorPosition = zipEndOfCentralDirectoryPosition - ZIP64_EOCD_LOCATOR_SIZE;
        if (locatorPosition < 0) {
            return false;
        }

        return zipContents.getInt(locatorPosition) == ZIP64_EOCD_LOCATOR_SIG;
    }

    /**
     * Returns the offset of the start of the ZIP Central Directory in the archive.
     *
     * <p>NOTE: Byte order of {@code zipEndOfCentralDirectory} must be little-endian.
     */
    public static long getZipEocdCentralDirectoryOffset(ByteBuffer zipEndOfCentralDirectory) {
        assertByteOrderLittleEndian(zipEndOfCentralDirectory);
        return getUnsignedInt32(zipEndOfCentralDirectory, zipEndOfCentralDirectory.position() + ZIP_EOCD_CENTRAL_DIR_OFFSET_FIELD_OFFSET);
    }

    /**
     * Sets the offset of the start of the ZIP Central Directory in the archive.
     *
     * <p>NOTE: Byte order of {@code zipEndOfCentralDirectory} must be little-endian.
     */
    public static void setZipEocdCentralDirectoryOffset(ByteBuffer zipEndOfCentralDirectory, long offset) {
        assertByteOrderLittleEndian(zipEndOfCentralDirectory);
        setUnsignedInt32(zipEndOfCentralDirectory, zipEndOfCentralDirectory.position() + ZIP_EOCD_CENTRAL_DIR_OFFSET_FIELD_OFFSET, offset);
    }

    /**
     * Returns the size (in bytes) of the ZIP Central Directory.
     *
     * <p>NOTE: Byte order of {@code zipEndOfCentralDirectory} must be little-endian.
     */
    public static long getZipEocdCentralDirectorySizeBytes(ByteBuffer zipEndOfCentralDirectory) {
        assertByteOrderLittleEndian(zipEndOfCentralDirectory);
        return getUnsignedInt32(zipEndOfCentralDirectory, zipEndOfCentralDirectory.position() + ZIP_EOCD_CENTRAL_DIR_SIZE_FIELD_OFFSET);
    }

    private static void assertByteOrderLittleEndian(ByteBuffer buffer) {
        if (buffer.order() != ByteOrder.LITTLE_ENDIAN) {
            throw new IllegalArgumentException("ByteBuffer byte order must be little endian");
        }
    }

    private static int getUnsignedInt16(ByteBuffer buffer, int offset) {
        return buffer.getShort(offset) & 0xffff;
    }

    private static long getUnsignedInt32(ByteBuffer buffer, int offset) {
        return buffer.getInt(offset) & 0xffffffffL;
    }

    private static void setUnsignedInt32(ByteBuffer buffer, int offset, long value) {
        if ((value < 0) || (value > 0xffffffffL)) {
            throw new IllegalArgumentException("uint32 value of out range: " + value);
        }
        buffer.putInt(buffer.position() + offset, (int) value);
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/su/SuCallbackHandler.kt`:

```kt
package com.topjohnwu.magisk.core.su

import android.content.Context
import android.os.Bundle
import android.widget.Toast
import com.topjohnwu.magisk.core.BuildConfig
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.core.ktx.getLabel
import com.topjohnwu.magisk.core.ktx.getPackageInfo
import com.topjohnwu.magisk.core.ktx.toast
import com.topjohnwu.magisk.core.model.su.SuPolicy
import com.topjohnwu.magisk.core.model.su.createSuLog
import kotlinx.coroutines.runBlocking
import timber.log.Timber

object SuCallbackHandler {

    const val REQUEST = "request"
    const val LOG = "log"
    const val NOTIFY = "notify"

    fun run(context: Context, action: String?, data: Bundle?) {
        data ?: return

        // Debug messages
        if (BuildConfig.DEBUG) {
            Timber.d(action)
            data.let { bundle ->
                bundle.keySet().forEach {
                    Timber.d("[%s]=[%s]", it, bundle[it])
                }
            }
        }

        when (action) {
            LOG -> handleLogging(context, data)
            NOTIFY -> handleNotify(context, data)
        }
    }

    // https://android.googlesource.com/platform/frameworks/base/+/547bf5487d52b93c9fe183aa6d56459c170b17a4
    private fun Bundle.getIntComp(key: String, defaultValue: Int): Int {
        val value = get(key) ?: return defaultValue
        return when (value) {
            is Int -> value
            is Long -> value.toInt()
            else -> defaultValue
        }
    }

    private fun handleLogging(context: Context, data: Bundle) {
        val fromUid = data.getIntComp("from.uid", -1)
        val notify = data.getBoolean("notify", true)
        val policy = data.getIntComp("policy", SuPolicy.ALLOW)
        val toUid = data.getIntComp("to.uid", -1)
        val pid = data.getIntComp("pid", -1)
        val command = data.getString("command", "")
        val target = data.getIntComp("target", -1)
        val seContext = data.getString("context", "")
        val gids = data.getString("gids", "")

        val pm = context.packageManager

        val log = runCatching {
            pm.getPackageInfo(fromUid, pid)?.applicationInfo?.let {
                pm.createSuLog(it, toUid, pid, command, policy, target, seContext, gids)
            }
        }.getOrNull() ?: createSuLog(fromUid, toUid, pid, command, policy, target, seContext, gids)

        if (notify)
            notify(context, log.action >= SuPolicy.ALLOW, log.appName)

        runBlocking { ServiceLocator.logRepo.insert(log) }
    }

    private fun handleNotify(context: Context, data: Bundle) {
        val uid = data.getIntComp("from.uid", -1)
        val pid = data.getIntComp("pid", -1)
        val policy = data.getIntComp("policy", SuPolicy.ALLOW)

        val pm = context.packageManager

        val appName = runCatching {
            pm.getPackageInfo(uid, pid)?.applicationInfo?.getLabel(pm)
        }.getOrNull() ?: "[UID] $uid"

        notify(context, policy >= SuPolicy.ALLOW, appName)
    }

    private fun notify(context: Context, granted: Boolean, appName: String) {
        if (Config.suNotification == Config.Value.NOTIFICATION_TOAST) {
            val resId = if (granted)
                R.string.su_allow_toast
            else
                R.string.su_deny_toast

            context.toast(context.getString(resId, appName), Toast.LENGTH_SHORT)
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/su/SuRequestHandler.kt`:

```kt
package com.topjohnwu.magisk.core.su

import android.content.Intent
import android.content.pm.PackageInfo
import android.content.pm.PackageManager
import com.topjohnwu.magisk.core.BuildConfig
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.data.magiskdb.PolicyDao
import com.topjohnwu.magisk.core.ktx.getPackageInfo
import com.topjohnwu.magisk.core.model.su.SuPolicy
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.io.DataOutputStream
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.util.concurrent.TimeUnit

class SuRequestHandler(
    val pm: PackageManager,
    private val policyDB: PolicyDao
) {

    private lateinit var output: File
    private lateinit var policy: SuPolicy
    lateinit var pkgInfo: PackageInfo
        private set

    // Return true to indicate undetermined policy, require user interaction
    suspend fun start(intent: Intent): Boolean {
        if (!init(intent))
            return false

        // Never allow com.topjohnwu.magisk (could be malware)
        if (pkgInfo.packageName == BuildConfig.APP_PACKAGE_NAME) {
            Shell.cmd("(pm uninstall ${BuildConfig.APP_PACKAGE_NAME} >/dev/null 2>&1)&").exec()
            return false
        }

        when (Config.suAutoResponse) {
            Config.Value.SU_AUTO_DENY -> {
                respond(SuPolicy.DENY, 0)
                return false
            }
            Config.Value.SU_AUTO_ALLOW -> {
                respond(SuPolicy.ALLOW, 0)
                return false
            }
        }

        return true
    }

    private suspend fun init(intent: Intent): Boolean {
        val uid = intent.getIntExtra("uid", -1)
        val pid = intent.getIntExtra("pid", -1)
        val fifo = intent.getStringExtra("fifo")
        if (uid <= 0 || pid <= 0 || fifo == null) {
            Timber.e("Unexpected extras: uid=[${uid}], pid=[${pid}], fifo=[${fifo}]")
            return false
        }
        output = File(fifo)
        policy = policyDB.fetch(uid) ?: SuPolicy(uid)
        try {
            pkgInfo = pm.getPackageInfo(uid, pid) ?: PackageInfo().apply {
                val name = pm.getNameForUid(uid) ?: throw PackageManager.NameNotFoundException()
                // We only fill in sharedUserId and leave other fields uninitialized
                sharedUserId = name.split(":")[0]
            }
        } catch (e: PackageManager.NameNotFoundException) {
            Timber.e(e)
            respond(SuPolicy.DENY, -1)
            return false
        }
        if (!output.canWrite()) {
            Timber.e("Cannot write to $output")
            return false
        }
        return true
    }

    suspend fun respond(action: Int, time: Long) {
        if (action == SuPolicy.ALLOW && Config.suRestrict) {
            policy.policy = SuPolicy.RESTRICT
        } else {
            policy.policy = action
        }
        if (time >= 0) {
            policy.remain = TimeUnit.MINUTES.toSeconds(time)
        } else {
            policy.remain = time
        }

        withContext(Dispatchers.IO) {
            try {
                DataOutputStream(FileOutputStream(output)).use {
                    it.writeInt(policy.policy)
                    it.flush()
                }
            } catch (e: IOException) {
                Timber.e(e)
            }
            if (time >= 0) {
                policyDB.update(policy)
            }
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/tasks/AppMigration.kt`:

```kt
package com.topjohnwu.magisk.core.tasks

import android.app.Activity
import android.app.ActivityOptions
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.widget.Toast
import com.topjohnwu.magisk.StubApk
import com.topjohnwu.magisk.core.AppApkPath
import com.topjohnwu.magisk.core.BuildConfig.APP_PACKAGE_NAME
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.ktx.await
import com.topjohnwu.magisk.core.ktx.toast
import com.topjohnwu.magisk.core.ktx.writeTo
import com.topjohnwu.magisk.core.signing.JarMap
import com.topjohnwu.magisk.core.signing.SignApk
import com.topjohnwu.magisk.core.utils.AXML
import com.topjohnwu.magisk.core.utils.Keygen
import com.topjohnwu.magisk.utils.APKInstall
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.io.File
import java.io.IOException
import java.io.OutputStream
import java.security.SecureRandom
import kotlin.random.asKotlinRandom

object AppMigration {

    private const val ALPHA = "abcdefghijklmnopqrstuvwxyz"
    private const val ALPHADOTS = "$ALPHA....."
    private const val ANDROID_MANIFEST = "AndroidManifest.xml"
    private const val TEST_PKG_NAME = "$APP_PACKAGE_NAME.test"

    // Some arbitrary limit
    const val MAX_LABEL_LENGTH = 32
    const val PLACEHOLDER = "COMPONENT_PLACEHOLDER"

    private fun genPackageName(): String {
        val random = SecureRandom()
        val len = 5 + random.nextInt(15)
        val builder = StringBuilder(len)
        var next: Char
        var prev = 0.toChar()
        for (i in 0 until len) {
            next = if (prev == '.' || i == 0 || i == len - 1) {
                ALPHA[random.nextInt(ALPHA.length)]
            } else {
                ALPHADOTS[random.nextInt(ALPHADOTS.length)]
            }
            builder.append(next)
            prev = next
        }
        if (!builder.contains('.')) {
            // Pick a random index and set it as dot
            val idx = random.nextInt(len - 2)
            builder[idx + 1] = '.'
        }
        return builder.toString()
    }

    private fun classNameGenerator() = sequence {
        val c1 = mutableListOf<String>()
        val c2 = mutableListOf<String>()
        val c3 = mutableListOf<String>()
        val random = SecureRandom()
        val kRandom = random.asKotlinRandom()

        fun <T> chain(vararg iters: Iterable<T>) = sequence {
            iters.forEach { it.forEach { v -> yield(v) } }
        }

        for (a in chain('a'..'z', 'A'..'Z')) {
            if (a != 'a' && a != 'A') {
                c1.add("$a")
            }
            for (b in chain('a'..'z', 'A'..'Z', '0'..'9')) {
                c2.add("$a$b")
                for (c in chain('a'..'z', 'A'..'Z', '0'..'9')) {
                    c3.add("$a$b$c")
                }
            }
        }

        c1.shuffle(random)
        c2.shuffle(random)
        c3.shuffle(random)

        fun notJavaKeyword(name: String) = when (name) {
            "do", "if", "for", "int", "new", "try" -> false
            else -> true
        }

        fun List<String>.process() = asSequence().filter(::notJavaKeyword)

        val names = mutableListOf<String>()
        names.addAll(c1)
        names.addAll(c2.process().take(30))
        names.addAll(c3.process().take(30))

        while (true) {
            val seg = 2 + random.nextInt(4)
            val cls = StringBuilder()
            for (i in 0 until seg) {
                cls.append(names.random(kRandom))
                if (i != seg - 1)
                    cls.append('.')
            }
            // Old Android does not support capitalized package names
            // Check Android 7.0.0 PackageParser#buildClassName
            cls[0] = cls[0].lowercaseChar()
            yield(cls.toString())
        }
    }.distinct().iterator()

    private fun patch(
        context: Context,
        apk: File, out: OutputStream,
        pkg: String, label: CharSequence
    ): Boolean {
        val pm = context.packageManager
        val info = pm.getPackageArchiveInfo(apk.path, 0)?.applicationInfo ?: return false
        val origLabel = info.nonLocalizedLabel.toString()
        try {
            JarMap.open(apk, true).use { jar ->
                val je = jar.getJarEntry(ANDROID_MANIFEST)
                val xml = AXML(jar.getRawData(je))
                val generator = classNameGenerator()
                val p = xml.patchStrings {
                    when {
                        it.contains(APP_PACKAGE_NAME) -> it.replace(APP_PACKAGE_NAME, pkg)
                        it.contains(PLACEHOLDER) -> generator.next()
                        it == origLabel -> label.toString()
                        else -> it
                    }
                }
                if (!p) return false

                // Write apk changes
                jar.getOutputStream(je).use { it.write(xml.bytes) }
                val keys = Keygen()
                SignApk.sign(keys.cert, keys.key, jar, out)
                return true
            }
        } catch (e: Exception) {
            Timber.e(e)
            return false
        }
    }

    private fun patchTest(apk: File, out: File, pkg: String): Boolean {
        try {
            JarMap.open(apk, true).use { jar ->
                val je = jar.getJarEntry(ANDROID_MANIFEST)
                val xml = AXML(jar.getRawData(je))
                val p = xml.patchStrings {
                    when (it) {
                        APP_PACKAGE_NAME -> pkg
                        TEST_PKG_NAME -> "$pkg.test"
                        else -> it
                    }
                }
                if (!p) return false

                // Write apk changes
                jar.getOutputStream(je).use { it.write(xml.bytes) }
                val keys = Keygen()
                out.outputStream().use { SignApk.sign(keys.cert, keys.key, jar, it) }
                return true
            }
        } catch (e: Exception) {
            Timber.e(e)
            return false
        }
    }

    private fun launchApp(context: Context, pkg: String) {
        val intent = context.packageManager.getLaunchIntentForPackage(pkg) ?: return
        intent.putExtra(Const.Key.PREV_CONFIG, Config.toBundle())
        val options = ActivityOptions.makeBasic()
        if (Build.VERSION.SDK_INT >= 34) {
            options.setShareIdentityEnabled(true)
        }
        context.startActivity(intent, options.toBundle())
        if (context is Activity) {
            context.finish()
        }
    }

    suspend fun patchAndHide(context: Context, label: String, pkg: String? = null): Boolean {
        val stub = File(context.cacheDir, "stub.apk")
        try {
            context.assets.open("stub.apk").writeTo(stub)
        } catch (e: IOException) {
            Timber.e(e)
            return false
        }

        // Generate a new random signature and package name if needed
        val pkg = pkg ?: genPackageName()
        Config.keyStoreRaw = ""

        // Check and patch the test APK
        try {
            val info = context.packageManager.getApplicationInfo(TEST_PKG_NAME, 0)
            val testApk = File(info.sourceDir)
            val testRepack = File(context.cacheDir, "test.apk")
            if (!patchTest(testApk, testRepack, pkg))
                return false
            val cmd = "adb_pm_install $testRepack $pkg.test"
            if (!Shell.cmd(cmd).exec().isSuccess)
                return false
        } catch (e: PackageManager.NameNotFoundException) {
        }

        val repack = File(context.cacheDir, "patched.apk")
        repack.outputStream().use {
            if (!patch(context, stub, it, pkg, label))
                return false
        }

        // Install and auto launch app
        val cmd = "adb_pm_install $repack $pkg"
        if (Shell.cmd(cmd).exec().isSuccess) {
            Config.suManager = pkg
            Shell.cmd("touch $AppApkPath").exec()
            launchApp(context, pkg)
            return true
        } else {
            return false
        }
    }

    @Suppress("DEPRECATION")
    suspend fun hide(activity: Activity, label: String) {
        val dialog = android.app.ProgressDialog(activity).apply {
            setTitle(activity.getString(R.string.hide_app_title))
            isIndeterminate = true
            setCancelable(false)
            show()
        }
        val success = withContext(Dispatchers.IO) {
            patchAndHide(activity, label)
        }
        if (!success) {
            dialog.dismiss()
            activity.toast(R.string.failure, Toast.LENGTH_LONG)
        }
    }

    suspend fun restoreApp(context: Context): Boolean {
        val apk = StubApk.current(context)
        val cmd = "adb_pm_install $apk $APP_PACKAGE_NAME"
        if (Shell.cmd(cmd).await().isSuccess) {
            Config.suManager = ""
            Shell.cmd("touch $AppApkPath").exec()
            launchApp(context, APP_PACKAGE_NAME)
            return true
        }
        return false
    }

    @Suppress("DEPRECATION")
    suspend fun restore(activity: Activity) {
        val dialog = android.app.ProgressDialog(activity).apply {
            setTitle(activity.getString(R.string.restore_img_msg))
            isIndeterminate = true
            setCancelable(false)
            show()
        }
        if (!restoreApp(activity)) {
            activity.toast(R.string.failure, Toast.LENGTH_LONG)
        }
        dialog.dismiss()
    }

    suspend fun upgradeStub(context: Context, apk: File): Intent? {
        val label = context.applicationInfo.nonLocalizedLabel
        val pkg = context.packageName
        val session = APKInstall.startSession(context)
        return withContext(Dispatchers.IO) {
            session.openStream(context).use {
                if (!patch(context, apk, it, pkg, label)) {
                    return@withContext null
                }
            }
            session.waitIntent()
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/tasks/FlashZip.kt`:

```kt
package com.topjohnwu.magisk.core.tasks

import android.net.Uri
import androidx.core.net.toFile
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.ktx.writeTo
import com.topjohnwu.magisk.core.utils.MediaStoreUtils.displayName
import com.topjohnwu.magisk.core.utils.MediaStoreUtils.inputStream
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.io.File
import java.io.FileNotFoundException
import java.io.IOException

open class FlashZip(
    private val mUri: Uri,
    private val console: MutableList<String>,
    private val logs: MutableList<String>
) {

    private val installDir = File(AppContext.cacheDir, "flash")
    private lateinit var zipFile: File

    @Throws(IOException::class)
    private suspend fun flash(): Boolean {
        installDir.deleteRecursively()
        installDir.mkdirs()

        zipFile = if (mUri.scheme == "file") {
            mUri.toFile()
        } else {
            File(installDir, "install.zip").also {
                console.add("- Copying zip to temp directory")
                try {
                    mUri.inputStream().writeTo(it)
                } catch (e: IOException) {
                    when (e) {
                        is FileNotFoundException -> console.add("! Invalid Uri")
                        else -> console.add("! Cannot copy to cache")
                    }
                    throw e
                }
            }
        }

        try {
            val binary = File(installDir, "update-binary")
            AppContext.assets.open("module_installer.sh").use { it.writeTo(binary) }
        } catch (e: IOException) {
            console.add("! Unzip error")
            throw e
        }

        console.add("- Installing ${mUri.displayName}")

        return Shell.cmd("sh $installDir/update-binary dummy 1 \'$zipFile\'")
            .to(console, logs).exec().isSuccess
    }

    open suspend fun exec() = withContext(Dispatchers.IO) {
        try {
            if (!flash()) {
                console.add("! Installation failed")
                false
            } else {
                true
            }
        } catch (e: IOException) {
            Timber.e(e)
            false
        } finally {
            Shell.cmd("cd /", "rm -rf $installDir ${Const.TMPDIR}").submit()
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt`:

```kt
package com.topjohnwu.magisk.core.tasks

import android.net.Uri
import android.os.Process
import android.system.ErrnoException
import android.system.Os
import android.system.OsConstants
import android.system.OsConstants.O_WRONLY
import androidx.annotation.WorkerThread
import androidx.core.os.postDelayed
import com.topjohnwu.magisk.StubApk
import com.topjohnwu.magisk.core.AppApkPath
import com.topjohnwu.magisk.core.BuildConfig
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.core.isRunningAsStub
import com.topjohnwu.magisk.core.ktx.copyAll
import com.topjohnwu.magisk.core.ktx.writeTo
import com.topjohnwu.magisk.core.utils.DummyList
import com.topjohnwu.magisk.core.utils.MediaStoreUtils
import com.topjohnwu.magisk.core.utils.MediaStoreUtils.inputStream
import com.topjohnwu.magisk.core.utils.MediaStoreUtils.outputStream
import com.topjohnwu.magisk.core.utils.RootUtils
import com.topjohnwu.superuser.Shell
import com.topjohnwu.superuser.ShellUtils
import com.topjohnwu.superuser.internal.UiThreadHandler
import com.topjohnwu.superuser.nio.ExtendedFile
import com.topjohnwu.superuser.nio.FileSystemManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.apache.commons.compress.archivers.tar.TarArchiveEntry
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream
import org.apache.commons.compress.archivers.zip.ZipFile
import org.apache.commons.compress.compressors.lz4.FramedLZ4CompressorInputStream
import timber.log.Timber
import java.io.File
import java.io.FilterInputStream
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream
import java.io.PushbackInputStream
import java.nio.ByteBuffer
import java.security.SecureRandom
import java.util.Locale
import java.util.concurrent.atomic.AtomicBoolean

abstract class MagiskInstallImpl protected constructor(
    protected val console: MutableList<String>,
    private val logs: MutableList<String>
) {

    private lateinit var installDir: ExtendedFile
    private lateinit var srcBoot: ExtendedFile

    private val shell = Shell.getShell()
    private val useRootDir = shell.isRoot && Info.noDataExec
    protected val context get() = ServiceLocator.deContext

    private val rootFS get() = RootUtils.fs
    private val localFS get() = FileSystemManager.getLocal()

    private val destName: String by lazy {
        if (Config.randName) {
            val alpha = "abcdefghijklmnopqrstuvwxyz"
            val alphaNum = "$alpha${alpha.uppercase(Locale.ROOT)}0123456789"
            val random = SecureRandom()
            StringBuilder("magisk_patched-${BuildConfig.APP_VERSION_CODE}_").run {
                for (i in 1..5) {
                    append(alphaNum[random.nextInt(alphaNum.length)])
                }
                toString()
            }
        } else {
            "magisk_patched"
        }
    }

    private fun findImage(slot: String): Boolean {
        val cmd =
            "RECOVERYMODE=${Config.recovery} " +
            "VENDORBOOT=${Info.isVendorBoot} " +
            "SLOT=$slot " +
            "find_boot_image; echo \$BOOTIMAGE"
        val bootPath = ("($cmd)").fsh()
        if (bootPath.isEmpty()) {
            console.add("! Unable to detect target image")
            return false
        }
        srcBoot = rootFS.getFile(bootPath)
        console.add("- Target image: $bootPath")
        return true
    }

    private fun findImage(): Boolean {
        return findImage(Info.slot)
    }

    private fun findSecondary(): Boolean {
        val slot = if (Info.slot == "_a") "_b" else "_a"
        console.add("- Target slot: $slot")
        return findImage(slot)
    }

    private suspend fun extractFiles(): Boolean {
        console.add("- Device platform: ${Const.CPU_ABI}")
        console.add("- Installing: ${BuildConfig.APP_VERSION_NAME} (${BuildConfig.APP_VERSION_CODE})")

        installDir = localFS.getFile(context.filesDir.parent, "install")
        installDir.deleteRecursively()
        installDir.mkdirs()

        try {
            // Extract binaries
            if (isRunningAsStub) {
                ZipFile.builder().setFile(StubApk.current(context)).get().use { zf ->
                    zf.entries.asSequence().filter {
                        !it.isDirectory && it.name.startsWith("lib/${Const.CPU_ABI}/")
                    }.forEach {
                        val n = it.name.substring(it.name.lastIndexOf('/') + 1)
                        val name = n.substring(3, n.length - 3)
                        val dest = File(installDir, name)
                        zf.getInputStream(it).writeTo(dest)
                        dest.setExecutable(true)
                    }

                    val abi32 = Const.CPU_ABI_32
                    if (Process.is64Bit() && abi32 != null) {
                        val entry = zf.getEntry("lib/$abi32/libmagisk.so")
                        if (entry != null) {
                            val magisk32 = File(installDir, "magisk32")
                            zf.getInputStream(entry).writeTo(magisk32)
                        }
                    }
                }
            } else {
                val info = context.applicationInfo
                val libs = File(info.nativeLibraryDir).listFiles { _, name ->
                    name.startsWith("lib") && name.endsWith(".so")
                } ?: emptyArray()

                for (lib in libs) {
                    val name = lib.name.substring(3, lib.name.length - 3)
                    Os.symlink(lib.path, "$installDir/$name")
                }

                // Also extract magisk32 on 64-bit devices that supports 32-bit
                val abi32 = Const.CPU_ABI_32
                if (Process.is64Bit() && abi32 != null) {
                    val name = "lib/$abi32/libmagisk.so"
                    val entry = javaClass.classLoader!!.getResourceAsStream(name)
                    if (entry != null) {
                        val magisk32 = File(installDir, "magisk32")
                        entry.writeTo(magisk32)
                    }
                }
            }

            // Extract scripts
            for (script in listOf("util_functions.sh", "boot_patch.sh", "addon.d.sh", "stub.apk")) {
                val dest = File(installDir, script)
                context.assets.open(script).writeTo(dest)
            }
            // Extract chromeos tools
            File(installDir, "chromeos").mkdir()
            for (file in listOf("futility", "kernel_data_key.vbprivk", "kernel.keyblock")) {
                val name = "chromeos/$file"
                val dest = File(installDir, name)
                context.assets.open(name).writeTo(dest)
            }
        } catch (e: Exception) {
            console.add("! Unable to extract files")
            Timber.e(e)
            return false
        }

        if (useRootDir) {
            // Move everything to tmpfs to workaround Samsung bullshit
            rootFS.getFile(Const.TMPDIR).also {
                arrayOf(
                    "rm -rf $it",
                    "mkdir -p $it",
                    "cp_readlink $installDir $it",
                    "rm -rf $installDir"
                ).sh()
                installDir = it
            }
        }

        return true
    }

    private suspend fun InputStream.copyAndCloseOut(out: OutputStream) =
        out.use { copyAll(it, 1024 * 1024) }

    private class NoAvailableStream(s: InputStream) : FilterInputStream(s) {
        // Make sure available is never called on the actual stream and always return 0
        // to reduce max buffer size and avoid OOM
        override fun available() = 0
    }

    private class NoBootException : IOException()

    inner class BootItem(private val entry: TarArchiveEntry) {
        val name = entry.name.replace(".lz4", "")
        var file = installDir.getChildFile(name)

        suspend fun copyTo(tarOut: TarArchiveOutputStream) {
            entry.name = name
            entry.size = file.length()
            file.newInputStream().use {
                console.add("-- Writing   : $name")
                tarOut.putArchiveEntry(entry)
                it.copyAll(tarOut)
                tarOut.closeArchiveEntry()
            }
        }
    }

    @Throws(IOException::class)
    private suspend fun processTar(
        tarIn: TarArchiveInputStream,
        tarOut: TarArchiveOutputStream
    ): BootItem {
        console.add("- Processing tar file")
        var entry: TarArchiveEntry? = tarIn.nextEntry

        fun decompressedStream(): InputStream {
            val stream = if (tarIn.currentEntry.name.endsWith(".lz4"))
                FramedLZ4CompressorInputStream(tarIn, true) else tarIn
            return NoAvailableStream(stream)
        }

        var boot: BootItem? = null
        var initBoot: BootItem? = null
        var recovery: BootItem? = null

        while (entry != null) {
            val bootItem: BootItem?
            if (entry.name.startsWith("boot.img")) {
                bootItem = BootItem(entry)
                boot = bootItem
            } else if (entry.name.startsWith("init_boot.img")) {
                bootItem = BootItem(entry)
                initBoot = bootItem
            } else if (Config.recovery && entry.name.contains("recovery.img")) {
                bootItem = BootItem(entry)
                recovery = bootItem
            } else {
                bootItem = null
            }

            if (bootItem != null) {
                console.add("-- Extracting: ${bootItem.name}")
                decompressedStream().copyAndCloseOut(bootItem.file.newOutputStream())
            } else if (entry.name.contains("vbmeta.img")) {
                val rawData = decompressedStream().readBytes()
                // Valid vbmeta.img should be at least 256 bytes
                if (rawData.size < 256)
                    continue

                // vbmeta partition exist, disable boot vbmeta patch
                Info.patchBootVbmeta = false

                val name = entry.name.replace(".lz4", "")
                console.add("-- Patching  : $name")

                // Patch flags to AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED |
                // AVB_VBMETA_IMAGE_FLAGS_VERIFICATION_DISABLED
                ByteBuffer.wrap(rawData).putInt(120, 3)

                // Fetch the next entry first before modifying current entry
                val vbmeta = entry
                entry = tarIn.nextEntry

                // Update entry with new information
                vbmeta.name = name
                vbmeta.size = rawData.size.toLong()

                // Write output
                tarOut.putArchiveEntry(vbmeta)
                tarOut.write(rawData)
                tarOut.closeArchiveEntry()
                continue
            } else if (entry.name.contains("userdata.img")) {
                console.add("-- Skipping  : ${entry.name}")
            } else {
                console.add("-- Copying   : ${entry.name}")
                tarOut.putArchiveEntry(entry)
                tarIn.copyAll(tarOut)
                tarOut.closeArchiveEntry()
            }
            entry = tarIn.nextEntry ?: break
        }

        // Patch priority: recovery > init_boot > boot
        return when {
            recovery != null -> {
                if (boot != null) {
                    // Repack boot image to prevent auto restore
                    arrayOf(
                        "cd $installDir",
                        "chmod -R 755 .",
                        "./magiskboot unpack boot.img",
                        "./magiskboot repack boot.img",
                        "cat new-boot.img > boot.img",
                        "./magiskboot cleanup",
                        "rm -f new-boot.img",
                        "cd /").sh()
                    boot.copyTo(tarOut)
                }
                recovery
            }
            initBoot != null -> {
                boot?.copyTo(tarOut)
                initBoot
            }
            boot != null -> boot
            else -> throw NoBootException()
        }
    }

    @Throws(IOException::class)
    private suspend fun processZip(zipIn: ZipArchiveInputStream): ExtendedFile {
        console.add("- Processing zip file")
        val boot = installDir.getChildFile("boot.img")
        val initBoot = installDir.getChildFile("init_boot.img")
        var entry: ZipArchiveEntry
        while (true) {
            entry = zipIn.nextEntry ?: break
            if (entry.isDirectory) continue
            when (entry.name.substringAfterLast('/')) {
                "payload.bin" -> {
                    try {
                        return processPayload(zipIn)
                    } catch (e: IOException) {
                        // No boot image in payload.bin, continue to find boot images
                    }
                }
                "init_boot.img" -> {
                    console.add("- Extracting init_boot.img")
                    zipIn.copyAndCloseOut(initBoot.newOutputStream())
                    return initBoot
                }
                "boot.img" -> {
                    console.add("- Extracting boot.img")
                    zipIn.copyAndCloseOut(boot.newOutputStream())
                    // Don't return here since there might be an init_boot.img
                }
            }
        }
        if (boot.exists()) {
            return boot
        } else {
            throw NoBootException()
        }
    }

    @Throws(IOException::class)
    private fun processPayload(input: InputStream): ExtendedFile {
        var fifo: File? = null
        try {
            console.add("- Processing payload.bin")
            fifo = File.createTempFile("payload-fifo-", null, installDir)
            fifo.delete()
            Os.mkfifo(fifo.path, 420 /* 0644 */)

            // Enqueue the shell command first, or the subsequent FIFO open will block
            val future = arrayOf(
                "cd $installDir",
                "./magiskboot extract $fifo",
                "cd /"
            ).eq()

            val fd = Os.open(fifo.path, O_WRONLY, 0)
            try {
                val bufSize = 1024 * 1024
                val buf = ByteBuffer.allocate(bufSize)
                buf.position(input.read(buf.array()).coerceAtLeast(0)).flip()
                while (buf.hasRemaining()) {
                    try {
                        Os.write(fd, buf)
                    } catch (e: ErrnoException) {
                        if (e.errno != OsConstants.EPIPE)
                            throw e
                        // If SIGPIPE, then the other side is closed, we're done
                        break
                    }
                    if (!buf.hasRemaining()) {
                        buf.limit(bufSize)
                        buf.position(input.read(buf.array()).coerceAtLeast(0)).flip()
                    }
                }
            } finally {
                Os.close(fd)
            }

            val success = try { future.get().isSuccess } catch (e: Exception) { false }
            if (!success) {
                console.add("! Error while extracting payload.bin")
                throw IOException()
            }
            val boot = installDir.getChildFile("boot.img")
            val initBoot = installDir.getChildFile("init_boot.img")
            return when {
                initBoot.exists() -> {
                    console.add("-- Extract init_boot.img")
                    initBoot
                }
                boot.exists() -> {
                    console.add("-- Extract boot.img")
                    boot
                }
                else -> {
                    throw NoBootException()
                }
            }
        } catch (e: ErrnoException) {
            throw IOException(e)
        } finally {
            fifo?.delete()
        }
    }

    private suspend fun processFile(uri: Uri): Boolean {
        val outStream: OutputStream
        val outFile: MediaStoreUtils.UriFile
        var bootItem: BootItem? = null

        // Process input file
        try {
            PushbackInputStream(uri.inputStream().buffered(1024 * 1024), 512).use { src ->
                val head = ByteArray(512)
                if (src.read(head) != head.size) {
                    console.add("! Invalid input file")
                    return false
                }
                src.unread(head)

                val magic = head.copyOf(4)
                val tarMagic = head.copyOfRange(257, 262)

                srcBoot = if (tarMagic.contentEquals("ustar".toByteArray())) {
                    // tar file
                    outFile = MediaStoreUtils.getFile("$destName.tar")
                    val os = outFile.uri.outputStream().buffered(1024 * 1024)
                    outStream = TarArchiveOutputStream(os).also {
                        it.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR)
                        it.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU)
                    }

                    try {
                        bootItem = processTar(TarArchiveInputStream(src), outStream)
                        bootItem.file
                    } catch (e: IOException) {
                        outStream.close()
                        outFile.delete()
                        throw e
                    }
                } else {
                    // raw image
                    outFile = MediaStoreUtils.getFile("$destName.img")
                    outStream = outFile.uri.outputStream()

                    try {
                        if (magic.contentEquals("CrAU".toByteArray())) {
                            processPayload(src)
                        } else if (magic.contentEquals("PK\u0003\u0004".toByteArray())) {
                            processZip(ZipArchiveInputStream(src))
                        } else {
                            console.add("- Copying image to cache")
                            installDir.getChildFile("boot.img").also {
                                src.copyAndCloseOut(it.newOutputStream())
                            }
                        }
                    } catch (e: IOException) {
                        outStream.close()
                        outFile.delete()
                        throw e
                    }
                }
            }
        } catch (e: IOException) {
            if (e is NoBootException)
                console.add("! No boot image found")
            console.add("! Process error")
            Timber.e(e)
            return false
        }

        // Patch file
        if (!patchBoot()) {
            outFile.delete()
            return false
        }

        // Output file
        try {
            val newBoot = installDir.getChildFile("new-boot.img")
            if (bootItem != null) {
                bootItem.file = newBoot
                bootItem.copyTo(outStream as TarArchiveOutputStream)
            } else {
                newBoot.newInputStream().use { it.copyAll(outStream, 1024 * 1024) }
            }
            newBoot.delete()

            console.add("")
            console.add("****************************")
            console.add(" Output file is written to ")
            console.add(" $outFile ")
            console.add("****************************")
        } catch (e: IOException) {
            console.add("! Failed to output to $outFile")
            outFile.delete()
            Timber.e(e)
            return false
        } finally {
            outStream.close()
        }

        // Fix up binaries
        srcBoot.delete()
        "cp_readlink $installDir".sh()

        return true
    }

    private fun patchBoot(): Boolean {
        val newBoot = installDir.getChildFile("new-boot.img")
        if (!useRootDir) {
            // Create output files before hand
            newBoot.createNewFile()
            File(installDir, "stock_boot.img").createNewFile()
        }

        val cmds = arrayOf(
            "cd $installDir",
            "KEEPFORCEENCRYPT=${Config.keepEnc} " +
            "KEEPVERITY=${Config.keepVerity} " +
            "PATCHVBMETAFLAG=${Info.patchBootVbmeta} " +
            "RECOVERYMODE=${Config.recovery} " +
            "LEGACYSAR=${Info.legacySAR} " +
            "sh boot_patch.sh $srcBoot")
        val isSuccess = cmds.sh().isSuccess

        shell.newJob().add("./magiskboot cleanup", "cd /").exec()

        return isSuccess
    }

    private fun flashBoot() = "direct_install $installDir $srcBoot".sh().isSuccess

    private suspend fun postOTA(): Boolean {
        try {
            val bootctl = File.createTempFile("bootctl", null, context.cacheDir)
            context.assets.open("bootctl").writeTo(bootctl)
            "post_ota $bootctl".sh()
        } catch (e: IOException) {
            console.add("! Unable to download bootctl")
            Timber.e(e)
            return false
        }

        console.add("*************************************************************")
        console.add(" Next reboot will boot to second slot!")
        console.add(" Go back to System Updates and press Restart to complete OTA")
        console.add("*************************************************************")
        return true
    }

    private fun Array<String>.eq() = shell.newJob().add(*this).to(console, logs).enqueue()
    private fun String.sh() = shell.newJob().add(this).to(console, logs).exec()
    private fun Array<String>.sh() = shell.newJob().add(*this).to(console, logs).exec()
    private fun String.fsh() = ShellUtils.fastCmd(shell, this)
    private fun Array<String>.fsh() = ShellUtils.fastCmd(shell, *this)

    protected suspend fun patchFile(file: Uri) = extractFiles() && processFile(file)

    protected suspend fun direct() = findImage() && extractFiles() && patchBoot() && flashBoot()

    protected suspend fun secondSlot() =
        findSecondary() && extractFiles() && patchBoot() && flashBoot() && postOTA()

    protected suspend fun fixEnv() = extractFiles() && "fix_env $installDir".sh().isSuccess

    protected fun restore() = findImage() && "restore_imgs $srcBoot".sh().isSuccess

    protected fun uninstall() = "run_uninstaller $AppApkPath".sh().isSuccess

    @WorkerThread
    protected abstract suspend fun operations(): Boolean

    open suspend fun exec(): Boolean {
        if (haveActiveSession.getAndSet(true))
            return false

        val result = withContext(Dispatchers.IO) { operations() }
        haveActiveSession.set(false)
        if (result)
            return true

        // Not every operation initializes installDir
        if (::installDir.isInitialized)
            Shell.cmd("rm -rf $installDir").submit()
        return false
    }

    companion object {
        private var haveActiveSession = AtomicBoolean(false)
    }
}

abstract class ConsoleInstaller(
    console: MutableList<String>,
    logs: MutableList<String>
) : MagiskInstallImpl(console, logs) {
    override suspend fun exec(): Boolean {
        val success = super.exec()
        if (success) {
            console.add("- All done!")
        } else {
            console.add("! Installation failed")
        }
        return success
    }
}

abstract class CallBackInstaller : MagiskInstallImpl(DummyList, DummyList) {
    suspend fun exec(callback: (Boolean) -> Unit): Boolean {
        val success = exec()
        callback(success)
        return success
    }
}

class MagiskInstaller {

    class Patch(
        private val uri: Uri,
        console: MutableList<String>,
        logs: MutableList<String>
    ) : ConsoleInstaller(console, logs) {
        override suspend fun operations() = patchFile(uri)
    }

    class SecondSlot(
        console: MutableList<String>,
        logs: MutableList<String>
    ) : ConsoleInstaller(console, logs) {
        override suspend fun operations() = secondSlot()
    }

    class Direct(
        console: MutableList<String>,
        logs: MutableList<String>
    ) : ConsoleInstaller(console, logs) {
        override suspend fun operations() = direct()
    }

    class Emulator(
        console: MutableList<String>,
        logs: MutableList<String>
    ) : ConsoleInstaller(console, logs) {
        override suspend fun operations() = fixEnv()
    }

    class Uninstall(
        console: MutableList<String>,
        logs: MutableList<String>
    ) : ConsoleInstaller(console, logs) {
        override suspend fun operations() = uninstall()

        override suspend fun exec(): Boolean {
            val success = super.exec()
            if (success) {
                UiThreadHandler.handler.postDelayed(3000) {
                    Shell.cmd("pm uninstall ${context.packageName}").exec()
                }
            }
            return success
        }
    }

    class Restore : CallBackInstaller() {
        override suspend fun operations() = restore()
    }

    class FixEnv : CallBackInstaller() {
        override suspend fun operations() = fixEnv()
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/AXML.kt`:

```kt
package com.topjohnwu.magisk.core.utils

import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder.LITTLE_ENDIAN
import java.nio.charset.Charset

class AXML(b: ByteArray) {

    var bytes = b
        private set

    companion object {
        private const val CHUNK_SIZE_OFF = 4
        private const val STRING_INDICES_OFF = 7 * 4
        private val UTF_16LE = Charset.forName("UTF-16LE")
    }

    /**
     * String pool header:
     * 0:  0x1C0001
     * 1:  chunk size
     * 2:  number of strings
     * 3:  number of styles (assert as 0)
     * 4:  flags
     * 5:  offset to string data
     * 6:  offset to style data (assert as 0)
     *
     * Followed by an array of uint32_t with size = number of strings
     * Each entry points to an offset into the string data
     */
    fun patchStrings(mapFn: (String) -> String): Boolean {
        val buffer = ByteBuffer.wrap(bytes).order(LITTLE_ENDIAN)

        fun findStringPool(): Int {
            var offset = 8
            while (offset < bytes.size) {
                if (buffer.getInt(offset) == 0x1C0001)
                    return offset
                offset += buffer.getInt(offset + CHUNK_SIZE_OFF)
            }
            return -1
        }

        val start = findStringPool()
        if (start < 0)
            return false

        // Read header
        buffer.position(start + 4)
        val intBuf = buffer.asIntBuffer()
        val size = intBuf.get()
        val count = intBuf.get()
        intBuf.get()
        intBuf.get()
        val dataOff = start + intBuf.get()
        intBuf.get()

        val strList = ArrayList<String>(count)
        // Collect all strings in the pool
        for (i in 0 until count) {
            val off = dataOff + intBuf.get()
            val len = buffer.getShort(off)
            strList.add(String(bytes, off + 2, len * 2, UTF_16LE))
        }

        val strArr = strList.toTypedArray()
        for (i in strArr.indices) {
            strArr[i] = mapFn(strArr[i])
        }

        // Write everything before string data, will patch values later
        val baos = RawByteStream()
        baos.write(bytes, 0, dataOff)

        // Write string data
        val offList = IntArray(count)
        for (i in 0 until count) {
            offList[i] = baos.size() - dataOff
            val str = strArr[i]
            baos.write(str.length.toShortBytes())
            baos.write(str.toByteArray(UTF_16LE))
            // Null terminate
            baos.write(0)
            baos.write(0)
        }
        baos.align()

        val sizeDiff = baos.size() - start - size
        val newBuffer = ByteBuffer.wrap(baos.buffer).order(LITTLE_ENDIAN)

        // Patch XML size
        newBuffer.putInt(CHUNK_SIZE_OFF, buffer.getInt(CHUNK_SIZE_OFF) + sizeDiff)
        // Patch string pool size
        newBuffer.putInt(start + CHUNK_SIZE_OFF, size + sizeDiff)
        // Patch index table
        newBuffer.position(start + STRING_INDICES_OFF)
        val newIntBuf = newBuffer.asIntBuffer()
        offList.forEach { newIntBuf.put(it) }

        // Write the rest of the chunks
        val nextOff = start + size
        baos.write(bytes, nextOff, bytes.size - nextOff)

        bytes = baos.toByteArray()
        return true
    }

    private fun Int.toShortBytes(): ByteArray {
        val b = ByteBuffer.allocate(2).order(LITTLE_ENDIAN)
        b.putShort(this.toShort())
        return b.array()
    }

    private class RawByteStream : ByteArrayOutputStream() {
        val buffer: ByteArray get() = buf

        fun align(alignment: Int = 4) {
            val newCount = (count + alignment - 1) / alignment * alignment
            for (i in 0 until (newCount - count))
                write(0)
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/Desugar.java`:

```java
package com.topjohnwu.magisk.core.utils;

import android.os.Build;

import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.apache.commons.compress.archivers.zip.ZipUtil;

import java.nio.file.attribute.FileTime;
import java.util.zip.ZipEntry;

public class Desugar {
    public static FileTime getLastModifiedTime(ZipEntry entry) {
        if (Build.VERSION.SDK_INT >= 26) {
            return entry.getLastModifiedTime();
        } else {
            return FileTime.fromMillis(entry.getTime());
        }
    }

    public static FileTime getLastAccessTime(ZipEntry entry) {
        if (Build.VERSION.SDK_INT >= 26) {
            return entry.getLastAccessTime();
        } else {
            return null;
        }
    }

    public static FileTime getCreationTime(ZipEntry entry) {
        if (Build.VERSION.SDK_INT >= 26) {
            return entry.getCreationTime();
        } else {
            return null;
        }
    }

    /**
     * Within {@link ZipArchiveOutputStream#copyFromZipInputStream}, we redirect the method call
     * {@link ZipUtil#checkRequestedFeatures} to this method. This is safe because the only usage
     * of copyFromZipInputStream is in {@link ZipArchiveOutputStream#addRawArchiveEntry},
     * which does not need to actually understand the content of the zip entry. By removing
     * this feature check, we can modify zip files using unsupported compression methods.
     */
    public static void checkRequestedFeatures(final ZipArchiveEntry ze) {
        // No-op
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/DummyList.kt`:

```kt
package com.topjohnwu.magisk.core.utils

object DummyList : java.util.AbstractList<String>() {

    override val size: Int get() = 0

    override fun get(index: Int): String {
        throw IndexOutOfBoundsException()
    }

    override fun add(element: String): Boolean = false

    override fun add(index: Int, element: String) {}

    override fun clear() {}
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/Keygen.kt`:

```kt
package com.topjohnwu.magisk.core.utils

import android.util.Base64
import android.util.Base64OutputStream
import com.topjohnwu.magisk.core.Config
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder
import java.io.ByteArrayOutputStream
import java.math.BigInteger
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.PrivateKey
import java.security.cert.X509Certificate
import java.util.Calendar
import java.util.Locale
import java.util.Random
import java.util.zip.GZIPInputStream
import java.util.zip.GZIPOutputStream

private interface CertKeyProvider {
    val cert: X509Certificate
    val key: PrivateKey
}

class Keygen : CertKeyProvider {

    companion object {
        private const val ALIAS = "magisk"
        private val PASSWORD get() = "magisk".toCharArray()
        private const val DNAME = "C=US,ST=California,L=Mountain View,O=Google Inc.,OU=Android,CN=Android"
        private const val BASE64_FLAG = Base64.NO_PADDING or Base64.NO_WRAP
    }

    private val start = Calendar.getInstance().apply { add(Calendar.MONTH, -3) }
    private val end = (start.clone() as Calendar).apply { add(Calendar.YEAR, 30) }

    private val ks = init()
    override val cert = ks.getCertificate(ALIAS) as X509Certificate
    override val key = ks.getKey(ALIAS, PASSWORD) as PrivateKey

    private fun init(): KeyStore {
        val raw = Config.keyStoreRaw
        val ks = KeyStore.getInstance("PKCS12")
        if (raw.isEmpty()) {
            ks.load(null)
        } else {
            GZIPInputStream(Base64.decode(raw, BASE64_FLAG).inputStream()).use {
                ks.load(it, PASSWORD)
            }
        }

        // Keys already exist
        if (ks.containsAlias(ALIAS))
            return ks

        // Generate new private key and certificate
        val kp = KeyPairGenerator.getInstance("RSA").apply { initialize(4096) }.genKeyPair()
        val dname = X500Name(DNAME)
        val builder = X509v3CertificateBuilder(
            dname, BigInteger(160, Random()),
            start.time, end.time, Locale.ROOT, dname,
            SubjectPublicKeyInfo.getInstance(kp.public.encoded)
        )
        val signer = JcaContentSignerBuilder("SHA1WithRSA").build(kp.private)
        val cert = JcaX509CertificateConverter().getCertificate(builder.build(signer))

        // Store them into keystore
        ks.setKeyEntry(ALIAS, kp.private, PASSWORD, arrayOf(cert))
        val bytes = ByteArrayOutputStream()
        GZIPOutputStream(Base64OutputStream(bytes, BASE64_FLAG)).use {
            ks.store(it, PASSWORD)
        }
        Config.keyStoreRaw = bytes.toString("UTF-8")

        return ks
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/LocaleSetting.kt`:

```kt
package com.topjohnwu.magisk.core.utils

import android.annotation.SuppressLint
import android.app.LocaleConfig
import android.app.LocaleManager
import android.content.ContextWrapper
import android.content.Intent
import android.content.res.Resources
import android.net.Uri
import android.os.Build
import android.os.LocaleList
import android.provider.Settings
import androidx.annotation.RequiresApi
import com.topjohnwu.magisk.core.AppApkPath
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.base.relaunch
import com.topjohnwu.magisk.core.isRunningAsStub
import org.xmlpull.v1.XmlPullParser
import java.util.Locale

interface LocaleSetting {
    // The locale that is manually overridden, null if system default
    val appLocale: Locale?
    // The current active locale used in the application
    val currentLocale: Locale

    fun setLocale(tag: String)
    fun updateResource(res: Resources)

    private class Api23Impl : LocaleSetting {

        private val systemLocale: Locale = Locale.getDefault()

        override var appLocale: Locale? = null
        override var currentLocale: Locale = systemLocale

        init {
            setLocale(Config.locale)
        }

        override fun setLocale(tag: String) {
            val locale = when {
                tag.isEmpty() -> null
                else -> Locale.forLanguageTag(tag)
            }
            currentLocale = locale ?: systemLocale
            appLocale = locale
            Locale.setDefault(currentLocale)
            updateResource(AppContext.resources)
            AppContext.foregroundActivity?.relaunch()
        }

        @Suppress("DEPRECATION")
        override fun updateResource(res: Resources) {
            val config = res.configuration
            config.setLocale(currentLocale)
            res.updateConfiguration(config, null)
        }
    }

    @RequiresApi(24)
    private class Api24Impl : LocaleSetting {

        private val systemLocaleList = LocaleList.getDefault()
        private var currentLocaleList: LocaleList = systemLocaleList

        override var appLocale: Locale? = null
        override val currentLocale: Locale get() = currentLocaleList[0]

        init {
            setLocale(Config.locale)
        }

        override fun setLocale(tag: String) {
            val localeList = when {
                tag.isEmpty() -> null
                else -> LocaleList.forLanguageTags(tag)
            }
            currentLocaleList = localeList ?: systemLocaleList
            appLocale = localeList?.get(0)
            LocaleList.setDefault(currentLocaleList)
            updateResource(AppContext.resources)
            AppContext.foregroundActivity?.relaunch()
        }

        @Suppress("DEPRECATION")
        override fun updateResource(res: Resources) {
            val config = res.configuration
            config.setLocales(currentLocaleList)
            res.updateConfiguration(config, null)
        }
    }

    @RequiresApi(33)
    private class Api33Impl : LocaleSetting {

        private val lm: LocaleManager = AppContext.getSystemService(LocaleManager::class.java)

        override val appLocale: Locale?
            get() = lm.applicationLocales.let { if (it.isEmpty) null else it[0] }

        override val currentLocale: Locale
            get() = appLocale ?: lm.systemLocales[0]

        // These following methods should not be used
        override fun setLocale(tag: String) {}
        override fun updateResource(res: Resources) {}
    }

    class AppLocaleList(
        val names: Array<String>,
        val tags: Array<String>
    )

    @SuppressLint("NewApi")
    companion object {
        val available: AppLocaleList by lazy {
            val names = ArrayList<String>()
            val tags = ArrayList<String>()

            names.add(AppContext.getString(R.string.system_default))
            tags.add("")

            if (Build.VERSION.SDK_INT >= 34) {
                // Use platform LocaleConfig parser
                val config = localeConfig
                val list = config.supportedLocales ?: LocaleList.getEmptyLocaleList()
                names.ensureCapacity(list.size() + 1)
                tags.ensureCapacity(list.size() + 1)
                for (i in 0 until list.size()) {
                    val locale = list[i]
                    names.add(locale.getDisplayName(locale))
                    tags.add(locale.toLanguageTag())
                }
            } else {
                // Manually parse locale_config.xml
                val parser = AppContext.resources.getXml(R.xml.locale_config)
                while (true) {
                    when (parser.next()) {
                        XmlPullParser.START_TAG -> {
                            if (parser.name == "locale") {
                                val tag = parser.getAttributeValue(0)
                                val locale = Locale.forLanguageTag(tag)
                                names.add(locale.getDisplayName(locale))
                                tags.add(tag)
                            }
                        }
                        XmlPullParser.END_DOCUMENT -> break
                    }
                }
            }
            AppLocaleList(names.toTypedArray(), tags.toTypedArray())
        }

        @get:RequiresApi(34)
        val localeConfig: LocaleConfig by lazy {
            val context = if (isRunningAsStub) {
                val pkgInfo = AppContext.packageManager.getPackageArchiveInfo(AppApkPath, 0)!!
                object : ContextWrapper(AppContext) {
                    override fun getApplicationInfo() = pkgInfo.applicationInfo
                }
            } else {
                AppContext
            }
            LocaleConfig.fromContextIgnoringOverride(context)
        }

        private val localeManagerUsable get() =
            if (isRunningAsStub) Build.VERSION.SDK_INT >= 34 else Build.VERSION.SDK_INT >= 33

        val useLocaleManager by lazy {
            localeManagerUsable &&
                    localeSettingsIntent.resolveActivity(AppContext.packageManager) != null
        }

        val localeSettingsIntent get() = Intent(
            Settings.ACTION_APP_LOCALE_SETTINGS,
            Uri.fromParts("package", AppContext.packageName, null),
        )

        val instance: LocaleSetting by lazy {
            // Initialize available locale list
            available
            if (useLocaleManager) {
                Api33Impl()
            } else if (Build.VERSION.SDK_INT <= 23) {
                Api23Impl()
            } else {
                Api24Impl()
            }
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/MediaStoreUtils.kt`:

```kt
package com.topjohnwu.magisk.core.utils

import android.content.ContentUris
import android.content.ContentValues
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.provider.MediaStore
import android.provider.OpenableColumns
import androidx.annotation.RequiresApi
import androidx.core.net.toFile
import androidx.core.net.toUri
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.Config
import java.io.File
import java.io.FileNotFoundException
import java.io.IOException

@Suppress("DEPRECATION")
object MediaStoreUtils {

    private val cr get() = AppContext.contentResolver

    private fun relativePath(name: String) =
        if (name.isEmpty()) Environment.DIRECTORY_DOWNLOADS
        else Environment.DIRECTORY_DOWNLOADS + File.separator + name

    fun fullPath(name: String): String =
        File(Environment.getExternalStorageDirectory(), relativePath(name)).canonicalPath

    private val downloadPath get() = relativePath(Config.downloadDir)

    @RequiresApi(api = 30)
    @Throws(IOException::class)
    private fun insertFile(displayName: String): MediaStoreFile {
        val values = ContentValues()
        values.put(MediaStore.MediaColumns.RELATIVE_PATH, downloadPath)
        values.put(MediaStore.MediaColumns.DISPLAY_NAME, displayName)

        // When a file with the same name exists and was not created by us:
        // - Before Android 11, insert will return null
        // - On Android 11+, the system will automatically create a new name
        // Thus the reason to restrict this method call to API 30+
        val fileUri = cr.insert(MediaStore.Downloads.EXTERNAL_CONTENT_URI, values)
            ?: throw IOException("Can't insert $displayName.")

        val projection = arrayOf(MediaStore.MediaColumns._ID, MediaStore.MediaColumns.DATA)
        cr.query(fileUri, projection, null, null, null)?.use { cursor ->
            val idIndex = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID)
            val dataColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA)
            if (cursor.moveToFirst()) {
                val id = cursor.getLong(idIndex)
                val data = cursor.getString(dataColumn)
                return MediaStoreFile(id, data)
            }
        }

        throw IOException("Can't insert $displayName.")
    }

    @RequiresApi(api = 29)
    private fun queryFile(displayName: String): UriFile? {
        val projection = arrayOf(MediaStore.MediaColumns._ID, MediaStore.MediaColumns.DATA)
        // Before Android 10, we wrote the DISPLAY_NAME field when insert, so it can be used.
        val selection = "${MediaStore.MediaColumns.DISPLAY_NAME} == ?"
        val selectionArgs = arrayOf(displayName)
        val sortOrder = "${MediaStore.MediaColumns.DATE_ADDED} DESC"
        val query = cr.query(
            MediaStore.Downloads.EXTERNAL_CONTENT_URI,
            projection, selection, selectionArgs, sortOrder)
        query?.use { cursor ->
            val idColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID)
            val dataColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA)
            while (cursor.moveToNext()) {
                val id = cursor.getLong(idColumn)
                val data = cursor.getString(dataColumn)
                if (data.endsWith(downloadPath + File.separator + displayName)) {
                    return MediaStoreFile(id, data)
                }
            }
        }
        return null
    }

    @Throws(IOException::class)
    fun getFile(displayName: String): UriFile {
        return if (Build.VERSION.SDK_INT < Build.VERSION_CODES.R) {
            // Fallback to file based I/O pre Android 11
            val parent = File(Environment.getExternalStorageDirectory(), downloadPath)
            parent.mkdirs()
            LegacyUriFile(File(parent, displayName))
        } else {
            queryFile(displayName) ?: insertFile(displayName)
        }
    }

    fun Uri.inputStream() = cr.openInputStream(this) ?: throw FileNotFoundException()

    fun Uri.outputStream() = cr.openOutputStream(this, "rwt") ?: throw FileNotFoundException()

    val Uri.displayName: String get() {
        if (scheme == "file") {
            // Simple uri wrapper over file, directly get file name
            return toFile().name
        }
        require(scheme == "content") { "Uri lacks 'content' scheme: $this" }
        val projection = arrayOf(OpenableColumns.DISPLAY_NAME)
        cr.query(this, projection, null, null, null)?.use { cursor ->
            val displayNameColumn = cursor.getColumnIndexOrThrow(OpenableColumns.DISPLAY_NAME)
            if (cursor.moveToFirst()) {
                return cursor.getString(displayNameColumn)
            }
        }
        return this.toString()
    }

    interface UriFile {
        val uri: Uri
        fun delete(): Boolean
    }

    private class LegacyUriFile(private val file: File) : UriFile {
        override val uri = file.toUri()
        override fun delete() = file.delete()
        override fun toString() = file.toString()
    }

    @RequiresApi(api = 29)
    private class MediaStoreFile(private val id: Long, private val data: String) : UriFile {
        override val uri = ContentUris.withAppendedId(MediaStore.Downloads.EXTERNAL_CONTENT_URI, id)
        override fun toString() = data
        override fun delete(): Boolean {
            val selection = "${MediaStore.MediaColumns._ID} == ?"
            val selectionArgs = arrayOf(id.toString())
            return cr.delete(uri, selection, selectionArgs) == 1
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/NetworkObserver.kt`:

```kt
package com.topjohnwu.magisk.core.utils

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import android.os.PowerManager
import androidx.collection.ArraySet
import androidx.core.content.getSystemService
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.ktx.registerRuntimeReceiver

class NetworkObserver(context: Context) {
    private val manager = context.getSystemService<ConnectivityManager>()!!

    private val networkCallback = object : ConnectivityManager.NetworkCallback() {
        private val activeList = ArraySet<Network>()

        override fun onAvailable(network: Network) {
            activeList.add(network)
            postValue(true)
        }
        override fun onLost(network: Network) {
            activeList.remove(network)
            postValue(!activeList.isEmpty())
        }
    }

    private val receiver = object : BroadcastReceiver() {
        private fun Context.isIdleMode(): Boolean {
            val pwm = getSystemService<PowerManager>() ?: return true
            val isIgnoringOptimizations = pwm.isIgnoringBatteryOptimizations(packageName)
            return pwm.isDeviceIdleMode && !isIgnoringOptimizations
        }
        override fun onReceive(context: Context, intent: Intent) {
            if (context.isIdleMode()) {
                postValue(false)
            } else {
                postCurrentState()
            }
        }
    }

    init {
        val request = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
            .build()
        manager.registerNetworkCallback(request, networkCallback)
        val filter = IntentFilter(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED)
        context.applicationContext.registerRuntimeReceiver(receiver, filter)
    }

    fun postCurrentState() {
        postValue(
            manager.getNetworkCapabilities(manager.activeNetwork)
                ?.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED) == true
        )
    }

    private fun postValue(b: Boolean) {
        Info.resetUpdate()
        Info.isConnected.postValue(b)
    }

    companion object {
        fun init(context: Context): NetworkObserver {
            return NetworkObserver(context).apply { postCurrentState() }
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/ProgressInputStream.kt`:

```kt
package com.topjohnwu.magisk.core.utils

import java.io.FilterInputStream
import java.io.InputStream

class ProgressInputStream(
    base: InputStream,
    val progressEmitter: (Long) -> Unit
) : FilterInputStream(base) {

    private var bytesRead = 0L
    private var lastUpdate = 0L

    private fun emitProgress() {
        val cur = System.currentTimeMillis()
        if (cur - lastUpdate > 1000) {
            lastUpdate = cur
            progressEmitter(bytesRead)
        }
    }

    override fun read(): Int {
        val b = read()
        if (b >= 0) {
            bytesRead++
            emitProgress()
        }
        return b
    }

    override fun read(b: ByteArray): Int {
        return read(b, 0, b.size)
    }

    override fun read(b: ByteArray, off: Int, len: Int): Int {
        val sz = super.read(b, off, len)
        if (sz > 0) {
            bytesRead += sz
            emitProgress()
        }
        return sz
    }

    override fun close() {
        super.close()
        progressEmitter(bytesRead)
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/RequestAuthentication.kt`:

```kt
package com.topjohnwu.magisk.core.utils

import android.app.Activity
import android.app.KeyguardManager
import android.content.Context
import android.content.Intent
import androidx.activity.result.contract.ActivityResultContract

class RequestAuthentication: ActivityResultContract<Unit, Boolean>() {

    override fun createIntent(context: Context, input: Unit) =
        context.getSystemService(KeyguardManager::class.java)
            .createConfirmDeviceCredentialIntent(null, null)

    override fun parseResult(resultCode: Int, intent: Intent?) =
        resultCode == Activity.RESULT_OK
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/RequestInstall.kt`:

```kt
package com.topjohnwu.magisk.core.utils

import android.annotation.TargetApi
import android.app.Activity
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Build
import android.provider.Settings
import androidx.activity.result.contract.ActivityResultContract

class RequestInstall : ActivityResultContract<Unit, Boolean>() {

    @TargetApi(26)
    override fun createIntent(context: Context, input: Unit): Intent {
        // This will only be called on API 26+
        return Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES)
            .setData(Uri.parse("package:${context.packageName}"))
    }

    override fun parseResult(resultCode: Int, intent: Intent?) =
        resultCode == Activity.RESULT_OK

    override fun getSynchronousResult(
        context: Context,
        input: Unit
    ): SynchronousResult<Boolean>? {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O)
            return SynchronousResult(true)
        if (context.packageManager.canRequestPackageInstalls())
            return SynchronousResult(true)
        return null
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/RootUtils.kt`:

```kt
package com.topjohnwu.magisk.core.utils

import android.app.ActivityManager
import android.content.ComponentName
import android.content.Intent
import android.content.ServiceConnection
import android.os.IBinder
import android.system.Os
import androidx.core.content.getSystemService
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.superuser.Shell
import com.topjohnwu.superuser.ShellUtils
import com.topjohnwu.superuser.ipc.RootService
import com.topjohnwu.superuser.nio.FileSystemManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.io.File
import java.util.concurrent.locks.AbstractQueuedSynchronizer

class RootUtils(stub: Any?) : RootService() {

    private val className: String = stub?.javaClass?.name ?: javaClass.name
    private lateinit var am: ActivityManager

    constructor() : this(null)

    init {
        Timber.plant(object : Timber.DebugTree() {
            override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {
                super.log(priority, "Magisk", message, t)
            }
        })
    }

    override fun onCreate() {
        am = getSystemService()!!
    }

    override fun getComponentName(): ComponentName {
        return ComponentName(packageName, className)
    }

    override fun onBind(intent: Intent): IBinder {
        return object : IRootUtils.Stub() {
            override fun getAppProcess(pid: Int) = safe(null) { getAppProcessImpl(pid) }
            override fun getFileSystem(): IBinder = FileSystemManager.getService()
            override fun addSystemlessHosts() = safe(false) { addSystemlessHostsImpl() }
        }
    }

    private fun getAppProcessImpl(_pid: Int): ActivityManager.RunningAppProcessInfo? {
        val procList = am.runningAppProcesses
        var pid = _pid
        while (pid > 1) {
            val proc = procList.find { it.pid == pid }
            if (proc != null)
                return proc

            // Stop find when root process
            if (Os.stat("/proc/$pid").st_uid == 0) {
                return null
            }

            // Find PPID
            File("/proc/$pid/status").useLines {
                val line = it.find { l -> l.startsWith("PPid:") } ?: return null
                pid = line.substring(5).trim().toInt()
            }
        }
        return null
    }

    private fun addSystemlessHostsImpl(): Boolean {
        val module = File(Const.MODULE_PATH, "hosts")
        if (module.exists()) return true
        val hosts = File(module, "system/etc/hosts")
        if (!hosts.parentFile.mkdirs()) return false
        File(module, "module.prop").outputStream().writer().use {
            it.write("""
                id=hosts
                name=Systemless Hosts
                version=1.0
                versionCode=1
                author=Magisk
                description=Magisk app built-in systemless hosts module
            """.trimIndent())
        }
        File("/system/etc/hosts").copyTo(hosts)
        File(module, "update").createNewFile()
        return true
    }

    object Connection : AbstractQueuedSynchronizer(), ServiceConnection {
        init {
            state = 1
        }

        override fun onServiceConnected(name: ComponentName, service: IBinder) {
            Timber.d("onServiceConnected")
            IRootUtils.Stub.asInterface(service).let {
                obj = it
                fs = FileSystemManager.getRemote(it.fileSystem)
            }
            releaseShared(1)
        }

        override fun onServiceDisconnected(name: ComponentName) {
            state = 1
            obj = null
            bind(Intent().setComponent(name), this)
        }

        override fun tryAcquireShared(acquires: Int) = if (state == 0) 1 else -1

        override fun tryReleaseShared(releases: Int): Boolean {
            // Decrement count; signal when transition to zero
            while (true) {
                val c = state
                if (c == 0)
                    return false
                val n = c - 1
                if (compareAndSetState(c, n))
                    return n == 0
            }
        }

        fun await() {
            if (!Info.isRooted)
                return
            if (!ShellUtils.onMainThread()) {
                acquireSharedInterruptibly(1)
            } else if (state != 0) {
                throw IllegalStateException("Cannot await on the main thread")
            }
        }
    }

    companion object {
        var bindTask: Shell.Task? = null
        var fs: FileSystemManager = FileSystemManager.getLocal()
            get() {
                Connection.await()
                return field
            }
            private set
        private var obj: IRootUtils? = null
            get() {
                Connection.await()
                return field
            }

        fun getAppProcess(pid: Int) = safe(null) { obj?.getAppProcess(pid) }

        suspend fun addSystemlessHosts() =
            withContext(Dispatchers.IO) { safe(false) { obj?.addSystemlessHosts() ?: false } }

        private inline fun <T> safe(default: T, block: () -> T): T {
            return try {
                block()
            } catch (e: Throwable) {
                // The process died unexpectedly
                Timber.e(e)
                default
            }
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/utils/ShellInit.kt`:

```kt
package com.topjohnwu.magisk.core.utils

import android.content.Context
import com.topjohnwu.magisk.StubApk
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.isRunningAsStub
import com.topjohnwu.magisk.core.ktx.cachedFile
import com.topjohnwu.magisk.core.ktx.deviceProtectedContext
import com.topjohnwu.magisk.core.ktx.writeTo
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import java.io.File
import java.util.jar.JarFile

class ShellInit : Shell.Initializer() {
    override fun onInit(context: Context, shell: Shell): Boolean {
        if (shell.isRoot) {
            Info.isRooted = true
            RootUtils.bindTask?.let { shell.execTask(it) }
            RootUtils.bindTask = null
        }
        shell.newJob().apply {
            add("export ASH_STANDALONE=1")

            val localBB: File
            if (isRunningAsStub) {
                if (!shell.isRoot)
                    return true
                val jar = JarFile(StubApk.current(context))
                val bb = jar.getJarEntry("lib/${Const.CPU_ABI}/libbusybox.so")
                localBB = context.deviceProtectedContext.cachedFile("busybox")
                localBB.delete()
                runBlocking {
                    jar.getInputStream(bb).writeTo(localBB, dispatcher = Dispatchers.Unconfined)
                }
                localBB.setExecutable(true)
            } else {
                localBB = File(context.applicationInfo.nativeLibraryDir, "libbusybox.so")
            }

            if (shell.isRoot) {
                add("export MAGISKTMP=\$(magisk --path)")
                // Test if we can properly execute stuff in /data
                Info.noDataExec = !shell.newJob()
                    .add("$localBB sh -c '$localBB true'").exec().isSuccess
            }

            if (Info.noDataExec) {
                // Copy it out of /data to workaround Samsung bullshit
                add(
                    "if [ -x \$MAGISKTMP/.magisk/busybox/busybox ]; then",
                    "  cp -af $localBB \$MAGISKTMP/.magisk/busybox/busybox",
                    "  exec \$MAGISKTMP/.magisk/busybox/busybox sh",
                    "else",
                    "  cp -af $localBB /dev/busybox",
                    "  exec /dev/busybox sh",
                    "fi"
                )
            } else {
                // Directly execute the file
                add("exec $localBB sh")
            }

            add(context.assets.open("app_functions.sh"))
            if (shell.isRoot) {
                add(context.assets.open("util_functions.sh"))
            }
        }.exec()

        Info.init(shell)
        return true
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/view/Notifications.kt`:

```kt
package com.topjohnwu.magisk.view

import android.annotation.SuppressLint
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.os.Build
import android.os.Build.VERSION.SDK_INT
import androidx.core.content.getSystemService
import androidx.core.graphics.drawable.toIcon
import com.topjohnwu.magisk.core.AppContext
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.download.DownloadEngine
import com.topjohnwu.magisk.core.download.Subject
import com.topjohnwu.magisk.core.ktx.getBitmap
import com.topjohnwu.magisk.core.ktx.selfLaunchIntent
import java.util.concurrent.atomic.AtomicInteger

@Suppress("DEPRECATION")
object Notifications {

    val mgr by lazy { AppContext.getSystemService<NotificationManager>()!! }

    private const val APP_UPDATED_ID = 4
    private const val APP_UPDATE_AVAILABLE_ID = 5

    private const val UPDATE_CHANNEL = "update"
    private const val PROGRESS_CHANNEL = "progress"
    private const val UPDATED_CHANNEL = "updated"

    private val nextId = AtomicInteger(APP_UPDATE_AVAILABLE_ID)

    fun setup() {
        AppContext.apply {
            if (SDK_INT >= Build.VERSION_CODES.O) {
                val channel = NotificationChannel(UPDATE_CHANNEL,
                    getString(R.string.update_channel), NotificationManager.IMPORTANCE_DEFAULT)
                val channel2 = NotificationChannel(PROGRESS_CHANNEL,
                    getString(R.string.progress_channel), NotificationManager.IMPORTANCE_LOW)
                val channel3 = NotificationChannel(UPDATED_CHANNEL,
                    getString(R.string.updated_channel), NotificationManager.IMPORTANCE_HIGH)
                mgr.createNotificationChannels(listOf(channel, channel2, channel3))
            }
        }
    }

    @SuppressLint("InlinedApi")
    fun updateDone() {
        AppContext.apply {
            val flag = PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
            val pending = PendingIntent.getActivity(this, 0, selfLaunchIntent(), flag)
            val builder = if (SDK_INT >= Build.VERSION_CODES.O) {
                Notification.Builder(this, UPDATED_CHANNEL)
                    .setSmallIcon(getBitmap(R.drawable.ic_magisk_outline).toIcon())
            } else {
                Notification.Builder(this).setPriority(Notification.PRIORITY_HIGH)
                    .setSmallIcon(R.drawable.ic_magisk_outline)
            }
                .setContentIntent(pending)
                .setContentTitle(getText(R.string.updated_title))
                .setContentText(getText(R.string.updated_text))
                .setAutoCancel(true)
            mgr.notify(APP_UPDATED_ID, builder.build())
        }
    }

    fun updateAvailable() {
        AppContext.apply {
            val intent = DownloadEngine.getPendingIntent(this, Subject.App())
            val bitmap = getBitmap(R.drawable.ic_magisk_outline)
            val builder = if (SDK_INT >= Build.VERSION_CODES.O) {
                Notification.Builder(this, UPDATE_CHANNEL)
                    .setSmallIcon(bitmap.toIcon())
            } else {
                Notification.Builder(this)
                    .setSmallIcon(R.drawable.ic_magisk_outline)
            }
                .setLargeIcon(bitmap)
                .setContentTitle(getString(R.string.magisk_update_title))
                .setContentText(getString(R.string.manager_download_install))
                .setAutoCancel(true)
                .setContentIntent(intent)

            mgr.notify(APP_UPDATE_AVAILABLE_ID, builder.build())
        }
    }

    fun startProgress(title: CharSequence): Notification.Builder {
        val builder = if (SDK_INT >= Build.VERSION_CODES.O) {
            Notification.Builder(AppContext, PROGRESS_CHANNEL)
        } else {
            Notification.Builder(AppContext).setPriority(Notification.PRIORITY_LOW)
        }
            .setSmallIcon(android.R.drawable.stat_sys_download)
            .setContentTitle(title)
            .setProgress(0, 0, true)
            .setOngoing(true)
        if (SDK_INT >= Build.VERSION_CODES.S)
            builder.setForegroundServiceBehavior(Notification.FOREGROUND_SERVICE_IMMEDIATE)
        return builder
    }

    fun nextId() = nextId.incrementAndGet()
}

```

`app/core/src/main/java/com/topjohnwu/magisk/core/view/Shortcuts.kt`:

```kt
package com.topjohnwu.magisk.view

import android.content.Context
import android.content.Intent
import android.content.pm.ShortcutInfo
import android.content.pm.ShortcutManager
import android.graphics.drawable.Icon
import android.os.Build
import androidx.annotation.RequiresApi
import androidx.core.content.getSystemService
import androidx.core.content.pm.ShortcutInfoCompat
import androidx.core.content.pm.ShortcutManagerCompat
import androidx.core.graphics.drawable.IconCompat
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.R
import com.topjohnwu.magisk.core.isRunningAsStub
import com.topjohnwu.magisk.core.ktx.getBitmap

object Shortcuts {

    fun setupDynamic(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N_MR1) {
            val manager = context.getSystemService<ShortcutManager>() ?: return
            manager.dynamicShortcuts = getShortCuts(context)
        }
    }

    fun addHomeIcon(context: Context) {
        val intent = context.packageManager.getLaunchIntentForPackage(context.packageName) ?: return
        val info = ShortcutInfoCompat.Builder(context, Const.Nav.HOME)
            .setShortLabel(context.getString(R.string.magisk))
            .setIntent(intent)
            .setIcon(context.getIconCompat(R.drawable.ic_launcher))
            .build()
        ShortcutManagerCompat.requestPinShortcut(context, info, null)
    }

    private fun Context.getIcon(id: Int): Icon {
        return if (isRunningAsStub) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
                Icon.createWithAdaptiveBitmap(getBitmap(id))
            else
                Icon.createWithBitmap(getBitmap(id))
        } else {
            Icon.createWithResource(this, id)
        }
    }

    private fun Context.getIconCompat(id: Int): IconCompat {
        return if (isRunningAsStub) {
            val bitmap = getBitmap(id)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
                IconCompat.createWithAdaptiveBitmap(bitmap)
            else
                IconCompat.createWithBitmap(bitmap)
        } else {
            IconCompat.createWithResource(this, id)
        }
    }

    @RequiresApi(api = 25)
    private fun getShortCuts(context: Context): List<ShortcutInfo> {
        val intent = context.packageManager.getLaunchIntentForPackage(context.packageName)
            ?: return emptyList()

        val shortCuts = mutableListOf<ShortcutInfo>()

        if (Info.showSuperUser) {
            shortCuts.add(
                ShortcutInfo.Builder(context, Const.Nav.SUPERUSER)
                    .setShortLabel(context.getString(R.string.superuser))
                    .setIntent(
                        Intent(intent).putExtra(Const.Key.OPEN_SECTION, Const.Nav.SUPERUSER)
                    )
                    .setIcon(context.getIcon(R.drawable.sc_superuser))
                    .setRank(0)
                    .build()
            )
        }
        if (Info.env.isActive) {
            shortCuts.add(
                ShortcutInfo.Builder(context, Const.Nav.MODULES)
                    .setShortLabel(context.getString(R.string.modules))
                    .setIntent(
                        Intent(intent).putExtra(Const.Key.OPEN_SECTION, Const.Nav.MODULES)
                    )
                    .setIcon(context.getIcon(R.drawable.sc_extension))
                    .setRank(1)
                    .build()
            )
        }
        return shortCuts
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/test/AdditionalTest.kt`:

```kt
package com.topjohnwu.magisk.test

import android.os.ParcelFileDescriptor.AutoCloseInputStream
import androidx.annotation.Keep
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.uiautomator.By
import androidx.test.uiautomator.Until
import com.topjohnwu.magisk.core.model.module.LocalModule
import com.topjohnwu.magisk.core.utils.RootUtils
import com.topjohnwu.magisk.test.Environment.Companion.EMPTY_ZYGISK
import com.topjohnwu.magisk.test.Environment.Companion.INVALID_ZYGISK
import com.topjohnwu.magisk.test.Environment.Companion.MOUNT_TEST
import com.topjohnwu.magisk.test.Environment.Companion.REMOVE_TEST
import com.topjohnwu.magisk.test.Environment.Companion.SEPOLICY_RULE
import com.topjohnwu.magisk.test.Environment.Companion.UPGRADE_TEST
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Assert.assertArrayEquals
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Assume.assumeTrue
import org.junit.BeforeClass
import org.junit.Test
import org.junit.runner.RunWith
import java.util.concurrent.TimeUnit
import java.util.regex.Pattern

@Keep
@RunWith(AndroidJUnit4::class)
class AdditionalTest : BaseTest {

    companion object {
        private const val SHELL_PKG = "com.android.shell"
        private const val LSPOSED_CATEGORY = "org.lsposed.manager.LAUNCH_MANAGER"
        private const val LSPOSED_PKG = "org.lsposed.manager"

        private lateinit var modules: List<LocalModule>

        @BeforeClass
        @JvmStatic
        fun before() {
            BaseTest.prerequisite()
            runBlocking {
                modules = LocalModule.installed()
            }
        }
    }

    @After
    fun teardown() {
        device.pressHome()
    }

    @Test
    fun testModuleCount() {
        var expected = 4
        if (Environment.mount()) expected++
        if (Environment.preinit()) expected++
        if (Environment.lsposed()) expected++
        if (Environment.shamiko()) expected++
        assertEquals("Module count incorrect", expected, modules.size)
    }

    @Test
    fun testLsposed() {
        assumeTrue(Environment.lsposed())

        val module = modules.find { it.id == "zygisk_lsposed" }
        assertNotNull("zygisk_lsposed is not installed", module)
        module!!
        assertFalse("zygisk_lsposed is not enabled", module.zygiskUnloaded)

        // Launch lsposed manager to ensure the module is active
        uiAutomation.executeShellCommand(
            "am start -c $LSPOSED_CATEGORY $SHELL_PKG/.BugreportWarningActivity"
        ).let { pfd -> AutoCloseInputStream(pfd).use { it.readBytes() } }

        val pattern = Pattern.compile("$LSPOSED_PKG:id/.*")
        assertNotNull(
            "LSPosed manager launch failed",
            device.wait(Until.hasObject(By.res(pattern)), TimeUnit.SECONDS.toMillis(10))
        )
    }

    @Test
    fun testModuleMount() {
        assumeTrue(Environment.mount())

        assertNotNull("$MOUNT_TEST is not installed", modules.find { it.id == MOUNT_TEST })
        assertTrue(
            "/system/fonts/newfile should exist",
            RootUtils.fs.getFile("/system/fonts/newfile").exists()
        )
        assertFalse(
            "/system/bin/screenrecord should not exist",
            RootUtils.fs.getFile("/system/bin/screenrecord").exists()
        )
        val egg = RootUtils.fs.getFile("/system/app/EasterEgg").list() ?: arrayOf()
        assertArrayEquals(
            "/system/app/EasterEgg should be replaced",
            egg,
            arrayOf("newfile")
        )
    }

    @Test
    fun testSepolicyRule() {
        assumeTrue(Environment.preinit())

        assertNotNull("$SEPOLICY_RULE is not installed", modules.find { it.id == SEPOLICY_RULE })
        assertTrue(
            "Module sepolicy.rule is not applied",
            Shell.cmd("magiskpolicy --print-rules | grep -q magisk_test").exec().isSuccess
        )
    }

    @Test
    fun testEmptyZygiskModule() {
        val module = modules.find { it.id == EMPTY_ZYGISK }
        assertNotNull("$EMPTY_ZYGISK is not installed", module)
        module!!
        assertTrue("$EMPTY_ZYGISK should be zygisk unloaded", module.zygiskUnloaded)
    }

    @Test
    fun testInvalidZygiskModule() {
        val module = modules.find { it.id == INVALID_ZYGISK }
        assertNotNull("$INVALID_ZYGISK is not installed", module)
        module!!
        assertTrue("$INVALID_ZYGISK should be zygisk unloaded", module.zygiskUnloaded)
    }

    @Test
    fun testRemoveModule() {
        assertNull("$REMOVE_TEST should be removed", modules.find { it.id == REMOVE_TEST })
        assertTrue(
            "Uninstaller of $REMOVE_TEST should be run",
            RootUtils.fs.getFile(Environment.REMOVE_TEST_MARKER).exists()
        )
    }

    @Test
    fun testModuleUpgrade() {
        val module = modules.find { it.id == UPGRADE_TEST }
        assertNotNull("$UPGRADE_TEST is not installed", module)
        module!!
        assertFalse("$UPGRADE_TEST should be disabled", module.enable)
        assertTrue(
            "$UPGRADE_TEST should be updated",
            module.base.getChildFile("post-fs-data.sh").exists()
        )
        assertFalse(
            "$UPGRADE_TEST should be updated",
            module.base.getChildFile("service.sh").exists()
        )
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/test/BaseTest.kt`:

```kt
package com.topjohnwu.magisk.test

import android.app.Instrumentation
import android.app.UiAutomation
import android.content.Context
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.uiautomator.UiDevice
import com.topjohnwu.magisk.core.utils.RootUtils
import com.topjohnwu.superuser.Shell
import org.junit.Assert.assertTrue

interface BaseTest {
    val instrumentation: Instrumentation
        get() = InstrumentationRegistry.getInstrumentation()
    val appContext: Context get() = instrumentation.targetContext
    val testContext: Context get() = instrumentation.context
    val uiAutomation: UiAutomation get() = instrumentation.uiAutomation
    val device: UiDevice get() = UiDevice.getInstance(instrumentation)

    companion object {
        fun prerequisite() {
            assertTrue("Should have root access", Shell.getShell().isRoot)
            // Make sure the root service is running
            RootUtils.Connection.await()
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/test/Environment.kt`:

```kt
package com.topjohnwu.magisk.test

import android.app.Notification
import android.os.Build
import androidx.annotation.Keep
import androidx.core.net.toUri
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.topjohnwu.magisk.core.BuildConfig.APP_PACKAGE_NAME
import com.topjohnwu.magisk.core.Const
import com.topjohnwu.magisk.core.download.DownloadNotifier
import com.topjohnwu.magisk.core.download.DownloadProcessor
import com.topjohnwu.magisk.core.ktx.cachedFile
import com.topjohnwu.magisk.core.model.module.LocalModule
import com.topjohnwu.magisk.core.tasks.AppMigration
import com.topjohnwu.magisk.core.tasks.FlashZip
import com.topjohnwu.magisk.core.tasks.MagiskInstaller
import com.topjohnwu.magisk.core.utils.RootUtils
import com.topjohnwu.superuser.CallbackList
import com.topjohnwu.superuser.Shell
import com.topjohnwu.superuser.nio.ExtendedFile
import kotlinx.coroutines.runBlocking
import org.apache.commons.compress.archivers.zip.ZipFile
import org.junit.Assert.assertArrayEquals
import org.junit.Assert.assertEquals
import org.junit.Assert.assertTrue
import org.junit.BeforeClass
import org.junit.Test
import org.junit.runner.RunWith
import timber.log.Timber
import java.io.File
import java.io.PrintStream

@Keep
@RunWith(AndroidJUnit4::class)
class Environment : BaseTest {

    companion object {
        @BeforeClass
        @JvmStatic
        fun before() = BaseTest.prerequisite()

        // The kernel running on emulators < API 26 does not play well with
        // magic mount. Skip mount_test on those legacy platforms.
        fun mount(): Boolean {
            return Build.VERSION.SDK_INT >= 26
        }

        // It is possible that there are no suitable preinit partition to use
        fun preinit(): Boolean {
            return Shell.cmd("magisk --preinit-device").exec().isSuccess
        }

        fun lsposed(): Boolean {
            return Build.VERSION.SDK_INT in 27..34
        }

        fun shamiko(): Boolean {
            return Build.VERSION.SDK_INT >= 27
        }

        private const val MODULE_UPDATE_PATH  = "/data/adb/modules_update"
        private const val MODULE_ERROR = "Module zip processing incorrect"
        const val MOUNT_TEST = "mount_test"
        const val SEPOLICY_RULE = "sepolicy_rule"
        const val INVALID_ZYGISK = "invalid_zygisk"
        const val REMOVE_TEST = "remove_test"
        const val REMOVE_TEST_MARKER = "/dev/.remove_test_removed"
        const val EMPTY_ZYGISK = "empty_zygisk"
        const val UPGRADE_TEST = "upgrade_test"
    }

    object TimberLog : CallbackList<String>(Runnable::run) {
        override fun onAddElement(e: String) {
            Timber.i(e)
        }
    }

    private fun checkModuleZip(file: File) {
        // Make sure module processing is correct
        ZipFile.Builder().setFile(file).get().use { zip ->
            val meta = zip.entries
                .asSequence()
                .filter { it.name.startsWith("META-INF") }
                .toMutableList()
            assertEquals(MODULE_ERROR, 6, meta.size)

            val binary = zip.getInputStream(
                zip.getEntry("META-INF/com/google/android/update-binary")
            ).use { it.readBytes() }
            val ref = appContext.assets.open("module_installer.sh").use { it.readBytes() }
            assertArrayEquals(MODULE_ERROR, ref, binary)

            val script = zip.getInputStream(
                zip.getEntry("META-INF/com/google/android/updater-script")
            ).use { it.readBytes() }
            assertArrayEquals(MODULE_ERROR, "#MAGISK\n".toByteArray(), script)
        }
    }

    private fun setupMountTest(root: ExtendedFile) {
        val error = "$MOUNT_TEST setup failed"
        val path = root.getChildFile(MOUNT_TEST)

        // Create /system/fonts/newfile
        val etc = path.getChildFile("system").getChildFile("fonts")
        assertTrue(error, etc.mkdirs())
        assertTrue(error, etc.getChildFile("newfile").createNewFile())

        // Create /system/app/EasterEgg/.replace
        val egg = path.getChildFile("system").getChildFile("app").getChildFile("EasterEgg")
        assertTrue(error, egg.mkdirs())
        assertTrue(error, egg.getChildFile(".replace").createNewFile())

        // Create /system/app/EasterEgg/newfile
        assertTrue(error, egg.getChildFile("newfile").createNewFile())

        // Delete /system/bin/screenrecord
        val bin = path.getChildFile("system").getChildFile("bin")
        assertTrue(error, bin.mkdirs())
        assertTrue(error, Shell.cmd("mknod $bin/screenrecord c 0 0").exec().isSuccess)

        assertTrue(error, Shell.cmd("set_default_perm $path").exec().isSuccess)
    }

    private fun setupSystemlessHost() {
        val error = "hosts setup failed"
        assertTrue(error, runBlocking { RootUtils.addSystemlessHosts() })
        assertTrue(error, RootUtils.fs.getFile(Const.MODULE_PATH).getChildFile("hosts").exists())
    }

    private fun setupSepolicyRuleModule(root: ExtendedFile) {
        val error = "$SEPOLICY_RULE setup failed"
        val path = root.getChildFile(SEPOLICY_RULE)
        assertTrue(error, path.mkdirs())

        // Add sepolicy patch
        PrintStream(path.getChildFile("sepolicy.rule").newOutputStream()).use {
            it.println("type magisk_test domain")
        }

        assertTrue(error, Shell.cmd(
            "set_default_perm $path",
            "copy_preinit_files"
        ).exec().isSuccess)
    }

    private fun setupEmptyZygiskModule(root: ExtendedFile) {
        val error = "$EMPTY_ZYGISK setup failed"
        val path = root.getChildFile(EMPTY_ZYGISK)

        // Create an empty zygisk folder
        val module = LocalModule(path)
        assertTrue(error, module.zygiskFolder.mkdirs())
    }

    private fun setupInvalidZygiskModule(root: ExtendedFile) {
        val error = "$INVALID_ZYGISK setup failed"
        val path = root.getChildFile(INVALID_ZYGISK)

        // Create invalid zygisk libraries
        val module = LocalModule(path)
        assertTrue(error, module.zygiskFolder.mkdirs())
        assertTrue(error, module.zygiskFolder.getChildFile("armeabi-v7a.so").createNewFile())
        assertTrue(error, module.zygiskFolder.getChildFile("arm64-v8a.so").createNewFile())
        assertTrue(error, module.zygiskFolder.getChildFile("x86.so").createNewFile())
        assertTrue(error, module.zygiskFolder.getChildFile("x86_64.so").createNewFile())

        assertTrue(error, Shell.cmd("set_default_perm $path").exec().isSuccess)
    }

    private fun setupRemoveModule(root: ExtendedFile) {
        val error = "$REMOVE_TEST setup failed"
        val path = root.getChildFile(REMOVE_TEST)

        // Create a new module but mark is as "remove"
        val module = LocalModule(path)
        assertTrue(error, path.mkdirs())
        // Create uninstaller script
        path.getChildFile("uninstall.sh").newOutputStream().writer().use {
            it.write("touch $REMOVE_TEST_MARKER")
        }
        assertTrue(error, path.getChildFile("service.sh").createNewFile())
        module.remove = true

        assertTrue(error, Shell.cmd("set_default_perm $path").exec().isSuccess)
    }

    private fun setupUpgradeModule(root: ExtendedFile, update: ExtendedFile) {
        val error = "$UPGRADE_TEST setup failed"
        val oldPath = root.getChildFile(UPGRADE_TEST)
        val newPath = update.getChildFile(UPGRADE_TEST)

        // Create an existing module but mark as "disable
        val module = LocalModule(oldPath)
        assertTrue(error, oldPath.mkdirs())
        module.enable = false
        // Install service.sh into the old module
        assertTrue(error, oldPath.getChildFile("service.sh").createNewFile())

        // Create an upgrade module
        assertTrue(error, newPath.mkdirs())
        // Install post-fs-data.sh into the new module
        assertTrue(error, newPath.getChildFile("post-fs-data.sh").createNewFile())

        assertTrue(error, Shell.cmd(
            "set_default_perm $oldPath",
            "set_default_perm $newPath",
        ).exec().isSuccess)
    }

    @Test
    fun setupEnvironment() {
        runBlocking {
            assertTrue(
                "Magisk setup failed",
                MagiskInstaller.Emulator(TimberLog, TimberLog).exec()
            )
        }

        val notify = object : DownloadNotifier {
            override val context = appContext
            override fun notifyUpdate(id: Int, editor: (Notification.Builder) -> Unit) {}
        }
        val processor = DownloadProcessor(notify)

        val shamiko = appContext.cachedFile("shamiko.zip")
        runBlocking {
            testContext.assets.open("shamiko.zip").use {
                processor.handleModule(it, shamiko.toUri())
            }
            checkModuleZip(shamiko)
            if (shamiko()) {
                assertTrue(
                    "Shamiko installation failed",
                    FlashZip(shamiko.toUri(), TimberLog, TimberLog).exec()
                )
            }
        }

        val lsp = appContext.cachedFile("lsposed.zip")
        runBlocking {
            testContext.assets.open("lsposed.zip").use {
                processor.handleModule(it, lsp.toUri())
            }
            checkModuleZip(lsp)
            if (lsposed()) {
                assertTrue(
                    "LSPosed installation failed",
                    FlashZip(lsp.toUri(), TimberLog, TimberLog).exec()
                )
            }
        }

        val root = RootUtils.fs.getFile(Const.MODULE_PATH)
        val update = RootUtils.fs.getFile(MODULE_UPDATE_PATH)
        if (mount()) { setupMountTest(update) }
        if (preinit()) { setupSepolicyRuleModule(update) }
        setupSystemlessHost()
        setupEmptyZygiskModule(update)
        setupInvalidZygiskModule(update)
        setupRemoveModule(root)
        setupUpgradeModule(root, update)
    }

    @Test
    fun setupAppHide() {
        runBlocking {
            assertTrue(
                "App hiding failed",
                AppMigration.patchAndHide(
                    context = appContext,
                    label = "Settings",
                    pkg = "repackaged.$APP_PACKAGE_NAME"
                )
            )
        }
    }

    @Test
    fun setupAppRestore() {
        runBlocking {
            assertTrue(
                "App restoration failed",
                AppMigration.restoreApp(appContext)
            )
        }
    }
}

```

`app/core/src/main/java/com/topjohnwu/magisk/test/MagiskAppTest.kt`:

```kt
package com.topjohnwu.magisk.test

import android.content.Intent
import android.content.IntentFilter
import android.os.Build
import android.os.ParcelFileDescriptor.AutoCloseInputStream
import androidx.annotation.Keep
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.topjohnwu.magisk.core.Config
import com.topjohnwu.magisk.core.Info
import com.topjohnwu.magisk.core.di.ServiceLocator
import com.topjohnwu.magisk.core.model.su.SuPolicy
import kotlinx.coroutines.runBlocking
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertTrue
import org.junit.BeforeClass
import org.junit.Test
import org.junit.runner.RunWith
import java.util.concurrent.TimeUnit

@Keep
@RunWith(AndroidJUnit4::class)
class MagiskAppTest : BaseTest {

    companion object {
        @BeforeClass
        @JvmStatic
        fun before() = BaseTest.prerequisite()
    }

    @Test
    fun testZygisk() {
        assertTrue("Zygisk should be enabled", Info.isZygiskEnabled)
    }

    @Test
    fun testSuRequest() {
        // Bypass the need to actually show a dialog
        Config.suAutoResponse = Config.Value.SU_AUTO_ALLOW
        Config.prefs.edit().commit()

        // Inject an undetermined + mute logging policy for ADB shell
        val policy = SuPolicy(
            uid = 2000,
            logging = false,
            notification = false,
            remain = 0L
        )
        runBlocking {
            ServiceLocator.policyDB.update(policy)
        }

        val filter = IntentFilter(Intent.ACTION_VIEW)
        filter.addCategory(Intent.CATEGORY_DEFAULT)
        val monitor = instrumentation.addMonitor(filter, null, false)

        // Try to call su from ADB shell
        val cmd = if (Build.VERSION.SDK_INT < 24) {
            // API 23 runs executeShellCommand as root
            "/system/xbin/su 2000 su -c id"
        } else {
            "su -c id"
        }
        val pfd = uiAutomation.executeShellCommand(cmd)

        // Make sure SuRequestActivity is launched
        val suRequest = monitor.waitForActivityWithTimeout(TimeUnit.SECONDS.toMillis(10))
        assertNotNull("SuRequestActivity is not launched", suRequest)

        // Check that the request went through
        AutoCloseInputStream(pfd).reader().use {
            assertTrue(
                "Cannot grant root permission from shell",
                it.readText().contains("uid=0")
            )
        }

        // Check that the database is updated
        runBlocking {
            val policy = ServiceLocator.policyDB.fetch(2000)
                ?: throw AssertionError("PolicyDB is invalid")
            assertEquals("Policy for shell is incorrect", SuPolicy.ALLOW, policy.policy)
        }
    }
}

```

`app/core/src/main/res/drawable-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_magisk_padded" />
    <monochrome android:drawable="@drawable/ic_magisk_padded" />
</adaptive-icon>

```

`app/core/src/main/res/drawable-v26/sc_extension.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/light" />
    <foreground>
        <inset
            android:drawable="@drawable/ic_extension"
            android:inset="30%" />
    </foreground>
    <monochrome>
        <inset
            android:drawable="@drawable/ic_extension"
            android:inset="30%" />
    </monochrome>
</adaptive-icon>

```

`app/core/src/main/res/drawable-v26/sc_superuser.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/light" />
    <foreground>
        <inset
            android:drawable="@drawable/ic_superuser"
            android:inset="30%" />
    </foreground>
    <monochrome>
        <inset
            android:drawable="@drawable/ic_superuser"
            android:inset="30%" />
    </monochrome>
</adaptive-icon>

```

`app/core/src/main/res/drawable/ic_extension.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportHeight="24.0"
        android:viewportWidth="24.0">
    <path
        android:fillColor="@color/dark"
        android:pathData="M20.5,11H19V7c0,-1.1 -0.9,-2 -2,-2h-4V3.5C13,2.12 11.88,1 10.5,1S8,2.12 8,3.5V5H4c-1.1,0 -1.99,0.9 -1.99,2v3.8H3.5c1.49,0 2.7,1.21 2.7,2.7s-1.21,2.7 -2.7,2.7H2V20c0,1.1 0.9,2 2,2h3.8v-1.5c0,-1.49 1.21,-2.7 2.7,-2.7 1.49,0 2.7,1.21 2.7,2.7V22H17c1.1,0 2,-0.9 2,-2v-4h1.5c1.38,0 2.5,-1.12 2.5,-2.5S21.88,11 20.5,11z"/>
</vector>

```

`app/core/src/main/res/drawable/ic_favorite.xml`:

```xml
<vector android:height="24dp" android:tint="#000000"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M12,21.35l-1.45,-1.32C5.4,15.36 2,12.28 2,8.5 2,5.42 4.42,3 7.5,3c1.74,0 3.41,0.81 4.5,2.09C13.09,3.81 14.76,3 16.5,3 19.58,3 22,5.42 22,8.5c0,3.78 -3.4,6.86 -8.55,11.54L12,21.35z"/>
</vector>

```

`app/core/src/main/res/drawable/ic_fingerprint.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#FF000000"
        android:pathData="M17.81,4.47c-0.08,0 -0.16,-0.02 -0.23,-0.06C15.66,3.42 14,3 12.01,3c-1.98,0 -3.86,0.47 -5.57,1.41 -0.24,0.13 -0.54,0.04 -0.68,-0.2 -0.13,-0.24 -0.04,-0.55 0.2,-0.68C7.82,2.52 9.86,2 12.01,2c2.13,0 3.99,0.47 6.03,1.52 0.25,0.13 0.34,0.43 0.21,0.67 -0.09,0.18 -0.26,0.28 -0.44,0.28zM3.5,9.72c-0.1,0 -0.2,-0.03 -0.29,-0.09 -0.23,-0.16 -0.28,-0.47 -0.12,-0.7 0.99,-1.4 2.25,-2.5 3.75,-3.27C9.98,4.04 14,4.03 17.15,5.65c1.5,0.77 2.76,1.86 3.75,3.25 0.16,0.22 0.11,0.54 -0.12,0.7 -0.23,0.16 -0.54,0.11 -0.7,-0.12 -0.9,-1.26 -2.04,-2.25 -3.39,-2.94 -2.87,-1.47 -6.54,-1.47 -9.4,0.01 -1.36,0.7 -2.5,1.7 -3.4,2.96 -0.08,0.14 -0.23,0.21 -0.39,0.21zM9.75,21.79c-0.13,0 -0.26,-0.05 -0.35,-0.15 -0.87,-0.87 -1.34,-1.43 -2.01,-2.64 -0.69,-1.23 -1.05,-2.73 -1.05,-4.34 0,-2.97 2.54,-5.39 5.66,-5.39s5.66,2.42 5.66,5.39c0,0.28 -0.22,0.5 -0.5,0.5s-0.5,-0.22 -0.5,-0.5c0,-2.42 -2.09,-4.39 -4.66,-4.39 -2.57,0 -4.66,1.97 -4.66,4.39 0,1.44 0.32,2.77 0.93,3.85 0.64,1.15 1.08,1.64 1.85,2.42 0.19,0.2 0.19,0.51 0,0.71 -0.11,0.1 -0.24,0.15 -0.37,0.15zM16.92,19.94c-1.19,0 -2.24,-0.3 -3.1,-0.89 -1.49,-1.01 -2.38,-2.65 -2.38,-4.39 0,-0.28 0.22,-0.5 0.5,-0.5s0.5,0.22 0.5,0.5c0,1.41 0.72,2.74 1.94,3.56 0.71,0.48 1.54,0.71 2.54,0.71 0.24,0 0.64,-0.03 1.04,-0.1 0.27,-0.05 0.53,0.13 0.58,0.41 0.05,0.27 -0.13,0.53 -0.41,0.58 -0.57,0.11 -1.07,0.12 -1.21,0.12zM14.91,22c-0.04,0 -0.09,-0.01 -0.13,-0.02 -1.59,-0.44 -2.63,-1.03 -3.72,-2.1 -1.4,-1.39 -2.17,-3.24 -2.17,-5.22 0,-1.62 1.38,-2.94 3.08,-2.94 1.7,0 3.08,1.32 3.08,2.94 0,1.07 0.93,1.94 2.08,1.94s2.08,-0.87 2.08,-1.94c0,-3.77 -3.25,-6.83 -7.25,-6.83 -2.84,0 -5.44,1.58 -6.61,4.03 -0.39,0.81 -0.59,1.76 -0.59,2.8 0,0.78 0.07,2.01 0.67,3.61 0.1,0.26 -0.03,0.55 -0.29,0.64 -0.26,0.1 -0.55,-0.04 -0.64,-0.29 -0.49,-1.31 -0.73,-2.61 -0.73,-3.96 0,-1.2 0.23,-2.29 0.68,-3.24 1.33,-2.79 4.28,-4.6 7.51,-4.6 4.55,0 8.25,3.51 8.25,7.83 0,1.62 -1.38,2.94 -3.08,2.94s-3.08,-1.32 -3.08,-2.94c0,-1.07 -0.93,-1.94 -2.08,-1.94s-2.08,0.87 -2.08,1.94c0,1.71 0.66,3.31 1.87,4.51 0.95,0.94 1.86,1.46 3.27,1.85 0.27,0.07 0.42,0.35 0.35,0.61 -0.05,0.23 -0.26,0.38 -0.47,0.38z"/>
</vector>

```

`app/core/src/main/res/drawable/ic_github.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24.0dip"
        android:height="24.0dip"
        android:viewportHeight="24.0"
        android:viewportWidth="24.0">
    <path
        android:fillColor="#757575"
        android:pathData="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"/>
</vector>
```

`app/core/src/main/res/drawable/ic_logo.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <shape android:shape="oval">
            <solid android:color="#00AF9C"/>
        </shape>
    </item>

    <item android:drawable="@drawable/ic_magisk" />

</layer-list>
```

`app/core/src/main/res/drawable/ic_magisk.xml`:

```xml
<vector android:height="48dp" android:viewportHeight="720"
    android:viewportWidth="720" android:width="48dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#303030" android:pathData="M332.48,421.18c0,0 3.77,22.45 -0.82,71.95c-5.76,62.06 23.64,160.64 23.64,160.64c0,0 40.1,-98.78 33.1,-162.59c-5.75,-52.45 2.6,-70.79 0.82,-68.33c-30.81,42.57 -56.75,-1.67 -56.75,-1.67z"/>
    <path android:fillColor="#ffffff" android:pathData="M407.6,474.45c5.01,38.77 -0.57,60.01 -7.81,101.51c-3.66,20.99 74.78,-63.1 104.86,-113.23c5.02,-8.36 -28.77,32.6 -62.19,3.35c-23.18,-20.28 -27.16,-26.44 -45.18,-44.06c-6.08,-5.94 6.74,24.72 10.32,52.43z"/>
    <path android:fillColor="#ffffff" android:pathData="M321.99,425.09c-18.02,17.62 -22,23.78 -45.18,44.06c-33.42,29.25 -67.21,-11.71 -62.19,-3.35c30.08,50.13 108.52,134.22 104.86,113.23c-7.24,-41.5 -12.82,-62.74 -7.81,-101.51c3.58,-27.71 16.4,-58.37 10.32,-52.43z"/>
    <path android:fillColor="#303030" android:pathData="M399.15,355.87c36.67,10.57 50.89,61.5 87.91,67.8c7.65,1.3 16.27,3.6 26.31,3.12c18.77,-0.9 42.51,-11.51 74.22,-56.5c9.38,-13.3 -23.27,85.66 -105.13,86.86c-59.96,0.88 -66.97,-58.7 -106.93,-60.51c-14.43,-0.65 -15.34,-28.17 -15.34,-28.17c0,0 17.22,-18.86 38.96,-12.6z"/>
    <path android:fillColor="#303030" android:pathData="M321.51,355.59c-36.67,10.57 -50.89,61.5 -87.91,67.8c-7.65,1.3 -16.27,3.6 -26.31,3.12c-18.77,-0.9 -42.51,-11.51 -74.22,-56.5c-9.38,-13.3 23.27,85.66 105.13,86.86c59.96,0.88 66.97,-58.7 106.93,-60.51c14.43,-0.65 15.34,-28.17 15.34,-28.17c0,0 -17.22,-18.86 -38.96,-12.6z"/>
    <path android:fillColor="#fbbcc9" android:pathData="M458.64,355.09c36.87,27.94 25.88,58.7 46.57,49.92c69.7,-29.55 57.51,-181.21 51.87,-162.87c-31.77,103.41 -100.99,109.2 -167.61,61.63c-13.01,-9.29 48.38,35.57 69.16,51.31z"/>
    <path android:fillColor="#fbbcc9" android:pathData="M330.91,303.77c-66.62,47.56 -135.84,41.78 -167.61,-61.63c-5.63,-18.34 -17.82,133.31 51.87,162.87c20.7,8.78 9.7,-21.98 46.57,-49.92c20.78,-15.75 82.17,-60.6 69.16,-51.31z"/>
    <path android:fillColor="#3747a9" android:pathData="M465.61,318c80.43,-3.32 95.29,-135.17 88.96,-119.08c-28.39,72.22 -135.86,45.05 -146.13,90.64c-2.02,8.94 18.2,30.06 57.17,28.45z"/>
    <path android:fillColor="#3747a9" android:pathData="M311.95,289.55c-10.27,-45.59 -117.75,-18.41 -146.13,-90.64c-6.32,-16.09 8.53,115.76 88.96,119.08c38.97,1.61 59.19,-19.5 57.17,-28.45z"/>
    <path android:fillColor="#ff6e40" android:pathData="M403.42,269.47c0,0 43.73,-23.5 81.16,-33.74c34.99,-9.58 61.22,-33.13 64.14,-58.01c2.18,-18.53 -27.05,-53.55 -27.05,-53.55c0,0 -20.51,56.9 -47.41,85.34c-29.28,30.96 -18.15,26.78 -70.84,59.96z"/>
    <path android:fillColor="#ff6e40" android:pathData="M246.13,209.51c-26.9,-28.44 -47.41,-85.34 -47.41,-85.34c0,0 -29.23,35.01 -27.05,53.55c2.93,24.88 29.16,48.43 64.14,58.01c37.43,10.25 81.16,33.74 81.16,33.74c-52.69,-33.18 -41.55,-29 -70.84,-59.96z"/>
    <path android:fillColor="#ffffff" android:pathData="M398.12,265.85c47.36,-38.85 72.53,-89.54 113.51,-145.02c7.73,-10.46 -34.58,-35.7 -51.31,-37.37c-16.73,-1.67 -30.77,59.79 -32.35,95.94c-1.44,33.01 -36.21,91.68 -29.84,86.45z"/>
    <path android:fillColor="#ffffff" android:pathData="M292.42,179.39c-1.58,-36.15 -15.62,-97.61 -32.35,-95.94c-16.73,1.67 -59.04,26.91 -51.31,37.37c40.98,55.48 66.14,106.17 113.51,145.02c6.37,5.22 -28.4,-53.45 -29.84,-86.45z"/>
    <path android:fillColor="#ffb327" android:pathData="M402.86,140.35c3.34,-26.76 15.37,-46.32 39.32,-62.75c-21.17,-7.08 -38.77,-12.83 -47.97,-5.3c-9.2,7.53 -34.2,32.7 -30.85,73.68c3.34,40.98 0.18,194.09 7.43,191.25c3.9,-104.87 37.09,-135 32.07,-196.89z"/>
    <path android:fillColor="#ffb327" android:pathData="M349.59,337.24c7.24,2.83 4.08,-150.27 7.43,-191.25c3.34,-40.98 -21.65,-66.16 -30.85,-73.68c-9.2,-7.53 -26.8,-1.78 -47.97,5.3c23.95,16.43 35.98,35.98 39.32,62.75c-5.02,61.89 28.17,92.02 32.07,196.89z"/>
</vector>

```

`app/core/src/main/res/drawable/ic_magisk_outline.xml`:

```xml
<vector android:height="48dp" android:viewportHeight="720"
    android:viewportWidth="720" android:width="48dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#ffffff" android:pathData="M332.48,421.18c0,0 3.77,22.45 -0.82,71.95c-5.76,62.06 23.64,160.64 23.64,160.64c0,0 40.1,-98.78 33.1,-162.59c-5.75,-52.45 2.6,-70.79 0.82,-68.33c-30.81,42.57 -56.75,-1.67 -56.75,-1.67z"/>
    <path android:fillColor="#ffffff" android:pathData="M407.6,474.45c5.01,38.77 -0.57,60.01 -7.81,101.51c-3.66,20.99 74.78,-63.1 104.86,-113.23c5.02,-8.36 -28.77,32.6 -62.19,3.35c-23.18,-20.28 -27.16,-26.44 -45.18,-44.06c-6.08,-5.94 6.74,24.72 10.32,52.43z"/>
    <path android:fillColor="#ffffff" android:pathData="M321.99,425.09c-18.02,17.62 -22,23.78 -45.18,44.06c-33.42,29.25 -67.21,-11.71 -62.19,-3.35c30.08,50.13 108.52,134.22 104.86,113.23c-7.24,-41.5 -12.82,-62.74 -7.81,-101.51c3.58,-27.71 16.4,-58.37 10.32,-52.43z"/>
    <path android:fillColor="#ffffff" android:pathData="M399.15,355.87c36.67,10.57 50.89,61.5 87.91,67.8c7.65,1.3 16.27,3.6 26.31,3.12c18.77,-0.9 42.51,-11.51 74.22,-56.5c9.38,-13.3 -23.27,85.66 -105.13,86.86c-59.96,0.88 -66.97,-58.7 -106.93,-60.51c-14.43,-0.65 -15.34,-28.17 -15.34,-28.17c0,0 17.22,-18.86 38.96,-12.6z"/>
    <path android:fillColor="#ffffff" android:pathData="M321.51,355.59c-36.67,10.57 -50.89,61.5 -87.91,67.8c-7.65,1.3 -16.27,3.6 -26.31,3.12c-18.77,-0.9 -42.51,-11.51 -74.22,-56.5c-9.38,-13.3 23.27,85.66 105.13,86.86c59.96,0.88 66.97,-58.7 106.93,-60.51c14.43,-0.65 15.34,-28.17 15.34,-28.17c0,0 -17.22,-18.86 -38.96,-12.6z"/>
    <path android:fillColor="#ffffff" android:pathData="M458.64,355.09c36.87,27.94 25.88,58.7 46.57,49.92c69.7,-29.55 57.51,-181.21 51.87,-162.87c-31.77,103.41 -100.99,109.2 -167.61,61.63c-13.01,-9.29 48.38,35.57 69.16,51.31z"/>
    <path android:fillColor="#ffffff" android:pathData="M330.91,303.77c-66.62,47.56 -135.84,41.78 -167.61,-61.63c-5.63,-18.34 -17.82,133.31 51.87,162.87c20.7,8.78 9.7,-21.98 46.57,-49.92c20.78,-15.75 82.17,-60.6 69.16,-51.31z"/>
    <path android:fillColor="#ffffff" android:pathData="M465.61,318c80.43,-3.32 95.29,-135.17 88.96,-119.08c-28.39,72.22 -135.86,45.05 -146.13,90.64c-2.02,8.94 18.2,30.06 57.17,28.45z"/>
    <path android:fillColor="#ffffff" android:pathData="M311.95,289.55c-10.27,-45.59 -117.75,-18.41 -146.13,-90.64c-6.32,-16.09 8.53,115.76 88.96,119.08c38.97,1.61 59.19,-19.5 57.17,-28.45z"/>
    <path android:fillColor="#ffffff" android:pathData="M403.42,269.47c0,0 43.73,-23.5 81.16,-33.74c34.99,-9.58 61.22,-33.13 64.14,-58.01c2.18,-18.53 -27.05,-53.55 -27.05,-53.55c0,0 -20.51,56.9 -47.41,85.34c-29.28,30.96 -18.15,26.78 -70.84,59.96z"/>
    <path android:fillColor="#ffffff" android:pathData="M246.13,209.51c-26.9,-28.44 -47.41,-85.34 -47.41,-85.34c0,0 -29.23,35.01 -27.05,53.55c2.93,24.88 29.16,48.43 64.14,58.01c37.43,10.25 81.16,33.74 81.16,33.74c-52.69,-33.18 -41.55,-29 -70.84,-59.96z"/>
    <path android:fillColor="#ffffff" android:pathData="M398.12,265.85c47.36,-38.85 72.53,-89.54 113.51,-145.02c7.73,-10.46 -34.58,-35.7 -51.31,-37.37c-16.73,-1.67 -30.77,59.79 -32.35,95.94c-1.44,33.01 -36.21,91.68 -29.84,86.45z"/>
    <path android:fillColor="#ffffff" android:pathData="M292.42,179.39c-1.58,-36.15 -15.62,-97.61 -32.35,-95.94c-16.73,1.67 -59.04,26.91 -51.31,37.37c40.98,55.48 66.14,106.17 113.51,145.02c6.37,5.22 -28.4,-53.45 -29.84,-86.45z"/>
    <path android:fillColor="#ffffff" android:pathData="M402.86,140.35c3.34,-26.76 15.37,-46.32 39.32,-62.75c-21.17,-7.08 -38.77,-12.83 -47.97,-5.3c-9.2,7.53 -34.2,32.7 -30.85,73.68c3.34,40.98 0.18,194.09 7.43,191.25c3.9,-104.87 37.09,-135 32.07,-196.89z"/>
    <path android:fillColor="#ffffff" android:pathData="M349.59,337.24c7.24,2.83 4.08,-150.27 7.43,-191.25c3.34,-40.98 -21.65,-66.16 -30.85,-73.68c-9.2,-7.53 -26.8,-1.78 -47.97,5.3c23.95,16.43 35.98,35.98 39.32,62.75c-5.02,61.89 28.17,92.02 32.07,196.89z"/>
</vector>

```

`app/core/src/main/res/drawable/ic_magisk_padded.xml`:

```xml
<vector android:height="108dp" android:viewportHeight="1080"
    android:viewportWidth="1080" android:width="108dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#303030" android:pathData="M512.48,601.18c0,0 3.77,22.45 -0.82,71.95c-5.76,62.06 23.64,160.64 23.64,160.64c0,0 40.1,-98.78 33.1,-162.59c-5.75,-52.45 2.6,-70.79 0.82,-68.33c-30.81,42.57 -56.75,-1.67 -56.75,-1.67z"/>
    <path android:fillColor="#ffffff" android:pathData="M587.6,654.45c5.01,38.77 -0.57,60.01 -7.81,101.51c-3.66,20.99 74.78,-63.1 104.86,-113.23c5.02,-8.36 -28.77,32.6 -62.19,3.35c-23.18,-20.28 -27.16,-26.44 -45.18,-44.06c-6.08,-5.94 6.74,24.72 10.32,52.43z"/>
    <path android:fillColor="#ffffff" android:pathData="M501.99,605.09c-18.02,17.62 -22,23.78 -45.18,44.06c-33.42,29.25 -67.21,-11.71 -62.19,-3.35c30.08,50.13 108.52,134.22 104.86,113.23c-7.24,-41.5 -12.82,-62.74 -7.81,-101.51c3.58,-27.71 16.4,-58.37 10.32,-52.43z"/>
    <path android:fillColor="#303030" android:pathData="M579.15,535.87c36.67,10.57 50.89,61.5 87.91,67.8c7.65,1.3 16.27,3.6 26.31,3.12c18.77,-0.9 42.51,-11.51 74.22,-56.5c9.38,-13.3 -23.27,85.66 -105.13,86.86c-59.96,0.88 -66.97,-58.7 -106.93,-60.51c-14.43,-0.65 -15.34,-28.17 -15.34,-28.17c0,0 17.22,-18.86 38.96,-12.6z"/>
    <path android:fillColor="#303030" android:pathData="M501.51,535.59c-36.67,10.57 -50.89,61.5 -87.91,67.8c-7.65,1.3 -16.27,3.6 -26.31,3.12c-18.77,-0.9 -42.51,-11.51 -74.22,-56.5c-9.38,-13.3 23.27,85.66 105.13,86.86c59.96,0.88 66.97,-58.7 106.93,-60.51c14.43,-0.65 15.34,-28.17 15.34,-28.17c0,0 -17.22,-18.86 -38.96,-12.6z"/>
    <path android:fillColor="#fbbcc9" android:pathData="M638.64,535.09c36.87,27.94 25.88,58.7 46.57,49.92c69.7,-29.55 57.51,-181.21 51.87,-162.87c-31.77,103.41 -100.99,109.2 -167.61,61.63c-13.01,-9.29 48.38,35.57 69.16,51.31z"/>
    <path android:fillColor="#fbbcc9" android:pathData="M510.91,483.77c-66.62,47.56 -135.84,41.78 -167.61,-61.63c-5.63,-18.34 -17.82,133.31 51.87,162.87c20.7,8.78 9.7,-21.98 46.57,-49.92c20.78,-15.75 82.17,-60.6 69.16,-51.31z"/>
    <path android:fillColor="#3747a9" android:pathData="M645.61,498c80.43,-3.32 95.29,-135.17 88.96,-119.08c-28.39,72.22 -135.86,45.05 -146.13,90.64c-2.02,8.94 18.2,30.06 57.17,28.45z"/>
    <path android:fillColor="#3747a9" android:pathData="M491.95,469.55c-10.27,-45.59 -117.75,-18.41 -146.13,-90.64c-6.32,-16.09 8.53,115.76 88.96,119.08c38.97,1.61 59.19,-19.5 57.17,-28.45z"/>
    <path android:fillColor="#ff6e40" android:pathData="M583.42,449.47c0,0 43.73,-23.5 81.16,-33.74c34.99,-9.58 61.22,-33.13 64.14,-58.01c2.18,-18.53 -27.05,-53.55 -27.05,-53.55c0,0 -20.51,56.9 -47.41,85.34c-29.28,30.96 -18.15,26.78 -70.84,59.96z"/>
    <path android:fillColor="#ff6e40" android:pathData="M426.13,389.51c-26.9,-28.44 -47.41,-85.34 -47.41,-85.34c0,0 -29.23,35.01 -27.05,53.55c2.93,24.88 29.16,48.43 64.14,58.01c37.43,10.25 81.16,33.74 81.16,33.74c-52.69,-33.18 -41.55,-29 -70.84,-59.96z"/>
    <path android:fillColor="#ffffff" android:pathData="M578.12,445.85c47.36,-38.85 72.53,-89.54 113.51,-145.02c7.73,-10.46 -34.58,-35.7 -51.31,-37.37c-16.73,-1.67 -30.77,59.79 -32.35,95.94c-1.44,33.01 -36.21,91.68 -29.84,86.45z"/>
    <path android:fillColor="#ffffff" android:pathData="M472.42,359.39c-1.58,-36.15 -15.62,-97.61 -32.35,-95.94c-16.73,1.67 -59.04,26.91 -51.31,37.37c40.98,55.48 66.14,106.17 113.51,145.02c6.37,5.22 -28.4,-53.45 -29.84,-86.45z"/>
    <path android:fillColor="#ffb327" android:pathData="M582.86,320.35c3.34,-26.76 15.37,-46.32 39.32,-62.75c-21.17,-7.08 -38.77,-12.83 -47.97,-5.3c-9.2,7.53 -34.2,32.7 -30.85,73.68c3.34,40.98 0.18,194.09 7.43,191.25c3.9,-104.87 37.09,-135 32.07,-196.89z"/>
    <path android:fillColor="#ffb327" android:pathData="M529.59,517.24c7.24,2.83 4.08,-150.27 7.43,-191.25c3.34,-40.98 -21.65,-66.16 -30.85,-73.68c-9.2,-7.53 -26.8,-1.78 -47.97,5.3c23.95,16.43 35.98,35.98 39.32,62.75c-5.02,61.89 28.17,92.02 32.07,196.89z"/>
</vector>

```

`app/core/src/main/res/drawable/ic_more.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#FF000000"
        android:pathData="M6,10c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2zM18,10c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2zM12,10c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2z"/>
</vector>

```

`app/core/src/main/res/drawable/ic_patreon.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
  <path
      android:fillColor="#FF000000"
      android:pathData="M15.386,0.524c-4.764,0 -8.64,3.876 -8.64,8.64 0,4.75 3.876,8.613 8.64,8.613 4.75,0 8.614,-3.864 8.614,-8.613C24,4.4 20.136,0.524 15.386,0.524M0.003,23.537h4.22V0.524H0.003"/>
</vector>

```

`app/core/src/main/res/drawable/ic_paypal.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
  <path
      android:fillColor="#FF000000"
      android:pathData="M6.908,24L3.804,24c-0.664,0 -1.086,-0.529 -0.936,-1.18l0.149,-0.674h2.071c0.666,0 1.336,-0.533 1.482,-1.182l1.064,-4.592c0.15,-0.648 0.816,-1.18 1.48,-1.18h0.883c3.789,0 6.734,-0.779 8.84,-2.34s3.16,-3.6 3.16,-6.135c0,-1.125 -0.195,-2.055 -0.588,-2.789 0,-0.016 -0.016,-0.031 -0.016,-0.046l0.135,0.075c0.75,0.465 1.32,1.064 1.711,1.814 0.404,0.75 0.598,1.68 0.598,2.791 0,2.535 -1.049,4.574 -3.164,6.135 -2.1,1.545 -5.055,2.324 -8.834,2.324h-0.9c-0.66,0 -1.334,0.525 -1.484,1.186L8.39,22.812c-0.149,0.645 -0.81,1.17 -1.47,1.17L6.908,24zM4.231,21.305L1.126,21.305c-0.663,0 -1.084,-0.529 -0.936,-1.18L4.563,1.182C4.714,0.529 5.378,0 6.044,0h6.465c1.395,0 2.609,0.098 3.648,0.289 1.035,0.189 1.92,0.519 2.684,0.99 0.736,0.465 1.322,1.072 1.697,1.818 0.389,0.748 0.584,1.68 0.584,2.797 0,2.535 -1.051,4.574 -3.164,6.119 -2.1,1.561 -5.056,2.326 -8.836,2.326h-0.883c-0.66,0 -1.328,0.524 -1.478,1.169L5.7,20.097c-0.149,0.646 -0.817,1.172 -1.485,1.172l0.016,0.036zM11.677,3.936h-1.014c-0.666,0 -1.332,0.529 -1.48,1.178l-0.93,4.02c-0.15,0.648 0.27,1.179 0.93,1.179h0.766c1.664,0 2.97,-0.343 3.9,-1.021 0.929,-0.686 1.395,-1.654 1.395,-2.912 0,-0.83 -0.301,-1.445 -0.9,-1.84 -0.6,-0.404 -1.5,-0.605 -2.686,-0.605l0.019,0.001z"/>
</vector>

```

`app/core/src/main/res/drawable/ic_superuser.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:height="24dp"
    android:width="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@color/dark"
        android:pathData="M5.41,21L6.12,17H2.12L2.47,15H6.47L7.53,9H3.53L3.88,7H7.88L8.59,3H10.59L9.88,7H15.88L16.59,3H18.59L17.88,7H21.88L21.53,9H17.53L16.47,15H20.47L20.12,17H16.12L15.41,21H13.41L14.12,17H8.12L7.41,21H5.41M9.53,9L8.47,15H14.47L15.53,9H9.53Z" />
</vector>
```

`app/core/src/main/res/drawable/ic_twitter.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
  <path
      android:fillColor="#FF000000"
      android:pathData="M23.954,4.569c-0.885,0.389 -1.83,0.654 -2.825,0.775 1.014,-0.611 1.794,-1.574 2.163,-2.723 -0.951,0.555 -2.005,0.959 -3.127,1.184 -0.896,-0.959 -2.173,-1.559 -3.591,-1.559 -2.717,0 -4.92,2.203 -4.92,4.917 0,0.39 0.045,0.765 0.127,1.124C7.691,8.094 4.066,6.13 1.64,3.161c-0.427,0.722 -0.666,1.561 -0.666,2.475 0,1.71 0.87,3.213 2.188,4.096 -0.807,-0.026 -1.566,-0.248 -2.228,-0.616v0.061c0,2.385 1.693,4.374 3.946,4.827 -0.413,0.111 -0.849,0.171 -1.296,0.171 -0.314,0 -0.615,-0.03 -0.916,-0.086 0.631,1.953 2.445,3.377 4.604,3.417 -1.68,1.319 -3.809,2.105 -6.102,2.105 -0.39,0 -0.779,-0.023 -1.17,-0.067 2.189,1.394 4.768,2.209 7.557,2.209 9.054,0 13.999,-7.496 13.999,-13.986 0,-0.209 0,-0.42 -0.015,-0.63 0.961,-0.689 1.8,-1.56 2.46,-2.548l-0.047,-0.02z"/>
</vector>

```

`app/core/src/main/res/drawable/sc_extension.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <shape android:shape="oval">
            <solid android:color="@color/su_request_background"/>
        </shape>
    </item>
    <item>
        <inset
            android:drawable="@drawable/ic_extension"
            android:inset="13dp"/>
    </item>
</layer-list>
```

`app/core/src/main/res/drawable/sc_superuser.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <shape android:shape="oval">
            <solid android:color="@color/su_request_background"/>
        </shape>
    </item>
    <item>
        <inset
            android:drawable="@drawable/ic_superuser"
            android:inset="13dp"/>
    </item>
</layer-list>
```

`app/core/src/main/res/values-ar/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">الإضافات</string>
    <string name="superuser">صلاحية الروت</string>
    <string name="logs">السجلات</string>
    <string name="settings">الإعدادات</string>
    <string name="install">تثبيت</string>
    <string name="section_home">الصفحة الرئيسية</string>
    <string name="section_theme">المظهر</string>

    <!--Home-->
    <string name="no_connection">لا يوجد إتصال</string>
    <string name="app_changelog">تفاصيل التحديث</string>
    <string name="loading">جارٍ التحميل...</string>
    <string name="update">تحديث</string>
    <string name="not_available">غير متوفر</string>
    <string name="hide">إخفاء</string>
    <string name="home_package">الحزمة</string>

    <string name="home_support_title">تبرع لنا</string>
    <string name="home_item_source">الكود المصدري للتطبيق</string>
    <string name="home_support_content">ماجيسك هو، وسيظل دوماً، مجانياّ و مفتوح المصدر، اظهر اهتمامك لنا لكي نبقيه هكذا بدعم مالي صغير</string>
    <string name="home_installed_version">تم التثبيت</string>
    <string name="home_latest_version">آخر إصدار</string>
    <string name="invalid_update_channel">مصدر التحديث غير صالح</string>
    <string name="uninstall_magisk_title">إلغاء تثبيت ماجيسك</string>
    <string name="uninstall_magisk_msg">ستُعطل/ستُحذف جميع الإضافات. سيُحذف الروت، وربما ستشفر بياناتك إذا لم تكن غير مشفرة حالياً.</string>

    <!--Install-->
    <string name="keep_force_encryption">فرض التشفير الإجباري</string>
    <string name="keep_dm_verity">فرض تشفيرات AVB2.0/dm-verity</string>
    <string name="recovery_mode">وضـع الريكفري</string>
    <string name="install_options_title">الخيارات</string>
    <string name="install_method_title">الطريقة</string>
    <string name="install_next">التالي</string>
    <string name="install_start">هيا بنا</string>
    <string name="manager_download_install">اضغط للتنزيل و التثبيت</string>
    <string name="direct_install">تثبيت مباشر (موصى بها)</string>
    <string name="install_inactive_slot">التثبيت على المنطقة الغير نشطة (بعد OTA)</string>
    <string name="install_inactive_slot_msg">سيُجبر جهازك للاقلاع على المنطقة الغير النشطة بعد إعادة التشغيل!\n استخدم هذا الخيار فقط بعد الانتهاء من OTA. استمرار؟</string>
    <string name="setup_title">إعدادات إضافية</string>
    <string name="select_patch_file">حدد و عدل ملفاً</string>
    <string name="patch_file_msg">اختر ملف (*.img) أو ملف odin (*.tar)</string>
    <string name="reboot_delay_toast">إعادة التشغيل بعد ٥ ثواني…</string>
    <string name="flash_screen_title">التثبيت</string>

    <!--Superuser-->
    <string name="su_request_title">طلبات صلاحية الروت</string>
    <string name="deny">رفض</string>
    <string name="prompt">طلب</string>
    <string name="grant">سماح</string>
    <string name="su_warning">يمنح حق الوصول الكامل إلى جهازك. ارفض إذا كنت غير متأكد!</string>
    <string name="forever">للأبد</string>
    <string name="once">مرة واحدة</string>
    <string name="tenmin">10 دقائق</string>
    <string name="twentymin">20 دقيقة</string>
    <string name="thirtymin">30 دقيقة</string>
    <string name="sixtymin">60 دقيقة</string>
    <string name="su_allow_toast">تم منح صلاحيات الروت لـ%1$s</string>
    <string name="su_deny_toast">تم رفض صلاحيات الروت لـ%1$s </string>
    <string name="su_snack_grant">تم منح صلاحيات الروت لـ%1$s</string>
    <string name="su_snack_deny">تم رفض صلاحيات الروت لـ%1$s</string>
    <string name="su_snack_notif_on">تم تفعيل الإشعارات لـ%1$s</string>
    <string name="su_snack_notif_off">تم تعطيل الإشعارات لـ%1$s</string>
    <string name="su_snack_log_on">تم تفعيل السجلات لـ%1$s</string>
    <string name="su_snack_log_off">تم تعطيل السجلات لـ%1$s</string>
    <string name="su_revoke_title">منع؟</string>
    <string name="su_revoke_msg">هل تريد منع صلاحية %1$s?</string>
    <string name="toast">اشعار</string>
    <string name="none">بدون</string>

    <string name="superuser_toggle_notification">الإشعارات</string>
    <string name="superuser_toggle_revoke">منع</string>
    <string name="superuser_policy_none">لم يسأل آية تطبيق لصلاحيات الروت</string>

    <!--Logs-->
    <string name="log_data_none">لا يوجد أية سجلات هنا :-:، حاول استعمال تطبيقات روت اكثر</string>
    <string name="log_data_magisk_none">لا توجد أيةَ سجلات ⊙_⊙</string>
    <string name="menuSaveLog">حفظ السجلات</string>
    <string name="menuClearLog">حذف السجلات</string>
    <string name="logs_cleared">تم الحذف بنجاح</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">UID: %1$d</string>

    <!--SafetyNet-->

    <!-- MagiskHide -->
    <string name="show_system_app">إظهار برامج النظام</string>
    <string name="hide_filter_hint">البحث بالاسم</string>
    <string name="hide_search">ابحث</string>

    <!--Module Fragment-->
    <string name="no_info_provided">(لا تتوفر معلومات)</string>
    <string name="reboot_recovery">إعادة التشغيل إلى Recovery</string>
    <string name="reboot_bootloader">إعادة التشغيل إلى Bootloader</string>
    <string name="reboot_download">إعادة التشغيل إلى وضـع Odin</string>
    <string name="reboot_edl">إعادة التشغيل إلى EDL</string>
    <string name="module_version_author">%1$sبواسطة%2$s</string>
    <string name="module_state_remove">إزالة </string>
    <string name="module_state_restore">إسترجاع</string>
    <string name="module_action_install_external">اختر من الذاكرة الداخلية</string>
    <string name="update_available">التحديث متوفر</string>
    <string name="external_rw_permission_denied">امنحني إذن الولوج للذاكرة الداخلية</string>

    <!--Settings -->
    <string name="settings_dark_mode_title">المظهر</string>
    <string name="settings_dark_mode_message">حدد المظهر الذي يناسب ذوقك</string>
    <string name="settings_dark_mode_light">الوضـع المضيء</string>
    <string name="settings_dark_mode_system">اتبّع النظام</string>
    <string name="settings_dark_mode_dark">الوضع المظلم</string>
    <string name="settings_download_path_title">مسار التحميل</string>
    <string name="settings_download_path_message">ستحمل الملفات إلى %1$s</string>
    <string name="language">اللغة</string>
    <string name="system_default">(الإفتراضي)</string>
    <string name="settings_check_update_title">تحقق من التحديثات</string>
    <string name="settings_check_update_summary">التحقق من التحديثات في الخلفية بشكل دوري</string>
    <string name="settings_update_channel_title">مصدر التحديثات</string>
    <string name="settings_update_stable">مستقر</string>
    <string name="settings_update_beta">تجريبي</string>
    <string name="settings_update_custom">مخصص</string>
    <string name="settings_update_custom_msg">أدخل الرابط لمصدرك المخصص</string>
    <string name="settings_hosts_title">موانع الاعلانات</string>
    <string name="settings_hosts_summary">حجب الاعلانات دون تعديل النظام</string>
    <string name="settings_hosts_toast">تم تمكين خاصية حجب الاعلانات</string>
    <string name="settings_app_name_hint">الاسم الجديد</string>
    <string name="settings_app_name_helper">التطبيق الجديد سوف يملك هذا الاسم</string>
    <string name="settings_app_name_error">الصيغة غير مقبولة</string>
    <string name="settings_su_app_adb">التطبيقات و ADB</string>
    <string name="settings_su_app">التطبيقات فقط</string>
    <string name="settings_su_adb">ADB فقط</string>
    <string name="settings_su_disable">معطل</string>
    <string name="settings_su_request_10">10 ثواني</string>
    <string name="settings_su_request_15">15 ثانية</string>
    <string name="settings_su_request_20">20 ثانية</string>
    <string name="settings_su_request_30">30 ثانية</string>
    <string name="settings_su_request_45">45 ثانية</string>
    <string name="settings_su_request_60">60 ثانية</string>
    <string name="superuser_access">صلاحيات الروت</string>
    <string name="auto_response">الفعل التلقائي</string>
    <string name="request_timeout">المهلة قبل الفعل التلقائي</string>
    <string name="superuser_notification">إشعارات طلبات الروت</string>
    <string name="settings_su_reauth_title">إعادة المصادقة بعد التحديث</string>
    <string name="settings_su_reauth_summary">أعد مصادقة صلاحيات الروت بعد تحديث التطبيق</string>
    <string name="settings_customization">تخصيص</string>

    <string name="multiuser_mode">نمط المستخدم المزدوج</string>
    <string name="settings_owner_only">مالك الجهاز فقط</string>
    <string name="settings_owner_manage">المالك هو من يحدد</string>
    <string name="settings_user_independent">مستقل</string>
    <string name="owner_only_summary">للمالك فقط له صلاحيات الروت</string>
    <string name="owner_manage_summary">فقط المالك من يرفض و يمنح صلاحيات الروت</string>
    <string name="user_independent_summary">كل مستخدم له قواعد روت خاصة به</string>

    <string name="mount_namespace_mode">نمط Mount Namespace</string>
    <string name="settings_ns_global">نمط Namespace عام</string>
    <string name="settings_ns_requester">نمط NameSpace متوارث</string>
    <string name="settings_ns_isolate">نمط NameSpace معزول</string>
    <string name="global_summary">جميع الجلسات الروت تستخدم NameSpace العام</string>
    <string name="requester_summary">جميع الجلسات الروت تستخدم NameSpace المتوارث</string>
    <string name="isolate_summary">جميع الجلسات الروت تستخدم NameSpace المعزول</string>

    <!--Notifications-->
    <string name="update_channel">تحديثات ماجيسك</string>
    <string name="progress_channel">إشعارات التقدم</string>
    <string name="download_complete">اكتمل التنزيل</string>
    <string name="download_file_error">فشل تنزيل الملف</string>
    <string name="magisk_update_title">تحديث ماجيسك متوفر!</string>

    <!--Toasts, Dialogs-->
    <string name="yes">نعم</string>
    <string name="no">لا</string>
    <string name="download">تنزيل</string>
    <string name="reboot">إعادة التشغيل</string>
    <string name="release_notes">معلومات الإصدار الجديد</string>
    <string name="flashing">يتم التثبيت...</string>
    <string name="done">تم!</string>
    <string name="failure">فشل!</string>
    <string name="open_link_failed_toast">لم يُعثر على تطبيق لفتح الرابط …</string>
    <string name="complete_uninstall">إلغاء التثبيت بالكامل</string>
    <string name="restore_img">استعادة الصور</string>
    <string name="restore_img_msg">جار الإستعادة…</string>
    <string name="restore_done">تم الإستعادة</string>
    <string name="restore_fail">النسخة الإحتياطية الأصلية غير موجودة!</string>
    <string name="setup_fail">فشل الإعداد</string>
    <string name="env_fix_title">الإعداد الإضافي مطلوب</string>
    <string name="setup_msg">جار إعداد البيئة</string>
    <string name="unsupport_magisk_title">إصدار ماجيسك غير مدعوم</string>

</resources>

```

`app/core/src/main/res/values-ast/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!--Sections-->
    <string name="modules">Módulos</string>
    <string name="superuser">Superusuariu</string>
    <string name="logs">Rexistru</string>
    <string name="settings">Configuración</string>
    <string name="install">Instalar</string>
    <string name="section_home">Aniciu</string>
    <string name="section_theme">Estilos</string>
    <string name="denylist">Llista d\'esclusión</string>
    <!--Home-->
    <string name="no_connection">L\'accesu a internet nun ta disponible</string>
    <string name="app_changelog">Rexistru de cambeos</string>
    <string name="loading">Cargando…</string>
    <string name="update">Anovar</string>
    <string name="not_available">N/D</string>
    <string name="hide">Esconder</string>
    <string name="home_package">Paquete</string>
    <string name="home_app_title">Aplicación</string>
    <string name="home_notice_content">Baxa Magisk NAMÁS dende la páxina oficial de GitHub. ¡Los ficheros de fontes desconocíes puen ser maliciosos!</string>
    <string name="home_support_title">Collaboración</string>
    <string name="home_follow_title">Redes sociales</string>
    <string name="home_item_source">Códigu fonte</string>
    <string name="home_support_content">Magisk ye y va ser de códigu abiertu y gratuitu. Sicasí, pues ayudanos faciendo una donación o collaborando.</string>
    <string name="home_installed_version">Versión instalada</string>
    <string name="home_latest_version">Última versión</string>
    <string name="invalid_update_channel">La canal d\'anovamientu nun ye válida</string>
    <string name="uninstall_magisk_title">Desinstalar Magisk</string>
    <string name="uninstall_magisk_msg">¡Van quitase y desactivase tolos módulos y l\'accesu root!\nCualesquier almacenamientu internu ensin cifrar pente l\'usu de Magisk va volver cifrase.</string>
    <!--Install-->
    <string name="keep_force_encryption">Caltener el cifráu forciáu</string>
    <string name="keep_dm_verity">Caltener l\'AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Mou de recuperación</string>
    <string name="install_options_title">Opciones</string>
    <string name="install_method_title">Métodu</string>
    <string name="install_next">Siguiente</string>
    <string name="install_start">Siguir</string>
    <string name="manager_download_install">Primi equí pa baxalu ya instalalu</string>
    <string name="direct_install">Instalación direuta (aconséyase)</string>
    <string name="install_inactive_slot">Instalar na ralura inactiva (darréu del OTA)</string>
    <string name="install_inactive_slot_msg">¡El preséu va arrincar OBLIGATORIAMENTE na ralura inactiva dempués de reaniciar!\nUsa esta opción namás dempués d\'acabar l\'anovamientu per OTA.\n¿Quies siguir?</string>
    <string name="setup_title">Configuración adicional</string>
    <string name="select_patch_file">Seleicionar y parchiar un ficheru</string>
    <string name="patch_file_msg">Seleiciona una imaxe en bruto (*.img), un archivu d\'ODIN (*.tar) o un ficheru payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">Reaniciando en 5 segundos…</string>
    <string name="flash_screen_title">Instalación</string>
    <!--Superuser-->
    <string name="su_request_title">Solicitú de superusuariu</string>
    <string name="touch_filtered_warning">Como una aplicación torga la solicitú de superusuariu, Magisk nun pue verificar la to rempuesta</string>
    <string name="deny">Negar</string>
    <string name="prompt">Entrugar</string>
    <string name="grant">Conceder</string>
    <string name="su_warning">Concede l\'accesu completu al preséu.\n¡Niégalu en casu de dulda!</string>
    <string name="forever">Siempres</string>
    <string name="once">Una vegada</string>
    <string name="tenmin">10 minutos</string>
    <string name="twentymin">20 minutos</string>
    <string name="thirtymin">30 minutos</string>
    <string name="sixtymin">60 minutos</string>
    <string name="su_allow_toast">A %1$s concediéronse-y los derechos de superusuariu</string>
    <string name="su_deny_toast">A %1$s negáronse-y los derechos de superusuariu</string>
    <string name="su_snack_grant">Concediéronse los derechos de superusuariu a %1$s</string>
    <string name="su_snack_deny">Negáronse los derechos de superusuariu a %1$s</string>
    <string name="su_snack_notif_on">Activáronse los avisos de: %1$s</string>
    <string name="su_snack_notif_off">Desactiváronse los avisos de: %1$s</string>
    <string name="su_snack_log_on">Activóse\'l rexistru de: %1$s</string>
    <string name="su_snack_log_off">Desactivóse\'l rexistru de: %1$s</string>
    <string name="su_revoke_title">Revocación de derechos</string>
    <string name="su_revoke_msg">Confirma la revocación de los derechos de superusuariu pa «%1$s»</string>
    <string name="toast">Burbuya d\'avisu emerxente</string>
    <string name="none">Nada</string>
    <string name="superuser_toggle_notification">Avisos</string>
    <string name="superuser_toggle_revoke">Revocar</string>
    <string name="superuser_policy_none">Pel momentu, nenguna aplicación pidió\'l permisu de superusuariu.</string>
    <!--Logs-->
    <string name="log_data_none">El rexistru ta baleru. Prueba a usar más aplicaciones de root</string>
    <string name="log_data_magisk_none">El rexistru de Magisk ta baleru. ¡Qué raro!</string>
    <string name="menuSaveLog">Guardar el rexistru</string>
    <string name="menuClearLog">Llimpiar el rexistru</string>
    <string name="logs_cleared">El rexistru borróse correutamente</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">UID de destín: %1$d</string>
    <string name="target_pid">Mount ns target PID: %s</string>
    <string name="selinux_context">Contestu de SELinux: %s</string>
    <string name="supp_group">Grupu suplementariu: %s</string>
    <!--SafetyNet-->
    <!--MagiskHide-->
    <string name="show_system_app">Aplicaciones del sistema</string>
    <string name="show_os_app">Aplicaciones del SO</string>
    <string name="hide_filter_hint">Peñerar pol nome</string>
    <string name="hide_search">Buscar</string>
    <!--Module-->
    <string name="no_info_provided">(Nun s\'apurrió nenguna información)</string>
    <string name="reboot_userspace">Reaniciu del sistema</string>
    <string name="reboot_recovery">Reaniciar al recovery</string>
    <string name="reboot_bootloader">Reaniciar al cargador d\'arrinque</string>
    <string name="reboot_download">Reaniciar al mou de descarga</string>
    <string name="reboot_edl">Reaniciar al mou EDL</string>
    <string name="reboot_safe_mode">Mou seguru</string>
    <string name="module_version_author">%1$s por %2$s</string>
    <string name="module_state_remove">Quitar</string>
    <string name="module_action">Aición</string>
    <string name="module_state_restore">Restaurar</string>
    <string name="module_action_install_external">Instalar dende l\'almacenamientu</string>
    <string name="update_available">Hai un anovamientu disponible</string>
    <string name="suspend_text_riru">Suspendióse\'l módulu porque s\'activó «%1$s»</string>
    <string name="suspend_text_zygisk">Suspendióse\'l módulu porque nun s\'activó «%1$s»</string>
    <string name="zygisk_module_unloaded">El módulu de Zygisk nun cargó por haber incompatibilidaes</string>
    <string name="module_empty">Nun hai nengún módulu instaláu</string>
    <string name="confirm_install">¿Quies instalar el módulu «%1$s»?</string>
    <string name="confirm_install_title">Confirmación de la instalación</string>
    <!--Settings-->
    <string name="settings_dark_mode_title">Mou del estilu</string>
    <string name="settings_dark_mode_message">¡Seleiciona\'l mou que meyor s\'adaute al to estilu!</string>
    <string name="settings_dark_mode_light">Claridá</string>
    <string name="settings_dark_mode_system">L\'estilu del sistema</string>
    <string name="settings_dark_mode_dark">Escuridá</string>
    <string name="settings_download_path_title">Camín de les descargues</string>
    <string name="settings_download_path_message">Los ficheros van guardase en «%1$s»</string>
    <string name="settings_hide_app_title">Esconder Magisk</string>
    <string name="settings_hide_app_summary">Instala una aplicación intermedia con una ID y una etiqueta al debalu</string>
    <string name="settings_restore_app_title">Restaurar el mou visible</string>
    <string name="settings_restore_app_summary">Fai que l\'aplicación orixinal vuelva ser visible</string>
    <string name="language">Llingua</string>
    <string name="system_default">(Lo predeterminao)</string>
    <string name="settings_check_update_title">Comprobación d\'anovamientos</string>
    <string name="settings_check_update_summary">Comprueba si hai anovamientos en segundu planu</string>
    <string name="settings_update_channel_title">Canal d\'anovamientu</string>
    <string name="settings_update_stable">Estable</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Canal personalizada</string>
    <string name="settings_update_custom_msg">Inxerta la URL d\'una canal personalizada</string>
    <string name="settings_zygisk_summary">Executa partes de Magisk nel degorriu de Zygote</string>
    <string name="settings_denylist_title">Forciar la llista d\'esclusión</string>
    <string name="settings_denylist_summary">Los procesos de la llista d\'esclusión tienen toles modificaciones de Magisk anulaes</string>
    <string name="settings_denylist_config_title">Configurar la llista d\'esclusión</string>
    <string name="settings_denylist_config_summary">Seleiciona los procesos que s\'inclúin na llista d\'esclusión</string>
    <string name="settings_hosts_title">Módulu «Systemless Hosts»</string>
    <string name="settings_hosts_summary">Un módulu pa les aplicaciones que bloquien anuncios</string>
    <string name="settings_hosts_toast">Amestóse\'l módulu «Systemless Hosts»</string>
    <string name="settings_app_name_hint">Nome nuevu</string>
    <string name="settings_app_name_helper">L\'aplicación va volver empaquetase con esti nome</string>
    <string name="settings_app_name_error">El formatu nun ye válidu</string>
    <string name="settings_su_app_adb">Aplicaciones y ADB</string>
    <string name="settings_su_app">Namás aplicaciones</string>
    <string name="settings_su_adb">Namás ADB</string>
    <string name="settings_su_disable">Non</string>
    <string name="settings_su_request_10">10 segundos</string>
    <string name="settings_su_request_15">15 segundos</string>
    <string name="settings_su_request_20">20 segundos</string>
    <string name="settings_su_request_30">30 segundos</string>
    <string name="settings_su_request_45">45 segundos</string>
    <string name="settings_su_request_60">60 segundos</string>
    <string name="superuser_access">Accesu de superusuariu</string>
    <string name="auto_response">Rempuesta automática</string>
    <string name="request_timeout">Tiempu d\'espera de les solicitúes</string>
    <string name="superuser_notification">Avisu de superusuariu</string>
    <string name="settings_su_reauth_title">Volver autenticar dempués d\'anovar</string>
    <string name="settings_su_reauth_summary">Vuelve pidir los permisos de superusuariu dempués d\'anovar les aplicaciones</string>
    <string name="settings_su_tapjack_title">Proteición escontra\'l tapjacking</string>
    <string name="settings_su_tapjack_summary">El diálogu de concesión de permisos de superusuariu nun respuende a la entrada mentanto lu torgue otra ventana o superposición</string>
    <string name="settings_su_auth_title">Autenticación d\'usuariu</string>
    <string name="settings_su_auth_summary">Pide l\'autenticación demientres les solicitúes de superusuariu</string>
    <string name="settings_su_auth_insecure">Nun se configuró nengún métodu d\'autenticación nel preséu</string>
    <string name="settings_customization">Personalización</string>
    <string name="setting_add_shortcut_summary">Amiesta un atayu a la pantalla d\'aniciu en casu de que\'l nome y l\'iconu seyan difíciles de reconocer dempués d\'esconder l\'aplicación</string>
    <string name="settings_doh_title">DNS per HTTPS</string>
    <string name="settings_doh_description">Una igua alternativa pal envelenamientu de DNS en dalgunos países</string>
    <string name="settings_random_name_title">Nome de la salida aleatoriu</string>
    <string name="settings_random_name_description">Fai que\'l nome de ficheru de la salida de les imáxenes parchiaes y los ficheros tar seya aleatoriu pa impidir la deteición</string>
    <string name="multiuser_mode">Mou de multiusuariu</string>
    <string name="settings_owner_only">Namás el propietariu del preséu</string>
    <string name="settings_owner_manage">El propietariu xestionáu del preséu</string>
    <string name="settings_user_independent">Con independencia del usuariu</string>
    <string name="owner_only_summary">Namás el propietariu tien accesu de root</string>
    <string name="owner_manage_summary">Namás el propietariu pue xestionar l\'accesu de root y recibir solicitúes</string>
    <string name="user_independent_summary">Cada usuariu tien les sos regles de root individuales</string>
    <string name="mount_namespace_mode">Mou del montaxe del espaciu de nomes</string>
    <string name="settings_ns_global">Espaciu de nomes global</string>
    <string name="settings_ns_requester">Espaciu de nomes heredáu</string>
    <string name="settings_ns_isolate">Espaciu de nomes aisláu</string>
    <string name="global_summary">Toles sesiones de root usen l\'espaciu de nomes global</string>
    <string name="requester_summary">Les sesiones de root herieden l\'espaciu de nomes de los solicitantes</string>
    <string name="isolate_summary">Cada sesión de root tien el so espaciu de nomes propiu</string>
    <!--Notifications-->
    <string name="update_channel">Anovamientos de Magisk</string>
    <string name="progress_channel">Avisos de progresos</string>
    <string name="updated_channel">Anovamientu completáu</string>
    <string name="download_complete">Completóse la descarga</string>
    <string name="download_file_error">Hebo un fallu al baxar el ficheru</string>
    <string name="magisk_update_title">¡Hai un anovamientu pa Magisk!</string>
    <string name="updated_title">Magisk anovóse</string>
    <string name="updated_text">Toca equí p\'abrir l\'aplicación</string>
    <!--Toasts, Dialogs-->
    <string name="yes">Sí</string>
    <string name="no">Non</string>
    <string name="repo_install_title">Instalación de: %1$s %2$s (%3$d)</string>
    <string name="download">Baxar</string>
    <string name="reboot">Reaniciar</string>
    <string name="close">Zarrar</string>
    <string name="release_notes">Notes de la versión</string>
    <string name="flashing">Flaxando…</string>
    <string name="running">Executando…</string>
    <string name="done">¡Fecho!</string>
    <string name="done_action">Completóse l\'aición de: %1$s</string>
    <string name="failure">¡Falló!</string>
    <string name="hide_app_title">Escondiendo l\'aplicación Magisk…</string>
    <string name="open_link_failed_toast">Nun s\'atopó nenguna aplicación p\'abrir l\'enllaz</string>
    <string name="complete_uninstall">Desinstalar dafechu</string>
    <string name="restore_img">Restaurar les imáxenes</string>
    <string name="restore_img_msg">Restaurando…</string>
    <string name="restore_done">¡Restauración fecha!</string>
    <string name="restore_fail">¡La copia de seguranza de la imaxe de fábrica nun esiste!</string>
    <string name="setup_fail">La configuración falló</string>
    <string name="env_fix_title">Configuración adicional</string>
    <string name="env_fix_msg">El preséu precisa una configuración adicional pa que Magisk funcione afayadizamente. ¿Quies siguir y reaniciar?</string>
    <string name="env_full_fix_msg">El preséu precisa volver flaxar Magisk pa que funcione afayadizamente. Volvi instalar Magisk dientro de l\'aplicación porque\'l mou de recuperación nun pue consiguir la información correuta del preséu.</string>
    <string name="setup_msg">Executando la configuración del entornu…</string>
    <string name="unsupport_magisk_title">Versión non compatible</string>
    <string name="unsupport_magisk_msg">Esta versión de l\'aplicación nun ye compatible coles versiones de Magisk anteriores a la %1$s.\n\nL\'aplicación va comportase como si Magisk nun tuviere instaláu, anueva Magisk namás que puedas.</string>
    <string name="unsupport_general_title">Estáu anormal</string>
    <string name="unsupport_system_app_msg">Esta aplicación nun se pue executar nel espaciu del sistema. Volvi instalala mas nel espaciu del usuariu.</string>
    <string name="unsupport_other_su_msg">Detectóse un binariu «su» que nun ye de Magisk. Quita cualesquier solución de root y/o volvi instalar Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk ta instaláu nel almacenamientu esternu. Movi l\'aplicación al almacenamientu internu, por favor.</string>
    <string name="unsupport_nonroot_stub_msg">Magisk nun pue siguir funcionando nel mou escondíu darréu que se perdió\'l root. Restaura\'l mou visible de l\'aplicación.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Concede\'l permisu d\'almacenamientu p\'activar esta funcionalidá</string>
    <string name="post_notifications_denied">Concede\'l permisu de los avisos p\'activar esta función</string>
    <string name="install_unknown_denied">Permite la instalación d\'aplicaciones desconocíes p\'activar esta funcionalidá</string>
    <string name="add_shortcut_title">Amestar un atayu a la pantalla d\'aniciu</string>
    <string name="add_shortcut_msg">Dempués d\'esconder esta aplicación, el so nome ya iconu van ser difíciles de reconocer. ¿Quies amestar un atayu a la pantalla d\'aniciu?</string>
    <string name="app_not_found">Nun s\'atopó nenguna aplicación pa remanar esta aición</string>
    <string name="reboot_apply_change">Reanicia p\'aplicar los cambeos</string>
    <string name="restore_app_confirmation">Esta aición va restaurar l\'aplicación orixinal y desanicia la intermedia. ¿De xuru que quies facelo?</string>
</resources>

```

`app/core/src/main/res/values-az/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Modullar</string>
    <string name="superuser">Super İstifadəçi</string>
    <string name="logs">Qeydlər</string>
    <string name="settings">Ayarlar</string>
    <string name="install">Quraşdır</string>
    <string name="section_home">Əsas Səhifə</string>
    <string name="section_theme">Mövzular</string>
    <string name="denylist">Rəddedilənlər siyahısı</string>

    <!--Home-->
    <string name="no_connection">Bağlantı yoxdur</string>
    <string name="app_changelog">Dəyişikliklər</string>
    <string name="loading">Yüklənir…</string>
    <string name="update">Yenilə</string>
    <string name="not_available">Yüklü deyil</string>
    <string name="hide">Gizlə</string>
    <string name="home_package">Paket</string>
    <string name="home_app_title">Tətbiq</string>

    <string name="home_notice_content">Magiski YALNIZ rəsmi GitHub səhifəsindən endirin. Bilinməyən mənbələrdəki fayllar zərərli ola bilər!</string>
    <string name="home_support_title">Bizə Dəstək ol</string>
    <string name="home_follow_title">Bizi İzləyin</string>
    <string name="home_item_source">Mənbə</string>
    <string name="home_support_content">Magisk pulsuzdur və həmişə belə qalacaq. Amma istəsən bizə dəstək ola bilərsən.</string>
    <string name="home_installed_version">Qurulan</string>
    <string name="home_latest_version">Ən son versiya</string>
    <string name="invalid_update_channel">Keçərsiz yeniləmə kanalı</string>
    <string name="uninstall_magisk_title">Magisk\'i sil</string>
    <string name="uninstall_magisk_msg">Bütün modullar ləğv olunacaq/silinəcək. Root silinəcək, və əgər hal-hazırda deyilsə, bütün məlumatlarınız potensiyal olaraq şifrələnəcək.</string>

    <!--Install-->
    <string name="keep_force_encryption">Zorla şifrələməni saxla</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity saxla</string>
    <string name="recovery_mode">Xilasetmə Modu</string>
    <string name="install_options_title">Ayarlar</string>
    <string name="install_method_title">Metod</string>
    <string name="install_next">Növbəti</string>
    <string name="install_start">Başlat</string>
    <string name="manager_download_install">Endirmək və quraşdırmaq üçün bas</string>
    <string name="direct_install">Birbaşa Quraşdır (Tövsiyyə olunur)</string>
    <string name="install_inactive_slot">Aktiv olmayan Slot\'a quraşdır (OTA\'dan sonra)</string>
    <string name="install_inactive_slot_msg">Cihazınız yenidən başladıqdan sonra aktiv olmayan slotda başlamağa MƏCBUR ediləcək!\nBu seçimi ancaq OTA bitdikdən sonra tətbiq edin.\nDavam edilsin?</string>
    <string name="setup_title">Əlavə Sazlamalar</string>
    <string name="select_patch_file">Fayl seç və yamaqla</string>
    <string name="patch_file_msg">(*.img) yaxud ODIN (*.tar) seç</string>
    <string name="reboot_delay_toast">5 saniyəyə yenidən başlayacaq…</string>
    <string name="flash_screen_title">Quraşdırılma</string>

    <!--Superuser-->
    <string name="su_request_title">Super İstifadəçi İcazəsi</string>
    <string name="touch_filtered_warning">Hansısa tətbiq Super İstifadəçi icazəsini pozduğuna görə, Magisk göstərişinizi yerinə yetirə bilmir</string>
    <string name="deny">İmtina et</string>
    <string name="prompt">İstək</string>
    <string name="grant">İcazə ver</string>
    <string name="su_warning">Bu tətbiqə tam səlahiyyət verəcək.\nƏmin deyilsənsə imtina et!</string>
    <string name="forever">Həmişə</string>
    <string name="once">1 dəfəlik</string>
    <string name="tenmin">10 dəqiqəlik</string>
    <string name="twentymin">20 dəqiqəlik</string>
    <string name="thirtymin">30 dəqiqəlik</string>
    <string name="sixtymin">60 dəqiqəlik</string>
    <string name="su_allow_toast">%1$s Super İstifadəçi icazəsi aldı</string>
    <string name="su_deny_toast">%1$s Super İstifadəçi icazəsi ala bilmədi</string>
    <string name="su_snack_grant">%1$s üçün Super İstifadəçi haqları verilib</string>
    <string name="su_snack_deny">%1$s üçün Super İstifadəçi haqları verilməyib</string>
    <string name="su_snack_notif_on">%1$s üçün bildirişlər açıqdır</string>
    <string name="su_snack_notif_off">%1$s üçün bildirişlər qapalıdır</string>
    <string name="su_snack_log_on">%1$s qeydləri açıqdır</string>
    <string name="su_snack_log_off">%1$s qeydləri qapalıdır</string>
    <string name="su_revoke_title">Sil</string>
    <string name="su_revoke_msg">%1$s üçün Super İstifadəçi haqlarının silinməsini təsdiqlə</string>
    <string name="toast">Tost</string>
    <string name="none">Heçbiri</string>

    <string name="superuser_toggle_notification">bildirişlər</string>
    <string name="superuser_toggle_revoke">Sil</string>
    <string name="superuser_policy_none">Hələ heçbir tətbiq Super İstifadəçi icazəsi istəməyib.</string>

    <!--Logs-->
    <string name="log_data_none">Qeyd yoxdur, root icazəli tətbiqlərdən daha çox istifadə edin</string>
    <string name="log_data_magisk_none">Qəribədir, Magisk qeydləri boşdur</string>
    <string name="menuSaveLog">Qeydləri saxla</string>
    <string name="menuClearLog">Qeydləri sil</string>
    <string name="logs_cleared">Qeydlər silindi</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Hədəf UID: %1$d</string>
    <string name="selinux_context">SELinux kontenti: %s</string>
    <string name="supp_group">Əlavə grup: %s</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Sistem tətbiqlərini göstər</string>
    <string name="show_os_app">Əməliyyat sistemi tətbiqlərini göstər</string>
    <string name="hide_filter_hint">Adla sırala</string>
    <string name="hide_search">Axtar</string>

    <!--Module-->
    <string name="no_info_provided">(Məlumat verilməyib)</string>
    <string name="reboot_userspace">Yumuşaq yenidən başlat</string>
    <string name="reboot_recovery">Xilasetmə modunda yenidən başlat</string>
    <string name="reboot_bootloader">Önyükləyici modunda yenidən başlat</string>
    <string name="reboot_download">Yükləmə modunda yenidən başlat</string>
    <string name="reboot_edl">EDL modunda yenidən başlat</string>
    <string name="module_version_author">%2$s tərəfindən %1$s buraxılışı</string>
    <string name="module_state_remove">Sil</string>
    <string name="module_state_restore">Bərpa et</string>
    <string name="module_action_install_external">Yaddaşdan yüklə</string>
    <string name="update_available">Yeniləmə Mövcuddur</string>
    <string name="suspend_text_riru">%1$s açıq olduğundan Magisk modulu dayandırıldı</string>
    <string name="suspend_text_zygisk">%1$s qapalı olduğu üçün Magisk modulu dayandırıldı</string>
    <string name="zygisk_module_unloaded">Zygisk modulu uyğunsuzluq səbəbindən açılmadı</string>
    <string name="module_empty">Yüklü modul yoxdur</string>
    <string name="confirm_install">%1$s modulu yüklənsin?</string>
    <string name="confirm_install_title">Yükləmə Təsdiqi</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Mövzu Modu</string>
    <string name="settings_dark_mode_message">Zövqünüzə uyğun modu seçin!</string>
    <string name="settings_dark_mode_light">Həmişə Açıq</string>
    <string name="settings_dark_mode_system">Sistemə Uyğun</string>
    <string name="settings_dark_mode_dark">Həmişə Qaranlıq</string>
    <string name="settings_download_path_title">Endirmə yolu</string>
    <string name="settings_download_path_message">Fayllar %1$s\'a yerləşdiriləcək</string>
    <string name="settings_hide_app_title">Magisk tətbiqini gizlət</string>
    <string name="settings_hide_app_summary">Təsadüfi paket ID\'si ilə proxy yüklə və özəl tətbiq adı yaz</string>
    <string name="settings_restore_app_title">Magisk tətbiqini bərpa et</string>
    <string name="settings_restore_app_summary">Tətbiqi üzə çıxar və orijinal APKnı bərpa et</string>
    <string name="language">Dil</string>
    <string name="system_default">(Sistem Dili)</string>
    <string name="settings_check_update_title">Yeniləməni Yoxla</string>
    <string name="settings_check_update_summary">Vaxtaşırı arxaplanda yeniləmələri yoxla</string>
    <string name="settings_update_channel_title">Yeniləmə Kanalı</string>
    <string name="settings_update_stable">Sabit</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Özəl</string>
    <string name="settings_update_custom_msg">Özəl kanal URL\'si daxil et</string>
    <string name="settings_zygisk_summary">Magiskin bəzi hissələrini zygote daemonda aç</string>
    <string name="settings_denylist_title">İstisnaları Məcbur İşlət</string>
    <string name="settings_denylist_summary">İstisnalar siyahısındakı proseslər Magisk əlavələrini tərsinə çevirəcək</string>
    <string name="settings_denylist_config_title">İstisnaları Ayarla</string>
    <string name="settings_denylist_config_summary">İstisnalara yerləşdiriləcək prosesi seçin</string>
    <string name="settings_hosts_title">Sistemsiz hostlar</string>
    <string name="settings_hosts_summary">Reklam əngəlləyici tətbiqlər üçün host faylları</string>
    <string name="settings_hosts_toast">Sistemsiz hostların əlavəsi quruldu</string>
    <string name="settings_app_name_hint">Yeni Ad</string>
    <string name="settings_app_name_helper">Tətbiq bu adla yenidən paketlənəcək</string>
    <string name="settings_app_name_error">Keçərsiz Format</string>
    <string name="settings_su_app_adb">Tətbiqlər və ADB</string>
    <string name="settings_su_app">Yalmız Tətbiqlər</string>
    <string name="settings_su_adb">Yalnız ADB</string>
    <string name="settings_su_disable">Heç Biri</string>
    <string name="settings_su_request_10">10 saniyə</string>
    <string name="settings_su_request_15">15 saniyə</string>
    <string name="settings_su_request_20">20 saniyə</string>
    <string name="settings_su_request_30">30 saniyə</string>
    <string name="settings_su_request_45">45 saniyə</string>
    <string name="settings_su_request_60">60 saniyə</string>
    <string name="superuser_access">Super istifadəçi İcazəsi</string>
    <string name="auto_response">Avtomatik Cavab</string>
    <string name="request_timeout">İstək Vaxtaşımı</string>
    <string name="superuser_notification">Super İstifadəçi Bildirişi</string>
    <string name="settings_su_reauth_title">Yüksəltdikdən sonra yenidən səlahiyətləndir</string>
    <string name="settings_su_reauth_summary">Tətbiqləri yüksəltdikdən sonra Super İstifadəçi icazəsi istə</string>
    <string name="settings_su_tapjack_title">Saxta Ekran (Tapjacking) Qoruması</string>
    <string name="settings_su_tapjack_summary">Super İstifadəçi icazə pəncərəsi digər pəncərələr tərəfindən əngəlləndikdə heçbir girişə cavab verməyəcək</string>
    <string name="settings_customization">Özəlləşdirmə</string>
    <string name="setting_add_shortcut_summary">Tətbiqi gizlətdikdən sonra tapmaq çətin olmasın deyə ana ekrana qısayol əlavə et</string>
    <string name="settings_doh_title">HTTPS üzərindən DNS</string>
    <string name="settings_doh_description">Bəzi ölkələrdə DNS problemlərini həll edir</string>

    <string name="multiuser_mode">Çox istifadəçi Modu</string>
    <string name="settings_owner_only">Yalnız Cihazın Sahibi</string>
    <string name="settings_owner_manage">Cihaz Sahibinin İdarəsində</string>
    <string name="settings_user_independent">İstifadəçidən Qeyri-Asılı</string>
    <string name="owner_only_summary">Yalnız cihaz sahibində root icazəsi var</string>
    <string name="owner_manage_summary">Yalnız cihaz sahibində root icazəsi verə yaxud istəyə bilər</string>
    <string name="user_independent_summary">Hər istifadəçinin öz root icazəsi var</string>

    <string name="mount_namespace_mode">Adlarfəzası modunu qoş</string>
    <string name="settings_ns_global">Beynəlxalq Adlarfəzası</string>
    <string name="settings_ns_requester">Adlarfəzası Daxil et</string>
    <string name="settings_ns_isolate">Təklənmiş Adlarfəzası</string>
    <string name="global_summary">Bütün kök girişləri beynəlxaq adlarfəzası işlədəcək</string>
    <string name="requester_summary">Bütün kök girişləri öz adlarfəzalarından icazə alacaq</string>
    <string name="isolate_summary">Hər kök giriş üçün ayrıca kök adlarfəzası olacaq</string>

    <!--Notifications-->
    <string name="update_channel">Magisk Yeniləmələri</string>
    <string name="progress_channel">İrəliləmə Bildirişləri</string>
    <string name="updated_channel">Yeniləmə Bitdi</string>
    <string name="download_complete">Endirmə Bitdi</string>
    <string name="download_file_error">Faylı endirmək münkün olmadı</string>
    <string name="magisk_update_title">Magisk Yeniləməsi Var!</string>
    <string name="updated_title">Magisk Yeniləndi</string>
    <string name="updated_text">Tətbiqi açmaq üçün toxun</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Mövcud</string>
    <string name="no">Mövcud Deyil</string>
    <string name="repo_install_title">Quraşdır %1$s %2$s(%3$d)</string>
    <string name="download">Endir</string>
    <string name="reboot">Yenidən başlat</string>
    <string name="release_notes">Yeniliklər</string>
    <string name="flashing">Flashlanır...</string>
    <string name="done">Bitdi!</string>
    <string name="failure">Alınmadı!</string>
    <string name="hide_app_title">Magisk tətbiqi gizlədilir…</string>
    <string name="open_link_failed_toast">Keçidi açaçaq tətbiq yoxdur</string>
    <string name="complete_uninstall">Tamamilə sil</string>
    <string name="restore_img">Nüsxələri Bərpa et</string>
    <string name="restore_img_msg">Bərpa Edilir…</string>
    <string name="restore_done">Bərpa Edildi!</string>
    <string name="restore_fail">Bərpa üçün nüxsələr mövcud deyil!</string>
    <string name="setup_fail">Qurma uğursuz oldu</string>
    <string name="env_fix_title">Əlavə yükləməyə ethiyac var</string>
    <string name="env_fix_msg">Cihazınız Magiskin düzgün işləməsi üçün əlavə yükləməyə ehtiyac duyur. Yenidən başlatmaq istəyirsiniz?</string>
    <string name="setup_msg">Yüklənir…</string>
    <string name="unsupport_magisk_title">Bu Magisk versiyası dəstəklənmir</string>
    <string name="unsupport_magisk_msg">Tətbiqin bu versiyası Magiskin %1$s versiyasından aşağıları dəstəkləmir.\n\nTətbiq sanki Magisk heç yoxmuş kimi davranacaq, lütfən Magiski yüksəldin.</string>
    <string name="unsupport_general_title">Anormal Hal</string>
    <string name="unsupport_system_app_msg">Bu tətbiqi sistem tətbiqi kimi açmaq olmur. Onu yenidən istifadəçi tətbiqi etməlisiniz.</string>
    <string name="unsupport_other_su_msg">Magiskdən olmayan \"su\" tapıldı. Lütfən digər kök tətbiqi silin yaxud Magiski yenidən quraşdırın.</string>
    <string name="unsupport_external_storage_msg">Magisk xarici yaddaşa qurulub. Lütfən tətbiqi daxili yaddaşa keçirin.</string>
    <string name="unsupport_nonroot_stub_msg">Gizli Magisk tətbiqi kök itirildiyinə görə işləməyəcək. Orijinal APKnı geri qaytarın.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Bu funksiyanı işə salmaq üçün yaddaş icazəsi verin</string>
    <string name="post_notifications_denied">Bu funksiyanı işə salmaq üçün bildiriş icazəsi verin</string>
    <string name="install_unknown_denied">"bilinməyən tətbiqləri quraşdır"\ı açsanız bu funksiya işə düşəcək</string>
    <string name="add_shortcut_title">Ana ekranda qısayol yarat</string>
    <string name="add_shortcut_msg">Tətbiqi gizlətdikdən sonra tapmaq çətin olmasın deyə ana ekranda qısayol yaradılsın?</string>
    <string name="app_not_found">Bu işi görəcək heçbir tətbiq yoxdur</string>
    <string name="reboot_apply_change">Dəyişikliklər təkrar başladıqdan sonra olacaq</string>
    <string name="restore_app_confirmation">Gizli tətbiq əvvəlki halına qayıdacaq. Davam edilsin?</string>

</resources>

```

`app/core/src/main/res/values-b+sr+Latn/strings.xml`:

```xml
<resources>
    <!--Author: Radoš Milićev (https://github.com/rammba)-->

    <!--Sections-->
    <string name="modules">Moduli</string>
    <string name="superuser">Super-korisnik</string>
    <string name="logs">Logovi</string>
    <string name="settings">Podešavanja</string>
    <string name="install">Instalacija</string>
    <string name="section_home">Početno</string>
    <string name="section_theme">Teme</string>
    <string name="denylist">Lista zabrana</string>

    <!--Home-->
    <string name="no_connection">Nedostupna konekcija</string>
    <string name="app_changelog">Promene u aplikaciji</string>
    <string name="loading">Učitavanje…</string>
    <string name="update">Ažuriranje</string>
    <string name="not_available">N/A</string>
    <string name="hide">Sakrij</string>
    <string name="home_package">Paket</string>
    <string name="home_app_title">Apl.</string>
    <string name="home_notice_content">Preuzmite Magisk SAMO sa zvanične GitHub stranice. Fajlovi iz nepoznatih izvora mogu biti maliciozni!</string>
    <string name="home_support_title">Podržite nas</string>
    <string name="home_follow_title">Zapratite nas</string>
    <string name="home_item_source">Izvor</string>
    <string name="home_support_content">Magisk jeste i uvek će biti besplatan i open source. Međutim, možete pokazati da vam je stalo svojom donacijom.</string>
    <string name="home_installed_version">Instalirano</string>
    <string name="home_latest_version">Najnovije</string>
    <string name="invalid_update_channel">Nevalidan kanal ažuriranja</string>
    <string name="uninstall_magisk_title">Deinstaliraj Magisk</string>
    <string name="uninstall_magisk_msg">Svi moduli će biti onemogućeni/uklonjeni!\nKoren će biti uklonjen!\nSvako neenkriptovano interno skladište će upotrebom Magisk-a biti ponovo enkriptovano!</string>

    <!--Install-->
    <string name="keep_force_encryption">Zadrži forsiranu enkripciju</string>
    <string name="keep_dm_verity">Zadrži AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Režim oporavka</string>
    <string name="install_options_title">Opcije</string>
    <string name="install_method_title">Metod</string>
    <string name="install_next">Naredno</string>
    <string name="install_start">Počnimo</string>
    <string name="manager_download_install">Pritisni da preuzmeš i instaliraš</string>
    <string name="direct_install">Direktna instalacija (Preporučeno)</string>
    <string name="install_inactive_slot">Instalacija na neaktivan slot (Nakon OTA)</string>
    <string name="install_inactive_slot_msg">Vaš uređaj će biti FORSIRAN da se pokrene na trenutno neaktivnom slotu nakon ponovnog pokretanja!\nKoristite opciju samo kad se OTA završi.\nNastavi?</string>
    <string name="setup_title">Dodatne postavke</string>
    <string name="select_patch_file">Izaberite fajl</string>
    <string name="patch_file_msg">Izaberite sliku (*.img) ili ODIN tarfile (*.tar) ili payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">Ponovo pokretanje za 5 sekundi…</string>
    <string name="flash_screen_title">Instalacija</string>

    <!--Superuser-->
    <string name="su_request_title">Super-korisnički zahtev</string>
    <string name="touch_filtered_warning">Magisk ne može da verifikuje vaš odgovor, jer aplikacija prikriva super-korisnički zahtev.</string>
    <string name="deny">Zabrani</string>
    <string name="prompt">Zahtev</string>
    <string name="restrict">Ograniči</string>
    <string name="grant">Dozvoli</string>
    <string name="su_warning">Pruža potpun pristup vašem uređaju.\nZabranite ako niste sigurni!</string>
    <string name="forever">Zauvek</string>
    <string name="once">Jednom</string>
    <string name="tenmin">10 min</string>
    <string name="twentymin">20 min</string>
    <string name="thirtymin">30 min</string>
    <string name="sixtymin">60 min</string>
    <string name="su_allow_toast">%1$s je dobio prava na super-korisnika</string>
    <string name="su_deny_toast">%1$s nije dobio prava na super-korisnika</string>
    <string name="su_snack_grant">Super-korisnička prava od %1$s su pružena</string>
    <string name="su_snack_deny">Super-korisnička prava od %1$s su odbijena</string>
    <string name="su_snack_notif_on">Notifikacije od %1$s su omogućene</string>
    <string name="su_snack_notif_off">Notifikacije od %1$s su onemogućene</string>
    <string name="su_snack_log_on">Logovanje za %1$s je omogućeno</string>
    <string name="su_snack_log_off">Logovanje za %1$s je onemogućeno</string>
    <string name="su_revoke_title">Opozovi?</string>
    <string name="su_revoke_msg">Potvrdi da opozoveš prava na super-korisnika od %1$s?</string>
    <string name="toast">Toast</string>
    <string name="none">Ništa</string>
    <string name="superuser_toggle_notification">Notifikacije</string>
    <string name="superuser_toggle_revoke">Opozovi</string>
    <string name="superuser_policy_none">Nijedna aplikacija nije tražila permisije za super-korisnika još uvek.</string>

    <!--Logs-->
    <string name="log_data_none">Nemate logova. Pokušajte koristiti korenske aplikacije više.</string>
    <string name="log_data_magisk_none">Magisk logovi su prazni, to je čudno.</string>
    <string name="menuSaveLog">Sačuvaj log</string>
    <string name="menuClearLog">Ukloni log</string>
    <string name="logs_cleared">Log uspešno uklonjen</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Ciljani UID: %1$d</string>
    <string name="target_pid">Ciljani PID: %s</string>
    <string name="selinux_context">SELinux kontekst: %s</string>
    <string name="supp_group">Dopunska grupa: %s</string>

    <!--MagiskHide-->
    <string name="show_system_app">Prikaži sistemske apl.</string>
    <string name="show_os_app">Prikaži apl. OS-a</string>
    <string name="hide_filter_hint">Filtriraj po imenu</string>
    <string name="hide_search">Pretraga</string>

    <!--Module-->
    <string name="no_info_provided">(Bez informacija)</string>
    <string name="reboot_userspace">Lako ponovo pokretanje</string>
    <string name="reboot_recovery">Ponovo pokreni za oporavak</string>
    <string name="reboot_bootloader">Ponovo pokreni za bootloader</string>
    <string name="reboot_download">Ponovo pokreni za preuzimanje</string>
    <string name="reboot_edl">Ponovo pokreni za EDL</string>
    <string name="reboot_safe_mode">Siguran mod</string>
    <string name="module_version_author">%1$s od %2$s</string>
    <string name="module_state_remove">Ukloni</string>
    <string name="module_action">Akcija</string>
    <string name="module_state_restore">Povrati</string>
    <string name="module_action_install_external">Instaliraj iz skladišta</string>
    <string name="update_available">Ažuriranje dostupno</string>
    <string name="suspend_text_riru">Modul je suspendovan jer je %1$s omogućeno</string>
    <string name="suspend_text_zygisk">Modul je suspendovan jer %1$s nije omogućeno</string>
    <string name="zygisk_module_unloaded">Zygisk modul nije učitan zbog nekompatibilnosti</string>
    <string name="module_empty">Nijedan modul nije instaliran</string>
    <string name="confirm_install">Instaliraj modul %1$s?</string>
    <string name="confirm_install_title">Potvrda instalacije</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Tema</string>
    <string name="settings_dark_mode_message">Izaberite temu koja vam najviše odgovara!</string>
    <string name="settings_dark_mode_light">Uvek svetlo</string>
    <string name="settings_dark_mode_system">Prati sistem</string>
    <string name="settings_dark_mode_dark">Uvek tamno</string>
    <string name="settings_download_path_title">Putanja za preuzimanje</string>
    <string name="settings_download_path_message">Fajlovi će biti sačuvani na %1$s</string>
    <string name="settings_hide_app_title">Sakrij Magisk apl.</string>
    <string name="settings_hide_app_summary">Instaliraj proxy aplikaciju sa nasumičnim ID-jem paketa i prilagođenom labelom</string>
    <string name="settings_restore_app_title">Povrati Magisk apl.</string>
    <string name="settings_restore_app_summary">Otkrij apl. i povrati originalni APK</string>
    <string name="language">Jezik</string>
    <string name="system_default">(Podrazumevano sistemski)</string>
    <string name="settings_check_update_title">Proveri ažuriranja</string>
    <string name="settings_check_update_summary">Periodično proveri ažuriranja u pozadini</string>
    <string name="settings_update_channel_title">Kanal ažuriranja</string>
    <string name="settings_update_stable">Stabilno</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_debug">Debug</string>
    <string name="settings_update_custom">Prilagođeno</string>
    <string name="settings_update_custom_msg">Unesi prilagođeni URL kanala</string>
    <string name="settings_zygisk_summary">Pokreni delove Magisk-a u Zygote daemon-u</string>
    <string name="settings_denylist_title">Sprovedi listu zabrana</string>
    <string name="settings_denylist_summary">Procesi na listi zabrana će povratiti sve Magisk izmene</string>
    <string name="settings_denylist_config_title">Konfiguriši listu zabrana</string>
    <string name="settings_denylist_config_summary">Izaberi procese koji će biti na listi zabrana</string>
    <string name="settings_hosts_title">Bezsistemski domaćini (hosts)</string>
    <string name="settings_hosts_summary">Podrška bezsistemskih domaćina za aplikacije blokiranja reklama</string>
    <string name="settings_hosts_toast">Modul bezsistemskih domaćina dodat</string>
    <string name="settings_app_name_hint">Novo ime</string>
    <string name="settings_app_name_helper">Apl. će biti spakovana pod ovim imenom</string>
    <string name="settings_app_name_error">Nevalidan format</string>
    <string name="settings_su_app_adb">Aplikacije i ADB</string>
    <string name="settings_su_app">Samo aplikacije</string>
    <string name="settings_su_adb">Samo ADB</string>
    <string name="settings_su_disable">Onemogućeno</string>
    <string name="settings_su_request_10">10 sekundi</string>
    <string name="settings_su_request_15">15 sekundi</string>
    <string name="settings_su_request_20">20 sekundi</string>
    <string name="settings_su_request_30">30 sekundi</string>
    <string name="settings_su_request_45">45 sekundi</string>
    <string name="settings_su_request_60">60 sekundi</string>
    <string name="superuser_access">Pristup super-korisnika</string>
    <string name="auto_response">Automatski odgovor</string>
    <string name="request_timeout">Istek zahteva</string>
    <string name="superuser_notification">Notifikacije super-korisnika</string>
    <string name="settings_su_reauth_title">Ponovo odobri nakon ažuriranja</string>
    <string name="settings_su_reauth_summary">Ponovo traži permisije super-korisnika nakon ažuriranja aplikacija</string>
    <string name="settings_su_tapjack_title">Zaštita od tapjacking-a</string>
    <string name="settings_su_tapjack_summary">Prompt dijalog super-korisnika neće reagovati dok je prikriven drugim prozorom ili overlay-em</string>
    <string name="settings_su_auth_title">Autentifikacija korisnika</string>
    <string name="settings_su_auth_summary">Traži autentifikaciju korisnika tokom zahteva super-korisnika</string>
    <string name="settings_su_auth_insecure">Nijedan metod autentifikacije nije podešen na uređaju</string>
    <string name="settings_su_restrict_title">Ograniči korenske sposobnosti</string>
    <string name="settings_su_restrict_summary">Podrazumevano ograničava apl. super-korisnika. Upozorenje: ovo će većinu aplikacija skršiti. Ne omogućavaj, osim ako znaš šta radiš.</string>
    <string name="settings_customization">Prilagođavanje</string>
    <string name="setting_add_shortcut_summary">Dodaj lepu prečicu na početni ekran u slučaju da se ime i ikonica ne prepoznaju lako nakon skrivanja aplikacije</string>
    <string name="settings_doh_title">DNS preko HTTPS-a</string>
    <string name="settings_doh_description">Zaobilazno rešenje DNS trovanja u nekim nacijama</string>
    <string name="settings_random_name_title">Nasumično ime na izlazu</string>
    <string name="settings_random_name_description">Nasumično ime izlaznog fajla slika i tar fajlova radi sprečavanja detekcije</string>
    <string name="multiuser_mode">Višekorisnički režim</string>
    <string name="settings_owner_only">Samo vlasnik uređaja</string>
    <string name="settings_owner_manage">Određeno od strane vlasnika</string>
    <string name="settings_user_independent">Nezavisno od korisnika</string>
    <string name="owner_only_summary">Samo vlasnik ima pristup korenu</string>
    <string name="owner_manage_summary">Samo vlasnik može da pristupa korenu i da prima zahteve za njega</string>
    <string name="user_independent_summary">Svaki korisnik ima svoja pravila korena</string>
    <string name="mount_namespace_mode">Mount režim namespace-a</string>
    <string name="settings_ns_global">Globalni namespace</string>
    <string name="settings_ns_requester">Nasleđeni namespace</string>
    <string name="settings_ns_isolate">Izolovani namespace</string>
    <string name="global_summary">Sve korenske sesije koriste globalni mount namespace</string>
    <string name="requester_summary">Korenske sesije će naslediti namespace od podnosioca zahteva</string>
    <string name="isolate_summary">Svaka korenska sesija će imati svoj izolovani namespace</string>

    <!--Notifications-->
    <string name="update_channel">Ažuriranja Magisk-a</string>
    <string name="progress_channel">Notifikacije o progresu</string>
    <string name="updated_channel">Ažuriranje završeno</string>
    <string name="download_complete">Preuzimanje završeno</string>
    <string name="download_file_error">Greška pri preuzimanju fajla</string>
    <string name="magisk_update_title">Ažuriranje Magisk-a dostupno!</string>
    <string name="updated_title">Magisk je ažuriran</string>
    <string name="updated_text">Klikni da otvoriš aplikaciju</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Da</string>
    <string name="no">Ne</string>
    <string name="repo_install_title">Instaliraj %1$s %2$s(%3$d)</string>
    <string name="download">Preuzmi</string>
    <string name="reboot">Ponovo pokreni</string>
    <string name="close">Zatvori</string>
    <string name="release_notes">Release notes</string>
    <string name="flashing">Flešovanje…</string>
    <string name="running">Pokretanje…</string>
    <string name="done">Završeno!</string>
    <string name="done_action">Pokretanje akcije %1$s završeno</string>
    <string name="failure">Neuspešno!</string>
    <string name="hide_app_title">Skrivanje Magisk aplikacije…</string>
    <string name="open_link_failed_toast">Nije pronađena aplikacija za otvaranje linka</string>
    <string name="complete_uninstall">Kompletna deinstalacija</string>
    <string name="restore_img">Povrati slike</string>
    <string name="restore_img_msg">Povratak…</string>
    <string name="restore_done">Povratak uspešan!</string>
    <string name="restore_fail">Fabrički bekap ne postoji!</string>
    <string name="setup_fail">Neuspešna postavka</string>
    <string name="env_fix_title">Potrebno dodatno podešavanje</string>
    <string name="env_fix_msg">Vaš uređaj zahteva dodatno podešavanje da bi Magisk radio kako treba. Da li želite nastaviti i pokrenuti ponovo?</string>
    <string name="env_full_fix_msg">Vaš uređaj zahteva ponovno flešovanje da bi Magisk radio kako treba. Reinstalirajte Magisk kroz aplikaciju, režim oporavka ne može dobiti tačne informacije o uređaju.</string>
    <string name="setup_msg">Pokretanje podešavanja okruženja…</string>
    <string name="unsupport_magisk_title">Nepodržana verzija Magisk-a</string>
    <string name="unsupport_magisk_msg">Ova verzija aplikacije ne podržava Magisk verzije manje od %1$s.\n\nAplikacija će se ponašati kao da Magisk nije instaliran. Molimo ažurirajte Magisk što pre.</string>
    <string name="unsupport_general_title">Nenormalno stanje</string>
    <string name="unsupport_system_app_msg">Pokretanje aplikacije kao sistemske nije podržano. Molimo postavite aplikaciju da bude korisnička.</string>
    <string name="unsupport_other_su_msg">Detektovan \"su\" binary koji nije Magisk-ov. Molimo uklonite konkurentno korensko rešenje i/ili reinstalirajte Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk je instaliran na eksterno skladište. Molimo pomerite apl. u interno skladište.</string>
    <string name="unsupport_nonroot_stub_msg">Skrivena Magisk aplikacija ne može nastaviti sa radom jer je koren izgubljen. Molimo povratite originalni APK.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Dozvolite permisiju za skladište da biste omogućili ovu funkcionalnost</string>
    <string name="post_notifications_denied">Dozvolite permisiju za notifikacije da biste omogućili ovu funkcionalnost</string>
    <string name="install_unknown_denied">Dozvolite \"instaliranje nepoznatih aplikacija\" da biste omogućili ovu funkcionalnost</string>
    <string name="add_shortcut_title">Dodaj prečicu na početni ekran</string>
    <string name="add_shortcut_msg">Nakon skrivanja aplikacije, njeno ime i ikonicu ćete teško prepoznati. Želite li dodati lepu prečicu na početni ekran?</string>
    <string name="app_not_found">Nije pronađena aplikacija za ovu akciju</string>
    <string name="reboot_apply_change">Ponovo pokreni da primeniš izmene</string>
    <string name="restore_app_confirmation">Ovo će vratiti skrivenu aplikaciju na originalnu. Da li stvarno to želite?</string>

</resources>

```

`app/core/src/main/res/values-be/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!--Sections-->
    <string name="modules">Модулі</string>
    <string name="superuser">Правы суперкарыстальніка</string>
    <string name="logs">Журналы</string>
    <string name="settings">Налады</string>
    <string name="install">Усталёўка</string>
    <string name="section_home">Хатняя старонка</string>
    <string name="section_theme">Тэмы</string>
    <!--Home-->
    <string name="no_connection">Злучэнне адсутнічае</string>
    <string name="app_changelog">Спіс змен</string>
    <string name="loading">Загрузка…</string>
    <string name="update">Абнавіць</string>
    <string name="not_available">Не</string>
    <string name="hide">Схаваць</string>
    <string name="home_package">Пакунак</string>
    <string name="home_app_title">Праграма</string>
    <string name="home_notice_content">Спампоўваце Magisk ТОЛЬКІ з афіцыйнай старонкі на GitHub. Файлы з невядомых крыніц могуць быць шкоднаснымі!</string>
    <string name="home_support_title">Падтрымайце нас</string>
    <string name="home_item_source">Зыходны код</string>
    <string name="home_support_content">Magisk ёсць і заўсёды будзе бясплатным праектам з адкрытым зыходным кодам. Але вы заўсёды можаце ахвяраваць нам на распрацоўку.</string>
    <string name="home_installed_version">Усталявана</string>
    <string name="home_latest_version">Апошні</string>
    <string name="invalid_update_channel">Хібны канал абнаўлення</string>
    <string name="uninstall_magisk_title">Выдаліць Magisk</string>
    <string name="uninstall_magisk_msg">Усе модулі будуць адключаныя/выдаленыя!\nRoot будзе выдалены!\nВашыя даныя будуць зашыфраваныя!</string>
    <!--Install-->
    <string name="keep_force_encryption">Прымусова захаваць шыфраванне</string>
    <string name="keep_dm_verity">Захаваць AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Рэжым Recovery</string>
    <string name="install_options_title">Параметры</string>
    <string name="install_method_title">Метад</string>
    <string name="install_next">Далей</string>
    <string name="install_start">Усталяваць</string>
    <string name="manager_download_install">Націсніце, каб спампаваць і ўсталяваць</string>
    <string name="direct_install">Непасрэдная ўсталёўка (рэкамендуецца)</string>
    <string name="install_inactive_slot">Усталяваць у неактыўны слот (пасля OTA)</string>
    <string name="install_inactive_slot_msg">Ваша прылада ПРЫМУСОВА перазапусціцца ў неактыўны слот!\nВыкарыстоўвайце гэты параметр толькі пасля завяршэння OTA.\nПрацягнуць?</string>
    <string name="setup_title">Дадатковая ўсталёўка</string>
    <string name="select_patch_file">Абраць файл і ўжыць да яго патч</string>
    <string name="patch_file_msg">Абярыце файл вобраза (*.img) альбо архіў ODIN (*.tar)</string>
    <string name="reboot_delay_toast">Перазапуск праз 5 секунд…</string>
    <string name="flash_screen_title">Усталёўка</string>
    <!--Superuser-->
    <string name="su_request_title">Запыт правоў суперкарыстальніка</string>
    <string name="touch_filtered_warning">Праграма перакрывае запыт на выдачу правоў суперкарыстальніка, таму Magisk не можа апрацаваць ваш адказ</string>
    <string name="deny">Адмовіць</string>
    <string name="prompt">Запытаць</string>
    <string name="grant">Даць</string>
    <string name="su_warning">Даць поўны доступ да вашай прылады.\nКалі вы не ўпэўненыя, адхіліце запыт!</string>
    <string name="forever">Назаўсёды</string>
    <string name="once">Адзін раз</string>
    <string name="tenmin">10 хвіл</string>
    <string name="twentymin">20 хвіл</string>
    <string name="thirtymin">30 хвіл</string>
    <string name="sixtymin">60 хвіл</string>
    <string name="su_allow_toast">Праграме \"%1$s\" дадзеныя правы суперкарыстальніка</string>
    <string name="su_deny_toast">Праграме \"%1$s\" было адмоўлена ў правах суперкарыстальніка</string>
    <string name="su_snack_grant">Праграме \"%1$s\" дадзеныя правы суперкарыстальніка</string>
    <string name="su_snack_deny">Праграме \"%1$s\" адмоўлена ў правах суперкарыстальніка</string>
    <string name="su_snack_notif_on">Апавяшчэнні для \"%1$s\" уключаныя</string>
    <string name="su_snack_notif_off">Апавяшчэнні для \"%1$s\" адключаныя</string>
    <string name="su_snack_log_on">Вядзенне журнала для \"%1$s\" уключана</string>
    <string name="su_snack_log_off">Вядзенне журнала для \"%1$s\" адключана</string>
    <string name="su_revoke_title">Адклікаць?</string>
    <string name="su_revoke_msg">Адклікаць правы для \"%1$s\"?</string>
    <string name="toast">Выплыўныя апавяшчэнні</string>
    <string name="none">Нічога</string>
    <string name="superuser_toggle_notification">Апавяшчэнні</string>
    <string name="superuser_toggle_revoke">Адклікаць</string>
    <string name="superuser_policy_none">Праграма яшчэ не запытвала правоў суперкарыстальніка.</string>
    <!--Logs-->
    <string name="log_data_none">Журналаў няма. Паспрабуйце даць праграмам правы суперкарыстальніка.</string>
    <string name="log_data_magisk_none">Журналы адсутнічаюць.</string>
    <string name="menuSaveLog">Захаваць журнал</string>
    <string name="menuClearLog">Ачысціць журнал</string>
    <string name="logs_cleared">Журнал паспяхова ачышчаны</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Мэтавы UID: %1$d</string>
    <!--SafetyNet-->
    <!--MagiskHide-->
    <string name="show_system_app">Паказваць сістэмныя праграмы</string>
    <string name="show_os_app">Паказваць сістэмныя праграмы</string>
    <string name="hide_filter_hint">Фільтраваць па назве</string>
    <string name="hide_search">Пошук</string>
    <!--Module-->
    <string name="no_info_provided">(Няма інфармацыі)</string>
    <string name="reboot_userspace">Праграмны перазапуск</string>
    <string name="reboot_recovery">Перазапуск у Recovery</string>
    <string name="reboot_bootloader">Перазапуск у Bootloader</string>
    <string name="reboot_download">Перазапуск у Download</string>
    <string name="reboot_edl">Перазапуск у EDL</string>
    <string name="module_version_author">%1$s ад %2$s</string>
    <string name="module_state_remove">Выдаліць</string>
    <string name="module_state_restore">Аднавіць</string>
    <string name="module_action_install_external">Усталяваць са сховішча</string>
    <string name="update_available">Даступныя абнаўленні</string>
    <!--Settings-->
    <string name="settings_dark_mode_title">Рэжым афармлення</string>
    <string name="settings_dark_mode_message">Абярыце рэжым, які вам больш даспадобы!</string>
    <string name="settings_dark_mode_light">Заўсёды светлы</string>
    <string name="settings_dark_mode_system">Сістэмны</string>
    <string name="settings_dark_mode_dark">Заўсёды цёмны</string>
    <string name="settings_download_path_title">Каталог спамповак</string>
    <string name="settings_download_path_message">Файлы будуць спампоўвацца ў %1$s</string>
    <string name="settings_hide_app_title">Схаваць праграму Magisk</string>
    <string name="settings_hide_app_summary">Усталяваць проксі-праграму з выпадковым ідэнтыфікатарам пакунка і адвольным значком</string>
    <string name="settings_restore_app_title">Аднавіць праграму Magisk</string>
    <string name="settings_restore_app_summary">Вярнуць праграму да зыходнага стану</string>
    <string name="language">Мова</string>
    <string name="system_default">(Сістэмная)</string>
    <string name="settings_check_update_title">Правяраць на абнаўленні</string>
    <string name="settings_check_update_summary">Перыядычна правяраць наяўнасць абнаўленняў ў фонавым рэжыме</string>
    <string name="settings_update_channel_title">Канал абнаўлення</string>
    <string name="settings_update_stable">Стабільны</string>
    <string name="settings_update_beta">Бэта</string>
    <string name="settings_update_custom">Адвольны канал</string>
    <string name="settings_update_custom_msg">Устаўце URL</string>
    <string name="settings_hosts_title">Пазасістэмны файл hosts</string>
    <string name="settings_hosts_summary">Падтрымка пазасістэмнага файла hosts для праграм, якія блакуюць рэкламу</string>
    <string name="settings_hosts_toast">Дададзены модуль пазасістэмнага файла hosts</string>
    <string name="settings_app_name_hint">Новая назва</string>
    <string name="settings_app_name_helper">Праграма будзе перапакаваная з гэтай назвай</string>
    <string name="settings_app_name_error">Хібны фармат</string>
    <string name="settings_su_app_adb">Праграмы і ADB</string>
    <string name="settings_su_app">Толькі праграмы</string>
    <string name="settings_su_adb">Толькі ADB</string>
    <string name="settings_su_disable">Адключана</string>
    <string name="settings_su_request_10">10 секунд</string>
    <string name="settings_su_request_15">15 секунд</string>
    <string name="settings_su_request_20">20 секунд</string>
    <string name="settings_su_request_30">30 секунд</string>
    <string name="settings_su_request_45">45 секунд</string>
    <string name="settings_su_request_60">60 секунд</string>
    <string name="superuser_access">Доступ суперкарыстальніка</string>
    <string name="auto_response">Аўтаматычны адказ</string>
    <string name="request_timeout">Чаканне адказу</string>
    <string name="superuser_notification">Апавяшчэнне суперкарыстальніка</string>
    <string name="settings_su_reauth_title">Паўторная аўтэнтыфікацыя пасля абнаўлення</string>
    <string name="settings_su_reauth_summary">Паўторна запытваць правы суперкарыстальніка пасля абнаўлення праграмы</string>
    <string name="settings_su_tapjack_title">Уключыць абарону ад перахоплівання ўводу</string>
    <string name="settings_su_tapjack_summary">Дыялог выдачы правоў суперкарыстальніка не будзе адказваць на ўвод, калі па-над ім знаходзяцца іншыя вокны</string>
    <string name="settings_customization">Персаналізацыя</string>
    <string name="setting_add_shortcut_summary">Дадаць на хатні экран прыгожы цэтлік на той выпадак, калі пасля хавання праграмы будзе цяжка разглядзець значок і назву</string>
    <string name="settings_doh_title">DNS паверх HTTPS</string>
    <string name="settings_doh_description">Абыходны шлях для DNS у некаторых краінах</string>
    <string name="multiuser_mode">Шматкарыстальніцкі рэжым</string>
    <string name="settings_owner_only">Толькі ўладальнік</string>
    <string name="settings_owner_manage">Кіраванне ўладальнікам</string>
    <string name="settings_user_independent">Правілы карыстальнікаў</string>
    <string name="owner_only_summary">Толькі ўладальніку даступны рэжым суперкарыстальніка</string>
    <string name="owner_manage_summary">Толькі ўладальнік кіруе доступам суперкарыстальніка і апрацоўвае запыты</string>
    <string name="user_independent_summary">Кожны карыстальнік кіруе правіламі доступу суперкарыстальніка</string>
    <string name="mount_namespace_mode">Наладка прастораў назваў</string>
    <string name="settings_ns_global">Агульная прастора назваў</string>
    <string name="settings_ns_requester">Спадкаемная прастора назваў</string>
    <string name="settings_ns_isolate">Ізаляваная прастора назваў</string>
    <string name="global_summary">Сеансы суперкарыстальніка выкарыстоўваюць агульную прастору назваў</string>
    <string name="requester_summary">Сеансы суперкарыстальніка выкарыстоўваюць спадкаемную прастору назваў</string>
    <string name="isolate_summary">Сеансы суперкарыстальніка выкарыстоўваюць ізаляваную прастору назваў</string>
    <!--Notifications-->
    <string name="update_channel">Абнаўленні Magisk</string>
    <string name="progress_channel">Апавяшчэнні пра ход выканання</string>
    <string name="download_complete">Спампоўка завершаная</string>
    <string name="download_file_error">Не атрымалася спампаваць файл</string>
    <string name="magisk_update_title">Даступна абнаўленне Magisk!</string>
    <!--Toasts, Dialogs-->
    <string name="yes">Так</string>
    <string name="no">Не</string>
    <string name="repo_install_title">Усталяваць %1$s %2$s(%3$d)</string>
    <string name="download">Спампаваць</string>
    <string name="reboot">Перазапуск</string>
    <string name="release_notes">Пра выпуск</string>
    <string name="flashing">Усталёўка…</string>
    <string name="done">Завершана!</string>
    <string name="failure">Не атрымалася</string>
    <string name="hide_app_title">Хаванне праграмы Magisk…</string>
    <string name="open_link_failed_toast">Праграмы для адкрыцця спасылкі не знойдзена</string>
    <string name="complete_uninstall">Поўнае выдаленне</string>
    <string name="restore_img">Аднавіць раздзелы</string>
    <string name="restore_img_msg">Аднаўленне…</string>
    <string name="restore_done">Аднаўленне завершана!</string>
    <string name="restore_fail">Рэзервовая копія адсутнічае!</string>
    <string name="setup_fail">Усталяваць не атрымалася</string>
    <string name="env_fix_title">Патрабуецца дадатковая ўсталёўка</string>
    <string name="env_fix_msg">Для карэктнай працы на вашай прыладзе спатрэбіцца ўсталяваць дадатковыя кампаненты. Хочаце працягнуць?</string>
    <string name="setup_msg">Наладка асяроддзя…</string>
    <string name="unsupport_magisk_title">Непадтрымліваемая версія Magisk</string>
    <string name="unsupport_magisk_msg">Гэтая версія праграмы не падтрымлівае Magisk версіі ніжэй за %1$s.\n\nПраграма будзе працаваць так, як быццам Magisk не ўсталяваны. Як мага хутчэй абнавіце Magisk.</string>
    <string name="unsupport_general_title">Анамальны стан</string>
    <string name="unsupport_system_app_msg">Гэтую праграму немагчыма запусціць як сістэмную. Калі ласка, вярніце праграму да стану карыстальніцкай.</string>
    <string name="unsupport_other_su_msg">Выяўлены загад \"su\", які не належыць Magisk. Калі ласка, выдаліце іншы кліент.</string>
    <string name="unsupport_external_storage_msg">Праграма Magisk усталяваная ў вонкавым сховішчы. Калі ласка, перамясціце яе ва ўнітарнае сховішча.</string>
    <string name="unsupport_nonroot_stub_msg">Праграма не можа працягваць працу ў схаваным стане, бо root-доступ быў страчаны. Вярніце праграму да зыходнага стану.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Дайце доступ да сховішча, каб уключыць гэтую функцыю</string>
    <string name="add_shortcut_title">Дадаць цэтлік на хатні экран</string>
    <string name="add_shortcut_msg">Пасля хавання праграмы значок і назву можа быць цяжка знайсці. Хочаце дадаць цэтлік на хатні экран?</string>
    <string name="app_not_found">Не знойдзена праграм для апрацоўкі гэтага дзеяння</string>
</resources>

```

`app/core/src/main/res/values-bg/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Модули</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Дневник</string>
    <string name="settings">Настройки</string>
    <string name="install">Инсталиране</string>
    <string name="section_home">Начало</string>
    <string name="section_theme">Теми</string>
    <string name="denylist">Черен списък</string>

    <!--Home-->
    <string name="no_connection">Няма връзка</string>
    <string name="app_changelog">Списък с промени</string>
    <string name="loading">Зареждане…</string>
    <string name="update">Обновяване</string>
    <string name="not_available">Липсва</string>
    <string name="hide">Скриване</string>
    <string name="home_package">Пакет</string>
    <string name="home_app_title">Приложение</string>

    <string name="home_notice_content">Изтегляйте Magisk САМО от официалната страница в GitHub. Файловете от неизвестни източници могат да бъдат зловредни!</string>
    <string name="home_support_title">Подкрепете ни</string>
    <string name="home_follow_title">Последвайте ни</string>
    <string name="home_item_source">Изходен код</string>
    <string name="home_support_content">Magisk е, и винаги ще бъде, безплатен и с отворен изходен код. Въпреки това можете да покажете подкрапата си чрез дарение.</string>
    <string name="home_installed_version">Инсталиранo</string>
    <string name="home_latest_version">Последно</string>
    <string name="invalid_update_channel">Каналът за обновяване е недействителен</string>
    <string name="uninstall_magisk_title">Премахване на Magisk</string>
    <string name="uninstall_magisk_msg">Всички модули ще бъдат изключени/премахнати. Достъпът до правата на суперпотребителя ще бъде премахнат!\nАко вътрешното хранилище е разшифровано с Magisk, то ще бъде шифровано отново!</string>

    <!--Install-->
    <string name="keep_force_encryption">Запазване на наложеното шифроване</string>
    <string name="keep_dm_verity">Запазване на AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Режим за възстановяване</string>
    <string name="install_options_title">Настройки</string>
    <string name="install_method_title">Метод</string>
    <string name="install_next">Напред</string>
    <string name="install_start">Начало</string>
    <string name="manager_download_install">За да изтеглите и инсталирате, докоснете</string>
    <string name="direct_install">Директно инсталиране (препоръчително)</string>
    <string name="install_inactive_slot">Инсталиране в неактивен дял (след OTA)</string>
    <string name="install_inactive_slot_msg">Устройство ЗАДЪЛЖИТЕЛНО ще зареди от текущия неактивен дял при следващия рестарт.\nИзползвайте само при приключила инсталация на OTA.\nПродължаване?</string>
    <string name="setup_title">Допълнителни настройки</string>
    <string name="select_patch_file">Избор и закърпване на файл</string>
    <string name="patch_file_msg">Изберете образ (*.img) или архив на ODIN (*.tar)</string>
    <string name="reboot_delay_toast">Рестартиране след 5 секунди…</string>
    <string name="flash_screen_title">Инсталиране</string>

    <!--Superuser-->
    <string name="su_request_title">Запитване за достъп</string>
    <string name="touch_filtered_warning">Тъй като друго приложение закрива заявката за достъп до правата на суперпотребителя, Magisk не може да потвърди вашия отговор</string>
    <string name="deny">Отказ</string>
    <string name="prompt">Запитване</string>
    <string name="grant">Разрешаване</string>
    <string name="su_warning">Дава пълен достъп до устройството.\nОткажете, ако не сте сигурни.</string>
    <string name="forever">Винаги</string>
    <string name="once">Веднъж</string>
    <string name="tenmin">10 мин.</string>
    <string name="twentymin">20 мин.</string>
    <string name="thirtymin">30 мин.</string>
    <string name="sixtymin">60 мин.</string>
    <string name="su_allow_toast">%1$s получи достъп до суперпотребителя</string>
    <string name="su_deny_toast">%1$s не получи достъп до суперпотребителя</string>
    <string name="su_snack_grant">Достъп до суперпотребителя е разрешен на %1$s</string>
    <string name="su_snack_deny">Достъп до суперпотребителя е отказан на %1$s</string>
    <string name="su_snack_notif_on">Известията за %1$s са включени</string>
    <string name="su_snack_notif_off">Известията за %1$s са изключени</string>
    <string name="su_snack_log_on">Записването в дневника за %1$s е включено</string>
    <string name="su_snack_log_off">Записването в дневника за %1$s е изключено</string>
    <string name="su_revoke_title">Оттегляне?</string>
    <string name="su_revoke_msg">Потвърждавате ли оттегляне на достъпа на %1$s?</string>
    <string name="toast">Тост</string>
    <string name="none">Без</string>

    <string name="superuser_toggle_notification">Известия</string>
    <string name="superuser_toggle_revoke">Оттегляне</string>
    <string name="superuser_policy_none">За момента няма приложения, които да са поискали достъп до правата на суперпотребителя.</string>

    <!--Logs-->
    <string name="log_data_none">Дневникът е празен</string>
    <string name="log_data_magisk_none">Дневникът на Magisk е празен</string>
    <string name="menuSaveLog">Запазване на дневника</string>
    <string name="menuClearLog">Изчистване на дневника</string>
    <string name="logs_cleared">Дневникът е изчистен</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Целеви UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Показване на системни приложения</string>
    <string name="show_os_app">Показване на приложения на ОС</string>
    <string name="hide_filter_hint">Филтрира по име</string>
    <string name="hide_search">Търсене</string>

    <!--Module-->
    <string name="no_info_provided">(Липсва информация)</string>
    <string name="reboot_userspace">Бърз рестарт</string>
    <string name="reboot_recovery">Рестарт в режим за възстановяване</string>
    <string name="reboot_bootloader">Рестарт в bootloader</string>
    <string name="reboot_download">Рестарт в режим за изтегляне</string>
    <string name="reboot_edl">Рестарт в EDL</string>
    <string name="module_version_author">%1$s от %2$s</string>
    <string name="module_state_remove">Премахване</string>
    <string name="module_state_restore">Възстановяване</string>
    <string name="module_action_install_external">Инсталиране от хранилището</string>
    <string name="update_available">Има обновяване</string>
    <string name="suspend_text_riru">Модулът е спрян, защото е включено: %1$s</string>
    <string name="suspend_text_zygisk">Модулът е спрян, защото не е включено: %1$s</string>
    <string name="zygisk_module_unloaded">Поради несъвместимост модулът Zygisk не е зареден</string>
    <string name="module_empty">Не са инсталирани модули</string>
    <string name="confirm_install">Инсталиране на модула %1$s?</string>
    <string name="confirm_install_title">Подвърждаване на инсталиране</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Режим на темата</string>
    <string name="settings_dark_mode_message">Изберете режима, който ви отива най-много!</string>
    <string name="settings_dark_mode_light">Винаги светло</string>
    <string name="settings_dark_mode_system">Според системата</string>
    <string name="settings_dark_mode_dark">Винаги тъмно</string>
    <string name="settings_download_path_title">Папка за изтегляния</string>
    <string name="settings_download_path_message">Файловете ще бъдат запазвани в %1$s</string>
    <string name="settings_hide_app_title">Скриване на приложението на Magisk</string>
    <string name="settings_hide_app_summary">Инсталира междинно приложение с произволен идестификатор и име</string>
    <string name="settings_restore_app_title">Възстановяване на приложението на Magisk</string>
    <string name="settings_restore_app_summary">Показва и възстановява оригиналното приложение</string>
    <string name="language">Език</string>
    <string name="system_default">(Според системата)</string>
    <string name="settings_check_update_title">Проверка за обновяване</string>
    <string name="settings_check_update_summary">Периодична проверка за обновяване във фонов режим</string>
    <string name="settings_update_channel_title">Канал за обновяване</string>
    <string name="settings_update_stable">Стабилен</string>
    <string name="settings_update_beta">Бета</string>
    <string name="settings_update_custom">Потребителски</string>
    <string name="settings_update_custom_msg">Адрес на потребителски канал</string>
    <string name="settings_zygisk_summary">Изпълняване на части от Magisk в демон на zygote</string>
    <string name="settings_denylist_title">Налагане на черен списък</string>
    <string name="settings_denylist_summary">На процесите в черния списък ще бъдат възстановени всички модификации, направени от Magisk</string>
    <string name="settings_denylist_config_title">Настройка на черен списък</string>
    <string name="settings_denylist_config_summary">Изберете процесите, които да бъдат включени в черния списък</string>
    <string name="settings_hosts_title">Безсистемни хостове</string>
    <string name="settings_hosts_summary">Поддръжка на безсистемни хостове, ползвани от приложения за спиране на реклами</string>
    <string name="settings_hosts_toast">Модулът за безсистемни хостове е добавен</string>
    <string name="settings_app_name_hint">Ново име</string>
    <string name="settings_app_name_helper">Приложението ще бъде пакетирано с това име</string>
    <string name="settings_app_name_error">Форматът е недействителен</string>
    <string name="settings_su_app_adb">Приложения и ADB</string>
    <string name="settings_su_app">Само приложения</string>
    <string name="settings_su_adb">Само ADB</string>
    <string name="settings_su_disable">Изключен</string>
    <string name="settings_su_request_10">10 секунди</string>
    <string name="settings_su_request_15">15 секунди</string>
    <string name="settings_su_request_20">20 секунди</string>
    <string name="settings_su_request_30">30 секунди</string>
    <string name="settings_su_request_45">45 секунди</string>
    <string name="settings_su_request_60">60 секунди</string>
    <string name="superuser_access">Достъп до суперпотребителя</string>
    <string name="auto_response">Автоматичен отговор</string>
    <string name="request_timeout">Време за запитване</string>
    <string name="superuser_notification">Известие за суперпотребителя</string>
    <string name="settings_su_reauth_title">Повторно запитване след обновяване</string>
    <string name="settings_su_reauth_summary">Повторно запитване за достъп до правата на суперпотребителя след обновяване на приложения</string>
    <string name="settings_su_tapjack_title">Предпазване от измамно докосване</string>
    <string name="settings_su_tapjack_summary">Прозорецът за достъп до суперпотребителя няма да реагира, докато е покрит от друг прозорец или слой</string>
    <string name="settings_customization">Приспособяване</string>
    <string name="setting_add_shortcut_summary">Добавя красив пряк път на началния екран ако името или текущата икона на скритото приложение са трудни за разпознаване</string>
    <string name="settings_doh_title">DNS през HTTPS</string>
    <string name="settings_doh_description">Заобикаля „отравянето“ на DNS в някои държави</string>

    <string name="multiuser_mode">Многопотребителски режим</string>
    <string name="settings_owner_only">Само собственика</string>
    <string name="settings_owner_manage">Управление от страна на собственика</string>
    <string name="settings_user_independent">Независимо от потребителя</string>
    <string name="owner_only_summary">Само собственикът има достъп до суперпотребителя</string>
    <string name="owner_manage_summary">Само собственикът може да управлява достъпа до суперпотребителя и да получава запитвания за достъп</string>
    <string name="user_independent_summary">Всеки потребител има собствени правила за достъп до суперпотребителя</string>

    <string name="mount_namespace_mode">Монтиране по пространства от имена</string>
    <string name="settings_ns_global">Общо</string>
    <string name="settings_ns_requester">Наследено</string>
    <string name="settings_ns_isolate">Изолирано</string>
    <string name="global_summary">Всички сесии с достъп до суперпотребителя използват общото пространство от имена</string>
    <string name="requester_summary">Всички сесии с достъп до суперпотребителя наследяват пространството от имена на запитващото приложение</string>
    <string name="isolate_summary">Всички сесии с достъп до суперпотребителя получават изолирани пространства от имена</string>

    <!--Notifications-->
    <string name="update_channel">Обновяване на Magisk</string>
    <string name="progress_channel">Известия за напредък</string>
    <string name="updated_channel">Завършено обновяване</string>
    <string name="download_complete">Завършено изтегляне</string>
    <string name="download_file_error">Грешка при изтегляне на файл</string>
    <string name="magisk_update_title">Има обновяване на Magisk!</string>
    <string name="updated_title">Magisk е обновен</string>
    <string name="updated_text">За да отворите приложението, докоснете</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Да</string>
    <string name="no">Не</string>
    <string name="repo_install_title">Инсталиране на %1$s %2$s(%3$d)</string>
    <string name="download">Изтегляне</string>
    <string name="reboot">Рестартиране</string>
    <string name="release_notes">Бележки по изданието</string>
    <string name="flashing">Инсталиране…</string>
    <string name="done">Готово!</string>
    <string name="failure">Грешка!</string>
    <string name="hide_app_title">Скриване на приложението на Magisk…</string>
    <string name="open_link_failed_toast">Не е намерено приложение, с което препратката да бъде отворена</string>
    <string name="complete_uninstall">Премахване</string>
    <string name="restore_img">Възстановяване на образи</string>
    <string name="restore_img_msg">Възстановяване…</string>
    <string name="restore_done">Възстановяването е успешно!</string>
    <string name="restore_fail">На устройството липсва резервно копие на заводския образ!</string>
    <string name="setup_fail">Грешка при първоначална настройка</string>
    <string name="env_fix_title">Необходима е допълнителна настройка</string>
    <string name="env_fix_msg">За да работи Magisk нормално, устройството се нуждае от допълнителна настройка. Да бъде ли продължено след рестарт?</string>
    <string name="env_full_fix_msg">За да работи Magisk нормално, е необходимо да бъде инсталиран отново. Преинсталирайте Magisk от приложението, защото режимът за възстановяване не получава необходимата информация за устройството.</string>
    <string name="setup_msg">Надстройка на средата…</string>
    <string name="unsupport_magisk_title">Неподдържано издание на Magisk</string>
    <string name="unsupport_magisk_msg">Това издание на приложението не поддържа издания на Magisk преди %1$s.\n\nПриложението ще се държи все едно няма инсталиран Magisk. Обновете Magisk възможно най-скоро.</string>
    <string name="unsupport_general_title">Неочаквано състояние</string>
    <string name="unsupport_system_app_msg">Приложението не се поддържа да работи като системно. Върнете го като потребителско.</string>
    <string name="unsupport_other_su_msg">Намерен е двоичен файл „su“, който не е от Magisk. Премахнете всички други решения за достъп до правата на суперпотребителя и/или инсталирайте Magisk отново.</string>
    <string name="unsupport_external_storage_msg">Magisk е инсталиран във външно хранилище. Преместете приложението във вътрешното хранилище.</string>
    <string name="unsupport_nonroot_stub_msg">Скритото приложение на Magisk не може да продължи да работи, защото достъпът до правата на суперпотребителя е загубен. Възстановете оригиналното приложение.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">За да използвате нази възможност, разрешете достъп до хранилището</string>
    <string name="post_notifications_denied">За да използвате нази възможност, разрешете достъп до известията</string>
    <string name="install_unknown_denied">За да използвате тази възможност, разрешете „инсталиране на неизвестни приложения“</string>
    <string name="add_shortcut_title">Добавяне на пряк път на началния екран</string>
    <string name="add_shortcut_msg">След скриване на приложението името или икона може да станат трудни за разпознаване. Желаете ли да бъде добаве красив пряк път на началния екран?</string>
    <string name="app_not_found">Не е намерено приложение, което да извърши действието</string>
    <string name="reboot_apply_change">Рестартиране за прилагане на промените</string>
    <string name="restore_app_confirmation">По този начин ще възстановите скритото приложение в първоначалното му състояние. Това ли желаете да бъде направено?</string>

</resources>

```

`app/core/src/main/res/values-bn/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">মডিউল</string>
    <string name="superuser">সুপার ইউজার</string>
    <string name="logs">লগ</string>
    <string name="settings">সেটিংস</string>
    <string name="install">ইনস্টল করুন</string>
    <string name="section_home">হোম</string>
    <string name="section_theme">থিম</string>
    <string name="denylist">ডিনাইলিস্ট</string>

    <!--Home-->
    <string name="no_connection">কোনো সংযোগ উপলব্ধ নেই</string>
    <string name="app_changelog">চেঞ্জলগ</string>
    <string name="loading">লোড হচ্ছে…</string>
    <string name="update">হালনাগাদ</string>
    <string name="not_available">N/A</string>
    <string name="hide">লুকান</string>
    <string name="home_package">প্যাকেজ</string>
    <string name="home_app_title">অ্যাপ</string>

    <string name="home_notice_content">শুধুমাত্র অফিসিয়াল গিটহাব পেজ থেকে ম্যাজিস্ক ডাউনলোড করুন। অজানা উৎস থেকে ফাইল ক্ষতিকর হতে পারে!</string>
    <string name="home_support_title">আমাদের সমর্থন</string>
    <string name="home_follow_title">আমাদের অনুসরণ করো</string>
    <string name="home_item_source">সূত্র</string>
    <string name="home_support_content">ম্যাজিস্ক হল, এবং সবসময় থাকবে, বিনামূল্যে, এবং ওপেন সোর্স। তবে আপনি দান করার মাধ্যমে আমাদের দেখাতে পারেন যে আপনি যত্নশীল।</string>
    <string name="home_installed_version">ইনস্টল করা হয়েছে</string>
    <string name="home_latest_version">সর্বশেষ</string>
    <string name="invalid_update_channel">অবৈধ আপডেট চ্যানেল</string>
    <string name="uninstall_magisk_title">ম্যাজিস্ক আনইনস্টল করুন</string>
    <string name="uninstall_magisk_msg">সমস্ত মডিউল নিষ্ক্রিয়/মুছে ফেলা হবে!\nরুট সরানো হবে!\nম্যাজিস্ক ব্যবহারের মাধ্যমে এনক্রিপ্ট করা যে কোনও অভ্যন্তরীণ স্টোরেজ পুনরায় এনক্রিপ্ট করা হবে!</string>

    <!--Install-->
    <string name="keep_force_encryption">এনক্রিপশন সংরক্ষণ করুন</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity সংরক্ষণ করুন</string>
    <string name="recovery_mode">পুনরুদ্ধার অবস্থা</string>
    <string name="install_options_title">অপশন</string>
    <string name="install_method_title">পদ্ধতি</string>
    <string name="install_next">পরবর্তী</string>
    <string name="install_start">চলো যাই</string>
    <string name="manager_download_install">ডাউনলোড এবং ইনস্টল করুন</string>
    <string name="direct_install">সরাসরি ইনস্টল</string>
    <string name="install_inactive_slot">নিষ্ক্রিয় স্লটে ইনস্টল করুন (OTA এর পরে)</string>
    <string name="install_inactive_slot_msg">রিবুট করার পরে আপনার ডিভাইসটিকে বর্তমান নিষ্ক্রিয় স্লটে বুট করতে বাধ্য করা হবে!\It হয়ে গেলেই এই বিকল্পটি ব্যবহার করুন।\চালিয়ে রাখবেন?</string>
    <string name="setup_title">অতিরিক্ত সেটআপ</string>
    <string name="select_patch_file">একটি ফাইল নির্বাচন করুন এবং প্যাচ করুন</string>
    <string name="patch_file_msg">একটি কাঁচা চিত্র (*.img) বা একটি ODIN টারফাইল (*.tar) নির্বাচন করুন</string>
    <string name="reboot_delay_toast">৫ সেকেন্ডের মধ্যে রিবুট হচ্ছে...</string>
    <string name="flash_screen_title">স্থাপন</string>

    <!--Superuser-->
    <string name="su_request_title">সুপার ইউজার অনুরোধ/স্ট্রিং</string>
    <string name="touch_filtered_warning">যেহেতু একটি অ্যাপ সুপার ব্যবহারকারীর অনুরোধকে অস্পষ্ট করছে, ম্যাজিস্ক আপনার প্রতিক্রিয়া যাচাই করতে পারে না</string>
    <string name="deny">অস্বীকার করুন</string>
    <string name="prompt">শীঘ্র</string>
    <string name="grant">প্রদান</string>
    <string name="su_warning">আপনার ডিভাইসে সম্পূর্ণ অ্যাক্সেস মঞ্জুর করে৷\nআপনি নিশ্চিত না হলে অস্বীকার করুন!</string>
    <string name="forever">চিরতরে</string>
    <string name="once">একদা</string>
    <string name="tenmin">১০ মিনিট</string>
    <string name="twentymin">২০ মিনিট</string>
    <string name="thirtymin">৩০ মিনিট</string>
    <string name="sixtymin">৬০ মিনিট</string>
    <string name="su_allow_toast">%1$s সুপার ইউজার অধিকার দেওয়া হয়েছিল</string>
    <string name="su_deny_toast">%1$s সুপার ইউজার অধিকার অস্বীকার করা হয়েছিল</string>
    <string name="su_snack_grant">%1$s-এর সুপার ব্যবহারকারীর অধিকার মঞ্জুর করা হয়েছে</string>
    <string name="su_snack_deny">%1$s-এর সুপার ব্যবহারকারীর অধিকার অস্বীকার করা হয়েছে৷</string>
    <string name="su_snack_notif_on">%1$s-এর বিজ্ঞপ্তিগুলি সক্ষম করা হয়েছে৷</string>
    <string name="su_snack_notif_off">%1$s-এর বিজ্ঞপ্তিগুলি অক্ষম করা হয়েছে৷</string>
    <string name="su_snack_log_on">%1$s এর লগিং সক্ষম করা হয়েছে৷</string>
    <string name="su_snack_log_off">%1$s এর লগিং অক্ষম করা হয়েছে৷</string>
    <string name="su_revoke_title">প্রত্যাহার করুন?</string>
    <string name="su_revoke_msg">%1$s সুপার ব্যবহারকারীর অধিকার প্রত্যাহার করতে নিশ্চিত করুন৷</string>
    <string name="toast">টোস্ট</string>
    <string name="none">কোনোটিই নয়</string>
    <string name="superuser_toggle_notification">বিজ্ঞপ্তি</string>
    <string name="superuser_toggle_revoke">প্রত্যাহার করুন</string>
    <string name="superuser_policy_none">কোনো অ্যাপ এখনও সুপার ইউজারের অনুমতি চায়নি।</string>

    <!--Logs-->
    <string name="log_data_none">আপনি লগ-মুক্ত, আপনার রুট অ্যাপগুলি আরও ব্যবহার করার চেষ্টা করুন৷</string>
    <string name="log_data_magisk_none">ম্যাজিস্ক লগগুলি খালি, এটি অদ্ভুত</string>
    <string name="menuSaveLog">লগ সংরক্ষণ</string>
    <string name="menuClearLog">এখন লগ সাফ করুন</string>
    <string name="logs_cleared">লগ সফলভাবে সাফ করা হয়েছে৷</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">লক্ষ্য UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">সিস্টেম অ্যাপ দেখান</string>
    <string name="show_os_app">ওএস অ্যাপ দেখান</string>
    <string name="hide_filter_hint">নাম অনুসারে ফিল্টার করুন</string>
    <string name="hide_search">অনুসন্ধান করুন</string>

    <!--Module-->
    <string name="no_info_provided">(কোন তথ্য প্রদান করা হয়</string>
    <string name="reboot_userspace">নরম রিবুট</string>
    <string name="reboot_recovery">রিকভারিতে রিবুট করুন</string>
    <string name="reboot_bootloader">বুটলোডারে রিবুট করুন</string>
    <string name="reboot_download">ডাউনলোড করতে রিবুট করুন</string>
    <string name="reboot_edl">EDL এ রিবুট করুন</string>
    <string name="module_version_author">%1$s by %2$s</string>
    <string name="module_state_remove">অপসারণ</string>
    <string name="module_state_restore">পুনরুদ্ধার করুন</string>
    <string name="module_action_install_external">স্টোরেজ থেকে ইনস্টল করুন</string>
    <string name="update_available">আপডেট উপলব্ধ</string>
    <string name="suspend_text_riru">মডিউল সাসপেন্ড করা হয়েছে কারণ %1$s সক্ষম হয়েছে৷</string>
    <string name="suspend_text_zygisk">মডিউল সাসপেন্ড করা হয়েছে কারণ %1$s সক্ষম করা নেই৷</string>
    <string name="zygisk_module_unloaded">অসামঞ্জস্যতার কারণে জাইগিস্ক মডিউল লোড করা হয়নি</string>
    <string name="module_empty">কোন মডিউল ইনস্টল করা নেই</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">থিম মোড</string>
    <string name="settings_dark_mode_message">আপনার শৈলী সবচেয়ে উপযুক্ত মোড নির্বাচন করুন!</string>
    <string name="settings_dark_mode_light">সবসময় আলো</string>
    <string name="settings_dark_mode_system">সিস্টেম অনুসরণ করুন</string>
    <string name="settings_dark_mode_dark">সবসময় অন্ধকার</string>
    <string name="settings_download_path_title">পাথ ডাউনলোড করুন</string>
    <string name="settings_download_path_message">ফাইলগুলি %1$s এ সংরক্ষণ করা হবে৷</string>
    <string name="settings_hide_app_title">ম্যাজিস্ক অ্যাপটি লুকান</string>
    <string name="settings_hide_app_summary">একটি র্যান্ডম প্যাকেজ আইডি এবং কাস্টম অ্যাপ লেব সহ একটি প্রক্সি অ্যাপ ইনস্টল করুনl</string>
    <string name="settings_restore_app_title">ম্যাজিস্ক অ্যাপটি পুনরুদ্ধার করুন</string>
    <string name="settings_restore_app_summary">অ্যাপটি আড়াল করুন এবং আসলটি পুনরুদ্ধার করুন</string>
    <string name="language">ভাষা</string>
    <string name="system_default">(সিস্টেমের ডিফল্ট)</string>
    <string name="settings_check_update_title">আপডেট চেক করুন</string>
    <string name="settings_check_update_summary">পর্যায়ক্রমে পটভূমিতে আপডেটের জন্য চেক করুন</string>
    <string name="settings_update_channel_title">চ্যানেল আপডেট করুন</string>
    <string name="settings_update_stable">স্থিতিশীল</string>
    <string name="settings_update_beta">বেটা</string>
    <string name="settings_update_custom">কাস্টম</string>
    <string name="settings_update_custom_msg">একটি কাস্টম চ্যানেল URL সন্নিবেশ করুন</string>
    <string name="settings_zygisk_summary">জাইগোট ডেমনে ম্যাজিস্কের অংশগুলি চালান</string>
    <string name="settings_denylist_title">তালিকা অস্বীকার করুন প্রয়োগ করুন</string>
    <string name="settings_denylist_summary">ডিনালিস্টের প্রসেসগুলিতে সমস্ত ম্যাজিস্ক পরিবর্তনগুলি ফিরিয়ে দেওয়া হবে</string>
    <string name="settings_denylist_config_title">অস্বীকার তালিকা কনফিগার করুন</string>
    <string name="settings_denylist_config_summary">অস্বীকৃত তালিকায় অন্তর্ভুক্ত করার জন্য প্রক্রিয়াগুলি নির্বাচন করুন৷</string>
    <string name="settings_hosts_title">সিস্টেমহীন হোস্ট</string>
    <string name="settings_hosts_summary">বিজ্ঞাপন ব্লকিং অ্যাপের জন্য সিস্টেমলেস হোস্ট</string>
    <string name="settings_hosts_toast">সিস্টেমহীন হোস্ট মডিউল যোগ করা হয়েছে</string>
    <string name="settings_app_name_hint">নতুন নাম</string>
    <string name="settings_app_name_helper">অ্যাপটি এই নামের সাথে পুনরায় প্যাকেজ করা হবে</string>
    <string name="settings_app_name_error">ভুল ফরম্যাট</string>
    <string name="settings_su_app_adb">অ্যাপস এবং এডিবি</string>
    <string name="settings_su_app">শুধুমাত্র অ্যাপস</string>
    <string name="settings_su_adb">শুধুমাত্র এডিবি</string>
    <string name="settings_su_disable">অক্ষম</string>
    <string name="settings_su_request_10">১০ সেকেন্ড</string>
    <string name="settings_su_request_15">১৫ সেকেন্ড</string>
    <string name="settings_su_request_20">২০ সেকেন্ড</string>
    <string name="settings_su_request_30">৩০ সেকেন্ড</string>
    <string name="settings_su_request_45">৪৫ সেকেন্ড</string>
    <string name="settings_su_request_60">৬০ সেকেন্ড</string>
    <string name="superuser_access">সুপার ইউজার অ্যাক্সেস</string>
    <string name="auto_response">স্বয়ংক্রিয় প্রতিক্রিয়া</string>
    <string name="request_timeout">অনুরোধের সময়সীমা শেষ</string>
    <string name="superuser_notification">সুপার ইউজার বিজ্ঞপ্তি</string>
    <string name="settings_su_reauth_title">আপগ্রেড করার পরে পুনরায় প্রমাণীকরণ করুন</string>
    <string name="settings_su_reauth_summary">অ্যাপগুলি আপগ্রেড করার পরে আবার সুপার ইউজার অনুমতির জন্য জিজ্ঞাসা করুন</string>
    <string name="settings_su_tapjack_title">ট্যাপজ্যাকিং সুরক্ষা</string>
    <string name="settings_su_tapjack_summary">সুপার ইউজার প্রম্পট ডায়ালগ অন্য কোনো উইন্ডো বা ওভারলে দ্বারা অস্পষ্ট থাকাকালীন ইনপুটটিতে সাড়া দেবে না</string>
    <string name="settings_customization">কাস্টমাইজেশন</string>
    <string name="setting_add_shortcut_summary">অ্যাপটি লুকানোর পরে নাম এবং আইকন সনাক্ত করা কঠিন হলে হোম স্ক্রিনে একটি সুন্দর শর্টকাট যোগ করুন</string>
    <string name="settings_doh_title">HTTPS এর উপর ডিএনএস</string>
    <string name="settings_doh_description">কিছু দেশে ডিএনএস বিষক্রিয়ার সমাধান</string>

    <string name="multiuser_mode">মাল্টিউজার মোড</string>
    <string name="settings_owner_only">শুধুমাত্র ডিভাইসের মালিক</string>
    <string name="settings_owner_manage">ডিভাইস মালিক পরিচালিত</string>
    <string name="settings_user_independent">ব্যবহারকারী-স্বাধীন</string>
    <string name="owner_only_summary">শুধুমাত্র মালিকের রুট অ্যাক্সেস আছে</string>
    <string name="owner_manage_summary">শুধুমাত্র মালিকই রুট অ্যাক্সেস পরিচালনা করতে পারে এবং অনুরোধ প্রম্পট গ্রহণ করতে পারে</string>
    <string name="user_independent_summary">প্রতিটি ব্যবহারকারীর নিজস্ব পৃথক রুট নিয়ম আছে</string>

    <string name="mount_namespace_mode">মাউন্ট নেমস্পেস মোড</string>
    <string name="settings_ns_global">গ্লোবাল নেমস্পেস</string>
    <string name="settings_ns_requester">নেমস্পেস ইনহেরিট করুন</string>
    <string name="settings_ns_isolate">বিচ্ছিন্ন নামস্থান</string>
    <string name="global_summary">সমস্ত রুট সেশন গ্লোবাল মাউন্ট নেমস্পেস ব্যবহার করে</string>
    <string name="requester_summary">রুট সেশন অনুরোধকারীর নামস্থান উত্তরাধিকারী হবে</string>
    <string name="isolate_summary">প্রতিটি রুট সেশনের নিজস্ব বিচ্ছিন্ন নামস্থান থাকবে</string>

    <!--Notifications-->
    <string name="update_channel">ম্যাজিস্ক আপডেট</string>
    <string name="progress_channel">অগ্রগতি বিজ্ঞপ্তি</string>
    <string name="updated_channel">আপডেট সম্পূর্ণ</string>
    <string name="download_complete">ডাউনলোড শেষ</string>
    <string name="download_file_error">ফাইল ডাউনলোড করার সময় ত্রুটি</string>
    <string name="magisk_update_title">ম্যাজিস্ক আপডেট উপলব্ধ!</string>
    <string name="updated_title">ম্যাজিস্ক আপডেট</string>
    <string name="updated_text">অ্যাপ খুলতে আলতো চাপুন</string>

    <!--Toasts, Dialogs-->
    <string name="yes">হ্যাঁ</string>
    <string name="no">না</string>
    <string name="repo_install_title">ইনস্টল করুন %1$s %2$s(%3$d)</string>
    <string name="download">ডাউনলোড করুন</string>
    <string name="reboot">রিবুট করুন</string>
    <string name="release_notes">অব্যাহতি পত্র</string>
    <string name="flashing">ঝলকানি…</string>
    <string name="done">সম্পন্ন!</string>
    <string name="failure">ব্যর্থ হয়েছে!</string>
    <string name="hide_app_title">ম্যাজিস্ক অ্যাপটি লুকিয়ে রাখছে…</string>
    <string name="open_link_failed_toast">লিঙ্ক খোলার জন্য কোনো অ্যাপ পাওয়া যায়নি</string>
    <string name="complete_uninstall">সম্পূর্ণ আনইনস্টল করুন</string>
    <string name="restore_img">ছবি পুনরুদ্ধার করুন</string>
    <string name="restore_img_msg">পুনরুদ্ধার করা হচ্ছে…</string>
    <string name="restore_done">পুনরুদ্ধার করা হয়েছে!</string>
    <string name="restore_fail">স্টক ব্যাকআপ বিদ্যমান নেই!</string>
    <string name="setup_fail">সেটআপ ব্যর্থ হয়েছে৷</string>
    <string name="env_fix_title">অতিরিক্ত সেটআপ প্রয়োজন</string>
    <string name="env_fix_msg">ম্যাজিস্ক সঠিকভাবে কাজ করার জন্য আপনার ডিভাইসের অতিরিক্ত সেটআপ প্রয়োজন। আপনি কি এগিয়ে যেতে এবং রিবুট করতে চান?</string>
    <string name="setup_msg">চলমান পরিবেশ সেটআপ…</string>
    <string name="unsupport_magisk_title">অসমর্থিত ম্যাজিস্ক সংস্করণ</string>
    <string name="unsupport_magisk_msg">অ্যাপটির এই সংস্করণটি %1$s-এর চেয়ে কম ম্যাগিস্ক সংস্করণগুলিকে সমর্থন করে না৷\n\nঅ্যাপটি এমন আচরণ করবে যেন কোনও ম্যাজিস্ক ইনস্টল করা নেই, দয়া করে যত তাড়াতাড়ি সম্ভব ম্যাজিস্ক আপগ্রেড করুন।</string>
    <string name="unsupport_general_title">অস্বাভাবিক অবস্থা</string>
    <string name="unsupport_system_app_msg">এই অ্যাপটিকে একটি সিস্টেম অ্যাপ হিসেবে চালানো সমর্থিত নয়। অনুগ্রহ করে অ্যাপটিকে একটি ব্যবহারকারী অ্যাপে ফিরিয়ে দিন।</string>
    <string name="unsupport_other_su_msg">ম্যাজিস্ক থেকে নয় একটি \"su\" বাইনারি সনাক্ত করা হয়েছে। অনুগ্রহ করে কোনো প্রতিযোগী রুট সমাধান সরান এবং/অথবা ম্যাজিস্ক পুনরায় ইনস্টল করুন।</string>
    <string name="unsupport_external_storage_msg">ম্যাজিস্ক বহিরাগত স্টোরেজ ইনস্টল করা হয়। অনুগ্রহ করে অ্যাপটিকে অভ্যন্তরীণ সঞ্চয়স্থানে সরান৷</string>
    <string name="unsupport_nonroot_stub_msg">লুকানো ম্যাজিস্ক অ্যাপটি কাজ চালিয়ে যেতে পারে না কারণ রুট হারিয়ে গেছে। অনুগ্রহ করে আসল APK পুনরুদ্ধার করুন।</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">এই কার্যকারিতা সক্ষম করতে স্টোরেজ অনুমতি দিন</string>
    <string name="post_notifications_denied">নোটিফিকেশন এর অনোমতি দিন</string>
    <string name="install_unknown_denied">এই কার্যকারিতা সক্ষম করতে "অজানা অ্যাপগুলি ইনস্টল করুন" এর অনুমতি দিন</string>
    <string name="add_shortcut_title">হোম স্ক্রিনে শর্টকাট যোগ করুন</string>
    <string name="add_shortcut_msg">এই অ্যাপটি লুকানোর পরে, এর নাম এবং আইকন চিনতে অসুবিধা হতে পারে। আপনি কি হোম স্ক্রিনে একটি সুন্দর শর্টকাট যোগ করতে চান?</string>
    <string name="app_not_found">এই ক্রিয়াটি পরিচালনা করার জন্য কোনো অ্যাপ পাওয়া যায়নি</string>
    <string name="reboot_apply_change">পরিবর্তনগুলি প্রয়োগ করতে রিবুট করুন</string>
    <string name="restore_app_confirmation">এটি লুকানো অ্যাপটিকে মূল অ্যাপে ফিরিয়ে আনবে। আপনি কি সত্যিই এটি করতে চান?</string>

</resources>

```

`app/core/src/main/res/values-ca/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Mòduls</string>
    <string name="superuser">Superusuari</string>
    <string name="logs">Registre</string>
    <string name="settings">Configuració</string>
    <string name="install">Instal·lar</string>
    <string name="section_home">Inici</string>
    <string name="section_theme">Temes</string>

    <!--Home-->
    <string name="no_connection">Connexió no disponible</string>
    <string name="app_changelog">Registre de canvis</string>
    <string name="loading">Carregant…</string>
    <string name="update">Actualització</string>
    <string name="not_available">N/A</string>
    <string name="hide">Amagar</string>
    <string name="home_package">Paquet</string>
    <string name="home_app_title">App</string>

    <string name="home_notice_content">Descarregui Magisk NOMÉS des de la pàgina oficial de GitHub. Fitxers d\'altres fonts desconegudes poden ser maliciosos!</string>
    <string name="home_support_title">Doni suport</string>
    <string name="home_item_source">Codi font</string>
    <string name="home_support_content">Magisk és, i sempre serà, gratis i codi lliure. De totes maneres, pot mostrar el seu interès fent una petita donació.</string>
    <string name="home_installed_version">Instal·lat</string>
    <string name="home_latest_version">Última</string>
    <string name="invalid_update_channel">Canal d\'actualització invàlid</string>
    <string name="uninstall_magisk_title">Desinstal·lar Magisk</string>
    <string name="uninstall_magisk_msg">Tots els mòduls seran desactivats i eliminats! L\'accés d\'arrel s\'eliminarà i, possiblement, xifrarà totes les dades (si no estan ja xifrades).</string>

    <!--Install-->
    <string name="keep_force_encryption">Mantenir el xifrat forçat</string>
    <string name="keep_dm_verity">Mantenir AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Mode de Recuperació</string>
    <string name="install_options_title">Opcions</string>
    <string name="install_method_title">Mètode</string>
    <string name="install_next">Següent</string>
    <string name="install_start">Endavant</string>
    <string name="manager_download_install">Premi per baixar i instal·lar</string>
    <string name="direct_install">Instal·lació directa (Recomanat)</string>
    <string name="install_inactive_slot">Instal·la a la ranura inactiva (Després d\'una OTA)</string>
    <string name="install_inactive_slot_msg">El teu dispositiu serà FORÇAT a arrancar en l\'actual ranura inactiva després del reinici!\nUtilitza aquesta opció NOMÉS quan l\'OTA s\'hagi fet.\nContinuar?</string>
    <string name="setup_title">Instal·lació addicional</string>
    <string name="select_patch_file">Selecciona i arranja un arxiu</string>
    <string name="patch_file_msg">Selecciona una imatge crua (*.img) o un ODIN tarfile (*.tar)</string>
    <string name="reboot_delay_toast">Reinici en 5 segons…</string>
    <string name="flash_screen_title">Instal·lació</string>

    <!--Superuser-->
    <string name="su_request_title">Petició de superusuari</string>
    <string name="touch_filtered_warning">Com que una aplicació està ofuscant la petició de superusuari, Magisk no pot verificar la seva resposta</string>
    <string name="deny">Denegar</string>
    <string name="prompt">Preguntar</string>
    <string name="grant">Permetre</string>
    <string name="su_warning">Permet accés total al seu dispositiu.\nDenegui si no n\'està segur!</string>
    <string name="forever">Sempre</string>
    <string name="once">Un cop </string>
    <string name="tenmin">10 mins</string>
    <string name="twentymin">20 mins</string>
    <string name="thirtymin">30 mins</string>
    <string name="sixtymin">60 mins</string>
    <string name="su_allow_toast">Permesos els drets de superusuari de %1$s</string>
    <string name="su_deny_toast">Denegats els drets de superusuari de %1$s</string>
    <string name="su_snack_grant">Drets de superusuari de %1$s permesos</string>
    <string name="su_snack_deny">Drets de superusuari de %1$s denegats</string>
    <string name="su_snack_notif_on">Notificacions de %1$s habilitades</string>
    <string name="su_snack_notif_off">Notificacions de %1$s deshabilitades</string>
    <string name="su_snack_log_on">Registres de %1$s habilitats</string>
    <string name="su_snack_log_off">Registres de %1$s deshabilitats</string>
    <string name="su_revoke_title">Revocar?</string>
    <string name="su_revoke_msg">Confirmi per revocar drets de %1$s</string>
    <string name="toast">Avís</string>
    <string name="none">Cap</string>

    <string name="superuser_toggle_notification">Notificacions</string>
    <string name="superuser_toggle_revoke">Revocar</string>
    <string name="superuser_policy_none">Cap aplicació ha demanat permisos de superusuari.</string>

    <!--Logs-->
    <string name="log_data_none">No hi ha cap registre. Provi d\'utilitzar aplicacions que requereixen permisos de superusuari.</string>
    <string name="log_data_magisk_none">Els registres de Magisk estan buits. Això és estrany.</string>
    <string name="menuSaveLog">Desar registre</string>
    <string name="menuClearLog">Netejar registre ara</string>
    <string name="logs_cleared">Registre netejat correctament.</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">UID de l\'objectiu: %1$d</string>

    <!--SafetyNet-->

    <!-- MagiskHide -->
    <string name="show_system_app">Mostra aplicacions del sistema</string>
    <string name="show_os_app">Mostra aplicacions del SO</string>
    <string name="hide_filter_hint">Filtra per nom</string>
    <string name="hide_search">Cerca</string>

    <!--Module-->
    <string name="no_info_provided">(No hi ha informació)</string>
    <string name="reboot_userspace">Reinici suau</string>
    <string name="reboot_recovery">Reiniciar en Mode Recuperació</string>
    <string name="reboot_bootloader">Reiniciar en Mode Bootloader</string>
    <string name="reboot_download">Reiniciar en Mode Download</string>
    <string name="reboot_edl">Reiniciar a EDL</string>
    <string name="module_version_author">%1$s per %2$s</string>
    <string name="module_state_remove">Eliminar</string>
    <string name="module_state_restore">Recuperar</string>
    <string name="module_action_install_external">Instal·lar des de l\'emmagatzematge</string>
    <string name="update_available">Actualització Disponible</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Mode del tema</string>
    <string name="settings_dark_mode_message">Seleccioni el mode que més s\'adeqüi al seu estil!</string>
    <string name="settings_dark_mode_light">Sempre clar</string>
    <string name="settings_dark_mode_system">Seguir al sistema</string>
    <string name="settings_dark_mode_dark">Sempre fosc</string>
    <string name="settings_download_path_title">Directori de baixades</string>
    <string name="settings_download_path_message">Els arxius es desaran a %1$s</string>
    <string name="settings_hide_app_title">Amagar Magisk Manager</string>
    <string name="settings_hide_app_summary">Torna a empaquetar Magisk Manager amb un nom de paquet a l\'atzar</string>
    <string name="settings_restore_app_title">Restaurar Magisk Manager</string>
    <string name="settings_restore_app_summary">Restaura Magisk Manager amb el nom de paquet original</string>
    <string name="language">Idioma</string>
    <string name="system_default">(Idioma del sistema)</string>
    <string name="settings_check_update_title">Comprovar Actualitzacions</string>
    <string name="settings_check_update_summary">Comprovar periòdicament en segon pla si existeixen actualitzacions</string>
    <string name="settings_update_channel_title">Canal d\'Actualitzacions</string>
    <string name="settings_update_stable">Estable</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Canal personalitzat</string>
    <string name="settings_update_custom_msg">Inserta un URL personalitzada</string>
    <string name="settings_hosts_title">Systemless Hosts</string>
    <string name="settings_hosts_summary">Suport per aplicacions tipus Adblock fora de la partició del sistema</string>
    <string name="settings_hosts_toast">Agregat el mòdul Systemless Hosts</string>
    <string name="settings_app_name_hint">Nou nom</string>
    <string name="settings_app_name_helper">Es refarà l\'aplicació amb aquest nom</string>
    <string name="settings_app_name_error">Format invàlid</string>
    <string name="settings_su_app_adb">Aplicacions i ADB</string>
    <string name="settings_su_app">Només aplicacions</string>
    <string name="settings_su_adb">Només ADB</string>
    <string name="settings_su_disable">Deshabilitat</string>
    <string name="settings_su_request_10">10 segons</string>
    <string name="settings_su_request_15">15 segons</string>
    <string name="settings_su_request_20">20 segons</string>
    <string name="settings_su_request_30">30 segons</string>
    <string name="settings_su_request_45">45 segons</string>
    <string name="settings_su_request_60">60 segons</string>
    <string name="superuser_access">Accés de superusuari</string>
    <string name="auto_response">Resposta automàtica</string>
    <string name="request_timeout">Temps de petició</string>
    <string name="superuser_notification">Notificació de superusuari</string>
    <string name="settings_su_reauth_title">Demanar després d\'una actualització</string>
    <string name="settings_su_reauth_summary">Demanar permisos de superusuari novament si una aplicació és actualitzada o reinstal·lada</string>
    <string name="settings_su_tapjack_title">Activa la protecció contra \'TapJacking\'</string>
    <string name="settings_su_tapjack_summary">El diàleg per donar permisos de superusuari no respondrà mentre estigui ofuscat per alguna altra finestra o superposició</string>
    <string name="settings_customization">Personalització</string>
    <string name="setting_add_shortcut_summary">Afegeix una bonica drecera a la pantalla d\'inici en cas que el nom i la icona siguin difícils de reconèixer després d\'amagar l\'aplicació.</string>
    <string name="settings_doh_title">DNS sobre HTTPS</string>
    <string name="settings_doh_description">Solució per enverinament de DNS en algunes nacions</string>

    <string name="multiuser_mode">Mode Multiusuari</string>
    <string name="settings_owner_only">Només Administrador del Dispositiu</string>
    <string name="settings_owner_manage">Administrador del Dispositiu</string>
    <string name="settings_user_independent">Usuari Independent</string>
    <string name="owner_only_summary">Només l\'administrador té accés d\'arrel</string>
    <string name="owner_manage_summary">Només l\'administrador pot supervisar l\'accés d\'arrel i rebre sol·licituds d\'altres usuaris</string>
    <string name="user_independent_summary">Tots els usuaris tenen separades les seves pròpies regles d\'arrel</string>

    <string name="mount_namespace_mode">Muntar Namespace </string>
    <string name="settings_ns_global">Namespace Global</string>
    <string name="settings_ns_requester">Heretar Namespace</string>
    <string name="settings_ns_isolate">Aïllar Namespace</string>
    <string name="global_summary">Totes les sessions d\'arrel utilitzen el suport Namespace Global</string>
    <string name="requester_summary">Les sessions d\'arrel heretaran les peticions Namespace</string>
    <string name="isolate_summary">Totes les sessions d\'arrel tindran la seva pròpia Namespace</string>

    <!--Notifications-->
    <string name="update_channel">Actualització de Magisk</string>
    <string name="progress_channel">Notificacions de progrés</string>
    <string name="download_complete">Baixada completada</string>
    <string name="download_file_error">Error en baixar l\'arxiu</string>
    <string name="magisk_update_title">Actualització de Magisk disponible!</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Sí</string>
    <string name="no">No</string>
    <string name="repo_install_title">Instal·lar %1$s %2$s(%3$d)</string>
    <string name="download">Baixar</string>
    <string name="reboot">Reiniciar</string>
    <string name="release_notes">Notes de llançament</string>
    <string name="flashing">Arranjament…</string>
    <string name="done">Fet!</string>
    <string name="failure">Fallit</string>
    <string name="hide_app_title">Amagant Magisk Manager…</string>
    <string name="open_link_failed_toast">No s\'ha trobat una aplicació per obrir l\'enllaç</string>
    <string name="complete_uninstall">Desinstal·lació completa</string>
    <string name="restore_img">Restaura imatges</string>
    <string name="restore_img_msg">Restaurant…</string>
    <string name="restore_done">Restauració feta!</string>
    <string name="restore_fail">La còpia de seguretat de Estock no existeix!</string>
    <string name="setup_fail">Instal·lació fallida</string>
    <string name="env_fix_title">Es requereix instal·lació addicional</string>
    <string name="env_fix_msg">El teu dispositiu necessita instal·lació addicional per Magisk per funcionar correctament. Es baixarà el ZIP d\'instal·lació de Magisk, vol procedir a la instal·lació ara?</string>
    <string name="setup_msg">S\'està executant la configuració de l\'entorn…</string>
    <string name="unsupport_magisk_title">Versió de Magisk incompatible</string>
    <string name="unsupport_magisk_msg">Aquesta versió de Magisk Manager no suporta versions de Magisk més petites que la %1$s.\n\nL\'aplicació es comportarà com si Magisk no estigués instal·lat, si us plau actualitzi Magisk com més aviat millor.</string>
    <string name="external_rw_permission_denied">Ha de donar permís d\'emmagatzematge per activar aquesta funcionalitat</string>
    <string name="add_shortcut_title">Afegeix una drecera a la pantalla d\'inici</string>
    <string name="add_shortcut_msg">Després d\'amagar Magisk Manager, el seu nom i icona poden ser difícils de reconèixer. Vols afegir una bonica drecera a la teva pantalla d\'inici?</string>
    <string name="app_not_found">No s\'ha trobat una aplicació per emprar aquesta acció</string>

</resources>

```

`app/core/src/main/res/values-cs/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Moduly</string>
    <string name="superuser">SuperUser</string>
    <string name="logs">Protokol</string>
    <string name="settings">Nastavení</string>
    <string name="install">Instalovat</string>
    <string name="section_home">Domů</string>
    <string name="section_theme">Témata</string>
    <string name="denylist">DenyList</string>

    <!--Home-->
    <string name="no_connection">Žádné připojení</string>
    <string name="app_changelog">Seznam změn</string>
    <string name="loading">Načítání…</string>
    <string name="update">Aktualizovat</string>
    <string name="not_available">N/A</string>
    <string name="hide">Skrýt</string>
    <string name="home_package">Balíček</string>
    <string name="home_app_title">Aplikace</string>

    <string name="home_notice_content">Stahujte Magisk POUZE z oficiální stránky GitHub. Soubory z neznámých zdrojů mohou být škodlivé!</string>
    <string name="home_support_title">Podpořte nás</string>
    <string name="home_follow_title">Sledujte nás</string>
    <string name="home_item_source">Zdroj</string>
    <string name="home_support_content">Magisk je a vždy bude svobodný s otevřeným kódem. Můžete nám však zaslat malý dar jako poděkování.</string>
    <string name="home_installed_version">Nainstalováno</string>
    <string name="home_latest_version">Poslední</string>
    <string name="invalid_update_channel">Neplatný kanál aktualizace</string>
    <string name="uninstall_magisk_title">Odinstalovat Magisk</string>
    <string name="uninstall_magisk_msg">Všechny moduly budou zakázány/odstraněny!\nROOT bude odstraněn!\nPokud jsou data dešifrována, můžou být zašifrována!</string>

    <!--Install-->
    <string name="keep_force_encryption">Ponechat Force Encryption</string>
    <string name="keep_dm_verity">Ponechat AVB 2.0/DM-Verity</string>
    <string name="recovery_mode">Režim Recovery</string>
    <string name="install_options_title">Možnosti</string>
    <string name="install_method_title">Způsob</string>
    <string name="install_next">Další</string>
    <string name="install_start">Spustit</string>
    <string name="manager_download_install">Stiskněte pro stažení a instalaci</string>
    <string name="direct_install">Přímá instalace (doporučeno)</string>
    <string name="install_inactive_slot">Instalace do druhého slotu (po OTA)</string>
    <string name="install_inactive_slot_msg">Vaše zařízení bude po restartu VYNUCENĚ spuštěno do aktuálního neaktivního slotu!\nTuto možnost použijte pouze po dokončení OTA.\nChcete pokračovat?</string>
    <string name="setup_title">Další nastavení</string>
    <string name="select_patch_file">Vybrat a opravit soubor</string>
    <string name="patch_file_msg">Vyberte soubor RAW (*.img) nebo soubor TAR pro ODIN (*.tar)</string>
    <string name="reboot_delay_toast">Restartování za 5 sekund…</string>
    <string name="flash_screen_title">Instalace</string>

    <!--Superuser-->
    <string name="su_request_title">Požadavek SuperUser</string>
    <string name="touch_filtered_warning">Magisk nemůže ověřit Vaši odpověď, protože aplikace zavírá požadavek SuperUser</string>
    <string name="deny">Zakázat</string>
    <string name="prompt">Zeptat se</string>
    <string name="grant">Povolit</string>
    <string name="su_warning">Povolí plný přístup k Vašemu zařízení.\nZakažte, pokud si nejste jisti!</string>
    <string name="forever">Trvale</string>
    <string name="once">Jednou</string>
    <string name="tenmin">10 minut</string>
    <string name="twentymin">20 minut</string>
    <string name="thirtymin">30 minut</string>
    <string name="sixtymin">60 minut</string>
    <string name="su_allow_toast">Pro %1$s bylo oprávnění SuperUser povoleno</string>
    <string name="su_deny_toast">Pro %1$s bylo oprávnění SuperUser zakázáno</string>
    <string name="su_snack_grant">SuperUser oprávnění pro %1$s je povoleno</string>
    <string name="su_snack_deny">SuperUser oprávnění pro %1$s je zakázáno</string>
    <string name="su_snack_notif_on">Oznámení pro %1$s jsou povolena</string>
    <string name="su_snack_notif_off">Oznámení pro %1$s jsou zakázána</string>
    <string name="su_snack_log_on">Protokolování %1$s je povoleno</string>
    <string name="su_snack_log_off">Protokolování %1$s je zakázáno</string>
    <string name="su_revoke_title">Smazat?</string>
    <string name="su_revoke_msg">Potvrzením odeberete %1$s oprávnění SuperUser</string>
    <string name="toast">Text</string>
    <string name="none">Žádné</string>

    <string name="superuser_toggle_notification">Oznámení</string>
    <string name="superuser_toggle_revoke">Smazat</string>
    <string name="superuser_policy_none">Žádná aplikace nepožádala o oprávnění SuperUser.</string>

    <!--Logs-->
    <string name="log_data_none">Nemáte žádné protokoly. Vyzkoušejte nějakou aplikaci vyžadující oprávnění SuperUser</string>
    <string name="log_data_magisk_none">Protokoly Magisk jsou prázdné. To je zvláštní</string>
    <string name="menuSaveLog">Uložit protokol</string>
    <string name="menuClearLog">Smazat protokol</string>
    <string name="logs_cleared">Protokol byl smazán</string>
    <string name="pid">PID:%1$d</string>
    <string name="target_uid">Cílové UID: %1$d</string>
    <string name="target_pid">Připojit PID cílového ns: %s</string>
    <string name="selinux_context">SELinux kontext: %s</string>
    <string name="supp_group">Sekundární skupina: %s</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Zobrazit systémové aplikace</string>
    <string name="show_os_app">Zobrazit OS aplikace</string>
    <string name="hide_filter_hint">Filtrovat podle názvu</string>
    <string name="hide_search">Vyhledávání</string>

    <!--Module-->
    <string name="no_info_provided">(žádné informace)</string>
    <string name="reboot_userspace">Restartovat do UserSpace</string>
    <string name="reboot_recovery">Restartovat do Recovery</string>
    <string name="reboot_bootloader">Restartovat do Bootloader</string>
    <string name="reboot_download">Restartovat do Download</string>
    <string name="reboot_edl">Restartovat do EDL</string>
    <string name="module_version_author">%1$s od %2$s</string>
    <string name="module_state_remove">Odstranit</string>
    <string name="module_state_restore">Obnovit</string>
    <string name="module_action_install_external">Instalace z úložiště</string>
    <string name="update_available">Dostupná aktualizace</string>
    <string name="suspend_text_riru">Modul byl pozastaven, protože je povolen %1$s</string>
    <string name="suspend_text_zygisk">Modul byl pozastaven, protože %1$s není povoleno</string>
    <string name="zygisk_module_unloaded">Modul Zygisk nebyl načten z důvodu nekompatibility</string>
    <string name="module_empty">Není nainstalován žádný modul</string>
    <string name="confirm_install">Instalovat modul %1$s?</string>
    <string name="confirm_install_title">Potvrzení instalace</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Režim motivu</string>
    <string name="settings_dark_mode_message">Vyberte režim, který nejlépe vyhovuje Vašemu stylu!</string>
    <string name="settings_dark_mode_light">Světlý</string>
    <string name="settings_dark_mode_system">Podle systému</string>
    <string name="settings_dark_mode_dark">Tmavý</string>
    <string name="settings_download_path_title">Složka pro stahování</string>
    <string name="settings_download_path_message">Soubory budou uloženy do %1$s.</string>
    <string name="settings_hide_app_title">Skrýt aplikaci Magisk</string>
    <string name="settings_hide_app_summary">Skryje aplikaci náhodným ID balíčku a vlastním názvem aplikace</string>
    <string name="settings_restore_app_title">Obnovit aplikaci Magisk</string>
    <string name="settings_restore_app_summary">Obnoví aplikaci zpět do původního APK</string>
    <string name="language">Jazyk</string>
    <string name="system_default">(výchozí podle systému)</string>
    <string name="settings_check_update_title">Zkontrolovat aktualizace</string>
    <string name="settings_check_update_summary">Povolí pravidelnou kontrolu aktualizace na pozadí</string>
    <string name="settings_update_channel_title">Kanál aktualizace</string>
    <string name="settings_update_stable">Stabilní</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Vlastní</string>
    <string name="settings_update_custom_msg">Vložte vlastní URL</string>
    <string name="settings_zygisk_summary">Spustí části Magisku v démonu Zygote</string>
    <string name="settings_denylist_title">Vynutit DenyList</string>
    <string name="settings_denylist_summary">Na procesy v Denylistu nebudou aplikovány žádné změny, nebo modifikace způsobené Magiskem</string>
    <string name="settings_denylist_config_title">Nastavit DenyList</string>
    <string name="settings_denylist_config_summary">Vyberte procesy, které mají být zahrnuty v DenyListu</string>
    <string name="settings_hosts_title">Nesystémoví hostitelé</string>
    <string name="settings_hosts_summary">Přidá modul pro podporu nesystémových hostitelů v aplikaci AdBlock</string>
    <string name="settings_hosts_toast">Modul nesystémových hostitelů přidán</string>
    <string name="settings_app_name_hint">Nový název</string>
    <string name="settings_app_name_helper">Název aplikace bude nahrazen tímto názvem</string>
    <string name="settings_app_name_error">Neplatný formát</string>
    <string name="settings_su_app_adb">Aplikace a ADB</string>
    <string name="settings_su_app">Pouze aplikace</string>
    <string name="settings_su_adb">Pouze ADB</string>
    <string name="settings_su_disable">Zakázat</string>
    <string name="settings_su_request_10">10 sekund</string>
    <string name="settings_su_request_15">15 sekund</string>
    <string name="settings_su_request_20">20 sekund</string>
    <string name="settings_su_request_30">30 sekund</string>
    <string name="settings_su_request_45">45 sekund</string>
    <string name="settings_su_request_60">60 sekund</string>
    <string name="superuser_access">Přístup SuperUser</string>
    <string name="auto_response">Automatická odezva</string>
    <string name="request_timeout">Časový limit požadavku</string>
    <string name="superuser_notification">Oznámení SuperUser</string>
    <string name="settings_su_reauth_title">Opětovné ověření po aktualizaci</string>
    <string name="settings_su_reauth_summary">Opětovné ověření oprávnění SuperUser po aktualizaci aplikace.</string>
    <string name="settings_su_tapjack_title">Povolit ochranu před TapJack</string>
    <string name="settings_su_tapjack_summary">Okno dialogu SuperUser nebude reagovat na kliknutí v případě, že je zavřené nebo překryté jiným oknem</string>
    <string name="settings_customization">Přizpůsobit</string>
    <string name="setting_add_shortcut_summary">Přidá odkaz na domovskou obrazovku v případě, že se po skrytí aplikace její název a ikona těžko rozpoznávají.</string>
    <string name="settings_doh_title">DNS přes HTTPS</string>
    <string name="settings_doh_description">Obejde DNS v některých zemích</string>

    <string name="multiuser_mode">Režim více uživatelů</string>
    <string name="settings_owner_only">Vlastník zařízení</string>
    <string name="settings_owner_manage">Správce zařízení</string>
    <string name="settings_user_independent">Všichni uživatelé</string>
    <string name="owner_only_summary">Pouze vlastník má přístup ROOT</string>
    <string name="owner_manage_summary">Přístup ROOT má správce zařízení, který přijímá požadavky k přístupu</string>
    <string name="user_independent_summary">Každý uživatel má svá vlastní pravidla přístupu ROOT</string>

    <string name="mount_namespace_mode">Režim připojení jmenného prostoru</string>
    <string name="settings_ns_global">Globální jmenný prostor</string>
    <string name="settings_ns_requester">Odvozený jmenný prostor</string>
    <string name="settings_ns_isolate">Izolovaný jmenný prostor</string>
    <string name="global_summary">Všechny relace ROOT používají globální jmenný prostor.</string>
    <string name="requester_summary">Relace ROOT je odvozena od jmenného prostoru žadatele.</string>
    <string name="isolate_summary">Každá relace ROOT má svůj vlastní izolovaný jmenný prostor.</string>

    <!--Notifications-->
    <string name="update_channel">Aktualizace Magisk</string>
    <string name="progress_channel">Oznámení o průběhu</string>
    <string name="updated_channel">Aktualizace dokončena</string>
    <string name="download_complete">Stahování dokončeno</string>
    <string name="download_file_error">Chyba při stahování souboru</string>
    <string name="magisk_update_title">Aktualizace Magisk je dostupná!</string>
    <string name="updated_title">Magisk aktualizován</string>
    <string name="updated_text">Klepnutím otevřete aplikaci</string>

<!--Toasts, Dialogs-->
    <string name="yes">Ano</string>
    <string name="no">Ne</string>
    <string name="repo_install_title">Instalovat %1$s %2$s(%3$d)</string>
    <string name="download">Stáhnout</string>
    <string name="reboot">Restartovat</string>
    <string name="release_notes">Seznam změn</string>
    <string name="flashing">Flashuji…</string>
    <string name="done">Hotovo!</string>
    <string name="failure">Nepodařilo se!</string>
    <string name="hide_app_title">Skrývám aplikaci Magisk…</string>
    <string name="open_link_failed_toast">Nebyla nalezena žádná aplikace pro otevření odkazu</string>
    <string name="complete_uninstall">Kompletní odinstalace</string>
    <string name="restore_img">Obnovit obrazy</string>
    <string name="restore_img_msg">Obnovování…</string>
    <string name="restore_done">Proces obnovování dokončen!</string>
    <string name="restore_fail">Původní záloha neexistuje!</string>
    <string name="setup_fail">Nastavení selhalo</string>
    <string name="env_fix_title">Vyžadováno dodatečné nastavení</string>
    <string name="env_fix_msg">Aby mohl Magisk správně fungovat, je třeba zařízení dodatečně nastavit. Chcete pokračovat a restartovat zařízení?</string>
    <string name="env_full_fix_msg">Aby vaše zařízení správně fungovalo, potřebuje se Magisk znovu flashnout. Nainstalujte znovu Magisk v aplikaci, režim Recovery nemůže získat správné informace o zařízení.</string>
    <string name="setup_msg">Probíhá nastavení prostředí…</string>
    <string name="unsupport_magisk_title">Nepodporovaná verze Magisk</string>
    <string name="unsupport_magisk_msg">Tato verze aplikace nepodporuje Magisk ve verzi nižší než %1$s.\n\nAplikace se bude chovat, jako by žádný Magisk nebyl nainstalován. Aktualizujte prosím Magisk co nejdříve.</string>
    <string name="unsupport_general_title">Abnormální stav</string>
    <string name="unsupport_system_app_msg">Spuštění této aplikace jako systémové, není podporováno. Změňte prosím aplikaci zpět na uživatelskou.</string>
    <string name="unsupport_other_su_msg">Byl detekován binární soubor \"su\", který nepochází z Magisk. Odeberte jakékoli konkurenční ROOT řešení a/nebo přeinstalujte Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk je nainstalován na externím úložišti. Přesuňte prosím aplikaci do interního úložiště.</string>
    <string name="unsupport_nonroot_stub_msg">Skrytá aplikace Magisk nemůže dále fungovat, protože byl ztracen ROOT. Obnovte prosím původní soubor APK.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Pro povolení této funkce, povolte oprávnění pro přístup k úložišti</string>
    <string name="post_notifications_denied">Pro povolení této funkce, povolte oznámení</string>
    <string name="install_unknown_denied">Pro povolení této funkce, povolte "instalovat aplikace z neznámých zdrojů"</string>
    <string name="add_shortcut_title">Přidat zástupce na domovskou obrazovku</string>
    <string name="add_shortcut_msg">Po skrytí této aplikace může být obtížné rozpoznat její název a ikonu. Chcete přidat na domovskou obrazovku hezkého zástupce?</string>
    <string name="app_not_found">Nebyla nalezena žádná aplikace, která by tuto akci provedla</string>
    <string name="reboot_apply_change">Pro použití změn restartujte zařízení</string>
    <string name="restore_app_confirmation">Tímto skrytou aplikaci obnovíte zpět na původní aplikaci. Opravdu to chcete udělat?</string>

</resources>

```

`app/core/src/main/res/values-de/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Module</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Protokolle</string>
    <string name="settings">Einstellungen</string>
    <string name="install">Installieren</string>
    <string name="section_home">Startseite</string>
    <string name="section_theme">Themen</string>
    <string name="denylist">Ausnahmeliste</string>

    <!--Home-->
    <string name="no_connection">Keine Verbindung verfügbar</string>
    <string name="app_changelog">Änderungen</string>
    <string name="loading">Laden …</string>
    <string name="update">Aktualisieren</string>
    <string name="not_available">Nicht verfügbar</string>
    <string name="hide">Verstecken</string>
    <string name="home_package">Paket</string>
    <string name="home_app_title">App</string>

    <string name="home_notice_content">Laden Sie Magisk NUR von der offiziellen Github Seite herunter. Dateien aus unbekannten Quellen können bösartig sein!</string>
    <string name="home_support_title">Unterstütze uns</string>
    <string name="home_follow_title">Folge uns</string>
    <string name="home_item_source">Quelle</string>
    <string name="home_support_content">Magisk ist und wird immer frei und quelloffen sein. Du kannst uns jedoch jederzeit mit einer kleinen Spende unterstützen.</string>
    <string name="home_installed_version">Installiert</string>
    <string name="home_latest_version">Neueste</string>
    <string name="invalid_update_channel">Ungültiger Update-Kanal</string>
    <string name="uninstall_magisk_title">Magisk deinstallieren</string>
    <string name="uninstall_magisk_msg">Alle Module werden deaktiviert/entfernt!\nRoot wird entfernt!\nDeine Daten werden potentiell verschlüsselt, wenn sie nicht bereits verschlüsselt sind!</string>

    <!--Install-->
    <string name="keep_force_encryption">Erzwungene Verschlüsselung beibehalten</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity beibehalten</string>
    <string name="recovery_mode">Recovery Modus</string>
    <string name="install_options_title">Optionen</string>
    <string name="install_method_title">Methode</string>
    <string name="install_next">Nächster Schritt</string>
    <string name="install_start">Los geht\'s</string>
    <string name="manager_download_install">Tippen zum Herunterladen und Installieren</string>
    <string name="direct_install">Direkte Installation (empfohlen)</string>
    <string name="install_inactive_slot">In inaktiven Slot installieren (nach OTA)</string>
    <string name="install_inactive_slot_msg">Dein Gerät wird gezwungen, nach einem Neustart in den inaktiven Slot zu booten! Diese Option nur verwenden, wenn OTA abgeschlossen ist.\nWeiter?</string>
    <string name="setup_title">Zusätzliche Einstellungen</string>
    <string name="select_patch_file">Eine Datei auswählen und patchen</string>
    <string name="patch_file_msg">Ein Raw Image (*.img), eine ODIN Tar-Datei (*.tar) oder eine Payload.bin (*.bin) auswählen</string>
    <string name="reboot_delay_toast">Neustart in 5 Sekunden …</string>
    <string name="flash_screen_title">Installieren</string>

    <!--Superuser-->
    <string name="su_request_title">Superuser-Anfrage</string>
    <string name="touch_filtered_warning">Weil eine App eine Superuser-Anfrage verdeckt, kann Magisk deine Antwort nicht verifizieren</string>
    <string name="deny">Verweigern</string>
    <string name="prompt">Fragen</string>
    <string name="grant">Gewähren</string>
    <string name="su_warning">Zugriff auf dein Gerät gewähren. Verweigere den Zugriff, wenn du nicht sicher bist!</string>
    <string name="forever">Für immer</string>
    <string name="once">Einmalig</string>
    <string name="tenmin">10 Minuten</string>
    <string name="twentymin">20 Minuten</string>
    <string name="thirtymin">30 Minuten</string>
    <string name="sixtymin">60 Minuten</string>
    <string name="su_allow_toast">%1$s wurden Superuser-Rechte gewährt</string>
    <string name="su_deny_toast">%1$s wurden Superuser-Rechte verweigert</string>
    <string name="su_snack_grant">Superuser-Rechte für %1$s gewährt</string>
    <string name="su_snack_deny">Superuser-Rechte für %1$s verweigert</string>
    <string name="su_snack_notif_on">Benachrichtigungen für %1$s sind an</string>
    <string name="su_snack_notif_off">Benachrichtigungen für %1$s sind aus</string>
    <string name="su_snack_log_on">Protokollierung für %1$s ist an</string>
    <string name="su_snack_log_off">Protokollierung für %1$s ist aus</string>
    <string name="su_revoke_title">Widerrufen?</string>
    <string name="su_revoke_msg">Bestätigen, dass %1$s-Rechte widerufen werden?</string>
    <string name="toast">Toast</string>
    <string name="none">Keine</string>

    <string name="superuser_toggle_notification">Benachrichtigungen</string>
    <string name="superuser_toggle_revoke">Widerruf</string>
    <string name="superuser_policy_none">Bisher hat noch keine App um die Erlaubnis des Superusers gebeten.</string>

    <!--Logs-->
    <string name="log_data_none">Du bist protokollfrei, versuche deine SU-fähigen Apps mehr zu nutzen.</string>
    <string name="log_data_magisk_none">Magisk-Protokolle sind leer, das ist seltsam.</string>
    <string name="menuSaveLog">Protokoll speichern</string>
    <string name="menuClearLog">Protokoll jetzt löschen</string>
    <string name="logs_cleared">Protokoll erfolgreich gelöscht.</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Ziel-UID: %1$d</string>
    <string name="target_pid">NS Target PID einbinden: %s</string>
    <string name="selinux_context">SELinux Kontext: %s</string>
    <string name="supp_group">Ergänzende Gruppe: %s</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">System-Apps anzeigen</string>
    <string name="show_os_app">OS-Apps anzeigen</string>
    <string name="hide_filter_hint">Nach Namen filtern</string>
    <string name="hide_search">Suche</string>

    <!--Module-->
    <string name="no_info_provided">(Keine Informationen verfügbar)</string>
    <string name="reboot_userspace">Sanfter Neustart</string>
    <string name="reboot_recovery">Neustart zum Recovery</string>
    <string name="reboot_bootloader">Neustart zum Bootloader</string>
    <string name="reboot_download">Neustart zum Download</string>
    <string name="reboot_edl">Neustart zum EDL</string>
    <string name="module_version_author">%1$s von %2$s</string>
    <string name="module_state_remove">Entfernen</string>
    <string name="module_state_restore">Wiederherstellen</string>
    <string name="module_action_install_external">Aus dem Speicher installieren</string>
    <string name="update_available">Update verfügbar</string>
    <string name="suspend_text_riru">Modul ausgesetzt, weil %1$s aktiviert ist</string>
    <string name="suspend_text_zygisk">Modul ausgesetzt, weil %1$s nicht aktiviert ist</string>
    <string name="zygisk_module_unloaded">Zygisk-Modul aufgrund von Inkompatibilität nicht geladen</string>
    <string name="module_empty">Kein Modul installiert</string>
    <string name="confirm_install">Modul %1$s installieren?</string>
    <string name="confirm_install_title">Installation bestätigen</string>
 
    <!--Settings-->
    <string name="settings_dark_mode_title">Themen-Modus</string>
    <string name="settings_dark_mode_message">Modus auswählen, der am besten zu deinem Stil passt!</string>
    <string name="settings_dark_mode_light">Immer hell</string>
    <string name="settings_dark_mode_system">System folgen</string>
    <string name="settings_dark_mode_dark">Immer dunkel</string>
    <string name="settings_download_path_title">Download-Verzeichnis</string>
    <string name="settings_download_path_message">Dateien werden in %1$s gespeichert</string>
    <string name="settings_hide_app_title">Magisk-App verstecken</string>
    <string name="settings_hide_app_summary">Proxy-App mit zufälliger Paket-ID und benutzerdefiniertem App-Label installieren</string>
    <string name="settings_restore_app_title">Magisk-App wiederherstellen</string>
    <string name="settings_restore_app_summary">App wieder einblenden und original APK wiederherstellen</string>
    <string name="language">Sprache</string>
    <string name="system_default">Systemstandard</string>
    <string name="settings_check_update_title">Auf Updates prüfen</string>
    <string name="settings_check_update_summary">Regelmäßig im Hintergrund auf Aktualisierungen prüfen</string>
    <string name="settings_update_channel_title">Aktualisierungs-Kanal</string>
    <string name="settings_update_stable">Stabil</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Benutzerdefiniert</string>
    <string name="settings_update_custom_msg">Benutzerdefinierte URL einfügen</string>
    <string name="settings_zygisk_summary">Teile von Magisk im Zygoten-Daemon ausführen</string>
    <string name="settings_denylist_title">Ausnahmeliste erzwingen</string>
    <string name="settings_denylist_summary">Bei Prozessen, die auf der Ausnahmeliste stehen, werden alle Magisk-Änderungen rückgängig gemacht.</string>
    <string name="settings_denylist_config_title">Ausnahmeliste konfigurieren</string>
    <string name="settings_denylist_config_summary">Auswahl der Prozesse, die in die Ausnahmeliste aufgenommen werden sollen</string>
    <string name="settings_hosts_title">Systemlose Hosts-Datei</string>
    <string name="settings_hosts_summary">Systemlose Unterstützung für Werbeblocker</string>
    <string name="settings_hosts_toast">Systemloses Hosts-Modul hinzugefügt</string>
    <string name="settings_app_name_hint">Neuer Name</string>
    <string name="settings_app_name_helper">App wird unter diesem Namen neu gepackt</string>
    <string name="settings_app_name_error">Ungültiges Format</string>
    <string name="settings_su_app_adb">Apps und ADB</string>
    <string name="settings_su_app">Nur Apps</string>
    <string name="settings_su_adb">Nur ADB</string>
    <string name="settings_su_disable">Deaktiviert</string>
    <string name="settings_su_request_10">10 Sekunden</string>
    <string name="settings_su_request_15">15 Sekunden</string>
    <string name="settings_su_request_20">20 Sekunden</string>
    <string name="settings_su_request_30">30 Sekunden</string>
    <string name="settings_su_request_45">45 Sekunden</string>
    <string name="settings_su_request_60">60 Sekunden</string>
    <string name="superuser_access">Superuser-Zugriff</string>
    <string name="auto_response">Automatisch beantworten</string>
    <string name="request_timeout">Zeitlimit für Anfrage</string>
    <string name="superuser_notification">Superuser-Benachrichtigung</string>
    <string name="settings_su_reauth_title">Nach Aktualisierung erneut zertifizieren</string>
    <string name="settings_su_reauth_summary">Superuser-Berechtigungen nach App-Aktualisierung erneut authentifizieren</string>
    <string name="settings_su_tapjack_title">Tapjacking-Schutz aktivieren</string>
    <string name="settings_su_tapjack_summary">Das Dialogfeld der Superuser-Eingabeaufforderung reagiert nicht auf Eingaben, wenn es durch ein anderes Fenster oder Überlagerung verdeckt wird</string>
    <string name="settings_su_auth_title">Benutzerauthentifizierung</string>
    <string name="settings_su_auth_summary">Nachfrage nach Benutzerauthentifizierung bei Superuser-Anfragen</string>
    <string name="settings_su_auth_insecure">Auf dem Gerät ist keine Authentifizierungsmethode konfiguriert</string>>
    <string name="settings_customization">Personalisierung</string>
    <string name="setting_add_shortcut_summary">Hinzufügen einer hübschen Startbildschirm-Verknüpfung, falls der Name und das Symbol nach dem Ausblenden der App schwer zu erkennen sind</string>
    <string name="settings_doh_title">DNS über HTTPS</string>
    <string name="settings_doh_description">Umgehung des DNS-Poisoning in einigen Ländern</string>

    <string name="multiuser_mode">Mehrbenutzermodus</string>
    <string name="settings_owner_only">Nur der Gerätebesitzer</string>
    <string name="settings_owner_manage">Durch Gerätebesitzer verwaltet</string>
    <string name="settings_user_independent">Benutzerunabhängig</string>
    <string name="owner_only_summary">Nur der Besitzer hat Root-Zugriff</string>
    <string name="owner_manage_summary">Nur der Besitzer verwaltet den Root-Zugriff und erhält Zugriffsanfragen</string>
    <string name="user_independent_summary">Jeder Nutzer hat seine eigenen Root-Regeln</string>

    <string name="mount_namespace_mode">Mount Namespace Modus</string>
    <string name="settings_ns_global">Globaler Namespace</string>
    <string name="settings_ns_requester">Geerbter Namespace</string>
    <string name="settings_ns_isolate">Isolierter Namespace</string>
    <string name="global_summary">Alle Root-Sitzungen benutzen den global angelegten Namespace</string>
    <string name="requester_summary">Root-Sitzungen erben den Namespace des Abfragenden</string>
    <string name="isolate_summary">Jede Root-Sitzung hat ihren isolierten Namespace</string>

    <!--Notifications-->
    <string name="update_channel">Magisk Updates</string>
    <string name="progress_channel">Fortschrittsmitteilungen</string>
    <string name="updated_channel">Update abgeschlossen</string>
    <string name="download_complete">Download abgeschlossen</string>
    <string name="download_file_error">Fehler beim Herunterladen der Datei</string>
    <string name="magisk_update_title">Magisk Update verfügbar!</string>
    <string name="updated_title">Magisk aktualisiert</string>
    <string name="updated_text">Tippen, um die App zu öffnen</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Ja</string>
    <string name="no">Nein</string>
    <string name="repo_install_title">%1$s installieren %2$s(%3$d)</string>
    <string name="download">Herunterladen</string>
    <string name="reboot">Neustart</string>
    <string name="release_notes">Anmerkungen zur Veröffentlichung</string>
    <string name="flashing">Flashen …</string>
    <string name="done">Fertig!</string>
    <string name="failure">Fehlgeschlagen</string>
    <string name="hide_app_title">Magisk-App verstecken …</string>
    <string name="open_link_failed_toast">Keine App zum öffnen des Links gefunden</string>
    <string name="complete_uninstall">Vollständig deinstallieren</string>
    <string name="restore_img">Image wiederherstellen</string>
    <string name="restore_img_msg">Wiederherstellen …</string>
    <string name="restore_done">Wiederherstellen fertig!</string>
    <string name="restore_fail">Stock-Sicherung existiert nicht!</string>
    <string name="setup_fail">Setup fehlgeschlagen</string>
    <string name="env_fix_title">Zusätzliche Einrichtung erforderlich</string>
    <string name="env_fix_msg">Magisk braucht ein zusätzliches Setup, um auf deinem Gerät zu funktionieren. Willst du fortfahren und dein Gerät neustarten?</string>
    <string name="env_full_fix_msg">Dein Gerät benötigt einen Reflash von Magisk, um richtig zu funktionieren. Bitte Magisk innerhalb der App neu installieren, der Wiederherstellungsmodus kann keine korrekten Geräteinformationen abrufen.</string>
    <string name="setup_msg">Laufzeitumgebung einrichten …</string>
    <string name="unsupport_magisk_title">Nicht unterstützte Magisk-Version</string>
    <string name="unsupport_magisk_msg">Diese App-Version unterstützt keine Magisk-Version kleiner als %1$s.\n\nDie App verhält sich so, als ob kein Magisk installiert wäre. Bitte Magisk so bald wie möglich aktualisieren.</string>
    <string name="unsupport_general_title">Abnormaler Zustand</string>
    <string name="unsupport_system_app_msg">Ausführung dieser App als System-App wird nicht unterstützt. App bitte in eine Benutzer-App umwandeln.</string>
    <string name="unsupport_other_su_msg">Es wurde ein \"su\"-Befehl erkannt, der nicht zu Magisk gehört. Das andere nicht unterstützte \"su\" bitte entfernen.</string>
    <string name="unsupport_external_storage_msg">Magisk ist auf einem externen Speicher installiert. Die App bitte in internen Speicher verschieben.</string>
    <string name="unsupport_nonroot_stub_msg">App kann im versteckten Zustand nicht weiter funktionieren, da Root verloren gegangen ist. Ursprüngliche APK bitte wiederherstellen.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Speichererlaubnis erteilen, um diese Funktion zu aktivieren</string>
    <string name="install_unknown_denied">Unbekannte Apps installieren erlauben, um diese Funktion zu aktivieren</string>
    <string name="post_notifications_denied">Benachrichtigungen die Berechtigung erteilen, diese Funktion zu aktivieren</string>
    <string name="add_shortcut_title">Verknüpfung zum Startbildschirm hinzufügen</string>
    <string name="add_shortcut_msg">Nachdem du diese App versteckst, wird der Name und das Symbol eventuell schwer zu erkennen sein. Möchtest du zum Startbildschirm eine schöne Verknüpfung hinzufügen?</string>
    <string name="app_not_found">Keine App gefunden, die diese Aktion verarbeitet</string>
    <string name="reboot_apply_change">Neustart zum Änderungen übernehmen</string>
    <string name="restore_app_confirmation">Dadurch wird die versteckte App wieder zur ursprünglichen App. Willst du das wirklich tun?</string>

</resources>

```

`app/core/src/main/res/values-el/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Επεκτάσεις</string>
    <string name="superuser">Υπερχρήστης</string>
    <string name="logs">Αρχείο Καταγραφής</string>
    <string name="settings">Ρυθμίσεις</string>
    <string name="install">Εγκατάσταση</string>
    <string name="section_home">Αρχική</string>
    <string name="section_theme">Θέματα</string>
    <string name="denylist">Λίστα Απορρίψεων</string>

    <!--Home-->
    <string name="no_connection">Δεν υπάρχει διαθέσιμη σύνδεση</string>
    <string name="app_changelog">Καταγραφή αλλαγών εφαρμογής</string>
    <string name="loading">Φόρτωση…</string>
    <string name="update">Ενημέρωση</string>
    <string name="not_available">Μη διαθέσιμο</string>
    <string name="hide">Απόκρυψη</string>
    <string name="home_package">Πακέτο</string>
    <string name="home_app_title">Εφαρμογή</string>

    <string name="home_notice_content">Κάντε λήψη του Magisk ΜΟΝΟ από την επίσημη σελίδα του GitHub. Τα αρχεία από άγνωστες πηγές μπορεί να είναι κακόβουλα!</string>
    <string name="home_support_title">Υποστήριξη</string>
    <string name="home_follow_title">Ακολούθησε μας</string>
    <string name="home_item_source">Πηγή</string>
    <string name="home_support_content">Το Magisk είναι, και θα είναι για πάντα, δωρεάν και ανοιχτού κώδικα. Μπορείτε ωστόσο να μας δείξετε ότι ενδιαφέρεστε στέλνοντας μια μικρή δωρεά.</string>
    <string name="home_installed_version">Τρέχουσα έκδοση</string>
    <string name="home_latest_version">Διαθέσιμη έκδοση</string>
    <string name="invalid_update_channel">Λανθασμένο κανάλι ενημέρωσης</string>
    <string name="uninstall_magisk_title">Απεγκατάσταση Magisk</string>
    <string name="uninstall_magisk_msg">Όλα τα modules θα απενεργοποιηθούν/αφαιρεθούν. Το root θα αφαιρεθεί και ενδέχεται να κρυπτογραφηθούν τα δεδομένα σας, εάν δεν είναι κρυπτογραφημένα!</string>

    <!--Install-->
	<string name="keep_force_encryption">Διατήρηση επιβεβλημένης κρυπτογράφησης</string>
    <string name="keep_dm_verity">Διατήρηση AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Μέσω Recovery mode</string>
    <string name="install_options_title">Επιλογές</string>
    <string name="install_method_title">Μέθοδος</string>
    <string name="install_next">Επόμενο</string>
    <string name="install_start">Εκκίνηση</string>
    <string name="manager_download_install">Πιέστε για λήψη και εγκατάσταση</string>
    <string name="direct_install">Απευθείας Εγκατάσταση (Προτείνεται)</string>
    <string name="install_inactive_slot">Εγκατάσταση στο ανενεργό Slot (Μετά από OTA)</string>
    <string name="install_inactive_slot_msg">Η συσκευή σας θα αναγκαστεί να εκκινήσει στο τρέχον ανενεργό Slot μετά από επανεκκίνηση!\nΧρησιμοποιήστε αυτήν την επιλογή μόνο αφού ολοκληρωθεί το OTA.\nΣυνέχεια;</string>
    <string name="setup_title">Πρόσθετη εγκατάσταση</string>
    <string name="select_patch_file">Επέλεξε και κάνε Patch ένα αρχείο</string>
    <string name="patch_file_msg">Επέλεξε μία raw εικόνα (*.img) ή ένα ODIN tarfile (*.tar)</string>
    <string name="reboot_delay_toast">Επανεκκίνηση σε 5 δευτερόλεπτα…</string>
    <string name="flash_screen_title">Εγκατάσταση</string>

    <!--Superuser-->
    <string name="su_request_title">Αίτημα υπερχρήστη</string>
    <string name="touch_filtered_warning">Επειδή μια εφαρμογή αποκρύπτει ένα αίτημα υπερχρήστη, το Magisk δεν μπορεί να επαληθεύσει την απάντησή σας</string>
    <string name="deny">Άρνηση</string>
    <string name="prompt">Προτροπή</string>
    <string name="grant">Αποδοχή</string>
    <string name="su_warning">Δίνει πλήρη πρόσβαση στη συσκευή σας.\nΑρνηθείτε αν δεν είστε σίγουρος/η!</string>
    <string name="forever">Μόνιμα</string>
    <string name="once">Μία φορά</string>
    <string name="tenmin">10 λεπτά</string>
    <string name="twentymin">20 λεπτά</string>
    <string name="thirtymin">30 λεπτά</string>
    <string name="sixtymin">60 λεπτά</string>
    <string name="su_allow_toast">Παραχωρήθηκαν δικαιώματα υπερχρήστη στο %1$s</string>
    <string name="su_deny_toast">Απορρίφθηκαν τα δικαιώματα υπερχρήστη του %1$s</string>
    <string name="su_snack_grant">Παραχορούνται δικαιώματα υπερχρήστη στο %1$s</string>
    <string name="su_snack_deny">Δεν παραχορούνται δικαιώματα υπερχρήστη στο %1$s</string>
    <string name="su_snack_notif_on">Οι ειδοποιήσεις του %1$s είναι ενεργοποιημένες</string>
    <string name="su_snack_notif_off">Οι ειδοποιήσεις του %1$s είναι απενεργοποιημένες</string>
    <string name="su_snack_log_on">Η καταγραφή του %1$s είναι ενεργοποιημένη</string>
    <string name="su_snack_log_off">Η καταγραφή του %1$s είναι απενεργοποιημένη</string>
    <string name="su_revoke_title">Ανάκληση;</string>
    <string name="su_revoke_msg">Επιβεβαίωση για ανάκληση δικαιωμάτων %1$s;</string>
    <string name="toast">Αναδυόμενο παράθυρο</string>
    <string name="none">Κανένα</string>

    <string name="superuser_toggle_notification">Ειδοποιήσεις</string>
    <string name="superuser_toggle_revoke">Ανακάλεσε</string>
    <string name="superuser_policy_none">Καμία εφαρμογή δεν έχει ζητήσει άδεια υπερχρήστη.</string>
	
    <!--Logs-->
    <string name="log_data_none">Δεν υπάρχουν αρχεία καταγραφής, δοκιμάστε να χρησιμοποιήσετε περισσότερο τις εφαρμογές με δυνατότητα SU</string>
    <string name="log_data_magisk_none">Τα αρχεία καταγραφής του Magisk είναι κενά, αυτό είναι περίεργο</string>
    <string name="menuSaveLog">Αποθήκευση καταγραφής</string>
    <string name="menuClearLog">Εκκαθάριση αρχείου καταγραφής</string>
    <string name="logs_cleared">Το αρχείο καταγραφής εκκαθαρίστηκε επιτυχώς</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">UID Στόχος: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Εμφάνιση εφαρμογών συστήματος</string>
    <string name="show_os_app">Εμφάνιση εφαρμογών OS</string>
    <string name="hide_filter_hint">Φιλτράρισμα</string>
    <string name="hide_search">Αναζήτηση</string>

    <!--Module-->
    <string name="no_info_provided">(Δεν δόθηκαν πληροφορίες)</string>
    <string name="reboot_userspace">Soft επανεκκίνηση</string>
    <string name="reboot_recovery">Επανεκκίνηση στο Recovery</string>
    <string name="reboot_bootloader">Επανεκκίνηση στο Bootloader</string>
    <string name="reboot_download">Επανεκκίνηση για λήψη</string>
    <string name="reboot_edl">Επανεκκίνηση σε EDL</string>
    <string name="module_version_author">%1$s από %2$s</string>
    <string name="module_state_remove">Αφαίρεση</string>
    <string name="module_state_restore">Επαναφορά</string>
    <string name="module_action_install_external">Εγκατάσταση από χώρο αποθήκευσης</string>
    <string name="update_available">Διαθέσιμη Ενημέρωση</string>
    <string name="suspend_text_riru">Η επέκταση έχει ανασταλεί επειδή το %1$s είναι ενεργοποιημένο</string>
    <string name="suspend_text_zygisk">Η επέκταση έχει ανασταλεί επειδή το %1$s δεν είναι ενεργοποιημένο</string>
    <string name="zygisk_module_unloaded">Zygisk module not loaded due to incompatibility</string>
    <string name="module_empty">Δεν υπάρχουν εγκατεστημένες επεκτάσεις</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Λειτουργία θέματος</string>
    <string name="settings_dark_mode_message">Επιλέξτε τη λειτουργία που ταιριάζει καλύτερα στο στυλ σας!</string>
    <string name="settings_dark_mode_light">Πάντα Light</string>
    <string name="settings_dark_mode_system">Ακολούθησε το σύστημα</string>
    <string name="settings_dark_mode_dark">Πάντα Dark</string>
    <string name="settings_download_path_title">Διαδρομή λήψης</string>
    <string name="settings_download_path_message">Τα αρχεία θα αποθηκευτούν στο %1$s</string>
    <string name="settings_hide_app_title">Απόκρυψη της εφαρμογής Magisk</string>
    <string name="settings_hide_app_summary">Εγκαταστήστε μια εφαρμογή με τυχαίο αναγνωριστικό πακέτου και προσαρμοσμένη ετικέτα εφαρμογής</string>
    <string name="settings_restore_app_title">Επαναφέρετε την εφαρμογή Magisk</string>
    <string name="settings_restore_app_summary">Καταργήστε την απόκρυψη της εφαρμογής και επαναφέρετέ την στο αρχικό APK</string>
    <string name="language">Γλώσσα</string>
    <string name="system_default">(Προεπιλογή Συστήματος)</string>
    <string name="settings_check_update_title">Έλεγχος Ενημερώσεων</string>
    <string name="settings_check_update_summary">Περιοδικά ελέγχετε για ενημερώσεις στο παρασκήνιο</string>
    <string name="settings_update_channel_title">Κανάλι Ενημερώσεων</string>
    <string name="settings_update_stable">Σταθερό</string>
    <string name="settings_update_beta">Δοκιμαστικό</string>
    <string name="settings_update_custom">Προσαρμοσμένο</string>
    <string name="settings_update_custom_msg">Εισαγωγή ενός custom URL</string>
    <string name="settings_zygisk_summary">Εκτέλεση μέρους του Magisk μέσα στο zygote daemon</string>
    <string name="settings_denylist_title">Επιβολή Λίστας Απορρίψεων</string>
    <string name="settings_denylist_summary">Επαναφορά όλων των τροποποιήσεων του Magisk για της διεργασίες στην λίστα απορρίψεων</string>
    <string name="settings_denylist_config_title">Τροποποίηση της Λίστας Απορρίψεων</string>
    <string name="settings_denylist_config_summary">Επιλογή διεργασίας για να συμπεριληφθεί στη λίστα απορρίψεων</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">Υποστήριξη Systemless hosts για εφαρμογές Adblock</string>
    <string name="settings_hosts_toast">Προσθήκη αρθρώματος systemless hosts</string>
    <string name="settings_app_name_hint">Νέο όνομα</string>
    <string name="settings_app_name_helper">Η εφαρμογή θα επανασυσκευαστεί με αυτό το όνομα</string>
    <string name="settings_app_name_error">Μη έγκυρη μορφή</string>
    <string name="settings_su_app_adb">Εφαρμογές και ADB</string>
    <string name="settings_su_app">Εφαρμογές μόνο</string>
    <string name="settings_su_adb">ADB μόνο</string>
    <string name="settings_su_disable">Απενεργοποιημένο</string>
    <string name="settings_su_request_10">10 δευτερόλεπτα</string>
    <string name="settings_su_request_15">15 δευτερόλεπτα</string>
    <string name="settings_su_request_20">20 δευτερόλεπτα</string>
    <string name="settings_su_request_30">30 δευτερόλεπτα</string>
    <string name="settings_su_request_45">45 δευτερόλεπτα</string>
    <string name="settings_su_request_60">60 δευτερόλεπτα</string>
    <string name="superuser_access">Πρόσβαση Υπερχρήστη</string>
    <string name="auto_response">Αυτόματη Απόκριση</string>
    <string name="request_timeout">Χρονικό όριο Αιτήματος</string>
    <string name="superuser_notification">Ειδοποίηση Υπερχρήστη</string>
    <string name="settings_su_reauth_title">Επαναπιστοποίηση μετά από αναβάθμιση</string>
    <string name="settings_su_reauth_summary">Επαναπιστοποίηση αδειών υπερχρήστη μετά την αναβάθμιση μίας εφαρμογής</string>
    <string name="settings_su_tapjack_title">Ενεργοποίηση προστασίας Tapjacking</string>
    <string name="settings_su_tapjack_summary">Το παράθυρο διαλόγου προτροπής του υπερχρήστη δεν αποκρίνεται στην είσοδο ενώ κρύβεται από οποιοδήποτε άλλο παράθυρο</string>
    <string name="settings_customization">Προσαρμογή</string>
    <string name="setting_add_shortcut_summary">Προσθέστε μια όμορφη συντόμευση στην αρχική οθόνη σε περίπτωση που το όνομα και το εικονίδιο είναι δύσκολο να αναγνωριστούν αφού κρύψετε την εφαρμογή</string>
    <string name="settings_doh_title">DNS μέσω HTTPS</string>
    <string name="settings_doh_description">Λύση DNS poisoning για μερικά έθνη</string>

    <string name="multiuser_mode">Λειτουργία Πολλών Χρηστών</string>
    <string name="settings_owner_only">Μόνο Ιδιοκτήτης Συσκευής</string>
    <string name="settings_owner_manage">Διαχειριζόμενη από τον Ιδιοκτήτη</string>
    <string name="settings_user_independent">Ανεξάρτητη από τον χρήστη</string>
    <string name="owner_only_summary">Μόνο ο ιδιοκτήτης έχει πρόσβαση root</string>
    <string name="owner_manage_summary">Μόνο ο ιδιοκτήτης μπορεί να διαχειριστεί την πρόσβαση root και να δεχτεί προτροπές αίτημάτων</string>
    <string name="user_independent_summary">Κάθε χρήστης έχει τους δικούς του ξεχωριστούς κανόνες root</string>

    <string name="mount_namespace_mode">Λειτουργία προσάρτησης χώρου ονομάτων</string>
    <string name="settings_ns_global">Καθολικός Χώρος Ονομάτων</string>
    <string name="settings_ns_requester">Κληρονόμησε Χώρο Ονομάτων</string>
    <string name="settings_ns_isolate">Απομονωμένος Χώρος Ονομάτων</string>
    <string name="global_summary">Όλες οι συνεδρίες root χρησιμοποιούν τον καθολικό χώρο oνομάτων προσάρτησης</string>
    <string name="requester_summary">Οι συνεδρίες root θα κληρονομούν το χώρο ονομάτων του αιτούντα τους</string>
    <string name="isolate_summary">Κάθε συνεδρία root θα έχει το δικό της απομονωμένο χώρο ονομάτων</string>

    <!--Notifications-->
    <string name="update_channel">Ενημερώσεις Magisk</string>
    <string name="progress_channel">Ειδοποιήσεις προόδου</string>
    <string name="updated_channel">Η Αναβάθμηση Ολοκληρώθηκε</string>
    <string name="download_complete">Η λήψη ολοκληρώθηκε</string>
    <string name="download_file_error">Σφάλμα στη λήψη του αρχείου</string>
    <string name="magisk_update_title">Νέα Ενημέρωση Magisk Διαθέσιμη!</string>
    <string name="updated_title">Το Magisk Ενημερώθηκε</string>
    <string name="updated_text">Πατήστε για άνοιγμα εφαρμογής</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Ναι</string>
    <string name="no">Όχι</string>
    <string name="repo_install_title">Εγκατάσταση %1$s %2$s(%3$d)</string>
    <string name="download">Λήψη</string>
    <string name="reboot">Επανεκκίνηση</string>
    <string name="release_notes">Σημειώσεις έκδοσης</string>
    <string name="flashing">Προγραμματισμός σε εξέλιξη</string>
    <string name="done">Ολοκληρώθηκε</string>
    <string name="failure">Αποτυχία</string>
    <string name="hide_app_title">Απόκρυψη της εφαρμογής Magisk…</string>
    <string name="open_link_failed_toast">Δεν βρέθηκε εφαρμογή για άνοιγμα του συνδέσμου</string>
    <string name="complete_uninstall">Πλήρης απεγκατάσταση</string>
    <string name="restore_img">Επαναφορά Images</string>
    <string name="restore_img_msg">Επαναφορά…</string>
    <string name="restore_done">Η επαναφορά πραγματοποιήθηκε</string>
    <string name="restore_fail">Δεν υπάρχει αντίγραφο ασφαλείας!</string>
    <string name="setup_fail">Η εγκατάσταση απέτυχε</string>
    <string name="env_fix_title">Απαιτείται πρόσθετη εγκατάσταση</string>
    <string name="env_fix_msg">Η συσκευή σας χρειάζεται πρόσθετη ρύθμιση για να λειτουργεί σωστά το Magisk. Θέλετε να συνεχίσετε και να επανεκκινήσετε;</string>
    <string name="setup_msg">Τρέχει η εγκατάσταση περιβάλλοντος…</string>
    <string name="unsupport_magisk_title">Μη υποστηριζόμενη έκδοση Magisk</string>
    <string name="unsupport_magisk_msg">Αυτή η έκδοση της εφαρμογής δεν υποστηρίζει έκδοση Magisk χαμηλότερη από %1$s.\n\nΗ εφαρμογή θα συμπεριφέρεται σαν να μην έχει εγκατασταθεί το Magisk, αναβαθμίστε το Magisk το συντομότερο δυνατό.</string>
    <string name="unsupport_general_title">Μη Φυσιολογική Κατάσταση</string>
    <string name="unsupport_system_app_msg">Η εκτέλεση αυτής της εφαρμογής ως εφαρμογής συστήματος δεν υποστηρίζεται. Επαναφέρετε την εφαρμογή σε εφαρμογή χρήστη.</string>
    <string name="unsupport_other_su_msg">Εντοπίστηκε ένα \"su\" binary που δεν είναι από το Magisk. Καταργήστε οποιαδήποτε άλλη root μέθοδο και/ή επανεγκαταστήστε το Magisk.</string>
    <string name="unsupport_external_storage_msg">Το Magisk είναι εγκατεστημένο σε εξωτερικό χώρο αποθήκευσης. Μετακινήστε την εφαρμογή στον εσωτερικό χώρο αποθήκευσης.</string>
    <string name="unsupport_nonroot_stub_msg">Η κρυφή εφαρμογή Magisk δεν μπορεί να συνεχίσει να λειτουργεί επειδή χάθηκε το root. Παρακαλώ επαναφέρετε το αρχικό APK.</string>
    
	<string name="external_rw_permission_denied">Παραχωρήστε άδεια αποθήκευσης για να ενεργοποιήσετε αυτήν τη λειτουργία</string>
    <string name="install_unknown_denied">Επιτρέψτε την "εγκατάσταση άγνωστων εφαρμογών" για να ενεργοποιήσετε αυτήν τη λειτουργία</string>
    <string name="add_shortcut_title">Προσθέστε συντόμευση στην αρχική οθόνη</string>
    <string name="add_shortcut_msg">Μετά την απόκρυψη αυτής της εφαρμογής, το όνομα και το εικονίδιο της ενδέχεται να είναι δύσκολο να αναγνωριστούν. Θέλετε να προσθέσετε μια όμορφη συντόμευση στην αρχική οθόνη;</string>
    <string name="app_not_found">Δεν βρέθηκε εφαρμογή που να χειρίζεται αυτήν την ενέργεια</string>
    <string name="reboot_apply_change">Επανεκκινήστε για να εφαρμόσετε της αλλαγές</string>
    <string name="restore_app_confirmation">Αυτό θα επαναφέρει την κρυφή εφαρμογή πίσω στην αρχική εφαρμογή. Θέλετε πραγματικά να το κάνετε αυτό;</string>

</resources>

```

`app/core/src/main/res/values-es/strings.xml`:

```xml
<resources>

    <!--Secciones-->
    <string name="modules">Módulos</string>
    <string name="superuser">Superusuario</string>
    <string name="logs">Registros</string>
    <string name="settings">Ajustes</string>
    <string name="install">Instalar</string>
    <string name="section_home">Inicio</string>
    <string name="section_theme">Temas</string>
    <string name="denylist">Lista de denegación</string>

    <!--Inicio/Pantalla principal-->
    <string name="no_connection">Sin conexión disponible</string>
    <string name="app_changelog">Registro de cambios</string>
    <string name="loading">Cargando…</string>
    <string name="update">Actualizar</string>
    <string name="not_available">No disponible</string>
    <string name="hide">Ocultar</string>
    <string name="home_package">Nombre de paquete:</string>
    <string name="home_app_title">App</string>
    <string name="home_notice_content">Descarga Magisk únicamente desde la página oficial de GitHub. ¡Las descargas desde fuentes desconocidas pueden ser maliciosas!</string>
    <string name="home_support_title">Apóyanos</string>
    <string name="home_follow_title">Síguenos</string>
    <string name="home_item_source">Código fuente</string>
    <string name="home_support_content">Magisk es y siempre será gratis y de código abierto. Sin embargo, puedes mostrarnos tu apoyo mediante una donación.</string>
    <string name="home_installed_version">Versión instalada:</string>
    <string name="home_latest_version">Última versión disponible:</string>
    <string name="invalid_update_channel">Canal de actualización inválido</string>
    <string name="uninstall_magisk_title">Desinstalar Magisk</string>
    <string name="uninstall_magisk_msg">Antes de desinstalar Magisk, ten en cuenta lo siguiente:\n• Todos los módulos serán desinstalados\n• Perderás el acceso root\n• Tu almacenamiento interno será reencriptado en caso de que no lo esté</string>

    <!--Instalación-->
    <string name="keep_force_encryption">Mantener FDE (Full-Disk Encryption)</string>
    <string name="keep_dm_verity">Mantener AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Modo recovery</string>
    <string name="install_options_title">Opciones de instalación:</string>
    <string name="install_method_title">Método de instalación:</string>
    <string name="install_next">Siguiente</string>
    <string name="install_start">Instalar</string>
    <string name="manager_download_install">Pulsa para descargar e instalar</string>
    <string name="direct_install">Instalación directa (recomendado)</string>
    <string name="install_inactive_slot">Instalar en el slot inactivo (tras una OTA)</string>
    <string name="install_inactive_slot_msg">Tu dispositivo será forzado a bootear en el slot inactivo actual después de un reinicio\nUsa esta opción solo después de que la actualización OTA se complete.\n¿Quieres continuar?</string>
    <string name="setup_title">Configuración adicional</string>
    <string name="select_patch_file">Seleccionar y parchar un archivo</string>
    <string name="patch_file_msg">Selecciona una imagen raw (.img) o un archivo comprimido que la contenga (.tar), en caso de que quieras usar Odin (Samsung)</string>
    <string name="reboot_delay_toast">Reiniciando en 5 segundos…</string>
    <string name="flash_screen_title">Instalación</string>

    <!--Superusuario-->
    <string name="su_request_title">Solicitud de superusuario</string>
    <string name="touch_filtered_warning">Hay una app superponiéndose a la solicitud de superusuario, por lo que Magisk no puede verificar tu respuesta.</string>
    <string name="deny">Denegar</string>
    <string name="prompt">Preguntar</string>
    <string name="grant">Conceder</string>
    <string name="su_warning">Le concedes a esta app acceso completo a tu dispositivo.\n¡Rechaza la solicitud si desconfías de ella!</string>
    <string name="forever">Siempre</string>
    <string name="once">Una vez</string>
    <string name="tenmin">10 minutos</string>
    <string name="twentymin">20 minutos</string>
    <string name="thirtymin">30 minutos</string>
    <string name="sixtymin">1 hora</string>
    <string name="su_allow_toast">Le concediste privilegios de superusuario a %1$s</string>
    <string name="su_deny_toast">Le denegaste privilegios de superusuario a %1$s</string>
    <string name="su_snack_grant">Privilegios de superusuario para %1$s concedidos</string>
    <string name="su_snack_deny">Privilegios de superusuario para %1$s denegados</string>
    <string name="su_snack_notif_on">Notificaciones de %1$s habilitadas</string>
    <string name="su_snack_notif_off">Notificaciones de %1$s deshabilitadas</string>
    <string name="su_snack_log_on">Registros de %1$s habilitados</string>
    <string name="su_snack_log_off">Registros de %1$s deshabilitados</string>
    <string name="su_revoke_title">Revocar privilegios</string>
    <string name="su_revoke_msg">Confirma para revocarle los privilegios de superusuario a %1$s</string>
    <string name="toast">Mensaje emergente</string>
    <string name="none">Ninguno</string>
    <string name="superuser_toggle_notification">Notificaciones</string>
    <string name="superuser_toggle_revoke">Revocar</string>
    <string name="superuser_policy_none">Ninguna app ha solicitado privilegios de superusuario aún.</string>

    <!--Registros-->
    <string name="log_data_none">No hay registros de apps disponibles</string>
    <string name="log_data_magisk_none">No hay registros de Magisk disponibles</string>
    <string name="menuSaveLog">Guardar registro</string>
    <string name="menuClearLog">Limpiar registro</string>
    <string name="logs_cleared">Registros limpiados correctamente</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Objetivo UID: %1$d</string>
    <string name="target_pid">Montar ns objetivo PID: %s</string>
    <string name="selinux_context">Contexto SELinux: %s</string>
    <string name="supp_group">Grupo suplementario: %s</string>

    <!--SafetyNet/PlayIntegrity-->

    <!--Denylist-->
    <string name="show_system_app">Mostrar apps del sistema</string>
    <string name="show_os_app">Mostrar apps del sistema operativo</string>
    <string name="hide_filter_hint">Nombre de la app o del paquete</string>
    <string name="hide_search">Buscar</string>

    <!--Módulos-->
    <string name="no_info_provided">El creador del módulo no proporcionó ninguna descripción.</string>
    <string name="reboot_userspace">Reinicio suave</string>
    <string name="reboot_recovery">Modo Recovery</string>
    <string name="reboot_bootloader">Modo Bootloader</string>
    <string name="reboot_download">Modo Download</string>
    <string name="reboot_edl">Modo EDL</string>
    <string name="module_version_author">Versión %1$s, por %2$s</string>
    <string name="module_state_remove">Desinstalar</string>
    <string name="module_state_restore">Reinstalar</string>
    <string name="module_action_install_external">Instalar desde almacenamiento</string>
    <string name="update_available">Actualización disponible</string>
    <string name="suspend_text_riru">Módulo suspendido porque %1$s está activado</string>
    <string name="suspend_text_zygisk">Módulo suspendido porque %1$s está desactivado</string>
    <string name="zygisk_module_unloaded">El módulo Zygisk no se cargó por problemas de compatibilidad</string>
    <string name="module_empty">No hay módulos instalados</string>
    <string name="confirm_install">¿Quieres instalar el módulo %1$s?</string>
    <string name="confirm_install_title">Confirmar instalación</string>

    <!--Ajustes-->
    <string name="settings_dark_mode_title">Modo del tema</string>
    <string name="settings_dark_mode_message">¡Elige el modo que más se adapte a tu estilo!</string>
    <string name="settings_dark_mode_light">Claro</string>
    <string name="settings_dark_mode_dark">Oscuro</string>
    <string name="settings_dark_mode_system">Predeterminado del sistema</string>
    <string name="settings_download_path_title">Ruta de descarga</string>
    <string name="settings_download_path_message">Los archivos serán guardados en la siguiente ruta:\n%1$s</string>
    <string name="settings_hide_app_title">Ocultar la app de Magisk</string>
    <string name="settings_hide_app_summary">Instalar una versión proxy de la app con un nombre de paquete aleatorio y una etiqueta personalizada</string>
    <string name="settings_restore_app_title">Restaurar la app</string>
    <string name="settings_restore_app_summary">Desoculta la app y la reemplaza por la original</string>
    <string name="language">Idioma</string>
    <string name="system_default">Predeterminado del sistema</string>
    <string name="settings_check_update_title">Buscar actualizaciones</string>
    <string name="settings_check_update_summary">Busca actualizaciones periódicamente en segundo plano</string>
    <string name="settings_update_channel_title">Canal de actualización</string>
    <string name="settings_update_stable">Estable</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Personalizado</string>
    <string name="settings_update_custom_msg">Ingresa la URL del canal personalizado</string>
    <string name="settings_zygisk_summary">Ejecuta Magisk en el proceso Zygote de Android</string>
    <string name="settings_denylist_title">Aplicar lista de denegación</string>
    <string name="settings_denylist_summary">Las apps en la lista de denegación no serán modificadas por Magisk</string>
    <string name="settings_denylist_config_title">Configurar lista de denegación</string>
    <string name="settings_denylist_config_summary">Selecciona los procesos de cada app que se incluirán en la lista</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">Prepara al archivo hosts para que los bloqueadores de anuncios puedan modificarlo sin alterar el sistema</string>
    <string name="settings_hosts_toast">El módulo se instaló correctamente, reinicia para aplicar los cambios.</string>
    <string name="settings_app_name_hint">Nuevo nombre de la app</string>
    <string name="settings_app_name_helper">La app de Magisk será reempaquetada con este nombre</string>
    <string name="settings_app_name_error">El nombre es inválido</string>
    <string name="settings_su_app_adb">Permitir tanto a las apps como a ADB</string>
    <string name="settings_su_app">Permitir solo a las apps</string>
    <string name="settings_su_adb">Permitir solo a ADB</string>
    <string name="settings_su_disable">Deshabilitado</string>
    <string name="settings_su_request_10">10 segundos</string>
    <string name="settings_su_request_15">15 segundos</string>
    <string name="settings_su_request_20">20 segundos</string>
    <string name="settings_su_request_30">30 segundos</string>
    <string name="settings_su_request_45">45 segundos</string>
    <string name="settings_su_request_60">60 segundos</string>
    <string name="superuser_access">Acceso de superusuario</string>
    <string name="auto_response">Respuesta predeterminada</string>
    <string name="request_timeout">Duración de la solicitud</string>
    <string name="superuser_notification">Notificación de superusuario</string>
    <string name="settings_su_reauth_title">Reautenticar después de una actualización</string>
    <string name="settings_su_reauth_summary">Las apps volverán a solicitar privilegios de superusuario tras actualizarse</string>
    <string name="settings_su_tapjack_title">Protección contra tapjacking</string>
    <string name="settings_su_tapjack_summary">No podrás interactuar con las solicitudes de superusuario mientras estén tapadas por cualquier otra ventana o superposición</string>
    <string name="settings_su_auth_title">Autenticación de usuario</string>
    <string name="settings_su_auth_summary">Preguntar por la autenticación de usuario durante las peticiones de Superusuario</string>
    <string name="settings_su_auth_insecure">No hay método de autenticación configurado en el dispositivo</string>
    <string name="settings_customization">Personalización</string>
    <string name="setting_add_shortcut_summary">Añade un atajo a la app con el ícono de Magisk a la pantalla de inicio en caso de que te resulte difícil reconocerla tras haberle cambiado el nombre y el ícono</string>
    <string name="settings_doh_title">DNS sobre HTTPS</string>
    <string name="settings_doh_description">Proporciona una solución alternativa (workaround) contra el envenenamiento de DNS en algunos países</string>
    <string name="multiuser_mode">Modo multiusuario</string>
    <string name="settings_owner_only">Propietario del dispositivo</string>
    <string name="settings_owner_manage">Administrado por el propietario del dispositivo</string>
    <string name="settings_user_independent">Acceso independiente</string>
    <string name="owner_only_summary">Solo el administrador tiene acceso root</string>
    <string name="owner_manage_summary">Solo el administrador puede manipular y recibir solicitudes de superusuario</string>
    <string name="user_independent_summary">Cada usuario tiene sus propias reglas y acceso al root</string>
    <string name="mount_namespace_mode">Modo del namespace de montaje</string>
    <string name="settings_ns_global">Namespace global</string>
    <string name="settings_ns_requester">Namespace heredado</string>
    <string name="settings_ns_isolate">Namespace aislado</string>
    <string name="global_summary">Todas las sesiones de superusuario usarán el namespace de montaje global</string>
    <string name="requester_summary">Las sesiones de superusuario heredarán el namespace de montaje de quien las solicita</string>
    <string name="isolate_summary">Cada sesión de superusuario tendrá su propio namespace de montaje aislado</string>

    <!--Notificaciones-->
    <string name="update_channel">Actualizaciones de Magisk</string>
    <string name="progress_channel">Notificaciones de progreso</string>
    <string name="updated_channel">Actualización finalizada</string>
    <string name="download_complete">Descarga finalizada</string>
    <string name="download_file_error">Ocurrió un error en la descarga</string>
    <string name="magisk_update_title">¡Actualización de Magisk disponible!</string>
    <string name="updated_title">Se actualizó Magisk</string>
    <string name="updated_text">Pulsa para abrir la app</string>

    <!--Alertas y diálogos-->
    <string name="yes">Sí</string>
    <string name="no">No</string>
    <string name="repo_install_title">Instalar %1$s %2$s(%3$d)</string>
    <string name="download">Descargar</string>
    <string name="reboot">Reiniciar</string>
    <string name="release_notes">Notas de lanzamiento</string>
    <string name="flashing">Flasheando…</string>
    <string name="done">¡Listo!</string>
    <string name="failure">¡Ocurrió un error!</string>
    <string name="hide_app_title">Ocultando la app de Magisk…</string>
    <string name="open_link_failed_toast">No se encontró ninguna app que pueda abrir este enlace</string>
    <string name="complete_uninstall">Desinstalación completa</string>
    <string name="restore_img">Solo restaurar las imágenes</string>
    <string name="restore_img_msg">Restaurando…</string>
    <string name="restore_done">¡Restauración completa!</string>
    <string name="restore_fail">Oops... no se encontró una copia de seguridad de las imágenes originales</string>
    <string name="setup_fail">Ocurrió un error en la configuración</string>
    <string name="env_fix_title">Configuración adicional</string>
    <string name="env_fix_msg">Tu dispositivo necesita una configuración adicional para que Magisk funcione correctamente. ¿Quieres continuar y reiniciar?</string>
    <string name="env_full_fix_msg">Tu dispositivo necesita reinstalar Magisk para que este funcione correctamente. Por favor, reinstala Magisk desde la app, el modo recovery no puede obtener la información correcta del dispositivo.</string>
    <string name="setup_msg">Ejecutando configuración de entorno…</string>
    <string name="unsupport_magisk_title">Versión de Magisk no soportada</string>
    <string name="unsupport_magisk_msg">La versión actual de la app no soporta versiones de Magisk inferiores a la %1$s.\n\nLa app se comportará como si Magisk no estuviese instalado, por favor, actualízalo tan pronto como puedas</string>
    <string name="unsupport_general_title">Estado anormal</string>
    <string name="unsupport_system_app_msg">La ejecución de esta app como app del sistema no está soportada. Por favor, vuelve a instalarla como usuario</string>
    <string name="unsupport_other_su_msg">Se detectó un binario \"su\" ajeno a Magisk. Por favor, desinstala cualquier solución root de la competencia y/o reinstala Magisk</string>
    <string name="unsupport_external_storage_msg">La app de Magisk está instalada en un almacenamiento externo, por favor, muévela al almacenamiento interno.</string>
    <string name="unsupport_nonroot_stub_msg">La app de Magisk oculta no puede seguir funcionando porque se perdió el acceso root. Por favor, restaura el APK original</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Permite el acceso al almacenamiento para activar esta funcionalidad</string>
    <string name="post_notifications_denied">Permite mostrar notificaciones para activar esta funcionalidad</string>
    <string name="install_unknown_denied">Permite la instalación de apps desconocidas para activar esta funcionalidad</string>
    <string name="add_shortcut_title">Añadir un atajo a la pantalla de inicio</string>
    <string name="add_shortcut_msg">Añade un atajo a la app con el ícono de Magisk a la pantalla de inicio en caso de que te resulte difícil reconocerla tras haberle cambiado el nombre y el ícono</string>
    <string name="app_not_found">No se encontró ninguna app que pueda realizar esta acción</string>
    <string name="reboot_apply_change">Reinicia para aplicar los cambios</string>
    <string name="restore_app_confirmation">Se restaurará la app oculta de vuelta a la original. ¿Quieres continuar?</string>

</resources>

```

`app/core/src/main/res/values-et/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Moodulid</string>
    <string name="superuser">Superkasutaja</string>
    <string name="logs">Logid</string>
    <string name="settings">Seaded</string>
    <string name="install">Installi</string>
    <string name="section_home">Kodu</string>
    <string name="section_theme">Teemad</string>
    <string name="denylist">Keeluloend</string>

    <!--Home-->
    <string name="no_connection">Ühendus puudub</string>
    <string name="app_changelog">Muudatuste logi</string>
    <string name="loading">Laadimine…</string>
    <string name="update">Uuenda</string>
    <string name="not_available">teadmata</string>
    <string name="hide">Peida</string>
    <string name="home_package">Pakett</string>
    <string name="home_app_title">Rakendus</string>

    <string name="home_notice_content">Laadi Magisk alla vaid ametlikult GitHubi lehelt. Tundmatutest allikatest laaditud failid võivad olla pahatahtlikud!</string>
    <string name="home_support_title">Toeta meid</string>
    <string name="home_item_source">Lähtekood</string>
    <string name="home_support_content">Magisk on ja jääb alati tasuta ning avatud lähtekoodiga kättesaadavaks. Siiski, sa võid meile väikese annetuse näol toetust üles näidata.</string>
    <string name="home_installed_version">Installitud</string>
    <string name="home_latest_version">Viimatine</string>
    <string name="invalid_update_channel">Sobimatu uuenduste kanal</string>
    <string name="uninstall_magisk_title">Eemalda Magisk</string>
    <string name="uninstall_magisk_msg">Kõik moodulid keelatakse/eemaldatakse!\nJuurkasutaja eemaldatakse!\nMistahes sisemälu failid, millelt eemaldati Magiski tarbeks krüpteering, krüpteeritakse taas!</string>

    <!--Install-->
    <string name="keep_force_encryption">Säilita sunnitud krüpteering</string>
    <string name="keep_dm_verity">Säilita AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Taastusrežiim</string>
    <string name="install_options_title">Valikud</string>
    <string name="install_method_title">Meetod</string>
    <string name="install_next">Edasi</string>
    <string name="install_start">Läksime</string>
    <string name="manager_download_install">Vajuta allalaadimiseks ja installimiseks</string>
    <string name="direct_install">Otsene install (soovitatud)</string>
    <string name="install_inactive_slot">Installi ebaaktiivsesse lahtrisse (pärast üle-õhu uuendust)</string>
    <string name="install_inactive_slot_msg">Pärast taaskäivitust SUNNITAKSE sinu seade käivituma praegusesse ebaaktiivsesse lahtrisse!\nKasuta seda valikut vaid peale üle-õhu uuenduse teostamist.\nJätkad?</string>
    <string name="setup_title">Lisaseadistus</string>
    <string name="select_patch_file">Vali ja paika fail</string>
    <string name="patch_file_msg">Vali toortõmmis (*.img) või ODIN tar-fail (*.tar)</string>
    <string name="reboot_delay_toast">Taaskäivitamine 5 sekundi pärast…</string>
    <string name="flash_screen_title">Installimine</string>

    <!--Superuser-->
    <string name="su_request_title">Superkasutaja taotlus</string>
    <string name="touch_filtered_warning">Kuna rakendus varjab superkasutaja päringut, ei saa Magisk sinu vastust kinnitada</string>
    <string name="deny">Keela</string>
    <string name="prompt">Küsi</string>
    <string name="grant">Luba</string>
    <string name="su_warning">Annab täieliku ligipääsu sinu seadmele.\nKui sa pole kindel, keela!</string>
    <string name="forever">Igavesti</string>
    <string name="once">Üks kord</string>
    <string name="tenmin">10 min</string>
    <string name="twentymin">20 min</string>
    <string name="thirtymin">30 min</string>
    <string name="sixtymin">60 min</string>
    <string name="su_allow_toast">Rakendusele %1$s anti superkasutaja õigused</string>
    <string name="su_deny_toast">Rakendusel %1$s keelati superkasutaja õigused</string>
    <string name="su_snack_grant">Superkasutaja õigused antud rakendusele %1$s</string>
    <string name="su_snack_deny">Superkasutaja õigused keelatud rakendusele %1$s</string>
    <string name="su_snack_notif_on">Teavitused lubatud rakendusele %1$s</string>
    <string name="su_snack_notif_off">Teavitused keelatud rakendusele %1$s</string>
    <string name="su_snack_log_on">Logimine lubatud rakendusele %1$s</string>
    <string name="su_snack_log_off">Logimine keelatud rakendusele %1$s</string>
    <string name="su_revoke_title">Eemaldad?</string>
    <string name="su_revoke_msg">Kinnitad rakenduse %1$s õiguste eemaldamise?</string>
    <string name="toast">Hüpik</string>
    <string name="none">Puudub</string>

    <string name="superuser_toggle_notification">Teavitused</string>
    <string name="superuser_toggle_revoke">Eemalda</string>
    <string name="superuser_policy_none">Ükski rakendus ei ole veel superkasutaja õigusi küsinud.</string>

    <!--Logs-->
    <string name="log_data_none">Sa oled logivaba, proovi oma superkasutaja õigustega rakendusi rohkem kasutada</string>
    <string name="log_data_magisk_none">Magiski logid on tühjad, see on imelik</string>
    <string name="menuSaveLog">Salvesta logi</string>
    <string name="menuClearLog">Tühjenda logi nüüd</string>
    <string name="logs_cleared">Logi edukalt tühjendatud.</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Siht-UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Kuva uuendatavad süsteemirakendused</string>
    <string name="show_os_app">Kuva fikseeritud süsteemirakendused</string>
    <string name="hide_filter_hint">Filtreeri nime järgi</string>
    <string name="hide_search">Otsing</string>

    <!--Module-->
    <string name="no_info_provided">(Info puudub)</string>
    <string name="reboot_userspace">Pehme taaskäivitus</string>
    <string name="reboot_recovery">Taaskäivita taastusesse</string>
    <string name="reboot_bootloader">Taaskäivita käivitushaldurisse</string>
    <string name="reboot_download">Taaskäivita allalaadimisrežiimi</string>
    <string name="reboot_edl">Taaskäivita EDLi</string>
    <string name="module_version_author">%1$s autorilt %2$s</string>
    <string name="module_state_remove">Eemalda</string>
    <string name="module_state_restore">Taasta</string>
    <string name="module_action_install_external">Installi sisemälust</string>
    <string name="update_available">Uuendus saadaval</string>
    <string name="suspend_text_riru">Moodul keelatud %1$s lubamise tõttu</string>
    <string name="suspend_text_zygisk">Moodul keelatud %1$s mittelubamise tõttu</string>
    <string name="zygisk_module_unloaded">Zygisk-moodulit ei laaditud ühildumatuse tõttu</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Teema režiim</string>
    <string name="settings_dark_mode_message">Vali režiim, mis ühtib sinu stiiliga!</string>
    <string name="settings_dark_mode_light">Alati hele</string>
    <string name="settings_dark_mode_system">Järgi süsteemi</string>
    <string name="settings_dark_mode_dark">Alati tume</string>
    <string name="settings_download_path_title">Allalaadimise failitee</string>
    <string name="settings_download_path_message">Failid salvestatakse kausta %1$s</string>
    <string name="settings_hide_app_title">Peida Magiski rakendus</string>
    <string name="settings_hide_app_summary">Paigalda juhusliku paketi-ID ja kohandatud nimega puhverrakendus</string>
    <string name="settings_restore_app_title">Taasta Magiski rakendus</string>
    <string name="settings_restore_app_summary">Too rakendus peidust välja, taastades originaalse APK</string>
    <string name="language">Keel</string>
    <string name="system_default">(Süsteemi vaikesäte)</string>
    <string name="settings_check_update_title">Kontrolli uuendusi</string>
    <string name="settings_check_update_summary">Kontrolli taustal perioodiliselt uuendusi</string>
    <string name="settings_update_channel_title">Uuenduste kanal</string>
    <string name="settings_update_stable">Stabiilne</string>
    <string name="settings_update_beta">Beeta</string>
    <string name="settings_update_custom">Kohandatud</string>
    <string name="settings_update_custom_msg">Sisesta kohandatud kanali URL</string>
    <string name="settings_zygisk_summary">Käivita teatud Magiski osi zygote-protsessis</string>
    <string name="settings_denylist_title">Jõusta keeluloend</string>
    <string name="settings_denylist_summary">Keeluloendis olevatel protsessidel tühistatakse kõik Magiski muudatused</string>
    <string name="settings_denylist_config_title">Seadista keeluloendit</string>
    <string name="settings_denylist_config_summary">Vali keeluloendisse lisatavad protsessid</string>
    <string name="settings_hosts_title">Süsteemivaba hosts</string>
    <string name="settings_hosts_summary">Süsteemivaba hosts-tugi reklaamiblokeerijatest rakendustele</string>
    <string name="settings_hosts_toast">Süsteemivaba hostsi moodul lisatud</string>
    <string name="settings_app_name_hint">Uus nimi</string>
    <string name="settings_app_name_helper">Rakendus taaspakitakse selle nimega</string>
    <string name="settings_app_name_error">Sobimatu vorming</string>
    <string name="settings_su_app_adb">Rakendused ja ADB</string>
    <string name="settings_su_app">Ainult rakendused</string>
    <string name="settings_su_adb">Ainult ADB</string>
    <string name="settings_su_disable">Keelatud</string>
    <string name="settings_su_request_10">10 sekundit</string>
    <string name="settings_su_request_15">15 sekundit</string>
    <string name="settings_su_request_20">20 sekundit</string>
    <string name="settings_su_request_30">30 sekundit</string>
    <string name="settings_su_request_45">45 sekundit</string>
    <string name="settings_su_request_60">60 sekundit</string>
    <string name="superuser_access">Superkasutaja ligipääs</string>
    <string name="auto_response">Automaatne vastus</string>
    <string name="request_timeout">Taotluse ajalõpp</string>
    <string name="superuser_notification">Superkasutaja teavitus</string>
    <string name="settings_su_reauth_title">Taas-autendi peale uuendust</string>
    <string name="settings_su_reauth_summary">Pärast rakenduste uuendamist küsi superkasutaja luba uuesti</string>
    <string name="settings_su_tapjack_title">Nupu varjamise kaitse</string>
    <string name="settings_su_tapjack_summary">Superkasutaja taotluse hüpik ei reageeri vajutusele, kui seda katab mõni teine aken või ülekate</string>
    <string name="settings_customization">Kohandamine</string>
    <string name="setting_add_shortcut_summary">Lisa avakuvale ilus otsetee juhuks, kui nime ja ikooni on pärast rakenduse peitmist raske tuvastada</string>
    <string name="settings_doh_title">DNS üle HTTPSi</string>
    <string name="settings_doh_description">Väldi mõnes riigis DNSi mürgitamist</string>

    <string name="multiuser_mode">Mitmikkasutaja režiim</string>
    <string name="settings_owner_only">Ainult seadme omanik</string>
    <string name="settings_owner_manage">Seadme omaniku hallatud</string>
    <string name="settings_user_independent">Kasutajast sõltumatu</string>
    <string name="owner_only_summary">Ainult omanikul on juurkasutaja õigused</string>
    <string name="owner_manage_summary">Ainult omanik saab hallata juurkasutaja ligipääsu ja saada taotlusküsimusi</string>
    <string name="user_independent_summary">Igal kasutajal on oma isiklikud juurkasutaja reeglid.</string>

    <string name="mount_namespace_mode">Nimeruumi monteerimisrežiim</string>
    <string name="settings_ns_global">Globaalne nimeruum</string>
    <string name="settings_ns_requester">Võta nimeruum üle</string>
    <string name="settings_ns_isolate">Isoleeritud nimeruum</string>
    <string name="global_summary">Kõik juurkasutaja sessioonid kasutavad globaalset monteerimise nimeruumi</string>
    <string name="requester_summary">Juurkasutaja sessioonid võtavad üle selle taotleja nimeruumi</string>
    <string name="isolate_summary">Iga juurkasutaja sessioon saab oma isoleeritud nimeruumi</string>

    <!--Notifications-->
    <string name="update_channel">Magiski uuendused</string>
    <string name="progress_channel">Edenemise teated</string>
    <string name="download_complete">Allalaadimine valmis</string>
    <string name="download_file_error">Faili allalaadimisel esines viga</string>
    <string name="magisk_update_title">Magiski uuendus on saadaval!</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Jah</string>
    <string name="no">Ei</string>
    <string name="repo_install_title">Installi %1$s %2$s(%3$d)</string>
    <string name="download">Allalaadimine</string>
    <string name="reboot">Taaskäivita</string>
    <string name="release_notes">Väljalaskemärkmed</string>
    <string name="flashing">Välgutamine…</string>
    <string name="done">Valmis!</string>
    <string name="failure">Ebaõnnestus</string>
    <string name="hide_app_title">Magiski rakenduse peitmine…</string>
    <string name="open_link_failed_toast">Lingi avamiseks sobivat rakendust ei leitud.</string>
    <string name="complete_uninstall">Täielik eemaldus</string>
    <string name="restore_img">Taasta tõmmised</string>
    <string name="restore_img_msg">Taastamine…</string>
    <string name="restore_done">Taastamine valmis!</string>
    <string name="restore_fail">Originaalne varundus puudub!</string>
    <string name="setup_fail">Seadistus ebaõnnnestus</string>
    <string name="env_fix_title">Vajab lisaseadistust</string>
    <string name="env_fix_msg">Sinu seade vajab Magiski korralikuks toimimiseks lisaseadistust. Kas soovid jätkata ning seadme taaskäivitada?</string>
    <string name="setup_msg">Käivitan keskkonnaseadistust…</string>
    <string name="unsupport_magisk_title">Mittetoetatud Magiski versioon</string>
    <string name="unsupport_magisk_msg">See rakenduse versioon ei toeta Magiski versioone, mis on vanemad kui %1$s.\n\nRakendus käitub nii, nagu Magisk ei olekski installitud, palun täienda Magiskit esimesel võimalusel.</string>
    <string name="unsupport_general_title">Ebanormaalne seisund</string>
    <string name="unsupport_system_app_msg">Selle rakenduse käitamine süsteemirakendusena ei ole toetatud. Palun taasta see kasutajarakenduseks.</string>
    <string name="unsupport_other_su_msg">Tuvastati \"su\"-binaar, mida ei installinud Magisk. Palun eemalda mistahes konkureeriv juurkasutaja paigaldus ja/või taasinstalli Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk on paigaldatud välismällu. Palun liiguta rakendus sisemällu.</string>
    <string name="unsupport_nonroot_stub_msg">Peidetud Magiski rakendus ei saa enam töötada, kuna juurkasutaja on kadunud. Palun taasta originaalne APK.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Selle funktsionaalsuse lubamiseks anna mäluruumi haldamise luba</string>
    <string name="add_shortcut_title">Lisa avakuvale otsetee</string>
    <string name="add_shortcut_msg">Pärast selle rakenduse peitmist võib selle nimi ja ikoon olla raskesti tuvastatav. Kas soovid avakuvale lisada ilusa otsetee?</string>
    <string name="app_not_found">Selle tegevuse teostamiseks ei leitud ühtegi rakendust</string>
    <string name="reboot_apply_change">Muudatuste rakendamiseks taaskäivita</string>
    <string name="restore_app_confirmation">See taastab peidetud rakenduse uuesti originaalseks rakenduseks. Kas soovid tõesti seda teha?</string>

</resources>

```

`app/core/src/main/res/values-fa/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">ماژول ها</string>
    <string name="superuser">کاربر روت</string>
    <string name="logs">لاگ ها</string>
    <string name="settings">تنظیمات</string>
    <string name="install">نصب</string>
    <string name="section_home">خانه</string>
    <string name="section_theme">تم ها</string>
    <string name="denylist">لیست منع</string>

    <!--Home-->
    <string name="no_connection">هیچ اتصالی وجود ندارد</string>
    <string name="app_changelog">تغییرات</string>
    <string name="loading">در حال بارگذاری…</string>
    <string name="update">بروزرسانی کردن</string>
    <string name="not_available">غیر/قابل دسترسی</string>
    <string name="hide">پنهان کردن</string>
    <string name="home_package">پکیج</string>
    <string name="home_app_title">برنامه</string>
    <string name="home_notice_content">Magisk را فقط از صفحه رسمی GitHub دانلود کنید. فایل‌ها از منابع ناشناس می‌توانند مخرب باشند!</string>
    <string name="home_follow_title">ما را دنبال کنید</string>
    <string name="home_support_title">حمایت ما</string>
    <string name="home_item_source">منبع</string>
    <string name="home_support_content">این برنامه (Magisk) رایگان و متن باز است و همیشه خواهد ماند. اگرچه شما میتواند با دونیت خود نشان دهد که به ما اهمیت می دهید.</string>
    <string name="home_installed_version">نصب شده</string>
    <string name="home_latest_version">آخرین نسخه</string>
    <string name="invalid_update_channel">کانال بروزرسانی نامعتبر است</string>
    <string name="uninstall_magisk_title">حذف Magisk</string>
    <string name="uninstall_magisk_msg">همه ماژول ها غیرفعال/حذف می شوند!\nروت حذف می شود!\nداده های شما اگر از قبل رمزگذارری نشده بودند رمز نگاری میشوند!</string>

    <!--Install-->
    <string name="keep_force_encryption">حفظ رمزگذاری اجباری</string>
    <string name="keep_dm_verity">حفظ AVB 2.0/dm-verity</string>
    <string name="recovery_mode">حالت ریکاوری</string>
    <string name="install_options_title">گزینه ها</string>
    <string name="install_method_title">روش</string>
    <string name="install_next">بعدی</string>
    <string name="install_start">بزن بریم</string>
    <string name="manager_download_install">برای دانلود و نصب فشار دهید</string>
    <string name="direct_install">نصب مستقیم (توصیه می شود)</string>
    <string name="install_inactive_slot">نصب در حافظه غیر فعال (بعد OTA)</string>
    <string name="install_inactive_slot_msg">بعد از راه اندازی مجدد دستگاه شما مجبور به راه اندازی در حافظه غیرفعال فعلی می شود! \nفقط پس از انجام OTA از این گزینه استفاده کنید. \nادامه می دهید؟</string>
    <string name="setup_title">تنظیمات اضافی</string>
    <string name="select_patch_file">یک فایل را انتخاب و پچ کنید</string>
    <string name="patch_file_msg">یک تصویر خام (*.img) یا یک فایل (ODIN (*.tar انتخاب کنید</string>
    <string name="reboot_delay_toast">راه اندازی مجدد در 5 ثانیه…</string>
    <string name="flash_screen_title">نصب و راه اندازی</string>

    <!--Superuser-->
    <string name="su_request_title">درخواست کاربر روت</string>
    <string name="touch_filtered_warning">به دلیل اینکه یک برنامه در حال پوشاندن درخواست Superuser است، Magisk نمی‌تواند پاسخ شما را تأیید کند.</string>
    <string name="deny">رد کردن</string>
    <string name="prompt">درخواست کردن</string>
    <string name="restrict">محدود کردن</string>
    <string name="grant">اجازه دادن</string>
    <string name="su_warning">دسترسی کامل به دستگاه شما را اعطا می کند. \nاگر مطمئن نیستید رد کنید!</string>
    <string name="forever">همیشه</string>
    <string name="once">یکبار</string>
    <string name="tenmin">10 دقیقه</string>
    <string name="twentymin">20 دقیقه</string>
    <string name="thirtymin">30 دقیقه</string>
    <string name="sixtymin">60 دقیقه</string>
    <string name="su_allow_toast">%1$s اجازه دسترسی به روت داده شد</string>
    <string name="su_deny_toast">%1$s اجازه دسترسی به روت رد شد</string>
    <string name="su_snack_grant">دسترسی روت به %1$s داده شده است</string>
    <string name="su_snack_deny">دسترسی روت به %1$s داده نشده است</string>
    <string name="su_snack_notif_on">اعلان های %1$s فعال است</string>
    <string name="su_snack_notif_off">اعلان های %1$s غییر فعال است</string>
    <string name="su_snack_log_on">ورود به سیستم از %1$s فعال است</string>
    <string name="su_snack_log_off">ورود به سیستم از %1$s غییر فعال است</string>
    <string name="su_revoke_title">باطل بشه؟</string>
    <string name="su_revoke_msg">تایید کنید که %1$s باطل بشه؟</string>
    <string name="toast">پیام کوتاه</string>
    <string name="none">هیچ کدام</string>
    <string name="superuser_toggle_notification">اعلان ها</string>
    <string name="superuser_toggle_revoke">ابطال</string>
    <string name="superuser_policy_none">هنوز هیچ برنامه ای مجوز روت درخواست نکرده است.</string>

    <!--Logs-->
    <string name="log_data_none">شما هیچ لاگی ندارید, سعی کنید برنامه های که به روت دسترسی میگیرند را استفاده کنید.</string>
    <string name="log_data_magisk_none">لاگ های مربوط به Magisk خالی است.</string>
    <string name="menuSaveLog">ذخیره کردن لاگ</string>
    <string name="menuClearLog">پاک کردن لاگ</string>
    <string name="logs_cleared">لاگ با موفقیت پاک شد.</string>
    <string name="pid">شناسه پردازش: %1$d</string>
    <string name="target_uid">شناسه کاربر هدف: %1$d</string>
    <string name="target_pid">شناسه پردازش هدف: %s</string>
    <string name="selinux_context">متن SELinux: %s</string>
    <string name="supp_group">گروه تکمیلی: %s</string>

    <!-- MagiskHide -->
    <string name="show_system_app">نشان دادن برنامه های سیستمی</string>
    <string name="show_os_app">نمایش برنامه‌های سیستم عامل</string>
    <string name="hide_filter_hint">فیلتر کردن با نام</string>
    <string name="hide_search">سرچ کردن</string>

    <!--Module -->
    <string name="no_info_provided">(هیچ اطلاعاتی ارائه نشده است)</string>
    <string name="reboot_userspace">راه اندازی مججد</string>
    <string name="reboot_recovery">راه اندازی مججد برای رفتن به ریکاوری</string>
    <string name="reboot_bootloader">راه اندازی مججد برای رفتن به بوت لودر</string>
    <string name="reboot_download">راه اندازی مججد برای دانلود کردن</string>
    <string name="reboot_edl">راه اندازی مججد برای رفتن به EDL</string>
    <string name="reboot_safe_mode">راه اندازی مججد برای رفتن به حالت امن</string>
    <string name="module_version_author">%1$s با %2$s</string>
    <string name="module_state_remove">حذف کردن</string>
    <string name="module_state_restore">بازگرداندن</string>
    <string name="module_action_install_external">نصب از حافظه</string>
    <string name="update_available">بروزرسانی در دسترس است</string>
    <string name="suspend_text_riru">ماژول به دلیل فعال بودن %1$s متوقف شد</string>
    <string name="suspend_text_zygisk">ماژول به دلیل غیرفعال بودن %1$s متوقف شد</string>
    <string name="zygisk_module_unloaded">ماژول Zygisk به دلیل ناسازگاری بارگذاری نشد</string>
    <string name="module_empty">هیچ ماژولی نصب نشده است</string>
    <string name="confirm_install">نصب ماژول %1$s؟</string>
    <string name="confirm_install_title">تأیید نصب</string>


    <!--Settings -->
    <string name="settings_dark_mode_title">حالت تم</string>
    <string name="settings_dark_mode_message">حالت متناسب با سبک زندگی خود را انتخاب کنید!</string>
    <string name="settings_dark_mode_light">همیشه روشن</string>
    <string name="settings_dark_mode_system">با توجه به سیستم</string>
    <string name="settings_dark_mode_dark">همیشه تاریک</string>
    <string name="settings_download_path_title">مسیر دانلود</string>
    <string name="settings_download_path_message">فایل ها در %1$s ذخیره خواهند شد.</string>
    <string name="settings_hide_app_title">مخفی کردن برنامه Magisk</string>
    <string name="settings_hide_app_summary">نصب یک برنامه پروکسی با شناسه بسته تصادفی و برچسب سفارشی</string>
    <string name="settings_restore_app_title">بازگردانی برنامه Magisk</string>
    <string name="settings_restore_app_summary">آشکار کردن برنامه و بازگرداندن APK اصلی</string>
    <string name="language">زبان</string>
    <string name="system_default">(پیش فرض سیستم)</string>
    <string name="settings_check_update_title">چک کردن بروز رسانی ها</string>
    <string name="settings_check_update_summary"> برسی کردن به صورت دوره ای برای به روزرسانی در پس زمینه</string>
    <string name="settings_update_channel_title">کانال بروزرسانی</string>
    <string name="settings_update_stable">پایدار</string>
    <string name="settings_update_beta">آزمایشی</string>
    <string name="settings_update_debug">اشکال‌زدایی</string>
    <string name="settings_update_custom">شخصی سازی شده</string>
    <string name="settings_update_custom_msg">اضافه کردن یک URL سفارشی</string>
    <string name="settings_zygisk_summary">اجرای بخش‌هایی از Magisk در سرویس Zygote</string>
    <string name="settings_denylist_title">اعمال لیست منع</string>
    <string name="settings_denylist_summary">فرآیندهای موجود در لیست منع تمام تغییرات Magisk را از دست خواهند داد</string>
    <string name="settings_denylist_config_title">پیکربندی لیست منع</string>
    <string name="settings_denylist_config_summary">انتخاب فرآیندهایی که باید در لیست منع قرار گیرند</string>
    <string name="settings_hosts_title">نصب بدون حذف یا تغییر در فایل ها</string>
    <string name="settings_hosts_summary">نصب بدون حذف یا تغییر در فایل ها رای ساپورت از برنامه های Adblock</string>
    <string name="settings_hosts_toast">ماژول نصب بدون حذف یا تغییر در فایل ها اضافه شد</string>
    <string name="settings_app_name_hint">اسم جدید</string>
    <string name="settings_app_name_helper">برنامه به این نام تغییر خواهد کرد</string>
    <string name="settings_app_name_error">فرمت نامعتبر</string>
    <string name="settings_su_app_adb">برنامه ها و ADB</string>
    <string name="settings_su_app">فقط برنامه ها</string>
    <string name="settings_su_adb">ADB فقط</string>
    <string name="settings_su_disable">غییرفعال شده</string>
    <string name="settings_su_request_10">10 ثانیه</string>
    <string name="settings_su_request_15">15 ثانیه</string>
    <string name="settings_su_request_20">20 ثانیه</string>
    <string name="settings_su_request_30">30 ثانیه</string>
    <string name="settings_su_request_45">45 ثانیه</string>
    <string name="settings_su_request_60">60 ثانیه</string>
    <string name="superuser_access">دسترسی روت</string>
    <string name="auto_response">پاسخ خودکار</string>
    <string name="request_timeout">مهلت زمانی درخواست</string>
    <string name="superuser_notification">اعلان روت</string>
    <string name="settings_su_reauth_title">احراز هویت دوباره پس از بروز رسانی</string>
    <string name="settings_su_reauth_summary">تأیید کردندوباره مجوزهای روت پس از ارتقاء برنامه</string>
    <string name="settings_su_tapjack_title">محافظت در برابر Tapjacking</string>
    <string name="settings_su_tapjack_summary">پنجره درخواست Superuser زمانی که توسط پنجره یا لایه دیگری پوشانده شود، به ورودی پاسخ نخواهد داد</string>
    <string name="settings_su_auth_title">احراز هویت کاربر</string>
    <string name="settings_su_auth_summary">درخواست احراز هویت کاربر هنگام درخواست Superuser</string>
    <string name="settings_su_auth_insecure">هیچ روش احراز هویتی روی دستگاه پیکربندی نشده است</string>
    <string name="settings_su_restrict_title">محدود کردن دسترسی روت</string>
    <string name="settings_su_restrict_summary">به طور پیش‌فرض برنامه‌های Superuser جدید را محدود می‌کند. هشدار: این کار بیشتر برنامه‌ها را از کار می‌اندازد. فقط اگر دقیقاً می‌دانید چه می‌کنید آن را فعال کنید.</string>
    <string name="settings_customization">سفارشی سازی</string>
    <string name="setting_add_shortcut_summary">اضافه کردن یک میانبر زیبا را در صفحه اصلی در صورت شناسایی نام و نماد پس از پنهان کردن برنامه</string>
    <string name="settings_doh_title">DNS روی HTTPS</string>
    <string name="settings_doh_description">دور زدن مسمومیت DNS در برخی کشورها</string>
    <string name="settings_random_name_title">تغییر تصادفی نام خروجی</string>
    <string name="settings_random_name_description">تغییر تصادفی نام فایل خروجی تصاویر و فایل‌های tar پچ‌شده برای جلوگیری از شناسایی</string>
    <string name="multiuser_mode">حالت چند کاربره</string>
    <string name="settings_owner_only">فقط صاحب دستگاه</string>
    <string name="settings_owner_manage">صاحب دستگاه مدیریت شود</string>
    <string name="settings_user_independent">مستقل از کاربر</string>
    <string name="owner_only_summary">فقط مالک دسترسی روت دارد</string>
    <string name="owner_manage_summary">فقط مالک می تواند دسترسی روت را مدیریت کرده و درخواست های پرامپت را دریافت کند</string>
    <string name="user_independent_summary">هر کاربر قوانین روت جداگانه خود را دارد</string>
    <string name="mount_namespace_mode">نصب کردن Namespace Mode</string>
    <string name="settings_ns_global">سراسری Namespace</string>
    <string name="settings_ns_requester">وراثتی Namespace</string>
    <string name="settings_ns_isolate">منزوی Namespace</string>
    <string name="global_summary">همه سشن های روت از global namespace نصب شده استفاده میکنند</string>
    <string name="requester_summary">سشن های روت namespace دراخواست کننده را به ارث می برند</string>
    <string name="isolate_summary">هر سشن روت namespace جداگانه خود را دارد</string>

    <!--Notifications-->
    <string name="update_channel">Magisk بروزرسانی های</string>
    <string name="progress_channel">اعلان پیشرفت</string>
    <string name="updated_channel">به‌روزرسانی کامل شد</string>
    <string name="download_complete">دانلود کامل شد</string>
    <string name="download_file_error">خطا در دانلود فایل</string>
    <string name="magisk_update_title">بروزرسانی Magisk در دسترس است!</string>
    <string name="updated_title">Magisk به‌روزرسانی شد</string>
    <string name="updated_text">برای باز کردن برنامه لمس کنید</string>

    <!--Toasts, Dialogs-->
    <string name="yes">بله</string>
    <string name="no">نه</string>
    <string name="repo_install_title">نصب %1$s %2$s(%3$d)</string>
    <string name="download">دانلود کردن</string>
    <string name="reboot">راه اندازی مجدد</string>
    <string name="close">بستن</string>
    <string name="release_notes">نکته های نسخه</string>
    <string name="flashing">ر حال فلش کردن…</string>
    <string name="running">در حال اجرا…</string>
    <string name="done">تمام!</string>
    <string name="done_action">انجام عملیات %1$s به پایان رسید</string>
    <string name="failure">ناموفق</string>
    <string name="hide_app_title">در حال مخفی کردن برنامه Magisk…</string>
    <string name="open_link_failed_toast">هیچ برنامه ای برای باز کردن لینک یافت نشد</string>
    <string name="complete_uninstall">کامل کردن حذف</string>
    <string name="restore_img">بازیابی تصاویر</string>
    <string name="restore_img_msg">درحال بازیابی…</string>
    <string name="restore_done">بازیابی انجام شد!</string>
    <string name="restore_fail">نسخه پشتیبان استک موجود نیست!</string>
    <string name="setup_fail">نصب انجام نشد</string>
    <string name="env_fix_title">به تنظیمات اضافی نیاز دارد</string>
    <string name="env_fix_msg">دستگاه شما به پیکربندی اضافی نیاز دارد تا Magisk به درستی کار کند. آیا می‌خواهید ادامه دهید و راه‌اندازی مجدد انجام شود؟</string>
    <string name="env_full_fix_msg">دستگاه شما نیاز به نصب دوباره Magisk دارد تا به درستی کار کند. لطفاً Magisk را از داخل برنامه دوباره نصب کنید، حالت Recovery نمی‌تواند اطلاعات دستگاه را به درستی بگیرد.</string>
    <string name="setup_msg">راه اندازی محیط نصب…</string>
    <string name="unsupport_magisk_title">نسخه پشتیبانی نشده Magisk</string>
    <string name="unsupport_magisk_msg">این نسخه از برنامه از نسخه‌های Magisk پایین‌تر از %1$s پشتیبانی نمی‌کند.\n\nبرنامه طوری رفتار می‌کند که انگار Magisk نصب نشده است. لطفاً هرچه سریع‌تر Magisk را به‌روزرسانی کنید.</string>
    <string name="unsupport_general_title">وضعیت غیرعادی</string>
    <string name="unsupport_system_app_msg">اجرای این برنامه به عنوان برنامه سیستمی پشتیبانی نمی‌شود. لطفاً آن را به برنامه کاربری بازگردانید.</string>
    <string name="unsupport_other_su_msg">یک باینری "su" غیر از Magisk شناسایی شد. لطفاً هر راهکار روت دیگری را حذف کنید و/یا Magisk را دوباره نصب کنید.</string>
    <string name="unsupport_external_storage_msg">Magisk روی حافظه خارجی نصب شده است. لطفاً برنامه را به حافظه داخلی منتقل کنید.</string>
    <string name="unsupport_nonroot_stub_msg">برنامه مخفی Magisk نمی‌تواند ادامه دهد زیرا دسترسی روت از بین رفته است. لطفاً APK اصلی را بازگردانید.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">برای فعال کردن این قابلیت ، اجازه دسترسی به حافظه بدهید</string>
    <string name="post_notifications_denied">برای فعال‌سازی این قابلیت، مجوز اعلان‌ها را بدهید</string>
    <string name="install_unknown_denied">برای فعال‌سازی این قابلیت، «نصب برنامه‌های ناشناخته» را مجاز کنید</string>
    <string name="add_shortcut_title">اضافه کردن میانبر را به صفحه</string>
    <string name="add_shortcut_msg">بعد از مخفی کردن این برنامه، ممکن است نام و آیکون آن سخت قابل شناسایی شود. آیا می‌خواهید یک میانبر زیبا به صفحه اصلی اضافه کنید؟</string>
    <string name="app_not_found">هیچ برنامه‌ای برای انجام این عملیات یافت نشد</string>
    <string name="reboot_apply_change">برای اعمال تغییرات، دستگاه را دوباره راه‌اندازی کنید</string>
    <string name="restore_app_confirmation">این کار برنامه مخفی شده را به نسخه اصلی بازمی‌گرداند. آیا واقعاً می‌خواهید این کار را انجام دهید؟</string>

</resources>

```

`app/core/src/main/res/values-fr/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Modules</string>
    <string name="superuser">Super‑utilisateur</string>
    <string name="logs">Journaux</string>
    <string name="settings">Paramètres</string>
    <string name="install">Installer</string>
    <string name="section_home">Accueil</string>
    <string name="section_theme">Thèmes</string>
    <string name="denylist">Liste Refus</string>

    <!--Home-->
    <string name="no_connection">Aucune connexion disponible</string>
    <string name="app_changelog">Journal des modifications</string>
    <string name="loading">Chargement…</string>
    <string name="update">Mettre à jour</string>
    <string name="not_available">Non disponible</string>
    <string name="hide">Masquer</string>
    <string name="home_package">Paquet</string>
    <string name="home_app_title">Application</string>

    <string name="home_notice_content">Ne téléchargez Magisk qu’uniquement depuis la page GitHub officielle. Les fichiers provenant de sources inconnues peuvent être malveillants !</string>
    <string name="home_support_title">Soutenez‑nous</string>
    <string name="home_follow_title">Suivez-nous</string>
    <string name="home_item_source">Sources</string>
    <string name="home_support_content">Magisk est, et sera toujours, libre et open source. Vous pouvez cependant nous témoigner de votre soutien en envoyant un petit don.</string>
    <string name="home_installed_version">Version installée</string>
    <string name="home_latest_version">Dernière version</string>
    <string name="invalid_update_channel">Canal de mise à jour invalide</string>
    <string name="uninstall_magisk_title">Désinstaller Magisk</string>
    <string name="uninstall_magisk_msg">Tous les modules seront désactivés ou supprimés !\nL’accès super‑utiliateur sera perdu !\nVos données seront potentiellement chiffrées si elles ne le sont pas déjà.</string>

    <!--Install-->
    <string name="keep_force_encryption">Conserver le chiffrement forcé</string>
    <string name="keep_dm_verity">Conserver AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Mode récupération</string>
    <string name="install_options_title">Options</string>
    <string name="install_method_title">Méthode</string>
    <string name="install_next">Suivant</string>
    <string name="install_start">C’est parti</string>
    <string name="manager_download_install">Appuyez pour le télécharger et l’installer</string>
    <string name="direct_install">Installation directe (recommandée)</string>
    <string name="install_inactive_slot">Installer dans l’espace inactif (après mise à jour OTA)</string>
    <string name="install_inactive_slot_msg">Votre appareil sera obligatoirement réamorcé à partir de l’espace (slot) actuellement inactif après son redémarrage !\nN’utilisez uniquement cette option qu’après que la mise à jour OTA a été effectuée.\nVoulez‑vous continuer ?</string>
    <string name="setup_title">Configuration supplémentaire</string>
    <string name="select_patch_file">Sélectionnez le fichier cible du correctif</string>
    <string name="patch_file_msg">Sélectionnez une image brute (*.img) ou une archive TAR ODIN (*.tar) ou un fichier payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">Redémarrage dans 5 secondes…</string>
    <string name="flash_screen_title">Installation</string>

    <!--Superuser-->
    <string name="su_request_title">Demande d’accès super‑utilisateur</string>
    <string name="touch_filtered_warning">Magisk ne peut vérifier votre réponse parce qu’une application masque une requête de super‑utilisateur</string>
    <string name="deny">Refuser</string>
    <string name="prompt">Demander</string>
    <string name="grant">Accorder</string>
    <string name="su_warning">Autoriser l’accès complet à votre appareil.\nRefusez en cas de doute !</string>
    <string name="forever">Toujours</string>
    <string name="once">Une fois</string>
    <string name="tenmin">10 min</string>
    <string name="twentymin">20 min</string>
    <string name="thirtymin">30 min</string>
    <string name="sixtymin">60 min</string>
    <string name="su_allow_toast">%1$s a obtenu les droits de super‑utilisateur</string>
    <string name="su_deny_toast">%1$s s’est vu refuser les droits de super‑utilisateur</string>
    <string name="su_snack_grant">Les droits de super‑utilisateur sont accordés à %1$s</string>
    <string name="su_snack_deny">Les droits de super‑utilisateur sont refusés à %1$s</string>
    <string name="su_snack_notif_on">Les notifications sont activées pour %1$s</string>
    <string name="su_snack_notif_off">Les notifications sont désactivées pour %1$s</string>
    <string name="su_snack_log_on">La journalisation est activée pour %1$s</string>
    <string name="su_snack_log_off">La journalisation est désactivée pour %1$s</string>
    <string name="su_revoke_title">Révoquer ?</string>
    <string name="su_revoke_msg">Confirmez‑vous la révocation des droits accordés à %1$s ?</string>
    <string name="toast">Bulle de notification</string>
    <string name="none">Aucune</string>

    <string name="superuser_toggle_notification">Notifications</string>
    <string name="superuser_toggle_revoke">Révoquer</string>
    <string name="superuser_policy_none">Aucune application n’a encore demandé de droits super‑utilisateur.</string>

    <!--Logs-->
    <string name="log_data_none">Aucune information n’est journalisée, essayez d’utiliser davantage vos applications sollicitant des droits de super‑utilisateur.</string>
    <string name="log_data_magisk_none">Les journaux de Magisk sont vides, c’est étrange.</string>
    <string name="menuSaveLog">Enregistrer le journal</string>
    <string name="menuClearLog">Effacer le journal maintenant</string>
    <string name="logs_cleared">Le journal a été effacé.</string>
    <string name="pid">PID : %1$d</string>
    <string name="target_uid">UID cible : %1$d</string>
    <string name="target_pid">Montage ns PID cible: %s</string>
    <string name="selinux_context">Contexte SELinux: %s</string>
    <string name="supp_group">Groupe supplémentaire: %s</string>

    <!--SafetyNet-->

    <!-- MagiskHide -->
    <string name="show_system_app">Afficher les applications système</string>
    <string name="show_os_app">Afficher les applications intégrées au système</string>
    <string name="hide_filter_hint">Filtrer par nom</string>
    <string name="hide_search">Rechercher</string>

    <!--Module -->
    <string name="no_info_provided">(aucune info transmise)</string>
    <string name="reboot_userspace">Redémarrage à chaud</string>
    <string name="reboot_recovery">Redémarrer en mode récupération</string>
    <string name="reboot_bootloader">Redémarrer en mode amorçage</string>
    <string name="reboot_download">Redémarrer en mode téléchargement</string>
    <string name="reboot_edl">Redémarrer en mode secours (EDL)</string>
    <string name="reboot_safe_mode">Mode sans échec</string>
    <string name="module_version_author">%1$s, par %2$s</string>
    <string name="module_state_remove">Supprimer</string>
    <string name="module_state_restore">Restaurer</string>
    <string name="module_action_install_external">Installer depuis le stockage</string>
    <string name="update_available">Mise à jour disponible</string>
    <string name="suspend_text_riru">Module suspendu car %1$s est actif</string>
    <string name="suspend_text_zygisk">Module suspendu car %1$s n’est pas actif</string>
    <string name="zygisk_module_unloaded">Module Zygisk non chargé en raison d’une incompatibilité</string>
    <string name="module_empty">Aucun module installé</string>
    <string name="confirm_install">Installer le module %1$s?</string>
    <string name="confirm_install_title">Confirmer l’installation</string>

    <!--Settings -->
    <string name="settings_dark_mode_title">Mode du thème</string>
    <string name="settings_dark_mode_message">Choisissez le mode qui correspond le mieux à votre style !</string>
    <string name="settings_dark_mode_light">Toujours clair</string>
    <string name="settings_dark_mode_system">Identique au système</string>
    <string name="settings_dark_mode_dark">Toujours sombre</string>
    <string name="settings_download_path_title">Répertoire de téléchargement</string>
    <string name="settings_download_path_message">Les fichiers seront enregistrés sous %1$s</string>
    <string name="settings_hide_app_title">Masquer l’application Magisk</string>
    <string name="settings_hide_app_summary">Installer une application intermédiaire avec un identifiant de paquet aléatoire et un nom personnalisé</string>
    <string name="settings_restore_app_title">Restaurer l’application Magisk</string>
    <string name="settings_restore_app_summary">Démasquer l’application et la restaurer comme son APK d’origine.</string>
    <string name="language">Langue</string>
    <string name="system_default">(langue par défaut du système)</string>
    <string name="settings_check_update_title">Vérifier les mises à jour</string>
    <string name="settings_check_update_summary">Vérifier périodiquement en tâche de fond l’existence d’une mise à jour.</string>
    <string name="settings_update_channel_title">Canal de mise à jour</string>
    <string name="settings_update_stable">Stable</string>
    <string name="settings_update_beta">Bêta</string>
    <string name="settings_update_custom">Canal personnalisé</string>
    <string name="settings_update_custom_msg">Saisissez une URL personnalisée</string>
    <string name="settings_zygisk_summary">Exécuter des parties de Magisk dans le service zygote</string>
    <string name="settings_denylist_title">Imposer Liste Exclusion</string>
    <string name="settings_denylist_summary">Les processus figurant sur la liste des exclusions verront toutes les modifications de Magisk annulées.</string>
    <string name="settings_denylist_config_title">Configurer Liste Exclusion</string>
    <string name="settings_denylist_config_summary">Sélectionner le processus à inclure dans la liste d’exclusion</string>
    <string name="settings_hosts_title">Fichier d’hôtes hors partition système</string>
    <string name="settings_hosts_summary">Utilisation d’un fichier d’hôtes hors de la partition système pour les applications de blocage de publicité.</string>
    <string name="settings_hosts_toast">Ajout d’un module pour fichier hosts hors système</string>
    <string name="settings_app_name_hint">Nouveau nom</string>
    <string name="settings_app_name_helper">L’application sera réempaquetée sous ce nom</string>
    <string name="settings_app_name_error">Format incorrect</string>
    <string name="settings_su_app_adb">Applications et ADB</string>
    <string name="settings_su_app">Applications uniquement</string>
    <string name="settings_su_adb">ADB uniquement</string>
    <string name="settings_su_disable">Désactivé</string>
    <string name="settings_su_request_10">10 secondes</string>
    <string name="settings_su_request_15">15 secondes</string>
    <string name="settings_su_request_20">20 secondes</string>
    <string name="settings_su_request_30">30 secondes</string>
    <string name="settings_su_request_45">45 secondes</string>
    <string name="settings_su_request_60">60 secondes</string>
    <string name="superuser_access">Accès super‑utilisateur</string>
    <string name="auto_response">Réponse automatique</string>
    <string name="request_timeout">Délai d’expiration de la demande</string>
    <string name="superuser_notification">Notification super‑utilisateur</string>
    <string name="settings_su_reauth_title">S’authentifier à nouveau après la mise à niveau</string>
    <string name="settings_su_reauth_summary">Redemander une authentification pour autoriser l’accès en super‑utilisateur après une mise à jour de l’application</string>
    <string name="settings_su_tapjack_title">Activer la protection contre le détournement du tapotement</string>
    <string name="settings_su_tapjack_summary">Le dialogue d’invite du super‑utilisateur ne répondra pas à la saisie lorsqu’il est masqué par une autre fenêtre ou une surcouche</string>
    <string name="settings_su_auth_title">Authentification utilisateur</string>
    <string name="settings_su_auth_summary">Demander l’authentification utilisateur lors de la requête super-utilisateur</string>
    <string name="settings_su_auth_insecure">Aucun méthode d’authentification utilisateur n’est configurée sur le périphérique</string>
    <string name="settings_customization">Personnalisation</string>
    <string name="setting_add_shortcut_summary">Ajouter un joli raccourci dans l’écran d’accueil au cas où le nom et l’icône seraient difficiles à reconnaître après avoir masqué l’application</string>
    <string name="settings_doh_title">DNS sur HTTPS</string>
    <string name="settings_doh_description">Contournement de la censure du DNS dans certains pays</string>
    <string name="settings_random_name_title">Nom de sortie aléatoire</string>
    <string name="settings_random_name_description">Randomiser le nom du fichier de sortie des images modifiées et des fichiers tar afin d’éviter la détection.</string>

    <string name="multiuser_mode">Mode multi‑utilisateur</string>
    <string name="settings_owner_only">Propriétaire de l’appareil uniquement</string>
    <string name="settings_owner_manage">Géré par le propriétaire de l’appareil</string>
    <string name="settings_user_independent">Indépendant de l’utilisateur</string>
    <string name="owner_only_summary">Seul le propriétaire possède un accès super‑utilisateur.</string>
    <string name="owner_manage_summary">Seul le propriétaire peut gérer l’accès super‑utilisateur et recevoir les demandes d’accès.</string>
    <string name="user_independent_summary">Chaque utilisateur a ses propres règles d’accès super‑utilisateur distinctes.</string>

    <string name="mount_namespace_mode">Mode d’espace de noms du montage</string>
    <string name="settings_ns_global">Espace de noms global</string>
    <string name="settings_ns_requester">Hériter de l’espace de noms</string>
    <string name="settings_ns_isolate">Espace de noms isolé</string>
    <string name="global_summary">Toutes les sessions super‑utilisateur utilisent l’espace de noms global du montage.</string>
    <string name="requester_summary">Les sessions super‑utilisateur hériteront de l’espace de noms de leur demandeur.</string>
    <string name="isolate_summary">Chaque session super‑utilisateur aura son propre espace de noms isolé.</string>

    <!--Notifications-->
    <string name="update_channel">Mises à jour de Magisk</string>
    <string name="progress_channel">Notifications de progression</string>
    <string name="updated_channel">Mise à jour Terminée</string>
    <string name="download_complete">Téléchargement terminé</string>
    <string name="download_file_error">Erreur lors du téléchargement du fichier</string>
    <string name="magisk_update_title">Une mise à jour de Magisk est disponible !</string>
    <string name="updated_title">Magisk Mis à jour</string>
    <string name="updated_text">Appuyer pour ouvrir l’application</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Oui</string>
    <string name="no">Non</string>
    <string name="repo_install_title">Installer %1$s %2$s(%3$d)</string>
    <string name="download">Télécharger</string>
    <string name="reboot">Redémarrer</string>
    <string name="release_notes">Notes de version</string>
    <string name="flashing">Écriture en mémoire Flash…</string>
    <string name="done">Terminé !</string>
    <string name="failure">Erreur</string>
    <string name="hide_app_title">Masquage de l’application Magisk…</string>
    <string name="open_link_failed_toast">Aucune application permettant d’ouvrir le lien n’a été trouvée</string>
    <string name="complete_uninstall">Désinstallation complète</string>
    <string name="restore_img">Restauration des images</string>
    <string name="restore_img_msg">Restauration…</string>
    <string name="restore_done">Restauration effectuée !</string>
    <string name="restore_fail">La sauvegarde par défaut n’existe pas !</string>
    <string name="setup_fail">Échec de l’installation</string>
    <string name="env_full_fix_msg">Votre périphérique nécessite de réinstaller Magisk pour fonctionner correctement. Merci de réinstaller Magisk par l’application, le mode de récupération ne pouvant pas récupérer les informations correctement.</string>
    <string name="env_fix_title">Installation supplémentaire requise</string>
    <string name="env_fix_msg">Votre appareil a besoin d’une installation supplémentaire afin que Magisk fonctionne correctement. Voulez‑vous effectuer cette installation maintenant puis redémarrer ?</string>
    <string name="setup_msg">Configuration de l’environnement en cours…</string>
    <string name="unsupport_magisk_title">Version de Magisk non prise en charge</string>
    <string name="unsupport_magisk_msg">Cette version de Magisk Manager ne prend pas en charge les versions de Magisk inférieures à %1$s.\n\nL’application se comportera comme si Magisk n’était pas installé. Veuillez mettre à jour Magisk aussi vite que possible.</string>
    <string name="unsupport_general_title">État anormal</string>
    <string name="unsupport_system_app_msg">Cette application ne peut être installée en tant qu’application système. Veuillez la restaurer en tant qu’application utilisateur.</string>
    <string name="unsupport_other_su_msg">Une commande « su » n’appartenant pas à Magisk a été détectée. Merci de supprimer cet autre « su » qui n’est pas pris en charge.</string>
    <string name="unsupport_external_storage_msg">Magisk Manager est installé sur le stockage externe. Veuillez déplacer l’application sur le stockage interne.</string>
    <string name="unsupport_nonroot_stub_msg">Cette application ne peut continuer à fonctionner en étant masquée car l’accès en tant que super‑utilisateur a été perdu. Merci de restaurer l’APK originel.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Permettre l’accès au stockage pour activer cette fonctionnalité</string>
    <string name="post_notifications_denied">Permettre l’accès aux notifications pour activer cette fonctionnalité</string>
    <string name="install_unknown_denied">Autoriser "installation d’applications inconnues" pour activer cette fonctionnalité</string>
    <string name="add_shortcut_title">Ajouter un raccourci à l’écran d’accueil</string>
    <string name="add_shortcut_msg">Après avoir masqué Magisk, son nom et son icône peuvent devenir difficiles à reconnaître. Voulez‑vous ajouter un joli raccourci vers l’écran d’accueil ?</string>
    <string name="app_not_found">Aucune application n’a été trouvée pour gérer cette action</string>
    <string name="reboot_apply_change">Redémarrer pour appliquer les changements</string>
    <string name="restore_app_confirmation">Cela restaurera l’application cachée en application originale. Vous voulez vraiment faire ça ?</string>

</resources>

```

`app/core/src/main/res/values-hi/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">मॉड्यूल</string>
    <string name="superuser">सुपर यूज़र</string>
    <string name="logs">लॉग्स</string>
    <string name="settings">सेटिंग्स</string>
    <string name="install">इंस्टॉल</string>
    <string name="section_home">होम</string>
    <string name="section_theme">थीम</string>
    <string name="denylist">अस्वीकार सूची</string>

    <!--Home-->
    <string name="no_connection">कोई कनेक्शन उपलब्ध नहीं है</string>
    <string name="app_changelog">बदलाव</string>
    <string name="loading">लोड हो रहा है…</string>
    <string name="update">अद्यतन करें</string>
    <string name="not_available">उपलब्ध नहीं है</string>
    <string name="hide">छिपाएँ</string>
    <string name="home_package">पैकेज</string>
    <string name="home_app_title">ऐप</string>

    <string name="home_notice_content">मैजिस्क केवल आधिकारिक गिटहब पृष्ठ पेज से डाउनलोड करें। अज्ञात स्रोतों से फ़ाइलें दुर्भावनापूर्ण हो सकती हैं!</string>
    <string name="home_support_title">हमें सहयोग दीजिये</string>
    <string name="home_follow_title">अनुसरण करें</string>
    <string name="home_item_source">स्रोत</string>
    <string name="home_support_content">मैजिस्क है, और हमेशा मुफ्त और ओपन-सोर्स रहेगा। हालाँकि आप एक छोटा सा दान भेजकर हमारी मदद कर सकते है।</string>
    <string name="home_installed_version">इंस्टॉल्ड</string>
    <string name="home_latest_version">नवीनतम</string>
    <string name="invalid_update_channel">अमान्य अपडेट चैनल</string>
    <string name="uninstall_magisk_title">मैजिस्क को अनइंस्टॉल करें</string>
    <string name="uninstall_magisk_msg">सभी मॉड्यूल्स को निष्क्रिय/हटा दिया जाएगा!\n रूट को हटा दिया जाएगा!\n आपका डेटा संभावित रूप से एन्क्रिप्ट किया गया है यदि पहले से नहीं है!</string>

    <!--Install-->
    <string name="keep_force_encryption">फ़ोर्स एन्क्रिप्शन को संरक्षित रखें</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity को संरक्षित रखें</string>
    <string name="recovery_mode">रिकवरी मोड</string>
    <string name="install_options_title">विकल्प</string>
    <string name="install_method_title">तरीका</string>
    <string name="install_next">आगे</string>
    <string name="install_start">तो चलिए शुरू करते हैं!</string>
    <string name="manager_download_install">डाउनलोड और इंस्टॉल करने के लिए दबाएं</string>
    <string name="direct_install">प्रत्यक्ष इंस्टॉल (अनुशंसित)</string>
    <string name="install_inactive_slot">निष्क्रिय स्लॉट में इंस्टॉल करें (OTA के बाद)</string>
    <string name="install_inactive_slot_msg">आपका डिवाइस रीबूट होने के बाद वर्तमान निष्क्रिय स्लॉट में बूट करने के लिए मजबूर किया जाएगा!\n इस विकल्प का उपयोग सिर्फ OTA हो जाने के बाद करें।\n जारी रखें?</string>
    <string name="setup_title">अतिरिक्त सेटअप</string>
    <string name="select_patch_file">एक फ़ाइल का चयन और पैच करें</string>
    <string name="patch_file_msg">एक रॉ छवि (* .img) या एक ODIN tarfile (* .tar) का चयन करें</string>
    <string name="reboot_delay_toast">5 सेकंड में रिबूट हो रहा है...</string>
    <string name="flash_screen_title">इंस्टॉलेशन</string>

    <!--Superuser-->
    <string name="su_request_title">सुपरयूज़र अनुरोध</string>
    <string name="touch_filtered_warning">चूंकि एक ऐप सुपरयूज़र अनुरोध को अस्पष्ट कर रहा है, इसलिए मैजिस्क आपकी प्रतिक्रिया को सत्यापित नहीं कर सकता</string>
    <string name="deny">इंकार करें</string>
    <string name="prompt">संकेत दिखाएँ</string>
    <string name="grant">अनुमति दें</string>
    <string name="su_warning">यह आपके डिवाइस की पूरी पहुँच की अनुमति देगा,\n यदि आप सुनिश्चित नहीं हैं तो इंकार करें!</string>
    <string name="forever">सदैव</string>
    <string name="once">एक बार</string>
    <string name="tenmin">10 मिनिट</string>
    <string name="twentymin">20 मिनट</string>
    <string name="thirtymin">30 मिनट</string>
    <string name="sixtymin">60 मिनट</string>
    <string name="su_allow_toast"> %1$s को सुपरयूज़र अधिकार प्रदान किया गया</string>
    <string name="su_deny_toast"> %1$s को सुपरयूज़र अधिकार से इंकार किया गया</string>
    <string name="su_snack_grant"> %1$s को सुपरयूज़र अधिकार प्रदान किए गए </string>
    <string name="su_snack_deny"> %1$s के सुपरयूज़र अधिकारों को अस्वीकार कर दिया गया है</string>
    <string name="su_snack_notif_on"> %1$s की सूचनाएं सक्षम हैं</string>
    <string name="su_snack_notif_off"> %1$s की सूचनाएं अक्षम हैं</string>
    <string name="su_snack_log_on"> %1$s की लॉगिंग सक्षम है</string>
    <string name="su_snack_log_off"> %1$s की लॉगिंग अक्षम है</string>
    <string name="su_revoke_title">अधिकार वापस लें?</string>
    <string name="su_revoke_msg"> %1$s के अधिकारों को रद्द करने की पुष्टि करें?</string>
    <string name="toast">पॉप-अप सूचना</string>
    <string name="none">कोई नहीं</string>

    <string name="superuser_toggle_notification">सूचनाएं</string>
    <string name="superuser_toggle_revoke">अधिकार वापस लें</string>
    <string name="superuser_policy_none">किसी भी ऐप ने अभी तक सुपरयूज़र की अनुमति नहीं मांगी है।</string>

    <!--Logs-->
    <string name="log_data_none">कोई लॉग नहीं, अपने सुपरयूज़र सक्षम एप्लिकेशन का अधिक उपयोग करने का प्रयास करें।</string>
    <string name="log_data_magisk_none">मैजिस्क लॉग खाली हैं, यह अजीब है।</string>
    <string name="menuSaveLog">लॉग सहेजे</string>
    <string name="menuClearLog">लॉग साफ़ करें</string>
    <string name="logs_cleared">लॉग सफलतापूर्वक साफ़ किया गया।</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">लक्षित UID: %1$d</string>

    <!--SafetyNet-->

    <!-- MagiskHide -->
    <string name="show_system_app">सिस्टम ऐप्स दिखाएं</string>
    <string name="show_os_app">OS एप्लिकेशन दिखाएं</string>
    <string name="hide_filter_hint">नाम से फ़िल्टर करें</string>
    <string name="hide_search">खोजें</string>

    <!--Module -->
    <string name="no_info_provided">(कोई जानकारी नहीं दी गई)</string>
    <string name="reboot_userspace">सॉफ्ट रिबूट</string>
    <string name="reboot_recovery">रिकवरी रिबूट</string>
    <string name="reboot_bootloader">बूटलोडर रिबूट</string>
    <string name="reboot_download">डाउनलोड मोड रिबूट</string>
    <string name="reboot_edl">EDL रिबूट</string>
    <string name="module_version_author"> %2$s के द्वारा %1$s</string>
    <string name="module_state_remove">हटाएँ</string>
    <string name="module_state_restore">रिस्टोर करें</string>
    <string name="module_action_install_external">स्टोरेज से इनस्टॉल करें</string>
    <string name="update_available">अपडेट उपलब्ध</string>
    <string name="suspend_text_riru">%1$s सक्रिय होने के कारण मॉड्यूल निलंबित</string>
    <string name="suspend_text_zygisk">%1$s अक्षम होने के कारण मॉड्यूल निलंबित</string>
    <string name="zygisk_module_unloaded">Zygisk मॉड्यूल असंगतता के कारण लोड होने में असमर्थ</string>
    <string name="module_empty">कोई मॉड्यूल इंस्टॉल्ड नहीं</string>

    <!--Settings -->
    <string name="settings_dark_mode_title">थीम मोड</string>
    <string name="settings_dark_mode_message">ऐसी थीम का चयन करें जो आपकी शैली के अनुकूल हो!</string>
    <string name="settings_dark_mode_light">हमेशा सफेद रंग वाली</string>
    <string name="settings_dark_mode_system">सिस्टम के अनुसार</string>
    <string name="settings_dark_mode_dark">डार्क मोड</string>
    <string name="settings_download_path_title">डाउनलोड पथ</string>
    <string name="settings_download_path_message">फ़ाइलों को %1$s में सहेजा जाएगा</string>
    <string name="settings_hide_app_title">मैजिस्क ऐप को छिपाएं</string>
    <string name="settings_hide_app_summary">रैंडम पैकेज आईडी और कस्टम ऐप लेबल के साथ प्रॉक्सी ऐप इंस्टॉल करें</string>
    <string name="settings_restore_app_title">मैजिस्क ऐप को पुनर्स्थापित करें</string>
    <string name="settings_restore_app_summary">ऐप को उनहीदे करें और मूल एपीके को पुनर्स्थापित करें</string>
    <string name="language">भाषा</string>
    <string name="system_default">(सिस्टम डिफ़ॉल्ट)</string>
    <string name="settings_check_update_title">अपडेट जांचें</string>
    <string name="settings_check_update_summary">समय-समय पर बैकग्राउंड में अपडेट की जांच करते रहें</string>
    <string name="settings_update_channel_title">अपडेट चैनल</string>
    <string name="settings_update_stable">स्टेबल</string>
    <string name="settings_update_beta">बीटा</string>
    <string name="settings_update_custom">कस्टम चैनल</string>
    <string name="settings_update_custom_msg">एक कस्टम URL डालें</string>
    <string name="settings_zygisk_summary">मैजिस्क को जाइगोट डेमॉन के कुछ हिस्सों को चलाएं</string>
    <string name="settings_denylist_title">अस्वीकार सूची लागू करें</string>
    <string name="settings_denylist_summary">अस्वीकृत सूची की प्रक्रियाओं में सभी मैजिस्क संशोधन पूर्ववत हो जाएंगे</string>
    <string name="settings_denylist_config_title">अस्वीकार सूची कॉन्फ़िगर करें</string>
    <string name="settings_denylist_config_summary">अस्वीकार सूची में शामिल की जाने वाली प्रक्रियाओं का चयन करें</string>
    <string name="settings_hosts_title">सिस्टमलेस होस्ट</string>
    <string name="settings_hosts_summary">विज्ञापन ब्लॉक ऐप्स के लिए सिस्टमलेस होस्ट समर्थन:</string>
    <string name="settings_hosts_toast">सिस्टमलेस होस्ट मॉड्यूल जोड़ा गया</string>
    <string name="settings_app_name_hint">नया नाम</string>
    <string name="settings_app_name_helper">इस नाम से ऐप को फिर से इंस्टॉल किया जाएगा</string>
    <string name="settings_app_name_error">अवैध प्रारूप</string>
    <string name="settings_su_app_adb">ऐप्स और एडीबी</string>
    <string name="settings_su_app">केवल ऐप्स</string>
    <string name="settings_su_adb">केवल एडीबी</string>
    <string name="settings_su_disable">बंद है</string>
    <string name="settings_su_request_10">10 सेकंड</string>
    <string name="settings_su_request_15">15 सेकंड</string>
    <string name="settings_su_request_20">20 सेकंड</string>
    <string name="settings_su_request_30">30 सेकंड</string>
    <string name="settings_su_request_45">45 सेकंड</string>
    <string name="settings_su_request_60">60 सेकंड</string>
    <string name="superuser_access">सुपरयूज़र एक्सेस</string>
    <string name="auto_response">स्वचालित प्रतिक्रिया</string>
    <string name="request_timeout">अनुरोध की समय समाप्ति सीमा</string>
    <string name="superuser_notification">सुपरयूज़र सूचना</string>
    <string name="settings_su_reauth_title">अपग्रेड के बाद प्रमाणीकरण</string>
    <string name="settings_su_reauth_summary">एक ऐप अपडेट होने के बाद सुपरयूज़र अनुमति प्रमाणित करें</string>
    <string name="settings_su_tapjack_title">टैपजैकिंग सुरक्षा</string>
    <string name="settings_su_tapjack_summary">सुपरयुसर प्रॉम्प्ट डायलॉग किसी अन्य विंडो या ओवरले द्वारा अस्पष्ट होने पर इनपुट का जवाब नहीं देगा</string>
    <string name="settings_customization">कस्टमाईजेशन</string>
    <string name="setting_add_shortcut_summary">ऐप को छिपाने के बाद नाम और आइकन को पहचानना मुश्किल है, तो होम स्क्रीन में एक सुंदर शॉर्टकट जोड़ें</string>
    <string name="settings_doh_title">HTTPS पर DNS</string>
    <string name="settings_doh_description">कुछ राष्ट्रों में चल रही DNS विषाक्तता का समाधान</string>

    <string name="multiuser_mode">बहु उपयोगकर्ता मोड</string>
    <string name="settings_owner_only">केवल डिवाइस का मालिक</string>
    <string name="settings_owner_manage">डिवाइस मालिक द्वारा प्रबंधित</string>
    <string name="settings_user_independent"> स्वत्रंत उपयोगकर्ता</string>
    <string name="owner_only_summary">केवल मालिक के पास ही रूट की पहुँच है</string>
    <string name="owner_manage_summary">केवल मालिक रूट एक्सेस का प्रबंधन कर सकते हैं और अनुरोध संकेत प्राप्त कर सकते हैं</string>
    <string name="user_independent_summary">प्रत्येक उपयोगकर्ता का अपना अलग रूट नियम होता है</string>

    <string name="mount_namespace_mode">माउंट नेमस्पेस मोड</string>
    <string name="settings_ns_global">ग्लोबल नेमस्पेस</string>
    <string name="settings_ns_requester">इनहेरिट नेमस्पेस</string>
    <string name="settings_ns_isolate">आइसोलेटेड नेमस्पेस</string>
    <string name="global_summary">सभी रूट सत्र ग्लोबल नेमस्पेस का उपयोग करते हैं</string>
    <string name="requester_summary">रूट सत्रों को उनके अनुरोधकर्ताओं के नेमस्पेस विरासत में मिलेंगे</string>
    <string name="isolate_summary">प्रत्येक रूट सत्र का अपना अलग आइसोलेटेड नेमस्पेस होगा</string>

    <!--Notifications-->
    <string name="update_channel">मैजिस्क अपडेट</string>
    <string name="progress_channel">प्रगति सूचनाएँ</string>
    <string name="updated_channel">अपडेट पूरा हुआ</string>
    <string name="download_complete">डाउनलोड सम्पन्न हुआ</string>
    <string name="download_file_error">फ़ाइल डाउनलोड करने में त्रुटि</string>
    <string name="magisk_update_title">मैजिस्क अपडेट उपलब्ध है!</string>
    <string name="updated_title">मैजिस्क अपडेट पूरा हुआ</string>
    <string name="updated_text">ऐप खोलने के लिए टैप करें</string>

    <!--Toasts, Dialogs-->
    <string name="yes">हाँ</string>
    <string name="no">नहीं</string>
    <string name="repo_install_title">इंस्टॉल %1$s %2$s(%3$d)</string>
    <string name="download">डाउनलोड</string>
    <string name="reboot">रीबूट</string>
    <string name="release_notes">रिलीज नोट्स</string>
    <string name="flashing">फ़्लैश हो रहा है...</string>
    <string name="done">सफल हुआ!</string>
    <string name="failure">असफल हुआ !</string>
    <string name="hide_app_title">मैजिस्क ऐप अब छिप रहा है…</string>
    <string name="open_link_failed_toast">लिंक खोलने के लिए कोई एप्लिकेशन नहीं मिला</string>
    <string name="complete_uninstall">पूर्ण रूप से अनइंस्टॉल करें</string>
    <string name="restore_img">इमेज रिस्टोर करें</string>
    <string name="restore_img_msg">रिस्टोर हो रहा है...</string>
    <string name="restore_done">रिस्टोर सफल हुआ!</string>
    <string name="restore_fail">स्टॉक बैकअप मौजूद नहीं है!</string>
    <string name="setup_fail">सेटअप असफल हुआ</string>
    <string name="env_fix_title">अतिरिक्त सेटअप की आवश्यकता</string>
    <string name="env_fix_msg">मैजिस्क के ठीक से काम करने के लिए आपके डिवाइस को अतिरिक्त सेटअप की आवश्यकता है। क्या आप आगे बढ़ना और रिबूट करना चाहते हैं?</string>
    <string name="setup_msg">वातावरण सेटअप चल रहा है...</string>
    <string name="unsupport_magisk_title">असमर्थित मैजिस्क संस्करण</string>
    <string name="unsupport_magisk_msg">ऐप का यह संस्करण %1$s से कम के मैजिस्क संस्करणों का समर्थन नहीं करता है।\n\nऐप ऐसा व्यवहार करेगा जैसे कोई मैजिस्क इंस्टॉल नहीं है, कृपया जितनी जल्दी हो सके मैजिस्क को अपग्रेड करें।</string>
    <string name="unsupport_general_title">असामान्य अवस्था</string>
    <string name="unsupport_system_app_msg">इस ऐप को सिस्टम ऐप के रूप में चलाना समर्थित नहीं है। कृपया ऐप को उपयोगकर्ता ऐप पर वापस लाएं।</string>
    <string name="unsupport_other_su_msg">एक \"su\" बाइनरी का पता चला है जो मैजिस्क से नहीं है। कृपया कोई प्रतिस्पर्धी मूल समाधान निकालें और/या मैजिस्क को फिर से स्थापित करें।</string>
    <string name="unsupport_external_storage_msg">मैजिस्क बाहरी संग्रहण में स्थापित है। कृपया ऐप को इंटरनल स्टोरेज में ले जाएं।</string>
    <string name="unsupport_nonroot_stub_msg">छिपा हुआ मैजिक ऐप काम करना जारी नहीं रख सकता क्योंकि रूट खो गया था। कृपया मूल APK को पुनर्स्थापित करें।</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">इसका उपयोग करने के लिए स्टोरेज अनुमति प्रदान करें</string>
    <string name="install_unknown_denied">इस कार्यक्षमता को सक्षम करने के लिए "अज्ञात ऐप्स इंस्टॉल करें" की अनुमति दें</string>
    <string name="add_shortcut_title">होम स्क्रीन पर शॉर्टकट जोड़ें</string>
    <string name="add_shortcut_msg">इस ऐप को छिपाने के बाद इसका नाम और आइकन पहचानना मुश्किल हो सकता है। क्या आप होम स्क्रीन पर एक सुंदर शॉर्टकट जोड़ना चाहते हैं?</string>
    <string name="app_not_found">इस एक्शन को संभालने के लिए कोई एप्लिकेशन नहीं मिली</string>
    <string name="reboot_apply_change">परिवर्तन लागू करने के लिए रीबूट करें</string>
    <string name="restore_app_confirmation">यह छिपे हुए ऐप को मूल ऐप पर वापस बहाल कर देगा। क्या आप वाकई ऐसा करना चाहते हैं?</string>

</resources>

```

`app/core/src/main/res/values-hn/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Modules</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Logs</string>
    <string name="settings">Settings</string>
    <string name="install">Install</string>
    <string name="section_home">Home</string>
    <string name="section_theme">Themes</string>
    <string name="denylist">DenyList</string>

    <!--Home-->
    <string name="no_connection">Net nahi chal rha hai</string>
    <string name="app_changelog">Kya naga hai</string>
    <string name="loading">Loading ho rha hai…</string>
    <string name="update">Update</string>
    <string name="not_available">Available nahi hai</string>
    <string name="hide">Chhupao</string>
    <string name="home_package">Package</string>
    <string name="home_app_title">App</string>
    <string name="home_notice_content">Hamesha Magisk ko uske official github release source se download karein. Unofficial source ki file khatarnak ho sakti hai.</string>
    <string name="home_support_title">Humein Support karo</string>
    <string name="home_follow_title">Humein Karo</string>
    <string name="home_item_source">Source</string>
    <string name="home_support_content">Magisk hamesha free aur open source rahega. Agar aap support karna chahte ho, toh donation de sakte ho.</string>
    <string name="home_installed_version">Jo version install hai</string>
    <string name="home_latest_version">Latest</string>
    <string name="invalid_update_channel">Galat update channel</string>
    <string name="uninstall_magisk_title">Magisk uninstall karo</string>
    <string name="uninstall_magisk_msg">Saare modules disable ya remove ho jayenge!\nRoot khatam ho jayega!\nAgar Magisk ne storage ko decrypt kiya tha toh wo phir se encrypt ho jayega!</string>

    <!--Install-->
    <string name="keep_force_encryption">Force encryption ko preserve karo</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity ko preserve karo</string>
    <string name="recovery_mode">Recovery mode</string>
    <string name="install_options_title">Options</string>
    <string name="install_method_title">Method</string>
    <string name="install_next">Aage badho</string>
    <string name="install_start">Chalo shuru karein</string>
    <string name="manager_download_install">Download aur install karne ke liye dabao</string>
    <string name="direct_install">Direct install (Recommended)</string>
    <string name="install_inactive_slot">Inactive slot par install karo (OTA ke baad)</string>
    <string name="install_inactive_slot_msg">Reboot ke baad device ko inactive slot se boot karna padega!\nSirf tab use karo jab OTA complete ho chuka ho.\nAage badhna hai?</string>
    <string name="setup_title">Extra setup</string>
    <string name="select_patch_file">File select karke patch karo</string>
    <string name="patch_file_msg">Raw image (*.img), ODIN tar file (*.tar), ya payload.bin (*.bin) select karo</string>
    <string name="reboot_delay_toast">Phone 5 second mein reboot hoga…</string>
    <string name="flash_screen_title">Installation ho rahi hai</string>

    <!--Superuser-->
    <string name="su_request_title">ROOT access maang rha hai</string>
    <string name="touch_filtered_warning">Ek app Superuser request ko cover kar raha hai, isliye Magisk aapka response verify nahi kar sakta.</string>
    <string name="deny">Nahi</string>
    <string name="prompt">Poocho</string>
    <string name="restrict">Restrict</string>
    <string name="grant">Haan Theek hai</string>
    <string name="su_warning">Yeh full access dega device ko.\nAgar sure nahi ho toh deny kar do!</string>
    <string name="forever">Hamesha ke liye</string>
    <string name="once">Ek baar ke liye</string>
    <string name="tenmin">10 mins</string>
    <string name="twentymin">20 mins</string>
    <string name="thirtymin">30 mins</string>
    <string name="sixtymin">60 mins</string>
    <string name="su_allow_toast">%1$s ko ROOT access de diya gaya</string>
    <string name="su_deny_toast">%1$s ko ROOT access nahi diya gaya</string>
    <string name="su_snack_grant">%1$s ko ROOT access mila</string>
    <string name="su_snack_deny">%1$s ka ROOT access deny hua</string>
    <string name="su_snack_notif_on">%1$s ke notifications ON hain</string>
    <string name="su_snack_notif_off">%1$s ke notifications OFF hain</string>
    <string name="su_snack_log_on">%1$s ka logging ON hai</string>
    <string name="su_snack_log_off">%1$s ka logging OFF hai</string>
    <string name="su_revoke_title">Access wapas lena hai?</string>
    <string name="su_revoke_msg">Kya aap confirm karte ho ki %1$s ka ROOT access hata diya jaye?</string>
    <string name="toast">Toast</string>
    <string name="none">Kuch nahi</string>
    <string name="superuser_toggle_notification">Notifications</string>
    <string name="superuser_toggle_revoke">Wapas lelo</string>
    <string name="superuser_policy_none">Ab tak kisi bhi app ne ROOT access nahi manga hai</string>

    <!--Logs-->
    <string name="log_data_none">Koi logs nahi mile. Shayad tumhe root apps ka zyada use krna chahiye.</string>
    <string name="log_data_magisk_none">Ajeeb baat hai, Yaha toh logs hain hi nahi.</string>
    <string name="menuSaveLog">Log save karo</string>
    <string name="menuClearLog">Log clear karo</string>
    <string name="logs_cleared">Logs clear ho gaye</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Target UID: %1$d</string>
    <string name="target_pid">Target PID: %s</string>
    <string name="selinux_context">SELinux context: %s</string>
    <string name="supp_group">Supplementary group: %s</string>

    <!--MagiskHide-->
    <string name="show_system_app">System apps dikhao</string>
    <string name="show_os_app">OS apps dikhao</string>
    <string name="hide_filter_hint">Naam ke hisaab se filter karo</string>
    <string name="hide_search">Search karo</string>

    <!--Module-->
    <string name="no_info_provided">(Koi info nahi di gayi)</string>
    <string name="reboot_userspace">Soft reboot</string>
    <string name="reboot_recovery">Recovery mode mein reboot karo</string>
    <string name="reboot_bootloader">Bootloader mode mein reboot karo</string>
    <string name="reboot_download">Download mode mein reboot karo</string>
    <string name="reboot_edl">EDL mode mein reboot karo</string>
    <string name="reboot_safe_mode">Safe mode</string>
    <string name="module_version_author">%1$s ko %2$s ne banaya hai</string>
    <string name="module_state_remove">Delete karo</string>
    <string name="module_action">Action</string>
    <string name="module_state_restore">Wapas laao</string>
    <string name="module_action_install_external">Storage se install karo</string>
    <string name="update_available">Naya update available hai</string>
    <string name="suspend_text_riru">Module suspend kiya gaya kyunki %1$s enabled hai</string>
    <string name="suspend_text_zygisk">Bhai %1$s ON kr tabb ye module chalega</string>
    <string name="zygisk_module_unloaded">Zygisk module compatible nahi tha, isliye load nahi hua</string>
    <string name="module_empty">Koi module install nahi hai</string>
    <string name="confirm_install">>%1$s module install karna hai?</string>
    <string name="confirm_install_title">Ek baar firse soch lo</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Theme mode</string>
    <string name="settings_dark_mode_message">Apni hisaab se mode choose karo!</string>
    <string name="settings_dark_mode_light">Hamesha light theme</string>
    <string name="settings_dark_mode_system">System ke saath follow karo</string>
    <string name="settings_dark_mode_dark">Hamesha dark theme</string>
    <string name="settings_download_path_title">Download path</string>
    <string name="settings_download_path_message">Files yahan save hongi: %1$s</string>
    <string name="settings_hide_app_title">Magisk app ko hide karo</string>
    <string name="settings_hide_app_summary">Magisk app ka name aur package ID change kro</string>
    <string name="settings_restore_app_title">Magisk app ko unhide karo</string>
    <string name="settings_restore_app_summary">App ko unhide karo aur original APK wapas lao</string>
    <string name="language">Language</string>
    <string name="system_default">(System ki default)</string>
    <string name="settings_check_update_title">Updates check karo</string>
    <string name="settings_check_update_summary">Background mein updates auto check honge</string>
    <string name="settings_update_channel_title">Update channel</string>
    <string name="settings_update_stable">Stable</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_debug">Debug</string>
    <string name="settings_update_custom">Custom</string>
    <string name="settings_update_custom_msg">Apna custom channel URL daaloL</string>
    <string name="settings_zygisk_summary">Magisk ke kuch parts ko Zygote daemon mein run karo</string>
    <string name="settings_denylist_title">DenyList enforce karo</string>
    <string name="settings_denylist_summary">DenyList mein jo processes hain, unpe Magisk ka effect hata diya jayega</string>
    <string name="settings_denylist_config_title">DenyList set karo</string>
    <string name="settings_denylist_config_summary">Kaunse process DenyList mein daalne hain, select karo</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">Ad-blocking apps ke liye systemless hosts support</string>
    <string name="settings_hosts_toast">Systemless hosts module add kar diya gaya</string>
    <string name="settings_app_name_hint">Naya naam</string>
    <string name="settings_app_name_helper">App is naam ke saath repack hoga</string>
    <string name="settings_app_name_error">Naam ka format galat hai</string>
    <string name="settings_su_app_adb">Apps aur ADB</string>
    <string name="settings_su_app">Sirf apps</string>
    <string name="settings_su_adb">Sirf ADB</string>
    <string name="settings_su_disable">Disable kiya gaya</string>
    <string name="settings_su_request_10">10 seconds</string>
    <string name="settings_su_request_15">15 seconds</string>
    <string name="settings_su_request_20">20 seconds</string>
    <string name="settings_su_request_30">30 seconds</string>
    <string name="settings_su_request_45">45 seconds</string>
    <string name="settings_su_request_60">60 seconds</string>
    <string name="superuser_access">ROOT access</string>
    <string name="auto_response">Automatic response</string>
    <string name="request_timeout">Request timeout</string>
    <string name="superuser_notification">ROOT notification</string>
    <string name="settings_su_reauth_title">Upgrade ke baad dobara permission puchho</string>
    <string name="settings_su_reauth_summary">App upgrade hone ke baad Superuser permission firse maangna</string>
    <string name="settings_su_tapjack_title">Tapjacking se protection</string>
    <string name="settings_su_tapjack_summary">Agar Superuser prompt kisi aur window ya overlay ke neeche chhup gaya ho, toh uspar tap kaam nahi karega</string>
    <string name="settings_su_auth_title">User authentication</string>
    <string name="settings_su_auth_summary">Superuser request ke time user se authentication maango</string>
    <string name="settings_su_auth_insecure">Device mein koi bhi authentication method set nahi hai</string>
    <string name="settings_su_restrict_title">Root access ko limit karo</string>
    <string name="settings_su_restrict_summary">Nayeapps ko ROOT access maangne se block karega. Warning: Isse zyada tarr apps kaam karna band kar denge. Sirf tab enable karo jab aapko pata ho aap kya kar rahe ho.</string>
    <string name="settings_customization">Customization</string>
    <string name="setting_add_shortcut_summary">Agar app hide karne ke baad uska naam ya icon samajhne mein dikkat ho rahi ho, toh home screen pe ek shortcut add kar lo</string>
    <string name="settings_doh_title">DNS over HTTPS</string>
    <string name="settings_doh_description">DNS poisoning se bachne ke liye (kuch countries mein zaroori padti hai)</string>
    <string name="settings_random_name_title">Output file ka naam random karo</string>
    <string name="settings_random_name_description">Patched images aur tar files ka naam random bana ke detection se bachao</string>
    <string name="multiuser_mode">Multiuser mode</string>
    <string name="settings_owner_only">Sirf device owner</string>
    <string name="settings_owner_manage">Device owner manage karega</string>
    <string name="settings_user_independent">Har user ke liye alag</string>
    <string name="owner_only_summary">Sirf device owner ko root access milega</string>
    <string name="owner_manage_summary">Sirf owner root access manage kar sakta hai aur requests receive karega</string>
    <string name="user_independent_summary">Har user ke liye alag root rules honge</string>
    <string name="mount_namespace_mode">Mount namespace mode</string>
    <string name="settings_ns_global">Global namespace</string>
    <string name="settings_ns_requester">Inherit namespace</string>
    <string name="settings_ns_isolate">Isolated namespace</string>
    <string name="global_summary">Sabhi root sessions ek hi global mount namespace use karenge</string>
    <string name="requester_summary">Root session apne requester ka namespace inherit karega</string>
    <string name="isolate_summary">Har root session ka apna alag isolated namespace hoga</string>

    <!--Notifications-->
    <string name="update_channel">Magisk updates</string>
    <string name="progress_channel">Progress notifications</string>
    <string name="updated_channel">Update ho gaya</string>
    <string name="download_complete">Download ho gaya</string>
    <string name="download_file_error">File download karne mein error aaya</string>
    <string name="magisk_update_title">Magisk ka naya update available hai!</string>
    <string name="updated_title">Magisk update ho gaya</string>
    <string name="updated_text">App open karne ke liye tap karo</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Haan</string>
    <string name="no">Nahi</string>
    <string name="repo_install_title">%1$s %2$s(%3$d) Install karo</string>
    <string name="download">Download karo</string>
    <string name="reboot">Reboot karo</string>
    <string name="close">Close karo</string>
    <string name="release_notes">Release notes</string>
    <string name="flashing">Flash ho raha hai…</string>
    <string name="running">Chal raha hai…</string>
    <string name="done">Ho gaya!</string>
    <string name="done_action">%1$s ka action complete ho gaya</string>
    <string name="failure">Fail ho gaya!</string>
    <string name="hide_app_title">Magisk app ko chhupa rahe hain…</string>
    <string name="open_link_failed_toast">Link kholne ke liye koi app nahi mila</string>
    <string name="complete_uninstall">Sab kuch uninstall karo</string>
    <string name="restore_img">Images restore karo</string>
    <string name="restore_img_msg">Restore kiya ja raha hai…</string>
    <string name="restore_done">Restore complete ho gaya!</string>
    <string name="restore_fail">Stock backup available nahi hai!</string>
    <string name="setup_fail">Setup fail ho gaya</string>
    <string name="env_fix_title">Iske liye thoda extra setup chahiye</string>
    <string name="env_fix_msg">Magisk ko sahi se chalane ke liye thoda aur setup karna padega. Kya aap proceed karke device reboot karna chahte ho?</string>
    <string name="env_full_fix_msg">Magisk ko properly chalane ke liye aapko usse dubara flash karna padega. App ke andar se Magisk reinstall karo, kyunki Recovery mode sahi device info nahi de pata.</string>
    <string name="setup_msg">Environment setup chal raha hai…</string>
    <string name="unsupport_magisk_title">Magisk version supported nahi hain</string>
    <string name="unsupport_magisk_msg">Is app version ko %1$s se purani Magisk versions support nahi karti.\n\nApp aise behave karega jaise Magisk install hi nahi hai. Jaldi se Magisk ko update karo.</string>
    <string name="unsupport_general_title">System thoda alag behave kar raha hai</string>
    <string name="unsupport_system_app_msg">App ko system app bana ke chalana supported nahi hai. Please app ko wapas user app bana do.</string>
    <string name="unsupport_other_su_msg">Pehle doosri root method hatao ya Magisk dobara install karo.</string>
    <string name="unsupport_external_storage_msg">Magisk external storage pe installed hai. App ko internal storage mein move karo.</string>
    <string name="unsupport_nonroot_stub_msg">Hidden Magisk app ab kaam nahi karega kyunki root chala gaya hai. Please original APK restore karo.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Iss feature ko enable karne ke liye storage permission allow karo</string>
    <string name="post_notifications_denied">Is feature ke liye notifications permission allow karo</string>
    <string name="install_unknown_denied">\"Install unknown apps\" ki permission allow karo taaki ye feature kaam kar sakey</string>
    <string name="add_shortcut_title">Shortcut home screen pe add karo</string>
    <string name="add_shortcut_msg">App ko hide karne ke baad agar uska icon ya naam pehchanna mushkil ho, toh ek shortcut home screen pe add kar lein?</string>
    <string name="app_not_found">Is action ko handle karne ke liye koi app nahi mila</string>
    <string name="reboot_apply_change">Changes apply karne ke liye reboot krna zaroori hai</string>
    <string name="restore_app_confirmation">Ye action hidden app ko original version mein wapas laayega. Kya aap sach mein ye karna chahte ho?</string>

</resources>

```

`app/core/src/main/res/values-hr/strings.xml`:

```xml
<resources>
    <!--Universal-->

    <!--Welcome Activity-->
    <string name="modules">Moduli</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Zapisnik događaja</string>
    <string name="settings">Postavke</string>
    <string name="install">Instaliranje</string>
    <string name="section_home">Početna</string>
    <string name="section_theme">Teme</string>

    <!--Home-->
    <string name="no_connection">Nema dostupne veze</string>
    <string name="app_changelog">Popis izmjena</string>
    <string name="loading">Učitavanje…</string>
    <string name="update">Ažuriraj</string>
    <string name="not_available">N/A</string>
    <string name="hide">Sakrij</string>
    <string name="home_package">Paket</string>

    <string name="home_support_title">Podržite nas</string>
    <string name="home_item_source">Izvor</string>
    <string name="home_support_content">Magisk je i uvijek će biti besplatan i otvoren. Međutim, možete nam pokazati da vam je stalo slanjem male donacije.</string>
    <string name="home_installed_version">Instalirana</string>
    <string name="home_latest_version">Najnovija</string>
    <string name="invalid_update_channel">Nevažeći kanal ažuriranja</string>
    <string name="uninstall_magisk_title">Deinstaliraj Magisk</string>
    <string name="uninstall_magisk_msg">Svi će moduli biti onemogućeni/uklonjeni!\nRoot će biti uklonjen!\nVaši su podaci potencijalno šifrirani, ako već nisu!</string>

    <!--Install-->
    <string name="keep_force_encryption">Zadrži prisilno šifirannje</string>
    <string name="keep_dm_verity">Zadrži AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Recovery način</string>
    <string name="install_options_title">Opcije</string>
    <string name="install_method_title">Metoda</string>
    <string name="install_next">Dalje</string>
    <string name="install_start">Krenimo</string>
    <string name="manager_download_install">Dodirnite za preuzimanje i instalaciju</string>
    <string name="direct_install">Izravna instalacija (preporučeno)</string>
    <string name="install_inactive_slot">Instaliraj u neaktivni utor (Nakon OTA)</string>
    <string name="install_inactive_slot_msg">Vaš će se uređaj prisiliti pokrenuti s trenutnog neaktivnog mjesta nakon ponovnog pokretanja!\nKoristite tu opciju samo nakon što je OTA dovršena.\nContinue?</string>
    <string name="setup_title">Dodatno postavljanje</string>
    <string name="select_patch_file">Odaberite patch datoteku</string>
    <string name="patch_file_msg">Odaberite raw (*.img) ili ODIN tarfile (*.tar)</string>
    <string name="reboot_delay_toast">Ponovno pokretanje za 5 sekundi…</string>
    <string name="flash_screen_title">Instalacija</string>

    <!--Superuser-->
    <string name="su_request_title">Superuser zahtjev</string>
    <string name="deny">Odbij</string>
    <string name="prompt">Upit</string>
    <string name="grant">Odobri</string>
    <string name="su_warning">Odobren puni pristup vašem uređaju.\nOdbijte ako niste sigurni!</string>
    <string name="forever">Zauvijek</string>
    <string name="once">Jednom</string>
    <string name="tenmin">10 min</string>
    <string name="twentymin">20 min</string>
    <string name="thirtymin">30 min</string>
    <string name="sixtymin">60 min</string>
    <string name="su_allow_toast">%1$s su dodijeljena Superuser prava</string>
    <string name="su_deny_toast">%1$s su odbijena Superuser prava</string>
    <string name="su_snack_grant">Superuser prava su dodijeljena za %1$s</string>
    <string name="su_snack_deny">Superuser prava su odbijena za %1$s</string>
    <string name="su_snack_notif_on">Obavijesti za %1$s su odobrene</string>
    <string name="su_snack_notif_off">Obavijesti za %1$s su odbijene</string>
    <string name="su_snack_log_on">Zapisnik događaja omogućen je za %1$s</string>
    <string name="su_snack_log_off">Zapisnik događaja onemogućen je za %1$s</string>
    <string name="su_revoke_title">Opozvati?</string>
    <string name="su_revoke_msg">Potvrdite da biste opozvali prava za %1$s?</string>
    <string name="toast">Pop-up</string>
    <string name="none">Nijedan</string>

    <string name="superuser_toggle_notification">Obavijesti</string>
    <string name="superuser_toggle_revoke">Opozovi</string>
    <string name="superuser_policy_none">Još nijedna aplikacija nije zatražila Superuser prava.</string>

    <!--Logs-->
    <string name="log_data_none">Nemate zapisnika, pokušajte više upotrebljavati svoje aplikacije s omogućenim SU.</string>
    <string name="log_data_magisk_none">Zapisnici Magiska su prazni, to je čudno.</string>
    <string name="menuSaveLog">Spremi zapisnik</string>
    <string name="menuClearLog">Izbriši zapisnik</string>
    <string name="logs_cleared">Zapisnik uspješno izbrisan.</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Ciljani UID: %1$d</string>

    <!--SafetyNet-->

    <!-- MagiskHide -->
    <string name="show_system_app">Prikaži sistemske aplikacije</string>
    <string name="hide_filter_hint">Filtriraj prema nazivu</string>
    <string name="hide_search">Traži</string>

    <!--Module -->
    <string name="no_info_provided">(Nema podataka)</string>
    <string name="reboot_recovery">Ponovo pokreni u Recovery</string>
    <string name="reboot_bootloader">Ponovo pokreni u Bootloader</string>
    <string name="reboot_download">Ponovo pokreni u Download</string>
    <string name="reboot_edl">Ponovo pokreni u EDL</string>
    <string name="module_version_author">%1$s od %2$s</string>
    <string name="module_state_remove">Ukloni</string>
    <string name="module_state_restore">Vrati</string>
    <string name="module_action_install_external">Instaliraj iz pohrane</string>
    <string name="update_available">Ažuriranje dostupno</string>

    <!--Settings -->
    <string name="settings_dark_mode_title">Teme</string>
    <string name="settings_dark_mode_message">Odaberite temu koja najbolje odgovara vašem stilu!</string>
    <string name="settings_dark_mode_light">Uvijek svijetla</string>
    <string name="settings_dark_mode_system">Prati sustav</string>
    <string name="settings_dark_mode_dark">Uvijek crna</string>
    <string name="settings_download_path_title">Putanja preuzimanja</string>
    <string name="settings_download_path_message">Datoteke će biti spremljene u %1$s</string>
    <string name="language">Jezik</string>
    <string name="system_default">(Zadano sustavom)</string>
    <string name="settings_check_update_title">Provjeri za ažuriranja</string>
    <string name="settings_check_update_summary">Povremeno provjeravaj ima li ažuriranja u pozadini</string>
    <string name="settings_update_channel_title">Kanal ažuriranja</string>
    <string name="settings_update_stable">Stabilna</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Vlastiti kanal</string>
    <string name="settings_update_custom_msg">Umetnite prilagođeni URL</string>
    <string name="settings_hosts_title">Hostovi bez sistema</string>
    <string name="settings_hosts_summary">Podrška za hostove bez sistema za Adblock aplikacije</string>
    <string name="settings_hosts_toast">Dodan je modul hosta bez sistema</string>
    <string name="settings_app_name_hint">Novi naziv</string>
    <string name="settings_app_name_helper">Aplikacija će se prepakirati na ovaj naziv</string>
    <string name="settings_app_name_error">Nevažeći format</string>
    <string name="settings_su_app_adb">Aplikacije i ADB</string>
    <string name="settings_su_app">Samo aplikacije</string>
    <string name="settings_su_adb">Samo ADB</string>
    <string name="settings_su_disable">Onemogućeno</string>
    <string name="settings_su_request_10">10 sekundi</string>
    <string name="settings_su_request_15">15 sekundi</string>
    <string name="settings_su_request_20">20 sekundi</string>
    <string name="settings_su_request_30">30 sekundi</string>
    <string name="settings_su_request_45">45 sekundi</string>
    <string name="settings_su_request_60">60 sekundi</string>
    <string name="superuser_access">Superuser pristup</string>
    <string name="auto_response">Automatski odgovor</string>
    <string name="request_timeout">Vremensko ograničenje zahtjeva</string>
    <string name="superuser_notification">Superuser obavijest</string>
    <string name="settings_su_reauth_title">Ponovno provjerite autentičnost nakon ažuriranja</string>
    <string name="settings_su_reauth_summary">Ponovno provjerite autentičnost Superuser-a dopuštenja nakon ažuriranja aplikacije</string>
    <string name="settings_customization">Prilagodba</string>
    <string name="setting_add_shortcut_summary">Dodajte lijepi prečac na početni zaslon u slučaju da je naziv i ikonu teško prepoznati nakon skrivanja aplikacije</string>
    <string name="settings_doh_title">DNS preko HTTPS-a</string>
    <string name="settings_doh_description">Zaobilazno trovanje DNS-om u nekim zemljama</string>

    <string name="multiuser_mode">Višekorisnički način rada</string>
    <string name="settings_owner_only">Samo vlasnik uređaja</string>
    <string name="settings_owner_manage">Upravljano od strane vlasnika uređaja</string>
    <string name="settings_user_independent">Neovisno o korisniku</string>
    <string name="owner_only_summary">Samo vlasnik ima root pristup</string>
    <string name="owner_manage_summary">Samo vlasnik može upravljati root pristupom i primati zahtjeve za root pristup</string>
    <string name="user_independent_summary">Svaki korisnik ima vlastita root pravila</string>

    <string name="mount_namespace_mode">Postavljanje imenskog prostora</string>
    <string name="settings_ns_global">Globalni imenski prostor</string>
    <string name="settings_ns_requester">Naslijediti imenski prostor</string>
    <string name="settings_ns_isolate">Izolirani imenski prostor</string>
    <string name="global_summary">Sve root sesije koriste globalni imenski prostor</string>
    <string name="requester_summary">Root sesije će naslijediti imenski prostor tražitelja</string>
    <string name="isolate_summary">Svaka root sesija ima svoj vlastiti imenski prostor</string>

    <!--Notifications-->
    <string name="update_channel">Magisk Ažuriranja</string>
    <string name="progress_channel">Obavijesti o napretku</string>
    <string name="download_complete">Preuzimanje završeno</string>
    <string name="download_file_error">Pogreška pri preuzimanju datoteke</string>
    <string name="magisk_update_title">Dostupno je Magisk ažuriranje!</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Da</string>
    <string name="no">Ne</string>
    <string name="repo_install_title">Instaliraj %1$s %2$s(%3$d)</string>
    <string name="download">Preuzmi</string>
    <string name="reboot">Ponovno pokreni</string>
    <string name="release_notes">Bilješke o izdavanju aplikacije</string>
    <string name="flashing">Apliciranje…</string>
    <string name="done">Dovršeno!</string>
    <string name="failure">Nije uspjelo</string>
    <string name="open_link_failed_toast">Nije pronađena aplikacija za otvaranje veze</string>
    <string name="complete_uninstall">Dovršite deinstalaciju</string>
    <string name="restore_img">Vrati Images</string>
    <string name="restore_img_msg">Vraćanje…</string>
    <string name="restore_done">Vraćanje je dovršeno!</string>
    <string name="restore_fail">Izvorna Sig. kopija ne postoji!</string>
    <string name="setup_fail">Postavljanje nije uspjelo</string>
    <string name="env_fix_title">Zahtijeva dodatno postavljanje</string>
    <string name="setup_msg">Postavljanje okruženja za pokretanje…</string>
    <string name="unsupport_magisk_title">Nepodržana Magisk verzija</string>
    <string name="external_rw_permission_denied">Odobrite dopuštenje za pohranu da biste omogućili ovu funkciju</string>
    <string name="add_shortcut_title">Dodaj prečac na početni zaslon</string>
    <string name="app_not_found">Nije pronađena nijedna aplikacijaza obradu ove radnju</string>
</resources>

```

`app/core/src/main/res/values-hu/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Modulok</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Naplók</string>
    <string name="settings">Beállítások</string>
    <string name="install">Telepítés</string>
    <string name="section_home">Kezdőlap</string>
    <string name="section_theme">Témák</string>
    <string name="denylist">Tiltólista</string>

    <!--Home-->
    <string name="no_connection">Nincs elérhető kapcsolat</string>
    <string name="app_changelog">Változási napló</string>
    <string name="loading">Betöltés…</string>
    <string name="update">Frissít</string>
    <string name="not_available">N/A</string>
    <string name="hide">Elrejt</string>
    <string name="home_package">Csomag</string>
    <string name="home_app_title">App</string>

    <string name="home_notice_content">A Magisk-et CSAK a hivatalos GitHub oldalról töltsd le. Az ismeretlen forrásból származó fájlok rosszindulatúak lehetnek!</string>
    <string name="home_support_title">Támogass minket</string>
    <string name="home_follow_title">Kövess minket</string>
    <string name="home_item_source">Forrás</string>
    <string name="home_support_content">A Magisk ingyenes, nyílt forráskódú és mindig az is marad. Adományoddal azonban jelezheted, hogy törődsz vele.</string>
    <string name="home_installed_version">Telepítve</string>
    <string name="home_latest_version">Legújabb</string>
    <string name="invalid_update_channel">Érvénytelen frissítési csatorna</string>
    <string name="uninstall_magisk_title">A Magisk eltávolítása</string>
    <string name="uninstall_magisk_msg">Az összes modul le lesz tiltva/eltávolítva!\nA root eltávolításra kerül!\nA Magisk használatával titkosítatlan belső tárhely újra titkosításra kerül!</string>

    <!--Install-->
    <string name="keep_force_encryption">Az erőltetett titkosítás megőrzése</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity megőrzése</string>
    <string name="recovery_mode">Recovery mód</string>
    <string name="install_options_title">Lehetőségek</string>
    <string name="install_method_title">Módszer</string>
    <string name="install_next">Tovább</string>
    <string name="install_start">Hajrá</string>
    <string name="manager_download_install">Nyomd a letöltéshez és telepítéshez</string>
    <string name="direct_install">Közvetlen telepítés (ajánlott)</string>
    <string name="install_inactive_slot">Telepítés inaktív slot-ba (OTA után)</string>
    <string name="install_inactive_slot_msg">Eszközöd újraindítás után KÉNYSZERÍTVE az aktuális inaktív slot-ból indulásra!\nEzt az opciót csak az OTA befejezése után használd.\nFolytatod?</string>
    <string name="setup_title">További beállítások</string>
    <string name="select_patch_file">Fájl kiválasztás és módosítása</string>
    <string name="patch_file_msg">Válassz ki egy raw image-et (*.img) vagy egy ODIN tar fájlt (*.tar)</string>
    <string name="reboot_delay_toast">Újraindítás 5 másodpercen belül…</string>
    <string name="flash_screen_title">Telepítés</string>

    <!--Superuser-->
    <string name="su_request_title">Superuser kérés</string>
    <string name="touch_filtered_warning">Mivel egy alkalmazás eltakar egy Superuser kérést, a Magisk nem tudja ellenőrizni a válaszod</string>
    <string name="deny">Elutasít</string>
    <string name="prompt">Kérdés</string>
    <string name="grant">Megenged</string>
    <string name="su_warning">Teljes hozzáférést biztosít az eszközhöz.\nTagadd meg, ha nem vagy biztos benne!</string>
    <string name="forever">Végleges</string>
    <string name="once">Egyszeri</string>
    <string name="tenmin">10 perc</string>
    <string name="twentymin">20 perc</string>
    <string name="thirtymin">30 perc</string>
    <string name="sixtymin">60 perc</string>
    <string name="su_allow_toast">%1$s - Superuser jogokat kapott</string>
    <string name="su_deny_toast">%1$s - Superuser jogok megtagadva</string>
    <string name="su_snack_grant">%1$s - Superuser jogok megadva</string>
    <string name="su_snack_deny">%1$s - Superuser jogok megtagadva</string>
    <string name="su_snack_notif_on">%1$s értesítései bekapcsolva</string>
    <string name="su_snack_notif_off">%1$s értesítései kikapcsolva</string>
    <string name="su_snack_log_on">%1$s naplózása bekapcsolva</string>
    <string name="su_snack_log_off">%1$s naplózása kikapcsolva</string>
    <string name="su_revoke_title">Visszavonod?</string>
    <string name="su_revoke_msg">Erősítsd meg %1$s Superuser jogainak visszavonását</string>
    <string name="toast">Felbukkanó</string>
    <string name="none">Egyik sem</string>

    <string name="superuser_toggle_notification">Értesítések</string>
    <string name="superuser_toggle_revoke">Visszavonás</string>
    <string name="superuser_policy_none">Még egyetlen alkalmazás sem kért Superuser engedélyt.</string>

    <!--Logs-->
    <string name="log_data_none">Nincs naplózás, próbáld többet használni a root alkalmazásokat</string>
    <string name="log_data_magisk_none">A Magisk naplók üresek, ez furcsa</string>
    <string name="menuSaveLog">Napló mentés</string>
    <string name="menuClearLog">Napló törlése most</string>
    <string name="logs_cleared">A napló sikeresen törölve</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Cél UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Rendszerappok megjelenítése</string>
    <string name="show_os_app">OS-appok megjelenítése</string>
    <string name="hide_filter_hint">Szűrés névre</string>
    <string name="hide_search">Keresés</string>

    <!--Module-->
    <string name="no_info_provided">(Nincs információ)</string>
    <string name="reboot_userspace">Lágy újraindítás</string>
    <string name="reboot_recovery">Újraindítás - Recovery</string>
    <string name="reboot_bootloader">Újraindítás - Bootloader</string>
    <string name="reboot_download">Újraindítás - Download</string>
    <string name="reboot_edl">Újraindítás - EDL</string>
    <string name="module_version_author">%1$s / %2$s</string>
    <string name="module_state_remove">Eltávolít</string>
    <string name="module_state_restore">Visszaállít</string>
    <string name="module_action_install_external">Telepítés tárhelyről</string>
    <string name="update_available">Frissítés érhető el</string>
    <string name="suspend_text_riru">A modul felfüggesztve, mert a %1$s engedélyezve van</string>
    <string name="suspend_text_zygisk">A modul felfüggesztve, mert a %1$s nincs engedélyezve</string>
    <string name="zygisk_module_unloaded">A Zygisk modul nem lett betöltve inkompatibilitás miatt</string>
    <string name="module_empty">Nincs telepített modul</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Téma mód</string>
    <string name="settings_dark_mode_message">Válaszd ki a stílusodhoz leginkább illő módot!</string>
    <string name="settings_dark_mode_light">Mindig világos</string>
    <string name="settings_dark_mode_system">Rendszer követése</string>
    <string name="settings_dark_mode_dark">Mindig sötét</string>
    <string name="settings_download_path_title">Letöltési útvonal</string>
    <string name="settings_download_path_message">A fájlok a következő helyre kerülnek: %1$s</string>
    <string name="settings_hide_app_title">A Magisk app elrejtése</string>
    <string name="settings_hide_app_summary">Telepíts egy proxyalkalmazást véletlenszerű csomagazonosítóval és egyéni alkalmazáscímkével</string>
    <string name="settings_restore_app_title">A Magisk app visszaállítása</string>
    <string name="settings_restore_app_summary">Oldja fel az app elrejtését, és állítsa vissza az eredeti APK-t</string>
    <string name="language">Nyelv</string>
    <string name="system_default">(Rendszer nyelve)</string>
    <string name="settings_check_update_title">Frissítések ellenőrzése</string>
    <string name="settings_check_update_summary">Rendszeresen ellenőrzi a frissítéseket a háttérben</string>
    <string name="settings_update_channel_title">Frissítési csatorna</string>
    <string name="settings_update_stable">Stabil</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Egyéni</string>
    <string name="settings_update_custom_msg">Adj meg egy egyéni csatorna URL-t</string>
    <string name="settings_zygisk_summary">Futtassa a Magisk egyes részeit a zigóta démonban</string>
    <string name="settings_denylist_title">Tiltólista kényszerítés</string>
    <string name="settings_denylist_summary">A tiltólistán lévő folyamatok minden Magisk módosítást visszaállítanak</string>
    <string name="settings_denylist_config_title">Tiltólista konfigurálás</string>
    <string name="settings_denylist_config_summary">Válaszd ki a tiltólistára felvenni kívánt folyamatokat</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">Systemless hosts támogatás a hirdetésblokkoló alkalmazásokhoz</string>
    <string name="settings_hosts_toast">Systemless hosts modul hozzáadva</string>
    <string name="settings_app_name_hint">Új név</string>
    <string name="settings_app_name_helper">Az alkalmazás ezzel a névvel lesz újracsomagolva</string>
    <string name="settings_app_name_error">Érvénytelen formátum</string>
    <string name="settings_su_app_adb">Appok és ADB</string>
    <string name="settings_su_app">Csak Appok</string>
    <string name="settings_su_adb">Csak ADB</string>
    <string name="settings_su_disable">Kikapcsolva</string>
    <string name="settings_su_request_10">10 mp</string>
    <string name="settings_su_request_15">15 mp</string>
    <string name="settings_su_request_20">20 mp</string>
    <string name="settings_su_request_30">30 mp</string>
    <string name="settings_su_request_45">45 mp</string>
    <string name="settings_su_request_60">60 mp</string>
    <string name="superuser_access">Superuser hozzáférés</string>
    <string name="auto_response">Automatikus válasz</string>
    <string name="request_timeout">Kérés időtúllépése</string>
    <string name="superuser_notification">Superuser értesítés</string>
    <string name="settings_su_reauth_title">Frissítés után hitelesítse újra</string>
    <string name="settings_su_reauth_summary">Az appok frissítés után kérjenek ismét Superuser engedélyeket</string>
    <string name="settings_su_tapjack_title">Tapjacking védelem</string>
    <string name="settings_su_tapjack_summary">A Superuser kérés párbeszédpanel nem válaszol a bevitelre, ha más ablak vagy átfedés eltakarja</string>
    <string name="settings_customization">Testreszabás</string>
    <string name="setting_add_shortcut_summary">Adjon hozzá egy szép parancsikont a kezdőképernyőhöz arra az esetre, ha a nevet és az ikont nehéz felismerni az alkalmazás elrejtése után</string>
    <string name="settings_doh_title">DNS HTTPS-en keresztül</string>
    <string name="settings_doh_description">Megoldás DNS-mérgezés esetén egyes országokban</string>

    <string name="multiuser_mode">Többfelhasználós mód</string>
    <string name="settings_owner_only">Csak az eszköz tulajdonosa</string>
    <string name="settings_owner_manage">Az eszköz tulajdonosa kezeli</string>
    <string name="settings_user_independent">Felhasználó-független</string>
    <string name="owner_only_summary">Csak a tulajdonos rendelkezik root hozzáféréssel</string>
    <string name="owner_manage_summary">Csak a tulajdonos kezelheti a root hozzáférést és fogadhatja a kéréseket</string>
    <string name="user_independent_summary">Minden felhasználónak megvannak a saját, külön root szabályai</string>

    <string name="mount_namespace_mode">Névtér felcsatolás módja</string>
    <string name="settings_ns_global">Globális névtér</string>
    <string name="settings_ns_requester">Örökölt névtér</string>
    <string name="settings_ns_isolate">Elszigetelt névtér</string>
    <string name="global_summary">Minden root szekció a globális csatolási névteret használja</string>
    <string name="requester_summary">A root munkamenetek öröklik a kérelmező névterét</string>
    <string name="isolate_summary">Minden root szekciónak saját, elszigetelt névtere lesz</string>

    <!--Notifications-->
    <string name="update_channel">Magisk frissítések</string>
    <string name="progress_channel">Folyamat értesítések</string>
    <string name="updated_channel">A frissítés kész</string>
    <string name="download_complete">A letöltés kész</string>
    <string name="download_file_error">Hiba a fájl letöltése közben</string>
    <string name="magisk_update_title">Magisk frissítés érhető el!</string>
    <string name="updated_title">A Magisk frissült</string>
    <string name="updated_text">Érintsd az app megnyitásához</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Igen</string>
    <string name="no">Nem</string>
    <string name="repo_install_title">%1$s %2$s(%3$d) telepítése</string>
    <string name="download">Letöltés</string>
    <string name="reboot">Újraindítás</string>
    <string name="release_notes">Kiadási jegyzetek</string>
    <string name="flashing">Flashing…</string>
    <string name="done">Kész!</string>
    <string name="failure">Nem sikerült!</string>
    <string name="hide_app_title">A Magisk app elrejtése…</string>
    <string name="open_link_failed_toast">Nem található alkalmazás a link megnyitásához</string>
    <string name="complete_uninstall">Teljes eltávolítás</string>
    <string name="restore_img">Image-ek visszaállítása</string>
    <string name="restore_img_msg">Visszaállítás…</string>
    <string name="restore_done">A helyreállítás megtörtént!</string>
    <string name="restore_fail">Stock mentés nem létezik!</string>
    <string name="setup_fail">A beállítás nem sikerült</string>
    <string name="env_fix_title">További beállítást igényel</string>
    <string name="env_fix_msg">A Magisk megfelelő működéséhez az eszközön további beállításokra van szükség. Folytatod és újraindítod?</string>
    <string name="setup_msg">Futási környezet beállítása…</string>
    <string name="unsupport_magisk_title">Nem támogatott Magisk verzió</string>
    <string name="unsupport_magisk_msg">Az alkalmazás ezen verziója nem támogatja a %1$s-nál régebbi Magisk-verziókat.\n\nAz alkalmazás úgy fog viselkedni, mintha nem lenne telepítve a Magisk. A lehető leghamarabb frissítsd a Magisk-et..</string>
    <string name="unsupport_general_title">Rendellenes állapot</string>
    <string name="unsupport_system_app_msg">Az alkalmazás rendszeralkalmazásként való futtatása nem támogatott. Állítsd vissza az alkalmazást felhasználói alkalmazássá.</string>
    <string name="unsupport_other_su_msg">Nem a Magisktől származó \"su\" binárist észleltünk. Távolíts el minden konkurens gyökérmegoldást, és/vagy telepítsd újra a Magisk-et.</string>
    <string name="unsupport_external_storage_msg">A Magisk külső tárhelyre van telepítve. Helyezd át az alkalmazást a belső tárhelyre.</string>
    <string name="unsupport_nonroot_stub_msg">A rejtett Magisk alkalmazás nem tud tovább működni, mert a root elveszett. Kérjük állítsd vissza az eredeti APK-t.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Adj tárhely engedélyt a funkció használatához</string>
    <string name="install_unknown_denied">Engedélyezd az "Ismeretlen alkalmazások telepítése" lehetőséget a funkció használatához</string>
    <string name="add_shortcut_title">Parancsikon hozzáadása a kezdőképernyőhöz</string>
    <string name="add_shortcut_msg">Az alkalmazás elrejtése után nehéz lehet felismerni a nevét és ikonját. Szeretnél egy szép parancsikont hozzáadni a kezdőképernyőhöz?</string>
    <string name="app_not_found">Nem található alkalmazás ennek a műveletnek a kezelésére</string>
    <string name="reboot_apply_change">A változtatások alkalmazásához indítsd újra</string>
    <string name="restore_app_confirmation">Ezzel visszaállítod a rejtett alkalmazást az eredeti alkalmazásra. Tényleg ezt akarod csinálni?</string>

</resources>

```

`app/core/src/main/res/values-in/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Modul</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Log</string>
    <string name="settings">Setelan</string>
    <string name="install">Pasang</string>
    <string name="section_home">Beranda</string>
    <string name="section_theme">Tema</string>
    <string name="denylist">DenyList</string>

    <!--Home-->
    <string name="no_connection">Koneksi tidak tersedia</string>
    <string name="app_changelog">Catatan perubahan</string>
    <string name="loading">Memuat…</string>
    <string name="update">Perbarui</string>
    <string name="not_available">N/A</string>
    <string name="hide">Tutup</string>
    <string name="home_package">Paket</string>
    <string name="home_app_title">Aplikasi</string>

    <string name="home_notice_content">Unduh Magisk HANYA dari halaman GitHub resmi kami. File dari sumber yang tidak dikenal dapat berbahaya!</string>
    <string name="home_support_title">Dukung kami</string>
    <string name="home_follow_title">Ikuti Kami</string>
    <string name="home_item_source">Sumber</string>
    <string name="home_support_content">Magisk gratis dan bersumber terbuka, dan akan selalu seperti itu. Bagaimanapun juga Anda dapat menunjukan kepedulian Anda kepada kami dengan mengirimkan sedikit donasi.</string>
    <string name="home_installed_version">Terpasang</string>
    <string name="home_latest_version">Terbaru</string>
    <string name="invalid_update_channel">Saluran pembaruan tidak valid</string>
    <string name="uninstall_magisk_title">Copot Magisk</string>
    <string name="uninstall_magisk_msg">Semua modul akan dinonaktifkan/dihapus!\nRoot akan dihapus!\nData Anda berpotensi terenkripsi jika belum!</string>

    <!--Install-->
    <string name="keep_force_encryption">Pertahankan enkripsi paksa</string>
    <string name="keep_dm_verity">Pertahankan AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Mode Recovery</string>
    <string name="install_options_title">Opsi</string>
    <string name="install_method_title">Metode</string>
    <string name="install_next">Berikutnya</string>
    <string name="install_start">Mulai</string>
    <string name="manager_download_install">Sentuh untuk unduh dan pasang</string>
    <string name="direct_install">Langsung pasang (Disarankan)</string>
    <string name="install_inactive_slot">Pasang pada slot nonaktif (Setelah OTA)</string>
    <string name="install_inactive_slot_msg">Perangkat Anda akan DIPAKSA boot ke slot yang saat ini tidak aktif setelah perangkat dinyalakan ulang!\nGunakan opsi ini hanya setelah proses OTA selesai.\nLanjutkan?</string>
    <string name="setup_title">Penyiapan tambahan</string>
    <string name="select_patch_file">Pilih dan tambal file</string>
    <string name="patch_file_msg">Pilih mentahan image (*.img) atau file tar ODIN (*.tar)</string>
    <string name="reboot_delay_toast">Memulai ulang dalam 5 detik…</string>
    <string name="flash_screen_title">Instalasi</string>

    <!--Superuser-->
    <string name="su_request_title">Permintaan superuser</string>
    <string name="touch_filtered_warning">Karena terdapat aplikasi yang menghalangi dialog permintaan superuser, Magisk tidak dapat memverifikasi respons Anda</string>
    <string name="deny">Tolak</string>
    <string name="prompt">Ajukan</string>
    <string name="grant">Izinkan</string>
    <string name="su_warning">Berikan akses penuh ke perangkat Anda.\nTolak jika Anda tidak yakin!</string>
    <string name="forever">Selamanya</string>
    <string name="once">Sekali</string>
    <string name="tenmin">10 mnt</string>
    <string name="twentymin">20 mnt</string>
    <string name="thirtymin">30 mnt</string>
    <string name="sixtymin">60 mnt</string>
    <string name="su_allow_toast">%1$s mendapatkan hak superuser</string>
    <string name="su_deny_toast">%1$s ditolak atas hak superuser</string>
    <string name="su_snack_grant">Hak superuser %1$s diberikan</string>
    <string name="su_snack_deny">Hak superuser %1$s ditolak</string>
    <string name="su_snack_notif_on">Notifikasi %1$s diaktifkan</string>
    <string name="su_snack_notif_off">Notifikasi %1$s dinonaktifkan</string>
    <string name="su_snack_log_on">Pencatatan log %1$s diaktifkan</string>
    <string name="su_snack_log_off">Pencatatan log %1$s dinonaktifkan</string>
    <string name="su_revoke_title">Cabut?</string>
    <string name="su_revoke_msg">Konfirmasi untuk mencabut hak %1$s?</string>
    <string name="toast">Toast</string>
    <string name="none">Tidak ada</string>

    <string name="superuser_toggle_notification">Notifikasi</string>
    <string name="superuser_toggle_revoke">Cabut</string>
    <string name="superuser_policy_none">Belum ada aplikasi yang meminta izin superuser.</string>

    <!--Logs-->
    <string name="log_data_none">Log Anda masih kosong, coba gunakan lebih banyak aplikasi yang membutuhkan SU Anda</string>
    <string name="log_data_magisk_none">Log Magisk kosong, ini aneh</string>
    <string name="menuSaveLog">Simpan log</string>
    <string name="menuClearLog">Hapus log sekarang</string>
    <string name="logs_cleared">Log berhasil dihapus</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Target UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Tampilkan aplikasi sistem</string>
    <string name="show_os_app">Tampilkan aplikasi OS</string>
    <string name="hide_filter_hint">Filter menurut nama</string>
    <string name="hide_search">Telusuri</string>

    <!--Module-->
    <string name="no_info_provided">(Info tidak tersedia)</string>
    <string name="reboot_userspace">Mulai ulang secara halus</string>
    <string name="reboot_recovery">Mulai ulang ke mode Recovery</string>
    <string name="reboot_bootloader">Mulai ulang ke mode Bootloader</string>
    <string name="reboot_download">Mulai ulang ke mode Download</string>
    <string name="reboot_edl">Mulai ulang ke mode EDL</string>
    <string name="module_version_author">%1$s oleh %2$s</string>
    <string name="module_state_remove">Hapus</string>
    <string name="module_state_restore">Pulihkan</string>
    <string name="module_action_install_external">Pasang dari penyimpanan</string>
    <string name="update_available">Pembaruan tersedia</string>
    <string name="suspend_text_riru">Modul ditangguhkan karena %1$s diaktifkan</string>
    <string name="suspend_text_zygisk">Modul ditangguhkan karena %1$s tidak diaktifkan</string>
    <string name="zygisk_module_unloaded">Modul Zygisk tidak dimuat karena ketidakcocokan</string>
    <string name="module_empty">Tidak ada modul terpasang</string>
    <string name="confirm_install">Pasang modul %1$s?</string>
    <string name="confirm_install_title">Konfirmasi Pasang</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Mode tema</string>
    <string name="settings_dark_mode_message">Pilih mode yang paling cocok dengan gaya Anda!</string>
    <string name="settings_dark_mode_light">Selalu terang</string>
    <string name="settings_dark_mode_system">Ikuti sistem</string>
    <string name="settings_dark_mode_dark">Selalu gelap</string>
    <string name="settings_download_path_title">Lokasi unduhan</string>
    <string name="settings_download_path_message">File akan disimpan ke %1$s</string>
    <string name="settings_hide_app_title">Sembunyikan aplikasi Magisk</string>
    <string name="settings_hide_app_summary">Pasang aplikasi proxy dengan ID paket acak dan label aplikasi khusus</string>
    <string name="settings_restore_app_title">Pulihkan aplikasi Magisk</string>
    <string name="settings_restore_app_summary">Tampilkan aplikasi and pulihkan APK asli</string>
    <string name="language">Bahasa</string>
    <string name="system_default">(Bawaan sistem)</string>
    <string name="settings_check_update_title">Periksa pembaruan</string>
    <string name="settings_check_update_summary">Periksa pembaruan secara berkala di latar belakang</string>
    <string name="settings_update_channel_title">Saluran pembaruan</string>
    <string name="settings_update_stable">Stabil</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Saluran khusus</string>
    <string name="settings_update_custom_msg">Masukkan URL khusus</string>
    <string name="settings_zygisk_summary">Jalankan bagian-bagian Magisk dalam zygote daemon</string>
    <string name="settings_denylist_title">Paksa DenyList</string>
    <string name="settings_denylist_summary">Proses pada denylist akan mengembalikan semua modifikasi Magisk</string>
    <string name="settings_denylist_config_title">Konfigurasi DenyList</string>
    <string name="settings_denylist_config_summary">Pilih proses yang akan disertakan pada denylist</string>
    <string name="settings_hosts_title">Host systemless</string>
    <string name="settings_hosts_summary">Dukungan host secara systemless untuk aplikasi pemblokir iklan</string>
    <string name="settings_hosts_toast">Menambahkan modul host systemless</string>
    <string name="settings_app_name_hint">Nama baru</string>
    <string name="settings_app_name_helper">Aplikasi akan dikemas dengan nama tersebut</string>
    <string name="settings_app_name_error">Format tidak valid</string>
    <string name="settings_su_app_adb">Apl dan ADB</string>
    <string name="settings_su_app">Apl saja</string>
    <string name="settings_su_adb">ADB saja</string>
    <string name="settings_su_disable">Nonaktif</string>
    <string name="settings_su_request_10">10 detik</string>
    <string name="settings_su_request_15">15 detik</string>
    <string name="settings_su_request_20">20 detik</string>
    <string name="settings_su_request_30">30 detik</string>
    <string name="settings_su_request_45">45 detik</string>
    <string name="settings_su_request_60">60 detik</string>
    <string name="superuser_access">Akses superuser</string>
    <string name="auto_response">Respons otomatis</string>
    <string name="request_timeout">Batas waktu permintaan</string>
    <string name="superuser_notification">Notifikasi superuser</string>
    <string name="settings_su_reauth_title">Autentikasi ulang setelah peningkatan</string>
    <string name="settings_su_reauth_summary">Autentikasi ulang izin akses superuser setelah aplikasi ditingkatkan</string>
    <string name="settings_su_tapjack_title">Aktifkan perlindungan tapjacking</string>
    <string name="settings_su_tapjack_summary">Dialog permintaan superuser tidak akan menanggapi masukan saat terhalangi oleh lapisan atau jendela lainnya</string>
    <string name="settings_customization">Personalisasi</string>
    <string name="setting_add_shortcut_summary">Tambahkan pintasan yang menarik pada layar utama seandainya nama dan ikon sulit untuk dikenali setelah menyembunyikan aplikasi</string>
    <string name="settings_doh_title">DNS melalui HTTPS</string>
    <string name="settings_doh_description">Solusi untuk DNS poisoning di beberapa negara</string>

    <string name="multiuser_mode">Mode multi pengguna</string>
    <string name="settings_owner_only">Pemilik perangkat saja</string>
    <string name="settings_owner_manage">Pemilik perangkat mengelola</string>
    <string name="settings_user_independent">Pengguna independen</string>
    <string name="owner_only_summary">Hanya pemilik yang memiliki akses root</string>
    <string name="owner_manage_summary">Hanya pemilik yang dapat mengelola akses root dan menerima pesan permintaan</string>
    <string name="user_independent_summary">Setiap pengguna memiliki aturan root mereka sendiri</string>

    <string name="mount_namespace_mode">Mode ruang-nama mount</string>
    <string name="settings_ns_global">Ruang-nama global</string>
    <string name="settings_ns_requester">Ruang-nama warisan</string>
    <string name="settings_ns_isolate">Ruang-nama terpisah</string>
    <string name="global_summary">Semua sesi root menggunakan ruang-nama mount global</string>
    <string name="requester_summary">Sesi root akan mewarisi ruang-nama peminta mereka</string>
    <string name="isolate_summary">Setiap sesi root akan memiliki ruang-nama tersendiri</string>

    <!--Notifications-->
    <string name="update_channel">Pembaruan Magisk</string>
    <string name="progress_channel">Notifikasi Kemajuan</string>
    <string name="updated_channel">Pembaruan Selesai</string>
    <string name="download_complete">Unduhan selesai</string>
    <string name="download_file_error">Kesalahan saat mengunduh file</string>
    <string name="magisk_update_title">Pembaruan Magisk tersedia!</string>
    <string name="updated_title">Magisk Diperbarui</string>
    <string name="updated_text">Ketuk untuk buka aplikasi</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Ya</string>
    <string name="no">Tidak</string>
    <string name="repo_install_title">Pasang %1$s %2$s(%3$d)</string>
    <string name="download">Unduh</string>
    <string name="reboot">Mulai ulang</string>
    <string name="release_notes">Catatan rilis</string>
    <string name="flashing">Memasang…</string>
    <string name="done">Selesai!</string>
    <string name="failure">Gagal!</string>
    <string name="hide_app_title">Menyembunyikan aplikasi Magisk…</string>
    <string name="open_link_failed_toast">Tidak ditemukan aplikasi untuk membuka link ini</string>
    <string name="complete_uninstall">Pencopotan penuh</string>
    <string name="restore_img">Pulihkan image</string>
    <string name="restore_img_msg">Memulihkan…</string>
    <string name="restore_done">Pemulihan selesai!</string>
    <string name="restore_fail">Cadangan stock tidak ada!</string>
    <string name="setup_fail">Penyiapan gagal</string>
    <string name="env_fix_title">Perlu penyiapan tambahan</string>
    <string name="env_fix_msg">Perangkat Anda membutuhkan pengaturan tambahan untuk Magisk agar berfungsi dengan benar. Apakah Anda ingin melanjutkan dan Menyalakan ulang?</string>
    <string name="env_full_fix_msg">Perangkat Anda membutuhkan pemasangan ulang Magisk agar berfungsi dengan baik. Silakan pasang ulang Magisk dalam aplikasi, mode recovery tidak dapat memperoleh info perangkat yang benar.</string>
    <string name="setup_msg">Memproses penyiapan lingkungan…</string>
    <string name="unsupport_magisk_title">Versi Magisk tidak didukung</string>
    <string name="unsupport_magisk_msg">Versi aplikasi ini tidak mendukung versi Magisk yang lebih rendah dari %1$s.\n\nAplikasi akan berperilaku seolah-olah tidak ada Magisk yang dipasang, harap tingkatkan Magisk sesegera mungkin.</string>
    <string name="unsupport_general_title">Keadaan tidak normal</string>
    <string name="unsupport_system_app_msg">Menjalankan aplikasi ini sebagai aplikasi sistem tidak didukung. Harap kembalikan aplikasi ke aplikasi pengguna.</string>
    <string name="unsupport_other_su_msg">Sebuah \"su\" biner bukan dari Magisk telah terdeteksi. Hapus semua solusi root yang bersaing dan/atau pasang ulang Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk dipasang ke penyimpanan eksternal. Harap pindahkan aplikasi ke penyimpanan internal.</string>
    <string name="unsupport_nonroot_stub_msg">Aplikasi Magisk yang tersembunyi tidak dapat terus berfungsi karena root hilang. Tolong pulihkan APK asli.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Berikan izin akses ke penyimpanan untuk mengaktifkan fungsi ini</string>
    <string name="post_notifications_denied">Berikan izin akses ke notifikasi untuk mengaktifkan fungsi ini</string>
    <string name="install_unknown_denied">Izinkan "Sumber tidak dikenal" untuk mengaktifkan fungsi ini</string>
    <string name="add_shortcut_title">Tambahkan pintasan ke layar utama</string>
    <string name="add_shortcut_msg">Setelah menyembunyikan aplikasi ini, nama dan ikonnya mungkin sulit dikenali. Apakah Anda ingin menambahkan pintasan cantik ke layar utama?</string>
    <string name="app_not_found">Tidak ditemukan aplikasi untuk menangani tindakan ini</string>
    <string name="reboot_apply_change">Mulai ulang untuk menerapkan perubahan</string>
    <string name="restore_app_confirmation">Ini akan mengembalikan aplikasi tersembunyi kembali ke aplikasi asli. Apakah Anda benar-benar ingin melakukan ini?</string>

</resources>

```

`app/core/src/main/res/values-it/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Moduli</string>
    <string name="superuser">Accesso root</string>
    <string name="logs">Registro eventi</string>
    <string name="settings">Impostazioni</string>
    <string name="install">Installa</string>
    <string name="section_home">Home</string>
    <string name="section_theme">Temi</string>
    <string name="denylist">Lista di blocco</string>

    <!--Home-->
    <string name="no_connection">Connessione non disponibile</string>
    <string name="app_changelog">Changelog</string>
    <string name="loading">Caricamento…</string>
    <string name="update">Aggiorna</string>
    <string name="not_available">N/D</string>
    <string name="hide">Nascondi</string>
    <string name="home_package">Pacchetto</string>
    <string name="home_app_title">App</string>

    <string name="home_notice_content">Scarica Magisk SOLTANTO dalla pagina GitHub ufficiale. I file provenienti da fonti sconosciute possono essere dannosi!</string>
    <string name="home_support_title">Supportaci</string>
    <string name="home_follow_title">Seguici</string>												   
    <string name="home_item_source">Codice sorgente</string>
    <string name="home_support_content">Magisk è, e sempre sarà, gratuito ed open source. Puoi comunque mostrarci il tuo apprezzamento facendo una donazione.</string>
    <string name="home_installed_version">Installata</string>
    <string name="home_latest_version">Ultima</string>
    <string name="invalid_update_channel">Canale di aggiornamento non valido</string>
    <string name="uninstall_magisk_title">Disinstalla Magisk</string>
    <string name="uninstall_magisk_msg">Tutti i moduli verranno disabilitati/rimossi!\nIl root verrà rimosso!\nGli spazi di archiviazione interni decriptati tramite l\'uso di Magisk verranno nuovamente criptati!</string>

    <!--Install-->
    <string name="keep_force_encryption">Mantieni crittografia forzata</string>
    <string name="keep_dm_verity">Mantieni AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Modalità recovery</string>
    <string name="install_options_title">Opzioni</string>
    <string name="install_method_title">Metodo</string>
    <string name="install_next">Avanti</string>
    <string name="install_start">Andiamo!</string>
    <string name="manager_download_install">Apri questa notifica per scaricare e installare</string>
    <string name="direct_install">Installazione diretta (raccomandata)</string>
    <string name="install_inactive_slot">Installa nello slot inattivo (dopo un aggiornamento OTA)</string>
    <string name="install_inactive_slot_msg">Questo dispositivo verrà FORZATO ad avviarsi usando lo slot inattivo!\nUsa questo metodo solo dopo che un aggiornamento OTA è stato installato.\nVuoi continuare?</string>
    <string name="setup_title">Configurazione aggiuntiva</string>
    <string name="select_patch_file">Seleziona e aggiorna un file</string>
    <string name="patch_file_msg">Seleziona un\'immagine in formato .img, un file .tar di ODIN o un file payload.bin</string>
    <string name="reboot_delay_toast">Riavvio fra 5 secondi…</string>
    <string name="flash_screen_title">Installazione</string>

    <!--Superuser-->
    <string name="su_request_title">Richiesta di accesso root</string>
    <string name="touch_filtered_warning">Magisk non può verificare la tua risposta perché un\'app sta oscurando una richiesta di accesso root</string>
    <string name="deny">Nega</string>
    <string name="prompt">Chiedi</string>
    <string name="grant">Consenti</string>
    <string name="su_warning">Concede il pieno accesso al dispositivo.\nNega se non sei sicuro!</string>
    <string name="forever">Sempre</string>
    <string name="once">Una volta</string>
    <string name="tenmin">10 minuti</string>
    <string name="twentymin">20 minuti</string>
    <string name="thirtymin">30 minuti</string>
    <string name="sixtymin">60 minuti</string>
    <string name="su_allow_toast">%1$s ha ottenuto i permessi di root</string>
    <string name="su_deny_toast">%1$s non ha ottenuto i permessi di root</string>
    <string name="su_snack_grant">%1$s potrà ottenere i permessi di root</string>
    <string name="su_snack_deny">%1$s non potrà più ottenere i permessi di root</string>
    <string name="su_snack_notif_on">Notifiche per %1$s abilitate</string>
    <string name="su_snack_notif_off">Notifiche per %1$s disabilitate</string>
    <string name="su_snack_log_on">Registrazione eventi abilitata per %1$s</string>
    <string name="su_snack_log_off">Registrazione eventi disabilitata per %1$s</string>
    <string name="su_revoke_title">Conferma revoca</string>
    <string name="su_revoke_msg">Confermi la revoca dei permessi a %1$s?</string>
    <string name="toast">Toast</string>
    <string name="none">Nessuno</string>

    <string name="superuser_toggle_notification">Notifiche</string>
    <string name="superuser_toggle_revoke">Revoca</string>
    <string name="superuser_policy_none">Nessuna app ha ancora chiesto i permessi di root.</string>

    <!--Logs-->
    <string name="log_data_none">Non ci sono eventi, prova ad utilizzare un\'app che richiede i permessi di root.</string>
    <string name="log_data_magisk_none">Il registro eventi di Magisk è vuoto, questo è davvero strano.</string>
    <string name="menuSaveLog">Salva registro eventi</string>
    <string name="menuClearLog">Svuota il registro eventi</string>
    <string name="logs_cleared">Registro eventi svuotato correttamente.</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Target UID: %1$d</string>

    <!-- MagiskHide -->
    <string name="show_system_app">Mostra app di sistema</string>
    <string name="show_os_app">Mostra app del sistema operativo</string>
    <string name="hide_filter_hint">Filtra per nome</string>
    <string name="hide_search">Cerca</string>

    <!--Module-->
    <string name="no_info_provided">(Nessuna informazione)</string>
    <string name="reboot_userspace">Riavvio veloce</string>
    <string name="reboot_recovery">Riavvia in recovery</string>
    <string name="reboot_bootloader">Riavvia in bootloader</string>
    <string name="reboot_download">Riavvia in modalità download</string>
    <string name="reboot_edl">Riavvia in modalità EDL</string>
    <string name="module_version_author">%1$s di %2$s</string>
    <string name="module_state_remove">Rimuovi</string>
    <string name="module_state_restore">Ripristina</string>
    <string name="module_action_install_external">Installa dal dispositivo</string>
    <string name="update_available">Aggiornamento disponibile</string>
    <string name="suspend_text_riru">Modulo sospeso perché %1$s è abilitato</string>
    <string name="suspend_text_zygisk">Modulo sospeso perché %1$s non è abilitato</string>
    <string name="zygisk_module_unloaded">Modulo Zygisk non caricato a causa di incompatibilità</string>
    <string name="module_empty">Nessun modulo installato</string>

    <!--Settings -->
    <string name="confirm_install">Vuoi installare il modulo %1$s?</string>
    <string name="confirm_install_title">Conferma installazione</string>
    <string name="settings_dark_mode_title">Impostazioni tema</string>
    <string name="settings_dark_mode_message">Seleziona il tema che si adatta meglio al tuo stile!</string>
    <string name="settings_dark_mode_light">Chiaro</string>
    <string name="settings_dark_mode_system">Adatta al sistema</string>
    <string name="settings_dark_mode_dark">Scuro</string>
    <string name="settings_download_path_title">Percorso di download</string>
    <string name="settings_download_path_message">I file verranno salvati in %1$s</string>
    <string name="settings_hide_app_title">Nascondi l\'app di Magisk</string>
    <string name="settings_hide_app_summary">Installa un\'app \"proxy\" con un ID pacchetto casuale e un nome personalizzato</string>
    <string name="settings_restore_app_title">Ripristina l\'app di Magisk</string>
    <string name="settings_restore_app_summary">Rendi l\'app nuovamente rilevabile e ripristina l\'APK originale</string>
    <string name="language">Lingua</string>
    <string name="system_default">(Sistema)</string>
    <string name="settings_check_update_title">Controlla aggiornamenti</string>
    <string name="settings_check_update_summary">Controlla automaticamente gli aggiornamenti in background</string>
    <string name="settings_update_channel_title">Canale di aggiornamento</string>
    <string name="settings_update_stable">Stabile</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Personalizzato</string>
    <string name="settings_update_custom_msg">Inserisci l\'URL del canale personalizzato</string>
    <string name="settings_zygisk_summary">Esegui parti di Magisk nel processo zygote</string>
    <string name="settings_denylist_title">Applica lista di blocco</string>
    <string name="settings_denylist_summary">Tutte le modifiche apportate da Magisk verranno annullate per i processi in lista di blocco</string>
    <string name="settings_denylist_config_title">Configura lista di blocco</string>
    <string name="settings_denylist_config_summary">Seleziona i processi da includere nella lista di blocco</string>
    <string name="settings_hosts_title">File hosts systemless</string>
    <string name="settings_hosts_summary">Supporto al file hosts systemless per le app che bloccano le pubblicità</string>
    <string name="settings_hosts_toast">Aggiunto modulo per il supporto al file hosts systemless</string>
    <string name="settings_app_name_hint">Nuovo nome</string>
    <string name="settings_app_name_helper">L\'app sarà ricreata con questo nome</string>
    <string name="settings_app_name_error">Formato non valido</string>
    <string name="settings_su_app_adb">App e ADB</string>
    <string name="settings_su_app">Solo app</string>
    <string name="settings_su_adb">Solo ADB</string>
    <string name="settings_su_disable">Disabilitato</string>
    <string name="settings_su_request_10">10 secondi</string>
    <string name="settings_su_request_15">15 secondi</string>
    <string name="settings_su_request_20">20 secondi</string>
    <string name="settings_su_request_30">30 secondi</string>
    <string name="settings_su_request_45">45 secondi</string>
    <string name="settings_su_request_60">60 secondi</string>
    <string name="superuser_access">Accesso root</string>
    <string name="auto_response">Azione predefinita</string>
    <string name="request_timeout">Timeout richiesta</string>
    <string name="superuser_notification">Notifica di accesso root</string>
    <string name="settings_su_reauth_title">Riautentica dopo aggiornamento</string>
    <string name="settings_su_reauth_summary">Richiedi nuovamente i permessi di root dopo l\'aggiornamento di un\'app</string>
    <string name="settings_su_tapjack_title">Protezione anti-tapjacking</string>
    <string name="settings_su_tapjack_summary">La schermata di richiesta dei permessi di root non risponderà al tocco mentre è oscurata da altre finestre o elementi in sovraimpressione</string>
    <string name="settings_su_auth_title">Autenticazione utente</string>
    <string name="settings_su_auth_summary">Richiedi l\'autenticazione dell\'utente per le richieste di accesso root</string>
    <string name="settings_su_auth_insecure">Sul dispositivo non è configurato alcun metodo di autenticazione</string>
    <string name="settings_customization">Personalizzazione</string>
    <string name="setting_add_shortcut_summary">Aggiungi un collegamento alla schermata iniziale se il nome e l\'icona sono difficili da riconoscere dopo aver nascosto l\'app</string>
    <string name="settings_doh_title">DNS over HTTPS</string>
    <string name="settings_doh_description">Aggira il DNS poisoning in alcune nazioni</string>

    <string name="multiuser_mode">Modalità multiutente</string>
    <string name="settings_owner_only">Solo per il proprietario del dispositivo</string>
    <string name="settings_owner_manage">Gestito dal proprietario del dispositivo</string>
    <string name="settings_user_independent">Indipendente dall\'utente</string>
    <string name="owner_only_summary">Solo il proprietario possiede i permessi di root</string>
    <string name="owner_manage_summary">Solo il proprietario può gestire l\'accesso root e ricevere le richieste dalle app</string>
    <string name="user_independent_summary">Ogni utente ha le proprie regole di root indipendenti</string>

    <string name="mount_namespace_mode">Modalità mount namespace</string>
    <string name="settings_ns_global">Namespace globale</string>
    <string name="settings_ns_requester">Namespace ereditato</string>
    <string name="settings_ns_isolate">Namespace isolato</string>
    <string name="global_summary">Tutte le sessioni di root erediteranno il namespace globale</string>
    <string name="requester_summary">Le sessioni di root erediteranno il namespace del loro richiedente</string>
    <string name="isolate_summary">Ogni sessione di root avrà il suo namespace isolato</string>

    <!--Notifications-->
    <string name="update_channel">Aggiornamenti di Magisk</string>
    <string name="progress_channel">Notifiche di avanzamento</string>
    <string name="updated_channel">Aggiornamento completato</string>
    <string name="download_complete">Download completato</string>
    <string name="download_file_error">Errore durante il download del file</string>
    <string name="magisk_update_title">È disponibile un aggiornamento di Magisk!</string>
    <string name="updated_title">Magisk è stato aggiornato</string>
    <string name="updated_text">Tocca per aprire l\'app</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Sì</string>
    <string name="no">No</string>
    <string name="repo_install_title">Installazione di %1$s %2$s(%3$d)</string>
    <string name="download">Download</string>
    <string name="reboot">Riavvia</string>
    <string name="release_notes">Note di rilascio</string>
    <string name="flashing">Flash in corso…</string>
    <string name="done">Completato!</string>
    <string name="failure">Fallito</string>
    <string name="hide_app_title">Sto nascondendo l\'app di Magisk…</string>
    <string name="open_link_failed_toast">Nessuna app disponibile per aprire il link</string>
    <string name="complete_uninstall">Disinstalla completamente</string>
    <string name="restore_img">Ripristina immagini</string>
    <string name="restore_img_msg">Ripristino…</string>
    <string name="restore_done">Ripristino completato!</string>
    <string name="restore_fail">Non esiste un backup dell\'immagine di boot originale!</string>
    <string name="setup_fail">Configurazione fallita</string>
    <string name="env_fix_title">Configurazione aggiuntiva richiesta</string>
    <string name="env_fix_msg">Il tuo dispositivo necessita di una configurazione aggiuntiva per far funzionare Magisk correttamente. Vuoi procedere e riavviare il dispositivo?</string>
    <string name="env_full_fix_msg">È necessario eseguire di nuovo il flash di Magisk per farlo funzionare correttamente. Reinstalla Magisk utilizzando l\'app, in modalità recovery non è possibile ottenere informazioni corrette sul dispositivo.</string>
    <string name="setup_msg">Configurazione dell\'ambiente in corso…</string>
    <string name="unsupport_magisk_title">Versione di Magisk non supportata</string>
    <string name="unsupport_magisk_msg">Questa versione dell\'app non supporta le versioni di Magisk inferiori a %1$s.\n\nL\'app si comporterà come se Magisk non fosse installato: aggiornalo il prima possibile.</string>
    <string name="unsupport_general_title">Stato anomalo rilevato</string>
    <string name="unsupport_system_app_msg">L\'esecuzione di quest\'app come app di sistema non è supportata. Reinstallala come applicazione utente.</string>
    <string name="unsupport_other_su_msg">È stato rilevato un binario \"su\" che non appartiene a Magisk. Rimuovi qualsiasi altro sistema di root e/o reinstalla Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk è installato nella memoria esterna. Sposta l\'app nella memoria interna.</string>
    <string name="unsupport_nonroot_stub_msg">Dal momento che i permessi di root sono stati persi, l\'app di Magisk nascosta non può più funzionare. Ripristina l\'APK originale.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Consenti l\'accesso alla memoria del dispositivo per abilitare questa opzione</string>
    <string name="post_notifications_denied">Consenti l\'invio di notifiche per abilitare questa opzione</string>
    <string name="install_unknown_denied">Consenti l\'installazione di app sconosciute per abilitare questa funzionalità</string>
    <string name="add_shortcut_title">Aggiungi collegamento alla schermata iniziale</string>
    <string name="add_shortcut_msg">Dopo aver nascosto quest\'app, il suo nome e la sua icona potrebbero diventare difficili da riconoscere. Vuoi aggiungere una scorciatoia alla schermata principale?</string>
    <string name="app_not_found">Non è stata trovata un\'app per gestire questa azione</string>
    <string name="reboot_apply_change">Riavvia per applicare le modifiche</string>
    <string name="restore_app_confirmation">L\'app nascosta verrà sostituita con la versione originale. Sei sicuro di voler continuare?</string>

</resources>

```

`app/core/src/main/res/values-iw/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">מודולים</string>
    <string name="superuser">משתמש על</string>
    <string name="logs">Log</string>
    <string name="settings">הגדרות</string>
    <string name="install">התקנה</string>
    <string name="section_home">בית</string>
    <string name="section_theme">עיצוב</string>
    <string name="denylist">רשימת דחייה</string>

    <!--Home-->
    <string name="no_connection">אין חיבור זמין</string>
    <string name="app_changelog">רשימת שינויים</string>
    <string name="loading">טוען…</string>
    <string name="update">עדכון</string>
    <string name="not_available">לא זמין</string>
    <string name="hide">הסתרה</string>
    <string name="home_package">חבילה</string>
    <string name="home_app_title">יישום</string>
    <string name="home_notice_content">יש להוריד את Magisk רק מהדף הרשמי של GitHub. קבצים ממקורות לא ידועים יכולים להיות זדוניים!</string>
    <string name="home_support_title">תמיכה בנו</string>
    <string name="home_follow_title">עקבו אחרינו</string>
    <string name="home_item_source">מקור</string>
    <string name="home_support_content">Magisk היה ותמיד יהיה בקוד פתוח. עם זאת באפשרותך להראות לנו שאכפת לך על ידי שליחת תרומה קטנה.</string>
    <string name="home_installed_version">מותקנת</string>
    <string name="home_latest_version">אחרונה</string>
    <string name="invalid_update_channel">ערוץ עדכון לא חוקי</string>
    <string name="uninstall_magisk_title">הסרת Magisk</string>
    <string name="uninstall_magisk_msg">כל המודולים יושבתו/יוסרו!\nגישת Root תושבת!\nהנתונים שלך עשויים להיות מוצפנים אם לא הוצפנו כבר!</string>

    <!--Install-->
    <string name="keep_force_encryption">שמירה על הצפנה בכח</string>
    <string name="keep_dm_verity">שמירה על AVB 2.0/dm-verity</string>
    <string name="recovery_mode">מצב Recovery</string>
    <string name="install_options_title">אפשרויות</string>
    <string name="install_method_title">שיטה</string>
    <string name="install_next">הבא</string>
    <string name="install_start">צא לדרך</string>
    <string name="manager_download_install">לחיצה להורדה והתקנה</string>
    <string name="direct_install">התקנה ישירה (מומלץ)</string>
    <string name="install_inactive_slot">התקנה לסלוט לא פעיל (לאחר OTA)</string>
    <string name="install_inactive_slot_msg">ההתקן שלך ייאלץ אתחול לסלוט הלא פעיל הנוכחי שלך לאחר הפעלה מחדש!\nיש להשתמש באפשרות זו רק לאחר ביצוע OTA בלבד.\nלהמשיך?</string>
    <string name="setup_title">התקנה נוספת</string>
    <string name="select_patch_file">בחירה והתקנת קובץ</string>
    <string name="patch_file_msg">בחירת קובץ גולמי (*.img) או ODIN tarfile (*.tar) או payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">מאתחל בעוד 5 שניות…</string>
    <string name="flash_screen_title">התקנה</string>

    <!--Superuser-->
    <string name="su_request_title">בקשות משתמש על</string>
    <string name="touch_filtered_warning">מכיוון שיישום מסתיר בקשה של משתמש על, Magisk לא יכול לאמת את תגובתך</string>
    <string name="deny">דחייה</string>
    <string name="prompt">מיידי</string>
    <string name="grant">הענקה</string>
    <string name="su_warning">מעניק גישה מלאה להתקן שלך.\nיש לדחות באי וודאות!</string>
    <string name="forever">לצמיתות</string>
    <string name="once">פעם אחת</string>
    <string name="tenmin">10 דקות</string>
    <string name="twentymin">20 דקות</string>
    <string name="thirtymin">חצי שעה</string>
    <string name="sixtymin">שעה</string>
    <string name="su_allow_toast">%1$s קיבל הרשאות משתמש על</string>
    <string name="su_deny_toast">%1$s נשללו הרשאות משתמש על</string>
    <string name="su_snack_grant">הרשאות משתמש על עבור %1$s הוענקו</string>
    <string name="su_snack_deny">הרשאות משתמש על עבור %1$s נשללו</string>
    <string name="su_snack_notif_on">התראות של %1$s מופעלות</string>
    <string name="su_snack_notif_off">התראות של %1$s מושבתות</string>
    <string name="su_snack_log_on">Log עבור %1$s מופעל</string>
    <string name="su_snack_log_off">Log עבור %1$s מושבת</string>
    <string name="su_revoke_title">להסיר?</string>
    <string name="su_revoke_msg">נא לאשר שלילת הרשאות עבור %1$s?</string>
    <string name="toast">התראה</string>
    <string name="none">ללא</string>
    <string name="superuser_toggle_notification">התראות</string>
    <string name="superuser_toggle_revoke">הסרה</string>
    <string name="superuser_policy_none">טרם נתבקשו הרשאות משתמש על על ידי יישומים</string>

    <!--Logs-->
    <string name="log_data_none">אין Log, יש לנסות להשתמש יותר ביישומי הRoot שלך</string>
    <string name="log_data_magisk_none">Log Magisk ריק, זה מוזר</string>
    <string name="menuSaveLog">שמירת Log</string>
    <string name="menuClearLog">ניקוי Log כעת</string>
    <string name="logs_cleared">Log נוקה בהצלחה</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">יעד UID: %1$d</string>
    <string name="target_pid">מציב ns יעד PID: %s</string>
    <string name="selinux_context">הקשר SELinux: %s</string>
    <string name="supp_group">קבוצה משלימה: %s</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">הצגת יישומי מערכת</string>
    <string name="show_os_app">הצגת יישומי מערכת הפעלה</string>
    <string name="hide_filter_hint">סינון לפי שם</string>
    <string name="hide_search">חיפוש</string>

    <!--Module-->
    <string name="no_info_provided">(לא סופק מידע)</string>
    <string name="reboot_userspace">אתחול רך</string>
    <string name="reboot_recovery">אתחול למצב Recovery</string>
    <string name="reboot_bootloader">אתחול לBootloader</string>
    <string name="reboot_download">אתחול למצב הורדה</string>
    <string name="reboot_edl">אתחול למצב EDL</string>
    <string name="reboot_safe_mode">מצב בטוח</string>
    <string name="module_version_author">%1$s מאת %2$s</string>
    <string name="module_state_remove">הסרה</string>
    <string name="module_action">פעולה</string>
    <string name="module_state_restore">שיחזור</string>
    <string name="module_action_install_external">התקנה מהאחסון</string>
    <string name="update_available">עדכונים זמינים</string>
    <string name="suspend_text_riru">מודול מושעה כי %1$s מופעל</string>
    <string name="suspend_text_zygisk">המודול הושעה כי %1$s אינו מופעל</string>
    <string name="zygisk_module_unloaded">מודול Zygisk לא נטען עקב חוסר תאימות</string>
    <string name="module_empty">לא מותקן מודול</string>
    <string name="confirm_install">להתקין מודול %1$s?</string>
    <string name="confirm_install_title">אישור התקנה</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">מצב עיצוב</string>
    <string name="settings_dark_mode_message">נא לבחור מצב המתאים ביותר לסגנון שלך!</string>
    <string name="settings_dark_mode_light">תמיד בהיר</string>
    <string name="settings_dark_mode_system">בהתאם למערכת</string>
    <string name="settings_dark_mode_dark">תמיד כהה</string>
    <string name="settings_download_path_title">נתיב הורדה</string>
    <string name="settings_download_path_message">הקבצים ישמרו אל %1$s</string>
    <string name="settings_hide_app_title">הסתרת היישום Magisk</string>
    <string name="settings_hide_app_summary">התקנת יישום מתווך עם מזהה חבילה אקראי ותווית שם מותאמת אישית</string>
    <string name="settings_restore_app_title">שיחזור היישום Magisk</string>
    <string name="settings_restore_app_summary">ביטול הסתרת היישום ושיחזור אל ה-APK המקורי</string>
    <string name="language">שפה</string>
    <string name="system_default">(ברירת מחדל מערכת)</string>
    <string name="settings_check_update_title">בדיקת עדכונים</string>
    <string name="settings_check_update_summary">בדיקה מעת לעת ברקע אם יש עדכונים</string>
    <string name="settings_update_channel_title">ערוץ עדכון</string>
    <string name="settings_update_stable">יציב</string>
    <string name="settings_update_beta">בטא</string>
    <string name="settings_update_custom">מותאם אישית</string>
    <string name="settings_update_custom_msg">הזנת כתובת מותאמת אישית</string>
    <string name="settings_zygisk_summary">הפעל חלקים של Magisk בדמון zygote</string>
    <string name="settings_denylist_title">אכיפת רשימת דחייה</string>
    <string name="settings_denylist_summary">כל השינויים של Magisk יוחזרו לתהליכים ברשימת הדחייה</string>
    <string name="settings_denylist_config_title">הגדרת רשימת הדחייה</string>
    <string name="settings_denylist_config_summary">בחירת התהליכים שייכללו ברשימת הדחייה</string>
    <string name="settings_hosts_title">hosts חסרי מערכת</string>
    <string name="settings_hosts_summary">hosts חסרי מערכת תומכים ביישומים חוסמי פרסומות</string>
    <string name="settings_hosts_toast">הוספת מודול hosts חסרי מערכת</string>
    <string name="settings_app_name_hint">שם חדש</string>
    <string name="settings_app_name_helper">היישום יארז מחדש בשם זה</string>
    <string name="settings_app_name_error">פורמט לא חוקי</string>
    <string name="settings_su_app_adb">יישומים ו-ADB</string>
    <string name="settings_su_app">יישומים בלבד</string>
    <string name="settings_su_adb">ADB בלבד</string>
    <string name="settings_su_disable">מושבת</string>
    <string name="settings_su_request_10">10 שניות</string>
    <string name="settings_su_request_15">15 שניות</string>
    <string name="settings_su_request_20">20 שניות</string>
    <string name="settings_su_request_30">30 שניות</string>
    <string name="settings_su_request_45">45 שניות</string>
    <string name="settings_su_request_60">60 שניות</string>
    <string name="superuser_access">גישת משתמש על</string>
    <string name="auto_response">תגובה אוטומטית</string>
    <string name="request_timeout">בקשת פסק זמן</string>
    <string name="superuser_notification">התראות משתמש על</string>
    <string name="settings_su_reauth_title">אימות מחדש לאחר שדרוג</string>
    <string name="settings_su_reauth_summary">אימות מחדש הרשאות של משתמש על לאחר שדרוג יישום</string>
    <string name="settings_su_tapjack_title">הגנת Tapjacking</string>
    <string name="settings_su_tapjack_summary">תיבת הדו שיח של משתמש העל לא תגיב לקלט כשהיא מוסתרת על ידי חלון או שכבת על אחרת</string>
    <string name="settings_su_auth_title">אימות משתמש</string>
    <string name="settings_su_auth_summary">בקשת אימות משתמש במהלך בקשות משתמש על</string>
    <string name="settings_su_auth_insecure">לא מוגדרת שיטת אימות בהתקן</string>
    <string name="settings_customization">התאמה אישית</string>
    <string name="setting_add_shortcut_summary">הוספת קיצור דרך יפה במסך הבית למקרה שקשה לזהות את השם ואת הסמל לאחר הסתרת היישום</string>
    <string name="settings_doh_title">DNS על HTTPS</string>
    <string name="settings_doh_description">עקיפת DNS מורעל במדינות מסוימות</string>
    <string name="settings_random_name_title">שם פלט אקראי</string>
    <string name="settings_random_name_description">שם אקראי לקובץ הפלט של תמונות מתוקנות וקבצי tar כדי למנוע זיהוי</string>
    <string name="multiuser_mode">מצב מרובה משתמשים</string>
    <string name="settings_owner_only">בעל ההתקן בלבד</string>
    <string name="settings_owner_manage">אחראי ניהול ההתקן</string>
    <string name="settings_user_independent">משתמש עצמאי</string>
    <string name="owner_only_summary">לבעלים בלבד ישנה גישת Root</string>
    <string name="owner_manage_summary">הבעלים בלבד יכול לנהל גישת Root ולקבל הנחיות לבקשה</string>
    <string name="user_independent_summary">לכל משתמש יש כללי Root נפרדים משלו</string>
    <string name="mount_namespace_mode">מצב הצבת מרחב שם</string>
    <string name="settings_ns_global">מרחב שם גלובלי</string>
    <string name="settings_ns_requester">מרחב שם מורש</string>
    <string name="settings_ns_isolate">מרחב שם מבודד</string>
    <string name="global_summary">כלל חיבורי הRoot משתמשים במרחב שם הגלובלי</string>
    <string name="requester_summary">חיבורי הRoot יירשו את מרחב השם של המבקש</string>
    <string name="isolate_summary">לכל חיבור Root יהיה מרחב שם מבודד</string>

    <!--Notifications-->
    <string name="update_channel">עדכוני Magisk</string>
    <string name="progress_channel">התראות התקדמות</string>
    <string name="updated_channel">העדכון הושלם</string>
    <string name="download_complete">ההורדה הושלמה</string>
    <string name="download_file_error">שגיאה בהורדת קובץ</string>
    <string name="magisk_update_title">עדכון Magisk זמין!</string>
    <string name="updated_title">עדכון Magisk</string>
    <string name="updated_text">הקשה כדי לפתוח יישום</string>

    <!--Toasts, Dialogs-->
    <string name="yes">כן</string>
    <string name="no">לא</string>
    <string name="repo_install_title">מתקין %1$s %2$s(%3$d)</string>
    <string name="download">הורדה</string>
    <string name="reboot">הפעלה מחדש</string>
    <string name="close">סגירה</string>
    <string name="release_notes">הערות שחרור</string>
    <string name="flashing">צורב…</string>
    <string name="running">רץ…</string>
    <string name="done">בוצע!</string>
    <string name="done_action">בוצעה ריצת פעולה של %1$s</string>
    <string name="failure">נכשל!</string>
    <string name="hide_app_title">מסתיר את יישום Magisk…</string>
    <string name="open_link_failed_toast">לא נמצאו יישומים לפתיחת קישור זה</string>
    <string name="complete_uninstall">הסרה מלאה</string>
    <string name="restore_img">שיחזור תמונות</string>
    <string name="restore_img_msg">משחזר…</string>
    <string name="restore_done">השיחזור בוצע!</string>
    <string name="restore_fail">גיבוי מקורי אינו קיים!</string>
    <string name="setup_fail">ההתקנה כשלה</string>
    <string name="env_fix_title">דורש התקנה נוספת</string>
    <string name="env_fix_msg">ההתקן שלך זקוק להתקנה נוספת כדי ש-Magisk יפעל כראוי. האם ברצונך להמשיך ולהפעיל מחדש?</string>
    <string name="env_full_fix_msg">ההתקן שלך זקוק לצריבה מחדש של Magisk כדי לעבוד כראוי. נא להתקין מחדש את Magisk בתוך היישום, מצב הRecovery אינו יכול לקבל מידע נכון על ההתקן.</string>
    <string name="setup_msg">הגדרת סביבת ריצה…</string>
    <string name="unsupport_magisk_title">גרסת Magisk אינה נתמכת</string>
    <string name="unsupport_magisk_msg">גרסה זו של היישום אינה תומכת ביישום  Magisk הנמוך מ- %1$s.\n\nהיישום יתנהג כאילו Magisk אינו מותקן,יש לשדרג את Magisk במהירות האפשריות.</string>
    <string name="unsupport_general_title">מצב לא תקין</string>
    <string name="unsupport_system_app_msg">הפעלת יישום זה כיישום מערכת אינה נתמך. נא להשיב את היישום כיישום משתמש.</string>
    <string name="unsupport_other_su_msg">התגלתה פקודת \"su\" שאינה שייכת ליישום Magisk נא להסיר את הפקודה שאינה נתמכת.</string>
    <string name="unsupport_external_storage_msg">Magisk מותקן באחסון החיצוני. נא להעביר את היישום לאחסון הפנימי.</string>
    <string name="unsupport_nonroot_stub_msg">היישום אינו יכול להמשיך לעבוד במצב הנסתר מכיוון שגישת הRoot אבדה. נא לשחזר אותו חזרה ל-APK המקורי.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">הענת הרשאת אחסון להפעלת פונקציה זו</string>
    <string name="post_notifications_denied">הענקת הרשאה להתראות כדי להפעיל פונקציה זו</string>
    <string name="install_unknown_denied">יש לאפשר "התקנה ממקורות לא ידועים" בכדי להפעיל פונקציה זו</string>
    <string name="add_shortcut_title">הוספת קיצור דרך למסך הבית</string>
    <string name="add_shortcut_msg">לאחר הסתרת היישום הזה, השם והסמליל שלה עשויים להיות קשים לזיהוי. האם ברצונך להוסיף קיצור דרך יפה למסך הבית?</string>
    <string name="app_not_found">לא נמצא יישום לטיפול בפעולה זו</string>
    <string name="reboot_apply_change">ייש להפעיל מחדש כדי להחיל שינויים</string>
    <string name="restore_app_confirmation">פעולה זו תשחזר את היישום המוסתר חזרה ליישום המקורי. האם בוודאות ברצונך לעשות את זה?</string>

</resources>

```

`app/core/src/main/res/values-ja/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">モジュール</string>
    <string name="superuser">スーパーユーザー</string>
    <string name="logs">ログ</string>
    <string name="settings">設定</string>
    <string name="install">インストール</string>
    <string name="section_home">ホーム</string>
    <string name="section_theme">テーマ</string>
    <string name="denylist">DenyList</string>

    <!--Home-->
    <string name="no_connection">インターネット接続なし</string>
    <string name="app_changelog">アプリの更新履歴</string>
    <string name="loading">読み込み中…</string>
    <string name="update">更新</string>
    <string name="not_available">なし</string>
    <string name="hide">隠す</string>
    <string name="home_package">パッケージ ID </string>
    <string name="home_app_title">アプリ</string>

    <string name="home_notice_content">Magisk は必ず公式の GitHub ページからダウンロードしてください。その他の提供元では悪意あるコードを含んでいる可能性があります!</string>
    <string name="home_support_title">サポートする</string>
    <string name="home_follow_title">フォローする</string>
    <string name="home_item_source">ソース</string>
    <string name="home_support_content">Magisk はフリーでオープンソースです。寄付を送ると､ Magisk の開発を支援することができます。</string>
    <string name="home_installed_version">インストール済</string>
    <string name="home_latest_version">最新版</string>
    <string name="invalid_update_channel">不正な更新チャンネルです</string>
    <string name="uninstall_magisk_title">Magisk のアンインストール</string>
    <string name="uninstall_magisk_msg">すべてのモジュールが無効化/削除されます。\nアンインストール後は root が削除され､ストレージが暗号化されていない場合は暗号化される場合があります。</string>

    <!--Install-->
    <string name="keep_force_encryption">暗号化を維持する</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity を維持する</string>
    <string name="recovery_mode">リカバリーモード</string>
    <string name="install_options_title">オプション</string>
    <string name="install_method_title">方法</string>
    <string name="install_next">次へ</string>
    <string name="install_start">はじめる</string>
    <string name="manager_download_install">タップしてダウンロード＆インストールします</string>
    <string name="direct_install">直接インストール (推奨)</string>
    <string name="install_inactive_slot">別のスロットにインストール (OTA 後)</string>
    <string name="install_inactive_slot_msg">お使いのデバイスは再起動後に現在とは別のスロットで強制的に起動されます！\nこのオプションは OTA の完了後にのみ使用してください。\n続行しますか？</string>
    <string name="setup_title">追加セットアップ</string>
    <string name="select_patch_file">パッチするファイルの選択</string>
    <string name="patch_file_msg">イメージファイル (*.img) または ODIN tar ファイル (*.tar) を選択してください</string>
    <string name="reboot_delay_toast">5秒後に再起動します…</string>
    <string name="flash_screen_title">インストール</string>

    <!--Superuser-->
    <string name="su_request_title">スーパーユーザー権限の要求</string>
    <string name="touch_filtered_warning">他のアプリがスーパーユーザー権限の要求ダイアログを隠しているため、Magisk はあなたの応答を確認できません。</string>
    <string name="deny">拒否</string>
    <string name="prompt">尋ねる</string>
    <string name="grant">許可</string>
    <string name="su_warning">端末への完全なアクセスを許可します。\nもし確信が持てなければ拒否してください！</string>
    <string name="forever">今後も</string>
    <string name="once">今回のみ</string>
    <string name="tenmin">10 分</string>
    <string name="twentymin">20 分</string>
    <string name="thirtymin">30 分</string>
    <string name="sixtymin">60 分</string>
    <string name="su_allow_toast">%1$s のスーパーユーザー権限を許可しました</string>
    <string name="su_deny_toast">%1$s のスーパーユーザー権限を拒否しました</string>
    <string name="su_snack_grant">%1$s のスーパーユーザー権限を許可しました</string>
    <string name="su_snack_deny">%1$s のスーパーユーザー権限を拒否しました</string>
    <string name="su_snack_notif_on">%1$s の通知は有効です</string>
    <string name="su_snack_notif_off">%1$s の通知は無効です</string>
    <string name="su_snack_log_on">%1$s のログは有効です</string>
    <string name="su_snack_log_off">%1$s のログは無効です</string>
    <string name="su_revoke_title">確認</string>
    <string name="su_revoke_msg">%1$s の権限を取り消しますか？</string>
    <string name="toast">トースト通知</string>
    <string name="none">なし</string>

    <string name="superuser_toggle_notification">通知</string>
    <string name="superuser_toggle_revoke">取り消し</string>
    <string name="superuser_policy_none">スーパーユーザー権限の許可を求めたアプリはまだありません</string>

    <!--Logs-->
    <string name="log_data_none">ログはありません。スーパーユーザー権限を使用するアプリをもっと使ってみてください</string>
    <string name="log_data_magisk_none">おかしなことに Magisk のログは空です</string>
    <string name="menuSaveLog">ログを保存</string>
    <string name="menuClearLog">ログを消去</string>
    <string name="logs_cleared">ログを消去しました</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">ターゲット UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">システムアプリを表示</string>
    <string name="show_os_app">OS アプリを表示</string>
    <string name="hide_filter_hint">名前で絞り込み</string>
    <string name="hide_search">検索</string>

    <!--Module-->
    <string name="no_info_provided">(情報なし)</string>
    <string name="reboot_userspace">ソフトリブート</string>
    <string name="reboot_recovery">Recovery へ再起動</string>
    <string name="reboot_bootloader">Bootloader へ再起動</string>
    <string name="reboot_download">Download へ再起動</string>
    <string name="reboot_edl">EDL へ再起動</string>
    <string name="module_version_author">%1$s 開発者：%2$s</string>
    <string name="module_state_remove">削除</string>
    <string name="module_state_restore">復元</string>
    <string name="module_action_install_external">ストレージからインストール</string>
    <string name="update_available">更新あり</string>
    <string name="suspend_text_riru">モジュールは %1$s が有効化されているため休止しました</string>
    <string name="suspend_text_zygisk">モジュールは %1$s が有効化されていないため休止しました</string>
    <string name="zygisk_module_unloaded">互換性がないため Zygisk モジュールは読み込まれませんでした</string>
    <string name="module_empty">モジュールをインストールしていません</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">テーマ</string>
    <string name="settings_dark_mode_message">あなたの好きなスタイルを選びましょう！</string>
    <string name="settings_dark_mode_light">ライトモード</string>
    <string name="settings_dark_mode_system">システムに合わせる</string>
    <string name="settings_dark_mode_dark">ダークモード</string>
    <string name="settings_download_path_title">ファイルの保存場所</string>
    <string name="settings_download_path_message">ファイルは %1$s に保存されます</string>
    <string name="settings_hide_app_title">Magisk アプリを隠す</string>
    <string name="settings_hide_app_summary">ランダムなパッケージ ID と任意のアプリ名のプロキシアプリをインストールします</string>
    <string name="settings_restore_app_title">Magisk アプリを復元する</string>
    <string name="settings_restore_app_summary">隠すのを止めて、元の APK をインストールします</string>
    <string name="language">言語 (Language)</string>
    <string name="system_default">(システム標準)</string>
    <string name="settings_check_update_title">更新をチェック</string>
    <string name="settings_check_update_summary">バックグラウンドで定期的に更新をチェックします</string>
    <string name="settings_update_channel_title">更新チャンネル</string>
    <string name="settings_update_stable">安定版</string>
    <string name="settings_update_beta">ベータ版</string>
    <string name="settings_update_custom">カスタム</string>
    <string name="settings_update_custom_msg">カスタム URL を入力</string>
    <string name="settings_zygisk_summary">Magisk の一部を Zygote デーモン上で実行します</string>
    <string name="settings_denylist_title">DenyList を適用</string>
    <string name="settings_denylist_summary">DenyList 内のプロセスは Magisk の変更がすべて戻されます</string>
    <string name="settings_denylist_config_title">DenyList を構成</string>
    <string name="settings_denylist_config_summary">DenyList に含めるプロセスを選択します</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">広告ブロックアプリのための Systemless hosts サポートを有効化します</string>
    <string name="settings_hosts_toast">Systemless hosts モジュールを追加しました</string>
    <string name="settings_app_name_hint">アプリ名</string>
    <string name="settings_app_name_helper">プロキシアプリはこのアプリ名でインストールされます</string>
    <string name="settings_app_name_error">不正な形式</string>
    <string name="settings_su_app_adb">アプリと ADB</string>
    <string name="settings_su_app">アプリのみ</string>
    <string name="settings_su_adb">ADB のみ</string>
    <string name="settings_su_disable">無効</string>
    <string name="settings_su_request_10">10 秒</string>
    <string name="settings_su_request_15">15 秒</string>
    <string name="settings_su_request_20">20 秒</string>
    <string name="settings_su_request_30">30 秒</string>
    <string name="settings_su_request_45">45 秒</string>
    <string name="settings_su_request_60">60 秒</string>
    <string name="superuser_access">スーパーユーザー権限を使用できるプログラム</string>
    <string name="auto_response">自動応答</string>
    <string name="request_timeout">要求のタイムアウト</string>
    <string name="superuser_notification">スーパーユーザー通知</string>
    <string name="settings_su_reauth_title">アップグレード後の再認証</string>
    <string name="settings_su_reauth_summary">アプリのアップグレード後にスーパーユーザー権限を再認証します</string>
    <string name="settings_su_tapjack_title">タップジャッキング保護を有効にする</string>
    <string name="settings_su_tapjack_summary">他のウィンドウやオーバーレイで表示されている間は、スーパーユーザー権限の要求ダイアログが入力に応答しないようにします</string>
    <string name="settings_su_auth_title">ユーザー認証</string>
    <string name="settings_su_auth_summary">スーパーユーザー権限の要求でユーザー認証を行ないます</string>
    <string name="settings_su_auth_insecure">端末の認証方法が設定されていません</string>
    <string name="settings_customization">カスタマイズ</string>
    <string name="setting_add_shortcut_summary">アプリを隠した後に見つけられなくなったときは、ここでホーム画面にショートカットを追加できます</string>
    <string name="settings_doh_title">DNS over HTTPS</string>
    <string name="settings_doh_description">一部の国で DNS キャッシュポイズニングから守ります</string>

    <string name="multiuser_mode">複数ユーザーモード</string>
    <string name="settings_owner_only">端末の管理者のみ</string>
    <string name="settings_owner_manage">端末の管理者が管理</string>
    <string name="settings_user_independent">ユーザー毎</string>
    <string name="owner_only_summary">端末の管理者のみスーパーユーザー権限を利用できます</string>
    <string name="owner_manage_summary">端末の管理者のみがスーパーユーザー権限を管理し、要求を受け付けられます</string>
    <string name="user_independent_summary">ユーザー毎にそれぞれスーパーユーザー権限を設定できます</string>

    <string name="mount_namespace_mode">名前空間のマウントモード</string>
    <string name="settings_ns_global">グローバル名前空間</string>
    <string name="settings_ns_requester">継承された名前空間</string>
    <string name="settings_ns_isolate">分離された名前空間</string>
    <string name="global_summary">すべての root セッションがグローバル名前空間を使用します</string>
    <string name="requester_summary">root セッションはリクエスト者の名前空間を継承します</string>
    <string name="isolate_summary">root セッション毎に分離された名前空間を使用します</string>

    <!--Notifications-->
    <string name="update_channel">Magisk の更新</string>
    <string name="progress_channel">進捗通知</string>
    <string name="updated_channel">更新完了</string>
    <string name="download_complete">ダウンロード完了</string>
    <string name="download_file_error">ダウンロード中にエラーが発生しました</string>
    <string name="magisk_update_title">Magisk の更新があります！</string>
    <string name="updated_title">Magisk を更新しました</string>
    <string name="updated_text">タップでアプリを開きます</string>

    <!--Toasts, Dialogs-->
    <string name="yes">対応</string>
    <string name="no">非対応</string>
    <string name="repo_install_title">%1$s %2$s(%3$d) をインストール</string>
    <string name="download">ダウンロード</string>
    <string name="reboot">再起動</string>
    <string name="release_notes">更新履歴</string>
    <string name="flashing">書込中…</string>
    <string name="done">完了！</string>
    <string name="failure">失敗！</string>
    <string name="hide_app_title">Magisk アプリを隠しています…</string>
    <string name="open_link_failed_toast">このリンクを開けるアプリがありません</string>
    <string name="complete_uninstall">完全にアンインストール</string>
    <string name="restore_img">イメージのリストア</string>
    <string name="restore_img_msg">リストア中…</string>
    <string name="restore_done">リストア完了！</string>
    <string name="restore_fail">Stock のバックアップがありません！</string>
    <string name="setup_fail">セットアップに失敗しました</string>
    <string name="env_fix_title">追加のセットアップが必要です</string>
    <string name="env_fix_msg">Magisk を正常に動作させるためには追加のセットアップが必要です。今すぐ再起動しますか？</string>
    <string name="setup_msg">追加セットアップを実行中…</string>
    <string name="unsupport_magisk_title">対応していない Magisk バージョンです</string>
    <string name="unsupport_magisk_msg">このバージョンのアプリではバージョン %1$s 以下の Magisk に対応していません。\n\nアプリで Magisk を使えないため、すぐに Magisk を更新してください</string>
    <string name="unsupport_general_title">異常な状態です</string>
    <string name="unsupport_system_app_msg">このアプリをシステムアプリとして起動することはサポートされていません。ユーザーアプリに戻してください。</string>
    <string name="unsupport_other_su_msg">Magisk 以外の \"su\" バイナリが検出されました。競合する root 権限取得ソフトを削除し、Magisk をインストールし直してください。</string>
    <string name="unsupport_external_storage_msg">Magisk が外部ストレージにインストールされています。内部ストレージに移動してください。</string>
    <string name="unsupport_nonroot_stub_msg">root 権限が失われたため､隠し Magisk アプリが動作できなくなりました。元の APK を復元してください。</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">この機能を有効にするにはストレージ権限を許可してください</string>
    <string name="post_notifications_denied">この機能を有効化するには権限を許可してください</string>
    <string name="install_unknown_denied">この機能を有効化するには、不明なソースからのインストールを許可してください</string>
    <string name="add_shortcut_title">ホーム画面にショートカットを追加</string>
    <string name="add_shortcut_msg">アプリを隠すと、アプリ名やアイコンが判別しにくいことがあります。分かりやすいようホーム画面にショートカットを追加しますか？</string>
    <string name="app_not_found">このアクションを扱えるアプリがありません</string>
    <string name="reboot_apply_change">再起動して変更を適用</string>
    <string name="restore_app_confirmation">隠しアプリを元のアプリへと戻します。続行しますか?</string>

</resources>

```

`app/core/src/main/res/values-ka/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">მოდულები</string>
    <string name="superuser">სუპერმომხმარებელი</string>
    <string name="logs">ლოგები</string>
    <string name="settings">პარამეტრები</string>
    <string name="install">ინსტალაცია</string>
    <string name="section_home">საწყისი</string>
    <string name="section_theme">თემები</string>

    <!--Home-->
    <string name="no_connection">კავშირი არ არის</string>
    <string name="app_changelog">ცვლილებები</string>
    <string name="loading">იტვირთება…</string>
    <string name="update">განახლება</string>
    <string name="not_available">ხელმიუწვდომელია</string>
    <string name="hide">დამალვა</string>
    <string name="home_package">პაკეტი</string>
    <string name="home_app_title">აპი</string>

    <string name="home_notice_content">გადმოიწერეთ Magisk მხოლოდ ოფიციალური GitHub-ის გვერდიდან. სხვა წყაროებიდან გადმოწერილი ფაილები შესაძლოა სახიფათო იყოს!</string>
    <string name="home_support_title">მხარდაჭერა</string>
    <string name="home_item_source">წყარო</string>
    <string name="home_support_content">Magisk-ი არის და ყოველთვის იქნება უფასო და წყარო-გახსნილი. მაგრამ თქვენ შეგიძლიათ დახმარება გაგვიწიოთ პატარა დონაციით.</string>
    <string name="home_installed_version">დაინსტალირებული</string>
    <string name="home_latest_version">უახლესი</string>
    <string name="invalid_update_channel">არასწორი განახლების არხი</string>
    <string name="uninstall_magisk_title">Magisk-ის დეინსტალაცია</string>
    <string name="uninstall_magisk_msg">ყველა მოდული იქნება წაშლილი/გამორთული!\nRoot-ი წაიშლება!\nთქვენი მონაცემები დაიშიფრება!</string>

    <!--Install-->
    <string name="keep_force_encryption">შიფრირება ყოველთვის იყოს ჩართული</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity იყოს ჩართული</string>
    <string name="recovery_mode">Recovery რეჟიმი</string>
    <string name="install_options_title">ოფციები</string>
    <string name="install_method_title">მეთოდი</string>
    <string name="install_next">შემდეგი</string>
    <string name="install_start">დაწყება</string>
    <string name="manager_download_install">დააჭირეთ გადმოსაწერად და შემდგომ დასაყენებლად</string>
    <string name="direct_install">აქვე დაინსტალირება (რეკომენდირებულია)</string>
    <string name="install_inactive_slot">არააქტიურ სლოტში დაყენება (სისტემის განახლების შემდეგ)</string>
    <string name="install_inactive_slot_msg">თქვენი მოწყობილობა გადაიტვირთება არააქატიურ სლოტში!\nგამოიყენეთ ეს ოფცია მხოლოდ სისტემის განახლების დროს.\nგავაგრძელოთ?</string>
    <string name="setup_title">დამატებითი ინსტალაცია</string>
    <string name="select_patch_file">ფაილის დაპატჩვა</string>
    <string name="patch_file_msg">აირჩიეთ (*.img) ფაილი ან ODIN tarfile-ი (*.tar)</string>
    <string name="reboot_delay_toast">გადატვირთვა 5 წამში…</string>
    <string name="flash_screen_title">ინსტალაცია</string>

    <!--Superuser-->
    <string name="su_request_title">სუპერმომხმარებლის ნებართვის მოთხოვნა</string>
    <string name="touch_filtered_warning">სხვა აპი ხელს უშლის Magisk-ს თქვენი პასუხის დადასტურებაში</string>
    <string name="deny">აკრძალვა</string>
    <string name="prompt">კითხვა</string>
    <string name="grant">დართვა</string>
    <string name="su_warning">ანიჭებს სრულ წვდომას მოწყობილობასთან.\nაკრძალეთ თუ დარწმუნებული არ ხართ!</string>
    <string name="forever">სამუდამოდ</string>
    <string name="once">ერთჯერადად</string>
    <string name="tenmin">10 წუთში</string>
    <string name="twentymin">20 წუთში</string>
    <string name="thirtymin">30 წუთში</string>
    <string name="sixtymin">60 წუთში</string>
    <string name="su_allow_toast">%1$s-ს მიენიჭა სუპერმომხმარებლის ნებართვები</string>
    <string name="su_deny_toast">%1$s-ს აეკრძალა სუპერმომხმარებლის ნებართვები</string>
    <string name="su_snack_grant">%1$s-ის ნებართვები იქნა მინიჭებული</string>
    <string name="su_snack_deny">%1$s-ის ნებართვები იქნა აკრძალული</string>
    <string name="su_snack_notif_on">%1$s-ის შეტყობინებები ჩართულია</string>
    <string name="su_snack_notif_off">%1$s-ის შეტყობინებები გამორთულია</string>
    <string name="su_snack_log_on">%1$s-ის ლოგინგი ჩართულია</string>
    <string name="su_snack_log_off">%1$s-ის ლოგინგი გამორთულია</string>
    <string name="su_revoke_title">გავაუქმოთ?</string>
    <string name="su_revoke_msg">ნამდვილად გსურთ %1$s-ისთვის ნებართვების გაუქმება?</string>
    <string name="toast">ჩვეულებრივი</string>
    <string name="none">არანაირი</string>

    <string name="superuser_toggle_notification">შეტყობინებები</string>
    <string name="superuser_toggle_revoke">გაუქმება</string>
    <string name="superuser_policy_none">ჯერ არცერთ აპს არ მოუთხოვია სუპერმომხმარებლის ნებართვები.</string>

    <!--Logs-->
    <string name="log_data_none">თქვენი ლოგი ცარიელია, სცადეთ Root-ზე დაფუძნებული პროგრამების გამოყენება.</string>
    <string name="log_data_magisk_none">Magisk-ის ლოგები ცარიელია, უცნაურია.</string>
    <string name="menuSaveLog">ლოგის შენხავა</string>
    <string name="menuClearLog">ლოგის გასუფთავება</string>
    <string name="logs_cleared">ლოგი წარმატებით გასუფთავდა.</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">სამიზნე UID: %1$d</string>

    <!--SafetyNet-->

    <!-- MagiskHide -->
    <string name="show_system_app">სისტემის პროგრამების ჩვენება</string>
    <string name="show_os_app">ოპერაციული სისტემის აპების ჩვენება</string>
    <string name="hide_filter_hint">ფილტრაცია სახელის მიხედვით</string>
    <string name="hide_search">ძებნა</string>

    <!--Module Fragment-->
    <string name="no_info_provided">(ინფორმაცია არ არის მითითებული)</string>
    <string name="reboot_userspace">სისტემის გადატვირთვა</string>
    <string name="reboot_recovery">Recovery-ში გადატვირთვა</string>
    <string name="reboot_bootloader">Bootloader-ში გადატვირთვა</string>
    <string name="reboot_download">Download-ში გადატვირთვა</string>
    <string name="reboot_edl">EDL-ში გადატვირთვა</string>
    <string name="module_version_author">%1$s %2$s-სგან</string>
    <string name="module_state_remove">წაშლა</string>
    <string name="module_state_restore">აღდგენა</string>
    <string name="module_action_install_external">მახსოვრობიდან დაინსტალირება</string>
    <string name="update_available">ხელმისაწვდომია განახლება</string>

    <!--Settings -->
    <string name="settings_dark_mode_title">თემების ჩამონათვალი</string>
    <string name="settings_dark_mode_message">აირჩიეთ ის რაც ყველაზე ძალიან მოგწონთ!</string>
    <string name="settings_dark_mode_light">ღია თემა</string>
    <string name="settings_dark_mode_system">სისტემაზე დაფუძნებული</string>
    <string name="settings_dark_mode_dark">მუქი თემა</string>
    <string name="settings_download_path_title">გადმოწერის ლოკაცია</string>
    <string name="settings_download_path_message">ფაილები შეინახება %1$s-ში</string>
    <string name="settings_hide_app_title">Magisk-ის აპის დამალვა</string>
    <string name="settings_hide_app_summary">დაყენდეს ამოუცნობელი აპი შემთხვევითი პაკეტის ID-ით და განსხვავებული სახელით</string>
    <string name="settings_restore_app_title">Magisk-ის აპის დაბრუნება</string>
    <string name="settings_restore_app_summary">აპის თავდაპირველ მდგომარეობაზე დაბრუნება</string>
    <string name="language">ენა</string>
    <string name="system_default">(სისტემის რჩეული)</string>
    <string name="settings_check_update_title">განახლებების შემოწმება</string>
    <string name="settings_check_update_summary">განახლებების პერიოდულად შემოწმება ფონურ რეჟიმში</string>
    <string name="settings_update_channel_title">განახლებების არხი</string>
    <string name="settings_update_stable">სტაბილური</string>
    <string name="settings_update_beta">ბეტა</string>
    <string name="settings_update_custom">პერსონალიზირებული</string>
    <string name="settings_update_custom_msg">სხვა URL-ის ჩასმა</string>
    <string name="settings_hosts_title">გარესისტემური ჰოსტები</string>
    <string name="settings_hosts_summary">გარესისტემური ჰოსტები Adblock-ებისთვის</string>
    <string name="settings_hosts_toast">გარესისტემური ჰოსტების მოდული დამატებულია</string>
    <string name="settings_app_name_hint">ახალი სახელი</string>
    <string name="settings_app_name_helper">პროგრამას ეს პაკეტის სახელი ექნება</string>
    <string name="settings_app_name_error">არასწორი ფორმატი</string>
    <string name="settings_su_app_adb">აპები და ADB</string>
    <string name="settings_su_app">მხოლოდ აპები</string>
    <string name="settings_su_adb">მხოლოდ ADB</string>
    <string name="settings_su_disable">გამორთულია</string>
    <string name="settings_su_request_10">10 წამი</string>
    <string name="settings_su_request_15">15 წამი</string>
    <string name="settings_su_request_20">20 წამი</string>
    <string name="settings_su_request_30">30 წამი</string>
    <string name="settings_su_request_45">45 წამი</string>
    <string name="settings_su_request_60">60 წამი</string>
    <string name="superuser_access">სუპერმომხმარებელთან წვდომა</string>
    <string name="auto_response">ავტომატური პასუხი</string>
    <string name="request_timeout">პასუხის ტაიმაუტი</string>
    <string name="superuser_notification">სუპერმომხმარებლის შეტყობინება</string>
    <string name="settings_su_reauth_title">რეაუტენთიფიკაცია განახლების შემდეგ</string>
    <string name="settings_su_reauth_summary">სუპერმომხმარებლის ნებართვის რეაუტენთიფიკაცია აპის განახლების შემდეგ</string>
    <string name="settings_su_tapjack_title">Tapjacking-სგან თავის დაცვა</string> <!-- TODO: tapjacking has no direct translation; must make something up later -->
    <string name="settings_su_tapjack_summary">superuser-ის დიალოგის ღილაკებზე დაჭერა არ იქნება შესაძლებელი თუ სხვა აპი არის მასზე გადახურული</string>
    <string name="settings_customization">პერსონალიზაცია</string>
    <string name="setting_add_shortcut_summary">ლამაზი ხატულის დამატება საწყისს ეკრანზე, იმ შემთხვევაში თუ აპის ამოცნობა არის რთული დამალვის შემდეგ</string>
    <string name="settings_doh_title">DNS HTTPS-ზე</string>
    <string name="settings_doh_description">DNS-ის ლიმიტების მოხსნა კონკრეტულ სახელმწიფოებში</string>

    <string name="multiuser_mode">მრავალმომხმარებლიანი რეჟიმი</string>
    <string name="settings_owner_only">მხოლოდ მოწყობილობის მფლობელი</string>
    <string name="settings_owner_manage">მოწყობილობის მფლობელის მიერ მართვა</string>
    <string name="settings_user_independent">მომხმარებლისგან დამოუკიდებელი</string>
    <string name="owner_only_summary">მხოლოდ მფლობელს ჰქონდეს სუპერმომხმარებელთან წვდომა</string>
    <string name="owner_manage_summary">მხოლოდ მფლობელს ჰქონდეს ნებართვების მართვა</string>
    <string name="user_independent_summary">ყოველ მომხმარებელს თავიანთი ნებართვები ჰქონდეთ</string>

    <string name="mount_namespace_mode">Namespace რეჟიმის დამონტაჟება</string>
    <string name="settings_ns_global">გლობალური Namespace-ი</string>
    <string name="settings_ns_requester">მიღებითი Namespace-ი</string>
    <string name="settings_ns_isolate">იზოლირებული Namespace-ი</string>
    <string name="global_summary">ყველა root სესია გამოიყენებს გლობალურ სამონტაჟო namespace-ს</string>
    <string name="requester_summary">Root სესიები მიიღებენ მომწოდებლის სამონტაჟო namespace-ს</string>
    <string name="isolate_summary">ყოველ root სესიას ექნებათ თავიანთი იზოლირებული namespace-ი</string>

    <!--Notifications-->
    <string name="update_channel">Magisk-ის განახლებები</string>
    <string name="progress_channel">პროგრესის შეტყობინებები</string>
    <string name="download_complete">გადმოწერა დასრულებულია</string>
    <string name="download_file_error">შეცდომა გადმოწერის დროს</string>
    <string name="magisk_update_title">ხელმისაწვდომია Magisk-ის განახლება!</string>

    <!--Toasts, Dialogs-->
    <string name="yes">დიახ</string>
    <string name="no">არა</string>
    <string name="download">გადმოწერა</string>
    <string name="reboot">გადატვირთვა</string>
    <string name="release_notes">რელიზის შენიშვნები</string>
    <string name="flashing">მიმდინარეობს ჩაშენება…</string>
    <string name="done">დასრულდა!</string>
    <string name="failure">ჩაიშალა</string>
    <string name="hide_app_title">ვმალავთ Magisk-ის აპს…</string>
    <string name="open_link_failed_toast">ლინკის გამხსნელი აპლიკაცია ვერ მოიძებნა</string>
    <string name="complete_uninstall">დეინსტალაციის დასრულება</string>
    <string name="restore_img">სურათის აღდგენა</string>
    <string name="restore_img_msg">მიმდინარეობს აღდგენა…</string>
    <string name="restore_done">აღდგენა დასრულდა!</string>
    <string name="restore_fail">საწყისი რეზერვი არ არსებობს!</string>
    <string name="setup_fail">ინსტალაცია ჩაიშალა</string>
    <string name="env_fix_title">სჭირდება დამატებითი გამართვა</string>
    <string name="env_fix_msg">თქვენს მოწყობილობას სჭრიდება დამატებითი გამართვა იმისთვის რომ Magisk-მა იმუშავოს. გადმოიწერება "Magisk setup.zip" ფაილი, გსურთ გაგრძელება?</string>
    <string name="setup_msg">მიმდინარეობს ინტერფეისის ინსტალაცია…</string>
    <string name="unsupport_magisk_title">შეუთავსებელი Magisk-ის ვერსია</string>
    <string name="unsupport_magisk_msg">ეს აპის ვერსია შეუთავსებსლია Magisk-ის %1$s-ზე ნაკლებ ვერსიებთან.\n\nაპს ეგონება, რომ Magisk-ი არაა დაყენებული, გთხოვთ გაანხალოთ Magisk-ი დროულად.</string>
    <string name="external_rw_permission_denied">დართეთ მეხსიერებასთან წვდომის ნებართვა ამ ფუნქციის გამოსაყნებლად</string>
    <string name="add_shortcut_title">ხატულის დამატება საწყისს ეკრანზე</string>
    <string name="add_shortcut_msg">აპის დამალვის შემდეგ, მისი ნახატი და სახელი შეიძლება ამოუცნობი გახდეს. გნებავთ ხატულის დამატება ასწყისს ეკრანზე?</string>
    <string name="app_not_found">ამ ფუნქციის შესასრულებლად აპი ვერ მოიძებნა</string>

</resources>

```

`app/core/src/main/res/values-kk/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Модульдер</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Логтар</string>
    <string name="settings">Баптау</string>
    <string name="install">Орнату</string>
    <string name="section_home">Басты бет</string>
    <string name="section_theme">Кейіп</string>
    <string name="denylist">DenyList</string>

    <!--Home-->
    <string name="no_connection">Байланыс жоқ</string>
    <string name="app_changelog">Өзгеріс тізімі</string>
    <string name="loading">Жүктелуде…</string>
    <string name="update">Жаңарту</string>
    <string name="not_available">Белгісіз</string>
    <string name="hide">Жасыру</string>
    <string name="home_package">Десте атауы</string>
    <string name="home_app_title">Қолданба</string>

    <string name="home_notice_content">Magisk-ті ТЕК ресми GitHub репозиториінен жүктеп алыңыз. Басқа көзден алынған файлдар зиянды болуы мүмкін!</string>
    <string name="home_support_title">Бізді қолдау</string>
    <string name="home_follow_title">Бізге жазылу</string>
    <string name="home_item_source">Бастапқы коды</string>
    <string name="home_support_content">Magisk жобасы тегін әрі еркін болып, болашақта да солай болып қала бермек. Қиын болмаса, бізді қаржылай қолдасаңыз болады.</string>
    <string name="home_installed_version">Орнатылған</string>
    <string name="home_latest_version">Соңғы</string>
    <string name="invalid_update_channel">Жарамсыз жаңарту көзі</string>
    <string name="uninstall_magisk_title">Magisk-ті жою</string>
    <string name="uninstall_magisk_msg">Барлық модуль сөндіріледі/жойылады!\nRoot құқығынан айырыласыз!\nMagisk көмегімен шифрлауды сөндірген болсаңыз, құрылғының жады қайта шифрланады!</string>

    <!--Install-->
    <string name="keep_force_encryption">Шифрлауды сөндірмей қалдыру</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity қалдыру</string>
    <string name="recovery_mode">Recovery режімі</string>
    <string name="install_options_title">Баптау</string>
    <string name="install_method_title">Тәсіл</string>
    <string name="install_next">Келесі</string>
    <string name="install_start">Бастау</string>
    <string name="manager_download_install">Жүктеп алып, орнату үшін басыңыз</string>
    <string name="direct_install">Тікелей орнату (ұсынылады)</string>
    <string name="install_inactive_slot">Белсенді емес слотқа орнату (OTA-дан кейін)</string>
    <string name="install_inactive_slot_msg">Құрылғыңыз белсенді емес слотқа МӘЖБҮРЛІ ТҮРДЕ қайта жүктеледі!\nБұл тәсілді тек OTA жаңартуынан кейін қолданыңыз.\nЖалғастырасыз ба?</string>
    <string name="setup_title">Қосымша баптау</string>
    <string name="select_patch_file">Файл таңдап, патчтау</string>
    <string name="patch_file_msg">Жад бөлімінің бейнесін (*.img), ODIN мұрағатын (*.tar) немесе payload.bin (*.bin) файлын таңдаңыз</string>
    <string name="reboot_delay_toast">5 секундтан кейін қайта жүктеледі…</string>
    <string name="flash_screen_title">Орнату</string>

    <!--Superuser-->
    <string name="su_request_title">Superuser құқығына сұраным</string>
    <string name="touch_filtered_warning">Өзге қолданба Magisk терезесін бүркегендіктен, Superuser құқығына сұраным қабылданбады</string>
    <string name="deny">Бас тарту</string>
    <string name="prompt">Сұрау</string>
    <string name="grant">Беру</string>
    <string name="su_warning">Құрылғыңызға шексіз рұқсат бергелі жатырсыз.\nСенімді болмасаңыз, бас тартыңыз!</string>
    <string name="forever">Әрдайым</string>
    <string name="once">Бір рет</string>
    <string name="tenmin">10 минут</string>
    <string name="twentymin">20 минут</string>
    <string name="thirtymin">30 минут</string>
    <string name="sixtymin">60 минут</string>
    <string name="su_allow_toast">%1$s Superuser құқығын алды</string>
    <string name="su_deny_toast">%1$s Superuser құқығын алмады</string>
    <string name="su_snack_grant">%1$s қолданбасына Superuser құқығы берілді</string>
    <string name="su_snack_deny">%1$s қолданбасы Superuser құқығынан айырылды</string>
    <string name="su_snack_notif_on">%1$s жайлы мәлімдемелер қосулы</string>
    <string name="su_snack_notif_off">%1$s жайлы мәлімдемелер сөндірулі</string>
    <string name="su_snack_log_on">%1$s әрекеттері логта сақталады</string>
    <string name="su_snack_log_off">%1$s әрекеттері логта сақталмайды</string>
    <string name="su_revoke_title">Superuser баптауын арылту</string>
    <string name="su_revoke_msg">%1$s қолданбасының Superuser баптауын арылтасыз ба?</string>
    <string name="toast">Қалқыма мәлімдеме</string>
    <string name="none">Сөндірулі</string>

    <string name="superuser_toggle_notification">Мәлімдеме</string>
    <string name="superuser_toggle_revoke">Арылту</string>
    <string name="superuser_policy_none">Superuser құқығын әлі еш қолданба сұраған жоқ.</string>

    <!--Logs-->
    <string name="log_data_none">Әрекет логы бос, root құқығын қажет ететін қолданбаларды көбірек қолданып көріңіз.</string>
    <string name="log_data_magisk_none">Magisk логы бос, біртүрлі екен</string>
    <string name="menuSaveLog">Логты сақтау</string>
    <string name="menuClearLog">Логты тазалау</string>
    <string name="logs_cleared">Лог сәтті тазаланды</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Мақсатты UID: %1$d</string>
    <string name="target_pid">Mount ns-тегі мақсатты PID: %s</string>
    <string name="selinux_context">SELinux контексті: %s</string>
    <string name="supp_group">Қосымша топ: %s</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Жүйе қолданбаларын көрсету</string>
    <string name="show_os_app">ОЖ қолданбаларын көрсету</string>
    <string name="hide_filter_hint">Атауы бойынша іздеу</string>
    <string name="hide_search">Іздеу</string>

    <!--Module-->
    <string name="no_info_provided">(Ақпары жоқ)</string>
    <string name="reboot_userspace">Жүйеге қайта жүктеу</string>
    <string name="reboot_recovery">Recovery режіміне қайта жүктеу</string>
    <string name="reboot_bootloader">Bootloader-ге қайта жүктеу</string>
    <string name="reboot_download">Download режіміне қайта жүктеу</string>
    <string name="reboot_edl">EDL режіміне қайта жүктеу</string>
    <string name="reboot_safe_mode">Қауіпсіз режімге қайта жүктеу</string>
    <string name="module_version_author">%1$s, %2$s жасаған</string>
    <string name="module_state_remove">Жою</string>
    <string name="module_state_restore">Қалпына келтіру</string>
    <string name="module_action_install_external">Құрылғы жадынан орнату</string>
    <string name="update_available">Жаңарту қолжетімді</string>
    <string name="suspend_text_riru">Модуль сөндірілді, себебі %1$s қосылған</string>
    <string name="suspend_text_zygisk">Модуль сөндірілді, себебі %1$s қосылмаған</string>
    <string name="zygisk_module_unloaded">Zygisk модулі үйлеспегендіктен жүктелмеді</string>
    <string name="module_empty">Еш модуль орнатылған жоқ</string>
    <string name="confirm_install">%1$s модулін орнатасыз ба?</string>
    <string name="confirm_install_title">Орнатуды растау</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Кейіп режімі</string>
    <string name="settings_dark_mode_message">Өзіңізге ұнаған режімді таңдаңыз!</string>
    <string name="settings_dark_mode_light">Әрдайым ақшыл</string>
    <string name="settings_dark_mode_system">Жүйедегідей</string>
    <string name="settings_dark_mode_dark">Әрдайым қараңғы</string>
    <string name="settings_download_path_title">Жүктеу бумасы</string>
    <string name="settings_download_path_message">Файлдар %1$s бумасына сақталады</string>
    <string name="settings_hide_app_title">Magisk қолданбасын жасыру</string>
    <string name="settings_hide_app_summary">Қолданба атауын өзгертіп, кездейсоқ десте атауы бар APK файлын құрастыру</string>
    <string name="settings_restore_app_title">Magisk қолданбасын қалпына келтіру</string>
    <string name="settings_restore_app_summary">Қолданбаны жасырын күйден шығарып, түпнұсқа APK орнату</string>
    <string name="language">Тіл</string>
    <string name="system_default">(Жүйедегідей)</string>
    <string name="settings_check_update_title">Жаңартуды тексеру</string>
    <string name="settings_check_update_summary">Жаңартудың бар-жоғын мезгіл-мезгіл тексеру</string>
    <string name="settings_update_channel_title">Жаңарту көзі</string>
    <string name="settings_update_stable">Тұрақты</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Басқа</string>
    <string name="settings_update_custom_msg">Басқа арнаның URL мекенжайын енгізіңіз</string>
    <string name="settings_zygisk_summary">Magisk кодын zygote процесіне енгізу</string>
    <string name="settings_denylist_title">DenyList-тi қолдану</string>
    <string name="settings_denylist_summary">Magisk жасаған барлық өзгеріс DenyList-тегі процестерден жасырылады.</string>
    <string name="settings_denylist_config_title">DenyList-тi баптау</string>
    <string name="settings_denylist_config_summary">DenyList-ке қосқыңыз келетін процестерді таңдаңыз</string>
    <string name="settings_hosts_title">Жүйеден тыс hosts</string>
    <string name="settings_hosts_summary">Жарнама өшіретін қолданбалар үшін /system бөлімінен тыс hosts файлын қолдану</string>
    <string name="settings_hosts_toast">Жүйеден тыс hosts модулі қосылды</string>
    <string name="settings_app_name_hint">Жаңа атау</string>
    <string name="settings_app_name_helper">Қолданбаның қайта құрылған нұсқасы осы атауға ие болады</string>
    <string name="settings_app_name_error">Жарамсыз пішім</string>
    <string name="settings_su_app_adb">Қолданбалар мен ADB</string>
    <string name="settings_su_app">Қолданбалар ғана</string>
    <string name="settings_su_adb">ADB ғана</string>
    <string name="settings_su_disable">Сөндірулі</string>
    <string name="settings_su_request_10">10 секунд</string>
    <string name="settings_su_request_15">15 секунд</string>
    <string name="settings_su_request_20">20 секунд</string>
    <string name="settings_su_request_30">30 секунд</string>
    <string name="settings_su_request_45">45 секунд</string>
    <string name="settings_su_request_60">60 секунд</string>
    <string name="superuser_access">Superuser құқығына рұқсат</string>
    <string name="auto_response">Сұранымға әдепкі жауап</string>
    <string name="request_timeout">Сұранымның күту уақыты</string>
    <string name="superuser_notification">Superuser мәлімдемесі</string>
    <string name="settings_su_reauth_title">Жаңартудан кейін қайта растау</string>
    <string name="settings_su_reauth_summary">Әлдебір қолданба жаңартылғаннан кейін оның Superuser құқығын қайта растау</string>
    <string name="settings_su_tapjack_title">Қабаттасудан қорғау</string>
    <string name="settings_su_tapjack_summary">Өзге қолданба Magisk терезесін бүркесе, Superuser құқығын беру батырмасы сөндіріледі (tapjacking шабуылына жол бермеу үшін)</string>
    <string name="settings_su_auth_title">Қолданушыны растау</string>
    <string name="settings_su_auth_summary">Superuser құқығына сұраным келгенде қолданушының құпиясөзін не биометриялық дерегін сұрау</string>
    <string name="settings_su_auth_insecure">Бұл құрылғыда аутентификация әдісі орнатылмаған</string>
    <string name="settings_customization">Сыртқы көрініс</string>
    <string name="setting_add_shortcut_summary">Жасырылған қолданбаны табу қиын болса, бастапқы экранға ыңғайлы таңбаша қосуға болады</string>
    <string name="settings_doh_title">HTTPS арқылы DNS</string>
    <string name="settings_doh_description">Кейбір елдерде қолданылатын жалған DNS-тен қорғау</string>

    <string name="multiuser_mode">Көп қолданушы режімі</string>
    <string name="settings_owner_only">Құрылғы иесі ғана</string>
    <string name="settings_owner_manage">Құрылғы иесінің бақылауында</string>
    <string name="settings_user_independent">Тәуелсіз қолданушылар</string>
    <string name="owner_only_summary">Құрылғы иесі ғана root құқығын қолдана алады</string>
    <string name="owner_manage_summary">Құрылғы иесі ғана сұранымдарды қабылдап, басқаларға root құқығын бере алады</string>
    <string name="user_independent_summary">Әр қолданушы өз root ережелерін қолдана алады</string>

    <string name="mount_namespace_mode">Mount атау кеңістігін баптау</string>
    <string name="settings_ns_global">Ғаламдық атау кеңістігі</string>
    <string name="settings_ns_requester">Мұраланған атау кеңістігі</string>
    <string name="settings_ns_isolate">Оқшауланған атау кеңістігі</string>
    <string name="global_summary">Root сеанстары ғаламдық атау кеңістігін қолданады</string>
    <string name="requester_summary">Root сеанстары қолданушының атау кеңістігін мұралайды</string>
    <string name="isolate_summary">Әр root сеансы өз атау кеңістігін қолданады</string>

    <!--Notifications-->
    <string name="update_channel">Magisk жаңартулары</string>
    <string name="progress_channel">Прогресс мәлімдемесі</string>
    <string name="updated_channel">Жаңарту аяқталды</string>
    <string name="download_complete">Жүктеу аяқталды</string>
    <string name="download_file_error">Файлды жүктеп алу қатесі</string>
    <string name="magisk_update_title">Magisk жаңартуы қолжетімді!</string>
    <string name="updated_title">Magisk жаңартылды</string>
    <string name="updated_text">Қолданбасын ашу үшін басыңыз</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Иә</string>
    <string name="no">Жоқ</string>
    <string name="repo_install_title">%1$s %2$s(%3$d) орнату</string>
    <string name="download">Жүктеп алу</string>
    <string name="reboot">Қайта жүктеу</string>
    <string name="release_notes">Не жаңалық</string>
    <string name="flashing">Орнатуда…</string>
    <string name="done">Дайын!</string>
    <string name="failure">Қате!</string>
    <string name="hide_app_title">Magisk қолданбасын жасыруда…</string>
    <string name="open_link_failed_toast">Сілтемені аша алатын қолданба табылмады</string>
    <string name="complete_uninstall">Толығымен жою</string>
    <string name="restore_img">Жад бөлімдерін қалпына келтіру</string>
    <string name="restore_img_msg">Қалпына келтіруде…</string>
    <string name="restore_done">Жад қалпына келтірілді!</string>
    <string name="restore_fail">Өзгертілген бөлімдердің сақтық көшірмесі жоқ!</string>
    <string name="setup_fail">Орнату сәтсіз аяқталды</string>
    <string name="env_fix_title">Қосымша баптау керек</string>
    <string name="env_fix_msg">Magisk дұрыс жұмыс істеуі үшін қосымша әрекет қажет. Орнатуды жалғастырып, құрылғыны қайта қосасыз ба?</string>
    <string name="env_full_fix_msg">Magisk дұрыс жұмыс істеуі үшін оны қайта орнату керек. Magisk-ті қолданба арқылы қайта орнатыңыз; Recovery режімі құрылғыңыз туралы дұрыс ақпаратты таба алмайды.</string>
    <string name="setup_msg">Жұмыс ортасын баптауда…</string>
    <string name="unsupport_magisk_title">Үйлеспейтін Magisk нұсқасы</string>
    <string name="unsupport_magisk_msg">Қолданбаның осы нұсқасы Magisk-тің %1$s дейінгі нұсқаларына үйлеспейді.\n\nҚолданба Magisk орнатылмағандай жұмыс істейді; Magisk-ті жақын арада жаңартыңыз.</string>
    <string name="unsupport_general_title">Қалыпты емес жағдай</string>
    <string name="unsupport_system_app_msg">Бұл қолданба жүйе қолданбасы ретінде жұмыс істей алмайды. Оны қалыпты қолданба ретінде қайта орнатыңыз.</string>
    <string name="unsupport_other_su_msg">Magisk өзге бағдарламаға тиесілі \"su\" файлын анықтады. Қайшы келетін root қолданбасын жойып, Magisk-ті қайта орнатыңыз.</string>
    <string name="unsupport_external_storage_msg">Magisk қолданбасы сыртқы жадқа орнатылды. Қолданбаны ішкі жадқа жылжытыңыз.</string>
    <string name="unsupport_nonroot_stub_msg">Root құқығы жоғалғандықтан, жасырылған Magisk қолданбасы жұмыс істей алмайды. Түпнұсқа APK файлын орнатыңыз.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Мүмкіндікті қолдану үшін құрылғы жадына рұқсат беріңіз</string>
    <string name="post_notifications_denied">Мүмкіндікті қолдану үшін мәлімдеме жіберуге рұқсат беріңіз</string>
    <string name="install_unknown_denied">Мүмкіндікті қолдану үшін "белгісіз қолданбаларды орнатуға" рұқсат беріңіз</string>
    <string name="add_shortcut_title">Бастапқы экранға таңбаша қосу</string>
    <string name="add_shortcut_msg">Қолданба жасырылғаннан кейін, оның атауы мен таңбашасын тану қиын болуы мүмкін. Бастапқы экранға ыңғайлы таңбаша қосу керек пе?</string>
    <string name="app_not_found">Бұл әрекетті орындай алатын қолданба табылмады</string>
    <string name="reboot_apply_change">Өзгерістерді қолдану үшін құрылғыны қайта қосыңыз</string>
    <string name="restore_app_confirmation">Сөйтсеңіз, жасырын қолданба түпнұсқа қолданбаға айналады. Мұны істеу керек екеніне сенімдісіз бе?</string>

</resources>

```

`app/core/src/main/res/values-ko/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">모듈</string>
    <string name="superuser">슈퍼유저</string>
    <string name="logs">로그</string>
    <string name="settings">설정</string>
    <string name="install">설치</string>
    <string name="section_home">홈</string>
    <string name="section_theme">테마</string>
    <string name="denylist">거부목록</string>

    <!--Home-->
    <string name="no_connection">인터넷 연결 없음</string>
    <string name="app_changelog">앱 변경 사항</string>
    <string name="loading">로딩중…</string>
    <string name="update">업데이트</string>
    <string name="not_available">알 수 없음</string>
    <string name="hide">숨기기</string>
    <string name="home_package">패키지</string>
    <string name="home_app_title">앱</string>

    <string name="home_notice_content">공식 Github 페이지에서 Magisk를 다운로드하십시오. 알 수 없는 출처에서 받은 파일이 위험할 수 있습니다!</string>
    <string name="home_support_title">후원하기</string>
    <string name="home_item_source">소스</string>
    <string name="home_support_content">Magisk는 항상 무료일 것이며, 오픈소스일 것입니다. 그러나 소액의 후원을 통해 관심을 표할 수 있습니다.</string>
    <string name="home_installed_version">설치됨</string>
    <string name="home_latest_version">최신</string>
    <string name="invalid_update_channel">잘못된 업데이트 채널</string>
    <string name="uninstall_magisk_title">Magisk 제거</string>
    <string name="uninstall_magisk_msg">모든 모듈이 비활성화/제거됩니다. 루트도 제거될 것이며, 데이터도 암호화 되어있지 않으면 암호화될 수도 있습니다.</string>

    <!--Install-->
    <string name="keep_force_encryption">강제 암호화 유지</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity 유지</string>
    <string name="recovery_mode">리커버리 모드</string>
    <string name="install_options_title">옵션</string>
    <string name="install_method_title">설치 방법</string>
    <string name="install_next">다음</string>
    <string name="install_start">설치</string>
    <string name="manager_download_install">눌러서 다운로드하고 설치</string>
    <string name="direct_install">바로 설치 (권장됨)</string>
    <string name="install_inactive_slot">비활성 슬롯에 설치 (OTA 이후)</string>
    <string name="install_inactive_slot_msg">기기를 다시 시작한 후에는 현재 비활성 상태인 슬롯으로 강제로 부팅됩니다!\nOTA 업데이트 후에만 이 옵션을 사용하십시오.\n계속하시겠습니까?</string>
    <string name="setup_title">추가 설정</string>
    <string name="select_patch_file">파일 선택 및 패치</string>
    <string name="patch_file_msg">raw 이미지 (*.img) 또는 ODIN tar 파일 (*.tar) 선택</string>
    <string name="reboot_delay_toast">5초 후 다시 시작합니다…</string>
    <string name="flash_screen_title">설치과정</string>

    <!--Superuser-->
    <string name="su_request_title">슈퍼유저 요청</string>
    <string name="touch_filtered_warning">앱이 슈퍼유저 요청을 가려, Magisk에서 응답을 확인할 수 없습니다.</string>
    <string name="deny">모두 거부</string>
    <string name="prompt">물어보기</string>
    <string name="grant">모두 허용</string>
    <string name="su_warning">기기에 대한 슈퍼유저 권한을 부여합니다.\n확실하지 않은 경우 거부하세요!</string>
    <string name="forever">영구</string>
    <string name="once">한 번만</string>
    <string name="tenmin">10분</string>
    <string name="twentymin">20분</string>
    <string name="thirtymin">30분</string>
    <string name="sixtymin">60분</string>
    <string name="su_allow_toast">%1$s에 슈퍼유저 권한이 허용됨</string>
    <string name="su_deny_toast">%1$s에 슈퍼유저 권한이 거부됨</string>
    <string name="su_snack_grant">%1$s의 슈퍼유저 권한이 허용됨</string>
    <string name="su_snack_deny">%1$s의 슈퍼유저 권한이 거부됨</string>
    <string name="su_snack_notif_on">%1$s의 알림이 활성화됨</string>
    <string name="su_snack_notif_off">%1$s의 알림이 비활성화됨</string>
    <string name="su_snack_log_on">%1$s의 로깅이 활성화됨</string>
    <string name="su_snack_log_off">%1$s의 로깅이 비활성화됨</string>
    <string name="su_revoke_title">제거하시겠습니까?</string>
    <string name="su_revoke_msg">정말 %1$s의 권한을 제거하시겠습니까?</string>
    <string name="toast">토스트</string>
    <string name="none">없음</string>

    <string name="superuser_toggle_notification">알림</string>
    <string name="superuser_toggle_revoke">권한 제거</string>
    <string name="superuser_policy_none">슈퍼유저 권한을 요청한 앱이 없습니다.</string>

    <!--Logs-->
    <string name="log_data_none">로그가 없습니다. 슈퍼유저 권한을 필요로 하는 앱을 사용하십시오.</string>
    <string name="log_data_magisk_none">Magisk 로그가 없습니다.</string>
    <string name="menuSaveLog">로그 저장</string>
    <string name="menuClearLog">로그 삭제</string>
    <string name="logs_cleared">로그 삭제 완료.</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Target UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">시스템 앱 표시</string>
    <string name="show_os_app">OS 앱 표시</string>
    <string name="hide_filter_hint">이름 검색</string>
    <string name="hide_search">검색</string>

    <!--Module-->
    <string name="no_info_provided">(정보 없음)</string>
    <string name="reboot_userspace">조용히 다시 시작</string>
    <string name="reboot_recovery">복구 모드로 다시 시작</string>
    <string name="reboot_bootloader">부트로더로 다시 시작</string>
    <string name="reboot_download">다운로드 모드로 다시 시작</string>
    <string name="reboot_edl">EDL로 다시 시작</string>
    <string name="module_version_author">%1$s by %2$s</string>
    <string name="module_state_remove">제거</string>
    <string name="module_state_restore">복구</string>
    <string name="module_action_install_external">저장소에서 설치</string>
    <string name="update_available">업데이트 가능</string>
    <string name="suspend_text_riru">%1$s 가 활성화 되어있어 모듈이 로드되지 않았습니다.</string>
    <string name="suspend_text_zygisk">%1$s 가 활성화되어 있지 않아 모듈이 로드되지 않았습니다.</string>
    <string name="zygisk_module_unloaded">호환성 문제로 인해 Zygisk 모듈이 로드되지 않았습니다.</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">테마 선택</string>
    <string name="settings_dark_mode_message">원하는 테마 모드를 선택하세요!</string>
    <string name="settings_dark_mode_light">기본</string>
    <string name="settings_dark_mode_system">자동</string>
    <string name="settings_dark_mode_dark">다크 모드</string>
    <string name="settings_download_path_title">다운로드 위치</string>
    <string name="settings_download_path_message">파일이 %1$s에 저장됩니다</string>
    <string name="settings_hide_app_title">Magisk 앱 숨기기</string>
    <string name="settings_hide_app_summary">무작위 패키지명과 사용자 지정 앱 이름으로 Magisk 프록시 앱을 설치합니다.</string>
    <string name="settings_restore_app_title">Magisk 앱 복원</string>
    <string name="settings_restore_app_summary">앱 숨기기를 해제하고 원래 APK로 복원합니다.</string>
    <string name="language">언어</string>
    <string name="system_default">(시스템 기본값)</string>
    <string name="settings_check_update_title">업데이트 확인</string>
    <string name="settings_check_update_summary">백그라운드에서 주기적으로 업데이트를 확인합니다.</string>
    <string name="settings_update_channel_title">업데이트 채널</string>
    <string name="settings_update_stable">안정</string>
    <string name="settings_update_beta">베타</string>
    <string name="settings_update_custom">사용자 지정</string>
    <string name="settings_update_custom_msg">사용자 지정 URL 입력</string>
    <string name="settings_zygisk_summary">zygote 데몬에서 Magisk 부분 실행</string>
    <string name="settings_denylist_title">DenyList 적용</string>
    <string name="settings_denylist_summary">DenyList에 있는 프로세스를 실행할때 Magisk의 모든 수정사항을 되돌리고 실행합니다.</string>
    <string name="settings_denylist_config_title">DenyList 구성</string>
    <string name="settings_denylist_config_summary">Denylist에 포함할 프로세스를 선택합니다.</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">광고 차단 앱에서 사용하는 systemless hosts를 지원합니다.</string>
    <string name="settings_hosts_toast">Systemless hosts 모듈 추가됨</string>
    <string name="settings_app_name_hint">새 이름</string>
    <string name="settings_app_name_helper">이 이름으로 앱을 다시 패키징합니다.</string>
    <string name="settings_app_name_error">올바르지 않은 형식</string>
    <string name="settings_su_app_adb">앱 및 ADB</string>
    <string name="settings_su_app">앱만</string>
    <string name="settings_su_adb">ADB만</string>
    <string name="settings_su_disable">사용 안 함</string>
    <string name="settings_su_request_10">10초</string>
    <string name="settings_su_request_15">15초</string>
    <string name="settings_su_request_20">20초</string>
    <string name="settings_su_request_30">30초</string>
    <string name="settings_su_request_45">45초</string>
    <string name="settings_su_request_60">60초</string>
    <string name="superuser_access">슈퍼유저 액세스</string>
    <string name="auto_response">슈퍼유저 요청</string>
    <string name="request_timeout">요청 시간 제한</string>
    <string name="superuser_notification">슈퍼유저 알림</string>
    <string name="settings_su_reauth_title">업데이트 후 다시 승인</string>
    <string name="settings_su_reauth_summary">앱이 업데이트되면 권한 승인 요청을 다시 합니다.</string>
    <string name="settings_su_tapjack_title">탭재킹 보호 활성화</string>
    <string name="settings_su_tapjack_summary">슈퍼유저 프롬프트가 다른 창이나 오버레이로 가려지는 동안의 입력을 무시합니다.</string>
    <string name="settings_customization">커스터마이즈</string>
    <string name="setting_add_shortcut_summary">앱을 숨긴 후 아이콘과 이름을 알아보기 힘들 경우를 위해 알아보기 쉬운 바로가기를 홈 화면에 추가합니다.</string>
    <string name="settings_doh_title">DNS over HTTPS</string>
    <string name="settings_doh_description">일부 국가에 존재하는 DNS 포이즈닝을 해결합니다.</string>

    <string name="multiuser_mode">다중 사용자 모드</string>
    <string name="settings_owner_only">주인 사용자만</string>
    <string name="settings_owner_manage">주인 사용자에 의해 관리됨</string>
    <string name="settings_user_independent">사용자별 분리</string>
    <string name="owner_only_summary">주인 사용자만 루트 액세스를 갖습니다.</string>
    <string name="owner_manage_summary">주인 사용자가 다른 사용자들의 루트 액세스를 관리하고 요청을 받을 수 있습니다.</string>
    <string name="user_independent_summary">각각의 사용자가 권한을 관리합니다.</string>

    <string name="mount_namespace_mode">네임스페이스 마운트 모드</string>
    <string name="settings_ns_global">전역 네임스페이스</string>
    <string name="settings_ns_requester">네임스페이스 상속</string>
    <string name="settings_ns_isolate">격리된 네임스페이스</string>
    <string name="global_summary">모든 루트 세션이 전역 마운트 네임스페이스를 사용합니다.</string>
    <string name="requester_summary">루트 세션은 요청자의 네임스페이스를 상속합니다.</string>
    <string name="isolate_summary">각각의 루트 세션은 자신만의 독립된 네임스페이스를 사용합니다.</string>

    <!--Notifications-->
    <string name="update_channel">Magisk 업데이트</string>
    <string name="progress_channel">진행 상황</string>
    <string name="updated_channel">업데이트 완료</string>
    <string name="download_complete">다운로드 완료</string>
    <string name="download_file_error">파일 다운로드 실패</string>
    <string name="magisk_update_title">새 버전의 Magisk를 사용할 수 있습니다!</string>
    <string name="updated_title">Magisk가 업데이트 되었습니다!</string>
    <string name="updated_text">터치하여 앱 열기</string>

    <!--Toasts, Dialogs-->
    <string name="yes">예</string>
    <string name="no">아니오</string>
    <string name="repo_install_title">%1$s %2$s(%3$d) 설치</string>
    <string name="download">다운로드</string>
    <string name="reboot">다시 시작</string>
    <string name="release_notes">수정사항</string>
    <string name="flashing">설치 중…</string>
    <string name="done">완료!</string>
    <string name="failure">실패!</string>
    <string name="hide_app_title">Magisk 앱 숨기는 중…</string>
    <string name="open_link_failed_toast">링크를 열 수 있는 앱이 없습니다.</string>
    <string name="complete_uninstall">완전히 제거</string>
    <string name="restore_img">이미지 복구</string>
    <string name="restore_img_msg">복구하는 중…</string>
    <string name="restore_done">복구 완료!</string>
    <string name="restore_fail">백업이 존재하지 않습니다!</string>
    <string name="setup_fail">설치 실패</string>
    <string name="env_fix_title">추가 설정 필요</string>
    <string name="env_fix_msg">Magisk가 제대로 작동하려면 추가 설정이 필요합니다. 다시 시작 하시겠습니까?</string>
    <string name="setup_msg">환경 설정 진행 중…</string>
    <string name="unsupport_magisk_title">지원되지 않는 Magisk 버전</string>
    <string name="unsupport_magisk_msg">이 버전의 앱은 %1$s 미만의 Magisk 버전을 지원하지 않습니다.\n\n해당앱은 Magisk가 설치되지 않은것처럼 동작할것입니다. 가능한 빨리 Magisk 를 업데이트 하세요.</string>
    <string name="unsupport_general_title">비정상적인 상태</string>
    <string name="unsupport_system_app_msg">해당 앱을 시스템 앱으로 실행하는 것은 지원되지 않습니다. 앱을 일반 사용자 앱으로 실행해 주세요.</string>
    <string name="unsupport_other_su_msg">Magisk으로 부터 설치되지 않은 \"su\" 바이너리가 감지되었습니다. 다른 루팅 방법을 제거하거나, Magisk 를 다시 설치해주세요.</string>
    <string name="unsupport_external_storage_msg">Magisk 가 외부 저장소에 설치되어 있습니다. Magisk 를 내부 저장소에 설치 해주세요.</string>
    <string name="unsupport_nonroot_stub_msg">이 숨겨진 Magisk 앱은 루트 권한이 손실되어 사용할 수 없습니다. 원래 APK 를 복원하거나 재설치 해주세요.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">해당 기능을 사용하려면 저장소 권한을 허용해 주십시오.</string>
    <string name="install_unknown_denied">이 기능을 활성화 하려면 "출처를 알 수 없는 앱 설치"를 허용해주세요.</string>
    <string name="add_shortcut_title">홈 화면에 바로가기 추가</string>
    <string name="add_shortcut_msg">앱을 숨긴 후 아이콘과 이름을 알아보기 힘들 경우를 위해 알아보기 쉬운 바로가기를 홈 화면에 추가합니다.</string>
    <string name="app_not_found">해당 작업을 처리할 어플리케이션이 없습니다.</string>
    <string name="reboot_apply_change">변경 사항을 적용하려면 재부팅하세요.</string>
    <string name="restore_app_confirmation">정말로 실행하시겠습니까? 숨겨진 앱이 원본 앱으로 복원됩니다.</string>

</resources>

```

`app/core/src/main/res/values-ku/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">زیادکراوەکان</string>
    <string name="superuser">سوپەر یوسەر</string>
    <string name="logs">تۆمارەکان</string>
    <string name="settings">ڕێکخستنەکان</string>
    <string name="install">دامەزراندن</string>
    <string name="section_home">ماڵەوە</string>
    <string name="section_theme">ڕووکارەکان</string>
    <string name="denylist">پێڕستی ڕێگەپێنەدراوەکان</string>

    <!--Home-->
    <string name="no_connection">هێڵ بەردەست نییە</string>
    <string name="app_changelog">گۆڕانکارییەکان</string>
    <string name="loading">کردنەوە…</string>
    <string name="update">بەرزکردنەوە</string>
    <string name="not_available">نییە</string>
    <string name="hide">شاردنەوە</string>
    <string name="home_package">پاکێج</string>
    <string name="home_app_title">ئەپ</string>

    <string name="home_notice_content">تەنها لە گیتهەبی فەرمی ماجیسک دابگرە، لە شوێنی تر لەوانەیە زیانبەخش بێت</string>
    <string name="home_support_title">پشتگیریمان بکە</string>
    <string name="home_follow_title">شوێنمان بکەوە</string>
    <string name="home_item_source">سەرچاوە</string>
    <string name="home_support_content">ماجیسک بە خۆڕاییە و هەر واش ئەمێنێتەوە، بەهەرحاڵ ئەتوانیت پشتگیرییەکمان بکەی بۆ گرنگی پێدان</string>
    <string name="home_installed_version">داگیراوە</string>
    <string name="home_latest_version">دوایین وەشان</string>
    <string name="invalid_update_channel">کەناڵێکی نوێکردنەوەی هەڵە</string>
    <string name="uninstall_magisk_title">سڕینەوەی ماجیسک</string>
    <string name="uninstall_magisk_msg">هەموو زیادکراوەکان دەسڕێنەوە، ڕۆت دەسڕێتەوە، و هەر ڕەمزێنراوێک بەهۆی ماجیسک کرابێ لادەچێت!</string>

    <!--Install-->
    <string name="keep_force_encryption">ڕەمزاندنی بەزۆر بهێڵەوە</string>
    <string name="keep_dm_verity">بهێڵەوە AVB 2.0/dm-verity</string>
    <string name="recovery_mode">دۆخی ڕیکەڤەڕی</string>
    <string name="install_options_title">هەڵبژاردنەکان</string>
    <string name="install_method_title">ڕێگای</string>
    <string name="install_next">دواتر</string>
    <string name="install_start">با بیکەین</string>
    <string name="manager_download_install">بۆ داگرتن و ڕێکخستن کرتە بکە</string>
    <string name="direct_install">داگرتنی ڕاستەوخۆ(پێشنیارکراوە)</string>
    <string name="install_inactive_slot">دایبگرە بۆ خانەی ناچالاک(پاش OTA)</string>
    <string name="install_inactive_slot_msg">ئێستا ئامێرەکەت دەچێتە خانە ناچالاکەکە، ئەمە بەکاربهێنە تەنها دوای ئەپدەیت کردن لە ڕێگەی OTA، بەردەوام دەبیت؟</string>
    <string name="setup_title">ڕێکخستنی زیاتر</string>
    <string name="select_patch_file">فایلێک هەڵبژێرە و پینەی بکە</string>
    <string name="patch_file_msg">تکایە فایلێکی Tar یان img یان payload.bin هەڵبژێرە</string>
    <string name="reboot_delay_toast">ڕێستارت کردنەوە لە ماوەی ٥ چرکە…</string>
    <string name="flash_screen_title">ڕێکخستن</string>

    <!--Superuser-->
    <string name="su_request_title">داواکاری سوپەریوسەر</string>
    <string name="touch_filtered_warning">ئەپێک لە سەر شاشەکەیە، ناتوانین دڵنیا بینەوە</string>
    <string name="deny">ڕەتکردنەوە</string>
    <string name="prompt">داواکاری</string>
    <string name="grant">ڕێگەپێدان</string>
    <string name="su_warning">ڕێگەپێدان بۆ تەواوی ئامێرەکەت، گەر دڵنیا نیت ڕەتی بکەوە</string>
    <string name="forever">بۆ هەمیشە</string>
    <string name="once">بۆ یەکجار</string>
    <string name="tenmin">بۆ ١٠ خولەک</string>
    <string name="twentymin">بۆ ٢٠ خولەک</string>
    <string name="thirtymin">بۆ ٣٠ خولەک</string>
    <string name="sixtymin">بۆ ٦٠ خولەک</string>
    <string name="su_allow_toast">%1$s ڕێگەپێدانی سوپەریوسەری بۆ زیادکرا</string>
    <string name="su_deny_toast">%1$s ڕێگەپێدانی سوپەریوسەر ڕەتکرایەوە</string>
    <string name="su_snack_grant">ڕێگەپێدانی سوپەریوسەری %1$s بۆ درا</string>
    <string name="su_snack_deny">ڕێگەپێدانی سوپەریوسەر %1$s ڕەتکرایەوە</string>
    <string name="su_snack_notif_on">ئاگەدارکردنەوەکانی %1$s کارا کراوە</string>
    <string name="su_snack_notif_off">ئاگەدارکردنەوەکانی %1$s کوژاوەتەوە</string>
    <string name="su_snack_log_on">تۆمارەکانی %1$s کراوەتەوە</string>
    <string name="su_snack_log_off">تۆمارەکانی %1$s کوژاوەتەوە</string>
    <string name="su_revoke_title">لابردن؟</string>
    <string name="su_revoke_msg">دڵنیابەوە بۆ لابردنی سوپەریوسەر بۆ %1$s </string>
    <string name="toast">هێنانەسەر</string>
    <string name="none">هیچ</string>

    <string name="superuser_toggle_notification">ئاگادارییەکان</string>
    <string name="superuser_toggle_revoke">لابردن</string>
    <string name="superuser_policy_none">هیچ ئەپێک تا ئێستا داوای سوپەریوسەری نەکردووە</string>

    <!--Logs-->
    <string name="log_data_none">هیچ تۆمارێک نییە، ئەو ئەپانەی ڕۆتیان پێویستە زوزو بەکاریبێنە</string>
    <string name="log_data_magisk_none">تۆمارەکانی ماجیسک بەتاڵن، باشە بۆ؟</string>
    <string name="menuSaveLog">تۆمارەکان هەڵبگرە</string>
    <string name="menuClearLog">تۆمارەکان بسڕەوە</string>
    <string name="logs_cleared">بەسەرکەوتویی تۆمارەکان سڕانەوە</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">ئامانج UID: %1$d</string>
    <string name="target_pid">Mount ns target PID: %s</string>
    <string name="selinux_context">SELinux context: %s</string>
    <string name="supp_group">Supplementary group: %s</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">پیشاندانی ئەپەکانی سیستەم</string>
    <string name="show_os_app">پیشاندانی ئەپەکان</string>
    <string name="hide_filter_hint">پاڵاوتنی بەپێی ناو</string>
    <string name="hide_search">گەڕان</string>

    <!--Module-->
    <string name="no_info_provided">(هیچ زانیارییەک نییە)</string>
    <string name="reboot_userspace">ڕێستارت کردنەوە</string>
    <string name="reboot_recovery">چوونە ناو ڕیکەڤەری</string>
    <string name="reboot_bootloader">چوونە ناو بووتلۆدەر</string>
    <string name="reboot_download">چوونە ناو داونلۆد</string>
    <string name="reboot_edl">چوونە ناو EDL</string>
    <string name="reboot_safe_mode">دۆخی پارێزراو</string>
    <string name="module_version_author">%1$s by %2$s</string>
    <string name="module_state_remove">سڕینەوە</string>
    <string name="module_action">کارا</string>
    <string name="module_state_restore">گەڕاندنەوە</string>
    <string name="module_action_install_external">لە بیرگەکەتەوە ڕێکی بخە</string>
    <string name="update_available">وەشانی نوێ بەردەستە</string>
    <string name="suspend_text_riru">زیادکراوەکە کار ناکات چونکە %1$s کراوەتەوە</string>
    <string name="suspend_text_zygisk">زیادکراوەکە کارناکات چونکە %1$s نەکراوەتەوە</string>
    <string name="zygisk_module_unloaded">زیادکراوی Zygisk بەهۆی نەگونجان کارناکات</string>
    <string name="module_empty">هیچ زیادکراوێک دانەبەزیوە</string>
    <string name="confirm_install">دابەزاندنی زیادکراو %1$s?</string>
    <string name="confirm_install_title">دڵنیابوونەوە لە دابەزاندن</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">جۆری ڕووکار</string>
    <string name="settings_dark_mode_message">حەزت لە کامەی بوو ئەوە هەڵبژێرە</string>
    <string name="settings_dark_mode_light">هەمیشە دۆخی ڕوناک</string>
    <string name="settings_dark_mode_system">با بەگوێرەی سیستەمەکە بێت!</string>
    <string name="settings_dark_mode_dark">هەمیشە دۆخی تاریک</string>
    <string name="settings_download_path_title">شوێنی داگرتنەکە</string>
    <string name="settings_download_path_message">فایلەکان هەڵدەگیرێن لە %1$s</string>
    <string name="settings_hide_app_title">شاردنەوەی ئەپی ماجیسک</string>
    <string name="settings_hide_app_summary">داگرتنی ماجیسک بە ناوی جیاوە</string>
    <string name="settings_restore_app_title">ئەپە ڕەسەنەکە بهێنەوە</string>
    <string name="settings_restore_app_summary">ئەپەکە دەربخەوە و ڕەسەنڵ</string>
    <string name="language">زمان</string>
    <string name="system_default">(وەک هی ئامێرەکە)</string>
    <string name="settings_check_update_title">گەڕان بەدوای نوێکاری</string>
    <string name="settings_check_update_summary">گەڕان بەدوای نوێکاری خۆکارانە</string>
    <string name="settings_update_channel_title">کەناڵی نوێکاری</string>
    <string name="settings_update_stable">جێگیر</string>
    <string name="settings_update_beta">پێشوەختە(بێتا)</string>
    <string name="settings_update_custom">تایبەت</string>
    <string name="settings_update_custom_msg">بەستەرێکی تایبەت دابنێ</string>
    <string name="settings_zygisk_summary">کارپێکردنی بەشێکی ماجیسک لە zygote daemon</string>
    <string name="settings_denylist_title">پێڕستی نەرێنی کراوەکان</string>
    <string name="settings_denylist_summary">هەر ئەپێک لە پێڕستی نەرێنییەکان کاریگەریەکانی ماجیسکی لەسەر نییە</string>
    <string name="settings_denylist_config_title">دەستکاریکردنی پێڕستی نەرێنیکراوەکان</string>
    <string name="settings_denylist_config_summary">ئەو ئەپە هەڵبژێرە کە دەتەوێت نەرێنیی بکەیت</string>
    <string name="settings_hosts_title">هۆستی ناسیستەمی</string>
    <string name="settings_hosts_summary"> هۆستی ناسیستەمی بۆ لابردنی ڕیکلامەکان</string>
    <string name="settings_hosts_toast"> هۆستی ناسیستەمی زیادکرا</string>
    <string name="settings_app_name_hint">ناوی نوێ</string>
    <string name="settings_app_name_helper">ئەپەکە بەم ناوەوە دروست دەکرێتەوە</string>
    <string name="settings_app_name_error">هەڵەیە</string>
    <string name="settings_su_app_adb">ئەپەکان و ADB</string>
    <string name="settings_su_app">تەنها ئەپەکان</string>
    <string name="settings_su_adb">ADB تەنها</string>
    <string name="settings_su_disable">ناچالاک کراوە</string>
    <string name="settings_su_request_10">10 چرکە</string>
    <string name="settings_su_request_15">15 چرکە</string>
    <string name="settings_su_request_20">20 چرکە</string>
    <string name="settings_su_request_30">30 چرکە</string>
    <string name="settings_su_request_45">45 چرکە</string>
    <string name="settings_su_request_60">60 چرکە</string>
    <string name="superuser_access">دەسەڵاتی سوپەریوسەر</string>
    <string name="auto_response">وەڵامدانەوەی خۆکارانە</string>
    <string name="request_timeout">ماوەی وەڵامدانەوە</string>
    <string name="superuser_notification">ئاگەدارییەکانی سوپەریوسەر</string>
    <string name="settings_su_reauth_title">پرسیاربکەوە دوای هەر نوێکردنەوەیەک</string>
    <string name="settings_su_reauth_summary">دوای نوێکردنەوەی ئەپەکان دووبارە پرسیار بکەوە بۆ دەسەڵاتی سوپەریوسەر</string>
    <string name="settings_su_tapjack_title">پارێزگاری کردن لە ئەگەری دەستلێدانی تر</string>
    <string name="settings_su_tapjack_summary"> کاتێک ئەپێکی تر بەسەر شاشەکەوەیە، سوپەر یوسەر وەڵام ناداتەوە لە کردنی هەر بژاردەیەک لەبەر پارێزراوی</string>
    <string name="settings_su_auth_title">دڵنیاکردنەوەی کەسی</string>
    <string name="settings_su_auth_summary">داواکاری بکە بۆ دڵنیاکردنەوەی کەسی لەکاتی داواکاری سوپەریوسەر</string>
    <string name="settings_su_auth_insecure">هیچ دڵنیاکردنەوەیەک نییە</string>
    <string name="settings_customization">دەستکاریکردن</string>
    <string name="setting_add_shortcut_summary">یەک ئایکۆنی جوان زیادبکە بۆ سەر شاشەکە ئەگەر قورس بوو ئەوەی خۆی بدۆزیتەوە</string>
    <string name="settings_doh_title">DNS بەسەر HTTPS</string>
    <string name="settings_doh_description">Workaround DNS خراپە لە هەندێک شوێن</string>
    <string name="settings_random_name_title">ناوێک لەخۆیەوە</string>
    <string name="settings_random_name_description">دانانی ناوێک لەخۆوە تاوەکوو ئاشکرا نەبێت</string>

    <string name="multiuser_mode">دۆخی فرەبەکارهێنەر</string>
    <string name="settings_owner_only">تەنها خاوەنی ئامێر</string>
    <string name="settings_owner_manage">خاوەنی ئامێر</string>
    <string name="settings_user_independent">بەکارهێنەری سەربەخۆ</string>
    <string name="owner_only_summary">تەنها خاوەنەکە دۆخی ڕۆتی هەیە</string>
    <string name="owner_manage_summary">تەنها خاوەنەکە دەسەڵاتی بەکارهێنانی ڕۆتی هەیە</string>
    <string name="user_independent_summary">هەر بەکارهێنەرێک یاسای جیاوازی هەیە</string>

    <string name="mount_namespace_mode">چونە دۆخی بۆشایی ناو</string>
    <string name="settings_ns_global">بۆشاییناوی گشتی</string>
    <string name="settings_ns_requester">بۆشایی ناوی خۆیی</string>
    <string name="settings_ns_isolate">بۆشایی ناوی جیا</string>
    <string name="global_summary">هەمو ڕۆتەکان ناوی گشتی بەکار ئەهێنن</string>
    <string name="requester_summary">هەمو ڕۆتەکان ناوی خۆیی بەکار ئەهێنن</string>
    <string name="isolate_summary">هەمو ڕۆتەکان ناوی جیا بەکار ئەهێنن</string>

    <!--Notifications-->
    <string name="update_channel">نوێکردنەوەکانی ماجیسک</string>
    <string name="progress_channel">ئاگادارییە کاراکان</string>
    <string name="updated_channel">نوێکردنەوە سەرکەوتووبوو</string>
    <string name="download_complete">داگرتن سەرکەوتووبوو</string>
    <string name="download_file_error">هەڵەیەک رووی دا لەکاتی داگرتنی فایلەکە</string>
    <string name="magisk_update_title">وەشانی نوێی ماجیسک ئامادەیە!</string>
    <string name="updated_title">ماجیسک نوێکراوە!</string>
    <string name="updated_text">کرتە بکە بۆ کردنەوەی ئەپ</string>

    <!--Toasts, Dialogs-->
    <string name="yes">بەڵێ</string>
    <string name="no">نەخێر</string>
    <string name="repo_install_title">داگرتن %1$s %2$s(%3$d)</string>
    <string name="download">داگرتن</string>
    <string name="reboot">ڕێستارت</string>
    <string name="close">داخستن</string>
    <string name="release_notes">نێبینییەکان</string>
    <string name="flashing">فلاش کردن</string>
    <string name="running">کار کردن...</string>
    <string name="done">تەواو!</string>
    <string name="done_action">کارکردنی %1$s تەواو بوو</string>
    <string name="failure">Failed!</string>
    <string name="hide_app_title">شاردنەوەی ئەپی ماجیسک…</string>
    <string name="open_link_failed_toast">هیچ ئەپێک تییە تا لینکەکەی پێ بکرێتەوە</string>
    <string name="complete_uninstall">سڕینەوەی تەواوی</string>
    <string name="restore_img">هێنانەوەی img</string>
    <string name="restore_img_msg">هێنانەوە…</string>
    <string name="restore_done">هاتەوە!</string>
    <string name="restore_fail">هیچ فایلێکی هەڵگیراوت نیە!</string>
    <string name="setup_fail">ڕێکخستن شکستی هێنا</string>
    <string name="env_fix_title">پێویستی بە ڕێکخستنی زیاترە</string>
    <string name="env_fix_msg">مۆبایلەکەت پێویستی بە ڕێکخستنی زیاترە، ئایا ئەتەوێت بەردەوام بیت و ڕێستارتی بکەیتەوە؟</string>
    <string name="env_full_fix_msg"> پێویستە دوبارە ماجیسک دابگریتەوە بۆ ئەوەی بەباشی کاربکات تکایە ماجیسک دابگرەوە لەناو ئەپەکە خۆی چونکە لە ڕیکەڤەرییەوە ناتوانرێ زانیاری تەواو لەسەر ئامێرەکە دەستبخرێت </string>
    <string name="setup_msg">دەستپێکردن....</string>
    <string name="unsupport_magisk_title">وەشانی ماجیسک پاڵپشتینەکراوە</string>
    <string name="unsupport_magisk_msg">وەشانی ماجیسکەکەت زۆر کۆنە وەک ئەوە وایە هەر نەبێت، تکایە نوێی بکەوە بە زوترین کات</string>
    <string name="unsupport_general_title">باری نائاسایی</string>
    <string name="unsupport_system_app_msg">ئەم ئەپە وەکو ئەپی سیستەم کارناکات، تکایە بیگۆڕەوە بۆ ئەپی ئاسایی</string>
    <string name="unsupport_other_su_msg"> \"su\" binary یەکی بێگانە دۆزرایەوە، تکایە جگە لە ماجیسک ئەپی تر بەکارمەهێنە بۆ ڕۆت کردن  </string>
    <string name="unsupport_external_storage_msg">ماجیسک لە بیرگەی دەرەکی داگیراوە، تکایە بیبەوە بۆ ناوەکی</string>
    <string name="unsupport_nonroot_stub_msg">ئەپە شاراوەکە کار ناکات چونکە ڕۆتەکە نەماوە، تکایە ئەپە ڕەسەنەکە بگەڕێنەوە</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">ڕەزامەندی بیرگە بدە تاوەکوو ئەمە کار بکات</string>
    <string name="post_notifications_denied">ڕەزامەندی ئاگاداری بکە تاوەکوو ئەمە کار بکات</string>
    <string name="install_unknown_denied">ڕەزامەندی "install unknown apps" تاوەکوو کار بکات</string>
    <string name="add_shortcut_title">زیادی بکە بۆ سەر شاشە</string>
    <string name="add_shortcut_msg">دوای شاردنەوەی ئەم ئەپە، ئەتەوێت یەک ئایکۆنی جوان زیادبکەیت بۆ سەر شاشەکە ئەگەر قورس بوو ئەوەی خۆی بدۆزیتەوە؟</string>
    <string name="app_not_found">هیچ ئەپێک نەدۆزرایەوە تاوەکوو ئەم کارەی پێ بکرێت</string>
    <string name="reboot_apply_change">ڕێستارت بکە تاوەکوو کاریگەریەکان کار بکەن</string>
    <string name="restore_app_confirmation">ئەمە ئەپە ڕەسەنەکە ئەهێنێتەوە، دڵنیایت لە کردنی؟</string>

</resources>
      

```

`app/core/src/main/res/values-lt/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Moduliai</string>
    <string name="superuser">Supernaudotojas</string>
    <string name="logs">Žurnalas</string>
    <string name="settings">Nustatymai</string>
    <string name="install">Įdiegti</string>
    <string name="section_home">Pagrindinis</string>
    <string name="section_theme">Temos</string>
    <string name="denylist">DenyList</string>

    <!--Home-->
    <string name="no_connection">Nėra ryšio</string>
    <string name="app_changelog">Keitimų sąrašas</string>
    <string name="loading">Įkeliama…</string>
    <string name="update">Naujinti</string>
    <string name="not_available">Neįdiegta</string>
    <string name="hide">Slėpti</string>
    <string name="home_package">Paketas</string>
    <string name="home_app_title">Programėlė</string>

    <string name="home_notice_content">Magisk siųskites TIK iš oficialiojo GitHub puslapio. Failai iš nežinomų šaltinių gali būti kenkėjiški!</string>
    <string name="home_support_title">Palaikykite mus</string>
    <string name="home_follow_title">Sekite mus</string>
    <string name="home_item_source">Pirminis kodas</string>
    <string name="home_support_content">Magisk yra ir visada bus nemokamas, atvirojo kodo. Tačiau galite paaukoti pinigų, jei norite parodyti, kad jums rūpi.</string>
    <string name="home_installed_version">Įdiegta versija</string>
    <string name="home_latest_version">Naujausia versija</string>
    <string name="invalid_update_channel">Neteisingas naujinimų kanalas</string>
    <string name="uninstall_magisk_title">Pašalinti Magisk</string>
    <string name="uninstall_magisk_msg">Visi moduliai bus išjungti/pašalinti!\nRoot prieiga bus pašalinta!\nVidinė atmintis, iššifruota su Magisk, bus iš naujo užšifruota!</string>

    <!--Install-->
    <string name="keep_force_encryption">Neišjungti priverstinio šifravimo</string>
    <string name="keep_dm_verity">Neišjungti AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Atkūrimo režimas</string>
    <string name="install_options_title">Parinktys</string>
    <string name="install_method_title">Būdas</string>
    <string name="install_next">Toliau</string>
    <string name="install_start">Įdiegti</string>
    <string name="manager_download_install">Spustelėkite, kad atsisiųstumėte ir įdiegtumėte</string>
    <string name="direct_install">Tiesioginis įdiegimas (rekomenduojama)</string>
    <string name="install_inactive_slot">Įdiegti į antrąją vietą (po OTA naujinimo)</string>
    <string name="install_inactive_slot_msg">Jūsų įremginys bus PRIVERSTAS pasileisti į dabartinę neaktyvią vietą po paleidimo iš naujo!\nNaudokite šią parinktį, kai OTA naujinimas yra baigtas.\nTęsti?</string>
    <string name="setup_title">Išplėstinė sąranka</string>
    <string name="select_patch_file">Pasirinkite ir taisykite failą</string>
    <string name="patch_file_msg">Pasirinkite vaizdo failą (*.img) arba ODIN archyvą (*.tar)</string>
    <string name="reboot_delay_toast">Paleidžiama iš naujo po 5 sekundžių…</string>
    <string name="flash_screen_title">Įdiegimas</string>

    <!--Superuser-->
    <string name="su_request_title">Supernaudotojo užklausa</string>
    <string name="touch_filtered_warning">Programėlė užstoja supernaudotojo užklausą, todėl Magisk negali patvirtinti jūsų atsakymo</string>
    <string name="deny">Atmesti</string>
    <string name="prompt">Klausti</string>
    <string name="grant">Leisti</string>
    <string name="su_warning">Suteikia prieigą prie jūsų įrenginio.\nAtmeskite, jei nesate tikri!</string>
    <string name="forever">Amžinai</string>
    <string name="once">Kartą</string>
    <string name="tenmin">10 minučių</string>
    <string name="twentymin">20 minučių</string>
    <string name="thirtymin">30 minučių</string>
    <string name="sixtymin">60 minučių</string>
    <string name="su_allow_toast">%1$s suteiktos supernaudotojo teisės</string>
    <string name="su_deny_toast">%1$s atmestos supernaudotojo teisės</string>
    <string name="su_snack_grant">%1$s supernaudotojo teisės yra suteiktos</string>
    <string name="su_snack_deny">%1$s supernaudotojo teisės yra atmestos</string>
    <string name="su_snack_notif_on">%1$s pranešimai yra įjungti</string>
    <string name="su_snack_notif_off">%1$s pranešimai yra išjungti</string>
    <string name="su_snack_log_on">%1$s registravimas yra įjungtas</string>
    <string name="su_snack_log_off">%1$s registravimas yra išjungtas</string>
    <string name="su_revoke_title">Atšaukti?</string>
    <string name="su_revoke_msg">Patvirtinkite %1$s supernaudotojo teisių atšaukimą</string>
    <string name="toast">Iššokantys pranešimai</string>
    <string name="none">Nėra</string>

    <string name="superuser_toggle_notification">Pranešimai</string>
    <string name="superuser_toggle_revoke">Atšaukti</string>
    <string name="superuser_policy_none">Kol kas jokia programėlė neprašė supernaudotojo teisių.</string>

    <!--Logs-->
    <string name="log_data_none">Žurnalas tuščias</string>
    <string name="log_data_magisk_none">Magisk žurnalas yra tuščias, keistoka</string>
    <string name="menuSaveLog">Išsaugoti žurnalą</string>
    <string name="menuClearLog">Valyti žurnalą</string>
    <string name="logs_cleared">Žurnalas išvalytas</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Tikslinis UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Rodyti sistemos programėles</string>
    <string name="show_os_app">Rodyti OS programėles</string>
    <string name="hide_filter_hint">Filtruoti pagal pavadinimą</string>
    <string name="hide_search">Ieškoti</string>

    <!--Module-->
    <string name="no_info_provided">(Nėra informacijos)</string>
    <string name="reboot_userspace">Paleidimas neišjungus</string>
    <string name="reboot_recovery">Paleidimas į Recovery</string>
    <string name="reboot_bootloader">Paleidimas į Bootloader</string>
    <string name="reboot_download">Paleidimas į Download</string>
    <string name="reboot_edl">Paleidimas į EDL</string>
    <string name="module_version_author">%1$s nuo %2$s</string>
    <string name="module_state_remove">Šalinti</string>
    <string name="module_state_restore">Atkurti</string>
    <string name="module_action_install_external">Įdiegti iš saugyklos</string>
    <string name="update_available">Prieinamas naujinimas</string>
    <string name="suspend_text_riru">Modulis išjungtas, nes %1$s yra įjungtas</string>
    <string name="suspend_text_zygisk">Modulis išjungtas, nes %1$s nėra įjungtas</string>
    <string name="zygisk_module_unloaded">Zygisk moduis neįkeltas dėl nesuderinamumo</string>
    <string name="module_empty">Modulių nėra</string>
    <string name="confirm_install">Įdiegti modulį %1$s?</string>
    <string name="confirm_install_title">Įdiegimo patvirtinimas</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Temos režimas</string>
    <string name="settings_dark_mode_message">Pasirinkite režimą, kuris geriausiai atitinka jūsų stilių!</string>
    <string name="settings_dark_mode_light">Visada šviesi</string>
    <string name="settings_dark_mode_system">Sistemos</string>
    <string name="settings_dark_mode_dark">Visada tamsi</string>
    <string name="settings_download_path_title">Atsisiuntimo kelias</string>
    <string name="settings_download_path_message">Failai bus išsaugoti %1$s</string>
    <string name="settings_hide_app_title">Slėpti Magisk programėlę</string>
    <string name="settings_hide_app_summary">Įdiegti įgaliotąją programėlę su atsitiktiniu paketo ID ir kitu pavadinimu</string>
    <string name="settings_restore_app_title">Atkurti Magisk programėlę</string>
    <string name="settings_restore_app_summary">Atkurti programėlę ir originalų APK</string>
    <string name="language">Kalba</string>
    <string name="system_default">(Sistemos numatytoji)</string>
    <string name="settings_check_update_title">Naujinimų tikrinimas</string>
    <string name="settings_check_update_summary">Periodiškai fone tikrinti, ar nėra naujinimų</string>
    <string name="settings_update_channel_title">Naujinimų kanalas</string>
    <string name="settings_update_stable">Stabilus</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Tinkintas</string>
    <string name="settings_update_custom_msg">Įdėkite tinkinto kanalo URL</string>
    <string name="settings_zygisk_summary">Vykdyti Magisk dalis zygote tarnyboje</string>
    <string name="settings_denylist_title">Aktyvinti DenyList</string>
    <string name="settings_denylist_summary">Visos procesų, esančių denylist, Magisk modifikacijos bus atkurtos</string>
    <string name="settings_denylist_config_title">Konfigūruoti DenyList</string>
    <string name="settings_denylist_config_summary">Pasirinkite procesus, kuriuos norite įtraukti į denylist</string>
    <string name="settings_hosts_title">Basisteminis hosts</string>
    <string name="settings_hosts_summary">Basisteminis hosts palaiko reklamų blokatorių programėlėms</string>
    <string name="settings_hosts_toast">Pridėtas besisteminio hosts modulis</string>
    <string name="settings_app_name_hint">Naujas pavadinimas</string>
    <string name="settings_app_name_helper">Programėlė bus perpakuota su šiuo pavadinimu</string>
    <string name="settings_app_name_error">Netinkamas formatas</string>
    <string name="settings_su_app_adb">Programėlės ir ADB</string>
    <string name="settings_su_app">Tik programėlės</string>
    <string name="settings_su_adb">Tik ADB</string>
    <string name="settings_su_disable">Išjungta</string>
    <string name="settings_su_request_10">10 sekundžių</string>
    <string name="settings_su_request_15">15 sekundžių</string>
    <string name="settings_su_request_20">20 sekundžių</string>
    <string name="settings_su_request_30">30 sekundžių</string>
    <string name="settings_su_request_45">45 sekundės</string>
    <string name="settings_su_request_60">60 sekundžių</string>
    <string name="superuser_access">Prieigos lygis</string>
    <string name="auto_response">Automatinis atsakymas</string>
    <string name="request_timeout">Atsakymo laukimas</string>
    <string name="superuser_notification">Supernaudotojo pranešimas</string>
    <string name="settings_su_reauth_title">Pakartotinis autentifikavimas</string>
    <string name="settings_su_reauth_summary">Iš naujo prašyti supernaudotojo teisių po programėlių naujinimo</string>
    <string name="settings_su_tapjack_title">Bakstelėjimų perėmimo apsauga</string>
    <string name="settings_su_tapjack_summary">Supernaudotojo užklausos langas bus neaktyvus, kol jis yra užstotas kito lango</string>
    <string name="settings_customization">Tinkinimas</string>
    <string name="setting_add_shortcut_summary">Pridėti nuorodą į pagrindinį ekraną, jei po programėlės paslėpimo yra sunku atpažinti jos pavadinimą ir piktogramą</string>
    <string name="settings_doh_title">DNS virš HTTPS</string>
    <string name="settings_doh_description">Aktyvinti DoH (naudokite, jei kyla problemų jungiantis prie tinklo</string>

    <string name="multiuser_mode">Daugelio naudotojų režimas</string>
    <string name="settings_owner_only">Tik įrenginio savininkas</string>
    <string name="settings_owner_manage">Valdoma įrenginio savininko</string>
    <string name="settings_user_independent">Naudotojų taisyklės</string>
    <string name="owner_only_summary">Tik savininkas turi root prieigą</string>
    <string name="owner_manage_summary">Tik savininkas gali tvarkyti root prieigą ir gauti užklausas</string>
    <string name="user_independent_summary">Kiekvienas naudotojas turi savo atskiras root taisykles</string>

    <string name="mount_namespace_mode">Pavadinimų erdvės režimas</string>
    <string name="settings_ns_global">Bendra pavadinimų erdvė</string>
    <string name="settings_ns_requester">Paveldima pavadinimų erdvė</string>
    <string name="settings_ns_isolate">Izoliuota pavadinimų erdvė</string>
    <string name="global_summary">Visos root sesijos naudos bendrą pavainimų erdvę</string>
    <string name="requester_summary">Root sesijos paveldės prašytojų pavadinimų erdvę</string>
    <string name="isolate_summary">Kiekviena root sesija turės savo izoliuotą pavadinimų erdvę</string>

    <!--Notifications-->
    <string name="update_channel">Magisk naujinimai</string>
    <string name="progress_channel">Progreso pranešimai</string>
    <string name="updated_channel">Naujinimas baigtas</string>
    <string name="download_complete">Atsisiuntimas baigtas</string>
    <string name="download_file_error">Klaida atsisiunčiant failą</string>
    <string name="magisk_update_title">Prieinamas Magisk naujinimas!</string>
    <string name="updated_title">Magisk atnaujintas</string>
    <string name="updated_text">Bakstelėkite, kad atidarytumėte programėlę</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Taip</string>
    <string name="no">Ne</string>
    <string name="repo_install_title">Įdiegimas %1$s %2$s(%3$d)</string>
    <string name="download">Atsisiųsti</string>
    <string name="reboot">Paleisti iš naujo</string>
    <string name="release_notes">Laidos informacija</string>
    <string name="flashing">Diegiama…</string>
    <string name="done">Baigta!</string>
    <string name="failure">Nepavyko!</string>
    <string name="hide_app_title">Slepiama Magisk programėlė…</string>
    <string name="open_link_failed_toast">Nerasta programėlių nuorodos atidarymui</string>
    <string name="complete_uninstall">Visiškas pašalinimas</string>
    <string name="restore_img">Atkurti vaizdą</string>
    <string name="restore_img_msg">Atkuriama…</string>
    <string name="restore_done">Atkūrimas baigtas!</string>
    <string name="restore_fail">Nėra atsarginės kopijos!</string>
    <string name="setup_fail">Sąranka nepavyko</string>
    <string name="env_fix_title">Reikalinga išplėstinė sąranka</string>
    <string name="env_fix_msg">Jūsų įrenginiui reikalinga išplėstinė sąranka, kad Magisk veiktų tinkamai. Norite tęsti ir įrenginį paleisti iš naujo?</string>
    <string name="env_full_fix_msg">Jūsų įrenginiui reikia iš naujo įdiegti Magisk, kad jis veiktų tinkamai. Iš naujo įdiekite Magisk su programėle, atkūrimo režimas negali gauti teisingos įrenginio informacijos.</string>
    <string name="setup_msg">Vykdoma Running aplinkos sąranka…</string>
    <string name="unsupport_magisk_title">Nepalaikoma Magisk versija</string>
    <string name="unsupport_magisk_msg">Ši programėlės versija nepalaiko Magisk versijų, žemesnių už %1$s.\n\nProgramėlė veiks taip, lyg Magisk yra neįdiegtas. Kuo greičiau atnaujinkite Magisk.</string>
    <string name="unsupport_general_title">Nenormali būsena</string>
    <string name="unsupport_system_app_msg">Šios programėlės vykdymas kaip sistemos programėlės yra nepalaikomas. Nustatykite ją atgal į naudotojo programėlę.</string>
    <string name="unsupport_other_su_msg">Aptiktas dvejetainis failas \"su\" ne iš Magisk. Pašalinkite pašalinį root teisių tiekėją ir/arba iš naujo įdiekite Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk yra įdiegtas išorinėje saugykloje. Perkelkite programėlę į vidinę saugyklą.</string>
    <string name="unsupport_nonroot_stub_msg">Paslėpta Magisk programėlė negali tęsti darbo, nes root teisės buvo prarastos. Atkurkite originalų APk.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Suteikti prieigą prie saugyklos</string>
    <string name="post_notifications_denied">Suteikti prieigą prie pranešimų</string>
    <string name="install_unknown_denied">Suteikti prieigą prie įdiegimo iš nežinomų šaltinių</string>
    <string name="add_shortcut_title">Pridėti nuorodą į pagrindinį ekraną</string>
    <string name="add_shortcut_msg">Po šios programėlės paslėpimo jos pavadinimas, piktograma gali būti sunkiai atpažįstamos. Norite pridėti nuorodą į pagrindinį ekraną?</string>
    <string name="app_not_found">Nerasta programėlė, galinti atlikti šį veiksmą</string>
    <string name="reboot_apply_change">Paleiskite iš naujo, kad pritaikytumėte pakeitimus</string>
    <string name="restore_app_confirmation">Šis veiksmas atkurs paslėptą programėlę į originalią būseną. Tikrai norite tai padaryti?</string>

</resources>

```

`app/core/src/main/res/values-mk/strings.xml`:

```xml
<resources>

    <!--Welcome Activity-->
    <string name="modules">Модули</string>
    <string name="superuser">Супер-корисник</string>
    <string name="logs">Записник</string>
    <string name="settings">Поставки</string>
    <string name="install">Инсталирај</string>
    <string name="unsupport_magisk_title">Неподдржана верзија на Magisk</string>

    <!--Status Fragment-->
    <string name="invalid_update_channel">Невалиден канал за ажурирања</string>
    <string name="keep_force_encryption">Задржи ја присилната енкрипција</string>
    <string name="keep_dm_verity">Задржи AVB 2.0/dm-verity</string>
    <string name="uninstall_magisk_title">Деинсталирај го Magisk</string>
    <string name="uninstall_magisk_msg">Сите модули ќе бидат оневозможени/oтстранети. Рут привилегиите ќе бидат отстранети, а вашите податоци може да се енкриптираат ако моментално не се.</string>
    <string name="update">Ажурирај</string>

    <!--Module Fragment-->
    <string name="no_info_provided">(Нема информации)</string>
    <string name="reboot_recovery">Рестартирај во Recovery режим</string>
    <string name="reboot_bootloader">Рестартирај во Bootloader режим</string>
    <string name="reboot_download">Рестартирај во Download режим</string>

    <!--Repo Fragment-->
    <string name="update_available">Достапно е ажурирање</string>
    <string name="home_installed_version">Инсталирано</string>

    <!--Log Fragment-->
    <string name="menuSaveLog">Зачувај записник</string>
    <string name="menuClearLog">Исчисти го записникот сега</string>
    <string name="logs_cleared">Записникот е успешно исчистен.</string>

    <!--About Activity-->
    <string name="app_changelog">Листа на промени</string>

    <!-- System Components, Notifications -->
    <string name="update_channel">Magisk Ажурирања</string>
    <string name="progress_channel">Известувања за прогресот</string>
    <string name="download_complete">Преземањето е завршено</string>
    <string name="download_file_error">Грешка при преземање на фајлот</string>
    <string name="magisk_update_title">Достапно е ажурирање на Magisk!</string>

    <!-- Installation -->
    <string name="manager_download_install">Притисни за преземање и инсталирање.</string>
    <string name="direct_install">Директна инсталација (Препорачано)</string>
    <string name="install_inactive_slot">Инсталирај во неактивен слот (по ОТА)</string>
    <string name="install_inactive_slot_msg">Вашиот уред ќе биде ПРИНУДЕН да се подигне на тековниот неактивен слот по рестартирањето!\nОваа опција користете ја само откако OTA ажурирање е направено.\nПродолжи?</string>
    <string name="setup_title">Дополнителни подесувања</string>
    <string name="select_patch_file">Избери и обнови ја датотеката</string>
    <string name="patch_file_msg">Избери само image датотека (*.img) или ODIN tar датотека (*.tar)</string>
    <string name="reboot_delay_toast">Рестартирање за 5 секунди…</string>

    <!--Toasts, Dialogs-->
    <string name="repo_install_title">Инсталирај %1$s %2$s(%3$d)</string>
    <string name="download">Преземи</string>
    <string name="reboot">Рестартирај</string>
    <string name="release_notes">Белешки за изданието</string>

    <string name="flashing">Применувам</string>
    <string name="open_link_failed_toast">Не е пронајдена апликација за отворање на врската.</string>
    <string name="complete_uninstall">Целосно деинсталирање</string>
    <string name="restore_img">Врати image датотеки</string>
    <string name="restore_img_msg">Враќање…</string>
    <string name="restore_done">Враќањето заврши!</string>
    <string name="restore_fail">Не постои оригинална резервна копија!</string>
    <string name="setup_fail">Поставувањето е неуспешно.</string>
    <string name="env_fix_title">Потребни е дополнително поставување</string>
    <string name="setup_msg">Надградба на работната околина…</string>

    <!--Settings Activity -->
    <string name="language">Јазик</string>
    <string name="system_default">(Стандарден системски)</string>
    <string name="settings_check_update_title">Провери за ажурирања</string>
    <string name="settings_check_update_summary">Периодично проверувај за ажурирања во позадина.</string>
    <string name="settings_update_channel_title">Канал за ажурирања</string>
    <string name="settings_update_stable">Стабилен</string>
    <string name="settings_update_beta">Бета</string>
    <string name="settings_update_custom">Прилагодено</string>
    <string name="settings_update_custom_msg">Внеси прилагоден URL линк</string>
    <string name="settings_hosts_title">Несистемски хостови</string>
    <string name="settings_hosts_summary">Поддршка за несистемски хостови за Adblock апликации.</string>
    <string name="settings_hosts_toast">Додаден е модул за несистемски хостови</string>

    <string name="settings_su_app_adb">Апликации и АДБ</string>
    <string name="settings_su_app">Само апликации</string>
    <string name="settings_su_adb">Само АДБ</string>
    <string name="settings_su_disable">Оневозможено</string>
    <string name="settings_su_request_10">10 секунди</string>
    <string name="settings_su_request_15">15 секунди</string>
    <string name="settings_su_request_20">20 секунди</string>
    <string name="settings_su_request_30">30 секунди</string>
    <string name="settings_su_request_45">45 секунди</string>
    <string name="settings_su_request_60">60 секунди</string>
    <string name="superuser_access">Пристап за супер-корисник</string>
    <string name="auto_response">Автоматски одговор</string>
    <string name="request_timeout">Временско ограничување на барање</string>
    <string name="superuser_notification">Супер-корисник известување</string>
    <string name="settings_su_reauth_title">Повторна автентикација по надградба</string>
    <string name="settings_su_reauth_summary">Повторна автентикација за супер-корисник дозвола по надградбата на апликацијата</string>

    <string name="multiuser_mode">Режим на повеќе корисници</string>
    <string name="settings_owner_only">Само сопственикот на уредот</string>
    <string name="settings_owner_manage">Управувано од сопственикот на уредот</string>
    <string name="settings_user_independent">Независно од корисникот</string>
    <string name="owner_only_summary">Само сопственикот има рут пристап.</string>
    <string name="owner_manage_summary">Само сопственикот може да управува со рут пристапот и да ги прима барања за рут пристап.</string>
    <string name="user_independent_summary">Секој корисник има сопствени рут правила.</string>

    <string name="mount_namespace_mode">Поставете го режимот на именски простор</string>
    <string name="settings_ns_global">Глобален именски простор</string>
    <string name="settings_ns_requester">Наследи именски простор</string>
    <string name="settings_ns_isolate">Изолиран именски простор</string>
    <string name="global_summary">Сите рут сесии го користат глобалниот именски простор.</string>
    <string name="requester_summary">Рут сесиите ќе го наследат именскиот простор на нивниот барател.</string>
    <string name="isolate_summary">Секоја рут сесија ќе има свој изолиран именски простор.</string>

    <!--Superuser-->
    <string name="su_request_title">Супер-корисник барање</string>
    <string name="deny">Одбиј</string>
    <string name="prompt">Прашај</string>
    <string name="grant">Одобри</string>
    <string name="su_warning">Дава целосен пристап на вашиот уред.\nОдбијте ако не сте сигурни!</string>
    <string name="forever">Засекогаш</string>
    <string name="once">Еднаш</string>
    <string name="tenmin">10 минути</string>
    <string name="twentymin">20 минути</string>
    <string name="thirtymin">30 минути</string>
    <string name="sixtymin">60 минути</string>
    <string name="su_allow_toast">На %1$s се доделени правата на супер-корисник</string>
    <string name="su_deny_toast">На %1$s се одбиени правата на супер-корисник</string>
    <string name="su_snack_grant">Правата за супер-корисник од %1$s се одобрени</string>
    <string name="su_snack_deny">Правата за супер-корисник од %1$s се одбиени</string>
    <string name="su_snack_notif_on">Известувањата од %1$s се овозможени</string>
    <string name="su_snack_notif_off">Известувањата од %1$s се оневозможени</string>
    <string name="su_snack_log_on">Записникот на настани е овозможен за %1$s</string>
    <string name="su_snack_log_off">Записникот на настани е оневозможен %1$s</string>
    <string name="su_revoke_title">Анулирај?</string>
    <string name="su_revoke_msg">Дали потврдувате анулирање на поставките за пристап на %1$s?</string>
    <string name="toast">Тост</string>
    <string name="none">Ниеден</string>

    <!--Superuser logs-->
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Целен UID: %1$d</string>

    <!-- MagiskHide -->
    <string name="show_system_app">Прикажи ги системските апликации</string>

</resources>

```

`app/core/src/main/res/values-ml/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">മൊഡ്യുൾസ്</string>
    <string name="superuser">സൂപ്പർയുസർ</string>
    <string name="logs">ലോഗ്സ്</string>
    <string name="settings">സെറ്റിംഗ്സ്</string>
    <string name="install">ഇൻസ്റ്റോൾ</string>
    <string name="section_home">ഹോം</string>
    <string name="section_theme">തീമുകൾ</string>
    <string name="denylist">നിഷിദ്ധ പട്ടിക</string>

    <!--Home-->
    <string name="no_connection">കണക്ഷൻ ലഭ്യമല്ല</string>
    <string name="app_changelog">മാറ്റങ്ങൾ</string>
    <string name="loading">ലോഡിംഗ്...</string>
    <string name="update">അപ്ഡേറ്റ്</string>
    <string name="not_available">ലഭ്യമല്ല</string>
    <string name="hide">മറയ്ക്കൂ</string>
    <string name="home_package">പാക്കേജ്</string>
    <string name="home_app_title">ആപ്പ്</string>

    <string name="home_notice_content">ഔദ്യോഗിക ഗിറ്റ്ഹബ് പേജിൽ നിന്ന് മാത്രം മജിസ്‌ക് ഡൗൺലോഡ് ചെയ്യുക. അജ്ഞാത ഉറവിടങ്ങളിൽ നിന്നുള്ള ഫയലുകൾ ക്ഷുദ്രകരമാകാം!</string>
    <string name="home_support_title">ഞങ്ങളെ തുണയ്‌ക്കുക</string>
    <string name="home_follow_title">ഞങ്ങളെ ഫോളോ ചെയ്യുക</string>
    <string name="home_item_source">സോഴ്സ്</string>
    <string name="home_support_content">മജിസ്‌ക് എല്ലായ്പ്പോഴും സ്വതന്ത്രവും ഓപ്പൺ സോഴ്‌സും ആയിരിക്കും. എന്നിരുന്നാലും, ഒരു സംഭാവന നൽകിക്കൊണ്ട് നിങ്ങൾ പിന്തുണയ്ക്കുന്നുവെന്ന് ഞങ്ങളെ കാണിക്കാനാകും.</string>
    <string name="home_installed_version">ഇൻസ്റ്റാൾ ചെയ്ത പതിപ്പ്</string>
    <string name="home_latest_version">പുതിയ പതിപ്പ്</string>
    <string name="invalid_update_channel">അപ്‌ഡേറ്റ് ചാനൽ അസാധുവാണ്</string>
    <string name="uninstall_magisk_title">മജിസ്‌ക് അൺഇൻസ്റ്റാൾ ചെയ്യുക</string>
    <string name="uninstall_magisk_msg">എല്ലാ മൊഡ്യൂളുകളും പ്രവർത്തനരഹിതമാക്കും/നീക്കം ചെയ്യപ്പെടും!\nറൂട്ട് നീക്കം ചെയ്യപ്പെടും!\nമജിസ്‌ക് വഴി  അൺഎൻക്രിപ്റ്റ്  ചെയ്യപ്പെട്ട ഇന്റെര്ണല് സ്റ്റോറേജുകൾ വീണ്ടും എൻക്രിപ്റ്റ് ചെയ്യപ്പെടും!!</string>

    <!--Install-->
    <string name="keep_force_encryption">ഫോഴ്‌സ് എൻക്രിപ്ഷൻ സംരക്ഷിക്കുക</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity സംരക്ഷിക്കുക</string>
    <string name="recovery_mode">റിക്കവറി മോഡ്</string>
    <string name="install_options_title">ഓപ്ഷനുകൾ</string>
    <string name="install_method_title">രീതി</string>
    <string name="install_next">അടുത്തത്</string>
    <string name="install_start">നമുക്ക് തുടങ്ങാം</string>
    <string name="manager_download_install">ഡൗൺലോഡ് ചെയ്ത് ഇൻസ്റ്റാൾ ചെയ്യാൻ അമർത്തുക</string>
    <string name="direct_install">നേരിട്ടുള്ള ഇൻസ്റ്റാളേഷൻ (ശുപാർശ ചെയ്യുന്നത്)</string>
    <string name="install_inactive_slot">നിഷ്ക്രിയ സ്ലോട്ടിലേക്ക് ഇൻസ്‌റ്റാൾ ചെയ്യുക (OTA-ന് ശേഷം)</string>
    <string name="install_inactive_slot_msg">റീബൂട്ടിന് ശേഷം നിങ്ങളുടെ ഉപകരണം നിലവിലെ നിഷ്‌ക്രിയ സ്ലോട്ടിലേക്ക് ബൂട്ട് ചെയ്യാൻ നിർബന്ധിതരാകും!\nOTA പൂർത്തിയാക്കിയതിന് ശേഷം മാത്രം ഈ ഓപ്ഷൻ ഉപയോഗിക്കുക.\nതുടരണോ?</string>
    <string name="setup_title">അധിക സജ്ജീകരണം</string>
    <string name="select_patch_file">ഒരു ഫയൽ തിരഞ്ഞെടുത്ത് പാച്ച് ചെയ്യുക</string>
    <string name="patch_file_msg">ഒരു റോ ഇമേജ് (*.img) അല്ലെങ്കിൽ ഒരു ODIN ടാർ ഫയൽ (*.tar) തിരഞ്ഞെടുക്കുക</string>
    <string name="reboot_delay_toast">5 സെക്കൻഡിൽ റീബൂട്ട് ചെയ്യുന്നു…</string>
    <string name="flash_screen_title">ഇൻസ്റ്റലേഷൻ</string>

    <!--Superuser-->
    <string name="su_request_title">സൂപ്പർയൂസർ അഭ്യർത്ഥന</string>
    <string name="touch_filtered_warning">ഒരു ആപ്പ് ഒരു സൂപ്പർയൂസർ അഭ്യർത്ഥന മറയ്ക്കുന്നതിനാൽ, മജിസ്‌ക്-ന് നിങ്ങളുടെ പ്രതികരണം പരിശോധിക്കാൻ കഴിയില്ല</string>
    <string name="deny">നിഷേധിക്കുക</string>
    <string name="prompt">പ്രോംപ്റ്റ്</string>
    <string name="grant">അനുവദിക്കുക</string>
    <string name="su_warning">നിങ്ങളുടെ ഉപകരണത്തിലേക്ക് പൂർണ്ണ ആക്‌സസ് നൽകും.\nനിങ്ങൾക്ക് ഉറപ്പില്ലെങ്കിൽ നിരസിക്കുക!</string>
    <string name="forever">എന്നേക്കും</string>
    <string name="once">ഒരിക്കൽ</string>
    <string name="tenmin">10 മിനിറ്റ്</string>
    <string name="twentymin">20 മിനിറ്റ്</string>
    <string name="thirtymin">30 മിനിറ്റ്</string>
    <string name="sixtymin">60 മിനിറ്റ്</string>
    <string name="su_allow_toast">%1$s-ന് സൂപ്പർയൂസർ അവകാശം ലഭിച്ചു</string>
    <string name="su_deny_toast">%1$s-ന് സൂപ്പർയൂസർ അവകാശം നിഷേധിച്ചു </string>
    <string name="su_snack_grant">%1$s-ന്റെ സൂപ്പർയൂസർ അവകാശം അനുവദിച്ചിരിക്കുന്നു </string>
    <string name="su_snack_deny">1$s-ന്റെ സൂപ്പർയൂസർ അവകാശം നിഷേധിക്കപ്പെട്ടിരിക്കുന്നു</string>
    <string name="su_snack_notif_on">%1$s-ന്റെ അറിയിപ്പുകൾ പ്രവർത്തനക്ഷമമാക്കി</string>
    <string name="su_snack_notif_off">%1$s-ന്റെ അറിയിപ്പുകൾ പ്രവർത്തനരഹിതമാക്കി</string>
    <string name="su_snack_log_on">%1$s-ന്റെ ലോഗിംഗ് പ്രവർത്തനക്ഷമമാക്കി</string>
    <string name="su_snack_log_off">%1$s-ന്റെ ലോഗിംഗ് പ്രവർത്തനരഹിതമാക്കി</string>
    <string name="su_revoke_title">പിൻവലിക്കണോ?</string>
    <string name="su_revoke_msg">%1$s-ന്റെ സൂപ്പർയൂസർ അവകാശം അസാധുവാക്കാൻ സ്ഥിരീകരിക്കുക</string>
    <string name="toast">ടോസ്റ്റ്</string>
    <string name="none">ഒന്നുമില്</string>

    <string name="superuser_toggle_notification">അറിയിപ്പുകൾ</string>
    <string name="superuser_toggle_revoke">പിന്‍വലിക്കുക</string>
    <string name="superuser_policy_none">ആപ്പുകളൊന്നും ഇതുവരെ സൂപ്പർയൂസർ അനുമതി ചോദിച്ചിട്ടില്ല.</string>

    <!--Logs-->
    <string name="log_data_none">നിങ്ങൾക്ക് ലോഗുകൾ ഒന്നുമില്ലലോ, റൂട്ട് ആപ്പുകൾ കൂടുതൽ ഉപയോഗിക്കൂ</string>
    <string name="log_data_magisk_none">മജിസ്‌ക് ലോഗുകൾ കാലിയാണ്, \nഎവിടെയോ എന്തോ ഒരു തകരാറു പോലെ</string>
    <string name="menuSaveLog">ലോഗ് സേവ് ചെയ്യുക</string>
    <string name="menuClearLog">ലോഗ് മായ്‌ക്കുക</string>
    <string name="logs_cleared">ലോഗ് മായ്ച്ചു</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">ടാർഗെറ്റ് UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">സിസ്റ്റം ആപ്പുകൾ കാണിക്കുക</string>
    <string name="show_os_app">OS ആപ്പുകൾ കാണിക്കുക</string>
    <string name="hide_filter_hint">പേര് പ്രകാരം ഫിൽട്ടർ ചെയ്യുക</string>
    <string name="hide_search">തിരയുക</string>

    <!--Module-->
    <string name="no_info_provided">(വിവരങ്ങളൊന്നും നൽകിയിട്ടില്ല)</string>
    <string name="reboot_userspace">സോഫ്റ്റ് റീബൂട്ട്</string>
    <string name="reboot_recovery">റിക്കവറിയിലേക്ക് റീബൂട്ട് ചെയ്യുക</string>
    <string name="reboot_bootloader">ബൂട്ട്ലോഡറിലേക്ക് റീബൂട്ട് ചെയ്യുക</string>
    <string name="reboot_download">ഡൗൺലോഡ് മോഡിലേക്ക് റീബൂട്ട് ചെയ്യുക</string>
    <string name="reboot_edl">EDL-ലേക്ക് റീബൂട്ട് ചെയ്യുക</string>
    <string name="module_version_author">%1$s നിർമ്മിച്ചത് %2$s</string>
    <string name="module_state_remove">നീക്കുക</string>
    <string name="module_state_restore">പുനഃസ്ഥാപിക്കുക</string>
    <string name="module_action_install_external">സ്റ്റോറേജിൽ നിന്ന് ഇൻസ്റ്റാൾ ചെയ്യുക</string>
    <string name="update_available">അപ്ഡേറ്റ് ലഭ്യമാണ്</string>
    <string name="suspend_text_riru">%1$s പ്രവർത്തനക്ഷമമാക്കിയതിനാൽ മൊഡ്യൂൾ താൽക്കാലികമായി നിർത്തി</string>
    <string name="suspend_text_zygisk">%1$s പ്രവർത്തനക്ഷമമാക്കാത്തതിനാൽ മൊഡ്യൂൾ താൽക്കാലികമായി നിർത്തി</string>
    <string name="zygisk_module_unloaded">പൊരുത്തക്കേട് കാരണം Zygisk മൊഡ്യൂൾ ലോഡ് ചെയ്തിട്ടില്ല</string>
    <string name="module_empty">മൊഡ്യൂൾ ഇൻസ്റ്റാൾ ചെയ്തിട്ടില്ല</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">തീം മോഡ്</string>
    <string name="settings_dark_mode_message">നിങ്ങളുടെ ശൈലിക്ക് ഏറ്റവും അനുയോജ്യമായ മോഡ് തിരഞ്ഞെടുക്കുക!</string>
    <string name="settings_dark_mode_light">എപ്പോഴും ലൈറ്റ്</string>
    <string name="settings_dark_mode_system">സിസ്റ്റം തീം</string>
    <string name="settings_dark_mode_dark">എപ്പോഴും ഡാർക്ക്</string>
    <string name="settings_download_path_title">ഡൗൺലോഡ് സ്ഥലം</string>
    <string name="settings_download_path_message">ഫയലുകൾ %1$s-ലേക്ക് സേവ് ചെയ്യപ്പെടും</string>
    <string name="settings_hide_app_title">മജിസ്‌ക് ആപ്പ് മറയ്ക്കുക</string>
    <string name="settings_hide_app_summary">ക്രമരഹിതമായ പാക്കേജ് ഐഡിയും ഇഷ്‌ടാനുസൃത ആപ്പ് ലേബലും ഉള്ള ഒരു പ്രോക്‌സി ആപ്പ് ഇൻസ്‌റ്റാൾ ചെയ്യുക</string>
    <string name="settings_restore_app_title">മജിസ്‌ക് ആപ്പ് പുനഃസ്ഥാപിക്കുക</string>
    <string name="settings_restore_app_summary">ആപ്പ് മറച്ചത് മാറ്റി യഥാർത്ഥ APK പുനഃസ്ഥാപിക്കുക</string>
    <string name="language">ഭാഷ</string>
    <string name="system_default">(സിസ്റ്റം ക്രമാനുസാരം)</string>
    <string name="settings_check_update_title">അപ്ഡേറ്റുകൾക്കായി നോക്കുക</string>
    <string name="settings_check_update_summary">പശ്ചാത്തലത്തിൽ അപ്ഡേറ്റുകൾക്കായി ഇടയ്ക്കിടെ പരിശോധിക്കുക</string>
    <string name="settings_update_channel_title">അപ്ഡേറ്റിനുള്ള ചാനൽ</string>
    <string name="settings_update_stable">സ്റ്റേബിൾ</string>
    <string name="settings_update_beta">ബീറ്റ</string>
    <string name="settings_update_custom">കസ്റ്റം</string>
    <string name="settings_update_custom_msg">കസ്റ്റം ചാനലിന്റെ URL ചേർക്കുക</string>
    <string name="settings_zygisk_summary">സൈഗോട്ട് ഡെമണിൽ മജിസ്കിന്റെ ഭാഗങ്ങൾ പ്രവർത്തിപ്പിക്കുക</string>
    <string name="settings_denylist_title">നിഷിദ്ധ പട്ടിക പ്രാബല്യത്തിലാകുക</string>
    <string name="settings_denylist_summary">നിഷിദ്ധ പട്ടികയിലെ പ്രോസസ്സുകൾക്കായി എല്ലാ മജിസ്‌ക് പരിഷ്‌ക്കരണങ്ങളും പഴയപടിയാക്കും</string>
    <string name="settings_denylist_config_title">നിഷിദ്ധ പട്ടിക കോൺഫിഗർ ചെയ്യുക</string>
    <string name="settings_denylist_config_summary">നിഷിദ്ധ പട്ടികയിൽ ഉൾപ്പെടുത്തേണ്ട പ്രോസസ്സുകൾ തിരഞ്ഞെടുക്കുക</string>
    <string name="settings_hosts_title">സിസ്റ്റംലെസ്സ് ഹോസ്റ്റ്</string>
    <string name="settings_hosts_summary">പരസ്യം തടയുന്ന ആപ്പുകൾക്കായി സിസ്റ്റംലെസ്സ് ഹോസ്റ്റ്</string>
    <string name="settings_hosts_toast">സിസ്റ്റംലെസ്സ് ഹോസ്റ്റ് മൊഡ്യൂൾ ചേർത്തു</string>
    <string name="settings_app_name_hint">പുതിയ പേര്</string>
    <string name="settings_app_name_helper">ആപ്പ് ഈ പേരിൽ വീണ്ടും പാക്ക് ചെയ്യും</string>
    <string name="settings_app_name_error">അസാധുവായ ഫോർമാറ്റ്</string>
    <string name="settings_su_app_adb">ആപ്പുകളും ADB</string>
    <string name="settings_su_app">ആപ്പുകൾ മാത്രം</string>
    <string name="settings_su_adb">ADB മാത്രം</string>
    <string name="settings_su_disable">അപ്രാപ്തമാക്കി</string>
    <string name="settings_su_request_10">10 സെക്കന്റുകൾ</string>
    <string name="settings_su_request_15">15 സെക്കന്റുകൾ</string>
    <string name="settings_su_request_20">20 സെക്കന്റുകൾ</string>
    <string name="settings_su_request_30">30 സെക്കന്റുകൾ</string>
    <string name="settings_su_request_45">45 സെക്കന്റുകൾ</string>
    <string name="settings_su_request_60">60 സെക്കന്റുകൾ</string>
    <string name="superuser_access">സൂപ്പർയൂസർ ആക്സസ്</string>
    <string name="auto_response">സ്വയമേവ പ്രതികരണം</string>
    <string name="request_timeout">അഭ്യർത്ഥന സമയപരിധി</string>
    <string name="superuser_notification">സൂപ്പർയൂസർ അറിയിപ്പ്</string>
    <string name="settings_su_reauth_title">അപ്‌ഗ്രേഡിന് ശേഷം വീണ്ടും പ്രാമാണീകരിക്കുക</string>
    <string name="settings_su_reauth_summary">ആപ്പുകൾ അപ്‌ഗ്രേഡ് ചെയ്‌തതിന് ശേഷം സൂപ്പർയൂസർ അനുമതികൾക്കായി വീണ്ടും ആവശ്യപ്പെടുക</string>
    <string name="settings_su_tapjack_title">ടാപ്പ്ജാക്കിംഗ് സംരക്ഷണം</string>
    <string name="settings_su_tapjack_summary">സൂപ്പർയൂസർ പ്രോംപ്റ്റ് ഡയലോഗ് മറ്റേതെങ്കിലും വിൻഡോയോ ഓവർലേയോ മറയ്ക്കുമ്പോൾ ഇൻപുട്ടിനോട് പ്രതികരിക്കില്</string>
    <string name="settings_customization">കസ്റ്റമയിസേഷൻ</string>
    <string name="setting_add_shortcut_summary">ആപ്പ് മറച്ചതിന് ശേഷം പേരും ഐക്കണും തിരിച്ചറിയാൻ പ്രയാസമാണെങ്കിൽ ഹോം സ്‌ക്രീനിലേക്ക് മനോഹരമായ ഒരു ഷോർട്ട്ക്കട് ചേർക്കുക</string>
    <string name="settings_doh_title">DNS ഓവർ HTTPS</string>
    <string name="settings_doh_description">ചില രാജ്യങ്ങളിലെ DNS പോയ്സണിങിന് പരിഹാരം</string>

    <string name="multiuser_mode">മൾട്ടിയൂസർ മോഡ്</string>
    <string name="settings_owner_only">ഉപകരണ ഉടമ മാത്രം</string>
    <string name="settings_owner_manage">ഉപകരണ ഉടമ നിയന്ത്രിക്കുന്നു</string>
    <string name="settings_user_independent">ഉപയോക്താവിനെ ആശ്രയിക്കുന്നില്</string>
    <string name="owner_only_summary">ഉടമയ്ക്ക് മാത്രമേ റൂട്ട് ആക്സസ് ഉള്ളൂ</string>
    <string name="owner_manage_summary">റൂട്ട് ആക്‌സസ് നിയന്ത്രിക്കാനും അഭ്യർത്ഥന നിർദ്ദേശങ്ങൾ സ്വീകരിക്കാനും ഉടമയ്ക്ക് മാത്രമേ കഴിയൂ</string>
    <string name="user_independent_summary">ഓരോ ഉപയോക്താവിനും അവരുടേതായ പ്രത്യേക റൂട്ട് നിയമങ്ങൾ ഉണ്ടാവാം</string>

    <string name="mount_namespace_mode">മൗണ്ട് നെയിംസ്പേസ് മോഡ്</string>
    <string name="settings_ns_global">ഗ്ലോബൽ നെയിംസ്പേസ്</string>
    <string name="settings_ns_requester">പൂര്‍വ്വാര്‍ജ്ജിതമായ് നെയിംസ്പേസ്</string>
    <string name="settings_ns_isolate">ഒറ്റപ്പെട് നെയിംസ്പേസ്</string>
    <string name="global_summary">എല്ലാ റൂട്ട് സെഷനുകളും ഗ്ലോബൽ മൗണ്ട് നെയിംസ്പേസ് ഉപയോഗിക്കും</string>
    <string name="requester_summary">റൂട്ട് സെഷനുകൾ അവരുടെ അഭ്യർത്ഥനയുടെ നെയിംസ്പേസ് ഉപയോഗിക്കും</string>
    <string name="isolate_summary">ഓരോ റൂട്ട് സെഷനും അതിന്റേതായ ഒറ്റപ്പെട്ട നെയിംസ്പേസ് ഉണ്ടായിരിക്കും</string>

    <!--Notifications-->
    <string name="update_channel">മജിസ്‌ക് അപ്‌ഡേറ്റുകൾ</string>
    <string name="progress_channel">പുരോഗതി അറിയിപ്പുകൾ</string>
    <string name="updated_channel">അപ്‌ഡേറ്റ് പൂർത്തിയായി</string>
    <string name="download_complete">ഡൗൺലോഡ് പൂർത്തിയായി</string>
    <string name="download_file_error">ഫയൽ ഡൗൺലോഡ് ചെയ്യുന്നതിൽ പിശക്</string>
    <string name="magisk_update_title">മജിസ്‌ക് അപ്‌ഡേറ്റ് ലഭ്യമാണ്!</string>
    <string name="updated_title">മജിസ്‌ക് അപ്ഡേറ്റ് ചെയ്തു</string>
    <string name="updated_text">ആപ്പ് തുറക്കാൻ ടാപ്പ് ചെയ്യുക</string>

    <!--Toasts, Dialogs-->
    <string name="yes">അതെ</string>
    <string name="no">ഇല്ല</string>
    <string name="repo_install_title">%1$s %2$s(%3$d) ഇൻസ്റ്റാൾ ചെയ്യുക</string>
    <string name="download">ഡൗൺലോഡ്</string>
    <string name="reboot">റീബൂട്ട്</string>
    <string name="release_notes">റിലീസ് നോട്ടുകൾ</string>
    <string name="flashing">ഫ്ലാഷ് ചെയ്യുന്നു...</string>
    <string name="done">ചെയ്തു!</string>
    <string name="failure">പരാജയപ്പെട്ടു!</string>
    <string name="hide_app_title">മജിസ്‌ക് ആപ്പ് മറയ്ക്കുന്നു...</string>
    <string name="open_link_failed_toast">ലിങ്ക് തുറക്കാൻ ആപ്പൊന്നും കണ്ടെത്തിയില്ല</string>
    <string name="complete_uninstall">പൂർണ്ണമായും അൺഇൻസ്റ്റാൾ ചെയ്യുക</string>
    <string name="restore_img">ഇമേജുകൾ റിസ്റ്റോർ ചെയ്യുക</string>
    <string name="restore_img_msg">റിസ്റ്റോർ ചെയ്യുന്നു…</string>
    <string name="restore_done">റിസ്റ്റോർ ചെയ്തു!</string>
    <string name="restore_fail">സ്റ്റോക്ക് ബാക്കപ്പ് നിലവിലില്ല!</string>
    <string name="setup_fail">സെറ്റപ്പ് പരാജയപ്പെട്ടു</string>
    <string name="env_fix_title">കൂടുതൽ സജ്ജീകരണം ആവശ്യമാണ്</string>
    <string name="env_fix_msg">മജിസ്‌ക് ശരിയായി പ്രവർത്തിക്കാൻ നിങ്ങളുടെ ഉപകരണത്തിന് കൂടുതൽ സജ്ജീകരണം ആവശ്യമാണ്. നിങ്ങൾക്ക് തുടരാനും റീബൂട്ട് ചെയ്യാനും താൽപ്പര്യമുണ്ടോ?</string>
    <string name="setup_msg">ഇൻവൈറൻമൻറ്റ് സജ്ജീകരണം പ്രവർത്തിക്കുന്നു...</string>
    <string name="unsupport_magisk_title">പിന്തുണയ്ക്കാത്ത മജിസ്‌ക് പതിപ്പ്</string>
    <string name="unsupport_magisk_msg">ആപ്പിന്റെ ഈ പതിപ്പ് %1$s-ൽ താഴെയുള്ള മജിസ്‌ക് പതിപ്പുകളെ പിന്തുണയ്‌ക്കുന്നില്ല.\n\nമജിസ്‌ക് ഇൻസ്റ്റാൾ ചെയ്തിട്ടില്ലെന്ന മട്ടിൽ ആപ്പ് പ്രവർത്തിക്കും, ദയവായി മജിസ്‌ക് എത്രയും വേഗം അപ്‌ഗ്രേഡ് ചെയ്യുക.</string>
    <string name="unsupport_general_title">അസാധാരണമായ നില</string>
    <string name="unsupport_system_app_msg">ഒരു സിസ്റ്റം ആപ്പായി ഈ ആപ്പ് പ്രവർത്തിപ്പിക്കുന്നത് സാധ്യമല്ല. ഒരു യൂസർ ആപ്പിലേക്ക് ആപ്പ് പുനഃസ്ഥാപിക്കുക.</string>
    <string name="unsupport_other_su_msg">മജിസ്‌ക്-ൽ നിന്ന് അല്ലാത്ത ഒരു \"su\" ബൈനറി കണ്ടെത്തി. അധിക റൂട്ട് സൊല്യൂഷൻ നീക്കം ചെയ്യുക കൂടാതെ/അല്ലെങ്കിൽ മാജിസ്ക് വീണ്ടും ഇൻസ്റ്റാൾ ചെയ്യുക.</string>
    <string name="unsupport_external_storage_msg">മജിസ്‌ക് ഇക്സ്റ്റർനൽ സ്റ്റോറേജിൽ ഇൻസ്റ്റാൾ ചെയ്തിരിക്കുകയാണ്. ആപ്പ് ഇൻറ്റർനൽ സ്റ്റോറേജിലെക് നീക്കുക.</string>
    <string name="unsupport_nonroot_stub_msg">റൂട്ട് നഷ്‌ടമായതിനാൽ മറഞ്ഞിരിക്കുന്ന മജിസ്‌ക് ആപ്പിന് തുടർന്നും പ്രവർത്തിക്കാനാകില്ല. യഥാർത്ഥ APK പുനഃസ്ഥാപിക്കുക.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">ഈ പ്രവർത്തനം പ്രവർത്തനക്ഷമമാക്കാൻ സ്റ്റോറജ് ​​അനുമതി നൽകുക</string>
    <string name="post_notifications_denied">ഈ പ്രവർത്തനം പ്രവർത്തനക്ഷമമാക്കാൻ അറിയിപ്പ്‌ അനുമതി നൽകുക</string>
    <string name="install_unknown_denied">ഈ പ്രവർത്തനം പ്രവർത്തനക്ഷമമാക്കാൻ "install unknown apps" അനുവദിക്കുക</string>
    <string name="add_shortcut_title">ഹോം സ്ക്രീനിലേക്ക് ഷോർട്ട്കട്ട് ചേർക്കുക</string>
    <string name="add_shortcut_msg">ഈ ആപ്പ് മറച്ചതിന് ശേഷം, അതിന്റെ പേരും ഐക്കണും തിരിച്ചറിയാൻ ബുദ്ധിമുട്ടായേക്കാം. ഹോം സ്‌ക്രീനിലേക്ക് മനോഹരമായ ഒരു ഷോർറ്റ്കറ്റ ചേർക്കാൻ നിങ്ങൾ ആഗ്രഹിക്കുന്നുണ്ടോ?</string>
    <string name="app_not_found">ഈ പ്രവർത്തനം കൈകാര്യം ചെയ്യാൻ ഒരു ആപ്പും കണ്ടെത്തിയില്ല</string>
    <string name="reboot_apply_change">മാറ്റങ്ങൾ പ്രയോഗിക്കാൻ റീബൂട്ട് ചെയ്യുക</string>
    <string name="restore_app_confirmation">ഇത് മറച്ച ആപ്പിനെ യഥാർത്ഥ ആപ്പിലേക്ക് തിരികെ കൊണ്ടുവരും. നിങ്ങൾ ശരിക്കും ഇത് ചെയ്യാൻ ആഗ്രഹിക്കുന്നുണ്ടോ?</string>

</resources>

```

`app/core/src/main/res/values-nb/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Moduler</string>
    <string name="superuser">Superbruker</string>
    <string name="logs">Logg</string>
    <string name="settings">Innstillinger</string>
    <string name="install">Install</string>
    <string name="section_home">Hjem</string>
    <string name="section_theme">Drakter</string>

    <!--Home-->
    <string name="no_connection">Mangler tilkobling</string>
    <string name="app_changelog">Endringslogg</string>
    <string name="loading">Laster inn…</string>
    <string name="update">Oppgrader</string>
    <string name="not_available">I/T</string>
    <string name="hide">Skjul</string>
    <string name="home_package">Pakke</string>
    <string name="home_app_title">Program</string>

    <string name="home_notice_content">Kun last ned Magisk fra den offisielle GitHub siden. Filer fra ukjente kilder kan være skadelige!</string>
    <string name="home_support_title">Kronerulling</string>
    <string name="home_item_source">Kildekode</string>
    <string name="home_support_content">Magisk er og vil alltid forbli fritt.\nDu kan vise at du setter pris på programmet ved å sende en slant.</string>
    <string name="home_installed_version">Installert</string>
    <string name="home_latest_version">Seneste</string>
    <string name="invalid_update_channel">Ugyldig installasjonskanal</string>
    <string name="uninstall_magisk_title">Avinstaller Magisk</string>
    <string name="uninstall_magisk_msg">Alle moduler vil bli avskrudd/fjernet.\nRot-tigang vil bli fjernet!\nKrypter din data hvis den ikke er det allerede.</string>

    <!--Install-->
    <string name="keep_force_encryption">Bevar påvunget kryptering</string>
    <string name="keep_dm_verity">Bevar AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Gjenopprettingsmodus</string>
    <string name="install_options_title">Innstillinger</string>
    <string name="install_method_title">Metode</string>
    <string name="install_next">Neste</string>
    <string name="install_start">Start</string>
    <string name="manager_download_install">Trykk for å laste ned og installere</string>
    <string name="direct_install">Direkte installasjon (anbefalt)</string>
    <string name="install_inactive_slot">Installer til inaktiv plass (etter OTA)</string>
    <string name="install_inactive_slot_msg">Din enhet vil bli tvunget til å starte opp i inaktiv plass etter omstart!\nKun bruk dette etter at OTA er ferdig.\Fortsett?</string>
    <string name="setup_title">Ytterligere oppsett</string>
    <string name="select_patch_file">Velg og utfør programfiks av en fil</string>
    <string name="patch_file_msg">Velg et rå-avtrykk (*.img) eller en ODIN-tjæreballfil (*.tar)</string>
    <string name="reboot_delay_toast">Starter på ny om 5 sek …</string>
    <string name="flash_screen_title">Installasjon</string>

    <!--Superuser-->
    <string name="su_request_title">Superbrukerforespørsel</string>
    <string name="touch_filtered_warning">Fordi et program tilslører en superbrukerforespørsel kan ikke Magisk bekrefte</string>
    <string name="deny">Avslå</string>
    <string name="prompt">Spør</string>
    <string name="grant">Innvilg</string>
    <string name="su_warning">Gir full tilgang til enheten din.\nAvslå hvis du ikke er sikker!</string>
    <string name="forever">Permanent</string>
    <string name="once">Én gang</string>
    <string name="tenmin">10 min</string>
    <string name="twentymin">20 min</string>
    <string name="thirtymin">30 min</string>
    <string name="sixtymin">60 min</string>
    <string name="su_allow_toast">%1$s ble innvilget superbruker-rettigheter</string>
    <string name="su_deny_toast">%1$s ble nektet superbruker-rettigheter</string>
    <string name="su_snack_grant">Superbruker-rettigheter for %1$s ble innvilget</string>
    <string name="su_snack_deny">Superbruker-rettigheter for %1$s ble nektet</string>
    <string name="su_snack_notif_on">Merknader for %1$s er påskrudd</string>
    <string name="su_snack_notif_off">Merknader for %1$s er avskrudd</string>
    <string name="su_snack_log_on">Logging av %1$s er påskrudd</string>
    <string name="su_snack_log_off">Logging av %1$s er avskrudd</string>
    <string name="su_revoke_title">Trekk tilbake?</string>
    <string name="su_revoke_msg">Bekreft tilbaketrekking av %1$s-rettigheter?</string>
    <string name="toast">Oppsprettsmerknad</string>
    <string name="none">Ingen</string>

    <string name="superuser_toggle_notification">Merknader</string>
    <string name="superuser_toggle_revoke">Tilbakekall</string>
    <string name="superuser_policy_none">Ingen programmer har forespurt superbrukertilgang enda.</string>

    <!--Logs-->
    <string name="log_data_none">Ingen loggføring. Prøv å bruke superbrukerprogrammene dine oftere.</string>
    <string name="log_data_magisk_none">Magisk-loggene er tomme, det er rart</string>
    <string name="menuSaveLog">Lagre logg</string>
    <string name="menuClearLog">Tøm logg nå</string>
    <string name="logs_cleared">Loggføring tømt</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Mål-UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Vis systemprogrammer</string>
    <string name="show_os_app">Vis systemprogrammer</string>
    <string name="hide_filter_hint">Filtrer etter navn</string>
    <string name="hide_search">Søk</string>

    <!--Module-->
    <string name="no_info_provided">(Ingen info angitt)</string>
    <string name="reboot_userspace">Myk omstart</string>
    <string name="reboot_recovery">Omstart til gjenoppretting</string>
    <string name="reboot_bootloader">Omstart til oppstartslaster</string>
    <string name="reboot_download">Omstart til nedlasting</string>
    <string name="reboot_edl">Omstart til EDL</string>
    <string name="module_version_author">%1$s av %2$s</string>
    <string name="module_state_remove">Fjern</string>
    <string name="module_state_restore">Gjenopprett</string>
    <string name="module_action_install_external">Installer fra lagring</string>
    <string name="update_available">Oppgradering tilgjengelig</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Draktmodus</string>
    <string name="settings_dark_mode_message">Velg det snittet som kler deg best.</string>
    <string name="settings_dark_mode_light">Alltid lys</string>
    <string name="settings_dark_mode_system">Følg systemet</string>
    <string name="settings_dark_mode_dark">Alltid mørk</string>
    <string name="settings_download_path_title">Nedlastingssti</string>
    <string name="settings_download_path_message">Filer vil lagres i %1$s</string>
    <string name="settings_hide_app_title">Skjul Magisk-programmet</string>
    <string name="settings_hide_app_summary">Installer et mellomtjenerprogram med tilfeldig pakke-ID og egendefinert program-etikett</string>
    <string name="settings_restore_app_title">Gjenopprett Magisk-programmet</string>
    <string name="settings_restore_app_summary">Opphev skjuling av programmet og gjenopprett det tilbake til opprinnelig APK</string>
    <string name="language">Språk</string>
    <string name="system_default">(Systemforvalg)</string>
    <string name="settings_check_update_title">Finn nye versjoner</string>
    <string name="settings_check_update_summary">Periodisk søken etter nye oppgraderinger i bakgrunnen</string>
    <string name="settings_update_channel_title">Oppgraderingskanal</string>
    <string name="settings_update_stable">Stabil</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Egendefinert kanal</string>
    <string name="settings_update_custom_msg">Sett inn en egendefinert nettadresse</string>
    <string name="settings_hosts_title">Systemløs vertsfil</string>
    <string name="settings_hosts_summary">Systemløs vertsfilstøtte for reklameblokkeringsprogrammer</string>
    <string name="settings_hosts_toast">La til modul for systemløs vertsfil</string>
    <string name="settings_app_name_hint">Nytt navn</string>
    <string name="settings_app_name_helper">Programmet vil bli ompakket til dette navnet</string>
    <string name="settings_app_name_error">Ugyldig format</string>
    <string name="settings_su_app_adb">Programmer og ADB</string>
    <string name="settings_su_app">Kun programmer</string>
    <string name="settings_su_adb">Kun ADB</string>
    <string name="settings_su_disable">Avskrudd</string>
    <string name="settings_su_request_10">10 sekunder</string>
    <string name="settings_su_request_15">15 sekunder</string>
    <string name="settings_su_request_20">20 sekunder</string>
    <string name="settings_su_request_30">30 sekunder</string>
    <string name="settings_su_request_45">45 sekunder</string>
    <string name="settings_su_request_60">60 sekunder</string>
    <string name="superuser_access">Superbruker-tilgang</string>
    <string name="auto_response">Automatisk svar</string>
    <string name="request_timeout">Tidsavbrudd for forespørsel</string>
    <string name="superuser_notification">Superbruker-merknad</string>
    <string name="settings_su_reauth_title">Ny identitetsbekreftelse etter oppgradering</string>
    <string name="settings_su_reauth_summary">Identitetsbekreft superbrukertilganger etter programoppgraderinger</string>
    <string name="settings_su_tapjack_title">Trykkstjelingsbeskyttelse</string>
    <string name="settings_su_tapjack_summary">Superbrukings-forespørselsdialogen vil ikke svare på inndata mens den dekkes av et annet vindu eller lag</string>
    <string name="settings_customization">Tilpasning</string>
    <string name="setting_add_shortcut_summary">Legg til fin snarvei på hjemmeskjermen i fall navnet og ikonet er vanskelig å gjenkjenne etter skjuling av programmet</string>
    <string name="settings_doh_title">DNS over HTTPS</string>
    <string name="settings_doh_description">Unngåelse av DNS-forgiftelse i noen land</string>

    <string name="multiuser_mode">Multibrukermodus</string>
    <string name="settings_owner_only">Kun for enhetseier</string>
    <string name="settings_owner_manage">Enhetseier, håndtert</string>
    <string name="settings_user_independent">Brukeruavhengig</string>
    <string name="owner_only_summary">Rot-tilgang kun for eier</string>
    <string name="owner_manage_summary">Kun eier kan håndtere rot-tilgang og motta forespørsler</string>
    <string name="user_independent_summary">Hver bruker har egne rot-regler</string>

    <string name="mount_namespace_mode">Modus for montering av navnerom</string>
    <string name="settings_ns_global">Omspennede navnerom</string>
    <string name="settings_ns_requester">Nedarv navnerom</string>
    <string name="settings_ns_isolate">Isolert navnerom</string>
    <string name="global_summary">Alle rot-økter bruker det omspennende monteringsnavnerommet</string>
    <string name="requester_summary">Rot-økter nedarver forespørrers navnerom</string>
    <string name="isolate_summary">Hver rot-økt får eget isolert navnerom</string>

    <!--Notifications-->
    <string name="update_channel">Magisk-oppgraderinger</string>
    <string name="progress_channel">Framdriftsmerknader</string>
    <string name="download_complete">Nedlasting fullført</string>
    <string name="download_file_error">Kunne ikke laste ned fil</string>
    <string name="magisk_update_title">Ny versjon av Magisk tilgjengelig.</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Ja</string>
    <string name="no">Nei</string>
    <string name="repo_install_title">Installer %1$s %2$s(%3$d)</string>
    <string name="download">Last ned</string>
    <string name="reboot">Omstart</string>
    <string name="release_notes">Utgivelsesnotater</string>
    <string name="flashing">Innbrenner …</string>
    <string name="done">Ferdig!</string>
    <string name="failure">Mislykket!</string>
    <string name="hide_app_title">Skjuler Magisk-programmet …</string>
    <string name="open_link_failed_toast">Ingen programmer kunne åpne lenken</string>
    <string name="complete_uninstall">Fullfør avinstallasjon</string>
    <string name="restore_img">Gjenopprett avtrykk</string>
    <string name="restore_img_msg">Gjenoppretter …</string>
    <string name="restore_done">Gjenoppretting fullført.</string>
    <string name="restore_fail">Fabrikk-sikkerhetskopi finnes ikke!</string>
    <string name="setup_fail">Oppsett mislyktes</string>
    <string name="env_fix_title">Krever ytterligere oppsett</string>
    <string name="env_fix_msg">Enheten din krever ytterligere oppsett for at Magisk skal fungere rett. Fortsett med omstart?</string>
    <string name="setup_msg">Kjører oppsett av miljø…</string>
    <string name="unsupport_magisk_title">Ustøttet Magisk-versjon</string>
    <string name="unsupport_magisk_msg">Denne versjonen av programmet støtter ikke Magisk før versjon %1$s.\n\nProgrammet vil oppføre seg som om Magisk ikke er installert. Oppgrader Magisk så snart som mulig.</string>
    <string name="unsupport_general_title">Unormal tilstand</string>
    <string name="unsupport_system_app_msg">Kjøring av dette programmet som systemprogram støttes ikke. Gjør om programmet til et brukerprogram igjen.</string>
    <string name="unsupport_other_su_msg">En \"su\"-kommando som ikke tilhører Magisk ble oppdaget. Fjern dette andre ustøttede opphavet.</string>
    <string name="unsupport_external_storage_msg">Magisk er installert på eksternlagring. Flytt det til internlagring.</string>
    <string name="unsupport_nonroot_stub_msg">Programmet kan ikke fortsette å fungere i skjult tilstand siden rot-tilgang gikk tapt. Gjenopprett det tilbake til opprinnelig APK.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Innvilg lagringstilgang for å skru på denne funksjonaliteten</string>
    <string name="add_shortcut_title">Legg til snarvei på hjemmeskjermen</string>
    <string name="add_shortcut_msg">Etter å ha skjult programmet kan det vli vanskelig å gjenkjenne navn og ikon. Legg til fin snarvei på hjemmeskjermen?</string>
    <string name="app_not_found">Ingen programmer kan håndtere denne forespørselen</string>

</resources>

```

`app/core/src/main/res/values-night/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="splash_background">#0D0D0D</color>
</resources>

```

`app/core/src/main/res/values-nl/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Modules</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Logboek</string>
    <string name="settings">Instellingen</string>
    <string name="install">Installeren</string>
    <string name="section_home">Overzicht</string>
    <string name="section_theme">Thema\'s</string>

    <!--Home-->
    <string name="no_connection">Geen internetverbinding</string>
    <string name="app_changelog">Wijzigingslog</string>
    <string name="loading">Bezig met laden…</string>
    <string name="update">Updaten</string>
    <string name="not_available">Niet beschikbaar</string>
    <string name="hide">Verbergen</string>
    <string name="home_package">Pakket</string>

    <string name="home_support_title">Ondersteun ons</string>
    <string name="home_item_source">Broncode</string>
    <string name="home_support_content">Magisk is en zal altijd gratis en open source blijven, maar als je wilt, kun je een kleine donatie doen.</string>
    <string name="home_installed_version">Geïnstalleerd</string>
    <string name="home_latest_version">Actueel</string>
    <string name="invalid_update_channel">Ongeldig updatekanaal</string>
    <string name="uninstall_magisk_title">Magisk deïnstalleren</string>
    <string name="uninstall_magisk_msg">Alle modules worden uitgeschakeld/verwijderd!\nRoot wordt verwijderd!\nJe gegevens worden, als ze dat nog niet waren, mogelijk versleuteld!</string>


    <!--Install-->
    <string name="keep_force_encryption">Afgedwongen versleuteling behouden</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity behouden</string>
    <string name="recovery_mode">Herstelmodus</string>
    <string name="install_options_title">Opties</string>
    <string name="install_method_title">Methode</string>
    <string name="install_next">Volgende</string>
    <string name="install_start">Aan de slag</string>
    <string name="manager_download_install">Druk om te downloaden en installeren</string>
    <string name="direct_install">Direct installeren (aanbevolen)</string>
    <string name="install_inactive_slot">Installeren in inactieve sleuf (na OTA)</string>
    <string name="install_inactive_slot_msg">Je apparaat wordt GEDWONGEN opgestart in de huidige inactieve sleuf na het herstarten!\nGebruik deze optie alleen NA het installeren van een OTA-update.\nWil je doorgaan?</string>
    <string name="setup_title">Installatie afronden</string>
    <string name="select_patch_file">Kies en patch een bestand</string>
    <string name="patch_file_msg">Kies een schijfkopie (*.img) of ODIN-tarbestand (*.tar)</string>
    <string name="reboot_delay_toast">Je apparaat wordt over 5 seconden herstart…</string>
    <string name="flash_screen_title">Installatie</string>

    <!--Superuser-->
    <string name="su_request_title">Superuserverzoek</string>
    <string name="deny">Weigeren</string>
    <string name="prompt">Vraag</string>
    <string name="grant">Toestaan</string>
    <string name="su_warning">Verleent volledige toegang tot je apparaat.\nBij twijfel, altijd weigeren!</string>
    <string name="forever">Permanent</string>
    <string name="once">Eenmalig</string>
    <string name="tenmin">10 min</string>
    <string name="twentymin">20 min</string>
    <string name="thirtymin">30 min</string>
    <string name="sixtymin">60 min</string>
    <string name="su_allow_toast">%1$s beschikt nu over superuserrechten</string>
    <string name="su_deny_toast">Superuserrecht van %1$s geweigerd</string>
    <string name="su_snack_grant">%1$s beschikt nu over superuserrechten</string>
    <string name="su_snack_deny">Superuserrecht van %1$s geweigerd</string>
    <string name="su_snack_notif_on">%1$s-meldingen ingeschakeld</string>
    <string name="su_snack_notif_off">%1$s-meldingen uitgeschakeld</string>
    <string name="su_snack_log_on">%1$s wordt nu gelogd</string>
    <string name="su_snack_log_off">%1$s wordt niet gelogd</string>
    <string name="su_revoke_title">Intrekken?</string>
    <string name="su_revoke_msg">Wil je de rechten van %1$s intrekken?</string>
    <string name="toast">Ballon</string>
    <string name="none">Geen</string>

    <string name="superuser_toggle_notification">Meldingen</string>
    <string name="superuser_toggle_revoke">Intrekken</string>
    <string name="superuser_policy_none">Er zijn nog geen superuserverzoeken geweest.</string>

    <!--Logs-->
    <string name="log_data_none">Er is nog niks gelogd. Gebruik meer apps met superuserrechten!</string>
    <string name="log_data_magisk_none">Het Magisk-logboek is leeg. Dit is ongebruikelijk.</string>
    <string name="menuSaveLog">Logboek opslaan</string>
    <string name="menuClearLog">Logboek wissen</string>
    <string name="logs_cleared">Het logboek is gewist.</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Doel-uid: %1$d</string>

    <!--SafetyNet-->

    <!-- MagiskHide -->
    <string name="show_system_app">Systeemapps tonen</string>
    <string name="hide_filter_hint">Filteren op naam</string>
    <string name="hide_search">Zoeken</string>

    <!--Module Fragment-->
    <string name="no_info_provided">(geen informatie verstrekt)</string>
    <string name="reboot_recovery">Recovery starten</string>
    <string name="reboot_bootloader">Bootloader starten</string>
    <string name="reboot_download">Downloadmodus starten</string>
    <string name="reboot_edl">EDL starten</string>
    <string name="module_version_author">%1$s van %2$s</string>
    <string name="module_state_remove">Verwijderen</string>
    <string name="module_state_restore">Herstellen</string>
    <string name="module_action_install_external">Gedownloade module installeren</string>
    <string name="update_available">Update beschikbaar</string>

    <!--Settings -->
    <string name="settings_dark_mode_title">Thema</string>
    <string name="settings_dark_mode_message">Kies het thema dat het best bij je past!</string>
    <string name="settings_dark_mode_light">Licht</string>
    <string name="settings_dark_mode_system">Systeemstandaard</string>
    <string name="settings_dark_mode_dark">Donker</string>
    <string name="settings_download_path_title">Downloadpad</string>
    <string name="settings_download_path_message">Bestanden worden opgeslagen in %1$s</string>
    <string name="language">Taal</string>
    <string name="system_default">(systeemstandaard)</string>
    <string name="settings_check_update_summary">Controleer automatisch op updates op de achtergrond.</string>
    <string name="settings_update_channel_title">Updatekanaal</string>
    <string name="settings_update_stable">Stabiel</string>
    <string name="settings_update_beta">Bèta</string>
    <string name="settings_update_custom">Aangepast</string>
    <string name="settings_update_custom_msg">Voer een aangepaste url in</string>
    <string name="settings_hosts_title">Systeemloze hosts</string>
    <string name="settings_hosts_summary">Systeemloze hosts-ondersteuning voor advertentieblokkeringsapps.</string>
    <string name="settings_hosts_toast">De systeemloze hosts-module is toegevoegd</string>
    <string name="settings_app_name_hint">Nieuwe naam</string>
    <string name="settings_app_name_helper">De app wordt opnieuw ingepakt onder deze naam</string>
    <string name="settings_app_name_error">Onjuiste opmaak</string>
    <string name="settings_su_app_adb">Apps en ADB</string>
    <string name="settings_su_app">Alleen apps</string>
    <string name="settings_su_adb">Alleen ADB</string>
    <string name="settings_su_disable">Uitgeschakeld</string>
    <string name="settings_su_request_10">10 seconden</string>
    <string name="settings_su_request_15">15 seconden</string>
    <string name="settings_su_request_20">20 seconden</string>
    <string name="settings_su_request_30">30 seconden</string>
    <string name="settings_su_request_45">45 seconden</string>
    <string name="settings_su_request_60">60 seconden</string>
    <string name="superuser_access">Superusertoegang</string>
    <string name="auto_response">Automatisch antwoord</string>
    <string name="request_timeout">Verzoektime-out</string>
    <string name="superuser_notification">Superusermelding</string>
    <string name="settings_su_reauth_title">Opnieuw goedkeuren na update</string>
    <string name="settings_su_reauth_summary">Superuserrechten opnieuw goedkeuren na app-updates.</string>
    <string name="settings_customization">Aanpassingen</string>

    <string name="multiuser_mode">Meerdere gebruikers</string>
    <string name="settings_owner_only">Alleen apparaateigenaar</string>
    <string name="settings_owner_manage">Beheerd door apparaateigenaar</string>
    <string name="settings_user_independent">Gebruikeronafhankelijk</string>
    <string name="owner_only_summary">Alleen de apparaateigenaar heeft roottoegang</string>
    <string name="owner_manage_summary">Alleen de eigenaar kan roottoegang goedkeuren en verzoeken ontvangen</string>
    <string name="user_independent_summary">Elke gebruiker heeft zijn/haar eigen rootregels</string>

    <string name="mount_namespace_mode">Naamruimtemodus aankoppelen</string>
    <string name="settings_ns_global">Globale naamruimte</string>
    <string name="settings_ns_requester">Naamruimte overnemen</string>
    <string name="settings_ns_isolate">Geïsoleerde naamruimte</string>
    <string name="global_summary">Alle rootsessies gebruiken de globale naamruimte</string>
    <string name="requester_summary">Rootsessies gebruiken de naamruimte van de verzoeker</string>
    <string name="isolate_summary">Elke rootsessie heeft zijn eigen geïsoleerde naamruimte</string>

    <!--Notifications-->
    <string name="update_channel">Magisk-updates</string>
    <string name="progress_channel">Voortgangsmeldingen</string>
    <string name="download_complete">Downloaden voltooid</string>
    <string name="download_file_error">Het bestand kan niet worden gedownload</string>
    <string name="magisk_update_title">Er is een Magisk-update beschikbaar!</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Ja</string>
    <string name="no">Nee</string>
    <string name="repo_install_title">%1$s installeren %2$s(%3$d)</string>
    <string name="download">Downloaden</string>
    <string name="reboot">Herstarten</string>
    <string name="release_notes">Wijzigingslog</string>
    <string name="flashing">Bezig met flashen…</string>
    <string name="done">Voltooid!</string>
    <string name="failure">Mislukt</string>
    <string name="open_link_failed_toast">Er is geen app op je apparaat die deze link kan openen</string>
    <string name="complete_uninstall">Volledig deïnstalleren</string>
    <string name="restore_img">Schijfkopieën herstellen</string>
    <string name="restore_img_msg">Bezig met herstellen…</string>
    <string name="restore_done">Herstellen voltooid!</string>
    <string name="restore_fail">Er is geen back-up beschikbaar.</string>
    <string name="setup_fail">Installatie mislukt</string>
    <string name="env_fix_title">Installatie nog niet afgerond</string>
    <string name="setup_msg">Bezig met toepassen van omgevingsinstellingen…</string>
    <string name="unsupport_magisk_title">Niet-ondersteunde Magisk-versie</string>
    <string name="external_rw_permission_denied">Verleen het opslagrecht om deze functie gebruiken</string>
    <string name="add_shortcut_title">Snelkoppeling maken op startscherm</string>
    <string name="app_not_found">Er is geen app op je apparaat die deze handeling kan uitvoeren</string>

</resources>

```

`app/core/src/main/res/values-pa/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">ਮੋਡੀਊਲ</string>
    <string name="superuser">ਸੁਪਰਯੂਜ਼ਰ</string>
    <string name="logs">ਲੋਗਜ਼</string>
    <string name="settings">ਸੈਟਿੰਗਜ਼</string>
    <string name="install">ਇੰਸਟਾਲ</string>
    <string name="section_home">ਹੋਮ</string>
    <string name="section_theme">ਥੀਮ</string>

    <!--Home-->
    <string name="no_connection">ਕੋਈ ਸੰਪਰਕ ਉਪਲਬਧ ਨਹੀਂ ਹੈ</string>
    <string name="app_changelog">ਬਦਲਾਓ</string>
    <string name="loading">ਲੋਡ ਹੋ ਰਿਹਾ ਹੈ</string>
    <string name="update">ਅੱਪਡੇਟ</string>
    <string name="not_available">N/A</string>
    <string name="hide">ਓਹਲੇ</string>
    <string name="home_package">ਪੈਕੇਜ</string>

    <string name="home_support_title">ਸਾਡਾ ਸਮਰਥਨ ਕਰੋ</string>
    <string name="home_item_source">ਸਰੋਤ</string>
    <string name="home_support_content">ਮੈਜਿਸਕ ਮੁਫਤ ਅਤੇ ਖੁੱਲਾ ਸਰੋਤ ਹੈ, ਅਤੇ ਹਮੇਸ਼ਾਂ ਰਹੇਗਾ। ਹਾਲਾਂਕਿ, ਤੁਸੀਂ ਦਿਖਾ ਸਕਦੇ ਹੋ ਕਿ ਤੁਸੀਂ ਇੱਕ ਛੋਟਾ ਜਿਹਾ ਦਾਨ ਭੇਜ ਕੇ ਦੇਖਭਾਲ ਕਰਦੇ ਹੋ।</string>
    <string name="home_installed_version">ਇੰਸਟਾਲਡ</string>
    <string name="home_latest_version">ਨਵੀਨਤਮ</string>
    <string name="invalid_update_channel">ਅਵੈਧ ਅਪਡੇਟ ਚੈਨਲ</string>
    <string name="uninstall_magisk_title">ਮੈਜਿਸਕ ਨੂੰ ਅਣਇੰਸਟੌਲ ਕਰੋ</string>
    <string name="uninstall_magisk_msg">ਸਾਰੇ ਮੋਡੀਊਲ ਅਯੋਗ/ਮਿਟਾ ਦਿੱਤੇ ਜਾਣਗੇ!\n ਰੂਟ ਨੂੰ ਹਟਾਇਆ ਜਾਏਗਾ!\n ਤੁਹਾਡਾ ਡਾਟਾ ਸੰਭਾਵਤ ਤੌਰ ਤੇ ਐਨਕ੍ਰਿਪਟ ਕੀਤਾ ਗਿਆ ਹੈ ਜੇ ਪਹਿਲਾਂ ਹੀ ਨਹੀਂ!</string>

    <!--Install-->
    <string name="keep_force_encryption">ਫੋਰਸ ਇਨਕ੍ਰਿਪਸ਼ਨ ਨੂੰ ਸੁਰੱਖਿਅਤ ਰੱਖੋ</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity ਨੂੰ ਸੁਰੱਖਿਅਤ ਰੱਖੋ</string>
    <string name="recovery_mode">ਰਿਕਵਰੀ ਮੋਡ</string>
    <string name="install_options_title">ਚੋਣ</string>
    <string name="install_method_title">ਤਰੀਕਾ</string>
    <string name="install_next">ਅੱਗੇ</string>
    <string name="install_start">ਤਾਂ ਆਓ ਸ਼ੁਰੂ ਕਰੀਏ!</string>
    <string name="manager_download_install">ਡਾਊਨਲੋਡ ਅਤੇ ਇੰਸਟੌਲ ਕਰਨ ਲਈ ਦਬਾਓ</string>
    <string name="direct_install">ਸਿੱਦਾ ਇੰਸਟਾਲ (ਸਿਫਾਰਸ਼ੀ)</string>
    <string name="install_inactive_slot">ਨਾ-ਸਰਗਰਮ ਸਲਾਟ ਵਿੱਚ ਇੰਸਟਾਲ ਕਰੋ (OTA ਤੋਂ ਬਾਅਦ)</string>
    <string name="install_inactive_slot_msg">ਤੁਹਾਡੀ ਡਿਵਾਈਸ ਨੂੰ ਮੁੜ ਚਾਲੂ ਹੋਣ ਤੋਂ ਬਾਅਦ ਮੌਜੂਦਾ ਨਿਸ਼ਕਿਰਿਆ ਨੰਬਰ ਤੇ ਬੂਟ ਕਰਨ ਲਈ ਮਜਬੂਰ ਕੀਤਾ ਜਾਏਗਾ!\n OTA ਪੂਰਾ ਹੋਣ ਤੋਂ ਬਾਅਦ ਹੀ ਇਸ ਵਿਕਲਪ ਦੀ ਵਰਤੋਂ ਕਰੋ।\n ਜਾਰੀ ਰੱਖਣਾ ਹੈ?</string>
    <string name="setup_title">ਅਤਿਰਿਕਤ ਸੈਟਅਪ</string>
    <string name="select_patch_file">ਇੱਕ ਫਾਈਲ ਚੁਣੋ ਅਤੇ ਪੈਚ ਕਰੋ</string>
    <string name="patch_file_msg">ਇੱਕ ਰੋ ਛੱਞੀ ਨੂੰ (* .img) ਜਾਂ ਇੱਕ Odin tarfile (* .tar) ਦੀ ਚੋਣ ਕਰੋ</string>
    <string name="reboot_delay_toast">5 ਸਕਿੰਟਾਂ ਵਿੱਚ ਰੀਬੂਟ ਹੋ ਰਿਹਾ ਹੈ …</string>
    <string name="flash_screen_title">ਇੰਸਟਾਲੇਸ਼ਨ</string>

    <!--Superuser-->
    <string name="su_request_title">ਸੁਪਰਯੂਜ਼ਰ ਮੰਗ</string>
    <string name="deny">ਇਨਕਾਰ ਕਰੋ</string>
    <string name="prompt">ਸੰਕੇਤ ਦਿਖਾਓ</string>
    <string name="grant">ਆਗਿਆ ਦਿਓ</string>
    <string name="su_warning">ਇਹ ਤੁਹਾਡੀ ਡਿਵਾਈਸ ਤੇ ਪੂਰੀ ਪਹੁੰਚ ਦੀ ਆਗਿਆ ਦੇਵੇਗਾ,\n ਜੇ ਤੁਹਾਨੂੰ ਯਕੀਨ ਨਹੀਂ ਹੈ ਤਾਂ ਇਨਕਾਰ ਕਰੋ!</string>
    <string name="forever">ਹਮੇਸ਼ਾ</string>
    <string name="once">ਇਕ ਵਾਰ</string>
    <string name="tenmin">10 ਮਿੰਟ</string>
    <string name="twentymin">20 ਮਿੰਟ</string>
    <string name="thirtymin">30 ਮਿੰਟ</string>
    <string name="sixtymin">60 ਮਿੰਟ</string>
    <string name="su_allow_toast"> %1$s ਨੂੰ ਸੁਪਰਯੂਜ਼ਰ ਅਧਿਕਾਰ ਦਿੱਤੇ ਗਏ ਸਨ</string>
    <string name="su_deny_toast"> %1$s ਸੁਪਰਯੂਜ਼ਰ ਅਧਿਕਾਰਾਂ ਤੋਂ ਇਨਕਾਰ ਕੀਤਾ ਗਿਆ ਸੀ</string>
    <string name="su_snack_grant"> %1$s ਨੂੰ ਸੁਪਰਯੂਜ਼ਰ ਅਧਿਕਾਰ ਦਿੱਤੇ ਗਏ ਸਨ</string>
    <string name="su_snack_deny"> %1$s ਸੁਪਰ ਯੂਜ਼ਰ ਅਧਿਕਾਰਾਂ ਤੋਂ ਇਨਕਾਰ ਕੀਤਾ ਗਿਆ ਹੈ</string>
    <string name="su_snack_notif_on"> %1$s ਦੀਆਂ ਸੂਚਨਾਵਾਂ ਯੋਗ ਹਨ</string>
    <string name="su_snack_notif_off"> %1$s ਦੀਆਂ ਸੂਚਨਾਵਾਂ ਅਯੋਗ ਹਨ</string>
    <string name="su_snack_log_on"> %1$s ਦੀਆਂ ਲੌਗਿੰਗ ਯੋਗ ਹਨ</string>
    <string name="su_snack_log_off"> %1$s ਦੀਆਂ ਲੌਗਿੰਗ ਅਯੋਗ ਹਨ</string>
    <string name="su_revoke_title">ਅਧਿਕਾਰ ਵਾਪਸ ਲਓ?</string>
    <string name="su_revoke_msg"> %1$s ਦੇ ਅਧਿਕਾਰਾਂ ਨੂੰ ਰੱਦ ਕਰਨ ਦੀ ਪੁਸ਼ਟੀ ਕਰਦੇ ਹੋ?</string>
    <string name="toast">ਪੌਪ-ਅੱਪ ਸੂਚਨਾ</string>
    <string name="none">ਕੋਈ ਨਹੀਂ</string>

    <string name="superuser_toggle_notification">ਸੂਚਨਾ</string>
    <string name="superuser_toggle_revoke">ਅਧਿਕਾਰ ਵਾਪਸ ਲਓ</string>
    <string name="superuser_policy_none">ਅਜੇ ਤੱਕ ਕਿਸੇ ਵੀ ਐਪ ਨੇ ਸੁਪਰਯੂਜ਼ਰ ਲਈ ਆਗਿਆ ਨਹੀਂ ਮੰਗੀ ਹੈ।</string>

    <!--Logs-->
    <string name="log_data_none">ਕੋਈ ਲੌਗਸ ਨਹੀਂ, ਆਪਣੀ ਸੁਪਰਯੂਜ਼ਰ ਸਮਰਥਿਤ ਐਪਲੀਕੇਸ਼ਨ ਨੂੰ ਹੋਰ ਵਰਤਣ ਦੀ ਕੋਸ਼ਿਸ਼ ਕਰੋ।</string>
    <string name="log_data_magisk_none">ਮੈਜਿਸਕ ਲੌਗਸ ਖਾਲੀ ਹਨ, ਇਹ ਅਜੀਬ ਹੈ।</string>
    <string name="menuSaveLog">ਲੌਗ ਸੇਵ ਕਰੋ</string>
    <string name="menuClearLog">ਲੌਗ ਸਾਫ ਕਰੋ</string>
    <string name="logs_cleared">ਲੌਗ ਸਫਲਤਾਪੂਰਕ ਸਾਫ ਹੋ ਗਏ ਹਨ।</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">ਟੀਚਾ UID: %1$d</string>

    <!--SafetyNet-->

    <!-- MagiskHide -->
    <string name="show_system_app">ਸਿਸਟਮ ਐਪਸ ਦਿਖਾਓ</string>
    <string name="show_os_app">OS ਐਪਲੀਕੇਸ਼ਨ ਦਿਖਾਓ</string>
    <string name="hide_filter_hint">ਨਾਮ ਦੁਆਰਾ ਫਿਲਟਰ ਕਰੋ</string>
    <string name="hide_search">ਖੋਜੋ</string>

    <!--Module -->
    <string name="no_info_provided">(ਕੋਈ ਜਾਣਕਾਰੀ ਨਹੀਂ ਦਿੱਤੀ ਗਈ)</string>
    <string name="reboot_userspace">ਸਾਫਟ ਰੀਬੂਟ</string>
    <string name="reboot_recovery">ਰਿਕਵਰੀ ਰੀਬੂਟ</string>
    <string name="reboot_bootloader">ਬੂਟਲੋਡਰ ਰੀਬੂਟ</string>
    <string name="reboot_download">ਡਾਊਨਲੋਡ ਮੋਡ ਰੀਬੂਟ</string>
    <string name="reboot_edl">EDL ਰੀਬੂਟ</string>
    <string name="module_version_author"> %2$s ਦੇ ਦੁਆਰਾ %1$s</string>
    <string name="module_state_remove">ਹਟਾਓ</string>
    <string name="module_state_restore">ਰੀਸਟੋਰ ਕਰੋ</string>
    <string name="module_action_install_external">ਸਟੋਰੇਜ ਤੋਂ ਇੰਸਟਾਲ ਕਰੋ</string>
    <string name="update_available">ਅਪਡੇਟ ਉਪਲੱਬਧ ਹੈ</string>

    <!--Settings -->
    <string name="settings_dark_mode_title">ਥੀਮ ਮੋਡ</string>
    <string name="settings_dark_mode_message">ਕੋਈ ਥੀਮ ਚੁਣੋ ਜੋ ਤੁਹਾਡੀ ਸ਼ੈਲੀ ਦੇ ਅਨੁਕੂਲ ਹੋਵੇ!</string>
    <string name="settings_dark_mode_light">ਹਮੇਸ਼ਾਂ ਚਿੱਟੇ ਰੰਗ ਦੀ</string>
    <string name="settings_dark_mode_system">ਸਿਸਟਮ ਦੇ ਅਨੁਸਾਰ</string>
    <string name="settings_dark_mode_dark">ਹਮੇਸ਼ਾ ਗਹਿਰੇ ਰੰਗ ਦੀ</string>
    <string name="settings_download_path_title">ਡਾਊਨਲੋਡ ਮਾਰਗ</string>
    <string name="settings_download_path_message">ਫਾਈਲਾਂ ਨੂੰ %1$s ਵਿੱਚ ਸੇਵ ਕੀਤਾ ਜਾਏਗਾ</string>
    <string name="language">ਭਾਸ਼ਾ</string>
    <string name="system_default">(ਸਿਸਟਮ ਡਿਫੌਲਟ)</string>
    <string name="settings_check_update_title">ਚੈੱਕ ਅੱਪਡੇਟ</string>
    <string name="settings_check_update_summary">ਸਮੇਂ-ਸਮੇਂ \'ਤੇ ਪਿਛੋਕੜ ਦੇ ਅਪਡੇਟਾਂ ਦੀ ਜਾਂਚ ਕਰੋ</string>
    <string name="settings_update_channel_title">ਅਪਡੇਟ ਚੈਨਲ</string>
    <string name="settings_update_stable">ਸਥਿਰ</string>
    <string name="settings_update_beta">ਬੀਟਾ</string>
    <string name="settings_update_custom">ਕਸਟਮ ਚੈਨਲ</string>
    <string name="settings_update_custom_msg">ਇੱਕ ਕਸਟਮ URL ਦਾਖਲ ਕਰੋ</string>
    <string name="settings_hosts_title">Systemless ਹੋਸਟ</string>
    <string name="settings_hosts_summary">Adblock ਐਪਸ ਲਈ Systemless ਹੋਸਟ ਦੀ ਸਹਿਯੋਗ</string>
    <string name="settings_hosts_toast">Systemless ਹੋਸਟ ਮੋਡੀਊਲ ਸ਼ਾਮਲ ਕੀਤਾ ਗਿਆ</string>
    <string name="settings_app_name_hint">ਨਵਾਂ ਨਾਮ</string>
    <string name="settings_app_name_helper">ਇਸ ਨਾਮ ਨਾਲ ਐਪ ਦੁਬਾਰਾ ਇੰਸਟਾਲ ਕੀਤਾ ਜਾਵੇਗਾ</string>
    <string name="settings_app_name_error">ਗਲਤ ਫਾਰਮੈਟ</string>
    <string name="settings_su_app_adb">ਐਪਸ ਅਤੇ ਐਡਬੀ</string>
    <string name="settings_su_app">ਸਿਰਫ ਐਪਸ</string>
    <string name="settings_su_adb">ਸਿਰਫ ਐਡਬੀ</string>
    <string name="settings_su_disable">ਬੰਦ ਹੈ</string>
    <string name="settings_su_request_10">10 ਸਕਿੰਟ</string>
    <string name="settings_su_request_15">15 ਸਕਿੰਟ</string>
    <string name="settings_su_request_20">20 ਸਕਿੰਟ</string>
    <string name="settings_su_request_30">30 ਸਕਿੰਟ</string>
    <string name="settings_su_request_45">45 ਸਕਿੰਟ</string>
    <string name="settings_su_request_60">60 ਸਕਿੰਟ</string>
    <string name="superuser_access">ਸੁਪਰਯੂਜ਼ਰ ਐਕਸੈਸ</string>
    <string name="auto_response">ਆਟੋਮੈਟਿਕ ਜਵਾਬ</string>
    <string name="request_timeout">ਬੇਨਤੀ ਦਾ ਸਮਾਂ ਸਮਾਪਤ</string>
    <string name="superuser_notification">ਸੁਪਰਯੂਜ਼ਰ ਸੂਚਨਾ</string>
    <string name="settings_su_reauth_title">ਅਪਗ੍ਰੇਡ ਹੋਣ ਤੋਂ ਬਾਅਦ ਪ੍ਰਮਾਣਿਕਤਾ</string>
    <string name="settings_su_reauth_summary">ਇੱਕ ਐਪ ਦੇ ਅਪਡੇਟ ਹੋਣ ਤੋਂ ਬਾਅਦ ਸੁਪਰਯੂਜ਼ਰ ਆਗਿਆ ਪ੍ਰਮਾਣਿਤ ਕਰੋ</string>
    <string name="settings_customization">ਕਸਟਮਾਈਜੇਸ਼ਨ</string>
    <string name="setting_add_shortcut_summary">ਐਪ ਨੂੰ ਲੁਕਾਉਣ ਤੋਂ ਬਾਅਦ ਨਾਮ ਅਤੇ ਆਈਕਾਨ ਨੂੰ ਪਛਾਣਨਾ ਮੁਸ਼ਕਲ ਹੈ, ਤਾਂ ਹੋਮ ਸਕ੍ਰੀਨ ਵਿਚ ਇਕ ਸੁੰਦਰ ਸ਼ਾਰਟਕੱਟ ਸ਼ਾਮਲ ਕਰੋ</string>
    <string name="settings_doh_title">DNS ਉੱਤੇ HTTPS</string>
    <string name="settings_doh_description">ਕੁਝ ਦੇਸ਼ਾਂ ਵਿੱਚ ਚੱਲ ਰਹੇ DNS ਵਿਸ਼ਾਕਤਤਾ ਦਾ ਹੱਲ</string>

    <string name="multiuser_mode">ਮਲਟੀ ਯੂਜ਼ਰ ਮੋਡ</string>
    <string name="settings_owner_only">ਸਿਰਫ ਡਿਵਾਈਸ ਮਾਲਕ</string>
    <string name="settings_owner_manage">ਡਿਵਾਈਸ ਮਾਲਕ ਦੁਆਰਾ ਪ੍ਰਬੰਧਿਤ</string>
    <string name="settings_user_independent">ਸੁਤੰਤਰ ਉਪਭੋਗਤਾ</string>
    <string name="owner_only_summary">ਸਿਰਫ ਮਾਲਕ ਕੋਲ ਰੂਟ ਐਕਸੈਸ ਹੈ</string>
    <string name="owner_manage_summary">ਸਿਰਫ ਮਾਲਕ ਰੂਟ ਐਕਸੈਸ ਦਾ ਪ੍ਰਬੰਧ ਕਰ ਸਕਦੇ ਹਨ ਅਤੇ ਬੇਨਤੀ ਸਿਗਨਲ ਪ੍ਰਾਪਤ ਕਰ ਸਕਦੇ ਹਨ</string>
    <string name="user_independent_summary">ਹਰੇਕ ਉਪਭੋਗਤਾ ਦਾ ਆਪਣਾ ਵੱਖਰਾ ਰੂਟ ਨਿਯਮ ਹੁੰਦਾ ਹੈ</string>

    <string name="mount_namespace_mode">ਮਾਉਂਟ ਨੇਮਸਪੇਸ ਮੋਡ</string>
    <string name="settings_ns_global">ਗਲੋਬਲ ਨੇਮਸਪੇਸ</string>
    <string name="settings_ns_requester">ਇਨਹੇਰਟ ਨੇਮਸਪੇਸ</string>
    <string name="settings_ns_isolate">ਆਈਸੋਲੇਟਿਡ ਨੇਮਸਪੇਸ</string>
    <string name="global_summary">ਸਾਰੇ ਰੂਟ ਸੈਸ਼ਨ ਗਲੋਬਲ ਨੇਮਸਪੇਸ ਦੀ ਵਰਤੋਂ ਕਰਦੇ ਹਨ</string>
    <string name="requester_summary">ਰੂਟ ਸੈਸ਼ਨ ਨਾਮਸਪੇਸ ਬੇਨਤੀਆਂ ਨੂੰ ਪ੍ਰਾਪਤ ਕਰਨਗੇ</string>
    <string name="isolate_summary">ਹਰੇਕ ਰੂਟ ਸੈਸ਼ਨ ਦਾ ਆਪਣਾ ਵੱਖਰਾ ਨਾਮਸਪੇਸ ਹੋਵੇਗਾ</string>

    <!--Notifications-->
    <string name="update_channel">ਮੈਜਿਸਕ ਅਪਡੇਟ</string>
    <string name="progress_channel">ਤਰੱਕੀ ਦੀਆਂ ਸੂਚਨਾਵਾਂ</string>
    <string name="download_complete">ਡਾਊਨਲੋਡ ਪੂਰਾ</string>
    <string name="download_file_error">ਫਾਈਲ ਡਾਊਨਲੋਡ ਕਰਨ ਦੌਰਾਨ ਗਲਤੀ</string>
    <string name="magisk_update_title">ਮੈਜਿਸਕ ਅਪਡੇਟ ਉਪਲੱਬਧ!</string>

    <!--Toasts, Dialogs-->
    <string name="yes">ਹਾਂ</string>
    <string name="no">ਨਹੀਂ</string>
    <string name="repo_install_title">ਇੰਸਟਾਲ %1$s %2$s(%3$d)</string>
    <string name="download">ਡਾਊਨਲੋਡ</string>
    <string name="reboot">ਰੀਬੂਟ</string>
    <string name="release_notes">ਰੀਲਿਜ਼ ਨੋਟਿਸ</string>
    <string name="flashing">ਫਲੈਸ਼ਿੰਗ …</string>
    <string name="done">ਸਫਲ ਹੋਇਆ!</string>
    <string name="failure">ਅਸਫਲ ਹੋਇਆ</string>
    <string name="open_link_failed_toast">ਲਿੰਕ ਖੋਲ੍ਹਣ ਲਈ ਕੋਈ ਐਪਲੀਕੇਸ਼ਨ ਨਹੀਂ ਮਿਲੀ</string>
    <string name="complete_uninstall">ਪੂਰੀ ਤਰ੍ਹਾਂ ਅਣਇੰਸਟੌਲ ਕਰੋ</string>
    <string name="restore_img">ਇਮੇਜ ਰਿਸਟੋਰ ਕਰੋ</string>
    <string name="restore_img_msg">ਰਿਸਟੋਰ ਹੋ ਰਿਹਾ ਹੈ …</string>
    <string name="restore_done">रिस्टोर ਸਫਲ ਹੋਇਆ!</string>
    <string name="restore_fail">ਸਟਾਕ ਬੈਕਅਪ ਮੌਜੂਦ ਨਹੀਂ ਹੈ!</string>
    <string name="setup_fail">ਸੈਟਅਪ ਅਸਫਲ ਹੋਇਆ</string>
    <string name="env_fix_title">ਵਾਧੂ ਸੈਟਅਪ ਚਾਹੀਦਾ ਹੈ</string>
    <string name="setup_msg">ਵਾਤਾਵਰਣ ਸੈਟਅਪ ਚੱਲ ਰਿਹਾ ਹੈ …</string>
    <string name="unsupport_magisk_title">ਗ਼ੈਰ ਮੈਜਿਸਕ ਵਰਜਨ</string>
    <string name="external_rw_permission_denied">ਇਸ ਦੀ ਵਰਤੋਂ ਕਰਨ ਲਈ ਸਟੋਰੇਜ ਦੀ ਆਗਿਆ ਦਿਓ</string>
    <string name="add_shortcut_title">ਹੋਮਸਕ੍ਰੀਨ \'ਤੇ ਸ਼ਾਰਟਕੱਟ ਸ਼ਾਮਲ ਕਰੋ</string>
    <string name="app_not_found">ਇਸ ਐਕਸ਼ਨ ਨੂੰ ਸੰਭਾਲਣ ਲਈ ਕੋਈ ਐਪਲੀਕੇਸ਼ਨ ਨਹੀਂ ਮਿਲੀ</string>

</resources>

```

`app/core/src/main/res/values-pl/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Moduły</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Logi</string>
    <string name="settings">Ustawienia</string>
    <string name="install">Instaluj</string>
    <string name="section_home">Strona główna</string>
    <string name="section_theme">Motywy</string>
    <string name="denylist">Lista odmów (DenyList)</string>

    <!--Home-->
    <string name="no_connection">Połączenie niedostępne</string>
    <string name="app_changelog">Dziennik zmian</string>
    <string name="loading">Ładowanie…</string>
    <string name="update">Zaktualizuj</string>
    <string name="not_available">N/D</string>
    <string name="hide">Ukryj</string>
    <string name="home_package">Pakiet</string>
    <string name="home_app_title">Aplikacja</string>

    <string name="home_notice_content">Pobieraj Magisk tylko z oficjalnej strony GitHub. Pliki z nieznanych źródeł mogą być szkodliwe!</string>
    <string name="home_support_title">Wesprzyj nas</string>
    <string name="home_follow_title">Śledź nas</string>
    <string name="home_item_source">Źródło</string>
    <string name="home_support_content">Magisk jest i zawsze będzie darmowy i otwarty. Niemniej możesz nam pokazać, że Ci zależy, wysyłając drobną darowiznę.</string>
    <string name="home_installed_version">Zainstalowany</string>
    <string name="home_latest_version">Ostatni</string>
    <string name="invalid_update_channel">Nieprawidłowy kanał aktualizacji</string>
    <string name="uninstall_magisk_title">Odinstalowywanie Magisk</string>
    <string name="uninstall_magisk_msg">Wszystkie moduły zostaną wyłączone/usunięte!\nRoot zostanie usunięty!\nWszelka wewnętrzna pamięć niezaszyfrowana w związku z użytkowaniem Magisk zostanie ponownie zaszyfrowana!</string>

    <!--Install-->
    <string name="keep_force_encryption">Zachowaj force encryption (wymuszenie szyfrowania)</string>
    <string name="keep_dm_verity">Zachowaj AVB 2.0/dm-verity (weryfikację rozruchu)</string>
    <string name="recovery_mode">Tryb Recovery</string>
    <string name="install_options_title">Opcje</string>
    <string name="install_method_title">Metoda</string>
    <string name="install_next">Dalej</string>
    <string name="install_start">Zaczynajmy</string>
    <string name="manager_download_install">Kliknij, aby pobrać i zainstalować</string>
    <string name="direct_install">Bezpośrednia instalacja (zalecana)</string>
    <string name="install_inactive_slot">Zainstaluj w nieaktywnym slocie (po OTA)</string>
    <string name="install_inactive_slot_msg">Po ponownym uruchomieniu twoje urządzenie zostanie ZMUSZONE do rozruchu z aktualnie nieaktywnego slotu!\nUżywaj tej opcji tylko po ukończeniu aktualizacji OTA.\nKontynuować?</string>
    <string name="setup_title">Dodatkowa konfiguracja</string>
    <string name="select_patch_file">Wybierz i załataj plik</string>
    <string name="patch_file_msg">Wybierz obraz raw (*.img) lub plik tar ODIN (*.tar) lub payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">Ponowne uruchomienie za 5 sekund…</string>
    <string name="flash_screen_title">Instalacja</string>

    <!--Superuser-->
    <string name="su_request_title">Żądanie dostępu do Superusera</string>
    <string name="touch_filtered_warning">Ponieważ aplikacja zasłania żądanie o Superusera, Magisk nie może zweryfikować twojej odpowiedzi</string>
    <string name="deny">Odmów</string>
    <string name="prompt">Zapytaj</string>
    <string name="grant">Zezwól</string>
    <string name="su_warning">Udziela pełnego dostępu do urządzenia.\nOdmów, jeżeli nie jesteś pewien!</string>
    <string name="forever">Zawsze</string>
    <string name="once">Raz</string>
    <string name="tenmin">10 min</string>
    <string name="twentymin">20 min</string>
    <string name="thirtymin">30 min</string>
    <string name="sixtymin">60 min</string>
    <string name="su_allow_toast">%1$s otrzymał uprawnienia Superusera</string>
    <string name="su_deny_toast">%1$s odmówiono uprawnień Superusera</string>
    <string name="su_snack_grant">Przyznano uprawnienia Superusera dla %1$s</string>
    <string name="su_snack_deny">Unieważniono uprawnienia Superusera dla %1$s</string>
    <string name="su_snack_notif_on">Włączono powiadomienia dla %1$s</string>
    <string name="su_snack_notif_off">Wyłączono powiadomienia dla %1$s</string>
    <string name="su_snack_log_on">Włączono logowanie dla %1$s</string>
    <string name="su_snack_log_off">Wyłączono logowanie dla %1$s</string>
    <string name="su_revoke_title">Unieważnić?</string>
    <string name="su_revoke_msg">Potwierdź, aby unieważnić uprawnienia Superusera dla %1$s</string>
    <string name="toast">Wyskakujące powiadomienie</string>
    <string name="none">Brak</string>

    <string name="superuser_toggle_notification">Powiadomienia</string>
    <string name="superuser_toggle_revoke">Unieważnij</string>
    <string name="superuser_policy_none">Żadna aplikacja nie poprosiła jeszcze o uprawnienia Superusera.</string>

    <!--Logs-->
    <string name="log_data_none">Nie masz żadnych logów, spróbuj użyć aplikacji wymagających roota</string>
    <string name="log_data_magisk_none">Logi Magisk są puste, to jest dziwne</string>
    <string name="menuSaveLog">Zapisz log</string>
    <string name="menuClearLog">Wyczyść log</string>
    <string name="logs_cleared">Log został pomyślnie wyczyszczony</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Docelowy UID: %1$d</string>
    <string name="target_pid">Docelowy PID p.n. montowania: %s</string>
    <string name="selinux_context">Kontekst SELinux: %s</string>
    <string name="supp_group">Grupa uzupełniająca: %s</string>

    <!--SafetyNet-->

    <!--MagiskHide -->
    <string name="show_system_app">Pokaż aplikacje systemowe</string>
    <string name="show_os_app">Pokaż aplikacje OS</string>
    <string name="hide_filter_hint">Filtruj według nazwy</string>
    <string name="hide_search">Szukaj</string>

    <!--Module -->
    <string name="no_info_provided">(Brak informacji)</string>
    <string name="reboot_userspace">Miękki reboot</string>
    <string name="reboot_recovery">Reboot do trybu Recovery</string>
    <string name="reboot_bootloader">Reboot do trybu Bootloader</string>
    <string name="reboot_download">Reboot do trybu Download</string>
    <string name="reboot_edl">Reboot do trybu EDL</string>
    <string name="module_version_author">%1$s od %2$s</string>
    <string name="module_state_remove">Usuń</string>
    <string name="module_state_restore">Przywróć</string>
    <string name="module_action_install_external">Zainstaluj z pamięci</string>
    <string name="update_available">Dostępna aktualizacja</string>
    <string name="suspend_text_riru">Moduł jest zawieszony, ponieważ %1$s jest włączony</string>
    <string name="suspend_text_zygisk">Moduł jest zawieszony, ponieważ %1$s nie jest włączony</string>
    <string name="zygisk_module_unloaded">Moduł Zygisk nie został załadowany z powodu niekompatybilności</string>
    <string name="module_empty">Brak zainstalowanych modułów</string>
    <string name="confirm_install">Zainstalować moduł %1$s?</string>
    <string name="confirm_install_title">Potwierdzenie instalacji</string>

    <!--Settings -->
    <string name="settings_dark_mode_title">Tryb motywu</string>
    <string name="settings_dark_mode_message">Wybierz tryb, który najbardziej ci odpowiada!</string>
    <string name="settings_dark_mode_light">Zawsze jasny</string>
    <string name="settings_dark_mode_system">Ustawienie systemowe</string>
    <string name="settings_dark_mode_dark">Zawsze ciemny</string>
    <string name="settings_download_path_title">Ścieżka pobierania plików</string>
    <string name="settings_download_path_message">Pliki zostaną zapisane do %1$s</string>
    <string name="settings_hide_app_title">Ukryj aplikację Magisk</string>
    <string name="settings_hide_app_summary">Zainstaluj aplikację proxy z losowym ID pakietu i własną etykietą</string>
    <string name="settings_restore_app_title">Przywróć aplikację Magisk</string>
    <string name="settings_restore_app_summary">Przestań ukrywać aplikację i przywróć oryginalny plik APK</string>
    <string name="language">Język</string>
    <string name="system_default">(Domyślny systemowy)</string>
    <string name="settings_check_update_title">Sprawdzanie aktualizacji</string>
    <string name="settings_check_update_summary">Okresowo sprawdzaj dostępność aktualizacji w tle</string>
    <string name="settings_update_channel_title">Kanał aktualizacji</string>
    <string name="settings_update_stable">Stabilny</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Własny kanał</string>
    <string name="settings_update_custom_msg">Wprowadź adres URL własnego kanału</string>
    <string name="settings_zygisk_summary">Uruchom część Magisk w demonie zygote</string>
    <string name="settings_denylist_title">Egzekwowanie listy odmów (DenyList)</string>
    <string name="settings_denylist_summary">Procesy znajdujące się na liście odmów (DenyList) będą miały cofnięte wszystkie modyfikacje Magisk</string>
    <string name="settings_denylist_config_title">Konfiguracja listy odmów (DenyList)</string>
    <string name="settings_denylist_config_summary">Wybierz procesy, które mają się znajdować na liście odmów (DenyList)</string>
    <string name="settings_hosts_title">Hosty Systemless</string>
    <string name="settings_hosts_summary">Wsparcie hostów Systemless dla aplikacji blokujących reklamy</string>
    <string name="settings_hosts_toast">Dodano moduł hostów Systemless</string>
    <string name="settings_app_name_hint">Nowa nazwa</string>
    <string name="settings_app_name_helper">Aplikacja zostanie przepakowana z tą nazwą</string>
    <string name="settings_app_name_error">Nieprawidłowy format</string>
    <string name="settings_su_app_adb">Aplikacje i ADB</string>
    <string name="settings_su_app">Tylko aplikacje</string>
    <string name="settings_su_adb">Tylko ADB</string>
    <string name="settings_su_disable">Wyłączone</string>
    <string name="settings_su_request_10">10 sekund</string>
    <string name="settings_su_request_15">15 sekund</string>
    <string name="settings_su_request_20">20 sekund</string>
    <string name="settings_su_request_30">30 sekund</string>
    <string name="settings_su_request_45">45 sekund</string>
    <string name="settings_su_request_60">60 sekund</string>
    <string name="superuser_access">Dostęp do Superusera</string>
    <string name="auto_response">Automatyczna reakcja</string>
    <string name="request_timeout">Limit czasu żądania</string>
    <string name="superuser_notification">Powiadomienia Superusera</string>
    <string name="settings_su_reauth_title">Ponowienie uwierzytelniania po aktualizacji</string>
    <string name="settings_su_reauth_summary">Zapytaj ponownie o uprawnienia Superusera po uaktualnieniu aplikacji</string>
    <string name="settings_su_tapjack_title">Ochrona przed Tapjackingiem (niezamierzonym kliknięciem)</string>
    <string name="settings_su_tapjack_summary">Okno dialogowe z żądaniem Superusera nie będzie reagować na odpowiedź, jeżeli będzie zasłonięte przez inne okno lub nakładkę</string>
    <string name="settings_su_auth_title">Uwierzytelnianie użytkownika</string>
    <string name="settings_su_auth_summary">Pytaj o uwierzytelnienie użytkownika podczas żądań Superusera</string>
    <string name="settings_su_auth_insecure">Nie skonfigurowano żadnej metody uwierzytelniania na tym urządzeniu</string>
    <string name="settings_customization">Personalizacja</string>
    <string name="setting_add_shortcut_summary">Umieść ładny skrót na ekranie głównym na wypadek, gdyby nazwa i ikona były trudne do rozpoznania po ukryciu aplikacji</string>
    <string name="settings_doh_title">DNS over HTTPS</string>
    <string name="settings_doh_description">Zapobiegaj zatruwaniu DNS (DNS poisoning) w niektórych krajach</string>

    <string name="multiuser_mode">Tryb wielu użytkowników (Multiuser)</string>
    <string name="settings_owner_only">Tylko właściciel urządzenia</string>
    <string name="settings_owner_manage">Zarządzanie przez właściciela urządzenia</string>
    <string name="settings_user_independent">Niezależne ustawienia użytkowników</string>
    <string name="owner_only_summary">Tylko właściciel ma dostęp do roota</string>
    <string name="owner_manage_summary">Tylko właściciel może zarządzać dostępem do roota i otrzymywać żądania dostępu do roota</string>
    <string name="user_independent_summary">Każdy użytkownik ma niezależne ustawienia dostępu do roota</string>

    <string name="mount_namespace_mode">Tryb przestrzeni nazw montowania</string>
    <string name="settings_ns_global">Globalna przestrzeń nazw</string>
    <string name="settings_ns_requester">Dziedziczona przestrzeń nazw</string>
    <string name="settings_ns_isolate">Izolowana przestrzeń nazw</string>
    <string name="global_summary">Wszystkie sesje roota będą używać globalnej przestrzeni nazw montowania</string>
    <string name="requester_summary">Sesje roota odziedziczą przestrzeń nazw żądającego dostępu</string>
    <string name="isolate_summary">Każda sesja roota otrzyma własną, izolowaną przestrzeń nazw</string>

    <!--Notifications-->
    <string name="update_channel">Aktualizacja Magisk</string>
    <string name="progress_channel">Powiadomienia o postępach</string>
    <string name="updated_channel">Aktualizacja zakończona</string>
    <string name="download_complete">Pobieranie zakończone</string>
    <string name="download_file_error">Błąd pobierania pliku</string>
    <string name="magisk_update_title">Aktualizacja Magisk dostępna!</string>
    <string name="updated_title">Magisk zaktualizowany</string>
    <string name="updated_text">Kliknij, aby otworzyć aplikację</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Tak</string>
    <string name="no">Nie</string>
    <string name="repo_install_title">Instalacja %1$s %2$s(%3$d)</string>
    <string name="download">Pobierz</string>
    <string name="reboot">Reboot</string>
    <string name="release_notes">Lista zmian</string>
    <string name="flashing">Flashowanie…</string>
    <string name="done">Gotowe!</string>
    <string name="failure">Błąd</string>
    <string name="hide_app_title">Ukrywanie aplikacji Magisk…</string>
    <string name="open_link_failed_toast">Nie znaleziono aplikacji do otwarcia linku</string>
    <string name="complete_uninstall">Odinstaluj całkowicie</string>
    <string name="restore_img">Przywróć obrazy</string>
    <string name="restore_img_msg">Przywracanie…</string>
    <string name="restore_done">Przywracanie zakończone!</string>
    <string name="restore_fail">Kopia zapasowa nie istnieje!</string>
    <string name="setup_fail">Konfiguracja nieudana</string>
    <string name="env_fix_title">Wymagana dodatkowa konfiguracja</string>
    <string name="env_fix_msg">Twoje urządzenie wymaga dodatkowej konfiguracji, aby Magisk działał poprawnie. Czy chcesz kontynuować i uruchomić ponownie?</string>
    <string name="env_full_fix_msg">Twoje urządzenie wymaga ponownej instalacji Magisk, aby działać poprawnie. Zainstaluj ponownie Magisk używając aplikacji, tryb recovery nie może uzyskać prawidłowych informacji o urządzeniu.</string>
    <string name="setup_msg">Uruchamianie środowiska konfiguracji…</string>
    <string name="unsupport_magisk_title">Nieobsługiwana wersja Magisk</string>
    <string name="unsupport_magisk_msg">Ta wersja aplikacji nie obsługuje Magisk w wersji niższej niż %1$s.\n\nAplikacja będzie zachowywać się tak, jakby Magisk nie był zainstalowany, zaktualizuj Magisk tak szybko, jak to możliwe.</string>
    <string name="unsupport_general_title">Nieprawidłowy stan</string>
    <string name="unsupport_system_app_msg">Uruchomienie tej aplikacji jako aplikacja systemowa nie jest obsługiwane. Przywróć aplikację do stanu aplikacji użytkownika.</string>
    <string name="unsupport_other_su_msg">Wykryto plik binarny \"su\" nie należący do Magisk. Usuń wszelkie konkurencyjne rozwiązania root i/lub zainstaluj ponownie Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk jest zainstalowany w pamięci zewnętrznej. Przenieś aplikację do pamięci wewnętrznej.</string>
    <string name="unsupport_nonroot_stub_msg">Ukryta aplikacja Magisk nie może dłużej działać, ponieważ uprawnienia roota zostały utracone. Przywróć oryginalny plik APK.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Zezwól na dostęp do pamięci, aby włączyć tę funkcję</string>
    <string name="post_notifications_denied">Zezwól na otrzymywanie powiadomień, aby włączyć tę funkcję</string>
    <string name="install_unknown_denied">Zezwól na \"Instaluj z nieznanych źródeł\", aby włączyć tę funkcję</string>
    <string name="add_shortcut_title">Utwórz skrót na ekranie głównym</string>
    <string name="add_shortcut_msg">Po ukryciu tej aplikacji, jej nazwa i ikona może być trudna do rozpoznania. Czy chcesz dodać ładny skrót na ekranie głównym?</string>
    <string name="app_not_found">Nie znaleziono aplikacji do wykonania tej czynności</string>
    <string name="reboot_apply_change">Uruchom ponownie, aby zastosować zmiany</string>
    <string name="restore_app_confirmation">Spowoduje to przywrócenie ukrytej aplikacji z powrotem do stanu oryginalnej aplikacji. Czy na pewno chcesz to zrobić?</string>

</resources>

```

`app/core/src/main/res/values-pt-rBR/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Módulos</string>
    <string name="superuser">SuperUsuário</string>
    <string name="logs">Registros</string>
    <string name="settings">Configurações</string>
    <string name="install">Instalar</string>
    <string name="section_home">Início</string>
    <string name="section_theme">Temas</string>
    <string name="denylist">Lista de negação</string>

    <!--Home-->
    <string name="no_connection">Nenhuma conexão disponível</string>
    <string name="app_changelog">Registro de alterações</string>
    <string name="loading">Carregando…</string>
    <string name="update">Atualizar</string>
    <string name="not_available">Não disponível</string>
    <string name="hide">Ocultar</string>
    <string name="home_package">Pacote</string>
    <string name="home_app_title">App</string>
    <string name="home_notice_content">Baixe o Magisk SOMENTE pela página oficial do GitHub. Arquivos de fontes desconhecidas podem ser maliciosos!</string>
    <string name="home_support_title">Apoie-nos</string>
    <string name="home_follow_title">Siga-nos</string>
    <string name="home_item_source">Fonte</string>
    <string name="home_support_content">Magisk sempre foi e sempre será, gratuito e de código aberto. No entanto, você pode nos ajudar enviando uma pequena doação.</string>
    <string name="home_installed_version">Instalado</string>
    <string name="home_latest_version">Recente</string>
    <string name="invalid_update_channel">Canal de atualização inválido</string>
    <string name="uninstall_magisk_title">Desinstalar Magisk</string>
    <string name="uninstall_magisk_msg">Todos os módulos serão desativados/removidos!\nO root será removido!\nSeus dados não criptografados devido ao uso do Magisk, serão re-criptografados!</string>

    <!--Install-->
    <string name="keep_force_encryption">Manter criptografia forçada</string>
    <string name="keep_dm_verity">Manter AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Modo Recovery</string>
    <string name="install_options_title">Opções</string>
    <string name="install_method_title">Método</string>
    <string name="install_next">Próximo</string>
    <string name="install_start">Vamos lá</string>
    <string name="manager_download_install">Toque para baixar e instalar</string>
    <string name="direct_install">Instalação direta (recomendada)</string>
    <string name="install_inactive_slot">Instalar no slot inativo (após o OTA)</string>
    <string name="install_inactive_slot_msg">Seu dispositivo será FORÇADO a inicializar no slot inativo atual após uma reinicialização!\nSó use esta opção após a conclusão do OTA.\nDeseja continuar?</string>
    <string name="setup_title">Configuração adicional</string>
    <string name="select_patch_file">Selecione e corrija um arquivo</string>
    <string name="patch_file_msg">Selecione um arquivo imagem (*.img) ou um arquivo tar (*.tar) ou um arquivo payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">Reiniciando em 5 segundos…</string>
    <string name="flash_screen_title">Instalação</string>

    <!--Superuser-->
    <string name="su_request_title">Solicitação de SuperUsuário</string>
    <string name="touch_filtered_warning">Como um app está ocultando uma solicitação de SuperUsuário, o Magisk não pode verificar sua resposta.</string>
    <string name="deny">Negar</string>
    <string name="prompt">Perguntar</string>
    <string name="restrict">Restringir</string>
    <string name="grant">Permitir</string>
    <string name="su_warning">Permite acesso total ao seu dispositivo.\nNão permita se você não tiver certeza do que está fazendo!</string>
    <string name="forever">Sempre</string>
    <string name="once">Uma vez</string>
    <string name="tenmin">10 mins</string>
    <string name="twentymin">20 mins</string>
    <string name="thirtymin">30 mins</string>
    <string name="sixtymin">60 mins</string>
    <string name="su_allow_toast">%1$s foi permitido o acesso de SuperUsuário</string>
    <string name="su_deny_toast">%1$s foi negado o acesso de SuperUsuário</string>
    <string name="su_snack_grant">Os acessos de SuperUsuário de %1$s foram permitidos</string>
    <string name="su_snack_deny">Os acessos de SuperUsuário de %1$s foram negados</string>
    <string name="su_snack_notif_on">As notificações de %1$s foram ativadas</string>
    <string name="su_snack_notif_off">As notificações de %1$s foram desativadas</string>
    <string name="su_snack_log_on">Os registros de %1$s foram ativados</string>
    <string name="su_snack_log_off">Os registros de %1$s foram desativados</string>
    <string name="su_revoke_title">Revogar?</string>
    <string name="su_revoke_msg">Confirme para revogar os acessos de SuperUsuário de %1$s</string>
    <string name="toast">Notificação (Pop-up)</string>
    <string name="none">Nenhum</string>
    <string name="superuser_toggle_notification">Notificações</string>
    <string name="superuser_toggle_revoke">Revogar</string>
    <string name="superuser_policy_none">Nenhum app solicitou permissão de SuperUsuário ainda.</string>

    <!--Logs-->
    <string name="log_data_none">Não há registros. Tente usar mais seus apps root.</string>
    <string name="log_data_magisk_none">Os registros do Magisk estão vazios, isso é estranho.</string>
    <string name="menuSaveLog">Salvar registros</string>
    <string name="menuClearLog">Limpar registros agora</string>
    <string name="logs_cleared">Registros limpo com sucesso</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Alvo UID: %1$d</string>
    <string name="target_pid">Alvo PID: %s</string>
    <string name="selinux_context">Contexto SELinux: %s</string>
    <string name="supp_group">Grupo suplementar: %s</string>

    <!--MagiskHide-->
    <string name="show_system_app">Mostrar apps do sistema</string>
    <string name="show_os_app">Mostrar apps do SO</string>
    <string name="hide_filter_hint">Filtrar pelo nome</string>
    <string name="hide_search">Pesquisar</string>

    <!--Module-->
    <string name="no_info_provided">(Nenhuma informação fornecida)</string>
    <string name="reboot_userspace">Reinicialização suave</string>
    <string name="reboot_recovery">Reiniciar em modo Recovery</string>
    <string name="reboot_bootloader">Reiniciar em modo Bootloader</string>
    <string name="reboot_download">Reiniciar em modo Download</string>
    <string name="reboot_edl">Reiniciar em modo EDL</string>
    <string name="reboot_safe_mode">Modo de segurança</string>
    <string name="module_version_author">%1$s por %2$s</string>
    <string name="module_state_remove">Remover</string>
    <string name="module_action">Ação</string>
    <string name="module_state_restore">Restaurar</string>
    <string name="module_action_install_external">Instalar a partir do armazenamento</string>
    <string name="update_available">Atualização disponível</string>
    <string name="suspend_text_riru">Módulo suspenso porque %1$s está ativado</string>
    <string name="suspend_text_zygisk">Módulo suspenso porque %1$s não está ativado</string>
    <string name="zygisk_module_unloaded">Modulo Zygisk não carregado devido a incompatibilidade</string>
    <string name="module_empty">Nenhum módulo instalado</string>
    <string name="confirm_install">Instalar módulo %1$s?</string>
    <string name="confirm_install_title">Confirmação de instalação</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Modo do tema</string>
    <string name="settings_dark_mode_message">Selecione o modo mais adequado para você!</string>
    <string name="settings_dark_mode_light">Sempre claro</string>
    <string name="settings_dark_mode_system">Seguir sistema</string>
    <string name="settings_dark_mode_dark">Sempre escuro</string>
    <string name="settings_download_path_title">Caminho para baixar</string>
    <string name="settings_download_path_message">Os arquivos serão salvos em %1$s</string>
    <string name="settings_hide_app_title">Ocultar app do Magisk</string>
    <string name="settings_hide_app_summary">Instala o app oculto com ID aleatório e nome personalizado</string>
    <string name="settings_restore_app_title">Restaurar app do Magisk</string>
    <string name="settings_restore_app_summary">Desoculta o app do Magisk e restaura o APK original</string>
    <string name="language">Idioma</string>
    <string name="system_default">(Padrão do sistema)</string>
    <string name="settings_check_update_title">Verificar por atualizações</string>
    <string name="settings_check_update_summary">Verifique automaticamente se há atualizações ao abrir o app</string>
    <string name="settings_update_channel_title">Canal de atualização</string>
    <string name="settings_update_stable">Estável</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_debug">Debug</string>
    <string name="settings_update_custom">Personalizado</string>
    <string name="settings_update_custom_msg">Insira um URL de canal personalizado</string>
    <string name="settings_zygisk_summary">Executa partes do Magisk no Zygote</string>
    <string name="settings_denylist_title">Aplicar lista de negação</string>
    <string name="settings_denylist_summary">Os processos na lista de negação terão todas as modificações do Magisk revertidas</string>
    <string name="settings_denylist_config_title">Configurar lista de negação</string>
    <string name="settings_denylist_config_summary">Selecione os processos a serem incluídos na lista de negação</string>
    <string name="settings_hosts_title">Hosts sem sistema</string>
    <string name="settings_hosts_summary">Suporte de hosts sem sistema para apps AdBlock</string>
    <string name="settings_hosts_toast">Adicionado módulo de hosts sem sistema</string>
    <string name="settings_app_name_hint">Novo nome</string>
    <string name="settings_app_name_helper">O app do Magisk será reinstalado com este nome</string>
    <string name="settings_app_name_error">Formato inválido</string>
    <string name="settings_su_app_adb">Apps e ADB</string>
    <string name="settings_su_app">Apenas apps</string>
    <string name="settings_su_adb">Apenas ADB</string>
    <string name="settings_su_disable">Desativado</string>
    <string name="settings_su_request_10">10 segundos</string>
    <string name="settings_su_request_15">15 segundos</string>
    <string name="settings_su_request_20">20 segundos</string>
    <string name="settings_su_request_30">30 segundos</string>
    <string name="settings_su_request_45">45 segundos</string>
    <string name="settings_su_request_60">60 segundos</string>
    <string name="superuser_access">Acesso de SuperUsuário</string>
    <string name="auto_response">Resposta automática</string>
    <string name="request_timeout">Tempo limite da solicitação</string>
    <string name="superuser_notification">Notificação de SuperUsuário</string>
    <string name="settings_su_reauth_title">Reautenticar após atualização</string>
    <string name="settings_su_reauth_summary">Solicite permissões de SuperUsuário novamente após atualizar os apps</string>
    <string name="settings_su_tapjack_title">Proteção contra atividades sobrepostas</string>
    <string name="settings_su_tapjack_summary">A caixa de diálogo do SuperUsuário não responderá à entrada enquanto estiver oculta por qualquer outra janela ou sobreposição</string>
    <string name="settings_su_auth_title">Autenticação de usuário</string>
    <string name="settings_su_auth_summary">Solicite autenticação de usuário durante solicitações de SuperUsuário</string>
    <string name="settings_su_auth_insecure">Nenhum método de autenticação está configurado no dispositivo</string>
    <string name="settings_su_restrict_title">Restringir recursos root</string>
    <string name="settings_su_restrict_summary">Restringirá novos apps de SuperUsuário por padrão. Aviso: isso quebrará a maioria dos apps. Não ative se você não souber o que está fazendo.</string>
    <string name="settings_customization">Personalizações</string>
    <string name="setting_add_shortcut_summary">Adicione um atalho na tela inicial, caso o nome e o ícone sejam difíceis de reconhecer logo após ocultar o app.</string>
    <string name="settings_doh_title">DNS sobre HTTPS</string>
    <string name="settings_doh_description">Solução alternativa para envenenamento de DNS em alguns países</string>
    <string name="settings_random_name_title">Randomizar nome de saída</string>
    <string name="settings_random_name_description">Randomize o nome do arquivo de saída de imagens corrigidas e arquivos tar (*.tar) para evitar a detecção</string>
    <string name="multiuser_mode">Modo multiusuário</string>
    <string name="settings_owner_only">Somente proprietário do dispositivo</string>
    <string name="settings_owner_manage">Gerenciado pelo proprietário do dispositivo</string>
    <string name="settings_user_independent">Independente do usuário</string>
    <string name="owner_only_summary">Somente o proprietário tem acesso root</string>
    <string name="owner_manage_summary">Somente o proprietário pode gerenciar o acesso root e receber pedidos de solicitação</string>
    <string name="user_independent_summary">Cada usuário tem suas próprias regras de root separadas</string>
    <string name="mount_namespace_mode">Montar namespace</string>
    <string name="settings_ns_global">Global</string>
    <string name="settings_ns_requester">Herdado</string>
    <string name="settings_ns_isolate">Individual</string>
    <string name="global_summary">Todas as sessões root usam o namespace de montagem global</string>
    <string name="requester_summary">As sessões root herdarão o namespace do solicitante</string>
    <string name="isolate_summary">Cada sessão root terá seu próprio namespace individual</string>

    <!--Notifications-->
    <string name="update_channel">Atualizações do Magisk</string>
    <string name="progress_channel">Notificações de progresso</string>
    <string name="updated_channel">Atualização concluída</string>
    <string name="download_complete">Download concluído</string>
    <string name="download_file_error">Erro ao baixar arquivo</string>
    <string name="magisk_update_title">Atualização do Magisk disponível!</string>
    <string name="updated_title">Magisk atualizado</string>
    <string name="updated_text">Toque para abrir o app</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Sim</string>
    <string name="no">Não</string>
    <string name="repo_install_title">Instalar %1$s %2$s(%3$d)</string>
    <string name="download">Baixar</string>
    <string name="reboot">Reiniciar</string>
    <string name="close">Fechar</string>
    <string name="release_notes">Notas da atualização</string>
    <string name="flashing">Flashando…</string>
    <string name="running">Executando…</string>
    <string name="done">Concluído!</string>
    <string name="done_action">Ação de execução de %1$s concluída</string>
    <string name="failure">Falhou!</string>
    <string name="hide_app_title">Ocultando o app do Magisk…</string>
    <string name="open_link_failed_toast">Nenhum app encontrado para abrir o link</string>
    <string name="complete_uninstall">Desinstalação completa</string>
    <string name="restore_img">Restaurar imagens</string>
    <string name="restore_img_msg">Restaurando…</string>
    <string name="restore_done">Restauração concluída!</string>
    <string name="restore_fail">O backup original não existe!</string>
    <string name="setup_fail">Falha na instalação</string>
    <string name="env_fix_title">Configuração adicional exigida</string>
    <string name="env_fix_msg">Seu dispositivo exige uma configuração adicional para o Magisk funcionar corretamente. Deseja continuar e reiniciar?</string>
    <string name="env_full_fix_msg">Seu dispositivo precisa refazer o flash do Magisk para funcionar corretamente. Por favor, reinstale o Magisk no app, o modo Recovery não pode obter as devidas informações do dispositivo.</string>
    <string name="setup_msg">Executando a configuração do ambiente…</string>
    <string name="unsupport_magisk_title">Versão do Magisk não suportada</string>
    <string name="unsupport_magisk_msg">Esta versão do app não suporta a versão do Magisk inferior a %1$s.\n\nO app irá se comportar como se nenhum Magisk estivesse sido instalado. Por favor, atualize o Magisk assim que possível.</string>
    <string name="unsupport_general_title">Estado anormal</string>
    <string name="unsupport_system_app_msg">Não há suporte para executar este app como um app do sistema. Por favor, reverta o app para um app de usuário.</string>
    <string name="unsupport_other_su_msg">Não foi possível detectar o binário \"su\" do Magisk. Por favor, remova qualquer outro root concorrente e/ou reinstale o Magisk.</string>
    <string name="unsupport_external_storage_msg">O app do Magisk está instalado no armazenamento externo. Por favor, mova o app para o armazenamento interno.</string>
    <string name="unsupport_nonroot_stub_msg">O app oculto do Magisk não pode continuar funcionando porque o root foi perdido. Por favor, restaure o APK original.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Conceda permissão de armazenamento para ativar esta funcionalidade</string>
    <string name="post_notifications_denied">Conceda permissão às notificações para ativar esta funcionalidade</string>
    <string name="install_unknown_denied">Permita a opção \"Instalar apps de fontes desconhecidas\" para ativar esta funcionalidade</string>
    <string name="add_shortcut_title">Adicionar atalho à tela inicial</string>
    <string name="add_shortcut_msg">Após ocultar o app do Magisk, seu nome e ícone ficarão difíceis de reconhecer. Deseja adicionar um atalho na tela inicial?</string>
    <string name="app_not_found">Nenhum app encontrado para realizar esta ação</string>
    <string name="reboot_apply_change">Reinicie para aplicar as mudanças</string>
    <string name="restore_app_confirmation">Isso irá restaurar o app oculto do Magisk de volta para o app original. Deseja realmente fazer isso?</string>

</resources>

```

`app/core/src/main/res/values-pt-rPT/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Módulos</string>
    <string name="superuser">SuperUsuário</string>
    <string name="logs">Registos</string>
    <string name="settings">Configurações</string>
    <string name="install">Instalar</string>
    <string name="section_home">Início</string>
    <string name="section_theme">Temas</string>
    <string name="denylist">Lista de negação</string>

    <!--Home-->
    <string name="no_connection">Nenhuma ligação disponível</string>
    <string name="app_changelog">Registo de alterações</string>
    <string name="loading">A carregar…</string>
    <string name="update">Atualizar</string>
    <string name="not_available">Não disponível</string>
    <string name="hide">Ocultar</string>
    <string name="home_package">Pacote</string>
    <string name="home_app_title">App</string>
    <string name="home_notice_content">Descarregue o Magisk APENAS na página oficial do GitHub. Os ficheiros de fontes desconhecidas podem ser maliciosos!</string>
    <string name="home_support_title">Apoie-nos</string>
    <string name="home_follow_title">Siga-nos</string>
    <string name="home_item_source">Fonte</string>
    <string name="home_support_content">Magisk sempre foi e sempre será, gratuito e de código aberto. No entanto, você pode ajudar-nos enviando uma pequena doação.</string>
    <string name="home_installed_version">Instalado</string>
    <string name="home_latest_version">Recente</string>
    <string name="invalid_update_channel">Canal de atualização inválido</string>
    <string name="uninstall_magisk_title">Desinstalar Magisk</string>
    <string name="uninstall_magisk_msg">Todos os módulos serão desativados/removidos!\nO root será removido!\nOs seus dados não encriptados devido à utilização do Magisk, serão re-encriptados!</string>

    <!--Install-->
    <string name="keep_force_encryption">Manter encriptação forçada</string>
    <string name="keep_dm_verity">Manter AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Modo Recovery</string>
    <string name="install_options_title">Opções</string>
    <string name="install_method_title">Método</string>
    <string name="install_next">Próximo</string>
    <string name="install_start">Vamos lá</string>
    <string name="manager_download_install">Toque para descarregar e instalar</string>
    <string name="direct_install">Instalação direta (recomendada)</string>
    <string name="install_inactive_slot">Instalar no slot inativo (após o OTA)</string>
    <string name="install_inactive_slot_msg">O seu dispositivo será FORÇADO a inicializar no slot inativo atual após um reinício!\nSó use esta opção após a conclusão do OTA.\nDeseja continuar?</string>
    <string name="setup_title">Configuração adicional</string>
    <string name="select_patch_file">Selecione e corrija um ficheiro</string>
    <string name="patch_file_msg">Selecione um ficheiro de imagem (*.img) ou um ficheiro tar (*.tar) ou um ficheiro payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">A reiniciar em 5 segundos…</string>
    <string name="flash_screen_title">Instalação</string>

    <!--Superuser-->
    <string name="su_request_title">Solicitação de SuperUsuário</string>
    <string name="touch_filtered_warning">Como um app está a ocultar um pedido de SuperUsuário, o Magisk não consegue verificar a sua resposta.</string>
    <string name="deny">Negar</string>
    <string name="prompt">Perguntar</string>
    <string name="restrict">Restringir</string>
    <string name="grant">Permitir</string>
    <string name="su_warning">Permite o acesso total ao seu dispositivo.\nNão o permita se não tiver a certeza do que está a fazer!</string>
    <string name="forever">Sempre</string>
    <string name="once">Uma vez</string>
    <string name="tenmin">10 mins</string>
    <string name="twentymin">20 mins</string>
    <string name="thirtymin">30 mins</string>
    <string name="sixtymin">60 mins</string>
    <string name="su_allow_toast">%1$s foi permitido o acesso de SuperUsuário</string>
    <string name="su_deny_toast">%1$s foi negado o acesso de SuperUsuário</string>
    <string name="su_snack_grant">Os acessos de SuperUsuário de %1$s foram permitidos</string>
    <string name="su_snack_deny">Os acessos de SuperUsuário de %1$s foram negados</string>
    <string name="su_snack_notif_on">As notificações de %1$s foram ativadas</string>
    <string name="su_snack_notif_off">As notificações de %1$s foram desativadas</string>
    <string name="su_snack_log_on">Os registos de %1$s foram ativados</string>
    <string name="su_snack_log_off">Os registos de %1$s foram desativados</string>
    <string name="su_revoke_title">Revogar?</string>
    <string name="su_revoke_msg">Confirme para revogar os acessos de SuperUsuário de %1$s</string>
    <string name="toast">Notificação (Pop-up)</string>
    <string name="none">Nenhum</string>
    <string name="superuser_toggle_notification">Notificações</string>
    <string name="superuser_toggle_revoke">Revogar</string>
    <string name="superuser_policy_none">Nenhum app solicitou permissão de SuperUsuário ainda.</string>

    <!--Logs-->
    <string name="log_data_none">Não há registos. Tente utilizar mais seus apps root.</string>
    <string name="log_data_magisk_none">Os registos do Magisk estão vazios, isto é estranho.</string>
    <string name="menuSaveLog">Salvar registos</string>
    <string name="menuClearLog">Limpar registos agora</string>
    <string name="logs_cleared">Registos limpo com sucesso</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Alvo UID: %1$d</string>
    <string name="target_pid">Alvo PID: %s</string>
    <string name="selinux_context">Contexto SELinux: %s</string>
    <string name="supp_group">Grupo suplementar: %s</string>

    <!--MagiskHide-->
    <string name="show_system_app">Mostrar apps do sistema</string>
    <string name="show_os_app">Mostrar apps do SO</string>
    <string name="hide_filter_hint">Filtrar pelo nome</string>
    <string name="hide_search">Pesquisar</string>

    <!--Module-->
    <string name="no_info_provided">(Nenhuma informação fornecida)</string>
    <string name="reboot_userspace">Reinicialização suave</string>
    <string name="reboot_recovery">Reiniciar em modo Recovery</string>
    <string name="reboot_bootloader">Reiniciar em modo Bootloader</string>
    <string name="reboot_download">Reiniciar em modo Download</string>
    <string name="reboot_edl">Reiniciar em modo EDL</string>
    <string name="reboot_safe_mode">Modo de segurança</string>
    <string name="module_version_author">%1$s por %2$s</string>
    <string name="module_state_remove">Remover</string>
    <string name="module_action">Ação</string>
    <string name="module_state_restore">Restaurar</string>
    <string name="module_action_install_external">Instalar a partir do armazenamento</string>
    <string name="update_available">Atualização disponível</string>
    <string name="suspend_text_riru">Módulo suspenso porque %1$s está ativado</string>
    <string name="suspend_text_zygisk">Módulo suspenso porque %1$s não está ativado</string>
    <string name="zygisk_module_unloaded">Modulo Zygisk não carregado devido a incompatibilidade</string>
    <string name="module_empty">Nenhum módulo instalado</string>
    <string name="confirm_install">Instalar módulo %1$s?</string>
    <string name="confirm_install_title">Confirmação de instalação</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Modo do tema</string>
    <string name="settings_dark_mode_message">Selecione o modo mais adequado para si!</string>
    <string name="settings_dark_mode_light">Sempre claro</string>
    <string name="settings_dark_mode_system">Seguir sistema</string>
    <string name="settings_dark_mode_dark">Sempre escuro</string>
    <string name="settings_download_path_title">Caminho para descarregar</string>
    <string name="settings_download_path_message">Os ficheiros serão salvos em %1$s</string>
    <string name="settings_hide_app_title">Ocultar app do Magisk</string>
    <string name="settings_hide_app_summary">Instala o app oculto com ID aleatório e nome personalizado</string>
    <string name="settings_restore_app_title">Restaurar app do Magisk</string>
    <string name="settings_restore_app_summary">Desoculta o app do Magisk e restaura o APK original</string>
    <string name="language">Idioma</string>
    <string name="system_default">(Predefinição do sistema)</string>
    <string name="settings_check_update_title">Verificar por atualizações</string>
    <string name="settings_check_update_summary">Verifique automaticamente se há atualizações ao abrir o app</string>
    <string name="settings_update_channel_title">Canal de atualização</string>
    <string name="settings_update_stable">Estável</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_debug">Debug</string>
    <string name="settings_update_custom">Personalizado</string>
    <string name="settings_update_custom_msg">Introduza um URL de canal personalizado</string>
    <string name="settings_zygisk_summary">Executa partes do Magisk no Zygote</string>
    <string name="settings_denylist_title">Aplicar lista de negação</string>
    <string name="settings_denylist_summary">Os processos na lista de negação terão todas as modificações do Magisk revertidas</string>
    <string name="settings_denylist_config_title">Configurar lista de negação</string>
    <string name="settings_denylist_config_summary">Selecione os processos a serem incluídos na lista de negação</string>
    <string name="settings_hosts_title">Hosts sem sistema</string>
    <string name="settings_hosts_summary">Suporte de hosts sem sistema para apps AdBlock</string>
    <string name="settings_hosts_toast">Adicionado módulo de hosts sem sistema</string>
    <string name="settings_app_name_hint">Novo nome</string>
    <string name="settings_app_name_helper">O app do Magisk será reinstalado com este nome</string>
    <string name="settings_app_name_error">Formato inválido</string>
    <string name="settings_su_app_adb">Apps e ADB</string>
    <string name="settings_su_app">Apenas apps</string>
    <string name="settings_su_adb">Apenas ADB</string>
    <string name="settings_su_disable">Desativado</string>
    <string name="settings_su_request_10">10 segundos</string>
    <string name="settings_su_request_15">15 segundos</string>
    <string name="settings_su_request_20">20 segundos</string>
    <string name="settings_su_request_30">30 segundos</string>
    <string name="settings_su_request_45">45 segundos</string>
    <string name="settings_su_request_60">60 segundos</string>
    <string name="superuser_access">Acesso de SuperUsuário</string>
    <string name="auto_response">Resposta automática</string>
    <string name="request_timeout">Tempo limite da solicitação</string>
    <string name="superuser_notification">Notificação de SuperUsuário</string>
    <string name="settings_su_reauth_title">Reautenticar após atualização</string>
    <string name="settings_su_reauth_summary">Solicite permissões de SuperUsuário novamente após atualizar os apps</string>
    <string name="settings_su_tapjack_title">Proteção contra atividades sobrepostas</string>
    <string name="settings_su_tapjack_summary">A caixa de diálogo do SuperUsuário não responderá à entrada enquanto estiver oculta por qualquer outra janela ou sobreposição</string>
    <string name="settings_su_auth_title">Autenticação de usuário</string>
    <string name="settings_su_auth_summary">Solicite autenticação de usuário durante pedidos de SuperUsuário</string>
    <string name="settings_su_auth_insecure">Nenhum método de autenticação está configurado no dispositivo</string>
    <string name="settings_su_restrict_title">Restringir recursos root</string>
    <string name="settings_su_restrict_summary">Restringirá novos apps de SuperUsuário por predefinição. Aviso: isto quebrará a maioria dos apps. Não ative se você não souber o que está a fazer.</string>
    <string name="settings_customization">Personalizações</string>
    <string name="setting_add_shortcut_summary">Adicione um atalho no ecrã inicial, caso o nome e o ícone sejam difíceis de reconhecer logo após ocultar o app.</string>
    <string name="settings_doh_title">DNS sobre HTTPS</string>
    <string name="settings_doh_description">Solução alternativa para envenenamento de DNS em alguns países</string>
    <string name="settings_random_name_title">Randomizar nome de saída</string>
    <string name="settings_random_name_description">Randomize o nome do ficheiro de saída de imagens corrigidas e ficheiros tar (*.tar) para evitar a deteção</string>
    <string name="multiuser_mode">Modo multiusuário</string>
    <string name="settings_owner_only">Somente proprietário do dispositivo</string>
    <string name="settings_owner_manage">Gerido pelo proprietário do dispositivo</string>
    <string name="settings_user_independent">Independente do usuário</string>
    <string name="owner_only_summary">Somente o proprietário tem acesso root</string>
    <string name="owner_manage_summary">Somente o proprietário pode gerir o acesso root e receber pedidos de solicitação</string>
    <string name="user_independent_summary">Cada usuário tem suas próprias regras de root separadas</string>
    <string name="mount_namespace_mode">Montar namespace</string>
    <string name="settings_ns_global">Global</string>
    <string name="settings_ns_requester">Herdado</string>
    <string name="settings_ns_isolate">Individual</string>
    <string name="global_summary">Todas as sessões root utilizam o namespace de montagem global</string>
    <string name="requester_summary">As sessões root herdarão o namespace do requerente</string>
    <string name="isolate_summary">Cada sessão root terá o seu próprio namespace individual</string>

    <!--Notifications-->
    <string name="update_channel">Atualizações do Magisk</string>
    <string name="progress_channel">Notificações de progresso</string>
    <string name="updated_channel">Atualização concluída</string>
    <string name="download_complete">Download concluído</string>
    <string name="download_file_error">Erro ao descarregar ficheiro</string>
    <string name="magisk_update_title">Atualização do Magisk disponível!</string>
    <string name="updated_title">Magisk atualizado</string>
    <string name="updated_text">Toque para abrir o app</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Sim</string>
    <string name="no">Não</string>
    <string name="repo_install_title">Instalar %1$s %2$s(%3$d)</string>
    <string name="download">Baixar</string>
    <string name="reboot">Reiniciar</string>
    <string name="close">Fechar</string>
    <string name="release_notes">Notas da atualização</string>
    <string name="flashing">Flashando…</string>
    <string name="running">A executar…</string>
    <string name="done">Concluído!</string>
    <string name="done_action">Ação de execução de %1$s concluída</string>
    <string name="failure">Falhou!</string>
    <string name="hide_app_title">A ocultar o app do Magisk…</string>
    <string name="open_link_failed_toast">Nenhum app encontrado para abrir o link</string>
    <string name="complete_uninstall">Desinstalação completa</string>
    <string name="restore_img">Restaurar imagens</string>
    <string name="restore_img_msg">A restaurar…</string>
    <string name="restore_done">Restauração concluída!</string>
    <string name="restore_fail">O backup original não existe!</string>
    <string name="setup_fail">Falha na instalação</string>
    <string name="env_fix_title">Configuração adicional exigida</string>
    <string name="env_fix_msg">Seu dispositivo exige uma configuração adicional para o Magisk funcionar corretamente. Deseja continuar e reiniciar?</string>
    <string name="env_full_fix_msg">O seu dispositivo precisa de refazer o flash do Magisk para funcionar corretamente. Por favor, reinstale o Magisk no app, o modo Recovery não consegue obter as devidas informações do dispositivo.</string>
    <string name="setup_msg">A executar a configuração do ambiente…</string>
    <string name="unsupport_magisk_title">Versão do Magisk não suportada</string>
    <string name="unsupport_magisk_msg">Esta versão do app não suporta versões do Magisk inferiores a %1$s.\n\nO app irá comportar-se como se nenhum Magisk estivesse instalado. Por favor, atualize o Magisk assim que possível.</string>
    <string name="unsupport_general_title">Estado anormal</string>
    <string name="unsupport_system_app_msg">Não há suporte para executar este app como um app do sistema. Por favor, reverta o app para um app de usuário.</string>
    <string name="unsupport_other_su_msg">Não foi possível detectar o binário \"su\" do Magisk. Por favor, remova qualquer outro root concorrente e/ou reinstale o Magisk.</string>
    <string name="unsupport_external_storage_msg">O app do Magisk está instalado no armazenamento externo. Por favor, mova o app para o armazenamento interno.</string>
    <string name="unsupport_nonroot_stub_msg">O app oculto do Magisk não pode continuar a funcionar porque o root foi perdido. Por favor, restaure o APK original.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Conceda permissão de armazenamento para ativar esta funcionalidade</string>
    <string name="post_notifications_denied">Conceda permissão às notificações para ativar esta funcionalidade</string>
    <string name="install_unknown_denied">Permita a opção \"Instalar apps de fontes desconhecidas\" para ativar esta funcionalidade</string>
    <string name="add_shortcut_title">Adicionar atalho ao ecrã inicial</string>
    <string name="add_shortcut_msg">Após ocultar o app do Magisk, o seu nome e ícone serão difíceis de reconhecer. Deseja adicionar um atalho no ecrã inicial?</string>
    <string name="app_not_found">Nenhum app encontrado para realizar esta ação</string>
    <string name="reboot_apply_change">Reinicie para aplicar as alterações</string>
    <string name="restore_app_confirmation">Isso irá restaurar o app oculto do Magisk de volta para o app original. Deseja realmente fazer isso?</string>

</resources>

```

`app/core/src/main/res/values-ro/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Module</string>
    <string name="superuser">Superutilizator</string>
    <string name="logs">Jurnale</string>
    <string name="settings">Setări</string>
    <string name="install">Instalează</string>
    <string name="section_home">Start</string>
    <string name="section_theme">Teme</string>
    <string name="denylist">Listă de refuzări</string>

    <!--Home-->
    <string name="no_connection">Nicio conexiune disponibilă</string>
    <string name="app_changelog">Jurnalul modificărilor</string>
    <string name="loading">Se încarcă…</string>
    <string name="update">Actualizează</string>
    <string name="not_available">Indisponibil</string>
    <string name="hide">Ascunde</string>
    <string name="home_package">Pachet</string>
    <string name="home_app_title">Aplicație</string>

    <string name="home_notice_content">Descarcă Magisk NUMAI de pe pagina oficială GitHub. Fișierele din surse necunoscute pot fi rău intenționate!</string>
    <string name="home_support_title">Sprijină-ne</string>
    <string name="home_follow_title">Urmărește-ne</string>
    <string name="home_item_source">Sursă</string>
    <string name="home_support_content">Magisk este și va fi întotdeauna gratuit și open-source. Cu toate acestea, ne poți arăta că îți pasă făcând o donație.</string>
    <string name="home_installed_version">Versiune instalată</string>
    <string name="home_latest_version">Ultima versiune</string>
    <string name="invalid_update_channel">Canal de actualizare nevalid</string>
    <string name="uninstall_magisk_title">Dezinstalează Magisk</string>
    <string name="uninstall_magisk_msg">Toate modulele vor fi dezactivate/eliminate!\nRootul va fi eliminat!\nOrice spațiu de stocare intern necriptat prin folosirea Magisk va fi recriptat!</string>

    <!--Install-->
    <string name="keep_force_encryption">Păstrează criptarea forțată</string>
    <string name="keep_dm_verity">Păstrează AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Mod de recuperare</string>
    <string name="install_options_title">Opțiuni</string>
    <string name="install_method_title">Metodă</string>
    <string name="install_next">Înainte</string>
    <string name="install_start">Să-i dăm drumul</string>
    <string name="manager_download_install">Apasă pentru a descărca și a instala</string>
    <string name="direct_install">Instalează direct (Recomandat)</string>
    <string name="install_inactive_slot">Instalează în slotul inactiv (După OTA)</string>
    <string name="install_inactive_slot_msg">Dispozitivul va fi FORȚAT să booteze în slotul actual inactiv după repornire!\nFolosește această opțiune numai după terminarea OTA.\nContinui?</string>
    <string name="setup_title">Configurare suplimentară</string>
    <string name="select_patch_file">Selectează și patchuiește un fișier</string>
    <string name="patch_file_msg">Selectează o imagine brută (*.img) sau un fișier tar ODIN (*.tar)</string>
    <string name="reboot_delay_toast">Repornire în 5 secunde…</string>
    <string name="flash_screen_title">Instalare</string>

    <!--Superuser-->
    <string name="su_request_title">Cerere de superutilizator</string>
    <string name="touch_filtered_warning">Deoarece o aplicație ascunde o cerere de superutilizator, Magisk nu îți poate verifica răspunsul</string>
    <string name="deny">Refuză</string>
    <string name="prompt">Solicită</string>
    <string name="grant">Acordă</string>
    <string name="su_warning">Acordă acces complet la dispozitivul tău.\nRefuză dacă nu ești sigur!</string>
    <string name="forever">Pentru totdeauna</string>
    <string name="once">O singură dată</string>
    <string name="tenmin">10 minute</string>
    <string name="twentymin">20 de minute</string>
    <string name="thirtymin">30 de minute</string>
    <string name="sixtymin">60 de minute</string>
    <string name="su_allow_toast">Aplicației %1$s i-au fost acordate drepturi de superutilizator</string>
    <string name="su_deny_toast">Aplicației %1$s i-au fost refuzate drepturi de superutilizator</string>
    <string name="su_snack_grant">Drepturile de superutilizator pentru %1$s au fost acordate</string>
    <string name="su_snack_deny">Drepturile de superutilizator pentru %1$s au fost refuzate</string>
    <string name="su_snack_notif_on">Notificările pentru %1$s au fost activate</string>
    <string name="su_snack_notif_off">Notificările pentru %1$s au fost dezactivate</string>
    <string name="su_snack_log_on">Jurnalizarea pentru %1$s a fost activată</string>
    <string name="su_snack_log_off">Jurnalizarea pentru %1$s a fost dezactivată</string>
    <string name="su_revoke_title">Revoci?</string>
    <string name="su_revoke_msg">Confirmă revocarea drepturilor de superutilizator pentru %1$s</string>
    <string name="toast">Mesaj</string>
    <string name="none">Niciuna</string>

    <string name="superuser_toggle_notification">Notificări</string>
    <string name="superuser_toggle_revoke">Revocă</string>
    <string name="superuser_policy_none">Nicio aplicație nu a cerut încă permisiunea de superutilizator.</string>

    <!--Logs-->
    <string name="log_data_none">Nu există jurnale, încearcă să folosești ceva mai mult aplicațiile care folosesc root</string>
    <string name="log_data_magisk_none">Jurnalele Magisk sunt goale, asta-i ciudat</string>
    <string name="menuSaveLog">Salvează jurnalul</string>
    <string name="menuClearLog">Golește jurnalul acum</string>
    <string name="logs_cleared">Jurnal golit cu succes</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">UID țintă: %1$d</string>
    <string name="target_pid">PID țintă pentru ns-ul montat: %s</string>
    <string name="selinux_context">Context SELinux: %s</string>
    <string name="supp_group">Grup suplimentar: %s</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Afișează aplicațiile de sistem</string>
    <string name="show_os_app">Afișează aplicațiile SO-ului</string>
    <string name="hide_filter_hint">Filtrează după nume</string>
    <string name="hide_search">Căutare</string>

    <!--Module-->
    <string name="no_info_provided">(Nu sunt furnizate informații)</string>
    <string name="reboot_userspace">Repornire software</string>
    <string name="reboot_recovery">Repornește în modul recovery</string>
    <string name="reboot_bootloader">Repornește în modul bootloader</string>
    <string name="reboot_download">Repornește în modul download</string>
    <string name="reboot_edl">Repornește în EDL</string>
    <string name="reboot_safe_mode">Mod sigur</string>
    <string name="module_version_author">%1$s de %2$s</string>
    <string name="module_state_remove">Elimină</string>
    <string name="module_state_restore">Restaurează</string>
    <string name="module_action_install_external">Instalează din spațiul de stocare</string>
    <string name="update_available">Actualizare disponibilă</string>
    <string name="suspend_text_riru">Modul suspendat deoarece %1$s este activat</string>
    <string name="suspend_text_zygisk">Modul suspendat deoarece %1$s nu este activat</string>
    <string name="zygisk_module_unloaded">Modulul Zygisk nu a fost încărcat din cauza incompatibilității</string>
    <string name="module_empty">Niciun modul instalat</string>
    <string name="confirm_install">Instalezi modulul %1$s?</string>
    <string name="confirm_install_title">Confirmare pentru instalare</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Mod pentru temă</string>
    <string name="settings_dark_mode_message">Selectează modul care ți se pliază cel mai bine stilului!</string>
    <string name="settings_dark_mode_light">Mereu deschis</string>
    <string name="settings_dark_mode_system">Urmează modul sistemului</string>
    <string name="settings_dark_mode_dark">Mereu întunecat</string>
    <string name="settings_download_path_title">Cale de descărcare</string>
    <string name="settings_download_path_message">Fișierele vor fi salvate în %1$s</string>
    <string name="settings_hide_app_title">Ascunde aplicația Magisk</string>
    <string name="settings_hide_app_summary">Instalează o aplicație proxy cu ID aleatoriu pentru pachet și etichetă personalizată pentru aplicație</string>
    <string name="settings_restore_app_title">Restaurează aplicația Magisk</string>
    <string name="settings_restore_app_summary">Dezvăluie aplicația și restaurează APK-ul original</string>
    <string name="language">Limbă</string>
    <string name="system_default">(Implicită a sistemului)</string>
    <string name="settings_check_update_title">Caută actualizări</string>
    <string name="settings_check_update_summary">Caută periodic actualizări în fundal</string>
    <string name="settings_update_channel_title">Canal de actualizare</string>
    <string name="settings_update_stable">Stabil</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Personalizat</string>
    <string name="settings_update_custom_msg">Inserează un URL pentru canal personalizat</string>
    <string name="settings_zygisk_summary">Rulează părți ale Magisk în daemonul zygote</string>
    <string name="settings_denylist_title">Impune lista de refuzări</string>
    <string name="settings_denylist_summary">Procesele din lista de refuzări vor avea toate modificările Magisk anulate</string>
    <string name="settings_denylist_config_title">Configurează lista de refuzări</string>
    <string name="settings_denylist_config_summary">Selectează procesele care vor fi incluse în lista de refuzări</string>
    <string name="settings_hosts_title">Fișier hosts în afara partiției system</string>
    <string name="settings_hosts_summary">Suport pentru fișierul hosts în afara partiției system, în cazul aplicațiilor care blochează reclame</string>
    <string name="settings_hosts_toast">Modulul pentru fișierul hosts în afara partiției system, adăugat</string>
    <string name="settings_app_name_hint">Nume nou</string>
    <string name="settings_app_name_helper">Aplicația va fi reîmpachetată cu acest nume</string>
    <string name="settings_app_name_error">Format nevalid</string>
    <string name="settings_su_app_adb">Aplicații și ADB</string>
    <string name="settings_su_app">Doar aplicații</string>
    <string name="settings_su_adb">Doar ADB</string>
    <string name="settings_su_disable">Dezactivat</string>
    <string name="settings_su_request_10">10 secunde</string>
    <string name="settings_su_request_15">15 secunde</string>
    <string name="settings_su_request_20">20 de secunde</string>
    <string name="settings_su_request_30">30 de secunde</string>
    <string name="settings_su_request_45">45 de secunde</string>
    <string name="settings_su_request_60">60 de secunde</string>
    <string name="superuser_access">Acces pentru superutilizator</string>
    <string name="auto_response">Răspuns automat</string>
    <string name="request_timeout">Expirare pentru cerere</string>
    <string name="superuser_notification">Notificare de superutilizator</string>
    <string name="settings_su_reauth_title">Reautentificare după actualizare</string>
    <string name="settings_su_reauth_summary">Cere din nou permisiunile de superutilizator după actualizarea aplicațiilor</string>
    <string name="settings_su_tapjack_title">Protecție față de tapjacking</string>
    <string name="settings_su_tapjack_summary">Caseta de dialog pentru solicitarea permisiunilor de superutilizator nu va răspunde la input cât timp este ascunsă de orice altă fereastră sau suprapunere</string>
    <string name="settings_su_auth_title">Autentificarea utilizatorului</string>
    <string name="settings_su_auth_summary">Cere autentificarea utilizatorului în timpul cererilor de superutilizator</string>
    <string name="settings_su_auth_insecure">Nu este configurată nicio metodă de autentificare pe dispozitiv</string>
    <string name="settings_customization">Personalizare</string>
    <string name="setting_add_shortcut_summary">Adaugă o comandă rapidă frumoasă în ecranul de pornire în cazul în care numele și pictograma sunt dificil de recunoscut după ascunderea aplicației</string>
    <string name="settings_doh_title">DNS prin HTTPS</string>
    <string name="settings_doh_description">Soluție ocolitoare pentru poisoningul DNS în anumite țări</string>
    <string name="settings_random_name_title">Randomizează numele ieșirii</string>
    <string name="settings_random_name_description">Randomizează numele fișierului de ieșire a imaginilor patchuite și a fișierelor tar pentru a împiedica detectarea</string>

    <string name="multiuser_mode">Mod de multiutilizator</string>
    <string name="settings_owner_only">Numai proprietarul dispozitivului</string>
    <string name="settings_owner_manage">Gestionat de proprietarul dispozitivului</string>
    <string name="settings_user_independent">Utilizator independent</string>
    <string name="owner_only_summary">Numai proprietarul are acces la root</string>
    <string name="owner_manage_summary">Numai proprietarul poate să gestioneze accesul la root și să primească cereri</string>
    <string name="user_independent_summary">Fiecare utilizator are propriile sale reguli separate pentru root</string>

    <string name="mount_namespace_mode">Mod de montare a spațiului de nume</string>
    <string name="settings_ns_global">Spațiu de nume global</string>
    <string name="settings_ns_requester">Spațiu de nume moștenit</string>
    <string name="settings_ns_isolate">Spațiu de nume izolat</string>
    <string name="global_summary">Toate sesiunile de root folosesc spațiul de nume global</string>
    <string name="requester_summary">Sesiunile de root vor moșteni spațiul de nume al solicitantului</string>
    <string name="isolate_summary">Fiecare sesiune de root va avea propriul spațiu de nume izolat</string>

    <!--Notifications-->
    <string name="update_channel">Actualizări Magisk</string>
    <string name="progress_channel">Notificări de progres</string>
    <string name="updated_channel">Actualizare finalizată</string>
    <string name="download_complete">Descărcare finalizată</string>
    <string name="download_file_error">Eroare la descărcarea fișierului</string>
    <string name="magisk_update_title">Actualizare Magisk disponibilă!</string>
    <string name="updated_title">Magisk actualizat</string>
    <string name="updated_text">Atinge pentru a deschide aplicația</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Da</string>
    <string name="no">Nu</string>
    <string name="repo_install_title">Instalează %1$s %2$s(%3$d)</string>
    <string name="download">Descarcă</string>
    <string name="reboot">Repornește</string>
    <string name="release_notes">Note privind versiunea</string>
    <string name="flashing">Se scrie în memoria flash…</string>
    <string name="done">Terminat!</string>
    <string name="failure">Eșec!</string>
    <string name="hide_app_title">Se ascunde aplicația Magisk…</string>
    <string name="open_link_failed_toast">Nu a fost găsită nicio aplicație pentru a deschide linkul</string>
    <string name="complete_uninstall">Finalizează dezinstalarea</string>
    <string name="restore_img">Restaurează imagini</string>
    <string name="restore_img_msg">Se restaurează…</string>
    <string name="restore_done">Restaurare terminată!</string>
    <string name="restore_fail">Nu există backup stock!</string>
    <string name="setup_fail">Configurare eșuată</string>
    <string name="env_fix_title">Necesită configurare suplimentară</string>
    <string name="env_fix_msg">Dispozitivul are nevoie de configurare suplimentară pentru ca Magisk să funcționeze corect. Vrei să continui și să repornești?</string>
    <string name="env_full_fix_msg">Dispozitivul are nevoie de rescrierea în memoria flash a Magisk pentru a funcționa corect. Te rugăm să reinstalezi Magisk în cadrul aplicației, modul de recuperare nu poate obține informații corecte despre dispozitiv.</string>
    <string name="setup_msg">Rulează configurarea mediului…</string>
    <string name="unsupport_magisk_title">Versiune Magisk nesuportată</string>
    <string name="unsupport_magisk_msg">Această versiune a aplicației nu suportă versiunile Magisk mai mici de %1$s.\n\nAplicația se va comporta ca și cum Magisk nu este instalat, te rugăm să actualizezi Magisk cât mai curând posibil.</string>
    <string name="unsupport_general_title">Stare anormală</string>
    <string name="unsupport_system_app_msg">Rularea acestei aplicații ca aplicație de sistem nu este suportată. Te rugăm să readuci aplicația într-o aplicație de utilizator.</string>
    <string name="unsupport_other_su_msg">A fost detectat un binar „su” care nu provine de la Magisk. Te rugăm să elimini orice soluție root concurentă și/sau să reinstalezi Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk este instalat în spațiul de stocare extern. Te rugăm să muți aplicația în spațiul de stocare intern.</string>
    <string name="unsupport_nonroot_stub_msg">Aplicația Magisk ascunsă nu poate continua să funcționeze deoarece rootul a fost pierdut. Te rugăm să restaurezi APK-ul original.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Acordă permisiunea de stocare pentru a activa această funcționalitate</string>
    <string name="post_notifications_denied">Acordă permisiunea de notificări pentru a activa această funcționalitate</string>
    <string name="install_unknown_denied">Permite „instalarea de aplicații necunoscute” pentru a activa această funcționalitate</string>
    <string name="add_shortcut_title">Adaugă comandă rapidă pe ecranul de pornire</string>
    <string name="add_shortcut_msg">După ascunderea acestei aplicații, numele și pictograma acesteia ar putea deveni dificil de recunoscut. Vrei să adaugi o comandă rapidă frumoasă pe ecranul de pornire?</string>
    <string name="app_not_found">Nu s-a găsit nicio aplicație care să gestioneze această acțiune</string>
    <string name="reboot_apply_change">Repornește pentru a aplica modificările</string>
    <string name="restore_app_confirmation">Acest lucru va restaura aplicația ascunsă în aplicația originală. Sigur vrei să faci asta?</string>

</resources>

```

`app/core/src/main/res/values-ru/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Модули</string>
    <string name="superuser">Superuser</string> <!--Do not translate! #6016-->
    <string name="logs">Логи</string>
    <string name="settings">Настройки</string>
    <string name="install">Установка</string>
    <string name="section_home">Главная</string>
    <string name="section_theme">Темы</string>
    <string name="denylist">DenyList</string>

    <!--Home-->
    <string name="no_connection">Нет подключения к сети</string>
    <string name="app_changelog">Изменения</string>
    <string name="loading">Загрузка…</string>
    <string name="update">Обновить</string>
    <string name="not_available">Не установлен</string>
    <string name="hide">Скрыть</string>
    <string name="home_package">Имя пакета</string>
    <string name="home_app_title">Приложение</string>

    <string name="home_notice_content">Скачивайте Magisk только из официального репозитория на GitHub. Файлы из других источников могут содержать вредоносный код!</string>
    <string name="home_support_title">Поддержите нас</string>
    <string name="home_follow_title">Подпишитесь</string>
    <string name="home_item_source">Исходный код</string>
    <string name="home_support_content">Magisk был и всегда будет бесплатным и открытым проектом. Однако Вы всегда можете поддержать нас, отправив небольшое пожертвование.</string>
    <string name="home_installed_version">Текущая версия</string>
    <string name="home_latest_version">Последняя версия</string>
    <string name="invalid_update_channel">Некорректный канал обновлений</string>
    <string name="uninstall_magisk_title">Удаление Magisk</string>
    <string name="uninstall_magisk_msg">Все модули будут отключены либо удалены!\nRoot-доступ будет недоступен!\nБудет активировано шифрование /data (если отключалось при установке)!</string>

    <!--Install-->
    <string name="keep_force_encryption">Не отключать шифрование /data</string>
    <string name="keep_dm_verity">Не отключать AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Патчить образ recovery вместо boot</string>
    <string name="install_options_title">Опции</string>
    <string name="install_method_title">Способ</string>
    <string name="install_next">Далее</string>
    <string name="install_start">Установить</string>
    <string name="manager_download_install">Нажмите для установки</string>
    <string name="direct_install">Автоматическая установка (рекомендуется)</string>
    <string name="install_inactive_slot">Установка во второй слот (после OTA-обновления)</string>
    <string name="install_inactive_slot_msg">Ваше устройство будет принудительно перезагружено в неактивный (противоположный) слот!\nИспользуйте эту опцию только при интеграции Magisk после OTA-обновления!\nПродолжить?</string>
    <string name="setup_title">Расширенная установка</string>
    <string name="select_patch_file">Пропатчить boot-образ</string>
    <string name="patch_file_msg">Выберите файл образа (*.img) или архив ODIN (*.tar)</string>
    <string name="reboot_delay_toast">Перезагрузка через 5 секунд…</string>
    <string name="flash_screen_title">Установка</string>

    <!--Superuser-->
    <string name="su_request_title">Запрос прав суперпользователя</string>
    <string name="touch_filtered_warning">Одно из приложений отображается поверх окна Magisk, выдача Root-прав недоступна</string>
    <string name="deny">Запретить</string>
    <string name="prompt">Запросить</string>
    <string name="grant">Разрешить</string>
    <string name="su_warning">Разрешить полный доступ к устройству?\nЕсли не уверены - отклоните данный запрос!</string>
    <string name="forever">Навсегда</string>
    <string name="once">Единожды</string>
    <string name="tenmin">10 мин.</string>
    <string name="twentymin">20 мин.</string>
    <string name="thirtymin">30 мин.</string>
    <string name="sixtymin">60 мин.</string>
    <string name="su_allow_toast">%1$s предоставлены права суперпользователя</string>
    <string name="su_deny_toast">%1$s отказано в правах суперпользователя</string>
    <string name="su_snack_grant">%1$s предоставлены права суперпользователя</string>
    <string name="su_snack_deny">%1$s отказано в правах суперпользователя</string>
    <string name="su_snack_notif_on">Уведомления для %1$s включены</string>
    <string name="su_snack_notif_off">Уведомления для %1$s отключены</string>
    <string name="su_snack_log_on">Логирование для %1$s включено</string>
    <string name="su_snack_log_off">Логирование для %1$s отключено</string>
    <string name="su_revoke_title">Сброс настроек прав</string>
    <string name="su_revoke_msg">Сбросить настройки для %1$s?</string>
    <string name="toast">Всплывающие уведомления</string>
    <string name="none">Отключены</string>

    <string name="superuser_toggle_notification">Уведомления</string>
    <string name="superuser_toggle_revoke">Отозвать</string>
    <string name="superuser_policy_none">Приложения ещё не запрашивали права суперпользователя</string>

    <!--Logs-->
    <string name="log_data_none">Логи отсутствуют</string>
    <string name="log_data_magisk_none">Логи отсутствуют</string>
    <string name="menuSaveLog">Сохранить логи</string>
    <string name="menuClearLog">Очистить логи</string>
    <string name="logs_cleared">Логи успешно очищены</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Целевой UID: %1$d</string>
    <string name="target_pid">Целевой PID пространства имён: %s</string>
    <string name="selinux_context">Контекст SELinux: %s</string>
    <string name="supp_group">Дополнительная группа: %s</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Системные приложения</string>
    <string name="show_os_app">Встроенные приложения</string>
    <string name="hide_filter_hint">Введите имя</string>
    <string name="hide_search">Поиск</string>

    <!--Module-->
    <string name="no_info_provided">(Нет информации)</string>
    <string name="reboot_userspace">Перезапуск оболочки</string>
    <string name="reboot_recovery">Перезагрузка в Recovery</string>
    <string name="reboot_bootloader">Перезагрузка в Bootloader</string>
    <string name="reboot_download">Перезагрузка в Download</string>
    <string name="reboot_edl">Перезагрузка в EDL</string>
    <string name="module_version_author">%1$s от %2$s</string>
    <string name="module_state_remove">Удалить</string>
    <string name="module_state_restore">Восстановить</string>
    <string name="module_action_install_external">Установить из хранилища</string>
    <string name="update_available">Доступно обновление</string>
    <string name="suspend_text_riru">Модуль отключён, поскольку активирован %1$s</string>
    <string name="suspend_text_zygisk">Модуль отключён, поскольку %1$s не активирован</string>
    <string name="zygisk_module_unloaded">Модуль Zygisk не запущен из-за несовместимости</string>
    <string name="module_empty">Модули не установлены</string>
    <string name="confirm_install">Установить модуль %1$s?</string>
    <string name="confirm_install_title">Подтверждение установки</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Оттенок</string>
    <string name="settings_dark_mode_message">Настройте оформление под себя!</string>
    <string name="settings_dark_mode_light">Всегда светлый</string>
    <string name="settings_dark_mode_system">Как в системе</string>
    <string name="settings_dark_mode_dark">Всегда тёмный</string>
    <string name="settings_download_path_title">Папка для загрузок</string>
    <string name="settings_download_path_message">Файлы будут загружаться в %1$s</string>
    <string name="settings_hide_app_title">Скрытие приложения Magisk</string>
    <string name="settings_hide_app_summary">Пересобрать приложение Magisk с другим названием и случайным именем пакета</string>
    <string name="settings_restore_app_title">Восстановление приложения Magisk</string>
    <string name="settings_restore_app_summary">Восстановить приложение Magisk к исходному состоянию</string>
    <string name="language">Язык</string>
    <string name="system_default">По умолчанию</string>
    <string name="settings_check_update_title">Проверка обновлений</string>
    <string name="settings_check_update_summary">Периодически проверять наличие обновлений в фоновом режиме</string>
    <string name="settings_update_channel_title">Источник обновлений</string>
    <string name="settings_update_stable">Стабильный канал</string>
    <string name="settings_update_beta">Beta канал</string>
    <string name="settings_update_custom">Сторонний канал</string>
    <string name="settings_update_custom_msg">Укажите ссылку</string>
    <string name="settings_zygisk_summary">Запускать компоненты Magisk в zygote процессе</string>
    <string name="settings_denylist_title">Активировать DenyList</string>
    <string name="settings_denylist_summary">Все изменения, внесённые Magisk-ом, будут скрыты от процессов, отмеченных в DenyList</string>
    <string name="settings_denylist_config_title">Настройка DenyList</string>
    <string name="settings_denylist_config_summary">Отметьте процессы для скрытия в DenyList</string>
    <string name="settings_hosts_title">Внесистемный hosts файл</string>
    <string name="settings_hosts_summary">Поддержка внесистемного hosts файла для приложений, блокирующих рекламу</string>
    <string name="settings_hosts_toast">Модуль для внесистемного hosts файла установлен</string>
    <string name="settings_app_name_hint">Введите имя</string>
    <string name="settings_app_name_helper">Приложение будет пересобрано с этим именем</string>
    <string name="settings_app_name_error">Некорректный формат</string>
    <string name="settings_su_app_adb">Приложения и ADB</string>
    <string name="settings_su_app">Только приложения</string>
    <string name="settings_su_adb">Только ADB</string>
    <string name="settings_su_disable">Отключён</string>
    <string name="settings_su_request_10">10 секунд</string>
    <string name="settings_su_request_15">15 секунд</string>
    <string name="settings_su_request_20">20 секунд</string>
    <string name="settings_su_request_30">30 секунд</string>
    <string name="settings_su_request_45">45 секунд</string>
    <string name="settings_su_request_60">60 секунд</string>
    <string name="superuser_access">Уровень доступа</string>
    <string name="auto_response">Автоматический ответ</string>
    <string name="request_timeout">Ожидание ответа</string>
    <string name="superuser_notification">Уведомления суперпользователя</string>
    <string name="settings_su_reauth_title">Повторная аутентификация</string>
    <string name="settings_su_reauth_summary">Повторный запрос прав суперпользователя после обновления приложений</string>
    <string name="settings_su_tapjack_title">Защита от перехвата нажатий</string>
    <string name="settings_su_auth_title">Аутентификация пользователя</string>
    <string name="settings_su_auth_summary">Требовать аутентификацию пользователя при запросах Superuser</string>
    <string name="settings_su_auth_insecure">На устройстве не настроен метод аутентификации</string>
    <string name="settings_su_tapjack_summary">Окно запроса прав суперпользователя будет неактивно пока активированы наложения экрана</string>
    <string name="settings_customization">Персонализация</string>
    <string name="setting_add_shortcut_summary">Добавить ярлык на рабочий стол для удобного восприятия приложения после его скрытия</string>
    <string name="settings_doh_title">DNS поверх HTTPS</string>
    <string name="settings_doh_description">Активировать DoH (используйте при проблемах с подключением к сети)</string>
    <string name="settings_random_name_title">Случайное имя образа</string>
    <string name="settings_random_name_description">Генерировать случайные имена для патченных образов и tar-файлов для предотвращения обнаружения</string>

    <string name="multiuser_mode">Многопользовательский режим</string>
    <string name="settings_owner_only">Только администратор</string>
    <string name="settings_owner_manage">Управление администратором</string>
    <string name="settings_user_independent">Правила пользователей</string>
    <string name="owner_only_summary">Только администратору доступен Root-доступ</string>
    <string name="owner_manage_summary">Администратор управляет Root-доступом пользователей и обрабатывает запросы</string>
    <string name="user_independent_summary">Каждый пользователь управляет собственными правилами Root-доступа</string>

    <string name="mount_namespace_mode">Настройка пространств имён</string>
    <string name="settings_ns_global">Общее пространство имён</string>
    <string name="settings_ns_requester">Наследуемое пространство имён</string>
    <string name="settings_ns_isolate">Изолированное пространство имён</string>
    <string name="global_summary">Сессии суперпользователя используют общее пространство имён</string>
    <string name="requester_summary">Сессии суперпользователя наследуют пространство имён запрашивающего</string>
    <string name="isolate_summary">Сессии суперпользователя используют изолированные пространства имён</string>

    <!--Notifications-->
    <string name="update_channel">Обновление Magisk</string>
    <string name="progress_channel">Уведомления о прогрессе</string>
    <string name="updated_channel">Обновление завершено</string>
    <string name="download_complete">Загрузка завершена</string>
    <string name="download_file_error">Ошибка загрузки файла</string>
    <string name="magisk_update_title">Доступно обновление Magisk!</string>
    <string name="updated_title">Magisk обновлён</string>
    <string name="updated_text">Нажмите, чтобы открыть</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Да</string>
    <string name="no">Нет</string>
    <string name="repo_install_title">Установка %1$s %2$s(%3$d)</string>
    <string name="download">Скачать</string>
    <string name="reboot">Перезагрузка</string>
    <string name="release_notes">О версии</string>
    <string name="flashing">Установка…</string>
    <string name="done">Завершено!</string>
    <string name="failure">Ошибка!</string>
    <string name="hide_app_title">Скрытие приложения Magisk…</string>
    <string name="open_link_failed_toast">Приложения для открытия ссылки не найдены</string>
    <string name="complete_uninstall">Полное удаление</string>
    <string name="restore_img">Восстановить разделы</string>
    <string name="restore_img_msg">Восстановление…</string>
    <string name="restore_done">Восстановление завершено!</string>
    <string name="restore_fail">Резервная копия отсутствует!</string>
    <string name="setup_fail">Ошибка установки</string>
    <string name="env_fix_title">Требуется расширенная установка</string>
    <string name="env_fix_msg">Требуется расширенная установка Magisk для корректной работы. Продолжить и выполнить перезагрузку?</string>
    <string name="env_full_fix_msg">Необходимо переустановить Magisk для корректной работы на вашем устройстве. Пожалуйста, переустановите Magisk в самом приложении (не из recovery).</string>
    <string name="setup_msg">Настройка рабочей среды…</string>
    <string name="unsupport_magisk_title">Неподдерживаемая версия Magisk</string>
    <string name="unsupport_magisk_msg">Эта версия приложения Magisk не поддерживает версию Magisk ниже %1$s.\n\nПриложение будет работать так, словно Magisk не установлен, пожалуйста, обновите Magisk как можно скорее.</string>
    <string name="unsupport_general_title">Неподдерживаемые условия</string>
    <string name="unsupport_system_app_msg">Запуск приложения в качестве системного невозможен. Пожалуйста, переустановите его как пользовательское.</string>
    <string name="unsupport_other_su_msg">Обнаружен неподдерживаемый бинарный файл \"su\". Пожалуйста, удалите сторонний провайдер Root-прав и/или переустановите Magisk.</string>
    <string name="unsupport_external_storage_msg">Приложение установлено во внешнее хранилище. Пожалуйста, переустановите его во внутреннее хранилище.</string>
    <string name="unsupport_nonroot_stub_msg">Пересобранное для скрытия приложение Magisk не может дальше работать, поскольку Root-права недоступны. Пожалуйста, восстановите приложение к исходному состоянию.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Предоставьте разрешение на доступ к хранилищу</string>
    <string name="post_notifications_denied">Предоставьте разрешение на отправку уведомлений</string>
    <string name="install_unknown_denied">Предоставьте разрешение на "Установку из неизвестных источников"</string>
    <string name="add_shortcut_title">Добавление ярлыка</string>
    <string name="add_shortcut_msg">После скрытия приложения Magisk его название и иконка могут быть неудобны для восприятия. Хотите создать ярлык на рабочем столе?</string>
    <string name="app_not_found">Приложение для обработки этого действия не найдено</string>
    <string name="reboot_apply_change">Перезагрузите устройство для применения изменений</string>
    <string name="restore_app_confirmation">Это действие восстановит пересобранное для скрытия приложение к исходному состоянию. Вы действительно хотите продолжить?</string>

</resources>

```

`app/core/src/main/res/values-sk/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Moduly</string>
    <string name="superuser">Superužívateľ</string>
    <string name="logs">Záznamy</string>
    <string name="settings">Nastavenia</string>
    <string name="install">Inštalovať</string>
    <string name="section_home">Domov</string>
    <string name="section_theme">Motívy</string>
    <string name="denylist">Zoznam zamietnutých</string>

    <!--Home-->
    <string name="no_connection">Žiadne pripojenie</string>
    <string name="app_changelog">Zoznam zmien</string>
    <string name="loading">Načítava sa…</string>
    <string name="update">Aktualizovať</string>
    <string name="not_available">N/A</string>
    <string name="hide">Skryť</string>
    <string name="home_package">Balíček</string>
    <string name="home_app_title">App</string>

    <string name="home_notice_content">Magisk sťahujte IBA z oficiálnej stránky na GitHube. Súbory z neznámych zdrojov môžu byť škodlivé!</string>
    <string name="home_support_title">Podporte nás</string>
    <string name="home_follow_title">Sledujte nás</string>
    <string name="home_item_source">Zdroj</string>
    <string name="home_support_content">Magisk je a vždy bude slobodný a s otvoreným kódom. Môžete nám však dať najavo, že vám na nás záleží, tým, že nám prispejete.</string>
    <string name="home_installed_version">Nainštalované</string>
    <string name="home_latest_version">Posledná</string>
    <string name="invalid_update_channel">Neplatný aktualizačný kanál</string>
    <string name="uninstall_magisk_title">Odinštalovať Magisk</string>
    <string name="uninstall_magisk_msg">Všetky moduly budú zakázané/odstránené!\nRoot bude odstránený!\nAkékoľvek interné úložisko nešifrované pomocou Magisku bude znovu zašifrované!</string>

    <!--Install-->
    <string name="keep_force_encryption">Ponechať vynútené šifrovanie</string>
    <string name="keep_dm_verity">Ponechať AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Režim Recovery</string>
    <string name="install_options_title">Možnosti</string>
    <string name="install_method_title">Metóda</string>
    <string name="install_next">Ďalej</string>
    <string name="install_start">Poďme na to</string>
    <string name="manager_download_install">Stlačte pre stiahnutie a inštaláciu</string>
    <string name="direct_install">Priama inštalácia (Odporúča sa)</string>
    <string name="install_inactive_slot">Inštalovať na neaktívny slot (Po OTA)</string>
    <string name="install_inactive_slot_msg">Vaše zariadenie bude po reštarte PRINÚTENÉ nabootovať do aktuálne neaktívneho slotu!\nTúto voľbu použite iba po skončení OTA.\nPokračovať?</string>
    <string name="setup_title">Ďalšie nastavenia</string>
    <string name="select_patch_file">Vybrať a zaplátať súbor</string>
    <string name="patch_file_msg">Vyberte raw súbor (*.img) alebo tar súbor ODIN (*.tar) alebo payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">Reštart o 5 sekúnd…</string>
    <string name="flash_screen_title">Inštalácia</string>

    <!--Superuser-->
    <string name="su_request_title">Požiadavka superužívateľa</string>
    <string name="touch_filtered_warning">Pretože aplikácia zakrýva požiadavku superužívateľa, Magisk nemôže overiť vašu odpoveď</string>
    <string name="deny">Zamietnuť</string>
    <string name="prompt">Výzva</string>
    <string name="grant">Udeliť</string>
    <string name="su_warning">Udelí úplný prístup k vášmu zariadeniu.\nZamietnite, ak si nie ste istý!</string>
    <string name="forever">Navždy</string>
    <string name="once">Raz</string>
    <string name="tenmin">10 min</string>
    <string name="twentymin">20 min</string>
    <string name="thirtymin">30 min</string>
    <string name="sixtymin">60 min</string>
    <string name="su_allow_toast">%1$s boli udelené práva Superužívateľa</string>
    <string name="su_deny_toast">%1$s boli zamietnuté práva Superužívateľa</string>
    <string name="su_snack_grant">Práva Superužívateľa pre %1$s sú udelené</string>
    <string name="su_snack_deny">Práva Superužívateľa pre %1$s sú zamietnuté</string>
    <string name="su_snack_notif_on">Upozornenia pre %1$s sú povolené</string>
    <string name="su_snack_notif_off">Upozornenia pre %1$s sú zakázané</string>
    <string name="su_snack_log_on">Zaznamenávanie %1$s je povolené</string>
    <string name="su_snack_log_off">Zaznamenávanie %1$s je zakázané</string>
    <string name="su_revoke_title">Zrušiť?</string>
    <string name="su_revoke_msg">Potvrdzujete zrušenie práv roota %1$s?</string>
    <string name="toast">Toast</string>
    <string name="none">Nič</string>

    <string name="superuser_toggle_notification">Upozornenia</string>
    <string name="superuser_toggle_revoke">Zrušiť</string>
    <string name="superuser_policy_none">Žiadna aplikácia zatiaľ nepožiadala o povolenie Superužívateľa.</string>

    <!--Logs-->
    <string name="log_data_none">Nie sú žiadne záznamy, skúste nejakú appku vyžadujúcu práva superpoužívateľa</string>
    <string name="log_data_magisk_none">Záznamy Magisku sú prázdne, to je divné</string>
    <string name="menuSaveLog">Uložiť záznam</string>
    <string name="menuClearLog">Odstrániť záznam</string>
    <string name="logs_cleared">Záznam úspešne odstránený</string>
    <string name="pid">PID:%1$d</string>
    <string name="target_uid">Cieľové UID: %1$d</string>
    <string name="target_pid">Pripojiť ns cieľový PID: %s</string>
    <string name="selinux_context">SELinux kontext: %s</string>
    <string name="supp_group">Doplnková skupina: %s</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Zobraziť systémové aplikácie</string>
    <string name="show_os_app">Zobraziť aplikácie OS</string>
    <string name="hide_filter_hint">Filtrovať podľa názvu</string>
    <string name="hide_search">Vyhľadávanie</string>

    <!--Module-->
    <string name="no_info_provided">(Nie sú k dispozícii žiadne informácie)</string>
    <string name="reboot_userspace">Softvérový reštart</string>
    <string name="reboot_recovery">Reštartovať do Recovery</string>
    <string name="reboot_bootloader">Reštartovať do Bootloader</string>
    <string name="reboot_download">Reštartovať do Download</string>
    <string name="reboot_edl">Reštartovať do EDL</string>
    <string name="reboot_safe_mode">Núdzový režim</string>
    <string name="module_version_author">%1$s od %2$s</string>
    <string name="module_state_remove">Odstrániť</string>
    <string name="module_state_restore">Obnoviť</string>
    <string name="module_action_install_external">Inštalácia z úložiska</string>
    <string name="update_available">Dostupná aktualizácia</string>
    <string name="suspend_text_riru">Modul bol pozastavený, lebo %1$s je povolené</string>
    <string name="suspend_text_zygisk">Modul bol pozastavený, lebo %1$s nie je povolené</string>
    <string name="zygisk_module_unloaded">Modul Zygisk sa nenačítal z dôvodu nekompatibility</string>
    <string name="module_empty">Nie je nainštalovaný žiadny modul</string>
    <string name="confirm_install">Nainštalovať modul %1$s?</string>
    <string name="confirm_install_title">Potvrdenie inštalácie</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Režim motívu</string>
    <string name="settings_dark_mode_message">Vyberte režim, ktorý najlepšie vyhovuje vášmu štýlu!</string>
    <string name="settings_dark_mode_light">Vždy svetlý</string>
    <string name="settings_dark_mode_system">Podľa systému</string>
    <string name="settings_dark_mode_dark">Vždy tmavý</string>
    <string name="settings_download_path_title">Cesta na sťahovanie</string>
    <string name="settings_download_path_message">Súbory budú uložené do %1$s</string>
    <string name="settings_hide_app_title">Skryť aplikáciu Magisk</string>
    <string name="settings_hide_app_summary">Inštalovať proxy aplikáciu s náhodným ID balíčka a vlastným názvom aplikácie</string>
    <string name="settings_restore_app_title">Obnoviť aplikáciu Magisk</string>
    <string name="settings_restore_app_summary">Odkryť aplikáciu a obnoviť pôvodný súbor APK</string>
    <string name="language">Jazyk</string>
    <string name="system_default">(Predvolený systémom)</string>
    <string name="settings_check_update_title">Kontrolovať aktualizácie</string>
    <string name="settings_check_update_summary">Aktualizácie sa budú pravidelne kontrolovať na pozadí</string>
    <string name="settings_update_channel_title">Aktualizačný kanál</string>
    <string name="settings_update_stable">Stabilný</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Vlastný kanál</string>
    <string name="settings_update_custom_msg">Zadajte vlastnú URL</string>
    <string name="settings_zygisk_summary">Spustiť časti Magisku v démonovi zygote</string>
    <string name="settings_denylist_title">Vynútiť zoznam zamietnutých</string>
    <string name="settings_denylist_summary">Pre procesy na zozname zamietnutých budú všetky úpravy Magiskom vrátené</string>
    <string name="settings_denylist_config_title">Nastavenie zoznamu zamietnutých</string>
    <string name="settings_denylist_config_summary">Vyberte procesy, ktoré majú byť zahrnuté do zoznamu blokovaných</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">Podpora pre aplikácie na blokovanie reklamy so systemless hosts</string>
    <string name="settings_hosts_toast">Pridaný modul systemless hosts</string>
    <string name="settings_app_name_hint">Nový názov</string>
    <string name="settings_app_name_helper">Aplikácia bude prebalená s týmto názvom</string>
    <string name="settings_app_name_error">Neplatný formát</string>
    <string name="settings_su_app_adb">Aplikácie a ADB</string>
    <string name="settings_su_app">Iba aplikácie</string>
    <string name="settings_su_adb">Iba ADB</string>
    <string name="settings_su_disable">Zakázané</string>
    <string name="settings_su_request_10">10 sekúnd</string>
    <string name="settings_su_request_15">15 sekúnd</string>
    <string name="settings_su_request_20">20 sekúnd</string>
    <string name="settings_su_request_30">30 sekúnd</string>
    <string name="settings_su_request_45">45 sekúnd</string>
    <string name="settings_su_request_60">60 sekúnd</string>
    <string name="superuser_access">Prístup Superužívateľa</string>
    <string name="auto_response">Automatická odpoveď</string>
    <string name="request_timeout">Časový limit na odpoveď</string>
    <string name="superuser_notification">Upozornenia Superužívateľa</string>
    <string name="settings_su_reauth_title">Overenie autentifikácie po upgrade</string>
    <string name="settings_su_reauth_summary">Opätovne vyzve na udelenie oprávnení Superužívateľa po upgrade aplikácie</string>
    <string name="settings_su_tapjack_title">Ochrana pred tapjackingom</string>
    <string name="settings_su_tapjack_summary">Dialógové okno superužívateľa nebude reagovať na zadanie, ak je zakryté alebo prekryté iným oknom</string>
    <string name="settings_su_auth_title">Overenie používateľa</string>
    <string name="settings_su_auth_summary">Žiadosť o overenie používateľa počas požiadaviek Superužívateľa</string>
    <string name="settings_su_auth_insecure">V zariadení nie je nakonfigurovaná žiadna metóda overovania</string>
    <string name="settings_customization">Prispôsobenie</string>
    <string name="setting_add_shortcut_summary">V prípade, že sa po skrytí apky názov a ikona ťažko rozpoznávajú, pridať na domovskú obrazovku odkaz</string>
    <string name="settings_doh_title">DNS over HTTPS</string>
    <string name="settings_doh_description">Riešenie otravy DNS v niektorých krajinách</string>
    <string name="settings_random_name_title">Náhodný názov výstupu</string>
    <string name="settings_random_name_description">Na zabránenie detekcie sa vygeneruje náhodný názov výstupných zaplátaných obrazov a súborov tar</string>

    <string name="multiuser_mode">Režim viacerých používateľov</string>
    <string name="settings_owner_only">Iba majiteľ zariadenia</string>
    <string name="settings_owner_manage">Spravuje majiteľ zariadenia</string>
    <string name="settings_user_independent">Nezávisí od používateľa</string>
    <string name="owner_only_summary">Root prístup má iba majiteľ zariadenia</string>
    <string name="owner_manage_summary">Iba majiteľ zariadenia môže spravovať prístup root a prijímať žiadosti</string>
    <string name="user_independent_summary">Každý používateľ má vlastné pravidlá pre root</string>

    <string name="mount_namespace_mode">Režim Mount namespace</string>
    <string name="settings_ns_global">Globálny namespace</string>
    <string name="settings_ns_requester">Zdedený namespace</string>
    <string name="settings_ns_isolate">Izolovaný namespace</string>
    <string name="global_summary">Všetky relácie root použijú globálny mount namespace</string>
    <string name="requester_summary">Relácie root zdedia namespace od žiadateľa</string>
    <string name="isolate_summary">Každá relácia root bude mať vlastný izolovaný namespace</string>

    <!--Notifications-->
    <string name="update_channel">Aktualizácie Magisku</string>
    <string name="progress_channel">Upozornenia o priebehu</string>
    <string name="updated_channel">Aktualizácia dokončená</string>
    <string name="download_complete">Sťahovanie ukončené</string>
    <string name="download_file_error">Chyba sťahovania súboru</string>
    <string name="magisk_update_title">Je dostupná aktualizácia Magisku!</string>
    <string name="updated_title">Magisk aktualizovaný</string>
    <string name="updated_text">Ťuknutím otvoríte apku</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Áno</string>
    <string name="no">Nie</string>
    <string name="repo_install_title">Nainštalovať %1$s %2$s(%3$d)</string>
    <string name="download">Stiahnuť</string>
    <string name="reboot">Reštartovať</string>
    <string name="release_notes">Poznámky k vydaniu</string>
    <string name="flashing">Flashovanie...</string>
    <string name="done">Hotovo!</string>
    <string name="failure">Zlyhalo!</string>
    <string name="hide_app_title">Skrýva sa aplikácia Magisk…</string>
    <string name="open_link_failed_toast">Nepodarilo sa nájsť vhodnú aplikáciu na otvorenie odkazu</string>
    <string name="complete_uninstall">Úplne odinštalovať</string>
    <string name="restore_img">Obnoviť obrazy</string>
    <string name="restore_img_msg">Obnovovanie…</string>
    <string name="restore_done">Obnovovanie ukončené!</string>
    <string name="restore_fail">Stock záloha neexistuje!</string>
    <string name="setup_fail">Nastavenie zlyhalo</string>
    <string name="env_fix_title">Vyžaduje sa ďalšie nastavenie</string>
    <string name="env_fix_msg">Aby Magisk fungoval správne, vaše zariadenie potrebuje ďalšie nastavenie. Chcete pokračovať a reštartovať?</string>
    <string name="env_full_fix_msg">Vaše zariadenie potrebuje na správne fungovanie reflash Magisku. Preinštalujte Magisk priamo z aplikácie, režim obnovenia nemôže získať správne informácie o zariadení.</string>
    <string name="setup_msg">Nastavenie je spustené…</string>
    <string name="unsupport_magisk_title">Nepodporovaná verzia Magisku</string>
    <string name="unsupport_magisk_msg">Táto verzia aplikácie nepodporuje Magisk s verziou nižšou ako %1$s.\n\nAplikácia sa bude správať, akoby Magisk nebol nainštalový, aktualizujte Magisk čo najskôr.</string>
    <string name="unsupport_general_title">Abnormálny stav</string>
    <string name="unsupport_system_app_msg">Spustenie tejto apky ako systémovej nie je podporované. Preveďte apku na používateľskú.</string>
    <string name="unsupport_other_su_msg">Bol nájdený binárny súbor \"su\", ktorý nie je pre Magisk. Odstráňte, prosím, konkurenčné root spôsoby a/alebo preinštalujte Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk je nainštalovaný na externom úložisku. Prosím, presuňte apku na interné úložisko.</string>
    <string name="unsupport_nonroot_stub_msg">Skrytá aplikácia Magisk nemôže pokračovať v práci, lebo root sa stratil. Prosím, obnovte ju z pôvodného súboru APK.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Udeľte povolenie na zapnutie tejto funkcie</string>
    <string name="post_notifications_denied">Udeľte upozorneniam povolenie na zapnutie tejto funkcie</string>
    <string name="install_unknown_denied">Povoľte "inštaláciu neznámych aplikácii" na povolenie tejto funkcie</string>
    <string name="add_shortcut_title">Pridať odkaz na domovskú obrazovku</string>
    <string name="add_shortcut_msg">Po skrytí tejto aplikácie sa jej názov a ikona môžu stať ťažko rozoznateľnými. Chcete pridať krajší odkaz na domovskú obrazovku?</string>
    <string name="app_not_found">Nenašla sa žiadna aplikácia, ktorá dokáže spracovať túto akciu</string>
    <string name="reboot_apply_change">Reštartovať počítač, aby sa použili zmeny</string>
    <string name="restore_app_confirmation">Týmto obnovíte skrytú aplikáciu späť na pôvodnú aplikáciu. Naozaj to chcete urobiť?</string>

</resources>

```

`app/core/src/main/res/values-sq/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Modulet</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Regjistrimet</string>
    <string name="settings">Parametrat</string>
    <string name="install">Instalo</string>
    <string name="section_home">Shtëpia</string>
    <string name="section_theme">Temat</string>
    <string name="denylist">Lista e ndaluar</string>

    <!--Home-->
    <string name="no_connection">Nuk ka lidhje të disponueshme</string>
    <string name="app_changelog">Shënimet e ndryshimeve</string>
    <string name="loading">Duke u ngarkuar…</string>
    <string name="update">Përditëso</string>
    <string name="not_available">N/A</string>
    <string name="hide">Fshih</string>
    <string name="home_package">Paketa</string>
    <string name="home_app_title">Aplikacioni</string>
    <string name="home_notice_content">Shkarkoni Magisk VETËM nga faqja zyrtare në GitHub. Skedarët nga burime të panjohura mund të jenë të dëmshëm!</string>
    <string name="home_support_title">Na mbështetni</string>
    <string name="home_follow_title">Na ndiqni</string>
    <string name="home_item_source">Burimi</string>
    <string name="home_support_content">Magisk është dhe do të mbetet gjithmonë falas dhe me burim të hapur. Megjithatë, mund të na mbështesni duke bërë një donacion.</string>
    <string name="home_installed_version">Instaluar</string>
    <string name="home_latest_version">Më i fundit</string>
    <string name="invalid_update_channel">Kanal i pavlefshëm për përditësime</string>
    <string name="uninstall_magisk_title">Çinstalo Magisk</string>
    <string name="uninstall_magisk_msg">Të gjitha modulet do të çaktivizohen/hiqen!
Root-i do të hiqet!
Çdo memorie e brendshme që është çenkriptuar përmes Magisk do të rikriptohet!</string>

    <!--Install-->
    <string name="keep_force_encryption">Ruaj enkriptimin e detyruar</string>
    <string name="keep_dm_verity">Ruaj AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Mënyra Recovery</string>
    <string name="install_options_title">Opsionet</string>
    <string name="install_method_title">Metoda</string>
    <string name="install_next">Vazhdoni</string>
    <string name="install_start">Le të fillojmë</string>
    <string name="manager_download_install">Shtypni për të shkarkuar dhe instaluar</string>
    <string name="direct_install">Instalim i drejtpërdrejtë (Rekomandohet)</string>
    <string name="install_inactive_slot">Instalo në slot-in joaktiv (Pas OTA)</string>
    <string name="install_inactive_slot_msg">Pajisja juaj do të detyrohet të niset në slot-in joaktiv pas rinisjes!
Përdorni këtë opsion vetëm pasi OTA të ketë përfunduar.
Të vazhdoj?</string>
    <string name="setup_title">Konfigurim shtesë</string>
    <string name="select_patch_file">Zgjidh dhe përpuno një skedar</string>
    <string name="patch_file_msg">Zgjidh një imazh të papërpunuar (*.img) ose një skedar ODIN (*.tar) ose një payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">Rinisja pas 5 sekondash…</string>
    <string name="flash_screen_title">Instalimi</string>

    <!--Superuser-->
    <string name="su_request_title">Kërkesë Superuser</string>
    <string name="touch_filtered_warning">Për shkak se një aplikacion po mbivendos kërkesën Superuser, Magisk nuk mund të verifikojë përgjigjen tuaj.</string>
    <string name="deny">Refuzo</string>
    <string name="prompt">Pyete</string>
    <string name="restrict">Kufizo</string>
    <string name="grant">Lejo</string>
    <string name="su_warning">Jep akses të plotë në pajisjen tuaj.
Refuzoni nëse nuk jeni të sigurt!</string>
    <string name="forever">Përgjithmonë</string>
    <string name="once">Një herë</string>
    <string name="tenmin">10 minuta</string>
    <string name="twentymin">20 minuta</string>
    <string name="thirtymin">30 minuta</string>
    <string name="sixtymin">60 minuta</string>
    <string name="su_allow_toast">%1$s mori të drejtat Superuser</string>
    <string name="su_deny_toast">%1$s u refuzua të drejtat Superuser</string>
    <string name="su_snack_grant">%1$s mori të drejtat Superuser</string>
    <string name="su_snack_deny">%1$s u refuzua të drejtat Superuser</string>
    <string name="su_snack_notif_on">Njoftimet për %1$s u aktivizuan</string>
    <string name="su_snack_notif_off">Njoftimet për %1$s u çaktivizuan</string>
    <string name="su_snack_log_on">Regjistrimi për %1$s u aktivizua</string>
    <string name="su_snack_log_off">Regjistrimi për %1$s u çaktivizua</string>
    <string name="su_revoke_title">Të hiqen?</string>
    <string name="su_revoke_msg">Konfirmoni heqjen e të drejtave Superuser për %1$s</string>
    <string name="toast">Njoftim</string>
    <string name="none">Asnjë</string>
    <string name="superuser_toggle_notification">Njoftimet</string>
    <string name="superuser_toggle_revoke">Hiq</string>
    <string name="superuser_policy_none">Asnjë aplikacion nuk ka kërkuar ende leje Superuser.</string>

    <!--Logs-->
    <string name="log_data_none">Nuk keni regjistrime. Provojeni të përdorni më shumë aplikacionet me root.</string>
    <string name="log_data_magisk_none">Regjistrimet e Magisk janë bosh — çuditërisht.</string>
    <string name="menuSaveLog">Ruaj regjistrimin</string>
    <string name="menuClearLog">Pastro regjistrimin tani</string>
    <string name="logs_cleared">Regjistrimet u pastruan me sukses</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">UID i synuar: %1$d</string>
    <string name="target_pid">PID i synuar: %s</string>
    <string name="selinux_context">Konteksti SELinux: %s</string>
    <string name="supp_group">Grupi shtesë: %s</string>

    <!--MagiskHide-->
    <string name="show_system_app">Shfaq aplikacionet e sistemit</string>
    <string name="show_os_app">Shfaq aplikacionet e OS</string>
    <string name="hide_filter_hint">Filtro sipas emrit</string>
    <string name="hide_search">Kërko</string>

    <!--Module-->
    <string name="no_info_provided">(Nuk u dha informacion)</string>
    <string name="reboot_userspace">Rinisje Normale</string>
    <string name="reboot_recovery">Rinis në Recovery</string>
    <string name="reboot_bootloader">Rinis në Bootloader</string>
    <string name="reboot_download">Rinis në Download</string>
    <string name="reboot_edl">Rinis në EDL</string>
    <string name="reboot_safe_mode">Mënyra e sigurt</string>
    <string name="module_version_author">%1$s nga %2$s</string>
    <string name="module_state_remove">Hiqe</string>
    <string name="module_action">Veprimi</string>
    <string name="module_state_restore">Rikthe</string>
    <string name="module_action_install_external">Instalo nga memoria</string>
    <string name="update_available">Përditësim i disponueshëm</string>
    <string name="suspend_text_riru">Moduli u pezullua sepse %1$s është aktiv</string>
    <string name="suspend_text_zygisk">Moduli u pezullua sepse %1$s nuk është aktiv</string>
    <string name="zygisk_module_unloaded">Moduli Zygisk nuk u ngarkua për shkak të mospërputhjes</string>
    <string name="module_empty">Nuk ka module të instaluara</string>
    <string name="confirm_install">Të instalohet moduli %1$s?</string>
    <string name="confirm_install_title">Konfirmim instalimi</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Mënyra e temës</string>
    <string name="settings_dark_mode_message">Zgjidh mënyrën që i përshtatet më shumë stilit tënd!</string>
    <string name="settings_dark_mode_light">Gjithmonë e ndritshme</string>
    <string name="settings_dark_mode_system">Ndiq sistemin</string>
    <string name="settings_dark_mode_dark">Gjithmonë e errët</string>
    <string name="settings_download_path_title">Rruga e shkarkimit</string>
    <string name="settings_download_path_message">Skedarët do të ruhen në %1$s</string>
    <string name="settings_hide_app_title">Fshi aplikacionin Magisk</string>
    <string name="settings_hide_app_summary">Instalo një aplikacion proxy me një ID pakete të rastësishme dhe emër të personalizuar</string>
    <string name="settings_restore_app_title">Rikthe aplikacionin Magisk</string>
    <string name="settings_restore_app_summary">Zbulo aplikacionin dhe rikthe APK-në origjinale</string>
    <string name="language">Gjuha</string>
    <string name="system_default">(Parazgjedhja e sistemit)</string>
    <string name="settings_check_update_title">Kontrollo për përditësime</string>
    <string name="settings_check_update_summary">Kontrollo periodikisht për përditësimet në sfond</string>
    <string name="settings_update_channel_title">Kanal për përditësime</string>
    <string name="settings_update_stable">Stable</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_debug">Debug</string>
    <string name="settings_update_custom">Custom</string>
    <string name="settings_update_custom_msg">Fut një URL të personalizuar të kanalit</string>
    <string name="settings_zygisk_summary">Ekzekuto pjesë të Magisk në demonin Zygote</string>
    <string name="settings_denylist_title">Zbato listën e ndaluar</string>
    <string name="settings_denylist_summary">Proceset në listën e ndaluar do të rikthehen pa modifikimet e Magisk</string>
    <string name="settings_denylist_config_title">Konfiguro listën e ndaluar</string>
    <string name="settings_denylist_config_summary">Zgjidh proceset që do të përfshihen në listën e ndaluar</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">Mbështetje për systemless hosts për aplikacionet që bllokojnë reklamat</string>
    <string name="settings_hosts_toast">U shtua moduli systemless hosts</string>
    <string name="settings_app_name_hint">Emër i ri</string>
    <string name="settings_app_name_helper">Aplikacioni do të ripaketizohet me këtë emër</string>
    <string name="settings_app_name_error">Format i pavlefshëm</string>
    <string name="settings_su_app_adb">Aplikacionet dhe ADB</string>
    <string name="settings_su_app">Vetëm aplikacionet</string>
    <string name="settings_su_adb">Vetëm ADB</string>
    <string name="settings_su_disable">Çaktivizuar</string>
    <string name="settings_su_request_10">10 sekonda</string>
    <string name="settings_su_request_15">15 sekonda</string>
    <string name="settings_su_request_20">20 sekonda</string>
    <string name="settings_su_request_30">30 sekonda</string>
    <string name="settings_su_request_45">45 sekonda</string>
    <string name="settings_su_request_60">60 sekonda</string>
    <string name="superuser_access">Akses Superuser</string>
    <string name="auto_response">Përgjigje automatike</string>
    <string name="request_timeout">Koha e skadimit të kërkesës</string>
    <string name="superuser_notification">Njoftimi Superuser</string>
    <string name="settings_su_reauth_title">Riautentifikimi pas përditësimit</string>
    <string name="settings_su_reauth_summary">Kërko sërish lejet Superuser pas përditësimit të aplikacioneve</string>
    <string name="settings_su_tapjack_title">Mbrojtje nga mbivendosja e klikimeve</string>
    <string name="settings_su_tapjack_summary">Dritarja e kërkesës Superuser nuk do të pranojë input kur është e mbuluar nga ndonjë dritare tjetër</string>
    <string name="settings_su_auth_title">Autentifikimi i përdoruesit</string>
    <string name="settings_su_auth_summary">Kërko autentifikim të përdoruesit gjatë kërkesave Superuser</string>
    <string name="settings_su_auth_insecure">Nuk ka asnjë metodë autentifikimi të konfiguruar në pajisje</string>
    <string name="settings_su_restrict_title">Kufizo aftësitë e root</string>
    <string name="settings_su_restrict_summary">Do të kufizojë aplikacionet e reja Superuser si parazgjedhje. Kujdes: kjo mund të prishë shumicën e aplikacioneve. Mos e aktivizoni nëse nuk dini çfarë bëni.</string>
    <string name="settings_customization">Personalizimi</string>
    <string name="setting_add_shortcut_summary">Shto një shkurtore në ekranin bazë nëse emri/ikona bëhen të vështira për t’u dalluar pas fshehjes së aplikacionit</string>
    <string name="settings_doh_title">DNS mbi HTTPS</string>
    <string name="settings_doh_description">Zgjidhje për helmimin e DNS në disa shtete</string>
    <string name="settings_random_name_title">Emër i rastësishëm</string>
    <string name="settings_random_name_description">Rastësizo emrin e skedarit të daljes për imazhet e patch-uara dhe skedarët tar për të shmangur detektimin</string>
    <string name="multiuser_mode">Mënyra multi-përdorues</string>
    <string name="settings_owner_only">Vetëm pronari i pajisjes</string>
    <string name="settings_owner_manage">Menaxhuar nga pronari</string>
    <string name="settings_user_independent">I pavarur për përdoruesit</string>
    <string name="owner_only_summary">Vetëm pronari ka akses root</string>
    <string name="owner_manage_summary">Vetëm pronari mund të menaxhojë aksesin root dhe të marrë kërkesat</string>
    <string name="user_independent_summary">Çdo përdorues ka rregullat e veta të root</string>
    <string name="mount_namespace_mode">Mënyra e mount namespace</string>
    <string name="settings_ns_global">Namespace global</string>
    <string name="settings_ns_requester">Trashëgo namespace</string>
    <string name="settings_ns_isolate">Namespace i izoluar</string>
    <string name="global_summary">Të gjitha sesionet root përdorin namespace global</string>
    <string name="requester_summary">Sesioni root trashëgon namespace-in e kërkuesit</string>
    <string name="isolate_summary">Çdo sesion root do të ketë namespace të izoluar</string>

    <!--Notifications-->
    <string name="update_channel">Përditësimet e Magisk</string>
    <string name="progress_channel">Njoftimet e progresit</string>
    <string name="updated_channel">Përditësimi përfundoi</string>
    <string name="download_complete">Shkarkimi përfundoi</string>
    <string name="download_file_error">Gabim gjatë shkarkimit të skedarit</string>
    <string name="magisk_update_title">Përditësim i ri i Magisk!</string>
    <string name="updated_title">Magisk u përditësua</string>
    <string name="updated_text">Shtypni për të hapur aplikacionin</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Po</string>
    <string name="no">Jo</string>
    <string name="repo_install_title">Instalo %1$s %2$s(%3$d)</string>
    <string name="download">Shkarko</string>
    <string name="reboot">Rinise</string>
    <string name="close">Mbyll</string>
    <string name="release_notes">Shënimet e versionit</string>
    <string name="flashing">Duke flashuar..</string>
    <string name="running">Duke u ekzekutuar..</string>
    <string name="done">U krye!</string>
    <string name="done_action">Veprimi i %1$s u krye</string>
    <string name="failure">Dështoi!</string>
    <string name="hide_app_title">Duke fshehur aplikacionin Magisk..</string>
    <string name="open_link_failed_toast">Nuk u gjet asnjë aplikacion për të hapur lidhjen</string>
    <string name="complete_uninstall">Çinstalim i plotë</string>
    <string name="restore_img">Rikthe imazhet</string>
    <string name="restore_img_msg">Duke rikthyer..</string>
    <string name="restore_done">Rikthimi u krye!</string>
    <string name="restore_fail">Backup-i origjinal nuk ekziston!</string>
    <string name="setup_fail">Konfigurimi dështoi</string>
    <string name="env_fix_title">Kërkohet konfigurim shtesë</string>
    <string name="env_fix_msg">Pajisja ka nevojë për konfigurim shtesë që Magisk të funksionojë si duhet. Dëshironi të vazhdoni dhe të rinisni pajisjen?</string>
    <string name="env_full_fix_msg">Pajisja ka nevojë për ri-flash të Magisk për të funksionuar saktë. Ju lutemi riinstaloni Magisk brenda aplikacionit; Recovery nuk mund të marrë informacionet e sakta të pajisjes.</string>
    <string name="setup_msg">Duke ekzekutuar konfigurimin e mjedisit..</string>
    <string name="unsupport_magisk_title">Version i Magisk i pambështetur</string>
    <string name="unsupport_magisk_msg">Ky version i aplikacionit nuk mbështet versione të Magisk më të ulëta se %1$s.

Aplikacioni do të sillet sikur Magisk nuk është i instaluar. Ju lutemi përditësoni Magisk sa më shpejt të jetë e mundur.</string>
    <string name="unsupport_general_title">Gjendje jonormale</string>
    <string name="unsupport_system_app_msg">Ekzekutimi i këtij aplikacioni si aplikacion sistemi nuk mbështetet. Ju lutemi kthejeni në aplikacion përdoruesi.</string>
    <string name="unsupport_other_su_msg">Është zbuluar një binar "su" që nuk është nga Magisk. Ju lutemi hiqni çdo zgjidhje tjetër root dhe/ose riinstaloni Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk është instaluar në memorien e jashtme. Lëvizni aplikacionin në memorien e brendshme.</string>
    <string name="unsupport_nonroot_stub_msg">Aplikacioni i fshehur i Magisk nuk mund të vazhdojë të funksionojë sepse root u humb. Ju lutemi riktheni APK-në origjinale.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Jepni lejen e magazinimit për të aktivizuar këtë funksion</string>
    <string name="post_notifications_denied">Jepni lejen e njoftimeve për të aktivizuar këtë funksion</string>
    <string name="install_unknown_denied">Lejoni "Instalo aplikacione të panjohura" për të aktivizuar këtë funksion</string>
    <string name="add_shortcut_title">Shto shkurtore në ekranin bazë</string>
    <string name="add_shortcut_msg">Pas fshehjes së aplikacionit, emri dhe ikona mund të jenë të vështira për t’u njohur. Dëshironi të shtoni një shkurtore të bukur në ekranin bazë?</string>
    <string name="app_not_found">Nuk u gjet aplikacion për të kryer këtë veprim</string>
    <string name="reboot_apply_change">Rinisni për të aplikuar ndryshimet</string>
    <string name="restore_app_confirmation">Kjo do të rikthejë aplikacionin e fshehur në gjendjen origjinale. Jeni të sigurt që dëshironi ta bëni këtë?</string>

</resources>

```

`app/core/src/main/res/values-sr/strings.xml`:

```xml
<resources>
    <!--Author: Radoš Milićev (https://github.com/rammba)-->

    <!--Sections-->
    <string name="modules">Модули</string>
    <string name="superuser">Супер-корисник</string>
    <string name="logs">Логови</string>
    <string name="settings">Подешавања</string>
    <string name="install">Инсталација</string>
    <string name="section_home">Почетно</string>
    <string name="section_theme">Теме</string>
    <string name="denylist">Листа забрана</string>

    <!--Home-->
    <string name="no_connection">Недоступна конекција</string>
    <string name="app_changelog">Промене у апликацији</string>
    <string name="loading">Учитавање…</string>
    <string name="update">Ажурирање</string>
    <string name="not_available">N/A</string>
    <string name="hide">Сакриј</string>
    <string name="home_package">Пакет</string>
    <string name="home_app_title">Апл.</string>
    <string name="home_notice_content">Преузмите Magisk САМО са званичне GitHub странице. Фајлови из непознатих извора могу бити малициозни!</string>
    <string name="home_support_title">Подржите нас</string>
    <string name="home_follow_title">Запратите нас</string>
    <string name="home_item_source">Извор</string>
    <string name="home_support_content">Magisk јесте и увек ће бити бесплатан и open source. Међутим, можете показати да вам је стало својом донацијом.</string>
    <string name="home_installed_version">Инсталирано</string>
    <string name="home_latest_version">Најновије</string>
    <string name="invalid_update_channel">Невалидан канал ажурирања</string>
    <string name="uninstall_magisk_title">Деинсталирај Magisk</string>
    <string name="uninstall_magisk_msg">Сви модули ће бити онемогућени/уклоњени!\nКорен ће бити уклоњен!\nСвако неенкриптовано интерно складиште ће употребом Magisk-а бити поново енкриптовано!</string>

    <!--Install-->
    <string name="keep_force_encryption">Задржи форсирану енкрипцију</string>
    <string name="keep_dm_verity">Задржи AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Режим опоравка</string>
    <string name="install_options_title">Опције</string>
    <string name="install_method_title">Метод</string>
    <string name="install_next">Наредно</string>
    <string name="install_start">Почнимо</string>
    <string name="manager_download_install">Притисни да преузмеш и инсталираш</string>
    <string name="direct_install">Директна инсталација (Препоручено)</string>
    <string name="install_inactive_slot">Инсталација на неактиван слот (Након OTA)</string>
    <string name="install_inactive_slot_msg">Ваш уређај ће бити ФОРСИРАН да се покрене на тренутно неактивном слоту након поновног покретања!\nКористите опцију само кад се OTA заврши.\nНастави?</string>
    <string name="setup_title">Додатне поставке</string>
    <string name="select_patch_file">Изаберите фајл</string>
    <string name="patch_file_msg">Изаберите слику (*.img) или ODIN tarfile (*.tar) или payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">Поново покретање за 5 секунди…</string>
    <string name="flash_screen_title">Инсталација</string>

    <!--Superuser-->
    <string name="su_request_title">Супер-кориснички захтев</string>
    <string name="touch_filtered_warning">Magisk не може да верификује ваш одговор, јер апликација прикрива супер-кориснички захтев.</string>
    <string name="deny">Забрани</string>
    <string name="prompt">Захтев</string>
    <string name="restrict">Ограничи</string>
    <string name="grant">Дозволи</string>
    <string name="su_warning">Пружа потпун приступ вашем уређају.\nЗабраните ако нисте сигурни!</string>
    <string name="forever">Заувек</string>
    <string name="once">Једном</string>
    <string name="tenmin">10 мин</string>
    <string name="twentymin">20 мин</string>
    <string name="thirtymin">30 мин</string>
    <string name="sixtymin">60 мин</string>
    <string name="su_allow_toast">%1$s је добио права на супер-корисника</string>
    <string name="su_deny_toast">%1$s није добио права на супер-корисника</string>
    <string name="su_snack_grant">Супер-корисничка права од %1$s су пружена</string>
    <string name="su_snack_deny">Супер-корисничка права од %1$s су одбијена</string>
    <string name="su_snack_notif_on">Нотификације од %1$s су омогућене</string>
    <string name="su_snack_notif_off">Нотификације од %1$s су онемогућене</string>
    <string name="su_snack_log_on">Логовање за %1$s је омогућено</string>
    <string name="su_snack_log_off">Логовање за %1$s је онемогућено</string>
    <string name="su_revoke_title">Опозови?</string>
    <string name="su_revoke_msg">Потврди да опозовеш права на супер-корисника од %1$s?</string>
    <string name="toast">Toast</string>
    <string name="none">Ништа</string>
    <string name="superuser_toggle_notification">Нотификације</string>
    <string name="superuser_toggle_revoke">Опозови</string>
    <string name="superuser_policy_none">Ниједна апликација није тражила пермисије за супер-корисника још увек.</string>

    <!--Logs-->
    <string name="log_data_none">Немате логова. Покушајте користити коренске апликације више.</string>
    <string name="log_data_magisk_none">Magisk логови су празни, то је чудно.</string>
    <string name="menuSaveLog">Сачувај лог</string>
    <string name="menuClearLog">Уклони лог</string>
    <string name="logs_cleared">Лог успешно уклоњен</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Циљани UID: %1$d</string>
    <string name="target_pid">Циљани PID: %s</string>
    <string name="selinux_context">SELinux контекст: %s</string>
    <string name="supp_group">Допунска група: %s</string>

    <!--MagiskHide-->
    <string name="show_system_app">Прикажи системске апл.</string>
    <string name="show_os_app">Прикажи апл. ОС-а</string>
    <string name="hide_filter_hint">Филтрирај по имену</string>
    <string name="hide_search">Претрага</string>

    <!--Module-->
    <string name="no_info_provided">(Без информација)</string>
    <string name="reboot_userspace">Лако поново покретање</string>
    <string name="reboot_recovery">Поново покрени за опоравак</string>
    <string name="reboot_bootloader">Поново покрени за bootloader</string>
    <string name="reboot_download">Поново покрени за преузимање</string>
    <string name="reboot_edl">Поново покрени за EDL</string>
    <string name="reboot_safe_mode">Сигуран мод</string>
    <string name="module_version_author">%1$s од %2$s</string>
    <string name="module_state_remove">Уклони</string>
    <string name="module_action">Акција</string>
    <string name="module_state_restore">Поврати</string>
    <string name="module_action_install_external">Инсталирај из складишта</string>
    <string name="update_available">Ажурирање доступно</string>
    <string name="suspend_text_riru">Модул је суспендован јер је %1$s омогућено</string>
    <string name="suspend_text_zygisk">Модул је суспендован јер %1$s није омогућено</string>
    <string name="zygisk_module_unloaded">Zygisk модул није учитан због некомпатибилности</string>
    <string name="module_empty">Ниједан модул није инсталиран</string>
    <string name="confirm_install">Инсталирај модул %1$s?</string>
    <string name="confirm_install_title">Потврда инсталације</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Тема</string>
    <string name="settings_dark_mode_message">Изаберите тему која вам највише одговара!</string>
    <string name="settings_dark_mode_light">Увек светло</string>
    <string name="settings_dark_mode_system">Прати систем</string>
    <string name="settings_dark_mode_dark">Увек тамно</string>
    <string name="settings_download_path_title">Путања за преузимање</string>
    <string name="settings_download_path_message">Фајлови ће бити сачувани на %1$s</string>
    <string name="settings_hide_app_title">Сакриј Magisk апл.</string>
    <string name="settings_hide_app_summary">Инсталирај proxy апликацију са насумичним ID-јем пакета и прилагођеном лабелом</string>
    <string name="settings_restore_app_title">Поврати Magisk апл.</string>
    <string name="settings_restore_app_summary">Откриј апл. и поврати оригинални APK</string>
    <string name="language">Језик</string>
    <string name="system_default">(Подразумевано системски)</string>
    <string name="settings_check_update_title">Провери ажурирања</string>
    <string name="settings_check_update_summary">Периодично провери ажурирања у позадини</string>
    <string name="settings_update_channel_title">Канал ажурирања</string>
    <string name="settings_update_stable">Стабилно</string>
    <string name="settings_update_beta">Бета</string>
    <string name="settings_update_debug">Debug</string>
    <string name="settings_update_custom">Прилагођено</string>
    <string name="settings_update_custom_msg">Унеси прилагођени URL канала</string>
    <string name="settings_zygisk_summary">Покрени делове Magisk-а у Zygote daemon-у</string>
    <string name="settings_denylist_title">Спроведи листу забрана</string>
    <string name="settings_denylist_summary">Процеси на листи забрана ће повратити све Magisk измене</string>
    <string name="settings_denylist_config_title">Конфигуриши листу забрана</string>
    <string name="settings_denylist_config_summary">Изабери процесе који ће бити на листи забрана</string>
    <string name="settings_hosts_title">Безсистемски домаћини (hosts)</string>
    <string name="settings_hosts_summary">Подршка безсистемских домаћина за апликације блокирања реклама</string>
    <string name="settings_hosts_toast">Модул безсистемских домаћина додат</string>
    <string name="settings_app_name_hint">Ново име</string>
    <string name="settings_app_name_helper">Апл. ће бити спакована под овим именом</string>
    <string name="settings_app_name_error">Невалидан формат</string>
    <string name="settings_su_app_adb">Апликације и ADB</string>
    <string name="settings_su_app">Само апликације</string>
    <string name="settings_su_adb">Само ADB</string>
    <string name="settings_su_disable">Онемогућено</string>
    <string name="settings_su_request_10">10 секунди</string>
    <string name="settings_su_request_15">15 секунди</string>
    <string name="settings_su_request_20">20 секунди</string>
    <string name="settings_su_request_30">30 секунди</string>
    <string name="settings_su_request_45">45 секунди</string>
    <string name="settings_su_request_60">60 секунди</string>
    <string name="superuser_access">Приступ супер-корисника</string>
    <string name="auto_response">Аутоматски одговор</string>
    <string name="request_timeout">Истек захтева</string>
    <string name="superuser_notification">Нотификације супер-корисника</string>
    <string name="settings_su_reauth_title">Поново одобри након ажурирања</string>
    <string name="settings_su_reauth_summary">Поново тражи пермисије супер-корисника након ажурирања апликација</string>
    <string name="settings_su_tapjack_title">Заштита од tapjacking-а</string>
    <string name="settings_su_tapjack_summary">Prompt дијалог супер-корисника неће реаговати док је прикривен другим прозором или overlay-ем</string>
    <string name="settings_su_auth_title">Аутентификација корисника</string>
    <string name="settings_su_auth_summary">Тражи аутентификацију корисника током захтева супер-корисника</string>
    <string name="settings_su_auth_insecure">Ниједан метод аутентификације није подешен на уређају</string>
    <string name="settings_su_restrict_title">Ограничи коренске способности</string>
    <string name="settings_su_restrict_summary">Подразумевано ограничава апл. супер-корисника. Упозорење: ово ће већину апликација скршити. Не омогућавај, осим ако знаш шта радиш.</string>
    <string name="settings_customization">Прилагођавање</string>
    <string name="setting_add_shortcut_summary">Додај лепу пречицу на почетни екран у случају да се име и иконица не препознају лако након скривања апликације</string>
    <string name="settings_doh_title">DNS преко HTTPS-а</string>
    <string name="settings_doh_description">Заобилазно решење DNS тровања у неким нацијама</string>
    <string name="settings_random_name_title">Насумично име на излазу</string>
    <string name="settings_random_name_description">Насумично име излазног фајла слика и tar фајлова ради спречавања детекције</string>
    <string name="multiuser_mode">Вишекориснички режим</string>
    <string name="settings_owner_only">Само власник уређаја</string>
    <string name="settings_owner_manage">Одређено од стране власника</string>
    <string name="settings_user_independent">Независно од корисника</string>
    <string name="owner_only_summary">Само власник има приступ корену</string>
    <string name="owner_manage_summary">Само власник може да приступа корену и да прима захтеве за њега</string>
    <string name="user_independent_summary">Сваки корисник има своја правила корена</string>
    <string name="mount_namespace_mode">Mount режим namespace-а</string>
    <string name="settings_ns_global">Глобални namespace</string>
    <string name="settings_ns_requester">Наслеђени namespace</string>
    <string name="settings_ns_isolate">Изоловани namespace</string>
    <string name="global_summary">Све коренске сесије користе глобални mount namespace</string>
    <string name="requester_summary">Коренске сесије ће наследити namespace од подносиоца захтева</string>
    <string name="isolate_summary">Свака коренска сесија ће имати свој изоловани namespace</string>

    <!--Notifications-->
    <string name="update_channel">Ажурирања Magisk-а</string>
    <string name="progress_channel">Нотификације о прогресу</string>
    <string name="updated_channel">Ажурирање завршено</string>
    <string name="download_complete">Преузимање завршено</string>
    <string name="download_file_error">Грешка при преузимању фајла</string>
    <string name="magisk_update_title">Ажурирање Magisk-а доступно!</string>
    <string name="updated_title">Magisk је ажуриран</string>
    <string name="updated_text">Кликни да отвориш апликацију</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Да</string>
    <string name="no">Не</string>
    <string name="repo_install_title">Инсталирај %1$s %2$s(%3$d)</string>
    <string name="download">Преузми</string>
    <string name="reboot">Поново покрени</string>
    <string name="close">Затвори</string>
    <string name="release_notes">Release notes</string>
    <string name="flashing">Флешовање…</string>
    <string name="running">Покретање…</string>
    <string name="done">Завршено!</string>
    <string name="done_action">Покретање акције %1$s завршено</string>
    <string name="failure">Неуспешно!</string>
    <string name="hide_app_title">Скривање Magisk апликације…</string>
    <string name="open_link_failed_toast">Није пронађена апликација за отварање линка</string>
    <string name="complete_uninstall">Комплетна деинсталација</string>
    <string name="restore_img">Поврати слике</string>
    <string name="restore_img_msg">Повратак…</string>
    <string name="restore_done">Повратак успешан!</string>
    <string name="restore_fail">Фабрички бекап не постоји!</string>
    <string name="setup_fail">Неуспешна поставка</string>
    <string name="env_fix_title">Потребно додатно подешавање</string>
    <string name="env_fix_msg">Ваш уређај захтева додатно подешавање да би Magisk радио како треба. Да ли желите наставити и покренути поново?</string>
    <string name="env_full_fix_msg">Ваш уређај захтева поновно флешовање да би Magisk радио како треба. Реинсталирајте Magisk кроз апликацију, режим опоравка не може добити тачне информације о уређају.</string>
    <string name="setup_msg">Покретање подешавања окружења…</string>
    <string name="unsupport_magisk_title">Неподржана верзија Magisk-а</string>
    <string name="unsupport_magisk_msg">Ова верзија апликације не подржава Magisk верзије мање од %1$s.\n\nАпликација ће се понашати као да Magisk није инсталиран. Молимо ажурирајте Magisk што пре.</string>
    <string name="unsupport_general_title">Ненормално стање</string>
    <string name="unsupport_system_app_msg">Покретање апликације као системске није подржано. Молимо поставите апликацију да буде корисничка.</string>
    <string name="unsupport_other_su_msg">Детектован \"su\" binary који није Magisk-ов. Молимо уклоните конкурентно коренско решење и/или реинсталирајте Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk је инсталиран на екстерно складиште. Молимо померите апл. у интерно складиште.</string>
    <string name="unsupport_nonroot_stub_msg">Скривена Magisk апликација не може наставити са радом јер је корен изгубљен. Молимо повратите оригинални APK.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Дозволите пермисију за складиште да бисте омогућили ову функционалност</string>
    <string name="post_notifications_denied">Дозволите пермисију за нотификације да бисте омогућили ову функционалност</string>
    <string name="install_unknown_denied">Дозволите \"инсталирање непознатих апликација\" да бисте омогућили ову функционалност</string>
    <string name="add_shortcut_title">Додај пречицу на почетни екран</string>
    <string name="add_shortcut_msg">Након скривања апликације, њено име и иконицу ћете тешко препознати. Желите ли додати лепу пречицу на почетни екран?</string>
    <string name="app_not_found">Није пронађена апликација за ову акцију</string>
    <string name="reboot_apply_change">Поново покрени да примениш измене</string>
    <string name="restore_app_confirmation">Ово ће вратити скривену апликацију на оригиналну. Да ли стварно то желите?</string>

</resources>

```

`app/core/src/main/res/values-sv/strings.xml`:

```xml
<resources>
	<!--Sections-->
    <string name="modules">Moduler</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Logg</string>
    <string name="settings">Inställningar</string>
    <string name="install">Installera</string>
    <string name="section_home">Hem</string>
    <string name="section_theme">Tema</string>

    <!--Home-->
    <string name="no_connection">Ingen anslutning tillgänglig</string>
    <string name="app_changelog">Ändringslogg</string>
    <string name="loading">Laddar…</string>
    <string name="update">Uppdatera</string>
    <string name="not_available">Inte tillgänglig</string>
    <string name="hide">Dölj</string>
    <string name="home_package">Paket</string>
    <string name="home_app_title">App</string>

    <string name="home_notice_content">Ladda endast ned magisk från den officiella GitHub-sidan. Filer från okända källor kan innehålla skadlig kod!</string>
    <string name="home_support_title">Stöd oss</string>
    <string name="home_item_source">Källa</string>
    <string name="home_support_content">Magisk är och kommer alltid att vara gratis med öppen källkod. Du kan dock visa din uppskattning genom att skicka en donation</string>
    <string name="home_installed_version">Installerad</string>
    <string name="home_latest_version">Senaste</string>
    <string name="invalid_update_channel">Ogiltig uppdateringskanal</string>
    <string name="uninstall_magisk_title">Avinstallera Magisk</string>
    <string name="uninstall_magisk_msg">Alla moduler kommer att bli inaktiverade/borttagna!\nRoot kommer också att avinstalleras!\nDin data kan komma att krypteras om den inte är det redan!</string>

    <!--Install-->
    <string name="keep_force_encryption">Bibehåll tvingad kryptering</string>
    <string name="keep_dm_verity">Bibehåll AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Recovery-läge</string>
    <string name="install_options_title">Alternativ</string>
    <string name="install_method_title">Metod</string>
    <string name="install_next">Nästa</string>
    <string name="install_start">Nu kör vi!</string>
    <string name="manager_download_install">Tryck för att ladda ned och installera install</string>
    <string name="direct_install">Direkt installation (Rekommenderas)</string>
    <string name="install_inactive_slot">Installera till inaktiv Slot (Efter OTA)</string>
    <string name="install_inactive_slot_msg">Din enhet kommer att bli TVINGAD att starta till den nuvarande inaktiva slot efter omstart!\nAnvänd endast detta alternativ efter att en OTA uppdatering är utförd.\nFortsätt??</string>
    <string name="setup_title">Ytterligare installation</string>
    <string name="select_patch_file">Välj och patcha en fil</string>
    <string name="patch_file_msg">Välj en rå avbildningsfil (*.img) eller en ODIN tar-fil (*.tar)</string>
    <string name="reboot_delay_toast">Omstart om 5 sekunder…</string>
    <string name="flash_screen_title">Installation</string>

    <!--Superuser-->
    <string name="su_request_title">Superuser-förfrågan</string>
    <string name="touch_filtered_warning">Eftersom en app döljer, eller ritar över en begäran om superuser, så kan inte Magisk verifera ditt svar</string>
    <string name="deny">Neka</string>
    <string name="prompt">Fråga</string>
    <string name="grant">Bevilja</string>
    <string name="su_warning">Beviljar full tillgång till din enhet.\nNeka om du är osäker!</string>
    <string name="forever">För alltid</string>
    <string name="once">En gång</string>
    <string name="tenmin">10 minuter</string>
    <string name="twentymin">20 minuter</string>
    <string name="thirtymin">30 minuter</string>
    <string name="sixtymin">60 minuter</string>
    <string name="su_allow_toast">%1$s beviljades Superuser-rättigheter</string>
    <string name="su_deny_toast">%1$s nekades Superuser-rättigheter</string>
    <string name="su_snack_grant">Superuser-rättigheter till %1$s är beviljade</string>
    <string name="su_snack_deny">Superuser-rättigheter of %1$s är nekade</string>
    <string name="su_snack_notif_on">Aviseringar för %1$s är aktiverade</string>
    <string name="su_snack_notif_off">Aviseringar för %1$s är inaktiverade</string>
    <string name="su_snack_log_on">Loggning av %1$s är aktiverad</string>
    <string name="su_snack_log_off">Logging av %1$s är inaktiverade</string>
    <string name="su_revoke_title">Återkalla?</string>
    <string name="su_revoke_msg">Bekräfta återkallning utav %1$s rättigheter?</string>
    <string name="toast">Toast-meddelande</string>
    <string name="none">Inga</string>

    <string name="superuser_toggle_notification">Aviseringar</string>
    <string name="superuser_toggle_revoke">Återkalla</string>
    <string name="superuser_policy_none">Inga appar har bett om superuser-rättigheter ännu.</string>

    <!--Logs-->
    <string name="log_data_none">Du är logg-lös, försök att använda dina SU-aktiverade appar mer</string>
    <string name="log_data_magisk_none">Magisks loggar är tomma. Underligt.</string>
    <string name="menuSaveLog">Spara loggen</string>
    <string name="menuClearLog">Rensa loggen</string>
    <string name="logs_cleared">Loggrensning lyckades</string>
    <!-- <string name="pid">PID: %1$d</string> -->
    <!-- <string name="target_uid">Target UID: %1$d</string> -->

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Visa system-appar</string>
    <string name="show_os_app">Via OS-appar</string>
    <string name="hide_filter_hint">Filtrera med namn</string>
    <string name="hide_search">Sök</string>

    <!--Module-->
    <string name="no_info_provided">(Ingen information tillgänglig)</string>
    <string name="reboot_userspace">Mjuk omstart</string>
    <string name="reboot_recovery">Starta om till Recovery</string>
    <string name="reboot_bootloader">Omstart till Bootloader</string>
    <string name="reboot_download">Omstart till Nedladdningsläge</string>
    <string name="reboot_edl">Omstart till EDL</string>
    <string name="module_version_author">%1$s av %2$s</string>
    <string name="module_state_remove">Ta bort</string>
    <string name="module_state_restore">Återställ</string>
    <string name="module_action_install_external">Installera från lagringsmedia</string>
    <string name="update_available">Uppdatering tillgänglig</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Temaläge</string>
    <string name="settings_dark_mode_message">Välj det läge som bäst passar din stil!</string>
    <string name="settings_dark_mode_light">Alltid ljus</string>
    <string name="settings_dark_mode_system">Följ systeminställningar</string>
    <string name="settings_dark_mode_dark">Alltid mörk</string>
    <string name="settings_download_path_title">Nedladdningsmapp</string>
    <string name="settings_download_path_message">Filer kommer att spara till %1$s</string>
    <string name="settings_hide_app_title">Göm Magisk-appen</string>
    <string name="settings_hide_app_summary">Installera en proxy-app med ett slumpmässigt paket-ID och appnamn</string>
    <string name="settings_restore_app_title">Återställ Magisk-appen</string>
    <string name="settings_restore_app_summary">Ta bort proxy-appen och återställ den ursprungliga APK filen</string>
    <string name="language">Språk</string>
    <string name="system_default">(Följ systeminställningar)</string>
    <string name="settings_check_update_title">Kontrollera uppdateringar</string>
    <string name="settings_check_update_summary">Kontrollera regelbundet efter uppdateringar i bakgrunden</string>
    <string name="settings_update_channel_title">Uppdateringskanal</string>
    <string name="settings_update_stable">Stabil</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Anpassad kanal</string>
    <string name="settings_update_custom_msg">Lägg till en anpassad URL</string>
    <string name="settings_hosts_title">Systemfri hosts</string>
    <string name="settings_hosts_summary">Stöd för Adblock-appar med systemfri hosts-fil</string>
    <string name="settings_hosts_toast">Lagt till modul för systemfri hosts-fil</string>
    <string name="settings_app_name_hint">Nytt namn</string>
    <string name="settings_app_name_helper">Appen kommer att pacakas om till detta namn</string>
    <string name="settings_app_name_error">Ogiltigt format</string>
    <string name="settings_su_app_adb">Appar och ADB</string>
    <string name="settings_su_app">Bara Appar</string>
    <string name="settings_su_adb">Bara ADB</string>
    <string name="settings_su_disable">Inaktiverad</string>
    <string name="settings_su_request_10">10 sekunder</string>
    <string name="settings_su_request_15">15 sekunder</string>
    <string name="settings_su_request_20">20 sekunder</string>
    <string name="settings_su_request_30">30 sekunder</string>
    <string name="settings_su_request_45">45 sekunder</string>
    <string name="settings_su_request_60">60 sekunder</string>
    <string name="superuser_access">Superuser-tillgång</string>
    <string name="auto_response">Automatiskt svar</string>
    <string name="request_timeout">Förfrågnings-timeout</string>
    <string name="superuser_notification">Superuser-avisering</string>
    <string name="settings_su_reauth_title">Återautentisera efter uppdatering</string>
    <string name="settings_su_reauth_summary">Återautentisera superuser-rättigheter efter en applikationsuppdatering</string>
    <string name="settings_su_tapjack_title">Aktivera Tapjacking-skydd</string>
    <string name="settings_su_tapjack_summary">Superuser-dialogrutan kommer inte att lyssna på någon input om den är dold eller övertäckt utav något annat fönster.</string>
    <string name="settings_customization">Anpassning</string>
    <string name="setting_add_shortcut_summary">Lägg till en snygg genväg på startskärmen om namnet och ikonen är svåra att känna igen efter att appen har döljts</string>
    <string name="settings_doh_title">DNS över HTTPS</string>
    <string name="settings_doh_description">Lösning för DNS-förgiftning i vissa länder</string>

    <string name="multiuser_mode">Multiuser-läge</string>
    <string name="settings_owner_only">Endast enhetsägare</string>
    <string name="settings_owner_manage">Enhetsägare hanterar</string>
    <string name="settings_user_independent">Användaroberoende</string>
    <string name="owner_only_summary">Endast ägare har root-åtkomst</string>
    <string name="owner_manage_summary">Endast ägare kan hantera root-åtkomst och ta emot bägärda förfrågningar</string>
    <string name="user_independent_summary">Varje användare har sina egna separata root-regler</string>

    <string name="mount_namespace_mode">Montera namnrymdsläge</string>
    <string name="settings_ns_global">Global namnrymd</string>
    <string name="settings_ns_requester">Ärv namnrymden</string>
    <string name="settings_ns_isolate">Isolerad namnrymd</string>
    <string name="global_summary">Alla root-sessioner använder den globala namnrymden</string>
    <string name="requester_summary">Root-sessioner kommer att ärva den sökandes namnrymd</string>
    <string name="isolate_summary">Varje root-session kommer att ha sin egen isolerade namnrymd</string>


    <!--Notifications-->
    <string name="update_channel">Magisk-uppdatering</string>
    <string name="progress_channel">Statusmeddelanden</string>
    <string name="download_complete">Nedladdning slutförd</string>
    <string name="download_file_error">Fel vid nedladdning utav fil</string>
    <string name="magisk_update_title">En uppdatering för Magisk finns tillgänglig!</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Ja</string>
    <string name="no">Nej</string>
    <string name="repo_install_title">Installera %1$s %2$s(%3$d)</string>
    <string name="download">Ladda ned</string>
    <string name="reboot">Omstart</string>
    <string name="release_notes">Utgivningsanmärkningar</string>
    <string name="flashing">Flashar…</string>
    <string name="done">Färdig!</string>
    <string name="failure">Misslyckades!</string>
    <string name="hide_app_title">Gömmer Magisk-appen…</string>
    <string name="open_link_failed_toast">Ingen app hittades som kan öppna länken link</string>
    <string name="complete_uninstall">Komplett avinstallation</string>
    <string name="restore_img">Återställ avbilder</string>
    <string name="restore_img_msg">Återställer…</string>
    <string name="restore_done">Återställning slutförd!</string>
    <string name="restore_fail">Orörd backup hittades inte!</string>
    <string name="setup_fail">Installation misslyckades</string>
    <string name="env_fix_title">Kräver ytterligare installation</string>
    <string name="env_fix_msg">Din enhet behöver ytterligare installation för att Magisk ska fungera korrekt. Vill du fortsätta och starta om enheten?</string>
    <string name="setup_msg">Inställning av körmiljö…</string>
    <string name="unsupport_magisk_title">Magisk-versionen stöds ej</string>
    <string name="unsupport_magisk_msg">Denna version utav appen stödjer inte Magisk-versioner lägre än 1$s.\n\nAppen kommer att bete sig som att Magisk inte är installerat. Vänligen uppgradera din Magisk-version så snart som möjligt.</string>
    <string name="external_rw_permission_denied">Tillåt tillgång till externt lagrinsmedia för att aktievera denna funktion</string>
    <string name="add_shortcut_title">Lägg till genväg på hemskärmen</string>
    <string name="add_shortcut_msg">Efter att appen dolts så kan ikonen och namnet vara svårt att känna igen. Vill du lägga till en snygg genväg till din hemskärm?</string>
    <string name="app_not_found">Ingen applikation hittades för att hantera den här åtgärden</string>
</resources>

```

`app/core/src/main/res/values-sw/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Moduli</string>
    <string name="superuser">Mtumiaji mkuu</string>
    <string name="logs">Kumbukumbu</string>
    <string name="settings">Mipangilio</string>
    <string name="install">Sakinisha</string>
    <string name="section_home">Nyumbanik</string>
    <string name="section_theme">Mandhari</string>
    <string name="denylist">DenyList</string>

    <!--Home-->
    <string name="no_connection">Hakuna muunganisho unaopatikana</string>
    <string name="app_changelog">Kumbukumbu</string>
    <string name="loading">Loading…</string>
    <string name="update">Sasisha</string>
    <string name="not_available">Haipatikani</string>
    <string name="hide">Ficha</string>
    <string name="home_package">Kifurushi</string>
    <string name="home_app_title">Programu</string>

    <string name="home_notice_content">Download Magisk ONLY from the official GitHub page. Files from unknown sources can be malicious!</string>
    <string name="home_support_title">Support Us</string>
    <string name="home_item_source">Source</string>
    <string name="home_support_content">Magisk is, and always will be, free, and open source. You can however show us that you care by making a donation.</string>
    <string name="home_installed_version">Installed</string>
    <string name="home_latest_version">Latest</string>
    <string name="invalid_update_channel">Invalid Update Channel</string>
    <string name="uninstall_magisk_title">Uninstall Magisk</string>
    <string name="uninstall_magisk_msg">All modules will be disabled/removed!\nRoot will be removed!\nAny internal storage unencrypted through the use of Magisk will be re-encrypted!</string>

    <!--Install-->
    <string name="keep_force_encryption">Preserve force encryption</string>
    <string name="keep_dm_verity">Preserve AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Recovery Mode</string>
    <string name="install_options_title">Options</string>
    <string name="install_method_title">Method</string>
    <string name="install_next">Next</string>
    <string name="install_start">Let\'s go</string>
    <string name="manager_download_install">Press to download and install</string>
    <string name="direct_install">Direct Install (Recommended)</string>
    <string name="install_inactive_slot">Install to Inactive Slot (After OTA)</string>
    <string name="install_inactive_slot_msg">Your device will be FORCED to boot to the current inactive slot after a reboot!\nOnly use this option after OTA is done.\nContinue?</string>
    <string name="setup_title">Additional Setup</string>
    <string name="select_patch_file">Select and Patch a File</string>
    <string name="patch_file_msg">Select a raw image (*.img) or an ODIN tarfile (*.tar)</string>
    <string name="reboot_delay_toast">Rebooting in 5 seconds…</string>
    <string name="flash_screen_title">Installation</string>

    <!--Superuser-->
    <string name="su_request_title">Superuser Request</string>
    <string name="touch_filtered_warning">Because an app is obscuring a Superuser request, Magisk can\'t verify your response</string>
    <string name="deny">Deny</string>
    <string name="prompt">Prompt</string>
    <string name="grant">Grant</string>
    <string name="su_warning">Grants full access to your device.\nDeny if you\'re not sure!</string>
    <string name="forever">Forever</string>
    <string name="once">Once</string>
    <string name="tenmin">10 mins</string>
    <string name="twentymin">20 mins</string>
    <string name="thirtymin">30 mins</string>
    <string name="sixtymin">60 mins</string>
    <string name="su_allow_toast">%1$s was granted Superuser rights</string>
    <string name="su_deny_toast">%1$s was denied Superuser rights</string>
    <string name="su_snack_grant">Superuser rights of %1$s are granted</string>
    <string name="su_snack_deny">Superuser rights of %1$s are denied</string>
    <string name="su_snack_notif_on">Notifications of %1$s are enabled</string>
    <string name="su_snack_notif_off">Notifications of %1$s are disabled</string>
    <string name="su_snack_log_on">Logging of %1$s is enabled</string>
    <string name="su_snack_log_off">Logging of %1$s is disabled</string>
    <string name="su_revoke_title">Revoke?</string>
    <string name="su_revoke_msg">Confirm to revoke %1$s Superuser rights</string>
    <string name="toast">Toast</string>
    <string name="none">None</string>

    <string name="superuser_toggle_notification">Notifications</string>
    <string name="superuser_toggle_revoke">Revoke</string>
    <string name="superuser_policy_none">No apps have asked for Superuser permission yet.</string>

    <!--Logs-->
    <string name="log_data_none">You\'re log-free, try using your root apps more</string>
    <string name="log_data_magisk_none">Magisk logs are empty, that\'s weird</string>
    <string name="menuSaveLog">Save log</string>
    <string name="menuClearLog">Clear log now</string>
    <string name="logs_cleared">Log successfully cleared</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Target UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Show system apps</string>
    <string name="show_os_app">Show OS apps</string>
    <string name="hide_filter_hint">Filter by name</string>
    <string name="hide_search">Search</string>

    <!--Module-->
    <string name="no_info_provided">(No info provided)</string>
    <string name="reboot_userspace">Soft reboot</string>
    <string name="reboot_recovery">Reboot to Recovery</string>
    <string name="reboot_bootloader">Reboot to Bootloader</string>
    <string name="reboot_download">Reboot to Download</string>
    <string name="reboot_edl">Reboot to EDL</string>
    <string name="module_version_author">%1$s by %2$s</string>
    <string name="module_state_remove">Remove</string>
    <string name="module_state_restore">Restore</string>
    <string name="module_action_install_external">Install from storage</string>
    <string name="update_available">Update Available</string>
    <string name="suspend_text_riru">Module suspended because %1$s is enabled</string>
    <string name="suspend_text_zygisk">Module suspended because %1$s is not enabled</string>
    <string name="zygisk_module_unloaded">Zygisk module not loaded due to incompatibility</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Theme Mode</string>
    <string name="settings_dark_mode_message">Select mode which best suits your style!</string>
    <string name="settings_dark_mode_light">Always Light</string>
    <string name="settings_dark_mode_system">Follow System</string>
    <string name="settings_dark_mode_dark">Always Dark</string>
    <string name="settings_download_path_title">Download path</string>
    <string name="settings_download_path_message">Files will be saved to %1$s</string>
    <string name="settings_hide_app_title">Hide the Magisk app</string>
    <string name="settings_hide_app_summary">Install a proxy app with a random package ID and custom app label</string>
    <string name="settings_restore_app_title">Restore the Magisk app</string>
    <string name="settings_restore_app_summary">Unhide the app and restore the original APK</string>
    <string name="language">Language</string>
    <string name="system_default">(System Default)</string>
    <string name="settings_check_update_title">Check Updates</string>
    <string name="settings_check_update_summary">Periodically check for updates in the background</string>
    <string name="settings_update_channel_title">Update Channel</string>
    <string name="settings_update_stable">Stable</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Custom</string>
    <string name="settings_update_custom_msg">Insert a custom channel URL</string>
    <string name="settings_zygisk_summary">Run parts of Magisk in the zygote daemon</string>
    <string name="settings_denylist_title">Enforce DenyList</string>
    <string name="settings_denylist_summary">Processes on the denylist will have all Magisk modifications reverted</string>
    <string name="settings_denylist_config_title">Configure DenyList</string>
    <string name="settings_denylist_config_summary">Select the processes to be included on the denylist</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">Systemless hosts support for ad blocking apps</string>
    <string name="settings_hosts_toast">Added systemless hosts module</string>
    <string name="settings_app_name_hint">New name</string>
    <string name="settings_app_name_helper">App will be repackaged with this name</string>
    <string name="settings_app_name_error">Invalid format</string>
    <string name="settings_su_app_adb">Apps and ADB</string>
    <string name="settings_su_app">Apps only</string>
    <string name="settings_su_adb">ADB only</string>
    <string name="settings_su_disable">Disabled</string>
    <string name="settings_su_request_10">10 seconds</string>
    <string name="settings_su_request_15">15 seconds</string>
    <string name="settings_su_request_20">20 seconds</string>
    <string name="settings_su_request_30">30 seconds</string>
    <string name="settings_su_request_45">45 seconds</string>
    <string name="settings_su_request_60">60 seconds</string>
    <string name="superuser_access">Superuser Access</string>
    <string name="auto_response">Automatic Response</string>
    <string name="request_timeout">Request Timeout</string>
    <string name="superuser_notification">Superuser Notification</string>
    <string name="settings_su_reauth_title">Reauthenticate after upgrade</string>
    <string name="settings_su_reauth_summary">Ask for Superuser permissions again after upgrading apps</string>
    <string name="settings_su_tapjack_title">Tapjacking Protection</string>
    <string name="settings_su_tapjack_summary">The Superuser prompt dialog will not respond to input while obscured by any other window or overlay</string>
    <string name="settings_customization">Customization</string>
    <string name="setting_add_shortcut_summary">Add a pretty shortcut to the home screen in case the name and icon are difficult to recognize after hiding the app</string>
    <string name="settings_doh_title">DNS over HTTPS</string>
    <string name="settings_doh_description">Workaround DNS poisoning in some nations</string>

    <string name="multiuser_mode">Multiuser Mode</string>
    <string name="settings_owner_only">Device Owner Only</string>
    <string name="settings_owner_manage">Device Owner Managed</string>
    <string name="settings_user_independent">User-Independent</string>
    <string name="owner_only_summary">Only owner has root access</string>
    <string name="owner_manage_summary">Only owner can manage root access and receive request prompts</string>
    <string name="user_independent_summary">Each user has their own separate root rules</string>

    <string name="mount_namespace_mode">Mount Namespace Mode</string>
    <string name="settings_ns_global">Global Namespace</string>
    <string name="settings_ns_requester">Inherit Namespace</string>
    <string name="settings_ns_isolate">Isolated Namespace</string>
    <string name="global_summary">All root sessions use the global mount namespace</string>
    <string name="requester_summary">Root sessions will inherit their requester\'s namespace</string>
    <string name="isolate_summary">Each root session will have its own isolated namespace</string>

    <!--Notifications-->
    <string name="update_channel">Magisk Updates</string>
    <string name="progress_channel">Progress Notifications</string>
    <string name="updated_channel">Update Complete</string>
    <string name="download_complete">Download complete</string>
    <string name="download_file_error">Error downloading file</string>
    <string name="magisk_update_title">Magisk Update Available!</string>
    <string name="updated_title">Magisk Updated</string>
    <string name="updated_text">Tap to open app</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Yes</string>
    <string name="no">No</string>
    <string name="repo_install_title">Install %1$s %2$s(%3$d)</string>
    <string name="download">Download</string>
    <string name="reboot">Reboot</string>
    <string name="release_notes">Release notes</string>
    <string name="flashing">Flashing…</string>
    <string name="done">Done!</string>
    <string name="failure">Failed!</string>
    <string name="hide_app_title">Hiding the Magisk app…</string>
    <string name="open_link_failed_toast">No app found to open the link</string>
    <string name="complete_uninstall">Complete Uninstall</string>
    <string name="restore_img">Restore Images</string>
    <string name="restore_img_msg">Restoring…</string>
    <string name="restore_done">Restoration done!</string>
    <string name="restore_fail">Stock backup does not exist!</string>
    <string name="setup_fail">Setup failed</string>
    <string name="env_fix_title">Requires Additional Setup</string>
    <string name="env_fix_msg">Your device needs additional setup for Magisk to work properly. Do you want to proceed and reboot?</string>
    <string name="setup_msg">Running environment setup…</string>
    <string name="unsupport_magisk_title">Unsupported Magisk Version</string>
    <string name="unsupport_magisk_msg">This version of the app does not support Magisk versions lower than %1$s.\n\nThe app will behave as if no Magisk is installed, please upgrade Magisk as soon as possible.</string>
    <string name="unsupport_general_title">Abnormal State</string>
    <string name="unsupport_system_app_msg">Running this app as a system app is not supported. Please revert the app to a user app.</string>
    <string name="unsupport_other_su_msg">A \"su\" binary not from Magisk has been detected. Please remove any competing root solution and/or reinstall Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk is installed to external storage. Please move the app to internal storage.</string>
    <string name="unsupport_nonroot_stub_msg">The hidden Magisk app cannot continue to work because root was lost. Please restore the original APK.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Grant storage permission to enable this functionality</string>
    <string name="install_unknown_denied">Allow "install unknown apps" to enable this functionality</string>
    <string name="add_shortcut_title">Add shortcut to home screen</string>
    <string name="add_shortcut_msg">After hiding this app, its name and icon might become difficult to recognize. Do you want to add a pretty shortcut to the home screen?</string>
    <string name="app_not_found">No app found to handle this action</string>
    <string name="reboot_apply_change">Reboot to apply changes</string>
    <string name="restore_app_confirmation">This will restore the hidden app back to the original app. Do you really want to do this?</string>

</resources>

```

`app/core/src/main/res/values-ta/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">தொகுதிகள்</string>
    <string name="superuser">சூப்பர் யூசர்</string>
    <string name="logs">பதிவுகள்</string>
    <string name="settings">அமைப்புகள்</string>
    <string name="install">நிறுவு</string>
    <string name="section_home">முகப்புப்பக்கம்</string>
    <string name="section_theme">வடிவமைப்புகள்</string>

    <!--Home-->
    <string name="no_connection">இணைப்பு கிடைக்கவில்லை</string>
    <string name="app_changelog">சேஞ்ச்லாக்</string>
    <string name="loading">ஏற்றுகிறது...</string>
    <string name="update">புதுப்பிப்பு</string>
    <string name="not_available">எதுவும் இல்லை</string>
    <string name="hide">பார்வையில் இருந்து மறைத்து வை</string>
    <string name="home_package">தொகுப்பு</string>
    <string name="home_app_title">செயலி</string>

    <string name="home_notice_content">அதிகாரப்பூர்வ கிட்ஹப் பக்கத்திலிருந்து மட்டுமே மேகிஸ்கை பதிவிறக்கவும். அறியப்படாத மூலங்களிலிருந்து வரும் கோப்புகள் தீங்கிழைக்கும்!</string>
    <string name="home_support_title">எங்களை ஆதரியுங்கள்</string>
    <string name="home_item_source">ஆரம்ப இடம்</string>
    <string name="home_support_content">மேஜிஸ்க் என்பது எப்போதும் இலவசமாகவும் திறந்த மூலமாகவும் இருக்கும். ஒரு சிறிய நன்கொடை அனுப்புவதன் மூலம் நீங்கள் அக்கறை காட்டுகிறீர்கள் என்பதை எங்களுக்குக் காட்டலாம்.</string>
    <string name="home_installed_version">நிறுவப்பட்டுள்ளது</string>
    <string name="home_latest_version">அண்மை</string>
    <string name="invalid_update_channel">புதுப்பிப்பு சேனல் தவறானது</string>
    <string name="uninstall_magisk_title">மேஜிஸ்க் நிறுவலை நீக்கு</string>
    <string name="uninstall_magisk_msg">அனைத்து தொகுதிகள் முடக்கப்படும்/அகற்றப்படும்!\nரூட் அகற்றப்படும்!\nஏற்கனவே இல்லையென்றால் உங்கள் தரவு குறியாக்கம் செய்யப்படலாம்!</string>

    <!--Install-->
    <string name="keep_force_encryption">குறியாக்கத்தைப் பாதுகாக்கவும்</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verityயை பாதுகாக்கவும்</string>
    <string name="recovery_mode">மீட்பு செயல்முறை</string>
    <string name="install_options_title">விருப்பங்கள்</string>
    <string name="install_method_title">செயல்முறை</string>
    <string name="install_next">அடுத்தது</string>
    <string name="install_start">போகலாம்</string>
    <string name="manager_download_install">பதிவிறக்கி நிறுவ இந்த பொத்தானை அழுத்தவும்</string>
    <string name="direct_install">நேரடி நிறுவல் (பரிந்துரைக்கப்படுகிறது)</string>
    <string name="install_inactive_slot">செயலற்ற ஸ்லாட்டுக்கு நிறுவவும் (OTA க்குப் பிறகு)</string>
    <string name="install_inactive_slot_msg">மறுதொடக்கம் செய்தபின் தற்போதைய செயலற்ற ஸ்லாட்டுக்கு துவக்க உங்கள் சாதனம் கட்டாயப்படுத்தப்படும்!\nOTA முடிந்தபின் மட்டுமே இந்த விருப்பத்தைப் பயன்படுத்தவும்.\nதொடரவா?</string>
    <string name="setup_title">கூடுதல் அமைப்பு</string>
    <string name="select_patch_file">ஒரு கோப்பைத் தேர்ந்தெடுத்து ஒட்டவும்</string>
    <string name="patch_file_msg">மூல படம் (* .img) அல்லது ODIN டார்ஃபைல் (* .tar) ஐத் தேர்ந்தெடுக்கவும்</string>
    <string name="reboot_delay_toast">5 வினாடிகளில் மீண்டும் துவக்குகிறது…</string>
    <string name="flash_screen_title">நிறுவல்</string>

    <!--Superuser-->
    <string name="su_request_title">சூப்பர் யூசர் கோரிக்கை</string>
    <string name="touch_filtered_warning">ஒரு பயன்பாடு ஒரு சூப்பர் யூசர் கோரிக்கையை மறைப்பதால், மேகிஸ்கால் உங்கள் பதிலைச் சரிபார்க்க முடியாது</string>
    <string name="deny">மறு</string>
    <string name="prompt">உடனடி</string>
    <string name="grant">வழங்கு</string>
    <string name="su_warning">உங்கள் சாதனத்திற்கு முழு அணுகலை வழங்குகிறது.\nஉங்களுக்கு உறுதியாக தெரியவில்லை என்றால் மறுக்கவும்!</string>
    <string name="forever">என்றென்றும்</string>
    <string name="once">ஒருமுறை</string>
    <string name="tenmin">10 நிமிடங்கள்</string>
    <string name="twentymin">20 நிமிடங்கள்</string>
    <string name="thirtymin">30 நிமிடங்கள்</string>
    <string name="sixtymin">ஒரு மணி நேரம்</string>
    <string name="su_allow_toast">%1$s க்கு சூப்பர் யூசர் உரிமைகள் வழங்கப்பட்டன</string>
    <string name="su_deny_toast">%1$s க்கு சூப்பர் யூசர் உரிமைகள் மறுக்கப்பட்டன</string>
    <string name="su_snack_grant">%1$s இன் சூப்பர் யூசர் உரிமைகள் வழங்கப்படுகின்றன</string>
    <string name="su_snack_deny">%1$s இன் சூப்பர் யூசர் உரிமைகள் மறுக்கப்படுகின்றன</string>
    <string name="su_snack_notif_on">%1$s இன் அறிவிப்புகள் இயக்கப்பட்டன</string>
    <string name="su_snack_notif_off">%1$s இன் அறிவிப்புகள் முடக்கப்பட்டுள்ளன</string>
    <string name="su_snack_log_on">%1$s இன் பதிவுசெய்தல் இயக்கப்பட்டது</string>
    <string name="su_snack_log_off">%1$s இன் பதிவுசெய்தல் முடக்கப்பட்டுள்ளது</string>
    <string name="su_revoke_title">ரத்து செய்?</string>
    <string name="su_revoke_msg">%1$s உரிமைகளை ரத்து செய்ய உறுதிப்படுத்தவும்</string>
    <string name="toast">செய்தி</string>
    <string name="none">எதுவும் இல்லை</string>

    <string name="superuser_toggle_notification">அறிவிப்புகள்</string>
    <string name="superuser_toggle_revoke">ரத்து செய்</string>
    <string name="superuser_policy_none">எந்த பயன்பாடும் இதுவரை சூப்பர் யூசர் அனுமதி கேட்கவில்லை.</string>

    <!--Logs-->
    <string name="log_data_none">பதிவு செய்யப்படாது, உங்கள் SU இயக்கப்பட்ட பயன்பாடுகளைப் பயன்படுத்த முயற்சிக்கவும்</string>
    <string name="log_data_magisk_none">மேஜிஸ்க் பதிவுகள் காலியாக உள்ளன, அது வித்தியாசமானது</string>
    <string name="menuSaveLog">பதிவைச் சேமிக்கவும்</string>
    <string name="menuClearLog">இப்போது பதிவை அழிக்கவும்</string>
    <string name="logs_cleared">Lபதிவு வெற்றிகரமாக அழிக்கப்பட்டது</string>
    <string name="pid">பிஐடி: %1$d</string>
    <string name="target_uid">இலக்கு பிஐடி: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">தொலைபேசி பயன்பாடுகளைக் காட்டு</string>
    <string name="show_os_app">OS பயன்பாடுகளைக் காட்டு</string>
    <string name="hide_filter_hint">பெயரால் வடிகட்டவும்</string>
    <string name="hide_search">தேடல்</string>

    <!--Module-->
    <string name="no_info_provided">(எந்த தகவலும் வழங்கப்படவில்லை)</string>
    <string name="reboot_userspace">மென்மையான மறுதொடக்கம்</string>
    <string name="reboot_recovery">மீட்டெடுப்பிற்கு மறுதொடக்கம் செய்</string>
    <string name="reboot_bootloader">துவக்க ஏற்றிக்கு மீண்டும் துவக்கவும்</string>
    <string name="reboot_download">பதிவிறக்க பயன்முறையில் மீண்டும் துவக்கவும்</string>
    <string name="reboot_edl">EDL க்கு மறுதொடக்கம் செய்</string>
    <string name="module_version_author">%1$s மூலமாக %2$s</string>
    <string name="module_state_remove">அகற்று</string>
    <string name="module_state_restore">மீட்டமை</string>
    <string name="module_action_install_external">சேமிப்பிலிருந்து நிறுவவும்</string>
    <string name="update_available">புதுப்பிப்பு கிடைக்கிறது</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">தீம் பயன்முறை</string>
    <string name="settings_dark_mode_message">உங்கள் பாணிக்கு மிகவும் பொருத்தமான பயன்முறையைத் தேர்ந்தெடுக்கவும்!</string>
    <string name="settings_dark_mode_light">எப்போதும் ஒளி</string>
    <string name="settings_dark_mode_system">தொலைபேசி அமைப்புகளைப் பின்பற்றவும்</string>
    <string name="settings_dark_mode_dark">எப்போதும் இருண்டது</string>
    <string name="settings_download_path_title">பதிவிறக்க இடம்</string>
    <string name="settings_download_path_message">%1$s ல் கோப்புகள் சேமிக்கப்படும்</string>
    <string name="settings_hide_app_title">மேஜிஸ்க் செயலியை மறைக்கவும்</string>
    <string name="settings_hide_app_summary">சீரற்ற தொகுப்பு ஐடி மற்றும் தனிப்பயன் பயன்பாட்டு லேபிளுடன் ப்ராக்ஸி பயன்பாட்டை நிறுவவும்</string>
    <string name="settings_restore_app_title">மேஜிஸ்க் பயன்பாட்டை மீட்டமை</string>
    <string name="settings_restore_app_summary">பயன்பாட்டை மறைத்து, அசல் APK க்கு மீண்டும் மீட்டமைக்கவும்</string>
    <string name="language">மொழி</string>
    <string name="system_default">(தொலைபேசியின் இயல்புநிலை)</string>
    <string name="settings_check_update_title">புதுப்பிப்புகளைச் சரிபார்க்கவும்</string>
    <string name="settings_check_update_summary">பின்னணியில் புதுப்பிப்புகளை அவ்வப்போது சரிபார்க்கவும்</string>
    <string name="settings_update_channel_title">புதுப்பிப்பு வழி</string>
    <string name="settings_update_stable">நிலையானது</string>
    <string name="settings_update_beta">தற்காலிகமானது</string>
    <string name="settings_update_custom">தனிப்பயன் வழி</string>
    <string name="settings_update_custom_msg">தனிப்பயன் URL ஐ உள்ளிடவும்</string>
    <string name="settings_hosts_title">கணினி இல்லாத ஹோஸ்ட்கள்</string>
    <string name="settings_hosts_summary">கணினி இல்லாத ஹோஸ்ட்கள் Adblock பயன்பாடுகளுக்கு ஆதரவளிக்கின்றன</string>
    <string name="settings_hosts_toast">கணினி இல்லாத ஹோஸ்ட்கள் தொகுதி சேர்க்கப்பட்டது</string>
    <string name="settings_app_name_hint">புதிய பெயர்</string>
    <string name="settings_app_name_helper">பயன்பாடு இந்த பெயருக்கு மீண்டும் தொகுக்கப்படும்</string>
    <string name="settings_app_name_error">தவறான வடிவம்</string>
    <string name="settings_su_app_adb">பயன்பாடுகள் மற்றும் ADB</string>
    <string name="settings_su_app">பயன்பாடுகள் மட்டும்</string>
    <string name="settings_su_adb">ADB மட்டும்</string>
    <string name="settings_su_disable">முடக்கப்பட்டது</string>
    <string name="settings_su_request_10">10 வினாடிகள்</string>
    <string name="settings_su_request_15">15 வினாடிகள்</string>
    <string name="settings_su_request_20">20 வினாடிகள்</string>
    <string name="settings_su_request_30">30 வினாடிகள்</string>
    <string name="settings_su_request_45">45 வினாடிகள்</string>
    <string name="settings_su_request_60">60 வினாடிகள்</string>
    <string name="superuser_access">சூப்பர் யூசர் அணுகல்</string>
    <string name="auto_response">தானியங்கி பதில்</string>
    <string name="request_timeout">கோரிக்கை முடிவு நேரம்</string>
    <string name="superuser_notification">சூப்பர் யூசர் அறிவிப்பு</string>
    <string name="settings_su_reauth_title">மேம்படுத்தப்பட்ட பிறகு மீண்டும் அங்கீகரிக்கவும்</string>
    <string name="settings_su_reauth_summary">பயன்பாட்டு மேம்படுத்தல்களுக்குப் பிறகு சூப்பர் யூசர் அனுமதிகளை மீண்டும் அங்கீகரிக்கவும்</string>
    <string name="settings_su_tapjack_title">டாப்ஜாகிங் பாதுகாப்பை இயக்கு</string>
    <string name="settings_su_tapjack_summary">வேறு எந்த சாளரத்தாலும் அல்லது மேலடுக்கினாலும் மறைக்கப்படும்போது சூப்பர் யூசர் வரியில் உரையாடல் உள்ளீட்டிற்கு பதிலளிக்காது</string>
    <string name="settings_customization">தனிப்பயனாக்கம்</string>
    <string name="setting_add_shortcut_summary">பயன்பாட்டை மறைத்தபின் பெயர் மற்றும் ஐகான் அடையாளம் காண கடினமாக இருந்தால் முகப்புத் திரையில் அழகான குறுக்குவழியைச் சேர்க்கவும்</string>
    <string name="settings_doh_title">HTTPS வழியாக டி.என்.எஸ்</string>
    <string name="settings_doh_description">சில நாடுகளில் டி.என்.எஸ் பணிபுரியும்</string>

    <string name="multiuser_mode">மல்டியூசர் பயன்முறை</string>
    <string name="settings_owner_only">சாதன உரிமையாளர் மட்டுமே</string>
    <string name="settings_owner_manage">சாதன உரிமையாளர் நிர்வகிக்கப்பட்டார்</string>
    <string name="settings_user_independent">பயனர்-சுதந்திரம்</string>
    <string name="owner_only_summary">உரிமையாளருக்கு மட்டுமே ரூட் அணுகல் உள்ளது</string>
    <string name="owner_manage_summary">உரிமையாளர் மட்டுமே ரூட் அணுகலை நிர்வகிக்க முடியும்</string>
    <string name="user_independent_summary">ஒவ்வொரு பயனருக்கும் அவரவர் / அவளுக்கு தனித்தனி ரூட் விதிகள் உள்ளன</string>

    <string name="mount_namespace_mode">நேம்ஸ்பேஸ் பயன்முறையை சேர்</string>
    <string name="settings_ns_global">உலகளாவிய பெயர்வெளி</string>
    <string name="settings_ns_requester">பெயர்வெளி மரபுரிமை</string>
    <string name="settings_ns_isolate">தனிமைப்படுத்தப்பட்ட பெயர்வெளி</string>
    <string name="global_summary">அனைத்து ரூட் அமர்வுகளும் உலகளாவிய மவுண்ட் பெயர்வெளியைப் பயன்படுத்துகின்றன</string>
    <string name="requester_summary">ரூட் அமர்வுகள் அவற்றின் கோரிக்கையாளரின் பெயர்வெளியைப் பெறும்</string>
    <string name="isolate_summary">ஒவ்வொரு ரூட் அமர்வுக்கும் அதன் தனிமைப்படுத்தப்பட்ட பெயர்வெளி இருக்கும்</string>

    <!--Notifications-->
    <string name="update_channel">மேஜிக் புதுப்பிப்புகள்</string>
    <string name="progress_channel">முன்னேற்ற அறிவிப்புகள்</string>
    <string name="download_complete">பதிவிறக்கம் முடிந்தது</string>
    <string name="download_file_error">கோப்பை பதிவிறக்குவதில் பிழை</string>
    <string name="magisk_update_title">மேஜிஸ்க் புதுப்பிப்பு கிடைக்கிறது!</string>

    <!--Toasts, Dialogs-->
    <string name="yes">ஆம்</string>
    <string name="no">இல்லை</string>
    <string name="repo_install_title">நிறுவு %1$s %2$s(%3$d)</string>
    <string name="download">பதிவிறக்கம்</string>
    <string name="reboot">மறுதொடக்கம்</string>
    <string name="release_notes">வெளியீட்டு குறிப்புகள்</string>
    <string name="flashing">ஏற்றுகிறது…</string>
    <string name="done">முடிந்தது!</string>
    <string name="failure">தோல்வி!</string>
    <string name="hide_app_title">மேஜிஸ்க் பயன்பாட்டை மறைக்கிறது…</string>
    <string name="open_link_failed_toast">இணைப்பைத் திறக்க எந்த பயன்பாடும் கிடைக்கவில்லை</string>
    <string name="complete_uninstall">நிறுவல் நீக்குதல்</string>
    <string name="restore_img">படங்களை மீட்டமை</string>
    <string name="restore_img_msg">மீட்டமைக்கிறது…</string>
    <string name="restore_done">மறுசீரமைப்பு செய்யப்பட்டது!</string>
    <string name="restore_fail">அசல் பிரதி இல்லை!</string>
    <string name="setup_fail">அமைப்பு தோல்வியுற்றது</string>
    <string name="env_fix_title">கூடுதல் அமைப்பு தேவை</string>
    <string name="env_fix_msg">மேகிஸ்க் சரியாக வேலை செய்ய உங்கள் சாதனத்திற்கு கூடுதல் அமைப்பு தேவை. மறுதொடக்கம் செய்ய விரும்புகிறீர்களா??</string>
    <string name="setup_msg">சூழல் அமைப்பை இயக்குகிறது…</string>
    <string name="unsupport_magisk_title">ஆதரிக்கப்படாத மேஜிஸ்க் பதிப்பு</string>
    <string name="unsupport_magisk_msg">பயன்பாட்டின் இந்த பதிப்பு மேஜிஸ்க் பதிப்பை %1$s ஐ விடக் குறைவாக ஆதரிக்காது.</string>
    <string name="external_rw_permission_denied">இந்த செயல்பாட்டை இயக்க சேமிப்பக அனுமதி வழங்கவும்</string>
    <string name="add_shortcut_title">முகப்புத் திரையில் குறுக்குவழியைச் சேர்க்கவும்</string>
    <string name="add_shortcut_msg">இந்த பயன்பாட்டை மறைத்த பிறகு, அதன் பெயர் மற்றும் ஐகானை அடையாளம் காண்பது கடினமாகிவிடும். முகப்புத் திரையில் அழகான குறுக்குவழியைச் சேர்க்க விரும்புகிறீர்களா??</string>
    <string name="app_not_found">இந்த செயலைக் கையாள எந்த பயன்பாடும் கிடைக்கவில்லை</string>

</resources>

```

`app/core/src/main/res/values-th/strings.xml`:

```xml
<resources>

    <!--Welcome Activity-->
    <string name="modules">โมดูล</string>
    <string name="superuser">Superuser</string>
    <string name="logs">บันทึก</string>
    <string name="settings">ตั้งค่า</string>
    <string name="install">ติดตั้ง</string>

    <!--Status Fragment-->
    <string name="invalid_update_channel">ช่องทางการอัปเดตไม่ถูกต้อง</string>
    <string name="keep_force_encryption">เก็บค่าบังคับการเข้ารหัส</string>
    <string name="keep_dm_verity">เก็บค่า AVB 2.0/dm-verity</string>
    <string name="uninstall_magisk_title">ถอนการติดตั้ง Magisk</string>
    <string name="uninstall_magisk_msg">โมดูลทั้งหมดจะถูกปิดการใช้งาน/ถูกลบ, สิทธิการเข้าถึง Root จะถูกลบ และข้อมูลของคุณอาจถูกเข้ารหัส</string>
    <string name="update">อัปเดต</string>

    <!--Module Fragment-->
    <string name="no_info_provided">(ไม่มีข้อมูล)</string>
    <string name="reboot_recovery">รีบู๊ตไปโหมดกู้คืน</string>
    <string name="reboot_bootloader">รีบู๊ตไป Bootloader</string>
    <string name="reboot_download">รีบู๊ตไป Download</string>

    <!--Repo Fragment-->
    <string name="update_available">มีการอัปเดต</string>
    <string name="home_installed_version">ติดตั้งแล้ว</string>

    <!--Log Fragment-->
    <string name="menuSaveLog">เก็บบันทึก</string>
    <string name="menuClearLog">ล้างบันทึก</string>
    <string name="logs_cleared">บันทึกถูกล้างแล้ว</string>

    <!--About Activity-->
    <string name="app_changelog">สิ่งที่เพิ่มใหม่</string>

    <!-- System Components, Notifications -->
    <string name="update_channel">การอัปเดต Magisk</string>
    <string name="progress_channel">สถานะ</string>
    <string name="download_complete">ดาวน์โหลดสำเร็จ</string>
    <string name="download_file_error">เกิดข้อผิดพลาดในการดาวน์โหลดไฟล์</string>
    <string name="magisk_update_title">มีการอัปเดต Magisk!</string>

    <!--Toasts, Dialogs-->
    <string name="repo_install_title">ติดตั้ง %1$s %2$s(%3$d)</string>
    <string name="download">ดาวน์โหลด</string>
    <string name="reboot">รีบู๊ต</string>
    <string name="release_notes">ข้อมูลเพิ่มเติม</string>
    <string name="manager_download_install">แตะเพื่อดาวน์โหลดและติดตั้ง</string>
    <string name="flashing">กำลังแฟลช</string>
    <string name="open_link_failed_toast">ไม่พบแอปพลิเคชันสำหรับเปิดลิ้งค์</string>
    <string name="direct_install">การติดตั้งโดยตรง (แนะนำ)</string>
    <string name="install_inactive_slot">ติดตั้งไปยัง Slot ที่ไม่ใช้งาน (หลังจาก OTA)</string>
    <string name="install_inactive_slot_msg">อุปกรณ์ของคุณจะถูกบังคับให้บู๊ตไป Slot ที่ไม่ใช่งานหลังจากรีบูต!\nใช้ตัวเลือกนี้หลังจาก OTA เสร็จเท่านั้น\nดำเนินการต่อ?</string>
    <string name="complete_uninstall">ถอนการติดตั้งแบบสมบูรณ์</string>
    <string name="restore_img">กู้คืน Images</string>
    <string name="restore_img_msg">กำลังกู้คืน…</string>
    <string name="restore_done">การกู้คืนสำเร็จ!</string>
    <string name="restore_fail">ไม่มีไฟล์แบ็คอัพ!</string>
    <string name="setup_fail">การตั้งค่าล้มเหลว</string>
    <string name="env_fix_title">ต้องมีการตั้งค่าเพิ่มเติม</string>
    <string name="setup_title">การตั้งค่าเพิ่มเติม</string>
    <string name="setup_msg">กำลังรันการตั้งค่า…</string>

    <!--Settings Activity -->
    <string name="language">ภาษา</string>
    <string name="system_default">(มาตรฐานระบบ)</string>
    <string name="settings_check_update_title">ตรวจสอบการอัปเดต</string>
    <string name="settings_check_update_summary">ตรวจสอบการอัปเดตเป็นระยะในพื้นหลัง</string>
    <string name="settings_update_channel_title">ช่องทางการอัปเดต</string>
    <string name="settings_update_stable">เสถียร</string>
    <string name="settings_update_beta">เบต้า</string>
    <string name="settings_update_custom">กำหนดเอง</string>
    <string name="settings_update_custom_msg">ใส่ URL</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">การรองรับ Systemless hosts เพื่อแอพ Adblock ต่างๆ</string>
    <string name="settings_hosts_toast">ทำการเพิ่มโมดูล systemless hosts แล้ว</string>

    <string name="settings_su_app_adb">แอปและ ADB</string>
    <string name="settings_su_app">แอปเท่านั้น</string>
    <string name="settings_su_adb">ADB เท่านั้น</string>
    <string name="settings_su_disable">ปิด</string>
    <string name="settings_su_request_10">10 วินาที</string>
    <string name="settings_su_request_15">15 วินาที</string>
    <string name="settings_su_request_20">20 วินาที</string>
    <string name="settings_su_request_30">30 วินาที</string>
    <string name="settings_su_request_45">45 วินาที</string>
    <string name="settings_su_request_60">60 วินาที</string>
    <string name="superuser_access">การเข้าถึง Superuser</string>
    <string name="auto_response">การตอบกลับ</string>
    <string name="request_timeout">เวลาการขอใช้งาน</string>
    <string name="superuser_notification">การแจ้งเตือน Superuser</string>
    <string name="settings_su_reauth_title">ขอสิทธิ์ใหม่หลังจากอัปเกรด</string>
    <string name="settings_su_reauth_summary">ขอสิทธิ์ superuser ใหม่หลังจากแอปถูกอัปเกรด</string>

    <string name="multiuser_mode">โหมดผู้ใช้หลายคน</string>
    <string name="settings_owner_only">เจ้าของอุปกรณ์เท่านั้น</string>
    <string name="settings_owner_manage">จัดการโดยเจ้าของอุปกรณ์</string>
    <string name="settings_user_independent">ตามผู้ใช้</string>
    <string name="owner_only_summary">เฉพาะเจ้าของที่มีสิทธิ์การเข้าถึง root</string>
    <string name="owner_manage_summary">เจ้าของสามารถจัดการสิทธิ์การเข้าถึง root</string>
    <string name="user_independent_summary">ผู้ใช้แต่ละคนสามารถจัดการกฏของตนเอง</string>

    <string name="mount_namespace_mode">Mount Namespace Mode</string>
    <string name="settings_ns_global">Global Namespace</string>
    <string name="settings_ns_requester">Inherit Namespace</string>
    <string name="settings_ns_isolate">Isolated Namespace</string>
    <string name="global_summary">All root sessions use the global mount namespace.</string>
    <string name="requester_summary">Root sessions will inherit their requester\'s namespace.</string>
    <string name="isolate_summary">Each root session will have its own isolated namespace.</string>

    <!--Superuser-->
    <string name="su_request_title">การขอเข้าถึง Superuser</string>
    <string name="deny">ปฏิเสธ</string>
    <string name="prompt">ถาม</string>
    <string name="grant">อนุญาต</string>
    <string name="su_warning">จะให้การเข้าถึงอุปกรณ์ในทุกรูปแบบ กรุณาปฏิเสธหากคุณไม่มั่นใจ!</string>
    <string name="forever">ตลอดกาล</string>
    <string name="once">ครั้งเดียว</string>
    <string name="tenmin">10 นาที</string>
    <string name="twentymin">20 นาที</string>
    <string name="thirtymin">30 นาที</string>
    <string name="sixtymin">60 นาที</string>
    <string name="su_allow_toast">%1$s ถูกอนุญาตสิทธิ์ Superuser</string>
    <string name="su_deny_toast">%1$s ถูกปฏิเสธสิทธิ์ Superuser</string>
    <string name="su_snack_grant">สิทธิ์ Superuser ของ %1$s ถูกอนุญาต</string>
    <string name="su_snack_deny">สิทธิ์ Superuser ของ %1$s ถูกปฏิเสธ</string>
    <string name="su_snack_notif_on">การแจ้งเตือนของ %1$s ถูกเปิด</string>
    <string name="su_snack_notif_off">การแจ้งเตือนของ %1$s ถูกปิด</string>
    <string name="su_snack_log_on">การบันทึก %1$s ถูกเปิด</string>
    <string name="su_snack_log_off">การบันทึก %1$s ถูกปิด</string>
    <string name="su_revoke_title">ลบสิทธิ์?</string>
    <string name="su_revoke_msg">ยืนยันการลบสิทธิ์ของ %1$s?</string>
    <string name="toast">การเตือน</string>
    <string name="none">ไม่มี</string>

    <!--Superuser logs-->
    <string name="target_uid">UID เป้าหมาย: %1$d</string>

</resources>

```

`app/core/src/main/res/values-tr/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Modüller</string>
    <string name="superuser">Süper Kullanıcı</string>
    <string name="logs">Günlükler</string>
    <string name="settings">Ayarlar</string>
    <string name="install">Kur</string>
    <string name="section_home">Ana Sayfa</string>
    <string name="section_theme">Temalar</string>
    <string name="denylist">Red Listesi</string>

    <!--Home-->
    <string name="no_connection">Bağlantı Yok</string>
    <string name="app_changelog">Değişiklik Günlüğü</string>
    <string name="loading">Yükleniyor…</string>
    <string name="update">Güncelle</string>
    <string name="not_available">Mevcut Değil</string>
    <string name="hide">Gizle</string>
    <string name="home_package">Paket</string>
    <string name="home_app_title">Uygulama</string>
    <string name="home_notice_content">Magisk\'i YALNIZCA resmi GitHub sayfasından indirin. Bilinmeyen kaynaklardan gelen dosyalar kötü amaçlı olabilir!</string>
    <string name="home_support_title">Bize Destek Olun</string>
    <string name="home_follow_title">Bizi Takip Edin</string>
    <string name="home_item_source">Kaynak</string>
    <string name="home_support_content">Magisk ücretsizdir, açık kaynaklıdır ve her zaman öyle kalacaktır. Ancak, bağış yaparak bize değer verdiğinizi gösterebilirsiniz.</string>
    <string name="home_installed_version">Yüklü</string>
    <string name="home_latest_version">En Son</string>
    <string name="invalid_update_channel">Geçersiz güncelleme kanalı</string>
    <string name="uninstall_magisk_title">Magisk\'i Kaldır</string>
    <string name="uninstall_magisk_msg">Tüm modüller devre dışı bırakılacak/kaldırılacak!\nRoot kaldırılacak!\nMagisk kullanılarak şifresi çözülen dahili depolama birimleri yeniden şifrelenecek!</string>

    <!--Install-->
    <string name="keep_force_encryption">Zorunlu Şifrelemeyi Koru</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity Koru</string>
    <string name="recovery_mode">Kurtarma Modu</string>
    <string name="install_options_title">Seçenekler</string>
    <string name="install_method_title">Yöntem</string>
    <string name="install_next">Sonraki</string>
    <string name="install_start">Hadi Başlayalım</string>
    <string name="manager_download_install">İndirmek ve kurmak için basın</string>
    <string name="direct_install">Doğrudan kurulum (Önerilen)</string>
    <string name="install_inactive_slot">Etkin olmayan slota kur (OTA sonrası)</string>
    <string name="install_inactive_slot_msg">Cihazınız, yeniden başlattıktan sonra mevcut etkin olmayan slota önyükleme yapmaya ZORLANACAKTIR!\nBu seçeneği yalnızca OTA güncellemesi yapıldıktan sonra kullanın.\nDevam edilsin mi?</string>
    <string name="setup_title">Ek Kurulum</string>
    <string name="select_patch_file">Bir dosya seçin ve yamalayın</string>
    <string name="patch_file_msg">Ham bir imaj (*.img), bir ODIN tar dosyası (*.tar) veya bir payload.bin (*.bin) seçin</string>
    <string name="reboot_delay_toast">5 saniye içinde yeniden başlatılıyor…</string>
    <string name="flash_screen_title">Kuruluyor</string>

    <!--Superuser-->
    <string name="su_request_title">Süper Kullanıcı İsteği</string>
    <string name="touch_filtered_warning">Bir uygulama Süper Kullanıcı isteğini engellediği için Magisk yanıtınızı doğrulayamıyor.</string>
    <string name="deny">Reddet</string>
    <string name="prompt">Sor</string>
    <string name="restrict">Kısıtla</string>
    <string name="grant">İzin Ver</string>
    <string name="su_warning">Cihazınıza tam erişim sağlar.\nEmin değilseniz reddedin!</string>
    <string name="forever">Her Zaman</string>
    <string name="once">Bir Kez</string>
    <string name="tenmin">10 Dakika</string>
    <string name="twentymin">20 Dakika</string>
    <string name="thirtymin">30 Dakika</string>
    <string name="sixtymin">60 Dakika</string>
    <string name="su_allow_toast">%1$s uygulamasına Süper Kullanıcı hakları verildi</string>
    <string name="su_deny_toast">%1$s uygulamasının Süper Kullanıcı hakları reddedildi</string>
    <string name="su_snack_grant">%1$s uygulamasının Süper Kullanıcı hakları verildi</string>
    <string name="su_snack_deny">%1$s uygulamasının Süper Kullanıcı hakları reddedildi</string>
    <string name="su_snack_notif_on">%1$s bildirimleri etkinleştirildi</string>
    <string name="su_snack_notif_off">%1$s bildirimleri devre dışı bırakıldı</string>
    <string name="su_snack_log_on">%1$s için günlük kaydı etkinleştirildi</string>
    <string name="su_snack_log_off">%1$s için günlük kaydı devre dışı bırakıldı</string>
    <string name="su_revoke_title">İptal Edilsin mi?</string>
    <string name="su_revoke_msg">%1$s uygulamasının Süper Kullanıcı haklarını iptal etmeyi onaylayın</string>
    <string name="toast">Bildirim Penceresi</string>
    <string name="none">Yok</string>
    <string name="superuser_toggle_notification">Bildirimler</string>
    <string name="superuser_toggle_revoke">İptal Et</string>
    <string name="superuser_policy_none">Henüz hiçbir uygulama Süper Kullanıcı izni istemedi.</string>

    <!--Logs-->
    <string name="log_data_none">Günlüğünüz temiz. Root uygulamalarınızı daha fazla kullanmayı deneyin.</string>
    <string name="log_data_magisk_none">Magisk günlükleri boş, bu garip.</string>
    <string name="menuSaveLog">Günlüğü Kaydet</string>
    <string name="menuClearLog">Günlüğü Şimdi Temizle</string>
    <string name="logs_cleared">Günlük başarıyla temizlendi</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Hedef UID: %1$d</string>
    <string name="target_pid">Hedef PID: %s</string>
    <string name="selinux_context">SELinux bağlamı: %s</string>
    <string name="supp_group">Ek grup: %s</string>

    <!--MagiskHide-->
    <string name="show_system_app">Sistem Uygulamalarını Göster</string>
    <string name="show_os_app">İS Uygulamalarını Göster</string>
    <string name="hide_filter_hint">Ada göre filtrele</string>
    <string name="hide_search">Ara</string>

    <!--Module-->
    <string name="no_info_provided">(Bilgi sağlanmadı)</string>
    <string name="reboot_userspace">Hızlı Yeniden Başlat</string>
    <string name="reboot_recovery">Kurtarma Modunda Yeniden Başlat</string>
    <string name="reboot_bootloader">Önyükleyici Modunda Yeniden Başlat</string>
    <string name="reboot_download">Download Modunda Yeniden Başlat</string>
    <string name="reboot_edl">EDL Modunda Yeniden Başlat</string>
    <string name="reboot_safe_mode">Güvenli Mod</string>
    <string name="module_version_author">%1$s, Geliştirici: %2$s</string>
    <string name="module_state_remove">Kaldır</string>
    <string name="module_action">Eylem</string>
    <string name="module_state_restore">Geri Yükle</string>
    <string name="module_action_install_external">Depolamadan yükle</string>
    <string name="update_available">Güncelleme mevcut</string>
    <string name="suspend_text_riru">Modül, %1$s etkin olduğu için askıya alındı</string>
    <string name="suspend_text_zygisk">Modül, %1$s etkin olmadığı için askıya alındı</string>
    <string name="zygisk_module_unloaded">Zygisk modülü uyumsuzluk nedeniyle yüklenmedi</string>
    <string name="module_empty">Yüklü modül yok</string>
    <string name="confirm_install">%1$s modülü yüklensin mi?</string>
    <string name="confirm_install_title">Yükleme Onayı</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Tema Modu</string>
    <string name="settings_dark_mode_message">Tarzınıza en uygun modu seçin!</string>
    <string name="settings_dark_mode_light">Her Zaman Aydınlık</string>
    <string name="settings_dark_mode_system">Sistemi Takip Et</string>
    <string name="settings_dark_mode_dark">Her Zaman Karanlık</string>
    <string name="settings_download_path_title">İndirme Yolu</string>
    <string name="settings_download_path_message">Dosyalar %1$s konumuna kaydedilecek</string>
    <string name="settings_hide_app_title">Magisk Uygulamasını Gizle</string>
    <string name="settings_hide_app_summary">Rastgele bir paket kimliği ve özel uygulama etiketi ile bir proxy uygulaması yükleyin</string>
    <string name="settings_restore_app_title">Magisk Uygulamasını Geri Yükle</string>
    <string name="settings_restore_app_summary">Uygulamanın gizliliğini kaldırın ve orijinal APK\'yi geri yükleyin</string>
    <string name="language">Dil</string>
    <string name="system_default">(Sistem Varsayılanı)</string>
    <string name="settings_check_update_title">Güncellemeleri Kontrol Et</string>
    <string name="settings_check_update_summary">Arka planda periyodik olarak güncellemeleri kontrol et</string>
    <string name="settings_update_channel_title">Güncelleme Kanalı</string>
    <string name="settings_update_stable">Kararlı</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_debug">Hata Ayıklama</string>
    <string name="settings_update_custom">Özel</string>
    <string name="settings_update_custom_msg">Özel bir kanal URL\'si girin</string>
    <string name="settings_zygisk_summary">Magisk\'in bazı kısımlarını Zygote daemon içinde çalıştırın</string>
    <string name="settings_denylist_title">Red Listesini Uygula</string>
    <string name="settings_denylist_summary">Red listesindeki işlemlerin tüm Magisk değişiklikleri geri alınacak</string>
    <string name="settings_denylist_config_title">Red Listesini Yapılandır</string>
    <string name="settings_denylist_config_summary">Red listesine dahil edilecek işlemleri seçin</string>
    <string name="settings_hosts_title">Sistemsiz Hosts</string>
    <string name="settings_hosts_summary">Reklam engelleme uygulamaları için sistemsiz hosts desteği</string>
    <string name="settings_hosts_toast">Sistemsiz hosts modülü eklendi</string>
    <string name="settings_app_name_hint">Yeni ad</string>
    <string name="settings_app_name_helper">Uygulama bu adla yeniden paketlenecek</string>
    <string name="settings_app_name_error">Geçersiz format</string>
    <string name="settings_su_app_adb">Uygulamalar ve ADB</string>
    <string name="settings_su_app">Sadece Uygulamalar</string>
    <string name="settings_su_adb">Sadece ADB</string>
    <string name="settings_su_disable">Devre Dışı</string>
    <string name="settings_su_request_10">10 Saniye</string>
    <string name="settings_su_request_15">15 Saniye</string>
    <string name="settings_su_request_20">20 Saniye</string>
    <string name="settings_su_request_30">30 Saniye</string>
    <string name="settings_su_request_45">45 Saniye</string>
    <string name="settings_su_request_60">60 Saniye</string>
    <string name="superuser_access">Süper Kullanıcı Erişimi</string>
    <string name="auto_response">Otomatik Yanıt</string>
    <string name="request_timeout">İstek Zaman Aşımı</string>
    <string name="superuser_notification">Süper Kullanıcı Bildirimi</string>
    <string name="settings_su_reauth_title">Yükseltmeden Sonra Yeniden Kimlik Doğrula</string>
    <string name="settings_su_reauth_summary">Uygulamaları yükselttikten sonra tekrar Süper Kullanıcı izinlerini iste</string>
    <string name="settings_su_tapjack_title">Dokunma Saldırısı Koruması</string>
    <string name="settings_su_tapjack_summary">Süper Kullanıcı istek penceresi, başka bir pencere veya katman tarafından engellendiğinde girdilere yanıt vermeyecektir</string>
    <string name="settings_su_auth_title">Kullanıcı Kimlik Doğrulaması</string>
    <string name="settings_su_auth_summary">Süper Kullanıcı istekleri sırasında kullanıcı kimlik doğrulaması iste</string>
    <string name="settings_su_auth_insecure">Cihazda yapılandırılmış bir kimlik doğrulama yöntemi yok</string>
    <string name="settings_su_restrict_title">Root Yeteneklerini Kısıtla</string>
    <string name="settings_su_restrict_summary">Yeni Süper Kullanıcı uygulamalarını varsayılan olarak kısıtlayacaktır. Uyarı: Bu, çoğu uygulamayı bozacaktır. Ne yaptığınızı bilmiyorsanız etkinleştirmeyin.</string>
    <string name="settings_customization">Özelleştirme</string>
    <string name="setting_add_shortcut_summary">Uygulamayı gizledikten sonra adı ve simgesi tanınması zor olursa ana ekrana güzel bir kısayol ekleyin</string>
    <string name="settings_doh_title">HTTPS üzerinden DNS</string>
    <string name="settings_doh_description">Bazı ülkelerdeki DNS zehirlenmesini aşmak için geçici çözüm</string>
    <string name="settings_random_name_title">Çıktı Adını Rastgele Yap</string>
    <string name="settings_random_name_description">Tespit edilmesini önlemek için yamalanmış imajların ve tar dosyalarının çıktı dosya adını rastgele yapın</string>
    <string name="multiuser_mode">Çoklu Kullanıcı Modu</string>
    <string name="settings_owner_only">Sadece Cihaz Sahibi</string>
    <string name="settings_owner_manage">Cihaz Sahibi Tarafından Yönetilen</string>
    <string name="settings_user_independent">Kullanıcıdan Bağımsız</string>
    <string name="owner_only_summary">Sadece cihaz sahibi root erişimine sahiptir</string>
    <string name="owner_manage_summary">Sadece cihaz sahibi root erişimini yönetebilir ve istekleri alabilir</string>
    <string name="user_independent_summary">Her kullanıcının kendi ayrı root kuralları vardır</string>
    <string name="mount_namespace_mode">Bağlama Ad Alanı Modu</string>
    <string name="settings_ns_global">Genel Ad Alanı</string>
    <string name="settings_ns_requester">Ad Alanını Devral</string>
    <string name="settings_ns_isolate">Yalıtılmış Ad Alanı</string>
    <string name="global_summary">Tüm root oturumları genel bağlama ad alanını kullanır</string>
    <string name="requester_summary">Root oturumları, istekçilerinin ad alanını devralır</string>
    <string name="isolate_summary">Her root oturumunun kendi yalıtılmış ad alanı olacaktır</string>

    <!--Notifications-->
    <string name="update_channel">Magisk güncellemeleri</string>
    <string name="progress_channel">İlerleme bildirimleri</string>
    <string name="updated_channel">Güncelleme tamamlandı</string>
    <string name="download_complete">İndirme tamamlandı</string>
    <string name="download_file_error">Dosya indirilirken hata oluştu</string>
    <string name="magisk_update_title">Magisk güncellemesi mevcut!</string>
    <string name="updated_title">Magisk güncellendi</string>
    <string name="updated_text">Uygulamayı açmak için dokunun</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Evet</string>
    <string name="no">Hayır</string>
    <string name="repo_install_title">%1$s %2$s(%3$d) Yüklensin mi?</string>
    <string name="download">İndir</string>
    <string name="reboot">Yeniden Başlat</string>
    <string name="close">Kapat</string>
    <string name="release_notes">Sürüm Notları</string>
    <string name="flashing">Flaşlanıyor…</string>
    <string name="running">Çalışıyor…</string>
    <string name="done">Bitti!</string>
    <string name="done_action">%1$s eylemi tamamlandı</string>
    <string name="failure">Başarısız!</string>
    <string name="hide_app_title">Magisk uygulaması gizleniyor…</string>
    <string name="open_link_failed_toast">Bağlantıyı açacak bir uygulama bulunamadı</string>
    <string name="complete_uninstall">Tamamen Kaldır</string>
    <string name="restore_img">İmajları Geri Yükle</string>
    <string name="restore_img_msg">Geri yükleniyor…</string>
    <string name="restore_done">Geri yükleme tamamlandı!</string>
    <string name="restore_fail">Stok yedeği mevcut değil!</string>
    <string name="setup_fail">Kurulum başarısız oldu</string>
    <string name="env_fix_title">Ek Kurulum Gerektiriyor</string>
    <string name="env_fix_msg">Cihazınızın Magisk\'in düzgün çalışması için ek kuruluma ihtiyacı var. Devam edip yeniden başlatmak ister misiniz?</string>
    <string name="env_full_fix_msg">Cihazınızın düzgün çalışması için Magisk\'i yeniden flaşlamanız gerekiyor. Lütfen Magisk\'i uygulama içinden yeniden kurun, Kurtarma modu doğru cihaz bilgisini alamaz.</string>
    <string name="setup_msg">Çalışma ortamı kuruluyor…</string>
    <string name="unsupport_magisk_title">Desteklenmeyen Magisk Sürümü</string>
    <string name="unsupport_magisk_msg">Uygulamanın bu sürümü, %1$s sürümünden daha düşük Magisk sürümlerini desteklemiyor.\n\nUygulama, Magisk yüklü değilmiş gibi davranacaktır. Lütfen Magisk\'i en kısa sürede güncelleyin.</string>
    <string name="unsupport_general_title">Anormal Durum</string>
    <string name="unsupport_system_app_msg">Bu uygulamanın bir sistem uygulaması olarak çalıştırılması desteklenmiyor. Lütfen uygulamayı bir kullanıcı uygulamasına geri döndürün.</string>
    <string name="unsupport_other_su_msg">Magisk\'e ait olmayan bir "su" ikili dosyası tespit edildi. Lütfen rakip root çözümlerini kaldırın ve/veya Magisk\'i yeniden yükleyin.</string>
    <string name="unsupport_external_storage_msg">Magisk harici depolamaya kurulmuş. Lütfen uygulamayı dahili depolamaya taşıyın.</string>
    <string name="unsupport_nonroot_stub_msg">Gizlenmiş Magisk uygulaması, root kaybolduğu için çalışmaya devam edemiyor. Lütfen orijinal APK\'yi geri yükleyin.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Bu işlevi etkinleştirmek için depolama izni verin</string>
    <string name="post_notifications_denied">Bu işlevi etkinleştirmek için bildirim izni verin</string>
    <string name="install_unknown_denied">Bu işlevi etkinleştirmek için "Bilinmeyen uygulamaları yükle" iznini verin</string>
    <string name="add_shortcut_title">Ana Ekrana Kısayol Ekle</string>
    <string name="add_shortcut_msg">Bu uygulamayı gizledikten sonra adı ve simgesi tanınması zor olabilir. Ana ekrana güzel bir kısayol eklemek ister misiniz?</string>
    <string name="app_not_found">Bu eylemi gerçekleştirecek bir uygulama bulunamadı</string>
    <string name="reboot_apply_change">Değişiklikleri uygulamak için yeniden başlatın</string>
    <string name="restore_app_confirmation">Bu, gizlenmiş uygulamayı orijinal uygulamaya geri yükleyecektir. Bunu gerçekten yapmak istiyor musunuz?</string>

</resources>

```

`app/core/src/main/res/values-uk/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Модулі</string>
    <string name="superuser">Суперкористувач</string>
    <string name="logs">Журнали</string>
    <string name="settings">Налаштування</string>
    <string name="install">Встановлення</string>
    <string name="section_home">Домашня</string>
    <string name="section_theme">Теми</string>
    <string name="denylist">DenyList</string>

    <!--Home-->
    <string name="no_connection">Немає з\’єднання</string>
    <string name="app_changelog">Список змін</string>
    <string name="loading">Завантаження…</string>
    <string name="update">Оновити</string>
    <string name="not_available">Н/Д</string>
    <string name="hide">Сховати</string>
    <string name="home_package">Пакунок</string>
    <string name="home_app_title">Застосунок</string>

    <string name="home_notice_content">Завантажуйте Magisk ЛИШЕ з офіційної сторінки на GitHub. Файли з невідомих джерел можуть містити шкідливий функціонал!</string>
    <string name="home_support_title">Підтримати нас</string>
    <string name="home_item_source">Джерело</string>
    <string name="home_support_content">Magisk є, і завжди буде безкоштовним та з відкритим кодом. Однак, якщо вам не байдуже, можете зробити невеличке пожертвування.</string>
    <string name="home_installed_version">Встановлено</string>
    <string name="home_latest_version">Найновіша</string>
    <string name="invalid_update_channel">Невірний канал оновлення</string>
    <string name="uninstall_magisk_title">Видалити Magisk</string>
    <string name="uninstall_magisk_msg">Ця дія призведе до вимкнення/видалення всіх модулів! Рут буде повністю видалено!\nВаші дані можуть зашифруватися, якщо вони не зашифровані!\nВпевнені, що бажаєте продовжити?</string>

    <!--Install-->
    <string name="keep_force_encryption">Залишити примусове шифрування</string>
    <string name="keep_dm_verity">Залишити AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Режим Recovery</string>
    <string name="install_options_title">Параметри</string>
    <string name="install_method_title">Спосіб</string>
    <string name="install_next">Далі</string>
    <string name="install_start">Встановити</string>
    <string name="manager_download_install">Натисніть, щоб завантажити і встановити</string>
    <string name="direct_install">Пряме встановлення (рекомендовано)</string>
    <string name="install_inactive_slot">Встановити в неактивний слот (після OTA)</string>
    <string name="install_inactive_slot_msg">Ваш пристрій буде примусово перезавантажено в неактивний слот!\nВикористовуйте цю опцію тільки для встановлення OTA.\nПродовжити?</string>
    <string name="setup_title">Додаткове налаштування</string>
    <string name="select_patch_file">Вибрати і пропатчити файл</string>
    <string name="patch_file_msg">Виберіть необроблений образ (*.img) або стиснутий файл ODIN (*.tar)</string>
    <string name="reboot_delay_toast">Перезавантаження через 5 секунд…</string>
    <string name="flash_screen_title">Встановлення</string>

    <!--Superuser-->
    <string name="su_request_title">Запит прав суперкористувача</string>
    <string name="touch_filtered_warning">Magisk не може перевірити вашу відповідь, тому що застосунок заступає вікно запиту прав суперкористувача</string>
    <string name="deny">Відмовити</string>
    <string name="prompt">Запитувати</string>
    <string name="grant">Надати</string>
    <string name="su_warning">Надати повний доступ до пристрою.\nЯкщо не впевнені, відмовте в доступі!</string>
    <string name="forever">Назавжди</string>
    <string name="once">Одноразово</string>
    <string name="tenmin">10 хв.</string>
    <string name="twentymin">20 хв.</string>
    <string name="thirtymin">30 хв.</string>
    <string name="sixtymin">60 хв.</string>
    <string name="su_allow_toast">%1$s надані права суперкористувача</string>
    <string name="su_deny_toast">%1$s відмовлено в правах суперкористувача</string>
    <string name="su_snack_grant">%1$s надані права суперкористувача</string>
    <string name="su_snack_deny">%1$s відмовлено в правах суперкористувача</string>
    <string name="su_snack_notif_on">Сповіщення для %1$s увімкнено</string>
    <string name="su_snack_notif_off">Сповіщення для %1$s вимкнено</string>
    <string name="su_snack_log_on">Журнал подій для %1$s увімкнено</string>
    <string name="su_snack_log_off">Журнал подій для %1$s вимкнено</string>
    <string name="su_revoke_title">Відкликати?</string>
    <string name="su_revoke_msg">Підтвердити відкликання прав для %1$s?</string>
    <string name="toast">Спливаюче сповіщення</string>
    <string name="none">Нічого</string>

    <string name="superuser_toggle_notification">Сповіщення</string>
    <string name="superuser_toggle_revoke">Відкликати</string>
    <string name="superuser_policy_none">Досі ніякий застосунок не запитував права суперкористувача</string>

    <!--Logs-->
    <string name="log_data_none">Покищо немає даних в журналі, спробуйте більше користуватися застосунками, які потребують прав суперкористувача</string>
    <string name="log_data_magisk_none">Журнал Magisk порожній, це дивно.</string>
    <string name="menuSaveLog">Зберегти журнал</string>
    <string name="menuClearLog">Очистити журнал</string>
    <string name="logs_cleared">Журнал успішно очищено</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Цільовий UID: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Показувати системні застосунки</string>
    <string name="show_os_app">Показувати вбудовані застосунки</string>
    <string name="hide_filter_hint">Фільтрувати за назвою</string>
    <string name="hide_search">Пошук</string>

    <!--Module-->
    <string name="no_info_provided">(немає наданої інформації)</string>
    <string name="reboot_userspace">Швидке перезавантаження</string>
    <string name="reboot_recovery">Перезавантажити в Recovery</string>
    <string name="reboot_bootloader">Перезавантажити в Bootloader</string>
    <string name="reboot_download">Перезавантажити в Download</string>
    <string name="reboot_edl">Перезавантажити в EDL</string>
    <string name="module_version_author">%1$s, розробник %2$s</string>
    <string name="module_state_remove">Видалити</string>
    <string name="module_state_restore">Відновити</string>
    <string name="module_action_install_external">Встановити зі сховища</string>
    <string name="update_available">Доступне оновлення</string>

    <!--Settings -->
    <string name="settings_dark_mode_title">Режим теми</string>
    <string name="settings_dark_mode_message">Виберіть режим, який вам найбільш до вподоби!</string>
    <string name="settings_dark_mode_light">Завжди світлий</string>
    <string name="settings_dark_mode_system">Слідувати системному</string>
    <string name="settings_dark_mode_dark">Завжди темний</string>
    <string name="settings_download_path_title">Шлях завантаження</string>
    <string name="settings_download_path_message">Файли зберігатимуться в %1$s</string>
    <string name="settings_hide_app_title">Сховати застосунок Magisk</string>
    <string name="settings_hide_app_summary">Встановити проксі-застосунок з довільним ID пакунку та назвою</string>
    <string name="settings_restore_app_title">Відновити застосунок Magisk</string>
    <string name="settings_restore_app_summary">Відновити застосунок з оригінального APK та показати його</string>
    <string name="language">Мова</string>
    <string name="system_default">(системна)</string>
    <string name="settings_check_update_title">Перевіряти оновлення</string>
    <string name="settings_check_update_summary">Періодично перевіряти оновлення у фоновому режимі</string>
    <string name="settings_update_channel_title">Канал оновлення</string>
    <string name="settings_update_stable">Стабільний реліз</string>
    <string name="settings_update_beta">Бета реліз</string>
    <string name="settings_update_custom">Власний</string>
    <string name="settings_update_custom_msg">Вставте власний URL</string>
    <string name="settings_zygisk_summary">Запускати частини Magisk в сервісі zygote</string>
    <string name="settings_denylist_title">Увімкнути DenyList</string>
    <string name="settings_denylist_summary">Всі зміни, внесені Magisk, будуть приховані від процесів, позначених у DenyList</string>
    <string name="settings_denylist_config_title">Налаштувати DenyList</string>
    <string name="settings_denylist_config_summary">Вибрати процеси, які будуть додані до denylist</string>
    <string name="settings_hosts_title">Позасистемні хости</string>
    <string name="settings_hosts_summary">Підтримка позасистемних хостів для застосунків блокування реклами</string>
    <string name="settings_hosts_toast">Додано модуль позасистемних хостів</string>
    <string name="settings_app_name_hint">Нове ім\’я</string>
    <string name="settings_app_name_helper">Застосунок буде перезібрано з цим ім\’ям</string>
    <string name="settings_app_name_error">Неправильний формат</string>
    <string name="settings_su_app_adb">Застосунки і ADB</string>
    <string name="settings_su_app">Застосунки</string>
    <string name="settings_su_adb">ADB</string>
    <string name="settings_su_disable">Вимкнено</string>
    <string name="settings_su_request_10">10 секунд</string>
    <string name="settings_su_request_15">15 секунд</string>
    <string name="settings_su_request_20">20 секунд</string>
    <string name="settings_su_request_30">30 секунд</string>
    <string name="settings_su_request_45">45 секунд</string>
    <string name="settings_su_request_60">60 секунд</string>
    <string name="superuser_access">Доступ суперкористувача</string>
    <string name="auto_response">Автоматична відповідь</string>
    <string name="request_timeout">Час запиту</string>
    <string name="superuser_notification">Сповіщення суперкористувача</string>
    <string name="settings_su_reauth_title">Повторна автентифікація</string>
    <string name="settings_su_reauth_summary">Перевидача прав суперкористувача після оновлення застосунку</string>
    <string name="settings_su_tapjack_title">Увімкнути захист від підміни натискань</string>
    <string name="settings_su_tapjack_summary">Діалогове вікно суперкористувача не буде отримувати ввід від користувача, коли вікно перекрито іншим застосунком чи вікном</string>
    <string name="settings_customization">Оформлення</string>
    <string name="setting_add_shortcut_summary">Додати ярлик на домашній екран для зручного сприйняття застосунку після його приховування</string>
    <string name="settings_doh_title">DNS поверх HTTPS</string>
    <string name="settings_doh_description">Відключити DoH (при нестабільному підключенні)</string>

    <string name="multiuser_mode">Багатокористувацький режим</string>
    <string name="settings_owner_only">Тільки власник</string>
    <string name="settings_owner_manage">Регулювання власником</string>
    <string name="settings_user_independent">Незалежний користувач</string>
    <string name="owner_only_summary">Тільки власник має root-доступ</string>
    <string name="owner_manage_summary">Тільки власник може керувати root-доступом і опрацьовувати запити на надання доступу</string>
    <string name="user_independent_summary">Кожен користувач має власні правила root-доступу</string>

    <string name="mount_namespace_mode">Режим монтування простору імен</string>
    <string name="settings_ns_global">Глобальний простір імен</string>
    <string name="settings_ns_requester">Наслідуваний простір імен</string>
    <string name="settings_ns_isolate">Ізольований простір імен</string>
    <string name="global_summary">Всі сеанси суперкористувача використовують глобальний простір імен</string>
    <string name="requester_summary">Сеанси суперкористувача наслідують простір імен запитувача</string>
    <string name="isolate_summary">Кожнен сеанс суперкористувача має власний ізольований простір імен</string>

    <!--Notifications-->
    <string name="update_channel">Оновлення Magisk</string>
    <string name="progress_channel">Сповіщення прогресу</string>
    <string name="download_complete">Завантаження завершено</string>
    <string name="download_file_error">Помилка завантаження файлу</string>
    <string name="magisk_update_title">Доступне оновлення Magisk!</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Так</string>
    <string name="no">Ні</string>
    <string name="repo_install_title">Встановити %1$s %2$s(%3$d)</string>
    <string name="download">Завантажити</string>
    <string name="reboot">Перезавантажити</string>
    <string name="release_notes">Особливості версії</string>
    <string name="flashing">Прошивання…</string>
    <string name="done">Готово!</string>
    <string name="failure">Не вдалося!</string>
    <string name="hide_app_title">Ховання застосунку Magisk…</string>
    <string name="open_link_failed_toast">Не знайдено застосунку для відкриття посилання</string>
    <string name="complete_uninstall">Повне видалення</string>
    <string name="restore_img">Відновити розділи</string>
    <string name="restore_img_msg">Відновлення…</string>
    <string name="restore_done">Відновлення завершено!</string>
    <string name="restore_fail">Немає оригінальної резервної копії!</string>
    <string name="setup_fail">Не вдалося налаштувати</string>
    <string name="env_fix_title">Потрібне додаткове налаштування</string>
    <string name="env_fix_msg">Для вашого пристрою необхідне додаткове налаштування, щоб Magisk працював як слід. Бажаєте виконати налаштування та перезавантажити пристрій?</string>
    <string name="setup_msg">Налаштування робочого середовища…</string>
    <string name="unsupport_magisk_title">Версія Magisk не підтримується</string>
    <string name="unsupport_magisk_msg">Ця версія застосунку не підтримує версію Magisk, нижчу за %1$s.\n\nЗастосунок буде працювати так, ніби немає встановленого Magisk. Будь ласка, оновіть Magisk якнайшвидше.</string>
    <string name="unsupport_general_title">Ненормальний стан</string>
    <string name="unsupport_system_app_msg">Запуск цього застосунку як системний застосунок не підтримується. Будь ласка, перевстановіть цей застосунок, щоб він був як звичайний застосунок, який встановлений користувачем.</string>
    <string name="unsupport_other_su_msg">Виявлено команду \"su\", яка не належить до Magisk. Будь ласка, видаліть інші непідтримувані su.</string>
    <string name="unsupport_external_storage_msg">Magisk встановлено на зовнішнє сховище. Будь ласка, перемістіть застосунок на внутрішнє сховище.</string>
    <string name="unsupport_nonroot_stub_msg">Застосунок не може продовжувати працювати в прихованому режимі, тому що втрачено root. Будь ласка, відновіть оригінальний застосунок з APK.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Надайте доступ до сховища, щоб увімкнути цей функціонал</string>
    <string name="add_shortcut_title">Ярлик на домашньому екрані</string>
    <string name="add_shortcut_msg">Після приховування цього застосунку, його значок та ім\’я будуть іншими, тому застосунок буде важко впізнати. Хочете додати ярлик на домашній екран?</string>
    <string name="app_not_found">Не знайдено застосунок, який повинен опрацювати цю дію</string>
    <string name="reboot_apply_change">Перезавантажити, щоб застосувати зміни</string>

</resources>

```

`app/core/src/main/res/values-ur/strings.xml`:

```xml
<resources>

    <string name="modules">ماڈیولز</string>
    <string name="superuser">سپر یوزر</string>
    <string name="logs">لاگز</string>
    <string name="settings">سیٹنگز</string>
    <string name="install">انسٹال کریں</string>
    <string name="section_home">ہوم</string>
    <string name="section_theme">تھیمز</string>
    <string name="denylist">مسترد فہرست</string>

    <string name="no_connection">کوئی کنکشن دستیاب نہیں</string>
    <string name="app_changelog">ایپ چینج لاگ</string>
    <string name="loading">لوڈ ہو رہا ہے…</string>
    <string name="update">اپ ڈیٹ</string>
    <string name="not_available">دستیاب نہیں</string>
    <string name="hide">چھپائیں</string>
    <string name="home_package">پیکیج</string>
    <string name="home_app_title">ایپ</string>

    <string name="home_notice_content">صرف آفیشل گٹ ہب پیج سے Magisk ڈاؤن لوڈ کریں۔ نامعلوم ذرائع سے فائلیں نقصان دہ ہو سکتی ہیں!</string>
    <string name="home_support_title">ہماری مدد کریں</string>
    <string name="home_follow_title">ہمیں فالو کریں</string>
    <string name="home_item_source">ذریعہ</string>
    <string name="home_support_content">Magisk ہمیشہ مفت اور اوپن سورس رہے گا۔ تاہم، آپ عطیہ کر کے ہمیں اپنی دیکھ بھال کا اظہار کر سکتے ہیں۔</string>
    <string name="home_installed_version">انسٹال شدہ</string>
    <string name="home_latest_version">تازہ ترین</string>
    <string name="invalid_update_channel">غلط اپ ڈیٹ چینل</string>
    <string name="uninstall_magisk_title">Magisk اَن انسٹال کریں</string>
    <string name="uninstall_magisk_msg">تمام ماڈیولز غیر فعال/ہٹا دیے جائیں گے!\nروٹ ہٹا دیا جائے گا!\nMagisk کے استعمال کے ذریعے غیر اینکرپٹ کی گئی کوئی بھی اندرونی اسٹوریج دوبارہ اینکرپٹ ہو جائے گی!</string>

    <string name="keep_force_encryption">جبری انکرپشن کو محفوظ رکھیں</string>
    <string name="keep_dm_verity">AVB 2.0/dm-verity کو محفوظ رکھیں</string>
    <string name="recovery_mode">ریکوری موڈ</string>
    <string name="install_options_title">آپشنز</string>
    <string name="install_method_title">طریقہ</string>
    <string name="install_next">اگلا</string>
    <string name="install_start">چلو شروع کرتے ہیں</string>
    <string name="manager_download_install">ڈاؤن لوڈ اور انسٹال کرنے کے لیے دبائیں</string>
    <string name="direct_install">براہ راست انسٹال (تجویز کردہ)</string>
    <string name="install_inactive_slot">غیر فعال سلاٹ میں انسٹال کریں (OTA کے بعد)</string>
    <string name="install_inactive_slot_msg">ریبوٹ کے بعد آپ کا آلہ زبردستی موجودہ غیر فعال سلاٹ میں بوٹ ہو جائے گا!\nیہ آپشن صرف OTA مکمل ہونے کے بعد استعمال کریں۔\nجاری رکھیں؟</string>
    <string name="setup_title">اضافی سیٹ اپ</string>
    <string name="select_patch_file">پیچ فائل منتخب اور پیچ کریں</string>
    <string name="patch_file_msg">ایک خام امیج (*.img) یا ایک ODIN ٹار فائل (*.tar) یا ایک payload.bin (*.bin) منتخب کریں</string>
    <string name="reboot_delay_toast">5 سیکنڈ میں ریبوٹ ہو رہا ہے…</string>
    <string name="flash_screen_title">انسٹالیشن</string>

    <string name="su_request_title">سپر یوزر کی درخواست</string>
    <string name="touch_filtered_warning">چونکہ ایک ایپ سپر یوزر کی درخواست کو دھندلا کر رہی ہے، اس لیے Magisk آپ کے جواب کی تصدیق نہیں کر سکتا</string>
    <string name="deny">منع کریں</string>
    <string name="prompt">پوچھیں</string>
    <string name="grant">اجازت دیں</string>
    <string name="su_warning">اپنے آلے تک مکمل رسائی کی اجازت دیں۔\nاگر آپ کو یقین نہیں ہے تو منع کریں!</string>
    <string name="forever">ہمیشہ کے لیے</string>
    <string name="once">ایک بار</string>
    <string name="tenmin">10 منٹ</string>
    <string name="twentymin">20 منٹ</string>
    <string name="thirtymin">30 منٹ</string>
    <string name="sixtymin">60 منٹ</string>
    <string name="su_allow_toast">%1$s کو سپر یوزر کے حقوق دیئے گئے</string>
    <string name="su_deny_toast">%1$s کو سپر یوزر کے حقوق سے انکار کر دیا گیا</string>
    <string name="su_snack_grant">%1$s کے سپر یوزر حقوق دیئے گئے</string>
    <string name="su_snack_deny">%1$s کے سپر یوزر حقوق سے انکار کر دیا گیا</string>
    <string name="su_snack_notif_on">%1$s کی اطلاعات فعال ہیں</string>
    <string name="su_snack_notif_off">%1$s کی اطلاعات غیر فعال ہیں</string>
    <string name="su_snack_log_on">%1$s کی لاگنگ فعال ہے</string>
    <string name="su_snack_log_off">%1$s کی لاگنگ غیر فعال ہے</string>
    <string name="su_revoke_title">منسوخ کریں؟</string>
    <string name="su_revoke_msg">%1$s کے سپر یوزر حقوق منسوخ کرنے کی تصدیق کریں</string>
    <string name="toast">ٹوسٹ</string>
    <string name="none">کوئی نہیں</string>

    <string name="superuser_toggle_notification">اطلاعات</string>
    <string name="superuser_toggle_revoke">منسوخ کریں</string>
    <string name="superuser_policy_none">ابھی تک کسی ایپ نے سپر یوزر کی اجازت نہیں مانگی ہے۔</string>

    <string name="log_data_none">آپ لاگ فری ہیں، اپنی روٹ ایپس کو مزید استعمال کرنے کی کوشش کریں</string>
    <string name="log_data_magisk_none">Magisk لاگز خالی ہیں، یہ عجیب بات ہے</string>
    <string name="menuSaveLog">لاگ محفوظ کریں</string>
    <string name="menuClearLog">ابھی لاگ صاف کریں</string>
    <string name="logs_cleared">لاگ کامیابی سے صاف ہو گیا</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">ٹارگٹ UID: %1$d</string>
    <string name="target_pid">ماؤنٹ این ایس ٹارگٹ PID: %s</string>
    <string name="selinux_context">SELinux سیاق و سباق: %s</string>
    <string name="supp_group">اضافی گروپ: %s</string>

    <string name="show_system_app">سسٹم ایپس دکھائیں</string>
    <string name="show_os_app">OS ایپس دکھائیں</string>
    <string name="hide_filter_hint">نام سے فلٹر کریں</string>
    <string name="hide_search">تلاش کریں</string>

    <string name="no_info_provided">(کوئی معلومات فراہم نہیں کی گئی)</string>
    <string name="reboot_userspace">سافٹ ریبوٹ</string>
    <string name="reboot_recovery">ریکوری میں ریبوٹ کریں</string>
    <string name="reboot_bootloader">بوٹ لوڈر میں ریبوٹ کریں</string>
    <string name="reboot_download">ڈاؤن لوڈ میں ریبوٹ کریں</string>
    <string name="reboot_edl">EDL میں ریبوٹ کریں</string>
    <string name="reboot_safe_mode">محفوظ موڈ</string>
    <string name="module_version_author">%2$s کی جانب سے %1$s</string>
    <string name="module_state_remove">ہٹائیں</string>
    <string name="module_state_restore">بحال کریں</string>
    <string name="module_action_install_external">اسٹوریج سے انسٹال کریں</string>
    <string name="update_available">اپ ڈیٹ دستیاب ہے</string>
    <string name="suspend_text_riru">ماڈیول معطل کر دیا گیا کیونکہ %1$s فعال ہے</string>
    <string name="suspend_text_zygisk">ماڈیول معطل کر دیا گیا کیونکہ %1$s فعال نہیں ہے</string>
    <string name="zygisk_module_unloaded">غیر مطابقت کی وجہ سے Zygisk ماڈیول لوڈ نہیں ہوا</string>
    <string name="module_empty">کوئی ماڈیول انسٹال نہیں ہے</string>
    <string name="confirm_install">ماڈیول %1$s انسٹال کریں؟</string>
    <string name="confirm_install_title">انسٹالیشن کی تصدیق</string>

    <string name="settings_dark_mode_title">تھیم موڈ</string>
    <string name="settings_dark_mode_message">وہ موڈ منتخب کریں جو آپ کے انداز کے مطابق ہو!</string>
    <string name="settings_dark_mode_light">ہمیشہ لائٹ</string>
    <string name="settings_dark_mode_system">سسٹم کی پیروی کریں</string>
    <string name="settings_dark_mode_dark">ہمیشہ ڈارک</string>
    <string name="settings_download_path_title">ڈاؤن لوڈ کا راستہ</string>
    <string name="settings_download_path_message">فائلیں %1$s میں محفوظ کی جائیں گی</string>
    <string name="settings_hide_app_title">Magisk ایپ کو چھپائیں</string>
    <string name="settings_hide_app_summary">ایک رینڈم پیکیج ID اور کسٹم ایپ لیبل کے ساتھ ایک پراکسی ایپ انسٹال کریں</string>
    <string name="settings_restore_app_title">Magisk ایپ کو بحال کریں</string>
    <string name="settings_restore_app_summary">ایپ کو ان ہائیڈ کریں اور اصل APK کو بحال کریں</string>
    <string name="language">زبان</string>
    <string name="system_default">(سسٹم ڈیفالٹ)</string>
    <string name="settings_check_update_title">اپ ڈیٹس چیک کریں</string>
    <string name="settings_check_update_summary">وقفے وقفے سے پس منظر میں اپ ڈیٹس چیک کریں</string>
    <string name="settings_update_channel_title">اپ ڈیٹ چینل</string>
    <string name="settings_update_stable">مستحکم</string>
    <string name="settings_update_beta">بیٹا</string>
    <string name="settings_update_custom">کسٹم</string>
    <string name="settings_update_custom_msg">ایک کسٹم چینل URL درج کریں</string>
    <string name="settings_zygisk_summary">zygote ڈیمن میں Magisk کے کچھ حصے چلائیں</string>
    <string name="settings_denylist_title">مسترد فہرست نافذ کریں</string>
    <string name="settings_denylist_summary">مسترد فہرست میں موجود عملوں میں Magisk کی تمام ترامیم کو کالعدم قرار دیا جائے گا</string>
    <string name="settings_denylist_config_title">مسترد فہرست کی تشکیل کریں</string>
    <string name="settings_denylist_config_summary">مسترد فہرست میں شامل کرنے کے لیے عمل منتخب کریں</string>
    <string name="settings_hosts_title">سسٹم لیس ہوسٹس</string>
    <string name="settings_hosts_summary">ایڈ بلاکنگ ایپس کے لیے سسٹم لیس ہوسٹس سپورٹ</string>
    <string name="settings_hosts_toast">سسٹم لیس ہوسٹس ماڈیول شامل کیا گیا</string>
    <string name="settings_app_name_hint">نیا نام</string>
    <string name="settings_app_name_helper">ایپ کو اس نام سے دوبارہ پیک کیا جائے گا</string>
    <string name="settings_app_name_error">غلط فارمیٹ</string>
    <string name="settings_su_app_adb">ایپس اور ADB</string>
    <string name="settings_su_app">صرف ایپس</string>
    <string name="settings_su_adb">صرف ADB</string>
    <string name="settings_su_disable">غیر فعال</string>
    <string name="settings_su_request_10">10 سیکنڈ</string>
    <string name="settings_su_request_15">15 سیکنڈ</string>
    <string name="settings_su_request_20">20 سیکنڈ</string>
    <string name="settings_su_request_30">30 سیکنڈ</string>
    <string name="settings_su_request_45">45 سیکنڈ</string>
    <string name="settings_su_request_60">60 سیکنڈ</string>
    <string name="superuser_access">سپر یوزر تک رسائی</string>
    <string name="auto_response">خودکار جواب</string>
    <string name="request_timeout">درخواست کا وقت ختم</string>
    <string name="superuser_notification">سپر یوزر اطلاع</string>
    <string name="settings_su_reauth_title">اپ گریڈ کے بعد دوبارہ تصدیق کریں</string>
    <string name="settings_su_reauth_summary">ایپس کو اپ گریڈ کرنے کے بعد دوبارہ سپر یوزر کی اجازتیں مانگیں</string>
    <string name="settings_su_tapjack_title">ٹیپ جیکنگ سے تحفظ</string>
    <string name="settings_su_tapjack_summary">سپر یوزر پرامپٹ ڈائیلاگ کسی دوسری ونڈو یا اوورلے سے دھندلا ہونے کے دوران ان پٹ کا جواب نہیں دے گا</string>
    <string name="settings_su_auth_title">صارف کی تصدیق</string>
    <string name="settings_su_auth_summary">سپر یوزر کی درخواستوں کے دوران صارف کی تصدیق طلب کریں</string>
    <string name="settings_su_auth_insecure">آلے پر کوئی تصدیقی طریقہ کار تشکیل نہیں دیا گیا ہے</string>
    <string name="settings_customization">حسب ضرورت سازی</string>
    <string name="setting_add_shortcut_summary">اگر ایپ کو چھپانے کے بعد اس کا نام اور آئیکن پہچاننا مشکل ہو جائے تو ہوم اسکرین پر ایک خوبصورت شارٹ کٹ شامل کریں</string>
    <string name="settings_doh_title">HTTPS پر DNS</string>
    <string name="settings_doh_description">بعض ممالک میں DNS زہر آلودگی کا حل</string>
    <string name="settings_random_name_title">بے ترتیب آؤٹ پٹ نام</string>
    <string name="settings_random_name_description">پتہ لگانے سے بچنے کے لیے پیچ شدہ امیجز اور ٹار فائلوں کے آؤٹ پٹ فائل کے نام کو بے ترتیب بنائیں</string>

    <string name="multiuser_mode">ملٹی یوزر موڈ</string>
    <string name="settings_owner_only">صرف آلہ کا مالک</string>
    <string name="settings_owner_manage">آلہ کے مالک کے زیر انتظام</string>
    <string name="settings_user_independent">صارف سے آزاد</string>
    <string name="owner_only_summary">صرف مالک کو روٹ تک رسائی حاصل ہے</string>
    <string name="owner_manage_summary">صرف مالک روٹ تک رسائی کا انتظام کر سکتا ہے اور درخواست کے اشارے وصول کر سکتا ہے</string>
    <string name="user_independent_summary">ہر صارف کے اپنے علیحدہ روٹ کے قواعد ہیں</string>

    <string name="mount_namespace_mode">ماؤنٹ نیم اسپیس موڈ</string>
    <string name="settings_ns_global">عالمی نیم اسپیس</string>
    <string name="settings_ns_requester">نیم اسپیس وراثت میں حاصل کریں</string>
    <string name="settings_ns_isolate">آئسولیٹڈ نیم اسپیس</string>
    <string name="isolate_summary">ہر روٹ سیشن کی اپنی آئسولیٹڈ نیم اسپیس ہوگی</string>
    <string name="update_channel">Magisk اپ ڈیٹس</string>
    <string name="progress_channel">پیش رفت کی اطلاعات</string>
    <string name="updated_channel">اپ ڈیٹ مکمل</string>
    <string name="download_complete">ڈاؤن لوڈ مکمل</string>
    <string name="download_file_error">فائل ڈاؤن لوڈ کرنے میں خرابی</string>
    <string name="magisk_update_title">Magisk اپ ڈیٹ دستیاب ہے!</string>
    <string name="updated_title">Magisk اپ ڈیٹ ہو گیا</string>
    <string name="updated_text">ایپ کھولنے کے لیے ٹیپ کریں</string>
    <string name="yes">ہاں</string>
    <string name="no">نہیں</string>
    <string name="repo_install_title">%1$s %2$s (%3$d) انسٹال کریں</string>
    <string name="download">ڈاؤن لوڈ</string>
    <string name="reboot">ریبوٹ</string>
    <string name="close">بند کریں</string>
    <string name="release_notes">ریلیز نوٹ</string>
    <string name="flashing">فلیش ہو رہا ہے…</string>
    <string name="done">ہو گیا!</string>
    <string name="failure">ناکام!</string>
    <string name="hide_app_title">Magisk ایپ کو چھپایا جا رہا ہے…</string>
    <string name="open_link_failed_toast">لنک کھولنے کے لیے کوئی ایپ نہیں ملی</string>
    <string name="complete_uninstall">مکمل ان انسٹال</string>
    <string name="restore_img">تصاویر بحال کریں</string>
    <string name="restore_img_msg">بحال ہو رہا ہے…</string>
    <string name="restore_done">بحالی مکمل ہو گئی!</string>
    <string name="restore_fail">اسٹاک بیک اپ موجود نہیں ہے!</string>
    <string name="setup_fail">سیٹ اپ ناکام ہو گیا</string>
    <string name="env_full_fix_msg">Magisk کو صحیح طریقے سے کام کرنے کے لیے آپ کے آلے کو دوبارہ فلیش کرنے کی ضرورت ہے۔ براہ کرم ایپ کے اندر Magisk کو دوبارہ انسٹال کریں، ریکوری موڈ درست ڈیوائس کی معلومات حاصل نہیں کر سکتا۔</string>
    <string name="env_fix_title">اضافی سیٹ اپ درکار ہے</string>
    <string name="env_fix_msg">Magisk کو صحیح طریقے سے کام کرنے کے لیے آپ کے آلے کو اضافی سیٹ اپ کی ضرورت ہے۔ کیا آپ جاری رکھنا چاہتے ہیں اور ریبوٹ کرنا چاہتے ہیں؟</string>
    <string name="setup_msg">ماحول کا سیٹ اپ چل رہا ہے…</string>
    <string name="unsupport_magisk_title">Magisk کا غیر تعاون یافتہ ورژن</string>
    <string name="unsupport_magisk_msg">ایپ کا یہ ورژن %1$s سے کم Magisk ورژنز کو سپورٹ نہیں کرتا ہے۔\n\nایپ ایسے برتاؤ کرے گی جیسے کوئی Magisk انسٹال نہیں ہے، براہ کرم جلد از جلد Magisk کو اپ گریڈ کریں۔</string>
    <string name="unsupport_general_title">غیر معمولی حالت</string>
    <string name="unsupport_system_app_msg">سسٹم ایپ کے طور پر اس ایپ کو چلانا تعاون یافتہ نہیں ہے۔ براہ کرم ایپ کو صارف ایپ میں واپس کریں۔</string>
    <string name="unsupport_other_su_msg">Magisk کے علاوہ کسی اور "su" بائنری کا پتہ چلا ہے۔ براہ کرم کسی بھی مسابقتی روٹ حل کو ہٹا دیں اور/یا Magisk کو دوبارہ انسٹال کریں۔</string>
    <string name="unsupport_external_storage_msg">Magisk بیرونی اسٹوریج پر انسٹال ہے۔ براہ کرم ایپ کو اندرونی اسٹوریج میں منتقل کریں۔</string>
    <string name="unsupport_nonroot_stub_msg">چھپی ہوئی Magisk ایپ کام جاری نہیں رکھ سکتی کیونکہ روٹ ختم ہو گیا ہے۔ براہ کرم اصل APK کو بحال کریں۔</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">اس فعالیت کو فعال کرنے کے لیے اسٹوریج کی اجازت دیں</string>
    <string name="post_notifications_denied">اس فعالیت کو فعال کرنے کے لیے اطلاعات کی اجازت دیں</string>
    <string name="install_unknown_denied">اس فعالیت کو فعال کرنے کے لیے "نامعلوم ایپس انسٹال کریں" کی اجازت دیں</string>
    <string name="add_shortcut_title">ہوم اسکرین پر شارٹ کٹ شامل کریں</string>
    <string name="add_shortcut_msg">اس ایپ کو چھپانے کے بعد، اس کا نام اور آئیکن پہچاننا مشکل ہو سکتا ہے۔ کیا آپ ہوم اسکرین پر ایک خوبصورت شارٹ کٹ شامل کرنا چاہتے ہیں؟</string>
    <string name="app_not_found">اس عمل کو سنبھالنے کے لیے کوئی ایپ نہیں ملی</string>
    <string name="reboot_apply_change">تبدیلیاں لاگو کرنے کے لیے ریبوٹ کریں</string>
    <string name="restore_app_confirmation">یہ چھپی ہوئی ایپ کو اصل ایپ میں بحال کردے گا۔ کیا آپ واقعی ایسا کرنا چاہتے ہیں؟</string>

</resources>

      

```

`app/core/src/main/res/values-v31/themes.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- For stub on API 31+, we cannot rely on the platform SplashScreen -->
    <!-- Force using SplashScreen.Common that was used for older APIs -->
    <style name="StubSplashTheme" parent="Theme.SplashScreen.Common">
        <item name="android:enforceStatusBarContrast">false</item>
        <item name="android:enforceNavigationBarContrast">false</item>
        <item name="windowSplashScreenBackground">@color/splash_background</item>
        <item name="windowSplashScreenAnimatedIcon">@drawable/ic_magisk_padded</item>
    </style>
</resources>

```

`app/core/src/main/res/values-v34/resources.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <bool name="enable_fg_service">false</bool>
</resources>

```

`app/core/src/main/res/values-vi/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Mô-đun</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Nhật ký</string>
    <string name="settings">Cài đặt</string>
    <string name="install">Cài đặt</string>
    <string name="section_home">Trang chủ</string>
    <string name="section_theme">Chủ đề</string>
    <string name="denylist">Danh sách loại trừ</string>

    <!--Home-->
    <string name="no_connection">Không có kết nối</string>
    <string name="app_changelog">Changelog</string>
    <string name="loading">Đang tải…</string>
    <string name="update">Cập nhật</string>
    <string name="not_available">Không có sẵn</string>
    <string name="hide">Ẩn</string>
    <string name="home_package">Gói</string>
    <string name="home_app_title">Ứng dụng</string>

    <string name="home_notice_content">Chỉ nên tải Magisk từ trang GitHub chính thức. Tải tệp từ các nguồn không rõ có thể gây hại!</string>
    <string name="home_support_title">Hỗ trợ chúng tôi</string>
    <string name="home_item_source">Nguồn</string>
    <string name="home_support_content">Magisk sẽ, và luôn luôn là, miễn phí và mã nguồn mở. Tuy nhiên, bạn có thể cho chúng tôi thấy rằng bạn quan tâm bằng cách gửi một khoản đóng góp nhỏ.</string>
    <string name="home_installed_version">Cài đặt</string>
    <string name="home_latest_version">Mới nhất</string>
    <string name="invalid_update_channel">Kênh cập nhật không hợp lệ</string>
    <string name="uninstall_magisk_title">Gỡ cài đặt Magisk</string>
    <string name="uninstall_magisk_msg">Tất cả các mô-đun sẽ bị tắt hoặc bị xóa!\nRoot sẽ bị gỡ bỏ\nPhân vùng data đã tắt mã hóa thông qua Magisk sẽ bị mã hóa lại!</string>

    <!--Install-->
    <string name="keep_force_encryption">Giữ bắt buộc mã hóa</string>
    <string name="keep_dm_verity">Giữ AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Chế độ Recovery</string>
    <string name="install_options_title">Tùy chọn</string>
    <string name="install_method_title">Phương pháp</string>
    <string name="install_next">Kế tiếp</string>
    <string name="install_start">Đi nào</string>
    <string name="manager_download_install">Nhấn để tải xuống và cài đặt</string>
    <string name="direct_install">Cài đặt trực tiếp (Khuyến nghị)</string>
    <string name="install_inactive_slot">Cài đặt vào vùng không hoạt động (Sau OTA)</string>
    <string name="install_inactive_slot_msg">Thiết bị của bạn sẽ bị BUỘC khởi động vào vị trí không hoạt động hiện tại sau khi khởi động lại!\nChỉ sử dụng tùy chọn này sau khi hoàn tất OTA.\nTiếp tục chứ?</string>
    <string name="setup_title">Thiết lập bổ sung</string>
    <string name="select_patch_file">Chọn và vá tệp</string>
    <string name="patch_file_msg">Chọn đĩa ảnh (*.img) hoặc tệp tarfile ODIN (*.tar)</string>
    <string name="reboot_delay_toast">Khởi động lại sau 5 giây…</string>
    <string name="flash_screen_title">Cài đặt</string>

    <!--Superuser-->
    <string name="su_request_title">Yêu cầu Superuser</string>
    <string name="touch_filtered_warning">Vì một ứng dụng đang che phủ yêu cầu Superuser, Magisk không thể xác minh phản hồi của bạn</string>
    <string name="deny">Từ chối</string>
    <string name="prompt">Nhắc nhở</string>
    <string name="grant">Cấp phép</string>
    <string name="su_warning">Cấp toàn quyền truy cập vào thiết bị của bạn.\nTừ chối nếu bạn không chắc chắn!</string>
    <string name="forever">Mãi mãi</string>
    <string name="once">Một lần</string>
    <string name="tenmin">10 phút</string>
    <string name="twentymin">20 phút</string>
    <string name="thirtymin">30 phút</string>
    <string name="sixtymin">60 phút</string>
    <string name="su_allow_toast">%1$s đã được cấp quyền Superuser</string>
    <string name="su_deny_toast">%1$s đã bị từ chối quyền của Superuser</string>
    <string name="su_snack_grant">Quyền Superuser của %1$s được cấp</string>
    <string name="su_snack_deny">Quyền Superuser của %1$s bị từ chối</string>
    <string name="su_snack_notif_on">Thông báo của %1$s được bật</string>
    <string name="su_snack_notif_off">Thông báo của %1$s bị tắt</string>
    <string name="su_snack_log_on">Ghi nhật ký %1$s được bật</string>
    <string name="su_snack_log_off">Ghi nhật ký %1$s bị vô hiệu hóa</string>
    <string name="su_revoke_title">Thu hồi?</string>
    <string name="su_revoke_msg">Xác nhận thu hồi quyền %1$s?</string>
    <string name="toast">Thông báo nổi</string>
    <string name="none">Không có</string>

    <string name="superuser_toggle_notification">Thông báo</string>
    <string name="superuser_toggle_revoke">Thu hồi</string>
    <string name="superuser_policy_none">Chưa có ứng dụng nào yêu cầu Superuser.</string>

    <!--Logs-->
    <string name="log_data_none">Nhật ký của bạn đang trống, hãy thử sử dụng các ứng dụng root của bạn nhiều hơn</string>
    <string name="log_data_magisk_none">Nhật ký Magisk trống, điều đó thật kỳ lạ</string>
    <string name="menuSaveLog">Lưu nhật ký</string>
    <string name="menuClearLog">Xóa nhật ký ngay bây giờ</string>
    <string name="logs_cleared">Đã xóa nhật ký thành công</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">UID mục tiêu: %1$d</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">Hiển thị các ứng dụng hệ thống</string>
    <string name="show_os_app">Hiển thị các ứng dụng hệ điều hành</string>
    <string name="hide_filter_hint">Lọc theo tên</string>
    <string name="hide_search">Tìm kiếm</string>

    <!--Module-->
    <string name="no_info_provided">(Không cung cấp thông tin)</string>
    <string name="reboot_userspace">Khởi động lại</string>
    <string name="reboot_recovery">Khởi động lại vào Recovery Mode</string>
    <string name="reboot_bootloader">Khởi động lại vào Bootloader</string>
    <string name="reboot_download">Khởi động lại vào Download</string>
    <string name="reboot_edl">Khởi động lại vào EDL</string>
    <string name="module_version_author">%1$s bởi %2$s</string>
    <string name="module_state_remove">Gỡ bỏ</string>
    <string name="module_state_restore">Khôi phục</string>
    <string name="module_action_install_external">Cài đặt từ bộ nhớ</string>
    <string name="update_available">Cập nhật có sẵn</string>
    <string name="suspend_text_riru">Mô-đun bị vô hiệu hóa vì %1$s được bật</string>
    <string name="suspend_text_zygisk">Mô-đun bị vô hiệu hóa vì %1$s không được bật</string>
    <string name="zygisk_module_unloaded">Không thể tải mô-đun Zygisk vì không tương thích</string>
    <string name="module_empty">Chưa có mô-đun nào được cài đặt!</string>


    <!--Settings-->
    <string name="settings_dark_mode_title">Chế độ chủ đề</string>
    <string name="settings_dark_mode_message">Chọn chế độ phù hợp nhất với phong cách của bạn!</string>
    <string name="settings_dark_mode_light">Luôn sáng</string>
    <string name="settings_dark_mode_system">Theo hệ thống</string>
    <string name="settings_dark_mode_dark">Luôn tối</string>
    <string name="settings_download_path_title">Đường dẫn tải xuống</string>
    <string name="settings_download_path_message">Các tệp sẽ được lưu vào %1$s</string>
    <string name="settings_hide_app_title">Ẩn ứng dụng Magisk</string>
    <string name="settings_hide_app_summary">Cài đặt ứng dụng proxy với ID gói ngẫu nhiên và nhãn ứng dụng tùy chỉnh</string>
    <string name="settings_restore_app_title">Khôi phục ứng dụng Magisk</string>
    <string name="settings_restore_app_summary">Bỏ ẩn ứng dụng và khôi phục nó về APK ban đầu</string>
    <string name="language">Ngôn ngữ</string>
    <string name="system_default">(Mặc định hệ thống)</string>
    <string name="settings_check_update_title">Kiểm tra cập nhật</string>
    <string name="settings_check_update_summary">Kiểm tra định kỳ các bản cập nhật trong nền</string>
    <string name="settings_update_channel_title">Kênh cập nhật</string>
    <string name="settings_update_stable">Ổn định</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_custom">Kênh tùy chỉnh</string>
    <string name="settings_update_custom_msg">Chèn một URL tùy chỉnh</string>
    <string name="settings_zygisk_summary">Khởi chạy các thành phần của Magisk trong tiến trình nền zygote</string>
    <string name="settings_denylist_title">Thực thi danh sách loại trừ</string>
    <string name="settings_denylist_summary">Mọi sửa đổi do Magisk thực hiện sẽ bị loại khỏi các quy trình trong danh sách loại trừ</string>
    <string name="settings_denylist_config_title">Cấu hình DenyList</string>
    <string name="settings_denylist_config_summary">Chọn các quy trình được đưa vào DenyList</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">Hỗ trợ systemless hosts cho các ứng dụng chặn quảng cáo</string>
    <string name="settings_hosts_toast">Đã thêm mô-đun systemless hosts</string>
    <string name="settings_app_name_hint">Tên mới</string>
    <string name="settings_app_name_helper">Ứng dụng sẽ được đóng gói lại với tên này</string>
    <string name="settings_app_name_error">Định dạng không hợp lệ</string>
    <string name="settings_su_app_adb">Ứng dụng và ADB</string>
    <string name="settings_su_app">Chỉ ứng dụng</string>
    <string name="settings_su_adb">Chỉ ADB</string>
    <string name="settings_su_disable">Vô hiệu hóa</string>
    <string name="settings_su_request_10">10 giây</string>
    <string name="settings_su_request_15">15 giây</string>
    <string name="settings_su_request_20">20 giây</string>
    <string name="settings_su_request_30">30 giây</string>
    <string name="settings_su_request_45">45 giây</string>
    <string name="settings_su_request_60">60 giây</string>
    <string name="superuser_access">Quyền truy cập Superuser</string>
    <string name="auto_response">Đáp ứng tự động</string>
    <string name="request_timeout">Hết thời gian yêu cầu</string>
    <string name="superuser_notification">Thông báo của Superuser</string>
    <string name="settings_su_reauth_title">Xác thực lại sau khi nâng cấp</string>
    <string name="settings_su_reauth_summary">Xác thực lại quyền Superuser sau khi nâng cấp ứng dụng</string>
    <string name="settings_su_tapjack_title">Bảo vệ khỏi Tapjacking</string>
    <string name="settings_su_tapjack_summary">Hộp thoại nhắc Superuser sẽ không trả lời đầu vào khi bị che khuất bởi bất kỳ cửa sổ hoặc lớp phủ nào khác</string>
    <string name="settings_customization">Tùy biến</string>
    <string name="setting_add_shortcut_summary">Thêm một phím tắt đẹp vào màn hình trong trường hợp khó tìm ra tên và biểu tượng sau khi ẩn ứng dụng</string>
    <string name="settings_doh_title">DNS over HTTPS</string>
    <string name="settings_doh_description">Workaround DNS poisoning in some nations</string>

    <string name="multiuser_mode">Chế độ đa người dùng</string>
    <string name="settings_owner_only">Chỉ chủ sở hữu thiết bị</string>
    <string name="settings_owner_manage">Chủ sở hữu thiết bị được quản lý</string>
    <string name="settings_user_independent">Người dùng độc lập</string>
    <string name="owner_only_summary">Chỉ chủ sở hữu mới có quyền truy cập root</string>
    <string name="owner_manage_summary">Chỉ chủ sở hữu mới có thể quản lý quyền truy cập root và nhận lời nhắc yêu cầu</string>
    <string name="user_independent_summary">Mỗi người dùng có các quy tắc root riêng biệt của riêng mình</string>

    <string name="mount_namespace_mode">Chế độ cho Mount namespace</string>
    <string name="settings_ns_global">Không gian tên chung</string>
    <string name="settings_ns_requester">Không gian tên kế thừa</string>
    <string name="settings_ns_isolate">Không gian tên độc lập</string>
    <string name="global_summary">Tất cả các phiên root sử dụng không gian tên gắn kết chung</string>
    <string name="requester_summary">Phiên root sẽ kế thừa không gian tên của người yêu cầu của họ</string>
    <string name="isolate_summary">Mỗi phiên root sẽ có không gian tên riêng biệt</string>

    <!--Thông báo-->
    <string name="update_channel">Cập nhật Magisk</string>
    <string name="progress_channel">Thông báo tiến độ</string>
    <string name="updated_channel">Cập nhật hoàn tất</string>
    <string name="download_complete">Tải về hoàn tất</string>
    <string name="download_file_error">Lỗi khi tải xuống tệp</string>
    <string name="magisk_update_title">Cập nhật Magisk có sẵn!</string>
    <string name="updated_title">Đã cập nhật Magisk</string>
    <string name="updated_text">Chạm để mở ứng dụng</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Có</string>
    <string name="no">Không</string>
    <string name="repo_install_title">Cài đặt %1$s %2$s(%3$d)</string>
    <string name="download">Tải xuống</string>
    <string name="reboot">Khởi động lại</string>
    <string name="release_notes">Ghi chú bản phát hành</string>
    <string name="flashing">Đang cài…</string>
    <string name="done">Xong!</string>
    <string name="failure">Thất bại!</string>
    <string name="hide_app_title">Đang ẩn ứng dụng Magisk…</string>
    <string name="open_link_failed_toast">Không tìm thấy ứng dụng nào để mở liên kết</string>
    <string name="complete_uninstall">Hoàn thành Gỡ cài đặt</string>
    <string name="restore_img">Khôi phục đĩa ảnh boot (boot image)</string>
    <string name="restore_img_msg">Đang khôi phục…</string>
    <string name="restore_done">Đã khôi phục xong!</string>
    <string name="restore_fail">Bản sao lưu gốc không tồn tại!</string>
    <string name="setup_fail">Thiết lập không thành công</string>
    <string name="env_fix_title">Yêu cầu thiết lập bổ sung</string>
    <string name="env_fix_msg">Thiết bị của bạn cần thiết lập bổ sung để Magisk hoạt động bình thường. Bạn có muốn tiếp tục và khởi động lại không?</string>
    <string name="setup_msg">Đang chạy thiết lập môi trường…</string>
    <string name="unsupport_magisk_title">Phiên bản Magisk không được hỗ trợ</string>
    <string name="unsupport_magisk_msg">Phiên bản hiện tại của ứng dụng không hỗ trợ phiên bản Magisk thấp hơn %1$s.\n\nỨng dụng sẽ hoạt động như thể Magisk chưa được cài đặt. Vui lòng nâng cấp lên phiên bản mới nhất.</string>
    <string name="unsupport_general_title">Trạng thái bất thường</string>
    <string name="unsupport_system_app_msg">Không hỗ trợ chạy ứng dụng này dưới dạng ứng dụng hệ thống. Vui lòng hoàn nguyên ứng dụng về ứng dụng người dùng.</string>
    <string name="unsupport_other_su_msg">Một lệnh \"su\" không thuộc về Magisk được phát hiện. Vui lòng gỡ bỏ bất kì phương pháp root khác và/hoặc cài đặt lại Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk được cài đặt vào bộ nhớ ngoài. Vui lòng chuyển ứng dụng vào bộ nhớ trong.</string>
    <string name="unsupport_nonroot_stub_msg">Ứng dụng không thể tiếp tục hoạt động ở trạng thái ẩn vì mất quyền root. Vui lòng khôi phục nó trở lại APK ban đầu.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Cấp quyền lưu trữ để bật chức năng này</string>
    <string name="install_unknown_denied">Cho phép "cài đặt ứng dụng không rõ nguồn gốc" để bật chức năng này</string>
    <string name="add_shortcut_title">Thêm lối tắt vào màn hình chính</string>
    <string name="add_shortcut_msg">Sau khi ẩn ứng dụng này, tên và biểu tượng của nó có thể trở nên khó nhận ra. Bạn có muốn thêm một phím tắt đẹp vào màn hình chính không?</string>
    <string name="app_not_found">Không tìm thấy ứng dụng nào để xử lý hành động này</string>
    <string name="reboot_apply_change">Khởi động lại để áp dụng các thay đổi</string>
    <string name="restore_app_confirmation">Điều này sẽ khôi phục ứng dụng ẩn về nguyên bản. Bạn chắc chắn muốn làm điều này chứ?</string>

</resources>

```

`app/core/src/main/res/values-zh-rCN/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">模块</string>
    <string name="superuser">超级用户</string>
    <string name="logs">日志</string>
    <string name="settings">设置</string>
    <string name="install">安装</string>
    <string name="section_home">主页</string>
    <string name="section_theme">主题</string>
    <string name="denylist">排除列表</string>

    <!--Home-->
    <string name="no_connection">无法连接</string>
    <string name="app_changelog">更新日志</string>
    <string name="loading">正在加载</string>
    <string name="update">更新</string>
    <string name="not_available">无法获取</string>
    <string name="hide">不再显示</string>
    <string name="home_package">包名</string>
    <string name="home_app_title">App</string>

    <string name="home_notice_content">仅从官方 GitHub 页面下载 Magisk。未知来源的文件可能具有恶意行为！</string>
    <string name="home_support_title">支持开发</string>
    <string name="home_follow_title">关注我们</string>
    <string name="home_item_source">源代码</string>
    <string name="home_support_content">Magisk 将一直保持免费且开源，向开发者捐赠以表示支持。</string>
    <string name="home_installed_version">当前</string>
    <string name="home_latest_version">最新</string>
    <string name="invalid_update_channel">无效的更新通道</string>
    <string name="uninstall_magisk_title">卸载 Magisk</string>
    <string name="uninstall_magisk_msg">所有模块将被停用或删除！超级用户权限丢失！\n如果设备尚未加密，用户数据可能被自动加密。</string>

    <!--Install-->
    <string name="keep_force_encryption">保持强制加密</string>
    <string name="keep_dm_verity">保留 AVB 2.0/dm-verity</string>
    <string name="recovery_mode">安装到 Recovery</string>
    <string name="install_options_title">选项</string>
    <string name="install_method_title">方式</string>
    <string name="install_next">下一步</string>
    <string name="install_start">开始</string>
    <string name="manager_download_install">立即安装</string>
    <string name="direct_install">直接安装（推荐）</string>
    <string name="install_inactive_slot">安装到未使用的槽位（OTA 后）</string>
    <string name="install_inactive_slot_msg">将在重启后强制切换到另一个槽位！注意只能在 OTA 更新完成后的重启之前使用。</string>
    <string name="setup_title">修复安装</string>
    <string name="select_patch_file">选择并修补一个文件</string>
    <string name="patch_file_msg">选择一个原始映像文件（*.img）、Odin 包（*.tar）或 payload.bin（*.bin）</string>
    <string name="reboot_delay_toast">设备将在 5 秒后重启</string>
    <string name="flash_screen_title">安装</string>

    <!--Superuser-->
    <string name="su_request_title">超级用户请求</string>
    <string name="touch_filtered_warning">由于某个应用遮挡了超级用户请求界面，因此 Magisk 无法验证您的回应</string>
    <string name="deny">拒绝</string>
    <string name="prompt">提示</string>
    <string name="restrict">受限</string>
    <string name="grant">允许</string>
    <string name="su_warning">将授予对该设备的最高权限。\n如果不确定，请拒绝！</string>
    <string name="forever">永久</string>
    <string name="once">仅此一次</string>
    <string name="tenmin">10 分钟</string>
    <string name="twentymin">20 分钟</string>
    <string name="thirtymin">30 分钟</string>
    <string name="sixtymin">60 分钟</string>
    <string name="su_allow_toast">%1$s 已被授予超级用户权限</string>
    <string name="su_deny_toast">%1$s 已被拒绝超级用户权限</string>
    <string name="su_snack_grant">已授予 %1$s 超级用户权限</string>
    <string name="su_snack_deny">已拒绝 %1$s 超级用户权限</string>
    <string name="su_snack_notif_on">已启用 %1$s 的通知</string>
    <string name="su_snack_notif_off">已禁用 %1$s 的通知</string>
    <string name="su_snack_log_on">已启用对 %1$s 的日志记录</string>
    <string name="su_snack_log_off">已禁用对 %1$s 的日志记录</string>
    <string name="su_revoke_title">撤销</string>
    <string name="su_revoke_msg">确认撤销授予 %1$s 的权限？</string>
    <string name="toast">消息提示</string>
    <string name="none">无</string>

    <string name="superuser_toggle_notification">通知</string>
    <string name="superuser_toggle_revoke">撤销</string>
    <string name="superuser_policy_none">尚无应用请求超级用户权限</string>

    <!--Logs-->
    <string name="log_data_none">没有超级用户权限使用日志</string>
    <string name="log_data_magisk_none">没有 Magisk 日志</string>
    <string name="menuSaveLog">保存日志</string>
    <string name="menuClearLog">清空日志</string>
    <string name="logs_cleared">日志已清空</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">目标 UID: %1$d</string>
    <string name="target_pid">挂载命名空间目标 PID: %s</string>
    <string name="selinux_context">SELinux 上下文: %s</string>
    <string name="supp_group">补充组: %s</string>

    <!--SafetyNet-->

    <!--MagiskHide-->
    <string name="show_system_app">显示系统应用</string>
    <string name="show_os_app">显示操作系统</string>
    <string name="hide_filter_hint">按名称过滤</string>
    <string name="hide_search">搜索</string>

    <!--Module-->
    <string name="no_info_provided">（未提供信息）</string>
    <string name="reboot_userspace">软重启</string>
    <string name="reboot_recovery">重启到 Recovery</string>
    <string name="reboot_bootloader">重启到 Bootloader</string>
    <string name="reboot_download">重启到 Download</string>
    <string name="reboot_edl">重启到 EDL</string>
    <string name="reboot_safe_mode">安全模式</string>
    <string name="module_version_author">%1$s，作者 %2$s</string>
    <string name="module_state_remove">移除</string>
    <string name="module_action">操作</string>
    <string name="module_state_restore">还原</string>
    <string name="module_action_install_external">从本地安装</string>
    <string name="update_available">可更新</string>
    <string name="suspend_text_riru">%1$s 已启用，此模块暂停加载</string>
    <string name="suspend_text_zygisk">%1$s 未启用，此模块暂停加载</string>
    <string name="zygisk_module_unloaded">存在兼容性问题，此模块未加载</string>
    <string name="module_empty">未安装任何模块</string>
    <string name="confirm_install">安装模块 %1$s？</string>
    <string name="confirm_install_title">安装确认</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">主题模式</string>
    <string name="settings_dark_mode_message">选择一个模式</string>
    <string name="settings_dark_mode_light">明亮模式</string>
    <string name="settings_dark_mode_system">跟随系统</string>
    <string name="settings_dark_mode_dark">深色模式</string>
    <string name="settings_download_path_title">下载路径</string>
    <string name="settings_download_path_message">文件将保存到 %1$s</string>
    <string name="settings_hide_app_title">隐藏 Magisk 应用</string>
    <string name="settings_hide_app_summary">安装具有随机包名和自定义应用名称的代理应用</string>
    <string name="settings_restore_app_title">还原 Magisk 应用</string>
    <string name="settings_restore_app_summary">取消隐藏，恢复到原始应用</string>
    <string name="language">语言</string>
    <string name="system_default">系统默认</string>
    <string name="settings_check_update_title">检查更新</string>
    <string name="settings_check_update_summary">定期在后台检查更新</string>
    <string name="settings_update_channel_title">更新通道</string>
    <string name="settings_update_stable">稳定版</string>
    <string name="settings_update_beta">测试版</string>
    <string name="settings_update_custom">自定义通道</string>
    <string name="settings_update_custom_msg">自定义通道网址</string>
    <string name="settings_zygisk_summary">在 Zygote 中运行 Magisk</string>
    <string name="settings_denylist_title">遵守排除列表</string>
    <string name="settings_denylist_summary">Magisk 不会修改列表中的进程</string>
    <string name="settings_denylist_config_title">配置排除列表</string>
    <string name="settings_denylist_config_summary">选择加入排除列表的进程</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">为广告屏蔽应用提供 Systemless hosts 支持</string>
    <string name="settings_hosts_toast">已添加 systemless hosts 模块</string>
    <string name="settings_app_name_hint">新的应用名称</string>
    <string name="settings_app_name_helper">将使用新名称重新安装本应用</string>
    <string name="settings_app_name_error">无效输入</string>
    <string name="settings_su_app_adb">应用和 ADB</string>
    <string name="settings_su_app">仅应用</string>
    <string name="settings_su_adb">仅 ADB</string>
    <string name="settings_su_disable">已禁用</string>
    <string name="settings_su_request_10">10 秒</string>
    <string name="settings_su_request_15">15 秒</string>
    <string name="settings_su_request_20">20 秒</string>
    <string name="settings_su_request_30">30 秒</string>
    <string name="settings_su_request_45">45 秒</string>
    <string name="settings_su_request_60">60 秒</string>
    <string name="superuser_access">超级用户访问权限</string>
    <string name="auto_response">自动响应</string>
    <string name="request_timeout">请求超时</string>
    <string name="superuser_notification">超级用户通知</string>
    <string name="settings_su_reauth_title">更新后重新认证</string>
    <string name="settings_su_reauth_summary">应用更新后重新认证超级用户权限</string>
    <string name="settings_su_tapjack_title">点按劫持保护</string>
    <string name="settings_su_tapjack_summary">存在屏幕叠加层时，超级用户请求弹窗不响应允许操作</string>
    <string name="settings_su_auth_title">身份验证</string>
    <string name="settings_su_auth_summary">对超级用户请求验证身份</string>
    <string name="settings_su_auth_insecure">设备未配置验证方式</string>
    <string name="settings_su_restrict_title">限制超级用户权能</string>
    <string name="settings_su_restrict_summary">默认限制新的超级用户应用。警告，这会破坏大多数应用，不建议启用。</string>
    <string name="settings_customization">个性化</string>
    <string name="setting_add_shortcut_summary">在隐藏后难以识别名称和图标的情况下，添加快捷方式到桌面</string>
    <string name="settings_doh_title">安全 DNS（DoH）</string>
    <string name="settings_doh_description">解决某些地区的 DNS 污染问题</string>
    <string name="settings_random_name_title">随机文件名</string>
    <string name="settings_random_name_description">随机修补镜像和 tar 文件的文件名以防止检测</string>

    <string name="multiuser_mode">多用户模式</string>
    <string name="settings_owner_only">仅设备所有者</string>
    <string name="settings_owner_manage">由设备所有者管理</string>
    <string name="settings_user_independent">各用户独立</string>
    <string name="owner_only_summary">仅设备所有者有超级用户权限</string>
    <string name="owner_manage_summary">仅设备所有者能管理超级用户并接收权限请求提示</string>
    <string name="user_independent_summary">每个用户有独立的超级用户规则</string>

    <string name="mount_namespace_mode">挂载命名空间模式</string>
    <string name="settings_ns_global">全局命名空间</string>
    <string name="settings_ns_requester">继承命名空间</string>
    <string name="settings_ns_isolate">独立命名空间</string>
    <string name="global_summary">所有 ROOT 会话使用全局挂载命名空间</string>
    <string name="requester_summary">ROOT 会话继承原进程的命名空间</string>
    <string name="isolate_summary">每个 ROOT 会话使用独立的命名空间</string>

    <!--Notifications-->
    <string name="update_channel">更新提示</string>
    <string name="progress_channel">下载进度</string>
    <string name="updated_channel">更新完成</string>
    <string name="download_complete">下载完成</string>
    <string name="download_file_error">下载失败</string>
    <string name="magisk_update_title">Magisk 已发布新版本！</string>
    <string name="updated_title">Magisk 已完成更新</string>
    <string name="updated_text">点按即可打开应用</string>

    <!--Toasts, Dialogs-->
    <string name="yes">是</string>
    <string name="no">否</string>
    <string name="repo_install_title">安装 %1$s %2$s(%3$d)</string>
    <string name="download">下载</string>
    <string name="reboot">重启</string>
    <string name="close">关闭</string>
    <string name="release_notes">发布说明</string>
    <string name="flashing">正在刷入</string>
    <string name="running">运行中……</string>
    <string name="done">完成！</string>
    <string name="done_action">%1$s 操作运行完成</string>
    <string name="failure">失败</string>
    <string name="hide_app_title">正在隐藏 Magisk 应用</string>
    <string name="open_link_failed_toast">找不到能打开此链接的应用</string>
    <string name="complete_uninstall">完全卸载</string>
    <string name="restore_img">还原原厂映像</string>
    <string name="restore_img_msg">正在还原</string>
    <string name="restore_done">已还原</string>
    <string name="restore_fail">原厂 Boot 映像的备份不存在</string>
    <string name="setup_fail">安装失败</string>
    <string name="env_fix_title">需要修复运行环境</string>
    <string name="env_fix_msg">需要一些额外的安装才能使 Magisk 正常工作。完成后自动重启，是否继续？</string>
    <string name="env_full_fix_msg">需要重新安装才能使 Magisk 正常工作。请在应用内重新安装，recovery 模式无法正确获取设备信息。</string>
    <string name="setup_msg">正在修复运行环境</string>
    <string name="unsupport_magisk_title">不支持的 Magisk 版本</string>
    <string name="unsupport_magisk_msg">应用不支持低于 %1$s 版本的 Magisk，表现为未安装状态。但升级功能可用，请尽快在应用内升级 Magisk。</string>
    <string name="unsupport_general_title">异常状态</string>
    <string name="unsupport_system_app_msg">Magisk 不支持安装为系统应用，请还原为用户应用。</string>
    <string name="unsupport_other_su_msg">检测到不属于 Magisk 的 su 文件，请删除其他超级用户程序。</string>
    <string name="unsupport_external_storage_msg">不支持将 Magisk 安装到外置存储卡，请将应用移动回内部存储空间。</string>
    <string name="unsupport_nonroot_stub_msg">超级用户权限丢失，应用无法在隐藏状态下继续工作，请恢复到原始 Magisk 应用。</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">允许访问存储空间以使用此功能</string>
    <string name="post_notifications_denied">允许发送通知以使用此功能</string>
    <string name="install_unknown_denied">允许安装未知应用以使用此功能</string>
    <string name="add_shortcut_title">添加快捷方式到桌面</string>
    <string name="add_shortcut_msg">隐藏后应用的名字和图标可能难以识别。需要在桌面上添加具有原始名称和图标的快捷方式吗？</string>
    <string name="app_not_found">找不到可处理此操作的应用</string>
    <string name="reboot_apply_change">重启后生效</string>
    <string name="restore_app_confirmation">即将把隐藏的 Magisk 应用恢复回原始应用，是否继续？</string>

</resources>

```

`app/core/src/main/res/values-zh-rTW/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">模組</string>
    <string name="superuser">超級使用者</string>
    <string name="logs">紀錄</string>
    <string name="settings">設定</string>
    <string name="install">安裝</string>
    <string name="section_home">首頁</string>
    <string name="section_theme">主題</string>
    <string name="denylist">黑名單</string>

    <!--Home-->
    <string name="no_connection">無法連線</string>
    <string name="app_changelog">變更紀錄</string>
    <string name="loading">載入中……</string>
    <string name="update">更新</string>
    <string name="not_available">無</string>
    <string name="hide">隱藏</string>
    <string name="home_package">套件</string>
    <string name="home_app_title">應用程式</string>

    <string name="home_notice_content">請從官方的 Github 網頁下載 Magisk。從未知來源下載的檔案可能懷有惡意！</string>
    <string name="home_support_title">支持開發</string>
    <string name="home_follow_title">追蹤我們</string>
    <string name="home_item_source">原始碼</string>
    <string name="home_support_content">Magisk 無論現在和未來永遠是免費且開源。但您可以透過發送小額的抖內來彰顯您對我們的支持。</string>
    <string name="home_installed_version">已安裝</string>
    <string name="home_latest_version">最新</string>
    <string name="invalid_update_channel">無效的更新頻道</string>
    <string name="uninstall_magisk_title">解除安裝 Magisk</string>
    <string name="uninstall_magisk_msg">所有模組將會被停用並移除！\nRoot 將會被移除且未被加密的資料將可能被加密！</string>

    <!--Install-->
    <string name="keep_force_encryption">保持強制加密</string>
    <string name="keep_dm_verity">保持 AVB 2.0/dm-verity</string>
    <string name="recovery_mode">安裝至 Recovery</string>
    <string name="install_options_title">選項</string>
    <string name="install_method_title">安裝方式</string>
    <string name="install_next">下一步</string>
    <string name="install_start">開始執行</string>
    <string name="manager_download_install">點選以下載並安裝</string>
    <string name="direct_install">直接安裝（建議）</string>
    <string name="install_inactive_slot">安裝到非使用中的槽位（在 OTA 更新後）</string>
    <string name="install_inactive_slot_msg">您的裝置將在下次重新啟動後強制切換到非使用中的槽位！\n這個選項僅在 OTA 更新完畢後使用。\n請問是否繼續？</string>
    <string name="setup_title">修復安裝</string>
    <string name="select_patch_file">選擇並修補檔案</string>
    <string name="patch_file_msg">請選取未修改過的映像檔 (*.img) 或 Odin 的 TAR 檔案 (*.tar) 或 payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">將在 5 秒後重新啟動……</string>
    <string name="flash_screen_title">安裝</string>

    <!--Superuser-->
    <string name="su_request_title">超級使用者要求</string>
    <string name="touch_filtered_warning">由於某個應用程式遮蔽了超級使用者要求的視窗，因此 Magisk 無法驗證您的回應</string>
    <string name="deny">拒絕</string>
    <string name="prompt">提示</string>
    <string name="grant">授予</string>
    <string name="su_warning">將授予本裝置使用 Root 權限。\n如果不確定，請拒絕！</string>
    <string name="forever">永久</string>
    <string name="once">僅此一次</string>
    <string name="tenmin">10 分鐘</string>
    <string name="twentymin">20 分鐘</string>
    <string name="thirtymin">30 分鐘</string>
    <string name="sixtymin">60 分鐘</string>
    <string name="su_allow_toast">已授予 %1$s 使用超級使用者的權限</string>
    <string name="su_deny_toast">已拒絕 %1$s 使用超級使用者的權限</string>
    <string name="su_snack_grant">已授予 %1$s 使用超級使用者的權限</string>
    <string name="su_snack_deny">已拒絕 %1$s 使用超級使用者的權限</string>
    <string name="su_snack_notif_on">已啟用 %1$s 通知</string>
    <string name="su_snack_notif_off">已停用 %1$s 通知</string>
    <string name="su_snack_log_on">已啟用 %1$s 寫入紀錄</string>
    <string name="su_snack_log_off">已停用 %1$s 寫入紀錄</string>
    <string name="su_revoke_title">撤銷權限？</string>
    <string name="su_revoke_msg">確定撤銷 %1$s 的權限？</string>
    <string name="toast">快顯通知</string>
    <string name="none">無</string>

    <string name="superuser_toggle_notification">通知</string>
    <string name="superuser_toggle_revoke">撤銷</string>
    <string name="superuser_policy_none">目前沒有任何應用程式要求超級使用者的權限。</string>

    <!--Logs-->
    <string name="log_data_none">您的紀錄是空的，請嘗試使用具備需要超級使用者權限的應用程式。</string>
    <string name="log_data_magisk_none">Magisk 的紀錄是空的，很奇怪……</string>
    <string name="menuSaveLog">儲存紀錄</string>
    <string name="menuClearLog">清除紀錄</string>
    <string name="logs_cleared">已成功清除紀錄</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">目標 UID: %1$d</string>

    <!--SafetyNet-->

    <!-- MagiskHide -->
    <string name="show_system_app">顯示系統應用程式</string>
    <string name="show_os_app">顯示作業系统</string>
    <string name="hide_filter_hint">過濾名稱</string>
    <string name="hide_search">搜尋</string>

    <!--Module -->
    <string name="no_info_provided">（未提供資訊）</string>
    <string name="reboot_userspace">快速重新啟動</string>
    <string name="reboot_recovery">重新啟動至 Recovery</string>
    <string name="reboot_bootloader">重新啟動至 Bootloader</string>
    <string name="reboot_download">重新啟動至 Download</string>
    <string name="reboot_edl">重新啟動至 EDL</string>
    <string name="module_version_author">%1$s 來自 %2$s</string>
    <string name="module_state_remove">移除</string>
    <string name="module_state_restore">復原</string>
    <string name="module_action_install_external">從本機安裝</string>
    <string name="update_available">有可用的更新</string>
    <string name="suspend_text_riru">此模組因 %1$s 已啟用而暫停運作</string>
    <string name="suspend_text_zygisk">此模組因 %1$s 未啟用而暫停運作</string>
    <string name="zygisk_module_unloaded">此模組因不相容 Zygisk 而未載入</string>
    <string name="module_empty">未安裝任何模組</string>
    <string name="confirm_install">安裝模組 %1$s？</string>
    <string name="confirm_install_title">安裝確認</string>

    <!--Settings -->
    <string name="settings_dark_mode_title">主題模式</string>
    <string name="settings_dark_mode_message">選擇最符合您風格的模式！</string>
    <string name="settings_dark_mode_light">淺色模式</string>
    <string name="settings_dark_mode_system">跟隨系統</string>
    <string name="settings_dark_mode_dark">深色模式</string>
    <string name="settings_download_path_title">下載路徑</string>
    <string name="settings_download_path_message">檔案將被儲存在：%1$s</string>
    <string name="settings_hide_app_title">隱藏 Magisk</string>
    <string name="settings_hide_app_summary">安裝一個隨機套件名稱和客製化應用程式名稱的代理應用程式</string>
    <string name="settings_restore_app_title">還原 Magisk</string>
    <string name="settings_restore_app_summary">取消隱藏並還原為原始套件</string>
    <string name="language">語言</string>
    <string name="system_default">（系統預設值）</string>
    <string name="settings_check_update_title">檢查更新</string>
    <string name="settings_check_update_summary">定期於背景檢查更新</string>
    <string name="settings_update_channel_title">更新頻道</string>
    <string name="settings_update_stable">穩定版</string>
    <string name="settings_update_beta">測試版</string>
    <string name="settings_update_custom">自訂頻道</string>
    <string name="settings_update_custom_msg">輸入一個自訂的網址</string>
    <string name="settings_zygisk_summary">在 Zygote 中執行 Magisk</string>
    <string name="settings_denylist_title">強制黑名單</string>
    <string name="settings_denylist_summary">Magisk 黑名單上的處理程序將復原變更</string>
    <string name="settings_denylist_config_title">設定黑名單</string>
    <string name="settings_denylist_config_summary">選擇要包含在黑名單的處理程序</string>
    <string name="settings_hosts_title">主機（hosts）模組化</string>
    <string name="settings_hosts_summary">為廣告阻擋程式提供主機模組</string>
    <string name="settings_hosts_toast">已安裝主機模組</string>
    <string name="settings_app_name_hint">新的名稱</string>
    <string name="settings_app_name_helper">應用程式將以此名稱重新封裝</string>
    <string name="settings_app_name_error">無效的格式</string>
    <string name="settings_su_app_adb">應用程式及 ADB</string>
    <string name="settings_su_app">僅限應用程式</string>
    <string name="settings_su_adb">僅限 ADB</string>
    <string name="settings_su_disable">停用</string>
    <string name="settings_su_request_10">10 秒</string>
    <string name="settings_su_request_15">15 秒</string>
    <string name="settings_su_request_20">20 秒</string>
    <string name="settings_su_request_30">30 秒</string>
    <string name="settings_su_request_45">45 秒</string>
    <string name="settings_su_request_60">60 秒</string>
    <string name="superuser_access">超級使用者存取權限</string>
    <string name="auto_response">自動回應</string>
    <string name="request_timeout">要求逾時</string>
    <string name="superuser_notification">超級使用者通知</string>
    <string name="settings_su_reauth_title">更新後重新驗證</string>
    <string name="settings_su_reauth_summary">應用程式更新後，重新驗證超級使用者的要求</string>
    <string name="settings_su_tapjack_title">啟用點選攔截保護</string>
    <string name="settings_su_tapjack_summary">發現有其他應用程式重疊在超級使用者視窗上面時，不回應允許操作</string>
    <string name="settings_customization">客製化</string>
    <string name="setting_add_shortcut_summary">在主螢幕中新增一個精緻的捷徑。防止隱藏 Magisk 以後，其名稱與圖示將難以辨識</string>
    <string name="settings_doh_title">安全化的網域解析(DoH)</string>
    <string name="settings_doh_description">解決某些地區的 DNS 中毒問題</string>

    <string name="multiuser_mode">多重使用者模式</string>
    <string name="settings_owner_only">僅限裝置擁有者</string>
    <string name="settings_owner_manage">由裝置擁有者管理</string>
    <string name="settings_user_independent">使用者獨立管理</string>
    <string name="owner_only_summary">僅限裝置擁有者可使用 Root 權限</string>
    <string name="owner_manage_summary">僅限裝置擁有者可管理及接收 Root 權限的要求提示</string>
    <string name="user_independent_summary">每個使用者皆擁有獨立的 Root 權限規則</string>

    <string name="mount_namespace_mode">掛接命名空間模式</string>
    <string name="settings_ns_global">全域命名空間</string>
    <string name="settings_ns_requester">繼承命名空間</string>
    <string name="settings_ns_isolate">獨立命名空間</string>
    <string name="global_summary">所有 Root 工作階段皆使用全域的命名空間</string>
    <string name="requester_summary">所有 Root 工作階段皆繼承原程式的命名空間</string>
    <string name="isolate_summary">所有 Root 工作階段皆擁有獨立的命名空間</string>

    <!--Notifications-->
    <string name="update_channel">Magisk 更新</string>
    <string name="progress_channel">進度通知</string>
    <string name="updated_channel">更新完成</string>
    <string name="download_complete">下載完成</string>
    <string name="download_file_error">下載錯誤</string>
    <string name="magisk_update_title">Magisk 有可用的更新！</string>
    <string name="updated_title">Magisk 已完成更新</string>
    <string name="updated_text">點選即可開啟應用程式</string>

    <!--Toasts, Dialogs-->
    <string name="yes">是</string>
    <string name="no">否</string>
    <string name="repo_install_title">安裝 %1$s %2$s(%3$d)</string>
    <string name="download">下載</string>
    <string name="reboot">重新啟動</string>
    <string name="release_notes">版本資訊</string>
    <string name="flashing">正在刷入……</string>
    <string name="done">完成！</string>
    <string name="failure">失敗！</string>
    <string name="hide_app_title">正在隱藏 Magisk……</string>
    <string name="open_link_failed_toast">沒有可以開啟此連結的應用程式</string>
    <string name="complete_uninstall">完全解除安裝</string>
    <string name="restore_img">還原原始映像檔</string>
    <string name="restore_img_msg">正在還原……</string>
    <string name="restore_done">還原完成！</string>
    <string name="restore_fail">不存在原始備份的映像檔！</string>
    <string name="setup_fail">安裝失敗</string>
    <string name="env_fix_title">需要修復執行環境</string>
    <string name="env_fix_msg">缺少讓 Magisk 正常執行所需的檔案。請您同意讓 Magisk 額外下載安裝包進行修復安裝，修復完成後將自動重新啟動。請問您是否繼續？</string>
    <string name="env_full_fix_msg">需要重新安裝才能使 Magisk 正常工作。請在應用程式內重新安裝，recovery 模式無法正確獲取設備訊息。</string>
    <string name="setup_msg">正在修復執行環境……</string>
    <string name="unsupport_magisk_title">不支援的 Magisk 版本</string>
    <string name="unsupport_magisk_msg">此應用程式的版本不支援 Magisk %1$s 版或更低的版本。\n\nMagisk 將顯示為未安裝的狀態。不過您仍然可以升級功能，請盡快升級。</string>
    <string name="unsupport_general_title">異常狀態</string>
    <string name="unsupport_system_app_msg">本應用程式不支援以系統應用程式的方式執行。請恢復為使用者應用程式。</string>
    <string name="unsupport_other_su_msg">偵測到一個不是來自 Magisk 的「su」二進位檔案。請移除其他 Root 方案。</string>
    <string name="unsupport_external_storage_msg">應用程式已被安裝到外部儲存空間。請移動應用程式至內部儲存空間。</string>
    <string name="unsupport_nonroot_stub_msg">應用程式無法在 Root 權限遺失的情況下以隱藏模式執行。請還原為原始套件。</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">授予儲存空間存取權以啟用此功能</string>
    <string name="install_unknown_denied">允許「安裝未知應用程式」以啟用此功能</string>
    <string name="add_shortcut_title">在主螢幕中新增捷徑</string>
    <string name="add_shortcut_msg">在隱藏應用程式以後，其名稱與圖示將難以辨識。請問您想要在主螢幕中新增一個精緻的捷徑嗎？</string>
    <string name="app_not_found">沒有可以處理這個動作的應用程式</string>
    <string name="reboot_apply_change">重新啟動裝置以套用設定變更</string>
    <string name="restore_app_confirmation">這將會還原隱藏的應用程式至原始。請問您確定要執行？</string>

</resources>

```

`app/core/src/main/res/values/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="allow_timeout">
        <item>@string/forever</item>
        <item>@string/once</item>
        <item>@string/tenmin</item>
        <item>@string/twentymin</item>
        <item>@string/thirtymin</item>
        <item>@string/sixtymin</item>
    </string-array>

    <string-array name="su_access">
        <item>@string/settings_su_disable</item>
        <item>@string/settings_su_app</item>
        <item>@string/settings_su_adb</item>
        <item>@string/settings_su_app_adb</item>
    </string-array>

    <string-array name="request_timeout">
        <item>@string/settings_su_request_10</item>
        <item>@string/settings_su_request_15</item>
        <item>@string/settings_su_request_20</item>
        <item>@string/settings_su_request_30</item>
        <item>@string/settings_su_request_45</item>
        <item>@string/settings_su_request_60</item>
    </string-array>

    <string-array name="auto_response">
        <item>@string/prompt</item>
        <item>@string/deny</item>
        <item>@string/grant</item>
    </string-array>

    <string-array name="su_notification">
        <item>@string/none</item>
        <item>@string/toast</item>
    </string-array>

    <string-array name="multiuser_mode">
        <item>@string/settings_owner_only</item>
        <item>@string/settings_owner_manage</item>
        <item>@string/settings_user_independent</item>
    </string-array>

    <string-array name="multiuser_summary">
        <item>@string/owner_only_summary</item>
        <item>@string/owner_manage_summary</item>
        <item>@string/user_independent_summary</item>
    </string-array>

    <string-array name="namespace">
        <item>@string/settings_ns_global</item>
        <item>@string/settings_ns_requester</item>
        <item>@string/settings_ns_isolate</item>
    </string-array>

    <string-array name="namespace_summary">
        <item>@string/global_summary</item>
        <item>@string/requester_summary</item>
        <item>@string/isolate_summary</item>
    </string-array>

    <string-array name="update_channel">
        <item>@string/settings_update_stable</item>
        <item>@string/settings_update_beta</item>
        <item>@string/settings_update_debug</item>
        <item>@string/settings_update_custom</item>
    </string-array>
</resources>

```

`app/core/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#00AF9C</color>
    <color name="dark">#00796B</color>
    <color name="light">#e0e0e0</color>
    <color name="su_request_background">#e0e0e0</color>
    <color name="splash_background">@color/ic_launcher_background</color>
</resources>

```

`app/core/src/main/res/values/resources.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Static strings -->
    <string name="magisk" translatable="false">Magisk</string>
    <string name="zygisk" translatable="false">Zygisk</string>
    <string name="empty" translatable="false"/>

    <string name="paypal" translatable="false">PayPal</string>
    <string name="patreon" translatable="false">Patreon</string>
    <string name="twitter" translatable="false">Twitter</string>
    <string name="github" translatable="false">GitHub</string>

    <drawable name="ic_launcher">@drawable/ic_logo</drawable>

    <bool name="enable_fg_service">true</bool>

</resources>

```

`app/core/src/main/res/values/strings.xml`:

```xml
<resources>

    <!--Sections-->
    <string name="modules">Modules</string>
    <string name="superuser">Superuser</string>
    <string name="logs">Logs</string>
    <string name="settings">Settings</string>
    <string name="install">Install</string>
    <string name="section_home">Home</string>
    <string name="section_theme">Themes</string>
    <string name="denylist">DenyList</string>

    <!--Home-->
    <string name="no_connection">No connection available</string>
    <string name="app_changelog">Changelog</string>
    <string name="loading">Loading…</string>
    <string name="update">Update</string>
    <string name="not_available">N/A</string>
    <string name="hide">Hide</string>
    <string name="home_package">Package</string>
    <string name="home_app_title">App</string>
    <string name="home_notice_content">Download Magisk ONLY from the official GitHub page. Files from unknown sources can be malicious!</string>
    <string name="home_support_title">Support Us</string>
    <string name="home_follow_title">Follow Us</string>
    <string name="home_item_source">Source</string>
    <string name="home_support_content">Magisk is, and always will be, free, and open source. However, you can show us that you care by making a donation.</string>
    <string name="home_installed_version">Installed</string>
    <string name="home_latest_version">Latest</string>
    <string name="invalid_update_channel">Invalid update channel</string>
    <string name="uninstall_magisk_title">Uninstall Magisk</string>
    <string name="uninstall_magisk_msg">All modules will be disabled/removed!\nRoot will be removed!\nAny internal storage unencrypted through the use of Magisk will be re-encrypted!</string>

    <!--Install-->
    <string name="keep_force_encryption">Preserve force encryption</string>
    <string name="keep_dm_verity">Preserve AVB 2.0/dm-verity</string>
    <string name="recovery_mode">Recovery mode</string>
    <string name="install_options_title">Options</string>
    <string name="install_method_title">Method</string>
    <string name="install_next">Next</string>
    <string name="install_start">Let\'s go</string>
    <string name="manager_download_install">Press to download and install</string>
    <string name="direct_install">Direct install (Recommended)</string>
    <string name="install_inactive_slot">Install to inactive slot (After OTA)</string>
    <string name="install_inactive_slot_msg">Your device will be FORCED to boot to the current inactive slot after a reboot!\nOnly use this option after OTA is done.\nContinue?</string>
    <string name="setup_title">Additional setup</string>
    <string name="select_patch_file">Select and patch a file</string>
    <string name="patch_file_msg">Select a raw image (*.img) or an ODIN tarfile (*.tar) or a payload.bin (*.bin)</string>
    <string name="reboot_delay_toast">Rebooting in 5 seconds…</string>
    <string name="flash_screen_title">Installation</string>

    <!--Superuser-->
    <string name="su_request_title">Superuser request</string>
    <string name="touch_filtered_warning">Because an app is obscuring a Superuser request, Magisk can\'t verify your response.</string>
    <string name="deny">Deny</string>
    <string name="prompt">Prompt</string>
    <string name="restrict">Restrict</string>
    <string name="grant">Grant</string>
    <string name="su_warning">Grants full access to your device.\nDeny if you\'re not sure!</string>
    <string name="forever">Forever</string>
    <string name="once">Once</string>
    <string name="tenmin">10 mins</string>
    <string name="twentymin">20 mins</string>
    <string name="thirtymin">30 mins</string>
    <string name="sixtymin">60 mins</string>
    <string name="su_allow_toast">%1$s was granted Superuser rights</string>
    <string name="su_deny_toast">%1$s was denied Superuser rights</string>
    <string name="su_snack_grant">Superuser rights of %1$s are granted</string>
    <string name="su_snack_deny">Superuser rights of %1$s are denied</string>
    <string name="su_snack_notif_on">Notifications of %1$s are enabled</string>
    <string name="su_snack_notif_off">Notifications of %1$s are disabled</string>
    <string name="su_snack_log_on">Logging of %1$s is enabled</string>
    <string name="su_snack_log_off">Logging of %1$s is disabled</string>
    <string name="su_revoke_title">Revoke?</string>
    <string name="su_revoke_msg">Confirm to revoke %1$s Superuser rights</string>
    <string name="toast">Toast</string>
    <string name="none">None</string>
    <string name="superuser_toggle_notification">Notifications</string>
    <string name="superuser_toggle_revoke">Revoke</string>
    <string name="superuser_policy_none">No apps have asked for Superuser permission yet.</string>

    <!--Logs-->
    <string name="log_data_none">You\'re log-free. Try using your root apps more.</string>
    <string name="log_data_magisk_none">Magisk logs are empty, that\'s weird.</string>
    <string name="menuSaveLog">Save log</string>
    <string name="menuClearLog">Clear log now</string>
    <string name="logs_cleared">Log successfully cleared</string>
    <string name="pid">PID: %1$d</string>
    <string name="target_uid">Target UID: %1$d</string>
    <string name="target_pid">Target PID: %s</string>
    <string name="selinux_context">SELinux context: %s</string>
    <string name="supp_group">Supplementary group: %s</string>

    <!--MagiskHide-->
    <string name="show_system_app">Show system apps</string>
    <string name="show_os_app">Show OS apps</string>
    <string name="hide_filter_hint">Filter by name</string>
    <string name="hide_search">Search</string>

    <!--Module-->
    <string name="no_info_provided">(No info provided)</string>
    <string name="reboot_userspace">Soft reboot</string>
    <string name="reboot_recovery">Reboot to Recovery</string>
    <string name="reboot_bootloader">Reboot to Bootloader</string>
    <string name="reboot_download">Reboot to Download</string>
    <string name="reboot_edl">Reboot to EDL</string>
    <string name="reboot_safe_mode">Safe mode</string>
    <string name="module_version_author">%1$s by %2$s</string>
    <string name="module_state_remove">Remove</string>
    <string name="module_action">Action</string>
    <string name="module_state_restore">Restore</string>
    <string name="module_action_install_external">Install from storage</string>
    <string name="update_available">Update available</string>
    <string name="suspend_text_riru">Module suspended because %1$s is enabled</string>
    <string name="suspend_text_zygisk">Module suspended because %1$s isn\'t enabled</string>
    <string name="zygisk_module_unloaded">Zygisk module not loaded due to incompatibility</string>
    <string name="module_empty">No module installed</string>
    <string name="confirm_install">Install module %1$s?</string>
    <string name="confirm_install_title">Install confirmation</string>

    <!--Settings-->
    <string name="settings_dark_mode_title">Theme mode</string>
    <string name="settings_dark_mode_message">Select mode which best suits your style!</string>
    <string name="settings_dark_mode_light">Always light</string>
    <string name="settings_dark_mode_system">Follow system</string>
    <string name="settings_dark_mode_dark">Always dark</string>
    <string name="settings_download_path_title">Download path</string>
    <string name="settings_download_path_message">Files will be saved to %1$s</string>
    <string name="settings_hide_app_title">Hide the Magisk app</string>
    <string name="settings_hide_app_summary">Install a proxy app with a random package ID and custom app label</string>
    <string name="settings_restore_app_title">Restore the Magisk app</string>
    <string name="settings_restore_app_summary">Unhide the app and restore the original APK</string>
    <string name="language">Language</string>
    <string name="system_default">(System default)</string>
    <string name="settings_check_update_title">Check for updates</string>
    <string name="settings_check_update_summary">Periodically check for updates in the background</string>
    <string name="settings_update_channel_title">Update channel</string>
    <string name="settings_update_stable">Stable</string>
    <string name="settings_update_beta">Beta</string>
    <string name="settings_update_debug">Debug</string>
    <string name="settings_update_custom">Custom</string>
    <string name="settings_update_custom_msg">Insert a custom channel URL</string>
    <string name="settings_zygisk_summary">Run parts of Magisk in the Zygote daemon</string>
    <string name="settings_denylist_title">Enforce DenyList</string>
    <string name="settings_denylist_summary">Processes on the denylist will have all Magisk modifications reverted</string>
    <string name="settings_denylist_config_title">Configure DenyList</string>
    <string name="settings_denylist_config_summary">Select the processes to be included on the denylist</string>
    <string name="settings_hosts_title">Systemless hosts</string>
    <string name="settings_hosts_summary">Systemless hosts support for ad blocking apps</string>
    <string name="settings_hosts_toast">Added systemless hosts module</string>
    <string name="settings_app_name_hint">New name</string>
    <string name="settings_app_name_helper">App will be repackaged with this name</string>
    <string name="settings_app_name_error">Invalid format</string>
    <string name="settings_su_app_adb">Apps and ADB</string>
    <string name="settings_su_app">Apps only</string>
    <string name="settings_su_adb">ADB only</string>
    <string name="settings_su_disable">Disabled</string>
    <string name="settings_su_request_10">10 seconds</string>
    <string name="settings_su_request_15">15 seconds</string>
    <string name="settings_su_request_20">20 seconds</string>
    <string name="settings_su_request_30">30 seconds</string>
    <string name="settings_su_request_45">45 seconds</string>
    <string name="settings_su_request_60">60 seconds</string>
    <string name="superuser_access">Superuser access</string>
    <string name="auto_response">Automatic response</string>
    <string name="request_timeout">Request timeout</string>
    <string name="superuser_notification">Superuser notification</string>
    <string name="settings_su_reauth_title">Reauthenticate after upgrade</string>
    <string name="settings_su_reauth_summary">Ask for Superuser permissions again after upgrading apps</string>
    <string name="settings_su_tapjack_title">Tapjacking protection</string>
    <string name="settings_su_tapjack_summary">The Superuser prompt dialog won\'t respond to input while obscured by any other window or overlay</string>
    <string name="settings_su_auth_title">User authentication</string>
    <string name="settings_su_auth_summary">Ask for user authentication during Superuser requests</string>
    <string name="settings_su_auth_insecure">No authentication method is configured on the device</string>
    <string name="settings_su_restrict_title">Restrict root capabilities</string>
    <string name="settings_su_restrict_summary">Will restrict new Superuser apps by default. Warning: this will break most apps. Don\'t enable it unless you know what you\'re doing.</string>
    <string name="settings_customization">Customization</string>
    <string name="setting_add_shortcut_summary">Add a pretty shortcut to the home screen in case the name and icon are difficult to recognize after hiding the app</string>
    <string name="settings_doh_title">DNS over HTTPS</string>
    <string name="settings_doh_description">Workaround DNS poisoning in some nations</string>
    <string name="settings_random_name_title">Randomize output name</string>
    <string name="settings_random_name_description">Randomize the output file name of patched images and tar files to prevent detection</string>
    <string name="multiuser_mode">Multiuser mode</string>
    <string name="settings_owner_only">Device owner only</string>
    <string name="settings_owner_manage">Device owner managed</string>
    <string name="settings_user_independent">User-independent</string>
    <string name="owner_only_summary">Only owner has root access</string>
    <string name="owner_manage_summary">Only owner can manage root access and receive request prompts</string>
    <string name="user_independent_summary">Each user has their own separate root rules</string>
    <string name="mount_namespace_mode">Mount namespace mode</string>
    <string name="settings_ns_global">Global namespace</string>
    <string name="settings_ns_requester">Inherit namespace</string>
    <string name="settings_ns_isolate">Isolated namespace</string>
    <string name="global_summary">All root sessions use the global mount namespace</string>
    <string name="requester_summary">Root sessions will inherit their requester\'s namespace</string>
    <string name="isolate_summary">Each root session will have its own isolated namespace</string>

    <!--Notifications-->
    <string name="update_channel">Magisk updates</string>
    <string name="progress_channel">Progress notifications</string>
    <string name="updated_channel">Update complete</string>
    <string name="download_complete">Download complete</string>
    <string name="download_file_error">Error downloading file</string>
    <string name="magisk_update_title">Magisk update available!</string>
    <string name="updated_title">Magisk updated</string>
    <string name="updated_text">Tap to open app</string>

    <!--Toasts, Dialogs-->
    <string name="yes">Yes</string>
    <string name="no">No</string>
    <string name="repo_install_title">Install %1$s %2$s(%3$d)</string>
    <string name="download">Download</string>
    <string name="reboot">Reboot</string>
    <string name="close">Close</string>
    <string name="release_notes">Release notes</string>
    <string name="flashing">Flashing…</string>
    <string name="running">Running…</string>
    <string name="done">Done!</string>
    <string name="done_action">Done running action of %1$s</string>
    <string name="failure">Failed!</string>
    <string name="hide_app_title">Hiding the Magisk app…</string>
    <string name="open_link_failed_toast">No app found to open the link</string>
    <string name="complete_uninstall">Complete uninstall</string>
    <string name="restore_img">Restore images</string>
    <string name="restore_img_msg">Restoring…</string>
    <string name="restore_done">Restoration done!</string>
    <string name="restore_fail">Stock backup doesn\'t exist!</string>
    <string name="setup_fail">Setup failed</string>
    <string name="env_fix_title">Requires additional setup</string>
    <string name="env_fix_msg">Your device needs additional setup for Magisk to work properly. Do you want to proceed and reboot?</string>
    <string name="env_full_fix_msg">Your device needs reflash Magisk to work properly. Please reinstall Magisk within app, Recovery mode cannot get correct device info.</string>
    <string name="setup_msg">Running environment setup…</string>
    <string name="unsupport_magisk_title">Unsupported Magisk version</string>
    <string name="unsupport_magisk_msg">This version of the app doesn\'t support Magisk versions lower than %1$s.\n\nThe app will behave as if no Magisk is installed. Please update Magisk as soon as possible.</string>
    <string name="unsupport_general_title">Abnormal state</string>
    <string name="unsupport_system_app_msg">Running this app as a system app isn\'t supported. Please revert the app to a user app.</string>
    <string name="unsupport_other_su_msg">A \"su\" binary not from Magisk has been detected. Please remove any competing root solution and/or reinstall Magisk.</string>
    <string name="unsupport_external_storage_msg">Magisk is installed to external storage. Please move the app to internal storage.</string>
    <string name="unsupport_nonroot_stub_msg">The hidden Magisk app cannot continue to work because root was lost. Please restore the original APK.</string>
    <string name="unsupport_nonroot_stub_title">@string/settings_restore_app_title</string>
    <string name="external_rw_permission_denied">Grant storage permission to enable this functionality</string>
    <string name="post_notifications_denied">Grant notifications permission to enable this functionality</string>
    <string name="install_unknown_denied">Allow \"Install unknown apps\" to enable this functionality</string>
    <string name="add_shortcut_title">Add shortcut to home screen</string>
    <string name="add_shortcut_msg">After hiding this app, its name and icon might become difficult to recognize. Do you want to add a pretty shortcut to the home screen?</string>
    <string name="app_not_found">No app found to handle this action</string>
    <string name="reboot_apply_change">Reboot to apply changes</string>
    <string name="restore_app_confirmation">This will restore the hidden app back to the original app. Do you really want to do this?</string>

</resources>

```

`app/core/src/main/res/values/themes.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="SplashTheme" parent="Theme.SplashScreen">
        <item name="windowSplashScreenBackground">@color/splash_background</item>
        <item name="windowSplashScreenAnimatedIcon">@drawable/ic_magisk_padded</item>
    </style>
    <style name="StubSplashTheme" parent="SplashTheme"/>
</resources>

```

`app/core/src/main/res/xml/locale_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<locale-config xmlns:android="http://schemas.android.com/apk/res/android">
    <locale android:name="ar" />
    <locale android:name="ast" />
    <locale android:name="az" />
    <locale android:name="be" />
    <locale android:name="bg" />
    <locale android:name="bn" />
    <locale android:name="ca" />
    <locale android:name="cs" />
    <locale android:name="de" />
    <locale android:name="el" />
    <locale android:name="en" />
    <locale android:name="es" />
    <locale android:name="et" />
    <locale android:name="fa" />
    <locale android:name="fr" />
    <locale android:name="hi" />
    <locale android:name="hr" />
    <locale android:name="hu" />
    <locale android:name="in" />
    <locale android:name="it" />
    <locale android:name="iw" />
    <locale android:name="ja" />
    <locale android:name="ka" />
    <locale android:name="kk" />
    <locale android:name="ko" />
    <locale android:name="lt" />
    <locale android:name="mk" />
    <locale android:name="ml" />
    <locale android:name="nb" />
    <locale android:name="nl" />
    <locale android:name="pa" />
    <locale android:name="pl" />
    <locale android:name="pt-BR" />
    <locale android:name="pt-PT" />
    <locale android:name="ro" />
    <locale android:name="ru" />
    <locale android:name="sk" />
    <locale android:name="sq" />
    <locale android:name="sr" />
    <locale android:name="sv" />
    <locale android:name="sw" />
    <locale android:name="ta" />
    <locale android:name="th" />
    <locale android:name="tr" />
    <locale android:name="uk" />
    <locale android:name="vi" />
    <locale android:name="zh-CN" />
    <locale android:name="zh-TW" />
</locale-config>

```

`app/gradle.properties`:

```properties
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
# Default value: -Xmx10248m -XX:MaxPermSize=256m
org.gradle.jvmargs=-Xmx2560m -Dfile.encoding=UTF-8

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
org.gradle.parallel=true

# Enable build cache
org.gradle.caching=true

# Use K2 in kapt
kapt.use.k2=true

# Android
android.injected.testOnly=false

# Magisk
magisk.stubVersion=40
magisk.versionCode=30700

```

`app/gradle/libs.versions.toml`:

```toml
[versions]
kotlin = "2.3.0"
android = "9.0.1"
ksp = "2.3.4"
rikka = "1.3.0"
navigation = "2.9.7"
libsu = "6.0.0"
okhttp = "5.3.2"
retrofit = "3.0.0"
room = "2.8.4"

[libraries]
bcpkix = { module = "org.bouncycastle:bcpkix-jdk18on", version = "1.83" }
commons-compress = { module = "org.apache.commons:commons-compress", version = "1.28.0" }
retrofit = { module = "com.squareup.retrofit2:retrofit", version.ref = "retrofit" }
retrofit-moshi = { module = "com.squareup.retrofit2:converter-moshi", version.ref = "retrofit" }
retrofit-scalars = { module = "com.squareup.retrofit2:converter-scalars", version.ref = "retrofit" }
markwon-core = { module = "io.noties.markwon:core", version = "4.6.2" }
okhttp = { module = "com.squareup.okhttp3:okhttp", version.ref = "okhttp" }
okhttp-dnsoverhttps = { module = "com.squareup.okhttp3:okhttp-dnsoverhttps", version.ref = "okhttp" }
okhttp-logging = { module = "com.squareup.okhttp3:logging-interceptor", version.ref = "okhttp" }
timber = { module = "com.jakewharton.timber:timber", version = "5.0.1" }
jgit = { module = "org.eclipse.jgit:org.eclipse.jgit", version = "7.1.0.202411261347-r" }

# AndroidX
activity = { module = "androidx.activity:activity", version = "1.12.4" }
appcompat = { module = "androidx.appcompat:appcompat", version = "1.7.1" }
core-ktx = { module = "androidx.core:core-ktx", version = "1.17.0" }
core-splashscreen = { module = "androidx.core:core-splashscreen", version = "1.2.0" }
constraintlayout = { module = "androidx.constraintlayout:constraintlayout", version = "2.2.1" }
fragment-ktx = { module = "androidx.fragment:fragment-ktx", version = "1.8.9" }
navigation-fragment-ktx = { module = "androidx.navigation:navigation-fragment-ktx", version.ref = "navigation" }
navigation-ui-ktx = { module = "androidx.navigation:navigation-ui-ktx", version.ref = "navigation" }
profileinstaller = { module = "androidx.profileinstaller:profileinstaller", version = "1.4.1" }
recyclerview = { module = "androidx.recyclerview:recyclerview", version = "1.4.0" }
room-ktx = { module = "androidx.room:room-ktx", version.ref = "room" }
room-runtime = { module = "androidx.room:room-runtime", version.ref = "room" }
room-compiler = { module = "androidx.room:room-compiler", version.ref = "room" }
swiperefreshlayout = { module = "androidx.swiperefreshlayout:swiperefreshlayout", version = "1.2.0" }
transition = { module = "androidx.transition:transition", version = "1.7.0" }
collection-ktx = { module = "androidx.collection:collection-ktx", version = "1.5.0" }
material = { module = "com.google.android.material:material", version = "1.13.0" }
jdk-libs = { module = "com.android.tools:desugar_jdk_libs_nio", version = "2.1.5" }
test-runner = { module = "androidx.test:runner", version = "1.7.0" }
test-rules = { module = "androidx.test:rules", version = "1.7.0" }
test-junit = { module = "androidx.test.ext:junit", version = "1.3.0" }
test-uiautomator = { module = "androidx.test.uiautomator:uiautomator", version = "2.3.0" }

# topjohnwu
indeterminate-checkbox = { module = "com.github.topjohnwu:indeterminate-checkbox", version = "1.0.7" }
libsu-core = { module = "com.github.topjohnwu.libsu:core", version.ref = "libsu" }
libsu-service = { module = "com.github.topjohnwu.libsu:service", version.ref = "libsu" }
libsu-nio = { module = "com.github.topjohnwu.libsu:nio", version.ref = "libsu" }

# Rikka
rikka-recyclerview = { module = "dev.rikka.rikkax.recyclerview:recyclerview-ktx", version = "1.3.2" }
rikka-layoutinflater = { module = "dev.rikka.rikkax.layoutinflater:layoutinflater", version.ref = "rikka" }
rikka-insets = { module = "dev.rikka.rikkax.insets:insets", version.ref = "rikka" }

# Build plugins
android-gradle-plugin = { module = "com.android.tools.build:gradle", version.ref = "android" }
android-kapt-plugin = { module = "com.android.legacy-kapt:com.android.legacy-kapt.gradle.plugin", version.ref = "android" }
ksp-plugin = { module = "com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin", version.ref = "ksp" }
navigation-safe-args-plugin = { module = "androidx.navigation:navigation-safe-args-gradle-plugin", version.ref = "navigation" }
lsparanoid-plugin = { module = "org.lsposed.lsparanoid:gradle-plugin", version = "0.6.0" }
moshi-plugin = { module = "dev.zacsweers.moshix:dev.zacsweers.moshix.gradle.plugin", version = "0.34.4" }

[plugins]

```

`app/gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-9.3.0-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`app/gradlew`:

```
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH="\\\"\\\""


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`app/gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`app/settings.gradle.kts`:

```kts
@Suppress("UnstableApiUsage")
dependencyResolutionManagement {
    repositoriesMode = RepositoriesMode.FAIL_ON_PROJECT_REPOS
    repositories {
        google()
        mavenCentral()
        maven("https://jitpack.io")
    }
}
rootProject.name = "Magisk"
include(":apk", ":core", ":shared", ":stub", ":test")

```

`app/shared/build.gradle.kts`:

```kts
plugins {
    id("com.android.library")
}

setupCommon()

android {
    namespace = "com.topjohnwu.shared"
    enableKotlin = false
}

```

`app/shared/src/debug/AndroidManifest.xml`:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:usesCleartextTraffic="true"
        tools:ignore="UnusedAttribute" />

</manifest>

```

`app/shared/src/main/AndroidManifest.xml`:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:installLocation="internalOnly">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" />
    <uses-permission android:name="android.permission.HIDE_OVERLAY_WINDOWS" />
    <uses-permission android:name="android.permission.UPDATE_PACKAGES_WITHOUT_USER_ACTION" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.RUN_USER_INITIATED_JOBS" />
    <uses-permission
        android:name="android.permission.FOREGROUND_SERVICE"
        android:maxSdkVersion="33" />
    <uses-permission
        android:name="android.permission.READ_EXTERNAL_STORAGE"
        android:maxSdkVersion="29" />
    <uses-permission
        android:name="android.permission.WRITE_EXTERNAL_STORAGE"
        android:maxSdkVersion="29"
        tools:ignore="ScopedStorage" />
    <uses-permission
        android:name="android.permission.QUERY_ALL_PACKAGES"
        tools:ignore="QueryAllPackagesPermission" />

    <application
        android:allowBackup="false"
        android:enableOnBackInvokedCallback="false"
        android:label="Magisk"
        android:requestLegacyExternalStorage="true"
        android:supportsRtl="true"
        android:theme="@android:style/Theme.Translucent.NoTitleBar" />

</manifest>

```

`app/shared/src/main/java/com/topjohnwu/magisk/ProviderInstaller.java`:

```java
package com.topjohnwu.magisk;

import android.content.Context;
import android.content.pm.ApplicationInfo;

public class ProviderInstaller {

    private static final String GMS_PACKAGE_NAME = "com.google.android.gms";

    public static void install(Context context) {
        try {
            // Check if gms is a system app
            ApplicationInfo appInfo = context.getPackageManager().getApplicationInfo(GMS_PACKAGE_NAME, 0);
            if ((appInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
                return;
            }

            // Try installing new SSL provider from Google Play Service
            Context gms = context.createPackageContext(GMS_PACKAGE_NAME,
                    Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);
            gms.getClassLoader()
                    .loadClass("com.google.android.gms.common.security.ProviderInstallerImpl")
                    .getMethod("insertProvider", Context.class)
                    .invoke(null, gms);
        } catch (Exception ignored) {
        }
    }
}

```

`app/shared/src/main/java/com/topjohnwu/magisk/StubApk.java`:

```java
package com.topjohnwu.magisk;

import static android.os.Build.VERSION.SDK_INT;
import static android.os.ParcelFileDescriptor.MODE_READ_ONLY;

import android.annotation.TargetApi;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ApplicationInfo;
import android.content.res.AssetManager;
import android.content.res.Resources;
import android.content.res.loader.ResourcesLoader;
import android.content.res.loader.ResourcesProvider;
import android.os.Build;
import android.os.ParcelFileDescriptor;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.Map;

public class StubApk {
    private static File dynDir;
    private static Method addAssetPath;

    private static File getDynDir(ApplicationInfo info) {
        if (dynDir == null) {
            final String dataDir;
            if (SDK_INT >= Build.VERSION_CODES.N) {
                // Use device protected path to allow directBootAware
                dataDir = info.deviceProtectedDataDir;
            } else {
                dataDir = info.dataDir;
            }
            dynDir = new File(dataDir, "dyn");
            dynDir.mkdirs();
        }
        return dynDir;
    }

    public static File current(Context c) {
        return new File(getDynDir(c.getApplicationInfo()), "current.apk");
    }

    public static File current(ApplicationInfo info) {
        return new File(getDynDir(info), "current.apk");
    }

    public static File update(Context c) {
        return new File(getDynDir(c.getApplicationInfo()), "update.apk");
    }

    public static File update(ApplicationInfo info) {
        return new File(getDynDir(info), "update.apk");
    }

    @TargetApi(Build.VERSION_CODES.R)
    private static ResourcesLoader getResourcesLoader(File path) throws IOException {
        var loader = new ResourcesLoader();
        ResourcesProvider provider;
        if (path.isDirectory()) {
            provider = ResourcesProvider.loadFromDirectory(path.getPath(), null);
        } else {
            var fd = ParcelFileDescriptor.open(path, MODE_READ_ONLY);
            provider = ResourcesProvider.loadFromApk(fd);
        }
        loader.addProvider(provider);
        return loader;
    }

    public static void addAssetPath(Resources res, String path) {
        if (SDK_INT >= Build.VERSION_CODES.R) {
            try {
                res.addLoaders(getResourcesLoader(new File(path)));
            } catch (IOException ignored) {}
        } else {
            AssetManager asset = res.getAssets();
            try {
                if (addAssetPath == null)
                    addAssetPath = AssetManager.class.getMethod("addAssetPath", String.class);
                addAssetPath.invoke(asset, path);
            } catch (Exception ignored) {}
        }
    }

    public static void restartProcess(Activity activity) {
        Intent intent = activity.getPackageManager()
                .getLaunchIntentForPackage(activity.getPackageName());
        activity.finishAffinity();
        activity.startActivity(intent);
        Runtime.getRuntime().exit(0);
    }

    public static class Data {
        // Indices of the object array
        private static final int STUB_VERSION = 0;
        private static final int CLASS_COMPONENT_MAP = 1;
        private static final int ROOT_SERVICE = 2;
        private static final int ARR_SIZE = 3;

        private final Object[] arr;

        public Data() { arr = new Object[ARR_SIZE]; }
        public Data(Object o) { arr = (Object[]) o; }
        public Object getObject() { return arr; }

        public int getVersion() { return (int) arr[STUB_VERSION]; }
        public void setVersion(int version) { arr[STUB_VERSION] = version; }
        public Map<String, String> getClassToComponent() {
            // noinspection unchecked
            return (Map<String, String>) arr[CLASS_COMPONENT_MAP];
        }
        public void setClassToComponent(Map<String, String> map) {
            arr[CLASS_COMPONENT_MAP] = map;
        }
        public Class<?> getRootService() { return (Class<?>) arr[ROOT_SERVICE]; }
        public void setRootService(Class<?> service) { arr[ROOT_SERVICE] = service; }
    }
}

```

`app/shared/src/main/java/com/topjohnwu/magisk/utils/APKInstall.java`:

```java
package com.topjohnwu.magisk.utils;

import static android.content.pm.PackageInstaller.EXTRA_SESSION_ID;
import static android.content.pm.PackageInstaller.EXTRA_STATUS;
import static android.content.pm.PackageInstaller.STATUS_FAILURE_INVALID;
import static android.content.pm.PackageInstaller.STATUS_PENDING_USER_ACTION;
import static android.content.pm.PackageInstaller.STATUS_SUCCESS;

import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInstaller.SessionParams;
import android.net.Uri;
import android.os.Build;

import java.io.File;
import java.io.FileInputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public final class APKInstall {

    public static void transfer(InputStream in, OutputStream out) throws IOException {
        int size = 8192;
        var buffer = new byte[size];
        int read;
        while ((read = in.read(buffer, 0, size)) >= 0) {
            out.write(buffer, 0, read);
        }
    }

    public static void registerReceiver(
            Context context, BroadcastReceiver receiver, IntentFilter filter) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            // noinspection InlinedApi
            context.registerReceiver(receiver, filter, Context.RECEIVER_NOT_EXPORTED);
        } else {
            context.registerReceiver(receiver, filter);
        }
    }

    public static Session startSession(Context context) {
        return startSession(context, null, null, null);
    }

    public static Session startSession(Context context, String pkg,
                                       Runnable onFailure, Runnable onSuccess) {
        var receiver = new InstallReceiver(pkg, onSuccess, onFailure);
        context = context.getApplicationContext();
        if (pkg != null) {
            // If pkg is not null, look for package added event
            var filter = new IntentFilter(Intent.ACTION_PACKAGE_ADDED);
            filter.addDataScheme("package");
            registerReceiver(context, receiver, filter);
        }
        registerReceiver(context, receiver, new IntentFilter(receiver.sessionId));
        return receiver;
    }

    public interface Session {
        // @WorkerThread
        OutputStream openStream(Context context) throws IOException;
        // @WorkerThread @Nullable
        Intent waitIntent();
    }

    private static class InstallReceiver extends BroadcastReceiver implements Session {
        private final String packageName;
        private final Runnable onSuccess;
        private final Runnable onFailure;
        private final CountDownLatch latch = new CountDownLatch(1);
        private Intent userAction = null;

        final String sessionId = UUID.randomUUID().toString();

        private InstallReceiver(String packageName, Runnable onSuccess, Runnable onFailure) {
            this.packageName = packageName;
            this.onSuccess = onSuccess;
            this.onFailure = onFailure;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
                Uri data = intent.getData();
                if (data == null)
                    return;
                String pkg = data.getSchemeSpecificPart();
                if (pkg.equals(packageName)) {
                    onSuccess(context);
                }
            } else if (sessionId.equals(intent.getAction())) {
                int status = intent.getIntExtra(EXTRA_STATUS, STATUS_FAILURE_INVALID);
                switch (status) {
                    case STATUS_PENDING_USER_ACTION ->
                            userAction = intent.getParcelableExtra(Intent.EXTRA_INTENT);
                    case STATUS_SUCCESS -> {
                        if (packageName == null) {
                            onSuccess(context);
                        }
                    }
                    default -> {
                        int id = intent.getIntExtra(EXTRA_SESSION_ID, 0);
                        var installer = context.getPackageManager().getPackageInstaller();
                        try {
                            installer.abandonSession(id);
                        } catch (SecurityException ignored) {
                        }
                        if (onFailure != null) {
                            onFailure.run();
                        }
                        try {
                            context.getApplicationContext().unregisterReceiver(this);
                        } catch (IllegalArgumentException ignored) {
                        }
                    }
                }
                latch.countDown();
            }
        }

        private void onSuccess(Context context) {
            if (onSuccess != null)
                onSuccess.run();
            try {
                context.getApplicationContext().unregisterReceiver(this);
            } catch (IllegalArgumentException ignored) {
            }
        }

        @Override
        public Intent waitIntent() {
            try {
                // noinspection ResultOfMethodCallIgnored
                latch.await(5, TimeUnit.SECONDS);
            } catch (Exception ignored) {}
            return userAction;
        }

        @Override
        public OutputStream openStream(Context context) throws IOException {
            // noinspection InlinedApi
            var flag = PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_MUTABLE;
            var intent = new Intent(sessionId).setPackage(context.getPackageName());
            var pending = PendingIntent.getBroadcast(context, 0, intent, flag);

            var installer = context.getPackageManager().getPackageInstaller();
            var params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                params.setRequireUserAction(SessionParams.USER_ACTION_NOT_REQUIRED);
            }
            var session = installer.openSession(installer.createSession(params));
            var out = session.openWrite(sessionId, 0, -1);
            return new FilterOutputStream(out) {
                @Override
                public void write(byte[] b, int off, int len) throws IOException {
                    out.write(b, off, len);
                }
                @Override
                public void close() throws IOException {
                    super.close();
                    session.commit(pending.getIntentSender());
                    session.close();
                }
            };
        }
    }
}

```

`app/shared/src/main/java/com/topjohnwu/magisk/utils/CompoundEnumeration.java`:

```java
package com.topjohnwu.magisk.utils;

import java.util.Enumeration;
import java.util.NoSuchElementException;

public class CompoundEnumeration<E> implements Enumeration<E> {
    private Enumeration<E>[] enums;
    private int index = 0;

    @SafeVarargs
    public CompoundEnumeration(Enumeration<E> ...enums) {
        this.enums = enums;
    }

    private boolean next() {
        while (index < enums.length) {
            if (enums[index] != null && enums[index].hasMoreElements()) {
                return true;
            }
            index++;
        }
        return false;
    }

    public boolean hasMoreElements() {
        return next();
    }

    public E nextElement() {
        if (!next()) {
            throw new NoSuchElementException();
        }
        return enums[index].nextElement();
    }
}

```

`app/shared/src/main/java/com/topjohnwu/magisk/utils/DynamicClassLoader.java`:

```java
package com.topjohnwu.magisk.utils;

import android.os.Process;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.Enumeration;

import dalvik.system.BaseDexClassLoader;

public class DynamicClassLoader extends BaseDexClassLoader {

    public DynamicClassLoader(File apk) {
        this(apk, DynamicClassLoader.class.getClassLoader());
    }

    public DynamicClassLoader(File apk, ClassLoader parent) {
        // Set optimizedDirectory to null for RootService to bypass DexFile's security checks
        super(apk.getPath(), Process.myUid() == 0 ? null : apk.getParentFile(), null, parent);
    }

    @Override
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        // First check if already loaded
        Class<?> cls = findLoadedClass(name);
        if (cls != null)
            return cls;

        try {
            // Then check boot classpath
            return getSystemClassLoader().loadClass(name);
        } catch (ClassNotFoundException ignored) {
            try {
                // Next try current dex
                return findClass(name);
            } catch (ClassNotFoundException fromSuper) {
                try {
                    // Finally try parent
                    return getParent().loadClass(name);
                } catch (ClassNotFoundException e) {
                    throw fromSuper;
                }
            }
        }
    }

    @Override
    public URL getResource(String name) {
        URL resource = getSystemClassLoader().getResource(name);
        if (resource != null)
            return resource;
        resource = findResource(name);
        if (resource != null)
            return resource;
        resource = getParent().getResource(name);
        return resource;
    }

    @Override
    public Enumeration<URL> getResources(String name) throws IOException {
        return new CompoundEnumeration<>(getSystemClassLoader().getResources(name),
                findResources(name), getParent().getResources(name));
    }
}

```

`app/stub/build.gradle.kts`:

```kts
plugins {
    id("com.android.application")
    id("org.lsposed.lsparanoid")
}

lsparanoid {
    seed = if (RAND_SEED != 0) RAND_SEED else null
    includeDependencies = true
    classFilter = { true }
}

android {
    namespace = "com.topjohnwu.magisk"

    val canary = !Config.version.contains(".")
    val base = "https://github.com/topjohnwu/Magisk/releases/download/"
    val url = base + "v${Config.version}/Magisk-v${Config.version}.apk"
    val canaryUrl = base + "canary-${Config.versionCode}/"

    defaultConfig {
        applicationId = "com.topjohnwu.magisk"
        versionCode = 1
        versionName = "1.0"
        buildConfigField("String", "APK_URL", "\"$url\"")
        buildConfigField("int", "STUB_VERSION", Config.stubVersion)
    }

    buildTypes {
        release {
            if (canary) buildConfigField("String", "APK_URL", "\"${canaryUrl}app-release.apk\"")
            proguardFiles("proguard-rules.pro")
            isMinifyEnabled = true
            isShrinkResources = false
        }
        debug {
            if (canary) buildConfigField("String", "APK_URL", "\"${canaryUrl}app-debug.apk\"")
        }
    }

    buildFeatures {
        buildConfig = true
    }
}

setupStubApk()

dependencies {
    implementation(project(":shared"))
}

```

`app/stub/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

-obfuscationdictionary ../dict.txt
-classobfuscationdictionary ../dict.txt
-packageobfuscationdictionary ../dict.txt

# Excessive obfuscation
-repackageclasses
-allowaccessmodification
-keepclassmembers class com.topjohnwu.magisk.dummy.* { <init>(); }
-keepclassmembers class com.topjohnwu.magisk.DownloadActivity { <init>(); }
-keepclassmembers class com.topjohnwu.magisk.StubRootService { <init>(); }

```

`app/stub/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission
        android:name="com.android.launcher.permission.INSTALL_SHORTCUT"
        android:maxSdkVersion="25" />

    <application tools:ignore="MissingApplicationIcon">
    </application>

</manifest>

```

`app/stub/src/main/java/com/topjohnwu/magisk/ClassLoaders.java`:

```java
package com.topjohnwu.magisk;

import android.content.pm.PackageInfo;

import com.topjohnwu.magisk.dummy.DummyProvider;
import com.topjohnwu.magisk.dummy.DummyReceiver;
import com.topjohnwu.magisk.dummy.DummyService;

import java.util.HashMap;
import java.util.Map;

// Wrap the actual classloader as we only want to resolve classname
// mapping when loading from platform (via LoadedApk.mClassLoader)
class MappingClassLoader extends ClassLoader {

    private final Map<String, String> mapping;

    MappingClassLoader(ClassLoader parent, Map<String, String> m) {
        super(parent);
        mapping = m;
    }

    @Override
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        String clz = mapping.get(name);
        name = clz != null ? clz : name;
        return super.loadClass(name, resolve);
    }
}

class StubClassLoader extends ClassLoader {

    private final Map<String, Class<?>> mapping = new HashMap<>();

    StubClassLoader(PackageInfo info) {
        super(StubClassLoader.class.getClassLoader());
        for (var c : info.activities) {
            mapping.put(c.name, DownloadActivity.class);
        }
        for (var c : info.services) {
            mapping.put(c.name, DummyService.class);
        }
        for (var c : info.providers) {
            mapping.put(c.name, DummyProvider.class);
        }
        for (var c : info.receivers) {
            mapping.put(c.name, DummyReceiver.class);
        }
    }

    @Override
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        Class<?> clz = mapping.get(name);
        return clz == null ? super.loadClass(name, resolve) : clz;
    }
}

class DelegateClassLoader extends ClassLoader {

    DelegateClassLoader() {
        super();
    }

    @Override
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        return DynLoad.activeClassLoader.loadClass(name);
    }
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/DelegateComponentFactory.java`:

```java
package com.topjohnwu.magisk;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.AppComponentFactory;
import android.app.Application;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.ContentProvider;
import android.content.Intent;
import android.content.pm.ApplicationInfo;

import com.topjohnwu.magisk.dummy.DummyProvider;
import com.topjohnwu.magisk.dummy.DummyReceiver;
import com.topjohnwu.magisk.dummy.DummyService;

@SuppressLint("NewApi")
public class DelegateComponentFactory extends AppComponentFactory {

    AppComponentFactory receiver;

    public DelegateComponentFactory() {
        DynLoad.componentFactory = this;
    }

    @Override
    public ClassLoader instantiateClassLoader(ClassLoader cl, ApplicationInfo info) {
        return new DelegateClassLoader();
    }

    @Override
    public Application instantiateApplication(ClassLoader cl, String className) {
        return new StubApplication();
    }

    @Override
    public Activity instantiateActivity(ClassLoader cl, String className, Intent intent)
            throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        if (receiver != null)
            return receiver.instantiateActivity(DynLoad.activeClassLoader, className, intent);
        return create(className, DownloadActivity.class);
    }

    @Override
    public BroadcastReceiver instantiateReceiver(ClassLoader cl, String className, Intent intent)
            throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        if (receiver != null)
            return receiver.instantiateReceiver(DynLoad.activeClassLoader, className, intent);
        return create(className, DummyReceiver.class);
    }

    @Override
    public Service instantiateService(ClassLoader cl, String className, Intent intent)
            throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        if (receiver != null)
            return receiver.instantiateService(DynLoad.activeClassLoader, className, intent);
        return create(className, DummyService.class);
    }

    @Override
    public ContentProvider instantiateProvider(ClassLoader cl, String className)
            throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        if (receiver != null)
            return receiver.instantiateProvider(DynLoad.activeClassLoader, className);
        return create(className, DummyProvider.class);
    }

    private <T> T create(String name, Class<T> fallback)
            throws IllegalAccessException, InstantiationException {
        try {
            // noinspection unchecked
            return (T) DynLoad.activeClassLoader.loadClass(name).newInstance();
        } catch (ClassNotFoundException e) {
            return fallback.newInstance();
        }
    }

}

```

`app/stub/src/main/java/com/topjohnwu/magisk/DownloadActivity.java`:

```java
package com.topjohnwu.magisk;

import static android.R.string.no;
import static android.R.string.ok;
import static android.R.string.yes;
import static com.topjohnwu.magisk.R.string.dling;
import static com.topjohnwu.magisk.R.string.no_internet_msg;
import static com.topjohnwu.magisk.R.string.upgrade_msg;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.Intent;
import android.content.res.loader.ResourcesLoader;
import android.content.res.loader.ResourcesProvider;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.ParcelFileDescriptor;
import android.system.Os;
import android.system.OsConstants;
import android.util.Log;
import android.view.ContextThemeWrapper;

import com.topjohnwu.magisk.net.Networking;
import com.topjohnwu.magisk.net.Request;
import com.topjohnwu.magisk.utils.APKInstall;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.zip.InflaterInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class DownloadActivity extends Activity {

    private static final String APP_NAME = "Magisk";

    private Context themed;
    private boolean dynLoad;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        themed = new ContextThemeWrapper(this, android.R.style.Theme_DeviceDefault);

        // Only download and dynamic load full APK if hidden
        dynLoad = !getPackageName().equals(BuildConfig.APPLICATION_ID);

        // Inject resources
        try {
            loadResources();
        } catch (Exception e) {
            error(e);
        }

        ProviderInstaller.install(this);

        if (Networking.checkNetworkStatus(this)) {
            showDialog();
        } else {
            new AlertDialog.Builder(themed)
                    .setCancelable(false)
                    .setTitle(APP_NAME)
                    .setMessage(getString(no_internet_msg))
                    .setNegativeButton(ok, (d, w) -> finish())
                    .show();
        }
    }

    @Override
    public void finish() {
        super.finish();
        Runtime.getRuntime().exit(0);
    }

    private void error(Throwable e) {
        Log.e(getClass().getSimpleName(), Log.getStackTraceString(e));
        finish();
    }

    private Request request(String url) {
        return Networking.get(url).setErrorHandler((conn, e) -> error(e));
    }

    private void showDialog() {
        new AlertDialog.Builder(themed)
                .setCancelable(false)
                .setTitle(APP_NAME)
                .setMessage(getString(upgrade_msg))
                .setPositiveButton(yes, (d, w) -> dlAPK())
                .setNegativeButton(no, (d, w) -> finish())
                .show();
    }

    private void dlAPK() {
        ProgressDialog.show(themed, getString(dling), getString(dling) + " " + APP_NAME, true);
        // Download and upgrade the app
        var request = request(BuildConfig.APK_URL).setExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
        if (dynLoad) {
            request.getAsFile(StubApk.current(this), file -> StubApk.restartProcess(this));
        } else {
            request.getAsInputStream(input -> {
                var session = APKInstall.startSession(this);
                try (input; var out = session.openStream(this)) {
                    if (out != null)
                        APKInstall.transfer(input, out);
                } catch (IOException e) {
                    error(e);
                }
                Intent intent = session.waitIntent();
                if (intent != null)
                    startActivity(intent);
            });
        }
    }

    private void decryptResources(OutputStream out) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        SecretKey key = new SecretKeySpec(Bytes.key(), "AES");
        IvParameterSpec iv = new IvParameterSpec(Bytes.iv());
        cipher.init(Cipher.DECRYPT_MODE, key, iv);
        var is = new InflaterInputStream(new CipherInputStream(
                new ByteArrayInputStream(Bytes.res()), cipher));
        try (is; out) {
            APKInstall.transfer(is, out);
        }
    }

    private void loadResources() throws Exception {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            var fd = Os.memfd_create("res", 0);
            try {
                decryptResources(new FileOutputStream(fd));
                Os.lseek(fd, 0, OsConstants.SEEK_SET);
                var loader = new ResourcesLoader();
                try (var pfd = ParcelFileDescriptor.dup(fd)) {
                    loader.addProvider(ResourcesProvider.loadFromTable(pfd, null));
                    getResources().addLoaders(loader);
                }
            } finally {
                Os.close(fd);
            }
        } else {
            File res = new File(getCodeCacheDir(), "res.apk");
            try (var out = new ZipOutputStream(new FileOutputStream(res))) {
                // AndroidManifest.xml is required on Android 6-, and directory support is broken on Android 9-10
                out.putNextEntry(new ZipEntry("AndroidManifest.xml"));
                try (var stubApk = new ZipFile(getPackageCodePath())) {
                    APKInstall.transfer(stubApk.getInputStream(stubApk.getEntry("AndroidManifest.xml")), out);
                }
                out.putNextEntry(new ZipEntry("resources.arsc"));
                decryptResources(out);
            }
            StubApk.addAssetPath(getResources(), res.getPath());
        }
    }
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/DynLoad.java`:

```java
package com.topjohnwu.magisk;

import static com.topjohnwu.magisk.BuildConfig.APPLICATION_ID;

import android.app.AppComponentFactory;
import android.app.Application;
import android.app.job.JobService;
import android.content.Context;
import android.content.ContextWrapper;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ServiceInfo;
import android.os.Build;
import android.util.Log;

import com.topjohnwu.magisk.utils.APKInstall;
import com.topjohnwu.magisk.utils.DynamicClassLoader;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

@SuppressWarnings("ResultOfMethodCallIgnored")
public class DynLoad {

    static Object componentFactory;
    static ClassLoader activeClassLoader = DynLoad.class.getClassLoader();

    static StubApk.Data createApkData() {
        var data = new StubApk.Data();
        data.setVersion(BuildConfig.STUB_VERSION);
        data.setClassToComponent(new HashMap<>());
        data.setRootService(StubRootService.class);
        return data;
    }

    static void attachContext(Object o, Context context) {
        if (!(o instanceof ContextWrapper))
            return;
        try {
            Method m = ContextWrapper.class.getDeclaredMethod("attachBaseContext", Context.class);
            m.setAccessible(true);
            m.invoke(o, context);
        } catch (Exception ignored) { /* Impossible */ }
    }

    // Dynamically load APK from internal, external storage, or previous app
    static DynamicClassLoader loadApk(Context context) {
        File apk = StubApk.current(context);
        File update = StubApk.update(context);

        if (update.exists()) {
            // Rename from update
            update.renameTo(apk);
        }

        // Copy from external for easier development
        if (BuildConfig.DEBUG) {
            try {
                File external = new File(context.getExternalFilesDir(null), "magisk.apk");
                if (external.exists()) {
                    apk.delete();
                    try {
                        var in = new FileInputStream(external);
                        var out = new FileOutputStream(apk);
                        apk.setReadOnly();
                        try (in; out) {
                            APKInstall.transfer(in, out);
                        }
                    } catch (IOException e) {
                        Log.e(DynLoad.class.getSimpleName(), "", e);
                        apk.delete();
                    } finally {
                        external.delete();
                    }
                }
            } catch (SecurityException e) {
                // Do not crash in root service
            }
        }

        if (apk.exists()) {
            apk.setReadOnly();
            return new DynamicClassLoader(apk);
        }

        // If no APK is loaded, attempt to copy from previous app
        if (!context.getPackageName().equals(APPLICATION_ID)) {
            try {
                var info = context.getPackageManager().getApplicationInfo(APPLICATION_ID, 0);
                apk.delete();
                var src = new FileInputStream(info.sourceDir);
                var out = new FileOutputStream(apk);
                apk.setReadOnly();
                try (src; out) {
                    APKInstall.transfer(src, out);
                }
                return new DynamicClassLoader(apk);
            } catch (PackageManager.NameNotFoundException ignored) {
            } catch (IOException e) {
                Log.e(DynLoad.class.getSimpleName(), "", e);
                apk.delete();
            }
        }

        return null;
    }

    // Dynamically load APK and initialize the application
    static void loadAndInitializeApp(Application context) {
        // On API >= 29, AppComponentFactory will replace the ClassLoader for us
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q)
            replaceClassLoader(context);

        // noinspection InlinedApi
        int flags = PackageManager.GET_ACTIVITIES | PackageManager.GET_SERVICES
                | PackageManager.GET_PROVIDERS | PackageManager.GET_RECEIVERS
                | PackageManager.MATCH_DIRECT_BOOT_AWARE | PackageManager.MATCH_DISABLED_COMPONENTS
                | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;
        var pm = context.getPackageManager();

        final PackageInfo stubInfo;
        try {
            // noinspection WrongConstant
            stubInfo = pm.getPackageInfo(context.getPackageName(), flags);
        } catch (PackageManager.NameNotFoundException e) {
            // Impossible
            throw new RuntimeException(e);
        }

        File apk = StubApk.current(context);

        final var cl = loadApk(context);
        if (cl != null) try {
            // noinspection WrongConstant
            var apkInfo = pm.getPackageArchiveInfo(apk.getPath(), flags);
            var mapping = generateMapping(stubInfo, apkInfo);

            var data = createApkData();
            var map = data.getClassToComponent();
            // Create the inverse mapping (class to component name)
            for (var e : mapping.entrySet()) {
                map.put(e.getValue(), e.getKey());
            }

            var appInfo = apkInfo.applicationInfo;
            // Create the receiver Application with proper constructor
            var app = cl.loadClass(appInfo.className)
                    .getConstructor(Object.class)
                    .newInstance(data.getObject());

            // Create the receiver component factory
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P && componentFactory != null) {
                var delegate = (DelegateComponentFactory) componentFactory;
                if (appInfo.appComponentFactory == null) {
                    delegate.receiver = new AppComponentFactory();
                } else {
                    Object factory = cl.loadClass(appInfo.appComponentFactory).newInstance();
                    delegate.receiver = (AppComponentFactory) factory;
                }
            }

            activeClassLoader = new MappingClassLoader(cl, mapping);

            // Call Application.attachBaseContext
            attachContext(app, context);
        } catch (Exception e) {
            Log.e(DynLoad.class.getSimpleName(), "", e);
            apk.delete();
        } else {
            // Dynamic loading failed, use normal stub classloader
            activeClassLoader = new StubClassLoader(stubInfo);
        }
    }

    // Replace LoadedApk mClassLoader
    private static void replaceClassLoader(Context context) {
        // Get ContextImpl
        while (context instanceof ContextWrapper) {
            context = ((ContextWrapper) context).getBaseContext();
        }

        try {
            Field mInfo = context.getClass().getDeclaredField("mPackageInfo");
            mInfo.setAccessible(true);
            Object loadedApk = mInfo.get(context);
            assert loadedApk != null;
            Field mcl = loadedApk.getClass().getDeclaredField("mClassLoader");
            mcl.setAccessible(true);
            mcl.set(loadedApk, new DelegateClassLoader());
        } catch (Exception e) {
            // Actually impossible as this method is only called on API < 29,
            // and API 23 - 28 do not restrict access to these fields.
            Log.e(DynLoad.class.getSimpleName(), "", e);
        }
    }

    private static Map<String, String> generateMapping(PackageInfo stub, PackageInfo app) {
        var mapping = new HashMap<String, String>();
        {
            var src = stub.activities;
            var dest = app.activities;

            final ActivityInfo sa;
            final ActivityInfo da;
            final ActivityInfo sb;
            final ActivityInfo db;
            if (src[0].exported) {
                sa = src[0];
                sb = src[1];
            } else {
                sa = src[1];
                sb = src[0];
            }
            if (dest[0].exported) {
                da = dest[0];
                db = dest[1];
            } else {
                da = dest[1];
                db = dest[0];
            }
            mapping.put(sa.name, da.name);
            mapping.put(sb.name, db.name);
        }

        {
            var src = stub.services;
            var dest = app.services;

            final ServiceInfo sa;
            final ServiceInfo da;
            final ServiceInfo sb;
            final ServiceInfo db;
            if (JobService.PERMISSION_BIND.equals(src[0].permission)) {
                sa = src[0];
                sb = src[1];
            } else {
                sa = src[1];
                sb = src[0];
            }
            if (JobService.PERMISSION_BIND.equals(dest[0].permission)) {
                da = dest[0];
                db = dest[1];
            } else {
                da = dest[1];
                db = dest[0];
            }
            mapping.put(sa.name, da.name);
            mapping.put(sb.name, db.name);
        }

        {
            var src = stub.receivers;
            var dest = app.receivers;
            mapping.put(src[0].name, dest[0].name);
        }

        {
            var src = stub.providers;
            var dest = app.providers;
            mapping.put(src[0].name, dest[0].name);
        }
        return mapping;
    }
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/StubApplication.java`:

```java
package com.topjohnwu.magisk;

import android.app.Application;
import android.content.Context;

public class StubApplication extends Application {
    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        DynLoad.loadAndInitializeApp(this);
    }
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/StubRootService.java`:

```java
package com.topjohnwu.magisk;

import android.content.Context;
import android.content.ContextWrapper;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.util.Log;

import java.io.File;
import java.lang.reflect.Constructor;

public class StubRootService extends ContextWrapper {

    public StubRootService() {
        super(null);
    }

    @Override
    protected void attachBaseContext(Context base) {
        ClassLoader loader = DynLoad.loadApk(base);
        if (loader == null)
            return;

        try {
            // Create application to get the real root service class
            var data = DynLoad.createApkData();
            File apk = StubApk.current(base);
            PackageManager pm = base.getPackageManager();
            PackageInfo pkgInfo = pm.getPackageArchiveInfo(apk.getPath(), 0);
            loader.loadClass(pkgInfo.applicationInfo.className)
                    .getConstructor(Object.class)
                    .newInstance(data.getObject());

            // Create the actual RootService and call its attachBaseContext
            Constructor<?> ctor = data.getRootService().getConstructor(Object.class);
            ctor.setAccessible(true);
            Object service = ctor.newInstance(this);
            DynLoad.attachContext(service, base);
        } catch (Exception e) {
            Log.e(StubRootService.class.getSimpleName(), "", e);
        }
    }
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/dummy/DummyProvider.java`:

```java
package com.topjohnwu.magisk.dummy;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;

public class DummyProvider extends ContentProvider {
    @Override
    public boolean onCreate() {
        return false;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
        return null;
    }

    @Override
    public String getType(Uri uri) {
        return null;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        return null;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        return 0;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        return 0;
    }
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/dummy/DummyReceiver.java`:

```java
package com.topjohnwu.magisk.dummy;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

public class DummyReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {}
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/dummy/DummyService.java`:

```java
package com.topjohnwu.magisk.dummy;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;

public class DummyService extends Service {
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/net/BadRequest.java`:

```java
package com.topjohnwu.magisk.net;

import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

class BadRequest extends Request {

    private final IOException ex;

    BadRequest(IOException e) { super(null); ex = e; }

    @Override
    public Request addHeaders(String key, String value) { return this; }

    @Override
    public Result<InputStream> execForInputStream() { fail(); return new Result<>(); }

    @Override
    public void getAsFile(File out, ResponseListener<File> rs) { fail(); }

    @Override
    public void execForFile(File out) { fail(); }

    @Override
    public void getAsString(ResponseListener<String> rs) { fail(); }

    @Override
    public Result<String> execForString() { fail(); return new Result<>(); }

    @Override
    public void getAsJSONObject(ResponseListener<JSONObject> rs) { fail(); }

    @Override
    public Result<JSONObject> execForJSONObject() { fail(); return new Result<>(); }

    @Override
    public void getAsJSONArray(ResponseListener<JSONArray> rs) { fail(); }

    @Override
    public Result<JSONArray> execForJSONArray() { fail(); return new Result<>(); }

    private void fail() {
        if (err != null)
            err.onError(null, ex);
    }
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/net/ErrorHandler.java`:

```java
package com.topjohnwu.magisk.net;

import java.net.HttpURLConnection;

public interface ErrorHandler {
    void onError(HttpURLConnection conn, Exception e);
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/net/Networking.java`:

```java
package com.topjohnwu.magisk.net;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Handler;
import android.os.Looper;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;

public class Networking {

    private static final int READ_TIMEOUT = 15000;
    private static final int CONNECT_TIMEOUT = 15000;
    static Handler mainHandler = new Handler(Looper.getMainLooper());

    private static Request request(String url, String method) {
        try {
            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
            conn.setRequestMethod(method);
            conn.setReadTimeout(READ_TIMEOUT);
            conn.setConnectTimeout(CONNECT_TIMEOUT);
            return new Request(conn);
        } catch (IOException e) {
            return new BadRequest(e);
        }
    }

    public static Request get(String url) {
        return request(url, "GET");
    }

    public static boolean checkNetworkStatus(Context context) {
        ConnectivityManager manager = (ConnectivityManager)
                context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo networkInfo = manager.getActiveNetworkInfo();
        return networkInfo != null && networkInfo.isConnected();
    }
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/net/Request.java`:

```java
package com.topjohnwu.magisk.net;

import android.os.AsyncTask;

import com.topjohnwu.magisk.utils.APKInstall;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.util.Scanner;
import java.util.concurrent.Executor;

public class Request {
    private final HttpURLConnection conn;
    private Executor executor = null;
    private int code = -1;

    ErrorHandler err = null;

    private interface Requestor<T> {
        T request() throws Exception;
    }

    public class Result<T> {
        T result;

        public T getResult() {
            return result;
        }

        public int getCode() {
            return code;
        }

        public boolean isSuccess() {
            return code >= 200 && code <= 299;
        }

        public HttpURLConnection getConnection() {
            return conn;
        }
    }

    Request(HttpURLConnection c) {
        conn = c;
    }

    public Request addHeaders(String key, String value) {
        conn.setRequestProperty(key, value);
        return this;
    }

    public Request setErrorHandler(ErrorHandler handler) {
        err = handler;
        return this;
    }

    public Request setExecutor(Executor e) {
        executor = e;
        return this;
    }

    public Result<Void> connect() {
        try {
            connect0();
        } catch (IOException e) {
            if (err != null)
                err.onError(conn, e);
        }
        return new Result<>();
    }

    public Result<InputStream> execForInputStream() {
        return exec(this::getInputStream);
    }

    public void getAsInputStream(ResponseListener<InputStream> rs) {
        submit(this::getInputStream, rs);
    }

    public void getAsFile(File out, ResponseListener<File> rs) {
        submit(() -> dlFile(out), rs);
    }

    public void execForFile(File out) {
        exec(() -> dlFile(out));
    }

    public void getAsBytes(ResponseListener<byte[]> rs) {
        submit(this::dlBytes, rs);
    }

    public Result<byte[]> execForBytes() {
        return exec(this::dlBytes);
    }

    public void getAsString(ResponseListener<String> rs) {
        submit(this::dlString, rs);
    }

    public Result<String> execForString() {
        return exec(this::dlString);
    }

    public void getAsJSONObject(ResponseListener<JSONObject> rs) {
        submit(this::dlJSONObject, rs);
    }

    public Result<JSONObject> execForJSONObject() {
        return exec(this::dlJSONObject);
    }

    public void getAsJSONArray(ResponseListener<JSONArray> rs) {
        submit(this::dlJSONArray, rs);
    }

    public Result<JSONArray> execForJSONArray() {
        return exec(this::dlJSONArray);
    }

    private void connect0() throws IOException {
        conn.connect();
        code = conn.getResponseCode();
    }

    private <T> Result<T> exec(Requestor<T> req) {
        Result<T> res = new Result<>();
        try {
            res.result = req.request();
        } catch (Exception e) {
            if (err != null)
                err.onError(conn, e);
        }
        return res;
    }

    private <T> void submit(Requestor<T> req, ResponseListener<T> rs) {
        AsyncTask.THREAD_POOL_EXECUTOR.execute(() -> {
            try {
                T t = req.request();
                Runnable cb = () -> rs.onResponse(t);
                if (executor == null)
                    Networking.mainHandler.post(cb);
                else
                    executor.execute(cb);
            } catch (Exception e) {
                if (err != null)
                    err.onError(conn, e);
            }
        });
    }

    private BufferedInputStream getInputStream() throws IOException {
        connect0();
        InputStream in = new FilterInputStream(conn.getInputStream()) {
            @Override
            public void close() throws IOException {
                super.close();
                conn.disconnect();
            }
        };
        return new BufferedInputStream(in);
    }

    private String dlString() throws IOException {
        try (Scanner s = new Scanner(getInputStream(), "UTF-8")) {
            s.useDelimiter("\\A");
            return s.next();
        }
    }

    private JSONObject dlJSONObject() throws IOException, JSONException {
        return new JSONObject(dlString());
    }

    private JSONArray dlJSONArray() throws IOException, JSONException {
        return new JSONArray(dlString());
    }

    private File dlFile(File f) throws IOException {
        try (InputStream in = getInputStream();
             OutputStream out = new BufferedOutputStream(new FileOutputStream(f))) {
            APKInstall.transfer(in, out);
        }
        return f;
    }

    private byte[] dlBytes() throws IOException {
        int len = conn.getContentLength();
        len = len > 0 ? len : 32;
        ByteArrayOutputStream out = new ByteArrayOutputStream(len);
        try (InputStream in = getInputStream()) {
            APKInstall.transfer(in, out);
        }
        return out.toByteArray();
    }
}

```

`app/stub/src/main/java/com/topjohnwu/magisk/net/ResponseListener.java`:

```java
package com.topjohnwu.magisk.net;

public interface ResponseListener<T> {
    void onResponse(T response);
}

```

`app/stub/src/main/res/values-ar/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">عليك بتحديث ماجيسك لإكمال تهيئة التطبيق. هل تريد التنزيل والتثبيت؟</string>
    <string name="no_internet_msg">يرجى الإتصال بالإنترنت! تحديث ماجيسك مطلوب.</string>
    <string name="dling">جارٍ التنزيل</string>
    <string name="relaunch_app">يرجى إعادة تشغيل التطبيق يدوياً</string>
</resources>

```

`app/stub/src/main/res/values-ast/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Instala la versión completa de Magisk pa finar la configuración. ¿Quies facelo agora?</string>
    <string name="no_internet_msg">¡Conéctate a internet! Tienes d\'instalar la versión completa de Magisk.</string>
    <string name="dling">Baxando</string>
    <string name="relaunch_app">Volvi llanzar l\'aplicación manualmente</string>
</resources>

```

`app/stub/src/main/res/values-az/strings.xml`:

```xml
<resources>
    <string name="upgrade_msg">Qurmanı sonlandırmaq üçün full Magisk Manager`ə yüksəldin. Yüklənib qurulsun?</string>
    <string name="no_internet_msg">Lütfən internetə qoşulun! Full Magisk Manager\'ə yüksəltmə lazımidir.</string>
</resources>

```

`app/stub/src/main/res/values-b+sr+Latn/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--Author: Radoš Milićev (https://github.com/rammba)-->
<resources>
    <string name="upgrade_msg">Ažurirajte Magisk da biste završili postavljanje. Preuzmi i instaliraj?</string>
    <string name="no_internet_msg">Molimo povežite se na internet! Neophodno je ažuriranje Magisk-a.</string>
    <string name="dling">Preuzimanje</string>
    <string name="relaunch_app">Molimo pokrenite aplikaciju ponovo</string>
</resources>

```

`app/stub/src/main/res/values-be/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Абнавіце Magisk Manager для завяршэння ўсталёўкі. Спампаваць і ўсталяваць?</string>
    <string name="no_internet_msg">Калі ласка, падлучыцеся да інтэрнэту! Патрабуецца абнаўленне Magisk Manager.</string>
    <string name="dling">Спампоўванне</string>
    <string name="relaunch_app">Калі ласка, уласнаручна перазапусціце праграму</string>
</resources>

```

`app/stub/src/main/res/values-bg/strings.xml`:

```xml
<resources>
    <string name="upgrade_msg">Надградете до пълната версия на Magisk Manager, за да довършите първоначалната настройка. Изтегляне и инсталиране сега?</string>
    <string name="no_internet_msg">Моля да се свържете към работеща интернет мрежа, защото надграждането до пълната версия на Magisk Manager е задължително.</string>
</resources>

```

`app/stub/src/main/res/values-ca/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Fes una actualització total de Magisk Manager per finalitzar l\'instal·lació. Descarregar i instal·lar?</string>
    <string name="no_internet_msg">Si us plau, connecta\'t a internet! Es necessari fer una actualització total de Magisk Manager.</string>
    <string name="dling">Baixant</string>
    <string name="relaunch_app">Torni a obrir l\'aplicació manualment, si us plau</string>
</resources>

```

`app/stub/src/main/res/values-cs/strings.xml`:

```xml
<resources></resources>

```

`app/stub/src/main/res/values-de/strings.xml`:

```xml
<resources>
    <string name="upgrade_msg">Upgrade zum vollständigen Magisk Manager, um das Setup abzuschließen. Herunterladen und installieren?</string>
    <string name="no_internet_msg">Bitte Internetverbindung herstellen! Das Upgrade zum vollständigen Magisk Manager ist erforderlich.</string>
    <string name="dling">Herunterladen...</string>
    <string name="relaunch_app">Bitte starte die App manuell neu!</string>
</resources>

```

`app/stub/src/main/res/values-el/strings.xml`:

```xml
<resources></resources>

```

`app/stub/src/main/res/values-es/strings.xml`:

```xml
<resources>
    <string name="upgrade_msg">Actualiza a la versión completa de Magisk para finalizar la instalación. ¿Descargar e instalar?</string>
    <string name="no_internet_msg">Sin conexión disponible</string>
    <string name="dling">Descargando...</string>
    <string name="relaunch_app">Por favor, relanza la app</string>
</resources>

```

`app/stub/src/main/res/values-et/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Täienda seadistuse lõpetamiseks Magiski täisversioonile. Kas laadid alla ja installid?</string>
    <string name="no_internet_msg">Palun ühendu Internetti! Nõutud on Magiski täisversioonile täiendamine.</string>
    <string name="dling">Allalaadimine</string>
    <string name="relaunch_app">Palun käivita rakendus käsitsi uuesti</string>
</resources>

```

`app/stub/src/main/res/values-fa/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">برای به پایان رساندن تنظیمات ، به نسخه کامل Magisk Manager ارتقا دهید. دانلود و نصب بشه؟</string>
    <string name="no_internet_msg">لطفاً به اینترنت متصل شوید! برای ارتقا به نسخه کامل Magisk Manager لازم است.</string>
    <string name="dling">درحال دانلود</string>
    <string name="relaunch_app">لطفاً به صورت دستی برنامه را دوباره راه اندازی کنید</string>
</resources>
```

`app/stub/src/main/res/values-fr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Une mise à niveau de Magisk Manager en version complète est nécessaire afin de terminer l’installation. Souhaitez‑vous procéder à son téléchargement et son installation ?</string>
    <string name="no_internet_msg">Veuillez vous connecter à Internet ! Une mise à niveau complète de Magisk Manager est requise.</string>
    <string name="dling">Téléchargement en cours</string>
    <string name="relaunch_app">Veuillez relancer manuellement l’application</string>
</resources>

```

`app/stub/src/main/res/values-hi/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">सेटअप को पूरा करने के लिए पूर्ण मैजिस्क मैनेजर में अपग्रेड करें. डाउनलोड करके इंस्टॉल करें?</string>
    <string name="no_internet_msg">कृपया इन्टरनेट से जुड़िये! पूर्ण मैजिस्क मैनेजर में अपग्रेड की आवश्यकता है।</string>
    <string name="dling">डाउनलोड हो रहा है</string>
    <string name="relaunch_app">कृपया ऐप को फिर से शुरू करें</string>
</resources>

```

`app/stub/src/main/res/values-hn/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Setup complete karne ke liye full Magisk install karna hoga. Abhi download aur install karein?</string>
    <string name="no_internet_msg">Full Magisk upgrade ke liye Internet se connect hona zaroori hai!</string>
    <string name="dling">Download ho raha hai…</string>
    <string name="relaunch_app">App ko reopen karo</string>
</resources>

```

`app/stub/src/main/res/values-hr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Nadogradite na full Magisk Manager da biste dovršili postavljanje. Preuzeti i instalirati?</string>
    <string name="no_internet_msg">Povežite se na Internet! Potrebna je nadogradnja na full Magisk Manager.</string>
    <string name="dling">Preuzimanje</string>
    <string name="relaunch_app">Ručno ponovno pokrenite aplikaciju</string>
</resources>

```

`app/stub/src/main/res/values-hu/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">A telepítés befejezéséhez frissíts a teljes Magiskre. Letöltés és telepítés?</string>
    <string name="no_internet_msg">Csatlakozz az internethez! Frissíteni kell a teljes Magiskre.</string>
    <string name="dling">Letöltés</string>
    <string name="relaunch_app">Kérjük manuálisan indítsd újra az alkalmazást</string>
</resources>

```

`app/stub/src/main/res/values-in/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Tingkatkan Magisk Manager ke versi utuh untuk menyelesaikan penyiapan. Download dan instal?</string>
    <string name="no_internet_msg">Harap sambungkan ke Internet! Peningkatan Magisk Manager versi utuh diperlukan.</string>
    <string name="dling">Mendownload</string>
    <string name="relaunch_app">Buka kembali aplikasi secara manual</string>
</resources>

```

`app/stub/src/main/res/values-it/strings.xml`:

```xml
<resources>
    <string name="upgrade_msg">Aggiorna alla versione completa di Magisk per completare l\'installazione. Vuoi procedere con il download e l\'installazione?</string>
    <string name="no_internet_msg">Controlla la connessione a Internet! È necessaria per l\'aggiornamento alla versione completa di Magisk.</string>
    <string name="dling">Download in corso</string>
    <string name="relaunch_app">Riavvia manualmente l\'app</string>
</resources>

```

`app/stub/src/main/res/values-iw/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">יש לעדכן לגירסה מלאה של מנהל Magisk בכדי לסיים את העדכון. להוריד ולהתקין?</string>
    <string name="no_internet_msg">נא להתחבר לאינטרנט! עדכון לגירסה מלאה של מנהל Magisk נדרש.</string>
    <string name="dling">מוריד</string>
</resources>

```

`app/stub/src/main/res/values-ja/strings.xml`:

```xml
<resources>
    <string name="upgrade_msg">Magisk Manager のフルバージョンにアップグレードしてセットアップを完了します。ダウンロードしてインストールしますか？</string>
    <string name="dling">ダウンロード中</string>
    <string name="no_internet_msg">インターネットに接続してください！フルバージョンの Magisk Manager が必要です。</string>
</resources>

```

`app/stub/src/main/res/values-ka/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">განაახლეთ სრულ Magisk მენჯერის ვერსიამდე ინსტალაციის დასასრულებლად. გსურთ გადმოწერა და ინსტალირება?</string>
    <string name="no_internet_msg">გთხოვთ დაუკავშირდით ინტერნეტს! საჭიროა Magisk მენეჯერის სრულ ვერსიამდე განახლება.</string>
    <string name="dling">მიმდინარეობს გადმოწერა</string>
</resources>

```

`app/stub/src/main/res/values-kk/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Орнатуды аяқтау үшін Magisk қолданбасының толық нұсқасын жүктеп алу керек. Жалғастырасыз ба?</string>
    <string name="no_internet_msg">Интернетке қосылыңызшы! Magisk қолданбасын жаңарту керек.</string>
    <string name="dling">Жүктеп алуда</string>
    <string name="relaunch_app">Қолданбаны қайта қосыңыз</string>
</resources>

```

`app/stub/src/main/res/values-ko/strings.xml`:

```xml
<resources>
    <string name="upgrade_msg">완전한 Magisk Manager로 업데이트하여 설치를 마치십시오. 다운로드하고 설치하시겠습니까?</string>
    <string name="no_internet_msg">인터넷에 연결해 주시기 바랍니다! 완전한 Magisk Manager로 업데이트 해야 합니다.</string>
    <string name="dling">다운로드중</string>
    <string name="relaunch_app">앱을 수동으로 재시작 하세요</string>
</resources>

```

`app/stub/src/main/res/values-ku/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">ماجیسکەکەت بەرزبکەوە بۆ وەشانی تەواوەتی، دەتەوێت دایبگریت و ڕێکیبخەیت؟</string>
    <string name="no_internet_msg">تکایە پەیوەست ببە بە ئینتەرنێتەوە، پێویستە ماجیسکەکەت ڕێک بخەیت.</string>
    <string name="dling">داگرتن</string>
    <string name="relaunch_app">تکایە دووبارە ئەپەکە بکەوە</string>
</resources>

```

`app/stub/src/main/res/values-lt/strings.xml`:

```xml
<resources>
    <string name="upgrade_msg">Atsinaujinkite į pilną Magisk Manager versiją, kad baigtumėte pasiruošimą. Atsisiųsti ir instaliuoti?</string>
    <string name="no_internet_msg">Prašome prisijungti prie interneto! Atsinaujinimas į pilną Magisk Manager versiją yra privalomas.</string>
</resources>

```

`app/stub/src/main/res/values-mk/strings.xml`:

```xml
<resources>
    <string name="upgrade_msg">Надградете до целосната верзија на Magisk Manager за да го завршите поставувањето. Преземете и инсталирајте?</string>
    <string name="no_internet_msg">Ве молиме поврзете се на интернет бидејќи е потребна надградба на целосната верзија на Magisk Manager.</string>
</resources>

```

`app/stub/src/main/res/values-ml/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">സജ്ജീകരണം പൂർത്തിയാക്കാൻ പൂർണ്ണ മജിസ്കിലേക്ക് അപ്ഗ്രേഡ് ചെയ്യുക. ഡൗൺലോഡ് ചെയ്ത് ഇൻസ്റ്റാൾ ചെയ്യണോ?</string>
    <string name="no_internet_msg">ദയവായി ഇന്റർനെറ്റിലേക്ക് കണക്റ്റുചെയ്യുക! പൂർണ്ണ മജിസ്കിലേക്ക് അപ്‌ഗ്രേഡ് ചെയ്യേണ്ടതുണ്ട്.</string>
    <string name="dling">ഡൗൺലോഡ് ചെയ്യുന്നു</string>
    <string name="relaunch_app">ആപ്പ് സ്വമേധയാ വീണ്ടും തുറക്കുക</string>
</resources>

```

`app/stub/src/main/res/values-nb/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Oppgrader til den komplette versjonen av Magisk Manager for å fullføre oppsettet. Vil du laste ned og installere?</string>
    <string name="no_internet_msg">Vennligst koble deg på internettet! Å oppgradere til den komplette versjonen av Magisk Manager er påkrevd.</string>
</resources>

```

`app/stub/src/main/res/values-nl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Installeer de volledige Magisk Manager om de installatie af te ronden. Wil je dit nu doen?</string>
    <string name="no_internet_msg">Maak verbinding met het internet! Het installeren van de volledige Magisk Manager is vereist.</string>
    <string name="dling">Bezig met downloaden...</string>
</resources>

```

`app/stub/src/main/res/values-pa/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">ਸੈਟਅਪ ਨੂੰ ਪੂਰਾ ਕਰਨ ਲਈ ਪੂਰੇ ਮੈਜਿਕਸ ਮੈਨੇਜਰ ਵਿਚ ਅਪਗ੍ਰੇਡ ਕਰੋ. ਡਾਉਨਲੋਡ ਅਤੇ ਇੰਸਟੌਲ ਕਰੋ?</string>
    <string name="no_internet_msg">ਕਿਰਪਾ ਕਰਕੇ ਇੰਟਰਨੈਟ ਨਾਲ ਜੁੜੋ! ਪੂਰਾ ਮੈਜਿਕਸ ਮੈਨੇਜਰ ਅਪਗ੍ਰੇਡ ਕਰਨ ਦੀ ਲੋੜ ਹੈ।</string>
    <string name="dling">ਡਾਊਨਲੋਡ ਹੋ ਰਿਹਾ ਹੈ</string>
    <string name="relaunch_app">ਕਿਰਪਾ ਕਰਕੇ ਐਪ ਨੂੰ ਮੁੜ ਚਾਲੂ ਕਰੋ</string>
</resources>

```

`app/stub/src/main/res/values-pl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Zaktualizuj Magisk do pełnej wersji aby ukończyć instalację. Pobrać i zainstalować?</string>
    <string name="no_internet_msg">Połącz się z Internetem! Wymagane jest uaktualnienie Magisk do pełnej wersji.</string>
    <string name="dling">Pobieranie</string>
    <string name="relaunch_app">Proszę ręcznie uruchomić aplikację ponownie.</string>
</resources>

```

`app/stub/src/main/res/values-pt-rBR/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Atualize para o Magisk completo para finalizar a configuração. Deseja baixar e instalar?</string>
    <string name="no_internet_msg">Por favor, conecte-se à internet! É necessário atualizar para o Magisk completo.</string>
    <string name="dling">Baixando</string>
    <string name="relaunch_app">Por favor, reinicie o app manualmente.</string>
</resources>

```

`app/stub/src/main/res/values-pt-rPT/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Atualize para o Magisk completo para finalizar a configuração. Deseja descarregar e instalar?</string>
    <string name="no_internet_msg">Por favor, ligue-se à internet! É necessário atualizar para o Magisk completo.</string>
    <string name="dling">A descarregar</string>
    <string name="relaunch_app">Por favor, reinicie o app manualmente.</string>
</resources>

```

`app/stub/src/main/res/values-ro/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Treci la versiunea completă Magisk pentru a finaliza configurarea. Descarci și instalezi?</string>
    <string name="no_internet_msg">Te rugăm să te conectezi la internet! Este necesară actualizarea la versiunea completă Magisk.</string>
    <string name="dling">Se descarcă</string>
    <string name="relaunch_app">Te rugăm să relansezi manual aplicația</string>
</resources>

```

`app/stub/src/main/res/values-ru/strings.xml`:

```xml
<resources>
    <string name="upgrade_msg">Обновите Magisk для завершения установки. Продолжить?</string>
    <string name="no_internet_msg">Пожалуйста, подключитесь к Интернету! Требуется обновление Magisk.</string>
    <string name="dling">Загрузка</string>
    <string name="relaunch_app">Пожалуйста, перезапустите приложение</string>
</resources>

```

`app/stub/src/main/res/values-sk/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Pre dokončenie inštalácie sa vyžaduje upgrade Magisk Managera. Stiahnuť a nainštalovať?</string>
    <string name="no_internet_msg">Pripojte sa na internet! Upgrade Magisk Managera je potrebný.</string>
    <string name="dling">Sťahuje sa</string>
    <string name="relaunch_app">Zavrite a spustite apku manuálne</string>
</resources>

```

`app/stub/src/main/res/values-sq/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Përditësoni Magisk në versionin e plotë për të përfunduar konfigurimin. Shkarkoni dhe instaloni?</string>
    <string name="no_internet_msg">Ju lutemi lidhuni me internetin! Kërkohet internet për të shkarkuar Magisk në versionin e plotë.</string>
    <string name="dling">Duke shkarkuar</string>
    <string name="relaunch_app">Ju lutemi, ri-hapni aplikacionin manualisht</string>
</resources>

```

`app/stub/src/main/res/values-sr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--Author: Radoš Milićev (https://github.com/rammba)-->
<resources>
    <string name="upgrade_msg">Ажурирајте Magisk да бисте завршили постављање. Преузми и инсталирај?</string>
    <string name="no_internet_msg">Молимо повежите се на интернет! Неопходно је ажурирање Magisk-а.</string>
    <string name="dling">Преузимање</string>
    <string name="relaunch_app">Молимо покрените апликацију поново</string>
</resources>

```

`app/stub/src/main/res/values-sv/strings.xml`:

```xml
<resources></resources>

```

`app/stub/src/main/res/values-sw/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Pata toleo jipya la Magisk kamili ili kumaliza usanidi. Pakua na usakinishe?</string>
    <string name="no_internet_msg">Tafadhali unganisha kwenye Mtandao! Kusasisha hadi Magisk kamili inahitajika.</string>
    <string name="dling">Inapakua</string>
    <string name="relaunch_app">Tafadhali zindua upya programu wewe mwenyewe</string>
</resources>

```

`app/stub/src/main/res/values-ta/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">அமைப்பை முடிக்க முழு மேகிஸ்க்கு மேம்படுத்தவும். பதிவிறக்கி நிறுவவா?</string>
    <string name="no_internet_msg">இணையத்துடன் இணைக்கவும்! முழு மேகிஸ்க்கு மேம்படுத்தல் தேவை.</string>
    <string name="dling">பதிவிறக்குகிறது</string>
    <string name="relaunch_app">பயன்பாட்டை கைமுறையாக மீண்டும் தொடங்கவும்</string>
</resources>

```

`app/stub/src/main/res/values-th/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources></resources>

```

`app/stub/src/main/res/values-tr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Kurulumu tamamlamak için tam Magisk Manager\'a yükseltin. İndirip yüklensin mi?</string>
    <string name="no_internet_msg">Lütfen internete bağlanın! Magisk Manager\'ın tam sürümüne yükseltmek gerekiyor.</string>
    <string name="dling">İndiriliyor</string>
    <string name="relaunch_app">Lütfen uygulamayı el ile yeniden açınız.</string>
</resources>


```

`app/stub/src/main/res/values-uk/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Оновіть додаток Magisk для завершення встановлення. Завантажити і встановити?</string>
    <string name="no_internet_msg">Будь ласка, підключіться до Інтернету! Потрібно оновити додаток Magisk.</string>
    <string name="dling">Завантаження</string>
</resources>

```

`app/stub/src/main/res/values-vi/strings.xml`:

```xml
<resources></resources>

```

`app/stub/src/main/res/values-zh-rCN/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">需要下载完整版 Magisk 才能正常运行。开始下载？</string>
    <string name="no_internet_msg">下载需要网络，请检查网络连接。</string>
    <string name="dling">正在下载</string>
    <string name="relaunch_app">请重新打开本应用</string>
</resources>

```

`app/stub/src/main/res/values-zh-rTW/strings.xml`:

```xml
<resources>
    <string name="upgrade_msg">需要升級到完整版 Magisk Manager。是否下載並安裝？</string>
    <string name="no_internet_msg">請連上網路！升級到完整版 Magisk Manager 是必須的。</string>
    <string name="dling">正在下載</string>
</resources>

```

`app/stub/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="upgrade_msg">Upgrade to full Magisk to finish the setup. Download and install?</string>
    <string name="no_internet_msg">Please connect to the Internet! Upgrading to full Magisk is required.</string>
    <string name="dling">Downloading</string>
    <string name="relaunch_app">Please manually re-launch the app</string>
</resources>

```

`app/test/build.gradle.kts`:

```kts
plugins {
    id("com.android.application")
}

android {
    namespace = "com.topjohnwu.magisk.test"

    defaultConfig {
        applicationId = "com.topjohnwu.magisk.test"
        versionCode = 1
        versionName = "1.0"
        proguardFile("proguard-rules.pro")
    }

    buildTypes {
        release {
            isMinifyEnabled = true
        }
    }
}

setupTestApk()

dependencies {
    implementation(libs.test.runner)
    implementation(libs.test.rules)
    implementation(libs.test.junit)
    implementation(libs.test.uiautomator)
}

```

`app/test/proguard-rules.pro`:

```pro
# Keep all test dependencies
-keep class org.junit.** { *; }
-keep class androidx.test.** { *; }

# Make sure the classloader constructor is kept
-keepclassmembers class com.topjohnwu.magisk.test.TestClassLoader { <init>(); }

# Repackage dependencies
-repackageclasses 'deps'
-allowaccessmodification

# Keep attributes for stacktrace
-keepattributes *

```

`app/test/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission
        android:name="android.permission.QUERY_ALL_PACKAGES"
        tools:ignore="QueryAllPackagesPermission" />

    <queries tools:node="removeAll" />

    <application tools:node="replace">
        <uses-library android:name="android.test.runner" />
    </application>

    <instrumentation
        android:name="com.topjohnwu.magisk.test.AppTestRunner"
        android:targetPackage="com.topjohnwu.magisk" />

    <instrumentation
        android:name="com.topjohnwu.magisk.test.TestRunner"
        android:targetPackage="com.topjohnwu.magisk.test" />

</manifest>

```

`app/test/src/main/java/com/topjohnwu/magisk/test/AppMigrationTest.kt`:

```kt
package com.topjohnwu.magisk.test

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.ParcelFileDescriptor.AutoCloseInputStream
import androidx.annotation.Keep
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.platform.app.InstrumentationRegistry
import org.junit.After
import org.junit.Assert.assertTrue
import org.junit.Test
import org.junit.runner.RunWith
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit

@Keep
@RunWith(AndroidJUnit4::class)
class AppMigrationTest {

    companion object {
        private const val APP_PKG = "com.topjohnwu.magisk"
        private const val STUB_PKG = "repackaged.$APP_PKG"
        private const val RECEIVER_TIMEOUT = 20L
    }

    private val instrumentation get() = InstrumentationRegistry.getInstrumentation()
    private val context get() = instrumentation.context
    private val uiAutomation get() = instrumentation.uiAutomation
    private val registeredReceivers = mutableListOf<BroadcastReceiver>()

    class PackageRemoveMonitor(
        context: Context,
        private val packageName: String
    ) : BroadcastReceiver() {

        val latch = CountDownLatch(1)

        init {
            val filter = IntentFilter(Intent.ACTION_PACKAGE_REMOVED)
            filter.addDataScheme("package")
            context.registerReceiver(this, filter)
        }

        override fun onReceive(context: Context, intent: Intent) {
            if (intent.action != Intent.ACTION_PACKAGE_REMOVED)
                return
            val data = intent.data ?: return
            val pkg = data.schemeSpecificPart
            if (pkg == packageName) latch.countDown()
        }
    }

    @After
    fun tearDown() {
        registeredReceivers.forEach(context::unregisterReceiver)
    }

    private fun testAppMigration(pkg: String, method: String) {
        val receiver = PackageRemoveMonitor(context, pkg)
        registeredReceivers.add(receiver)

        // Trigger the test to run migration
        val pfd = uiAutomation.executeShellCommand(
            "am instrument -w --user 0 -e class .Environment#$method " +
                "$pkg.test/${AppTestRunner::class.java.name}"
        )
        val output = AutoCloseInputStream(pfd).reader().use { it.readText() }
        assertTrue("$method failed, inst out: $output", output.contains("OK ("))

        // Wait for migration to complete
        assertTrue(
            "$pkg uninstallation failed",
            receiver.latch.await(RECEIVER_TIMEOUT, TimeUnit.SECONDS)
        )
    }

    @Test
    fun testAppHide() {
        testAppMigration(APP_PKG, "setupAppHide")
    }

    @Test
    fun testAppRestore() {
        testAppMigration(STUB_PKG, "setupAppRestore")
    }
}

```

`app/test/src/main/java/com/topjohnwu/magisk/test/Runners.kt`:

```kt
package com.topjohnwu.magisk.test

import android.os.Bundle
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.runner.AndroidJUnitRunner

open class TestRunner : AndroidJUnitRunner() {
    override fun onCreate(arguments: Bundle) {
        // Support short-hand ".ClassName"
        arguments.getString("class")?.let {
            val classArg = it.split(",").joinToString(separator = ",") { clz ->
                if (clz.startsWith(".")) {
                    "com.topjohnwu.magisk.test$clz"
                } else {
                    clz
                }
            }
            arguments.putString("class", classArg)
        }
        super.onCreate(arguments)
    }
}

class AppTestRunner : TestRunner() {
    override fun onCreate(arguments: Bundle) {
        // Force using the target context's classloader to run tests
        arguments.putString("classLoader", TestClassLoader::class.java.name)
        super.onCreate(arguments)
    }
}

private val targetClassLoader inline get() =
    InstrumentationRegistry.getInstrumentation().targetContext.classLoader

class TestClassLoader : ClassLoader(targetClassLoader)

```

`build.py`:

```py
#!/usr/bin/env python3
import argparse
import glob
import multiprocessing
import os
import platform
import re
import shutil
import stat
import subprocess
import sys
import tarfile
import urllib.request
from pathlib import Path
from zipfile import ZipFile


def color_print(code, str):
    if no_color:
        print(str)
    else:
        str = str.replace("\n", f"\033[0m\n{code}")
        print(f"{code}{str}\033[0m")


def error(str):
    color_print("\033[41;39m", f"\n! {str}\n")
    sys.exit(1)


def header(str):
    color_print("\033[44;39m", f"\n{str}\n")


def vprint(str):
    if args.verbose > 0:
        print(str)


# OS detection
os_name = platform.system().lower()
is_windows = False
if os_name != "linux" and os_name != "darwin":
    # It's possible we're using MSYS/Cygwin/MinGW, treat them all as Windows
    is_windows = True
    os_name = "windows"
EXE_EXT = ".exe" if is_windows else ""

no_color = False
if is_windows:
    try:
        import colorama

        colorama.init()
    except ImportError:
        # We can't do ANSI color codes in terminal on Windows without colorama
        no_color = True

if not sys.version_info >= (3, 8):
    error("Requires Python 3.8+")

cpu_count = multiprocessing.cpu_count()

# Common constants
support_abis = {
    "armeabi-v7a": "thumbv7neon-linux-androideabi",
    "x86": "i686-linux-android",
    "arm64-v8a": "aarch64-linux-android",
    "x86_64": "x86_64-linux-android",
    "riscv64": "riscv64-linux-android",
}
abi_alias = {
    "arm": "armeabi-v7a",
    "arm32": "armeabi-v7a",
    "arm64": "arm64-v8a",
    "x64": "x86_64",
}
default_abis = support_abis.keys() - {"riscv64"}
support_targets = {"magisk", "magiskinit", "magiskboot", "magiskpolicy", "resetprop"}
default_targets = support_targets - {"resetprop"}
rust_targets = default_targets.copy()
clean_targets = {"native", "cpp", "rust", "app"}
ondk_version = "r29.5"

# Global vars
config = {}
args: argparse.Namespace
build_abis: dict[str, str]
force_out = False

###################
# Helper functions
###################


def mv(source: Path, target: Path):
    try:
        shutil.move(source, target)
        vprint(f"mv {source} -> {target}")
    except:
        pass


def cp(source: Path, target: Path):
    try:
        shutil.copyfile(source, target)
        vprint(f"cp {source} -> {target}")
    except:
        pass


def rm(file: Path):
    try:
        os.remove(file)
        vprint(f"rm {file}")
    except FileNotFoundError as e:
        pass


def rm_on_error(func, path, _):
    # Removing a read-only file on Windows will get "WindowsError: [Error 5] Access is denied"
    # Clear the "read-only" bit and retry
    try:
        os.chmod(path, stat.S_IWRITE)
        os.unlink(path)
    except FileNotFoundError as e:
        pass


def rm_rf(path: Path):
    vprint(f"rm -rf {path}")
    if sys.version_info >= (3, 12):
        shutil.rmtree(path, ignore_errors=False, onexc=rm_on_error)
    else:
        shutil.rmtree(path, ignore_errors=False, onerror=rm_on_error)


def execv(cmds: list, env=None):
    out = None if force_out or args.verbose > 0 else subprocess.DEVNULL
    # Use shell on Windows to support PATHEXT
    return subprocess.run(cmds, stdout=out, env=env, shell=is_windows)


def cmd_out(cmds: list):
    return (
        subprocess.run(
            cmds,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            shell=is_windows,
        )
        .stdout.strip()
        .decode("utf-8")
    )


###############
# Build Native
###############


def clean_elf():
    cargo_toml = Path("tools", "elf-cleaner", "Cargo.toml")
    cmds = ["run", "--release", "--manifest-path", cargo_toml]
    if args.verbose == 0:
        cmds.append("-q")
    elif args.verbose > 1:
        cmds.append("--verbose")
    cmds.append("--")
    cmds.extend(glob.glob("native/out/*/magisk"))
    cmds.extend(glob.glob("native/out/*/magiskpolicy"))
    run_cargo(cmds)


def collect_ndk_build():
    for arch in build_abis.keys():
        arch_dir = Path("native", "libs", arch)
        out_dir = Path("native", "out", arch)
        for source in arch_dir.iterdir():
            target = out_dir / source.name
            mv(source, target)


def run_ndk_build(cmds: list[str]):
    os.chdir("native")
    cmds.append("NDK_PROJECT_PATH=.")
    cmds.append("NDK_APPLICATION_MK=src/Application.mk")
    cmds.append(f"APP_ABI={' '.join(build_abis.keys())}")
    cmds.append(f"-j{cpu_count}")
    if args.verbose > 1:
        cmds.append("V=1")
    if not args.release:
        cmds.append("MAGISK_DEBUG=1")
    proc = execv([ndk_build, *cmds])
    if proc.returncode != 0:
        error("Build binary failed!")
    os.chdir("..")


def build_cpp_src(targets: set[str]):
    cmds = []
    clean = False

    if "magisk" in targets:
        cmds.append("B_MAGISK=1")
        clean = True

    if "magiskpolicy" in targets:
        cmds.append("B_POLICY=1")
        clean = True

    if "magiskinit" in targets:
        cmds.append("B_PRELOAD=1")

    if "resetprop" in targets:
        cmds.append("B_PROP=1")

    if cmds:
        run_ndk_build(cmds)
        collect_ndk_build()

    cmds.clear()

    if "magiskinit" in targets:
        cmds.append("B_INIT=1")

    if "magiskboot" in targets:
        cmds.append("B_BOOT=1")

    if cmds:
        cmds.append("B_CRT0=1")
        run_ndk_build(cmds)
        collect_ndk_build()

    if clean:
        clean_elf()


def run_cargo(cmds: list[str]):
    ensure_paths()
    env = os.environ.copy()
    env["PATH"] = f"{rust_sysroot / "bin"}{os.pathsep}{env["PATH"]}"
    env["CARGO_BUILD_RUSTFLAGS"] = f"-Z threads={min(8, cpu_count)}"
    # Cargo calls executables in $RUSTROOT/lib/rustlib/$TRIPLE/bin, we need
    # to make sure the runtime linker also search $RUSTROOT/lib for libraries.
    # This is only required on Unix, as Windows search dlls from PATH.
    if os_name == "darwin":
        env["DYLD_FALLBACK_LIBRARY_PATH"] = str(rust_sysroot / "lib")
    elif os_name == "linux":
        env["LD_LIBRARY_PATH"] = str(rust_sysroot / "lib")
    return execv(["cargo", *cmds], env)


def build_rust_src(targets: set[str]):
    targets = targets.copy()
    if "resetprop" in targets:
        targets.add("magisk")
    targets = targets & rust_targets
    if not targets:
        return

    os.chdir(Path("native", "src"))

    # Start building the build commands
    cmds = ["build", "-p", ""]
    if args.release:
        cmds.append("-r")
        profile = "release"
    else:
        profile = "debug"
    if args.verbose == 0:
        cmds.append("-q")
    elif args.verbose > 1:
        cmds.append("--verbose")

    for triple in build_abis.values():
        cmds.append("--target")
        cmds.append(triple)

    for tgt in targets:
        cmds[2] = tgt
        proc = run_cargo(cmds)
        if proc.returncode != 0:
            error("Build binary failed!")

    os.chdir(Path("..", ".."))

    native_out = Path("native", "out")
    rust_out = native_out / "rust"
    for arch, triple in build_abis.items():
        arch_out = native_out / arch
        arch_out.mkdir(mode=0o755, exist_ok=True)
        for tgt in targets:
            source = rust_out / triple / profile / f"lib{tgt}.a"
            target = arch_out / f"lib{tgt}-rs.a"
            mv(source, target)


def write_if_diff(file_name: Path, text: str):
    do_write = True
    if file_name.exists():
        with open(file_name, "r") as f:
            orig = f.read()
        do_write = orig != text
    if do_write:
        with open(file_name, "w") as f:
            f.write(text)


def dump_flag_header():
    flag_txt = "#pragma once\n"
    flag_txt += f'#define MAGISK_VERSION      "{config["version"]}"\n'
    flag_txt += f'#define MAGISK_VER_CODE     {config["versionCode"]}\n'
    flag_txt += f"#define MAGISK_DEBUG        {0 if args.release else 1}\n"

    native_gen_path = Path("native", "out", "generated")
    native_gen_path.mkdir(mode=0o755, parents=True, exist_ok=True)
    write_if_diff(native_gen_path / "flags.h", flag_txt)

    rust_flag_txt = f'pub const MAGISK_VERSION: &str = "{config["version"]}";\n'
    rust_flag_txt += f'pub const MAGISK_VER_CODE: i32 = {config["versionCode"]};\n'
    write_if_diff(native_gen_path / "flags.rs", rust_flag_txt)


def ensure_toolchain():
    ensure_paths()

    # Verify NDK install
    try:
        with open(Path(ndk_path, "ONDK_VERSION"), "r") as ondk_ver:
            assert ondk_ver.read().strip(" \t\r\n") == ondk_version
    except:
        error('Unmatched NDK. Please install/upgrade NDK with "build.py ndk"')

    if sccache := shutil.which("sccache"):
        os.environ["RUSTC_WRAPPER"] = sccache
        os.environ["NDK_CCACHE"] = sccache
        os.environ["CARGO_INCREMENTAL"] = "0"
    if ccache := shutil.which("ccache"):
        os.environ["NDK_CCACHE"] = ccache


def build_native():
    ensure_toolchain()

    if "targets" not in vars(args) or not args.targets:
        targets = default_targets
    else:
        targets = set(args.targets) & support_targets
        if not targets:
            return

    header("* Building: " + " ".join(targets))

    dump_flag_header()
    build_rust_src(targets)
    build_cpp_src(targets)


############
# Build App
############


def find_jdk():
    env = os.environ.copy()
    if "ANDROID_STUDIO" in env:
        studio = env["ANDROID_STUDIO"]
        jbr = Path(studio, "jbr", "bin")
        if not jbr.exists():
            jbr = Path(studio, "Contents", "jbr", "Contents", "Home", "bin")
        if jbr.exists():
            env["PATH"] = f'{jbr}{os.pathsep}{env["PATH"]}'

    no_jdk = False
    try:
        proc = subprocess.run(
            "javac -version",
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            env=env,
            shell=True,
        )
        no_jdk = proc.returncode != 0
    except FileNotFoundError:
        no_jdk = True

    if no_jdk:
        error(
            "Please set Android Studio's path to environment variable ANDROID_STUDIO,\n"
            + "or install JDK 21 and make sure 'javac' is available in PATH"
        )

    return env


def build_apk(module: str):
    ensure_paths()
    env = find_jdk()
    props = args.config.resolve()

    os.chdir("app")
    build_type = "Release" if args.release else "Debug"
    proc = execv(
        [
            gradlew,
            f"{module}:assemble{build_type}",
            f"-PconfigPath={props}",
            f"-PabiList={','.join(build_abis.keys())}",
        ],
        env=env,
    )
    os.chdir("..")
    if proc.returncode != 0:
        error(f"Build {module} failed!")

    build_type = build_type.lower()

    paths = module.split(":")

    apk = f"{paths[-1]}-{build_type}.apk"
    source = Path("app", *paths, "build", "outputs", "apk", build_type, apk)
    target = config["outdir"] / apk
    mv(source, target)
    return target


def build_app():
    header("* Building the Magisk app")
    apk = build_apk(":apk")

    build_type = "release" if args.release else "debug"

    # Rename apk-variant.apk to app-variant.apk
    source = apk
    target = apk.parent / apk.name.replace("apk-", "app-")
    mv(source, target)
    header(f"Output: {target}")

    # Stub building is directly integrated into the main app
    # build process. Copy the stub APK into output directory.
    source = Path("app", "core", "src", build_type, "assets", "stub.apk")
    target = config["outdir"] / f"stub-{build_type}.apk"
    cp(source, target)


def build_stub():
    header("* Building the stub app")
    apk = build_apk(":stub")
    header(f"Output: {apk}")


def build_test():
    old_release = args.release
    # Test APK has to be built as release to prevent classname clash
    args.release = True
    try:
        header("* Building the test app")
        source = build_apk(":test")
        target = source.parent / "test.apk"
        mv(source, target)
        header(f"Output: {target}")
    finally:
        args.release = old_release


################
# Build General
################


def cleanup():
    ensure_paths()
    if args.targets:
        targets: set[str] = set(args.targets) & clean_targets
        if "native" in targets:
            targets.add("cpp")
            targets.add("rust")
    else:
        targets = clean_targets

    if "cpp" in targets:
        header("* Cleaning C++")
        rm_rf(Path("native", "libs"))
        rm_rf(Path("native", "obj"))

    if "rust" in targets:
        header("* Cleaning Rust")
        rm_rf(Path("native", "out", "rust"))
        rm(Path("native", "src", "boot", "proto", "mod.rs"))
        rm(Path("native", "src", "boot", "proto", "update_metadata.rs"))
        for rs_gen in glob.glob("native/**/*-rs.*pp", recursive=True):
            rm(Path(rs_gen))

    if "native" in targets:
        header("* Cleaning native")
        rm_rf(Path("native", "out"))
        rm_rf(Path("tools", "elf-cleaner", "target"))

    if "app" in targets:
        header("* Cleaning app")
        os.chdir("app")
        execv([gradlew, ":clean"], env=find_jdk())
        os.chdir("..")


def build_all():
    build_native()
    build_app()
    build_test()


############
# Utilities
############


def gen_ide():
    ensure_paths()
    set_build_abis({args.abi})

    # Dump flags for both C++ and Rust code
    dump_flag_header()

    # Run build.rs to generate Rust/C++ FFI bindings
    os.chdir(Path("native", "src"))
    run_cargo(["check"])
    os.chdir(Path("..", ".."))

    # Generate compilation database
    rm_rf(Path("native", "compile_commands.json"))
    run_ndk_build(
        [
            "B_MAGISK=1",
            "B_INIT=1",
            "B_BOOT=1",
            "B_POLICY=1",
            "B_PRELOAD=1",
            "B_PROP=1",
            "B_CRT0=1",
            "compile_commands.json",
        ]
    )


def clippy_cli():
    ensure_toolchain()
    global force_out
    force_out = True
    if args.abi:
        set_build_abis(set(args.abi))
    else:
        set_build_abis(default_abis)

    if not args.release and not args.debug:
        # If none is specified, run both
        args.release = True
        args.debug = True

    os.chdir(Path("native", "src"))
    cmds = ["clippy", "--no-deps", "--target"]
    for triple in build_abis.values():
        if args.debug:
            run_cargo(cmds + [triple])
        if args.release:
            run_cargo(cmds + [triple, "--release"])
    os.chdir(Path("..", ".."))


def cargo_cli():
    global force_out
    force_out = True
    if len(args.commands) >= 1 and args.commands[0] == "--":
        args.commands = args.commands[1:]
    os.chdir(Path("native", "src"))
    run_cargo(args.commands)
    os.chdir(Path("..", ".."))


def setup_ndk():
    ensure_paths()
    url = f"https://github.com/topjohnwu/ondk/releases/download/{ondk_version}/ondk-{ondk_version}-{os_name}.tar.xz"
    ndk_archive = url.split("/")[-1]
    ondk_path = Path(ndk_root, f"ondk-{ondk_version}")

    header(f"* Downloading and extracting {ndk_archive}")
    rm_rf(ondk_path)
    with urllib.request.urlopen(url) as response:
        with tarfile.open(mode="r|xz", fileobj=response) as tar:
            if hasattr(tarfile, "data_filter"):
                tar.extractall(ndk_root, filter="tar")
            else:
                tar.extractall(ndk_root)

    rm_rf(ndk_path)
    mv(ondk_path, ndk_path)


def setup_rustup():
    wrapper_dir = Path(args.wrapper_dir)
    rm_rf(wrapper_dir)
    wrapper_dir.mkdir(mode=0o755, parents=True, exist_ok=True)
    if "CARGO_HOME" in os.environ:
        cargo_home = Path(os.environ["CARGO_HOME"])
    else:
        cargo_home = Path.home() / ".cargo"
    cargo_bin = cargo_home / "bin"
    for src in cargo_bin.iterdir():
        tgt = wrapper_dir / src.name
        tgt.symlink_to(f"rustup{EXE_EXT}")

    # Build rustup-wrapper
    wrapper_src = Path("tools", "rustup-wrapper")
    cargo_toml = wrapper_src / "Cargo.toml"
    cmds = ["build", "--release", f"--manifest-path={cargo_toml}"]
    if args.verbose > 1:
        cmds.append("--verbose")
    run_cargo(cmds)

    # Replace rustup with wrapper
    wrapper = wrapper_dir / (f"rustup{EXE_EXT}")
    wrapper.unlink(missing_ok=True)
    cp(wrapper_src / "target" / "release" / (f"rustup-wrapper{EXE_EXT}"), wrapper)
    wrapper.chmod(0o755)


##################
# AVD and testing
##################


def push_files(script: Path):
    if args.build:
        build_all()
    ensure_adb()

    abi = cmd_out([adb_path, "shell", "getprop", "ro.product.cpu.abi"])
    if not abi:
        error("Cannot detect emulator ABI")

    if args.apk:
        apk = Path(args.apk)
    else:
        apk = Path(
            config["outdir"], ("app-release.apk" if args.release else "app-debug.apk")
        )

    # Extract busybox from APK
    busybox = Path(config["outdir"], "busybox")
    with ZipFile(apk) as zf:
        with zf.open(f"lib/{abi}/libbusybox.so") as libbb:
            with open(busybox, "wb") as bb:
                bb.write(libbb.read())

    try:
        proc = execv([adb_path, "push", busybox, script, "/data/local/tmp"])
        if proc.returncode != 0:
            error("adb push failed!")
    finally:
        rm_rf(busybox)

    proc = execv([adb_path, "push", apk, "/data/local/tmp/magisk.apk"])
    if proc.returncode != 0:
        error("adb push failed!")


def setup_avd():
    header("* Setting up emulator")

    push_files(Path("scripts", "live_setup.sh"))

    proc = execv([adb_path, "shell", "sh", "/data/local/tmp/live_setup.sh"])
    if proc.returncode != 0:
        error("live_setup.sh failed!")


def patch_avd_file():
    input = Path(args.image)
    output = Path(args.output)

    header(f"* Patching {input.name}")

    push_files(Path("scripts", "host_patch.sh"))

    proc = execv([adb_path, "push", input, "/data/local/tmp"])
    if proc.returncode != 0:
        error("adb push failed!")

    src_file = f"/data/local/tmp/{input.name}"
    out_file = f"{src_file}.magisk"

    proc = execv([adb_path, "shell", "sh", "/data/local/tmp/host_patch.sh", src_file])
    if proc.returncode != 0:
        error("host_patch.sh failed!")

    proc = execv([adb_path, "pull", out_file, output])
    if proc.returncode != 0:
        error("adb pull failed!")

    header(f"Output: {output}")


##########################
# Config, paths, argparse
##########################


def ensure_paths():
    global sdk_path, ndk_root, ndk_path, rust_sysroot
    global ndk_build, gradlew, adb_path

    # Skip if already initialized
    if "sdk_path" in globals():
        return

    try:
        sdk_path = Path(os.environ["ANDROID_HOME"])
    except KeyError:
        try:
            sdk_path = Path(os.environ["ANDROID_SDK_ROOT"])
        except KeyError:
            error("Please set Android SDK path to environment variable ANDROID_HOME")

    ndk_root = sdk_path / "ndk"
    ndk_path = ndk_root / "magisk"
    ndk_build = ndk_path / "ndk-build"
    rust_sysroot = ndk_path / "toolchains" / "rust"
    adb_path = sdk_path / "platform-tools" / "adb"
    gradlew = Path.cwd() / "app" / "gradlew"


# We allow using several functionality with only ADB
def ensure_adb():
    global adb_path
    if "adb_path" not in globals():
        if adb := shutil.which("adb"):
            adb_path = Path(adb)
        else:
            error("Command 'adb' cannot be found in PATH")


def parse_props(file: Path) -> dict[str, str]:
    props = {}
    with open(file, "r") as f:
        for line in [l.strip(" \t\r\n") for l in f]:
            if line.startswith("#") or len(line) == 0:
                continue
            prop = line.split("=")
            if len(prop) != 2:
                continue
            key = prop[0].strip(" \t\r\n")
            value = prop[1].strip(" \t\r\n")
            if not key or not value:
                continue
            props[key] = value
    return props


def set_build_abis(abis: set[str]):
    global build_abis
    # Try to convert several aliases to real ABI
    abis = {abi_alias.get(k, k) for k in abis}
    # Check any unknown ABIs
    for k in abis - support_abis.keys():
        error(f"Unknown ABI: {k}")
    build_abis = {k: support_abis[k] for k in abis if k in support_abis}


def load_config():
    commit_hash = cmd_out(["git", "rev-parse", "--short=8", "HEAD"])

    # Default values
    config["version"] = commit_hash
    config["versionCode"] = 1000000
    config["outdir"] = "out"

    # Load prop files
    if args.config.exists():
        config.update(parse_props(args.config))

    gradle_props = Path("app", "gradle.properties")
    if gradle_props.exists():
        for key, value in parse_props(gradle_props).items():
            if key.startswith("magisk."):
                config[key[7:]] = value

    try:
        config["versionCode"] = int(config["versionCode"])
    except ValueError:
        error('Config error: "versionCode" is required to be an integer')

    config["outdir"] = Path(config["outdir"])
    config["outdir"].mkdir(mode=0o755, parents=True, exist_ok=True)

    if "abiList" in config:
        abis = set(re.split("\\s*,\\s*", config["abiList"]))
    else:
        abis = default_abis

    set_build_abis(abis)


def parse_args():
    parser = argparse.ArgumentParser(description="Magisk build script")
    parser.set_defaults(func=lambda x: None)
    parser.add_argument(
        "-r", "--release", action="store_true", help="compile in release mode"
    )
    parser.add_argument(
        "-v", "--verbose", action="count", default=0, help="verbose output"
    )
    parser.add_argument(
        "-c",
        "--config",
        default="config.prop",
        help="custom config file (default: config.prop)",
    )
    subparsers = parser.add_subparsers(title="actions")

    all_parser = subparsers.add_parser("all", help="build everything")

    native_parser = subparsers.add_parser("native", help="build native binaries")
    native_parser.add_argument(
        "targets",
        nargs="*",
        help=f"{', '.join(support_targets)}, \
        or empty for defaults ({', '.join(default_targets)})",
    )

    app_parser = subparsers.add_parser("app", help="build the Magisk app")

    stub_parser = subparsers.add_parser("stub", help="build the stub app")

    test_parser = subparsers.add_parser("test", help="build the test app")

    clean_parser = subparsers.add_parser("clean", help="cleanup")
    clean_parser.add_argument(
        "targets", nargs="*", help="native, cpp, rust, java, or empty to clean all"
    )

    ndk_parser = subparsers.add_parser("ndk", help="setup Magisk NDK")

    emu_parser = subparsers.add_parser("emulator", help="setup AVD for development")
    emu_parser.add_argument("apk", help="a Magisk APK to use", nargs="?")
    emu_parser.add_argument(
        "-b", "--build", action="store_true", help="build before patching"
    )

    avd_patch_parser = subparsers.add_parser(
        "avd_patch", help="patch AVD ramdisk.img or init_boot.img"
    )
    avd_patch_parser.add_argument("image", help="path to ramdisk.img or init_boot.img")
    avd_patch_parser.add_argument("output", help="output file name")
    avd_patch_parser.add_argument("--apk", help="a Magisk APK to use")
    avd_patch_parser.add_argument(
        "-b", "--build", action="store_true", help="build before patching"
    )

    cargo_parser = subparsers.add_parser(
        "cargo", help="call 'cargo' commands against the project"
    )
    cargo_parser.add_argument("commands", nargs=argparse.REMAINDER)

    clippy_parser = subparsers.add_parser("clippy", help="run clippy on Rust sources")
    clippy_parser.add_argument(
        "--abi", action="append", help="target ABI(s) to run clippy"
    )
    clippy_parser.add_argument(
        "-r", "--release", action="store_true", help="run clippy as release"
    )
    clippy_parser.add_argument(
        "-d", "--debug", action="store_true", help="run clippy as debug"
    )

    rustup_parser = subparsers.add_parser("rustup", help="setup rustup wrapper")
    rustup_parser.add_argument(
        "wrapper_dir", help="path to setup rustup wrapper binaries"
    )

    gen_parser = subparsers.add_parser("gen", help="generate files for IDE")
    gen_parser.add_argument("--abi", default="arm64-v8a", help="target ABI to generate")

    # Set callbacks
    all_parser.set_defaults(func=build_all)
    native_parser.set_defaults(func=build_native)
    cargo_parser.set_defaults(func=cargo_cli)
    clippy_parser.set_defaults(func=clippy_cli)
    rustup_parser.set_defaults(func=setup_rustup)
    gen_parser.set_defaults(func=gen_ide)
    app_parser.set_defaults(func=build_app)
    stub_parser.set_defaults(func=build_stub)
    test_parser.set_defaults(func=build_test)
    emu_parser.set_defaults(func=setup_avd)
    avd_patch_parser.set_defaults(func=patch_avd_file)
    clean_parser.set_defaults(func=cleanup)
    ndk_parser.set_defaults(func=setup_ndk)

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    return parser.parse_args()


def main():
    global args
    args = parse_args()
    args.config = Path(args.config)
    load_config()
    args.func()


if __name__ == "__main__":
    main()

```

`config.prop.sample`:

```sample
##########################################################
# All variables in config.prop are optional
# Removing or leaving them blank will keep default values
##########################################################

# The version name of Magisk. Default: git HEAD short SHA1
version=string

# Output path. Default: out
outdir=string

# List of ABIs to build, separated with ','
# Default: armeabi-v7a,x86,arm64-v8a,x86_64
abiList=[string]

#####################################################
# Signing configs for signing zips and APKs
# These 4 variables has to be either all set or not
#####################################################

# Path to keystore file
keyStore=string
# Keystore password
keyStorePass=string
# The desired key alias in the keystore
keyAlias=string
# Password of specified key alias
keyPass=string

```

`docs/README.md`:

```md
# Magisk Documentation

- [Installation Instructions](install.md)
- [Frequently Asked Questions](faq.md)
- [Magisk Changelog](changes.md)

The following sections are for developers

- [Building and Developing Magisk](build.md) (for developing Magisk itself)
- [Developer Guides](guides.md) (for developers **using** Magisk)
- [Magisk Tools](tools.md)
- [Internal Details](details.md)
- [Android Booting Shenanigans](boot.md)

```

`docs/app_changes.md`:

```md
# Magisk Manager Changelog

### v8.0.7

- Fix sepolicy rule migration when upgrading

### v8.0.6

- Minor UI changes
- Update internal scripts

### v8.0.5

- Fix sepolicy rule copying

### v8.0.4

- A lot of stability changes and minor bug fixes
- Collect device properties, app logcat, and Magisk logs when saving logs in the logs menu

### v8.0.3

- Switch to the new Magisk Module Repo setup in preparation to allow 3rd party repos
- Add tapjacking protection on Superuser request dialog
- Stability changes and bug fixes

### v8.0.2

- Fix an issue with requesting permission on devices older than Android 10
- Make more files download through CDN

### v8.0.1

- Fix `vbmeta.img` patching for Samsung `AP.tar` files. This fixes bootloops on devices like Galaxy S10 after flashing updated AP files.
- Properly truncate existing files before writing to prevent corrupted files
- Prevent a possible UI loop when device ran into very low memory
- Switch to use JSDelivr CDN for several files

### v8.0.0

- 100% full app rewrite! Will highlight functional changes below.
- Add detailed device info in home screen to assist user installation
- Support Magisk v21.0 communication protocol
- Support patching modern Samsung `AP.tar`

### v7.5.1

- Fix toggling app components in MagiskHide screen
- Update translations

### v7.5.0

- Support new MagiskSU communication method (ContentProvider)
- Fix several issues with hidden stub APK
- Support using BiometricPrompt (face unlock)

### v7.4.0

- Hide Magisk Manager with stub APKs on Android 9.0+
- Allow customizing app name when hiding Magisk Manager
- Generate random keys to sign the hidden Magisk Manager to prevent signature detections
- Fix fingerprint UI infinite loop

### v7.3.5

- Sort installed modules by name
- Better pre-5.0 support
- Fix potential issues when patching tar files

### v7.3.4

- App is now fully written in Kotlin!
- New downloading system
- Add new "Recovery Mode" to Advanced Settings

### v7.3.0/1/2

- HUGE code base modernization, thanks @diareuse!
- More sweet changes coming in the future!
- Reboot device using proper API (no more abrupt reboot)
- New floating button in Magisk logs to go to bottom

### v7.2.0

- Huge UI overhaul
- More sweet changes coming in the future!

### v7.1.2

- Support patching Samsung AP firmware
- Much better module downloading mechanism

### v7.1.1

- Fix a bug that causes some modules using new format not showing up

### v7.1.0

- Support the new module format
- Support per-application component granularity MagiskHide targets (only on v19+)
- Ask for fingerprint before deleting rules if enabled
- Fix the bug that causes repackaging to lose settings
- Several UI fixes

### v7.0.0

- Major UI redesign!
- Render Markdown natively (no more buggy WebView!)
- Support down to Android 4.1 (native Magisk only support Android 4.2 though)
- Significantly improve Magisk log display performance
- Fix post OTA scripts for A/B devices
- Reduce memory usages when verifying and signing boot image
- Drop support for Magisk lower than v18.0

### v6.1.0

- Introduce new downloading methods: no longer uses buggy system Download Manager
- Introduce many new notifications for better user experience
- Add support for Magisk v18.0
- Change application name to "Manager" after hiding(repackaging) to prevent app name detection
- Add built-in systemless hosts module (access in settings)
- Auto launch the newly installed app after hiding(repackaging) and restoring Magisk Manager
- Fix bug causing incomplete module.prop in modules to have improper UI

### v6.0.1

- Update to use new online module's organizing method
- When fingerprint authentication is enabled, toggling root permissions in "Superuser" section now requires fingerprint beforehand
- Fix crashes when entering MagiskHide section on some devices
- Remove support to Magisk version lower than v15.0
- Ask storage permissions before patching stock boot image
- Update dark theme CardView color

### v6.0.0

- Update to latest AndroidX support library
- Fix crashes when online repos contain incomplete metadata
- Optimize BootSigner to use as little memory as possible, prevent OutOfMemoryError
- Support new communication scheme between Magisk v17.2 and Magisk Manager
- Enable excessive obfuscation to prevent APK analysis root detections (still not 100% obfuscated due to backwards compatibility with stable channel)

### v5.9.0/v5.9.1

- No more on boot notifications
- Support new mechanism for installing to inactive slot for OTAs on A/B devices
- Fix restore Magisk Manager settings on Android P
- Verify existing file checksums to prevent unnecessary re-downloads
- Update SNET extension to use new Google API, fix "Invalid Response" errors
- Move fingerprint settings to magisk database to prevent the settings to be easily removed
- Fingerprint settings are now guarded with fingerprint authentications before it can get changed
- Prevent any files to be downloaded to /sdcard/MagiskManager

### v5.8.3

- Prevent invalid modules in the online repo crashing the app
- Update Stable and Beta channel URLs

### v5.8.1

- Fix a bug that cause the root shell initializer not running in BusyBox environment

### v5.8.0

- Remain hidden when upgrading within repackaged Magisk Manager
- New feature: support reconstructing a proper Magisk environment if error detected (e.g. after factory reset)
- New uninstall method: download uninstaller and completely remove Magisk + Magisk Manager, following with a reboot
- Hidden apps are now shown on the top of the list in MagiskHide fragment
- Tons of under-the-hood bug fixes and improvements

### v5.7.0

- Add app shortcuts for Android 7.1+
- Bump minimal module minMagisk requirement to 1500
- Adjustments for new sepolicies on v16.4+
- Fix crashes when refreshing the online repo

### v5.6.4

- Remove the blacklisted apps using SafetyNet (e.g. Pokemon GO)

### v5.6.3

- Fix repo loading UI logic

### v5.6.2

- Cleanup folders if installation failed
- Add support for Android P

### v5.6.1

- Fix database crashes on F2FS with SQLite 3.21.0+
- Optimize several settings options
- Use native XML for settings migration

### v5.6.0

- Remove JNI requirement, Magisk Manager is now pure Java
- Update the method of handling su database, may fix the issue that root requests won't save
- Add the option to restore Magisk Manager after repackaging with random package name
- Massive under-the-hood

### v5.5.5

- Fix crashes on Lollipop and some devices not following AOSP standards

### v5.5.4

- Fix dtbo on-boot detection, should follow configured dtbo patching behavior on Pixel 2 devices
- Add fingerprint authentication for Superuser requests

### v5.5.3

- Update translations
- Update internal scripts (in sync with Magisk)
- Minor adjustments

### v5.5.2

- Support sorting online repos with last update
- Fix issue that advanced installation settings won't stick
- Prevent sudb crashing Magisk Manager

### v5.5.1
- Fix an issue in setting up superuser database, which causes some users to experience tons of root issues

### v5.5.0

- Fix dynamic resource loading, prevent crashes when checking SafetyNet
- Update SignAPK to use very little RAM for supporting old devices
- Support settings migration after hiding Magisk Manager
- Add reboot menu in modules section
- Add dark theme to superuser request dialogs
- Properly handle new HIGHCOMP and add recommended KEEPVERITY and KEEPFORCEENCRYPT flags for installation
- Support new paths for v14.6
- Massive improvements in repackaging Magisk Manager

### v5.4.3

- Add flags to intent to prevent crashes
- Update translations

### v5.4.2

- Support new paths and setup of v14.5
- Support repackaging Magisk Manager for hiding (only works on v14.5+)
- Support hardlinking global su database into app data
- Support signing boot images (AVB 1.0)
- Update app icon to adaptive icons
- Remove app from MagiskHide list if uninstalled
- Add support to save detailed logs when installing Magisk or modules
- Fix download progress error if module is larger than 20MB
- Changed the way how downloaded repos are processed, should be rock stable
- Prevent crashes when database is corrupted - clear db instead
- Fix saving wrong UID issue on multiuser mode
- Add custom update channel support - you can now switch to your own update server!
- Some UI adjustments and asynchronous UI performance improvements

### v5.4.0

- SafetyNet checks now require external code extension (for 100% FOSS)
- Repo loading will now show real-time progress instead of blank screen
- Show progress when downloading an online module
- Allow secondary users to access superuser settings if allowed
- Fix several places where external storage is needed but forgot to request
- Fetching online repo info from sever is significantly faster thanks to multithreading
- Pulling down Download page will now force a full refresh, thanks to the faster loading speed
- Using new resetprop tool to properly detect MagiskHide status

### v5.3.5

- Fix error when MagiskManager folder doesn't exist
- Offload many logic to scripts: script fixes will also be picked up in the app
- Add installing Magisk to second slot on A/B partition devices
- Support file based encryption: store necessary files into DE storage
- Update uninstall method to self remove app and prompt user to manually reboot

### v5.3.0

- Add hide Magisk Manager feature - hide the app from detection
- Add update channel settings - you can now receive beta updates through the app
- Proper runtime permission implementation - request storage permission only when needed
- Add boot image file patch feature - you can patch boot images without root!
- Rewrite Magisk direct install method - merge with boot image file patch mode
- Add feature to restore stock boot image - convenient for applying OTAs

### v5.2.0

- Fix force close which occurs when failure in flashing zips
- Remove several external dependencies and rewrite a large portion of components
- Improve MarkDown support: showing README.MD is much faster and will properly render Unicode characters (e.g. Chinese characters)
- Add language settings: you can now switch to languages other than system default
- Remove busybox included within APK; download through Internet if needed
- Use Magisk internal busybox if detected
- Busybox is added to the highest priority in PATH to create reliable shell environment
- Always use global namespace for internal shell if possible

### v5.1.1

- Fix Magisk Manager hanging when reading files with no end newline
- Massive rewrite AsyncTasks to prevent potential memory leak
- Fix some minor issues with notifications
- Improve update notification and popup behavior
- Update internal uninstaller script

### v5.1.0

- Introduce a new flash log activity, so you know what is actually happening, just like flashing in custom recoveries!
- Rewritten Java native shall interface: merged root shell and normal shell
- Cleaned up implementation of repo recyclerview and adapters

### v5.0.6

- Fix crash when installing modules downloading from repos

### v5.0.5

- Fix update notifications on Android O
- Fix crash when trying to install Magisk Manager update
- Update translations

### v5.0.4

- Fix bug in su timeout

### v5.0.3

- Fix FC on boot on Android O
- Adapt to Android O broadcast limitations: re-authenticate app when update is disabled on Android O

### v5.0.2
- Rewrite zip signing part, zips downloaded from repo will be properly signed and adjusted for custom recoveries

### v5.0.1

- Add namespace mode options
- Fix a bug in Manager OTA system

### v5.0.0

- Support the new Magisk unified binary
- Properly handle application install / uninstall root management issues
- Add multiuser mode support
- Add application upgrade re-authentication feature
- Add basic integrity check for SafetyNet
- Merged install fragment and status fragment into Magisk fragment
- Fix theme switching glitch
- Update translations

### v4.3.3

- Re-build APK with stable build tools

### v4.3.2

- Improve usage of Github API to support unlimited amount of online repos
- Update translations (thanks to all contributors!!)

### v4.3.1
- Update proper Magisk busybox detection, will not be confused by busybox installed by default in custom roms

### v4.3.0

- Add Core Only Mode option
- Fix crashes when selecting release note on Samsung devices
- Hide modules using template lower than version 3

### v4.2.7

- Update translations
- Update uninstall scripts

### v4.2.6

- Samsung crashes finally fixed (confirmed!)
- Add settings to disable update notifications
- Adjust Dark theme colors
- Refined download section, now support download only when root is not detected
- Fix crashes in boot image selection

### v4.2

- Change Repo cache to database
- Dark theme refined
- Alert Dialog buttons now properly aligned
- Support very large online modules' zip processing
- You can now download online modules without installing
- Add notifications when new Magisk version is available
- Removed changelog, donation link, support link in download cards
- Read and display README.md for online modules

### v4.1

- Change MagiskHide startup
- Reduce static data (= less memory leaks/issues)
- Translation updates

### v4.0

- Whole new Superuser section for MagiskSU management!
- Add Superuser tab in Logs section
- Add lots of Superuser settings
- Handle MagiskSU requests, logging, notifications
- Controls MagiskHide initialization
- Add disable button
- Add uninstall button
- Tons of improvements, not practical to list all :)

### v3.1

- Fix online repo inaccessible issue
- Fix repo list card expanding issues
- Change SafetyNet check to manually triggered
- Update translations
- Tons of bug fixes preventing potential crashes

### v3.0

- Now on Play Store
- Add Status Section, you can check Safety Net, root status, and Magisk status in one place
- Add Install Section, you can manually choose the boot image location and advanced options

### v2.5

- Add Magisk Hide section, you can now add/remove apps from Magisk Hide list
- Support custom Magisk Version names, any string is now accepted (for custom builds)
- Fixed modules and repos not sorted by name

### v2.1

- Add Magisk Hide settings
- Add search bar in "Downloads Sections"
- Fix crashes when no root is available
- Fix trash can icon not updated when removing module
- Prevent crash when Magisk Version is set incorrectly

### v2.0

- Massive refactor
- Material Design
- Module Management
- Download Section
- And much more....

### v1.0

- Initial release

```

`docs/boot.md`:

```md
# Android Booting Shenanigans

## Terminologies

- **rootdir**: the root directory (`/`). All files/folders/filesystems are stored in or mounted under rootdir. On Android, the filesystem may be either `rootfs` or the `system` partition.
- **`initramfs`**: a section in Android's boot image that the Linux kernel will use as `rootfs`. People also use the term **ramdisk** interchangeably
- **`recovery` and `boot` partition**: these 2 are actually very similar: both are Android boot images containing ramdisk and Linux kernel (plus some other stuff). The only difference is that booting `boot` partition will bring us to Android, while `recovery` has a minimalist self contained Linux environment for repairing and upgrading the device.
- **SAR**: System-as-root. That is, the device uses `system` as rootdir instead of `rootfs`
- **A/B, A-only**: For devices supporting [Seamless System Updates](https://source.android.com/devices/tech/ota/ab), it will have 2 slots of all read-only partitions; we call these **A/B devices**. To differentiate, non A/B devices will be called **A-only**
- **2SI**: Two Stage Init. The way Android 10+ boots. More info later.

Here are a few parameters to more precisely define a device's Android version:

- **LV**: Launch Version. The Android version the device is **launched** with. That is, the Android version pre-installed when the device first hit the market.
- **RV**: Running Version. The Android version the device is currently running on.

We will use **Android API level** to represent LV and RV. The mapping between API level and Android versions can be seen in [this table](https://source.android.com/setup/start/build-numbers#platform-code-names-versions-api-levels-and-ndk-releases). For example: Pixel XL is released with Android 7.1, and is running Android 10, these parameters will be `(LV = 25, RV = 29)`

## Boot Methods

Android booting can be roughly categorized into 3 major different methods. We provide a general rule of thumb to determine which method your device is most likely using, with exceptions listed separately.

Method | Initial rootdir | Final rootdir
:---: | --- | ---
**A** | `rootfs` | `rootfs`
**B** | `system` | `system`
**C** | `rootfs` | `system`

- **Method A - Legacy ramdisk**: This is how *all* Android devices used to boot (good old days). The kernel uses `initramfs` as rootdir, and exec `/init` to boot.
	- Devices that does not fall in any of Method B and C's criteria
- **Method B - Legacy SAR**: This method was first seen on Pixel 1. The kernel directly mounts the `system` partition as rootdir and exec `/init` to boot.
	- Devices with `(LV = 28)`
	- Google: Pixel 1 and 2. Pixel 3 and 3a when `(RV = 28)`.
	- OnePlus: 6 - 7
	- Maybe some `(LV < 29)` Android Go devices?
- **Method C - 2SI ramdisk SAR**: This method was first seen on Pixel 3 Android 10 developer preview. The kernel uses `initramfs` as rootdir and exec `/init` in `rootfs`. This `init` is responsible to mount the `system` partition and use it as the new rootdir, then finally exec `/system/bin/init` to boot.
	- Devices with `(LV >= 29)`
	- Devices with `(LV < 28, RV >= 29)`, excluding those that were already using Method B
	- Google: Pixel 3 and 3a with `(RV >= 29)`

### Discussion

From documents online, Google's definition of SAR only considers how the kernel boots the device (**Initial rootdir** in the table above), meaning that only devices using **Method B** is *officially* considered an SAR device from Google's standpoint.

However for Magisk, the real difference lies in what the device ends up using when fully booted (**Final rootdir** in the table above), meaning that **as far as Magisk's concern, both Method B and C is a form of SAR**, but just implemented differently. Every instance of SAR later mentioned in this document will refer to **Magisk's definition** unless specifically says otherwise.

The criteria for Method C is a little complicated, in layman's words: either your device is modern enough to launch with Android 10+, or you are running an Android 10+ custom ROM on a device that was using Method A.

- Any Method A device running Android 10+ will automatically be using Method C
- **Method B devices are stuck with Method B**, with the only exception being Pixel 3 and 3a, which Google retrofitted the device to adapt the new method.

SAR is a very important part of [Project Treble](https://source.android.com/devices/architecture#hidl) as rootdir should be tied to the platform. This is also the reason why Method B and C comes with `(LV >= ver)` criterion as Google has enforced all OEMs to comply with updated requirements every year.

## Some History

When Google released the first generation Pixel, it also introduced [A/B (Seamless) System Updates](https://source.android.com/devices/tech/ota/ab). Due to [storage size concerns](https://source.android.com/devices/tech/ota/ab/ab_faqs), there are several differences compared to A-only, the most relevant one being the removal of `recovery` partition and the recovery ramdisk being merged into `boot`.

Let's go back in time when Google is first designing A/B. If using SAR (only Boot Method B exists at that time), the kernel doesn't need `initramfs` to boot Android (because rootdir is in `system`). This mean we can be smart and just stuff the recovery ramdisk (containing the minimalist Linux environment) into `boot`, remove `recovery`, and let the kernel pick whichever rootdir to use (ramdisk or `system`) based on information from the bootloader.

As time passed from Android 7.1 to Android 10, Google introduced [Dynamic Partitions](https://source.android.com/devices/tech/ota/dynamic_partitions/implement). This is bad news for SAR, because the Linux kernel cannot directly understand this new partition format, thus unable to directly mount `system` as rootdir. This is when they came up with Boot Method C: always boot into `initramfs`, and let userspace handle the rest of booting. This includes deciding whether to boot into Android or recovery, or as they officially call: `USES_RECOVERY_AS_BOOT`.

Some modern devices using A/B with 2SI also comes with `recovery_a/_b` partitions. This is officially supported with Google's standard. These devices will then only use the boot ramdisk to boot into Android as recovery is stored on a separate partition.

## Piecing Things Together

With all the knowledge above, now we can categorize all Android devices into these different types:

Type | Boot Method | Partition | 2SI | Ramdisk in `boot`
:---: | :---: | :---: | :---: | :---:
**I** | A | A-only | No | `boot` ramdisk
**II** | B | A/B | Any | `recovery` ramdisk
**III** | B | A-only | Any | ***N/A***
**IV** | C | Any | Yes | Hybrid ramdisk

These types are ordered chronologically by the time they were first available.

- **Type I**: Good old legacy ramdisk boot
- **Type II**: Legacy A/B devices. Pixel 1 is the first device of this type, being both the first A/B and SAR device
- **Type III**: Late 2018 - 2019 devices that are A-only. **The worst type of device to ever exist as far as Magisk is concerned.**
- **Type IV**: All devices using Boot Method C are Type IV. A/B Type IV ramdisk can boot into either Android or recovery based on info from bootloader; A-only Type IV ramdisk can only boot into Android.

Further details on Type III devices: Magisk is always installed in the ramdisk of a boot image. For all other device types, because their `boot` partition have ramdisk included, Magisk can be easily installed by patching boot image through the Magisk app or flash zip in custom recovery. However for Type III devices, they are **limited to install Magisk into the `recovery` partition**. Magisk will not function when booted normally; instead Type III device owners have to always reboot to recovery to maintain Magisk access.

Some Type III devices' bootloader will still accept and provide `initramfs` that was manually added to the `boot` image to the kernel (e.g. some Xiaomi phones), but many device don't (e.g. Samsung S10, Note 10). It solely depends on how the OEM implements its bootloader.

```

`docs/build.md`:

```md
# Building and Development

## Setup Environment

- Supported platforms:
  - Linux x64
  - macOS x64 (Intel)
  - macOS arm64 (Apple Silicon)
  - Windows x64
- Windows only: Enable [developer mode](https://learn.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development). This is required because we need symbolic link support.
- Install Python 3.8+:
  - On Unix, install python3 using your favorite package manager
  - On Windows, download and install the latest Python version on the [official website](https://www.python.org/downloads/windows/).<br>
    Make sure to select **"Add Python to PATH"** during installation.
  - (Optional on Windows): Run `pip install colorama` to install the `colorama` python package
- Install Git:
  - On Unix, install git with your favorite package manager
  - On Windows, download the install the latest Git version on the [official website](https://git-scm.com/download/win).<br>
    Make sure to **"Enable symbolic links"** during installation.
- Install Android Studio and follow the instructions and go through the initial setup.
- Set environment variable `ANDROID_HOME` to the Android SDK folder. This path can be found in Android Studio settings.
- Setup JDK:
  - The recommended option is to set environment variable `ANDROID_STUDIO` to the path where your Android Studio is installed. The build script will automatically find and use the bundled JDK.
  - You can also setup JDK 17 yourself, but this guide will not cover the instructions.
- Clone sources: `git clone --recurse-submodules https://github.com/topjohnwu/Magisk.git`
- Run `./build.py ndk` to let the script download and install NDK for you

## Building

- To build everything and create the final Magisk APK, run `./build.py all`.
- You can also build specific sub-components; call `build.py` to see your options. \
  For each action, use `-h` to access help (e.g. `./build.py binary -h`)
- Configure the build by using `config.prop`. A sample `config.prop.sample` is provided.

## IDE Support

- Kotlin, Java, C++, and C code in the project should be supported in Android Studio out of the box. This repository can be directly opened with Android Studio as a project.
- For Rust development, see the next section.
- Before working on any native code, build all native code first with `./build.py binary`, as some generated code is only created during the build process.

### Developing Rust

First, install [rustup](https://www.rust-lang.org/tools/install), the official Rust toolchain manager. The Magisk NDK package [ONDK](https://github.com/topjohnwu/ondk) (the one installed with `./build.py ndk`) bundles a complete Rust toolchain, so _building_ the Magisk project itself does not require any further configuration.

However, if you'd like to work on the Rust codebase, it'll be easier if you link ONDK's Rust toolchain in `rustup` and set it as default so several development tools and IDEs will work properly:

```bash
# Link the ONDK toolchain with the name "magisk"
rustup toolchain link magisk "$ANDROID_HOME/ndk/magisk/toolchains/rust"
# Set magisk as default
rustup default magisk
```

If you plan to use VSCode, you can then install the [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer) plugin and everything should be good to go. If you plan to use Jetbrain IDEs (e.g. [Rustrover](https://www.jetbrains.com/rust/), or its Rust Plugin), we need some additional setup:

- Install the official nightly toolchain and add some components. We won't actually use the nightly toolchain for anything other than tricking the IDE to cooperate; the magic happens in the wrapper we setup in the next step.

```bash
rustup toolchain install nightly
# Add some components that is also included in ONDK
rustup +nightly component add rust-src clippy
```

- Create a wrapper cargo bin directory to workaround `rustup` limitations

```bash
# We choose ~/.cargo/wrapper here as an example (and a good recommendation)
# Pick any path you like, you just need to use this path in the next step
./build.py rustup ~/.cargo/wrapper
```

- In Settings > Rust > Toolchain location, set this to the path of the wrapper directory we just created.
- The IDE should now be fully functional, and you are able to enable `rustfmt` and use `Clippy` as the external linter.

## Signing and Distribution

- In release builds, the certificate of the key signing the Magisk APK will be used by Magisk's root daemon as a reference to reject and forcefully uninstall any non-matching Magisk apps to protect users from malicious and unverified Magisk APKs.
- To do any development on Magisk itself, switch to an **official debug build and reinstall Magisk** to turn off the signature check.
- To distribute your own Magisk builds signed with your own keys, set your signing configs in `config.prop`.
- Check [Google's Documentation](https://developer.android.com/studio/publish/app-signing.html#generate-key) for more details on generating your own key.

```

`docs/changes.md`:

```md
# Magisk Changelog

### v30.7 (2026.2.23)

- [MagiskInit] Support Android 16 QPR2 sepolicy format
- [MagiskInit] Support using klogdump partition as pre-init storage
- [Zygisk] Support Android 16 QPR2 and higher
- [Zygisk] Support Android XR and some Nubia devices
- [MagiskSU] Do not drop capabilities by default, even when switching to non-root UIDs. Explicitly use the `--drop-cap` argument to drop capabilities.
- [MagiskBoot] Better lzma format detection
- [MagiskBoot] Fix various commandline argument parsing bugs

### v30.6 (2025.12.1)

- [MagiskInit] Revert a change that could result in bootloops

### v30.5 (2025.12.1)

- [General] Improve commandline argument parsing logic
- [resetprop] Properly support Android versions with property overrides

### v30.4 (2025.10.2)

- [MagiskSU] Fix several implementation bugs

### v30.3 (2025.9.29)

- [General] Support installing Magisk into vendor_boot partition
- [MagiskPolicy] Support new sepolicy binary format introduced in Android 16 QPR2
- [Core] Migrate much more code into Rust
- [MagiskSU] Fallback to older implementation when the kernel doesn't support zero userspace copy APIs

### v30.2 (2025.8.6)

- [Core] Fix an edge case breaking modules when overlayfs is involved
- [Core] Fix module `.replace` functionality in certain situations
- [resetprop] Reduce property modification traces

### v30.1 (2025.7.3)

- [Core] Fix bug in module mounting implementation
- [MagiskSU] Add ability to restrict Linux capabilities even if running as root (uid=0)

### v30.0 (2025.7.1)

- [General] Various minor bug fixes
- [Core] Migrate module implementation to Rust
- [Core] Improve Magisk specific files injection logic
- [MagiskBoot] Migrate compression code to Rust

### v29.0 (2025.5.14)

- [General] Massive internal refactoring and code migration
- [App] Support downloading module zip files with XZ compression
- [App] Disable app animations when system animations are disabled
- [Core] Support systemlessly deleting files with modules using blank file nodes
- [MagiskInit] Redesign sepolicy patching and injection logic
- [MagiskSU] Better TTY/PTY support

### v28.1 (2024.12.6)

- [App] Fix stub APK download link
- [App] Fix support for Android lower than 8.0
- [General] Fix support for MTK Samsung devices
- [MagiskInit] Fix a regression for 2SI devices
- [MagiskPolicy] Fix a regression causing `overlay.d` replaced files to be not accessible

### v28.0 (2024.10.10)

- [General] Support 16k page size
- [General] Add basic support for RISC-V (not built in releases)
- [General] Use a minimal libc to build static executables (`magiskinit` and `magiskboot`) for smaller sizes
- [Core] Remove unnecessary mirror for magic mount
- [Core] Update boot image detection logic to support more devices
- [MagiskInit] Rewrite 2SI logic for injecting `magiskinit` as `init`
- [MagiskInit] Update preinit partition detection
- [Zygisk] Update internal JNI hooking implementation
- [MagiskPolicy] Preserve sepolicy config flag after patching
- [MagiskPolicy] Optimize patching rules to reduce the amount of new rules being injected
- [DenyList] Support enforcing denylist when Zygisk is disabled
- [Resetprop] Improve implementation to workaround several property modification detections
- [Resetprop] Update to properly work with property overlays
- [App] Major internal code refactoring
- [App] Support patching Samsung firmware with images larger than 8GiB
- [App] Use user-initiated job instead of foreground services on Android 14
- [App] Support Android 13+ built-in per-app language preferences
- [App] Add `action.sh` support to allow modules to define an action triggered from UI
- [MagiskBoot] Support spliting kernel images without decompression
- [MagiskBoot] Properly support vendor boot images
- [MagiskBoot] Disable Samsung PROCA from kernel image

### v27.0 (2024.2.3)

- [Zygisk] Introduce new code injection mechanism
- [Zygisk] Support new signature introduced in U QPR2
- [SEPolicy] Update libsepol to properly set some policy config bits
- [MagiskBoot] Support compressing `init` so Magisk is installable on devices with small boot partitions
- [ResetProp] Add new wait for property feature `resetprop -w`

### v26.4 (2023.11.5)

- [MagiskBoot] Don't pad zeros if signed boot image is larger
- [MagiskPolicy] Fix `genfscon` and `filename_trans`
- [MagiskPolicy] Fix bug in `libsepol`
- [Zygisk] Fix and simplify file descriptor sanitization logic
- [App] Prevent OOM when patching AP tarfiles
- [App] Fix bug in device configuration detection
- [Daemon] Fix certificate parsing of APKs
- [General] Fix logging errors from C++ code being ignored

### v26.3 (2023.9.4)

- [General] Fix device information detection script
- [General] Update BusyBox to 1.36.1
- [General] Update toolchain that produces broken arm32 executables
- [App] Fix root service unable to bind on OnePlus devices

### v26.2 (2023.8.27)

- [MagiskBoot] Support extracting boot image from `payload.bin`
- [MagiskBoot] Support cpio files containing character files
- [MagiskBoot] Support listing cpio content
- [MagiskBoot] Directly handle AVB 1.0 signing and verification without going through Java implementation
- [Daemon] Make daemon socket a fixed path in MAGISKTMP
- [resetprop] Support printing property context
- [resetprop] Support only printing persistent properties from storage
- [resetprop] Properly support setting persistent properties bypassing property_service
- [MagiskSU] Support `-g` and `-G` options
- [MagiskSU] Support switching mount namespace to PID with `-t`
- [MagiskPolicy] Fix patching extended permissions
- [MagiskPolicy] Support more syntax for extended permissions
- [MagiskPolicy] Support printing out the loaded sepolicy rules
- [App] Support patching boot image from ROM zips
- [App] Properly preserve `boot.img` when patching Samsung firmware with `init_boot.img`

### v26.1 (2023.4.11)

- [App] Fix crashing when revoking root permissions
- [MagiskInit] Always prefer `ext4` partitions over `f2fs` when selecting the pre-init partition
- [General] Restore module files' context/owner/group from mirror. This is a regression introduced in v26.0

### v26.0 (2023.4.5)

- [General] Bump minimum supported Android version to Android 6.0
- [General] New magic mount backend. It supports loading modules into system with `overlayfs` files injected
- [Zygisk] Release new API version 4
- [Zygisk] Prevent crashing daemon in error
- [Zygisk] Rewrite zygote code injection with new loader library approach
- [Zygisk] Rewrite code unloading implementation
- [MagiskBoot] Support amonet microloader devices
- [MagiskBoot] Always use lz4_legacy compression on v4 boot images. This fixes boot image patching issues on Android U preview.
- [MagiskInit] Support replacing existing \*.rc files in `overlay.d`
- [MagiskInit] Rewrite sepolicy.rules mounting and loading implementation
- [App] Make stub patching 100% offline
- [App] Support patching `init_boot.img` for Samsung ODIN firmware
- [MagiskPolicy] Fix minor bug in command line argument parsing
- [MagiskPolicy] Update rules to support Android U

### v25.2 (2022.7.20)

- [MagiskInit] Fix a potential issue when stub cpio is used
- [MagiskInit] Fix reboot to recovery when stub cpio is used
- [MagiskInit] Fix sepolicy.rules symlink for rootfs devices
- [General] Better data encryption detection
- [General] Move the whole logging infrastructure into Rust

### v25.1 (2022.6.19)

- [MagiskBoot] Fix ramdisk backup being incorrectly skipped
- [MagiskBoot] Add new feature to detect unsupported dtb and abort during installation
- [Zygisk] Change binary hijack paths
- [App] Fix incorrect recovery mode detection and installation
- [MagiskInit] Fix config not properly exported in legacy SAR devices
- [General] Enforce the Magisk app to always match or be newer than `magiskd`

### v25.0 (2022.6.7)

- [MagiskInit] Update 2SI implementation, significantly increase device compatibility (e.g. Sony Xperia devices)
- [MagiskInit] Introduce new `sepolicy` injection mechanism
- [MagiskInit] Support Oculus Go
- [MagiskInit] Support Android 13 GKIs (Pixel 6)
- [MagiskBoot] Fix vbmeta extraction implementation
- [App] Fix stub app on older Android versions
- [App] [MagiskSU] Properly support apps using `sharedUserId`
- [MagiskSU] Fix a possible crash in `magiskd`
- [MagiskSU] Prune unused UIDs as soon as `system_server` restarts to prevent UID reuse attacks
- [MagiskSU] Verify and enforce the installed Magisk app's certificate to match the distributor's signature
- [MagiskSU] [Zygisk] Proper package management and detection
- [Zygisk] Fix function hooking on devices running Android 12 with old kernels
- [Zygisk] Fix Zygisk's self code unloading implementation
- [DenyList] Fix DenyList on shared UID apps
- [BusyBox] Add workaround for devices running old kernels

### v24.3 (2022.3.10)

- [General] Stop using `getrandom` syscall
- [Zygisk] Update API to v3, adding new fields to `AppSpecializeArgs`
- [App] Improve app repackaging installation workflow

### v24.2 (2022.3.1)

- [MagiskSU] Fix buffer overflow
- [MagiskSU] Fix owner managed multiuser superuser settings
- [MagiskSU] Fix command logging when using `su -c <cmd>`
- [MagiskSU] Prevent su request indefinite blocking
- [MagiskBoot] Support `lz4_legacy` archive with multiple magic
- [MagiskBoot] Fix `lz4_lg` compression
- [DenyList] Allow targeting processes running as system UID
- [Zygisk] Workaround Samsung's "early zygote"
- [Zygisk] Improved Zygisk loading mechanism
- [Zygisk] Fix application UID tracking
- [Zygisk] Fix improper `umask` being set in zygote
- [App] Fix BusyBox execution test
- [App] Improve stub loading mechanism
- [App] Major app upgrade flow improvements
- [General] Improve commandline error handling and messaging

### v24.1 (2022.1.28)

- [App] Stability improvements

### v24.0 (2022.1.26)

- [General] MagiskHide is removed from Magisk
- [General] Support Android 12
- [General] Support devices that do not support 32-bit and only runs 64-bit code
- [General] Update BusyBox to 1.34.1
- [Zygisk] Introduce new feature: Zygisk
- [Zygisk] Introduce DenyList feature to revert Magisk features in user selected processes
- [MagiskBoot] Support patching 32-bit kernel zImages
- [MagiskBoot] Support boot image header v4
- [MagiskBoot] Support patching out `skip_initramfs` from dtb bootargs
- [MagiskBoot] Add new env variable `PATCHVBMETAFLAG` to configure whether vbmeta flags should be patched
- [MagiskInit] Support loading fstab from `/system/etc` (required for Pixel 6)
- [MagiskInit] Support `/proc/bootconfig` for loading boot configurations
- [MagiskInit] Better support for some Meizu devices
- [MagiskInit] Better support for some OnePlus/Oppo/Realme devices
- [MagiskInit] Support `init.real` on some Sony devices
- [MagiskInit] Skip loading Magisk when detecting DSU
- [MagiskPolicy] Load `*_compat_cil_file` from system_ext
- [MagiskSU] Use isolated devpts if the kernel supports it
- [MagiskSU] Fix root shell if isolated mount namespace is set
- [resetprop] Deleted properties are now wiped from memory instead of just unlinking
- [App] Build a single APK for all ABIs
- [App] Switch to use standard bottom navigation bar
- [App] Downloading modules from the centralized Magisk-Modules-Repo is removed
- [App] Support user configuration of boot image vbmeta patching
- [App] Restore the ability to install Magisk on the other slot on some A/B devices
- [App] Allow modules to specify an update URL for in-app update + install

### v23.0 (2021.5.12)

- [App] Update snet extension. This fixes SafetyNet API errors.
- [App] Fix a bug in the stub app that causes APK installation to fail
- [App] Hide annoying errors in logs when hidden as stub
- [App] Fix issues when patching ODIN tar files when the app is hidden
- [General] Remove all pre Android 5.0 support
- [General] Update BusyBox to use proper libc
- [General] Fix C++ undefined behaviors
- [General] Several `sepolicy.rule` copy/installation fixes
- [MagiskPolicy] Remove unnecessary sepolicy rules
- [MagiskHide] Update package and process name validation logic
- [MagiskHide] Some changes that prevents zygote deadlock

### v22.1 (2021.4.9)

- [App] Prevent multiple installation sessions running in parallel
- [App] Prevent OutOfMemory crashes when checking boot signature on PXA boot images
- [General] Proper cgroup migration implementation
- [General] Rewrite log writer from scratch, should resolve any crashes and deadlocks
- [General] Many scripts updates fixing regressions
- [MagiskHide] Prevent possible deadlock when signal arrives
- [MagiskHide] Partial match process names if necessary
- [MagiskBoot] Preserve and patch AVB 2.0 structures/headers in boot images
- [MagiskBoot] Properly strip out data encryption flags
- [MagiskBoot] Prevent possible integer overflow
- [MagiskInit] Fix `sepolicy.rule` mounting strategy
- [resetprop] Always delete existing `ro.` props before updating. This will fix bootloops that could be caused by modifying device fingerprint properties.

### v22.0 (2021.2.23)

- [General] Magisk and Magisk Manager is now merged into the same package!
- [App] The term "Magisk Manager" is no longer used elsewhere. We refer it as the Magisk app.
- [App] Support hiding the Magisk app with advanced technique (stub APK loading) on Android 5.0+ (it used to be 9.0+)
- [App] Disallow re-packaging the Magisk app on devices lower than Android 5.0
- [App] Detect and warn about multiple invalid states and provide instructions on how to resolve it
- [MagiskHide] Fix a bug when stopping MagiskHide does not take effect
- [MagiskBoot] Fix bug when unpacking `lz4_lg` compressed boot images
- [MagiskInit] Support Galaxy S21 series
- [MagiskSU] Fix incorrect APEX paths that caused `libsqlite.so` fail to load

### v21.4 (2021.1.17)

- [MagiskSU] Fix `su -c` behavior that broke many root apps
- [General] Properly handle read/write over sockets (the `broken pipe` issue)

### v21.3 (2021.1.16)

- [MagiskInit] Avoid mounting `f2fs` userdata as it may result in kernel crashes. This shall fix a lot of bootloops
- [MagiskBoot] Fix a minor header checksum bug for `DHTB` header and ASUS `blob` image formats
- [MagiskHide] Allowing hiding isolated processes if the mount namespace is separated

### v21.2 (2020.12.28)

- [MagiskInit] Detect 2SI after mounting `system_root` on legacy SAR devices
- [General] Make sure `post-fs-data` scripts cannot block more than 35 seconds
- [General] Fix the `magisk --install-module` command
- [General] Trim Windows newline when reading files
- [General] Directly log to file to prevent `logcat` weirdness
- [MagiskBoot] Fix header dump/load for header v3 images

### v21.1 (2020.11.13)

- [MagiskBoot] Support boot header v3 (Pixel 5 and 4a 5G)
- [MagiskBoot] Distinguish `lz4_lg` and `lz4_legacy` (Pixel 5 and 4a 5G)
- [MagiskBoot] Support vendor boot images (for dev, not relevant for Magisk installation)
- [MagiskInit] Support kernel cmdline `androidboot.fstab_suffix`
- [MagiskInit] Support kernel initialized dm-verity on legacy SAR
- [General] Significantly broaden sepolicy.rule compatibility
- [General] Add Magisk binaries to `PATH` when executing boot scripts
- [General] Update `--remove-modules` command implementation
- [General] Make Magisk properly survive after factory reset on Android 11
- [MagiskSU] Add APEX package `com.android.i18n` to `LD_LIBRARY_PATH` when linking `libsqlite.so`
- [MagiskHide] Support hiding apps installed in secondary users (e.g. work profile)
- [MagiskHide] Make zygote detection more robust

### v21.0 (2020.10.3)

- [General] Support Android 11 🎉
- [General] Add Safe Mode detection. Disable all modules when the device is booting into Safe Mode.
- [General] Increase `post-fs-data` mode timeout from 10 seconds to 40 seconds
- [MagiskInit] Rewritten 2SI support from scratch
- [MagiskInit] Support when no `/sbin` folder exists (Android 11)
- [MagiskInit] Dump fstab from device-tree to rootfs and force `init` to use it for 2SI devices
- [MagiskInit] Strip out AVB for 2SI as it may cause bootloop
- [Modules] Rewritten module mounting logic from scratch
- [MagiskSU] For Android 8.0+, a completely new policy setup is used. This reduces compromises in Android's sandbox, providing more policy isolation and better security for root users.
- [MagiskSU] Isolated mount namespace will now first inherit from parent process, then isolate itself from the world
- [MagiskSU] Update communication protocol with Magisk Manager to work with the hardened SELinux setup
- [MagiskPolicy] Optimize match all rules. This will significantly reduce policy binary size and save memory and improve general kernel performance.
- [MagiskPolicy] Support declaring new types and attributes
- [MagiskPolicy] Make policy statement closer to stock `*.te` format. Please check updated documentation or `magiskpolicy --help` for more details.
- [MagiskBoot] Support compressed `extra` blobs
- [MagiskBoot] Pad boot images to original size with zeros
- [MagiskHide] Manipulate additional vendor properties

### v20.4 (2020.3.23)

- [MagiskInit] Fix potential bootloop in A-only 2SI devices
- [MagiskInit] Properly support Tegra partition naming
- [General] Load libsqlite.so dynamically, which removes the need to use wrapper scripts on Android 10+
- [General] Detect API level with a fallback method on some devices
- [General] Workaround possible bug in x86 kernel readlinkat system call
- [BusyBox] Enable SELinux features. Add chcon/runcon etc., and '-Z' option to many applets
- [BusyBox] Introduce standalone mode. More details in release notes
- [MagiskHide] Disable MagiskHide by default
- [MagiskHide] Add more potential detectable system properties
- [MagiskHide] Add workaround for Xiaomi devices bootloop when MagiskHide is enabled on cross region ROMs
- [MagiskBoot] Support patching special Motorolla DTB format
- [MagiskPolicy] Support 'genfscon' sepolicy rules
- [Scripts] Support NAND based boot images (character nodes in /dev/block)
- [Scripts] Better addon.d (both v1 and v2) support
- [Scripts] Support Lineage Recovery for Android 10+

### v20.3 (2020.1.10)

- [MagiskBoot] Fix `lz4_legacy` decompression

### v20.2 (2020.1.2)

- [MagiskSU] Properly handle communication between daemon and application (root request prompt)
- [MagiskInit] Fix logging in kmsg
- [MagiskBoot] Support patching dtb/dtbo partition formats
- [General] Support pre-init sepolicy patch in modules
- [Scripts] Update magisk stock image backup format

### v20.1 (2019.11.2)

- [MagiskSU] Support component name agnostic communication (for stub APK)
- [MagiskBoot] Set proper `header_size` in boot image headers (fix vbmeta error on Samsung devices)
- [MagiskHide] Scan zygote multiple times
- [MagiskInit] Support recovery images without /sbin/recovery binary. This will fix some A/B devices unable to boot to recovery after flashing Magisk
- [General] Move acct to prevent daemon being killed
- [General] Make sure "--remove-modules" will execute uninstall.sh after removal

### v20.0 (2019.10.11)

- [MagiskBoot] Support inject/modify `mnt_point` value in DTB fstab
- [MagiskBoot] Support patching QCDT
- [MagiskBoot] Support patching DTBH
- [MagiskBoot] Support patching PXA-DT
- [MagiskInit] [2SI] Support non A/B setup (Android 10)
- [MagiskHide] Fix bug that reject process names with ":"
- [MagicMount] Fix a bug that cause /product mirror not created

### v19.4 (2019.9.19)

- [MagiskInit] [SAR] Boot system-as-root devices with system mounted as /
- [MagiskInit] [2SI] Support 2-stage-init for A/B devices (Pixel 3 Android 10)
- [MagiskInit] [initramfs] Delay sbin overlay creation to post-fs-data
- [MagiskInit] [SARCompat] Old system-as-root implementation is deprecated, no more future changes
- [MagiskInit] Add overlay.d support for root directory overlay for new system-as-root implementation
- [MagiskSU] Unblock all signals in root shells (fix bash on Android)
- [MagicMount] Support replacing files in /product
- [MagiskHide] Support Android 10's Zygote blastula pool
- [MagiskHide] All random strings now also have random length
- [MagiskBoot] Allow no recompression for ramdisk.cpio
- [MagiskBoot] Support some weird Huawei boot images
- [General] Add new `--remove-modules` command to remove modules without root in ADB shell
- [General] Support Android 10 new APEX libraries (Project Mainline)

### v19.3 (2019.6.5)

- [MagiskHide] Hugely improve process monitor implementation, hopefully should no longer cause 100% CPU and daemon crashes
- [MagiskInit] Wait for partitions to be ready for early mount, should fix bootloops on a handful of devices
- [MagiskInit] Support EROFS used in EMUI 9.1
- [MagiskSU] Properly implement mount namespace isolation
- [MagiskBoot] Proper checksum calculation for header v2

### v19.2 (2019.5.20)

- [General] Fix uninstaller
- [General] Fix bootloops on some devices with tmpfs mounting to /data
- [MagiskInit] Add Kirin hi6250 support
- [MagiskSU] Stop claiming device focus for su logging/notify if feasible.
  This fix issues with users locking Magisk Manager with app lock, and prevent
  video apps get messed up when an app is requesting root in the background.

### v19.1 (2019.5.1)

- [General] Support recovery based Magisk
- [General] Support Android Q Beta 2
- [MagiskInit] New sbin overlay setup process for better compatibility
- [MagiskInit] Allow long pressing volume up to boot to recovery in recovery mode
- [MagicMount] Use proper system_root mirror
- [MagicMount] Use self created device nodes for mirrors
- [MagicMount] Do not allow adding new files/folders in partition root folder (e.g. /system or /vendor)

### v19.0 (2019.3.28)

- [General] Remove usage of magisk.img
- [General] Add 64 bit magisk binary for native 64 bit support
- [General] Support A only system-as-root devices that released with Android 9.0
- [General] Support non EXT4 system and vendor partitions
- [MagiskHide] Use Zygote ptracing for monitoring new processes
- [MagiskHide] Targets are now per-application component
- [MagiskInit] Support Android Q (no logical partition support yet!)
- [MagiskPolicy] Support Android Q new split sepolicy setup
- [MagiskInit] Move sbin overlay creation from main daemon post-fs-data to early-init
- [General] Service scripts now run in parallel
- [MagiskInit] Directly inject magisk services to init.rc
- [General] Use lzma2 compressed ramdisk in extreme conditions
- [MagicMount] Clone attributes from original file if exists
- [MagiskSU] Use `ACTION_REBOOT` intent to workaround some OEM broadcast restrictions
- [General] Use `skip_mount` instead of `auto_mount`: from opt-in to opt-out

### v18.1 (2019.2.4)

- [General] Support EMUI 9.0
- [General] Support Kirin 960 devices
- [General] Support down to Android 4.2
- [General] Major code base modernization under-the-hood

### v18.0 (2018.12.8)

- [General] Migrate all code base to C++
- [General] Modify database natively instead of going through Magisk Manager
- [General] Deprecate path /sbin/.core, please start using /sbin/.magisk
- [General] Boot scripts are moved from `<magisk_img>/.core/<stage>.d` to `/data/adb/<stage>.d`
- [General] Remove native systemless hosts (Magisk Manager is updated with a built-in systemless hosts module)
- [General] Allow module post-fs-data.sh scripts to disable/remove modules
- [MagiskHide] Use component names instead of process names as targets
- [MagiskHide] Add procfs protection on SDK 24+ (Nougat)
- [MagiskHide] Remove the folder /.backup to prevent detection
- [MagiskHide] Hide list is now stored in database instead of raw textfile in images
- [MagiskHide] Add "--status" option to CLI
- [MagiskHide] Stop unmounting non-custom related mount points
- [MagiskSU] Add `FLAG_INCLUDE_STOPPED_PACKAGES` in broadcasts to force wake Magisk Manager
- [MagiskSU] Fix a bug causing SIGWINCH not properly detected
- [MagiskPolicy] Support new av rules: type_change, type_member
- [MagiskPolicy] Remove all AUDITDENY rules after patching sepolicy to log all denies for debugging
- [MagiskBoot] Properly support extra_cmdline in boot headers
- [MagiskBoot] Try to repair broken v1 boot image headers
- [MagiskBoot] Add new CPIO command: "exists"

### v17.3 (2018.10.20)

- [MagiskBoot] Support boot image header v1 (Pixel 3)
- [MagiskSU] No more linked lists for caching `su_info`
- [MagiskSU] Parse command-lines in client side and send only options to daemon
- [MagiskSU] Early ACK to prevent client freezes and early denies
- [Daemon] Prevent bootloops in situations where /data is mounted twice
- [Daemon] Prevent logcat failures when /system/bin is magic mounting, could cause MagiskHide to fail
- [Scripts] Switch hexpatch to remove Samsung Defex to a more general pattern
- [Scripts] Update data encryption detection for better custom recovery support

### v17.2 (2018.9.21)

- [ResetProp] Update to AOSP upstream to support serialized system properties
- [MagiskInit] Randomize Magisk service names to prevent detection (e.g. FGO)
- [MagiskSU] New communication scheme to communicate with Magisk Manager

### v17.0/17.1 (2018.9.1)

- [General] Bring back install to inactive slot for OTAs on A/B devices
- [Script] Remove system based root in addon.d
- [Script] Add proper addon.d-v2 for preserving Magisk on custom ROMs on A/B devices
- [Script] Enable KEEPVERITY when the device is using system_root_image
- [Script] Add hexpatch to remove Samsung defex in new Oreo kernels
- [Daemon] Support non ext4 filesystems for mirrors (system/vendor)
- [MagiskSU] Make pts sockets always run in dev_pts secontext, providing all terminal emulator root shell the same power as adb shells
- [MagiskHide] Kill all processes with same UID of the target to workaround OOS embryo optimization
- [MagiskInit] Move all sepolicy patches pre-init to prevent Pixel 2 (XL) boot service breakdown

### v16.7 (2018.7.19)

- [Scripts] Fix boot image patching errors on Android P (workaround the strengthened seccomp)
- [MagiskHide] Support hardlink based ns proc mnt (old kernel support)
- [Daemon] Fix permission of /dev/null after logcat commands, fix ADB on EMUI
- [Daemon] Log fatal errors only on debug builds
- [MagiskInit] Detect early mount partname from fstab in device tree

### v16.6 (2018.7.8)

- [General] Add wrapper script to overcome weird `LD_XXX` flags set in apps
- [General] Prevent bootloop when flashing Magisk after full wipe on FBE devices
- [Scripts] Support patching DTB placed in extra sections in boot images (Samsung S9/S9+)
- [Scripts] Add support for addon.d-v2 (untested)
- [Scripts] Fix custom recovery console output in addon.d
- [Scripts] Fallback to parsing sysfs for detecting block devices
- [Daemon] Check whether a valid Magisk Manager is installed on boot, if not, install stub APK embedded in magiskinit
- [Daemon] Check whether Magisk Manager is repackaged (hidden), and prevent malware from hijacking com.topjohnwu.magisk
- [Daemon] Introduce new daemon: magisklogd, a dedicated daemon to handle all logcat related monitoring
- [Daemon] Replace old invincible mode with handshake between magiskd and magisklogd, one will respawn the other if disconnected
- [Daemon] Support GSI adbd bind mounting
- [MagiskInit] Support detecting block names in upper case (Samsung)
- [MagiskBoot] Check DTB headers to prevent false detections within kernel binary
- [MagiskHide] Compare mount namespace with PPID to make sure the namespace is actually separated, fix root loss
- [MagiskSU] Simplify `su_info` caching system, should use less resources and computing power
- [MagiskSU] Reduce the amount of broadcasting to Magisk Manager
- [ImgTool] Separate all ext4 image related operations to a new applet called "imgtool"
- [ImgTool] Use precise free space calculation methods
- [ImgTool] Use our own set of loop devices hidden along side with sbin tmpfs overlay. This not only eliminates another possible detection method, but also fixes apps that mount OBB files as loop devices (huge thanks to dev of Pzizz for reporting this issue)

### v16.4 (2018.4.29)

- [Daemon] Directly check logcat command instead of detecting logd, should fix logging and MagiskHide on several Samsung devices
- [Daemon] Fix startup Magisk Manager APK installation on Android P
- [MagiskPolicy] Switch from AOSP u:r:su:s0 to u:r:magisk:s0 to prevent conflicts
- [MagiskPolicy] Remove unnecessary sepolicy rules to reduce security penalty
- [Daemon] Massive re-design /sbin tmpfs overlay and daemon start up
- [MagiskInit] Remove `magiskinit_daemon`, the actual magisk daemon (magiskd) shall handle everything itself
- [Daemon] Remove post-fs stage as it is very limited and also will not work on A/B devices; replaced with simple mount in post-fs-data, which will run ASAP even before the daemon is started
- [General] Remove all 64-bit binaries as there is no point in using them; all binaries are now 32-bit only.
  Some weirdly implemented root apps might break (e.g. Tasker, already reported to the developer), but it is not my fault :)
- [resetprop] Add Protobuf encode/decode to support manipulating persist properties on Android P
- [MagiskHide] Include app sub-services as hiding targets. This might significantly increase the amount of apps that could be properly hidden

### v16.3 (2018.3.28)

- [General] Remove symlinks used for backwards compatibility
- [MagiskBoot] Fix a small size calculation bug

### v16.2 (2018.3.18)

- [General] Force use system binaries in handling ext4 images (fix module installation on Android P)
- [MagiskHide] Change property state to disable if logd is disabled

### v16.1 (2018.3.11)

- [MagiskBoot] Fix MTK boot image packaging
- [MagiskBoot] Add more Nook/Acclaim headers support
- [MagiskBoot] Support unpacking DTB with empty kernel image
- [MagiskBoot] Update high compression mode detection logic
- [Daemon] Support new mke2fs tool on Android P
- [resetprop] Support Android P new property context files
- [MagiskPolicy] Add new rules for Android P

### v16.0 (2018.2.22)

- [MagiskInit] Support non `skip_initramfs` devices with slot suffix (Huawei Treble)
- [MagiskPolicy] Add rules for Magisk Manager
- [Compiler] Workaround an NDK compiler bug that causes bootloops

### v15.4 (2018.2.13)

- [MagiskBoot] Support Samsung PXA, DHTB header images
- [MagiskBoot] Support ASUS blob images
- [MagiskBoot] Support Nook Green Loader images
- [MagiskBoot] Support pure ramdisk images
- [MagiskInit] Prevent OnePlus angela `sepolicy_debug` from loading
- [MagiskInit] Obfuscate Magisk socket entry to prevent detection and security
- [Daemon] Fix subfolders in /sbin shadowed by overlay
- [Daemon] Obfuscate binary names to prevent naive detections
- [Daemon] Check logd before force trying to start logcat in a loop

### v15.3 (2018.1.12)

- [Daemon] Fix the bug that only one script would be executed in post-fs-data.d/service.d
- [Daemon] Add `MS_SILENT` flag when mounting, should fix some devices that cannot mount magisk.img
- [MagiskBoot] Fix potential segmentation fault when patching ramdisk, should fix some installation failures

### v15.2 (2018.1.1)

- [MagiskBoot] Fix dtb verity patches, should fix dm-verity bootloops on newer devices placing fstabs in dtb
- [MagiskPolicy] Add new rules for proper Samsung support, should fix MagiskHide
- [MagiskInit] Support non `skip_initramfs` devices using split sepolicies (e.g. Zenfone 4 Oreo)
- [Daemon] Use specific logcat buffers, some devices does not support all log buffers
- [scripts] Update scripts to double check whether boot slot is available, some devices set a boot slot without A/B partitions

### v15.1 (2017.12.29)

- [MagiskBoot] Fix faulty code in ramdisk patches which causes bootloops in some config and fstab format combos

### v15.0 (2017.12.26)

- [Daemon] Fix the bug that Magisk cannot properly detect /data encryption state
- [Daemon] Add merging `/cache/magisk.img` and `/data/adb/magisk_merge.img` support
- [Daemon] Update to upstream libsepol to support cutting edge split policy custom ROM cil compilations

### v14.6 (2017.12.22)

- [General] Move all files into a safe location: /data/adb
- [Daemon] New invincible implementation: use `magiskinit_daemon` to monitor sockets
- [Daemon] Rewrite logcat monitor to be more efficient
- [Daemon] Fix a bug where logcat monitor may spawn infinite logcat processes
- [MagiskSU] Update su to work the same as proper Linux implementation:
  Initialize window size; all environment variables will be migrated (except HOME, SHELL, USER, LOGNAME, these will be set accordingly),
  "--preserve-environment" option will preserve all variables, including those four exceptions.
  Check the Linux su manpage for more info
- [MagiskBoot] Massive refactor, rewrite all cpio operations and CLI
- [MagiskInit][magiskboot] Support ramdisk high compression mode

### v14.5 (1456) (2017.11.23)

- [Magiskinit] Fix bootloop issues on several devices
- [misc] Build binaries with NDK r10e, should get rid of the nasty linker warning when executing magisk

### v14.5 (1455) (2017.11.23)

- [Daemon] Moved internal path to /sbin/.core, new image mountpoint is /sbin/.core/img
- [MagiskSU] Support switching package name, used when Magisk Manager is hidden
- [MagiskHide] Add temporary /magisk removal
- [MagiskHide] All changes above contributes to hiding from nasty apps like FGO and several banking apps
- [Magiskinit] Use magiskinit for all devices (dynamic initramfs)
- [Magiskinit] Fix Xiaomi A1 support
- [Magiskinit] Add Pixel 2 (XL) support
- [Magiskboot] Add support to remove avb-verity in dtbo.img
- [Magiskboot] Fix typo in handling MTK boot image headers
- [script] Along with updates in Magisk Manager, add support to sign boot images (AVB 1.0)
- [script] Add dtbo.img backup and restore support
- [misc] Many small adjustments to properly support old platforms like Android 5.0

### v14.3 (2017.10.15)

- [MagiskBoot] Fix Pixel C installation
- [MagiskBoot] Handle special `lz4_legacy` format properly, should fix all LG devices
- [Daemon] New universal logcat monitor is added, support plug-and-play to worker threads
- [Daemon] Invincible mode: daemon will be restarted by init, everything should seamlessly through daemon restarts
- [Daemon] Add new restorecon action, will go through and fix all Magisk files with selinux unlabeled to `system_file` context
- [Daemon] Add brute-force image resizing mode, should prevent the notorious Samsung crappy resize2fs from affecting the result
- [resetprop] Add new "-p" flag, used to toggle whether alter/access the actual persist storage for persist props

### v14.2 (2017.9.28)

- [MagicMount] Clone attributes to tmpfs mountpoint, should fix massive module breakage

### v14.1 (2017.9.28)

- [MagiskInit] Introduce a new init binary to support `skip_initramfs` devices (Pixel family)
- [script] Fix typo in update-binary for x86 devices
- [script] Fix stock boot image backup not moved to proper location
- [script] Add functions to support A/B slot and `skip_initramfs` devices
- [script] Detect Meizu boot blocks
- [MagiskBoot] Add decompress zImage support
- [MagiskBoot] Support extracting dtb appended to zImage block
- [MagiskBoot] Support patching fstab within dtb
- [Daemon/MagiskSU] Proper file based encryption support
- [Daemon] Create core folders if not exist
- [resetprop] Fix a bug which delete props won't remove persist props not in memory
- [MagicMount] Remove usage of dummy folder, directly mount tmpfs and construct file structure skeleton in place

### v14.0 (2017.9.6)

- [script] Simplify installation scripts
- [script] Fix a bug causing backing up and restoring stock boot images failure
- [script] Installation and uninstallation will migrate old or broken stock boot image backups to proper format
- [script] Fix an issue with selabel setting in `util_functions.sh` on Lollipop
- [rc script] Enable logd in post-fs to start logging as early as possible
- [MagiskHide] magisk.img mounted is no longer a requirement
  Devices with issues mounting magisk.img can now run in proper core-only mode
- [MagiskBoot] Add native function to extract stock SHA1 from ramdisk
- [b64xz] New tool to extract compressed and encoded binary dumps in shell script
- [busybox] Add busybox to Magisk source, and embed multi-arch busybox binary into update-binary shell script
- [busybox] Busybox is added into PATH for all boot scripts (post-fs-data.d, service.d, and all module scripts)
- [MagiskSU] Fully fix multiuser issues
- [Magic Mount] Fix a typo in cloning attributes
- [Daemon] Fix the daemon crashing when boot scripts opens a subshell
- [Daemon] Adjustments to prevent stock Samsung kernel restrictions on exec system calls for binaries started from /data
- [Daemon] Workaround on Samsung device with weird fork behaviors

### v13.3 (2017.7.18)

- [MagiskHide] Update to bypass Google CTS (2017.7.17)
- [resetprop] Properly support removing persist props
- [uninstaller] Remove Magisk Manager and persist props

### v13.2 (2017.7.14)

- [magiskpolicy] Fix magiskpolicy segfault on old Android versions, should fix tons of older devices that couldn't use v13.1
- [MagiskHide] Set proper selinux context while re-linking /sbin to hide Magisk, should potentially fix many issues
- [MagiskBoot] Change lzma compression encoder flag from `LZMA_CHECK_CRC64` to `LZMA_CHECK_CRC32`, kernel only supports latter
- [General] Core-only mode now properly mounts systemless hosts and magiskhide

### v13.1 (2017.7.11)

- [General] Merge MagiskSU, magiskhide, resetprop, magiskpolicy into one binary
- [General] Add Android O support (tested on DP3)
- [General] Dynamic link libselinux.so, libsqlite.so from system to greatly reduce binary size
- [General] Remove bundled busybox because it causes a lot of issues
- [General] Unlock all block devices for read-write support instead of emmc only (just figured not all devices uses emmc lol)
- [Scripts] Run all ext4 image operations through magisk binary in flash scripts
- [Scripts] Updated scripts to use magisk native commands to increase compatibility
- [Scripts] Add addon.d survival support
- [Scripts] Introduce `util_functions.sh`, used as a global shell script function source for all kinds of installation
- [MagiskBoot] Moved boot patch logic into magiskboot binary
- [MagiskSU] Does not fork new process for each request, add new threads instead
- [MagiskSU] Added multiuser support
- [MagiskSU] Introduce new timeout queue mechanism, prevent performance hit with poorly written su apps
- [MagiskSU] Multiple settings moved from prop detection to database
- [MagiskSU] Add namespace mode option support
- [MagiskSU] Add master-mount option
- [resetprop] Updated to latest AOSP upstream, support props from 5.0 to Android O
- [resetprop] Renamed all functions to prevent calling functions from external libc
- [magiskpolicy] Updated libsepol from official SELinux repo
- [magiskpolicy] Added xperm patching support (in order to make Android O work properly)
- [magiskpolicy] Updated rules for Android O, and Liveboot support
- [MagiskHide] Remove pseudo permissive mode, directly hide permissive status instead
- [MagiskHide] Remove unreliable list file monitor, change to daemon request mode
- [MagiskHide] MagiskHide is now enabled by default
- [MagiskHide] Update unmount policies, passes CTS in SafetyNet!
- [MagiskHide] Add more props for hiding
- [MagiskHide] Remove background magiskhide daemon, spawn short life process for unmounting purpose
- [Magic Mount] Ditched shell script based mounting, use proper C program to parse and mount files. Speed is SIGNIFICANTLY improved

### v12.0 (2017.3.31)

- [General] Move most binaries into magisk.img (Samsung cannot run su daemon in /data)
- [General] Move sepolicy live patch to `late_start` service
  This shall fix the long boot times, especially on Samsung devices
- [General] Add Samsung RKP hexpatch back, should now work on Samsung stock kernels
- [General] Fix installation with SuperSU
- [MagiskHide] Support other logcat `am_proc_start` patterns
- [MagiskHide] Change /sys/fs/selinux/enforce(policy) permissions if required
  Samsung devices cannot switch selinux states, if running on permissive custom kernel, the users will stuck at permissive
  If this scenario is detected, change permissions to hide the permissive state, leads to SafetyNet passes
- [MagiskHide] Add built in prop rules to fake KNOX status
  Samsung apps requiring KNOX status to be 0x0 should now work (Samsung Pay not tested)
- [MagiskHide] Remove all ro.build props, since they cause more issues than they benefit...
- [MagiskBoot] Add lz4 legacy format support (most linux kernel using lz4 for compression is using this)
- [MagiskBoot] Fix MTK kernels with MTK headers

### v11.5/11.6 (2017.3.21)

- [Magic Mount] Fix mounting issues with devices that have separate /vendor partitions
- [MagiskBoot] Whole new boot image patching tool, please check release note for more info
- [magiskpolicy] Rename sepolicy-inject to magiskpolicy
- [magiskpolicy] Update a rule to allow chcon everything properly
- [MagiskHide] Prevent multirom crashes
- [MagiskHide] Add patches for ro.debuggable, ro.secure, ro.build.type, ro.build.tags, ro.build.selinux
- [MagiskHide] Change /sys/fs/selinux/enforce, /sys/fs/selinux/policy permissions for Samsung compatibility
- [MagiskSU] Fix read-only partition mounting issues
- [MagiskSU] Disable -cn option, the option will do nothing, preserved for compatibility

### v11.1 (2017.2.6)

- [sepolicy-inject] Add missing messages
- [magiskhide] Start MagiskHide with scripts

### v11.0 (2017.2.6)

- [Magic Mount] Support replacing symlinks.
  Symlinks cannot be a target of a bind mounted, so they are treated the same as new files
- [Magic Mount] Fix the issue when file/folder name contains spaces
- [BusyBox] Updated to v1.26.2. Should fix the black screen issues of FlashFire
- [resetprop] Support reading prop files that contains spaces in prop values
- [MagiskSU] Adapt communication to Magisk Manager; stripped out unused data transfer
- [MagiskSU] Implement SuperUser access option (Disable, APP only, ADB Only, APP & ADB)
  phh Superuser app has this option but the feature isn't implemented within the su binary
- [MagiskSU] Fixed all issues with su -c "commands" (run commands with root)
  This feature is supposed to only allow one single option, but apparently adb shell su -c "command" doesn't work this way, and plenty of root apps don't follow the rule. The su binary will now consider everything after -c as a part of the command.
- [MagiskSU] Removed legacy context hack for TiBack, what it currently does is slowing down the invocation
- [MagiskSU] Preserve the current working directory after invoking su
  Previously phh superuser will change the path to /data/data after obtaining root shell. It will now stay in the same directory where you called su
- [MagiskSU] Daemon now also runs in u:r:su:s0 context
- [MagiskSU] Removed an unnecessary fork, reduce running processes and speed up the invocation
- [MagiskSU] Add -cn option to the binary
  Not sure if this is still relevant, and also not sure if implemented correctly, but hey it's here
- [sepolicy-inject] Complete re-write the command-line options, now nearly matches supolicy syntax
- [sepolicy-inject] Support all matching mode for nearly every action (makes pseudo enforced possible)
- [sepolicy-inject] Fixed an ancient bug that allocated memory isn't reset
- [uninstaller] Now works as a independent script that can be executed at boot
  Fully support recovery with no /data access, Magisk uninstallation with Magisk Manager
- [Addition] Busybox, MagiskHide, hosts settings can now be applied instantly; no reboots required
- [Addition] Add post-fs-data.d and service.d
- [Addition] Add option to disable Magisk (MagiskSU will still be started)

### v10.2 (2017.1.2)

- [Magic Mount] Remove apps/priv-app from whitelist, should fix all crashes
- [phh] Fix binary out-of-date issue
- [scripts] Fix root disappear issue when upgrading within Magisk Manager

### v10 (2017.1.2)

- [Magic Mount] Use a new way to mount system (vendor) mirrors
- [Magic Mount] Use universal way to deal with /vendor, handle both separate partition or not
- [Magic Mount] Adding **anything to any place** is now officially supported (including /system root and /vendor root)
- [Magic Mount] Use symlinks for mirroring back if possible, reduce bind mounts for adding files
- [Magisk Hide] Check init namespace, zygote namespace to prevent Magic Mount breakage (a.k.a root loss)
- [Magisk Hide] Send SIGSTOP to pause target process ASAP to prevent crashing if unmounting too late
- [Magisk Hide] Hiding should work under any conditions, including adding libs and /system root etc.
- [phh] Root the device if no proper root detected
- [phh] Move `/sbin` to `/sbin_orig` and link back, fix Samsung no-suid issue
- [scripts] Improve SuperSU integration, now uses sukernel to patch ramdisk, support SuperSU built in ramdisk restore
- [template] Add PROPFILE option to load system.prop

### v9 (2016.11.14)

- **[API Change] Remove the interface for post-fs modules**
- [resetprop] New tool "resetprop" is added to Magisk to replace most post-fs modules' functionality
- [resetprop] Magisk will now patch "ro.boot.verifiedbootstate", "ro.boot.flash.locked", "ro.boot.veritymode" to bypass Safety Net
- [Magic Mount] Move dummy skeleton / mirror / mountinfo filesystem tree to tmpfs
- [Magic Mount] Rewritten dummy cloning mechanism from scratch, will result in minimal bind mounts, minimal file traversal, eliminate all possible issues that might happen in extreme cases
- [Magic Mount] Adding new items to /system/bin, /system/vendor, /system/lib(64) is properly supported (devices with separate vendor partition is not supported yet)
- [Magisk Hide] Rewritten from scratch, now run in daemon mode, proper list monitoring, proper mount detection, and maybe more.....
- [Boot Image] Add support for Motorola boot image dtb, it shall now unpack correctly
- [Uninstaller] Add removal of SuperSU custom patch script

### v8 (2016.10.19)

- Add Magisk Hide to bypass SafetyNet
- Improve SuperSU integration: no longer changes the SuperSU PATH
- Support rc script entry points not located in init.rc

### v7 (2016.10.04)

- Fully open source
- Remove supolicy dependency, use my own sepolicy-injection
- Run everything in its own selinux domain, should fix all selinux issues
- Add Note 7 stock kernel hex patches
- Add support to install Magisk in Magisk Manager
- Add support for image merging for module flashing in Magisk Manager
- Add root helpers for SuperSU auto module-ize and auto upgrading legacy phh superuser
- New paths to toggle busybox, and support all root solutions
- Remove root management API; both SuperSU and phh has their own superior solutions

### [v6 (2016.8.21)](https://xdaforums.com/t/magisk-general-support-discussion.3432382/post-68298121)

- Fixed the algorithm for adding new files and dummy system
- Updated the module template with a default permission, since people tend to forget them :)

### [v5 (2016.8.20)](https://xdaforums.com/t/magisk-general-support-discussion.3432382/post-68274534)

- Hotfix for older Android versions (detect policy before patching)
- Update uninstaller to NOT uninstall Magisk Manager, since it cause problems

### [v4 (2016.8.19)](https://xdaforums.com/t/magisk-general-support-discussion.3432382/post-68269300)

- Important: Uninstall v1 - v3 Magisk before upgrading with the uninstaller in the OP!!
- Massive Rewrite Magisk Interface API! All previous mods are NOT compatible! Please download the latest version of the mods you use (root/xposed)
- Mods are now installed independently in their own subfolder. This paves the way for future Magisk Manager versions to manage mods, **just like how Xposed Modules are handled**
- Support small boot partition devices (Huawei devices)
- Use minimal sepolicy patch in boot image for smaller ramdisk size. Live patch policies after bootup
- Include updated open source sepolicy injection tool (source code available), support nearly all SuperSU supolicy tool's functionality

### [v3 (2016.8.11)](https://xdaforums.com/t/magisk-general-support-discussion.3432382/post-68146978)

- Fix bootimg-extract for Exynos Samsung devices (thanks to @phhusson), should fix all Samsung device issues
- Add supolicy back to patch sepolicy (stock Samsung do not accept permissive domain)
- Update sepolicy-injection to patch su domain for Samsung devices to use phh's root
- Update root disable method, using more aggressive approach
- Use lazy unmount to unmount root from system, should fix some issues with custom roms
- Use the highest possible compression rate for ramdisk, hope to fix some devices with no boot partition space
- Detect boot partition space insufficient, will abort installer instead of breaking your device

### [v2 (2016.8.9)](https://xdaforums.com/t/magisk-general-support-discussion.3432382/post-68108058)

- Fix verity patch. It should now work on all devices (might fix some of the unable-to-boot issues)
- All scripts will now run in selinux permissive mode for maximum compatibility (this will **NOT** turn your device to permissive)
- Add Nougat Developer Preview 5 support
- Add systemless host support for AdBlock Apps (enabled by default)
- Add support for new root disable method
- Remove sepolicy patches that uses SuperSU's supolicy tool; it is now using a minimal set of modifications
- Removed Magisk Manager in Magisk patch, it is now included in Magisk phh's superuser only

### [v1 (2016.8.3)](https://xdaforums.com/t/magisk-general-support-discussion.3432382/post-68034103)

- Initial release

```

`docs/details.md`:

```md
# Internal Details

## File Structure

### Paths in "Magisk tmpfs directory"

Magisk will mount a `tmpfs` directory to store some temporary data. For devices with the `/sbin` folder, it will be chosen as it will also act as an overlay to inject binaries into `PATH`. From Android 11 onwards, the `/sbin` folder might not exist, so Magisk will use `/debug_ramdisk` as the base folder.

```
# In order to get the current base folder Magisk is using,
# use the command `magisk --path`.
# Binaries like magisk, magiskinit, and all symlinks to
# applets are directly stored in this path. This means when
# this is /sbin, these binaries will be directly in PATH.
MAGISKTMP=$(magisk --path)

# Magisk internal stuffs
INTERNALDIR=$MAGISKTMP/.magisk

# /data/adb/modules will be bind mounted here.
# The original folder is not used due to nosuid mount flag.
$INTERNALDIR/modules

# The current Magisk installation config
$INTERNALDIR/config

# Partition mirrors
# Each directory in this path will be mounted with the
# partition of its directory name.
# e.g. system, system_ext, vendor, data ...
$INTERNALDIR/mirror

# Root directory patch files
# On system-as-root devices, / is not writable.
# All pre-init patched files are stored here and bind mounted.
$INTERNALDIR/rootdir
```

### Paths in `/data`

Some binaries and files should be stored on non-volatile storages in `/data`. In order to prevent detection, everything has to be stored somewhere safe and undetectable in `/data`. The folder `/data/adb` was chosen because of the following advantages:

- It is an existing folder on modern Android, so it cannot be used as an indication of the existence of Magisk.
- The permission of the folder is by default `700`, owner as `root`, so non-root processes are unable to enter, read, write the folder in any possible way.
- The folder is labeled with secontext `u:object_r:adb_data_file:s0`, and very few processes have the permission to do any interaction with that secontext.
- The folder is located in _Device encrypted storage_, so it is accessible as soon as data is properly mounted in FBE (File-Based Encryption) devices.

```
SECURE_DIR=/data/adb

# Folder storing general post-fs-data scripts
$SECURE_DIR/post-fs-data.d

# Folder storing general late_start service scripts
$SECURE_DIR/service.d

# Magisk modules
$SECURE_DIR/modules

# Magisk modules that are pending for upgrade
# Module files are not safe to be modified when mounted
# Modules installed through the Magisk app will be stored here
# and will be merged into $SECURE_DIR/modules in the next reboot
$SECURE_DIR/modules_update

# Database storing settings and root permissions
MAGISKDB=$SECURE_DIR/magisk.db

# All magisk related binaries, including busybox,
# scripts, and magisk binaries. Used in supporting
# module installation, addon.d, the Magisk app etc.
DATABIN=$SECURE_DIR/magisk

```

## Magisk Booting Process

### Pre-Init

`magiskinit` will replace `init` as the first program to run.

- Early mount required partitions. On legacy system-as-root devices, we switch root to system; on 2SI devices, we patch the original `init` to redirect the 2nd stage init file to magiskinit and execute it to mount partitions for us.
- Inject magisk services into `init.rc`
- On devices using monolithic policy, load sepolicy from `/sepolicy`; otherwise we hijack nodes in selinuxfs with FIFO, set `LD_PRELOAD` to hook `security_load_policy` and assist hijacking on 2SI devices, and start a daemon to wait until init tries to load sepolicy.
- Patch sepolicy rules. If we are using "hijack" method, load patched sepolicy into kernel, unblock init and exit daemon
- Execute the original `init` to continue the boot process

### post-fs-data

This triggers on `post-fs-data` when `/data` is decrypted and mounted. The daemon `magiskd` will be launched, post-fs-data scripts are executed, and module files are magic mounted.

### late_start

Later in the booting process, the class `late_start` will be triggered, and Magisk "service" mode will be started. In this mode, service scripts are executed.

## Resetprop

Usually, system properties are designed to only be updated by `init` and read-only to non-root processes. With root you can change properties by sending requests to `property_service` (hosted by `init`) using commands such as `setprop`, but changing read-only props (props that start with `ro.` like `ro.build.product`) and deleting properties are still prohibited.

`resetprop` is implemented by distilling out the source code related to system properties from AOSP and patched to allow direct modification to property area, or `prop_area`, bypassing the need to go through `property_service`. Since we are bypassing `property_service`, there are a few caveats:

- `on property:foo=bar` actions registered in `*.rc` scripts will not be triggered if property changes does not go through `property_service`. The default set property behavior of `resetprop` matches `setprop`, which **WILL** trigger events (implemented by first deleting the property then set it via `property_service`). There is a flag `-n` to disable it if you need this special behavior.
- persist properties (props that starts with `persist.`, like `persist.sys.usb.config`) are stored in both `prop_area` and `/data/property`. By default, deleting props will **NOT** remove it from persistent storage, meaning the property will be restored after the next reboot; reading props will **NOT** read from persistent storage, as this is the behavior of `getprop`. With the flag `-p`, deleting props will remove the prop in **BOTH** `prop_area` and `/data/property`, and reading props will be read from **BOTH** `prop_area` and persistent storage.

## SELinux Policies

Magisk will patch the stock `sepolicy` to make sure root and Magisk operations can be done in a safe and secure way. The new domain `magisk` is effectively permissive, which is what `magiskd` and all root shell will run in. `magisk_file` is a new file type that is setup to be allowed to be accessed by every domain (unrestricted file context).

Before Android 8.0, all allowed su client domains are allowed to directly connect to `magiskd` and establish connection with the daemon to get a remote root shell. Magisk also have to relax some `ioctl` operations so root shells can function properly.

After Android 8.0, to reduce relaxation of rules in Android's sandbox, a new SELinux model is deployed. The `magisk` binary is labelled with `magisk_exec` file type, and processes running as allowed su client domains executing the `magisk` binary (this includes the `su` command) will transit to `magisk_client` by using a `type_transition` rule. Rules strictly restrict that only `magisk` domain processes are allowed to attribute files to `magisk_exec`. Direct connection to sockets of `magiskd` are not allowed; the only way to access the daemon is through a `magisk_client` process. These changes allow us to keep the sandbox intact, and keep Magisk specific rules separated from the rest of the policies.

The full set of rules can be found in `sepolicy/rules.cpp`.

```

`docs/faq.md`:

```md
# Frequently Asked Questions

### Q: I installed a module and it bootlooped my device. Help!

If you have USB debugging enabled in developer options, connect your phone to the PC. If your device is detected (check by `adb devices`), enter ADB shell and run the command `magisk --remove-modules`. This will remove all your modules and automatically reboot the device.

If unfortunately you do not have USB debugging enabled you can boot using the Safe Mode key combo to cause Magisk to create an empty file named 'disable' in modules directories which disables modules when next booted with Magisk. Most modern Android devices support such a special key combo at boot to enter system Safe Mode as an emergency option, but **please note** that Magisk's key combo detection occurs _earlier_ than system detection so the key combo timing indicated by many online guides may need to be altered to activate Magisk's Safe Mode. (It's possible to activate system Safe Mode but not Magisk Safe Mode and vice versa.)

The following details should ensure that modules are properly disabled:

1. Many online guides for entering Safe Mode say 'When the animated logo appears, press and hold the volume down button until the system boots' or similar. This may actually be _too late_ for Magisk detection however and result in activating system Safe Mode but modules are not disabled.
2. By pressing the volume down button some seconds before the animation and releasing it as soon as the boot animation appears, Magisk's Safe Mode should be activated without activating system Safe Mode (thus avoiding disabling other device and app settings) and the device should then simply boot to normal system with modules disabled.
3. By pressing the volume down button some seconds before the animation and holding it until the system boots, both Magisk's Safe Mode and system Safe Mode should be activated. Next, after booting back to normal system, modules will be disabled.

### Q: Why is X app detecting root?

Magisk no longer handles root hiding. There are plenty of Magisk/Zygisk modules available that specifically provide these functionalities, please search around 😉

### Q: Magisk App shows Magisk Installed = N/A after an update but magisk su is still working.

If upgrading with App hidden (ie. you took the 'Hide the Magisk app' option), the stub app (for hiding Magisk) may remain while a full Magisk app is also installed. This creates a conflict and the full app fails to see or access root... Uninstalling and reinstalling the full app can fix this, but not if a hidden app (stub) still exists.

The solution is to check for a hidden stub app and remove it. It may not show up normally in your launcher homescreen any longer, but should be visible from general settings, Apps. The hidden app will be named 'Settings' (default) or whatever you named it during the hiding process. Note that it is possible to have multiple obfuscated apps present. Uninstall any iterations of the hidden app you find and try opening the full app again. If necessary, uninstall it and reinstall the full app matching the binaries installed. Typing magisk -c in a terminal emulator app will show the version and version code for Magisk binaries installed (despite Installed = N/A showing).

Additionally, if a 'second space', eg. Workspace, Parallel Space etc, or another sandboxed environment, eg. a Multiple User additional profile, Island app or similar, is set up, check that no iterations of Magisk (either hidden or full apps) are running within these environments.

### Q: After I take the 'Hide the Magisk app' option the app icon is broken.

When hiding the Magisk app, it will install a "stub" APK that has nothing in it. The only functionality this stub app has is to download the full Magisk app APK data into its internal storage and dynamically load it. Due to the fact that the stub APK is literally empty, it does not contain the image resource for the app icon.

When you open the hidden Magisk app, it will offer you the option to create a shortcut in the homescreen (which has both the correct app name and icon) for your convenience. You can also manually ask the app to create the icon in app settings.

### Q: How to use Magisk in the emulator?

With the emulator running and accessible via ADB, run `./build.py emulator <path to Magisk APK>` to temporarily install Magisk on to the emulator. The patch is not persistent, meaning Magisk will be lost after a reboot, so re-execute the script to emulate a reboot if required.

The script is only tested on the official Android Virtual Device (AVD) shipped alongside Android Studio; other emulators may work, but the emulator must have SELinux enabled.

```

`docs/guides.md`:

```md
# Developer Guides

## BusyBox

Magisk ships with a feature complete BusyBox binary (including full SELinux support). The executable is located at `/data/adb/magisk/busybox`. Magisk's BusyBox supports runtime toggle-able "ASH Standalone Shell Mode". What this standalone mode means is that when running in the `ash` shell of BusyBox, every single command will directly use the applet within BusyBox, regardless of what is set as `PATH`. For example, commands like `ls`, `rm`, `chmod` will **NOT** use what is in `PATH` (in the case of Android by default it will be `/system/bin/ls`, `/system/bin/rm`, and `/system/bin/chmod` respectively), but will instead directly call internal BusyBox applets. This makes sure that scripts always run in a predictable environment and always have the full suite of commands no matter which Android version it is running on. To force a command _not_ to use BusyBox, you have to call the executable with full paths.

Every single shell script running in the context of Magisk will be executed in BusyBox's `ash` shell with standalone mode enabled. For what is relevant to 3rd party developers, this includes all boot scripts and module installation scripts.

For those who want to use this "Standalone Mode" feature outside of Magisk, there are 2 ways to enable it:

1. Set environment variable `ASH_STANDALONE` to `1`<br>Example: `ASH_STANDALONE=1 /data/adb/magisk/busybox sh <script>`
2. Toggle with command-line options:<br>`/data/adb/magisk/busybox sh -o standalone <script>`

To make sure all subsequent `sh` shell executed also runs in standalone mode, option 1 is the preferred method (and this is what Magisk and the Magisk app internally use) as environment variables are inherited down to child processes.

## Magisk Modules

A Magisk module is a folder placed in `/data/adb/modules` with the structure below:

```
/data/adb/modules
├── .
├── .
|
├── $MODID                  <--- The folder is named with the ID of the module
│   │
│   │      *** Module Identity ***
│   │
│   ├── module.prop         <--- This file stores the metadata of the module
│   │
│   │      *** Main Contents ***
│   │
│   ├── system              <--- This folder will be mounted if skip_mount does not exist
│   │   ├── ...
│   │   ├── ...
│   │   └── ...
│   │
│   ├── zygisk              <--- This folder contains the module's Zygisk native libraries
│   │   ├── arm64-v8a.so
│   │   ├── armeabi-v7a.so
│   │   ├── riscv64.so
│   │   ├── x86.so
│   │   ├── x86_64.so
│   │   └── unloaded        <--- If exists, the native libraries are incompatible
│   │
│   │      *** Status Flags ***
│   │
│   ├── skip_mount          <--- If exists, Magisk will NOT mount your system folder
│   ├── disable             <--- If exists, the module will be disabled
│   ├── remove              <--- If exists, the module will be removed next reboot
│   │
│   │      *** Optional Files ***
│   │
│   ├── post-fs-data.sh     <--- This script will be executed in post-fs-data
│   ├── service.sh          <--- This script will be executed in late_start service
|   ├── uninstall.sh        <--- This script will be executed when Magisk removes your module
|   ├── action.sh           <--- This script will be executed when user click the action button in Magisk app
│   ├── system.prop         <--- Properties in this file will be loaded as system properties by resetprop
│   ├── sepolicy.rule       <--- Additional custom sepolicy rules
│   │
│   │      *** Auto Generated, DO NOT MANUALLY CREATE OR MODIFY ***
│   │
│   ├── vendor              <--- A symlink to $MODID/system/vendor
│   ├── product             <--- A symlink to $MODID/system/product
│   ├── system_ext          <--- A symlink to $MODID/system/system_ext
│   │
│   │      *** Any additional files / folders are allowed ***
│   │
│   ├── ...
│   └── ...
|
├── another_module
│   ├── .
│   └── .
├── .
├── .
```

#### module.prop

This is the **strict** format of `module.prop`

```
id=<string>
name=<string>
version=<string>
versionCode=<int>
author=<string>
description=<string>
updateJson=<url> (optional)
```

- `id` has to match this regular expression: `^[a-zA-Z][a-zA-Z0-9._-]+$`<br>
  ex: ✓ `a_module`, ✓ `a.module`, ✓ `module-101`, ✗ `a module`, ✗ `1_module`, ✗ `-a-module`<br>
  This is the **unique identifier** of your module. You should not change it once published.
- `versionCode` has to be an **integer**. This is used to compare versions
- `updateJson` should point to a URL that downloads a JSON to provide info so the Magisk app can update the module.
- Others that weren't mentioned above can be any **single line** string.
- Make sure to use the `UNIX (LF)` line break type and not the `Windows (CR+LF)` or `Macintosh (CR)`.

Update JSON format:

```
{
    "version": string,
    "versionCode": int,
    "zipUrl": url,
    "changelog": url
}
```

#### Shell scripts (`*.sh`)

Please read the [Boot Scripts](#boot-scripts) section to understand the difference between `post-fs-data.sh` and `service.sh`. For most module developers, `service.sh` should be good enough if you just need to run a boot script. If you need to wait for boot completed, you can use `resetprop -w sys.boot_completed 0`.

In all scripts of your module, please use `MODDIR=${0%/*}` to get your module's base directory path; do **NOT** hardcode your module path in scripts.
If Zygisk is enabled, the environment variable `ZYGISK_ENABLED` will be set to `1`.

#### The `system` folder

All files you want to replace/inject should be placed in this folder. This folder will be recursively merged into the real `/system`; that is: existing files in the real `/system` will be replaced by the one in the module's `system`, and new files in the module's `system` will be added to the real `/system`.

If you place a file named `.replace` in any of the folders, instead of merging its contents, that folder will directly replace the one in the real system. This can be very handy for swapping out an entire folder.

If you want to replace files in `/vendor`, `/product`, or `/system_ext`, please place them under `system/vendor`, `system/product`, and `system/system_ext` respectively. Magisk will transparently handle whether these partitions are in a separate partition or not.

If you want to remove a specific file or folder, please place a dummy character device with major number 0 and minor number 0 in the same path. For example, if you want to remove `/system/app/GoogleCamera`, you can `mknod GoogleCamera c 0 0` in `$MODDIR/system/app`.

#### Zygisk

Zygisk is a feature of Magisk that allows advanced module developers to run code directly in every Android applications' processes before they are specialized and running. For more details about the Zygisk API and building a Zygisk module, please checkout the [Zygisk Module Sample](https://github.com/topjohnwu/zygisk-module-sample) project.

#### system.prop

This file follows the same format as `build.prop`. Each line comprises of `[key]=[value]`.

#### sepolicy.rule

If your module requires some additional sepolicy patches, please add those rules into this file. Each line in this file will be treated as a policy statement. For more details about how a policy statement is formatted, please check [magiskpolicy](tools.md#magiskpolicy)'s documentation.

## Magisk Module Installer

A Magisk module installer is a Magisk module packaged in a zip file that can be flashed in the Magisk app or custom recoveries such as TWRP. The simplest Magisk module installer is just a Magisk module packed as a zip file, in addition to the following files only if the module supports flashing in recovery:

- `update-binary`: Download the latest [module_installer.sh](https://github.com/topjohnwu/Magisk/blob/master/scripts/module_installer.sh) and rename/copy that script as `update-binary`
- `updater-script`: This file should only contain the string `#MAGISK`

The module installer script will setup the environment, extract the module files from the zip file to the correct location, then finalizes the installation process, which should be good enough for most simple Magisk modules.

```
module.zip
│
├── META-INF                           <--- Only needed for flashing in recovery
│   └── com
│       └── google
│           └── android
│               ├── update-binary      <--- The module_installer.sh you downloaded
│               └── updater-script     <--- Should only contain the string "#MAGISK"
│
├── customize.sh                       <--- (Optional, more details later)
│                                           This script will be sourced by update-binary
├── ...
├── ...  /* The rest of module's files */
│
```

#### Customization

If you need to customize the module installation process, optionally you can create a script in the installer named `customize.sh`. This script will be _sourced_ (not executed!) by the module installer script after all files are extracted and default permissions and secontext are applied. This is very useful if your module require additional setup based on the device ABI, or you need to set special permissions/secontext for some of your module files.

If you would like to fully control and customize the installation process, declare `SKIPUNZIP=1` in `customize.sh` to skip all default installation steps. By doing so, your `customize.sh` will be responsible to install everything by itself.

The `customize.sh` script runs in Magisk's BusyBox `ash` shell with "Standalone Mode" enabled. The following variables and functions are available:

##### Variables

- `MAGISK_VER` (string): the version string of current installed Magisk (e.g. `v20.0`)
- `MAGISK_VER_CODE` (int): the version code of current installed Magisk (e.g. `20000`)
- `BOOTMODE` (bool): `true` if the module is being installed in the Magisk app
- `MODPATH` (path): the path where your module files should be installed
- `TMPDIR` (path): a place where you can temporarily store files
- `ZIPFILE` (path): your module's installation zip
- `ARCH` (string): the CPU architecture of the device. Value is either `arm`, `arm64`, `x86`, `x64`, or `riscv64`
- `IS64BIT` (bool): `true` if `$ARCH` is either `arm64`, `x64`, or `riscv64`
- `API` (int): the API level (Android version) of the device (e.g. `23` for Android 6.0)

##### Functions

```
ui_print <msg>
    Print <msg> to console
    Avoid using 'echo' as it will not display in custom recovery's console

abort <msg>
    Print error message <msg> to console and terminate the installation
    Avoid using 'exit' as it will skip the termination cleanup steps

set_perm <target> <owner> <group> <permission> [context]
    If [context] is not specified, the default is "u:object_r:system_file:s0"
    This function is a shorthand for the following commands:
       chown owner.group target
       chmod permission target
       chcon context target

set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]
    If [context] is not specified, the default is "u:object_r:system_file:s0"
    This function is a shorthand for the following psuedo code:
      set_perm <directory> owner group dirpermission context
      for file in <directory>:
        set_perm file owner group filepermission context
      for dir in <directory>:
        set_perm_recursive dir owner group dirpermission context
```

For convenience, you can also declare a list of folders you want to replace in the variable name `REPLACE`. The module installer script will create the `.replace` file into the folders listed in `REPLACE`. For example:

```sh
REPLACE="
/system/app/YouTube
/system/app/Bloatware
"
```

The list above will result in the following files being created: `$MODPATH/system/app/YouTube/.replace` and `$MODPATH/system/app/Bloatware/.replace`.

For convenience, you can also declare a list of files/folders you want to remove in the variable name `REMOVE`. The module installer script will create the corresponding dummy devices. For example:

```sh
REMOVE="
/system/app/YouTube
/system/fonts/Roboto.ttf
"
```

The list above will result in the following dummy devices being created: `$MODPATH/system/app/YouTube` and `$MODPATH/system/fonts/Roboto.ttf`.

#### Notes

- When your module is downloaded with the Magisk app, `update-binary` will be **forcefully** replaced with the latest [`module_installer.sh`](https://github.com/topjohnwu/Magisk/blob/master/scripts/module_installer.sh). **DO NOT** try to add any custom logic in `update-binary`.
- Due to historical reasons, **DO NOT** add a file named `install.sh` in your module installer zip.
- **DO NOT** call `exit` at the end of `customize.sh`. The module installer script has to perform some cleanups before exiting.

## Boot Scripts

In Magisk, you can run boot scripts in 2 different modes: **post-fs-data** and **late_start service** mode.

- post-fs-data mode
  - This stage is BLOCKING. The boot process is paused before execution is done, or 40 seconds have passed.
  - Scripts run before any modules are mounted. This allows a module developer to dynamically adjust their modules before it gets mounted.
  - This stage happens before Zygote is started, which pretty much means everything in Android
  - **WARNING:** using `setprop` will deadlock the boot process! Please use `resetprop -n <prop_name> <prop_value>` instead.
  - **Only run scripts in this mode if necessary.**
- late_start service mode
  - This stage is NON-BLOCKING. Your script runs in parallel with the rest of the booting process.
  - **This is the recommended stage to run most scripts.**

In Magisk, there are also 2 kinds of scripts: **general scripts** and **module scripts**.

- General Scripts
  - Placed in `/data/adb/post-fs-data.d` or `/data/adb/service.d`
  - Only executed if the script is set as executable (`chmod +x script.sh`)
  - Scripts in `post-fs-data.d` runs in post-fs-data mode, and scripts in `service.d` runs in late_start service mode.
  - Modules should **NOT** add general scripts during installation
- Module Scripts
  - Placed in the module's own folder
  - Only executed if the module is enabled
  - `post-fs-data.sh` runs in post-fs-data mode, and `service.sh` runs in late_start service mode.

All boot scripts will run in Magisk's BusyBox `ash` shell with "Standalone Mode" enabled.

## Root Directory Overlay System

Since `/` is read-only on system-as-root devices, Magisk provides an overlay system to enable developers to replace files in rootdir or add new `*.rc` scripts. This feature is designed mostly for custom kernel developers.

Overlay files shall be placed in the `overlay.d` folder in boot image ramdisk, and they follow these rules:

1. Each `*.rc` file (except for `init.rc`) in `overlay.d` will be read and concatenated **AFTER** `init.rc` if it does not exist in the root directory, otherwise it will **REPLACE** the existing one.
2. Existing files can be replaced by files located at the same relative path
3. Files that correspond to a non-existing file will be ignored

To add additional files which you can refer to in your custom `*.rc` scripts, add them into `overlay.d/sbin`. The 3 rules above do not apply to anything in this folder; instead, they will be directly copied to Magisk's internal `tmpfs` directory (which used to always be `/sbin`).

Starting from Android 11, the `/sbin` folder may no longer exists, and in that scenario, Magisk uses `/debug_ramdisk` instead. Every occurrence of the pattern `${MAGISKTMP}` in your `*.rc` scripts will be replaced with the Magisk `tmpfs` folder when `magiskinit` injects it into `init.rc`. On pre Android 11 devices, `${MAGISKTMP}` will simply be replaced with `/sbin`, so **NEVER** hardcode `/sbin` in the `*.rc` scripts when referencing these additional files.

Here is an example of how to setup `overlay.d` with a custom `*.rc` script:

```
ramdisk
│
├── overlay.d
│   ├── sbin
│   │   ├── libfoo.ko      <--- These 2 files will be copied
│   │   └── myscript.sh    <--- into Magisk's tmpfs directory
│   ├── custom.rc          <--- This file will be injected into init.rc
│   ├── res
│   │   └── random.png     <--- This file will replace /res/random.png
│   └── new_file           <--- This file will be ignored because
│                               /new_file does not exist
├── res
│   └── random.png         <--- This file will be replaced by
│                               /overlay.d/res/random.png
├── ...
├── ...  /* The rest of initramfs files */
│
```

Here is an example of the `custom.rc`:

```
# Use ${MAGISKTMP} to refer to Magisk's tmpfs directory

on early-init
    setprop sys.example.foo bar
    insmod ${MAGISKTMP}/libfoo.ko
    start myservice

service myservice ${MAGISKTMP}/myscript.sh
    oneshot
```

```

`docs/install.md`:

```md
# Installation

If you already have Magisk installed, it is **strongly recommended** to upgrade directly via the Magisk app using its "Direct Install" method. The following tutorial is only for the initial installation.

## Getting Started

Before you start:

- This tutorial assumes you understand how to use `adb` and `fastboot`
- If you plan to also install custom kernels, install it after Magisk
- Your device's bootloader has to be unlocked

---

Download and install the latest [Magisk app](https://github.com/topjohnwu/Magisk/releases/latest). In the home screen, you should see:

<p align="center"><img src="images/device_info.png" width="500"/></p>

The result of **Ramdisk** determines whether your device has ramdisk in the boot partition. If your device does not have boot ramdisk, read the [Magisk in Recovery](#magisk-in-recovery) section before continuing.

> _(Unfortunately, there are exceptions as some devices' bootloader accepts ramdisk even if it shouldn't. In this case, you will have to follow the instructions as if your device's boot partition **does** include ramdisk. There is no way to detect this, so the only way to know for sure is to actually try. Fortunately, as far as we know, only some Xiaomi devices are known to have this property, so most people can simply ignore this piece of information.)_

If you are using a Samsung device, you can now jump to [its own section](#samsung-devices).

If your device has boot ramdisk, get a copy of the `boot.img` (or `init_boot.img` if exists).<br>
If your device does **NOT** have boot ramdisk, get a copy of the `recovery.img`.<br>
You should be able to extract the file you need from official firmware packages or your custom ROM zip.

Quick recap, at this point, you should have known and prepared:

1. Whether your device has boot ramdisk
2. A `boot.img`, `init_boot.img` or `recovery.img` based on (1)

Let's continue to [Patching Images](#patching-images).

## Patching Images

- Copy the boot/init_boot/recovery image to your device
- Press the **Install** button in the Magisk card
- If you are patching a recovery image, check the **"Recovery Mode"** option
- Choose **"Select and Patch a File"** in method, and select the boot/init_boot/recovery image
- Start the installation, and copy the patched image to your PC using ADB:<br>
  `adb pull /sdcard/Download/magisk_patched_[random_strings].img`
- Flash the patched boot/init_boot/recovery image to your device;<br>
  for most devices, reboot into fastboot mode and flash with command:<br>
  `fastboot flash boot /path/to/magisk_patched_[random_strings].img` or <br>
  `fastboot flash init_boot /path/to/magisk_patched_[random_strings].img` or <br>
  `fastboot flash recovery /path/to/magisk_patched_[random_strings].img` <br>
- (Optional) If your device has a separate `vbmeta` partition, you can patch the `vbmeta` partition with command:<br>
  `fastboot flash vbmeta --disable-verity --disable-verification vbmeta.img` (note that it may **wipe your data**)
- Reboot and launch Magisk app (you will see a stub Magisk app if you have wiped your data; use it to bootstrap to a complete Magisk app), and you will see a prompt asking for environment fix; click and wait for the reboot
- Voila!

> Warning: **NEVER** flash patched image shared by others or patch image on another device even if they have the same device model! You may need to do a full data wipe to recover your device. **ALWAYS** patch boot image **on the same device where you want to install Magisk**.

## Uninstallation

The easiest way to uninstall Magisk is directly through the Magisk app. If you insist on using custom recoveries, rename the Magisk APK to `uninstall.zip` and flash it like any other ordinary flashable zip.

## Magisk in Recovery

In the case when your device does not have ramdisk in boot images, Magisk has no choice but to hijack the recovery partition. For these devices, you will have to **reboot to recovery** every time you want Magisk enabled.

When Magisk hijacks the recovery, there is a special mechanism to allow you to _actually_ boot into recovery mode. Each device model has its own key combo to boot into recovery, as an example for Galaxy S10 it is (Power + Bixby + Volume Up). A quick search online should easily get you this info. As soon as you press the key combo and the device vibrates with a splash screen, release all buttons to boot into Magisk. If you decide to boot into the actual recovery mode, **long press volume up until you see the recovery screen**.

As a summary, after installing Magisk in recovery **(starting from power off)**:

- **(Power up normally) → (System with NO Magisk)**
- **(Recovery Key Combo) → (Splash screen) → (Release all buttons) → (System with Magisk)**
- **(Recovery Key Combo) → (Splash screen) → (Long press volume up) → (Recovery Mode)**

(Note: You **CANNOT** use custom recoveries to install or upgrade Magisk in this case!!)

## Samsung Devices

Before proceeding, please acknowledge that:

- Installing Magisk **WILL** trip your Knox Warranty Bit, this action is not reversible in any way.
- Installing Magisk for the first time **REQUIRES** a full data wipe (this is **NOT** counting the data wipe when unlocking bootloader). Please make a backup of your data.

### Flashing Tools

- [Samsung Odin3](https://dl2018.sammobile.com/Odin.zip) (Windows only) (requires [Samsung USB Drivers](https://developer.samsung.com/android-usb-driver))
- [Samsung Odin4](https://forum.xda-developers.com/t/official-samsung-odin-v4-1-2-1-dc05e3ea-for-linux.4453423/) (Linux only)
- [Heimdall](https://www.glassechidna.com.au/heimdall/) (or [Grimler's fork](https://git.sr.ht/~grimler/Heimdall))

### Requirements

To verify whether or not Magisk can be installed in your Samsung device, you first must check the OEM Lock and KnoxGuard (RMM) status. To do so, boot your device in Download mode with its key combo.

Possible OEM Lock values are the following:
- **ON (L)**: fully locked.
- **ON (U)**: bootloader locked, OEM unlocking enabled.
- **OFF (U)**: fully unlocked.

To unlock your bootloader, follow the instructions below. If no OEM Lock value is shown in Download mode, your device is probably not unlockable due to market limitations (USA/Canada devices).

Possible KnoxGuard values are the following:

- `Active`, `Locked`: your device has been remotely locked by your telecom operator or your insurance company.
- `Prenormal`: your device is temporarily locked, reaching 168h of uptime should trigger unlock.
- `Checking`, `Completed`, `Broken`: your device is unlocked.

Having KnoxGuard active will prevent you from installing/running Magisk regardless of your bootloader lock state.

### Unlocking the bootloader

- Allow bootloader unlocking in **Developer options → OEM unlocking**
- Reboot to download mode: power off your device and press the download mode key combo for your device
- Long press volume up to unlock the bootloader. **This will wipe your data and automatically reboot.**
- Go through the initial setup. Skip through all the steps since data will be wiped again in later steps. **Connect the device to Internet during the setup.**
- Enable developer options, and **confirm that the OEM unlocking option exists and is grayed out.** This means KnoxGuard hasn't locked your device.
- Your bootloader now accepts unofficial images in download mode

### Instructions

- Download the latest firmware package for your device, you can use one of the tools below to download it directly from Samsung servers:
  - [SamFirm.NET](https://github.com/jesec/SamFirm.NET), [samfirm.js](https://github.com/jesec/samfirm.js)
  - [Frija](https://forum.xda-developers.com/s10-plus/how-to/tool-frija-samsung-firmware-downloader-t3910594)
  - [Samloader](https://forum.xda-developers.com/s10-plus/how-to/tool-samloader-samfirm-frija-replacement-t4105929)
  - [Bifrost](https://forum.xda-developers.com/t/tool-samsung-samsung-firmware-downloader.4240719/)
- Unzip the firmware and copy the `AP` tar file to your device. It is normally named as `AP_[device_model_sw_ver].tar.md5`
- Press the **Install** button in the Magisk card
- If your device does **NOT** have boot ramdisk, check the **"Recovery Mode"** option
- Choose **"Select and Patch a File"** in method, and select the `AP` tar file
- Start the installation, and copy the patched tar file to your PC using ADB:<br>
  `adb pull /sdcard/Download/magisk_patched_[random_strings].tar`<br>
  **DO NOT USE MTP** as it is known to corrupt large files.
- Reboot to download mode. Open Odin on your PC, and flash `magisk_patched.tar` as `AP`, together with `BL`, `CP`, and `CSC` (**NOT** `HOME_CSC` because we want to **wipe data**) from the original firmware.
- Your device should reboot automatically once Odin finished flashing. **Agree to do a factory reset if asked.**
- If your device does **NOT** have boot ramdisk, reboot to recovery now to enable Magisk (reason stated in [Magisk in Recovery](#magisk-in-recovery)).
- Install the Magisk app you've already downloaded and launch the app. It should show a dialog asking for additional setup.
- Let the app do its job and automatically reboot the device. Voila!

### Upgrading the OS

Once you have rooted your Samsung device, you can no longer upgrade your Android OS through OTA. To upgrade your device's OS, you have to manually download the new firmware zip file and go through the same `AP` patching process written in the previous section. **The only difference here is in the Odin flashing step: do NOT use the `CSC` tar, but instead use the `HOME_CSC` tar as we are performing an upgrade, not the initial install**.

### Important Notes

- **Never, ever** try to restore either `boot`, `init_boot`, `recovery`, or `vbmeta` partitions back to stock! You can brick your device by doing so, and the only way to recover from this is to do a full Odin restore with data wipe.
- To upgrade your device with a new firmware, **NEVER** directly use the stock `AP` tar file with reasons mentioned above. **Always** patch `AP` in the Magisk app and use that instead.

## Custom Recovery

> **This installation method is deprecated and is maintained with minimum effort. YOU HAVE BEEN WARNED!**

Installing using custom recoveries is only possible if your device has boot ramdisk. Installing Magisk through custom recoveries on modern devices is no longer recommended. If you face any issues, please use the [Patch Image](#patching-images) method.

- Download the Magisk APK
- Rename the `.apk` file extension to `.zip`, for example: `Magisk-v24.0.apk` → `Magisk-v24.0.zip`. If you have trouble renaming the file extension (like on Windows), use a file manager on Android or the one included in the custom recovery to rename the file.
- Flash the zip just like any other ordinary flashable zip.
- Reboot and check whether the Magisk app is installed. If it isn't installed automatically, manually install the APK.
- Launch the Magisk app; it will show a dialog asking for reinstallation. Do the reinstallation **directly within the app** and reboot (if you are using MTK devices that lock the boot partition after boot, please [patch the boot image](#patching-images) and flash it by custom recovery or fastboot).

> Warning: the `sepolicy.rule` file of modules may be stored in the `cache` partition. DO NOT WIPE THE `CACHE` PARTITION.

```

`docs/ota.md`:

```md
## OTA Upgrade Guides
Magisk does not modify most read-only partitions, which means applying official OTAs is much simpler. Here are the tutorials for several different kind of devices to apply OTAs and preserve Magisk after the installation (if possible). This is just a general guide as procedures for each device may vary.

**NOTE: In order to apply OTAs, you HAVE to make sure you haven't modified and read-only partitions yourself (such as `/system` or `/vendor`) in any way. Even remounting the partition to rw will tamper block verification!!**

### Prerequisites
- Please disable *Automatic system updates* in developer options, so it won't install OTAs without your acknowledgement.

<p align="center"><img src="images/disable_auto_ota.png" width="250"/></p>

- When an OTA is available, first go to (Magisk app → Uninstall → Restore Images). **Do not reboot or you will have Magisk uninstalled.** This will restore partitions modified by Magisk back to stock from backups made at install in order to pass pre-OTA block verifications. **This step is required before doing any of the following steps written below!**

<p align="center"><img src="images/restore_img.png" width="300"/></p>

### Devices with A/B Partitions

It is possible to have the OTA installed to the inactive slot and have the Magisk app install Magisk onto the updated partitions. The out-of-the-box OTA installation works seamlessly and Magisk can be preserved after the installation.

- After restoring stock images, apply OTAs as you normally would (Settings → System → System Update).
- Wait for the installation to be fully done (both step 1: "installing update", and step 2: "optimizing your device", of the OTA), **do not press the "Restart now" or "Reboot" button!** Instead, go to (Magisk app → Install → Install to Inactive Slot) to install Magisk to the updated slot.

<p align="center"><img src="images/ota_done.png" width="250"/> <img src="images/install_inactive_slot.png" width="250"/></p>

- After installation is done, follow the final instructions at the end of the Magisk installation on how to reboot into the new slot, currently involving going back to the regular system update and hitting "restart now" (previous method of using reboot within Magisk App may not result in rebooting to new slot). Under-the-hood, the Magisk app tracks your device switch to the updated slot, bypassing any possible post-OTA verifications.

<p align="center"><img src="images/manager_reboot.png" width="250"/></p>

### "Non A/B" Devices
Unfortunately, there are no real good ways to apply OTAs on these devices. The following tutorial will not preserve Magisk; you will have to manually re-root your device after the upgrade, and this will require access to a computer. These are simply "best practices".

- To properly install OTAs, you must have your stock recovery installed on your device. If you have custom recovery installed, you can restore it from your previous backup, or dumps found online, or factory images provided by OEMs.
If you decide to start by installing Magisk without touching your recovery partition, you have a few choices, either way you will end up with a Magisk rooted device, but recovery remains stock untouched:
    - If supported, use `fastboot boot <recovery_img>` to boot the custom recovery and install Magisk.
    - If you have a copy of your stock image dump, install Magisk by using the Magisk app's "patch images" feature
- Once you restored back to stock recovery and other images, download the OTA. Optionally, once you have downloaded the OTA update zip, find a way to extract the zip (as it usually involved root)
- Apply the OTA and reboot your device. This will use the official stock OTA installation mechanism of your device to upgrade your system.
- Once it's done you will be left with an upgraded, 100% stock, un-rooted device. You will have to manually flash Magisk back. Consider using the methods stated in step 1. to flash Magisk without touching the recovery partition if you want to receive stock OTAs frequently.

```

`docs/tools.md`:

```md
# Magisk Tools

Magisk comes with a huge collections of tools for installation, daemons, and utilities for developers. This documentation covers the 4 binaries and all included applets. The binaries and applets are shown below:

```
magiskboot                 /* binary */
magiskinit                 /* binary */
magiskpolicy               /* binary */
supolicy -> magiskpolicy
magisk                     /* binary */
resetprop -> magisk
su -> magisk
```

### magiskboot

A tool to unpack / repack boot images, parse / patch / extract cpio, patch dtb, hex patch binaries, and compress / decompress files with multiple algorithms.

`magiskboot` natively supports (which means it does not rely on external tools) common compression formats including `gzip`, `lz4`, `lz4_legacy` , `lz4_lg` ([the LG edition](https://events.static.linuxfound.org/sites/events/files/lcjpcojp13_klee.pdf) of `lz4_legacy`, only used on LG), `lzma`, `xz`, and `bzip2`.

The concept of `magiskboot` is to make boot image modification simpler. For unpacking, it parses the header and extracts all sections in the image, decompressing on-the-fly if compression is detected in any sections. For repacking, the original boot image is required so the original headers can be used, changing only the necessary entries such as section sizes and checksum. All sections will be compressed back to the original format if required. The tool also supports many CPIO and DTB operations.

```
Usage: ./magiskboot <action> [args...]

Supported actions:
  unpack [-n] [-h] <bootimg>
    Unpack <bootimg> to its individual components, each component to
    a file with its corresponding file name in the current directory.
    Supported components: kernel, kernel_dtb, ramdisk.cpio, second,
    dtb, extra, and recovery_dtbo.
    By default, each component will be automatically decompressed
    on-the-fly before writing to the output file.
    If '-n' is provided, all decompression operations will be skipped;
    each component will remain untouched, dumped in its original format.
    If '-h' is provided, the boot image header information will be
    dumped to the file 'header', which can be used to modify header
    configurations during repacking.
    Return values:
    0:valid    1:error    2:chromeos

  repack [-n] <origbootimg> [outbootimg]
    Repack boot image components using files from the current directory
    to [outbootimg], or 'new-boot.img' if not specified. Current directory
    should only contain required files for [outbootimg], or incorrect
    [outbootimg] may be produced.
    <origbootimg> is the original boot image used to unpack the components.
    By default, each component will be automatically compressed using its
    corresponding format detected in <origbootimg>. If a component file
    in the current directory is already compressed, then no addition
    compression will be performed for that specific component.
    If '-n' is provided, all compression operations will be skipped.
    If env variable PATCHVBMETAFLAG is set to true, all disable flags in
    the boot image's vbmeta header will be set.

  verify <bootimg> [x509.pem]
    Check whether the boot image is signed with AVB 1.0 signature.
    Optionally provide a certificate to verify whether the image is
    signed by the public key certificate.
    Return value:
    0:valid    1:error

  sign <bootimg> [name] [x509.pem pk8]
    Sign <bootimg> with AVB 1.0 signature.
    Optionally provide the name of the image (default: '/boot').
    Optionally provide the certificate/private key pair for signing.
    If the certificate/private key pair is not provided, the AOSP
    verity key bundled in the executable will be used.

  extract <payload.bin> [partition] [outfile]
    Extract [partition] from <payload.bin> to [outfile].
    If [outfile] is not specified, then output to '[partition].img'.
    If [partition] is not specified, then attempt to extract either
    'init_boot' or 'boot'. Which partition was chosen can be determined
    by whichever 'init_boot.img' or 'boot.img' exists.
    <payload.bin> can be '-' to be STDIN.

  hexpatch <file> <hexpattern1> <hexpattern2>
    Search <hexpattern1> in <file>, and replace it with <hexpattern2>

  cpio <incpio> [commands...]
    Do cpio commands to <incpio> (modifications are done in-place)
    Each command is a single argument, add quotes for each command.
    Supported commands:
      exists ENTRY
        Return 0 if ENTRY exists, else return 1
      rm [-r] ENTRY
        Remove ENTRY, specify [-r] to remove recursively
      mkdir MODE ENTRY
        Create directory ENTRY in permissions MODE
      ln TARGET ENTRY
        Create a symlink to TARGET with the name ENTRY
      mv SOURCE DEST
        Move SOURCE to DEST
      add MODE ENTRY INFILE
        Add INFILE as ENTRY in permissions MODE; replaces ENTRY if exists
      extract [ENTRY OUT]
        Extract ENTRY to OUT, or extract all entries to current directory
      test
        Test the cpio's status
        Return value is 0 or bitwise or-ed of following values:
        0x1:Magisk    0x2:unsupported
      patch
        Apply ramdisk patches
        Configure with env variables: KEEPVERITY KEEPFORCEENCRYPT
      backup ORIG
        Create ramdisk backups from ORIG
      restore
        Restore ramdisk from ramdisk backup stored within incpio

  dtb <file> <action> [args...]
    Do dtb related actions to <file>
    Supported actions:
      print [-f]
        Print all contents of dtb for debugging
        Specify [-f] to only print fstab nodes
      patch
        Search for fstab and remove verity/avb
        Modifications are done directly to the file in-place
        Configure with env variables: KEEPVERITY
      test
        Test the fstab's status
        Return values:
        0:valid    1:error

  split <file>
    Split image.*-dtb into kernel + kernel_dtb

  sha1 <file>
    Print the SHA1 checksum for <file>

  cleanup
    Cleanup the current working directory

  compress[=format] <infile> [outfile]
    Compress <infile> with [format] to [outfile].
    <infile>/[outfile] can be '-' to be STDIN/STDOUT.
    If [format] is not specified, then gzip will be used.
    If [outfile] is not specified, then <infile> will be replaced
    with another file suffixed with a matching file extension.
    Supported formats: gzip zopfli xz lzma bzip2 lz4 lz4_legacy lz4_lg 

  decompress <infile> [outfile]
    Detect format and decompress <infile> to [outfile].
    <infile>/[outfile] can be '-' to be STDIN/STDOUT.
    If [outfile] is not specified, then <infile> will be replaced
    with another file removing its archive format file extension.
    Supported formats: gzip zopfli xz lzma bzip2 lz4 lz4_legacy lz4_lg 
```

### magiskinit

This binary will replace `init` in the ramdisk of a Magisk patched boot image. It is originally created for supporting devices using system-as-root, but the tool is extended to support all devices and became a crucial part of Magisk. More details can be found in the **Pre-Init** section in [Magisk Booting Process](details.md#magisk-booting-process).

### magiskpolicy

(This tool is aliased to `supolicy` for compatibility with SuperSU's sepolicy tool)

This tool could be used for advanced developers to modify SELinux policies. In common scenarios like Linux server admins, they would directly modify the SELinux policy sources (`*.te`) and recompile the `sepolicy` binary, but here on Android we directly patch the binary file (or runtime policies).

All processes spawned from the Magisk daemon, including root shells and all its forks, are running in the context `u:r:magisk:s0`. The rule used on all Magisk installed systems can be viewed as stock `sepolicy` with these patches: `magiskpolicy --magisk 'allow magisk * * *'`.

```
Usage: ./magiskpolicy [--options...] [policy statements...]

Options:
   --help            show help message for policy statements
   --load FILE       load monolithic sepolicy from FILE
   --load-split      load from precompiled sepolicy or compile
                     split cil policies
   --compile-split   compile split cil policies
   --save FILE       dump monolithic sepolicy to FILE
   --live            immediately load sepolicy into the kernel
   --magisk          apply built-in Magisk sepolicy rules
   --apply FILE      apply rules from FILE, read and parsed
                     line by line as policy statements
                     (multiple --apply are allowed)

If neither --load, --load-split, nor --compile-split is specified,
it will load from current live policies (/sys/fs/selinux/policy)

One policy statement should be treated as one parameter;
this means each policy statement should be enclosed in quotes.
Multiple policy statements can be provided in a single command.

Statements has a format of "<rule_name> [args...]".
Arguments labeled with (^) can accept one or more entries. Multiple
entries consist of a space separated list enclosed in braces ({}).
Arguments labeled with (*) are the same as (^), but additionally
support the match-all operator (*).

Example: "allow { s1 s2 } { t1 t2 } class *"
Will be expanded to:

allow s1 t1 class { all-permissions-of-class }
allow s1 t2 class { all-permissions-of-class }
allow s2 t1 class { all-permissions-of-class }
allow s2 t2 class { all-permissions-of-class }

Supported policy statements:

"allow *source_type *target_type *class *perm_set"
"deny *source_type *target_type *class *perm_set"
"auditallow *source_type *target_type *class *perm_set"
"dontaudit *source_type *target_type *class *perm_set"

"allowxperm *source_type *target_type *class operation xperm_set"
"auditallowxperm *source_type *target_type *class operation xperm_set"
"dontauditxperm *source_type *target_type *class operation xperm_set"
- The only supported operation is 'ioctl'
- xperm_set format is either 'low-high', 'value', or '*'.
  '*' will be treated as '0x0000-0xFFFF'.
  All values should be written in hexadecimal.

"permissive ^type"
"enforce ^type"

"typeattribute ^type ^attribute"

"type type_name ^(attribute)"
- Argument 'attribute' is optional, default to 'domain'

"attribute attribute_name"

"type_transition source_type target_type class default_type (object_name)"
- Argument 'object_name' is optional

"type_change source_type target_type class default_type"
"type_member source_type target_type class default_type"

"genfscon fs_name partial_path fs_context"
```

### magisk

When the magisk binary is called with the name `magisk`, it works as a utility tool with many helper functions and the entry points for several Magisk services.

```
Usage: magisk [applet [arguments]...]
   or: magisk [options]...

Options:
   -c                        print current binary version
   -v                        print running daemon version
   -V                        print running daemon version code
   --list                    list all available applets
   --remove-modules [-n]     remove all modules, reboot if -n is not provided
   --install-module ZIP      install a module zip file

Advanced Options (Internal APIs):
   --daemon                  manually start magisk daemon
   --stop                    remove all magisk changes and stop daemon
   --[init trigger]          callback on init triggers. Valid triggers:
                             post-fs-data, service, boot-complete, zygote-restart
   --unlock-blocks           set BLKROSET flag to OFF for all block devices
   --restorecon              restore selinux context on Magisk files
   --clone-attr SRC DEST     clone permission, owner, and selinux context
   --clone SRC DEST          clone SRC to DEST
   --sqlite SQL              exec SQL commands to Magisk database
   --path                    print Magisk tmpfs mount path
   --denylist ARGS           denylist config CLI
   --preinit-device          resolve a device to store preinit files

Available applets:
    su, resetprop

Usage: magisk --denylist [action [arguments...] ]
Actions:
   status          Return the enforcement status
   enable          Enable denylist enforcement
   disable         Disable denylist enforcement
   add PKG [PROC]  Add a new target to the denylist
   rm PKG [PROC]   Remove target(s) from the denylist
   ls              Print the current denylist
   exec CMDs...    Execute commands in isolated mount
                   namespace and do all unmounts
```

### su

An applet of `magisk`, the MagiskSU entry point. Good old `su` command.

```
Usage: su [options] [-] [user [argument...]]

Options:
  -c, --command COMMAND         Pass COMMAND to the invoked shell
  -g, --group GROUP             Specify the primary group
  -G, --supp-group GROUP        Specify a supplementary group.
                                The first specified supplementary group is also used
                                as a primary group if the option -g is not specified.
  -Z, --context CONTEXT         Change SELinux context
  -t, --target PID              PID to take mount namespace from
  -h, --help                    Display this help message and exit
  -, -l, --login                Pretend the shell to be a login shell
  -m, -p,
  --preserve-environment        Preserve the entire environment
  -s, --shell SHELL             Use SHELL instead of the default /system/bin/sh
  -v, --version                 Display version number and exit
  -V                            Display version code and exit
  -mm, -M,
  --mount-master                Force run in the global mount namespace
```

### resetprop

An applet of `magisk`. An advanced system property manipulation utility. Check the [Resetprop Details](details.md#resetprop) for more background information.

```
Usage: resetprop [flags] [options...]

Options:
   -h, --help        show this message
   (no arguments)    print all properties
   NAME              get property
   NAME VALUE        set property entry NAME with VALUE
   --file FILE       load props from FILE
   --delete NAME     delete property

Flags:
   -v      print verbose output to stderr
   -n      set props without going through property_service
           (this flag only affects setprop)
   -p      read/write props from/to persistent storage
           (this flag only affects getprop and delprop)
```

```

`native/src/Android-rs.mk`:

```mk
LOCAL_PATH := $(call my-dir)

###########################
# Rust compilation outputs
###########################

include $(CLEAR_VARS)
LOCAL_MODULE := magisk-rs
LOCAL_EXPORT_C_INCLUDES := src/core/include
LOCAL_LIB = ../out/$(TARGET_ARCH_ABI)/libmagisk-rs.a
ifneq (,$(wildcard $(LOCAL_PATH)/$(LOCAL_LIB)))
LOCAL_SRC_FILES := $(LOCAL_LIB)
include $(PREBUILT_STATIC_LIBRARY)
else
include $(BUILD_STATIC_LIBRARY)
endif

include $(CLEAR_VARS)
LOCAL_MODULE := boot-rs
LOCAL_LIB = ../out/$(TARGET_ARCH_ABI)/libmagiskboot-rs.a
ifneq (,$(wildcard $(LOCAL_PATH)/$(LOCAL_LIB)))
LOCAL_SRC_FILES := $(LOCAL_LIB)
include $(PREBUILT_STATIC_LIBRARY)
else
include $(BUILD_STATIC_LIBRARY)
endif

include $(CLEAR_VARS)
LOCAL_MODULE := init-rs
LOCAL_LIB = ../out/$(TARGET_ARCH_ABI)/libmagiskinit-rs.a
ifneq (,$(wildcard $(LOCAL_PATH)/$(LOCAL_LIB)))
LOCAL_SRC_FILES := $(LOCAL_LIB)
include $(PREBUILT_STATIC_LIBRARY)
else
include $(BUILD_STATIC_LIBRARY)
endif

include $(CLEAR_VARS)
LOCAL_MODULE := policy-rs
LOCAL_LIB = ../out/$(TARGET_ARCH_ABI)/libmagiskpolicy-rs.a
ifneq (,$(wildcard $(LOCAL_PATH)/$(LOCAL_LIB)))
LOCAL_SRC_FILES := $(LOCAL_LIB)
include $(PREBUILT_STATIC_LIBRARY)
else
include $(BUILD_STATIC_LIBRARY)
endif

```

`native/src/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

########################
# Binaries
########################

ifdef B_MAGISK

include $(CLEAR_VARS)
LOCAL_MODULE := magisk
LOCAL_STATIC_LIBRARIES := \
    libbase \
    libsystemproperties \
    liblsplt \
    libmagisk-rs

LOCAL_SRC_FILES := \
    core/applets.cpp \
    core/scripting.cpp \
    core/sqlite.cpp \
    core/utils.cpp \
    core/core-rs.cpp \
    core/resetprop/sys.cpp \
    core/su/su.cpp \
    core/zygisk/entry.cpp \
    core/zygisk/module.cpp \
    core/zygisk/hook.cpp \
    core/deny/cli.cpp \
    core/deny/utils.cpp \
    core/deny/logcat.cpp

LOCAL_LDLIBS := -llog
LOCAL_LDFLAGS := -Wl,--dynamic-list=src/exported_sym.txt

include $(BUILD_EXECUTABLE)

endif

ifdef B_PRELOAD

include $(CLEAR_VARS)
LOCAL_MODULE := init-ld
LOCAL_SRC_FILES := init/preload.c
LOCAL_LDFLAGS := -Wl,--strip-all
include $(BUILD_SHARED_LIBRARY)

endif

ifdef B_INIT

include $(CLEAR_VARS)
LOCAL_MODULE := magiskinit
LOCAL_STATIC_LIBRARIES := \
    libbase \
    libpolicy \
    libxz \
    libinit-rs

LOCAL_SRC_FILES := \
    init/mount.cpp \
    init/rootdir.cpp \
    init/getinfo.cpp \
    init/init-rs.cpp

LOCAL_LDFLAGS := -static

ifdef B_CRT0
LOCAL_STATIC_LIBRARIES += crt0
LOCAL_LDFLAGS += -Wl,--defsym=vfprintf=tiny_vfprintf
endif

include $(BUILD_EXECUTABLE)

endif

ifdef B_BOOT

include $(CLEAR_VARS)
LOCAL_MODULE := magiskboot
LOCAL_STATIC_LIBRARIES := \
    libbase \
    liblz4 \
    libboot-rs

LOCAL_SRC_FILES := \
    boot/bootimg.cpp \
    boot/boot-rs.cpp

LOCAL_LDFLAGS := -static

ifdef B_CRT0
LOCAL_STATIC_LIBRARIES += crt0
LOCAL_LDFLAGS += -lm -Wl,--defsym=vfprintf=musl_vfprintf
endif

include $(BUILD_EXECUTABLE)

endif

ifdef B_POLICY

include $(CLEAR_VARS)
LOCAL_MODULE := magiskpolicy
LOCAL_STATIC_LIBRARIES := \
    libbase \
    libpolicy \
    libpolicy-rs

include $(BUILD_EXECUTABLE)

endif

ifdef B_PROP

include $(CLEAR_VARS)
LOCAL_MODULE := resetprop
LOCAL_STATIC_LIBRARIES := \
    libbase \
    libsystemproperties \
    libmagisk-rs

LOCAL_SRC_FILES := \
    core/applet_stub.cpp \
    core/resetprop/sys.cpp \
    core/core-rs.cpp

LOCAL_CFLAGS := -DAPPLET_STUB_MAIN=resetprop_main
include $(BUILD_EXECUTABLE)

endif

########################
# Libraries
########################

include $(CLEAR_VARS)
LOCAL_MODULE := libpolicy
LOCAL_STATIC_LIBRARIES := \
    libbase \
    libsepol
LOCAL_C_INCLUDES := src/sepolicy/include
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_C_INCLUDES)
LOCAL_SRC_FILES := \
    sepolicy/api.cpp \
    sepolicy/sepolicy.cpp \
    sepolicy/policydb.cpp \
    sepolicy/policy-rs.cpp
include $(BUILD_STATIC_LIBRARY)

CWD := $(LOCAL_PATH)
include $(CWD)/Android-rs.mk
include $(CWD)/base/Android.mk
include $(CWD)/external/Android.mk

```

`native/src/Application.mk`:

```mk
APP_BUILD_SCRIPT := src/Android.mk
APP_CFLAGS       := -Wall -Oz -fomit-frame-pointer
APP_CPPFLAGS     := -std=c++23
APP_STL          := none
APP_PLATFORM     := android-23
APP_THIN_ARCHIVE := true
APP_STRIP_MODE   := none

ifdef MAGISK_DEBUG

NDK_APP_OUT 	 := ./obj/debug
APP_CFLAGS       += -flto=thin -gdwarf-4
APP_LDFLAGS      += -flto=thin

else

NDK_APP_OUT 	 := ./obj/release
APP_CFLAGS       += -flto
APP_LDFLAGS      += -flto -Wl,--icf=all

endif

ifdef B_CRT0

# Disable all security and debugging features
APP_CFLAGS       += -fno-unwind-tables -fno-asynchronous-unwind-tables -fno-stack-protector -fno-threadsafe-statics -U_FORTIFY_SOURCE
# Override output folder to make sure all dependencies are rebuilt with new CFLAGS
NDK_APP_OUT      := $(NDK_APP_OUT)-nolibc

endif

```

`native/src/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "anstyle"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5192cca8006f1fd4f7237516f40fa183bb07f8fbdfedaa0036de5ea9b0b45e78"

[[package]]
name = "anyhow"
version = "1.0.102"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f202df86484c868dbad7eaa557ef785d5c66295e41b460ef922eca0723b842c"

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "base"
version = "0.0.0"
dependencies = [
 "bitflags",
 "bytemuck",
 "cfg-if",
 "const_format",
 "cxx",
 "cxx-gen",
 "derive",
 "libc",
 "nix",
 "num-derive",
 "num-traits",
 "thiserror",
]

[[package]]
name = "base16ct"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd307490d624467aa6f74b0eabb77633d1f758a7b25f12bceb0b22e08d9726f6"

[[package]]
name = "base64ct"
version = "1.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2af50177e190e07a26ab74f8b1efbfe2ef87da2116221318cb1c2e82baf7de06"

[[package]]
name = "bit-set"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08807e080ed7f9d5433fa9b275196cfc35414f66a0c79d864dc51a0d825231a3"
dependencies = [
 "bit-vec",
]

[[package]]
name = "bit-vec"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e764a1d40d510daf35e07be9eb06e75770908c27d411ee6c92109c9840eaaf7"

[[package]]
name = "bitflags"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "843867be96c8daad0d758b57df9392b6d8d271134fce549de6ce169ff98a92af"

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "block-buffer"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96eb4cdd6cf1b31d671e9efe75c5d1ec614776856cefbe109ca373554a6d514f"
dependencies = [
 "hybrid-array",
]

[[package]]
name = "bumpalo"
version = "3.20.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d20789868f4b01b2f2caec9f5c4e0213b41e3e5702a50157d699ae31ced2fcb"

[[package]]
name = "bytemuck"
version = "1.25.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c8efb64bd706a16a1bdde310ae86b351e4d21550d98d056f22f8a7f7a2183fec"
dependencies = [
 "bytemuck_derive",
]

[[package]]
name = "bytemuck_derive"
version = "1.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9abbd1bc6865053c427f7198e6af43bfdedc55ab791faed4fbd361d789575ff"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bzip2"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3a53fac24f34a81bc9954b5d6cfce0c21e18ec6959f44f56e8e90e4bb7c346c"
dependencies = [
 "libbz2-rs-sys",
]

[[package]]
name = "cc"
version = "1.2.56"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aebf35691d1bfb0ac386a69bac2fde4dd276fb618cf8bf4f5318fe285e821bb2"
dependencies = [
 "find-msvc-tools",
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9330f8b2ff13f34540b44e946ef35111825727b38d33286ef986142615121801"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "clap"
version = "4.5.60"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2797f34da339ce31042b27d23607e051786132987f595b02ba4f6a6dffb7030a"
dependencies = [
 "clap_builder",
]

[[package]]
name = "clap_builder"
version = "4.5.60"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24a241312cea5059b13574bb9b3861cabf758b879c15190b37b6d6fd63ab6876"
dependencies = [
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_lex"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a822ea5bc7590f9d40f1ba12c0dc3c2760f3482c6984db1573ad11031420831"

[[package]]
name = "cmov"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de0758edba32d61d1fd9f4d69491b47604b91ee2f7e6b33de7e54ca4ebe55dc3"

[[package]]
name = "codespan-reporting"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af491d569909a7e4dee0ad7db7f5341fef5c614d5b8ec8cf765732aba3cff681"
dependencies = [
 "serde",
 "termcolor",
 "unicode-width",
]

[[package]]
name = "const-oid"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6ef517f0926dd24a1582492c791b6a4818a4d94e789a334894aa15b0d12f55c"

[[package]]
name = "const_format"
version = "0.2.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7faa7469a93a566e9ccc1c73fe783b4a65c274c5ace346038dca9c39fe0030ad"
dependencies = [
 "const_format_proc_macros",
]

[[package]]
name = "const_format_proc_macros"
version = "0.2.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d57c2eccfb16dbac1f4e61e206105db5820c9d26c3c472bc17c774259ef7744"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-xid",
]

[[package]]
name = "cpubits"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ef0c543070d296ea414df2dd7625d1b24866ce206709d8a4a424f28377f5861"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crypto-bigint"
version = "0.7.0-rc.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b43308b9b6a47554f4612d5b1fb95ff935040aa3927dd42b1d6cbc015a262d96"
dependencies = [
 "cpubits",
 "ctutils",
 "getrandom",
 "hybrid-array",
 "num-traits",
 "rand_core",
 "serdect",
 "subtle",
 "zeroize",
]

[[package]]
name = "crypto-common"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78c8292055d1c1df0cce5d180393dc8cce0abec0a7102adb6c7b1eef6016d60a"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "crypto-common"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "211f05e03c7d03754740fd9e585de910a095d6b99f8bcfffdef8319fa02a8331"
dependencies = [
 "getrandom",
 "hybrid-array",
 "rand_core",
]

[[package]]
name = "crypto-primes"
version = "0.7.0-pre.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6081ce8b60c0e533e2bba42771b94eb6149052115f4179744d5779883dc98583"
dependencies = [
 "crypto-bigint",
 "libm",
 "rand_core",
]

[[package]]
name = "ctutils"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1005a6d4446f5120ef475ad3d2af2b30c49c2c9c6904258e3bb30219bebed5e4"
dependencies = [
 "cmov",
 "subtle",
]

[[package]]
name = "cxx"
version = "1.0.189"
dependencies = [
 "cc",
 "cxx-build",
 "cxxbridge-cmd",
 "cxxbridge-flags",
 "cxxbridge-macro",
 "foldhash 0.2.0",
]

[[package]]
name = "cxx-build"
version = "1.0.189"
dependencies = [
 "cc",
 "codespan-reporting",
 "indexmap",
 "proc-macro2",
 "quote",
 "scratch",
 "syn",
]

[[package]]
name = "cxx-gen"
version = "0.7.189"
dependencies = [
 "codespan-reporting",
 "indexmap",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "cxxbridge-cmd"
version = "1.0.189"
dependencies = [
 "clap",
 "codespan-reporting",
 "indexmap",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "cxxbridge-flags"
version = "1.0.189"

[[package]]
name = "cxxbridge-macro"
version = "1.0.189"
dependencies = [
 "indexmap",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "der"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "71fd89660b2dc699704064e59e9dba0147b903e85319429e131620d022be411b"
dependencies = [
 "const-oid",
 "der_derive",
 "flagset",
 "pem-rfc7468",
 "zeroize",
]

[[package]]
name = "der_derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59600e2c2d636fde9b65e99cc6445ac770c63d3628195ff39932b8d6d7409903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "derive"
version = "0.0.0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer 0.10.4",
 "crypto-common 0.1.7",
]

[[package]]
name = "digest"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8bf3682cdec91817be507e4aa104314898b95b84d74f3d43882210101a545b6"
dependencies = [
 "block-buffer 0.11.0",
 "const-oid",
 "crypto-common 0.2.0",
 "ctutils",
]

[[package]]
name = "ecdsa"
version = "0.17.0-rc.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91bbdd377139884fafcad8dc43a760a3e1e681aa26db910257fa6535b70e1829"
dependencies = [
 "der",
 "digest 0.11.0",
 "elliptic-curve",
 "rfc6979",
 "signature",
 "spki",
 "zeroize",
]

[[package]]
name = "elliptic-curve"
version = "0.14.0-rc.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bde7860544606d222fd6bd6d9f9a0773321bf78072a637e1d560a058c0031978"
dependencies = [
 "base16ct",
 "crypto-bigint",
 "crypto-common 0.2.0",
 "digest 0.11.0",
 "hybrid-array",
 "once_cell",
 "pem-rfc7468",
 "pkcs8",
 "rand_core",
 "rustcrypto-ff",
 "rustcrypto-group",
 "sec1",
 "subtle",
 "zeroize",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "fdt"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784a4df722dc6267a04af36895398f59d21d07dce47232adf31ec0ff2fa45e67"

[[package]]
name = "fiat-crypto"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64cd1e32ddd350061ae6edb1b082d7c54915b5c672c389143b9a63403a109f24"

[[package]]
name = "find-msvc-tools"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5baebc0774151f905a1a2cc41989300b1e6fbb29aff0ceffa1064fdd3088d582"

[[package]]
name = "flagset"
version = "0.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b7ac824320a75a52197e8f2d787f6a38b6718bb6897a35142d749af3c0e8f4fe"

[[package]]
name = "flate2"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "843fba2746e448b37e26a819579957415c8cef339bf08564fe8b7ddbd959573c"
dependencies = [
 "miniz_oxide",
 "zlib-rs",
]

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "foldhash"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77ce24cb58228fbb8aa041425bb1050850ac19177686ea6e0f41a70416f56fdb"

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "139ef39800118c7683f2fd3c98c1b23c09ae076556b435f8e9064ae108aaeeec"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "rand_core",
 "wasip2",
 "wasip3",
]

[[package]]
name = "hashbrown"
version = "0.15.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9229cfe53dfd69f0609a49f65461bd93001ea1ef889cd5529dd176593f5338a1"
dependencies = [
 "foldhash 0.1.5",
]

[[package]]
name = "hashbrown"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "841d1cc9bed7f9236f321df977030373f4a4163ae1a7dbfe1a51a2c1a51d9100"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hmac"
version = "0.13.0-rc.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef451d73f36d8a3f93ad32c332ea01146c9650e1ec821a9b0e46c01277d544f8"
dependencies = [
 "digest 0.11.0",
]

[[package]]
name = "hybrid-array"
version = "0.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1b229d73f5803b562cc26e4da0396c8610a4ee209f4fac8fa4f8d709166dc45"
dependencies = [
 "subtle",
 "typenum",
 "zeroize",
]

[[package]]
name = "id-arena"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d3067d79b975e8844ca9eb072e16b31c3c1c36928edf9c6789548c524d0d954"

[[package]]
name = "indexmap"
version = "2.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7714e70437a7dc3ac8eb7e6f8df75fd8eb422675fc7678aff7364301092b1017"
dependencies = [
 "equivalent",
 "hashbrown 0.16.1",
 "serde",
 "serde_core",
]

[[package]]
name = "itoa"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92ecc6618181def0457392ccd0ee51198e065e016d1d527a7ac1b6dc7c1f09d2"

[[package]]
name = "leb128fmt"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09edd9e8b54e49e587e4f6295a7d29c3ea94d469cb40ab8ca70b288248a81db2"

[[package]]
name = "libbz2-rs-sys"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c4a545a15244c7d945065b5d392b2d2d7f21526fba56ce51467b06ed445e8f7"

[[package]]
name = "libc"
version = "0.2.182"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6800badb6cb2082ffd7b6a67e6125bb39f18782f793520caee8cb8846be06112"

[[package]]
name = "libm"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6d2cec3eae94f9f509c767b45932f1ada8350c4bdb85af2fcab4a3c14807981"

[[package]]
name = "log"
version = "0.4.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e5032e24019045c762d3c0f28f5b6b8bbf38563a65908389bf7978758920897"

[[package]]
name = "lz4"
version = "1.28.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a20b523e860d03443e98350ceaac5e71c6ba89aea7d960769ec3ce37f4de5af4"
dependencies = [
 "lz4-sys",
]

[[package]]
name = "lz4-sys"
version = "1.11.1+lz4-1.10.0"
dependencies = [
 "libc",
]

[[package]]
name = "lzma-rust2"
version = "0.16.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "47bb1e988e6fb779cf720ad431242d3f03167c1b3f2b1aae7f1a94b2495b36ae"
dependencies = [
 "sha2 0.10.9",
]

[[package]]
name = "magisk"
version = "0.0.0"
dependencies = [
 "base",
 "bit-set",
 "bitflags",
 "bytemuck",
 "cxx",
 "cxx-gen",
 "nix",
 "num-derive",
 "num-traits",
 "pb-rs",
 "quick-protobuf",
 "thiserror",
]

[[package]]
name = "magiskboot"
version = "0.0.0"
dependencies = [
 "base",
 "bytemuck",
 "byteorder",
 "bzip2",
 "cxx",
 "cxx-gen",
 "der",
 "digest 0.11.0",
 "fdt",
 "flate2",
 "lz4",
 "lzma-rust2",
 "num-traits",
 "p256",
 "p384",
 "p521",
 "pb-rs",
 "quick-protobuf",
 "rsa",
 "sha1",
 "sha2 0.11.0-rc.5",
 "size",
 "x509-cert",
 "zopfli",
]

[[package]]
name = "magiskinit"
version = "0.0.0"
dependencies = [
 "base",
 "cxx",
 "cxx-gen",
 "magiskpolicy",
 "num-traits",
]

[[package]]
name = "magiskpolicy"
version = "0.0.0"
dependencies = [
 "base",
 "cxx",
 "cxx-gen",
]

[[package]]
name = "memchr"
version = "2.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8ca58f447f06ed17d5fc4043ce1b10dd205e060fb3ce5b979b8ed8e59ff3f79"

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
 "simd-adler32",
]

[[package]]
name = "nix"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74523f3a35e05aba87a1d978330aef40f67b0304ac79c1c00b294c9830543db6"
dependencies = [
 "bitflags",
 "cfg-if",
 "cfg_aliases",
 "libc",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "num-derive"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed3955f1a9c7c0c15e092f9c887db08b1fc683305fdf6eb6684f22555355e202"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "p256"
version = "0.14.0-rc.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "018bfbb86e05fd70a83e985921241035ee09fcd369c4a2c3680b389a01d2ad28"
dependencies = [
 "ecdsa",
 "elliptic-curve",
 "primefield",
 "primeorder",
 "sha2 0.11.0-rc.5",
]

[[package]]
name = "p384"
version = "0.14.0-rc.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c91df688211f5957dbe2ab599dcbcaade8d6d3cdc15c5b350d350d7d07ce423"
dependencies = [
 "ecdsa",
 "elliptic-curve",
 "fiat-crypto",
 "primefield",
 "primeorder",
 "sha2 0.11.0-rc.5",
]

[[package]]
name = "p521"
version = "0.14.0-rc.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de6cd9451de522549d36cc78a1b45a699a3d55a872e8ea0c8f0318e502d99e2c"
dependencies = [
 "base16ct",
 "ecdsa",
 "elliptic-curve",
 "primefield",
 "primeorder",
 "sha2 0.11.0-rc.5",
]

[[package]]
name = "pb-rs"
version = "0.10.0"
source = "git+https://github.com/topjohnwu/quick-protobuf.git#980b0fb0ff81f59c0faa6e6db490fb8ecf59c633"
dependencies = [
 "log",
 "nom",
]

[[package]]
name = "pem-rfc7468"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6305423e0e7738146434843d1694d621cce767262b2a86910beab705e4493d9"
dependencies = [
 "base64ct",
]

[[package]]
name = "pkcs1"
version = "0.8.0-rc.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "986d2e952779af96ea048f160fd9194e1751b4faea78bcf3ceb456efe008088e"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "pkcs8"
version = "0.11.0-rc.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "12922b6296c06eb741b02d7b5161e3aaa22864af38dfa025a1a3ba3f68c84577"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "prettyplease"
version = "0.2.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "479ca8adacdd7ce8f1fb39ce9ecccbfe93a3f1344b3d0d97f20bc0196208f62b"
dependencies = [
 "proc-macro2",
 "syn",
]

[[package]]
name = "primefield"
version = "0.14.0-rc.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93401c13cc7ff24684571cfca9d3cf9ebabfaf3d4b7b9963ade41ec54da196b5"
dependencies = [
 "crypto-bigint",
 "crypto-common 0.2.0",
 "rand_core",
 "rustcrypto-ff",
 "subtle",
 "zeroize",
]

[[package]]
name = "primeorder"
version = "0.14.0-rc.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a0c5c8a39bcd764bfedf456e8d55e115fe86dda3e0f555371849f2a41cbc9706"
dependencies = [
 "elliptic-curve",
]

[[package]]
name = "proc-macro2"
version = "1.0.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fd00f0bb2e90d81d1044c2b32617f68fcb9fa3bb7640c23e9c748e53fb30934"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quick-protobuf"
version = "0.8.1"
source = "git+https://github.com/topjohnwu/quick-protobuf.git#980b0fb0ff81f59c0faa6e6db490fb8ecf59c633"
dependencies = [
 "byteorder",
]

[[package]]
name = "quote"
version = "1.0.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "21b2ebcf727b7760c461f091f9f0f539b77b8e87f2fd88131e7f1b433b3cece4"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rand_core"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c8d0fd677905edcbeedbf2edb6494d676f0e98d54d5cf9bda0b061cb8fb8aba"

[[package]]
name = "rfc6979"
version = "0.5.0-rc.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23a3127ee32baec36af75b4107082d9bd823501ec14a4e016be4b6b37faa74ae"
dependencies = [
 "hmac",
 "subtle",
]

[[package]]
name = "rsa"
version = "0.10.0-rc.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b342b99544549f37509ed7fd42b0cea04bfd9ce07c16ca56094cf0fbeefbbcd"
dependencies = [
 "const-oid",
 "crypto-bigint",
 "crypto-primes",
 "digest 0.11.0",
 "pkcs1",
 "pkcs8",
 "rand_core",
 "sha2 0.11.0-rc.5",
 "signature",
 "spki",
 "zeroize",
]

[[package]]
name = "rustcrypto-ff"
version = "0.14.0-rc.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c5db129183b2c139d7d87d08be57cba626c715789db17aec65c8866bfd767d1f"
dependencies = [
 "rand_core",
 "subtle",
]

[[package]]
name = "rustcrypto-group"
version = "0.14.0-rc.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c4b1463f274a3ff6fb2f44da43e576cb9424367bd96f185ead87b52fe00523"
dependencies = [
 "rand_core",
 "rustcrypto-ff",
 "subtle",
]

[[package]]
name = "scratch"
version = "1.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d68f2ec51b097e4c1a75b681a8bec621909b5e91f15bb7b840c4f2f7b01148b2"

[[package]]
name = "sec1"
version = "0.8.0-rc.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2400ed44a13193820aa528a19f376c3843141a8ce96ff34b11104cc79763f2"
dependencies = [
 "base16ct",
 "ctutils",
 "der",
 "hybrid-array",
 "subtle",
 "zeroize",
]

[[package]]
name = "semver"
version = "1.0.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d767eb0aabc880b29956c35734170f26ed551a859dbd361d140cdbeca61ab1e2"

[[package]]
name = "serde"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a8e94ea7f378bd32cbbd37198a4a91436180c5bb472411e48b5ec2e2124ae9e"
dependencies = [
 "serde_core",
 "serde_derive",
]

[[package]]
name = "serde_core"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d385c7d4ca58e59fc732af25c3983b67ac852c1a25000afe1175de458b67ad"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d540f220d3187173da220f885ab66608367b6574e925011a9353e4badda91d79"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.149"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83fc039473c5595ace860d8c4fafa220ff474b3fc6bfdb4293327f1a37e94d86"
dependencies = [
 "itoa",
 "memchr",
 "serde",
 "serde_core",
 "zmij",
]

[[package]]
name = "serdect"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9af4a3e75ebd5599b30d4de5768e00b5095d518a79fefc3ecbaf77e665d1ec06"
dependencies = [
 "base16ct",
 "serde",
]

[[package]]
name = "sha1"
version = "0.11.0-rc.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b167252f3c126be0d8926639c4c4706950f01445900c4b3db0fd7e89fcb750a"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.11.0",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.10.7",
]

[[package]]
name = "sha2"
version = "0.11.0-rc.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c5f3b1e2dc8aad28310d8410bd4d7e180eca65fca176c52ab00d364475d0024"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.11.0",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signature"
version = "3.0.0-rc.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f1880df446116126965eeec169136b2e0251dba37c6223bcc819569550edea3"
dependencies = [
 "digest 0.11.0",
 "rand_core",
]

[[package]]
name = "simd-adler32"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e320a6c5ad31d271ad523dcf3ad13e2767ad8b1cb8f047f75a8aeaf8da139da2"

[[package]]
name = "size"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b6709c7b6754dca1311b3c73e79fcce40dd414c782c66d88e8823030093b02b"

[[package]]
name = "spki"
version = "0.8.0-rc.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8baeff88f34ed0691978ec34440140e1572b68c7dd4a495fd14a3dc1944daa80"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "2.0.117"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e665b8803e7b1d2a727f4023456bbbbe74da67099c585258af0ad9c5013b9b99"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "2.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4288b5bcbc7920c07a1149a35cf9590a2aa808e0bc1eafaade0b80947865fbc4"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "2.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebc4ee7f67670e9b64d05fa4253e753e016c6c95ff35b89b7941d6b856dec1d5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tls_codec"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0de2e01245e2bb89d6f05801c564fa27624dbd7b1846859876c7dad82e90bf6b"
dependencies = [
 "tls_codec_derive",
 "zeroize",
]

[[package]]
name = "tls_codec_derive"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2d2e76690929402faae40aebdda620a2c0e25dd6d3b9afe48867dfd95991f4bd"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "typenum"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "562d481066bde0658276a35467c4af00bdc6ee726305698a55b86e61d7ad82bb"

[[package]]
name = "unicode-ident"
version = "1.0.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6e4313cd5fcd3dad5cafa179702e2b244f760991f45397d14d4ebf38247da75"

[[package]]
name = "unicode-width"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4ac048d71ede7ee76d585517add45da530660ef4390e49b098733c6e897f254"

[[package]]
name = "unicode-xid"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebc1c04c71510c7f702b52b7c350734c9ff1295c464a03335b00bb84fc54f853"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasip2"
version = "1.0.2+wasi-0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9517f9239f02c069db75e65f174b3da828fe5f5b945c4dd26bd25d89c03ebcf5"
dependencies = [
 "wit-bindgen",
]

[[package]]
name = "wasip3"
version = "0.4.0+wasi-0.3.0-rc-2026-01-06"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5428f8bf88ea5ddc08faddef2ac4a67e390b88186c703ce6dbd955e1c145aca5"
dependencies = [
 "wit-bindgen",
]

[[package]]
name = "wasm-encoder"
version = "0.244.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "990065f2fe63003fe337b932cfb5e3b80e0b4d0f5ff650e6985b1048f62c8319"
dependencies = [
 "leb128fmt",
 "wasmparser",
]

[[package]]
name = "wasm-metadata"
version = "0.244.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb0e353e6a2fbdc176932bbaab493762eb1255a7900fe0fea1a2f96c296cc909"
dependencies = [
 "anyhow",
 "indexmap",
 "wasm-encoder",
 "wasmparser",
]

[[package]]
name = "wasmparser"
version = "0.244.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "47b807c72e1bac69382b3a6fb3dbe8ea4c0ed87ff5629b8685ae6b9a611028fe"
dependencies = [
 "bitflags",
 "hashbrown 0.15.5",
 "indexmap",
 "semver",
]

[[package]]
name = "winapi-util"
version = "0.1.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2a7b1c03c876122aa43f3020e6c3c3ee5c05081c9a00739faf7503aeba10d22"
dependencies = [
 "windows-sys",
]

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-sys"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
dependencies = [
 "windows-link",
]

[[package]]
name = "wit-bindgen"
version = "0.51.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d7249219f66ced02969388cf2bb044a09756a083d0fab1e566056b04d9fbcaa5"
dependencies = [
 "wit-bindgen-rust-macro",
]

[[package]]
name = "wit-bindgen-core"
version = "0.51.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea61de684c3ea68cb082b7a88508a8b27fcc8b797d738bfc99a82facf1d752dc"
dependencies = [
 "anyhow",
 "heck",
 "wit-parser",
]

[[package]]
name = "wit-bindgen-rust"
version = "0.51.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b7c566e0f4b284dd6561c786d9cb0142da491f46a9fbed79ea69cdad5db17f21"
dependencies = [
 "anyhow",
 "heck",
 "indexmap",
 "prettyplease",
 "syn",
 "wasm-metadata",
 "wit-bindgen-core",
 "wit-component",
]

[[package]]
name = "wit-bindgen-rust-macro"
version = "0.51.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c0f9bfd77e6a48eccf51359e3ae77140a7f50b1e2ebfe62422d8afdaffab17a"
dependencies = [
 "anyhow",
 "prettyplease",
 "proc-macro2",
 "quote",
 "syn",
 "wit-bindgen-core",
 "wit-bindgen-rust",
]

[[package]]
name = "wit-component"
version = "0.244.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d66ea20e9553b30172b5e831994e35fbde2d165325bec84fc43dbf6f4eb9cb2"
dependencies = [
 "anyhow",
 "bitflags",
 "indexmap",
 "log",
 "serde",
 "serde_derive",
 "serde_json",
 "wasm-encoder",
 "wasm-metadata",
 "wasmparser",
 "wit-parser",
]

[[package]]
name = "wit-parser"
version = "0.244.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecc8ac4bc1dc3381b7f59c34f00b67e18f910c2c0f50015669dde7def656a736"
dependencies = [
 "anyhow",
 "id-arena",
 "indexmap",
 "log",
 "semver",
 "serde",
 "serde_derive",
 "serde_json",
 "unicode-xid",
 "wasmparser",
]

[[package]]
name = "x509-cert"
version = "0.3.0-rc.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e21aad3a769f25f3d2d0cbf30ea8b50a1d602354bd6ab687fad112821608ba6"
dependencies = [
 "const-oid",
 "der",
 "spki",
 "tls_codec",
]

[[package]]
name = "zeroize"
version = "1.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b97154e67e32c85465826e8bcc1c59429aaaf107c1e4a9e53c8d8ccd5eff88d0"
dependencies = [
 "zeroize_derive",
]

[[package]]
name = "zeroize_derive"
version = "1.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85a5b4158499876c763cb03bc4e49185d3cccbabb15b33c627f7884f43db852e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zlib-rs"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c745c48e1007337ed136dc99df34128b9faa6ed542d80a1c673cf55a6d7236c8"

[[package]]
name = "zmij"
version = "1.0.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8848ee67ecc8aedbaf3e4122217aff892639231befc6a1b58d29fff4c2cabaa"

[[package]]
name = "zopfli"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f05cd8797d63865425ff89b5c4a48804f35ba0ce8d125800027ad6017d2b5249"
dependencies = [
 "bumpalo",
 "crc32fast",
 "log",
 "simd-adler32",
]

```

`native/src/Cargo.toml`:

```toml
cargo-features = ["panic-immediate-abort"]

[workspace]
exclude = ["external"]
members = ["base", "base/derive", "boot", "core", "init", "sepolicy"]
resolver = "2"

[workspace.package]
version = "0.0.0"
edition = "2024"

[workspace.dependencies]
base = { path = "base" }
derive = { path = "base/derive" }
magiskpolicy = { path = "sepolicy" }
cxx = { path = "external/cxx-rs" }
cxx-gen = { path = "external/cxx-rs/gen/lib" }
libc = "0.2.182"
cfg-if = "1.0.4"
num-traits = "0.2.19"
num-derive = "0.4.2"
thiserror = "2.0.18"
byteorder = "1.5.0"
size = "0.5.0"
bytemuck = "1.25.0"
fdt = "0.1.5"
const_format = "0.2.35"
bit-set = "0.8.0"
syn = "2.0.117"
quote = "1.0.44"
proc-macro2 = "1.0.106"
pb-rs = { version = "0.10.0", default-features = false }
quick-protobuf = "0.8.1"
flate2 = { version = "1.1.9", default-features = false }
bzip2 = "0.6.1"
zopfli = "0.8.3"
lz4 = "1.28.1"
lzma-rust2 = { version = "0.16.2", default-features = false }
nix = "0.30.1"
bitflags = "2.11.0"

# Rust crypto crates are tied together
sha1 = "0.11.0-rc.5"
sha2 = "0.11.0-rc.5"
digest = "0.11.0"
p256 = "0.14.0-rc.7"
p384 = "0.14.0-rc.7"
p521 = "0.14.0-rc.7"
rsa = "0.10.0-rc.15"
x509-cert = "0.3.0-rc.4"
der = "0.8.0"

[patch.crates-io]
pb-rs = { git = "https://github.com/topjohnwu/quick-protobuf.git" }
quick-protobuf = { git = "https://github.com/topjohnwu/quick-protobuf.git" }
lz4-sys = { path = "external/lz4-sys" }

[workspace.lints.clippy]
unwrap_used = "deny"

[profile.dev]
opt-level = "z"
lto = "thin"
panic = "immediate-abort"
debug = "none"

[profile.release]
opt-level = "z"
lto = "fat"
codegen-units = 1
panic = "immediate-abort"
strip = true

```

`native/src/base/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

# Magisk project-wide common code

include $(CLEAR_VARS)
LOCAL_MODULE := libbase
LOCAL_C_INCLUDES := \
    src/include \
    $(LOCAL_PATH)/include \
    out/generated
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_C_INCLUDES)
LOCAL_EXPORT_STATIC_LIBRARIES := libcxx
LOCAL_STATIC_LIBRARIES := libcxx
LOCAL_SRC_FILES := \
    base.cpp \
    base-rs.cpp \
    ../external/cxx-rs/src/cxx.cc
include $(BUILD_STATIC_LIBRARY)

```

`native/src/base/Cargo.toml`:

```toml
[package]
name = "base"
version.workspace = true
edition.workspace = true

[lib]
path = "lib.rs"

[features]
selinux = []

[lints]
workspace = true

[build-dependencies]
cxx-gen = { workspace = true }

[dependencies]
derive = { workspace = true }
cxx = { workspace = true }
libc = { workspace = true }
cfg-if = { workspace = true }
thiserror = { workspace = true }
bytemuck = { workspace = true }
num-traits = { workspace = true }
num-derive = { workspace = true }
const_format = { workspace = true }
nix = { workspace = true, features = ["fs", "mount", "user"] }
bitflags = { workspace = true }

```

`native/src/base/argh.rs`:

```rs
// Copyright (c) 2020 Google LLC All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//! Derive-based argument parsing optimized for code size and conformance
//! to the Fuchsia commandline tools specification
//!
//! The public API of this library consists primarily of the `FromArgs`
//! derive and the `from_env` function, which can be used to produce
//! a top-level `FromArgs` type from the current program's commandline
//! arguments.
//!
//! ## Basic Example
//!
//! ```rust,no_run
//! use argh::FromArgs;
//!
//! #[derive(FromArgs)]
//! /// Reach new heights.
//! struct GoUp {
//!     /// whether or not to jump
//!     #[argh(switch, short = 'j')]
//!     jump: bool,
//!
//!     /// how high to go
//!     #[argh(option)]
//!     height: usize,
//!
//!     /// an optional nickname for the pilot
//!     #[argh(option)]
//!     pilot_nickname: Option<String>,
//! }
//!
//! let up: GoUp = argh::from_env();
//! ```
//!
//! `./some_bin --help` will then output the following:
//!
//! ```bash
//! Usage: cmdname [-j] --height <height> [--pilot-nickname <pilot-nickname>]
//!
//! Reach new heights.
//!
//! Options:
//!   -j, --jump        whether or not to jump
//!   --height          how high to go
//!   --pilot-nickname  an optional nickname for the pilot
//!   --help, help      display usage information
//! ```
//!
//! The resulting program can then be used in any of these ways:
//! - `./some_bin --height 5`
//! - `./some_bin -j --height 5`
//! - `./some_bin --jump --height 5 --pilot-nickname Wes`
//!
//! Switches, like `jump`, are optional and will be set to true if provided.
//!
//! Options, like `height` and `pilot_nickname`, can be either required,
//! optional, or repeating, depending on whether they are contained in an
//! `Option` or a `Vec`. Default values can be provided using the
//! `#[argh(default = "<your_code_here>")]` attribute, and in this case an
//! option is treated as optional.
//!
//! ```rust
//! use argh::FromArgs;
//!
//! fn default_height() -> usize {
//!     5
//! }
//!
//! #[derive(FromArgs)]
//! /// Reach new heights.
//! #[argh(help_triggers("-h", "--help", "help"))]
//! struct GoUp {
//!     /// an optional nickname for the pilot
//!     #[argh(option)]
//!     pilot_nickname: Option<String>,
//!
//!     /// an optional height
//!     #[argh(option, default = "default_height()")]
//!     height: usize,
//!
//!     /// an optional direction which is "up" by default
//!     #[argh(option, default = "String::from(\"only up\")")]
//!     direction: String,
//! }
//!
//! fn main() {
//!     let up: GoUp = argh::from_env();
//! }
//! ```
//!
//! Custom option types can be deserialized so long as they implement the
//! `FromArgValue` trait (automatically implemented for all `FromStr` types).
//! If more customized parsing is required, you can supply a custom
//! `fn(&str) -> Result<T, String>` using the `from_str_fn` attribute:
//!
//! ```
//! # use argh::FromArgs;
//!
//! #[derive(FromArgs)]
//! /// Goofy thing.
//! struct FiveStruct {
//!     /// always five
//!     #[argh(option, from_str_fn(always_five))]
//!     five: usize,
//! }
//!
//! fn always_five(_value: &str) -> Result<usize, String> {
//!     Ok(5)
//! }
//! ```
//!
//! Positional arguments can be declared using `#[argh(positional)]`.
//! These arguments will be parsed in order of their declaration in
//! the structure:
//!
//! ```rust
//! use argh::FromArgs;
//! #[derive(FromArgs, PartialEq, Debug)]
//! /// A command with positional arguments.
//! struct WithPositional {
//!     #[argh(positional)]
//!     first: String,
//! }
//! ```
//!
//! The last positional argument may include a default, or be wrapped in
//! `Option` or `Vec` to indicate an optional or repeating positional argument.
//!
//! If your final positional argument has the `greedy` option on it, it will consume
//! any arguments after it as if a `--` were placed before the first argument to
//! match the greedy positional:
//!
//! ```rust
//! use argh::FromArgs;
//! #[derive(FromArgs, PartialEq, Debug)]
//! /// A command with a greedy positional argument at the end.
//! struct WithGreedyPositional {
//!     /// some stuff
//!     #[argh(option)]
//!     stuff: Option<String>,
//!     #[argh(positional, greedy)]
//!     all_the_rest: Vec<String>,
//! }
//! ```
//!
//! Now if you pass `--stuff Something` after a positional argument, it will
//! be consumed by `all_the_rest` instead of setting the `stuff` field.
//!
//! Note that `all_the_rest` won't be listed as a positional argument in the
//! long text part of help output (and it will be listed at the end of the usage
//! line as `[all_the_rest...]`), and it's up to the caller to append any
//! extra help output for the meaning of the captured arguments. This is to
//! enable situations where some amount of argument processing needs to happen
//! before the rest of the arguments can be interpreted, and shouldn't be used
//! for regular use as it might be confusing.
//!
//! Subcommands are also supported. To use a subcommand, declare a separate
//! `FromArgs` type for each subcommand as well as an enum that cases
//! over each command:
//!
//! ```rust
//! # use argh::FromArgs;
//!
//! #[derive(FromArgs, PartialEq, Debug)]
//! /// Top-level command.
//! struct TopLevel {
//!     #[argh(subcommand)]
//!     nested: MySubCommandEnum,
//! }
//!
//! #[derive(FromArgs, PartialEq, Debug)]
//! #[argh(subcommand)]
//! enum MySubCommandEnum {
//!     One(SubCommandOne),
//!     Two(SubCommandTwo),
//! }
//!
//! #[derive(FromArgs, PartialEq, Debug)]
//! /// First subcommand.
//! #[argh(subcommand, name = "one")]
//! struct SubCommandOne {
//!     #[argh(option)]
//!     /// how many x
//!     x: usize,
//! }
//!
//! #[derive(FromArgs, PartialEq, Debug)]
//! /// Second subcommand.
//! #[argh(subcommand, name = "two")]
//! struct SubCommandTwo {
//!     #[argh(switch)]
//!     /// whether to fooey
//!     fooey: bool,
//! }
//! ```
//!
//! You can also discover subcommands dynamically at runtime. To do this,
//! declare subcommands as usual and add a variant to the enum with the
//! `dynamic` attribute. Instead of deriving `FromArgs`, the value inside the
//! dynamic variant should implement `DynamicSubCommand`.
//!
//! ```rust
//! # use argh::CommandInfo;
//! # use argh::DynamicSubCommand;
//! # use argh::EarlyExit;
//! # use argh::FromArgs;
//! # use once_cell::sync::OnceCell;
//!
//! #[derive(FromArgs, PartialEq, Debug)]
//! /// Top-level command.
//! struct TopLevel {
//!     #[argh(subcommand)]
//!     nested: MySubCommandEnum,
//! }
//!
//! #[derive(FromArgs, PartialEq, Debug)]
//! #[argh(subcommand)]
//! enum MySubCommandEnum {
//!     Normal(NormalSubCommand),
//!     #[argh(dynamic)]
//!     Dynamic(Dynamic),
//! }
//!
//! #[derive(FromArgs, PartialEq, Debug)]
//! /// Normal subcommand.
//! #[argh(subcommand, name = "normal")]
//! struct NormalSubCommand {
//!     #[argh(option)]
//!     /// how many x
//!     x: usize,
//! }
//!
//! /// Dynamic subcommand.
//! #[derive(PartialEq, Debug)]
//! struct Dynamic {
//!     name: String
//! }
//!
//! impl DynamicSubCommand for Dynamic {
//!     fn commands() -> &'static [&'static CommandInfo] {
//!         static RET: OnceCell<Vec<&'static CommandInfo>> = OnceCell::new();
//!         RET.get_or_init(|| {
//!             let mut commands = Vec::new();
//!
//!             // argh needs the `CommandInfo` structs we generate to be valid
//!             // for the static lifetime. We can allocate the structures on
//!             // the heap with `Box::new` and use `Box::leak` to get a static
//!             // reference to them. We could also just use a constant
//!             // reference, but only because this is a synthetic example; the
//!             // point of using dynamic commands is to have commands you
//!             // don't know about until runtime!
//!             commands.push(&*Box::leak(Box::new(CommandInfo {
//!                 name: "dynamic_command",
//!                 description: "A dynamic command",
//!             })));
//!
//!             commands
//!         })
//!     }
//!
//!     fn try_redact_arg_values(
//!         command_name: &[&str],
//!         args: &[&str],
//!     ) -> Option<Result<Vec<String>, EarlyExit>> {
//!         for command in Self::commands() {
//!             if command_name.last() == Some(&command.name) {
//!                 // Process arguments and redact values here.
//!                 if !args.is_empty() {
//!                     return Some(Err("Our example dynamic command never takes arguments!"
//!                                     .to_string().into()));
//!                 }
//!                 return Some(Ok(Vec::new()))
//!             }
//!         }
//!         None
//!     }
//!
//!     fn try_from_args(command_name: &[&str], args: &[&str]) -> Option<Result<Self, EarlyExit>> {
//!         for command in Self::commands() {
//!             if command_name.last() == Some(&command.name) {
//!                 if !args.is_empty() {
//!                     return Some(Err("Our example dynamic command never takes arguments!"
//!                                     .to_string().into()));
//!                 }
//!                 return Some(Ok(Dynamic { name: command.name.to_string() }))
//!             }
//!         }
//!         None
//!     }
//! }
//! ```
//!
//! Programs that are run from an environment such as cargo may find it
//! useful to have positional arguments present in the structure but
//! omitted from the usage output. This can be accomplished by adding
//! the `hidden_help` attribute to that argument:
//!
//! ```rust
//! # use argh::FromArgs;
//!
//! #[derive(FromArgs)]
//! /// Cargo arguments
//! struct CargoArgs {
//!     // Cargo puts the command name invoked into the first argument,
//!     // so we don't want this argument to show up in the usage text.
//!     #[argh(positional, hidden_help)]
//!     command: String,
//!     /// an option used for internal debugging
//!     #[argh(option, hidden_help)]
//!     internal_debugging: String,
//!     #[argh(positional)]
//!     real_first_arg: String,
//! }
//! ```

use std::str::FromStr;

pub use derive::FromArgs;

/// Information about a particular command used for output.
pub type CommandInfo = argh_shared::CommandInfo<'static>;

/// Information about the command including the options and arguments.
pub type CommandInfoWithArgs = argh_shared::CommandInfoWithArgs<'static>;

/// Information about a subcommand.
pub type SubCommandInfo = argh_shared::SubCommandInfo<'static>;

pub use argh_shared::{ErrorCodeInfo, FlagInfo, FlagInfoKind, Optionality, PositionalInfo};

/// Structured information about the command line arguments.
pub trait ArgsInfo {
    /// Returns the argument info.
    fn get_args_info() -> CommandInfoWithArgs;

    /// Returns the list of subcommands
    fn get_subcommands() -> Vec<SubCommandInfo> {
        Self::get_args_info().commands
    }
}

/// Types which can be constructed from a set of commandline arguments.
pub trait FromArgs: Sized {
    /// Construct the type from an input set of arguments.
    ///
    /// The first argument `command_name` is the identifier for the current command. In most cases,
    /// users should only pass in a single item for the command name, which typically comes from
    /// the first item from `std::env::args()`. Implementations however should append the
    /// subcommand name in when recursively calling [FromArgs::from_args] for subcommands. This
    /// allows `argh` to generate correct subcommand help strings.
    ///
    /// The second argument `args` is the rest of the command line arguments.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use argh::FromArgs;
    ///
    /// /// Command to manage a classroom.
    /// #[derive(Debug, PartialEq, FromArgs)]
    /// struct ClassroomCmd {
    ///     #[argh(subcommand)]
    ///     subcommands: Subcommands,
    /// }
    ///
    /// #[derive(Debug, PartialEq, FromArgs)]
    /// #[argh(subcommand)]
    /// enum Subcommands {
    ///     List(ListCmd),
    ///     Add(AddCmd),
    /// }
    ///
    /// /// list all the classes.
    /// #[derive(Debug, PartialEq, FromArgs)]
    /// #[argh(subcommand, name = "list")]
    /// struct ListCmd {
    ///     /// list classes for only this teacher.
    ///     #[argh(option)]
    ///     teacher_name: Option<String>,
    /// }
    ///
    /// /// add students to a class.
    /// #[derive(Debug, PartialEq, FromArgs)]
    /// #[argh(subcommand, name = "add")]
    /// struct AddCmd {
    ///     /// the name of the class's teacher.
    ///     #[argh(option)]
    ///     teacher_name: String,
    ///
    ///     /// the name of the class.
    ///     #[argh(positional)]
    ///     class_name: String,
    /// }
    ///
    /// let args = ClassroomCmd::from_args(
    ///     &["classroom"],
    ///     &["list", "--teacher-name", "Smith"],
    /// ).unwrap();
    /// assert_eq!(
    ///    args,
    ///     ClassroomCmd {
    ///         subcommands: Subcommands::List(ListCmd {
    ///             teacher_name: Some("Smith".to_string()),
    ///         })
    ///     },
    /// );
    ///
    /// // Help returns an error, but internally returns an `Ok` status.
    /// let early_exit = ClassroomCmd::from_args(
    ///     &["classroom"],
    ///     &["help"],
    /// ).unwrap_err();
    /// assert_eq!(
    ///     early_exit,
    ///     argh::EarlyExit {
    ///        output: r#"Usage: classroom <command> [<args>]
    ///
    /// Command to manage a classroom.
    ///
    /// Options:
    ///   --help, help      display usage information
    ///
    /// Commands:
    ///   list              list all the classes.
    ///   add               add students to a class.
    /// "#.to_string(),
    ///        status: Ok(()),
    ///     },
    /// );
    ///
    /// // Help works with subcommands.
    /// let early_exit = ClassroomCmd::from_args(
    ///     &["classroom"],
    ///     &["list", "help"],
    /// ).unwrap_err();
    /// assert_eq!(
    ///     early_exit,
    ///     argh::EarlyExit {
    ///        output: r#"Usage: classroom list [--teacher-name <teacher-name>]
    ///
    /// list all the classes.
    ///
    /// Options:
    ///   --teacher-name    list classes for only this teacher.
    ///   --help, help      display usage information
    /// "#.to_string(),
    ///        status: Ok(()),
    ///     },
    /// );
    ///
    /// // Incorrect arguments will error out.
    /// let err = ClassroomCmd::from_args(
    ///     &["classroom"],
    ///     &["lisp"],
    /// ).unwrap_err();
    /// assert_eq!(
    ///    err,
    ///    argh::EarlyExit {
    ///        output: "Unrecognized argument: lisp\n".to_string(),
    ///        status: Err(()),
    ///     },
    /// );
    /// ```
    fn from_args(command_name: &[&str], args: &[&str]) -> Result<Self, EarlyExit>;
}

/// A top-level `FromArgs` implementation that is not a subcommand.
pub trait TopLevelCommand: FromArgs {}

/// A `FromArgs` implementation that can parse into one or more subcommands.
pub trait SubCommands: FromArgs {
    /// Info for the commands.
    const COMMANDS: &'static [&'static CommandInfo];

    /// Get a list of commands that are discovered at runtime.
    fn dynamic_commands() -> &'static [&'static CommandInfo] {
        &[]
    }
}

/// A `FromArgs` implementation that represents a single subcommand.
pub trait SubCommand: FromArgs {
    /// Information about the subcommand.
    const COMMAND: &'static CommandInfo;
}

impl<T: SubCommand> SubCommands for T {
    const COMMANDS: &'static [&'static CommandInfo] = &[T::COMMAND];
}

/// Trait implemented by values returned from a dynamic subcommand handler.
pub trait DynamicSubCommand: Sized {
    /// Info about supported subcommands.
    fn commands() -> &'static [&'static CommandInfo];

    /// Perform the function of `FromArgs::redact_arg_values` for this dynamic
    /// command.
    ///
    /// The full list of subcommands, ending with the subcommand that should be
    /// dynamically recognized, is passed in `command_name`. If the command
    /// passed is not recognized, this function should return `None`. Otherwise
    /// it should return `Some`, and the value within the `Some` has the same
    /// semantics as the return of `FromArgs::redact_arg_values`.
    fn try_redact_arg_values(
        command_name: &[&str],
        args: &[&str],
    ) -> Option<Result<Vec<String>, EarlyExit>>;

    /// Perform the function of `FromArgs::from_args` for this dynamic command.
    ///
    /// The full list of subcommands, ending with the subcommand that should be
    /// dynamically recognized, is passed in `command_name`. If the command
    /// passed is not recognized, this function should return `None`. Otherwise
    /// it should return `Some`, and the value within the `Some` has the same
    /// semantics as the return of `FromArgs::from_args`.
    fn try_from_args(command_name: &[&str], args: &[&str]) -> Option<Result<Self, EarlyExit>>;
}

/// Information to display to the user about why a `FromArgs` construction exited early.
///
/// This can occur due to either failed parsing or a flag like `--help`.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct EarlyExit {
    /// The output to display to the user of the commandline tool.
    pub output: String,
    /// If the early exit is caused by help triggers.
    pub is_help: bool,
}

impl From<String> for EarlyExit {
    fn from(err_msg: String) -> Self {
        Self {
            output: err_msg,
            is_help: false,
        }
    }
}

/// Types which can be constructed from a single commandline value.
///
/// Any field type declared in a struct that derives `FromArgs` must implement
/// this trait. A blanket implementation exists for types implementing
/// `FromStr<Error: Display>`. Custom types can implement this trait
/// directly.
pub trait FromArgValue: Sized {
    /// Construct the type from a commandline value, returning an error string
    /// on failure.
    fn from_arg_value(value: &str) -> Result<Self, String>;
}

impl<T> FromArgValue for T
where
    T: FromStr,
    T::Err: std::fmt::Display,
{
    fn from_arg_value(value: &str) -> Result<Self, String> {
        T::from_str(value).map_err(|x| x.to_string())
    }
}

// The following items are all used by the generated code, and should not be considered part
// of this library's public API surface.

#[doc(hidden)]
pub trait ParseFlag {
    fn set_flag(&mut self, arg: &str);
}

impl<T: Flag> ParseFlag for T {
    fn set_flag(&mut self, _arg: &str) {
        <T as Flag>::set_flag(self);
    }
}

// A trait for for slots that reserve space for a value and know how to parse that value
// from a command-line `&str` argument.
//
// This trait is only implemented for the type `ParseValueSlotTy`. This indirection is
// necessary to allow abstracting over `ParseValueSlotTy` instances with different
// generic parameters.
#[doc(hidden)]
pub trait ParseValueSlot {
    fn fill_slot(&mut self, arg: &str, value: &str) -> Result<(), String>;
}

// The concrete type implementing the `ParseValueSlot` trait.
//
// `T` is the type to be parsed from a single string.
// `Slot` is the type of the container that can hold a value or values of type `T`.
#[doc(hidden)]
pub struct ParseValueSlotTy<Slot, T> {
    // The slot for a parsed value.
    pub slot: Slot,
    // The function to parse the value from a string
    pub parse_func: fn(&str, &str) -> Result<T, String>,
}

// `ParseValueSlotTy<Option<T>, T>` is used as the slot for all non-repeating
// arguments, both optional and required.
impl<T> ParseValueSlot for ParseValueSlotTy<Option<T>, T> {
    fn fill_slot(&mut self, arg: &str, value: &str) -> Result<(), String> {
        if self.slot.is_some() {
            return Err("duplicate values provided".to_string());
        }
        self.slot = Some((self.parse_func)(arg, value)?);
        Ok(())
    }
}

// `ParseValueSlotTy<Vec<T>, T>` is used as the slot for repeating arguments.
impl<T> ParseValueSlot for ParseValueSlotTy<Vec<T>, T> {
    fn fill_slot(&mut self, arg: &str, value: &str) -> Result<(), String> {
        self.slot.push((self.parse_func)(arg, value)?);
        Ok(())
    }
}

// `ParseValueSlotTy<Option<Vec<T>>, T>` is used as the slot for optional repeating arguments.
impl<T> ParseValueSlot for ParseValueSlotTy<Option<Vec<T>>, T> {
    fn fill_slot(&mut self, arg: &str, value: &str) -> Result<(), String> {
        self.slot
            .get_or_insert_with(Vec::new)
            .push((self.parse_func)(arg, value)?);
        Ok(())
    }
}

/// A type which can be the receiver of a `Flag`.
pub trait Flag {
    /// Creates a default instance of the flag value;
    fn default() -> Self
    where
        Self: Sized;

    /// Sets the flag. This function is called when the flag is provided.
    fn set_flag(&mut self);
}

impl Flag for bool {
    fn default() -> Self {
        false
    }
    fn set_flag(&mut self) {
        *self = true;
    }
}

impl Flag for Option<bool> {
    fn default() -> Self {
        None
    }

    fn set_flag(&mut self) {
        *self = Some(true);
    }
}

macro_rules! impl_flag_for_integers {
    ($($ty:ty,)*) => {
        $(
            impl Flag for $ty {
                fn default() -> Self {
                    0
                }
                fn set_flag(&mut self) {
                    *self = self.saturating_add(1);
                }
            }
        )*
    }
}

impl_flag_for_integers![u8, u16, u32, u64, u128, i8, i16, i32, i64, i128,];

/// This function implements argument parsing for structs.
///
/// `cmd_name`: The identifier for the current command.
/// `args`: The command line arguments.
/// `parse_options`: Helper to parse optional arguments.
/// `parse_positionals`: Helper to parse positional arguments.
/// `parse_subcommand`: Helper to parse a subcommand.
/// `help_func`: Generate a help message.
#[doc(hidden)]
pub fn parse_struct_args(
    cmd_name: &[&str],
    args: &[&str],
    mut parse_options: ParseStructOptions<'_>,
    mut parse_positionals: ParseStructPositionals<'_>,
    mut parse_subcommand: Option<ParseStructSubCommand<'_>>,
) -> Result<(), EarlyExit> {
    let mut help = false;
    let mut remaining_args = args;
    let mut positional_index = 0;
    let mut options_ended = false;

    'parse_args: while let Some(&next_arg) = remaining_args.first() {
        remaining_args = &remaining_args[1..];
        if (parse_options.help_triggers.contains(&next_arg)) && !options_ended {
            help = true;
            continue;
        }

        if next_arg.starts_with('-') && !options_ended {
            if next_arg == "--" {
                options_ended = true;
                continue;
            }

            if help {
                return Err("Trailing arguments are not allowed after `help`."
                    .to_string()
                    .into());
            }

            parse_options.parse(next_arg, &mut remaining_args)?;
            continue;
        }

        if let Some(ref mut parse_subcommand) = parse_subcommand
            && parse_subcommand.parse(help, cmd_name, next_arg, remaining_args)?
        {
            // Unset `help`, since we handled it in the subcommand
            help = false;
            break 'parse_args;
        }

        options_ended |= parse_positionals.parse(&mut positional_index, next_arg)?;
    }

    if help {
        Err(EarlyExit {
            output: String::new(),
            is_help: true,
        })
    } else {
        Ok(())
    }
}

#[doc(hidden)]
pub struct ParseStructOptions<'a> {
    /// A mapping from option string literals to the entry
    /// in the output table. This may contain multiple entries mapping to
    /// the same location in the table if both a short and long version
    /// of the option exist (`-z` and `--zoo`).
    pub arg_to_slot: &'static [(&'static str, usize)],

    /// The storage for argument output data.
    pub slots: &'a mut [ParseStructOption<'a>],

    /// help triggers is a list of strings that trigger printing of help
    pub help_triggers: &'a [&'a str],
}

impl<'a> ParseStructOptions<'a> {
    /// Parse a commandline option.
    ///
    /// `arg`: the current option argument being parsed (e.g. `--foo`).
    /// `remaining_args`: the remaining command line arguments. This slice
    /// will be advanced forwards if the option takes a value argument.
    fn parse(&mut self, arg: &str, remaining_args: &mut &[&str]) -> Result<(), String> {
        let pos = self
            .arg_to_slot
            .iter()
            .find_map(|&(name, pos)| if name == arg { Some(pos) } else { None })
            .ok_or_else(|| unrecognized_argument(arg, self.arg_to_slot, self.help_triggers))?;

        match self.slots[pos] {
            ParseStructOption::Flag(ref mut b) => b.set_flag(arg),
            ParseStructOption::Value(ref mut pvs) => {
                let value = remaining_args
                    .first()
                    .ok_or_else(|| ["No value provided for option '", arg, "'.\n"].concat())?;
                *remaining_args = &remaining_args[1..];
                pvs.fill_slot(arg, value).map_err(|s| {
                    [
                        "Error parsing option '",
                        arg,
                        "' with value '",
                        value,
                        "': ",
                        &s,
                        "\n",
                    ]
                    .concat()
                })?;
            }
        }

        Ok(())
    }
}

fn unrecognized_argument(
    given: &str,
    arg_to_slot: &[(&str, usize)],
    extra_suggestions: &[&str],
) -> String {
    // get the list of available arguments
    let available = arg_to_slot
        .iter()
        .map(|(name, _pos)| *name)
        .chain(extra_suggestions.iter().copied())
        .collect::<Vec<&str>>();

    if available.is_empty() {
        return format!("Unrecognized argument: \"{}\"\n", given);
    }

    ["Unrecognized argument: ", given, "\n"].concat()
}

// `--` or `-` options, including a mutable reference to their value.
#[doc(hidden)]
pub enum ParseStructOption<'a> {
    // A flag which is set to `true` when provided.
    Flag(&'a mut dyn ParseFlag),
    // A value which is parsed from the string following the `--` argument,
    // e.g. `--foo bar`.
    Value(&'a mut dyn ParseValueSlot),
}

#[doc(hidden)]
pub struct ParseStructPositionals<'a> {
    pub positionals: &'a mut [ParseStructPositional<'a>],
    pub last_is_repeating: bool,
    pub last_is_greedy: bool,
}

impl ParseStructPositionals<'_> {
    /// Parse the next positional argument.
    ///
    /// `arg`: the argument supplied by the user.
    ///
    /// Returns true if non-positional argument parsing should stop
    /// after this one.
    fn parse(&mut self, index: &mut usize, arg: &str) -> Result<bool, EarlyExit> {
        if *index < self.positionals.len() {
            self.positionals[*index].parse(arg)?;

            if self.last_is_repeating && *index == self.positionals.len() - 1 {
                // Don't increment position if we're at the last arg
                // *and* the last arg is repeating. If it's also remainder,
                // halt non-option processing after this.
                Ok(self.last_is_greedy)
            } else {
                // If it is repeating, though, increment the index and continue
                // processing options.
                *index += 1;
                Ok(false)
            }
        } else {
            Err(EarlyExit {
                output: unrecognized_arg(arg),
                is_help: false,
            })
        }
    }
}

#[doc(hidden)]
pub struct ParseStructPositional<'a> {
    // The positional's name
    pub name: &'static str,

    // The function to parse the positional.
    pub slot: &'a mut dyn ParseValueSlot,
}

impl ParseStructPositional<'_> {
    /// Parse a positional argument.
    ///
    /// `arg`: the argument supplied by the user.
    fn parse(&mut self, arg: &str) -> Result<(), EarlyExit> {
        self.slot.fill_slot("", arg).map_err(|s| {
            [
                "Error parsing positional argument '",
                self.name,
                "' with value '",
                arg,
                "': ",
                &s,
                "\n",
            ]
            .concat()
            .into()
        })
    }
}

// A type to simplify parsing struct subcommands.
//
// This indirection is necessary to allow abstracting over `FromArgs` instances with different
// generic parameters.
#[doc(hidden)]
pub struct ParseStructSubCommand<'a> {
    // The subcommand commands
    pub subcommands: &'static [&'static CommandInfo],

    pub dynamic_subcommands: &'a [&'static CommandInfo],

    // The function to parse the subcommand arguments.
    #[allow(clippy::type_complexity)]
    pub parse_func: &'a mut dyn FnMut(&[&str], &[&str]) -> Result<(), EarlyExit>,
}

impl ParseStructSubCommand<'_> {
    fn parse(
        &mut self,
        help: bool,
        cmd_name: &[&str],
        arg: &str,
        remaining_args: &[&str],
    ) -> Result<bool, EarlyExit> {
        for subcommand in self
            .subcommands
            .iter()
            .chain(self.dynamic_subcommands.iter())
        {
            if subcommand.name == arg {
                let mut command = cmd_name.to_owned();
                command.push(subcommand.name);
                let prepended_help;
                let remaining_args = if help {
                    prepended_help = prepend_help(remaining_args);
                    &prepended_help
                } else {
                    remaining_args
                };

                (self.parse_func)(&command, remaining_args)?;

                return Ok(true);
            }
        }

        Ok(false)
    }
}

// Prepend `help` to a list of arguments.
// This is used to pass the `help` argument on to subcommands.
fn prepend_help<'a>(args: &[&'a str]) -> Vec<&'a str> {
    [&["help"], args].concat()
}

#[doc(hidden)]
pub fn print_subcommands<'a>(commands: impl Iterator<Item = &'a CommandInfo>) -> String {
    let mut out = String::new();
    for cmd in commands {
        argh_shared::write_description(&mut out, cmd);
    }
    out
}

fn unrecognized_arg(arg: &str) -> String {
    ["Unrecognized argument: ", arg, "\n"].concat()
}

// An error string builder to report missing required options and subcommands.
#[doc(hidden)]
#[derive(Default)]
pub struct MissingRequirements {
    options: Vec<&'static str>,
    subcommands: Option<Vec<&'static CommandInfo>>,
    positional_args: Vec<&'static str>,
}

const NEWLINE_INDENT: &str = "\n    ";

impl MissingRequirements {
    // Add a missing required option.
    #[doc(hidden)]
    pub fn missing_option(&mut self, name: &'static str) {
        self.options.push(name)
    }

    // Add a missing required subcommand.
    #[doc(hidden)]
    pub fn missing_subcommands(&mut self, commands: impl Iterator<Item = &'static CommandInfo>) {
        self.subcommands = Some(commands.collect());
    }

    // Add a missing positional argument.
    #[doc(hidden)]
    pub fn missing_positional_arg(&mut self, name: &'static str) {
        self.positional_args.push(name)
    }

    // If any missing options or subcommands were provided, returns an error string
    // describing the missing args.
    #[doc(hidden)]
    pub fn err_on_any(&self) -> Result<(), String> {
        if self.options.is_empty() && self.subcommands.is_none() && self.positional_args.is_empty()
        {
            return Ok(());
        }

        let mut output = String::new();

        if !self.positional_args.is_empty() {
            output.push_str("Required positional arguments not provided:");
            for arg in &self.positional_args {
                output.push_str(NEWLINE_INDENT);
                output.push_str(arg);
            }
        }

        if !self.options.is_empty() {
            if !self.positional_args.is_empty() {
                output.push('\n');
            }
            output.push_str("Required options not provided:");
            for option in &self.options {
                output.push_str(NEWLINE_INDENT);
                output.push_str(option);
            }
        }

        if let Some(missing_subcommands) = &self.subcommands {
            if !self.options.is_empty() {
                output.push('\n');
            }
            output.push_str("One of the following subcommands must be present:");
            output.push_str(NEWLINE_INDENT);
            output.push_str("help");
            for subcommand in missing_subcommands {
                output.push_str(NEWLINE_INDENT);
                output.push_str(subcommand.name);
            }
        }

        output.push('\n');

        Err(output)
    }
}

mod argh_shared {
    //! Shared functionality between argh_derive and the argh runtime.
    //!
    //! This library is intended only for internal use by these two crates.

    /// Information about a particular command used for output.
    pub struct CommandInfo<'a> {
        /// The name of the command.
        pub name: &'a str,
        /// A short description of the command's functionality.
        pub description: &'a str,
    }

    /// Information about the command line arguments for a given command.
    #[derive(Debug, Default, PartialEq, Eq, Clone)]
    pub struct CommandInfoWithArgs<'a> {
        /// The name of the command.
        pub name: &'a str,
        /// A short description of the command's functionality.
        pub description: &'a str,
        /// Examples of usage
        pub examples: &'a [&'a str],
        /// Flags
        pub flags: &'a [FlagInfo<'a>],
        /// Notes about usage
        pub notes: &'a [&'a str],
        /// The subcommands.
        pub commands: Vec<SubCommandInfo<'a>>,
        /// Positional args
        pub positionals: &'a [PositionalInfo<'a>],
        /// Error code information
        pub error_codes: &'a [ErrorCodeInfo<'a>],
    }

    /// Information about a documented error code.
    #[derive(Debug, PartialEq, Eq)]
    pub struct ErrorCodeInfo<'a> {
        /// The code value.
        pub code: i32,
        /// Short description about what this code indicates.
        pub description: &'a str,
    }

    /// Information about positional arguments
    #[derive(Debug, PartialEq, Eq)]
    pub struct PositionalInfo<'a> {
        /// Name of the argument.
        pub name: &'a str,
        /// Description of the argument.
        pub description: &'a str,
        /// Optionality of the argument.
        pub optionality: Optionality,
        /// Visibility in the help for this argument.
        /// `false` indicates this argument will not appear
        /// in the help message.
        pub hidden: bool,
    }

    /// Information about a subcommand.
    /// Dynamic subcommands do not implement
    /// get_args_info(), so the command field
    /// only contains the name and description.
    #[derive(Debug, Default, PartialEq, Eq, Clone)]
    pub struct SubCommandInfo<'a> {
        /// The subcommand name.
        pub name: &'a str,
        /// The information about the subcommand.
        pub command: CommandInfoWithArgs<'a>,
    }

    /// Information about a flag or option.
    #[derive(Debug, Default, PartialEq, Eq)]
    pub struct FlagInfo<'a> {
        /// The kind of flag.
        pub kind: FlagInfoKind<'a>,
        /// The optionality of the flag.
        pub optionality: Optionality,
        /// The long string of the flag.
        pub long: &'a str,
        /// The single character short indicator
        /// for this flag.
        pub short: Option<char>,
        /// The description of the flag.
        pub description: &'a str,
        /// Visibility in the help for this argument.
        /// `false` indicates this argument will not appear
        /// in the help message.
        pub hidden: bool,
    }

    /// The kind of flags.
    #[derive(Debug, Default, PartialEq, Eq)]
    pub enum FlagInfoKind<'a> {
        /// switch represents a boolean flag,
        #[default]
        Switch,
        /// option is a flag that also has an associated
        /// value. This value is named `arg_name`.
        Option { arg_name: &'a str },
    }

    /// The optionality defines the requirements related
    /// to the presence of the argument on the command line.
    #[derive(Debug, Default, PartialEq, Eq)]
    pub enum Optionality {
        /// Required indicates the argument is required
        /// exactly once.
        #[default]
        Required,
        /// Optional indicates the argument may or may not
        /// be present.
        Optional,
        /// Repeating indicates the argument may appear zero
        /// or more times.
        Repeating,
        /// Greedy is used for positional arguments which
        /// capture the all command line input up to the next flag or
        /// the end of the input.
        Greedy,
    }

    pub const INDENT: &str = "  ";
    const DESCRIPTION_INDENT: usize = 20;
    const WRAP_WIDTH: usize = 80;

    /// Write command names and descriptions to an output string.
    pub fn write_description(out: &mut String, cmd: &CommandInfo<'_>) {
        let mut current_line = INDENT.to_string();
        current_line.push_str(cmd.name);

        if cmd.description.is_empty() {
            new_line(&mut current_line, out);
            return;
        }

        if !indent_description(&mut current_line) {
            // Start the description on a new line if the flag names already
            // add up to more than DESCRIPTION_INDENT.
            new_line(&mut current_line, out);
        }

        let mut words = cmd.description.split(' ').peekable();
        while let Some(first_word) = words.next() {
            indent_description(&mut current_line);
            current_line.push_str(first_word);

            'inner: while let Some(&word) = words.peek() {
                if (char_len(&current_line) + char_len(word) + 1) > WRAP_WIDTH {
                    new_line(&mut current_line, out);
                    break 'inner;
                } else {
                    // advance the iterator
                    let _ = words.next();
                    current_line.push(' ');
                    current_line.push_str(word);
                }
            }
        }
        new_line(&mut current_line, out);
    }

    // Indent the current line in to DESCRIPTION_INDENT chars.
    // Returns a boolean indicating whether or not spacing was added.
    fn indent_description(line: &mut String) -> bool {
        let cur_len = char_len(line);
        if cur_len < DESCRIPTION_INDENT {
            let num_spaces = DESCRIPTION_INDENT - cur_len;
            line.extend(std::iter::repeat_n(' ', num_spaces));
            true
        } else {
            false
        }
    }

    fn char_len(s: &str) -> usize {
        s.chars().count()
    }

    // Append a newline and the current line to the output,
    // clearing the current line.
    fn new_line(current_line: &mut String, out: &mut String) {
        out.push('\n');
        out.push_str(current_line);
        current_line.truncate(0);
    }
}

```

`native/src/base/base.cpp`:

```cpp
#include <sys/wait.h>
#include <sys/prctl.h>
#include <sys/mman.h>
#include <android/log.h>
#include <linux/fs.h>
#include <syscall.h>

#include <base.hpp>
#include <flags.h>

using namespace std;

#ifndef __call_bypassing_fortify
#define __call_bypassing_fortify(fn) (&fn)
#endif

#ifdef __LP64__
static_assert(BLKGETSIZE64 == 0x80081272);
#else
static_assert(BLKGETSIZE64 == 0x80041272);
#endif

// Override libc++ new implementation to optimize final build size

void* operator new(std::size_t s) { return std::malloc(s); }
void* operator new[](std::size_t s) { return std::malloc(s); }
void  operator delete(void *p) { std::free(p); }
void  operator delete[](void *p) { std::free(p); }
void* operator new(std::size_t s, const std::nothrow_t&) noexcept { return std::malloc(s); }
void* operator new[](std::size_t s, const std::nothrow_t&) noexcept { return std::malloc(s); }
void  operator delete(void *p, const std::nothrow_t&) noexcept { std::free(p); }
void  operator delete[](void *p, const std::nothrow_t&) noexcept { std::free(p); }

rust::Vec<size_t> byte_data::patch(byte_view from, byte_view to) const {
    rust::Vec<size_t> v;
    if (ptr == nullptr)
        return v;
    auto p = ptr;
    auto eof = ptr + sz;
    while (p < eof) {
        p = static_cast<uint8_t *>(memmem(p, eof - p, from.data(), from.size()));
        if (p == nullptr)
            return v;
        memset(p, 0, from.size());
        memcpy(p, to.data(), to.size());
        v.push_back(p - ptr);
        p += from.size();
    }
    return v;
}

rust::Vec<size_t> mut_u8_patch(MutByteSlice buf, ByteSlice from, ByteSlice to) {
    byte_data data(buf);
    return data.patch(from, to);
}

int fork_dont_care() {
    if (int pid = xfork()) {
        waitpid(pid, nullptr, 0);
        return pid;
    } else if (xfork()) {
        exit(0);
    }
    return 0;
}

int fork_no_orphan() {
    int pid = xfork();
    if (pid)
        return pid;
    prctl(PR_SET_PDEATHSIG, SIGKILL);
    if (getppid() == 1)
        exit(1);
    return 0;
}

int exec_command(exec_t &exec) {
    auto pipefd = array<int, 2>{-1, -1};
    int outfd = -1;

    if (exec.fd == -1) {
        if (xpipe2(pipefd, O_CLOEXEC) == -1)
            return -1;
        outfd = pipefd[1];
    } else if (exec.fd >= 0) {
        outfd = exec.fd;
    }

    int pid = exec.fork();
    if (pid < 0) {
        close(pipefd[0]);
        close(pipefd[1]);
        return -1;
    } else if (pid) {
        if (exec.fd == -1) {
            exec.fd = pipefd[0];
            close(pipefd[1]);
        }
        return pid;
    }

    // Unblock all signals
    sigset_t set;
    sigfillset(&set);
    pthread_sigmask(SIG_UNBLOCK, &set, nullptr);

    if (outfd >= 0) {
        xdup2(outfd, STDOUT_FILENO);
        if (exec.err)
            xdup2(outfd, STDERR_FILENO);
        close(outfd);
    }

    // Call the pre-exec callback
    if (exec.pre_exec)
        exec.pre_exec();

    execve(exec.argv[0], (char **) exec.argv, environ);
    PLOGE("execve %s", exec.argv[0]);
    exit(-1);
}

int exec_command_sync(exec_t &exec) {
    int pid = exec_command(exec);
    if (pid < 0)
        return -1;
    int status;
    waitpid(pid, &status, 0);
    return WEXITSTATUS(status);
}

int new_daemon_thread(thread_entry entry, void *arg) {
    pthread_t thread;
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    errno = pthread_create(&thread, &attr, entry, arg);
    if (errno) {
        PLOGE("pthread_create");
    }
    return errno;
}

static char *argv0;
static size_t name_len;
void init_argv0(int argc, char **argv) {
    argv0 = argv[0];
    name_len = (argv[argc - 1] - argv[0]) + strlen(argv[argc - 1]) + 1;
}

void set_nice_name(Utf8CStr name) {
    memset(argv0, 0, name_len);
    strscpy(argv0, name.c_str(), name_len);
    prctl(PR_SET_NAME, name.c_str());
}

template<typename T, int base>
static T parse_num(string_view s) {
    T val = 0;
    for (char c : s) {
        if (isdigit(c)) {
            c -= '0';
        } else if (base > 10 && isalpha(c)) {
            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
        } else {
            return -1;
        }
        if (c >= base) {
            return -1;
        }
        val *= base;
        val += c;
    }
    return val;
}

/*
 * Bionic's atoi runs through strtol().
 * Use our own implementation for faster conversion.
 */
int parse_int(string_view s) {
    return parse_num<int, 10>(s);
}

uint32_t parse_uint32_hex(string_view s) {
    return parse_num<uint32_t, 16>(s);
}

int switch_mnt_ns(int pid) {
    int ret = -1;
    int fd = syscall(__NR_pidfd_open, pid, 0);
    if (fd > 0) {
        ret = setns(fd, CLONE_NEWNS);
        close(fd);
    }
    if (ret < 0) {
        char mnt[32];
        ssprintf(mnt, sizeof(mnt), "/proc/%d/ns/mnt", pid);
        fd = open(mnt, O_RDONLY);
        if (fd < 0) return 1; // Maybe process died..

        // Switch to its namespace
        ret = xsetns(fd, 0);
        close(fd);
    }
    return ret;
}

string &replace_all(string &str, string_view from, string_view to) {
    size_t pos = 0;
    while((pos = str.find(from, pos)) != string::npos) {
        str.replace(pos, from.length(), to);
        pos += to.length();
    }
    return str;
}

template <typename T>
static auto split_impl(string_view s, string_view delims) {
    vector<T> result;
    size_t base = 0;
    size_t found;
    while (true) {
        found = s.find_first_of(delims, base);
        result.emplace_back(s.substr(base, found - base));
        if (found == string::npos)
            break;
        base = found + 1;
    }
    return result;
}

vector<string> split(string_view s, string_view delims) {
    return split_impl<string>(s, delims);
}

#undef vsnprintf
int vssprintf(char *dest, size_t size, const char *fmt, va_list ap) {
    if (size > 0) {
        *dest = 0;
        return std::min(vsnprintf(dest, size, fmt, ap), (int) size - 1);
    }
    return -1;
}

int ssprintf(char *dest, size_t size, const char *fmt, ...) {
    va_list va;
    va_start(va, fmt);
    int r = vssprintf(dest, size, fmt, va);
    va_end(va);
    return r;
}

#undef strlcpy
size_t strscpy(char *dest, const char *src, size_t size) {
    return std::min(strlcpy(dest, src, size), size - 1);
}

#undef vsnprintf
static int fmt_and_log_with_rs(LogLevel level, const char *fmt, va_list ap) {
    constexpr int sz = 4096;
    char buf[sz];
    buf[0] = '\0';
    // Fortify logs when a fatal error occurs. Do not run through fortify again
    int len = std::min(__call_bypassing_fortify(vsnprintf)(buf, sz, fmt, ap), sz - 1);
    log_with_rs(level, Utf8CStr(buf, len + 1));
    return len;
}

// Used to override external C library logging
extern "C" int magisk_log_print(int prio, const char *tag, const char *fmt, ...) {
    LogLevel level;
    switch (prio) {
    case ANDROID_LOG_DEBUG:
        level = LogLevel::Debug;
        break;
    case ANDROID_LOG_INFO:
        level = LogLevel::Info;
        break;
    case ANDROID_LOG_WARN:
        level = LogLevel::Warn;
        break;
    case ANDROID_LOG_ERROR:
        level = LogLevel::Error;
        break;
    default:
        return 0;
    }

    char fmt_buf[4096];
    auto len = strscpy(fmt_buf, tag, sizeof(fmt_buf) - 1);
    // Prevent format specifications in the tag
    std::replace(fmt_buf, fmt_buf + len, '%', '_');
    len = ssprintf(fmt_buf + len, sizeof(fmt_buf) - len - 1, ": %s", fmt) + len;
    // Ensure the fmt string always ends with newline
    if (fmt_buf[len - 1] != '\n') {
        fmt_buf[len] = '\n';
        fmt_buf[len + 1] = '\0';
    }
    va_list argv;
    va_start(argv, fmt);
    int ret = fmt_and_log_with_rs(level, fmt_buf, argv);
    va_end(argv);
    return ret;
}

#define LOG_BODY(level)   \
    va_list argv;         \
    va_start(argv, fmt);  \
    fmt_and_log_with_rs(LogLevel::level, fmt, argv); \
    va_end(argv);         \

// LTO will optimize out the NOP function
#if MAGISK_DEBUG
void LOGD(const char *fmt, ...) { LOG_BODY(Debug) }
#else
void LOGD(const char *fmt, ...) {}
#endif
void LOGI(const char *fmt, ...) { LOG_BODY(Info) }
void LOGW(const char *fmt, ...) { LOG_BODY(Warn) }
void LOGE(const char *fmt, ...) { LOG_BODY(Error) }

// Export raw symbol to fortify compat
extern "C" void __vloge(const char* fmt, va_list ap) {
    fmt_and_log_with_rs(LogLevel::Error, fmt, ap);
}

string full_read(int fd) {
    string str;
    char buf[4096];
    for (ssize_t len; (len = xread(fd, buf, sizeof(buf))) > 0;)
        str.insert(str.end(), buf, buf + len);
    return str;
}

string full_read(const char *filename) {
    string str;
    if (int fd = xopen(filename, O_RDONLY | O_CLOEXEC); fd >= 0) {
        str = full_read(fd);
        close(fd);
    }
    return str;
}

void write_zero(int fd, size_t size) {
    char buf[4096] = {0};
    size_t len;
    while (size > 0) {
        len = sizeof(buf) > size ? size : sizeof(buf);
        write(fd, buf, len);
        size -= len;
    }
}

sDIR make_dir(DIR *dp) {
    return sDIR(dp, [](DIR *dp){ return dp ? closedir(dp) : 1; });
}

sFILE make_file(FILE *fp) {
    return sFILE(fp, [](FILE *fp){ return fp ? fclose(fp) : 1; });
}

mmap_data::mmap_data(const char *name, bool rw) {
    auto slice = rust::map_file(name, rw);
    if (!slice.empty()) {
        this->ptr = slice.data();
        this->sz = slice.size();
    }
}

mmap_data::mmap_data(int dirfd, const char *name, bool rw) {
    auto slice = rust::map_file_at(dirfd, name, rw);
    if (!slice.empty()) {
        this->ptr = slice.data();
        this->sz = slice.size();
    }
}

mmap_data::mmap_data(int fd, size_t sz, bool rw) {
    auto slice = rust::map_fd(fd, sz, rw);
    if (!slice.empty()) {
        this->ptr = slice.data();
        this->sz = slice.size();
    }
}

mmap_data::~mmap_data() {
    if (ptr) munmap(ptr, sz);
}

void mmap_data::swap(mmap_data &o) {
    std::swap(ptr, o.ptr);
    std::swap(sz, o.sz);
}

string resolve_preinit_dir(const char *base_dir) {
    string dir = base_dir;
    if (access((dir + "/unencrypted").data(), F_OK) == 0) {
        dir += "/unencrypted/magisk";
    } else if (access((dir + "/adb").data(), F_OK) == 0) {
        dir += "/adb";
    } else if (access((dir + "/watchdog").data(), F_OK) == 0) {
        dir += "/watchdog/magisk";
    } else {
        dir += "/magisk";
    }
    return dir;
}

// FFI for Utf8CStr

extern "C" void cxx$utf8str$new(Utf8CStr *self, const void *s, size_t len);
extern "C" const char *cxx$utf8str$ptr(const Utf8CStr *self);
extern "C" size_t cxx$utf8str$len(const Utf8CStr *self);

Utf8CStr::Utf8CStr(const char *s, size_t len) : repr{} {
    cxx$utf8str$new(this, s, len);
}

const char *Utf8CStr::data() const {
    return cxx$utf8str$ptr(this);
}

size_t Utf8CStr::length() const {
    return cxx$utf8str$len(this);
}

```

`native/src/base/build.rs`:

```rs
use crate::codegen::gen_cxx_binding;

#[path = "../include/codegen.rs"]
mod codegen;

fn main() {
    gen_cxx_binding("base-rs");
}

```

`native/src/base/cstr.rs`:

```rs
use cxx::{ExternType, type_id};
use libc::c_char;
use nix::NixPath;
use std::borrow::Borrow;
use std::cmp::{Ordering, min};
use std::ffi::{CStr, FromBytesUntilNulError, FromBytesWithNulError, OsStr};
use std::fmt::{Debug, Display, Formatter, Write};
use std::ops::Deref;
use std::os::unix::ffi::OsStrExt;
use std::path::{Path, PathBuf};
use std::str::{FromStr, Utf8Error};
use std::{fmt, mem, slice, str};
use thiserror::Error;

use crate::slice_from_ptr_mut;

// Utf8CStr types are UTF-8 validated and null terminated strings.
//
// Several Utf8CStr types:
//
// Utf8CStr: can only exist as reference, similar to &str
// Utf8CString: dynamically sized buffer allocated on the heap, similar to String
// Utf8CStrBufRef: reference to a fixed sized buffer
// Utf8CStrBufArr<N>: fixed sized buffer allocated on the stack
//
// For easier usage, please use the helper functions in cstr::buf.
//
// In most cases, these are the types being used
//
// &Utf8CStr: whenever a printable null terminated string is needed
// &mut dyn Utf8CStrBuf: whenever we need a buffer that needs to support appending
//                       strings to the end, and has to be null terminated
// &mut dyn Utf8CStrBuf: whenever we need a pre-allocated buffer that is large enough to fit
//                       in the result, and has to be null terminated
//
// All types dereferences to &Utf8CStr.
// Utf8CString, Utf8CStrBufRef, and Utf8CStrBufArr<N> implements Utf8CStrBuf.

// Public helper functions

pub mod buf {
    use super::{Utf8CStrBufArr, Utf8CStrBufRef, Utf8CString};

    #[inline(always)]
    pub fn dynamic(capacity: usize) -> Utf8CString {
        Utf8CString::with_capacity(capacity)
    }

    #[inline(always)]
    pub fn default() -> Utf8CStrBufArr<4096> {
        Utf8CStrBufArr::default()
    }

    #[inline(always)]
    pub fn new<const N: usize>() -> Utf8CStrBufArr<N> {
        Utf8CStrBufArr::new()
    }

    #[inline(always)]
    pub fn wrap(buf: &mut [u8]) -> Utf8CStrBufRef<'_> {
        Utf8CStrBufRef::from(buf)
    }

    #[inline(always)]
    pub unsafe fn wrap_ptr<'a>(buf: *mut u8, len: usize) -> Utf8CStrBufRef<'a> {
        unsafe { Utf8CStrBufRef::from_ptr(buf, len) }
    }
}

// Trait definitions

pub trait Utf8CStrBuf: Display + Write + AsRef<Utf8CStr> + Deref<Target = Utf8CStr> {
    // The length of the string without the terminating null character.
    // assert_true(len <= capacity - 1)
    fn len(&self) -> usize;
    fn push_str(&mut self, s: &str) -> usize;
    // The capacity of the internal buffer. The maximum string length this buffer can contain
    // is capacity - 1, because the last byte is reserved for the terminating null character.
    fn capacity(&self) -> usize;
    fn clear(&mut self);
    fn as_mut_ptr(&mut self) -> *mut c_char;
    fn truncate(&mut self, new_len: usize);
    // Rebuild the Utf8CStr based on the contents of the internal buffer. Required after any
    // unsafe modifications directly though the pointer obtained from self.as_mut_ptr().
    // If an error is returned, the internal buffer will be reset, resulting in an empty string.
    fn rebuild(&mut self) -> Result<(), StrErr>;

    #[inline(always)]
    fn is_empty(&self) -> bool {
        self.len() == 0
    }
}

pub trait StringExt {
    fn nul_terminate(&mut self) -> &mut [u8];
}

impl StringExt for String {
    fn nul_terminate(&mut self) -> &mut [u8] {
        self.reserve(1);
        // SAFETY: the string is reserved to have enough capacity to fit in the null byte
        // SAFETY: the null byte is explicitly added outside the string's length
        unsafe {
            let buf = slice::from_raw_parts_mut(self.as_mut_ptr(), self.len() + 1);
            *buf.get_unchecked_mut(self.len()) = b'\0';
            buf
        }
    }
}

impl StringExt for PathBuf {
    #[allow(mutable_transmutes)]
    fn nul_terminate(&mut self) -> &mut [u8] {
        self.reserve(1);
        // SAFETY: the PathBuf is reserved to have enough capacity to fit in the null byte
        // SAFETY: the null byte is explicitly added outside the PathBuf's length
        unsafe {
            let bytes: &mut [u8] = mem::transmute(self.as_mut_os_str().as_bytes());
            let buf = slice::from_raw_parts_mut(bytes.as_mut_ptr(), bytes.len() + 1);
            *buf.get_unchecked_mut(bytes.len()) = b'\0';
            buf
        }
    }
}

pub struct Utf8CString(String);

impl Default for Utf8CString {
    fn default() -> Self {
        Utf8CString::with_capacity(256)
    }
}

impl Utf8CString {
    pub fn with_capacity(capacity: usize) -> Utf8CString {
        Utf8CString::from(String::with_capacity(capacity))
    }

    pub fn ensure_capacity(&mut self, capacity: usize) {
        if self.capacity() >= capacity {
            return;
        }
        self.0.reserve(capacity - self.0.len())
    }
}

impl AsRef<Utf8CStr> for Utf8CString {
    #[inline(always)]
    fn as_ref(&self) -> &Utf8CStr {
        // SAFETY: the internal string is always null terminated
        unsafe { mem::transmute(slice::from_raw_parts(self.0.as_ptr(), self.0.len() + 1)) }
    }
}

impl Utf8CStrBuf for Utf8CString {
    #[inline(always)]
    fn len(&self) -> usize {
        self.0.len()
    }

    fn push_str(&mut self, s: &str) -> usize {
        self.0.push_str(s);
        self.0.nul_terminate();
        s.len()
    }

    fn capacity(&self) -> usize {
        self.0.capacity()
    }

    fn clear(&mut self) {
        self.0.clear();
        self.0.nul_terminate();
    }

    fn as_mut_ptr(&mut self) -> *mut c_char {
        self.0.as_mut_ptr().cast()
    }

    fn truncate(&mut self, new_len: usize) {
        self.0.truncate(new_len);
        self.0.nul_terminate();
    }

    fn rebuild(&mut self) -> Result<(), StrErr> {
        // Temporarily move the internal String out
        let mut tmp = String::new();
        mem::swap(&mut tmp, &mut self.0);
        let (ptr, _, capacity) = tmp.into_raw_parts();

        unsafe {
            // Validate the entire buffer, including the unused part
            let bytes = slice::from_raw_parts(ptr, capacity);
            match Utf8CStr::from_bytes_until_nul(bytes) {
                Ok(s) => {
                    // Move the String with the new length back
                    self.0 = String::from_raw_parts(ptr, s.len(), capacity);
                }
                Err(e) => {
                    // Move the String with 0 length back
                    self.0 = String::from_raw_parts(ptr, 0, capacity);
                    self.0.nul_terminate();
                    return Err(e);
                }
            }
        }

        Ok(())
    }
}

impl From<String> for Utf8CString {
    fn from(mut value: String) -> Self {
        value.nul_terminate();
        Utf8CString(value)
    }
}

impl From<&str> for Utf8CString {
    fn from(value: &str) -> Self {
        let mut s = String::with_capacity(value.len() + 1);
        s.push_str(value);
        s.nul_terminate();
        Utf8CString(s)
    }
}

impl FromStr for Utf8CString {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(s.into())
    }
}

impl Borrow<Utf8CStr> for Utf8CString {
    fn borrow(&self) -> &Utf8CStr {
        self.deref()
    }
}

// UTF-8 validated + null terminated reference to buffer
pub struct Utf8CStrBufRef<'a> {
    used: usize,
    buf: &'a mut [u8],
}

impl<'a> Utf8CStrBufRef<'a> {
    pub unsafe fn from_ptr(buf: *mut u8, len: usize) -> Utf8CStrBufRef<'a> {
        unsafe { Self::from(slice_from_ptr_mut(buf, len)) }
    }
}

impl<'a> From<&'a mut [u8]> for Utf8CStrBufRef<'a> {
    fn from(buf: &'a mut [u8]) -> Utf8CStrBufRef<'a> {
        buf[0] = b'\0';
        Utf8CStrBufRef { used: 0, buf }
    }
}

// UTF-8 validated + null terminated buffer on the stack
pub struct Utf8CStrBufArr<const N: usize> {
    used: usize,
    buf: [u8; N],
}

impl<const N: usize> Utf8CStrBufArr<N> {
    pub fn new() -> Self {
        Utf8CStrBufArr {
            used: 0,
            buf: [0; N],
        }
    }
}

impl Default for Utf8CStrBufArr<4096> {
    fn default() -> Self {
        Utf8CStrBufArr::<4096>::new()
    }
}

#[derive(Debug, Error)]
pub enum StrErr {
    #[error(transparent)]
    Utf8Error(#[from] Utf8Error),
    #[error(transparent)]
    CStrWithNullError(#[from] FromBytesWithNulError),
    #[error(transparent)]
    CStrUntilNullError(#[from] FromBytesUntilNulError),
    #[error("argument is null")]
    NullPointerError,
}

// UTF-8 validated + null terminated string slice
#[repr(transparent)]
pub struct Utf8CStr([u8]);

impl Utf8CStr {
    pub fn from_cstr(cstr: &CStr) -> Result<&Utf8CStr, StrErr> {
        // Validate the buffer during construction
        str::from_utf8(cstr.to_bytes())?;
        Ok(unsafe { Self::from_bytes_unchecked(cstr.to_bytes_with_nul()) })
    }

    fn from_bytes_until_nul(bytes: &[u8]) -> Result<&Utf8CStr, StrErr> {
        Self::from_cstr(CStr::from_bytes_until_nul(bytes)?)
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<&Utf8CStr, StrErr> {
        Self::from_cstr(CStr::from_bytes_with_nul(bytes)?)
    }

    pub fn from_string(s: &mut String) -> &Utf8CStr {
        let buf = s.nul_terminate();
        // SAFETY: the null byte is explicitly added to the buffer
        unsafe { mem::transmute(buf) }
    }

    #[inline(always)]
    pub const unsafe fn from_bytes_unchecked(bytes: &[u8]) -> &Utf8CStr {
        unsafe { mem::transmute(bytes) }
    }

    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> Result<&'a Utf8CStr, StrErr> {
        if ptr.is_null() {
            return Err(StrErr::NullPointerError);
        }
        Self::from_cstr(unsafe { CStr::from_ptr(ptr) })
    }

    pub unsafe fn from_ptr_unchecked<'a>(ptr: *const c_char) -> &'a Utf8CStr {
        unsafe {
            let cstr = CStr::from_ptr(ptr);
            Self::from_bytes_unchecked(cstr.to_bytes_with_nul())
        }
    }

    pub unsafe fn from_raw_parts<'a>(ptr: *const c_char, len: usize) -> &'a Utf8CStr {
        unsafe {
            let bytes = slice::from_raw_parts(ptr.cast(), len);
            Self::from_bytes_unchecked(bytes)
        }
    }

    #[inline(always)]
    pub fn as_bytes_with_nul(&self) -> &[u8] {
        &self.0
    }

    #[inline(always)]
    pub fn as_ptr(&self) -> *const c_char {
        self.0.as_ptr().cast()
    }

    #[inline(always)]
    pub fn as_cstr(&self) -> &CStr {
        // SAFETY: Already validated as null terminated during construction
        unsafe { CStr::from_bytes_with_nul_unchecked(&self.0) }
    }

    #[inline(always)]
    pub fn as_utf8_cstr(&self) -> &Utf8CStr {
        self
    }

    #[inline(always)]
    pub fn as_str(&self) -> &str {
        // SAFETY: Already UTF-8 validated during construction
        // SAFETY: The length of the slice is at least 1 due to null termination check
        unsafe { str::from_utf8_unchecked(self.0.get_unchecked(..self.0.len() - 1)) }
    }
}

impl Deref for Utf8CStr {
    type Target = str;

    #[inline(always)]
    fn deref(&self) -> &str {
        self.as_str()
    }
}

impl ToOwned for Utf8CStr {
    type Owned = Utf8CString;

    fn to_owned(&self) -> Utf8CString {
        let mut s = Utf8CString::with_capacity(self.len() + 1);
        s.push_str(self.as_str());
        s
    }
}

impl AsRef<Utf8CStr> for Utf8CStr {
    fn as_ref(&self) -> &Utf8CStr {
        self
    }
}

impl NixPath for Utf8CStr {
    #[inline(always)]
    fn is_empty(&self) -> bool {
        self.as_str().is_empty()
    }

    #[inline(always)]
    fn len(&self) -> usize {
        self.as_str().len()
    }

    #[inline(always)]
    fn with_nix_path<T, F>(&self, f: F) -> nix::Result<T>
    where
        F: FnOnce(&CStr) -> T,
    {
        Ok(f(self.as_cstr()))
    }
}

// Notice that we only implement ExternType on Utf8CStr *reference*
unsafe impl ExternType for &Utf8CStr {
    type Id = type_id!("Utf8CStr");
    type Kind = cxx::kind::Trivial;
}

macro_rules! const_assert_eq {
    ($left:expr, $right:expr $(,)?) => {
        const _: [(); $left] = [(); $right];
    };
}

// Assert ABI layout
const_assert_eq!(size_of::<&Utf8CStr>(), size_of::<[usize; 2]>());
const_assert_eq!(align_of::<&Utf8CStr>(), align_of::<[usize; 2]>());

// File system path extensions types

#[repr(transparent)]
pub struct FsPathFollow(Utf8CStr);

impl AsRef<Utf8CStr> for FsPathFollow {
    #[inline(always)]
    fn as_ref(&self) -> &Utf8CStr {
        &self.0
    }
}

// impl<T: AsRef<Utf8CStr>> Deref<Target = Utf8CStr> for T { ... }
macro_rules! impl_cstr_deref {
    ($( ($t:ty, $($g:tt)*) )*) => {$(
        impl<$($g)*> Deref for $t {
            type Target = Utf8CStr;

            #[inline(always)]
            fn deref(&self) -> &Utf8CStr {
                self.as_ref()
            }
        }
    )*}
}

impl_cstr_deref!(
    (Utf8CStrBufRef<'_>,)
    (Utf8CStrBufArr<N>, const N: usize)
    (Utf8CString,)
    (FsPathFollow,)
);

// impl<T: Deref<Target = Utf8CStr>> BoilerPlate for T { ... }
macro_rules! impl_cstr_misc {
    ($( ($t:ty, $($g:tt)*) )*) => {$(
        impl<$($g)*> AsRef<str> for $t {
            #[inline(always)]
            fn as_ref(&self) -> &str {
                self.as_str()
            }
        }
        impl<$($g)*> AsRef<CStr> for $t {
            #[inline(always)]
            fn as_ref(&self) -> &CStr {
                self.as_cstr()
            }
        }
        impl<$($g)*> AsRef<OsStr> for $t {
            #[inline(always)]
            fn as_ref(&self) -> &OsStr {
                OsStr::new(self.as_str())
            }
        }
        impl<$($g)*> AsRef<Path> for $t {
            #[inline(always)]
            fn as_ref(&self) -> &Path {
                Path::new(self.as_str())
            }
        }
        impl<$($g)*> Display for $t {
            #[inline(always)]
            fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                Display::fmt(self.as_str(), f)
            }
        }
        impl<$($g)*> Debug for $t {
            #[inline(always)]
            fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                Debug::fmt(self.as_str(), f)
            }
        }
        impl<$($g)*> PartialEq<str> for $t {
            #[inline(always)]
            fn eq(&self, other: &str) -> bool {
                self.as_str() == other
            }
        }
        impl<$($g)*> PartialEq<$t> for str {
            #[inline(always)]
            fn eq(&self, other: &$t) -> bool {
                self == other.as_str()
            }
        }
        impl<$($g)*> PartialEq<CStr> for $t {
            #[inline(always)]
            fn eq(&self, other: &CStr) -> bool {
                self.as_cstr() == other
            }
        }
        impl<$($g)*> PartialEq<$t> for CStr {
            #[inline(always)]
            fn eq(&self, other: &$t) -> bool {
                self == other.as_cstr()
            }
        }
        impl<T: AsRef<Utf8CStr> + ?Sized, $($g)*> PartialEq<T> for $t {
            #[inline(always)]
            fn eq(&self, other: &T) -> bool {
                self.as_bytes_with_nul() == other.as_ref().as_bytes_with_nul()
            }
        }
        impl<$($g)*> Eq for $t {}
        impl<$($g)*> PartialOrd for $t {
            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
                Some(self.cmp(other))
            }
        }
        impl<$($g)*> Ord for $t {
            fn cmp(&self, other: &Self) -> Ordering {
                self.as_str().cmp(other.as_str())
            }
        }
    )*}
}

impl_cstr_misc!(
    (Utf8CStr,)
    (Utf8CStrBufRef<'_>,)
    (Utf8CStrBufArr<N>, const N: usize)
    (Utf8CString,)
    (FsPathFollow,)
);

fn copy_cstr_truncate(dest: &mut [u8], src: &[u8]) -> usize {
    if dest.len() <= 1 {
        // Truncate
        return 0;
    }
    let len = min(src.len(), dest.len() - 1);
    if len > 0 {
        dest[..len].copy_from_slice(&src[..len]);
    }
    dest[len] = b'\0';
    len
}

// impl<T> AsRef<Utf8CStr> for T { ... }
// impl<T> Utf8CStrBuf for T { ... }
macro_rules! impl_cstr_buf {
    ($( ($t:ty, $($g:tt)*) )*) => {$(
        impl<$($g)*> AsRef<Utf8CStr> for $t {
            #[inline(always)]
            fn as_ref(&self) -> &Utf8CStr {
                // SAFETY: the internal buffer is always UTF-8 checked
                // SAFETY: self.used is guaranteed to always <= SIZE - 1
                unsafe { Utf8CStr::from_bytes_unchecked(self.buf.get_unchecked(..(self.used + 1))) }
            }
        }
        impl<$($g)*> Utf8CStrBuf for $t {
            #[inline(always)]
            fn len(&self) -> usize {
                self.used
            }
            #[inline(always)]
            fn push_str(&mut self, s: &str) -> usize {
                // SAFETY: self.used is guaranteed to always <= SIZE - 1
                let dest = unsafe { self.buf.get_unchecked_mut(self.used..) };
                let len = copy_cstr_truncate(dest, s.as_bytes());
                self.used += len;
                len
            }
            #[inline(always)]
            fn capacity(&self) -> usize {
                self.buf.len()
            }
            #[inline(always)]
            fn clear(&mut self) {
                self.buf[0] = b'\0';
                self.used = 0;
            }
            #[inline(always)]
            fn as_mut_ptr(&mut self) -> *mut c_char {
                self.buf.as_mut_ptr().cast()
            }
            fn truncate(&mut self, new_len: usize) {
                if self.used <= new_len {
                    return;
                }
                self.buf[new_len] = b'\0';
                self.used = new_len;
            }
            fn rebuild(&mut self) -> Result<(), StrErr> {
                // Validate the entire buffer, including the unused part
                match Utf8CStr::from_bytes_until_nul(&self.buf) {
                    Ok(s) => self.used = s.len(),
                    Err(e) => {
                        self.used = 0;
                        self.buf[0] = b'\0';
                        return Err(e);
                    }
                }
                Ok(())
            }
        }
    )*}
}

impl_cstr_buf!(
    (Utf8CStrBufRef<'_>,)
    (Utf8CStrBufArr<N>, const N: usize)
);

// impl<T: Utf8CStrBuf> Write for T { ... }
macro_rules! impl_cstr_buf_write {
    ($( ($t:ty, $($g:tt)*) )*) => {$(
        impl<$($g)*> Write for $t {
            #[inline(always)]
            fn write_str(&mut self, s: &str) -> fmt::Result {
                self.push_str(s);
                Ok(())
            }
        }
    )*}
}

impl_cstr_buf_write!(
    (Utf8CStrBufRef<'_>,)
    (Utf8CStrBufArr<N>, const N: usize)
    (Utf8CString,)
);

#[macro_export]
macro_rules! cstr {
    ($str:expr) => {{
        const NULL_STR: &str = $crate::const_format::concatcp!($str, "\0");
        #[allow(unused_unsafe)]
        unsafe {
            $crate::Utf8CStr::from_bytes_unchecked(NULL_STR.as_bytes())
        }
    }};
}

#[macro_export]
macro_rules! raw_cstr {
    ($str:expr) => {{ $crate::cstr!($str).as_ptr() }};
}

```

`native/src/base/cxx_extern.rs`:

```rs
// Functions in this file are only for exporting to C++, DO NOT USE IN RUST

use std::fs::File;
use std::io::BufReader;
use std::mem::ManuallyDrop;
use std::ops::DerefMut;
use std::os::fd::{BorrowedFd, FromRawFd, RawFd};

use crate::ffi::{FnBoolStr, FnBoolStrStr};
use crate::files::map_file_at;
pub(crate) use crate::xwrap::*;
use crate::{
    BufReadExt, ResultExt, Utf8CStr, clone_attr, cstr, fclone_attr, map_fd, map_file,
    slice_from_ptr,
};
use cfg_if::cfg_if;
use libc::{c_char, mode_t};
use nix::fcntl::OFlag;

#[unsafe(no_mangle)]
unsafe extern "C" fn canonical_path(path: *const c_char, buf: *mut u8, bufsz: usize) -> isize {
    unsafe {
        match Utf8CStr::from_ptr(path) {
            Ok(path) => {
                let mut buf = cstr::buf::wrap_ptr(buf, bufsz);
                path.realpath(&mut buf)
                    .log()
                    .map_or(-1_isize, |_| buf.len() as isize)
            }
            Err(_) => -1,
        }
    }
}

#[unsafe(export_name = "mkdirs")]
unsafe extern "C" fn mkdirs_for_cxx(path: *const c_char, mode: mode_t) -> i32 {
    unsafe {
        match Utf8CStr::from_ptr(path) {
            Ok(path) => path.mkdirs(mode).map_or(-1, |_| 0),
            Err(_) => -1,
        }
    }
}

#[unsafe(export_name = "rm_rf")]
unsafe extern "C" fn rm_rf_for_cxx(path: *const c_char) -> bool {
    unsafe {
        match Utf8CStr::from_ptr(path) {
            Ok(path) => path.remove_all().is_ok(),
            Err(_) => false,
        }
    }
}

pub(crate) fn map_file_for_cxx(path: &Utf8CStr, rw: bool) -> &'static mut [u8] {
    map_file(path, rw).log().unwrap_or(&mut [])
}

pub(crate) fn map_file_at_for_cxx(fd: RawFd, path: &Utf8CStr, rw: bool) -> &'static mut [u8] {
    unsafe {
        map_file_at(BorrowedFd::borrow_raw(fd), path, rw)
            .log()
            .unwrap_or(&mut [])
    }
}

pub(crate) fn map_fd_for_cxx(fd: RawFd, sz: usize, rw: bool) -> &'static mut [u8] {
    unsafe {
        map_fd(BorrowedFd::borrow_raw(fd), sz, rw)
            .log()
            .unwrap_or(&mut [])
    }
}

pub(crate) unsafe fn readlinkat(
    dirfd: RawFd,
    path: *const c_char,
    buf: *mut u8,
    bufsz: usize,
) -> isize {
    unsafe {
        // readlinkat() may fail on x86 platform, returning random value
        // instead of number of bytes placed in buf (length of link)
        cfg_if! {
            if #[cfg(any(target_arch = "x86", target_arch = "x86_64"))] {
                libc::memset(buf.cast(), 0, bufsz);
                let mut r = libc::readlinkat(dirfd, path, buf.cast(), bufsz - 1);
                if r > 0 {
                    r = libc::strlen(buf.cast()) as isize;
                }
            } else {
                let r = libc::readlinkat(dirfd, path, buf.cast(), bufsz - 1);
                if r >= 0 {
                    *buf.offset(r) = b'\0';
                }
            }
        }
        r
    }
}

#[unsafe(export_name = "cp_afc")]
unsafe extern "C" fn cp_afc_for_cxx(src: *const c_char, dest: *const c_char) -> bool {
    unsafe {
        if let Ok(src) = Utf8CStr::from_ptr(src)
            && let Ok(dest) = Utf8CStr::from_ptr(dest)
        {
            return src.copy_to(dest).is_ok();
        }
        false
    }
}

#[unsafe(export_name = "mv_path")]
unsafe extern "C" fn mv_path_for_cxx(src: *const c_char, dest: *const c_char) -> bool {
    unsafe {
        if let Ok(src) = Utf8CStr::from_ptr(src)
            && let Ok(dest) = Utf8CStr::from_ptr(dest)
        {
            return src.move_to(dest).is_ok();
        }
        false
    }
}

#[unsafe(export_name = "link_path")]
unsafe extern "C" fn link_path_for_cxx(src: *const c_char, dest: *const c_char) -> bool {
    unsafe {
        if let Ok(src) = Utf8CStr::from_ptr(src)
            && let Ok(dest) = Utf8CStr::from_ptr(dest)
        {
            return src.link_to(dest).is_ok();
        }
        false
    }
}

#[unsafe(export_name = "clone_attr")]
unsafe extern "C" fn clone_attr_for_cxx(src: *const c_char, dest: *const c_char) -> bool {
    unsafe {
        if let Ok(src) = Utf8CStr::from_ptr(src)
            && let Ok(dest) = Utf8CStr::from_ptr(dest)
        {
            return clone_attr(src, dest).log().is_ok();
        }
        false
    }
}

#[unsafe(export_name = "fclone_attr")]
unsafe extern "C" fn fclone_attr_for_cxx(a: RawFd, b: RawFd) -> bool {
    fclone_attr(a, b).log().is_ok()
}

#[unsafe(export_name = "cxx$utf8str$new")]
unsafe extern "C" fn str_new(this: &mut &Utf8CStr, s: *const u8, len: usize) {
    unsafe {
        *this = Utf8CStr::from_bytes(slice_from_ptr(s, len)).unwrap_or(cstr!(""));
    }
}

#[unsafe(export_name = "cxx$utf8str$ptr")]
unsafe extern "C" fn str_ptr(this: &&Utf8CStr) -> *const u8 {
    this.as_ptr().cast()
}

#[unsafe(export_name = "cxx$utf8str$len")]
unsafe extern "C" fn str_len(this: &&Utf8CStr) -> usize {
    this.len()
}

pub(crate) fn parse_prop_file_rs(name: &Utf8CStr, f: &FnBoolStrStr) {
    if let Ok(file) = name.open(OFlag::O_RDONLY) {
        BufReader::new(file).for_each_prop(|key, value| f.call(key, value))
    }
}

pub(crate) fn file_readline_for_cxx(fd: RawFd, f: &FnBoolStr) {
    let mut fd = ManuallyDrop::new(unsafe { File::from_raw_fd(fd) });
    BufReader::new(fd.deref_mut()).for_each_line(|line| f.call(Utf8CStr::from_string(line)));
}

```

`native/src/base/derive/Cargo.toml`:

```toml
[package]
name = "derive"
version.workspace = true
edition.workspace = true

[lib]
path = "lib.rs"
proc-macro = true

[dependencies]
syn = { workspace = true }
quote = { workspace = true }
proc-macro2 = { workspace = true }

```

`native/src/base/derive/argh/errors.rs`:

```rs
// Copyright (c) 2020 Google LLC All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

use proc_macro2::{Span, TokenStream};
use quote::ToTokens;
use std::cell::RefCell;

/// A type for collecting procedural macro errors.
#[derive(Default)]
pub struct Errors {
    errors: RefCell<Vec<syn::Error>>,
}

/// Produce functions to expect particular literals in `syn::Expr`
macro_rules! expect_lit_fn {
    ($(($fn_name:ident, $syn_type:ident, $variant:ident, $lit_name:literal),)*) => {
        $(
            pub fn $fn_name<'a>(&self, e: &'a syn::Expr) -> Option<&'a syn::$syn_type> {
                if let syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::$variant(inner), .. }) = e {
                    Some(inner)
                } else {
                    self.unexpected_lit($lit_name, e);
                    None
                }
            }
        )*
    }
}

/// Produce functions to expect particular variants of `syn::Meta`
macro_rules! expect_meta_fn {
    ($(($fn_name:ident, $syn_type:ident, $variant:ident, $meta_name:literal),)*) => {
        $(
            pub fn $fn_name<'a>(&self, meta: &'a syn::Meta) -> Option<&'a syn::$syn_type> {
                if let syn::Meta::$variant(inner) = meta {
                    Some(inner)
                } else {
                    self.unexpected_meta($meta_name, meta);
                    None
                }
            }
        )*
    }
}

impl Errors {
    /// Issue an error like:
    ///
    /// Duplicate foo attribute
    /// First foo attribute here
    pub fn duplicate_attrs(
        &self,
        attr_kind: &str,
        first: &impl syn::spanned::Spanned,
        second: &impl syn::spanned::Spanned,
    ) {
        self.duplicate_attrs_inner(attr_kind, first.span(), second.span())
    }

    fn duplicate_attrs_inner(&self, attr_kind: &str, first: Span, second: Span) {
        self.err_span(second, &["Duplicate ", attr_kind, " attribute"].concat());
        self.err_span(first, &["First ", attr_kind, " attribute here"].concat());
    }

    expect_lit_fn![
        (expect_lit_str, LitStr, Str, "string"),
        (expect_lit_char, LitChar, Char, "character"),
        (expect_lit_int, LitInt, Int, "integer"),
    ];

    expect_meta_fn![
        (expect_meta_word, Path, Path, "path"),
        (expect_meta_list, MetaList, List, "list"),
        (
            expect_meta_name_value,
            MetaNameValue,
            NameValue,
            "name-value pair"
        ),
    ];

    fn unexpected_lit(&self, expected: &str, found: &syn::Expr) {
        fn lit_kind(lit: &syn::Lit) -> &'static str {
            use syn::Lit::{Bool, Byte, ByteStr, Char, Float, Int, Str, Verbatim};
            match lit {
                Str(_) => "string",
                ByteStr(_) => "bytestring",
                Byte(_) => "byte",
                Char(_) => "character",
                Int(_) => "integer",
                Float(_) => "float",
                Bool(_) => "boolean",
                Verbatim(_) => "unknown (possibly extra-large integer)",
                _ => "unknown literal kind",
            }
        }

        if let syn::Expr::Lit(syn::ExprLit { lit, .. }) = found {
            self.err(
                found,
                &[
                    "Expected ",
                    expected,
                    " literal, found ",
                    lit_kind(lit),
                    " literal",
                ]
                .concat(),
            )
        } else {
            self.err(
                found,
                &[
                    "Expected ",
                    expected,
                    " literal, found non-literal expression.",
                ]
                .concat(),
            )
        }
    }

    fn unexpected_meta(&self, expected: &str, found: &syn::Meta) {
        fn meta_kind(meta: &syn::Meta) -> &'static str {
            use syn::Meta::{List, NameValue, Path};
            match meta {
                Path(_) => "path",
                List(_) => "list",
                NameValue(_) => "name-value pair",
            }
        }

        self.err(
            found,
            &[
                "Expected ",
                expected,
                " attribute, found ",
                meta_kind(found),
                " attribute",
            ]
            .concat(),
        )
    }

    /// Issue an error relating to a particular `Spanned` structure.
    pub fn err(&self, spanned: &impl syn::spanned::Spanned, msg: &str) {
        self.err_span(spanned.span(), msg);
    }

    /// Issue an error relating to a particular `Span`.
    pub fn err_span(&self, span: Span, msg: &str) {
        self.push(syn::Error::new(span, msg));
    }

    /// Issue an error spanning over the given syntax tree node.
    pub fn err_span_tokens<T: ToTokens>(&self, tokens: T, msg: &str) {
        self.push(syn::Error::new_spanned(tokens, msg));
    }

    /// Push a `syn::Error` onto the list of errors to issue.
    pub fn push(&self, err: syn::Error) {
        self.errors.borrow_mut().push(err);
    }

    /// Convert a `syn::Result` to an `Option`, logging the error if present.
    pub fn ok<T>(&self, r: syn::Result<T>) -> Option<T> {
        match r {
            Ok(v) => Some(v),
            Err(e) => {
                self.push(e);
                None
            }
        }
    }
}

impl ToTokens for Errors {
    /// Convert the errors into tokens that, when emit, will cause
    /// the user of the macro to receive compiler errors.
    fn to_tokens(&self, tokens: &mut TokenStream) {
        tokens.extend(self.errors.borrow().iter().map(|e| e.to_compile_error()));
    }
}

```

`native/src/base/derive/argh/mod.rs`:

```rs
// Copyright (c) 2020 Google LLC All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

use syn::ext::IdentExt as _;

/// Implementation of the `FromArgs` and `argh(...)` derive attributes.
///
/// For more thorough documentation, see the `argh` crate itself.
extern crate proc_macro;

use errors::Errors;
use parse_attrs::{FieldAttrs, FieldKind, TypeAttrs, check_long_name};
use proc_macro2::{Span, TokenStream};
use quote::{ToTokens, quote, quote_spanned};
use std::collections::HashMap;
use std::str::FromStr;
use syn::spanned::Spanned;
use syn::{GenericArgument, LitStr, PathArguments, Type};

mod errors;
mod parse_attrs;

/// Transform the input into a token stream containing any generated implementations,
/// as well as all errors that occurred.
pub(crate) fn impl_from_args(input: &syn::DeriveInput) -> TokenStream {
    let errors = &Errors::default();
    let type_attrs = &TypeAttrs::parse(errors, input);
    let mut output_tokens = match &input.data {
        syn::Data::Struct(ds) => {
            impl_from_args_struct(errors, &input.ident, type_attrs, &input.generics, ds)
        }
        syn::Data::Enum(de) => {
            impl_from_args_enum(errors, &input.ident, type_attrs, &input.generics, de)
        }
        syn::Data::Union(_) => {
            errors.err(input, "`#[derive(FromArgs)]` cannot be applied to unions");
            TokenStream::new()
        }
    };
    errors.to_tokens(&mut output_tokens);
    output_tokens
}

/// The kind of optionality a parameter has.
enum Optionality {
    None,
    Defaulted(TokenStream),
    Optional,
    Repeating,
    DefaultedRepeating(TokenStream),
}

impl PartialEq<Optionality> for Optionality {
    fn eq(&self, other: &Optionality) -> bool {
        use Optionality::*;
        // NB: (Defaulted, Defaulted) can't contain the same token streams
        matches!((self, other), (Optional, Optional) | (Repeating, Repeating))
    }
}

impl Optionality {
    /// Whether or not this is `Optionality::None`
    fn is_required(&self) -> bool {
        matches!(self, Optionality::None)
    }
}

/// A field of a `#![derive(FromArgs)]` struct with attributes and some other
/// notable metadata appended.
struct StructField<'a> {
    /// The original parsed field
    field: &'a syn::Field,
    /// The parsed attributes of the field
    attrs: FieldAttrs,
    /// The field name. This is contained optionally inside `field`,
    /// but is duplicated non-optionally here to indicate that all field that
    /// have reached this point must have a field name, and it no longer
    /// needs to be unwrapped.
    name: &'a syn::Ident,
    /// Similar to `name` above, this is contained optionally inside `FieldAttrs`,
    /// but here is fully present to indicate that we only have to consider fields
    /// with a valid `kind` at this point.
    kind: FieldKind,
    // If `field.ty` is `Vec<T>` or `Option<T>`, this is `T`, otherwise it's `&field.ty`.
    // This is used to enable consistent parsing code between optional and non-optional
    // keyed and subcommand fields.
    ty_without_wrapper: &'a syn::Type,
    // Whether the field represents an optional value, such as an `Option` subcommand field
    // or an `Option` or `Vec` keyed argument, or if it has a `default`.
    optionality: Optionality,
    // The `--`-prefixed name of the option, if one exists.
    long_name: Option<String>,
}

impl<'a> StructField<'a> {
    /// Attempts to parse a field of a `#[derive(FromArgs)]` struct, pulling out the
    /// fields required for code generation.
    fn new(errors: &Errors, field: &'a syn::Field, attrs: FieldAttrs) -> Option<Self> {
        let name = field.ident.as_ref().expect("missing ident for named field");

        // Ensure that one "kind" is present (switch, option, subcommand, positional)
        let kind = if let Some(field_type) = &attrs.field_type {
            field_type.kind
        } else {
            errors.err(
                field,
                concat!(
                    "Missing `argh` field kind attribute.\n",
                    "Expected one of: `switch`, `option`, `remaining`, `subcommand`, `positional`",
                ),
            );
            return None;
        };

        // Parse out whether a field is optional (`Option` or `Vec`).
        let optionality;
        let ty_without_wrapper;
        match kind {
            FieldKind::Switch => {
                if !ty_expect_switch(errors, &field.ty) {
                    return None;
                }
                optionality = Optionality::Optional;
                ty_without_wrapper = &field.ty;
            }
            FieldKind::Option | FieldKind::Positional => {
                if let Some(default) = &attrs.default {
                    let tokens = match TokenStream::from_str(&default.value()) {
                        Ok(tokens) => tokens,
                        Err(_) => {
                            errors.err(&default, "Invalid tokens: unable to lex `default` value");
                            return None;
                        }
                    };
                    // Set the span of the generated tokens to the string literal
                    let tokens: TokenStream = tokens
                        .into_iter()
                        .map(|mut tree| {
                            tree.set_span(default.span());
                            tree
                        })
                        .collect();
                    let inner = if let Some(x) = ty_inner(&["Vec"], &field.ty) {
                        optionality = Optionality::DefaultedRepeating(tokens);
                        x
                    } else {
                        optionality = Optionality::Defaulted(tokens);
                        &field.ty
                    };
                    ty_without_wrapper = inner;
                } else {
                    let mut inner = None;
                    optionality = if let Some(x) = ty_inner(&["Option"], &field.ty) {
                        inner = Some(x);
                        Optionality::Optional
                    } else if let Some(x) = ty_inner(&["Vec"], &field.ty) {
                        inner = Some(x);
                        Optionality::Repeating
                    } else {
                        Optionality::None
                    };
                    ty_without_wrapper = inner.unwrap_or(&field.ty);
                }
            }
            FieldKind::SubCommand => {
                let inner = ty_inner(&["Option"], &field.ty);
                optionality = if inner.is_some() {
                    Optionality::Optional
                } else {
                    Optionality::None
                };
                ty_without_wrapper = inner.unwrap_or(&field.ty);
            }
        }

        // Determine the "long" name of options and switches.
        // Defaults to the kebab-cased field name if `#[argh(long = "...")]` is omitted.
        // If `#[argh(long = none)]` is explicitly set, no long name will be set.
        let long_name = match kind {
            FieldKind::Switch | FieldKind::Option => {
                let long_name = match &attrs.long {
                    None => {
                        let kebab_name = to_kebab_case(&name.unraw().to_string());
                        check_long_name(errors, name, &kebab_name);
                        Some(kebab_name)
                    }
                    Some(None) => None,
                    Some(Some(long)) => Some(long.value()),
                }
                .map(|long_name| {
                    if long_name == "help" {
                        errors.err(field, "Custom `--help` flags are not supported.");
                    }
                    format!("--{}", long_name)
                });
                if let (None, None) = (&attrs.short, &long_name) {
                    errors.err(field, "At least one of `short` or `long` has to be set.")
                };
                long_name
            }
            FieldKind::SubCommand | FieldKind::Positional => None,
        };

        Some(StructField {
            field,
            attrs,
            kind,
            optionality,
            ty_without_wrapper,
            name,
            long_name,
        })
    }

    pub(crate) fn positional_arg_name(&self) -> String {
        self.attrs
            .arg_name
            .as_ref()
            .map(LitStr::value)
            .unwrap_or_else(|| self.name.to_string().trim_matches('_').to_owned())
    }

    fn option_arg_name(&self) -> String {
        match (&self.attrs.short, &self.long_name) {
            (None, None) => unreachable!("short and long cannot both be None"),
            (Some(short), None) => format!("-{}", short.value()),
            (None, Some(long)) => long.clone(),
            (Some(short), Some(long)) => format!("-{},{long}", short.value()),
        }
    }
}

fn to_kebab_case(s: &str) -> String {
    let words = s.split('_').filter(|word| !word.is_empty());
    let mut res = String::with_capacity(s.len());
    for word in words {
        if !res.is_empty() {
            res.push('-')
        }
        res.push_str(word)
    }
    res
}

/// Implements `FromArgs` and `TopLevelCommand` or `SubCommand` for a `#[derive(FromArgs)]` struct.
fn impl_from_args_struct(
    errors: &Errors,
    name: &syn::Ident,
    type_attrs: &TypeAttrs,
    generic_args: &syn::Generics,
    ds: &syn::DataStruct,
) -> TokenStream {
    let fields = match &ds.fields {
        syn::Fields::Named(fields) => fields,
        syn::Fields::Unnamed(_) => {
            errors.err(
                &ds.struct_token,
                "`#![derive(FromArgs)]` is not currently supported on tuple structs",
            );
            return TokenStream::new();
        }
        syn::Fields::Unit => {
            errors.err(
                &ds.struct_token,
                "#![derive(FromArgs)]` cannot be applied to unit structs",
            );
            return TokenStream::new();
        }
    };

    let fields: Vec<_> = fields
        .named
        .iter()
        .filter_map(|field| {
            let attrs = FieldAttrs::parse(errors, field);
            StructField::new(errors, field, attrs)
        })
        .collect();

    ensure_unique_names(errors, &fields);
    ensure_only_trailing_positionals_are_optional(errors, &fields);

    let impl_span = Span::call_site();

    let from_args_method = impl_from_args_struct_from_args(errors, type_attrs, &fields);

    let top_or_sub_cmd_impl = top_or_sub_cmd_impl(errors, name, type_attrs, generic_args);

    let (impl_generics, ty_generics, where_clause) = generic_args.split_for_impl();
    let trait_impl = quote_spanned! { impl_span =>
        #[automatically_derived]
        impl #impl_generics argh::FromArgs for #name #ty_generics #where_clause {
            #from_args_method
        }

        #top_or_sub_cmd_impl
    };

    trait_impl
}

fn impl_from_args_struct_from_args<'a>(
    errors: &Errors,
    type_attrs: &TypeAttrs,
    fields: &'a [StructField<'a>],
) -> TokenStream {
    let init_fields = declare_local_storage_for_from_args_fields(fields);
    let unwrap_fields = unwrap_from_args_fields(fields);
    let positional_fields: Vec<&StructField<'_>> = fields
        .iter()
        .filter(|field| field.kind == FieldKind::Positional)
        .collect();
    let positional_field_idents = positional_fields.iter().map(|field| &field.field.ident);
    let positional_field_names = positional_fields.iter().map(|field| field.name.to_string());
    let last_positional_is_repeating = positional_fields
        .last()
        .map(|field| field.optionality == Optionality::Repeating)
        .unwrap_or(false);
    let last_positional_is_greedy = positional_fields
        .last()
        .map(|field| field.kind == FieldKind::Positional && field.attrs.greedy.is_some())
        .unwrap_or(false);

    let flag_output_table = fields.iter().filter_map(|field| {
        let field_name = &field.field.ident;
        match field.kind {
            FieldKind::Option => Some(quote! { argh::ParseStructOption::Value(&mut #field_name) }),
            FieldKind::Switch => Some(quote! { argh::ParseStructOption::Flag(&mut #field_name) }),
            FieldKind::SubCommand | FieldKind::Positional => None,
        }
    });

    let flag_str_to_output_table_map = flag_str_to_output_table_map_entries(fields);

    let mut subcommands_iter = fields
        .iter()
        .filter(|field| field.kind == FieldKind::SubCommand)
        .fuse();

    let subcommand: Option<&StructField<'_>> = subcommands_iter.next();
    for dup_subcommand in subcommands_iter {
        errors.duplicate_attrs(
            "subcommand",
            subcommand.unwrap().field,
            dup_subcommand.field,
        );
    }

    let impl_span = Span::call_site();

    let missing_requirements_ident = syn::Ident::new("__missing_requirements", impl_span);

    let append_missing_requirements =
        append_missing_requirements(&missing_requirements_ident, fields);

    let parse_subcommands = if let Some(subcommand) = subcommand {
        let name = subcommand.name;
        let ty = subcommand.ty_without_wrapper;
        quote_spanned! { impl_span =>
            Some(argh::ParseStructSubCommand {
                subcommands: <#ty as argh::SubCommands>::COMMANDS,
                dynamic_subcommands: &<#ty as argh::SubCommands>::dynamic_commands(),
                parse_func: &mut |__command, __remaining_args| {
                    #name = Some(<#ty as argh::FromArgs>::from_args(__command, __remaining_args)?);
                    Ok(())
                },
            })
        }
    } else {
        quote_spanned! { impl_span => None }
    };

    let help_triggers = get_help_triggers(type_attrs);

    let method_impl = quote_spanned! { impl_span =>
        fn from_args(__cmd_name: &[&str], __args: &[&str])
            -> std::result::Result<Self, argh::EarlyExit>
        {
            #![allow(clippy::unwrap_in_result)]

            #( #init_fields )*

            argh::parse_struct_args(
                __cmd_name,
                __args,
                argh::ParseStructOptions {
                    arg_to_slot: &[ #( #flag_str_to_output_table_map ,)* ],
                    slots: &mut [ #( #flag_output_table, )* ],
                    help_triggers: &[ #( #help_triggers ),* ],
                },
                argh::ParseStructPositionals {
                    positionals: &mut [
                        #(
                            argh::ParseStructPositional {
                                name: #positional_field_names,
                                slot: &mut #positional_field_idents as &mut dyn argh::ParseValueSlot,
                            },
                        )*
                    ],
                    last_is_repeating: #last_positional_is_repeating,
                    last_is_greedy: #last_positional_is_greedy,
                },
                #parse_subcommands,
            )?;

            let mut #missing_requirements_ident = argh::MissingRequirements::default();
            #(
                #append_missing_requirements
            )*
            #missing_requirements_ident.err_on_any()?;

            Ok(Self {
                #( #unwrap_fields, )*
            })
        }
    };

    method_impl
}

/// get help triggers vector from type_attrs.help_triggers as a [`Vec<String>`]
///
/// Defaults to vec!["-h", "--help"] if type_attrs.help_triggers is None
fn get_help_triggers(type_attrs: &TypeAttrs) -> Vec<String> {
    if type_attrs.is_subcommand.is_some() {
        // Subcommands should never have any help triggers
        Vec::new()
    } else {
        type_attrs.help_triggers.as_ref().map_or_else(
            || vec!["-h".to_string(), "--help".to_string()],
            |s| {
                s.iter()
                    .filter_map(|s| {
                        let trigger = s.value();
                        let trigger_trimmed = trigger.trim().to_owned();
                        if trigger_trimmed.is_empty() {
                            None
                        } else {
                            Some(trigger_trimmed)
                        }
                    })
                    .collect::<Vec<_>>()
            },
        )
    }
}

/// Ensures that only trailing positional args are non-required.
fn ensure_only_trailing_positionals_are_optional(errors: &Errors, fields: &[StructField<'_>]) {
    let mut first_non_required_span = None;
    for field in fields {
        if field.kind == FieldKind::Positional {
            if let Some(first) = first_non_required_span
                && field.optionality.is_required()
            {
                errors.err_span(
                    first,
                    "Only trailing positional arguments may be `Option`, `Vec`, or defaulted.",
                );
                errors.err(
                    &field.field,
                    "Later non-optional positional argument declared here.",
                );
                return;
            }
            if !field.optionality.is_required() {
                first_non_required_span = Some(field.field.span());
            }
        }
    }
}

/// Ensures that only one short or long name is used.
fn ensure_unique_names(errors: &Errors, fields: &[StructField<'_>]) {
    let mut seen_short_names = HashMap::new();
    let mut seen_long_names = HashMap::new();

    for field in fields {
        if let Some(short_name) = &field.attrs.short {
            let short_name = short_name.value();
            if let Some(first_use_field) = seen_short_names.get(&short_name) {
                errors.err_span_tokens(
                    first_use_field,
                    &format!(
                        "The short name of \"-{}\" was already used here.",
                        short_name
                    ),
                );
                errors.err_span_tokens(field.field, "Later usage here.");
            }

            seen_short_names.insert(short_name, &field.field);
        }

        if let Some(long_name) = &field.long_name {
            if let Some(first_use_field) = seen_long_names.get(&long_name) {
                errors.err_span_tokens(
                    *first_use_field,
                    &format!("The long name of \"{}\" was already used here.", long_name),
                );
                errors.err_span_tokens(field.field, "Later usage here.");
            }

            seen_long_names.insert(long_name, field.field);
        }
    }
}

/// Implement `argh::TopLevelCommand` or `argh::SubCommand` as appropriate.
fn top_or_sub_cmd_impl(
    errors: &Errors,
    name: &syn::Ident,
    type_attrs: &TypeAttrs,
    generic_args: &syn::Generics,
) -> TokenStream {
    let description = String::new();
    let (impl_generics, ty_generics, where_clause) = generic_args.split_for_impl();
    if type_attrs.is_subcommand.is_none() {
        // Not a subcommand
        quote! {
            #[automatically_derived]
            impl #impl_generics argh::TopLevelCommand for #name #ty_generics #where_clause {}
        }
    } else {
        let empty_str = syn::LitStr::new("", Span::call_site());
        let subcommand_name = type_attrs.name.as_ref().unwrap_or_else(|| {
            errors.err(
                name,
                "`#[argh(name = \"...\")]` attribute is required for subcommands",
            );
            &empty_str
        });
        quote! {
            #[automatically_derived]
            impl #impl_generics argh::SubCommand for #name #ty_generics #where_clause {
                const COMMAND: &'static argh::CommandInfo = &argh::CommandInfo {
                    name: #subcommand_name,
                    description: #description,
                };
            }
        }
    }
}

/// Declare a local slots to store each field in during parsing.
///
/// Most fields are stored in `Option<FieldType>` locals.
/// `argh(option)` fields are stored in a `ParseValueSlotTy` along with a
/// function that knows how to decode the appropriate value.
fn declare_local_storage_for_from_args_fields<'a>(
    fields: &'a [StructField<'a>],
) -> impl Iterator<Item = TokenStream> + 'a {
    fields.iter().map(|field| {
        let field_name = &field.field.ident;
        let field_type = &field.ty_without_wrapper;

        // Wrap field types in `Option` if they aren't already `Option` or `Vec`-wrapped.
        let field_slot_type = match field.optionality {
            Optionality::Optional | Optionality::Repeating => (&field.field.ty).into_token_stream(),
            Optionality::None | Optionality::Defaulted(_) => {
                quote! { std::option::Option<#field_type> }
            }
            Optionality::DefaultedRepeating(_) => {
                quote! { std::option::Option<std::vec::Vec<#field_type>> }
            }
        };

        match field.kind {
            FieldKind::Option | FieldKind::Positional => {
                let from_str_fn = match &field.attrs.from_str_fn {
                    Some(from_str_fn) => from_str_fn.into_token_stream(),
                    None => {
                        quote! {
                            <#field_type as argh::FromArgValue>::from_arg_value
                        }
                    }
                };

                quote! {
                    let mut #field_name: argh::ParseValueSlotTy<#field_slot_type, #field_type>
                        = argh::ParseValueSlotTy {
                            slot: std::default::Default::default(),
                            parse_func: |_, value| { #from_str_fn(value) },
                        };
                }
            }
            FieldKind::SubCommand => {
                quote! { let mut #field_name: #field_slot_type = None; }
            }
            FieldKind::Switch => {
                quote! { let mut #field_name: #field_slot_type = argh::Flag::default(); }
            }
        }
    })
}

/// Unwrap non-optional fields and take options out of their tuple slots.
fn unwrap_from_args_fields<'a>(
    fields: &'a [StructField<'a>],
) -> impl Iterator<Item = TokenStream> + 'a {
    fields.iter().map(|field| {
        let field_name = field.name;
        match field.kind {
            FieldKind::Option | FieldKind::Positional => match &field.optionality {
                Optionality::None => quote! {
                    #field_name: #field_name.slot.unwrap()
                },
                Optionality::Optional | Optionality::Repeating => {
                    quote! { #field_name: #field_name.slot }
                }
                Optionality::Defaulted(tokens) | Optionality::DefaultedRepeating(tokens) => {
                    quote! {
                        #field_name: #field_name.slot.unwrap_or_else(|| #tokens)
                    }
                }
            },
            FieldKind::Switch => field_name.into_token_stream(),
            FieldKind::SubCommand => match field.optionality {
                Optionality::None => quote! { #field_name: #field_name.unwrap() },
                Optionality::Optional | Optionality::Repeating => field_name.into_token_stream(),
                Optionality::Defaulted(_) | Optionality::DefaultedRepeating(_) => unreachable!(),
            },
        }
    })
}

/// Entries of tokens like `("--some-flag-key", 5)` that map from a flag key string
/// to an index in the output table.
fn flag_str_to_output_table_map_entries<'a>(fields: &'a [StructField<'a>]) -> Vec<TokenStream> {
    let mut flag_str_to_output_table_map = vec![];

    for (i, field) in fields.iter().enumerate() {
        if let Some(short) = &field.attrs.short {
            let short = format!("-{}", short.value());
            flag_str_to_output_table_map.push(quote! { (#short, #i) });
        }
        if let Some(long) = &field.long_name {
            flag_str_to_output_table_map.push(quote! { (#long, #i) });
        }
    }
    flag_str_to_output_table_map
}

/// For each non-optional field, add an entry to the `argh::MissingRequirements`.
fn append_missing_requirements<'a>(
    // missing_requirements_ident
    mri: &syn::Ident,
    fields: &'a [StructField<'a>],
) -> impl Iterator<Item = TokenStream> + 'a {
    let mri = mri.clone();
    fields
        .iter()
        .filter(|f| f.optionality.is_required())
        .map(move |field| {
            let field_name = field.name;
            match field.kind {
                FieldKind::Switch => unreachable!("switches are always optional"),
                FieldKind::Positional => {
                    let name = field.positional_arg_name();
                    quote! {
                        if #field_name.slot.is_none() {
                            #mri.missing_positional_arg(#name)
                        }
                    }
                }
                FieldKind::Option => {
                    let name = field.option_arg_name();
                    quote! {
                        if #field_name.slot.is_none() {
                            #mri.missing_option(#name)
                        }
                    }
                }
                FieldKind::SubCommand => {
                    let ty = field.ty_without_wrapper;
                    quote! {
                        if #field_name.is_none() {
                            #mri.missing_subcommands(
                                <#ty as argh::SubCommands>::COMMANDS
                                    .iter()
                                    .cloned()
                                    .chain(
                                        <#ty as argh::SubCommands>::dynamic_commands()
                                            .iter()
                                            .copied()
                                    ),
                            )
                        }
                    }
                }
            }
        })
}

/// Require that a type can be a `switch`.
/// Throws an error for all types except booleans and integers
fn ty_expect_switch(errors: &Errors, ty: &syn::Type) -> bool {
    fn ty_can_be_switch(ty: &syn::Type) -> bool {
        if let syn::Type::Path(path) = ty {
            if path.qself.is_some() {
                return false;
            }
            if path.path.segments.len() != 1 {
                return false;
            }
            let ident = &path.path.segments[0].ident;
            // `Option<bool>` can be used as a `switch`.
            if ident == "Option"
                && let PathArguments::AngleBracketed(args) = &path.path.segments[0].arguments
                && let GenericArgument::Type(Type::Path(p)) = &args.args[0]
                && p.path.segments[0].ident == "bool"
            {
                return true;
            }
            [
                "bool", "u8", "u16", "u32", "u64", "u128", "i8", "i16", "i32", "i64", "i128",
            ]
            .iter()
            .any(|path| ident == path)
        } else {
            false
        }
    }

    let res = ty_can_be_switch(ty);
    if !res {
        errors.err(
            ty,
            "switches must be of type `bool`, `Option<bool>`, or integer type",
        );
    }
    res
}

/// Returns `Some(T)` if a type is `wrapper_name<T>` for any `wrapper_name` in `wrapper_names`.
fn ty_inner<'a>(wrapper_names: &[&str], ty: &'a syn::Type) -> Option<&'a syn::Type> {
    if let syn::Type::Path(path) = ty {
        if path.qself.is_some() {
            return None;
        }
        // Since we only check the last path segment, it isn't necessarily the case that
        // we're referring to `std::vec::Vec` or `std::option::Option`, but there isn't
        // a fool proof way to check these since name resolution happens after macro expansion,
        // so this is likely "good enough" (so long as people don't have their own types called
        // `Option` or `Vec` that take one generic parameter they're looking to parse).
        let last_segment = path.path.segments.last()?;
        if !wrapper_names.iter().any(|name| last_segment.ident == *name) {
            return None;
        }
        if let syn::PathArguments::AngleBracketed(gen_args) = &last_segment.arguments {
            let generic_arg = gen_args.args.first()?;
            if let syn::GenericArgument::Type(ty) = &generic_arg {
                return Some(ty);
            }
        }
    }
    None
}

/// Implements `FromArgs` and `SubCommands` for a `#![derive(FromArgs)]` enum.
fn impl_from_args_enum(
    errors: &Errors,
    name: &syn::Ident,
    type_attrs: &TypeAttrs,
    generic_args: &syn::Generics,
    de: &syn::DataEnum,
) -> TokenStream {
    parse_attrs::check_enum_type_attrs(errors, type_attrs, &de.enum_token.span);

    // An enum variant like `<name>(<ty>)`
    struct SubCommandVariant<'a> {
        name: &'a syn::Ident,
        ty: &'a syn::Type,
    }

    let mut dynamic_type_and_variant = None;

    let variants: Vec<SubCommandVariant<'_>> = de
        .variants
        .iter()
        .filter_map(|variant| {
            let name = &variant.ident;
            let ty = enum_only_single_field_unnamed_variants(errors, &variant.fields)?;
            if parse_attrs::VariantAttrs::parse(errors, variant)
                .is_dynamic
                .is_some()
            {
                if dynamic_type_and_variant.is_some() {
                    errors.err(variant, "Only one variant can have the `dynamic` attribute");
                }
                dynamic_type_and_variant = Some((ty, name));
                None
            } else {
                Some(SubCommandVariant { name, ty })
            }
        })
        .collect();

    let name_repeating = std::iter::repeat(name.clone());
    let variant_ty = variants.iter().map(|x| x.ty).collect::<Vec<_>>();
    let variant_names = variants.iter().map(|x| x.name).collect::<Vec<_>>();
    let dynamic_from_args =
        dynamic_type_and_variant
            .as_ref()
            .map(|(dynamic_type, dynamic_variant)| {
                quote! {
                    if let Some(result) = <#dynamic_type as argh::DynamicSubCommand>::try_from_args(
                        command_name, args) {
                        return result.map(#name::#dynamic_variant);
                    }
                }
            });
    let dynamic_commands = dynamic_type_and_variant.as_ref().map(|(dynamic_type, _)| {
        quote! {
            fn dynamic_commands() -> &'static [&'static argh::CommandInfo] {
                <#dynamic_type as argh::DynamicSubCommand>::commands()
            }
        }
    });

    let (impl_generics, ty_generics, where_clause) = generic_args.split_for_impl();
    quote! {
        impl #impl_generics argh::FromArgs for #name #ty_generics #where_clause {
            fn from_args(command_name: &[&str], args: &[&str])
                -> std::result::Result<Self, argh::EarlyExit>
            {
                let subcommand_name = if let Some(subcommand_name) = command_name.last() {
                    *subcommand_name
                } else {
                    return Err(argh::EarlyExit::from("no subcommand name".to_owned()));
                };

                #(
                    if subcommand_name == <#variant_ty as argh::SubCommand>::COMMAND.name {
                        return Ok(#name_repeating::#variant_names(
                            <#variant_ty as argh::FromArgs>::from_args(command_name, args)?
                        ));
                    }
                )*

                #dynamic_from_args

                Err(argh::EarlyExit::from("no subcommand matched".to_owned()))
            }
        }

        impl #impl_generics argh::SubCommands for #name #ty_generics #where_clause {
            const COMMANDS: &'static [&'static argh::CommandInfo] = &[#(
                <#variant_ty as argh::SubCommand>::COMMAND,
            )*];

            #dynamic_commands
        }
    }
}

/// Returns `Some(Bar)` if the field is a single-field unnamed variant like `Foo(Bar)`.
/// Otherwise, generates an error.
fn enum_only_single_field_unnamed_variants<'a>(
    errors: &Errors,
    variant_fields: &'a syn::Fields,
) -> Option<&'a syn::Type> {
    macro_rules! with_enum_suggestion {
        ($help_text:literal) => {
            concat!(
                $help_text,
                "\nInstead, use a variant with a single unnamed field for each subcommand:\n",
                "    enum MyCommandEnum {\n",
                "        SubCommandOne(SubCommandOne),\n",
                "        SubCommandTwo(SubCommandTwo),\n",
                "    }",
            )
        };
    }

    match variant_fields {
        syn::Fields::Named(fields) => {
            errors.err(
                fields,
                with_enum_suggestion!(
                    "`#![derive(FromArgs)]` `enum`s do not support variants with named fields."
                ),
            );
            None
        }
        syn::Fields::Unit => {
            errors.err(
                variant_fields,
                with_enum_suggestion!(
                    "`#![derive(FromArgs)]` does not support `enum`s with no variants."
                ),
            );
            None
        }
        syn::Fields::Unnamed(fields) => {
            if fields.unnamed.len() != 1 {
                errors.err(
                    fields,
                    with_enum_suggestion!(
                        "`#![derive(FromArgs)]` `enum` variants must only contain one field."
                    ),
                );
                None
            } else {
                // `unwrap` is okay because of the length check above.
                let first_field = fields.unnamed.first().unwrap();
                Some(&first_field.ty)
            }
        }
    }
}

```

`native/src/base/derive/argh/parse_attrs.rs`:

```rs
// Copyright (c) 2020 Google LLC All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

use syn::parse::Parser;
use syn::punctuated::Punctuated;

use super::errors::Errors;
use proc_macro2::Span;
use std::collections::hash_map::{Entry, HashMap};

/// Attributes applied to a field of a `#![derive(FromArgs)]` struct.
#[derive(Default)]
pub struct FieldAttrs {
    pub default: Option<syn::LitStr>,
    pub description: Option<Description>,
    pub from_str_fn: Option<syn::ExprPath>,
    pub field_type: Option<FieldType>,
    pub long: Option<Option<syn::LitStr>>,
    pub short: Option<syn::LitChar>,
    pub arg_name: Option<syn::LitStr>,
    pub greedy: Option<syn::Path>,
    pub hidden_help: bool,
}

/// The purpose of a particular field on a `#![derive(FromArgs)]` struct.
#[derive(Copy, Clone, Eq, PartialEq)]
pub enum FieldKind {
    /// Switches are booleans that are set to "true" by passing the flag.
    Switch,
    /// Options are `--key value`. They may be optional (using `Option`),
    /// or repeating (using `Vec`), or required (neither `Option` nor `Vec`)
    Option,
    /// Subcommand fields (of which there can be at most one) refer to enums
    /// containing one of several potential subcommands. They may be optional
    /// (using `Option`) or required (no `Option`).
    SubCommand,
    /// Positional arguments are parsed literally if the input
    /// does not begin with `-` or `--` and is not a subcommand.
    /// They are parsed in declaration order, and only the last positional
    /// argument in a type may be an `Option`, `Vec`, or have a default value.
    Positional,
}

/// The type of a field on a `#![derive(FromArgs)]` struct.
///
/// This is a simple wrapper around `FieldKind` which includes the `syn::Ident`
/// of the attribute containing the field kind.
pub struct FieldType {
    pub kind: FieldKind,
    pub ident: syn::Ident,
}

/// A description of a `#![derive(FromArgs)]` struct.
///
/// Defaults to the docstring if one is present, or `#[argh(description = "...")]`
/// if one is provided.
pub struct Description {
    /// Whether the description was an explicit annotation or whether it was a doc string.
    pub explicit: bool,
    pub content: syn::LitStr,
}

impl FieldAttrs {
    pub fn parse(errors: &Errors, field: &syn::Field) -> Self {
        let mut this = Self::default();

        for attr in &field.attrs {
            if is_doc_attr(attr) {
                parse_attr_doc(errors, attr, &mut this.description);
                continue;
            }

            let ml = if let Some(ml) = argh_attr_to_meta_list(errors, attr) {
                ml
            } else {
                continue;
            };

            for meta in ml {
                let name = meta.path();
                if name.is_ident("arg_name") {
                    if let Some(m) = errors.expect_meta_name_value(&meta) {
                        this.parse_attr_arg_name(errors, m);
                    }
                } else if name.is_ident("default") {
                    if let Some(m) = errors.expect_meta_name_value(&meta) {
                        this.parse_attr_default(errors, m);
                    }
                } else if name.is_ident("description") {
                    if let Some(m) = errors.expect_meta_name_value(&meta) {
                        parse_attr_description(errors, m, &mut this.description);
                    }
                } else if name.is_ident("from_str_fn") {
                    if let Some(m) = errors.expect_meta_list(&meta) {
                        this.parse_attr_from_str_fn(errors, m);
                    }
                } else if name.is_ident("long") {
                    if let Some(m) = errors.expect_meta_name_value(&meta) {
                        this.parse_attr_long(errors, m);
                    }
                } else if name.is_ident("option") {
                    parse_attr_field_type(errors, &meta, FieldKind::Option, &mut this.field_type);
                } else if name.is_ident("short") {
                    if let Some(m) = errors.expect_meta_name_value(&meta) {
                        this.parse_attr_short(errors, m);
                    }
                } else if name.is_ident("subcommand") {
                    parse_attr_field_type(
                        errors,
                        &meta,
                        FieldKind::SubCommand,
                        &mut this.field_type,
                    );
                } else if name.is_ident("switch") {
                    parse_attr_field_type(errors, &meta, FieldKind::Switch, &mut this.field_type);
                } else if name.is_ident("positional") {
                    parse_attr_field_type(
                        errors,
                        &meta,
                        FieldKind::Positional,
                        &mut this.field_type,
                    );
                } else if name.is_ident("greedy") {
                    this.greedy = Some(name.clone());
                } else if name.is_ident("hidden_help") {
                    this.hidden_help = true;
                } else {
                    errors.err(
                        &meta,
                        concat!(
                            "Invalid field-level `argh` attribute\n",
                            "Expected one of: `arg_name`, `default`, `description`, `from_str_fn`, `greedy`, ",
                            "`long`, `option`, `short`, `subcommand`, `switch`, `hidden_help`",
                        ),
                    );
                }
            }
        }

        if let (Some(default), Some(field_type)) = (&this.default, &this.field_type) {
            match field_type.kind {
                FieldKind::Option | FieldKind::Positional => {}
                FieldKind::SubCommand | FieldKind::Switch => errors.err(
                    default,
                    "`default` may only be specified on `#[argh(option)]` \
                     or `#[argh(positional)]` fields",
                ),
            }
        }

        match (&this.greedy, this.field_type.as_ref().map(|f| f.kind)) {
            (Some(_), Some(FieldKind::Positional)) => {}
            (Some(greedy), Some(_)) => errors.err(
                &greedy,
                "`greedy` may only be specified on `#[argh(positional)]` \
                    fields",
            ),
            _ => {}
        }

        if let Some(d) = &this.description {
            check_option_description(errors, d.content.value().trim(), d.content.span());
        }

        this
    }

    fn parse_attr_from_str_fn(&mut self, errors: &Errors, m: &syn::MetaList) {
        parse_attr_fn_name(errors, m, "from_str_fn", &mut self.from_str_fn)
    }

    fn parse_attr_default(&mut self, errors: &Errors, m: &syn::MetaNameValue) {
        parse_attr_single_string(errors, m, "default", &mut self.default);
    }

    fn parse_attr_arg_name(&mut self, errors: &Errors, m: &syn::MetaNameValue) {
        parse_attr_single_string(errors, m, "arg_name", &mut self.arg_name);
    }

    fn parse_attr_long(&mut self, errors: &Errors, m: &syn::MetaNameValue) {
        if let Some(first) = &self.long {
            errors.duplicate_attrs("long", first, m);
        } else if let syn::Expr::Path(syn::ExprPath { path, .. }) = &m.value
            && let Some(ident) = path.get_ident()
            && ident.to_string().eq_ignore_ascii_case("none")
        {
            self.long = Some(None);
        } else if let Some(lit_str) = errors.expect_lit_str(&m.value) {
            self.long = Some(Some(lit_str.clone()));
        }
        if let Some(Some(long)) = &self.long {
            let value = long.value();
            check_long_name(errors, long, &value);
        }
    }

    fn parse_attr_short(&mut self, errors: &Errors, m: &syn::MetaNameValue) {
        if let Some(first) = &self.short {
            errors.duplicate_attrs("short", first, m);
        } else if let Some(lit_char) = errors.expect_lit_char(&m.value) {
            self.short = Some(lit_char.clone());
            if !lit_char.value().is_ascii() {
                errors.err(lit_char, "Short names must be ASCII");
            }
        }
    }
}

pub(crate) fn check_long_name(errors: &Errors, spanned: &impl syn::spanned::Spanned, value: &str) {
    if !value.is_ascii() {
        errors.err(spanned, "Long names must be ASCII");
    }
    if !value
        .chars()
        .all(|c| c.is_lowercase() || c == '-' || c.is_ascii_digit())
    {
        errors.err(
            spanned,
            "Long names may only contain lowercase letters, digits, and dashes",
        );
    }
}

fn parse_attr_fn_name(
    errors: &Errors,
    m: &syn::MetaList,
    attr_name: &str,
    slot: &mut Option<syn::ExprPath>,
) {
    if let Some(first) = slot {
        errors.duplicate_attrs(attr_name, first, m);
    }

    *slot = errors.ok(m.parse_args());
}

fn parse_attr_field_type(
    errors: &Errors,
    meta: &syn::Meta,
    kind: FieldKind,
    slot: &mut Option<FieldType>,
) {
    if let Some(path) = errors.expect_meta_word(meta) {
        if let Some(first) = slot {
            errors.duplicate_attrs("field kind", &first.ident, path);
        } else if let Some(word) = path.get_ident() {
            *slot = Some(FieldType {
                kind,
                ident: word.clone(),
            });
        }
    }
}

// Whether the attribute is one like `#[<name> ...]`
fn is_matching_attr(name: &str, attr: &syn::Attribute) -> bool {
    attr.path().segments.len() == 1 && attr.path().segments[0].ident == name
}

/// Checks for `#[doc ...]`, which is generated by doc comments.
fn is_doc_attr(attr: &syn::Attribute) -> bool {
    is_matching_attr("doc", attr)
}

/// Checks for `#[argh ...]`
fn is_argh_attr(attr: &syn::Attribute) -> bool {
    is_matching_attr("argh", attr)
}

/// Filters out non-`#[argh(...)]` attributes and converts to a sequence of `syn::Meta`.
fn argh_attr_to_meta_list(
    errors: &Errors,
    attr: &syn::Attribute,
) -> Option<impl IntoIterator<Item = syn::Meta>> {
    if !is_argh_attr(attr) {
        return None;
    }
    let ml = errors.expect_meta_list(&attr.meta)?;
    errors.ok(ml.parse_args_with(
        syn::punctuated::Punctuated::<syn::Meta, syn::Token![,]>::parse_terminated,
    ))
}

/// Represents a `#[derive(FromArgs)]` type's top-level attributes.
#[derive(Default)]
pub struct TypeAttrs {
    pub is_subcommand: Option<syn::Ident>,
    pub name: Option<syn::LitStr>,
    pub description: Option<Description>,
    pub examples: Vec<syn::LitStr>,
    pub notes: Vec<syn::LitStr>,
    pub error_codes: Vec<(syn::LitInt, syn::LitStr)>,
    /// Arguments that trigger printing of the help message
    pub help_triggers: Option<Vec<syn::LitStr>>,
}

impl TypeAttrs {
    /// Parse top-level `#[argh(...)]` attributes
    pub fn parse(errors: &Errors, derive_input: &syn::DeriveInput) -> Self {
        let mut this = TypeAttrs::default();

        for attr in &derive_input.attrs {
            if is_doc_attr(attr) {
                parse_attr_doc(errors, attr, &mut this.description);
                continue;
            }

            let ml: Vec<syn::Meta> = if let Some(ml) = argh_attr_to_meta_list(errors, attr) {
                ml.into_iter().collect()
            } else {
                continue;
            };

            for meta in ml.iter() {
                let name = meta.path();
                if name.is_ident("description") {
                    if let Some(m) = errors.expect_meta_name_value(meta) {
                        parse_attr_description(errors, m, &mut this.description);
                    }
                } else if name.is_ident("error_code") {
                    if let Some(m) = errors.expect_meta_list(meta) {
                        this.parse_attr_error_code(errors, m);
                    }
                } else if name.is_ident("example") {
                    if let Some(m) = errors.expect_meta_name_value(meta) {
                        this.parse_attr_example(errors, m);
                    }
                } else if name.is_ident("name") {
                    if let Some(m) = errors.expect_meta_name_value(meta) {
                        this.parse_attr_name(errors, m);
                    }
                } else if name.is_ident("note") {
                    if let Some(m) = errors.expect_meta_name_value(meta) {
                        this.parse_attr_note(errors, m);
                    }
                } else if name.is_ident("subcommand") {
                    if let Some(ident) = errors.expect_meta_word(meta).and_then(|p| p.get_ident()) {
                        this.parse_attr_subcommand(errors, ident);
                    }
                } else if name.is_ident("help_triggers") {
                    if let Some(m) = errors.expect_meta_list(meta) {
                        Self::parse_help_triggers(m, errors, &mut this);
                    }
                } else {
                    errors.err(
                        meta,
                        concat!(
                            "Invalid type-level `argh` attribute\n",
                            "Expected one of: `description`, `error_code`, `example`, `name`, ",
                            "`note`, `subcommand`, `help_triggers`",
                        ),
                    );
                }
            }

            if this.is_subcommand.is_some() && this.help_triggers.is_some() {
                let help_meta = ml
                    .iter()
                    .find(|meta| meta.path().is_ident("help_triggers"))
                    .unwrap();
                errors.err(help_meta, "Cannot use `help_triggers` on a subcommand");
            }
        }

        this.check_error_codes(errors);
        this
    }

    /// Checks that error codes are within range for `i32` and that they are
    /// never duplicated.
    fn check_error_codes(&self, errors: &Errors) {
        // map from error code to index
        let mut map: HashMap<u64, usize> = HashMap::new();
        for (index, (lit_int, _lit_str)) in self.error_codes.iter().enumerate() {
            let value = match lit_int.base10_parse::<u64>() {
                Ok(v) => v,
                Err(e) => {
                    errors.push(e);
                    continue;
                }
            };
            if value > (i32::MAX as u64) {
                errors.err(lit_int, "Error code out of range for `i32`");
            }
            match map.entry(value) {
                Entry::Occupied(previous) => {
                    let previous_index = *previous.get();
                    let (previous_lit_int, _previous_lit_str) = &self.error_codes[previous_index];
                    errors.err(lit_int, &format!("Duplicate error code {}", value));
                    errors.err(
                        previous_lit_int,
                        &format!("Error code {} previously defined here", value),
                    );
                }
                Entry::Vacant(slot) => {
                    slot.insert(index);
                }
            }
        }
    }

    fn parse_attr_error_code(&mut self, errors: &Errors, ml: &syn::MetaList) {
        errors.ok(ml.parse_args_with(|input: syn::parse::ParseStream| {
            let err_code = input.parse()?;
            input.parse::<syn::Token![,]>()?;
            let err_msg = input.parse()?;
            if let (Some(err_code), Some(err_msg)) = (
                errors.expect_lit_int(&err_code),
                errors.expect_lit_str(&err_msg),
            ) {
                self.error_codes.push((err_code.clone(), err_msg.clone()));
            }
            Ok(())
        }));
    }

    fn parse_attr_example(&mut self, errors: &Errors, m: &syn::MetaNameValue) {
        parse_attr_multi_string(errors, m, &mut self.examples)
    }

    fn parse_attr_name(&mut self, errors: &Errors, m: &syn::MetaNameValue) {
        parse_attr_single_string(errors, m, "name", &mut self.name);
        if let Some(name) = &self.name
            && name.value() == "help"
        {
            errors.err(name, "Custom `help` commands are not supported.");
        }
    }

    fn parse_attr_note(&mut self, errors: &Errors, m: &syn::MetaNameValue) {
        parse_attr_multi_string(errors, m, &mut self.notes)
    }

    fn parse_attr_subcommand(&mut self, errors: &Errors, ident: &syn::Ident) {
        if let Some(first) = &self.is_subcommand {
            errors.duplicate_attrs("subcommand", first, ident);
        } else {
            self.is_subcommand = Some(ident.clone());
        }
    }

    // get the list of arguments that trigger printing of the help message as a vector of strings (help_arguments("-h", "--help", "help"))
    fn parse_help_triggers(m: &syn::MetaList, errors: &Errors, this: &mut TypeAttrs) {
        let parser = Punctuated::<syn::Expr, syn::Token![,]>::parse_terminated;
        match parser.parse(m.tokens.clone().into()) {
            Ok(args) => {
                let mut triggers = Vec::new();
                for arg in args {
                    if let syn::Expr::Lit(syn::ExprLit {
                        lit: syn::Lit::Str(lit_str),
                        ..
                    }) = arg
                    {
                        triggers.push(lit_str);
                    }
                }

                this.help_triggers = Some(triggers);
            }
            Err(err) => errors.push(err),
        }
    }
}

/// Represents an enum variant's attributes.
#[derive(Default)]
pub struct VariantAttrs {
    pub is_dynamic: Option<syn::Path>,
}

impl VariantAttrs {
    /// Parse enum variant `#[argh(...)]` attributes
    pub fn parse(errors: &Errors, variant: &syn::Variant) -> Self {
        let mut this = VariantAttrs::default();

        let fields = match &variant.fields {
            syn::Fields::Named(fields) => Some(&fields.named),
            syn::Fields::Unnamed(fields) => Some(&fields.unnamed),
            syn::Fields::Unit => None,
        };

        for field in fields.into_iter().flatten() {
            for attr in &field.attrs {
                if is_argh_attr(attr) {
                    err_unused_enum_attr(errors, attr);
                }
            }
        }

        for attr in &variant.attrs {
            let ml = if let Some(ml) = argh_attr_to_meta_list(errors, attr) {
                ml
            } else {
                continue;
            };

            for meta in ml {
                let name = meta.path();
                if name.is_ident("dynamic") {
                    if let Some(prev) = this.is_dynamic.as_ref() {
                        errors.duplicate_attrs("dynamic", prev, &meta);
                    } else {
                        this.is_dynamic = errors.expect_meta_word(&meta).cloned();
                    }
                } else {
                    errors.err(
                        &meta,
                        "Invalid variant-level `argh` attribute\n\
                         Variants can only have the #[argh(dynamic)] attribute.",
                    );
                }
            }
        }

        this
    }
}

fn check_option_description(errors: &Errors, desc: &str, span: Span) {
    let chars = &mut desc.trim().chars();
    match (chars.next(), chars.next()) {
        (Some(x), _) if x.is_lowercase() => {}
        // If both the first and second letter are not lowercase,
        // this is likely an initialism which should be allowed.
        (Some(x), Some(y)) if !x.is_lowercase() && (y.is_alphanumeric() && !y.is_lowercase()) => {}
        _ => {
            errors.err_span(span, "Descriptions must begin with a lowercase letter");
        }
    }
}

fn parse_attr_single_string(
    errors: &Errors,
    m: &syn::MetaNameValue,
    name: &str,
    slot: &mut Option<syn::LitStr>,
) {
    if let Some(first) = slot {
        errors.duplicate_attrs(name, first, m);
    } else if let Some(lit_str) = errors.expect_lit_str(&m.value) {
        *slot = Some(lit_str.clone());
    }
}

fn parse_attr_multi_string(errors: &Errors, m: &syn::MetaNameValue, list: &mut Vec<syn::LitStr>) {
    if let Some(lit_str) = errors.expect_lit_str(&m.value) {
        list.push(lit_str.clone());
    }
}

fn parse_attr_doc(errors: &Errors, attr: &syn::Attribute, slot: &mut Option<Description>) {
    let nv = if let Some(nv) = errors.expect_meta_name_value(&attr.meta) {
        nv
    } else {
        return;
    };

    // Don't replace an existing explicit description.
    if slot.as_ref().map(|d| d.explicit).unwrap_or(false) {
        return;
    }

    if let Some(lit_str) = errors.expect_lit_str(&nv.value) {
        let lit_str = if let Some(previous) = slot {
            let previous = &previous.content;
            let previous_span = previous.span();
            syn::LitStr::new(
                &(previous.value() + &unescape_doc(lit_str.value())),
                previous_span,
            )
        } else {
            syn::LitStr::new(&unescape_doc(lit_str.value()), lit_str.span())
        };
        *slot = Some(Description {
            explicit: false,
            content: lit_str,
        });
    }
}

/// Replaces escape sequences in doc-comments with the characters they represent.
///
/// Rustdoc understands CommonMark escape sequences consisting of a backslash followed by an ASCII
/// punctuation character. Any other backslash is treated as a literal backslash.
fn unescape_doc(s: String) -> String {
    let mut result = String::with_capacity(s.len());

    let mut characters = s.chars().peekable();
    while let Some(mut character) = characters.next() {
        if character == '\\'
            && let Some(next_character) = characters.peek()
            && next_character.is_ascii_punctuation()
        {
            character = *next_character;
            characters.next();
        }

        // Braces must be escaped as this string will be used as a format string
        if character == '{' || character == '}' {
            result.push(character);
        }

        result.push(character);
    }

    result
}

fn parse_attr_description(errors: &Errors, m: &syn::MetaNameValue, slot: &mut Option<Description>) {
    let lit_str = if let Some(lit_str) = errors.expect_lit_str(&m.value) {
        lit_str
    } else {
        return;
    };

    // Don't allow multiple explicit (non doc-comment) descriptions
    if let Some(description) = slot
        && description.explicit
    {
        errors.duplicate_attrs("description", &description.content, lit_str);
    }

    *slot = Some(Description {
        explicit: true,
        content: lit_str.clone(),
    });
}

/// Checks that a `#![derive(FromArgs)]` enum has an `#[argh(subcommand)]`
/// attribute and that it does not have any other type-level `#[argh(...)]` attributes.
pub fn check_enum_type_attrs(errors: &Errors, type_attrs: &TypeAttrs, type_span: &Span) {
    let TypeAttrs {
        is_subcommand,
        name,
        description,
        examples,
        notes,
        error_codes,
        help_triggers,
    } = type_attrs;

    // Ensure that `#[argh(subcommand)]` is present.
    if is_subcommand.is_none() {
        errors.err_span(
            *type_span,
            concat!(
                "`#![derive(FromArgs)]` on `enum`s can only be used to enumerate subcommands.\n",
                "Consider adding `#[argh(subcommand)]` to the `enum` declaration.",
            ),
        );
    }

    // Error on all other type-level attributes.
    if let Some(name) = name {
        err_unused_enum_attr(errors, name);
    }
    if let Some(description) = description
        && description.explicit
    {
        err_unused_enum_attr(errors, &description.content);
    }
    if let Some(example) = examples.first() {
        err_unused_enum_attr(errors, example);
    }
    if let Some(note) = notes.first() {
        err_unused_enum_attr(errors, note);
    }
    if let Some(err_code) = error_codes.first() {
        err_unused_enum_attr(errors, &err_code.0);
    }
    if let Some(triggers) = help_triggers
        && let Some(trigger) = triggers.first()
    {
        err_unused_enum_attr(errors, trigger);
    }
}

fn err_unused_enum_attr(errors: &Errors, location: &impl syn::spanned::Spanned) {
    errors.err(
        location,
        concat!(
            "Unused `argh` attribute on `#![derive(FromArgs)]` enum. ",
            "Such `enum`s can only be used to dispatch to subcommands, ",
            "and should only contain the #[argh(subcommand)] attribute.",
        ),
    );
}

```

`native/src/base/derive/decodable.rs`:

```rs
use proc_macro2::TokenStream;
use quote::{quote, quote_spanned};
use syn::spanned::Spanned;
use syn::{Data, DeriveInput, Fields, GenericParam, parse_macro_input, parse_quote};

pub(crate) fn derive_decodable(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    let name = input.ident;

    // Add a bound `T: Decodable` to every type parameter T.
    let mut generics = input.generics;
    for param in &mut generics.params {
        if let GenericParam::Type(ref mut type_param) = *param {
            type_param
                .bounds
                .push(parse_quote!(crate::socket::Decodable));
        }
    }

    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let encode = gen_encode(&input.data);
    let decode = gen_decode(&input.data);

    let expanded = quote! {
        // The generated impl.
        impl #impl_generics crate::socket::Encodable for #name #ty_generics #where_clause {
            fn encode(&self, w: &mut impl std::io::Write) -> std::io::Result<()> {
                #encode
                Ok(())
            }
        }
        impl #impl_generics crate::socket::Decodable for #name #ty_generics #where_clause {
            fn decode(r: &mut impl std::io::Read) -> std::io::Result<Self> {
                let val = #decode;
                Ok(val)
            }
        }
    };
    proc_macro::TokenStream::from(expanded)
}

// Generate an expression to encode each field.
fn gen_encode(data: &Data) -> TokenStream {
    match *data {
        Data::Struct(ref data) => {
            match data.fields {
                Fields::Named(ref fields) => {
                    // Expands to an expression like
                    //
                    //     self.x.encode(w)?; self.y.encode(w)?; self.z.encode(w)?;
                    let recurse = fields.named.iter().map(|f| {
                        let name = &f.ident;
                        quote_spanned! { f.span() =>
                            crate::socket::Encodable::encode(&self.#name, w)?;
                        }
                    });
                    quote! {
                        #(#recurse)*
                    }
                }
                _ => unimplemented!(),
            }
        }
        Data::Enum(_) | Data::Union(_) => unimplemented!(),
    }
}

// Generate an expression to decode each field.
fn gen_decode(data: &Data) -> TokenStream {
    match *data {
        Data::Struct(ref data) => {
            match data.fields {
                Fields::Named(ref fields) => {
                    // Expands to an expression like
                    //
                    //     Self { x: Decodable::decode(r)?, y: Decodable::decode(r)?, }
                    let recurse = fields.named.iter().map(|f| {
                        let name = &f.ident;
                        quote_spanned! { f.span() =>
                            #name: crate::socket::Decodable::decode(r)?,
                        }
                    });
                    quote! {
                        Self { #(#recurse)* }
                    }
                }
                _ => unimplemented!(),
            }
        }
        Data::Enum(_) | Data::Union(_) => unimplemented!(),
    }
}

```

`native/src/base/derive/lib.rs`:

```rs
#![recursion_limit = "256"]

use proc_macro::TokenStream;

mod argh;
mod decodable;

#[proc_macro_derive(Decodable)]
pub fn derive_decodable(input: TokenStream) -> TokenStream {
    decodable::derive_decodable(input)
}

/// Entrypoint for `#[derive(FromArgs)]`.
#[proc_macro_derive(FromArgs, attributes(argh))]
pub fn argh_derive(input: TokenStream) -> TokenStream {
    let ast = syn::parse_macro_input!(input as syn::DeriveInput);
    let token = argh::impl_from_args(&ast);
    token.into()
}

```

`native/src/base/dir.rs`:

```rs
use crate::cxx_extern::readlinkat;
use crate::{
    FsPathBuilder, LibcReturn, LoggedResult, OsError, OsResult, Utf8CStr, Utf8CStrBuf, cstr, errno,
    fd_path, fd_set_attr,
};
use libc::{dirent, mode_t};
use nix::errno::Errno;
use nix::fcntl::{AtFlags, OFlag};
use nix::sys::stat::Mode;
use nix::unistd::UnlinkatFlags;
use std::fs::File;
use std::ops::Deref;
use std::os::fd::{AsFd, AsRawFd, BorrowedFd, IntoRawFd, OwnedFd, RawFd};
use std::ptr::NonNull;
use std::slice;

pub struct DirEntry<'a> {
    dir: &'a Directory,
    entry: NonNull<dirent>,
    d_name_len: usize,
}

impl DirEntry<'_> {
    pub fn as_ptr(&self) -> *mut dirent {
        self.entry.as_ptr()
    }

    pub fn name(&self) -> &Utf8CStr {
        // SAFETY: Utf8CStr is already validated in Directory::read
        unsafe {
            Utf8CStr::from_bytes_unchecked(slice::from_raw_parts(
                self.d_name.as_ptr().cast(),
                self.d_name_len,
            ))
        }
    }

    pub fn resolve_path(&self, buf: &mut dyn Utf8CStrBuf) -> OsResult<'static, ()> {
        self.dir.path_at(self.name(), buf)
    }

    pub fn is_dir(&self) -> bool {
        self.d_type == libc::DT_DIR
    }

    pub fn is_file(&self) -> bool {
        self.d_type == libc::DT_REG
    }

    pub fn is_symlink(&self) -> bool {
        self.d_type == libc::DT_LNK
    }

    pub fn is_block_device(&self) -> bool {
        self.d_type == libc::DT_BLK
    }

    pub fn is_char_device(&self) -> bool {
        self.d_type == libc::DT_CHR
    }

    pub fn is_fifo(&self) -> bool {
        self.d_type == libc::DT_FIFO
    }

    pub fn is_socket(&self) -> bool {
        self.d_type == libc::DT_SOCK
    }

    pub fn unlink(&self) -> OsResult<'_, ()> {
        let flag = if self.is_dir() {
            UnlinkatFlags::RemoveDir
        } else {
            UnlinkatFlags::NoRemoveDir
        };
        self.dir.unlink_at(self.name(), flag)
    }

    pub fn read_link(&self, buf: &mut dyn Utf8CStrBuf) -> OsResult<'_, ()> {
        self.dir.read_link_at(self.name(), buf)
    }

    pub fn open_as_dir(&self) -> OsResult<'_, Directory> {
        if !self.is_dir() {
            return Err(OsError::new(
                Errno::ENOTDIR,
                "fdopendir",
                Some(self.name()),
                None,
            ));
        }
        self.dir.open_as_dir_at(self.name())
    }

    pub fn open_as_file(&self, flags: OFlag) -> OsResult<'_, File> {
        if self.is_dir() {
            return Err(OsError::new(
                Errno::EISDIR,
                "open_as_file",
                Some(self.name()),
                None,
            ));
        }
        self.dir.open_as_file_at(self.name(), flags, 0)
    }

    pub fn rename_to<'a, 'entry: 'a>(
        &'entry self,
        new_dir: impl AsFd,
        path: &'a Utf8CStr,
    ) -> OsResult<'a, ()> {
        self.dir.rename_at(self.name(), new_dir, path)
    }
}

impl Deref for DirEntry<'_> {
    type Target = dirent;

    fn deref(&self) -> &dirent {
        unsafe { self.entry.as_ref() }
    }
}

#[repr(transparent)]
pub struct Directory {
    inner: NonNull<libc::DIR>,
}

pub enum WalkResult {
    Continue,
    Abort,
    Skip,
}

impl Directory {
    fn open_at<'a>(&self, name: &'a Utf8CStr, flags: OFlag, mode: mode_t) -> OsResult<'a, OwnedFd> {
        nix::fcntl::openat(
            self,
            name,
            flags | OFlag::O_CLOEXEC,
            Mode::from_bits_truncate(mode),
        )
        .into_os_result("openat", Some(name), None)
    }

    fn path_at(&self, name: &Utf8CStr, buf: &mut dyn Utf8CStrBuf) -> OsResult<'static, ()> {
        self.resolve_path(buf)?;
        buf.append_path(name);
        Ok(())
    }
}

// Low-level methods, we should track the caller when error occurs, so return OsResult.
impl Directory {
    pub fn open(path: &Utf8CStr) -> OsResult<'_, Directory> {
        let dirp = unsafe { libc::opendir(path.as_ptr()) };
        let dirp = dirp.into_os_result("opendir", Some(path), None)?;
        Ok(Directory { inner: dirp })
    }

    pub fn read(&mut self) -> OsResult<'static, Option<DirEntry<'_>>> {
        *errno() = 0;
        let e = unsafe { libc::readdir(self.inner.as_ptr()) };
        if e.is_null() {
            return if *errno() != 0 {
                Err(OsError::last_os_error("readdir", None, None))
            } else {
                Ok(None)
            };
        }
        // Skip non UTF-8 entries, ".", and ".."
        unsafe {
            let entry = &*e;

            let Ok(name) = Utf8CStr::from_ptr(entry.d_name.as_ptr()) else {
                return self.read();
            };

            if name == "." || name == ".." {
                self.read()
            } else {
                let e = DirEntry {
                    dir: self,
                    entry: NonNull::from(entry),
                    d_name_len: name.as_bytes_with_nul().len(),
                };
                Ok(Some(e))
            }
        }
    }

    pub fn rewind(&mut self) {
        unsafe { libc::rewinddir(self.inner.as_ptr()) };
    }

    pub fn open_as_dir_at<'a>(&self, name: &'a Utf8CStr) -> OsResult<'a, Directory> {
        let fd = self.open_at(name, OFlag::O_RDONLY, 0)?;
        Directory::try_from(fd).map_err(|e| e.set_args(Some(name), None))
    }

    pub fn open_as_file_at<'a>(
        &self,
        name: &'a Utf8CStr,
        flags: OFlag,
        mode: mode_t,
    ) -> OsResult<'a, File> {
        let fd = self.open_at(name, flags, mode)?;
        Ok(File::from(fd))
    }

    pub fn read_link_at<'a>(
        &self,
        name: &'a Utf8CStr,
        buf: &mut dyn Utf8CStrBuf,
    ) -> OsResult<'a, ()> {
        buf.clear();
        unsafe {
            readlinkat(
                self.as_raw_fd(),
                name.as_ptr(),
                buf.as_mut_ptr().cast(),
                buf.capacity(),
            )
            .check_os_err("readlinkat", Some(name), None)?;
        }
        buf.rebuild().ok();
        Ok(())
    }

    pub fn mkdir_at<'a>(&self, name: &'a Utf8CStr, mode: mode_t) -> OsResult<'a, ()> {
        match nix::sys::stat::mkdirat(self, name, Mode::from_bits_truncate(mode)) {
            Ok(_) | Err(Errno::EEXIST) => Ok(()),
            Err(e) => Err(OsError::new(e, "mkdirat", Some(name), None)),
        }
    }

    // ln -s target self/name
    pub fn create_symlink_at<'a>(
        &self,
        name: &'a Utf8CStr,
        target: &'a Utf8CStr,
    ) -> OsResult<'a, ()> {
        nix::unistd::symlinkat(target, self, name).check_os_err(
            "symlinkat",
            Some(target),
            Some(name),
        )
    }

    pub fn unlink_at<'a>(&self, name: &'a Utf8CStr, flag: UnlinkatFlags) -> OsResult<'a, ()> {
        nix::unistd::unlinkat(self, name, flag).check_os_err("unlinkat", Some(name), None)
    }

    pub fn contains_path(&self, path: &Utf8CStr) -> bool {
        // WARNING: Using faccessat is incorrect, because the raw linux kernel syscall
        // does not support the flag AT_SYMLINK_NOFOLLOW until 5.8 with faccessat2.
        // Use fstatat to check the existence of a file instead.
        nix::sys::stat::fstatat(self, path, AtFlags::AT_SYMLINK_NOFOLLOW).is_ok()
    }

    pub fn resolve_path(&self, buf: &mut dyn Utf8CStrBuf) -> OsResult<'static, ()> {
        fd_path(self.as_raw_fd(), buf)
    }

    pub fn rename_at<'a>(
        &self,
        old: &'a Utf8CStr,
        new_dir: impl AsFd,
        new: &'a Utf8CStr,
    ) -> OsResult<'a, ()> {
        nix::fcntl::renameat(self, old, new_dir, new).check_os_err("renameat", Some(old), Some(new))
    }
}

// High-level helper methods, composed of multiple operations.
// We should treat these as application logic and log ASAP, so return LoggedResult.
impl Directory {
    pub fn post_order_walk<F: FnMut(&DirEntry) -> LoggedResult<WalkResult>>(
        &mut self,
        mut f: F,
    ) -> LoggedResult<WalkResult> {
        self.post_order_walk_impl(&mut f)
    }

    pub fn pre_order_walk<F: FnMut(&DirEntry) -> LoggedResult<WalkResult>>(
        &mut self,
        mut f: F,
    ) -> LoggedResult<WalkResult> {
        self.pre_order_walk_impl(&mut f)
    }

    pub fn remove_all(mut self) -> LoggedResult<()> {
        self.post_order_walk(|e| {
            e.unlink()?;
            Ok(WalkResult::Continue)
        })?;
        Ok(())
    }

    pub fn copy_into(&mut self, dir: &Directory) -> LoggedResult<()> {
        let mut buf = cstr::buf::default();
        self.copy_into_impl(dir, &mut buf)
    }

    pub fn move_into(&mut self, dir: &Directory) -> LoggedResult<()> {
        while let Some(ref e) = self.read()? {
            if e.is_dir() && dir.contains_path(e.name()) {
                // Destination folder exists, needs recursive move
                let mut src = e.open_as_dir()?;
                let dest = dir.open_as_dir_at(e.name())?;
                src.move_into(&dest)?;
                return Ok(e.unlink()?);
            }
            e.rename_to(dir, e.name())?;
        }
        Ok(())
    }

    pub fn link_into(&mut self, dir: &Directory) -> LoggedResult<()> {
        let mut buf = cstr::buf::default();
        self.link_into_impl(dir, &mut buf)
    }
}

impl Directory {
    fn post_order_walk_impl<F: FnMut(&DirEntry) -> LoggedResult<WalkResult>>(
        &mut self,
        f: &mut F,
    ) -> LoggedResult<WalkResult> {
        use WalkResult::*;
        loop {
            match self.read()? {
                None => return Ok(Continue),
                Some(ref e) => {
                    if e.is_dir() {
                        let mut dir = e.open_as_dir()?;
                        if let Abort = dir.post_order_walk_impl(f)? {
                            return Ok(Abort);
                        }
                    }
                    match f(e)? {
                        Abort => return Ok(Abort),
                        Skip => return Ok(Continue),
                        Continue => {}
                    }
                }
            }
        }
    }

    fn pre_order_walk_impl<F: FnMut(&DirEntry) -> LoggedResult<WalkResult>>(
        &mut self,
        f: &mut F,
    ) -> LoggedResult<WalkResult> {
        use WalkResult::*;
        loop {
            match self.read()? {
                None => return Ok(Continue),
                Some(ref e) => match f(e)? {
                    Abort => return Ok(Abort),
                    Skip => continue,
                    Continue => {
                        if e.is_dir() {
                            let mut dir = e.open_as_dir()?;
                            if let Abort = dir.pre_order_walk_impl(f)? {
                                return Ok(Abort);
                            }
                        }
                    }
                },
            }
        }
    }

    fn copy_into_impl(
        &mut self,
        dest_dir: &Directory,
        buf: &mut dyn Utf8CStrBuf,
    ) -> LoggedResult<()> {
        while let Some(ref e) = self.read()? {
            e.resolve_path(buf)?;
            let attr = buf.get_attr()?;
            if e.is_dir() {
                dest_dir.mkdir_at(e.name(), 0o777)?;
                let mut src = e.open_as_dir()?;
                let dest = dest_dir.open_as_dir_at(e.name())?;
                src.copy_into_impl(&dest, buf)?;
                fd_set_attr(dest.as_raw_fd(), &attr)?;
            } else if e.is_file() {
                let mut src = e.open_as_file(OFlag::O_RDONLY)?;
                let mut dest = dest_dir.open_as_file_at(
                    e.name(),
                    OFlag::O_WRONLY | OFlag::O_CREAT | OFlag::O_TRUNC,
                    0o777,
                )?;
                std::io::copy(&mut src, &mut dest)?;
                fd_set_attr(dest.as_raw_fd(), &attr)?;
            } else if e.is_symlink() {
                e.read_link(buf)?;
                dest_dir.create_symlink_at(e.name(), buf)?;
                dest_dir.path_at(e.name(), buf)?;
                buf.set_attr(&attr)?;
            }
        }
        Ok(())
    }

    fn link_into_impl(
        &mut self,
        dest_dir: &Directory,
        buf: &mut dyn Utf8CStrBuf,
    ) -> LoggedResult<()> {
        while let Some(ref e) = self.read()? {
            if e.is_dir() {
                dest_dir.mkdir_at(e.name(), 0o777)?;
                e.resolve_path(buf)?;
                let attr = buf.get_attr()?;
                let mut src = e.open_as_dir()?;
                let dest = dest_dir.open_as_dir_at(e.name())?;
                src.link_into_impl(&dest, buf)?;
                fd_set_attr(dest.as_raw_fd(), &attr)?;
            } else {
                nix::unistd::linkat(e.dir, e.name(), dest_dir, e.name(), AtFlags::empty())
                    .check_os_err("linkat", Some(e.name()), None)?;
            }
        }
        Ok(())
    }
}

impl TryFrom<OwnedFd> for Directory {
    type Error = OsError<'static>;

    fn try_from(fd: OwnedFd) -> OsResult<'static, Self> {
        let dirp = unsafe { libc::fdopendir(fd.into_raw_fd()) };
        let dirp = dirp.into_os_result("fdopendir", None, None)?;
        Ok(Directory { inner: dirp })
    }
}

impl AsRawFd for Directory {
    fn as_raw_fd(&self) -> RawFd {
        unsafe { libc::dirfd(self.inner.as_ptr()) }
    }
}

impl AsFd for Directory {
    fn as_fd(&self) -> BorrowedFd<'_> {
        unsafe { BorrowedFd::borrow_raw(self.as_raw_fd()) }
    }
}

impl Drop for Directory {
    fn drop(&mut self) {
        unsafe {
            libc::closedir(self.inner.as_ptr());
        }
    }
}

```

`native/src/base/files.rs`:

```rs
use crate::{
    Directory, FsPathFollow, LibcReturn, LoggedResult, OsError, OsResult, Utf8CStr, Utf8CStrBuf,
    cstr, errno, error,
};
use bytemuck::{Pod, bytes_of, bytes_of_mut};
use libc::{c_uint, makedev, mode_t};
use nix::errno::Errno;
use nix::fcntl::{AT_FDCWD, OFlag};
use nix::sys::stat::{FchmodatFlags, Mode};
use nix::unistd::{AccessFlags, Gid, Uid};
use num_traits::AsPrimitive;
use std::cmp::min;
use std::ffi::CStr;
use std::fmt::Display;
use std::fs::File;
use std::io::{BufRead, BufReader, Read, Seek, SeekFrom, Write};
use std::mem::MaybeUninit;
use std::os::fd::{AsFd, BorrowedFd};
use std::os::unix::ffi::OsStrExt;
use std::os::unix::io::{AsRawFd, OwnedFd, RawFd};
use std::path::Path;
use std::{io, mem, ptr, slice};

pub trait ReadExt {
    fn skip(&mut self, len: usize) -> io::Result<()>;
    fn read_pod<F: Pod>(&mut self, data: &mut F) -> io::Result<()>;
}

impl<T: Read> ReadExt for T {
    fn skip(&mut self, mut len: usize) -> io::Result<()> {
        let mut buf = MaybeUninit::<[u8; 4096]>::uninit();
        let buf = unsafe { buf.assume_init_mut() };
        while len > 0 {
            let l = min(buf.len(), len);
            self.read_exact(&mut buf[..l])?;
            len -= l;
        }
        Ok(())
    }

    fn read_pod<F: Pod>(&mut self, data: &mut F) -> io::Result<()> {
        self.read_exact(bytes_of_mut(data))
    }
}

pub trait ReadSeekExt {
    fn skip(&mut self, len: usize) -> io::Result<()>;
}

impl<T: Read + Seek> ReadSeekExt for T {
    fn skip(&mut self, len: usize) -> io::Result<()> {
        if self.seek(SeekFrom::Current(len as i64)).is_err() {
            // If the file is not actually seekable, fallback to read
            ReadExt::skip(self, len)?;
        }
        Ok(())
    }
}

pub trait BufReadExt {
    fn for_each_line<F: FnMut(&mut String) -> bool>(&mut self, f: F);
    fn for_each_prop<F: FnMut(&str, &str) -> bool>(&mut self, f: F);
}

impl<T: BufRead> BufReadExt for T {
    fn for_each_line<F: FnMut(&mut String) -> bool>(&mut self, mut f: F) {
        let mut buf = String::new();
        loop {
            match self.read_line(&mut buf) {
                Ok(0) => break,
                Ok(_) => {
                    if !f(&mut buf) {
                        break;
                    }
                }
                Err(e) => {
                    error!("{}", e);
                    break;
                }
            };
            buf.clear();
        }
    }

    fn for_each_prop<F: FnMut(&str, &str) -> bool>(&mut self, mut f: F) {
        self.for_each_line(|line| {
            // Reserve an additional byte, because this string will be manually
            // null terminated on the C++ side, and it may need more space.
            line.reserve(1);
            let line = line.trim();
            if line.starts_with('#') {
                return true;
            }
            if let Some((key, value)) = line.split_once('=') {
                return f(key.trim(), value.trim());
            }
            true
        });
    }
}

pub trait WriteExt {
    fn write_zeros(&mut self, len: usize) -> io::Result<()>;
    fn write_pod<F: Pod>(&mut self, data: &F) -> io::Result<()>;
}

impl<T: Write> WriteExt for T {
    fn write_zeros(&mut self, mut len: usize) -> io::Result<()> {
        let buf = [0_u8; 4096];
        while len > 0 {
            let l = min(buf.len(), len);
            self.write_all(&buf[..l])?;
            len -= l;
        }
        Ok(())
    }

    fn write_pod<F: Pod>(&mut self, data: &F) -> io::Result<()> {
        self.write_all(bytes_of(data))
    }
}

pub enum FileOrStd {
    StdIn,
    StdOut,
    StdErr,
    File(File),
}

impl FileOrStd {
    pub fn as_file(&self) -> &File {
        let raw_fd_ref: &'static RawFd = match self {
            FileOrStd::StdIn => &0,
            FileOrStd::StdOut => &1,
            FileOrStd::StdErr => &2,
            FileOrStd::File(file) => return file,
        };
        // SAFETY: File is guaranteed to have the same ABI as RawFd
        unsafe { mem::transmute(raw_fd_ref) }
    }
}

fn open_fd(path: &Utf8CStr, flags: OFlag, mode: mode_t) -> OsResult<'_, OwnedFd> {
    nix::fcntl::open(path, flags, Mode::from_bits_truncate(mode)).into_os_result(
        "open",
        Some(path),
        None,
    )
}

pub fn fd_path(fd: RawFd, buf: &mut dyn Utf8CStrBuf) -> OsResult<'static, ()> {
    let path = cstr::buf::new::<64>()
        .join_path("/proc/self/fd")
        .join_path_fmt(fd);
    path.read_link(buf).map_err(|e| e.set_args(None, None))
}

pub struct FileAttr {
    pub st: libc::stat,
    #[cfg(feature = "selinux")]
    pub con: crate::Utf8CStrBufArr<128>,
}

impl Default for FileAttr {
    fn default() -> Self {
        Self::new()
    }
}

impl FileAttr {
    pub fn new() -> Self {
        FileAttr {
            st: unsafe { mem::zeroed() },
            #[cfg(feature = "selinux")]
            con: crate::Utf8CStrBufArr::new(),
        }
    }

    #[inline(always)]
    #[allow(clippy::unnecessary_cast)]
    fn is(&self, mode: mode_t) -> bool {
        (self.st.st_mode & libc::S_IFMT as c_uint) as mode_t == mode
    }

    pub fn is_dir(&self) -> bool {
        self.is(libc::S_IFDIR)
    }

    pub fn is_file(&self) -> bool {
        self.is(libc::S_IFREG)
    }

    pub fn is_symlink(&self) -> bool {
        self.is(libc::S_IFLNK)
    }

    pub fn is_block_device(&self) -> bool {
        self.is(libc::S_IFBLK)
    }

    pub fn is_char_device(&self) -> bool {
        self.is(libc::S_IFCHR)
    }

    pub fn is_fifo(&self) -> bool {
        self.is(libc::S_IFIFO)
    }

    pub fn is_socket(&self) -> bool {
        self.is(libc::S_IFSOCK)
    }

    pub fn is_whiteout(&self) -> bool {
        self.is_char_device() && self.st.st_rdev == 0
    }
}

const XATTR_NAME_SELINUX: &CStr = c"security.selinux";

// Low-level methods, we should track the caller when error occurs, so return OsResult.
impl Utf8CStr {
    pub fn follow_link(&self) -> &FsPathFollow {
        unsafe { mem::transmute(self) }
    }

    pub fn open(&self, flags: OFlag) -> OsResult<'_, File> {
        Ok(File::from(open_fd(self, flags, 0)?))
    }

    pub fn create(&self, flags: OFlag, mode: mode_t) -> OsResult<'_, File> {
        Ok(File::from(open_fd(self, OFlag::O_CREAT | flags, mode)?))
    }

    pub fn exists(&self) -> bool {
        nix::sys::stat::lstat(self).is_ok()
    }

    pub fn rename_to<'a>(&'a self, name: &'a Utf8CStr) -> OsResult<'a, ()> {
        nix::fcntl::renameat(AT_FDCWD, self, AT_FDCWD, name).check_os_err(
            "rename",
            Some(self),
            Some(name),
        )
    }

    pub fn remove(&self) -> OsResult<'_, ()> {
        unsafe { libc::remove(self.as_ptr()).check_os_err("remove", Some(self), None) }
    }

    #[allow(clippy::unnecessary_cast)]
    pub fn read_link(&self, buf: &mut dyn Utf8CStrBuf) -> OsResult<'_, ()> {
        buf.clear();
        unsafe {
            let r = libc::readlink(self.as_ptr(), buf.as_mut_ptr(), buf.capacity() - 1)
                .into_os_result("readlink", Some(self), None)? as isize;
            *(buf.as_mut_ptr().offset(r) as *mut u8) = b'\0';
        }
        buf.rebuild().ok();
        Ok(())
    }

    pub fn mkdir(&self, mode: mode_t) -> OsResult<'_, ()> {
        match nix::unistd::mkdir(self, Mode::from_bits_truncate(mode)) {
            Ok(_) | Err(Errno::EEXIST) => Ok(()),
            Err(e) => Err(OsError::new(e, "mkdir", Some(self), None)),
        }
    }

    // Inspired by https://android.googlesource.com/platform/bionic/+/master/libc/bionic/realpath.cpp
    pub fn realpath(&self, buf: &mut dyn Utf8CStrBuf) -> OsResult<'_, ()> {
        let fd = self.open(OFlag::O_PATH | OFlag::O_CLOEXEC)?;
        let mut skip_check = false;

        let st1 = match nix::sys::stat::fstat(&fd) {
            Ok(st) => st,
            Err(_) => {
                // This will only fail on Linux < 3.6
                skip_check = true;
                unsafe { mem::zeroed() }
            }
        };

        fd_path(fd.as_raw_fd(), buf)?;

        let st2 = nix::sys::stat::stat(buf.as_cstr()).into_os_result("stat", Some(self), None)?;
        if !skip_check && (st2.st_dev != st1.st_dev || st2.st_ino != st1.st_ino) {
            return Err(OsError::new(Errno::ENOENT, "realpath", Some(self), None));
        }
        Ok(())
    }

    pub fn get_attr(&self) -> OsResult<'_, FileAttr> {
        #[allow(unused_mut)]
        let mut attr = FileAttr {
            st: nix::sys::stat::lstat(self).into_os_result("lstat", Some(self), None)?,
            #[cfg(feature = "selinux")]
            con: cstr::buf::new(),
        };
        #[cfg(feature = "selinux")]
        self.get_secontext(&mut attr.con)?;
        Ok(attr)
    }

    pub fn set_attr<'a>(&'a self, attr: &'a FileAttr) -> OsResult<'a, ()> {
        if !attr.is_symlink()
            && let Err(e) = self.follow_link().chmod((attr.st.st_mode & 0o777).as_())
        {
            // Double check if self is symlink before reporting error
            let self_attr = self.get_attr()?;
            if !self_attr.is_symlink() {
                return Err(e);
            }
        }

        unsafe {
            libc::lchown(self.as_ptr(), attr.st.st_uid, attr.st.st_gid).check_os_err(
                "lchown",
                Some(self),
                None,
            )?;
        }

        #[cfg(feature = "selinux")]
        if !attr.con.is_empty() {
            self.set_secontext(&attr.con)?;
        }
        Ok(())
    }

    pub fn get_secontext(&self, con: &mut dyn Utf8CStrBuf) -> OsResult<'_, ()> {
        con.clear();
        let result = unsafe {
            libc::lgetxattr(
                self.as_ptr(),
                XATTR_NAME_SELINUX.as_ptr(),
                con.as_mut_ptr().cast(),
                con.capacity(),
            )
            .check_err()
        };

        match result {
            Ok(_) => {
                con.rebuild().ok();
                Ok(())
            }
            Err(Errno::ENODATA) => Ok(()),
            Err(e) => Err(OsError::new(e, "lgetxattr", Some(self), None)),
        }
    }

    pub fn set_secontext<'a>(&'a self, con: &'a Utf8CStr) -> OsResult<'a, ()> {
        unsafe {
            libc::lsetxattr(
                self.as_ptr(),
                XATTR_NAME_SELINUX.as_ptr(),
                con.as_ptr().cast(),
                con.len() + 1,
                0,
            )
            .check_os_err("lsetxattr", Some(self), Some(con))
        }
    }

    pub fn parent_dir(&self) -> Option<&str> {
        Path::new(self.as_str())
            .parent()
            .map(Path::as_os_str)
            // SAFETY: all substring of self is valid UTF-8
            .map(|s| unsafe { std::str::from_utf8_unchecked(s.as_bytes()) })
    }

    pub fn file_name(&self) -> Option<&str> {
        Path::new(self.as_str())
            .file_name()
            // SAFETY: all substring of self is valid UTF-8
            .map(|s| unsafe { std::str::from_utf8_unchecked(s.as_bytes()) })
    }

    // ln -s target self
    pub fn create_symlink_to<'a>(&'a self, target: &'a Utf8CStr) -> OsResult<'a, ()> {
        nix::unistd::symlinkat(target, AT_FDCWD, self).check_os_err(
            "symlink",
            Some(target),
            Some(self),
        )
    }

    pub fn mkfifo(&self, mode: mode_t) -> OsResult<'_, ()> {
        nix::unistd::mkfifo(self, Mode::from_bits_truncate(mode)).check_os_err(
            "mkfifo",
            Some(self),
            None,
        )
    }
}

// High-level helper methods, composed of multiple operations.
// We should treat these as application logic and log ASAP, so return LoggedResult.
impl Utf8CStr {
    pub fn remove_all(&self) -> LoggedResult<()> {
        let attr = match self.get_attr() {
            Ok(attr) => attr,
            Err(e) => {
                return match e.errno {
                    // Allow calling remove_all on non-existence file
                    Errno::ENOENT => Ok(()),
                    _ => Err(e)?,
                };
            }
        };
        if attr.is_dir() {
            let dir = Directory::open(self)?;
            dir.remove_all()?;
        }
        Ok(self.remove()?)
    }

    pub fn mkdirs(&self, mode: mode_t) -> LoggedResult<()> {
        if self.is_empty() {
            return Ok(());
        }

        let mut path = cstr::buf::default();
        let mut components = self.split('/').filter(|s| !s.is_empty());

        if self.starts_with('/') {
            path.append_path("/");
        }

        loop {
            let Some(s) = components.next() else {
                break;
            };
            path.append_path(s);
            path.mkdir(mode)?;
        }

        *errno() = 0;
        Ok(())
    }

    pub fn copy_to(&self, path: &Utf8CStr) -> LoggedResult<()> {
        let attr = self.get_attr()?;
        if attr.is_dir() {
            path.mkdir(0o777)?;
            let mut src = Directory::open(self)?;
            let dest = Directory::open(path)?;
            src.copy_into(&dest)?;
        } else {
            // It's OK if remove failed
            path.remove().ok();
            if attr.is_file() {
                let mut src = self.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC)?;
                let mut dest = path.create(
                    OFlag::O_WRONLY | OFlag::O_CREAT | OFlag::O_TRUNC | OFlag::O_CLOEXEC,
                    0o777,
                )?;
                std::io::copy(&mut src, &mut dest)?;
            } else if attr.is_symlink() {
                let mut buf = cstr::buf::default();
                self.read_link(&mut buf)?;
                unsafe {
                    libc::symlink(buf.as_ptr(), path.as_ptr()).check_os_err(
                        "symlink",
                        Some(&buf),
                        Some(path),
                    )?;
                }
            }
        }
        path.set_attr(&attr)?;
        Ok(())
    }

    pub fn move_to(&self, path: &Utf8CStr) -> LoggedResult<()> {
        if path.exists() {
            let attr = path.get_attr()?;
            if attr.is_dir() {
                let mut src = Directory::open(self)?;
                let dest = Directory::open(path)?;
                return src.move_into(&dest);
            } else {
                path.remove()?;
            }
        }
        self.rename_to(path)?;
        Ok(())
    }

    // ln self path
    pub fn link_to(&self, path: &Utf8CStr) -> LoggedResult<()> {
        let attr = self.get_attr()?;
        if attr.is_dir() {
            path.mkdir(0o777)?;
            path.set_attr(&attr)?;
            let mut src = Directory::open(self)?;
            let dest = Directory::open(path)?;
            Ok(src.link_into(&dest)?)
        } else {
            unsafe {
                libc::link(self.as_ptr(), path.as_ptr()).check_os_err(
                    "link",
                    Some(self),
                    Some(path),
                )?;
            }
            Ok(())
        }
    }
}

impl FsPathFollow {
    pub fn exists(&self) -> bool {
        nix::unistd::access(self.as_utf8_cstr(), AccessFlags::F_OK).is_ok()
    }

    pub fn chmod(&self, mode: mode_t) -> OsResult<'_, ()> {
        nix::sys::stat::fchmodat(
            AT_FDCWD,
            self.as_utf8_cstr(),
            Mode::from_bits_truncate(mode),
            FchmodatFlags::FollowSymlink,
        )
        .check_os_err("chmod", Some(self), None)
    }

    pub fn get_attr(&self) -> OsResult<'_, FileAttr> {
        #[allow(unused_mut)]
        let mut attr = FileAttr {
            st: nix::sys::stat::stat(self.as_utf8_cstr()).into_os_result(
                "lstat",
                Some(self),
                None,
            )?,
            #[cfg(feature = "selinux")]
            con: cstr::buf::new(),
        };
        #[cfg(feature = "selinux")]
        self.get_secontext(&mut attr.con)?;
        Ok(attr)
    }

    pub fn set_attr<'a>(&'a self, attr: &'a FileAttr) -> OsResult<'a, ()> {
        self.chmod((attr.st.st_mode & 0o777).as_())?;

        nix::unistd::chown(
            self.as_utf8_cstr(),
            Some(Uid::from(attr.st.st_uid)),
            Some(Gid::from(attr.st.st_gid)),
        )
        .check_os_err("chown", Some(self), None)?;

        #[cfg(feature = "selinux")]
        if !attr.con.is_empty() {
            self.set_secontext(&attr.con)?;
        }
        Ok(())
    }

    pub fn get_secontext(&self, con: &mut dyn Utf8CStrBuf) -> OsResult<'_, ()> {
        con.clear();
        let result = unsafe {
            libc::getxattr(
                self.as_ptr(),
                XATTR_NAME_SELINUX.as_ptr(),
                con.as_mut_ptr().cast(),
                con.capacity(),
            )
            .check_err()
        };

        match result {
            Ok(_) => {
                con.rebuild().ok();
                Ok(())
            }
            Err(Errno::ENODATA) => Ok(()),
            Err(e) => Err(OsError::new(e, "getxattr", Some(self), None)),
        }
    }

    pub fn set_secontext<'a>(&'a self, con: &'a Utf8CStr) -> OsResult<'a, ()> {
        unsafe {
            libc::setxattr(
                self.as_ptr(),
                XATTR_NAME_SELINUX.as_ptr(),
                con.as_ptr().cast(),
                con.len() + 1,
                0,
            )
            .check_os_err("setxattr", Some(self), Some(con))
        }
    }
}

pub trait FsPathBuilder {
    fn join_path<T: AsRef<str>>(mut self, path: T) -> Self
    where
        Self: Sized,
    {
        self.append_path(path);
        self
    }
    fn join_path_fmt<T: Display>(mut self, name: T) -> Self
    where
        Self: Sized,
    {
        self.append_path_fmt(name);
        self
    }
    fn append_path<T: AsRef<str>>(&mut self, path: T) -> &mut Self;
    fn append_path_fmt<T: Display>(&mut self, name: T) -> &mut Self;
}

fn append_path_impl(buf: &mut dyn Utf8CStrBuf, path: &str) {
    if path.starts_with('/') {
        buf.clear();
    }
    if !buf.is_empty() && !buf.ends_with('/') {
        buf.push_str("/");
    }
    buf.push_str(path);
}

impl<S: Utf8CStrBuf + Sized> FsPathBuilder for S {
    fn append_path<T: AsRef<str>>(&mut self, path: T) -> &mut Self {
        append_path_impl(self, path.as_ref());
        self
    }

    fn append_path_fmt<T: Display>(&mut self, name: T) -> &mut Self {
        self.write_fmt(format_args!("/{name}")).ok();
        self
    }
}

impl FsPathBuilder for dyn Utf8CStrBuf + '_ {
    fn append_path<T: AsRef<str>>(&mut self, path: T) -> &mut Self {
        append_path_impl(self, path.as_ref());
        self
    }

    fn append_path_fmt<T: Display>(&mut self, name: T) -> &mut Self {
        self.write_fmt(format_args!("/{name}")).ok();
        self
    }
}

pub fn fd_get_attr(fd: RawFd) -> OsResult<'static, FileAttr> {
    let mut attr = FileAttr::new();
    unsafe {
        libc::fstat(fd, &mut attr.st).check_os_err("fstat", None, None)?;

        #[cfg(feature = "selinux")]
        fd_get_secontext(fd, &mut attr.con)?;
    }
    Ok(attr)
}

pub fn fd_set_attr(fd: RawFd, attr: &FileAttr) -> OsResult<'_, ()> {
    unsafe {
        libc::fchmod(fd, (attr.st.st_mode & 0o777).as_()).check_os_err("fchmod", None, None)?;
        libc::fchown(fd, attr.st.st_uid, attr.st.st_gid).check_os_err("fchown", None, None)?;

        #[cfg(feature = "selinux")]
        if !attr.con.is_empty() {
            fd_set_secontext(fd, &attr.con)?;
        }
    }
    Ok(())
}

pub fn fd_get_secontext(fd: RawFd, con: &mut dyn Utf8CStrBuf) -> OsResult<'static, ()> {
    con.clear();
    let result = unsafe {
        libc::fgetxattr(
            fd,
            XATTR_NAME_SELINUX.as_ptr(),
            con.as_mut_ptr().cast(),
            con.capacity(),
        )
        .check_err()
    };

    match result {
        Ok(_) => {
            con.rebuild().ok();
            Ok(())
        }
        Err(Errno::ENODATA) => Ok(()),
        Err(e) => Err(OsError::new(e, "fgetxattr", None, None)),
    }
}

pub fn fd_set_secontext(fd: RawFd, con: &Utf8CStr) -> OsResult<'_, ()> {
    unsafe {
        libc::fsetxattr(
            fd,
            XATTR_NAME_SELINUX.as_ptr(),
            con.as_ptr().cast(),
            con.len() + 1,
            0,
        )
        .check_os_err("fsetxattr", Some(con), None)
    }
}

pub fn clone_attr<'a>(a: &'a Utf8CStr, b: &'a Utf8CStr) -> OsResult<'a, ()> {
    let attr = a.get_attr().map_err(|e| e.set_args(Some(a), None))?;
    b.set_attr(&attr).map_err(|e| e.set_args(Some(b), None))
}

pub fn fclone_attr(a: RawFd, b: RawFd) -> OsResult<'static, ()> {
    let attr = fd_get_attr(a)?;
    fd_set_attr(b, &attr).map_err(|e| e.set_args(None, None))
}

pub struct MappedFile(&'static mut [u8]);

impl MappedFile {
    pub fn open(path: &Utf8CStr) -> OsResult<'_, MappedFile> {
        Ok(MappedFile(map_file(path, false)?))
    }

    pub fn open_rw(path: &Utf8CStr) -> OsResult<'_, MappedFile> {
        Ok(MappedFile(map_file(path, true)?))
    }

    pub fn openat<'a, T: AsFd>(dir: &T, path: &'a Utf8CStr) -> OsResult<'a, MappedFile> {
        Ok(MappedFile(map_file_at(dir.as_fd(), path, false)?))
    }

    pub fn openat_rw<'a, T: AsFd>(dir: &T, path: &'a Utf8CStr) -> OsResult<'a, MappedFile> {
        Ok(MappedFile(map_file_at(dir.as_fd(), path, true)?))
    }

    pub fn create(fd: BorrowedFd, sz: usize, rw: bool) -> OsResult<MappedFile> {
        Ok(MappedFile(map_fd(fd, sz, rw)?))
    }
}

impl AsRef<[u8]> for MappedFile {
    fn as_ref(&self) -> &[u8] {
        self.0
    }
}

impl AsMut<[u8]> for MappedFile {
    fn as_mut(&mut self) -> &mut [u8] {
        self.0
    }
}

impl Drop for MappedFile {
    fn drop(&mut self) {
        unsafe {
            libc::munmap(self.0.as_mut_ptr().cast(), self.0.len());
        }
    }
}

unsafe extern "C" {
    // Don't use the declaration from the libc crate as request should be u32 not i32
    fn ioctl(fd: RawFd, request: u32, ...) -> i32;
}

// We mark the returned slice static because it is valid until explicitly unmapped
pub(crate) fn map_file(path: &Utf8CStr, rw: bool) -> OsResult<'_, &'static mut [u8]> {
    map_file_at(AT_FDCWD, path, rw)
}

pub(crate) fn map_file_at<'a>(
    dirfd: BorrowedFd,
    path: &'a Utf8CStr,
    rw: bool,
) -> OsResult<'a, &'static mut [u8]> {
    #[cfg(target_pointer_width = "64")]
    const BLKGETSIZE64: u32 = 0x80081272;

    #[cfg(target_pointer_width = "32")]
    const BLKGETSIZE64: u32 = 0x80041272;

    let flag = if rw { OFlag::O_RDWR } else { OFlag::O_RDONLY };
    let fd = nix::fcntl::openat(dirfd, path, flag | OFlag::O_CLOEXEC, Mode::empty())
        .into_os_result("openat", Some(path), None)?;
    let attr = fd_get_attr(fd.as_raw_fd())?;
    let sz = if attr.is_block_device() {
        let mut sz = 0_u64;
        unsafe {
            ioctl(fd.as_raw_fd(), BLKGETSIZE64, &mut sz).check_os_err("ioctl", Some(path), None)?;
        }
        sz
    } else {
        attr.st.st_size as u64
    };

    map_fd(fd.as_fd(), sz as usize, rw).map_err(|e| e.set_args(Some(path), None))
}

pub(crate) fn map_fd(fd: BorrowedFd, sz: usize, rw: bool) -> OsResult<'static, &'static mut [u8]> {
    let flag = if rw {
        libc::MAP_SHARED
    } else {
        libc::MAP_PRIVATE
    };
    unsafe {
        let ptr = libc::mmap(
            ptr::null_mut(),
            sz,
            libc::PROT_READ | libc::PROT_WRITE,
            flag,
            fd.as_raw_fd(),
            0,
        );
        if ptr == libc::MAP_FAILED {
            return Err(OsError::last_os_error("mmap", None, None));
        }
        Ok(slice::from_raw_parts_mut(ptr.cast(), sz))
    }
}

#[allow(dead_code)]
pub struct MountInfo {
    pub id: u32,
    pub parent: u32,
    pub device: u64,
    pub root: String,
    pub target: String,
    pub vfs_option: String,
    pub shared: u32,
    pub master: u32,
    pub propagation_from: u32,
    pub unbindable: bool,
    pub fs_type: String,
    pub source: String,
    pub fs_option: String,
}

#[allow(clippy::useless_conversion)]
fn parse_mount_info_line(line: &str) -> Option<MountInfo> {
    let mut iter = line.split_whitespace();
    let id = iter.next()?.parse().ok()?;
    let parent = iter.next()?.parse().ok()?;
    let (maj, min) = iter.next()?.split_once(':')?;
    let maj = maj.parse().ok()?;
    let min = min.parse().ok()?;
    let device = makedev(maj, min).into();
    let root = iter.next()?.to_string();
    let target = iter.next()?.to_string();
    let vfs_option = iter.next()?.to_string();
    let mut optional = iter.next()?;
    let mut shared = 0;
    let mut master = 0;
    let mut propagation_from = 0;
    let mut unbindable = false;
    while optional != "-" {
        if let Some(peer) = optional.strip_prefix("master:") {
            master = peer.parse().ok()?;
        } else if let Some(peer) = optional.strip_prefix("shared:") {
            shared = peer.parse().ok()?;
        } else if let Some(peer) = optional.strip_prefix("propagate_from:") {
            propagation_from = peer.parse().ok()?;
        } else if optional == "unbindable" {
            unbindable = true;
        }
        optional = iter.next()?;
    }
    let fs_type = iter.next()?.to_string();
    let source = iter.next()?.to_string();
    let fs_option = iter.next()?.to_string();
    Some(MountInfo {
        id,
        parent,
        device,
        root,
        target,
        vfs_option,
        shared,
        master,
        propagation_from,
        unbindable,
        fs_type,
        source,
        fs_option,
    })
}

pub fn parse_mount_info(pid: &str) -> Vec<MountInfo> {
    let mut res = vec![];
    let mut path = format!("/proc/{pid}/mountinfo");
    if let Ok(file) = Utf8CStr::from_string(&mut path).open(OFlag::O_RDONLY | OFlag::O_CLOEXEC) {
        BufReader::new(file).for_each_line(|line| {
            parse_mount_info_line(line)
                .map(|info| res.push(info))
                .is_some()
        });
    }
    res
}

```

`native/src/base/include/base.hpp`:

```hpp
#pragma once

#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <fcntl.h>
#include <functional>

#include <rust/cxx.h>

void LOGD(const char *fmt, ...) __printflike(1, 2);
void LOGI(const char *fmt, ...) __printflike(1, 2);
void LOGW(const char *fmt, ...) __printflike(1, 2);
void LOGE(const char *fmt, ...) __printflike(1, 2);
#define PLOGE(fmt, args...) LOGE(fmt " failed with %d: %s\n", ##args, errno, std::strerror(errno))

extern "C" {

// xwraps

FILE *xfopen(const char *pathname, const char *mode);
FILE *xfdopen(int fd, const char *mode);
int xopen(const char *pathname, int flags, mode_t mode = 0);
int xopenat(int dirfd, const char *pathname, int flags, mode_t mode = 0);
ssize_t xwrite(int fd, const void *buf, size_t count);
ssize_t xread(int fd, void *buf, size_t count);
ssize_t xxread(int fd, void *buf, size_t count);
int xsetns(int fd, int nstype);
int xunshare(int flags);
DIR *xopendir(const char *name);
DIR *xfdopendir(int fd);
dirent *xreaddir(DIR *dirp);
pid_t xsetsid();
int xfstat(int fd, struct stat *buf);
int xdup2(int oldfd, int newfd);
ssize_t xreadlinkat(
        int dirfd, const char * __restrict__ pathname, char * __restrict__ buf, size_t bufsiz);
int xsymlink(const char *target, const char *linkpath);
int xmount(const char *source, const char *target,
           const char *filesystemtype, unsigned long mountflags,
           const void *data);
int xumount2(const char *target, int flags);
int xrename(const char *oldpath, const char *newpath);
int xmkdir(const char *pathname, mode_t mode);
int xmkdirs(const char *pathname, mode_t mode);
ssize_t xsendfile(int out_fd, int in_fd, off_t *offset, size_t count);
pid_t xfork();
ssize_t xrealpath(const char * __restrict__ path, char * __restrict__ buf, size_t bufsiz);
int xmknod(const char * pathname, mode_t mode, dev_t dev);

// Utils

int mkdirs(const char *path, mode_t mode);
ssize_t canonical_path(const char * __restrict__ path, char * __restrict__ buf, size_t bufsiz);
bool rm_rf(const char *path);
bool cp_afc(const char *src, const char *dest);
bool mv_path(const char *src, const char *dest);
bool link_path(const char *src, const char *dest);
bool clone_attr(const char *src, const char *dest);
bool fclone_attr(int src, int dest);

} // extern "C"

#define DISALLOW_COPY_AND_MOVE(clazz) \
clazz(const clazz&) = delete;        \
clazz(clazz &&) = delete;

#define ALLOW_MOVE_ONLY(clazz) \
clazz(const clazz&) = delete;  \
clazz(clazz &&o) : clazz() { swap(o); }  \
clazz& operator=(clazz &&o) { swap(o); return *this; }

struct Utf8CStr;

class mutex_guard {
    DISALLOW_COPY_AND_MOVE(mutex_guard)
public:
    explicit mutex_guard(pthread_mutex_t &m): mutex(&m) {
        pthread_mutex_lock(mutex);
    }
    void unlock() {
        pthread_mutex_unlock(mutex);
        mutex = nullptr;
    }
    ~mutex_guard() {
        if (mutex) pthread_mutex_unlock(mutex);
    }
private:
    pthread_mutex_t *mutex;
};

template <class Func>
class run_finally {
    DISALLOW_COPY_AND_MOVE(run_finally)
public:
    explicit run_finally(Func &&fn) : fn(std::move(fn)) {}
    ~run_finally() { fn(); }
private:
    Func fn;
};

template<class T>
static void default_new(T *&p) { p = new T(); }

template<class T>
static void default_new(std::unique_ptr<T> &p) { p.reset(new T()); }

struct StringCmp {
    using is_transparent = void;
    bool operator()(std::string_view a, std::string_view b) const { return a < b; }
};

using ByteSlice = rust::Slice<const uint8_t>;
using MutByteSlice = rust::Slice<uint8_t>;

// Interchangeable as `&[u8]` in Rust
struct byte_view {
    byte_view() : ptr(nullptr), sz(0) {}
    byte_view(const void *buf, size_t sz) : ptr((uint8_t *) buf), sz(sz) {}

    // byte_view, or any of its subclasses, can be copied as byte_view
    byte_view(const byte_view &o) : ptr(o.ptr), sz(o.sz) {}

    // Transparent conversion to Rust slice
    byte_view(const ByteSlice o) : byte_view(o.data(), o.size()) {}
    operator ByteSlice() const { return {ptr, sz}; }

    // String as bytes, including null terminator
    byte_view(const char *s) : byte_view(s, strlen(s) + 1) {}

    const uint8_t *data() const { return ptr; }
    size_t size() const { return sz; }

protected:
    uint8_t *ptr;
    size_t sz;
};

// Interchangeable as `&mut [u8]` in Rust
struct byte_data : public byte_view {
    byte_data() = default;
    byte_data(void *buf, size_t sz) : byte_view(buf, sz) {}

    // byte_data, or any of its subclasses, can be copied as byte_data
    byte_data(const byte_data &o) : byte_data(o.ptr, o.sz) {}

    // Transparent conversion to Rust slice
    byte_data(const MutByteSlice o) : byte_data(o.data(), o.size()) {}
    operator MutByteSlice() const { return {ptr, sz}; }

    using byte_view::data;
    uint8_t *data() const { return ptr; }

    rust::Vec<size_t> patch(byte_view from, byte_view to) const;
};

struct mmap_data : public byte_data {
    ALLOW_MOVE_ONLY(mmap_data)

    mmap_data() = default;
    explicit mmap_data(const char *name, bool rw = false);
    mmap_data(int dirfd, const char *name, bool rw = false);
    mmap_data(int fd, size_t sz, bool rw = false);
    ~mmap_data();
private:
    void swap(mmap_data &o);
};


struct owned_fd {
    ALLOW_MOVE_ONLY(owned_fd)

    owned_fd() : fd(-1) {}
    owned_fd(int fd) : fd(fd) {}
    ~owned_fd() { close(fd); fd = -1; }

    operator int() { return fd; }
    int release() { int f = fd; fd = -1; return f; }
    void swap(owned_fd &owned) { std::swap(fd, owned.fd); }

private:
    int fd;
};

rust::Vec<size_t> mut_u8_patch(MutByteSlice buf, ByteSlice from, ByteSlice to);

uint32_t parse_uint32_hex(std::string_view s);
int parse_int(std::string_view s);

using thread_entry = void *(*)(void *);
extern "C" int new_daemon_thread(thread_entry entry, void *arg = nullptr);

static inline std::string rtrim(std::string &&s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !std::isspace(ch) && ch != '\0';
    }).base(), s.end());
    return std::move(s);
}

int fork_dont_care();
int fork_no_orphan();
void init_argv0(int argc, char **argv);
void set_nice_name(Utf8CStr name);
int switch_mnt_ns(int pid);
std::string &replace_all(std::string &str, std::string_view from, std::string_view to);
std::vector<std::string> split(std::string_view s, std::string_view delims);

// Similar to vsnprintf, but the return value is the written number of bytes
__printflike(3, 0) int vssprintf(char *dest, size_t size, const char *fmt, va_list ap);
// Similar to snprintf, but the return value is the written number of bytes
__printflike(3, 4) int ssprintf(char *dest, size_t size, const char *fmt, ...);
// This is not actually the strscpy from the Linux kernel.
// Silently truncates, and returns the number of bytes written.
extern "C" size_t strscpy(char *dest, const char *src, size_t size);

// Ban usage of unsafe cstring functions
#define vsnprintf  __use_vssprintf_instead__
#define snprintf   __use_ssprintf_instead__
#define strlcpy    __use_strscpy_instead__

struct exec_t {
    bool err = false;
    int fd = -2;
    void (*pre_exec)() = nullptr;
    int (*fork)() = xfork;
    const char **argv = nullptr;
};

int exec_command(exec_t &exec);
template <class ...Args>
int exec_command(exec_t &exec, Args &&...args) {
    const char *argv[] = {args..., nullptr};
    exec.argv = argv;
    return exec_command(exec);
}
int exec_command_sync(exec_t &exec);
template <class ...Args>
int exec_command_sync(exec_t &exec, Args &&...args) {
    const char *argv[] = {args..., nullptr};
    exec.argv = argv;
    return exec_command_sync(exec);
}
template <class ...Args>
int exec_command_sync(Args &&...args) {
    exec_t exec;
    return exec_command_sync(exec, args...);
}
template <class ...Args>
void exec_command_async(Args &&...args) {
    const char *argv[] = {args..., nullptr};
    exec_t exec {
        .fork = fork_dont_care,
        .argv = argv,
    };
    exec_command(exec);
}

template <typename T>
constexpr auto operator+(T e) noexcept ->
    std::enable_if_t<std::is_enum<T>::value, std::underlying_type_t<T>> {
    return static_cast<std::underlying_type_t<T>>(e);
}

std::string full_read(int fd);
std::string full_read(const char *filename);
void write_zero(int fd, size_t size);
std::string resolve_preinit_dir(const char *base_dir);

using sFILE = std::unique_ptr<FILE, decltype(&fclose)>;
using sDIR = std::unique_ptr<DIR, decltype(&closedir)>;
sDIR make_dir(DIR *dp);
sFILE make_file(FILE *fp);

static inline sDIR open_dir(const char *path) {
    return make_dir(opendir(path));
}

static inline sDIR xopen_dir(const char *path) {
    return make_dir(xopendir(path));
}

static inline sDIR xopen_dir(int dirfd) {
    return make_dir(xfdopendir(dirfd));
}

static inline sFILE open_file(const char *path, const char *mode) {
    return make_file(fopen(path, mode));
}

static inline sFILE xopen_file(const char *path, const char *mode) {
    return make_file(xfopen(path, mode));
}

static inline sFILE xopen_file(int fd, const char *mode) {
    return make_file(xfdopen(fd, mode));
}

// Bindings to &Utf8CStr in Rust
struct Utf8CStr {
    const char *data() const;
    size_t length() const;
    Utf8CStr(const char *s, size_t len);

    Utf8CStr() : Utf8CStr("", 1) {};
    Utf8CStr(const Utf8CStr &o) = default;
    Utf8CStr(const char *s) : Utf8CStr(s, strlen(s) + 1) {};
    Utf8CStr(std::string s) : Utf8CStr(s.data(), s.length() + 1) {};
    const char *c_str() const { return this->data(); }
    size_t size() const { return this->length(); }
    bool empty() const { return this->length() == 0 ; }
    std::string_view sv() const { return {data(), length()}; }
    operator std::string_view() const { return sv(); }
    bool operator==(std::string_view rhs) const { return sv() == rhs; }

private:
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
    std::array<std::uintptr_t, 2> repr;
#pragma clang diagnostic pop
};

// Bindings for std::function to be callable from Rust
using CxxFnBoolStrStr = std::function<bool(rust::Str, rust::Str)>;
struct FnBoolStrStr : public CxxFnBoolStrStr {
    using CxxFnBoolStrStr::function;
    bool call(rust::Str a, rust::Str b) const {
        return operator()(a, b);
    }
};
using CxxFnBoolStr = std::function<bool(Utf8CStr)>;
struct FnBoolStr : public CxxFnBoolStr {
    using CxxFnBoolStr::function;
    bool call(Utf8CStr s) const {
        return operator()(s);
    }
};

#include "../base-rs.hpp"

// Functor = function<bool(Utf8CStr, Utf8CStr)>
template <typename Functor>
void parse_prop_file(const char *file, Functor &&fn) {
    parse_prop_file_rs(file, [&](rust::Str key, rust::Str val) -> bool {
        // We perform the null termination here in C++ because it's very difficult to do it
        // right in Rust due to pointer provenance. Trying to dereference a pointer without
        // the correct provenance in Rust, even in unsafe code, is undefined behavior.
        // However on the C++ side, there are fewer restrictions on pointers, so the const_cast here
        // will not trigger UB in the compiler.
        *(const_cast<char *>(key.data()) + key.size()) = '\0';
        *(const_cast<char *>(val.data()) + val.size()) = '\0';
        return fn(Utf8CStr(key.data(), key.size() + 1), Utf8CStr(val.data(), val.size() + 1));
    });
}

```

`native/src/base/lib.rs`:

```rs
#![allow(clippy::missing_safety_doc)]

pub use {const_format, libc, nix};

pub use cstr::{
    FsPathFollow, StrErr, Utf8CStr, Utf8CStrBuf, Utf8CStrBufArr, Utf8CStrBufRef, Utf8CString,
};
use cxx_extern::*;
pub use derive;
pub use dir::*;
pub use ffi::{Utf8CStrRef, fork_dont_care, set_nice_name};
pub use files::*;
pub use logging::*;
pub use misc::*;
pub use result::*;

pub mod argh;
pub mod cstr;
mod cxx_extern;
mod dir;
mod files;
mod logging;
mod misc;
mod mount;
mod result;
mod xwrap;

#[cxx::bridge]
mod ffi {
    #[derive(Copy, Clone)]
    #[repr(i32)]
    #[cxx_name = "LogLevel"]
    pub(crate) enum LogLevelCxx {
        Error,
        Warn,
        Info,
        Debug,
    }

    unsafe extern "C++" {
        include!("base.hpp");

        #[cxx_name = "Utf8CStr"]
        type Utf8CStrRef<'a> = &'a crate::cstr::Utf8CStr;

        fn mut_u8_patch(buf: &mut [u8], from: &[u8], to: &[u8]) -> Vec<usize>;
        fn fork_dont_care() -> i32;
        fn set_nice_name(name: Utf8CStrRef);

        type FnBoolStrStr;
        fn call(self: &FnBoolStrStr, key: &str, value: &str) -> bool;

        type FnBoolStr;
        fn call(self: &FnBoolStr, key: Utf8CStrRef) -> bool;
    }

    extern "Rust" {
        #[cxx_name = "log_with_rs"]
        fn log_from_cxx(level: LogLevelCxx, msg: Utf8CStrRef);
        fn cmdline_logging();
        fn parse_prop_file_rs(name: Utf8CStrRef, f: &FnBoolStrStr);
        #[cxx_name = "file_readline"]
        fn file_readline_for_cxx(fd: i32, f: &FnBoolStr);
        fn xpipe2(fds: &mut [i32; 2], flags: i32) -> i32;
    }

    #[namespace = "rust"]
    extern "Rust" {
        #[cxx_name = "map_file"]
        fn map_file_for_cxx(path: Utf8CStrRef, rw: bool) -> &'static mut [u8];
        #[cxx_name = "map_file_at"]
        fn map_file_at_for_cxx(fd: i32, path: Utf8CStrRef, rw: bool) -> &'static mut [u8];
        #[cxx_name = "map_fd"]
        fn map_fd_for_cxx(fd: i32, sz: usize, rw: bool) -> &'static mut [u8];
    }
}

// In Rust, we do not want to deal with raw pointers, so we change the
// signature of all *mut c_void to usize for new_daemon_thread.
pub type ThreadEntry = extern "C" fn(usize) -> usize;
unsafe extern "C" {
    pub fn new_daemon_thread(entry: ThreadEntry, arg: usize);
}

```

`native/src/base/logging.rs`:

```rs
use crate::ffi::LogLevelCxx;
use crate::{Utf8CStr, cstr};
use bitflags::bitflags;
use num_derive::{FromPrimitive, ToPrimitive};
use num_traits::FromPrimitive;
use std::fmt;
use std::io::{Write, stderr, stdout};
use std::process::exit;

bitflags! {
    #[derive(Copy, Clone)]
    struct LogFlag : u32 {
        const DISABLE_ERROR = 1 << 0;
        const DISABLE_WARN = 1 << 1;
        const DISABLE_INFO = 1 << 2;
        const DISABLE_DEBUG = 1 << 3;
        const EXIT_ON_ERROR = 1 << 4;
    }
}

#[derive(Copy, Clone, FromPrimitive, ToPrimitive)]
#[repr(i32)]
pub enum LogLevel {
    Error = LogLevelCxx::Error.repr,
    Warn = LogLevelCxx::Warn.repr,
    Info = LogLevelCxx::Info.repr,
    Debug = LogLevelCxx::Debug.repr,
}

// We don't need to care about thread safety, because all
// logger changes will only happen on the main thread.
pub static mut LOGGER: Logger = Logger {
    write: |_, _| {},
    flags: LogFlag::empty(),
};

type LogWriter = fn(level: LogLevel, msg: &Utf8CStr);
pub(crate) type Formatter<'a> = &'a mut dyn fmt::Write;

#[derive(Copy, Clone)]
pub struct Logger {
    pub write: LogWriter,
    flags: LogFlag,
}

pub fn update_logger(f: impl FnOnce(&mut Logger)) {
    let mut logger = unsafe { LOGGER };
    f(&mut logger);
    unsafe {
        LOGGER = logger;
    }
}

pub fn exit_on_error(b: bool) {
    update_logger(|logger| logger.flags.set(LogFlag::EXIT_ON_ERROR, b));
}

impl LogLevel {
    fn as_disable_flag(&self) -> LogFlag {
        match *self {
            LogLevel::Error => LogFlag::DISABLE_ERROR,
            LogLevel::Warn => LogFlag::DISABLE_WARN,
            LogLevel::Info => LogFlag::DISABLE_INFO,
            LogLevel::Debug => LogFlag::DISABLE_DEBUG,
        }
    }
}

pub fn set_log_level_state(level: LogLevel, enabled: bool) {
    update_logger(|logger| logger.flags.set(level.as_disable_flag(), enabled));
}

fn log_with_writer<F: FnOnce(LogWriter)>(level: LogLevel, f: F) {
    let logger = unsafe { LOGGER };
    if logger.flags.contains(level.as_disable_flag()) {
        return;
    }
    f(logger.write);
    if matches!(level, LogLevel::Error) && logger.flags.contains(LogFlag::EXIT_ON_ERROR) {
        exit(-1);
    }
}

pub fn log_from_cxx(level: LogLevelCxx, msg: &Utf8CStr) {
    if let Some(level) = LogLevel::from_i32(level.repr) {
        log_with_writer(level, |write| write(level, msg));
    }
}

pub fn log_with_formatter<F: FnOnce(Formatter) -> fmt::Result>(level: LogLevel, f: F) {
    log_with_writer(level, |write| {
        let mut buf = cstr::buf::default();
        f(&mut buf).ok();
        write(level, &buf);
    });
}

pub fn cmdline_logging() {
    fn cmdline_write(level: LogLevel, msg: &Utf8CStr) {
        if matches!(level, LogLevel::Info) {
            stdout().write_all(msg.as_bytes()).ok();
        } else {
            stderr().write_all(msg.as_bytes()).ok();
        }
    }
    update_logger(|logger| logger.write = cmdline_write);
}

#[macro_export]
macro_rules! log_with_args {
    ($level:expr, $($args:tt)+) => {
        $crate::log_with_formatter($level, |w| writeln!(w, $($args)+))
    }
}

#[macro_export]
macro_rules! error {
    ($($args:tt)+) => {
        $crate::log_with_formatter($crate::LogLevel::Error, |w| writeln!(w, $($args)+))
    }
}

#[macro_export]
macro_rules! warn {
    ($($args:tt)+) => {
        $crate::log_with_formatter($crate::LogLevel::Warn, |w| writeln!(w, $($args)+))
    }
}

#[macro_export]
macro_rules! info {
    ($($args:tt)+) => {
        $crate::log_with_formatter($crate::LogLevel::Info, |w| writeln!(w, $($args)+))
    }
}

#[cfg(debug_assertions)]
#[macro_export]
macro_rules! debug {
    ($($args:tt)+) => {
        $crate::log_with_formatter($crate::LogLevel::Debug, |w| writeln!(w, $($args)+))
    }
}

#[cfg(not(debug_assertions))]
#[macro_export]
macro_rules! debug {
    ($($args:tt)+) => {};
}

```

`native/src/base/misc.rs`:

```rs
use super::argh::{EarlyExit, MissingRequirements};
use crate::{Utf8CStr, Utf8CString, cstr, ffi};
use libc::c_char;
use std::fmt::Arguments;
use std::io::Write;
use std::mem::ManuallyDrop;
use std::process::exit;
use std::sync::Arc;
use std::sync::atomic::{AtomicPtr, Ordering};
use std::{fmt, slice, str};

pub fn errno() -> &'static mut i32 {
    unsafe { &mut *libc::__errno() }
}

// When len is 0, don't care whether buf is null or not
#[inline]
pub unsafe fn slice_from_ptr<'a, T>(buf: *const T, len: usize) -> &'a [T] {
    unsafe {
        if len == 0 {
            &[]
        } else {
            slice::from_raw_parts(buf, len)
        }
    }
}

// When len is 0, don't care whether buf is null or not
#[inline]
pub unsafe fn slice_from_ptr_mut<'a, T>(buf: *mut T, len: usize) -> &'a mut [T] {
    unsafe {
        if len == 0 {
            &mut []
        } else {
            slice::from_raw_parts_mut(buf, len)
        }
    }
}

pub trait BytesExt {
    fn find(&self, needle: &[u8]) -> Option<usize>;
    fn contains(&self, needle: &[u8]) -> bool {
        self.find(needle).is_some()
    }
}

impl<T: AsRef<[u8]> + ?Sized> BytesExt for T {
    fn find(&self, needle: &[u8]) -> Option<usize> {
        fn inner(haystack: &[u8], needle: &[u8]) -> Option<usize> {
            unsafe {
                let ptr: *const u8 = libc::memmem(
                    haystack.as_ptr().cast(),
                    haystack.len(),
                    needle.as_ptr().cast(),
                    needle.len(),
                )
                .cast();
                if ptr.is_null() {
                    None
                } else {
                    Some(ptr.offset_from(haystack.as_ptr()) as usize)
                }
            }
        }
        inner(self.as_ref(), needle)
    }
}

pub trait MutBytesExt {
    fn patch(&mut self, from: &[u8], to: &[u8]) -> Vec<usize>;
}

impl<T: AsMut<[u8]> + ?Sized> MutBytesExt for T {
    fn patch(&mut self, from: &[u8], to: &[u8]) -> Vec<usize> {
        ffi::mut_u8_patch(self.as_mut(), from, to)
    }
}

pub trait EarlyExitExt<T> {
    fn on_early_exit<F: FnOnce()>(self, print_help_msg: F) -> T;
}

impl<T> EarlyExitExt<T> for Result<T, EarlyExit> {
    fn on_early_exit<F: FnOnce()>(self, print_help_msg: F) -> T {
        match self {
            Ok(t) => t,
            Err(EarlyExit { output, is_help }) => {
                if is_help {
                    print_help_msg();
                    exit(0)
                } else {
                    eprintln!("{output}");
                    print_help_msg();
                    exit(1)
                }
            }
        }
    }
}

pub struct PositionalArgParser<'a>(pub slice::Iter<'a, &'a str>);

impl PositionalArgParser<'_> {
    pub fn required(&mut self, field_name: &'static str) -> Result<Utf8CString, EarlyExit> {
        if let Some(next) = self.0.next() {
            Ok((*next).into())
        } else {
            let mut missing = MissingRequirements::default();
            missing.missing_positional_arg(field_name);
            missing.err_on_any()?;
            unreachable!()
        }
    }

    pub fn optional(&mut self) -> Option<Utf8CString> {
        self.0.next().map(|s| (*s).into())
    }

    pub fn last_required(&mut self, field_name: &'static str) -> Result<Utf8CString, EarlyExit> {
        let r = self.required(field_name)?;
        self.ensure_end()?;
        Ok(r)
    }

    pub fn last_optional(&mut self) -> Result<Option<Utf8CString>, EarlyExit> {
        let r = self.optional();
        if r.is_none() {
            return Ok(r);
        }
        self.ensure_end()?;
        Ok(r)
    }

    fn ensure_end(&mut self) -> Result<(), EarlyExit> {
        match self.0.next() {
            None => Ok(()),
            Some(s) => Err(EarlyExit::from(format!("Unrecognized argument: {s}\n"))),
        }
    }
}

pub struct FmtAdaptor<'a, T>(pub &'a mut T)
where
    T: Write;

impl<T: Write> fmt::Write for FmtAdaptor<'_, T> {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        self.0.write_all(s.as_bytes()).map_err(|_| fmt::Error)
    }
    fn write_fmt(&mut self, args: Arguments<'_>) -> fmt::Result {
        self.0.write_fmt(args).map_err(|_| fmt::Error)
    }
}

pub struct AtomicArc<T> {
    ptr: AtomicPtr<T>,
}

impl<T> AtomicArc<T> {
    pub fn new(arc: Arc<T>) -> AtomicArc<T> {
        let raw = Arc::into_raw(arc);
        Self {
            ptr: AtomicPtr::new(raw as *mut _),
        }
    }

    pub fn load(&self) -> Arc<T> {
        let raw = self.ptr.load(Ordering::Acquire);
        // SAFETY: the raw pointer is always created from Arc::into_raw
        let arc = ManuallyDrop::new(unsafe { Arc::from_raw(raw) });
        ManuallyDrop::into_inner(arc.clone())
    }

    fn swap_ptr(&self, raw: *const T) -> Arc<T> {
        let prev = self.ptr.swap(raw as *mut _, Ordering::AcqRel);
        // SAFETY: the raw pointer is always created from Arc::into_raw
        unsafe { Arc::from_raw(prev) }
    }

    pub fn swap(&self, arc: Arc<T>) -> Arc<T> {
        let raw = Arc::into_raw(arc);
        self.swap_ptr(raw)
    }

    pub fn store(&self, arc: Arc<T>) {
        // Drop the previous value
        let _ = self.swap(arc);
    }
}

impl<T> Drop for AtomicArc<T> {
    fn drop(&mut self) {
        // Drop the internal value
        let _ = self.swap_ptr(std::ptr::null());
    }
}

impl<T: Default> Default for AtomicArc<T> {
    fn default() -> Self {
        Self::new(Default::default())
    }
}

pub struct Chunker {
    chunk: Box<[u8]>,
    chunk_size: usize,
    pos: usize,
}

impl Chunker {
    pub fn new(chunk_size: usize) -> Self {
        Chunker {
            // SAFETY: all bytes will be initialized before it is used, tracked by self.pos
            chunk: unsafe { Box::new_uninit_slice(chunk_size).assume_init() },
            chunk_size,
            pos: 0,
        }
    }

    pub fn set_chunk_size(&mut self, chunk_size: usize) {
        self.chunk_size = chunk_size;
        self.pos = 0;
        if self.chunk.len() < chunk_size {
            self.chunk = unsafe { Box::new_uninit_slice(chunk_size).assume_init() };
        }
    }

    // Returns (remaining buf, Option<Chunk>)
    pub fn add_data<'a, 'b: 'a>(&'a mut self, mut buf: &'b [u8]) -> (&'b [u8], Option<&'a [u8]>) {
        let mut chunk = None;
        if self.pos > 0 {
            // Try to fill the chunk
            let len = std::cmp::min(self.chunk_size - self.pos, buf.len());
            self.chunk[self.pos..self.pos + len].copy_from_slice(&buf[..len]);
            self.pos += len;
            // If the chunk is filled, consume it
            if self.pos == self.chunk_size {
                chunk = Some(&self.chunk[..self.chunk_size]);
                self.pos = 0;
            }
            buf = &buf[len..];
        } else if buf.len() >= self.chunk_size {
            // Directly consume a chunk from buf
            chunk = Some(&buf[..self.chunk_size]);
            buf = &buf[self.chunk_size..];
        } else {
            // Copy buf into chunk
            self.chunk[self.pos..self.pos + buf.len()].copy_from_slice(buf);
            self.pos += buf.len();
            return (&[], None);
        }
        (buf, chunk)
    }

    pub fn get_available(&mut self) -> &[u8] {
        let chunk = &self.chunk[..self.pos];
        self.pos = 0;
        chunk
    }
}

pub struct CmdArgs(pub Vec<&'static str>);

impl CmdArgs {
    #[allow(clippy::not_unsafe_ptr_arg_deref)]
    pub fn new(argc: i32, argv: *const *const c_char) -> CmdArgs {
        CmdArgs(
            // SAFETY: libc guarantees argc and argv are properly setup and are static
            unsafe { slice::from_raw_parts(argv, argc as usize) }
                .iter()
                .map(|s| unsafe { Utf8CStr::from_ptr(*s) })
                .map(|r| r.unwrap_or(cstr!("<invalid>")))
                .map(Utf8CStr::as_str)
                .collect(),
        )
    }

    pub fn as_slice(&self) -> &[&'static str] {
        self.0.as_slice()
    }

    pub fn iter(&self) -> slice::Iter<'_, &'static str> {
        self.0.iter()
    }

    pub fn cstr_iter(&self) -> impl Iterator<Item = &'static Utf8CStr> {
        // SAFETY: libc guarantees null terminated strings
        self.0
            .iter()
            .map(|s| unsafe { Utf8CStr::from_raw_parts(s.as_ptr().cast(), s.len() + 1) })
    }
}

```

`native/src/base/mount.rs`:

```rs
use crate::{LibcReturn, OsResult, Utf8CStr};
use nix::mount::{MntFlags, MsFlags, mount, umount2};

impl Utf8CStr {
    pub fn bind_mount_to<'a>(&'a self, path: &'a Utf8CStr, rec: bool) -> OsResult<'a, ()> {
        let flag = if rec {
            MsFlags::MS_REC
        } else {
            MsFlags::empty()
        };
        mount(
            Some(self),
            path,
            None::<&Utf8CStr>,
            flag | MsFlags::MS_BIND,
            None::<&Utf8CStr>,
        )
        .check_os_err("bind_mount", Some(self), Some(path))
    }

    pub fn remount_mount_point_flags(&self, flags: MsFlags) -> OsResult<'_, ()> {
        mount(
            None::<&Utf8CStr>,
            self,
            None::<&Utf8CStr>,
            MsFlags::MS_BIND | MsFlags::MS_REMOUNT | flags,
            None::<&Utf8CStr>,
        )
        .check_os_err("remount", Some(self), None)
    }

    pub fn remount_mount_flags(&self, flags: MsFlags) -> OsResult<'_, ()> {
        mount(
            None::<&Utf8CStr>,
            self,
            None::<&Utf8CStr>,
            MsFlags::MS_REMOUNT | flags,
            None::<&Utf8CStr>,
        )
        .check_os_err("remount", Some(self), None)
    }

    pub fn remount_with_data(&self, data: &Utf8CStr) -> OsResult<'_, ()> {
        mount(
            None::<&Utf8CStr>,
            self,
            None::<&Utf8CStr>,
            MsFlags::MS_REMOUNT,
            Some(data),
        )
        .check_os_err("remount", Some(self), None)
    }

    pub fn move_mount_to<'a>(&'a self, path: &'a Utf8CStr) -> OsResult<'a, ()> {
        mount(
            Some(self),
            path,
            None::<&Utf8CStr>,
            MsFlags::MS_MOVE,
            None::<&Utf8CStr>,
        )
        .check_os_err("move_mount", Some(self), Some(path))
    }

    pub fn unmount(&self) -> OsResult<'_, ()> {
        umount2(self, MntFlags::MNT_DETACH).check_os_err("unmount", Some(self), None)
    }

    pub fn set_mount_private(&self, rec: bool) -> OsResult<'_, ()> {
        let flag = if rec {
            MsFlags::MS_REC
        } else {
            MsFlags::empty()
        };
        mount(
            None::<&Utf8CStr>,
            self,
            None::<&Utf8CStr>,
            flag | MsFlags::MS_PRIVATE,
            None::<&Utf8CStr>,
        )
        .check_os_err("set_mount_private", Some(self), None)
    }
}

```

`native/src/base/result.rs`:

```rs
use crate::logging::Formatter;
use crate::{LogLevel, log_with_args, log_with_formatter};
use nix::errno::Errno;
use std::fmt;
use std::fmt::Display;
use std::panic::Location;
use std::ptr::NonNull;

// Error handling throughout the Rust codebase in Magisk:
//
// All errors should be logged and consumed as soon as possible and converted into LoggedError.
// For `Result` with errors that implement the `Display` trait, use the `?` operator to
// log and convert to LoggedResult.
//
// To log an error with more information, use `ResultExt::log_with_msg()`.

#[derive(Default)]
pub struct LoggedError {}
pub type LoggedResult<T> = Result<T, LoggedError>;

#[macro_export]
macro_rules! log_err {
    () => {{
        Err($crate::LoggedError::default())
    }};
    ($($args:tt)+) => {{
        $crate::error!($($args)+);
        Err($crate::LoggedError::default())
    }};
}

// Any result or option can be silenced
pub trait SilentLogExt<T> {
    fn silent(self) -> LoggedResult<T>;
}

impl<T, E> SilentLogExt<T> for Result<T, E> {
    fn silent(self) -> LoggedResult<T> {
        self.map_err(|_| LoggedError::default())
    }
}

impl<T> SilentLogExt<T> for Option<T> {
    fn silent(self) -> LoggedResult<T> {
        self.ok_or_else(LoggedError::default)
    }
}

// Public API for logging results
pub trait ResultExt<T> {
    fn log(self) -> LoggedResult<T>;
    fn log_with_msg<F: FnOnce(Formatter) -> fmt::Result>(self, f: F) -> LoggedResult<T>;
    fn log_ok(self);
}

// Public API for converting Option to LoggedResult
pub trait OptionExt<T> {
    fn ok_or_log(self) -> LoggedResult<T>;
    fn ok_or_log_msg<F: FnOnce(Formatter) -> fmt::Result>(self, f: F) -> LoggedResult<T>;
}

impl<T> OptionExt<T> for Option<T> {
    #[inline(always)]
    fn ok_or_log(self) -> LoggedResult<T> {
        self.ok_or_else(LoggedError::default)
    }

    #[cfg(not(debug_assertions))]
    fn ok_or_log_msg<F: FnOnce(Formatter) -> fmt::Result>(self, f: F) -> LoggedResult<T> {
        self.ok_or_else(|| {
            do_log_msg(LogLevel::Error, None, f);
            LoggedError::default()
        })
    }

    #[track_caller]
    #[cfg(debug_assertions)]
    fn ok_or_log_msg<F: FnOnce(Formatter) -> fmt::Result>(self, f: F) -> LoggedResult<T> {
        let caller = Some(Location::caller());
        self.ok_or_else(|| {
            do_log_msg(LogLevel::Error, caller, f);
            LoggedError::default()
        })
    }
}

trait Loggable {
    fn do_log(self, level: LogLevel, caller: Option<&'static Location>) -> LoggedError;
    fn do_log_msg<F: FnOnce(Formatter) -> fmt::Result>(
        self,
        level: LogLevel,
        caller: Option<&'static Location>,
        f: F,
    ) -> LoggedError;
}

impl<T, E: Loggable> ResultExt<T> for Result<T, E> {
    #[cfg(not(debug_assertions))]
    fn log(self) -> LoggedResult<T> {
        self.map_err(|e| e.do_log(LogLevel::Error, None))
    }

    #[track_caller]
    #[cfg(debug_assertions)]
    fn log(self) -> LoggedResult<T> {
        let caller = Some(Location::caller());
        self.map_err(|e| e.do_log(LogLevel::Error, caller))
    }

    #[cfg(not(debug_assertions))]
    fn log_with_msg<F: FnOnce(Formatter) -> fmt::Result>(self, f: F) -> LoggedResult<T> {
        self.map_err(|e| e.do_log_msg(LogLevel::Error, None, f))
    }

    #[track_caller]
    #[cfg(debug_assertions)]
    fn log_with_msg<F: FnOnce(Formatter) -> fmt::Result>(self, f: F) -> LoggedResult<T> {
        let caller = Some(Location::caller());
        self.map_err(|e| e.do_log_msg(LogLevel::Error, caller, f))
    }

    #[cfg(not(debug_assertions))]
    fn log_ok(self) {
        self.map_err(|e| e.do_log(LogLevel::Error, None)).ok();
    }

    #[track_caller]
    #[cfg(debug_assertions)]
    fn log_ok(self) {
        let caller = Some(Location::caller());
        self.map_err(|e| e.do_log(LogLevel::Error, caller)).ok();
    }
}

impl<T> ResultExt<T> for LoggedResult<T> {
    fn log(self) -> LoggedResult<T> {
        self
    }

    #[cfg(not(debug_assertions))]
    fn log_with_msg<F: FnOnce(Formatter) -> fmt::Result>(self, f: F) -> LoggedResult<T> {
        self.inspect_err(|_| do_log_msg(LogLevel::Error, None, f))
    }

    #[track_caller]
    #[cfg(debug_assertions)]
    fn log_with_msg<F: FnOnce(Formatter) -> fmt::Result>(self, f: F) -> LoggedResult<T> {
        let caller = Some(Location::caller());
        self.inspect_err(|_| do_log_msg(LogLevel::Error, caller, f))
    }

    fn log_ok(self) {}
}

// Allow converting Loggable errors to LoggedError to support `?` operator
impl<T: Loggable> From<T> for LoggedError {
    #[cfg(not(debug_assertions))]
    fn from(e: T) -> Self {
        e.do_log(LogLevel::Error, None)
    }

    #[track_caller]
    #[cfg(debug_assertions)]
    fn from(e: T) -> Self {
        let caller = Some(Location::caller());
        e.do_log(LogLevel::Error, caller)
    }
}

// Actual logging implementation

// Make all printable objects Loggable
impl<T: Display> Loggable for T {
    fn do_log(self, level: LogLevel, caller: Option<&'static Location>) -> LoggedError {
        if let Some(caller) = caller {
            log_with_args!(level, "[{}:{}] {:#}", caller.file(), caller.line(), self);
        } else {
            log_with_args!(level, "{:#}", self);
        }
        LoggedError::default()
    }

    fn do_log_msg<F: FnOnce(Formatter) -> fmt::Result>(
        self,
        level: LogLevel,
        caller: Option<&'static Location>,
        f: F,
    ) -> LoggedError {
        log_with_formatter(level, |w| {
            if let Some(caller) = caller {
                write!(w, "[{}:{}] ", caller.file(), caller.line())?;
            }
            f(w)?;
            writeln!(w, ": {self:#}")
        });
        LoggedError::default()
    }
}

fn do_log_msg<F: FnOnce(Formatter) -> fmt::Result>(
    level: LogLevel,
    caller: Option<&'static Location>,
    f: F,
) {
    log_with_formatter(level, |w| {
        if let Some(caller) = caller {
            write!(w, "[{}:{}] ", caller.file(), caller.line())?;
        }
        f(w)?;
        w.write_char('\n')
    });
}

// Check libc return value and map to Result
pub trait LibcReturn
where
    Self: Sized,
{
    type Value;

    fn check_err(self) -> nix::Result<Self::Value>;

    fn into_os_result<'a>(
        self,
        name: &'static str,
        arg1: Option<&'a str>,
        arg2: Option<&'a str>,
    ) -> OsResult<'a, Self::Value> {
        self.check_err()
            .map_err(|e| OsError::new(e, name, arg1, arg2))
    }

    fn check_os_err<'a>(
        self,
        name: &'static str,
        arg1: Option<&'a str>,
        arg2: Option<&'a str>,
    ) -> OsResult<'a, ()> {
        self.check_err()
            .map(|_| ())
            .map_err(|e| OsError::new(e, name, arg1, arg2))
    }
}

macro_rules! impl_libc_return {
    ($($t:ty)*) => ($(
        impl LibcReturn for $t {
            type Value = Self;

            #[inline(always)]
            fn check_err(self) -> nix::Result<Self::Value> {
                if self < 0 {
                    Err(Errno::last())
                } else {
                    Ok(self)
                }
            }
        }
    )*)
}

impl_libc_return! { i8 i16 i32 i64 isize }

impl<T> LibcReturn for *mut T {
    type Value = NonNull<T>;

    #[inline(always)]
    fn check_err(self) -> nix::Result<Self::Value> {
        NonNull::new(self).ok_or_else(Errno::last)
    }
}

impl<T> LibcReturn for nix::Result<T> {
    type Value = T;

    #[inline(always)]
    fn check_err(self) -> Self {
        self
    }
}

#[derive(Debug)]
pub struct OsError<'a> {
    pub errno: Errno,
    name: &'static str,
    arg1: Option<&'a str>,
    arg2: Option<&'a str>,
}

impl OsError<'_> {
    pub fn new<'a>(
        errno: Errno,
        name: &'static str,
        arg1: Option<&'a str>,
        arg2: Option<&'a str>,
    ) -> OsError<'a> {
        OsError {
            errno,
            name,
            arg1,
            arg2,
        }
    }

    pub fn last_os_error<'a>(
        name: &'static str,
        arg1: Option<&'a str>,
        arg2: Option<&'a str>,
    ) -> OsError<'a> {
        Self::new(Errno::last(), name, arg1, arg2)
    }

    pub fn set_args<'a>(self, arg1: Option<&'a str>, arg2: Option<&'a str>) -> OsError<'a> {
        Self::new(self.errno, self.name, arg1, arg2)
    }
}

impl Display for OsError<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.name.is_empty() {
            write!(f, "{}", self.errno)
        } else {
            match (self.arg1, self.arg2) {
                (Some(arg1), Some(arg2)) => {
                    write!(f, "{} '{arg1}' '{arg2}': {}", self.name, self.errno)
                }
                (Some(arg1), None) => {
                    write!(f, "{} '{arg1}': {}", self.name, self.errno)
                }
                _ => {
                    write!(f, "{}: {}", self.name, self.errno)
                }
            }
        }
    }
}

impl std::error::Error for OsError<'_> {}

pub type OsResult<'a, T> = Result<T, OsError<'a>>;

```

`native/src/base/xwrap.rs`:

```rs
// Functions in this file are only for exporting to C++, DO NOT USE IN RUST

use crate::cxx_extern::readlinkat;
use crate::{Directory, LibcReturn, ResultExt, Utf8CStr, cstr, slice_from_ptr, slice_from_ptr_mut};
use libc::{c_char, c_uint, c_ulong, c_void, dev_t, mode_t, off_t};
use std::ffi::CStr;
use std::fs::File;
use std::io::{Read, Write};
use std::mem::ManuallyDrop;
use std::os::fd::FromRawFd;
use std::os::unix::io::RawFd;
use std::ptr;
use std::ptr::NonNull;

fn ptr_to_str<'a>(ptr: *const c_char) -> Option<&'a str> {
    if ptr.is_null() {
        None
    } else {
        unsafe { CStr::from_ptr(ptr) }.to_str().ok()
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xrealpath(path: *const c_char, buf: *mut u8, bufsz: usize) -> isize {
    unsafe {
        match Utf8CStr::from_ptr(path) {
            Ok(path) => {
                let mut buf = cstr::buf::wrap_ptr(buf, bufsz);
                path.realpath(&mut buf)
                    .log()
                    .map_or(-1, |_| buf.len() as isize)
            }
            Err(_) => -1,
        }
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xreadlinkat(
    dirfd: RawFd,
    path: *const c_char,
    buf: *mut u8,
    bufsz: usize,
) -> isize {
    unsafe {
        readlinkat(dirfd, path, buf, bufsz)
            .into_os_result("readlinkat", ptr_to_str(path), None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xfopen(path: *const c_char, mode: *const c_char) -> *mut libc::FILE {
    unsafe {
        libc::fopen(path, mode)
            .into_os_result("fopen", ptr_to_str(path), None)
            .log()
            .map_or(ptr::null_mut(), NonNull::as_ptr)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xfdopen(fd: RawFd, mode: *const c_char) -> *mut libc::FILE {
    unsafe {
        libc::fdopen(fd, mode)
            .into_os_result("fdopen", None, None)
            .log()
            .map_or(ptr::null_mut(), NonNull::as_ptr)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xopen(path: *const c_char, flags: i32, mode: mode_t) -> RawFd {
    unsafe {
        libc::open(path, flags, mode as c_uint)
            .into_os_result("open", ptr_to_str(path), None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xopenat(dirfd: RawFd, path: *const c_char, flags: i32, mode: mode_t) -> RawFd {
    unsafe {
        libc::openat(dirfd, path, flags, mode as c_uint)
            .into_os_result("openat", ptr_to_str(path), None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xwrite(fd: RawFd, buf: *const u8, bufsz: usize) -> isize {
    let mut file = unsafe { ManuallyDrop::new(File::from_raw_fd(fd)) };
    let data = unsafe { slice_from_ptr(buf, bufsz) };
    file.write_all(data)
        .log()
        .map_or(-1, |_| data.len() as isize)
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xread(fd: RawFd, buf: *mut c_void, bufsz: usize) -> isize {
    unsafe {
        libc::read(fd, buf, bufsz)
            .into_os_result("read", None, None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xxread(fd: RawFd, buf: *mut u8, bufsz: usize) -> isize {
    let mut file = unsafe { ManuallyDrop::new(File::from_raw_fd(fd)) };
    let data = unsafe { slice_from_ptr_mut(buf, bufsz) };
    file.read_exact(data)
        .log()
        .map_or(-1, |_| data.len() as isize)
}

pub(crate) fn xpipe2(fds: &mut [i32; 2], flags: i32) -> i32 {
    unsafe {
        libc::pipe2(fds.as_mut_ptr(), flags)
            .into_os_result("pipe2", None, None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
extern "C" fn xsetns(fd: RawFd, nstype: i32) -> i32 {
    unsafe {
        libc::setns(fd, nstype)
            .into_os_result("setns", None, None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
extern "C" fn xunshare(flags: i32) -> i32 {
    unsafe {
        libc::unshare(flags)
            .into_os_result("unshare", None, None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xopendir(path: *const c_char) -> *mut libc::DIR {
    unsafe {
        libc::opendir(path)
            .into_os_result("opendir", ptr_to_str(path), None)
            .log()
            .map_or(ptr::null_mut(), NonNull::as_ptr)
    }
}

#[unsafe(no_mangle)]
extern "C" fn xfdopendir(fd: RawFd) -> *mut libc::DIR {
    unsafe {
        libc::fdopendir(fd)
            .into_os_result("fdopendir", None, None)
            .log()
            .map_or(ptr::null_mut(), NonNull::as_ptr)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xreaddir(mut dir: ManuallyDrop<Directory>) -> *mut libc::dirent {
    dir.read()
        .log()
        .ok()
        .flatten()
        .map_or(ptr::null_mut(), |entry| entry.as_ptr())
}

#[unsafe(no_mangle)]
extern "C" fn xsetsid() -> i32 {
    unsafe {
        libc::setsid()
            .into_os_result("setsid", None, None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xfstat(fd: RawFd, buf: *mut libc::stat) -> i32 {
    unsafe {
        libc::fstat(fd, buf)
            .into_os_result("fstat", None, None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
extern "C" fn xdup2(oldfd: RawFd, newfd: RawFd) -> RawFd {
    unsafe {
        libc::dup2(oldfd, newfd)
            .into_os_result("dup2", None, None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xsymlink(target: *const c_char, linkpath: *const c_char) -> i32 {
    unsafe {
        libc::symlink(target, linkpath)
            .into_os_result("symlink", ptr_to_str(target), ptr_to_str(linkpath))
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xmount(
    src: *const c_char,
    target: *const c_char,
    fstype: *const c_char,
    flags: c_ulong,
    data: *const c_void,
) -> i32 {
    unsafe {
        libc::mount(src, target, fstype, flags, data)
            .into_os_result("mount", ptr_to_str(src), ptr_to_str(target))
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xumount2(target: *const c_char, flags: i32) -> i32 {
    unsafe {
        libc::umount2(target, flags)
            .into_os_result("umount2", ptr_to_str(target), None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xrename(oldname: *const c_char, newname: *const c_char) -> i32 {
    unsafe {
        libc::rename(oldname, newname)
            .into_os_result("rename", ptr_to_str(oldname), ptr_to_str(newname))
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xmkdir(path: *const c_char, mode: mode_t) -> i32 {
    unsafe {
        match Utf8CStr::from_ptr(path) {
            Ok(path) => path.mkdir(mode).log().map_or(-1, |_| 0),
            Err(_) => -1,
        }
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xmkdirs(path: *const c_char, mode: mode_t) -> i32 {
    unsafe {
        match Utf8CStr::from_ptr(path) {
            Ok(path) => path.mkdirs(mode).log().map_or(-1, |_| 0),
            Err(_) => -1,
        }
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xsendfile(
    out_fd: RawFd,
    in_fd: RawFd,
    offset: *mut off_t,
    count: usize,
) -> isize {
    unsafe {
        libc::sendfile(out_fd, in_fd, offset, count)
            .into_os_result("sendfile", None, None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
extern "C" fn xfork() -> i32 {
    unsafe {
        libc::fork()
            .into_os_result("fork", None, None)
            .log()
            .unwrap_or(-1)
    }
}

#[unsafe(no_mangle)]
unsafe extern "C" fn xmknod(pathname: *const c_char, mode: mode_t, dev: dev_t) -> i32 {
    unsafe {
        libc::mknod(pathname, mode, dev)
            .into_os_result("mknod", ptr_to_str(pathname), None)
            .log()
            .unwrap_or(-1)
    }
}

```

`native/src/boot/Cargo.toml`:

```toml
[package]
name = "magiskboot"
version.workspace = true
edition.workspace = true

[lib]
crate-type = ["staticlib"]
path = "lib.rs"

[lints]
workspace = true

[build-dependencies]
cxx-gen = { workspace = true }
pb-rs = { workspace = true }

[dependencies]
base = { workspace = true }
cxx = { workspace = true }
byteorder = { workspace = true }
size = { workspace = true }
quick-protobuf = { workspace = true }
sha1 = { workspace = true }
sha2 = { workspace = true }
digest = { workspace = true }
p256 = { workspace = true }
p384 = { workspace = true }
p521 = { workspace = true }
rsa = { workspace = true, features = ["sha2"] }
x509-cert = { workspace = true }
der = { workspace = true, features = ["derive", "pem"] }
fdt = { workspace = true }
bytemuck = { workspace = true, features = ["derive", "min_const_generics"] }
num-traits = { workspace = true }
flate2 = { workspace = true, features = ["zlib-rs"] }
bzip2 = { workspace = true }
lz4 = { workspace = true }
lzma-rust2 = { workspace = true, features = ["xz", "std", "encoder", "optimization"] }
zopfli = { workspace = true, features = ["gzip"] }

```

`native/src/boot/bootimg.cpp`:

```cpp
#include <bit>
#include <functional>
#include <memory>
#include <span>

#include <base.hpp>

#include "boot-rs.hpp"
#include "bootimg.hpp"
#include "magiskboot.hpp"

using namespace std;

#define PADDING 15
#define SHA256_DIGEST_SIZE 32
#define SHA_DIGEST_SIZE 20

#define RETURN_OK       0
#define RETURN_ERROR    1
#define RETURN_CHROMEOS 2
#define RETURN_VENDOR   3

static void decompress(FileFormat type, int fd, const void *in, size_t size) {
    decompress_bytes(type, byte_view { in, size }, fd);
}

static off_t compress_len(FileFormat type, byte_view in, int fd) {
    auto prev = lseek(fd, 0, SEEK_CUR);
    compress_bytes(type, in, fd);
    auto now = lseek(fd, 0, SEEK_CUR);
    return now - prev;
}

static void dump(const void *buf, size_t size, const char *filename) {
    if (size == 0)
        return;
    int fd = creat(filename, 0644);
    xwrite(fd, buf, size);
    close(fd);
}

static size_t restore(int fd, const char *filename) {
    int ifd = xopen(filename, O_RDONLY);
    size_t size = lseek(ifd, 0, SEEK_END);
    lseek(ifd, 0, SEEK_SET);
    xsendfile(fd, ifd, nullptr, size);
    close(ifd);
    return size;
}

static bool check_env(const char *name) {
    const char *val = getenv(name);
    return val != nullptr && val == "true"sv;
}

static bool guess_lzma(const uint8_t *buf, size_t len) {
    // 0     : (pb * 5 + lp) * 9 + lc
    // 1 - 4 : dict size, must be 2^n
    // 5 - 12: all 0xFF
    if (len <= 13) return false;
    if (memcmp(buf, "\x5d", 1) != 0) return false;
    uint32_t dict_sz = 0;
    memcpy(&dict_sz, buf + 1, sizeof(dict_sz));
    if (dict_sz == 0 || (dict_sz & (dict_sz - 1)) != 0) return false;
    if (memcmp(buf + 5, "\xff\xff\xff\xff\xff\xff\xff\xff", 8) != 0) return false;
    return true;
}

FileFormat check_fmt(const void *buf, size_t len) {
    if (CHECKED_MATCH(CHROMEOS_MAGIC)) {
        return FileFormat::CHROMEOS;
    } else if (CHECKED_MATCH(BOOT_MAGIC)) {
        return FileFormat::AOSP;
    } else if (CHECKED_MATCH(VENDOR_BOOT_MAGIC)) {
        return FileFormat::AOSP_VENDOR;
    } else if (CHECKED_MATCH(GZIP1_MAGIC) || CHECKED_MATCH(GZIP2_MAGIC)) {
        return FileFormat::GZIP;
    } else if (CHECKED_MATCH(LZOP_MAGIC)) {
        return FileFormat::LZOP;
    } else if (CHECKED_MATCH(XZ_MAGIC)) {
        return FileFormat::XZ;
    } else if (guess_lzma(static_cast<const uint8_t *>(buf), len)) {
        return FileFormat::LZMA;
    } else if (CHECKED_MATCH(BZIP_MAGIC)) {
        return FileFormat::BZIP2;
    } else if (CHECKED_MATCH(LZ41_MAGIC) || CHECKED_MATCH(LZ42_MAGIC)) {
        return FileFormat::LZ4;
    } else if (CHECKED_MATCH(LZ4_LEG_MAGIC)) {
        return FileFormat::LZ4_LEGACY;
    } else if (CHECKED_MATCH(MTK_MAGIC)) {
        return FileFormat::MTK;
    } else if (CHECKED_MATCH(DTB_MAGIC)) {
        return FileFormat::DTB;
    } else if (CHECKED_MATCH(DHTB_MAGIC)) {
        return FileFormat::DHTB;
    } else if (CHECKED_MATCH(TEGRABLOB_MAGIC)) {
        return FileFormat::BLOB;
    } else if (len >= 0x28 && memcmp(&((char *)buf)[0x24], ZIMAGE_MAGIC, 4) == 0) {
        return FileFormat::ZIMAGE;
    } else {
        return FileFormat::UNKNOWN;
    }
}

void dyn_img_hdr::print() const {
    uint32_t ver = header_version();
    fprintf(stderr, "%-*s [%u]\n", PADDING, "HEADER_VER", ver);
    if (!is_vendor())
        fprintf(stderr, "%-*s [%u]\n", PADDING, "KERNEL_SZ", kernel_size());
    fprintf(stderr, "%-*s [%u]\n", PADDING, "RAMDISK_SZ", ramdisk_size());
    if (ver < 3)
        fprintf(stderr, "%-*s [%u]\n", PADDING, "SECOND_SZ", second_size());
    if (ver == 0)
        fprintf(stderr, "%-*s [%u]\n", PADDING, "EXTRA_SZ", extra_size());
    if (ver == 1 || ver == 2)
        fprintf(stderr, "%-*s [%u]\n", PADDING, "RECOV_DTBO_SZ", recovery_dtbo_size());
    if (ver == 2 || is_vendor())
        fprintf(stderr, "%-*s [%u]\n", PADDING, "DTB_SZ", dtb_size());
    if (ver == 4 && is_vendor())
        fprintf(stderr, "%-*s [%u]\n", PADDING, "BOOTCONFIG_SZ", bootconfig_size());

    if (uint32_t os_ver = os_version()) {
        int a,b,c,y,m = 0;
        int version = os_ver >> 11;
        int patch_level = os_ver & 0x7ff;

        a = (version >> 14) & 0x7f;
        b = (version >> 7) & 0x7f;
        c = version & 0x7f;
        fprintf(stderr, "%-*s [%d.%d.%d]\n", PADDING, "OS_VERSION", a, b, c);

        y = (patch_level >> 4) + 2000;
        m = patch_level & 0xf;
        fprintf(stderr, "%-*s [%d-%02d]\n", PADDING, "OS_PATCH_LEVEL", y, m);
    }

    fprintf(stderr, "%-*s [%u]\n", PADDING, "PAGESIZE", page_size());
    if (const char *n = name()) {
        fprintf(stderr, "%-*s [%s]\n", PADDING, "NAME", n);
    }
    fprintf(stderr, "%-*s [%.*s%.*s]\n", PADDING, "CMDLINE",
            BOOT_ARGS_SIZE, cmdline(), BOOT_EXTRA_ARGS_SIZE, extra_cmdline());
    if (const char *checksum = id()) {
        fprintf(stderr, "%-*s [", PADDING, "CHECKSUM");
        for (int i = 0; i < SHA256_DIGEST_SIZE; ++i)
            fprintf(stderr, "%02hhx", checksum[i]);
        fprintf(stderr, "]\n");
    }
}

void dyn_img_hdr::dump_hdr_file() const {
    FILE *fp = xfopen(HEADER_FILE, "w");
    if (name())
        fprintf(fp, "name=%s\n", name());
    fprintf(fp, "cmdline=%.*s%.*s\n", BOOT_ARGS_SIZE, cmdline(), BOOT_EXTRA_ARGS_SIZE, extra_cmdline());
    uint32_t ver = os_version();
    if (ver) {
        int a, b, c, y, m;
        int version, patch_level;
        version = ver >> 11;
        patch_level = ver & 0x7ff;

        a = (version >> 14) & 0x7f;
        b = (version >> 7) & 0x7f;
        c = version & 0x7f;
        fprintf(fp, "os_version=%d.%d.%d\n", a, b, c);

        y = (patch_level >> 4) + 2000;
        m = patch_level & 0xf;
        fprintf(fp, "os_patch_level=%d-%02d\n", y, m);
    }
    fclose(fp);
}

void dyn_img_hdr::load_hdr_file() {
    parse_prop_file(HEADER_FILE, [=, this](Utf8CStr key, Utf8CStr value) -> bool {
        if (key == "name" && name()) {
            memset(name(), 0, 16);
            memcpy(name(), value.data(), value.length() > 15 ? 15 : value.length());
        } else if (key == "cmdline") {
            memset(cmdline(), 0, BOOT_ARGS_SIZE);
            memset(extra_cmdline(), 0, BOOT_EXTRA_ARGS_SIZE);
            if (value.length() > BOOT_ARGS_SIZE) {
                memcpy(cmdline(), value.data(), BOOT_ARGS_SIZE);
                auto len = std::min(value.length() - BOOT_ARGS_SIZE, (size_t) BOOT_EXTRA_ARGS_SIZE);
                memcpy(extra_cmdline(), value.data() + BOOT_ARGS_SIZE, len);
            } else {
                memcpy(cmdline(), value.data(), value.length());
            }
        } else if (key == "os_version") {
            int patch_level = os_version() & 0x7ff;
            int a, b, c;
            sscanf(value.data(), "%d.%d.%d", &a, &b, &c);
            os_version() = (((a << 14) | (b << 7) | c) << 11) | patch_level;
        } else if (key == "os_patch_level") {
            int os_ver = os_version() >> 11;
            int y, m;
            sscanf(value.data(), "%d-%d", &y, &m);
            y -= 2000;
            os_version() = (os_ver << 11) | (y << 4) | m;
        }
        return true;
    });
}

boot_img::boot_img(const char *image) :
map(image), k_fmt(FileFormat::UNKNOWN), r_fmt(FileFormat::UNKNOWN), e_fmt(FileFormat::UNKNOWN) {
    fprintf(stderr, "Parsing boot image: [%s]\n", image);
    for (const uint8_t *addr = map.data(); addr < map.data() + map.size(); ++addr) {
        FileFormat fmt = check_fmt(addr, map.size());
        switch (fmt) {
        case FileFormat::CHROMEOS:
            // chromeos require external signing
            flags[CHROMEOS_FLAG] = true;
            addr += 65535;
            break;
        case FileFormat::DHTB:
            flags[DHTB_FLAG] = true;
            flags[SEANDROID_FLAG] = true;
            fprintf(stderr, "DHTB_HDR\n");
            addr += sizeof(dhtb_hdr) - 1;
            break;
        case FileFormat::BLOB:
            flags[BLOB_FLAG] = true;
            fprintf(stderr, "TEGRA_BLOB\n");
            addr += sizeof(blob_hdr) - 1;
            break;
        case FileFormat::AOSP:
        case FileFormat::AOSP_VENDOR:
            if (parse_image(addr, fmt))
                return;
            // fallthrough
        default:
            break;
        }
    }
    exit(RETURN_ERROR);
}

boot_img::~boot_img() {
    delete hdr;
}

struct [[gnu::packed]] fdt_header {
    struct fdt32_t {
        uint32_t byte0: 8;
        uint32_t byte1: 8;
        uint32_t byte2: 8;
        uint32_t byte3: 8;

        constexpr operator uint32_t() const {
            return bit_cast<uint32_t>(fdt32_t {
                .byte0 = byte3,
                .byte1 = byte2,
                .byte2 = byte1,
                .byte3 = byte0
            });
        }
    };

    struct node_header {
        fdt32_t tag;
        char name[0];
    };

    fdt32_t magic;			 /* magic word FDT_MAGIC */
    fdt32_t totalsize;		 /* total size of DT block */
    fdt32_t off_dt_struct;		 /* offset to structure */
    fdt32_t off_dt_strings;		 /* offset to strings */
    fdt32_t off_mem_rsvmap;		 /* offset to memory reserve map */
    fdt32_t version;		 /* format version */
    fdt32_t last_comp_version;	 /* last compatible version */

    /* version 2 fields below */
    fdt32_t boot_cpuid_phys;	 /* Which physical CPU id we're
					    booting on */
    /* version 3 fields below */
    fdt32_t size_dt_strings;	 /* size of the strings block */

    /* version 17 fields below */
    fdt32_t size_dt_struct;		 /* size of the structure block */
};

static int find_dtb_offset(const uint8_t *buf, unsigned sz) {
    const uint8_t * const end = buf + sz;

    for (auto curr = buf; curr < end; curr += sizeof(fdt_header)) {
        curr = static_cast<uint8_t*>(memmem(curr, end - curr, DTB_MAGIC, sizeof(fdt_header::fdt32_t)));
        if (curr == nullptr)
            return -1;

        auto fdt_hdr = reinterpret_cast<const fdt_header *>(curr);

        // Check that fdt_header.totalsize does not overflow kernel image size or is empty dtb
        // https://github.com/torvalds/linux/commit/7b937cc243e5b1df8780a0aa743ce800df6c68d1
        uint32_t totalsize = fdt_hdr->totalsize;
        if (totalsize > end - curr || totalsize <= 0x48)
            continue;

        // Check that fdt_header.off_dt_struct does not overflow kernel image size
        uint32_t off_dt_struct = fdt_hdr->off_dt_struct;
        if (off_dt_struct > end - curr)
            continue;

        // Check that fdt_node_header.tag of first node is FDT_BEGIN_NODE
        auto fdt_node_hdr = reinterpret_cast<const fdt_header::node_header *>(curr + off_dt_struct);
        if (fdt_node_hdr->tag != 0x1u)
            continue;

        return curr - buf;
    }
    return -1;
}

static FileFormat check_fmt_lg(const uint8_t *buf, unsigned sz) {
    FileFormat fmt = check_fmt(buf, sz);
    if (fmt == FileFormat::LZ4_LEGACY) {
        // We need to check if it is LZ4_LG
        uint32_t off = 4;
        uint32_t block_sz;
        while (off + sizeof(block_sz) <= sz) {
            memcpy(&block_sz, buf + off, sizeof(block_sz));
            off += sizeof(block_sz);
            if (off + block_sz > sz)
                return FileFormat::LZ4_LG;
            off += block_sz;
        }
    }
    return fmt;
}

#define CMD_MATCH(s) BUFFER_MATCH(h->cmdline, s)

const uint8_t *boot_img::parse_hdr(const uint8_t *addr, FileFormat type) {
    if (type == FileFormat::AOSP_VENDOR) {
        fprintf(stderr, "VENDOR_BOOT_HDR\n");
        auto h = reinterpret_cast<const boot_img_hdr_vnd_v3*>(addr);
        switch (h->header_version) {
        case 4:
            hdr = new dyn_img_vnd_v4(addr);
            break;
        default:
            hdr = new dyn_img_vnd_v3(addr);
            break;
        }
        return addr;
    }

    auto h = reinterpret_cast<const boot_img_hdr_v0*>(addr);

    if (h->page_size >= 0x02000000) {
        fprintf(stderr, "PXA_BOOT_HDR\n");
        hdr = new dyn_img_pxa(addr);
        return addr;
    }

    auto make_aosp_hdr = [](const uint8_t *ptr, ssize_t size = -1) -> dyn_img_hdr * {
        auto h = reinterpret_cast<const boot_img_hdr_v0*>(ptr);
        if (memcmp(h->magic, BOOT_MAGIC, BOOT_MAGIC_SIZE) != 0)
            return nullptr;

        switch (h->header_version) {
        case 1:
            return new dyn_img_v1(ptr, size);
        case 2:
            return new dyn_img_v2(ptr, size);
        case 3:
            return new dyn_img_v3(ptr, size);
        case 4:
            return new dyn_img_v4(ptr, size);
        default:
            return new dyn_img_v0(ptr, size);
        }
    };

    // For NOOKHD and ACCLAIM, the entire boot image is shifted by a fixed offset.
    // For AMONET, the header itself is internally shifted by a fixed offset.

    if (BUFFER_CONTAIN(addr, AMONET_MICROLOADER_SZ, AMONET_MICROLOADER_MAGIC) &&
        BUFFER_MATCH(addr + AMONET_MICROLOADER_SZ, BOOT_MAGIC)) {
        flags[AMONET_FLAG] = true;
        fprintf(stderr, "AMONET_MICROLOADER\n");

        // The real header is shifted
        h = reinterpret_cast<const boot_img_hdr_v0*>(addr + AMONET_MICROLOADER_SZ);
        auto real_hdr_sz = h->page_size - AMONET_MICROLOADER_SZ;
        hdr = make_aosp_hdr(addr + AMONET_MICROLOADER_SZ, real_hdr_sz);
        return addr;
    }

    if (CMD_MATCH(NOOKHD_RL_MAGIC) ||
        CMD_MATCH(NOOKHD_GL_MAGIC) ||
        CMD_MATCH(NOOKHD_GR_MAGIC) ||
        CMD_MATCH(NOOKHD_EB_MAGIC) ||
        CMD_MATCH(NOOKHD_ER_MAGIC)) {
        flags[NOOKHD_FLAG] = true;
        fprintf(stderr, "NOOKHD_LOADER\n");
        addr += NOOKHD_PRE_HEADER_SZ;
    } else if (BUFFER_MATCH(h->name, ACCLAIM_MAGIC)) {
        flags[ACCLAIM_FLAG] = true;
        fprintf(stderr, "ACCLAIM_LOADER\n");
        addr += ACCLAIM_PRE_HEADER_SZ;
    }

    hdr = make_aosp_hdr(addr);
    return addr;
}

void boot_img::parse_zimage() {
    z_info.hdr = reinterpret_cast<const zimage_hdr *>(kernel);

    const uint8_t* piggy = nullptr;
    // Skip 0x28, which includes zimage header
    for (const uint8_t* curr = kernel + 0x28; curr < kernel + hdr->kernel_size(); curr++) {
        if (check_fmt_lg(curr, hdr->kernel_size() - (curr - kernel)) != FileFormat::UNKNOWN) {
            piggy = curr;
            break;
        }
    }

    if (piggy != nullptr) {
        fprintf(stderr, "ZIMAGE_KERNEL\n");
        z_info.hdr_sz = piggy - kernel;

        // Find end of piggy
        uint32_t piggy_size = z_info.hdr->end - z_info.hdr->start;
        uint32_t piggy_end = piggy_size;
        uint32_t offsets[16];
        memcpy(offsets, kernel + piggy_size - sizeof(offsets), sizeof(offsets));
        for (int i = 15; i >= 0; --i) {
            if (offsets[i] > (piggy_size - 0xFF) && offsets[i] < piggy_size) {
                piggy_end = offsets[i];
                break;
            }
        }

        if (piggy_end == piggy_size) {
            fprintf(stderr, "! Could not find end of zImage piggy, keeping raw kernel\n");
        } else {
            flags[ZIMAGE_KERNEL] = true;
            z_info.tail = byte_view(kernel + piggy_end, hdr->kernel_size() - piggy_end);
            // Shift the kernel pointer and resize
            kernel += z_info.hdr_sz;
            hdr->kernel_size() = piggy_end - z_info.hdr_sz;
            k_fmt = check_fmt_lg(kernel, hdr->kernel_size());
        }
    } else {
        fprintf(stderr, "! Could not find zImage piggy, keeping raw kernel\n");
    }
}

static const char *vendor_ramdisk_type(int type) {
    switch (type) {
    case VENDOR_RAMDISK_TYPE_PLATFORM:
        return "platform";
    case VENDOR_RAMDISK_TYPE_RECOVERY:
        return "recovery";
    case VENDOR_RAMDISK_TYPE_DLKM:
        return "dlkm";
    case VENDOR_RAMDISK_TYPE_NONE:
    default:
        return "none";
    }
}

std::span<const vendor_ramdisk_table_entry_v4> boot_img::vendor_ramdisk_tbl() const {
    if (hdr->vendor_ramdisk_table_size() == 0) {
        return {};
    }

    // v4 vendor boot contains multiple ramdisks
    using table_entry = const vendor_ramdisk_table_entry_v4;
    if (hdr->vendor_ramdisk_table_entry_size() != sizeof(table_entry)) {
        fprintf(stderr,
                "! Invalid vendor image: vendor_ramdisk_table_entry_size != %zu\n",
                sizeof(table_entry));
        exit(RETURN_ERROR);
    }
    return span(reinterpret_cast<table_entry *>(vendor_ramdisk_table), hdr->vendor_ramdisk_table_entry_num());
}


#define assert_off() \
if ((addr + off) > (map.data() + map_end)) {      \
    fprintf(stderr, "Corrupted boot image!\n");   \
    return false;                                 \
}

#define get_block(name)                 \
name = addr + off;                      \
off += hdr->name##_size();              \
off = align_to(off, hdr->page_size());  \
assert_off()

bool boot_img::parse_image(const uint8_t *addr, FileFormat type) {
    addr = parse_hdr(addr, type);
    if (hdr == nullptr) {
        fprintf(stderr, "Invalid boot image header!\n");
        return false;
    }

    if (const char *id = hdr->id()) {
        for (int i = SHA_DIGEST_SIZE + 4; i < SHA256_DIGEST_SIZE; ++i) {
            if (id[i]) {
                flags[SHA256_FLAG] = true;
                break;
            }
        }
    }

    hdr->print();

    size_t map_end = align_to(map.size(), getpagesize());
    size_t off = hdr->hdr_space();
    get_block(kernel);
    get_block(ramdisk);
    get_block(second);
    get_block(extra);
    get_block(recovery_dtbo);
    get_block(dtb);
    get_block(signature);
    get_block(vendor_ramdisk_table);
    get_block(bootconfig);

    payload = byte_view(addr, off);
    auto tail_addr = addr + off;
    tail = byte_view(tail_addr, map.data() + map_end - tail_addr);

    if (auto size = hdr->kernel_size()) {
        if (int dtb_off = find_dtb_offset(kernel, size); dtb_off > 0) {
            kernel_dtb = byte_view(kernel + dtb_off, size - dtb_off);
            hdr->kernel_size() = dtb_off;
            fprintf(stderr, "%-*s [%zu]\n", PADDING, "KERNEL_DTB_SZ", kernel_dtb.size());
        }

        k_fmt = check_fmt_lg(kernel, hdr->kernel_size());
        if (k_fmt == FileFormat::MTK) {
            fprintf(stderr, "MTK_KERNEL_HDR\n");
            flags[MTK_KERNEL] = true;
            k_hdr = reinterpret_cast<const mtk_hdr *>(kernel);
            fprintf(stderr, "%-*s [%u]\n", PADDING, "SIZE", k_hdr->size);
            fprintf(stderr, "%-*s [%s]\n", PADDING, "NAME", k_hdr->name);
            kernel += sizeof(mtk_hdr);
            hdr->kernel_size() -= sizeof(mtk_hdr);
            k_fmt = check_fmt_lg(kernel, hdr->kernel_size());
        }
        if (k_fmt == FileFormat::ZIMAGE) {
            parse_zimage();
        }
        fprintf(stderr, "%-*s [%s]\n", PADDING, "KERNEL_FMT", fmt2name(k_fmt));
    }
    if (auto size = hdr->ramdisk_size()) {
        if (hdr->vendor_ramdisk_table_size()) {
            for (auto &it : vendor_ramdisk_tbl()) {
                FileFormat fmt = check_fmt_lg(ramdisk + it.ramdisk_offset, it.ramdisk_size);
                fprintf(stderr,
                        "%-*s name=[%s] type=[%s] size=[%u] fmt=[%s]\n", PADDING, "VND_RAMDISK",
                        it.ramdisk_name, vendor_ramdisk_type(it.ramdisk_type),
                        it.ramdisk_size, fmt2name(fmt));
            }
        } else {
            r_fmt = check_fmt_lg(ramdisk, size);
            if (r_fmt == FileFormat::MTK) {
                fprintf(stderr, "MTK_RAMDISK_HDR\n");
                flags[MTK_RAMDISK] = true;
                r_hdr = reinterpret_cast<const mtk_hdr *>(ramdisk);
                fprintf(stderr, "%-*s [%u]\n", PADDING, "SIZE", r_hdr->size);
                fprintf(stderr, "%-*s [%s]\n", PADDING, "NAME", r_hdr->name);
                ramdisk += sizeof(mtk_hdr);
                hdr->ramdisk_size() -= sizeof(mtk_hdr);
                r_fmt = check_fmt_lg(ramdisk, hdr->ramdisk_size());
            }
            fprintf(stderr, "%-*s [%s]\n", PADDING, "RAMDISK_FMT", fmt2name(r_fmt));
        }
    }
    if (auto size = hdr->extra_size()) {
        e_fmt = check_fmt_lg(extra, size);
        fprintf(stderr, "%-*s [%s]\n", PADDING, "EXTRA_FMT", fmt2name(e_fmt));
    }

    if (tail.size()) {
        // Check special flags
        if (tail.size() >= 16 && BUFFER_MATCH(tail.data(), SEANDROID_MAGIC)) {
            fprintf(stderr, "SAMSUNG_SEANDROID\n");
            flags[SEANDROID_FLAG] = true;
        } else if (tail.size() >= 16 && BUFFER_MATCH(tail.data(), LG_BUMP_MAGIC)) {
            fprintf(stderr, "LG_BUMP_IMAGE\n");
            flags[LG_BUMP_FLAG] = true;
        } else if (verify()) {
            fprintf(stderr, "AVB1_SIGNED\n");
            flags[AVB1_SIGNED_FLAG] = true;
        }

        // Find AVB footer
        const void *footer = tail.data() + tail.size() - sizeof(AvbFooter);
        if (BUFFER_MATCH(footer, AVB_FOOTER_MAGIC)) {
            avb_footer = static_cast<const AvbFooter*>(footer);
            // Double check if meta header exists
            const void *meta = payload.data() + __builtin_bswap64(avb_footer->vbmeta_offset);
            if (BUFFER_MATCH(meta, AVB_MAGIC)) {
                fprintf(stderr, "VBMETA\n");
                flags[AVB_FLAG] = true;
                vbmeta = static_cast<const AvbVBMetaImageHeader*>(meta);
            }
        }
    }

    return true;
}

int split_image_dtb(Utf8CStr filename, bool skip_decomp) {
    mmap_data img(filename.c_str());

    if (int offset = find_dtb_offset(img.data(), img.size()); offset > 0) {
        size_t off = (size_t) offset;

        FileFormat fmt = check_fmt_lg(img.data(), img.size());
        if (!skip_decomp && fmt_compressed(fmt)) {
            int fd = creat(KERNEL_FILE, 0644);
            decompress(fmt, fd, img.data(), off);
            close(fd);
        } else {
            dump(img.data(), off, KERNEL_FILE);
        }
        dump(img.data() + off, img.size() - off, KER_DTB_FILE);
        return 0;
    } else {
        fprintf(stderr, "Cannot find DTB in %s\n", filename.c_str());
        return 1;
    }
}

int unpack(Utf8CStr image, bool skip_decomp, bool hdr) {
    const boot_img boot(image.c_str());

    if (hdr)
        boot.hdr->dump_hdr_file();

    // Dump kernel
    if (!skip_decomp && fmt_compressed(boot.k_fmt)) {
        if (boot.hdr->kernel_size() != 0) {
            int fd = creat(KERNEL_FILE, 0644);
            decompress(boot.k_fmt, fd, boot.kernel, boot.hdr->kernel_size());
            close(fd);
        }
    } else {
        dump(boot.kernel, boot.hdr->kernel_size(), KERNEL_FILE);
    }

    // Dump kernel_dtb
    dump(boot.kernel_dtb.data(), boot.kernel_dtb.size(), KER_DTB_FILE);

    // Dump ramdisk
    if (boot.hdr->vendor_ramdisk_table_size()) {
        xmkdir(VND_RAMDISK_DIR, 0755);
        owned_fd dirfd = xopen(VND_RAMDISK_DIR, O_RDONLY | O_CLOEXEC);
        for (auto &it : boot.vendor_ramdisk_tbl()) {
            char file_name[40];
            if (it.ramdisk_name[0] == '\0') {
                strscpy(file_name, RAMDISK_FILE, sizeof(file_name));
            } else {
                ssprintf(file_name, sizeof(file_name), "%s.cpio", it.ramdisk_name);
            }
            owned_fd fd = xopenat(dirfd, file_name, O_CREAT | O_TRUNC | O_WRONLY | O_CLOEXEC, 0644);
            FileFormat fmt = check_fmt_lg(boot.ramdisk + it.ramdisk_offset, it.ramdisk_size);
            if (!skip_decomp && fmt_compressed(fmt)) {
                decompress(fmt, fd, boot.ramdisk + it.ramdisk_offset, it.ramdisk_size);
            } else {
                xwrite(fd, boot.ramdisk + it.ramdisk_offset, it.ramdisk_size);
            }
        }
    } else if (!skip_decomp && fmt_compressed(boot.r_fmt)) {
        if (boot.hdr->ramdisk_size() != 0) {
            int fd = creat(RAMDISK_FILE, 0644);
            decompress(boot.r_fmt, fd, boot.ramdisk, boot.hdr->ramdisk_size());
            close(fd);
        }
    } else {
        dump(boot.ramdisk, boot.hdr->ramdisk_size(), RAMDISK_FILE);
    }

    // Dump second
    dump(boot.second, boot.hdr->second_size(), SECOND_FILE);

    // Dump extra
    if (!skip_decomp && fmt_compressed(boot.e_fmt)) {
        if (boot.hdr->extra_size() != 0) {
            int fd = creat(EXTRA_FILE, 0644);
            decompress(boot.e_fmt, fd, boot.extra, boot.hdr->extra_size());
            close(fd);
        }
    } else {
        dump(boot.extra, boot.hdr->extra_size(), EXTRA_FILE);
    }

    // Dump recovery_dtbo
    dump(boot.recovery_dtbo, boot.hdr->recovery_dtbo_size(), RECV_DTBO_FILE);

    // Dump dtb
    dump(boot.dtb, boot.hdr->dtb_size(), DTB_FILE);

    // Dump bootconfig
    dump(boot.bootconfig, boot.hdr->bootconfig_size(), BOOTCONFIG_FILE);

    if (boot.flags[CHROMEOS_FLAG]) return RETURN_CHROMEOS;
    if (boot.hdr->is_vendor()) return RETURN_VENDOR;
    return RETURN_OK;
}

#define file_align_with(page_size) \
write_zero(fd, align_padding(lseek(fd, 0, SEEK_CUR) - off.header, page_size))

#define file_align() file_align_with(boot.hdr->page_size())

void repack(Utf8CStr src_img, Utf8CStr out_img, bool skip_comp) {
    const boot_img boot(src_img.c_str());
    fprintf(stderr, "Repack to boot image: [%s]\n", out_img.c_str());

    struct {
        uint32_t header;
        uint32_t kernel;
        uint32_t ramdisk;
        uint32_t second;
        uint32_t extra;
        uint32_t dtb;
        uint32_t tail;
        uint32_t vbmeta;
    } off{};

    // Create a new boot header and reset sizes
    auto hdr = boot.hdr->clone();
    hdr->kernel_size() = 0;
    hdr->ramdisk_size() = 0;
    hdr->second_size() = 0;
    hdr->dtb_size() = 0;
    hdr->bootconfig_size() = 0;

    if (access(HEADER_FILE, R_OK) == 0)
        hdr->load_hdr_file();

    /***************
     * Write blocks
     ***************/

    // Create new image
    int fd = open(out_img.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0644);

    // Copy non-standard headers
    if (boot.flags[DHTB_FLAG]) {
        xwrite(fd, boot.map.data(), sizeof(dhtb_hdr));
    } else if (boot.flags[BLOB_FLAG]) {
        xwrite(fd, boot.map.data(), sizeof(blob_hdr));
    } else if (boot.flags[NOOKHD_FLAG]) {
        xwrite(fd, boot.map.data(), NOOKHD_PRE_HEADER_SZ);
    } else if (boot.flags[ACCLAIM_FLAG]) {
        xwrite(fd, boot.map.data(), ACCLAIM_PRE_HEADER_SZ);
    }

    // Copy raw header
    off.header = lseek(fd, 0, SEEK_CUR);
    xwrite(fd, boot.payload.data(), hdr->hdr_space());

    // kernel
    off.kernel = lseek(fd, 0, SEEK_CUR);
    if (boot.flags[MTK_KERNEL]) {
        // Copy MTK headers
        xwrite(fd, boot.k_hdr, sizeof(mtk_hdr));
    }
    if (boot.flags[ZIMAGE_KERNEL]) {
        // Copy zImage headers
        xwrite(fd, boot.z_info.hdr, boot.z_info.hdr_sz);
    }
    if (access(KERNEL_FILE, R_OK) == 0) {
        mmap_data m(KERNEL_FILE);
        if (!skip_comp && !fmt_compressed_any(check_fmt(m.data(), m.size())) && fmt_compressed(boot.k_fmt)) {
            // Always use zopfli for zImage compression
            auto fmt = (boot.flags[ZIMAGE_KERNEL] && boot.k_fmt == FileFormat::GZIP) ? FileFormat::ZOPFLI : boot.k_fmt;
            hdr->kernel_size() = compress_len(fmt, m, fd);
        } else {
            hdr->kernel_size() = xwrite(fd, m.data(), m.size());
        }

        if (boot.flags[ZIMAGE_KERNEL]) {
            if (hdr->kernel_size() > boot.hdr->kernel_size()) {
                fprintf(stderr, "! Recompressed kernel is too large, using original kernel\n");
                ftruncate64(fd, lseek64(fd, - (off64_t) hdr->kernel_size(), SEEK_CUR));
                xwrite(fd, boot.kernel, boot.hdr->kernel_size());
            } else if (!skip_comp) {
                // Pad zeros to make sure the zImage file size does not change
                // Also ensure the last 4 bytes are the uncompressed vmlinux size
                uint32_t sz = m.size();
                write_zero(fd, boot.hdr->kernel_size() - hdr->kernel_size() - sizeof(sz));
                xwrite(fd, &sz, sizeof(sz));
            }

            // zImage size shall remain the same
            hdr->kernel_size() = boot.hdr->kernel_size();
        }
    } else if (boot.hdr->kernel_size() != 0) {
        xwrite(fd, boot.kernel, boot.hdr->kernel_size());
        hdr->kernel_size() = boot.hdr->kernel_size();
    }
    if (boot.flags[ZIMAGE_KERNEL]) {
        // Copy zImage tail and adjust size accordingly
        hdr->kernel_size() += boot.z_info.hdr_sz;
        hdr->kernel_size() += xwrite(fd, boot.z_info.tail.data(), boot.z_info.tail.size());
    }

    // kernel dtb
    if (access(KER_DTB_FILE, R_OK) == 0)
        hdr->kernel_size() += restore(fd, KER_DTB_FILE);
    file_align();

    // ramdisk
    off.ramdisk = lseek(fd, 0, SEEK_CUR);
    if (boot.flags[MTK_RAMDISK]) {
        // Copy MTK headers
        xwrite(fd, boot.r_hdr, sizeof(mtk_hdr));
    }

    vector<vendor_ramdisk_table_entry_v4> ramdisk_table;

    if (boot.hdr->vendor_ramdisk_table_size()) {
        // Create a copy so we can modify it
        ramdisk_table.assign_range(boot.vendor_ramdisk_tbl());

        owned_fd dirfd = xopen(VND_RAMDISK_DIR, O_RDONLY | O_CLOEXEC);
        uint32_t ramdisk_offset = 0;
        for (auto &it : ramdisk_table) {
            char file_name[64];
            if (it.ramdisk_name[0] == '\0') {
                strscpy(file_name, RAMDISK_FILE, sizeof(file_name));
            } else {
                ssprintf(file_name, sizeof(file_name), "%s.cpio", it.ramdisk_name);
            }
            mmap_data m(dirfd, file_name);
            FileFormat fmt = check_fmt_lg(boot.ramdisk + it.ramdisk_offset, it.ramdisk_size);
            it.ramdisk_offset = ramdisk_offset;
            if (!skip_comp && !fmt_compressed_any(check_fmt(m.data(), m.size())) && fmt_compressed(fmt)) {
                it.ramdisk_size = compress_len(fmt, m, fd);
            } else {
                it.ramdisk_size = xwrite(fd, m.data(), m.size());
            }
            ramdisk_offset += it.ramdisk_size;
        }

        hdr->ramdisk_size() = ramdisk_offset;
        file_align();
    } else if (access(RAMDISK_FILE, R_OK) == 0) {
        mmap_data m(RAMDISK_FILE);
        auto r_fmt = boot.r_fmt;
        if (!skip_comp && !hdr->is_vendor() && hdr->header_version() == 4 && r_fmt != FileFormat::LZ4_LEGACY) {
            // A v4 boot image ramdisk will have to be merged with other vendor ramdisks,
            // and they have to use the exact same compression method. v4 GKIs are required to
            // use lz4 (legacy), so hardcode the format here.
            fprintf(stderr, "RAMDISK_FMT: [%s] -> [%s]\n", fmt2name(r_fmt), fmt2name(FileFormat::LZ4_LEGACY));
            r_fmt = FileFormat::LZ4_LEGACY;
        }
        if (!skip_comp && !fmt_compressed_any(check_fmt(m.data(), m.size())) && fmt_compressed(r_fmt)) {
            hdr->ramdisk_size() = compress_len(r_fmt, m, fd);
        } else {
            hdr->ramdisk_size() = xwrite(fd, m.data(), m.size());
        }
        file_align();
    }

    // second
    off.second = lseek(fd, 0, SEEK_CUR);
    if (access(SECOND_FILE, R_OK) == 0) {
        hdr->second_size() = restore(fd, SECOND_FILE);
        file_align();
    }

    // extra
    off.extra = lseek(fd, 0, SEEK_CUR);
    if (access(EXTRA_FILE, R_OK) == 0) {
        mmap_data m(EXTRA_FILE);
        if (!skip_comp && !fmt_compressed_any(check_fmt(m.data(), m.size())) && fmt_compressed(boot.e_fmt)) {
            hdr->extra_size() = compress_len(boot.e_fmt, m, fd);
        } else {
            hdr->extra_size() = xwrite(fd, m.data(), m.size());
        }
        file_align();
    }

    // recovery_dtbo
    if (access(RECV_DTBO_FILE, R_OK) == 0) {
        hdr->recovery_dtbo_offset() = lseek(fd, 0, SEEK_CUR);
        hdr->recovery_dtbo_size() = restore(fd, RECV_DTBO_FILE);
        file_align();
    }

    // dtb
    off.dtb = lseek(fd, 0, SEEK_CUR);
    if (access(DTB_FILE, R_OK) == 0) {
        hdr->dtb_size() = restore(fd, DTB_FILE);
        file_align();
    }

    // Copy boot signature
    if (boot.hdr->signature_size()) {
        xwrite(fd, boot.signature, boot.hdr->signature_size());
        file_align();
    }

    // vendor ramdisk table
    if (!ramdisk_table.empty()) {
        xwrite(fd, ramdisk_table.data(), sizeof(*ramdisk_table.data()) * ramdisk_table.size());
        file_align();
    }

    // bootconfig
    if (access(BOOTCONFIG_FILE, R_OK) == 0) {
        hdr->bootconfig_size() = restore(fd, BOOTCONFIG_FILE);
        file_align();
    }

    // Proprietary stuffs
    if (boot.flags[SEANDROID_FLAG]) {
        xwrite(fd, SEANDROID_MAGIC, 16);
        if (boot.flags[DHTB_FLAG]) {
            xwrite(fd, "\xFF\xFF\xFF\xFF", 4);
        }
    } else if (boot.flags[LG_BUMP_FLAG]) {
        xwrite(fd, LG_BUMP_MAGIC, 16);
    }

    off.tail = lseek(fd, 0, SEEK_CUR);
    file_align();

    // vbmeta
    if (boot.flags[AVB_FLAG]) {
        // According to avbtool.py, if the input is not an Android sparse image
        // (which boot images are not), the default block size is 4096
        file_align_with(4096);
        off.vbmeta = lseek(fd, 0, SEEK_CUR);
        uint64_t vbmeta_size = __builtin_bswap64(boot.avb_footer->vbmeta_size);
        xwrite(fd, boot.vbmeta, vbmeta_size);
    }

    // Pad image to original size if not chromeos (as it requires post processing)
    if (!boot.flags[CHROMEOS_FLAG]) {
        off_t current = lseek(fd, 0, SEEK_CUR);
        if (current < boot.map.size()) {
            write_zero(fd, boot.map.size() - current);
        }
    }

    /******************
     * Patch the image
     ******************/

    uint32_t aosp_img_size = off.tail - off.header;

    // Map output image as rw
    mmap_data out(fd, lseek(fd, 0, SEEK_END), true);

    // MTK headers
    if (boot.flags[MTK_KERNEL]) {
        auto m_hdr = reinterpret_cast<mtk_hdr *>(out.data() + off.kernel);
        m_hdr->size = hdr->kernel_size();
        hdr->kernel_size() += sizeof(mtk_hdr);
    }
    if (boot.flags[MTK_RAMDISK]) {
        auto m_hdr = reinterpret_cast<mtk_hdr *>(out.data() + off.ramdisk);
        m_hdr->size = hdr->ramdisk_size();
        hdr->ramdisk_size() += sizeof(mtk_hdr);
    }

    // Make sure header size matches
    hdr->header_size() = hdr->hdr_size();

    // Update checksum
    if (char *id = hdr->id()) {
        auto ctx = get_sha(!boot.flags[SHA256_FLAG]);
        uint32_t size = hdr->kernel_size();
        ctx->update(byte_view(out.data() + off.kernel, size));
        ctx->update(byte_view(&size, sizeof(size)));
        size = hdr->ramdisk_size();
        ctx->update(byte_view(out.data() + off.ramdisk, size));
        ctx->update(byte_view(&size, sizeof(size)));
        size = hdr->second_size();
        ctx->update(byte_view(out.data() + off.second, size));
        ctx->update(byte_view(&size, sizeof(size)));
        size = hdr->extra_size();
        if (size) {
            ctx->update(byte_view(out.data() + off.extra, size));
            ctx->update(byte_view(&size, sizeof(size)));
        }
        uint32_t ver = hdr->header_version();
        if (ver == 1 || ver == 2) {
            size = hdr->recovery_dtbo_size();
            ctx->update(byte_view(out.data() + hdr->recovery_dtbo_offset(), size));
            ctx->update(byte_view(&size, sizeof(size)));
        }
        if (ver == 2) {
            size = hdr->dtb_size();
            ctx->update(byte_view(out.data() + off.dtb, size));
            ctx->update(byte_view(&size, sizeof(size)));
        }
        memset(id, 0, BOOT_ID_SIZE);
        ctx->finalize_into(byte_data(id, ctx->output_size()));
    }

    // Print new header info
    hdr->print();

    // Copy main header
    if (boot.flags[AMONET_FLAG]) {
        auto real_hdr_sz = std::min(hdr->hdr_space() - AMONET_MICROLOADER_SZ, hdr->hdr_size());
        memcpy(out.data() + off.header + AMONET_MICROLOADER_SZ, hdr->raw_hdr(), real_hdr_sz);
    } else {
        memcpy(out.data() + off.header, hdr->raw_hdr(), hdr->hdr_size());
    }

    if (boot.flags[AVB_FLAG]) {
        // Copy and patch AVB structures
        auto footer = reinterpret_cast<AvbFooter*>(out.data() + out.size() - sizeof(AvbFooter));
        memcpy(footer, boot.avb_footer, sizeof(AvbFooter));
        footer->original_image_size = __builtin_bswap64(aosp_img_size);
        footer->vbmeta_offset = __builtin_bswap64(off.vbmeta);
        if (check_env("PATCHVBMETAFLAG")) {
            auto vbmeta = reinterpret_cast<AvbVBMetaImageHeader*>(out.data() + off.vbmeta);
            vbmeta->flags = __builtin_bswap32(3);
        }
    }

    if (boot.flags[DHTB_FLAG]) {
        // DHTB header
        auto d_hdr = reinterpret_cast<dhtb_hdr *>(out.data());
        d_hdr->size = aosp_img_size + 16 /* SEANDROID_MAGIC */ + 4 /* DHTB trailer */;
        sha256_hash(byte_view(out.data() + sizeof(dhtb_hdr), d_hdr->size),
                    byte_data(d_hdr->checksum, SHA256_DIGEST_SIZE));
    } else if (boot.flags[BLOB_FLAG]) {
        // Blob header
        auto b_hdr = reinterpret_cast<blob_hdr *>(out.data());
        b_hdr->size = aosp_img_size;
    }

    // Sign the image after we finish patching the boot image
    if (boot.flags[AVB1_SIGNED_FLAG]) {
        byte_view payload(out.data() + off.header, aosp_img_size);
        auto sig = sign_payload(payload);
        if (!sig.empty()) {
            lseek(fd, off.tail, SEEK_SET);
            xwrite(fd, sig.data(), sig.size());
        }
    }

    close(fd);
}

void cleanup() {
    unlink(HEADER_FILE);
    unlink(KERNEL_FILE);
    unlink(RAMDISK_FILE);
    unlink(SECOND_FILE);
    unlink(KER_DTB_FILE);
    unlink(EXTRA_FILE);
    unlink(RECV_DTBO_FILE);
    unlink(DTB_FILE);
    unlink(BOOTCONFIG_FILE);
    rm_rf(VND_RAMDISK_DIR);
}

```

`native/src/boot/bootimg.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <utility>
#include <bitset>
#include <rust/cxx.h>

/******************
 * Special Headers
 *****************/

struct mtk_hdr {
    uint32_t magic;         /* MTK magic */
    uint32_t size;          /* Size of the content */
    char name[32];          /* The type of the header */

    char padding[472];      /* Padding to 512 bytes */
} __attribute__((packed));

struct dhtb_hdr {
    char magic[8];          /* DHTB magic */
    uint8_t checksum[40];   /* Payload SHA256, whole image + SEANDROIDENFORCE + 0xFFFFFFFF */
    uint32_t size;          /* Payload size, whole image + SEANDROIDENFORCE + 0xFFFFFFFF */

    char padding[460];      /* Padding to 512 bytes */
} __attribute__((packed));

struct blob_hdr {
    char secure_magic[20];  /* "-SIGNED-BY-SIGNBLOB-" */
    uint32_t datalen;       /* 0x00000000 */
    uint32_t signature;     /* 0x00000000 */
    char magic[16];         /* "MSM-RADIO-UPDATE" */
    uint32_t hdr_version;   /* 0x00010000 */
    uint32_t hdr_size;      /* Size of header */
    uint32_t part_offset;   /* Same as size */
    uint32_t num_parts;     /* Number of partitions */
    uint32_t unknown[7];    /* All 0x00000000 */
    char name[4];           /* Name of partition */
    uint32_t offset;        /* offset in blob where this partition starts */
    uint32_t size;          /* Size of data */
    uint32_t version;       /* 0x00000001 */
} __attribute__((packed));

struct zimage_hdr {
    uint32_t code[9];
    uint32_t magic;      /* zImage magic */
    uint32_t start;      /* absolute load/run zImage address */
    uint32_t end;        /* zImage end address */
    uint32_t endian;     /* endianness flag */
    // There could be more fields, but we don't care
} __attribute__((packed));

/**************
 * AVB Headers
 **************/

#define AVB_FOOTER_MAGIC_LEN 4
#define AVB_MAGIC_LEN 4
#define AVB_RELEASE_STRING_SIZE 48

// https://android.googlesource.com/platform/external/avb/+/refs/heads/android11-release/libavb/avb_footer.h
struct AvbFooter {
    uint8_t magic[AVB_FOOTER_MAGIC_LEN];
    uint32_t version_major;
    uint32_t version_minor;
    uint64_t original_image_size;
    uint64_t vbmeta_offset;
    uint64_t vbmeta_size;
    uint8_t reserved[28];
} __attribute__((packed));

// https://android.googlesource.com/platform/external/avb/+/refs/heads/android11-release/libavb/avb_vbmeta_image.h
struct AvbVBMetaImageHeader {
    uint8_t magic[AVB_MAGIC_LEN];
    uint32_t required_libavb_version_major;
    uint32_t required_libavb_version_minor;
    uint64_t authentication_data_block_size;
    uint64_t auxiliary_data_block_size;
    uint32_t algorithm_type;
    uint64_t hash_offset;
    uint64_t hash_size;
    uint64_t signature_offset;
    uint64_t signature_size;
    uint64_t public_key_offset;
    uint64_t public_key_size;
    uint64_t public_key_metadata_offset;
    uint64_t public_key_metadata_size;
    uint64_t descriptors_offset;
    uint64_t descriptors_size;
    uint64_t rollback_index;
    uint32_t flags;
    uint32_t rollback_index_location;
    uint8_t release_string[AVB_RELEASE_STRING_SIZE];
    uint8_t reserved[80];
} __attribute__((packed));

/*********************
 * Boot Image Headers
 *********************/

// https://android.googlesource.com/platform/system/tools/mkbootimg/+/refs/heads/android12-release/include/bootimg/bootimg.h

#define BOOT_MAGIC_SIZE 8
#define BOOT_NAME_SIZE 16
#define BOOT_ID_SIZE 32
#define BOOT_ARGS_SIZE 512
#define BOOT_EXTRA_ARGS_SIZE 1024
#define VENDOR_BOOT_ARGS_SIZE 2048
#define VENDOR_RAMDISK_NAME_SIZE 32
#define VENDOR_RAMDISK_TABLE_ENTRY_BOARD_ID_SIZE 16

#define VENDOR_RAMDISK_TYPE_NONE 0
#define VENDOR_RAMDISK_TYPE_PLATFORM 1
#define VENDOR_RAMDISK_TYPE_RECOVERY 2
#define VENDOR_RAMDISK_TYPE_DLKM 3

/*
 * When the boot image header has a version of 0 - 2, the structure of the boot
 * image is as follows:
 *
 * +-----------------+
 * | boot header     | 1 page
 * +-----------------+
 * | kernel          | m pages
 * +-----------------+
 * | ramdisk         | n pages
 * +-----------------+
 * | second stage    | o pages
 * +-----------------+
 * | extra blob      | x pages (non standard)
 * +-----------------+
 * | recovery dtbo   | p pages
 * +-----------------+
 * | dtb             | q pages
 * +-----------------+
 *
 * m = (kernel_size + page_size - 1) / page_size
 * n = (ramdisk_size + page_size - 1) / page_size
 * o = (second_size + page_size - 1) / page_size
 * p = (recovery_dtbo_size + page_size - 1) / page_size
 * q = (dtb_size + page_size - 1) / page_size
 * x = (extra_size + page_size - 1) / page_size
 */

struct boot_img_hdr_v0_common {
    char magic[BOOT_MAGIC_SIZE];

    uint32_t kernel_size;  /* size in bytes */
    uint32_t kernel_addr;  /* physical load addr */

    uint32_t ramdisk_size; /* size in bytes */
    uint32_t ramdisk_addr; /* physical load addr */

    uint32_t second_size;  /* size in bytes */
    uint32_t second_addr;  /* physical load addr */
} __attribute__((packed));

struct boot_img_hdr_v0 : public boot_img_hdr_v0_common {
    uint32_t tags_addr;    /* physical addr for kernel tags */

    // In AOSP headers, this field is used for page size.
    // For Samsung PXA headers, the use of this field is unknown;
    // however, its value is something unrealistic to be treated as page size.
    // We use this fact to determine whether this is an AOSP or PXA header.
    union {
        uint32_t unknown;
        uint32_t page_size;    /* flash page size we assume */
    };

    // In header v1, this field is used for header version
    // However, on some devices like Samsung, this field is used to store DTB
    // We treat this field differently based on its value
    union {
        uint32_t header_version;  /* the version of the header */
        uint32_t extra_size;      /* extra blob size in bytes */
    };

    // Operating system version and security patch level.
    // For version "A.B.C" and patch level "Y-M-D":
    //   (7 bits for each of A, B, C; 7 bits for (Y-2000), 4 bits for M)
    //   os_version = A[31:25] B[24:18] C[17:11] (Y-2000)[10:4] M[3:0]
    uint32_t os_version;

    char name[BOOT_NAME_SIZE];  /* asciiz product name */
    char cmdline[BOOT_ARGS_SIZE];
    char id[BOOT_ID_SIZE];      /* timestamp / checksum / sha1 / etc */

    // Supplemental command line data; kept here to maintain
    // binary compatibility with older versions of mkbootimg.
    char extra_cmdline[BOOT_EXTRA_ARGS_SIZE];
} __attribute__((packed));

struct boot_img_hdr_v1 : public boot_img_hdr_v0 {
    uint32_t recovery_dtbo_size;    /* size in bytes for recovery DTBO/ACPIO image */
    uint64_t recovery_dtbo_offset;  /* offset to recovery dtbo/acpio in boot image */
    uint32_t header_size;
} __attribute__((packed));

struct boot_img_hdr_v2 : public boot_img_hdr_v1 {
    uint32_t dtb_size;  /* size in bytes for DTB image */
    uint64_t dtb_addr;  /* physical load address for DTB image */
} __attribute__((packed));

// Special Samsung header
struct boot_img_hdr_pxa : public boot_img_hdr_v0_common {
    uint32_t extra_size;   /* extra blob size in bytes */
    uint32_t unknown;
    uint32_t tags_addr;    /* physical addr for kernel tags */
    uint32_t page_size;    /* flash page size we assume */

    char name[24];         /* asciiz product name */
    char cmdline[BOOT_ARGS_SIZE];
    char id[BOOT_ID_SIZE]; /* timestamp / checksum / sha1 / etc */

    char extra_cmdline[BOOT_EXTRA_ARGS_SIZE];
} __attribute__((packed));

/*
 * When the boot image header has a version of 3 - 4, the structure of the boot
 * image is as follows:
 *
 * +---------------------+
 * | boot header         | 4096 bytes
 * +---------------------+
 * | kernel              | m pages
 * +---------------------+
 * | ramdisk             | n pages
 * +---------------------+
 * | boot signature      | g pages
 * +---------------------+
 *
 * m = (kernel_size + 4096 - 1) / 4096
 * n = (ramdisk_size + 4096 - 1) / 4096
 * g = (signature_size + 4096 - 1) / 4096
 *
 * Page size is fixed at 4096 bytes.
 *
 * The structure of the vendor boot image is as follows:
 *
 * +------------------------+
 * | vendor boot header     | o pages
 * +------------------------+
 * | vendor ramdisk section | p pages
 * +------------------------+
 * | dtb                    | q pages
 * +------------------------+
 * | vendor ramdisk table   | r pages
 * +------------------------+
 * | bootconfig             | s pages
 * +------------------------+
 *
 * o = (2128 + page_size - 1) / page_size
 * p = (vendor_ramdisk_size + page_size - 1) / page_size
 * q = (dtb_size + page_size - 1) / page_size
 * r = (vendor_ramdisk_table_size + page_size - 1) / page_size
 * s = (vendor_bootconfig_size + page_size - 1) / page_size
 *
 * Note that in version 4 of the vendor boot image, multiple vendor ramdisks can
 * be included in the vendor boot image. The bootloader can select a subset of
 * ramdisks to load at runtime. To help the bootloader select the ramdisks, each
 * ramdisk is tagged with a type tag and a set of hardware identifiers
 * describing the board, soc or platform that this ramdisk is intended for.
 *
 * The vendor ramdisk section is consist of multiple ramdisk images concatenated
 * one after another, and vendor_ramdisk_size is the size of the section, which
 * is the total size of all the ramdisks included in the vendor boot image.
 *
 * The vendor ramdisk table holds the size, offset, type, name and hardware
 * identifiers of each ramdisk. The type field denotes the type of its content.
 * The vendor ramdisk names are unique. The hardware identifiers are specified
 * in the board_id field in each table entry. The board_id field is consist of a
 * vector of unsigned integer words, and the encoding scheme is defined by the
 * hardware vendor.
 *
 * For the different type of ramdisks, there are:
 *    - VENDOR_RAMDISK_TYPE_NONE indicates the value is unspecified.
 *    - VENDOR_RAMDISK_TYPE_PLATFORM ramdisks contain platform specific bits, so
 *      the bootloader should always load these into memory.
 *    - VENDOR_RAMDISK_TYPE_RECOVERY ramdisks contain recovery resources, so
 *      the bootloader should load these when booting into recovery.
 *    - VENDOR_RAMDISK_TYPE_DLKM ramdisks contain dynamic loadable kernel
 *      modules.
 *
 * Version 4 of the vendor boot image also adds a bootconfig section to the end
 * of the image. This section contains Boot Configuration parameters known at
 * build time. The bootloader is responsible for placing this section directly
 * after the generic ramdisk, followed by the bootconfig trailer, before
 * entering the kernel.
 */

struct boot_img_hdr_v3 {
    uint8_t magic[BOOT_MAGIC_SIZE];

    uint32_t kernel_size;  /* size in bytes */
    uint32_t ramdisk_size; /* size in bytes */
    uint32_t os_version;
    uint32_t header_size;
    uint32_t reserved[4];

    uint32_t header_version;

    char cmdline[BOOT_ARGS_SIZE + BOOT_EXTRA_ARGS_SIZE];
} __attribute__((packed));

struct boot_img_hdr_vnd_v3 {
    // Must be VENDOR_BOOT_MAGIC.
    uint8_t magic[BOOT_MAGIC_SIZE];
    // Version of the vendor boot image header.
    uint32_t header_version;
    uint32_t page_size;     /* flash page size we assume */
    uint32_t kernel_addr;   /* physical load addr */
    uint32_t ramdisk_addr;  /* physical load addr */
    uint32_t ramdisk_size;  /* size in bytes */
    char cmdline[VENDOR_BOOT_ARGS_SIZE];
    uint32_t tags_addr;     /* physical addr for kernel tags (if required) */
    char name[BOOT_NAME_SIZE]; /* asciiz product name */
    uint32_t header_size;
    uint32_t dtb_size;      /* size in bytes for DTB image */
    uint64_t dtb_addr;      /* physical load address for DTB image */
} __attribute__((packed));

struct boot_img_hdr_v4 : public boot_img_hdr_v3 {
    uint32_t signature_size; /* size in bytes */
} __attribute__((packed));

struct boot_img_hdr_vnd_v4 : public boot_img_hdr_vnd_v3 {
    uint32_t vendor_ramdisk_table_size;       /* size in bytes for the vendor ramdisk table */
    uint32_t vendor_ramdisk_table_entry_num;  /* number of entries in the vendor ramdisk table */
    uint32_t vendor_ramdisk_table_entry_size; /* size in bytes for a vendor ramdisk table entry */
    uint32_t bootconfig_size; /* size in bytes for the bootconfig section */
} __attribute__((packed));

struct vendor_ramdisk_table_entry_v4 {
    uint32_t ramdisk_size;   /* size in bytes for the ramdisk image */
    uint32_t ramdisk_offset; /* offset to the ramdisk image in vendor ramdisk section */
    uint32_t ramdisk_type;   /* type of the ramdisk */
    char ramdisk_name[VENDOR_RAMDISK_NAME_SIZE]; /* asciiz ramdisk name */

    // Hardware identifiers describing the board, soc or platform which this
    // ramdisk is intended to be loaded on.
    uint32_t board_id[VENDOR_RAMDISK_TABLE_ENTRY_BOARD_ID_SIZE];
} __attribute__((packed));

/*******************************
 * Polymorphic Universal Header
 *******************************/

template <typename T>
static T align_to(T v, int a) {
    static_assert(std::is_integral_v<T>);
    return (v + a - 1) / a * a;
}

template <typename T>
static T align_padding(T v, int a) {
    return align_to(v, a) - v;
}

#define decl_val(name, len) \
virtual uint##len##_t name() const { return 0; }

#define decl_var(name, len) \
virtual uint##len##_t &name() { return j##len(); } \
decl_val(name, len)

#define decl_str(name) \
virtual char *name() { return nullptr; } \
virtual const char *name() const { return nullptr; }

struct dyn_img_hdr {

    virtual bool is_vendor() const = 0;

    // Standard entries
    decl_var(kernel_size, 32)
    decl_var(ramdisk_size, 32)
    decl_var(second_size, 32)
    decl_val(page_size, 32)
    decl_val(header_version, 32)
    decl_var(extra_size, 32)
    decl_var(os_version, 32)
    decl_str(name)
    decl_str(cmdline)
    decl_str(id)
    decl_str(extra_cmdline)

    // v1/v2 specific
    decl_var(recovery_dtbo_size, 32)
    decl_var(recovery_dtbo_offset, 64)
    decl_var(header_size, 32)
    decl_var(dtb_size, 32)

    // v4 specific
    decl_val(signature_size, 32)

    // v4 vendor specific
    decl_val(vendor_ramdisk_table_size, 32)
    decl_val(vendor_ramdisk_table_entry_num, 32)
    decl_val(vendor_ramdisk_table_entry_size, 32)
    decl_var(bootconfig_size, 32)

    virtual ~dyn_img_hdr() {
        free(raw);
    }

    virtual size_t hdr_size() const = 0;
    virtual size_t hdr_space() const { return page_size(); }
    virtual dyn_img_hdr *clone() const = 0;

    const void *raw_hdr() const { return raw; }
    void print() const;
    void dump_hdr_file() const;
    void load_hdr_file();

protected:
    union {
        boot_img_hdr_v2 *v2_hdr;     /* AOSP v2 header */
        boot_img_hdr_v4 *v4_hdr;     /* AOSP v4 header */
        boot_img_hdr_vnd_v4 *v4_vnd; /* AOSP vendor v4 header */
        boot_img_hdr_pxa *hdr_pxa;   /* Samsung PXA header */
        void *raw;                   /* Raw pointer */
    };

    static uint32_t &j32() { _j32 = 0; return _j32; }
    static uint64_t &j64() { _j64 = 0; return _j64; }

private:
    // Junk for references
    inline static uint32_t _j32 = 0;
    inline static uint64_t _j64 = 0;
};

#undef decl_var
#undef decl_val
#undef decl_str

#define __impl_cls(name, hdr)           \
protected: name() = default;            \
public:                                 \
explicit                                \
name(const void *p, ssize_t sz = -1) {  \
    if (sz < 0) sz = sizeof(hdr);       \
    raw = calloc(sizeof(hdr), 1);       \
    memcpy(raw, p, sz);                 \
}                                       \
size_t hdr_size() const override {      \
    return sizeof(hdr);                 \
}                                       \
dyn_img_hdr *clone() const override {   \
    auto p = new name(raw);             \
    return p;                           \
};

#define __impl_val(name, hdr_name) \
decltype(std::declval<const dyn_img_hdr>().name()) name() const override { return hdr_name->name; }

#define __impl_var(name, hdr_name) \
decltype(std::declval<dyn_img_hdr>().name()) name() override { return hdr_name->name; } \
__impl_val(name, hdr_name)

#define impl_cls(ver)  __impl_cls(dyn_img_##ver, boot_img_hdr_##ver)
#define impl_val(name) __impl_val(name, v2_hdr)
#define impl_var(name) __impl_var(name, v2_hdr)

struct dyn_img_hdr_boot : public dyn_img_hdr {
    bool is_vendor() const final { return false; }
};

struct dyn_img_common : public dyn_img_hdr_boot {
    impl_var(kernel_size)
    impl_var(ramdisk_size)
    impl_var(second_size)
};

struct dyn_img_v0 : public dyn_img_common {
    impl_cls(v0)

    impl_val(page_size)
    impl_var(extra_size)
    impl_var(os_version)
    impl_var(name)
    impl_var(cmdline)
    impl_var(id)
    impl_var(extra_cmdline)
};

struct dyn_img_v1 : public dyn_img_v0 {
    impl_cls(v1)

    impl_val(header_version)
    impl_var(recovery_dtbo_size)
    impl_var(recovery_dtbo_offset)
    impl_var(header_size)

    uint32_t &extra_size() override { return j32(); }
    uint32_t extra_size() const override { return 0; }
};

struct dyn_img_v2 : public dyn_img_v1 {
    impl_cls(v2)

    impl_var(dtb_size)
};

#undef impl_val
#undef impl_var
#define impl_val(name) __impl_val(name, hdr_pxa)
#define impl_var(name) __impl_var(name, hdr_pxa)

struct dyn_img_pxa : public dyn_img_common {
    impl_cls(pxa)

    impl_var(extra_size)
    impl_val(page_size)
    impl_var(name)
    impl_var(cmdline)
    impl_var(id)
    impl_var(extra_cmdline)
};

#undef impl_val
#undef impl_var
#define impl_val(name) __impl_val(name, v4_hdr)
#define impl_var(name) __impl_var(name, v4_hdr)

struct dyn_img_v3 : public dyn_img_hdr_boot {
    impl_cls(v3)

    impl_var(kernel_size)
    impl_var(ramdisk_size)
    impl_var(os_version)
    impl_var(header_size)
    impl_val(header_version)
    impl_var(cmdline)

    // Make API compatible
    uint32_t page_size() const override { return 4096; }
    char *extra_cmdline() override { return &v4_hdr->cmdline[BOOT_ARGS_SIZE]; }
    const char *extra_cmdline() const override { return &v4_hdr->cmdline[BOOT_ARGS_SIZE]; }
};

struct dyn_img_v4 : public dyn_img_v3 {
    impl_cls(v4)

    impl_val(signature_size)
};

struct dyn_img_hdr_vendor : public dyn_img_hdr {
    bool is_vendor() const final { return true; }
};

#undef impl_val
#undef impl_var
#define impl_val(name) __impl_val(name, v4_vnd)
#define impl_var(name) __impl_var(name, v4_vnd)

struct dyn_img_vnd_v3 : public dyn_img_hdr_vendor {
    impl_cls(vnd_v3)

    impl_val(header_version)
    impl_val(page_size)
    impl_var(ramdisk_size)
    impl_var(cmdline)
    impl_var(name)
    impl_var(header_size)
    impl_var(dtb_size)

    size_t hdr_space() const override { return align_to(hdr_size(), page_size()); }

    // Make API compatible
    char *extra_cmdline() override { return &v4_vnd->cmdline[BOOT_ARGS_SIZE]; }
    const char *extra_cmdline() const override { return &v4_vnd->cmdline[BOOT_ARGS_SIZE]; }
};

struct dyn_img_vnd_v4 : public dyn_img_vnd_v3 {
    impl_cls(vnd_v4)

    impl_val(vendor_ramdisk_table_size)
    impl_val(vendor_ramdisk_table_entry_num)
    impl_val(vendor_ramdisk_table_entry_size)
    impl_var(bootconfig_size)
};

#undef __impl_cls
#undef __impl_val
#undef __impl_var
#undef impl_cls
#undef impl_val
#undef impl_var

/******************
 * Full Boot Image
 ******************/

enum {
    MTK_KERNEL,
    MTK_RAMDISK,
    CHROMEOS_FLAG,
    DHTB_FLAG,
    SEANDROID_FLAG,
    LG_BUMP_FLAG,
    SHA256_FLAG,
    BLOB_FLAG,
    NOOKHD_FLAG,
    ACCLAIM_FLAG,
    AMONET_FLAG,
    AVB1_SIGNED_FLAG,
    AVB_FLAG,
    ZIMAGE_KERNEL,
    BOOT_FLAGS_MAX
};

struct boot_img {
    // Memory map of the whole image
    const mmap_data map;

    // Android image header
    dyn_img_hdr *hdr = nullptr;

    // Flags to indicate the state of current boot image
    std::bitset<BOOT_FLAGS_MAX> flags;

    // The format of kernel, ramdisk and extra
    FileFormat k_fmt;
    FileFormat r_fmt;
    FileFormat e_fmt;

    /*************************************************************
     * Following pointers points within the read-only mmap region
     *************************************************************/

    // Layout of the memory mapped region
    // +---------+
    // | head    | Vendor specific. Should not exist for standard AOSP boot images.
    // +---------+
    // | payload | The actual entire AOSP boot image, including the boot image header.
    // +---------+
    // | tail    | Data after payload. Usually contains signature/AVB information.
    // +---------+

    byte_view payload;
    byte_view tail;

    // MTK headers
    const mtk_hdr *k_hdr = nullptr;
    const mtk_hdr *r_hdr = nullptr;

    // The pointers/values after parse_image
    // +---------------+
    // | z_info.hdr    | z_info.hdr_sz
    // +---------------+
    // | kernel        | hdr->kernel_size()
    // +---------------+
    // | z_info.tail   |
    // +---------------+
    struct {
        const zimage_hdr *hdr = nullptr;
        uint32_t hdr_sz = 0;
        byte_view tail{};
    } z_info;

    // AVB structs
    const AvbFooter *avb_footer = nullptr;
    const AvbVBMetaImageHeader *vbmeta = nullptr;

    // Pointers to blocks defined in header
    const uint8_t *kernel = nullptr;
    const uint8_t *ramdisk = nullptr;
    const uint8_t *second = nullptr;
    const uint8_t *extra = nullptr;
    const uint8_t *recovery_dtbo = nullptr;
    const uint8_t *dtb = nullptr;
    const uint8_t *signature = nullptr;
    const uint8_t *vendor_ramdisk_table = nullptr;
    const uint8_t *bootconfig = nullptr;

    // dtb embedded in kernel
    byte_view kernel_dtb;

    explicit boot_img(const char *);
    ~boot_img();

    bool parse_image(const uint8_t *addr, FileFormat type);
    void parse_zimage();
    const uint8_t *parse_hdr(const uint8_t *addr, FileFormat type);
    std::span<const vendor_ramdisk_table_entry_v4> vendor_ramdisk_tbl() const;

    // Rust FFI
    static std::unique_ptr<boot_img> create(Utf8CStr name) { return std::make_unique<boot_img>(name.c_str()); }
    rust::Slice<const uint8_t> get_payload() const { return payload; }
    rust::Slice<const uint8_t> get_tail() const { return tail; }
    bool is_signed() const { return flags[AVB1_SIGNED_FLAG]; }
    uint64_t tail_off() const { return tail.data() - map.data(); }

    // Implemented in Rust
    bool verify() const noexcept;
};

```

`native/src/boot/build.rs`:

```rs
use pb_rs::ConfigBuilder;
use pb_rs::types::FileDescriptor;

use crate::codegen::gen_cxx_binding;

#[path = "../include/codegen.rs"]
mod codegen;

#[allow(clippy::unwrap_used)]
fn main() {
    println!("cargo:rerun-if-changed=proto/update_metadata.proto");

    gen_cxx_binding("boot-rs");

    let cb = ConfigBuilder::new(
        &["proto/update_metadata.proto"],
        None,
        Some(&"proto"),
        &["."],
    )
    .unwrap();
    FileDescriptor::run(
        &cb.single_module(true)
            .dont_use_cow(true)
            .generate_getters(true)
            .build(),
    )
    .unwrap();
}

```

`native/src/boot/cli.rs`:

```rs
use crate::compress::{compress_cmd, decompress_cmd};
use crate::cpio::{cpio_commands, print_cpio_usage};
use crate::dtb::{DtbAction, dtb_commands, print_dtb_usage};
use crate::ffi::{BootImage, FileFormat, cleanup, repack, split_image_dtb, unpack};
use crate::patch::hexpatch;
use crate::payload::extract_boot_from_payload;
use crate::sign::{sha1_hash, sign_boot_image};
use argh::{CommandInfo, EarlyExit, FromArgs, SubCommand};
use base::libc::umask;
use base::nix::fcntl::OFlag;
use base::{
    CmdArgs, EarlyExitExt, LoggedResult, MappedFile, PositionalArgParser, ResultExt, Utf8CStr,
    Utf8CString, WriteExt, argh, cmdline_logging, cstr, log_err,
};
use std::ffi::c_char;
use std::io::{Seek, SeekFrom, Write};
use std::str::FromStr;

#[derive(FromArgs)]
struct Cli {
    #[argh(subcommand)]
    action: Action,
}

#[derive(FromArgs)]
#[argh(subcommand)]
enum Action {
    Unpack(Unpack),
    Repack(Repack),
    Verify(Verify),
    Sign(Sign),
    Extract(Extract),
    HexPatch(HexPatch),
    Cpio(Cpio),
    Dtb(Dtb),
    Split(Split),
    Sha1(Sha1),
    Cleanup(Cleanup),
    Compress(Compress),
    Decompress(Decompress),
}

#[derive(FromArgs)]
#[argh(subcommand, name = "unpack")]
struct Unpack {
    #[argh(switch, short = 'n', long = none)]
    no_decompress: bool,
    #[argh(switch, short = 'h', long = none)]
    dump_header: bool,
    #[argh(positional)]
    img: Utf8CString,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "repack")]
struct Repack {
    #[argh(switch, short = 'n', long = none)]
    no_compress: bool,
    #[argh(positional)]
    img: Utf8CString,
    #[argh(positional)]
    out: Option<Utf8CString>,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "verify")]
struct Verify {
    #[argh(positional)]
    img: Utf8CString,
    #[argh(positional)]
    cert: Option<Utf8CString>,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "sign")]
struct Sign {
    #[argh(positional)]
    img: Utf8CString,
    #[argh(positional)]
    name: Option<Utf8CString>,
    #[argh(positional)]
    cert: Option<Utf8CString>,
    #[argh(positional)]
    key: Option<Utf8CString>,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "extract")]
struct Extract {
    #[argh(positional)]
    payload: Utf8CString,
    #[argh(positional)]
    partition: Option<Utf8CString>,
    #[argh(positional)]
    outfile: Option<Utf8CString>,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "hexpatch")]
struct HexPatch {
    #[argh(positional)]
    file: Utf8CString,
    #[argh(positional)]
    src: Utf8CString,
    #[argh(positional)]
    dest: Utf8CString,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "cpio")]
struct Cpio {
    #[argh(positional)]
    file: Utf8CString,
    #[argh(positional)]
    cmds: Vec<String>,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "dtb")]
struct Dtb {
    #[argh(positional)]
    file: Utf8CString,
    #[argh(subcommand)]
    action: DtbAction,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "split")]
struct Split {
    #[argh(switch, short = 'n', long = none)]
    no_decompress: bool,
    #[argh(positional)]
    file: Utf8CString,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "sha1")]
struct Sha1 {
    #[argh(positional)]
    file: Utf8CString,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "cleanup")]
struct Cleanup {}

struct Compress {
    format: FileFormat,
    file: Utf8CString,
    out: Option<Utf8CString>,
}

impl FromArgs for Compress {
    fn from_args(command_name: &[&str], args: &[&str]) -> Result<Self, EarlyExit> {
        let cmd = command_name.last().copied().unwrap_or_default();
        let fmt = cmd.strip_prefix("compress=").unwrap_or("gzip");

        let Ok(fmt) = FileFormat::from_str(fmt) else {
            return Err(EarlyExit::from(format!(
                "Unsupported or unknown compression format: {fmt}\n"
            )));
        };

        let mut iter = PositionalArgParser(args.iter());
        Ok(Compress {
            format: fmt,
            file: iter.required("infile")?,
            out: iter.last_optional()?,
        })
    }
}

impl SubCommand for Compress {
    const COMMAND: &'static CommandInfo = &CommandInfo {
        name: "compress",
        description: "",
    };
}

#[derive(FromArgs)]
#[argh(subcommand, name = "decompress")]
struct Decompress {
    #[argh(positional)]
    file: Utf8CString,
    #[argh(positional)]
    out: Option<Utf8CString>,
}

fn print_usage(cmd: &str) {
    eprintln!(
        r#"MagiskBoot - Boot Image Modification Tool

Usage: {0} <action> [args...]

Supported actions:
  unpack [-n] [-h] <bootimg>
    Unpack <bootimg> to its individual components, each component to
    a file with its corresponding file name in the current directory.
    Supported components: kernel, kernel_dtb, ramdisk.cpio, second,
    dtb, extra, and recovery_dtbo.
    By default, each component will be decompressed on-the-fly.
    If '-n' is provided, all decompression operations will be skipped;
    each component will remain untouched, dumped in its original format.
    If '-h' is provided, the boot image header information will be
    dumped to the file 'header', which can be used to modify header
    configurations during repacking.
    Return values:
    0:valid    1:error    2:chromeos    3:vendor_boot

  repack [-n] <origbootimg> [outbootimg]
    Repack boot image components using files from the current directory
    to [outbootimg], or 'new-boot.img' if not specified. Current directory
    should only contain required files for [outbootimg], or incorrect
    [outbootimg] may be produced.
    <origbootimg> is the original boot image used to unpack the components.
    By default, each component will be automatically compressed using its
    corresponding format detected in <origbootimg>. If a component file
    in the current directory is already compressed, then no addition
    compression will be performed for that specific component.
    If '-n' is provided, all compression operations will be skipped.
    If env variable PATCHVBMETAFLAG is set to true, all disable flags in
    the boot image's vbmeta header will be set.

  verify <bootimg> [x509.pem]
    Check whether the boot image is signed with AVB 1.0 signature.
    Optionally provide a certificate to verify whether the image is
    signed by the public key certificate.
    Return value:
    0:valid    1:error

  sign <bootimg> [name] [x509.pem pk8]
    Sign <bootimg> with AVB 1.0 signature.
    Optionally provide the name of the image (default: '/boot').
    Optionally provide the certificate/private key pair for signing.
    If the certificate/private key pair is not provided, the AOSP
    verity key bundled in the executable will be used.

  extract <payload.bin> [partition] [outfile]
    Extract [partition] from <payload.bin> to [outfile].
    If [outfile] is not specified, then output to '[partition].img'.
    If [partition] is not specified, then attempt to extract either
    'init_boot' or 'boot'. Which partition was chosen can be determined
    by whichever 'init_boot.img' or 'boot.img' exists.
    <payload.bin> can be '-' to be STDIN.

  hexpatch <file> <hexpattern1> <hexpattern2>
    Search <hexpattern1> in <file>, and replace it with <hexpattern2>

  cpio <incpio> [commands...]
    Do cpio commands to <incpio> (modifications are done in-place).
    Each command is a single argument; add quotes for each command.
    See "cpio --help" for supported commands.

  dtb <file> <action> [args...]
    Do dtb related actions to <file>.
    See "dtb --help" for supported actions.

  split [-n] <file>
    Split image.*-dtb into kernel + kernel_dtb.
    If '-n' is provided, decompression operations will be skipped;
    the kernel will remain untouched, split in its original format.

  sha1 <file>
    Print the SHA1 checksum for <file>

  cleanup
    Cleanup the current working directory

  compress[=format] <infile> [outfile]
    Compress <infile> with [format] to [outfile].
    <infile>/[outfile] can be '-' to be STDIN/STDOUT.
    If [format] is not specified, then gzip will be used.
    If [outfile] is not specified, then <infile> will be replaced
    with another file suffixed with a matching file extension.
    Supported formats:
    {1}

  decompress <infile> [outfile]
    Detect format and decompress <infile> to [outfile].
    <infile>/[outfile] can be '-' to be STDIN/STDOUT.
    If [outfile] is not specified, then <infile> will be replaced
    with another file removing its archive format file extension.
    Supported formats:
    {1}
"#,
        cmd,
        FileFormat::formats()
    );
}

fn verify_cmd(image: &Utf8CStr, cert: Option<&Utf8CStr>) -> bool {
    let image = BootImage::new(image);
    match cert {
        None => {
            // Boot image parsing already checks if the image is signed
            image.is_signed()
        }
        Some(_) => {
            // Provide a custom certificate and re-verify
            image.verify(cert).is_ok()
        }
    }
}

fn sign_cmd(
    image: &Utf8CStr,
    name: Option<&Utf8CStr>,
    cert: Option<&Utf8CStr>,
    key: Option<&Utf8CStr>,
) -> LoggedResult<()> {
    let img = BootImage::new(image);
    let name = name.unwrap_or(cstr!("/boot"));
    let sig = sign_boot_image(img.payload(), name, cert, key)?;
    let tail_off = img.tail_off();
    drop(img);
    let mut fd = image.open(OFlag::O_WRONLY | OFlag::O_CLOEXEC)?;
    fd.seek(SeekFrom::Start(tail_off))?;
    fd.write_all(&sig)?;
    let current = fd.stream_position()?;
    let eof = fd.seek(SeekFrom::End(0))?;
    if eof > current {
        // Zero out rest of the file
        fd.seek(SeekFrom::Start(current))?;
        fd.write_zeros((eof - current) as usize)?;
    }
    Ok(())
}

fn boot_main(cmds: CmdArgs) -> LoggedResult<i32> {
    let mut cmds = cmds.0;
    if cmds.len() < 2 {
        print_usage(cmds.first().unwrap_or(&"magiskboot"));
        return log_err!();
    }

    if cmds[1].starts_with("--") {
        cmds[1] = &cmds[1][2..];
    }

    let cli = if cmds[1].starts_with("compress=") {
        // Skip the main parser, directly parse the subcommand
        Compress::from_args(&cmds[..2], &cmds[2..]).map(|compress| Cli {
            action: Action::Compress(compress),
        })
    } else {
        Cli::from_args(&[cmds[0]], &cmds[1..])
    }
    .on_early_exit(|| match cmds[1] {
        "dtb" => print_dtb_usage(),
        "cpio" => print_cpio_usage(),
        _ => print_usage(cmds[0]),
    });

    match cli.action {
        Action::Unpack(Unpack {
            no_decompress,
            dump_header,
            img,
        }) => {
            return Ok(unpack(&img, no_decompress, dump_header));
        }
        Action::Repack(Repack {
            no_compress,
            img,
            out,
        }) => {
            repack(
                &img,
                out.as_deref().unwrap_or(cstr!("new-boot.img")),
                no_compress,
            );
        }
        Action::Verify(Verify { img, cert }) => {
            if !verify_cmd(&img, cert.as_deref()) {
                return log_err!();
            }
        }
        Action::Sign(Sign {
            img,
            name,
            cert,
            key,
        }) => {
            sign_cmd(&img, name.as_deref(), cert.as_deref(), key.as_deref())?;
        }
        Action::Extract(Extract {
            payload,
            partition,
            outfile,
        }) => {
            extract_boot_from_payload(
                &payload,
                partition.as_ref().map(AsRef::as_ref),
                outfile.as_ref().map(AsRef::as_ref),
            )
            .log_with_msg(|w| w.write_str("Failed to extract from payload"))?;
        }
        Action::HexPatch(HexPatch { file, src, dest }) => {
            if !hexpatch(&file, &src, &dest) {
                log_err!("Failed to patch")?;
            }
        }
        Action::Cpio(Cpio { file, cmds }) => {
            cpio_commands(&file, &cmds).log_with_msg(|w| w.write_str("Failed to process cpio"))?;
        }
        Action::Dtb(Dtb { file, action }) => {
            return dtb_commands(&file, &action)
                .map(|b| if b { 0 } else { 1 })
                .log_with_msg(|w| w.write_str("Failed to process dtb"));
        }
        Action::Split(Split {
            no_decompress,
            file,
        }) => {
            return Ok(split_image_dtb(&file, no_decompress));
        }
        Action::Sha1(Sha1 { file }) => {
            let file = MappedFile::open(&file)?;
            let mut sha1 = [0u8; 20];
            sha1_hash(file.as_ref(), &mut sha1);
            for byte in &sha1 {
                print!("{byte:02x}");
            }
            println!();
        }
        Action::Cleanup(_) => {
            eprintln!("Cleaning up...");
            cleanup();
        }
        Action::Decompress(Decompress { file, out }) => {
            decompress_cmd(&file, out.as_deref())?;
        }
        Action::Compress(Compress { format, file, out }) => {
            compress_cmd(format, &file, out.as_deref())?;
        }
    }
    Ok(0)
}

#[unsafe(no_mangle)]
pub extern "C" fn main(argc: i32, argv: *const *const c_char, _envp: *const *const c_char) -> i32 {
    cmdline_logging();
    unsafe { umask(0) };
    let cmds = CmdArgs::new(argc, argv);
    boot_main(cmds).unwrap_or(1)
}

```

`native/src/boot/compress.rs`:

```rs
use crate::ffi::{FileFormat, check_fmt};
use base::nix::fcntl::OFlag;
use base::{Chunker, FileOrStd, LoggedResult, ReadExt, Utf8CStr, Utf8CString, WriteExt, log_err};
use bzip2::Compression as BzCompression;
use bzip2::read::BzDecoder;
use bzip2::write::BzEncoder;
use flate2::Compression as GzCompression;
use flate2::read::MultiGzDecoder;
use flate2::write::GzEncoder;
use lz4::block::CompressionMode;
use lz4::liblz4::BlockChecksum;
use lz4::{
    BlockMode, BlockSize, ContentChecksum, Decoder as LZ4FrameDecoder, Encoder as LZ4FrameEncoder,
    EncoderBuilder as LZ4FrameEncoderBuilder,
};
use lzma_rust2::{CheckType, LzmaOptions, LzmaReader, LzmaWriter, XzOptions, XzReader, XzWriter};
use std::cmp::min;
use std::fmt::Write as FmtWrite;
use std::fs::File;
use std::io::{BufWriter, Cursor, Read, Write};
use std::mem::ManuallyDrop;
use std::num::NonZeroU64;
use std::ops::DerefMut;
use std::os::fd::{FromRawFd, RawFd};
use zopfli::{BlockType, GzipEncoder as ZopFliEncoder, Options as ZopfliOptions};

pub trait WriteFinish<W: Write>: Write {
    fn finish(self: Box<Self>) -> std::io::Result<W>;
}

// Boilerplate for existing types

macro_rules! finish_impl {
    ($($t:ty),*) => {$(
        impl<W: Write> WriteFinish<W> for $t {
            fn finish(self: Box<Self>) -> std::io::Result<W> {
                Self::finish(*self)
            }
        }
    )*}
}

finish_impl!(GzEncoder<W>, BzEncoder<W>, XzWriter<W>, LzmaWriter<W>);

impl<W: Write> WriteFinish<W> for BufWriter<ZopFliEncoder<W>> {
    fn finish(self: Box<Self>) -> std::io::Result<W> {
        let inner = self.into_inner()?;
        ZopFliEncoder::finish(inner)
    }
}

impl<W: Write> WriteFinish<W> for LZ4FrameEncoder<W> {
    fn finish(self: Box<Self>) -> std::io::Result<W> {
        let (w, r) = Self::finish(*self);
        r?;
        Ok(w)
    }
}

// LZ4BlockArchive format
//
// len:  |   4   |          4            |           n           | ... |           4             |
// data: | magic | compressed block size | compressed block data | ... | total uncompressed size |

// LZ4BlockEncoder

const LZ4_BLOCK_SIZE: usize = 0x800000;
const LZ4HC_CLEVEL_MAX: i32 = 12;
const LZ4_MAGIC: u32 = 0x184c2102;

struct LZ4BlockEncoder<W: Write> {
    write: W,
    chunker: Chunker,
    out_buf: Box<[u8]>,
    total: u32,
    is_lg: bool,
}

impl<W: Write> LZ4BlockEncoder<W> {
    fn new(write: W, is_lg: bool) -> Self {
        let out_sz = lz4::block::compress_bound(LZ4_BLOCK_SIZE).unwrap_or(LZ4_BLOCK_SIZE);
        LZ4BlockEncoder {
            write,
            chunker: Chunker::new(LZ4_BLOCK_SIZE),
            // SAFETY: all bytes will be initialized before it is used
            out_buf: unsafe { Box::new_uninit_slice(out_sz).assume_init() },
            total: 0,
            is_lg,
        }
    }

    fn encode_block(write: &mut W, out_buf: &mut [u8], chunk: &[u8]) -> std::io::Result<()> {
        let compressed_size = lz4::block::compress_to_buffer(
            chunk,
            Some(CompressionMode::HIGHCOMPRESSION(LZ4HC_CLEVEL_MAX)),
            false,
            out_buf,
        )?;
        let block_size = compressed_size as u32;
        write.write_pod(&block_size)?;
        write.write_all(&out_buf[..compressed_size])
    }
}

impl<W: Write> Write for LZ4BlockEncoder<W> {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        self.write_all(buf)?;
        Ok(buf.len())
    }

    fn flush(&mut self) -> std::io::Result<()> {
        Ok(())
    }

    fn write_all(&mut self, mut buf: &[u8]) -> std::io::Result<()> {
        if self.total == 0 {
            // Write header
            self.write.write_pod(&LZ4_MAGIC)?;
        }

        self.total += buf.len() as u32;
        while !buf.is_empty() {
            let (b, chunk) = self.chunker.add_data(buf);
            buf = b;
            if let Some(chunk) = chunk {
                Self::encode_block(&mut self.write, &mut self.out_buf, chunk)?;
            }
        }
        Ok(())
    }
}

impl<W: Write> WriteFinish<W> for LZ4BlockEncoder<W> {
    fn finish(mut self: Box<Self>) -> std::io::Result<W> {
        let chunk = self.chunker.get_available();
        if !chunk.is_empty() {
            Self::encode_block(&mut self.write, &mut self.out_buf, chunk)?;
        }
        if self.is_lg {
            self.write.write_pod(&self.total)?;
        }
        Ok(self.write)
    }
}

// LZ4BlockDecoder

struct LZ4BlockDecoder<R: Read> {
    read: R,
    in_buf: Box<[u8]>,
    out_buf: Box<[u8]>,
    out_len: usize,
    out_pos: usize,
}

impl<R: Read> LZ4BlockDecoder<R> {
    fn new(read: R) -> Self {
        let compressed_sz = lz4::block::compress_bound(LZ4_BLOCK_SIZE).unwrap_or(LZ4_BLOCK_SIZE);
        Self {
            read,
            in_buf: unsafe { Box::new_uninit_slice(compressed_sz).assume_init() },
            out_buf: unsafe { Box::new_uninit_slice(LZ4_BLOCK_SIZE).assume_init() },
            out_len: 0,
            out_pos: 0,
        }
    }
}

impl<R: Read> Read for LZ4BlockDecoder<R> {
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        if self.out_pos == self.out_len {
            let mut block_size: u32 = 0;
            if let Err(e) = self.read.read_pod(&mut block_size) {
                return if e.kind() == std::io::ErrorKind::UnexpectedEof {
                    Ok(0)
                } else {
                    Err(e)
                };
            }
            if block_size == LZ4_MAGIC {
                self.read.read_pod(&mut block_size)?;
            }

            let block_size = block_size as usize;

            if block_size > self.in_buf.len() {
                // This may be the LG format trailer, EOF
                return Ok(0);
            }

            // Read the entire compressed block
            let compressed_block = &mut self.in_buf[..block_size];
            if let Ok(len) = self.read.read(compressed_block) {
                if len == 0 {
                    // We hit EOF, that's fine
                    return Ok(0);
                } else if len != block_size {
                    let remain = &mut compressed_block[len..];
                    self.read.read_exact(remain)?;
                }
            }

            self.out_len = lz4::block::decompress_to_buffer(
                compressed_block,
                Some(LZ4_BLOCK_SIZE as i32),
                &mut self.out_buf,
            )?;
            self.out_pos = 0;
        }
        let copy_len = min(buf.len(), self.out_len - self.out_pos);
        buf[..copy_len].copy_from_slice(&self.out_buf[self.out_pos..self.out_pos + copy_len]);
        self.out_pos += copy_len;
        Ok(copy_len)
    }
}

// Top-level APIs

pub fn get_encoder<'a, W: Write + 'a>(
    format: FileFormat,
    w: W,
) -> std::io::Result<Box<dyn WriteFinish<W> + 'a>> {
    Ok(match format {
        FileFormat::XZ => {
            let mut opt = XzOptions::with_preset(9);
            opt.set_check_sum_type(CheckType::Crc32);
            Box::new(XzWriter::new(w, opt)?)
        }
        FileFormat::LZMA => Box::new(LzmaWriter::new_use_header(
            w,
            &LzmaOptions::with_preset(9),
            None,
        )?),
        FileFormat::BZIP2 => Box::new(BzEncoder::new(w, BzCompression::best())),
        FileFormat::LZ4 => {
            let encoder = LZ4FrameEncoderBuilder::new()
                .block_size(BlockSize::Max4MB)
                .block_mode(BlockMode::Independent)
                .checksum(ContentChecksum::ChecksumEnabled)
                .block_checksum(BlockChecksum::BlockChecksumEnabled)
                .level(9)
                .auto_flush(true)
                .build(w)?;
            Box::new(encoder)
        }
        FileFormat::LZ4_LEGACY => Box::new(LZ4BlockEncoder::new(w, false)),
        FileFormat::LZ4_LG => Box::new(LZ4BlockEncoder::new(w, true)),
        FileFormat::ZOPFLI => {
            // These options are already better than gzip -9
            let opt = ZopfliOptions {
                iteration_count: unsafe { NonZeroU64::new_unchecked(1) },
                maximum_block_splits: 1,
                ..Default::default()
            };
            Box::new(ZopFliEncoder::new_buffered(opt, BlockType::Dynamic, w)?)
        }
        FileFormat::GZIP => Box::new(GzEncoder::new(w, GzCompression::best())),
        _ => unreachable!(),
    })
}

pub fn get_decoder<'a, R: Read + 'a>(
    format: FileFormat,
    r: R,
) -> std::io::Result<Box<dyn Read + 'a>> {
    Ok(match format {
        FileFormat::XZ => Box::new(XzReader::new(r, true)),
        FileFormat::LZMA => Box::new(LzmaReader::new_mem_limit(r, u32::MAX, None)?),
        FileFormat::BZIP2 => Box::new(BzDecoder::new(r)),
        FileFormat::LZ4 => Box::new(LZ4FrameDecoder::new(r)?),
        FileFormat::LZ4_LG | FileFormat::LZ4_LEGACY => Box::new(LZ4BlockDecoder::new(r)),
        FileFormat::ZOPFLI | FileFormat::GZIP => Box::new(MultiGzDecoder::new(r)),
        _ => unreachable!(),
    })
}

// C++ FFI

pub fn compress_bytes(format: FileFormat, in_bytes: &[u8], out_fd: RawFd) {
    let mut out_file = unsafe { ManuallyDrop::new(File::from_raw_fd(out_fd)) };

    let _ = || -> LoggedResult<()> {
        let mut encoder = get_encoder(format, out_file.deref_mut())?;
        std::io::copy(&mut Cursor::new(in_bytes), encoder.deref_mut())?;
        encoder.finish()?;
        Ok(())
    }();
}

pub fn decompress_bytes(format: FileFormat, in_bytes: &[u8], out_fd: RawFd) {
    let mut out_file = unsafe { ManuallyDrop::new(File::from_raw_fd(out_fd)) };

    let _ = || -> LoggedResult<()> {
        let mut decoder = get_decoder(format, in_bytes)?;
        std::io::copy(decoder.as_mut(), out_file.deref_mut())?;
        Ok(())
    }();
}

// Command-line entry points

pub(crate) fn decompress_cmd(infile: &Utf8CStr, outfile: Option<&Utf8CStr>) -> LoggedResult<()> {
    let in_std = infile == "-";
    let mut rm_in = false;

    let mut buf = [0u8; 4096];

    let input = if in_std {
        FileOrStd::StdIn
    } else {
        FileOrStd::File(infile.open(OFlag::O_RDONLY)?)
    };

    // First read some bytes for format detection
    let len = input.as_file().read(&mut buf)?;
    let buf = &buf[..len];

    let format = check_fmt(buf);

    eprintln!("Detected format: {format}");

    if !format.is_compressed() {
        return log_err!("Input file is not a supported type!");
    }

    // If user did not provide outfile, infile has to be either
    // <path>.[ext], or "-". Outfile will be either <path> or "-".
    // If the input does not have proper format, abort.

    let output = if let Some(outfile) = outfile {
        if outfile == "-" {
            FileOrStd::StdOut
        } else {
            FileOrStd::File(outfile.create(OFlag::O_WRONLY | OFlag::O_TRUNC, 0o644)?)
        }
    } else if in_std {
        FileOrStd::StdOut
    } else {
        // Strip out extension and remove input
        let outfile = if let Some((outfile, ext)) = infile.rsplit_once('.')
            && ext == format.ext()
        {
            Utf8CString::from(outfile)
        } else {
            return log_err!("Input file is not a supported type!");
        };

        rm_in = true;
        eprintln!("Decompressing to [{outfile}]");
        FileOrStd::File(outfile.create(OFlag::O_WRONLY | OFlag::O_TRUNC, 0o644)?)
    };

    let mut decoder = get_decoder(format, Cursor::new(buf).chain(input.as_file()))?;
    std::io::copy(decoder.as_mut(), &mut output.as_file())?;

    if rm_in {
        infile.remove()?;
    }

    Ok(())
}

pub(crate) fn compress_cmd(
    method: FileFormat,
    infile: &Utf8CStr,
    outfile: Option<&Utf8CStr>,
) -> LoggedResult<()> {
    let in_std = infile == "-";
    let mut rm_in = false;

    let input = if in_std {
        FileOrStd::StdIn
    } else {
        FileOrStd::File(infile.open(OFlag::O_RDONLY)?)
    };

    let output = if let Some(outfile) = outfile {
        if outfile == "-" {
            FileOrStd::StdOut
        } else {
            FileOrStd::File(outfile.create(OFlag::O_WRONLY | OFlag::O_TRUNC, 0o644)?)
        }
    } else if in_std {
        FileOrStd::StdOut
    } else {
        let mut outfile = Utf8CString::default();
        outfile.write_str(infile).ok();
        outfile.write_char('.').ok();
        outfile.write_str(method.ext()).ok();
        eprintln!("Compressing to [{outfile}]");
        rm_in = true;
        let outfile = outfile.create(OFlag::O_WRONLY | OFlag::O_TRUNC, 0o644)?;
        FileOrStd::File(outfile)
    };

    let mut encoder = get_encoder(method, output.as_file())?;
    std::io::copy(&mut input.as_file(), encoder.as_mut())?;
    encoder.finish()?;

    if rm_in {
        infile.remove()?;
    }
    Ok(())
}

```

`native/src/boot/cpio.rs`:

```rs
#![allow(clippy::useless_conversion)]

use argh::FromArgs;
use base::argh;
use bytemuck::{Pod, Zeroable, from_bytes};
use num_traits::cast::AsPrimitive;
use size::{Base, Size, Style};
use std::cmp::Ordering;
use std::collections::{BTreeMap, HashMap};
use std::fmt::{Display, Formatter};
use std::fs::File;
use std::io::{Cursor, Read, Write};
use std::mem::size_of;
use std::process::exit;
use std::str;

use crate::check_env;
use crate::compress::{get_decoder, get_encoder};
use crate::ffi::FileFormat;
use crate::patch::{patch_encryption, patch_verity};
use base::libc::{
    S_IFBLK, S_IFCHR, S_IFDIR, S_IFLNK, S_IFMT, S_IFREG, S_IRGRP, S_IROTH, S_IRUSR, S_IWGRP,
    S_IWOTH, S_IWUSR, S_IXGRP, S_IXOTH, S_IXUSR, dev_t, gid_t, major, makedev, minor, mknod,
    mode_t, uid_t,
};
use base::nix::fcntl::OFlag;
use base::{
    BytesExt, EarlyExitExt, LoggedResult, MappedFile, OptionExt, ResultExt, Utf8CStr, Utf8CStrBuf,
    WriteExt, cstr, log_err,
};

#[derive(FromArgs)]
struct CpioCommand {
    #[argh(subcommand)]
    action: CpioAction,
}

#[derive(FromArgs)]
#[argh(subcommand)]
enum CpioAction {
    Test(Test),
    Restore(Restore),
    Patch(Patch),
    Exists(Exists),
    Backup(Backup),
    Remove(Remove),
    Move(Move),
    Extract(Extract),
    MakeDir(MakeDir),
    Link(Link),
    Add(Add),
    List(List),
}

#[derive(FromArgs)]
#[argh(subcommand, name = "test")]
struct Test {}

#[derive(FromArgs)]
#[argh(subcommand, name = "restore")]
struct Restore {}

#[derive(FromArgs)]
#[argh(subcommand, name = "patch")]
struct Patch {}

#[derive(FromArgs)]
#[argh(subcommand, name = "exists")]
struct Exists {
    #[argh(positional, arg_name = "entry")]
    path: String,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "backup")]
struct Backup {
    #[argh(switch, short = 'n')]
    skip_compress: bool,
    #[argh(positional, arg_name = "orig")]
    origin: String,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "rm")]
struct Remove {
    #[argh(switch, short = 'r')]
    recursive: bool,
    #[argh(positional, arg_name = "entry")]
    path: String,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "mv")]
struct Move {
    #[argh(positional, arg_name = "source")]
    from: String,
    #[argh(positional, arg_name = "dest")]
    to: String,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "extract")]
struct Extract {
    #[argh(positional, greedy)]
    paths: Vec<String>,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "mkdir")]
struct MakeDir {
    #[argh(positional, from_str_fn(parse_mode))]
    mode: mode_t,
    #[argh(positional, arg_name = "entry")]
    dir: String,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "ln")]
struct Link {
    #[argh(positional, arg_name = "entry")]
    src: String,
    #[argh(positional, arg_name = "target")]
    dst: String,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "add")]
struct Add {
    #[argh(positional, from_str_fn(parse_mode))]
    mode: mode_t,
    #[argh(positional, arg_name = "entry")]
    path: String,
    #[argh(positional, arg_name = "infile")]
    file: String,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "ls")]
struct List {
    #[argh(switch, short = 'r')]
    recursive: bool,
    #[argh(positional, default = r#"String::from("/")"#)]
    path: String,
}

pub(crate) fn print_cpio_usage() {
    eprintln!(
        r#"Usage: magiskboot cpio <incpio> [commands...]

Do cpio commands to <incpio> (modifications are done in-place).
Each command is a single argument; add quotes for each command.

Supported commands:
  exists ENTRY
    Return 0 if ENTRY exists, else return 1
  ls [-r] [PATH]
    List PATH ("/" by default); specify [-r] to list recursively
  rm [-r] ENTRY
    Remove ENTRY, specify [-r] to remove recursively
  mkdir MODE ENTRY
    Create directory ENTRY with permissions MODE
  ln TARGET ENTRY
    Create a symlink to TARGET with the name ENTRY
  mv SOURCE DEST
    Move SOURCE to DEST
  add MODE ENTRY INFILE
    Add INFILE as ENTRY with permissions MODE; replaces ENTRY if exists
  extract [ENTRY OUT]
    Extract ENTRY to OUT, or extract all entries to current directory
  test
    Test the cpio's status. Return values:
    0:stock    1:Magisk    2:unsupported
  patch
    Apply ramdisk patches
    Configure with env variables: KEEPVERITY KEEPFORCEENCRYPT
  backup ORIG [-n]
    Create ramdisk backups from ORIG, specify [-n] to skip compression
  restore
    Restore ramdisk from ramdisk backup stored within incpio
"#
    )
}

#[derive(Copy, Clone, Pod, Zeroable)]
#[repr(C, packed)]
struct CpioHeader {
    magic: [u8; 6],
    ino: [u8; 8],
    mode: [u8; 8],
    uid: [u8; 8],
    gid: [u8; 8],
    nlink: [u8; 8],
    mtime: [u8; 8],
    filesize: [u8; 8],
    devmajor: [u8; 8],
    devminor: [u8; 8],
    rdevmajor: [u8; 8],
    rdevminor: [u8; 8],
    namesize: [u8; 8],
    check: [u8; 8],
}

struct Cpio {
    entries: BTreeMap<String, Box<CpioEntry>>,
}

struct CpioEntry {
    mode: mode_t,
    uid: uid_t,
    gid: gid_t,
    rdevmajor: dev_t,
    rdevminor: dev_t,
    data: Vec<u8>,
}

impl Cpio {
    fn new() -> Self {
        Self {
            entries: BTreeMap::new(),
        }
    }

    fn load_from_data(data: &[u8]) -> LoggedResult<Self> {
        let mut cpio = Cpio::new();
        let mut pos = 0_usize;
        while pos < data.len() {
            let hdr_sz = size_of::<CpioHeader>();
            let hdr = from_bytes::<CpioHeader>(&data[pos..(pos + hdr_sz)]);
            if &hdr.magic != b"070701" {
                return log_err!("invalid cpio magic");
            }
            pos += hdr_sz;
            let name_sz = x8u(&hdr.namesize)? as usize;
            let name = Utf8CStr::from_bytes(&data[pos..(pos + name_sz)])?.to_string();
            pos += name_sz;
            pos = align_4(pos);
            if name == "." || name == ".." {
                continue;
            }
            if name == "TRAILER!!!" {
                match data[pos..].find(b"070701") {
                    Some(x) => pos += x,
                    None => break,
                }
                continue;
            }
            let file_sz = x8u(&hdr.filesize)? as usize;
            let entry = Box::new(CpioEntry {
                mode: x8u(&hdr.mode)?.as_(),
                uid: x8u(&hdr.uid)?.as_(),
                gid: x8u(&hdr.gid)?.as_(),
                rdevmajor: x8u(&hdr.rdevmajor)?.as_(),
                rdevminor: x8u(&hdr.rdevminor)?.as_(),
                data: data[pos..(pos + file_sz)].to_vec(),
            });
            pos += file_sz;
            cpio.entries.insert(name, entry);
            pos = align_4(pos);
        }
        Ok(cpio)
    }

    fn load_from_file(path: &Utf8CStr) -> LoggedResult<Self> {
        eprintln!("Loading cpio: [{path}]");
        let file = MappedFile::open(path)?;
        Self::load_from_data(file.as_ref())
    }

    fn dump(&self, path: &str) -> LoggedResult<()> {
        eprintln!("Dumping cpio: [{path}]");
        let mut file = File::create(path)?;
        let mut pos = 0usize;
        let mut inode = 300000i64;
        for (name, entry) in &self.entries {
            pos += file.write(
                format!(
                    "070701{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}",
                    inode,
                    entry.mode,
                    entry.uid,
                    entry.gid,
                    1,
                    0,
                    entry.data.len(),
                    0,
                    0,
                    entry.rdevmajor,
                    entry.rdevminor,
                    name.len() + 1,
                    0
                ).as_bytes(),
            )?;
            pos += file.write(name.as_bytes())?;
            pos += file.write(&[0])?;
            file.write_zeros(align_4(pos) - pos)?;
            pos = align_4(pos);
            pos += file.write(&entry.data)?;
            file.write_zeros(align_4(pos) - pos)?;
            pos = align_4(pos);
            inode += 1;
        }
        pos += file.write(
            format!("070701{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}",
                    inode, 0o755, 0, 0, 1, 0, 0, 0, 0, 0, 0, 11, 0
            ).as_bytes()
        )?;
        pos += file.write("TRAILER!!!\0".as_bytes())?;
        file.write_zeros(align_4(pos) - pos)?;
        Ok(())
    }

    fn rm(&mut self, path: &str, recursive: bool) {
        let path = norm_path(path);
        if self.entries.remove(&path).is_some() {
            eprintln!("Removed entry [{path}]");
        }
        if recursive {
            let path = path + "/";
            self.entries.retain(|k, _| {
                if k.starts_with(&path) {
                    eprintln!("Removed entry [{k}]");
                    false
                } else {
                    true
                }
            })
        }
    }

    fn extract_entry(&self, path: &str, out: &mut String) -> LoggedResult<()> {
        let entry = self
            .entries
            .get(path)
            .ok_or_log_msg(|w| w.write_str("No such file"))?;
        eprintln!("Extracting entry [{path}] to [{out}]");

        let out = Utf8CStr::from_string(out);

        let mut buf = cstr::buf::default();

        // Make sure its parent directories exist
        if let Some(dir) = out.parent_dir() {
            buf.push_str(dir);
            buf.mkdirs(0o755)?;
        }

        let mode: mode_t = (entry.mode & 0o777).into();

        match entry.mode & S_IFMT {
            S_IFDIR => out.mkdir(mode)?,
            S_IFREG => {
                let mut file = out.create(
                    OFlag::O_CREAT | OFlag::O_TRUNC | OFlag::O_WRONLY | OFlag::O_CLOEXEC,
                    mode,
                )?;
                file.write_all(&entry.data)?;
            }
            S_IFLNK => {
                buf.clear();
                buf.push_str(str::from_utf8(entry.data.as_slice())?);
                out.create_symlink_to(&buf)?;
            }
            S_IFBLK | S_IFCHR => {
                let dev = makedev(entry.rdevmajor.try_into()?, entry.rdevminor.try_into()?);
                unsafe { mknod(out.as_ptr().cast(), entry.mode, dev) };
            }
            _ => {
                return log_err!("unknown entry type");
            }
        }
        Ok(())
    }

    fn extract(&self, path: Option<&mut String>, out: Option<&mut String>) -> LoggedResult<()> {
        let path = path.map(|s| norm_path(s.as_str()));
        if let (Some(path), Some(out)) = (&path, out) {
            return self.extract_entry(path, out);
        } else {
            for path in self.entries.keys() {
                if path == "." || path == ".." {
                    continue;
                }
                self.extract_entry(path, &mut path.clone())?;
            }
        }
        Ok(())
    }

    fn exists(&self, path: &str) -> bool {
        self.entries.contains_key(&norm_path(path))
    }

    fn add(&mut self, mode: mode_t, path: &str, file: &mut String) -> LoggedResult<()> {
        if path.ends_with('/') {
            return log_err!("path cannot end with / for add");
        }
        let file = Utf8CStr::from_string(file);
        let attr = file.get_attr()?;

        let mut content = Vec::<u8>::new();
        let rdevmajor: dev_t;
        let rdevminor: dev_t;

        // Treat symlinks as regular files as symlinks are created by the 'ln TARGET ENTRY' command
        let mode = if attr.is_file() || attr.is_symlink() {
            rdevmajor = 0;
            rdevminor = 0;
            file.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC)?
                .read_to_end(&mut content)?;
            mode | S_IFREG
        } else {
            rdevmajor = major(attr.st.st_rdev.as_()).as_();
            rdevminor = minor(attr.st.st_rdev.as_()).as_();
            if attr.is_block_device() {
                mode | S_IFBLK
            } else if attr.is_char_device() {
                mode | S_IFCHR
            } else {
                return log_err!("unsupported file type");
            }
        };

        self.entries.insert(
            norm_path(path),
            Box::new(CpioEntry {
                mode,
                uid: 0,
                gid: 0,
                rdevmajor,
                rdevminor,
                data: content,
            }),
        );
        eprintln!("Add file [{path}] ({mode:04o})");
        Ok(())
    }

    fn mkdir(&mut self, mode: mode_t, dir: &str) {
        self.entries.insert(
            norm_path(dir),
            Box::new(CpioEntry {
                mode: mode | S_IFDIR,
                uid: 0,
                gid: 0,
                rdevmajor: 0,
                rdevminor: 0,
                data: vec![],
            }),
        );
        eprintln!("Create directory [{dir}] ({mode:04o})");
    }

    fn ln(&mut self, src: &str, dst: &str) {
        self.entries.insert(
            norm_path(dst),
            Box::new(CpioEntry {
                mode: S_IFLNK,
                uid: 0,
                gid: 0,
                rdevmajor: 0,
                rdevminor: 0,
                data: norm_path(src).as_bytes().to_vec(),
            }),
        );
        eprintln!("Create symlink [{dst}] -> [{src}]");
    }

    fn mv(&mut self, from: &str, to: &str) -> LoggedResult<()> {
        let entry = self
            .entries
            .remove(&norm_path(from))
            .ok_or_log_msg(|w| w.write_fmt(format_args!("No such entry {from}")))?;
        self.entries.insert(norm_path(to), entry);
        eprintln!("Move [{from}] -> [{to}]");
        Ok(())
    }

    fn ls(&self, path: &str, recursive: bool) {
        let path = norm_path(path);
        let path = if path.is_empty() {
            path
        } else {
            "/".to_string() + path.as_str()
        };
        for (name, entry) in &self.entries {
            let p = "/".to_string() + name.as_str();
            let Some(p) = p.strip_prefix(&path) else {
                continue;
            };
            if !p.is_empty() && !p.starts_with('/') {
                continue;
            }
            if !recursive && !p.is_empty() && p.matches('/').count() > 1 {
                continue;
            }
            println!("{entry}\t{name}");
        }
    }
}

const MAGISK_PATCHED: i32 = 1 << 0;
const UNSUPPORTED_CPIO: i32 = 1 << 1;

impl Cpio {
    fn patch(&mut self) {
        let keep_verity = check_env("KEEPVERITY");
        let keep_force_encrypt = check_env("KEEPFORCEENCRYPT");
        eprintln!(
            "Patch with flag KEEPVERITY=[{keep_verity}] KEEPFORCEENCRYPT=[{keep_force_encrypt}]"
        );
        self.entries.retain(|name, entry| {
            let fstab = (!keep_verity || !keep_force_encrypt)
                && entry.mode & S_IFMT == S_IFREG
                && !name.starts_with(".backup")
                && !name.starts_with("twrp")
                && !name.starts_with("recovery")
                && name.starts_with("fstab");
            if !keep_verity {
                if fstab {
                    eprintln!("Found fstab file [{name}]");
                    let len = patch_verity(entry.data.as_mut_slice());
                    if len != entry.data.len() {
                        entry.data.resize(len, 0);
                    }
                } else if name == "verity_key" {
                    return false;
                }
            }
            if !keep_force_encrypt && fstab {
                let len = patch_encryption(entry.data.as_mut_slice());
                if len != entry.data.len() {
                    entry.data.resize(len, 0);
                }
            }
            true
        });
    }

    fn test(&self) -> i32 {
        for file in [
            "sbin/launch_daemonsu.sh",
            "sbin/su",
            "init.xposed.rc",
            "boot/sbin/launch_daemonsu.sh",
        ] {
            if self.exists(file) {
                return UNSUPPORTED_CPIO;
            }
        }
        for file in [
            ".backup/.magisk",
            "init.magisk.rc",
            "overlay/init.magisk.rc",
        ] {
            if self.exists(file) {
                return MAGISK_PATCHED;
            }
        }
        0
    }

    fn restore(&mut self) -> LoggedResult<()> {
        let mut backups = HashMap::<String, Box<CpioEntry>>::new();
        let mut rm_list = String::new();
        self.entries
            .extract_if(.., |name, _| name.starts_with(".backup/"))
            .for_each(|(name, mut entry)| {
                if name == ".backup/.rmlist" {
                    if let Ok(data) = str::from_utf8(&entry.data) {
                        rm_list.push_str(data);
                    }
                } else if name != ".backup/.magisk" {
                    let new_name = if name.ends_with(".xz") && entry.decompress() {
                        &name[8..name.len() - 3]
                    } else {
                        &name[8..]
                    };
                    eprintln!("Restore [{name}] -> [{new_name}]");
                    backups.insert(new_name.to_string(), entry);
                }
            });
        self.rm(".backup", false);
        if rm_list.is_empty() && backups.is_empty() {
            self.entries.clear();
            return Ok(());
        }
        for rm in rm_list.split('\0') {
            if !rm.is_empty() {
                self.rm(rm, false);
            }
        }
        self.entries.extend(backups);

        Ok(())
    }

    fn backup(&mut self, origin: &mut String, skip_compress: bool) -> LoggedResult<()> {
        let mut backups = HashMap::<String, Box<CpioEntry>>::new();
        let mut rm_list = String::new();
        backups.insert(
            ".backup".to_string(),
            Box::new(CpioEntry {
                mode: S_IFDIR,
                uid: 0,
                gid: 0,
                rdevmajor: 0,
                rdevminor: 0,
                data: vec![],
            }),
        );
        let origin = Utf8CStr::from_string(origin);
        let mut o = Cpio::load_from_file(origin)?;
        o.rm(".backup", true);
        self.rm(".backup", true);

        let mut left_iter = o.entries.into_iter();
        let mut right_iter = self.entries.iter();

        let mut lhs = left_iter.next();
        let mut rhs = right_iter.next();

        loop {
            enum Action<'a> {
                Backup(String, Box<CpioEntry>),
                Record(&'a String),
                Noop,
            }

            // Move the iterator forward if needed
            if lhs.is_none() {
                lhs = left_iter.next();
            }
            if rhs.is_none() {
                rhs = right_iter.next();
            }

            let action = match (lhs.take(), rhs.take()) {
                (Some((ln, le)), Some((rn, re))) => match ln.as_str().cmp(rn.as_str()) {
                    Ordering::Less => {
                        // Put rhs back
                        rhs = Some((rn, re));
                        Action::Backup(ln, le)
                    }
                    Ordering::Greater => {
                        // Put lhs back
                        lhs = Some((ln, le));
                        Action::Record(rn)
                    }
                    Ordering::Equal => {
                        if re.data != le.data {
                            Action::Backup(ln, le)
                        } else {
                            Action::Noop
                        }
                    }
                },
                (Some((ln, le)), None) => Action::Backup(ln, le),
                (None, Some((rn, _))) => Action::Record(rn),
                (None, None) => break,
            };
            match action {
                Action::Backup(name, mut entry) => {
                    let backup = if !skip_compress && entry.compress() {
                        format!(".backup/{name}.xz")
                    } else {
                        format!(".backup/{name}")
                    };
                    eprintln!("Backup [{name}] -> [{backup}]");
                    backups.insert(backup, entry);
                }
                Action::Record(name) => {
                    eprintln!("Record new entry: [{name}] -> [.backup/.rmlist]");
                    rm_list.push_str(&format!("{name}\0"));
                }
                Action::Noop => {}
            }
        }
        if !rm_list.is_empty() {
            backups.insert(
                ".backup/.rmlist".to_string(),
                Box::new(CpioEntry {
                    mode: S_IFREG,
                    uid: 0,
                    gid: 0,
                    rdevmajor: 0,
                    rdevminor: 0,
                    data: rm_list.as_bytes().to_vec(),
                }),
            );
        }
        self.entries.extend(backups);

        Ok(())
    }
}

impl CpioEntry {
    pub(crate) fn compress(&mut self) -> bool {
        if self.mode & S_IFMT != S_IFREG {
            return false;
        }
        let Ok(data) = || -> std::io::Result<Vec<u8>> {
            let mut encoder = get_encoder(FileFormat::XZ, Vec::new())?;
            encoder.write_all(&self.data)?;
            encoder.finish()
        }() else {
            eprintln!("xz compression failed");
            return false;
        };

        self.data = data;
        true
    }

    pub(crate) fn decompress(&mut self) -> bool {
        if self.mode & S_IFMT != S_IFREG {
            return false;
        }

        let Ok(data) = || -> std::io::Result<Vec<u8>> {
            let mut decoder = get_decoder(FileFormat::XZ, Cursor::new(&self.data))?;
            let mut data = Vec::new();
            std::io::copy(decoder.as_mut(), &mut data)?;
            Ok(data)
        }() else {
            eprintln!("xz compression failed");
            return false;
        };

        self.data = data;
        true
    }
}

impl Display for CpioEntry {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}{}{}{}{}{}{}{}{}{}\t{}\t{}\t{}\t{}:{}",
            match self.mode & S_IFMT {
                S_IFDIR => "d",
                S_IFREG => "-",
                S_IFLNK => "l",
                S_IFBLK => "b",
                S_IFCHR => "c",
                _ => "?",
            },
            if self.mode & S_IRUSR != 0 { "r" } else { "-" },
            if self.mode & S_IWUSR != 0 { "w" } else { "-" },
            if self.mode & S_IXUSR != 0 { "x" } else { "-" },
            if self.mode & S_IRGRP != 0 { "r" } else { "-" },
            if self.mode & S_IWGRP != 0 { "w" } else { "-" },
            if self.mode & S_IXGRP != 0 { "x" } else { "-" },
            if self.mode & S_IROTH != 0 { "r" } else { "-" },
            if self.mode & S_IWOTH != 0 { "w" } else { "-" },
            if self.mode & S_IXOTH != 0 { "x" } else { "-" },
            self.uid,
            self.gid,
            Size::from_bytes(self.data.len())
                .format()
                .with_style(Style::Abbreviated)
                .with_base(Base::Base10),
            self.rdevmajor,
            self.rdevminor,
        )
    }
}

pub(crate) fn cpio_commands(file: &Utf8CStr, cmds: &Vec<String>) -> LoggedResult<()> {
    let mut cpio = if file.exists() {
        Cpio::load_from_file(file)?
    } else {
        Cpio::new()
    };

    for cmd in cmds {
        if cmd.starts_with('#') {
            continue;
        }
        let mut cmd = CpioCommand::from_args(
            &["magiskboot", "cpio", file],
            cmd.split(' ')
                .filter(|x| !x.is_empty())
                .collect::<Vec<_>>()
                .as_slice(),
        )
        .on_early_exit(print_cpio_usage);

        match &mut cmd.action {
            CpioAction::Test(_) => exit(cpio.test()),
            CpioAction::Restore(_) => cpio.restore()?,
            CpioAction::Patch(_) => cpio.patch(),
            CpioAction::Exists(Exists { path }) => {
                return if cpio.exists(path) {
                    Ok(())
                } else {
                    log_err!()
                };
            }
            CpioAction::Backup(Backup {
                origin,
                skip_compress,
            }) => cpio.backup(origin, *skip_compress)?,
            CpioAction::Remove(Remove { path, recursive }) => cpio.rm(path, *recursive),
            CpioAction::Move(Move { from, to }) => cpio.mv(from, to)?,
            CpioAction::MakeDir(MakeDir { mode, dir }) => cpio.mkdir(*mode, dir),
            CpioAction::Link(Link { src, dst }) => cpio.ln(src, dst),
            CpioAction::Add(Add { mode, path, file }) => cpio.add(*mode, path, file)?,
            CpioAction::Extract(Extract { paths }) => {
                if !paths.is_empty() && paths.len() != 2 {
                    log_err!("invalid arguments")?;
                }
                let mut it = paths.iter_mut();
                cpio.extract(it.next(), it.next())?;
            }
            CpioAction::List(List { path, recursive }) => {
                cpio.ls(path.as_str(), *recursive);
                return Ok(());
            }
        };
    }
    cpio.dump(file)?;
    Ok(())
}

fn x8u(x: &[u8; 8]) -> LoggedResult<u32> {
    // parse hex
    let mut ret = 0u32;
    let s = str::from_utf8(x).log_with_msg(|w| w.write_str("bad cpio header"))?;
    for c in s.chars() {
        ret = ret * 16
            + c.to_digit(16)
                .ok_or_log_msg(|w| w.write_str("bad cpio header"))?;
    }
    Ok(ret)
}

#[inline(always)]
fn align_4(x: usize) -> usize {
    (x + 3) & !3
}

#[inline(always)]
fn norm_path(path: &str) -> String {
    path.split('/')
        .filter(|x| !x.is_empty())
        .intersperse("/")
        .collect()
}

fn parse_mode(s: &str) -> Result<mode_t, String> {
    mode_t::from_str_radix(s, 8).map_err(|e| e.to_string())
}

```

`native/src/boot/dtb.rs`:

```rs
use argh::FromArgs;
use base::{LoggedResult, MappedFile, Utf8CStr, argh};
use fdt::node::{FdtNode, NodeProperty};
use fdt::{Fdt, FdtError};
use std::cell::UnsafeCell;

use crate::check_env;
use crate::patch::patch_verity;

#[derive(FromArgs)]
#[argh(subcommand)]
pub(crate) enum DtbAction {
    Print(Print),
    Patch(Patch),
    Test(Test),
}

#[derive(FromArgs)]
#[argh(subcommand, name = "print")]
pub(crate) struct Print {
    #[argh(switch, short = 'f', long = none)]
    fstab: bool,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "patch")]
pub(crate) struct Patch {}

#[derive(FromArgs)]
#[argh(subcommand, name = "test")]
pub(crate) struct Test {}

pub(crate) fn print_dtb_usage() {
    eprintln!(
        r#"Usage: magiskboot dtb <file> <action> [args...]
Do dtb related actions to <file>.

Supported actions:
  print [-f]
    Print all contents of dtb for debugging
    Specify [-f] to only print fstab nodes
  patch
    Search for fstab and remove verity/avb
    Modifications are done directly to the file in-place
    Configure with env variables: KEEPVERITY
  test
    Test the fstab's status
    Return values:
    0:valid    1:error"#
    );
}

const MAX_PRINT_LEN: usize = 32;

fn print_node(node: &FdtNode) {
    fn pretty_node(depth_set: &[bool]) {
        let mut depth_set = depth_set.iter().peekable();
        while let Some(depth) = depth_set.next() {
            let last = depth_set.peek().is_none();
            if *depth {
                if last {
                    print!("├── ");
                } else {
                    print!("│   ");
                }
            } else if last {
                print!("└── ");
            } else {
                print!("    ");
            }
        }
    }

    fn pretty_prop(depth_set: &[bool]) {
        let mut depth_set = depth_set.iter().peekable();
        while let Some(depth) = depth_set.next() {
            let last = depth_set.peek().is_none();
            if *depth {
                if last {
                    print!("│  ");
                } else {
                    print!("│   ");
                }
            } else if last {
                print!("└─ ");
            } else {
                print!("    ");
            }
        }
    }

    fn do_print_node(node: &FdtNode, depth_set: &mut Vec<bool>) {
        pretty_node(depth_set);
        let depth = depth_set.len();
        depth_set.push(true);
        println!("{}", node.name);
        let mut properties = node.properties().peekable();
        let mut children = node.children().peekable();
        while let Some(NodeProperty { name, value }) = properties.next() {
            let size = value.len();
            let is_str = !(size > 1 && value[0] == 0)
                && matches!(value.last(), Some(0u8) | None)
                && value.iter().all(|c| *c == 0 || (*c >= 32 && *c < 127));

            if depth_set[depth] && properties.peek().is_none() && children.peek().is_none() {
                depth_set[depth] = false;
            }

            pretty_prop(depth_set);
            if is_str {
                println!(
                    "[{}]: [\"{}\"]",
                    name,
                    if value.is_empty() {
                        ""
                    } else {
                        unsafe { Utf8CStr::from_bytes_unchecked(value) }
                    }
                );
            } else if size > MAX_PRINT_LEN {
                println!("[{name}]: <bytes>({size})");
            } else {
                println!("[{name}]: {value:02x?}");
            }
        }

        while let Some(child) = children.next() {
            if depth_set[depth] && children.peek().is_none() {
                depth_set[depth] = false;
            }
            do_print_node(&child, depth_set);
        }
        depth_set.pop();
    }

    do_print_node(node, &mut vec![]);
}

fn for_each_fdt<F: FnMut(usize, Fdt) -> LoggedResult<()>>(
    file: &Utf8CStr,
    rw: bool,
    mut f: F,
) -> LoggedResult<()> {
    eprintln!("Loading dtbs from [{file}]");
    let file = if rw {
        MappedFile::open_rw(file)?
    } else {
        MappedFile::open(file)?
    };
    let mut buf = Some(file.as_ref());
    let mut dtb_num = 0usize;
    while let Some(slice) = buf {
        let slice = if let Some(pos) = slice.windows(4).position(|w| w == b"\xd0\x0d\xfe\xed") {
            &slice[pos..]
        } else {
            break;
        };
        if slice.len() < 40 {
            break;
        }
        let fdt = match Fdt::new(slice) {
            Err(FdtError::BufferTooSmall) => {
                eprintln!("dtb.{dtb_num:04} is truncated");
                break;
            }
            Ok(fdt) => fdt,
            e => e?,
        };

        let size = fdt.total_size();

        f(dtb_num, fdt)?;

        dtb_num += 1;
        buf = Some(&slice[size..]);
    }
    Ok(())
}

fn find_fstab<'b, 'a: 'b>(fdt: &'b Fdt<'a>) -> Option<FdtNode<'b, 'a>> {
    fdt.all_nodes().find(|node| node.name == "fstab")
}

fn dtb_print(file: &Utf8CStr, fstab: bool) -> LoggedResult<()> {
    for_each_fdt(file, false, |n, fdt| {
        if fstab {
            if let Some(fstab) = find_fstab(&fdt) {
                eprintln!("Found fstab in dtb.{n:04}");
                print_node(&fstab);
            }
        } else if let Some(mut root) = fdt.find_node("/") {
            eprintln!("Printing dtb.{n:04}");
            if root.name.is_empty() {
                root.name = "/";
            }
            print_node(&root);
        }
        Ok(())
    })
}

fn dtb_test(file: &Utf8CStr) -> LoggedResult<bool> {
    let mut ret = true;
    for_each_fdt(file, false, |_, fdt| {
        if let Some(fstab) = find_fstab(&fdt) {
            for child in fstab.children() {
                if child.name != "system" {
                    continue;
                }
                if let Some(mount_point) = child.property("mnt_point")
                    && mount_point.value == b"/system_root\0"
                {
                    ret = false;
                    break;
                }
            }
        }
        Ok(())
    })?;
    Ok(ret)
}

fn dtb_patch(file: &Utf8CStr) -> LoggedResult<bool> {
    let keep_verity = check_env("KEEPVERITY");
    let mut patched = false;
    for_each_fdt(file, true, |n, fdt| {
        for node in fdt.all_nodes() {
            if node.name != "chosen" {
                continue;
            }
            if let Some(boot_args) = node.property("bootargs") {
                boot_args.value.windows(14).for_each(|w| {
                    if w == b"skip_initramfs" {
                        let w = unsafe {
                            &mut *std::mem::transmute::<&[u8], &UnsafeCell<[u8]>>(w).get()
                        };
                        w[..=4].copy_from_slice(b"want");
                        eprintln!("Patch [skip_initramfs] -> [want_initramfs] in dtb.{n:04}");
                        patched = true;
                    }
                });
            }
        }
        if keep_verity {
            return Ok(());
        }
        if let Some(fstab) = find_fstab(&fdt) {
            for child in fstab.children() {
                if let Some(flags) = child.property("fsmgr_flags") {
                    let flags = unsafe {
                        &mut *std::mem::transmute::<&[u8], &UnsafeCell<[u8]>>(flags.value).get()
                    };
                    if patch_verity(flags) != flags.len() {
                        patched = true;
                    }
                }
            }
        }
        Ok(())
    })?;
    Ok(patched)
}

pub(crate) fn dtb_commands(file: &Utf8CStr, action: &DtbAction) -> LoggedResult<bool> {
    match action {
        DtbAction::Print(Print { fstab }) => {
            dtb_print(file, *fstab)?;
            Ok(true)
        }
        DtbAction::Test(_) => Ok(dtb_test(file)?),
        DtbAction::Patch(_) => Ok(dtb_patch(file)?),
    }
}

```

`native/src/boot/format.rs`:

```rs
use crate::ffi::FileFormat;
use base::{Utf8CStr, cstr, libc};
use std::fmt::{Display, Formatter};
use std::str::FromStr;

impl FromStr for FileFormat {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "gzip" => Ok(Self::GZIP),
            "zopfli" => Ok(Self::ZOPFLI),
            "xz" => Ok(Self::XZ),
            "lzma" => Ok(Self::LZMA),
            "bzip2" => Ok(Self::BZIP2),
            "lz4" => Ok(Self::LZ4),
            "lz4_legacy" => Ok(Self::LZ4_LEGACY),
            "lz4_lg" => Ok(Self::LZ4_LG),
            _ => Err(()),
        }
    }
}

impl Display for FileFormat {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str(self.as_cstr())
    }
}

impl FileFormat {
    fn as_cstr(&self) -> &'static Utf8CStr {
        match *self {
            Self::GZIP => cstr!("gzip"),
            Self::ZOPFLI => cstr!("zopfli"),
            Self::LZOP => cstr!("lzop"),
            Self::XZ => cstr!("xz"),
            Self::LZMA => cstr!("lzma"),
            Self::BZIP2 => cstr!("bzip2"),
            Self::LZ4 => cstr!("lz4"),
            Self::LZ4_LEGACY => cstr!("lz4_legacy"),
            Self::LZ4_LG => cstr!("lz4_lg"),
            Self::DTB => cstr!("dtb"),
            Self::ZIMAGE => cstr!("zimage"),
            _ => cstr!("raw"),
        }
    }
}

impl FileFormat {
    pub fn ext(&self) -> &'static str {
        match *self {
            Self::GZIP | Self::ZOPFLI => "gz",
            Self::LZOP => "lzo",
            Self::XZ => "xz",
            Self::LZMA => "lzma",
            Self::BZIP2 => "bz2",
            Self::LZ4 | Self::LZ4_LEGACY | Self::LZ4_LG => "lz4",
            _ => "",
        }
    }

    pub fn is_compressed(&self) -> bool {
        matches!(
            *self,
            Self::GZIP
                | Self::ZOPFLI
                | Self::XZ
                | Self::LZMA
                | Self::BZIP2
                | Self::LZ4
                | Self::LZ4_LEGACY
                | Self::LZ4_LG
        )
    }

    pub fn formats() -> String {
        [
            Self::GZIP,
            Self::ZOPFLI,
            Self::XZ,
            Self::LZMA,
            Self::BZIP2,
            Self::LZ4,
            Self::LZ4_LEGACY,
            Self::LZ4_LG,
        ]
        .map(|f| f.to_string())
        .join(" ")
    }
}

// C++ FFI

pub fn fmt2name(fmt: FileFormat) -> *const libc::c_char {
    fmt.as_cstr().as_ptr()
}

pub fn fmt_compressed(fmt: FileFormat) -> bool {
    fmt.is_compressed()
}

pub fn fmt_compressed_any(fmt: FileFormat) -> bool {
    fmt.is_compressed() || matches!(fmt, FileFormat::LZOP)
}

```

`native/src/boot/lib.rs`:

```rs
#![feature(format_args_nl)]
#![feature(iter_intersperse)]

pub use base;
use compress::{compress_bytes, decompress_bytes};
use format::{fmt_compressed, fmt_compressed_any, fmt2name};
use sign::{SHA, get_sha, sha256_hash, sign_payload_for_cxx};
use std::env;

mod cli;
mod compress;
mod cpio;
mod dtb;
mod format;
mod patch;
mod payload;
// Suppress warnings in generated code
#[allow(warnings)]
mod proto;
mod sign;

#[cxx::bridge]
pub mod ffi {
    enum FileFormat {
        UNKNOWN,
        /* Boot formats */
        CHROMEOS,
        AOSP,
        AOSP_VENDOR,
        DHTB,
        BLOB,
        /* Compression formats */
        GZIP,
        ZOPFLI,
        XZ,
        LZMA,
        BZIP2,
        LZ4,
        LZ4_LEGACY,
        LZ4_LG,
        /* Unsupported compression */
        LZOP,
        /* Misc */
        MTK,
        DTB,
        ZIMAGE,
    }

    unsafe extern "C++" {
        include!("magiskboot.hpp");

        #[cxx_name = "Utf8CStr"]
        type Utf8CStrRef<'a> = base::Utf8CStrRef<'a>;

        fn cleanup();
        fn unpack(image: Utf8CStrRef, skip_decomp: bool, hdr: bool) -> i32;
        fn repack(src_img: Utf8CStrRef, out_img: Utf8CStrRef, skip_comp: bool);
        fn split_image_dtb(filename: Utf8CStrRef, skip_decomp: bool) -> i32;
        fn check_fmt(buf: &[u8]) -> FileFormat;
    }

    extern "Rust" {
        type SHA;
        fn get_sha(use_sha1: bool) -> Box<SHA>;
        fn update(self: &mut SHA, data: &[u8]);
        fn finalize_into(self: &mut SHA, out: &mut [u8]);
        fn output_size(self: &SHA) -> usize;
        fn sha256_hash(data: &[u8], out: &mut [u8]);

        fn compress_bytes(format: FileFormat, in_bytes: &[u8], out_fd: i32);
        fn decompress_bytes(format: FileFormat, in_bytes: &[u8], out_fd: i32);
        fn fmt2name(fmt: FileFormat) -> *const c_char;
        fn fmt_compressed(fmt: FileFormat) -> bool;
        fn fmt_compressed_any(fmt: FileFormat) -> bool;

        #[cxx_name = "sign_payload"]
        fn sign_payload_for_cxx(payload: &[u8]) -> Vec<u8>;
    }

    // BootImage FFI
    unsafe extern "C++" {
        include!("bootimg.hpp");
        #[cxx_name = "boot_img"]
        type BootImage;

        #[cxx_name = "get_payload"]
        fn payload(self: &BootImage) -> &[u8];
        #[cxx_name = "get_tail"]
        fn tail(self: &BootImage) -> &[u8];
        fn is_signed(self: &BootImage) -> bool;
        fn tail_off(self: &BootImage) -> u64;

        #[Self = BootImage]
        #[cxx_name = "create"]
        fn new(img: Utf8CStrRef) -> UniquePtr<BootImage>;
    }
    extern "Rust" {
        #[cxx_name = "verify"]
        fn verify_for_cxx(self: &BootImage) -> bool;
    }
}

#[inline(always)]
pub(crate) fn check_env(env: &str) -> bool {
    env::var(env).is_ok_and(|var| var == "true")
}

```

`native/src/boot/magiskboot.hpp`:

```hpp
#pragma once

#include <base.hpp>

#define HEADER_FILE     "header"
#define KERNEL_FILE     "kernel"
#define RAMDISK_FILE    "ramdisk.cpio"
#define VND_RAMDISK_DIR "vendor_ramdisk"
#define SECOND_FILE     "second"
#define EXTRA_FILE      "extra"
#define KER_DTB_FILE    "kernel_dtb"
#define RECV_DTBO_FILE  "recovery_dtbo"
#define DTB_FILE        "dtb"
#define BOOTCONFIG_FILE "bootconfig"
#define NEW_BOOT        "new-boot.img"

#define BUFFER_MATCH(buf, s) (memcmp(buf, s, sizeof(s) - 1) == 0)
#define BUFFER_CONTAIN(buf, sz, s) (memmem(buf, sz, s, sizeof(s) - 1) != nullptr)
#define CHECKED_MATCH(s) (len >= (sizeof(s) - 1) && BUFFER_MATCH(buf, s))

#define BOOT_MAGIC      "ANDROID!"
#define VENDOR_BOOT_MAGIC "VNDRBOOT"
#define CHROMEOS_MAGIC  "CHROMEOS"
#define GZIP1_MAGIC     "\x1f\x8b"
#define GZIP2_MAGIC     "\x1f\x9e"
#define LZOP_MAGIC      "\x89""LZO"
#define XZ_MAGIC        "\xfd""7zXZ"
#define BZIP_MAGIC      "BZh"
#define LZ4_LEG_MAGIC   "\x02\x21\x4c\x18"
#define LZ41_MAGIC      "\x03\x21\x4c\x18"
#define LZ42_MAGIC      "\x04\x22\x4d\x18"
#define MTK_MAGIC       "\x88\x16\x88\x58"
#define DTB_MAGIC       "\xd0\x0d\xfe\xed"
#define LG_BUMP_MAGIC   "\x41\xa9\xe4\x67\x74\x4d\x1d\x1b\xa4\x29\xf2\xec\xea\x65\x52\x79"
#define DHTB_MAGIC      "\x44\x48\x54\x42\x01\x00\x00\x00"
#define SEANDROID_MAGIC "SEANDROIDENFORCE"
#define TEGRABLOB_MAGIC "-SIGNED-BY-SIGNBLOB-"
#define NOOKHD_RL_MAGIC "Red Loader"
#define NOOKHD_GL_MAGIC "Green Loader"
#define NOOKHD_GR_MAGIC "Green Recovery"
#define NOOKHD_EB_MAGIC "eMMC boot.img+secondloader"
#define NOOKHD_ER_MAGIC "eMMC recovery.img+secondloader"
#define NOOKHD_PRE_HEADER_SZ 1048576
#define ACCLAIM_MAGIC   "BauwksBoot"
#define ACCLAIM_PRE_HEADER_SZ 262144
#define AMONET_MICROLOADER_MAGIC "microloader"
#define AMONET_MICROLOADER_SZ 1024
#define AVB_FOOTER_MAGIC "AVBf"
#define AVB_MAGIC "AVB0"
#define ZIMAGE_MAGIC "\x18\x28\x6f\x01"

enum class FileFormat : uint8_t;

int unpack(Utf8CStr image, bool skip_decomp = false, bool hdr = false);
void repack(Utf8CStr src_img, Utf8CStr out_img, bool skip_comp = false);
int split_image_dtb(Utf8CStr filename, bool skip_decomp = false);
void cleanup();
FileFormat check_fmt(const void *buf, size_t len);

static inline FileFormat check_fmt(rust::Slice<const uint8_t> bytes) {
    return check_fmt(bytes.data(), bytes.size());
}

```

`native/src/boot/patch.rs`:

```rs
use base::{LoggedResult, MappedFile, MutBytesExt, Utf8CStr};

// SAFETY: assert(buf.len() >= 1) && assert(len <= buf.len())
macro_rules! match_patterns {
    ($buf:ident, $($str:literal), *) => {{
        let mut len = if *$buf.get_unchecked(0) == b',' { 1 } else { 0 };
        let b = $buf.get_unchecked(len..);
        let found = if b.is_empty() {
            false
        }
        $(
        else if b.starts_with($str) {
            len += $str.len();
            true
        }
        )*
        else {
            false
        };
        if found {
            let b = $buf.get_unchecked(len..);
            if !b.is_empty() && b[0] == b'=' {
                for c in b.iter() {
                    if b" \n\0".contains(c) {
                        break;
                    }
                    len += 1;
                }
            }
            Some(len)
        } else {
            None
        }
    }};
}

fn remove_pattern(buf: &mut [u8], pattern_matcher: unsafe fn(&[u8]) -> Option<usize>) -> usize {
    let mut write = 0_usize;
    let mut read = 0_usize;
    let mut sz = buf.len();
    // SAFETY: assert(write <= read) && assert(read <= buf.len())
    unsafe {
        while read < buf.len() {
            if let Some(len) = pattern_matcher(buf.get_unchecked(read..)) {
                let skipped = buf.get_unchecked(read..(read + len));
                // SAFETY: all matching patterns are ASCII bytes
                let skipped = std::str::from_utf8_unchecked(skipped);
                eprintln!("Remove pattern [{skipped}]");
                sz -= len;
                read += len;
            } else {
                *buf.get_unchecked_mut(write) = *buf.get_unchecked(read);
                write += 1;
                read += 1;
            }
        }
    }
    if let Some(buf) = buf.get_mut(write..) {
        buf.fill(0);
    }
    sz
}

pub fn patch_verity(buf: &mut [u8]) -> usize {
    unsafe fn match_verity_pattern(buf: &[u8]) -> Option<usize> {
        unsafe {
            match_patterns!(
                buf,
                b"verifyatboot",
                b"verify",
                b"avb_keys",
                b"avb",
                b"support_scfs",
                b"fsverity"
            )
        }
    }

    remove_pattern(buf, match_verity_pattern)
}

pub fn patch_encryption(buf: &mut [u8]) -> usize {
    unsafe fn match_encryption_pattern(buf: &[u8]) -> Option<usize> {
        unsafe { match_patterns!(buf, b"forceencrypt", b"forcefdeorfbe", b"fileencryption") }
    }

    remove_pattern(buf, match_encryption_pattern)
}

fn hex2byte(hex: &[u8]) -> Vec<u8> {
    let mut v = Vec::with_capacity(hex.len() / 2);
    for bytes in hex.chunks(2) {
        if bytes.len() != 2 {
            break;
        }
        let high = bytes[0].to_ascii_uppercase() - b'0';
        let low = bytes[1].to_ascii_uppercase() - b'0';
        let h = if high > 9 { high - 7 } else { high };
        let l = if low > 9 { low - 7 } else { low };
        v.push((h << 4) | l);
    }
    v
}

pub fn hexpatch(file: &Utf8CStr, from: &Utf8CStr, to: &Utf8CStr) -> bool {
    let res = || -> LoggedResult<bool> {
        let mut map = MappedFile::open_rw(file)?;
        let pattern = hex2byte(from.as_bytes());
        let patch = hex2byte(to.as_bytes());

        let v = map.patch(pattern.as_slice(), patch.as_slice());
        for off in &v {
            eprintln!("Patch @ {off:#010X} [{from}] -> [{to}]");
        }
        Ok(!v.is_empty())
    }();
    res.unwrap_or(false)
}

```

`native/src/boot/payload.rs`:

```rs
use crate::compress::get_decoder;
use crate::ffi::check_fmt;
use crate::proto::update_metadata::DeltaArchiveManifest;
use crate::proto::update_metadata::mod_InstallOperation::Type;
use base::{LoggedError, LoggedResult, ReadSeekExt, ResultExt, WriteExt, error};
use byteorder::{BigEndian, ReadBytesExt};
use quick_protobuf::{BytesReader, MessageRead};
use std::fs::File;
use std::io::{BufReader, Cursor, Read, Seek, SeekFrom, Write};
use std::os::fd::FromRawFd;

macro_rules! bad_payload {
    ($msg:literal) => {{
        error!(concat!("Invalid payload: ", $msg));
        LoggedError::default()
    }};
    ($($args:tt)*) => {{
        error!("Invalid payload: {}", format_args!($($args)*));
        LoggedError::default()
    }};
}

const PAYLOAD_MAGIC: &str = "CrAU";

pub fn extract_boot_from_payload(
    in_path: &str,
    partition_name: Option<&str>,
    out_path: Option<&str>,
) -> LoggedResult<()> {
    let mut reader = BufReader::new(if in_path == "-" {
        unsafe { File::from_raw_fd(0) }
    } else {
        File::open(in_path).log_with_msg(|w| write!(w, "Cannot open '{in_path}'"))?
    });

    let buf = &mut [0u8; 4];
    reader.read_exact(buf)?;

    if buf != PAYLOAD_MAGIC.as_bytes() {
        return Err(bad_payload!("invalid magic"));
    }

    let version = reader.read_u64::<BigEndian>()?;
    if version != 2 {
        return Err(bad_payload!("unsupported version: {}", version));
    }

    let manifest_len = reader.read_u64::<BigEndian>()? as usize;
    if manifest_len == 0 {
        return Err(bad_payload!("manifest length is zero"));
    }

    let manifest_sig_len = reader.read_u32::<BigEndian>()?;
    if manifest_sig_len == 0 {
        return Err(bad_payload!("manifest signature length is zero"));
    }

    let mut buf = vec![0; manifest_len];

    let manifest = {
        let manifest = &mut buf[..manifest_len];
        reader.read_exact(manifest)?;
        let mut br = BytesReader::from_bytes(manifest);
        DeltaArchiveManifest::from_reader(&mut br, manifest)?
    };
    if manifest.get_minor_version() != 0 {
        return Err(bad_payload!(
            "delta payloads are not supported, please use a full payload file"
        ));
    }

    let block_size = manifest.get_block_size() as u64;

    let partition = match partition_name {
        None => {
            let boot = manifest
                .partitions
                .iter()
                .find(|p| p.partition_name == "init_boot");
            let boot = match boot {
                Some(boot) => Some(boot),
                None => manifest
                    .partitions
                    .iter()
                    .find(|p| p.partition_name == "boot"),
            };
            boot.ok_or_else(|| bad_payload!("boot partition not found"))?
        }
        Some(name) => manifest
            .partitions
            .iter()
            .find(|p| p.partition_name.as_str() == name)
            .ok_or_else(|| bad_payload!("partition '{}' not found", name))?,
    };

    let out_str: String;
    let out_path = match out_path {
        None => {
            out_str = format!("{}.img", partition.partition_name);
            out_str.as_str()
        }
        Some(s) => s,
    };

    let mut out_file =
        File::create(out_path).log_with_msg(|w| write!(w, "Cannot write to '{out_path}'"))?;

    // Skip the manifest signature
    reader.skip(manifest_sig_len as usize)?;

    // Sort the install operations with data_offset so we will only ever need to seek forward
    // This makes it possible to support non-seekable input file descriptors
    let mut operations = partition.operations.clone();
    operations.sort_by_key(|e| e.data_offset.unwrap_or(0));
    let mut curr_data_offset: u64 = 0;

    for operation in operations.iter() {
        let data_len = operation
            .data_length
            .ok_or_else(|| bad_payload!("data length not found"))? as usize;

        let data_offset = operation
            .data_offset
            .ok_or_else(|| bad_payload!("data offset not found"))?;

        let data_type = operation.type_pb;

        buf.resize(data_len, 0u8);
        let data = &mut buf[..data_len];

        // Skip to the next offset and read data
        let skip = data_offset - curr_data_offset;
        reader.skip(skip as usize)?;
        reader.read_exact(data)?;
        curr_data_offset = data_offset + data_len as u64;

        let out_offset = operation
            .dst_extents
            .first()
            .ok_or_else(|| bad_payload!("dst extents not found"))?
            .start_block
            .ok_or_else(|| bad_payload!("start block not found"))?
            * block_size;

        match data_type {
            Type::REPLACE => {
                out_file.seek(SeekFrom::Start(out_offset))?;
                out_file.write_all(data)?;
            }
            Type::ZERO => {
                for ext in operation.dst_extents.iter() {
                    let out_seek = ext
                        .start_block
                        .ok_or_else(|| bad_payload!("start block not found"))?
                        * block_size;
                    let num_blocks = ext
                        .num_blocks
                        .ok_or_else(|| bad_payload!("num blocks not found"))?;
                    out_file.seek(SeekFrom::Start(out_seek))?;
                    out_file.write_zeros(num_blocks as usize)?;
                }
            }
            Type::REPLACE_BZ | Type::REPLACE_XZ => {
                out_file.seek(SeekFrom::Start(out_offset))?;
                let fmt = check_fmt(data);

                let Ok(_) = || -> std::io::Result<()> {
                    let mut decoder = get_decoder(fmt, Cursor::new(data))?;
                    std::io::copy(decoder.as_mut(), &mut out_file)?;
                    Ok(())
                }() else {
                    return Err(bad_payload!("decompression failed"));
                };
            }
            _ => return Err(bad_payload!("unsupported operation type")),
        };
    }

    Ok(())
}

```

`native/src/boot/proto/update_metadata.proto`:

```proto
//
// Copyright (C) 2010 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Update file format: An update file contains all the operations needed
// to update a system to a specific version. It can be a full payload which
// can update from any version, or a delta payload which can only update
// from a specific version.
// The update format is represented by this struct pseudocode:
// struct delta_update_file {
//   char magic[4] = "CrAU";
//   uint64 file_format_version;  // payload major version
//   uint64 manifest_size;  // Size of protobuf DeltaArchiveManifest
//
//   // Only present if format_version >= 2:
//   uint32 metadata_signature_size;
//
//   // The DeltaArchiveManifest protobuf serialized, not compressed.
//   char manifest[manifest_size];
//
//   // The signature of the metadata (from the beginning of the payload up to
//   // this location, not including the signature itself). This is a serialized
//   // Signatures message.
//   char metadata_signature_message[metadata_signature_size];
//
//   // Data blobs for files, no specific format. The specific offset
//   // and length of each data blob is recorded in the DeltaArchiveManifest.
//   struct {
//     char data[];
//   } blobs[];
//
//   // The signature of the entire payload, everything up to this location,
//   // except that metadata_signature_message is skipped to simplify signing
//   // process. These two are not signed:
//   uint64 payload_signatures_message_size;
//   // This is a serialized Signatures message.
//   char payload_signatures_message[payload_signatures_message_size];
//
// };
// The DeltaArchiveManifest protobuf is an ordered list of InstallOperation
// objects. These objects are stored in a linear array in the
// DeltaArchiveManifest. Each operation is applied in order by the client.
// The DeltaArchiveManifest also contains the initial and final
// checksums for the device.
// The client will perform each InstallOperation in order, beginning even
// before the entire delta file is downloaded (but after at least the
// protobuf is downloaded). The types of operations are explained:
// - REPLACE: Replace the dst_extents on the drive with the attached data,
//   zero padding out to block size.
// - REPLACE_BZ: bzip2-uncompress the attached data and write it into
//   dst_extents on the drive, zero padding to block size.
// - MOVE: Copy the data in src_extents to dst_extents. Extents may overlap,
//   so it may be desirable to read all src_extents data into memory before
//   writing it out. (deprecated)
// - SOURCE_COPY: Copy the data in src_extents in the old partition to
//   dst_extents in the new partition. There's no overlapping of data because
//   the extents are in different partitions.
// - BSDIFF: Read src_length bytes from src_extents into memory, perform
//   bspatch with attached data, write new data to dst_extents, zero padding
//   to block size. (deprecated)
// - SOURCE_BSDIFF: Read the data in src_extents in the old partition, perform
//   bspatch with the attached data and write the new data to dst_extents in the
//   new partition.
// - ZERO: Write zeros to the destination dst_extents.
// - DISCARD: Discard the destination dst_extents blocks on the physical medium.
//   the data read from those blocks is undefined.
// - REPLACE_XZ: Replace the dst_extents with the contents of the attached
//   xz file after decompression. The xz file should only use crc32 or no crc at
//   all to be compatible with xz-embedded.
// - PUFFDIFF: Read the data in src_extents in the old partition, perform
//   puffpatch with the attached data and write the new data to dst_extents in
//   the new partition.
//
// The operations allowed in the payload (supported by the client) depend on the
// major and minor version. See InstallOperation.Type below for details.
syntax = "proto2";
package chromeos_update_engine;
// Data is packed into blocks on disk, always starting from the beginning
// of the block. If a file's data is too large for one block, it overflows
// into another block, which may or may not be the following block on the
// physical partition. An ordered list of extents is another
// representation of an ordered list of blocks. For example, a file stored
// in blocks 9, 10, 11, 2, 18, 12 (in that order) would be stored in
// extents { {9, 3}, {2, 1}, {18, 1}, {12, 1} } (in that order).
// In general, files are stored sequentially on disk, so it's more efficient
// to use extents to encode the block lists (this is effectively
// run-length encoding).
// A sentinel value (kuint64max) as the start block denotes a sparse-hole
// in a file whose block-length is specified by num_blocks.
message Extent {
  optional uint64 start_block = 1;
  optional uint64 num_blocks = 2;
}
// Signatures: Updates may be signed by the OS vendor. The client verifies
// an update's signature by hashing the entire download. The section of the
// download that contains the signature is at the end of the file, so when
// signing a file, only the part up to the signature part is signed.
// Then, the client looks inside the download's Signatures message for a
// Signature message that it knows how to handle. Generally, a client will
// only know how to handle one type of signature, but an update may contain
// many signatures to support many different types of client. Then client
// selects a Signature message and uses that, along with a known public key,
// to verify the download. The public key is expected to be part of the
// client.
message Signatures {
  message Signature {
    optional uint32 version = 1 [deprecated = true];
    optional bytes data = 2;
    // The DER encoded signature size of EC keys is nondeterministic for
    // different input of sha256 hash. However, we need the size of the
    // serialized signatures protobuf string to be fixed before signing;
    // because this size is part of the content to be signed. Therefore, we
    // always pad the signature data to the maximum possible signature size of
    // a given key. And the payload verifier will truncate the signature to
    // its correct size based on the value of |unpadded_signature_size|.
    optional fixed32 unpadded_signature_size = 3;
  }
  repeated Signature signatures = 1;
}
message PartitionInfo {
  optional uint64 size = 1;
  optional bytes hash = 2;
}
message InstallOperation {
  enum Type {
    REPLACE = 0;     // Replace destination extents w/ attached data.
    REPLACE_BZ = 1;  // Replace destination extents w/ attached bzipped data.
    MOVE = 2 [deprecated = true];    // Move source extents to target extents.
    BSDIFF = 3 [deprecated = true];  // The data is a bsdiff binary diff.
    // On minor version 2 or newer, these operations are supported:
    SOURCE_COPY = 4;    // Copy from source to target partition
    SOURCE_BSDIFF = 5;  // Like BSDIFF, but read from source partition
    // On minor version 3 or newer and on major version 2 or newer, these
    // operations are supported:
    REPLACE_XZ = 8;  // Replace destination extents w/ attached xz data.
    // On minor version 4 or newer, these operations are supported:
    ZERO = 6;     // Write zeros in the destination.
    DISCARD = 7;  // Discard the destination blocks, reading as undefined.
    BROTLI_BSDIFF = 10;  // Like SOURCE_BSDIFF, but compressed with brotli.
    // On minor version 5 or newer, these operations are supported:
    PUFFDIFF = 9;  // The data is in puffdiff format.
    // On minor version 8 or newer, these operations are supported:
    ZUCCHINI = 11;
    // On minor version 9 or newer, these operations are supported:
    LZ4DIFF_BSDIFF = 12;
    LZ4DIFF_PUFFDIFF = 13;
  }
  required Type type = 1;
  // Only minor version 6 or newer support 64 bits |data_offset| and
  // |data_length|, older client will read them as uint32.
  // The offset into the delta file (after the protobuf)
  // where the data (if any) is stored
  optional uint64 data_offset = 2;
  // The length of the data in the delta file
  optional uint64 data_length = 3;
  // Ordered list of extents that are read from (if any) and written to.
  repeated Extent src_extents = 4;
  // Byte length of src, equal to the number of blocks in src_extents *
  // block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
  // pass that external program the number of bytes to read from the blocks we
  // pass it.  This is not used in any other operation.
  optional uint64 src_length = 5;
  repeated Extent dst_extents = 6;
  // Byte length of dst, equal to the number of blocks in dst_extents *
  // block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
  // operation.
  optional uint64 dst_length = 7;
  // Optional SHA 256 hash of the blob associated with this operation.
  // This is used as a primary validation for http-based downloads and
  // as a defense-in-depth validation for https-based downloads. If
  // the operation doesn't refer to any blob, this field will have
  // zero bytes.
  optional bytes data_sha256_hash = 8;
  // Indicates the SHA 256 hash of the source data referenced in src_extents at
  // the time of applying the operation. If present, the update_engine daemon
  // MUST read and verify the source data before applying the operation.
  optional bytes src_sha256_hash = 9;
}
// Hints to VAB snapshot to skip writing some blocks if these blocks are
// identical to the ones on the source image. The src & dst extents for each
// CowMergeOperation should be contiguous, and they're a subset of an OTA
// InstallOperation.
// During merge time, we need to follow the pre-computed sequence to avoid
// read after write, similar to the inplace update schema.
message CowMergeOperation {
  enum Type {
    COW_COPY = 0;     // identical blocks
    COW_XOR = 1;      // used when src/dst blocks are highly similar
    COW_REPLACE = 2;  // Raw replace operation
  }
  optional Type type = 1;
  optional Extent src_extent = 2;
  optional Extent dst_extent = 3;
  // For COW_XOR, source location might be unaligned, so this field is in range
  // [0, block_size), representing how much should the src_extent shift toward
  // larger block number. If this field is non-zero, then src_extent will
  // include 1 extra block in the end, as the merge op actually references the
  // first |src_offset| bytes of that extra block. For example, if |dst_extent|
  // is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
  // Note that |src_extent| contains 1 extra block than the |dst_extent|.
  optional uint32 src_offset = 4;
}
// Describes the update to apply to a single partition.
message PartitionUpdate {
  // A platform-specific name to identify the partition set being updated. For
  // example, in Chrome OS this could be "ROOT" or "KERNEL".
  required string partition_name = 1;
  // Whether this partition carries a filesystem with post-install program that
  // must be run to finalize the update process. See also |postinstall_path| and
  // |filesystem_type|.
  optional bool run_postinstall = 2;
  // The path of the executable program to run during the post-install step,
  // relative to the root of this filesystem. If not set, the default "postinst"
  // will be used. This setting is only used when |run_postinstall| is set and
  // true.
  optional string postinstall_path = 3;
  // The filesystem type as passed to the mount(2) syscall when mounting the new
  // filesystem to run the post-install program. If not set, a fixed list of
  // filesystems will be attempted. This setting is only used if
  // |run_postinstall| is set and true.
  optional string filesystem_type = 4;
  // If present, a list of signatures of the new_partition_info.hash signed with
  // different keys. If the update_engine daemon requires vendor-signed images
  // and has its public key installed, one of the signatures should be valid
  // for /postinstall to run.
  repeated Signatures.Signature new_partition_signature = 5;
  optional PartitionInfo old_partition_info = 6;
  optional PartitionInfo new_partition_info = 7;
  // The list of operations to be performed to apply this PartitionUpdate. The
  // associated operation blobs (in operations[i].data_offset, data_length)
  // should be stored contiguously and in the same order.
  repeated InstallOperation operations = 8;
  // Whether a failure in the postinstall step for this partition should be
  // ignored.
  optional bool postinstall_optional = 9;
  // On minor version 6 or newer, these fields are supported:
  // The extent for data covered by verity hash tree.
  optional Extent hash_tree_data_extent = 10;
  // The extent to store verity hash tree.
  optional Extent hash_tree_extent = 11;
  // The hash algorithm used in verity hash tree.
  optional string hash_tree_algorithm = 12;
  // The salt used for verity hash tree.
  optional bytes hash_tree_salt = 13;
  // The extent for data covered by FEC.
  optional Extent fec_data_extent = 14;
  // The extent to store FEC.
  optional Extent fec_extent = 15;
  // The number of FEC roots.
  optional uint32 fec_roots = 16 [default = 2];
  // Per-partition version used for downgrade detection, added
  // as an effort to support partial updates. For most partitions,
  // this is the build timestamp.
  optional string version = 17;
  // A sorted list of CowMergeOperation. When writing cow, we can choose to
  // skip writing the raw bytes for these extents. During snapshot merge, the
  // bytes will read from the source partitions instead.
  repeated CowMergeOperation merge_operations = 18;
  // Estimated size for COW image. This is used by libsnapshot
  // as a hint. If set to 0, libsnapshot should use alternative
  // methods for estimating size.
  optional uint64 estimate_cow_size = 19;
}
message DynamicPartitionGroup {
  // Name of the group.
  required string name = 1;
  // Maximum size of the group. The sum of sizes of all partitions in the group
  // must not exceed the maximum size of the group.
  optional uint64 size = 2;
  // A list of partitions that belong to the group.
  repeated string partition_names = 3;
}
message VABCFeatureSet {
  optional bool threaded = 1;
  optional bool batch_writes = 2;
}
// Metadata related to all dynamic partitions.
message DynamicPartitionMetadata {
  // All updatable groups present in |partitions| of this DeltaArchiveManifest.
  // - If an updatable group is on the device but not in the manifest, it is
  //   not updated. Hence, the group will not be resized, and partitions cannot
  //   be added to or removed from the group.
  // - If an updatable group is in the manifest but not on the device, the group
  //   is added to the device.
  repeated DynamicPartitionGroup groups = 1;
  // Whether dynamic partitions have snapshots during the update. If this is
  // set to true, the update_engine daemon creates snapshots for all dynamic
  // partitions if possible. If this is unset, the update_engine daemon MUST
  // NOT create snapshots for dynamic partitions.
  optional bool snapshot_enabled = 2;
  // If this is set to false, update_engine should not use VABC regardless. If
  // this is set to true, update_engine may choose to use VABC if device
  // supports it, but not guaranteed.
  // VABC stands for Virtual AB Compression
  optional bool vabc_enabled = 3;
  // The compression algorithm used by VABC. Available ones are "gz", "brotli".
  // See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
  // as this parameter is ultimated forwarded to libsnapshot's CowWriter
  optional string vabc_compression_param = 4;
  // COW version used by VABC. The represents the major version in the COW
  // header
  optional uint32 cow_version = 5;
  // A collection of knobs to tune Virtual AB Compression
  optional VABCFeatureSet vabc_feature_set = 6;
}
// Definition has been duplicated from
// $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
message ApexInfo {
  optional string package_name = 1;
  optional int64 version = 2;
  optional bool is_compressed = 3;
  optional int64 decompressed_size = 4;
}
// Definition has been duplicated from
// $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
message ApexMetadata {
  repeated ApexInfo apex_info = 1;
}
message DeltaArchiveManifest {
  // Only present in major version = 1. List of install operations for the
  // kernel and rootfs partitions. For major version = 2 see the |partitions|
  // field.
  reserved 1, 2;
  // (At time of writing) usually 4096
  optional uint32 block_size = 3 [default = 4096];
  // If signatures are present, the offset into the blobs, generally
  // tacked onto the end of the file, and the length. We use an offset
  // rather than a bool to allow for more flexibility in future file formats.
  // If either is absent, it means signatures aren't supported in this
  // file.
  optional uint64 signatures_offset = 4;
  optional uint64 signatures_size = 5;
  // Fields deprecated in major version 2.
  reserved 6,7,8,9,10,11;
  // The minor version, also referred as "delta version", of the payload.
  // Minor version 0 is full payload, everything else is delta payload.
  optional uint32 minor_version = 12 [default = 0];
  // Only present in major version >= 2. List of partitions that will be
  // updated, in the order they will be updated. This field replaces the
  // |install_operations|, |kernel_install_operations| and the
  // |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
  // array can have more than two partitions if needed, and they are identified
  // by the partition name.
  repeated PartitionUpdate partitions = 13;
  // The maximum timestamp of the OS allowed to apply this payload.
  // Can be used to prevent downgrading the OS.
  optional int64 max_timestamp = 14;
  // Metadata related to all dynamic partitions.
  optional DynamicPartitionMetadata dynamic_partition_metadata = 15;
  // If the payload only updates a subset of partitions on the device.
  optional bool partial_update = 16;
  // Information on compressed APEX to figure out how much space is required for
  // their decompression
  repeated ApexInfo apex_info = 17;
  // Security patch level of the device, usually in the format of
  // yyyy-mm-dd
  optional string security_patch_level = 18;
}

```

`native/src/boot/sign.rs`:

```rs
use der::referenced::OwnedToRef;
use der::{Decode, DecodePem, Encode, Sequence, SliceReader};
use digest::DynDigest;
use p256::ecdsa::{
    Signature as P256Signature, SigningKey as P256SigningKey, VerifyingKey as P256VerifyingKey,
};
use p256::pkcs8::DecodePrivateKey;
use p384::ecdsa::{
    Signature as P384Signature, SigningKey as P384SigningKey, VerifyingKey as P384VerifyingKey,
};
use p521::ecdsa::{
    Signature as P521Signature, SigningKey as P521SigningKey, VerifyingKey as P521VerifyingKey,
};
use rsa::pkcs1v15::{
    Signature as RsaSignature, SigningKey as RsaSigningKey, VerifyingKey as RsaVerifyingKey,
};
use rsa::pkcs8::SubjectPublicKeyInfoRef;
use rsa::signature::SignatureEncoding;
use rsa::signature::hazmat::{PrehashSigner, PrehashVerifier};
use rsa::{RsaPrivateKey, RsaPublicKey};
use sha1::Sha1;
use sha2::{Sha256, Sha384, Sha512};
use x509_cert::Certificate;
use x509_cert::der::Any;
use x509_cert::der::asn1::{OctetString, PrintableString};
use x509_cert::spki::AlgorithmIdentifier;

use base::{LoggedResult, MappedFile, ResultExt, SilentLogExt, Utf8CStr, cstr, log_err};

use crate::ffi::BootImage;

#[allow(clippy::upper_case_acronyms)]
pub enum SHA {
    SHA1(Sha1),
    SHA256(Sha256),
}

impl SHA {
    pub fn update(&mut self, data: &[u8]) {
        match self {
            SHA::SHA1(h) => h.update(data),
            SHA::SHA256(h) => h.update(data),
        }
    }

    pub fn output_size(&self) -> usize {
        match self {
            SHA::SHA1(h) => h.output_size(),
            SHA::SHA256(h) => h.output_size(),
        }
    }

    pub fn finalize_into(&mut self, out: &mut [u8]) {
        match self {
            SHA::SHA1(h) => h.finalize_into_reset(out),
            SHA::SHA256(h) => h.finalize_into_reset(out),
        }
        .ok();
    }
}

pub fn get_sha(use_sha1: bool) -> Box<SHA> {
    Box::new(if use_sha1 {
        SHA::SHA1(Sha1::default())
    } else {
        SHA::SHA256(Sha256::default())
    })
}

pub fn sha1_hash(data: &[u8], out: &mut [u8]) {
    let mut h = Sha1::default();
    h.update(data);
    DynDigest::finalize_into(h, out).ok();
}

pub fn sha256_hash(data: &[u8], out: &mut [u8]) {
    let mut h = Sha256::default();
    h.update(data);
    DynDigest::finalize_into(h, out).ok();
}

#[allow(clippy::large_enum_variant)]
enum SigningKey {
    SHA256withRSA(RsaSigningKey<Sha256>),
    SHA256withECDSA(P256SigningKey),
    SHA384withECDSA(P384SigningKey),
    SHA521withECDSA(P521SigningKey),
}

#[allow(clippy::large_enum_variant)]
enum VerifyingKey {
    SHA256withRSA(RsaVerifyingKey<Sha256>),
    SHA256withECDSA(P256VerifyingKey),
    SHA384withECDSA(P384VerifyingKey),
    SHA521withECDSA(P521VerifyingKey),
}

struct Verifier {
    digest: Box<dyn DynDigest>,
    key: VerifyingKey,
}

impl Verifier {
    fn from_public_key(key: SubjectPublicKeyInfoRef) -> LoggedResult<Verifier> {
        let digest: Box<dyn DynDigest>;
        let key = if let Ok(rsa) = RsaPublicKey::try_from(key.clone()) {
            digest = Box::<Sha256>::default();
            VerifyingKey::SHA256withRSA(RsaVerifyingKey::<Sha256>::new(rsa))
        } else if let Ok(ec) = P256VerifyingKey::try_from(key.clone()) {
            digest = Box::<Sha256>::default();
            VerifyingKey::SHA256withECDSA(ec)
        } else if let Ok(ec) = P384VerifyingKey::try_from(key.clone()) {
            digest = Box::<Sha384>::default();
            VerifyingKey::SHA384withECDSA(ec)
        } else if let Ok(ec) = P521VerifyingKey::try_from(key.clone()) {
            digest = Box::<Sha512>::default();
            VerifyingKey::SHA521withECDSA(ec)
        } else {
            return log_err!("Unsupported private key");
        };
        Ok(Verifier { digest, key })
    }

    fn update(&mut self, data: &[u8]) {
        self.digest.update(data)
    }

    fn verify(mut self, signature: &[u8]) -> LoggedResult<()> {
        let hash = self.digest.finalize_reset();
        match &self.key {
            VerifyingKey::SHA256withRSA(key) => {
                let sig = RsaSignature::try_from(signature)?;
                key.verify_prehash(hash.as_ref(), &sig).log()
            }
            VerifyingKey::SHA256withECDSA(key) => {
                let sig = P256Signature::from_slice(signature)?;
                key.verify_prehash(hash.as_ref(), &sig).log()
            }
            VerifyingKey::SHA384withECDSA(key) => {
                let sig = P384Signature::from_slice(signature)?;
                key.verify_prehash(hash.as_ref(), &sig).log()
            }
            VerifyingKey::SHA521withECDSA(key) => {
                let sig = P521Signature::from_slice(signature)?;
                key.verify_prehash(hash.as_ref(), &sig).log()
            }
        }
    }
}

struct Signer {
    digest: Box<dyn DynDigest>,
    key: SigningKey,
}

impl Signer {
    fn from_private_key(key: &[u8]) -> LoggedResult<Signer> {
        let digest: Box<dyn DynDigest>;
        let key = match RsaPrivateKey::from_pkcs8_der(key) {
            Ok(rsa) => {
                digest = Box::<Sha256>::default();
                SigningKey::SHA256withRSA(RsaSigningKey::<Sha256>::new(rsa))
            }
            _ => match P256SigningKey::from_pkcs8_der(key) {
                Ok(ec) => {
                    digest = Box::<Sha256>::default();
                    SigningKey::SHA256withECDSA(ec)
                }
                _ => match P384SigningKey::from_pkcs8_der(key) {
                    Ok(ec) => {
                        digest = Box::<Sha384>::default();
                        SigningKey::SHA384withECDSA(ec)
                    }
                    _ => match P521SigningKey::from_pkcs8_der(key) {
                        Ok(ec) => {
                            digest = Box::<Sha512>::default();
                            SigningKey::SHA521withECDSA(ec)
                        }
                        _ => {
                            return log_err!("Unsupported private key");
                        }
                    },
                },
            },
        };
        Ok(Signer { digest, key })
    }

    fn update(&mut self, data: &[u8]) {
        self.digest.update(data)
    }

    fn sign(mut self) -> LoggedResult<Vec<u8>> {
        let hash = self.digest.finalize_reset();
        let v = match &self.key {
            SigningKey::SHA256withRSA(key) => {
                let sig: RsaSignature = key.sign_prehash(hash.as_ref())?;
                sig.to_vec()
            }
            SigningKey::SHA256withECDSA(key) => {
                let sig: P256Signature = key.sign_prehash(hash.as_ref())?;
                sig.to_vec()
            }
            SigningKey::SHA384withECDSA(key) => {
                let sig: P384Signature = key.sign_prehash(hash.as_ref())?;
                sig.to_vec()
            }
            SigningKey::SHA521withECDSA(key) => {
                let sig: P521Signature = key.sign_prehash(hash.as_ref())?;
                sig.to_vec()
            }
        };
        Ok(v)
    }
}

/*
 * BootSignature ::= SEQUENCE {
 *     formatVersion ::= INTEGER,
 *     certificate ::= Certificate,
 *     algorithmIdentifier ::= SEQUENCE {
 *         algorithm OBJECT IDENTIFIER,
 *         parameters ANY DEFINED BY algorithm OPTIONAL
 *     },
 *     authenticatedAttributes ::= SEQUENCE {
 *         target CHARACTER STRING,
 *         length INTEGER
 *     },
 *     signature ::= OCTET STRING
 * }
 */

#[derive(Sequence)]
struct AuthenticatedAttributes {
    target: PrintableString,
    length: u64,
}

#[derive(Sequence)]
struct BootSignature {
    format_version: i32,
    certificate: Certificate,
    algorithm_identifier: AlgorithmIdentifier<Any>,
    authenticated_attributes: AuthenticatedAttributes,
    signature: OctetString,
}

impl BootSignature {
    fn verify(self, payload: &[u8]) -> LoggedResult<()> {
        if self.authenticated_attributes.length as usize != payload.len() {
            return log_err!("Invalid image size");
        }
        let mut verifier = Verifier::from_public_key(
            self.certificate
                .tbs_certificate()
                .subject_public_key_info()
                .owned_to_ref(),
        )?;
        verifier.update(payload);
        let attr = self.authenticated_attributes.to_der()?;
        verifier.update(attr.as_slice());
        verifier.verify(self.signature.as_bytes())?;
        Ok(())
    }
}

impl BootImage {
    pub fn verify(&self, cert: Option<&Utf8CStr>) -> LoggedResult<()> {
        let tail = self.tail();
        if tail.starts_with(b"AVB0") {
            return log_err!();
        }

        // Don't use BootSignature::from_der because tail might have trailing zeros
        let mut reader = SliceReader::new(tail)?;
        let mut sig = BootSignature::decode(&mut reader).silent()?;
        if let Some(s) = cert {
            let pem = MappedFile::open(s)?;
            sig.certificate = Certificate::from_pem(pem)?;
        };

        sig.verify(self.payload()).log()
    }

    pub fn verify_for_cxx(&self) -> bool {
        self.verify(None).is_ok()
    }
}

enum Bytes {
    Mapped(MappedFile),
    Slice(&'static [u8]),
}

impl AsRef<[u8]> for Bytes {
    fn as_ref(&self) -> &[u8] {
        match self {
            Bytes::Mapped(m) => m.as_ref(),
            Bytes::Slice(s) => s,
        }
    }
}

const VERITY_PEM: &[u8] = include_bytes!("../../../tools/keys/verity.x509.pem");
const VERITY_PK8: &[u8] = include_bytes!("../../../tools/keys/verity.pk8");

pub fn sign_boot_image(
    payload: &[u8],
    name: &Utf8CStr,
    cert: Option<&Utf8CStr>,
    key: Option<&Utf8CStr>,
) -> LoggedResult<Vec<u8>> {
    let cert = match cert {
        Some(s) => Bytes::Mapped(MappedFile::open(s)?),
        None => Bytes::Slice(VERITY_PEM),
    };
    let key = match key {
        Some(s) => Bytes::Mapped(MappedFile::open(s)?),
        None => Bytes::Slice(VERITY_PK8),
    };

    // Parse cert and private key
    let cert = Certificate::from_pem(cert)?;
    let mut signer = Signer::from_private_key(key.as_ref())?;

    // Sign image
    let attr = AuthenticatedAttributes {
        target: PrintableString::new(name.as_bytes())?,
        length: payload.len() as u64,
    };
    signer.update(payload);
    signer.update(attr.to_der()?.as_slice());
    let sig = signer.sign()?;

    // Create BootSignature DER
    let alg_id = cert.signature_algorithm().clone();
    let sig = BootSignature {
        format_version: 1,
        certificate: cert,
        algorithm_identifier: alg_id,
        authenticated_attributes: attr,
        signature: OctetString::new(sig)?,
    };
    sig.to_der().log()
}

pub fn sign_payload_for_cxx(payload: &[u8]) -> Vec<u8> {
    sign_boot_image(payload, cstr!("/boot"), None, None).unwrap_or_default()
}

```

`native/src/core/Cargo.toml`:

```toml
[package]
name = "magisk"
version.workspace = true
edition.workspace = true

[lib]
crate-type = ["staticlib"]
path = "lib.rs"

[features]
default = ["check-signature", "check-client", "su-check-db"]

# Disable these features for easier debugging during development
check-signature = []
check-client = []
su-check-db = []

[lints]
workspace = true

[build-dependencies]
cxx-gen = { workspace = true }
pb-rs = { workspace = true }

[dependencies]
base = { workspace = true, features = ["selinux"] }
cxx = { workspace = true }
num-traits = { workspace = true }
num-derive = { workspace = true }
quick-protobuf = { workspace = true }
bytemuck = { workspace = true, features = ["derive"] }
thiserror = { workspace = true }
bit-set = { workspace = true }
nix = { workspace = true, features = ["fs", "mount", "poll", "signal", "term", "user", "zerocopy"] }
bitflags = { workspace = true }

```

`native/src/core/applet_stub.cpp`:

```cpp
#include <core.hpp>

int main(int argc, char *argv[]) {
    if (argc < 1)
        return 1;
    cmdline_logging();
    init_argv0(argc, argv);
    umask(0);
    return APPLET_STUB_MAIN(argc, argv);
}

```

`native/src/core/applets.cpp`:

```cpp
#include <libgen.h>
#include <sys/stat.h>

#include <core.hpp>

using namespace std;

struct Applet {
    string_view name;
    int (*fn)(int, char *[]);
};

constexpr Applet applets[] = {
    { "su", su_client_main },
    { "resetprop", resetprop_main },
};

constexpr Applet private_applets[] = {
    { "zygisk", zygisk_main },
};

int main(int argc, char *argv[]) {
    if (argc < 1)
        return 1;

    cmdline_logging();
    init_argv0(argc, argv);

    Utf8CStr argv0 = basename(argv[0]);

    umask(0);

    if (argv[0][0] == '\0') {
        // When argv[0] is an empty string, we're calling private applets
        if (argc < 2)
            return 1;
        --argc;
        ++argv;
        for (const auto &app : private_applets) {
            if (argv[0] == app.name) {
                return app.fn(argc, argv);
            }
        }
        fprintf(stderr, "%s: applet not found\n", argv[0]);
        return 1;
    }

    if (argv0 == "magisk" || argv0 == "magisk32" || argv0 == "magisk64") {
        if (argc > 1 && argv[1][0] != '-') {
            // Calling applet with "magisk [applet] args..."
            --argc;
            ++argv;
            argv0 = argv[0];
        } else {
            return magisk_main(argc, argv);
        }
    }

    for (const auto &app : applets) {
        if (argv0 == app.name) {
            return app.fn(argc, argv);
        }
    }
    fprintf(stderr, "%s: applet not found\n", argv0.c_str());
    return 1;
}

```

`native/src/core/bootstages.rs`:

```rs
use crate::consts::{APP_PACKAGE_NAME, BBPATH, DATABIN, MODULEROOT, SECURE_DIR};
use crate::daemon::MagiskD;
use crate::ffi::{
    DbEntryKey, RequestCode, check_key_combo, exec_common_scripts, exec_module_scripts,
    get_magisk_tmp, initialize_denylist,
};
use crate::logging::setup_logfile;
use crate::module::disable_modules;
use crate::mount::{clean_mounts, setup_preinit_dir};
use crate::resetprop::get_prop;
use crate::selinux::restorecon;
use base::const_format::concatcp;
use base::{BufReadExt, FsPathBuilder, ResultExt, cstr, error, info};
use bitflags::bitflags;
use nix::fcntl::OFlag;
use std::io::BufReader;
use std::os::unix::net::UnixStream;
use std::process::{Command, Stdio};
use std::sync::atomic::Ordering;

bitflags! {
    #[derive(Default)]
    pub struct BootState : u32 {
        const PostFsDataDone = 1 << 0;
        const LateStartDone = 1 << 1;
        const BootComplete = 1 << 2;
        const SafeMode = 1 << 3;
    }
}

impl MagiskD {
    fn setup_magisk_env(&self) -> bool {
        info!("* Initializing Magisk environment");

        let mut buf = cstr::buf::default();

        let app_bin_dir = buf
            .append_path(self.app_data_dir())
            .append_path("0")
            .append_path(APP_PACKAGE_NAME)
            .append_path("install");

        // Alternative binaries paths
        let alt_bin_dirs = &[
            cstr!("/cache/data_adb/magisk"),
            cstr!("/data/magisk"),
            app_bin_dir,
        ];
        for dir in alt_bin_dirs {
            if dir.exists() {
                cstr!(DATABIN).remove_all().ok();
                dir.copy_to(cstr!(DATABIN)).ok();
                dir.remove_all().ok();
            }
        }
        cstr!("/cache/data_adb").remove_all().ok();

        // Directories in /data/adb
        cstr!(SECURE_DIR).follow_link().chmod(0o700).log_ok();
        cstr!(DATABIN).mkdir(0o755).log_ok();
        cstr!(MODULEROOT).mkdir(0o755).log_ok();
        cstr!(concatcp!(SECURE_DIR, "/post-fs-data.d"))
            .mkdir(0o755)
            .log_ok();
        cstr!(concatcp!(SECURE_DIR, "/service.d"))
            .mkdir(0o755)
            .log_ok();
        restorecon();

        let busybox = cstr!(concatcp!(DATABIN, "/busybox"));
        if !busybox.exists() {
            return false;
        }

        let tmp_bb = buf.append_path(get_magisk_tmp()).append_path(BBPATH);
        tmp_bb.mkdirs(0o755).ok();
        tmp_bb.append_path("busybox");
        busybox.copy_to(tmp_bb).ok();
        tmp_bb.follow_link().chmod(0o755).log_ok();

        // Install busybox applets
        Command::new(&tmp_bb)
            .arg("--install")
            .arg("-s")
            .arg(tmp_bb.parent_dir().unwrap_or_default())
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .status()
            .log_ok();

        // magisk32 and magiskpolicy are not installed into ramdisk and has to be copied
        // from data to magisk tmp
        let magisk32 = cstr!(concatcp!(DATABIN, "/magisk32"));
        if magisk32.exists() {
            let tmp = buf.append_path(get_magisk_tmp()).append_path("magisk32");
            magisk32.copy_to(tmp).log_ok();
        }
        let magiskpolicy = cstr!(concatcp!(DATABIN, "/magiskpolicy"));
        if magiskpolicy.exists() {
            let tmp = buf
                .append_path(get_magisk_tmp())
                .append_path("magiskpolicy");
            magiskpolicy.copy_to(tmp).log_ok();
        }

        true
    }

    fn post_fs_data(&self) -> bool {
        setup_logfile();
        info!("** post-fs-data mode running");

        self.preserve_stub_apk();

        // Check secure dir
        let secure_dir = cstr!(SECURE_DIR);
        if !secure_dir.exists() {
            if self.sdk_int < 24 {
                secure_dir.mkdir(0o700).log_ok();
            } else {
                error!("* {} is not present, abort", SECURE_DIR);
                return true;
            }
        }

        self.prune_su_access();

        if !self.setup_magisk_env() {
            error!("* Magisk environment incomplete, abort");
            return true;
        }

        // Check safe mode
        let boot_cnt = self.get_db_setting(DbEntryKey::BootloopCount);
        self.set_db_setting(DbEntryKey::BootloopCount, boot_cnt + 1)
            .log()
            .ok();
        let safe_mode = boot_cnt >= 2
            || get_prop(cstr!("persist.sys.safemode")) == "1"
            || get_prop(cstr!("ro.sys.safemode")) == "1"
            || check_key_combo();

        if safe_mode {
            info!("* Safe mode triggered");
            // Disable all modules and zygisk so next boot will be clean
            disable_modules();
            self.set_db_setting(DbEntryKey::ZygiskConfig, 0).log_ok();
            return true;
        }

        exec_common_scripts(cstr!("post-fs-data"));
        self.zygisk_enabled.store(
            self.get_db_setting(DbEntryKey::ZygiskConfig) != 0,
            Ordering::Release,
        );
        initialize_denylist();
        self.handle_modules();
        clean_mounts();

        false
    }

    fn late_start(&self) {
        setup_logfile();
        info!("** late_start service mode running");

        exec_common_scripts(cstr!("service"));
        if let Some(module_list) = self.module_list.get() {
            exec_module_scripts(cstr!("service"), module_list);
        }
    }

    fn boot_complete(&self) {
        setup_logfile();
        info!("** boot-complete triggered");

        // Reset the bootloop counter once we have boot-complete
        self.set_db_setting(DbEntryKey::BootloopCount, 0).log_ok();

        // At this point it's safe to create the folder
        let secure_dir = cstr!(SECURE_DIR);
        if !secure_dir.exists() {
            secure_dir.mkdir(0o700).log_ok();
        }

        setup_preinit_dir();
        self.ensure_manager();
        if self.zygisk_enabled.load(Ordering::Relaxed) {
            self.zygisk.lock().reset(true);
        }
    }

    pub fn boot_stage_handler(&self, client: UnixStream, code: RequestCode) {
        // Make sure boot stage execution is always serialized
        let mut state = self.boot_stage_lock.lock();

        match code {
            RequestCode::POST_FS_DATA => {
                if check_data() && !state.contains(BootState::PostFsDataDone) {
                    if self.post_fs_data() {
                        state.insert(BootState::SafeMode);
                    }
                    state.insert(BootState::PostFsDataDone);
                }
            }
            RequestCode::LATE_START => {
                drop(client);
                if state.contains(BootState::PostFsDataDone) && !state.contains(BootState::SafeMode)
                {
                    self.late_start();
                    state.insert(BootState::LateStartDone);
                }
            }
            RequestCode::BOOT_COMPLETE => {
                drop(client);
                if state.contains(BootState::PostFsDataDone) {
                    state.insert(BootState::BootComplete);
                    self.boot_complete()
                }
            }
            _ => {}
        }
    }
}

fn check_data() -> bool {
    if let Ok(file) = cstr!("/proc/mounts").open(OFlag::O_RDONLY | OFlag::O_CLOEXEC) {
        let mut mnt = false;
        BufReader::new(file).for_each_line(|line| {
            if line.contains(" /data ") && !line.contains("tmpfs") {
                mnt = true;
                return false;
            }
            true
        });
        if !mnt {
            return false;
        }
        let crypto = get_prop(cstr!("ro.crypto.state"));
        return if !crypto.is_empty() {
            if crypto != "encrypted" {
                // Unencrypted, we can directly access data
                true
            } else {
                // Encrypted, check whether vold is started
                !get_prop(cstr!("init.svc.vold")).is_empty()
            }
        } else {
            // ro.crypto.state is not set, assume it's unencrypted
            true
        };
    }
    false
}

```

`native/src/core/build.rs`:

```rs
use pb_rs::ConfigBuilder;
use pb_rs::types::FileDescriptor;

use crate::codegen::gen_cxx_binding;

#[path = "../include/codegen.rs"]
mod codegen;

#[allow(clippy::unwrap_used)]
fn main() {
    println!("cargo:rerun-if-changed=resetprop/proto/persistent_properties.proto");

    gen_cxx_binding("core-rs");

    let cb = ConfigBuilder::new(
        &["resetprop/proto/persistent_properties.proto"],
        None,
        Some(&"resetprop/proto"),
        &["."],
    )
    .unwrap();
    FileDescriptor::run(
        &cb.single_module(true)
            .dont_use_cow(true)
            .generate_getters(true)
            .build(),
    )
    .unwrap();
}

```

`native/src/core/daemon.rs`:

```rs
use crate::bootstages::BootState;
use crate::consts::{
    MAGISK_FILE_CON, MAGISK_FULL_VER, MAGISK_PROC_CON, MAGISK_VER_CODE, MAGISK_VERSION,
    MAIN_CONFIG, MAIN_SOCKET, ROOTMNT, ROOTOVL,
};
use crate::db::Sqlite3;
use crate::ffi::{
    ModuleInfo, RequestCode, RespondCode, denylist_handler, get_magisk_tmp, scan_deny_apps,
};
use crate::logging::{android_logging, magisk_logging, setup_logfile, start_log_daemon};
use crate::module::remove_modules;
use crate::package::ManagerInfo;
use crate::resetprop::{get_prop, set_prop};
use crate::selinux::restore_tmpcon;
use crate::socket::{IpcRead, IpcWrite};
use crate::su::SuInfo;
use crate::thread::ThreadPool;
use crate::zygisk::ZygiskState;
use base::const_format::concatcp;
use base::{
    AtomicArc, BufReadExt, FileAttr, FsPathBuilder, LoggedResult, ReadExt, ResultExt, Utf8CStr,
    Utf8CStrBuf, WriteExt, cstr, fork_dont_care, info, libc, log_err, set_nice_name,
};
use nix::fcntl::OFlag;
use nix::mount::MsFlags;
use nix::sys::signal::SigSet;
use nix::unistd::{dup2_stderr, dup2_stdin, dup2_stdout, getpid, getuid, setsid};
use num_traits::AsPrimitive;
use std::fmt::Write as _;
use std::io::{BufReader, Write};
use std::os::fd::{AsFd, AsRawFd, IntoRawFd, RawFd};
use std::os::unix::net::{UCred, UnixListener, UnixStream};
use std::process::{Command, exit};
use std::sync::OnceLock;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::nonpoison::Mutex;
use std::time::Duration;

// Global magiskd singleton
pub static MAGISKD: OnceLock<MagiskD> = OnceLock::new();

pub const AID_ROOT: i32 = 0;
pub const AID_SHELL: i32 = 2000;
pub const AID_APP_START: i32 = 10000;
pub const AID_APP_END: i32 = 19999;
pub const AID_USER_OFFSET: i32 = 100000;

pub const fn to_app_id(uid: i32) -> i32 {
    uid % AID_USER_OFFSET
}

pub const fn to_user_id(uid: i32) -> i32 {
    uid / AID_USER_OFFSET
}

#[derive(Default)]
pub struct MagiskD {
    pub sql_connection: Mutex<Option<Sqlite3>>,
    pub manager_info: Mutex<ManagerInfo>,
    pub boot_stage_lock: Mutex<BootState>,
    pub module_list: OnceLock<Vec<ModuleInfo>>,
    pub zygisk_enabled: AtomicBool,
    pub zygisk: Mutex<ZygiskState>,
    pub cached_su_info: AtomicArc<SuInfo>,
    pub sdk_int: i32,
    pub is_emulator: bool,
    is_recovery: bool,
    exe_attr: FileAttr,
}

impl MagiskD {
    pub fn get() -> &'static MagiskD {
        unsafe { MAGISKD.get().unwrap_unchecked() }
    }

    pub fn sdk_int(&self) -> i32 {
        self.sdk_int
    }

    pub fn app_data_dir(&self) -> &'static Utf8CStr {
        if self.sdk_int >= 24 {
            cstr!("/data/user_de")
        } else {
            cstr!("/data/user")
        }
    }

    fn handle_request_sync(&self, mut client: UnixStream, code: RequestCode) {
        match code {
            RequestCode::CHECK_VERSION => {
                #[cfg(debug_assertions)]
                let s = concatcp!(MAGISK_VERSION, ":MAGISK:D");
                #[cfg(not(debug_assertions))]
                let s = concatcp!(MAGISK_VERSION, ":MAGISK:R");

                client.write_encodable(s).log_ok();
            }
            RequestCode::CHECK_VERSION_CODE => {
                client.write_pod(&MAGISK_VER_CODE).log_ok();
            }
            RequestCode::START_DAEMON => {
                setup_logfile();
            }
            RequestCode::STOP_DAEMON => {
                // Unmount all overlays
                denylist_handler(-1);

                // Restore native bridge property
                self.zygisk.lock().restore_prop();

                client.write_pod(&0).log_ok();

                // Terminate the daemon!
                exit(0);
            }
            _ => {}
        }
    }

    fn handle_request_async(&self, mut client: UnixStream, code: RequestCode, cred: UCred) {
        match code {
            RequestCode::DENYLIST => {
                denylist_handler(client.into_raw_fd());
            }
            RequestCode::SUPERUSER => {
                self.su_daemon_handler(client, cred);
            }
            RequestCode::ZYGOTE_RESTART => {
                info!("** zygote restarted");
                self.prune_su_access();
                scan_deny_apps();
                if self.zygisk_enabled.load(Ordering::Relaxed) {
                    self.zygisk.lock().reset(false);
                }
            }
            RequestCode::SQLITE_CMD => {
                self.db_exec_for_cli(client).ok();
            }
            RequestCode::REMOVE_MODULES => {
                let do_reboot: bool = client.read_decodable().log().unwrap_or_default();
                remove_modules();
                client.write_pod(&0).log_ok();
                if do_reboot {
                    self.reboot();
                }
            }
            RequestCode::ZYGISK => {
                self.zygisk_handler(client);
            }
            _ => {}
        }
    }

    fn reboot(&self) {
        if self.is_recovery {
            Command::new("/system/bin/reboot").arg("recovery").status()
        } else {
            Command::new("/system/bin/reboot").status()
        }
        .ok();
    }

    #[cfg(feature = "check-client")]
    fn is_client(&self, pid: i32) -> bool {
        let mut buf = cstr::buf::new::<32>();
        write!(buf, "/proc/{pid}/exe").ok();
        if let Ok(attr) = buf.follow_link().get_attr() {
            attr.st.st_dev == self.exe_attr.st.st_dev && attr.st.st_ino == self.exe_attr.st.st_ino
        } else {
            false
        }
    }

    #[cfg(not(feature = "check-client"))]
    fn is_client(&self, pid: i32) -> bool {
        true
    }

    fn handle_requests(&'static self, mut client: UnixStream) {
        let Ok(cred) = client.peer_cred() else {
            // Client died
            return;
        };

        // There are no abstractions for SO_PEERSEC yet, call the raw C API.
        let mut context = cstr::buf::new::<256>();
        unsafe {
            let mut len: libc::socklen_t = context.capacity().as_();
            libc::getsockopt(
                client.as_raw_fd(),
                libc::SOL_SOCKET,
                libc::SO_PEERSEC,
                context.as_mut_ptr().cast(),
                &mut len,
            );
        }
        context.rebuild().ok();

        let is_root = cred.uid == 0;
        let is_shell = cred.uid == 2000;
        let is_zygote = &context == "u:r:zygote:s0";

        if !is_root && !is_zygote && !self.is_client(cred.pid.unwrap_or(-1)) {
            // Unsupported client state
            client.write_pod(&RespondCode::ACCESS_DENIED.repr).log_ok();
            return;
        }

        let mut code = -1;
        client.read_pod(&mut code).ok();
        if !(0..RequestCode::END.repr).contains(&code)
            || code == RequestCode::_SYNC_BARRIER_.repr
            || code == RequestCode::_STAGE_BARRIER_.repr
        {
            // Unknown request code
            return;
        }

        let code = RequestCode { repr: code };

        // Permission checks
        match code {
            RequestCode::POST_FS_DATA
            | RequestCode::LATE_START
            | RequestCode::BOOT_COMPLETE
            | RequestCode::ZYGOTE_RESTART
            | RequestCode::SQLITE_CMD
            | RequestCode::DENYLIST
            | RequestCode::STOP_DAEMON => {
                if !is_root {
                    client.write_pod(&RespondCode::ROOT_REQUIRED.repr).log_ok();
                    return;
                }
            }
            RequestCode::REMOVE_MODULES => {
                if !is_root && !is_shell {
                    // Only allow root and ADB shell to remove modules
                    client.write_pod(&RespondCode::ACCESS_DENIED.repr).log_ok();
                    return;
                }
            }
            RequestCode::ZYGISK => {
                if !is_zygote {
                    // Invalid client context
                    client.write_pod(&RespondCode::ACCESS_DENIED.repr).log_ok();
                    return;
                }
            }
            _ => {}
        }

        if client.write_pod(&RespondCode::OK.repr).is_err() {
            return;
        }

        if code.repr < RequestCode::_SYNC_BARRIER_.repr {
            self.handle_request_sync(client, code)
        } else if code.repr < RequestCode::_STAGE_BARRIER_.repr {
            ThreadPool::exec_task(move || {
                self.handle_request_async(client, code, cred);
            })
        } else {
            ThreadPool::exec_task(move || {
                self.boot_stage_handler(client, code);
            })
        }
    }
}

fn switch_cgroup(cgroup: &str, pid: i32) {
    let mut buf = cstr::buf::new::<64>()
        .join_path(cgroup)
        .join_path("cgroup.procs");
    if !buf.exists() {
        return;
    }
    if let Ok(mut file) = buf.open(OFlag::O_WRONLY | OFlag::O_APPEND | OFlag::O_CLOEXEC) {
        buf.clear();
        write!(buf, "{pid}").ok();
        file.write_all(buf.as_bytes()).log_ok();
    }
}

fn daemon_entry() {
    set_nice_name(cstr!("magiskd"));
    android_logging();

    // Block all signals
    SigSet::all().thread_set_mask().log_ok();

    // Swap out the original stdio
    if let Ok(null) = cstr!("/dev/null").open(OFlag::O_WRONLY).log() {
        dup2_stdout(null.as_fd()).log_ok();
        dup2_stderr(null.as_fd()).log_ok();
    }
    if let Ok(zero) = cstr!("/dev/zero").open(OFlag::O_RDONLY).log() {
        dup2_stdin(zero).log_ok();
    }

    setsid().log_ok();

    // Make sure the current context is magisk
    if let Ok(mut current) =
        cstr!("/proc/self/attr/current").open(OFlag::O_WRONLY | OFlag::O_CLOEXEC)
    {
        let con = cstr!(MAGISK_PROC_CON);
        current.write_all(con.as_bytes_with_nul()).log_ok();
    }

    start_log_daemon();
    magisk_logging();
    info!("Magisk {MAGISK_FULL_VER} daemon started");

    let is_emulator = get_prop(cstr!("ro.kernel.qemu")) == "1"
        || get_prop(cstr!("ro.boot.qemu")) == "1"
        || get_prop(cstr!("ro.product.device")).contains("vsoc");

    // Load config status
    let magisk_tmp = get_magisk_tmp();
    let mut tmp_path = cstr::buf::new::<64>()
        .join_path(magisk_tmp)
        .join_path(MAIN_CONFIG);
    let mut is_recovery = false;
    if let Ok(main_config) = tmp_path.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC) {
        BufReader::new(main_config).for_each_prop(|key, val| {
            if key == "RECOVERYMODE" {
                is_recovery = val == "true";
                return false;
            }
            true
        });
    }
    tmp_path.truncate(magisk_tmp.len());

    let mut sdk_int = -1;
    if let Ok(build_prop) = cstr!("/system/build.prop").open(OFlag::O_RDONLY | OFlag::O_CLOEXEC) {
        BufReader::new(build_prop).for_each_prop(|key, val| {
            if key == "ro.build.version.sdk" {
                sdk_int = val.parse::<i32>().unwrap_or(-1);
                return false;
            }
            true
        });
    }
    if sdk_int < 0 {
        // In case some devices do not store this info in build.prop, fallback to getprop
        sdk_int = get_prop(cstr!("ro.build.version.sdk"))
            .parse::<i32>()
            .unwrap_or(-1);
    }
    info!("* Device API level: {sdk_int}");

    restore_tmpcon().log_ok();

    // Escape from cgroup
    let pid = getpid().as_raw();
    switch_cgroup("/acct", pid);
    switch_cgroup("/dev/cg2_bpf", pid);
    switch_cgroup("/sys/fs/cgroup", pid);
    if get_prop(cstr!("ro.config.per_app_memcg")) != "false" {
        switch_cgroup("/dev/memcg/apps", pid);
    }

    // Samsung workaround #7887
    if cstr!("/system_ext/app/mediatek-res/mediatek-res.apk").exists() {
        set_prop(cstr!("ro.vendor.mtk_model"), cstr!("0"));
    }

    // Cleanup pre-init mounts
    tmp_path.append_path(ROOTMNT);
    if let Ok(mount_list) = tmp_path.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC) {
        BufReader::new(mount_list).for_each_line(|line| {
            line.truncate(line.trim_end().len());
            let item = Utf8CStr::from_string(line);
            item.unmount().log_ok();
            true
        })
    }
    tmp_path.truncate(magisk_tmp.len());

    // Remount rootfs as read-only if requested
    if std::env::var_os("REMOUNT_ROOT").is_some() {
        cstr!("/").remount_mount_flags(MsFlags::MS_RDONLY).log_ok();
        unsafe { std::env::remove_var("REMOUNT_ROOT") };
    }

    // Remove all pre-init overlay files to free-up memory
    tmp_path.append_path(ROOTOVL);
    tmp_path.remove_all().ok();
    tmp_path.truncate(magisk_tmp.len());

    let exe_attr = cstr!("/proc/self/exe")
        .follow_link()
        .get_attr()
        .log()
        .unwrap_or_default();

    let daemon = MagiskD {
        sdk_int,
        is_emulator,
        is_recovery,
        exe_attr,
        ..Default::default()
    };
    MAGISKD.set(daemon).ok();

    let sock_path = cstr::buf::new::<64>()
        .join_path(get_magisk_tmp())
        .join_path(MAIN_SOCKET);
    sock_path.remove().ok();

    let Ok(sock) = UnixListener::bind(&sock_path).log() else {
        exit(1);
    };

    sock_path.follow_link().chmod(0o666).log_ok();
    sock_path.set_secontext(cstr!(MAGISK_FILE_CON)).log_ok();

    // Loop forever to listen for requests
    let daemon = MagiskD::get();
    for client in sock.incoming() {
        if let Ok(client) = client.log() {
            daemon.handle_requests(client);
        } else {
            exit(1);
        }
    }
}

pub fn connect_daemon(code: RequestCode, create: bool) -> LoggedResult<UnixStream> {
    let sock_path = cstr::buf::new::<64>()
        .join_path(get_magisk_tmp())
        .join_path(MAIN_SOCKET);

    fn send_request(code: RequestCode, mut socket: UnixStream) -> LoggedResult<UnixStream> {
        socket.write_pod(&code.repr).log_ok();
        let mut res = -1;
        socket.read_pod(&mut res).log_ok();
        let res = RespondCode { repr: res };
        match res {
            RespondCode::OK => Ok(socket),
            RespondCode::ROOT_REQUIRED => {
                log_err!("Root is required for this operation")
            }
            RespondCode::ACCESS_DENIED => {
                log_err!("Accessed denied")
            }
            _ => {
                log_err!("Daemon error")
            }
        }
    }

    match UnixStream::connect(&sock_path) {
        Ok(socket) => send_request(code, socket),
        Err(e) => {
            if !create || !getuid().is_root() {
                return log_err!("Cannot connect to daemon: {e}");
            }

            let mut buf = cstr::buf::new::<64>();
            if cstr!("/proc/self/exe").read_link(&mut buf).is_err()
                || !buf.starts_with(get_magisk_tmp().as_str())
            {
                return log_err!("Start daemon on magisk tmpfs");
            }

            // Fork a process and run the daemon
            if fork_dont_care() == 0 {
                daemon_entry();
                exit(0);
            }

            // In the client, we keep retry and connect to the socket
            loop {
                if let Ok(socket) = UnixStream::connect(&sock_path) {
                    return send_request(code, socket);
                } else {
                    std::thread::sleep(Duration::from_millis(100));
                }
            }
        }
    }
}

pub fn connect_daemon_for_cxx(code: RequestCode, create: bool) -> RawFd {
    connect_daemon(code, create)
        .map(IntoRawFd::into_raw_fd)
        .unwrap_or(-1)
}

```

`native/src/core/db.rs`:

```rs
#![allow(improper_ctypes, improper_ctypes_definitions)]
use crate::daemon::{MAGISKD, MagiskD};
use crate::ffi::{
    DbEntryKey, DbStatement, DbValues, MntNsMode, open_and_init_db, sqlite3, sqlite3_errstr,
};
use crate::socket::{IpcRead, IpcWrite};
use DbArg::{Integer, Text};
use base::{LoggedResult, ResultExt, Utf8CStr};
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;
use std::ffi::c_void;
use std::io::{BufReader, BufWriter};
use std::os::unix::net::UnixStream;
use std::pin::Pin;
use std::ptr;
use std::ptr::NonNull;
use thiserror::Error;

fn sqlite_err_str(code: i32) -> &'static Utf8CStr {
    // SAFETY: sqlite3 always returns UTF-8 strings
    unsafe { Utf8CStr::from_ptr_unchecked(sqlite3_errstr(code)) }
}

#[repr(transparent)]
#[derive(Error, Debug)]
#[error("sqlite3: {}", sqlite_err_str(self.0))]
pub struct SqliteError(i32);

pub type SqliteResult<T> = Result<T, SqliteError>;

pub trait SqliteReturn {
    fn sql_result(self) -> SqliteResult<()>;
}

impl SqliteReturn for i32 {
    fn sql_result(self) -> SqliteResult<()> {
        if self != 0 {
            Err(SqliteError(self))
        } else {
            Ok(())
        }
    }
}

pub trait SqlTable {
    fn on_row(&mut self, columns: &[String], values: &DbValues);
}

impl<T> SqlTable for T
where
    T: FnMut(&[String], &DbValues),
{
    fn on_row(&mut self, columns: &[String], values: &DbValues) {
        self.call_mut((columns, values))
    }
}

#[derive(Default)]
pub struct DbSettings {
    pub root_access: RootAccess,
    pub multiuser_mode: MultiuserMode,
    pub mnt_ns: MntNsMode,
    pub boot_count: i32,
    pub denylist: bool,
    pub zygisk: bool,
}

#[repr(i32)]
#[derive(Default, FromPrimitive)]
pub enum RootAccess {
    Disabled,
    AppsOnly,
    AdbOnly,
    #[default]
    AppsAndAdb,
}

#[repr(i32)]
#[derive(Default, FromPrimitive)]
pub enum MultiuserMode {
    #[default]
    OwnerOnly,
    OwnerManaged,
    User,
}

impl Default for MntNsMode {
    fn default() -> Self {
        MntNsMode::Requester
    }
}

impl DbEntryKey {
    fn to_str(self) -> &'static str {
        match self {
            DbEntryKey::RootAccess => "root_access",
            DbEntryKey::SuMultiuserMode => "multiuser_mode",
            DbEntryKey::SuMntNs => "mnt_ns",
            DbEntryKey::DenylistConfig => "denylist",
            DbEntryKey::ZygiskConfig => "zygisk",
            DbEntryKey::BootloopCount => "bootloop",
            DbEntryKey::SuManager => "requester",
            _ => "",
        }
    }
}

impl SqlTable for DbSettings {
    fn on_row(&mut self, columns: &[String], values: &DbValues) {
        let mut key = "";
        let mut value = 0;
        for (i, column) in columns.iter().enumerate() {
            if column == "key" {
                key = values.get_text(i as i32);
            } else if column == "value" {
                value = values.get_int(i as i32);
            }
        }
        match key {
            "root_access" => self.root_access = RootAccess::from_i32(value).unwrap_or_default(),
            "multiuser_mode" => {
                self.multiuser_mode = MultiuserMode::from_i32(value).unwrap_or_default()
            }
            "mnt_ns" => self.mnt_ns = MntNsMode { repr: value },
            "denylist" => self.denylist = value != 0,
            "zygisk" => self.zygisk = value != 0,
            "bootloop" => self.boot_count = value,
            _ => {}
        }
    }
}

#[repr(transparent)]
pub struct Sqlite3(NonNull<sqlite3>);
unsafe impl Send for Sqlite3 {}

type SqlBindCallback = Option<unsafe extern "C" fn(*mut c_void, i32, Pin<&mut DbStatement>) -> i32>;
type SqlExecCallback = Option<unsafe extern "C" fn(*mut c_void, &[String], &DbValues)>;

unsafe extern "C" {
    fn sql_exec_impl(
        db: *mut sqlite3,
        sql: &str,
        bind_callback: SqlBindCallback,
        bind_cookie: *mut c_void,
        exec_callback: SqlExecCallback,
        exec_cookie: *mut c_void,
    ) -> i32;
}

pub enum DbArg<'a> {
    Text(&'a str),
    Integer(i64),
}

struct DbArgs<'a> {
    args: &'a [DbArg<'a>],
    curr: usize,
}

unsafe extern "C" fn bind_arguments(v: *mut c_void, idx: i32, stmt: Pin<&mut DbStatement>) -> i32 {
    unsafe {
        let args = &mut *(v as *mut DbArgs<'_>);
        if args.curr < args.args.len() {
            let arg = &args.args[args.curr];
            args.curr += 1;
            match *arg {
                Text(v) => stmt.bind_text(idx, v),
                Integer(v) => stmt.bind_int64(idx, v),
            }
        } else {
            0
        }
    }
}

unsafe extern "C" fn read_db_row<T: SqlTable>(
    v: *mut c_void,
    columns: &[String],
    values: &DbValues,
) {
    unsafe {
        let table = &mut *(v as *mut T);
        table.on_row(columns, values);
    }
}

impl MagiskD {
    fn with_db<F: FnOnce(*mut sqlite3) -> i32>(&self, f: F) -> i32 {
        let mut db = self.sql_connection.lock();
        if db.is_none() {
            let raw_db = open_and_init_db();
            *db = NonNull::new(raw_db).map(Sqlite3);
        }
        match *db {
            Some(ref mut db) => f(db.0.as_ptr()),
            _ => -1,
        }
    }

    fn db_exec_impl(
        &self,
        sql: &str,
        args: &[DbArg],
        exec_callback: SqlExecCallback,
        exec_cookie: *mut c_void,
    ) -> i32 {
        let mut bind_callback: SqlBindCallback = None;
        let mut bind_cookie: *mut c_void = ptr::null_mut();
        let mut db_args = DbArgs { args, curr: 0 };
        if !args.is_empty() {
            bind_callback = Some(bind_arguments);
            bind_cookie = (&mut db_args) as *mut DbArgs as *mut c_void;
        }
        self.with_db(|db| unsafe {
            sql_exec_impl(
                db,
                sql,
                bind_callback,
                bind_cookie,
                exec_callback,
                exec_cookie,
            )
        })
    }

    pub fn db_exec_with_rows<T: SqlTable>(&self, sql: &str, args: &[DbArg], out: &mut T) -> i32 {
        self.db_exec_impl(
            sql,
            args,
            Some(read_db_row::<T>),
            out as *mut T as *mut c_void,
        )
    }

    pub fn db_exec(&self, sql: &str, args: &[DbArg]) -> i32 {
        self.db_exec_impl(sql, args, None, ptr::null_mut())
    }

    pub fn set_db_setting(&self, key: DbEntryKey, value: i32) -> SqliteResult<()> {
        self.db_exec(
            "INSERT OR REPLACE INTO settings (key,value) VALUES(?,?)",
            &[Text(key.to_str()), Integer(value as i64)],
        )
        .sql_result()
    }

    pub fn get_db_setting(&self, key: DbEntryKey) -> i32 {
        // Get default values
        let mut val = match key {
            DbEntryKey::RootAccess => RootAccess::default() as i32,
            DbEntryKey::SuMultiuserMode => MultiuserMode::default() as i32,
            DbEntryKey::SuMntNs => MntNsMode::default().repr,
            DbEntryKey::DenylistConfig => 0,
            DbEntryKey::ZygiskConfig => self.is_emulator as i32,
            DbEntryKey::BootloopCount => 0,
            _ => -1,
        };
        let mut func = |_: &[String], values: &DbValues| {
            val = values.get_int(0);
        };
        self.db_exec_with_rows(
            "SELECT value FROM settings WHERE key=?",
            &[Text(key.to_str())],
            &mut func,
        )
        .sql_result()
        .log()
        .ok();
        val
    }

    pub fn get_db_settings(&self) -> SqliteResult<DbSettings> {
        let mut cfg = DbSettings {
            zygisk: self.is_emulator,
            ..Default::default()
        };
        self.db_exec_with_rows("SELECT * FROM settings", &[], &mut cfg)
            .sql_result()?;
        Ok(cfg)
    }

    pub fn get_db_string(&self, key: DbEntryKey) -> String {
        let mut val = "".to_string();
        let mut func = |_: &[String], values: &DbValues| {
            val.push_str(values.get_text(0));
        };
        self.db_exec_with_rows(
            "SELECT value FROM strings WHERE key=?",
            &[Text(key.to_str())],
            &mut func,
        )
        .sql_result()
        .log()
        .ok();
        val
    }

    pub fn rm_db_string(&self, key: DbEntryKey) -> SqliteResult<()> {
        self.db_exec("DELETE FROM strings WHERE key=?", &[Text(key.to_str())])
            .sql_result()
    }

    pub fn db_exec_for_cli(&self, mut file: UnixStream) -> LoggedResult<()> {
        let mut reader = BufReader::new(&mut file);
        let sql: String = reader.read_decodable()?;
        let mut writer = BufWriter::new(&mut file);
        let mut output_fn = |columns: &[String], values: &DbValues| {
            let mut out = "".to_string();
            for (i, column) in columns.iter().enumerate() {
                if i != 0 {
                    out.push('|');
                }
                out.push_str(column);
                out.push('=');
                out.push_str(values.get_text(i as i32));
            }
            writer.write_encodable(&out).log_ok();
        };
        self.db_exec_with_rows(&sql, &[], &mut output_fn);
        writer.write_encodable("").log()
    }
}

impl MagiskD {
    pub fn set_db_setting_for_cxx(&self, key: DbEntryKey, value: i32) -> bool {
        self.set_db_setting(key, value).log().is_ok()
    }
}

#[unsafe(export_name = "sql_exec_rs")]
unsafe extern "C" fn sql_exec_for_cxx(
    sql: &str,
    bind_callback: SqlBindCallback,
    bind_cookie: *mut c_void,
    exec_callback: SqlExecCallback,
    exec_cookie: *mut c_void,
) -> i32 {
    unsafe {
        MAGISKD.get().unwrap_unchecked().with_db(|db| {
            sql_exec_impl(
                db,
                sql,
                bind_callback,
                bind_cookie,
                exec_callback,
                exec_cookie,
            )
        })
    }
}

```

`native/src/core/deny/cli.cpp`:

```cpp
#include <sys/wait.h>
#include <sys/mount.h>

#include <core.hpp>

#include "deny.hpp"

using namespace std;

[[noreturn]] static void usage() {
    fprintf(stderr,
R"EOF(DenyList Config CLI

Usage: magisk --denylist [action [arguments...] ]
Actions:
   status          Return the enforcement status
   enable          Enable denylist enforcement
   disable         Disable denylist enforcement
   add PKG [PROC]  Add a new target to the denylist
   rm PKG [PROC]   Remove target(s) from the denylist
   ls              Print the current denylist
   exec CMDs...    Execute commands in isolated mount
                   namespace and do all unmounts

)EOF");
    exit(1);
}

void denylist_handler(int client) {
    if (client < 0) {
        revert_unmount();
        return;
    }

    int req = read_int(client);
    int res = DenyResponse::ERROR;

    switch (req) {
    case DenyRequest::ENFORCE:
        res = enable_deny();
        break;
    case DenyRequest::DISABLE:
        res = disable_deny();
        break;
    case DenyRequest::ADD:
        res = add_list(client);
        break;
    case DenyRequest::REMOVE:
        res = rm_list(client);
        break;
    case DenyRequest::LIST:
        ls_list(client);
        return;
    case DenyRequest::STATUS:
        res = denylist_enforced ? DenyResponse::ENFORCED : DenyResponse::NOT_ENFORCED;
        break;
    default:
        // Unknown request code
        break;
    }
    write_int(client, res);
    close(client);
}

int denylist_cli(rust::Vec<rust::String> &args) {
    if (args.empty())
        usage();

    // Convert rust strings into c strings
    size_t argc = args.size();
    std::vector<const char *> argv;
    ranges::transform(args, std::back_inserter(argv), [](rust::String &arg) { return arg.c_str(); });
    // End with nullptr
    argv.push_back(nullptr);

    int req;
    if (argv[0] == "enable"sv)
        req = DenyRequest::ENFORCE;
    else if (argv[0] == "disable"sv)
        req = DenyRequest::DISABLE;
    else if (argv[0] == "add"sv)
        req = DenyRequest::ADD;
    else if (argv[0] == "rm"sv)
        req = DenyRequest::REMOVE;
    else if (argv[0] == "ls"sv)
        req = DenyRequest::LIST;
    else if (argv[0] == "status"sv)
        req = DenyRequest::STATUS;
    else if (argv[0] == "exec"sv && argc > 1) {
        xunshare(CLONE_NEWNS);
        xmount(nullptr, "/", nullptr, MS_PRIVATE | MS_REC, nullptr);
        revert_unmount();
        execvp(argv[1], (char **) argv.data() + 1);
        exit(1);
    } else {
        usage();
    }

    // Send request
    int fd = connect_daemon(RequestCode::DENYLIST);
    write_int(fd, req);
    if (req == DenyRequest::ADD || req == DenyRequest::REMOVE) {
        write_string(fd, argv[1]);
        write_string(fd, argv[2] ? argv[2] : "");
    }

    // Get response
    int res = read_int(fd);
    if (res < 0 || res >= DenyResponse::END)
        res = DenyResponse::ERROR;
    switch (res) {
    case DenyResponse::NOT_ENFORCED:
        fprintf(stderr, "Denylist is not enforced\n");
        goto return_code;
    case DenyResponse::ENFORCED:
        fprintf(stderr, "Denylist is enforced\n");
        goto return_code;
    case DenyResponse::ITEM_EXIST:
        fprintf(stderr, "Target already exists in denylist\n");
        goto return_code;
    case DenyResponse::ITEM_NOT_EXIST:
        fprintf(stderr, "Target does not exist in denylist\n");
        goto return_code;
    case DenyResponse::NO_NS:
        fprintf(stderr, "The kernel does not support mount namespace\n");
        goto return_code;
    case DenyResponse::INVALID_PKG:
        fprintf(stderr, "Invalid package / process name\n");
        goto return_code;
    case DenyResponse::ERROR:
        fprintf(stderr, "deny: Daemon error\n");
        return -1;
    case DenyResponse::OK:
        break;
    default:
        __builtin_unreachable();
    }

    if (req == DenyRequest::LIST) {
        string out;
        for (;;) {
            read_string(fd, out);
            if (out.empty())
                break;
            printf("%s\n", out.data());
        }
    }

return_code:
    return req == DenyRequest::STATUS ? res != DenyResponse::ENFORCED : res != DenyResponse::OK;
}

```

`native/src/core/deny/deny.hpp`:

```hpp
#pragma once

#include <string_view>

#define ISOLATED_MAGIC "isolated"

namespace DenyRequest {
enum : int {
    ENFORCE,
    DISABLE,
    ADD,
    REMOVE,
    LIST,
    STATUS,

    END
};
}

namespace DenyResponse {
enum : int {
    OK,
    ENFORCED,
    NOT_ENFORCED,
    ITEM_EXIST,
    ITEM_NOT_EXIST,
    INVALID_PKG,
    NO_NS,
    ERROR,

    END
};
}

// CLI entries
int enable_deny();
int disable_deny();
int add_list(int client);
int rm_list(int client);
void ls_list(int client);

bool proc_context_match(int pid, std::string_view context);
void *logcat(void *arg);
extern bool logcat_exit;

```

`native/src/core/deny/logcat.cpp`:

```cpp
#include <unistd.h>
#include <android/log.h>
#include <sys/syscall.h>
#include <string>
#include <map>

#include <core.hpp>

#include "deny.hpp"

using namespace std;

struct logger_entry {
    uint16_t len;      /* length of the payload */
    uint16_t hdr_size; /* sizeof(struct logger_entry) */
    int32_t pid;       /* generating process's pid */
    uint32_t tid;      /* generating process's tid */
    uint32_t sec;      /* seconds since Epoch */
    uint32_t nsec;     /* nanoseconds */
    uint32_t lid;      /* log id of the payload, bottom 4 bits currently */
    uint32_t uid;      /* generating process's uid */
};

#define LOGGER_ENTRY_MAX_LEN (5 * 1024)
struct log_msg {
    union [[gnu::aligned(4)]] {
        unsigned char buf[LOGGER_ENTRY_MAX_LEN + 1];
        struct logger_entry entry;
    };
};

struct AndroidLogEntry {
    time_t tv_sec;
    long tv_nsec;
    android_LogPriority priority;
    int32_t uid;
    int32_t pid;
    int32_t tid;
    const char *tag;
    size_t tagLen;
    size_t messageLen;
    const char *message;
};

struct [[gnu::packed]] android_event_header_t {
    int32_t tag;    // Little Endian Order
};

struct [[gnu::packed]] android_event_int_t {
    int8_t type;    // EVENT_TYPE_INT
    int32_t data;   // Little Endian Order
};

struct [[gnu::packed]] android_event_string_t {
    int8_t type;    // EVENT_TYPE_STRING;
    int32_t length; // Little Endian Order
    char data[];
};

struct [[gnu::packed]] android_event_list_t {
    int8_t type;    // EVENT_TYPE_LIST
    int8_t element_count;
} ;

// 30014 am_proc_start (User|1|5),(PID|1|5),(UID|1|5),(Process Name|3),(Type|3),(Component|3)
struct [[gnu::packed]] android_event_am_proc_start {
    android_event_header_t tag;
    android_event_list_t list;
    android_event_int_t user;
    android_event_int_t pid;
    android_event_int_t uid;
    android_event_string_t process_name;
//  android_event_string_t type;
//  android_event_string_t component;
};

// 3040 boot_progress_ams_ready (time|2|3)

extern "C" {

[[gnu::weak]] struct logger_list *android_logger_list_alloc(int mode, unsigned int tail, pid_t pid);
[[gnu::weak]] void android_logger_list_free(struct logger_list *list);
[[gnu::weak]] int android_logger_list_read(struct logger_list *list, struct log_msg *log_msg);
[[gnu::weak]] struct logger *android_logger_open(struct logger_list *list, log_id_t id);
[[gnu::weak]] int android_log_processLogBuffer(struct logger_entry *buf, AndroidLogEntry *entry);

}

// zygote pid -> mnt ns
static map<int, struct stat> zygote_map;
bool logcat_exit;

static int read_ns(const int pid, struct stat *st) {
    char path[32];
    sprintf(path, "/proc/%d/ns/mnt", pid);
    return stat(path, st);
}

static int parse_ppid(int pid) {
    char path[32];
    int ppid;
    sprintf(path, "/proc/%d/stat", pid);
    auto stat = open_file(path, "re");
    if (!stat) return -1;
    // PID COMM STATE PPID .....
    fscanf(stat.get(), "%*d %*s %*c %d", &ppid);
    return ppid;
}

static void check_zygote() {
    zygote_map.clear();
    int proc = open("/proc", O_RDONLY | O_CLOEXEC);
    auto proc_dir = xopen_dir(proc);
    if (!proc_dir) return;
    struct stat st{};
    for (dirent *entry; (entry = readdir(proc_dir.get()));) {
        int pid = parse_int(entry->d_name);
        if (pid <= 0) continue;
        if (fstatat(proc, entry->d_name, &st, 0)) continue;
        if (st.st_uid != 0) continue;
        if (proc_context_match(pid, "u:r:zygote:s0") && parse_ppid(pid) == 1) {
            if (read_ns(pid, &st) == 0) {
                LOGI("logcat: zygote PID=[%d]\n", pid);
                zygote_map[pid] = st;
            }
        }
    }
}

static void process_main_buffer(struct log_msg *msg) {
    AndroidLogEntry entry{};
    if (android_log_processLogBuffer(&msg->entry, &entry) < 0) return;
    entry.tagLen--;
    auto tag = string_view(entry.tag, entry.tagLen);

    static bool ready = false;
    if (tag == "AppZygote") {
        if (entry.uid != 1000) return;
        if (entry.message[0] == 'S') {
            ready = true;
        } else {
            ready = false;
        }
        return;
    }

    if (!ready || tag != "AppZygoteInit") return;
    if (!proc_context_match(msg->entry.pid, "u:r:app_zygote:s0")) return;
    ready = false;

    char cmdline[1024];
    sprintf(cmdline, "/proc/%d/cmdline", msg->entry.pid);
    if (auto f = open_file(cmdline, "re")) {
        fgets(cmdline, sizeof(cmdline), f.get());
    } else {
        return;
    }

    if (is_deny_target(entry.uid, cmdline)) {
        int pid = msg->entry.pid;
        kill(pid, SIGSTOP);
        if (fork_dont_care() == 0) {
            LOGI("logcat: revert [%s] PID=[%d] UID=[%d]\n", cmdline, pid, entry.uid);
            revert_unmount(pid);
            kill(pid, SIGCONT);
            _exit(0);
        }
    } else {
        LOGD("logcat: skip [%s] PID=[%d] UID=[%d]\n", cmdline, msg->entry.pid, entry.uid);
    }
}

static void process_events_buffer(struct log_msg *msg) {
    if (msg->entry.uid != 1000) return;
    auto event_data = &msg->buf[msg->entry.hdr_size];
    auto event_header = reinterpret_cast<const android_event_header_t *>(event_data);
    if (event_header->tag == 30014) {
        auto am_proc_start = reinterpret_cast<const android_event_am_proc_start *>(event_data);
        auto proc = string_view(am_proc_start->process_name.data,
                                am_proc_start->process_name.length);
        if (is_deny_target(am_proc_start->uid.data, proc)) {
            int pid = am_proc_start->pid.data;
            if (fork_dont_care() == 0) {
                int ppid = parse_ppid(pid);
                auto it = zygote_map.find(ppid);
                if (it == zygote_map.end()) {
                    LOGW("logcat: skip [%.*s] PID=[%d] UID=[%d] PPID=[%d]; parent not zygote\n",
                         (int) proc.length(), proc.data(),
                         pid, am_proc_start->uid.data, ppid);
                    _exit(0);
                }

                char path[16];
                ssprintf(path, sizeof(path), "/proc/%d", pid);
                struct stat st{};
                int fd = syscall(__NR_pidfd_open, pid, 0);
                if (fd > 0 && setns(fd, CLONE_NEWNS) == 0) {
                    pid = getpid();
                } else {
                    close(fd);
                    fd = -1;
                }
                while (read_ns(pid, &st) == 0 && it->second.st_ino == st.st_ino) {
                    if (stat(path, &st) == 0 && st.st_uid == 0) {
                        usleep(10 * 1000);
                    } else {
                        LOGW("logcat: skip [%.*s] PID=[%s] UID=[%d]; namespace not isolated\n",
                             (int) proc.length(), proc.data(),
                             path + 6, am_proc_start->uid.data);
                        _exit(0);
                    }
                    if (fd > 0) setns(fd, CLONE_NEWNS);
                }
                close(fd);

                LOGI("logcat: revert [%.*s] PID=[%d] UID=[%d]\n",
                     (int) proc.length(), proc.data(), pid, am_proc_start->uid.data);
                revert_unmount(pid);
                _exit(0);
            }
        } else {
            LOGD("logcat: skip [%.*s] PID=[%d] UID=[%d]\n",
                 (int) proc.length(), proc.data(),
                 am_proc_start->pid.data, am_proc_start->uid.data);
        }
        return;
    }
    if (event_header->tag == 3040) {
        LOGD("logcat: soft reboot\n");
        check_zygote();
    }
}

[[noreturn]] void run() {
    while (true) {
        const unique_ptr<logger_list, decltype(&android_logger_list_free)> logger_list{
            android_logger_list_alloc(0, 1, 0), &android_logger_list_free};

        for (log_id id: {LOG_ID_MAIN, LOG_ID_EVENTS}) {
            auto *logger = android_logger_open(logger_list.get(), id);
            if (logger == nullptr) continue;
        }

        struct log_msg msg{};
        while (true) {
            if (!denylist_enforced) {
                break;
            }

            if (android_logger_list_read(logger_list.get(), &msg) <= 0) {
                break;
            }

            switch (msg.entry.lid) {
                case LOG_ID_EVENTS:
                    process_events_buffer(&msg);
                    break;
                case LOG_ID_MAIN:
                    process_main_buffer(&msg);
                default:
                    break;
            }
        }

        if (!denylist_enforced) {
            break;
        }

        sleep(1);
    }

    LOGD("logcat: terminate\n");
    pthread_exit(nullptr);
}

void *logcat(void *) {
    check_zygote();
    run();
}

```

`native/src/core/deny/utils.cpp`:

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/inotify.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <set>
#include <map>

#include <consts.hpp>
#include <sqlite.hpp>
#include <core.hpp>

#include "deny.hpp"

using namespace std;

// For the following data structures:
// If package name == ISOLATED_MAGIC, or app ID == -1, it means isolated service

// Package name -> list of process names
static unique_ptr<map<string, set<string, StringCmp>, StringCmp>> pkg_to_procs_;
#define pkg_to_procs (*pkg_to_procs_)

// app ID -> list of pkg names (string_view points to a pkg_to_procs key)
static unique_ptr<map<int, set<string_view>>> app_id_to_pkgs_;
#define app_id_to_pkgs (*app_id_to_pkgs_)

// Locks the data structures above
static pthread_mutex_t data_lock = PTHREAD_MUTEX_INITIALIZER;

atomic<bool> denylist_enforced = false;

static int get_app_id(const vector<int> &users, const string &pkg) {
    struct stat st{};
    char buf[PATH_MAX];
    for (const auto &user_id: users) {
        ssprintf(buf, sizeof(buf), "%s/%d/%s", APP_DATA_DIR, user_id, pkg.data());
        if (stat(buf, &st) == 0) {
            return to_app_id(st.st_uid);
        }
    }
    return 0;
}

static void collect_users(vector<int> &users) {
    auto data_dir = xopen_dir(APP_DATA_DIR);
    if (!data_dir)
        return;
    dirent *entry;
    while ((entry = xreaddir(data_dir.get()))) {
        users.emplace_back(parse_int(entry->d_name));
    }
}

static int get_app_id(const string &pkg) {
    if (pkg == ISOLATED_MAGIC)
        return -1;
    vector<int> users;
    collect_users(users);
    return get_app_id(users, pkg);
}

static void update_app_id(int app_id, const string &pkg, bool remove) {
    if (app_id <= 0)
        return;
    if (remove) {
        if (auto it = app_id_to_pkgs.find(app_id); it != app_id_to_pkgs.end()) {
            it->second.erase(pkg);
            if (it->second.empty()) {
                app_id_to_pkgs.erase(it);
            }
        }
    } else {
        app_id_to_pkgs[app_id].emplace(pkg);
    }
}

// Leave /proc fd opened as we're going to read from it repeatedly
static DIR *procfp;

template<class F>
static void crawl_procfs(const F &fn) {
    rewinddir(procfp);
    dirent *dp;
    int pid;
    while ((dp = readdir(procfp))) {
        pid = parse_int(dp->d_name);
        if (pid > 0 && !fn(pid))
            break;
    }
}

static bool str_eql(string_view a, string_view b) { return a == b; }
static bool str_starts_with(string_view a, string_view b) { return a.starts_with(b); }

template<bool str_op(string_view, string_view) = str_eql>
static bool proc_name_match(int pid, string_view name) {
    char buf[4019];
    sprintf(buf, "/proc/%d/cmdline", pid);
    if (auto fp = open_file(buf, "re")) {
        fgets(buf, sizeof(buf), fp.get());
        if (str_op(buf, name)) {
            return true;
        }
    }
    return false;
}

bool proc_context_match(int pid, string_view context) {
    char buf[PATH_MAX];
    char con[1024] = {0};

    sprintf(buf, "/proc/%d", pid);
    if (lgetfilecon(buf, byte_data{ con, sizeof(con) })) {
        return string_view(con).starts_with(context);
    }
    return false;
}

template<bool matcher(int, string_view) = &proc_name_match>
static void kill_process(const char *name, bool multi = false) {
    crawl_procfs([=](int pid) -> bool {
        if (matcher(pid, name)) {
            kill(pid, SIGKILL);
            LOGD("denylist: kill PID=[%d] (%s)\n", pid, name);
            return multi;
        }
        return true;
    });
}

static bool validate(const char *pkg, const char *proc) {
    bool pkg_valid = false;
    bool proc_valid = true;

    if (str_eql(pkg, ISOLATED_MAGIC)) {
        pkg_valid = true;
        for (char c; (c = *proc); ++proc) {
            if (isalnum(c) || c == '_' || c == '.')
                continue;
            if (c == ':')
                break;
            proc_valid = false;
            break;
        }
    } else {
        for (char c; (c = *pkg); ++pkg) {
            if (isalnum(c) || c == '_')
                continue;
            if (c == '.') {
                pkg_valid = true;
                continue;
            }
            pkg_valid = false;
            break;
        }

        for (char c; (c = *proc); ++proc) {
            if (isalnum(c) || c == '_' || c == ':' || c == '.')
                continue;
            proc_valid = false;
            break;
        }
    }
    return pkg_valid && proc_valid;
}

static bool add_hide_set(const char *pkg, const char *proc) {
    auto p = pkg_to_procs[pkg].emplace(proc);
    if (!p.second)
        return false;
    LOGI("denylist add: [%s/%s]\n", pkg, proc);
    if (!denylist_enforced)
        return true;
    if (str_eql(pkg, ISOLATED_MAGIC)) {
        // Kill all matching isolated processes
        kill_process<&proc_name_match<str_starts_with>>(proc, true);
    } else {
        kill_process(proc);
    }
    return true;
}

void scan_deny_apps() {
    if (!app_id_to_pkgs_)
        return;

    app_id_to_pkgs.clear();

    char sql[4096];
    vector<int> users;
    collect_users(users);
    for (auto it = pkg_to_procs.begin(); it != pkg_to_procs.end();) {
        if (it->first == ISOLATED_MAGIC) {
            it++;
            continue;
        }
        int app_id = get_app_id(users, it->first);
        if (app_id == 0) {
            LOGI("denylist rm: [%s]\n", it->first.data());
            ssprintf(sql, sizeof(sql), "DELETE FROM denylist WHERE package_name='%s'",
                     it->first.data());
            db_exec(sql);
            it = pkg_to_procs.erase(it);
        } else {
            update_app_id(app_id, it->first, false);
            it++;
        }
    }
}

static void clear_data() {
    pkg_to_procs_.reset(nullptr);
    app_id_to_pkgs_.reset(nullptr);
}

static bool ensure_data() {
    if (pkg_to_procs_)
        return true;

    LOGI("denylist: initializing internal data structures\n");

    default_new(pkg_to_procs_);
    bool res = db_exec("SELECT * FROM denylist", {}, [](StringSlice columns, const DbValues &values) {
        const char *package_name;
        const char *process;
        for (int i = 0; i < columns.size(); ++i) {
            const auto &name = columns[i];
            if (name == "package_name") {
                package_name = values.get_text(i);
            } else if (name == "process") {
                process = values.get_text(i);
            }
        }
        add_hide_set(package_name, process);
    });
    if (!res)
        goto error;

    default_new(app_id_to_pkgs_);
    scan_deny_apps();

    return true;

error:
    clear_data();
    return false;
}

static int add_list(const char *pkg, const char *proc) {
    if (proc[0] == '\0')
        proc = pkg;

    if (!validate(pkg, proc))
        return DenyResponse::INVALID_PKG;

    {
        mutex_guard lock(data_lock);
        if (!ensure_data())
            return DenyResponse::ERROR;
        int app_id = get_app_id(pkg);
        if (app_id == 0)
            return DenyResponse::INVALID_PKG;
        if (!add_hide_set(pkg, proc))
            return DenyResponse::ITEM_EXIST;
        auto it = pkg_to_procs.find(pkg);
        update_app_id(app_id, it->first, false);
    }

    // Add to database
    char sql[4096];
    ssprintf(sql, sizeof(sql),
            "INSERT INTO denylist (package_name, process) VALUES('%s', '%s')", pkg, proc);
    return db_exec(sql) ? DenyResponse::OK : DenyResponse::ERROR;
}

int add_list(int client) {
    string pkg = read_string(client);
    string proc = read_string(client);
    return add_list(pkg.data(), proc.data());
}

static int rm_list(const char *pkg, const char *proc) {
    {
        mutex_guard lock(data_lock);
        if (!ensure_data())
            return DenyResponse::ERROR;

        bool remove = false;

        auto it = pkg_to_procs.find(pkg);
        if (it != pkg_to_procs.end()) {
            if (proc[0] == '\0') {
                update_app_id(get_app_id(pkg), it->first, true);
                pkg_to_procs.erase(it);
                remove = true;
                LOGI("denylist rm: [%s]\n", pkg);
            } else if (it->second.erase(proc) != 0) {
                remove = true;
                LOGI("denylist rm: [%s/%s]\n", pkg, proc);
                if (it->second.empty()) {
                    update_app_id(get_app_id(pkg), it->first, true);
                    pkg_to_procs.erase(it);
                }
            }
        }

        if (!remove)
            return DenyResponse::ITEM_NOT_EXIST;
    }

    char sql[4096];
    if (proc[0] == '\0')
        ssprintf(sql, sizeof(sql), "DELETE FROM denylist WHERE package_name='%s'", pkg);
    else
        ssprintf(sql, sizeof(sql),
                "DELETE FROM denylist WHERE package_name='%s' AND process='%s'", pkg, proc);
    return db_exec(sql) ? DenyResponse::OK : DenyResponse::ERROR;
}

int rm_list(int client) {
    string pkg = read_string(client);
    string proc = read_string(client);
    return rm_list(pkg.data(), proc.data());
}

void ls_list(int client) {
    {
        mutex_guard lock(data_lock);
        if (!ensure_data()) {
            write_int(client, static_cast<int>(DenyResponse::ERROR));
            return;
        }

        scan_deny_apps();
        write_int(client,static_cast<int>(DenyResponse::OK));

        for (const auto &[pkg, procs] : pkg_to_procs) {
            for (const auto &proc : procs) {
                write_int(client, pkg.size() + proc.size() + 1);
                xwrite(client, pkg.data(), pkg.size());
                xwrite(client, "|", 1);
                xwrite(client, proc.data(), proc.size());
            }
        }
    }
    write_int(client, 0);
    close(client);
}

int enable_deny() {
    if (denylist_enforced) {
        return DenyResponse::OK;
    } else {
        mutex_guard lock(data_lock);

        if (access("/proc/self/ns/mnt", F_OK) != 0) {
            LOGW("The kernel does not support mount namespace\n");
            return DenyResponse::NO_NS;
        }

        if (procfp == nullptr && (procfp = opendir("/proc")) == nullptr)
            return DenyResponse::ERROR;

        LOGI("* Enable DenyList\n");

        if (!ensure_data())
            return DenyResponse::ERROR;

        denylist_enforced = true;

        if (!MagiskD::Get().zygisk_enabled()) {
            if (new_daemon_thread(&logcat)) {
                denylist_enforced = false;
                return DenyResponse::ERROR;
            }
        }

        // On Android Q+, also kill blastula pool and all app zygotes
        if (SDK_INT >= 29) {
            kill_process("usap32", true);
            kill_process("usap64", true);
            kill_process<&proc_context_match>("u:r:app_zygote:s0", true);
        }
    }

    MagiskD::Get().set_db_setting(DbEntryKey::DenylistConfig, true);
    return DenyResponse::OK;
}

int disable_deny() {
    if (denylist_enforced.exchange(false)) {
        LOGI("* Disable DenyList\n");
    }
    MagiskD::Get().set_db_setting(DbEntryKey::DenylistConfig, false);
    return DenyResponse::OK;
}

void initialize_denylist() {
    if (!denylist_enforced) {
        if (MagiskD::Get().get_db_setting(DbEntryKey::DenylistConfig))
            enable_deny();
    }
}

bool is_deny_target(int uid, string_view process) {
    mutex_guard lock(data_lock);
    if (!ensure_data())
        return false;

    int app_id = to_app_id(uid);
    if (app_id >= 90000) {
        if (auto it = pkg_to_procs.find(ISOLATED_MAGIC); it != pkg_to_procs.end()) {
            for (const auto &s : it->second) {
                if (process.starts_with(s))
                    return true;
            }
        }
        return false;
    } else {
        auto it = app_id_to_pkgs.find(app_id);
        if (it == app_id_to_pkgs.end())
            return false;
        for (const auto &pkg : it->second) {
            if (pkg_to_procs.find(pkg)->second.count(process))
                return true;
        }
    }
    return false;
}

void update_deny_flags(int uid, rust::Str process, uint32_t &flags) {
    if (is_deny_target(uid, { process.begin(), process.end() })) {
        flags |= +ZygiskStateFlags::ProcessOnDenyList;
    }
    if (denylist_enforced) {
        flags |= +ZygiskStateFlags::DenyListEnforced;
    }
}

```

`native/src/core/include/core.hpp`:

```hpp
#pragma once

#include <sys/socket.h>
#include <string>
#include <atomic>
#include <functional>

#include <base.hpp>

#include "../core-rs.hpp"

#define AID_ROOT   0
#define AID_SHELL  2000
#define AID_USER_OFFSET 100000

#define to_app_id(uid)  (uid % AID_USER_OFFSET)
#define to_user_id(uid) (uid / AID_USER_OFFSET)

#define SDK_INT      (MagiskD::Get().sdk_int())
#define APP_DATA_DIR (SDK_INT >= 24 ? "/data/user_de" : "/data/user")

inline int connect_daemon(RequestCode req) {
    return connect_daemon(req, false);
}

// Multi-call entrypoints
int su_client_main(int argc, char *argv[]);
int zygisk_main(int argc, char *argv[]);

struct ModuleInfo;

// Utils
const char *get_magisk_tmp();
void unlock_blocks();
bool check_key_combo();
template<typename T> requires(std::is_trivially_copyable_v<T>)
T read_any(int fd) {
    T val;
    if (xxread(fd, &val, sizeof(val)) != sizeof(val))
        return -1;
    return val;
}
template<typename T> requires(std::is_trivially_copyable_v<T>)
void write_any(int fd, T val) {
    if (fd < 0) return;
    xwrite(fd, &val, sizeof(val));
}
inline int read_int(int fd) { return read_any<int>(fd); }
inline void write_int(int fd, int val) { write_any(fd, val); }
std::string read_string(int fd);
bool read_string(int fd, std::string &str);
void write_string(int fd, std::string_view str);
template<typename T> requires(std::is_trivially_copyable_v<T>)
void write_vector(int fd, const std::vector<T> &vec) {
    write_int(fd, vec.size());
    xwrite(fd, vec.data(), vec.size() * sizeof(T));
}
template<typename T> requires(std::is_trivially_copyable_v<T>)
bool read_vector(int fd, std::vector<T> &vec) {
    int size = read_int(fd);
    vec.resize(size);
    return xread(fd, vec.data(), size * sizeof(T)) == size * sizeof(T);
}

// Scripting
void install_apk(Utf8CStr apk);
void uninstall_pkg(Utf8CStr pkg);
void exec_common_scripts(Utf8CStr stage);
void exec_module_scripts(Utf8CStr stage, const rust::Vec<ModuleInfo> &module_list);
void exec_script(Utf8CStr script);
void clear_pkg(const char *pkg, int user_id);
[[noreturn]] void install_module(Utf8CStr file);

// Denylist
extern std::atomic<bool> denylist_enforced;
int denylist_cli(rust::Vec<rust::String> &args);
void denylist_handler(int client);
void initialize_denylist();
void scan_deny_apps();
bool is_deny_target(int uid, std::string_view process);
void revert_unmount(int pid = -1) noexcept;
void update_deny_flags(int uid, rust::Str process, uint32_t &flags);

// MagiskSU
void exec_root_shell(int client, int pid, SuRequest &req, MntNsMode mode);

// Rust bindings
inline Utf8CStr get_magisk_tmp_rs() { return get_magisk_tmp(); }
inline rust::String resolve_preinit_dir_rs(Utf8CStr base_dir) {
    return resolve_preinit_dir(base_dir.c_str());
}

```

`native/src/core/include/sqlite.hpp`:

```hpp
#pragma once

#include <functional>

#include <rust/cxx.h>

#define SQLITE_OPEN_READWRITE        0x00000002  /* Ok for sqlite3_open_v2() */
#define SQLITE_OPEN_CREATE           0x00000004  /* Ok for sqlite3_open_v2() */
#define SQLITE_OPEN_NOMUTEX          0x00008000  /* Ok for sqlite3_open_v2() */

#define SQLITE_OK           0   /* Successful result */
#define SQLITE_ROW         100  /* sqlite3_step() has another row ready */
#define SQLITE_DONE        101  /* sqlite3_step() has finished executing */

struct sqlite3;
struct sqlite3_stmt;

extern const char *(*sqlite3_errstr)(int);

// Transparent wrappers of sqlite3_stmt
struct DbValues {
    const char *get_text(int index) const;
    rust::Str get_str(int index) const { return get_text(index); }
    int get_int(int index) const;
    ~DbValues() = delete;
};
struct DbStatement {
    int bind_text(int index, rust::Str val);
    int bind_int64(int index, int64_t val);
    ~DbStatement() = delete;
};

using StringSlice = rust::Slice<rust::String>;
using sql_bind_callback = int(*)(void*, int, DbStatement&);
using sql_exec_callback = void(*)(void*, StringSlice, const DbValues&);

sqlite3 *open_and_init_db();

/************
 * C++ APIs *
 ************/

using db_exec_callback = std::function<void(StringSlice, const DbValues&)>;

struct DbArg {
    enum {
        INT,
        TEXT,
    } type;
    union {
        int64_t int_val;
        rust::Str str_val;
    };
    DbArg(int64_t v) : type(INT), int_val(v) {}
    DbArg(const char *v) : type(TEXT), str_val(v) {}
};

struct DbArgs {
    DbArgs() : curr(0) {}
    DbArgs(std::initializer_list<DbArg> list) : args(list), curr(0) {}
    int operator()(int index, DbStatement &stmt);
    bool empty() const { return args.empty(); }
private:
    std::vector<DbArg> args;
    size_t curr;
};

bool db_exec(const char *sql, DbArgs args = {}, db_exec_callback exec_fn = {});

template<typename T>
concept DbData = requires(T t, StringSlice s, DbValues &v) { t(s, v); };

template<DbData T>
bool db_exec(const char *sql, DbArgs args, T &data) {
    return db_exec(sql, std::move(args), (db_exec_callback) std::ref(data));
}

```

`native/src/core/lib.rs`:

```rs
#![feature(fn_traits)]
#![feature(unix_socket_ancillary_data)]
#![feature(unix_socket_peek)]
#![feature(default_field_values)]
#![feature(peer_credentials_unix_socket)]
#![feature(sync_nonpoison)]
#![feature(nonpoison_mutex)]
#![feature(nonpoison_condvar)]
#![allow(clippy::missing_safety_doc)]

use crate::ffi::SuRequest;
use crate::socket::Encodable;
use base::derive::Decodable;
use daemon::{MagiskD, connect_daemon_for_cxx};
use logging::{android_logging, zygisk_close_logd, zygisk_get_logd, zygisk_logging};
use magisk::magisk_main;
use mount::revert_unmount;
use resetprop::{get_prop, resetprop_main};
use selinux::{lgetfilecon, setfilecon};
use socket::{recv_fd, recv_fds, send_fd};
use std::fs::File;
use std::mem::ManuallyDrop;
use std::ops::DerefMut;
use std::os::fd::FromRawFd;
use su::{get_pty_num, pump_tty};
use zygisk::zygisk_should_load_module;

mod bootstages;
#[path = "../include/consts.rs"]
mod consts;
mod daemon;
mod db;
mod logging;
mod magisk;
mod module;
mod mount;
mod package;
mod resetprop;
mod selinux;
mod socket;
mod su;
mod thread;
mod zygisk;

#[allow(clippy::needless_lifetimes)]
#[cxx::bridge]
pub mod ffi {
    #[repr(i32)]
    enum RequestCode {
        START_DAEMON,
        CHECK_VERSION,
        CHECK_VERSION_CODE,
        STOP_DAEMON,

        _SYNC_BARRIER_,

        SUPERUSER,
        ZYGOTE_RESTART,
        DENYLIST,
        SQLITE_CMD,
        REMOVE_MODULES,
        ZYGISK,

        _STAGE_BARRIER_,

        POST_FS_DATA,
        LATE_START,
        BOOT_COMPLETE,

        END,
    }

    #[repr(i32)]
    enum RespondCode {
        ERROR = -1,
        OK = 0,
        ROOT_REQUIRED,
        ACCESS_DENIED,
        END,
    }

    enum DbEntryKey {
        RootAccess,
        SuMultiuserMode,
        SuMntNs,
        DenylistConfig,
        ZygiskConfig,
        BootloopCount,
        SuManager,
    }

    #[repr(i32)]
    enum MntNsMode {
        Global,
        Requester,
        Isolate,
    }

    #[repr(i32)]
    enum SuPolicy {
        Query,
        Deny,
        Allow,
        Restrict,
    }

    struct ModuleInfo {
        name: String,
        z32: i32,
        z64: i32,
    }

    #[repr(i32)]
    enum ZygiskRequest {
        GetInfo,
        ConnectCompanion,
        GetModDir,
    }

    #[repr(u32)]
    enum ZygiskStateFlags {
        ProcessGrantedRoot = 0x00000001,
        ProcessOnDenyList = 0x00000002,
        DenyListEnforced = 0x40000000,
        ProcessIsMagiskApp = 0x80000000,
    }

    #[derive(Decodable)]
    struct SuRequest {
        target_uid: i32,
        target_pid: i32,
        login: bool,
        keep_env: bool,
        drop_cap: bool,
        shell: String,
        command: String,
        context: String,
        gids: Vec<u32>,
    }

    unsafe extern "C++" {
        #[cxx_name = "Utf8CStr"]
        type Utf8CStrRef<'a> = base::Utf8CStrRef<'a>;

        include!("include/core.hpp");

        #[cxx_name = "get_magisk_tmp_rs"]
        fn get_magisk_tmp() -> Utf8CStrRef<'static>;
        #[cxx_name = "resolve_preinit_dir_rs"]
        fn resolve_preinit_dir(base_dir: Utf8CStrRef) -> String;
        fn check_key_combo() -> bool;
        fn unlock_blocks();
        fn update_deny_flags(uid: i32, process: &str, flags: &mut u32);
        fn initialize_denylist();
        fn switch_mnt_ns(pid: i32) -> i32;
        fn exec_root_shell(client: i32, pid: i32, req: &mut SuRequest, mode: MntNsMode);

        // Scripting
        fn exec_script(script: Utf8CStrRef);
        fn exec_common_scripts(stage: Utf8CStrRef);
        fn exec_module_scripts(state: Utf8CStrRef, modules: &Vec<ModuleInfo>);
        fn install_apk(apk: Utf8CStrRef);
        fn uninstall_pkg(apk: Utf8CStrRef);
        fn install_module(zip: Utf8CStrRef);

        // Denylist
        fn denylist_cli(args: &mut Vec<String>) -> i32;
        fn denylist_handler(client: i32);
        fn scan_deny_apps();

        include!("include/sqlite.hpp");

        type sqlite3;
        type DbValues;
        type DbStatement;

        fn sqlite3_errstr(code: i32) -> *const c_char;
        fn open_and_init_db() -> *mut sqlite3;
        fn get_int(self: &DbValues, index: i32) -> i32;
        #[cxx_name = "get_str"]
        fn get_text(self: &DbValues, index: i32) -> &str;
        fn bind_text(self: Pin<&mut DbStatement>, index: i32, val: &str) -> i32;
        fn bind_int64(self: Pin<&mut DbStatement>, index: i32, val: i64) -> i32;
    }

    extern "Rust" {
        fn android_logging();
        fn zygisk_logging();
        fn zygisk_close_logd();
        fn zygisk_get_logd() -> i32;
        fn revert_unmount(pid: i32);
        fn zygisk_should_load_module(flags: u32) -> bool;
        fn send_fd(socket: i32, fd: i32) -> bool;
        fn recv_fd(socket: i32) -> i32;
        fn recv_fds(socket: i32) -> Vec<i32>;
        fn write_to_fd(self: &SuRequest, fd: i32);
        fn pump_tty(ptmx: i32, pump_stdin: bool);
        fn get_pty_num(fd: i32) -> i32;
        fn lgetfilecon(path: Utf8CStrRef, con: &mut [u8]) -> bool;
        fn setfilecon(path: Utf8CStrRef, con: Utf8CStrRef) -> bool;

        fn get_prop(name: Utf8CStrRef) -> String;
        unsafe fn resetprop_main(argc: i32, argv: *mut *mut c_char) -> i32;

        #[cxx_name = "connect_daemon"]
        fn connect_daemon_for_cxx(code: RequestCode, create: bool) -> i32;
        unsafe fn magisk_main(argc: i32, argv: *mut *mut c_char) -> i32;
    }

    // Default constructors
    extern "Rust" {
        #[Self = SuRequest]
        #[cxx_name = "New"]
        fn default() -> SuRequest;
    }

    // FFI for MagiskD
    extern "Rust" {
        type MagiskD;
        fn sdk_int(&self) -> i32;
        fn zygisk_enabled(&self) -> bool;
        fn get_db_setting(&self, key: DbEntryKey) -> i32;
        #[cxx_name = "set_db_setting"]
        fn set_db_setting_for_cxx(&self, key: DbEntryKey, value: i32) -> bool;

        #[Self = MagiskD]
        #[cxx_name = "Get"]
        fn get() -> &'static MagiskD;
    }
}

impl SuRequest {
    fn write_to_fd(&self, fd: i32) {
        unsafe {
            let mut w = ManuallyDrop::new(File::from_raw_fd(fd));
            self.encode(w.deref_mut()).ok();
        }
    }
}

```

`native/src/core/logging.rs`:

```rs
use crate::consts::{LOG_PIPE, LOGFILE};
use crate::ffi::get_magisk_tmp;
use crate::logging::LogFile::{Actual, Buffer};
use base::const_format::concatcp;
use base::{
    FsPathBuilder, LogLevel, LoggedResult, ReadExt, ResultExt, Utf8CStr, Utf8CStrBuf, WriteExt,
    cstr, libc, new_daemon_thread, raw_cstr, update_logger,
};
use bytemuck::{Pod, Zeroable, bytes_of, write_zeroes};
use libc::{PIPE_BUF, c_char, localtime_r, sigtimedwait, time_t, timespec, tm};
use nix::fcntl::OFlag;
use nix::sys::signal::{SigSet, SigmaskHow, Signal};
use nix::unistd::{Gid, Uid, chown, getpid, gettid};
use num_derive::{FromPrimitive, ToPrimitive};
use num_traits::FromPrimitive;
use std::cmp::min;
use std::fmt::Write as _;
use std::fs::File;
use std::io::{IoSlice, Read, Write};
use std::mem::ManuallyDrop;
use std::os::fd::{FromRawFd, IntoRawFd, RawFd};
use std::ptr::null_mut;
use std::sync::Arc;
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::nonpoison::Mutex;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::{fs, io};

#[allow(dead_code, non_camel_case_types)]
#[derive(FromPrimitive, ToPrimitive)]
#[repr(i32)]
enum ALogPriority {
    ANDROID_LOG_UNKNOWN = 0,
    ANDROID_LOG_DEFAULT,
    ANDROID_LOG_VERBOSE,
    ANDROID_LOG_DEBUG,
    ANDROID_LOG_INFO,
    ANDROID_LOG_WARN,
    ANDROID_LOG_ERROR,
    ANDROID_LOG_FATAL,
    ANDROID_LOG_SILENT,
}

unsafe extern "C" {
    fn __android_log_write(prio: i32, tag: *const c_char, msg: *const c_char);
    fn strftime(buf: *mut c_char, len: usize, fmt: *const c_char, tm: *const tm) -> usize;
}

fn level_to_prio(level: LogLevel) -> i32 {
    match level {
        LogLevel::Error => ALogPriority::ANDROID_LOG_ERROR as i32,
        LogLevel::Warn => ALogPriority::ANDROID_LOG_WARN as i32,
        LogLevel::Info => ALogPriority::ANDROID_LOG_INFO as i32,
        LogLevel::Debug => ALogPriority::ANDROID_LOG_DEBUG as i32,
    }
}

fn android_log_write(level: LogLevel, msg: &Utf8CStr) {
    unsafe {
        __android_log_write(level_to_prio(level), raw_cstr!("Magisk"), msg.as_ptr());
    }
}

pub fn android_logging() {
    update_logger(|logger| logger.write = android_log_write);
}

pub fn magisk_logging() {
    fn magisk_log_write(level: LogLevel, msg: &Utf8CStr) {
        android_log_write(level, msg);
        magisk_log_to_pipe(level_to_prio(level), msg);
    }
    update_logger(|logger| logger.write = magisk_log_write);
}

pub fn zygisk_logging() {
    fn zygisk_log_write(level: LogLevel, msg: &Utf8CStr) {
        android_log_write(level, msg);
        zygisk_log_to_pipe(level_to_prio(level), msg);
    }
    update_logger(|logger| logger.write = zygisk_log_write);
}

#[derive(Copy, Clone, Pod, Zeroable)]
#[repr(C)]
struct LogMeta {
    prio: i32,
    len: i32,
    pid: i32,
    tid: i32,
}

const MAX_MSG_LEN: usize = PIPE_BUF - size_of::<LogMeta>();

fn write_log_to_pipe(mut logd: &File, prio: i32, msg: &Utf8CStr) -> io::Result<usize> {
    // Truncate message if needed
    let len = min(MAX_MSG_LEN, msg.len());
    let msg = &msg.as_bytes()[..len];

    let meta = LogMeta {
        prio,
        len: len as i32,
        pid: getpid().as_raw(),
        tid: gettid().as_raw(),
    };

    let io1 = IoSlice::new(bytes_of(&meta));
    let io2 = IoSlice::new(msg);
    let result = logd.write_vectored(&[io1, io2]);
    if let Err(ref e) = result {
        let mut buf = cstr::buf::new::<256>();
        write!(buf, "Cannot write_log_to_pipe: {e}").ok();
        android_log_write(LogLevel::Error, &buf);
    }
    result
}

static MAGISK_LOGD_FD: Mutex<Option<Arc<File>>> = Mutex::new(None);

fn with_logd_fd<R, F: FnOnce(&File) -> io::Result<R>>(f: F) {
    let fd = MAGISK_LOGD_FD.lock().clone();
    if let Some(logd) = fd
        && f(&logd).is_err()
    {
        // If any error occurs, shut down the logd pipe
        *MAGISK_LOGD_FD.lock() = None;
    }
}

fn magisk_log_to_pipe(prio: i32, msg: &Utf8CStr) {
    with_logd_fd(|logd| write_log_to_pipe(logd, prio, msg));
}

// SAFETY: zygisk client code runs single threaded, so no need to prevent data race
static ZYGISK_LOGD: AtomicI32 = AtomicI32::new(-1);

pub fn zygisk_close_logd() {
    unsafe {
        libc::close(ZYGISK_LOGD.swap(-1, Ordering::Relaxed));
    }
}

pub fn zygisk_get_logd() -> i32 {
    // If we don't have the log pipe set, open the log pipe FIFO. This could actually happen
    // multiple times in the zygote daemon (parent process) because we had to close this
    // file descriptor to prevent crashing.
    //
    // For some reason, zygote sanitizes and checks FDs *before* forking. This results in the fact
    // that *every* time before zygote forks, it has to close all logging related FDs in order
    // to pass FD checks, just to have it re-initialized immediately after any
    // logging happens ¯\_(ツ)_/¯.
    //
    // To be consistent with this behavior, we also have to close the log pipe to magiskd
    // to make zygote NOT crash if necessary. We accomplish this by hooking __android_log_close
    // and closing it at the same time as the rest of logging FDs.

    let mut raw_fd = ZYGISK_LOGD.load(Ordering::Relaxed);
    if raw_fd < 0 {
        android_logging();
        let path = cstr::buf::default()
            .join_path(get_magisk_tmp())
            .join_path(LOG_PIPE);
        // Open as RW as sometimes it may block
        if let Ok(fd) = path.open(OFlag::O_RDWR | OFlag::O_CLOEXEC) {
            // Only re-enable zygisk logging if success
            zygisk_logging();
            raw_fd = fd.into_raw_fd();
            unsafe {
                libc::close(ZYGISK_LOGD.swap(raw_fd, Ordering::Relaxed));
            }
        } else {
            return -1;
        }
    }
    raw_fd
}

fn zygisk_log_to_pipe(prio: i32, msg: &Utf8CStr) {
    let fd = zygisk_get_logd();
    if fd < 0 {
        // Cannot talk to pipe, abort
        return;
    }

    // Block SIGPIPE
    let mut mask = SigSet::empty();
    mask.add(Signal::SIGPIPE);
    let orig_mask = mask.thread_swap_mask(SigmaskHow::SIG_SETMASK);

    let logd = ManuallyDrop::new(unsafe { File::from_raw_fd(fd) });
    let result = write_log_to_pipe(&logd, prio, msg);

    // Consume SIGPIPE if exists, then restore mask
    if let Ok(orig_mask) = orig_mask {
        unsafe {
            // Unfortunately nix does not have an abstraction over sigtimedwait.
            // Fallback to use raw libc function calls.
            let ts: timespec = std::mem::zeroed();
            sigtimedwait(mask.as_ref(), null_mut(), &ts);
        }
        orig_mask.thread_set_mask().ok();
    }

    // If any error occurs, shut down the logd pipe
    if result.is_err() {
        zygisk_close_logd();
    }
}

// The following is implementation for the logging daemon

enum LogFile {
    Buffer(Vec<u8>),
    Actual(File),
}

impl LogFile {
    fn as_write(&mut self) -> &mut dyn Write {
        match self {
            Buffer(e) => e,
            Actual(e) => e,
        }
    }
}

fn logfile_write_loop(mut pipe: File) -> io::Result<()> {
    let mut logfile: LogFile = Buffer(Vec::new());

    let mut meta = LogMeta::zeroed();
    let mut msg_buf = [0u8; MAX_MSG_LEN];
    let mut aux = cstr::buf::new::<64>();

    loop {
        // Read request
        write_zeroes(&mut meta);
        pipe.read_pod(&mut meta)?;

        if meta.prio < 0 {
            if let Buffer(ref mut buf) = logfile {
                fs::rename(LOGFILE, concatcp!(LOGFILE, ".bak")).ok();
                let mut out = File::create(LOGFILE)?;
                out.write_all(buf.as_slice())?;
                logfile = Actual(out);
            }
            continue;
        }

        if meta.len < 0 || meta.len > MAX_MSG_LEN as i32 {
            continue;
        }

        // Read the rest of the message
        let msg = &mut msg_buf[..(meta.len as usize)];
        pipe.read_exact(msg)?;

        // Start building the log string
        aux.clear();
        let prio = ALogPriority::from_i32(meta.prio).unwrap_or(ALogPriority::ANDROID_LOG_UNKNOWN);
        let prio = match prio {
            ALogPriority::ANDROID_LOG_VERBOSE => 'V',
            ALogPriority::ANDROID_LOG_DEBUG => 'D',
            ALogPriority::ANDROID_LOG_INFO => 'I',
            ALogPriority::ANDROID_LOG_WARN => 'W',
            ALogPriority::ANDROID_LOG_ERROR => 'E',
            // Unsupported values, skip
            _ => continue,
        };

        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or(Duration::ZERO);

        // Note: the obvious better implementation is to use the rust chrono crate, however
        // the crate cannot fetch the proper local timezone without pulling in a bunch of
        // timezone handling code. To reduce binary size, fallback to use localtime_r in libc.
        unsafe {
            let secs = now.as_secs() as time_t;
            let mut tm: tm = std::mem::zeroed();
            if localtime_r(&secs, &mut tm).is_null() {
                continue;
            }
            strftime(aux.as_mut_ptr(), aux.capacity(), raw_cstr!("%m-%d %T"), &tm);
        }

        if aux.rebuild().is_ok() {
            write!(
                aux,
                ".{:03} {:5} {:5} {} : ",
                now.subsec_millis(),
                meta.pid,
                meta.tid,
                prio
            )
            .ok();
        } else {
            continue;
        }

        let io1 = IoSlice::new(aux.as_bytes());
        let io2 = IoSlice::new(msg);
        // We don't need to care the written len because we are writing less than PIPE_BUF
        // It's guaranteed to always write the whole thing atomically
        let _ = logfile.as_write().write_vectored(&[io1, io2])?;
    }
}

pub fn setup_logfile() {
    with_logd_fd(|mut logd| {
        let meta = LogMeta {
            prio: -1,
            len: 0,
            pid: 0,
            tid: 0,
        };
        (&mut logd).write_pod(&meta)
    });
}

pub fn start_log_daemon() {
    let path = cstr::buf::default()
        .join_path(get_magisk_tmp())
        .join_path(LOG_PIPE);

    extern "C" fn logfile_writer_thread(arg: usize) -> usize {
        let file = unsafe { File::from_raw_fd(arg as RawFd) };
        logfile_write_loop(file).ok();
        // If any error occurs, shut down the logd pipe
        *MAGISK_LOGD_FD.lock() = None;
        0
    }

    let _ = || -> LoggedResult<()> {
        path.mkfifo(0o666).log_ok();
        chown(path.as_utf8_cstr(), Some(Uid::from(0)), Some(Gid::from(0)))?;
        let read = path.open(OFlag::O_RDWR | OFlag::O_CLOEXEC)?;
        let write = path.open(OFlag::O_WRONLY | OFlag::O_CLOEXEC)?;
        *MAGISK_LOGD_FD.lock() = Some(Arc::new(write));
        unsafe {
            new_daemon_thread(logfile_writer_thread, read.into_raw_fd() as usize);
        }
        Ok(())
    }();
}

```

`native/src/core/magisk.rs`:

```rs
use crate::consts::{APPLET_NAMES, MAGISK_VER_CODE, MAGISK_VERSION, POST_FS_DATA_WAIT_TIME};
use crate::daemon::connect_daemon;
use crate::ffi::{RequestCode, denylist_cli, get_magisk_tmp, install_module, unlock_blocks};
use crate::mount::find_preinit_device;
use crate::selinux::restorecon;
use crate::socket::{Decodable, Encodable};
use argh::FromArgs;
use base::{CmdArgs, EarlyExitExt, LoggedResult, Utf8CString, argh, clone_attr};
use nix::poll::{PollFd, PollFlags, PollTimeout};
use std::ffi::c_char;
use std::os::fd::AsFd;
use std::process::exit;

fn print_usage() {
    eprintln!(
        r#"Magisk - Multi-purpose Utility

Usage: magisk [applet [arguments]...]
   or: magisk [options]...

Options:
   -c                        print current binary version
   -v                        print running daemon version
   -V                        print running daemon version code
   --list                    list all available applets
   --remove-modules [-n]     remove all modules, reboot if -n is not provided
   --install-module ZIP      install a module zip file

Advanced Options (Internal APIs):
   --daemon                  manually start magisk daemon
   --stop                    remove all magisk changes and stop daemon
   --[init trigger]          callback on init triggers. Valid triggers:
                             post-fs-data, service, boot-complete, zygote-restart
   --unlock-blocks           set BLKROSET flag to OFF for all block devices
   --restorecon              restore selinux context on Magisk files
   --clone-attr SRC DEST     clone permission, owner, and selinux context
   --clone SRC DEST          clone SRC to DEST
   --sqlite SQL              exec SQL commands to Magisk database
   --path                    print Magisk tmpfs mount path
   --denylist ARGS           denylist config CLI
   --preinit-device          resolve a device to store preinit files

Available applets:
     {}
"#,
        APPLET_NAMES.join(", ")
    );
}

#[derive(FromArgs)]
struct Cli {
    #[argh(subcommand)]
    action: MagiskAction,
}

#[derive(FromArgs)]
#[argh(subcommand)]
enum MagiskAction {
    LocalVersion(LocalVersion),
    Version(Version),
    VersionCode(VersionCode),
    List(ListApplets),
    RemoveModules(RemoveModules),
    InstallModule(InstallModule),
    Daemon(StartDaemon),
    Stop(StopDaemon),
    PostFsData(PostFsData),
    Service(ServiceCmd),
    BootComplete(BootComplete),
    ZygoteRestart(ZygoteRestart),
    UnlockBlocks(UnlockBlocks),
    RestoreCon(RestoreCon),
    CloneAttr(CloneAttr),
    CloneFile(CloneFile),
    Sqlite(Sqlite),
    Path(PathCmd),
    DenyList(DenyList),
    PreInitDevice(PreInitDevice),
}

#[derive(FromArgs)]
#[argh(subcommand, name = "-c")]
struct LocalVersion {}

#[derive(FromArgs)]
#[argh(subcommand, name = "-v")]
struct Version {}

#[derive(FromArgs)]
#[argh(subcommand, name = "-V")]
struct VersionCode {}

#[derive(FromArgs)]
#[argh(subcommand, name = "--list")]
struct ListApplets {}

#[derive(FromArgs)]
#[argh(subcommand, name = "--remove-modules")]
struct RemoveModules {
    #[argh(switch, short = 'n')]
    no_reboot: bool,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "--install-module")]
struct InstallModule {
    #[argh(positional)]
    zip: Utf8CString,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "--daemon")]
struct StartDaemon {}

#[derive(FromArgs)]
#[argh(subcommand, name = "--stop")]
struct StopDaemon {}

#[derive(FromArgs)]
#[argh(subcommand, name = "--post-fs-data")]
struct PostFsData {}

#[derive(FromArgs)]
#[argh(subcommand, name = "--service")]
struct ServiceCmd {}

#[derive(FromArgs)]
#[argh(subcommand, name = "--boot-complete")]
struct BootComplete {}

#[derive(FromArgs)]
#[argh(subcommand, name = "--zygote-restart")]
struct ZygoteRestart {}

#[derive(FromArgs)]
#[argh(subcommand, name = "--unlock-blocks")]
struct UnlockBlocks {}

#[derive(FromArgs)]
#[argh(subcommand, name = "--restorecon")]
struct RestoreCon {}

#[derive(FromArgs)]
#[argh(subcommand, name = "--clone-attr")]
struct CloneAttr {
    #[argh(positional)]
    from: Utf8CString,
    #[argh(positional)]
    to: Utf8CString,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "--clone")]
struct CloneFile {
    #[argh(positional)]
    from: Utf8CString,
    #[argh(positional)]
    to: Utf8CString,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "--sqlite")]
struct Sqlite {
    #[argh(positional)]
    sql: String,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "--path")]
struct PathCmd {}

#[derive(FromArgs)]
#[argh(subcommand, name = "--denylist")]
struct DenyList {
    #[argh(positional, greedy)]
    args: Vec<String>,
}

#[derive(FromArgs)]
#[argh(subcommand, name = "--preinit-device")]
struct PreInitDevice {}

impl MagiskAction {
    fn exec(self) -> LoggedResult<i32> {
        use MagiskAction::*;
        match self {
            LocalVersion(_) => {
                #[cfg(debug_assertions)]
                println!("{MAGISK_VERSION}:MAGISK:D ({MAGISK_VER_CODE})");
                #[cfg(not(debug_assertions))]
                println!("{MAGISK_VERSION}:MAGISK:R ({MAGISK_VER_CODE})");
            }
            Version(_) => {
                let mut fd = connect_daemon(RequestCode::CHECK_VERSION, false)?;
                let ver = String::decode(&mut fd)?;
                println!("{ver}");
            }
            VersionCode(_) => {
                let mut fd = connect_daemon(RequestCode::CHECK_VERSION_CODE, false)?;
                let ver = i32::decode(&mut fd)?;
                println!("{ver}");
            }
            List(_) => {
                for name in APPLET_NAMES {
                    println!("{name}");
                }
            }
            RemoveModules(self::RemoveModules { no_reboot }) => {
                let mut fd = connect_daemon(RequestCode::REMOVE_MODULES, false)?;
                let do_reboot = !no_reboot;
                do_reboot.encode(&mut fd)?;
                return Ok(i32::decode(&mut fd)?);
            }
            InstallModule(self::InstallModule { zip }) => {
                install_module(&zip);
            }
            Daemon(_) => {
                let _ = connect_daemon(RequestCode::START_DAEMON, true)?;
            }
            Stop(_) => {
                let mut fd = connect_daemon(RequestCode::STOP_DAEMON, false)?;
                return Ok(i32::decode(&mut fd)?);
            }
            PostFsData(_) => {
                let fd = connect_daemon(RequestCode::POST_FS_DATA, true)?;
                let mut pfd = [PollFd::new(fd.as_fd(), PollFlags::POLLIN)];
                nix::poll::poll(
                    &mut pfd,
                    PollTimeout::try_from(POST_FS_DATA_WAIT_TIME * 1000)?,
                )?;
            }
            Service(_) => {
                let _ = connect_daemon(RequestCode::LATE_START, true)?;
            }
            BootComplete(_) => {
                let _ = connect_daemon(RequestCode::BOOT_COMPLETE, false)?;
            }
            ZygoteRestart(_) => {
                let _ = connect_daemon(RequestCode::ZYGOTE_RESTART, false)?;
            }
            UnlockBlocks(_) => {
                unlock_blocks();
            }
            RestoreCon(_) => {
                restorecon();
            }
            CloneAttr(self::CloneAttr { from, to }) => {
                clone_attr(&from, &to)?;
            }
            CloneFile(self::CloneFile { from, to }) => {
                from.copy_to(&to)?;
            }
            Sqlite(self::Sqlite { sql }) => {
                let mut fd = connect_daemon(RequestCode::SQLITE_CMD, false)?;
                sql.encode(&mut fd)?;
                loop {
                    let line = String::decode(&mut fd)?;
                    if line.is_empty() {
                        return Ok(0);
                    }
                    println!("{line}");
                }
            }
            Path(_) => {
                let tmp = get_magisk_tmp();
                if tmp.is_empty() {
                    return Ok(1);
                } else {
                    println!("{tmp}");
                }
            }
            DenyList(self::DenyList { mut args }) => {
                return Ok(denylist_cli(&mut args));
            }
            PreInitDevice(_) => {
                let name = find_preinit_device();
                if name.is_empty() {
                    return Ok(1);
                } else {
                    println!("{name}");
                }
            }
        };
        Ok(0)
    }
}

pub fn magisk_main(argc: i32, argv: *mut *mut c_char) -> i32 {
    if argc < 2 {
        print_usage();
        exit(1);
    }
    let mut cmds = CmdArgs::new(argc, argv.cast()).0;
    // We need to manually inject "--" so that all actions can be treated as subcommands
    cmds.insert(1, "--");
    let cli = Cli::from_args(&cmds[..1], &cmds[1..]).on_early_exit(print_usage);
    cli.action.exec().unwrap_or(1)
}

```

`native/src/core/module.rs`:

```rs
use crate::consts::{MODULEMNT, MODULEROOT, MODULEUPGRADE, WORKERDIR};
use crate::daemon::MagiskD;
use crate::ffi::{ModuleInfo, exec_module_scripts, exec_script, get_magisk_tmp};
use crate::mount::setup_module_mount;
use crate::resetprop::load_prop_file;
use base::{
    DirEntry, Directory, FsPathBuilder, LoggedResult, OsResult, ResultExt, SilentLogExt, Utf8CStr,
    Utf8CStrBuf, Utf8CString, WalkResult, clone_attr, cstr, debug, error, info, libc, raw_cstr,
    warn,
};
use nix::fcntl::OFlag;
use nix::mount::MsFlags;
use nix::unistd::UnlinkatFlags;
use std::collections::BTreeMap;
use std::os::fd::IntoRawFd;
use std::path::{Component, Path};
use std::ptr;
use std::sync::atomic::Ordering;

const MAGISK_BIN_INJECT_PARTITIONS: [&Utf8CStr; 4] = [
    cstr!("/system/"),
    cstr!("/vendor/"),
    cstr!("/product/"),
    cstr!("/system_ext/"),
];

const SECONDARY_READ_ONLY_PARTITIONS: [&Utf8CStr; 3] =
    [cstr!("/vendor"), cstr!("/product"), cstr!("/system_ext")];

type FsNodeMap = BTreeMap<String, FsNode>;

macro_rules! module_log {
    ($($args:tt)+) => {
        debug!("{:8}: {} <- {}", $($args)+)
    }
}

#[allow(unused_variables)]
fn bind_mount(reason: &str, src: &Utf8CStr, dest: &Utf8CStr, rec: bool) {
    module_log!(reason, dest, src);
    // Ignore any kind of error here. If a single bind mount fails due to selinux permissions or
    // kernel limitations, don't let it break module mount entirely.
    src.bind_mount_to(dest, rec).log_ok();
    dest.remount_mount_point_flags(MsFlags::MS_RDONLY).log_ok();
}

fn mount_dummy<'a>(
    reason: &str,
    src: &Utf8CStr,
    dest: &'a Utf8CStr,
    is_dir: bool,
) -> OsResult<'a, ()> {
    if is_dir {
        dest.mkdir(0o000)?;
    } else {
        dest.create(OFlag::O_CREAT | OFlag::O_RDONLY | OFlag::O_CLOEXEC, 0o000)?;
    }
    bind_mount(reason, src, dest, false);
    Ok(())
}

// File path that act like a stack, popping out the last element
// automatically when out of scope. Using Rust's lifetime mechanism,
// we can ensure the buffer will never be incorrectly copied or modified.
// After calling append or reborrow, the mutable reference's lifetime is
// "transferred" to the returned object, and the compiler will guarantee
// that the original mutable reference can only be reused if and only if
// the newly created instance is destroyed.
struct PathTracker<'a> {
    path: &'a mut dyn Utf8CStrBuf,
    len: usize,
}

impl PathTracker<'_> {
    fn from<'a>(path: &'a mut dyn Utf8CStrBuf) -> PathTracker<'a> {
        let len = path.len();
        PathTracker { path, len }
    }

    fn append(&mut self, name: &str) -> PathTracker<'_> {
        let len = self.path.len();
        self.path.append_path(name);
        PathTracker {
            path: self.path,
            len,
        }
    }

    fn reborrow(&mut self) -> PathTracker<'_> {
        Self::from(self.path)
    }
}

impl Drop for PathTracker<'_> {
    // Revert back to the original state after finish using the buffer
    fn drop(&mut self) {
        self.path.truncate(self.len);
    }
}

// The comments for this struct assume real = "/system/bin"
struct ModulePaths<'a> {
    real: PathTracker<'a>,
    module: PathTracker<'a>,
    module_mnt: PathTracker<'a>,
}

impl ModulePaths<'_> {
    fn new<'a>(
        real: &'a mut dyn Utf8CStrBuf,
        module: &'a mut dyn Utf8CStrBuf,
        module_mnt: &'a mut dyn Utf8CStrBuf,
    ) -> ModulePaths<'a> {
        real.append_path("/");
        module.append_path(MODULEROOT);
        module_mnt
            .append_path(get_magisk_tmp())
            .append_path(MODULEMNT);
        ModulePaths {
            real: PathTracker::from(real),
            module: PathTracker::from(module),
            module_mnt: PathTracker::from(module_mnt),
        }
    }

    fn set_module(&mut self, module: &str) -> ModulePaths<'_> {
        ModulePaths {
            real: self.real.reborrow(),
            module: self.module.append(module),
            module_mnt: self.module_mnt.append(module),
        }
    }

    fn append(&mut self, name: &str) -> ModulePaths<'_> {
        ModulePaths {
            real: self.real.append(name),
            module: self.module.append(name),
            module_mnt: self.module_mnt.append(name),
        }
    }

    // Returns "/system/bin"
    fn real(&self) -> &Utf8CStr {
        self.real.path
    }

    // Returns "/data/adb/modules/{module}/system/bin"
    fn module(&self) -> &Utf8CStr {
        self.module.path
    }

    // Returns "$MAGISK_TMP/.magisk/modules/{module}/system/bin"
    fn module_mnt(&self) -> &Utf8CStr {
        self.module_mnt.path
    }
}

// The comments for this struct assume real = "/system/bin"
struct MountPaths<'a> {
    real: PathTracker<'a>,
    worker: PathTracker<'a>,
}

impl MountPaths<'_> {
    fn new<'a>(real: &'a mut dyn Utf8CStrBuf, worker: &'a mut dyn Utf8CStrBuf) -> MountPaths<'a> {
        real.append_path("/");
        worker.append_path(get_magisk_tmp()).append_path(WORKERDIR);
        MountPaths {
            real: PathTracker::from(real),
            worker: PathTracker::from(worker),
        }
    }

    fn append(&mut self, name: &str) -> MountPaths<'_> {
        MountPaths {
            real: self.real.append(name),
            worker: self.worker.append(name),
        }
    }

    fn reborrow(&mut self) -> MountPaths<'_> {
        MountPaths {
            real: self.real.reborrow(),
            worker: self.worker.reborrow(),
        }
    }

    // Returns "/system/bin"
    fn real(&self) -> &Utf8CStr {
        self.real.path
    }

    // Returns "$MAGISK_TMP/.magisk/worker/system/bin"
    fn worker(&self) -> &Utf8CStr {
        self.worker.path
    }
}

enum FsNode {
    Directory { children: FsNodeMap },
    File { src: Utf8CString },
    Symlink { target: Utf8CString },
    MagiskLink,
    Whiteout,
}

impl FsNode {
    fn new_dir() -> FsNode {
        FsNode::Directory {
            children: BTreeMap::new(),
        }
    }

    fn collect(&mut self, mut paths: ModulePaths) -> LoggedResult<()> {
        let FsNode::Directory { children } = self else {
            return Ok(());
        };
        let mut dir = Directory::open(paths.module())?;

        while let Some(entry) = dir.read()? {
            let entry_paths = paths.append(entry.name());
            let path = entry_paths.module();
            if entry.is_dir() {
                let node = children
                    .entry(entry.name().to_string())
                    .or_insert_with(FsNode::new_dir);
                node.collect(entry_paths)?;
            } else if entry.is_symlink() {
                // Read the link and store its target
                let mut link = cstr::buf::default();
                path.read_link(&mut link)?;
                children
                    .entry(entry.name().to_string())
                    .or_insert_with(|| FsNode::Symlink {
                        target: link.to_owned(),
                    });
            } else {
                if entry.is_char_device() {
                    let attr = path.get_attr()?;
                    if attr.is_whiteout() {
                        children
                            .entry(entry.name().to_string())
                            .or_insert_with(|| FsNode::Whiteout);
                        continue;
                    }
                }
                if entry_paths.real().exists() {
                    clone_attr(entry_paths.real(), path)?;
                }
                children
                    .entry(entry.name().to_string())
                    .or_insert_with(|| FsNode::File {
                        // Make sure to mount from module_mnt, not module
                        src: entry_paths.module_mnt().to_owned(),
                    });
            }
        }

        Ok(())
    }

    // The parent node has to be tmpfs if:
    // - Target does not exist
    // - Source or target is a symlink (since we cannot bind mount symlink)
    // - Source is whiteout (used for removal)
    fn parent_should_be_tmpfs(&self, target_path: &Utf8CStr) -> bool {
        match self {
            FsNode::Directory { .. } | FsNode::File { .. } => {
                if let Ok(attr) = target_path.get_attr() {
                    attr.is_symlink()
                } else {
                    true
                }
            }
            _ => true,
        }
    }

    fn children(&mut self) -> Option<&mut FsNodeMap> {
        match self {
            FsNode::Directory { children } => Some(children),
            _ => None,
        }
    }

    fn commit(&mut self, mut path: MountPaths, is_root_dir: bool) -> LoggedResult<()> {
        match self {
            FsNode::Directory { children } => {
                let mut is_tmpfs = false;

                // First determine whether tmpfs is required
                children.retain(|name, node| {
                    if name == ".replace" {
                        return if is_root_dir {
                            warn!("Unable to replace '{}', ignore request", path.real());
                            false
                        } else {
                            is_tmpfs = true;
                            true
                        };
                    }

                    let path = path.append(name);
                    if node.parent_should_be_tmpfs(path.real()) {
                        if is_root_dir {
                            // Ignore the unsupported child node
                            warn!("Unable to add '{}', skipped", path.real());
                            return false;
                        }
                        is_tmpfs = true;
                    }
                    true
                });

                if is_tmpfs {
                    self.commit_tmpfs(path.reborrow())?;
                    // Transitioning from non-tmpfs to tmpfs, we need to actually mount the
                    // worker dir to dest after all children are committed.
                    bind_mount("move", path.worker(), path.real(), true);
                } else {
                    for (name, node) in children {
                        let path = path.append(name);
                        node.commit(path, false)?;
                    }
                }
            }
            FsNode::File { src } => {
                bind_mount("mount", src, path.real(), false);
            }
            _ => {
                error!("Unable to handle '{}': parent should be tmpfs", path.real());
            }
        }

        Ok(())
    }

    fn commit_tmpfs(&mut self, mut path: MountPaths) -> LoggedResult<()> {
        match self {
            FsNode::Directory { children } => {
                path.worker().mkdirs(0o000)?;
                if path.real().exists() {
                    clone_attr(path.real(), path.worker())?;
                } else if let Some(p) = path.worker().parent_dir() {
                    let parent = Utf8CString::from(p);
                    clone_attr(&parent, path.worker())?;
                }

                // Check whether a file named '.replace' exists
                if let Some(FsNode::File { src }) = children.remove(".replace")
                    && let Some(replace_dir) = src.parent_dir()
                {
                    for (name, node) in children {
                        let path = path.append(name);
                        match node {
                            FsNode::Directory { .. } => {
                                // For replace, we don't need to traverse any deeper for mirroring.
                                // We can simply just bind mount the module dir to worker dir.
                                let src = Utf8CString::from(replace_dir).join_path(name);
                                mount_dummy("mount", &src, path.worker(), true)?;
                            }
                            _ => node.commit_tmpfs(path)?,
                        }
                    }

                    // If performing replace, we skip mirroring
                    return Ok(());
                }

                // Traverse the real directory and mount mirror files
                if let Ok(mut dir) = Directory::open(path.real()) {
                    while let Ok(Some(entry)) = dir.read() {
                        if children.contains_key(entry.name().as_str()) {
                            // Should not be mirrored, next
                            continue;
                        }

                        let path = path.append(entry.name());

                        if entry.is_dir() {
                            // At the first glance, it looks like we can directly mount the
                            // real dir to worker dir as mirror. However, this should NOT be done,
                            // because init will track these mounts with dev.mnt, causing issues.
                            // We unfortunately have to traverse recursively for mirroring.
                            FsNode::new_dir().commit_tmpfs(path)?;
                        } else if entry.is_symlink() {
                            let mut link = cstr::buf::default();
                            entry.read_link(&mut link).log_ok();
                            FsNode::Symlink {
                                target: link.to_owned(),
                            }
                            .commit_tmpfs(path)?;
                        } else {
                            // Mount the mirror file
                            mount_dummy("mirror", path.real(), path.worker(), false)?;
                        }
                    }
                }

                // Finally, commit children
                for (name, node) in children {
                    let path = path.append(name);
                    node.commit_tmpfs(path)?;
                }
            }
            FsNode::File { src } => {
                mount_dummy("mount", src, path.worker(), false)?;
            }
            FsNode::Symlink { target } => {
                module_log!("mklink", path.worker(), target);
                path.worker().create_symlink_to(target)?;
                if path.real().exists() {
                    clone_attr(path.real(), path.worker())?;
                }
            }
            FsNode::MagiskLink => {
                if let Some(name) = path.real().file_name()
                    && name == "supolicy"
                {
                    module_log!("mklink", path.worker(), "./magiskpolicy");
                    path.worker().create_symlink_to(cstr!("./magiskpolicy"))?;
                } else {
                    module_log!("mklink", path.worker(), "./magisk");
                    path.worker().create_symlink_to(cstr!("./magisk"))?;
                }
            }
            FsNode::Whiteout => {
                module_log!("delete", path.real(), "null");
            }
        }
        Ok(())
    }
}

fn get_path_env() -> String {
    std::env::var_os("PATH")
        .and_then(|s| s.into_string().ok())
        .unwrap_or_default()
}

fn inject_magisk_bins(system: &mut FsNode, is_emulator: bool) {
    fn inject(children: &mut FsNodeMap) {
        let mut path = cstr::buf::default().join_path(get_magisk_tmp());

        // Inject binaries

        let len = path.len();
        path.append_path("magisk");
        children.insert(
            "magisk".to_string(),
            FsNode::File {
                src: path.to_owned(),
            },
        );

        path.truncate(len);
        path.append_path("magiskpolicy");
        children.insert(
            "magiskpolicy".to_string(),
            FsNode::File {
                src: path.to_owned(),
            },
        );

        // Inject applet symlinks
        children.insert("su".to_string(), FsNode::MagiskLink);
        children.insert("resetprop".to_string(), FsNode::MagiskLink);
        children.insert("supolicy".to_string(), FsNode::MagiskLink);
    }

    // Strip /system prefix to insert correct node
    fn strip_system_prefix(orig_item: &str) -> String {
        match orig_item.strip_prefix("/system/") {
            Some(rest) => format!("/{rest}"),
            None => orig_item.to_string(),
        }
    }

    let path_env = get_path_env();
    let mut candidates = vec![];

    for orig_item in path_env.split(':') {
        // Filter non-suitable paths
        if !MAGISK_BIN_INJECT_PARTITIONS
            .iter()
            .any(|p| orig_item.starts_with(p.as_str()))
        {
            continue;
        }
        // Flatten apex path is not suitable too
        if orig_item.starts_with("/system/apex/") {
            continue;
        }

        // We want to keep /system/xbin/su on emulators (for debugging)
        if is_emulator && orig_item.starts_with("/system/xbin") {
            continue;
        }

        // Override existing su first
        let su_path = Utf8CString::from(format!("{orig_item}/su"));
        if su_path.exists() {
            let item = strip_system_prefix(orig_item);
            candidates.push((item, 0));
            break;
        }

        let path = Utf8CString::from(orig_item);
        if let Ok(attr) = path.get_attr()
            && (attr.st.st_mode & 0x0001) != 0
            && let Ok(mut dir) = Directory::open(&path)
        {
            let mut count = 0;
            if dir
                .pre_order_walk(|e| {
                    if e.is_file() {
                        count += 1;
                    }
                    Ok(WalkResult::Continue)
                })
                .is_err()
            {
                // Skip, we cannot ensure the result is correct
                continue;
            }
            let item = strip_system_prefix(orig_item);
            candidates.push((item, count));
        }
    }

    // Sort by amount of files
    candidates.sort_by_key(|&(_, count)| count);

    'path_loop: for candidate in candidates {
        let components = Path::new(&candidate.0)
            .components()
            .filter(|c| matches!(c, Component::Normal(_)))
            .filter_map(|c| c.as_os_str().to_str());

        let mut curr = match system {
            FsNode::Directory { children } => children,
            _ => continue,
        };

        for dir in components {
            let node = curr.entry(dir.to_owned()).or_insert_with(FsNode::new_dir);
            match node {
                FsNode::Directory { children } => curr = children,
                _ => continue 'path_loop,
            }
        }

        // Found a suitable path, done
        inject(curr);
        return;
    }

    // If still not found, directly inject into /system/bin
    let node = system
        .children()
        .map(|c| c.entry("bin".to_string()).or_insert_with(FsNode::new_dir));
    if let Some(FsNode::Directory { children }) = node {
        inject(children)
    }
}

fn inject_zygisk_bins(name: &str, system: &mut FsNode) {
    #[cfg(target_pointer_width = "64")]
    let has_32_bit = cstr!("/system/bin/linker").exists();

    #[cfg(target_pointer_width = "32")]
    let has_32_bit = true;

    if has_32_bit {
        let lib = system
            .children()
            .map(|c| c.entry("lib".to_string()).or_insert_with(FsNode::new_dir));
        if let Some(FsNode::Directory { children }) = lib {
            let mut bin_path = cstr::buf::default().join_path(get_magisk_tmp());

            #[cfg(target_pointer_width = "64")]
            bin_path.append_path("magisk32");

            #[cfg(target_pointer_width = "32")]
            bin_path.append_path("magisk");

            // There are some devices that announce ABI as 64 bit only, but ship with linker
            // because they make use of a special 32 bit to 64 bit translator (such as tango).
            // In this case, magisk32 does not exist, so inserting it will cause bind mount
            // failure and affect module mount. Native bridge injection does not support these
            // kind of translators anyway, so simply check if magisk32 exists here.
            if bin_path.exists() {
                children.insert(
                    name.to_string(),
                    FsNode::File {
                        src: bin_path.to_owned(),
                    },
                );
            }
        }
    }

    #[cfg(target_pointer_width = "64")]
    if cstr!("/system/bin/linker64").exists() {
        let lib64 = system
            .children()
            .map(|c| c.entry("lib64".to_string()).or_insert_with(FsNode::new_dir));
        if let Some(FsNode::Directory { children }) = lib64 {
            let bin_path = cstr::buf::default()
                .join_path(get_magisk_tmp())
                .join_path("magisk");

            children.insert(
                name.to_string(),
                FsNode::File {
                    src: bin_path.to_owned(),
                },
            );
        }
    }
}

fn upgrade_modules() -> LoggedResult<()> {
    let mut upgrade = Directory::open(cstr!(MODULEUPGRADE)).silent()?;
    let root = Directory::open(cstr!(MODULEROOT))?;
    while let Some(e) = upgrade.read()? {
        if !e.is_dir() {
            continue;
        }
        let module_name = e.name();
        let mut disable = false;
        // Cleanup old module if exists
        if root.contains_path(module_name) {
            let module = root.open_as_dir_at(module_name)?;
            // If the old module is disabled, we need to also disable the new one
            disable = module.contains_path(cstr!("disable"));
            module.remove_all()?;
            root.unlink_at(module_name, UnlinkatFlags::RemoveDir)?;
        }
        info!("Upgrade / New module: {module_name}");
        e.rename_to(&root, module_name)?;
        if disable {
            let path = cstr::buf::default()
                .join_path(module_name)
                .join_path("disable");
            let _ = root.open_as_file_at(
                &path,
                OFlag::O_RDONLY | OFlag::O_CREAT | OFlag::O_CLOEXEC,
                0,
            )?;
        }
    }
    upgrade.remove_all()?;
    cstr!(MODULEUPGRADE).remove()?;
    Ok(())
}

fn for_each_module(mut func: impl FnMut(&DirEntry) -> LoggedResult<()>) -> LoggedResult<()> {
    let mut root = Directory::open(cstr!(MODULEROOT))?;
    while let Some(ref e) = root.read()? {
        if e.is_dir() && e.name() != ".core" {
            func(e)?;
        }
    }
    Ok(())
}

pub fn disable_modules() {
    for_each_module(|e| {
        let dir = e.open_as_dir()?;
        dir.open_as_file_at(
            cstr!("disable"),
            OFlag::O_RDONLY | OFlag::O_CREAT | OFlag::O_CLOEXEC,
            0,
        )?;
        Ok(())
    })
    .log_ok();
}

fn run_uninstall_script(module_name: &Utf8CStr) {
    let script = cstr::buf::default()
        .join_path(MODULEROOT)
        .join_path(module_name)
        .join_path("uninstall.sh");
    exec_script(&script);
}

pub fn remove_modules() {
    for_each_module(|e| {
        let dir = e.open_as_dir()?;
        if dir.contains_path(cstr!("uninstall.sh")) {
            run_uninstall_script(e.name());
        }
        Ok(())
    })
    .log_ok();
    cstr!(MODULEROOT).remove_all().log_ok();
}

fn collect_modules(zygisk_enabled: bool, open_zygisk: bool) -> Vec<ModuleInfo> {
    let mut modules = Vec::new();

    #[allow(unused_mut)] // It's possible that z32 and z64 are unused
    for_each_module(|e| {
        let name = e.name();
        let dir = e.open_as_dir()?;
        if dir.contains_path(cstr!("remove")) {
            info!("{name}: remove");
            if dir.contains_path(cstr!("uninstall.sh")) {
                run_uninstall_script(name);
            }
            dir.remove_all()?;
            e.unlink()?;
            return Ok(());
        }
        dir.unlink_at(cstr!("update"), UnlinkatFlags::NoRemoveDir)
            .ok();
        if dir.contains_path(cstr!("disable")) {
            return Ok(());
        }

        let mut z32 = -1;
        let mut z64 = -1;

        let is_zygisk = dir.contains_path(cstr!("zygisk"));

        if zygisk_enabled {
            // Riru and its modules are not compatible with zygisk
            if name == "riru-core" || dir.contains_path(cstr!("riru")) {
                return Ok(());
            }

            fn open_fd_safe(dir: &Directory, name: &Utf8CStr) -> i32 {
                dir.open_as_file_at(name, OFlag::O_RDONLY | OFlag::O_CLOEXEC, 0)
                    .log()
                    .map(IntoRawFd::into_raw_fd)
                    .unwrap_or(-1)
            }

            if open_zygisk && is_zygisk {
                #[cfg(target_arch = "arm")]
                {
                    z32 = open_fd_safe(&dir, cstr!("zygisk/armeabi-v7a.so"));
                }
                #[cfg(target_arch = "aarch64")]
                {
                    z32 = open_fd_safe(&dir, cstr!("zygisk/armeabi-v7a.so"));
                    z64 = open_fd_safe(&dir, cstr!("zygisk/arm64-v8a.so"));
                }
                #[cfg(target_arch = "x86")]
                {
                    z32 = open_fd_safe(&dir, cstr!("zygisk/x86.so"));
                }
                #[cfg(target_arch = "x86_64")]
                {
                    z32 = open_fd_safe(&dir, cstr!("zygisk/x86.so"));
                    z64 = open_fd_safe(&dir, cstr!("zygisk/x86_64.so"));
                }
                #[cfg(target_arch = "riscv64")]
                {
                    z64 = open_fd_safe(&dir, cstr!("zygisk/riscv64.so"));
                }
                dir.unlink_at(cstr!("zygisk/unloaded"), UnlinkatFlags::NoRemoveDir)
                    .ok();
            }
        } else {
            // Ignore zygisk modules when zygisk is not enabled
            if is_zygisk {
                info!("{name}: ignore");
                return Ok(());
            }
        }
        modules.push(ModuleInfo {
            name: name.to_string(),
            z32,
            z64,
        });
        Ok(())
    })
    .log_ok();

    if zygisk_enabled && open_zygisk {
        let mut use_memfd = true;
        let mut convert_to_memfd = |fd: i32| -> i32 {
            if fd < 0 {
                return fd;
            }
            if use_memfd {
                let memfd = unsafe {
                    libc::syscall(
                        libc::SYS_memfd_create,
                        raw_cstr!("jit-cache"),
                        libc::MFD_CLOEXEC,
                    ) as i32
                };
                if memfd >= 0 {
                    unsafe {
                        if libc::sendfile(memfd, fd, ptr::null_mut(), i32::MAX as usize) < 0 {
                            libc::close(memfd);
                        } else {
                            libc::close(fd);
                            return memfd;
                        }
                    }
                }
                // Some error occurred, don't try again
                use_memfd = false;
            }
            fd
        };

        modules.iter_mut().for_each(|m| {
            m.z32 = convert_to_memfd(m.z32);
            m.z64 = convert_to_memfd(m.z64);
        });
    }

    modules
}

impl MagiskD {
    pub fn handle_modules(&self) {
        setup_module_mount();
        upgrade_modules().ok();

        let zygisk = self.zygisk_enabled.load(Ordering::Acquire);
        let modules = collect_modules(zygisk, false);
        exec_module_scripts(cstr!("post-fs-data"), &modules);

        // Recollect modules (module scripts could remove itself)
        let modules = collect_modules(zygisk, true);
        self.apply_modules(&modules);

        self.module_list.set(modules).ok();
    }

    fn apply_modules(&self, module_list: &[ModuleInfo]) {
        let mut system = FsNode::new_dir();

        // Create buffers for paths
        let mut buf1 = cstr::buf::dynamic(256);
        let mut buf2 = cstr::buf::dynamic(256);
        let mut buf3 = cstr::buf::dynamic(256);

        let mut paths = ModulePaths::new(&mut buf1, &mut buf2, &mut buf3);

        // Step 1: Create virtual filesystem tree
        //
        // In this step, there is zero logic applied during tree construction; we simply collect and
        // record the union of all module filesystem trees under each of their /system directory.

        for info in module_list {
            let mut paths = paths.set_module(&info.name);

            // Read props
            let prop = paths.append("system.prop");
            if prop.module().exists() {
                load_prop_file(prop.module());
            }
            drop(prop);

            // Check whether skip mounting
            let skip = paths.append("skip_mount");
            if skip.module().exists() {
                continue;
            }
            drop(skip);

            // Double check whether the system folder exists
            let sys = paths.append("system");
            if sys.module().exists() {
                info!("{}: loading module files", &info.name);
                system.collect(sys).log_ok();
            }
        }

        // Step 2: Inject custom files
        //
        // Magisk provides some built-in functionality that requires augmenting the filesystem.
        // We expose several cmdline tools (e.g. su) into PATH, and the zygisk shared library
        // has to also be added into the default LD_LIBRARY_PATH for code injection.
        // We directly inject file nodes into the virtual filesystem tree we built in the previous
        // step, treating Magisk just like a special "module".

        if get_magisk_tmp() != "/sbin" || get_path_env().split(":").all(|s| s != "/sbin") {
            inject_magisk_bins(&mut system, self.is_emulator);
        }

        // Handle zygisk
        if self.zygisk_enabled.load(Ordering::Acquire) {
            let mut zygisk = self.zygisk.lock();
            zygisk.set_prop();
            inject_zygisk_bins(&zygisk.lib_name, &mut system);
        }

        // Step 3: Extract all supported read-only partition roots
        //
        // For simplicity and backwards compatibility on older Android versions, when constructing
        // Magisk modules, we always assume that there is only a single read-only partition mounted
        // at /system. However, on modern Android there are actually multiple read-only partitions
        // mounted at their respective paths. We need to extract these subtrees out of the main
        // tree and treat them as individual trees.

        let mut roots = BTreeMap::new(); /* mapOf(partition_name -> FsNode) */
        if let FsNode::Directory { children } = &mut system {
            for dir in SECONDARY_READ_ONLY_PARTITIONS {
                // Only treat these nodes as root iff it is actually a directory in rootdir
                if let Ok(attr) = dir.get_attr()
                    && attr.is_dir()
                {
                    let name = dir.trim_start_matches('/');
                    if let Some(root) = children.remove(name) {
                        roots.insert(name, root);
                    }
                }
            }
        }
        roots.insert("system", system);

        drop(paths);
        let mut paths = MountPaths::new(&mut buf1, &mut buf2);

        for (dir, mut root) in roots {
            // Step 4: Convert virtual filesystem tree into concrete operations
            //
            // Compare the virtual filesystem tree we constructed against the real filesystem
            // structure on-device to generate a series of "operations".
            // The "core" of the logic is to decide which directories need to be rebuilt in the
            // tmpfs worker directory, and real sub-nodes need to be mirrored inside it.

            let paths = paths.append(dir);
            root.commit(paths, true).log_ok();
        }
    }
}

```

`native/src/core/mount.rs`:

```rs
use crate::consts::{MODULEMNT, MODULEROOT, PREINITDEV, PREINITMIRR, WORKERDIR};
use crate::ffi::{get_magisk_tmp, resolve_preinit_dir, switch_mnt_ns};
use crate::resetprop::get_prop;
use base::{
    FsPathBuilder, LibcReturn, LoggedResult, MountInfo, ResultExt, Utf8CStr, Utf8CStrBuf, cstr,
    debug, info, libc, parse_mount_info, warn,
};
use libc::{c_uint, dev_t, major};
use nix::mount::MsFlags;
use nix::sys::stat::{Mode, SFlag, mknod};
use num_traits::AsPrimitive;
use std::cmp::Ordering::{Greater, Less};
use std::ffi::OsStr;
use std::path::{Path, PathBuf};

// Linux allocated devices: 240-254 are reserved for LOCAL/EXPERIMENTAL use.
const DYNAMIC_MAJOR_MIN: u32 = 240;
const DYNAMIC_MAJOR_MAX: u32 = 254;

pub fn setup_preinit_dir() {
    let magisk_tmp = get_magisk_tmp();

    // Mount preinit directory
    let dev_path = cstr::buf::new::<64>()
        .join_path(magisk_tmp)
        .join_path(PREINITDEV);
    if let Ok(attr) = dev_path.get_attr()
        && attr.st.st_mode & libc::S_IFMT as c_uint == libc::S_IFBLK.as_()
    {
        // DO NOT mount the block device directly, as we do not know the flags and configs
        // to properly mount the partition; mounting block devices directly as rw could cause
        // crashes if the filesystem driver is crap (e.g. some broken F2FS drivers).
        // What we do instead is to scan through the current mountinfo and find a pre-existing
        // mount point mounting our desired partition, and then bind mount the target folder.
        let preinit_dev = attr.st.st_rdev;
        let mnt_path = cstr::buf::default()
            .join_path(magisk_tmp)
            .join_path(PREINITMIRR);
        for info in parse_mount_info("self") {
            if info.root == "/" && info.device == preinit_dev {
                if !info.fs_option.split(',').any(|s| s == "rw") {
                    // Only care about rw mounts
                    continue;
                }
                let mut target = info.target;
                let target = Utf8CStr::from_string(&mut target);
                let mut preinit_dir = resolve_preinit_dir(target);
                let preinit_dir = Utf8CStr::from_string(&mut preinit_dir);
                let r = || -> LoggedResult<()> {
                    preinit_dir.mkdir(0o700)?;
                    mnt_path.mkdirs(0o755)?;
                    mnt_path.remove().ok();
                    mnt_path.create_symlink_to(preinit_dir)?;
                    Ok(())
                }();
                if r.is_ok() {
                    info!("* Found preinit dir: {}", preinit_dir);
                    return;
                }
            }
        }
    }

    warn!("mount: preinit dir not found");
}

pub fn setup_module_mount() {
    // Bind remount module root to clear nosuid
    let module_mnt = cstr::buf::default()
        .join_path(get_magisk_tmp())
        .join_path(MODULEMNT);
    let _ = || -> LoggedResult<()> {
        module_mnt.mkdir(0o755)?;
        cstr!(MODULEROOT).bind_mount_to(&module_mnt, false)?;
        module_mnt.remount_mount_point_flags(MsFlags::MS_RDONLY)?;
        Ok(())
    }();
}

pub fn clean_mounts() {
    let magisk_tmp = get_magisk_tmp();

    let mut buf = cstr::buf::default();

    let module_mnt = buf.append_path(magisk_tmp).append_path(MODULEMNT);
    module_mnt.unmount().log_ok();
    buf.clear();

    let worker_dir = buf.append_path(magisk_tmp).append_path(WORKERDIR);
    let _ = || -> LoggedResult<()> {
        worker_dir.set_mount_private(true)?;
        worker_dir.unmount()?;
        Ok(())
    }();
}

// when partitions have the same fs type, the order is:
// - data: it has sufficient space and can be safely written
// - cache: size is limited, but still can be safely written
// - klogdump: available on some Smartisan devices and can be safely written
// - metadata: size is limited, and it might cause unexpected behavior if written
// - persist: it's the last resort, as it's dangerous to write to it
#[derive(PartialEq, Eq, PartialOrd, Ord)]
enum PartId {
    Data,
    Cache,
    Klogdump,
    Metadata,
    Persist,
}

enum EncryptType {
    None,
    Block,
    File,
    Metadata,
}

pub fn find_preinit_device() -> String {
    let encrypt_type = if get_prop(cstr!("ro.crypto.state")) != "encrypted" {
        EncryptType::None
    } else if get_prop(cstr!("ro.crypto.type")) == "block" {
        EncryptType::Block
    } else if get_prop(cstr!("ro.crypto.metadata.enabled")) == "true" {
        EncryptType::Metadata
    } else {
        EncryptType::File
    };

    let mut matched_info = parse_mount_info("self")
        .into_iter()
        .filter_map(|info| {
            if info.root != "/" || !info.source.starts_with('/') || info.source.contains("/dm-") {
                return None;
            }
            match info.fs_type.as_str() {
                "ext4" | "f2fs" => (),
                _ => return None,
            }
            if !info.fs_option.split(',').any(|s| s == "rw") {
                return None;
            }
            if let Some(path) = Path::new(&info.source).parent() {
                if !path.ends_with("by-name") && !path.ends_with("block") {
                    return None;
                }
            } else {
                return None;
            }
            // use device major number to filter out device-mapper
            let maj = major(info.device as dev_t) as u32;
            if (DYNAMIC_MAJOR_MIN..=DYNAMIC_MAJOR_MAX).contains(&maj)
                && !info.source.contains("/vd")
                && !info.source.contains("/by-name/")
            {
                return None;
            }
            // take data iff it's not encrypted or file-based encrypted without metadata
            // other partitions are always taken
            match info.target.as_str() {
                "/persist" | "/mnt/vendor/persist" => Some((PartId::Persist, info)),
                "/metadata" => Some((PartId::Metadata, info)),
                "/klogdump" => Some((PartId::Klogdump, info)),
                "/cache" => Some((PartId::Cache, info)),
                "/data" => Some((PartId::Data, info))
                    .take_if(|_| matches!(encrypt_type, EncryptType::None | EncryptType::File)),
                _ => None,
            }
        })
        .collect::<Vec<_>>();

    if matched_info.is_empty() {
        return String::new();
    }

    let (_, preinit_info, _) = matched_info.select_nth_unstable_by(
        0,
        |(ap, MountInfo { fs_type: at, .. }), (bp, MountInfo { fs_type: bt, .. })| match (
            ap,
            bp,
            at.as_str() == "ext4",
            bt.as_str() == "ext4",
        ) {
            // metadata is not affected by f2fs kernel bug
            (PartId::Metadata, _, _, true) | (_, PartId::Metadata, true, _) => ap.cmp(bp),
            // otherwise, take ext4 f2fs because f2fs has a kernel bug that causes kernel panic
            (_, _, true, false) => Less,
            (_, _, false, true) => Greater,
            // if both has the same fs type, compare the mount point
            _ => ap.cmp(bp),
        },
    );
    let info = &preinit_info.1;
    let mut target = info.target.clone();
    let mut preinit_dir = resolve_preinit_dir(Utf8CStr::from_string(&mut target));
    if unsafe { libc::getuid() } == 0
        && let Ok(tmp) = std::env::var("MAGISKTMP")
        && !tmp.is_empty()
    {
        let mut buf = cstr::buf::default();
        let mirror_dir = buf.append_path(&tmp).append_path(PREINITMIRR);
        let preinit_dir = Utf8CStr::from_string(&mut preinit_dir);
        let _ = || -> LoggedResult<()> {
            preinit_dir.mkdirs(0o700)?;
            mirror_dir.mkdirs(0o755)?;
            mirror_dir.unmount().ok();
            mirror_dir.remove().ok();
            mirror_dir.create_symlink_to(preinit_dir)?;
            Ok(())
        }();
        if std::env::var_os("MAKEDEV").is_some() {
            buf.clear();
            let dev_path = buf.append_path(&tmp).append_path(PREINITDEV);
            mknod(
                dev_path.as_utf8_cstr(),
                SFlag::S_IFBLK,
                Mode::from_bits_truncate(0o600),
                info.device as dev_t,
            )
            .check_os_err("mknod", Some(dev_path), None)
            .log_ok();
        }
    }
    Path::new(&info.source)
        .file_name()
        .and_then(OsStr::to_str)
        .unwrap_or_default()
        .to_string()
}

pub fn revert_unmount(pid: i32) {
    if pid > 0 {
        if switch_mnt_ns(pid) != 0 {
            return;
        }
        debug!("denylist: handling PID=[{}]", pid);
    }

    let mut targets = Vec::new();

    // Unmount Magisk tmpfs and mounts from module files
    for info in parse_mount_info("self") {
        if info.source == "magisk" || info.root.starts_with("/adb/modules") {
            targets.push(info.target);
        }
    }

    if targets.is_empty() {
        return;
    }

    let mut prev: Option<PathBuf> = None;
    targets.sort();
    targets.retain(|target| {
        if let Some(prev) = &prev
            && Path::new(target).starts_with(prev)
        {
            return false;
        }
        prev = Some(PathBuf::from(target.clone()));
        true
    });

    for mut target in targets {
        let target = Utf8CStr::from_string(&mut target);
        if target.unmount().is_ok() {
            debug!("denylist: Unmounted ({})", target);
        }
    }
}

```

`native/src/core/package.rs`:

```rs
use crate::consts::{APP_PACKAGE_NAME, MAGISK_VER_CODE};
use crate::daemon::{AID_APP_END, AID_APP_START, AID_USER_OFFSET, MagiskD, to_app_id};
use crate::ffi::{DbEntryKey, get_magisk_tmp, install_apk, uninstall_pkg};
use base::WalkResult::{Abort, Continue, Skip};
use base::{
    BufReadExt, Directory, FsPathBuilder, LoggedResult, ReadExt, ResultExt, Utf8CStrBuf,
    Utf8CString, cstr, error, fd_get_attr, warn,
};
use bit_set::BitSet;
use nix::fcntl::OFlag;
use std::collections::BTreeMap;
use std::fs::File;
use std::io;
use std::io::{Cursor, Read, Seek, SeekFrom};
use std::os::fd::AsRawFd;
use std::time::Duration;

const EOCD_MAGIC: u32 = 0x06054B50;
const APK_SIGNING_BLOCK_MAGIC: [u8; 16] = *b"APK Sig Block 42";
const SIGNATURE_SCHEME_V2_MAGIC: u32 = 0x7109871A;
const PACKAGES_XML: &str = "/data/system/packages.xml";

macro_rules! bad_apk {
    ($msg:literal) => {
        io::Error::new(io::ErrorKind::InvalidData, concat!("cert: ", $msg))
    };
}

/*
 * A v2/v3 signed APK has the format as following
 *
 * +---------------+
 * | zip content   |
 * +---------------+
 * | signing block |
 * +---------------+
 * | central dir   |
 * +---------------+
 * | EOCD          |
 * +---------------+
 *
 * Scan from end of file to find EOCD, and figure our way back to the
 * offset of the signing block. Next, directly extract the certificate
 * from the v2 signature block.
 *
 * All structures above are mostly just for documentation purpose.
 *
 * This method extracts the first certificate of the first signer
 * within the APK v2 signature block.
 */
fn read_certificate(apk: &mut File, version: i32) -> Vec<u8> {
    let res = || -> io::Result<Vec<u8>> {
        let mut u32_val = 0u32;
        let mut u64_val = 0u64;

        // Find EOCD
        for i in 0u16.. {
            let mut comment_sz = 0u16;
            apk.seek(SeekFrom::End(-(size_of_val(&comment_sz) as i64) - i as i64))?;
            apk.read_pod(&mut comment_sz)?;

            if comment_sz == i {
                apk.seek(SeekFrom::Current(-22))?;
                let mut magic = 0u32;
                apk.read_pod(&mut magic)?;
                if magic == EOCD_MAGIC {
                    break;
                }
            }
            if i == 0xffff {
                Err(bad_apk!("invalid APK format"))?;
            }
        }

        // We are now at EOCD + sizeof(magic)
        // Seek and read central_dir_off to find the start of the central directory
        let mut central_dir_off = 0u32;
        apk.seek(SeekFrom::Current(12))?;
        apk.read_pod(&mut central_dir_off)?;

        // Code for parse APK comment to get version code
        if version >= 0 {
            let mut comment_sz = 0u16;
            apk.read_pod(&mut comment_sz)?;
            let mut comment = vec![0u8; comment_sz as usize];
            apk.read_exact(&mut comment)?;
            let mut comment = Cursor::new(&comment);
            let mut apk_ver = 0;
            comment.for_each_prop(|k, v| {
                if k == "versionCode" {
                    apk_ver = v.parse::<i32>().unwrap_or(0);
                    false
                } else {
                    true
                }
            });
            if version > apk_ver {
                Err(bad_apk!("APK version too low"))?;
            }
        }

        // Next, find the start of the APK signing block
        apk.seek(SeekFrom::Start((central_dir_off - 24) as u64))?;
        apk.read_pod(&mut u64_val)?; // u64_value = block_sz_
        let mut magic = [0u8; 16];
        apk.read_exact(&mut magic)?;
        if magic != APK_SIGNING_BLOCK_MAGIC {
            Err(bad_apk!("invalid signing block magic"))?;
        }
        let mut signing_blk_sz = 0u64;
        apk.seek(SeekFrom::Current(
            -(u64_val as i64) - (size_of_val(&signing_blk_sz) as i64),
        ))?;
        apk.read_pod(&mut signing_blk_sz)?;
        if signing_blk_sz != u64_val {
            Err(bad_apk!("invalid signing block size"))?;
        }

        // Finally, we are now at the beginning of the id-value pair sequence
        loop {
            apk.read_pod(&mut u64_val)?; // id-value pair length
            if u64_val == signing_blk_sz {
                Err(bad_apk!("cannot find certificate"))?;
            }

            let mut id = 0u32;
            apk.read_pod(&mut id)?;
            if id == SIGNATURE_SCHEME_V2_MAGIC {
                // Skip [signer sequence length] + [1st signer length] + [signed data length]
                apk.seek(SeekFrom::Current((size_of_val(&u32_val) * 3) as i64))?;

                apk.read_pod(&mut u32_val)?; // digest sequence length
                apk.seek(SeekFrom::Current(u32_val as i64))?; // skip all digests

                apk.seek(SeekFrom::Current(size_of_val(&u32_val) as i64))?; // cert sequence length
                apk.read_pod(&mut u32_val)?; // 1st cert length

                let mut cert = vec![0; u32_val as usize];
                apk.read_exact(cert.as_mut())?;
                break Ok(cert);
            } else {
                // Skip this id-value pair
                apk.seek(SeekFrom::Current(
                    u64_val as i64 - (size_of_val(&id) as i64),
                ))?;
            }
        }
    }();
    res.log().unwrap_or(vec![])
}

fn find_apk_path(pkg: &str) -> LoggedResult<Utf8CString> {
    let mut buf = cstr::buf::default();
    Directory::open(cstr!("/data/app"))?.pre_order_walk(|e| {
        if !e.is_dir() {
            return Ok(Skip);
        }
        let name_bytes = e.name().as_bytes();
        if name_bytes.starts_with(pkg.as_bytes()) && name_bytes[pkg.len()] == b'-' {
            // Found the APK path, we can abort now
            e.resolve_path(&mut buf)?;
            return Ok(Abort);
        }
        if name_bytes.starts_with(b"~~") {
            return Ok(Continue);
        }
        Ok(Skip)
    })?;
    if !buf.is_empty() {
        buf.push_str("/base.apk");
    }
    Ok(buf.to_owned())
}

enum Status {
    Installed,
    NotInstalled,
    CertMismatch,
}

pub struct ManagerInfo {
    stub_apk_fd: Option<File>,
    trusted_cert: Vec<u8>,
    repackaged_app_id: i32,
    repackaged_pkg: String,
    repackaged_cert: Vec<u8>,
    tracked_files: BTreeMap<i32, TrackedFile>,
}

impl Default for ManagerInfo {
    fn default() -> Self {
        ManagerInfo {
            stub_apk_fd: None,
            trusted_cert: Vec::new(),
            repackaged_app_id: -1,
            repackaged_pkg: String::new(),
            repackaged_cert: Vec::new(),
            tracked_files: BTreeMap::new(),
        }
    }
}

#[derive(Default)]
struct TrackedFile {
    path: Utf8CString,
    timestamp: Duration,
}

impl TrackedFile {
    fn new(path: Utf8CString) -> TrackedFile {
        let attr = match path.get_attr() {
            Ok(attr) => attr,
            Err(_) => return TrackedFile::default(),
        };
        let timestamp = Duration::new(attr.st.st_ctime as u64, attr.st.st_ctime_nsec as u32);
        TrackedFile { path, timestamp }
    }

    fn is_same(&self) -> bool {
        if self.path.is_empty() {
            return false;
        }
        let attr = match self.path.get_attr() {
            Ok(attr) => attr,
            Err(_) => return false,
        };
        let timestamp = Duration::new(attr.st.st_ctime as u64, attr.st.st_ctime_nsec as u32);
        timestamp == self.timestamp
    }
}

impl ManagerInfo {
    fn check_dyn(&mut self, daemon: &MagiskD, user: i32, pkg: &str) -> Status {
        let apk = cstr::buf::default()
            .join_path(daemon.app_data_dir())
            .join_path_fmt(user)
            .join_path(pkg)
            .join_path("dyn")
            .join_path("current.apk");
        let uid: i32;
        let cert = match apk.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC) {
            Ok(mut fd) => {
                uid = fd_get_attr(fd.as_raw_fd())
                    .map(|attr| attr.st.st_uid as i32)
                    .unwrap_or(-1);
                read_certificate(&mut fd, MAGISK_VER_CODE)
            }
            Err(_) => {
                warn!("pkg: no dyn APK, ignore");
                return Status::NotInstalled;
            }
        };

        if cert.is_empty() || cert != self.trusted_cert {
            error!("pkg: dyn APK signature mismatch: {}", apk);
            #[cfg(all(feature = "check-signature", not(debug_assertions)))]
            {
                return Status::CertMismatch;
            }
        }

        self.repackaged_app_id = to_app_id(uid);
        self.tracked_files
            .insert(user, TrackedFile::new(apk.to_owned()));
        Status::Installed
    }

    fn check_stub(&mut self, user: i32, pkg: &str) -> Status {
        let Ok(apk) = find_apk_path(pkg) else {
            return Status::NotInstalled;
        };

        let cert = match apk.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC) {
            Ok(mut fd) => read_certificate(&mut fd, -1),
            Err(_) => return Status::NotInstalled,
        };

        if cert.is_empty() || (pkg == self.repackaged_pkg && cert != self.repackaged_cert) {
            error!("pkg: repackaged APK signature invalid: {}", apk);
            uninstall_pkg(&apk);
            return Status::CertMismatch;
        }

        self.repackaged_pkg.clear();
        self.repackaged_pkg.push_str(pkg);
        self.repackaged_cert = cert;
        self.tracked_files.insert(user, TrackedFile::new(apk));
        Status::Installed
    }

    fn check_orig(&mut self, user: i32) -> Status {
        let Ok(apk) = find_apk_path(APP_PACKAGE_NAME) else {
            return Status::NotInstalled;
        };

        let cert = match apk.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC) {
            Ok(mut fd) => read_certificate(&mut fd, MAGISK_VER_CODE),
            Err(_) => return Status::NotInstalled,
        };

        if cert.is_empty() || cert != self.trusted_cert {
            error!("pkg: APK signature mismatch: {}", apk);
            #[cfg(all(feature = "check-signature", not(debug_assertions)))]
            {
                uninstall_pkg(cstr!(APP_PACKAGE_NAME));
                return Status::CertMismatch;
            }
        }

        self.tracked_files.insert(user, TrackedFile::new(apk));
        Status::Installed
    }

    fn install_stub(&mut self) {
        if let Some(ref mut stub_fd) = self.stub_apk_fd {
            // Copy the stub APK
            let tmp_apk = cstr!("/data/stub.apk");
            let result = || -> LoggedResult<()> {
                {
                    let mut tmp_apk_file = tmp_apk.create(
                        OFlag::O_WRONLY | OFlag::O_CREAT | OFlag::O_TRUNC | OFlag::O_CLOEXEC,
                        0o600,
                    )?;
                    io::copy(stub_fd, &mut tmp_apk_file)?;
                }
                // Seek the fd back to start
                stub_fd.seek(SeekFrom::Start(0))?;
                Ok(())
            }();
            if result.is_ok() {
                install_apk(tmp_apk);
            }
        }
    }

    fn get_manager(&mut self, daemon: &MagiskD, user: i32, mut install: bool) -> (i32, &str) {
        let db_pkg = daemon.get_db_string(DbEntryKey::SuManager);

        // If database changed, always re-check files
        if db_pkg != self.repackaged_pkg {
            self.tracked_files.remove(&user);
        }

        if let Some(file) = self.tracked_files.get(&user)
            && file.is_same()
        {
            // no APK
            if &file.path == PACKAGES_XML {
                if install && !daemon.is_emulator {
                    self.install_stub();
                }
                return (-1, "");
            }
            // dyn APK is still the same
            if file.path.starts_with(daemon.app_data_dir().as_str()) {
                return (
                    user * AID_USER_OFFSET + self.repackaged_app_id,
                    &self.repackaged_pkg,
                );
            }
            // stub APK is still the same
            if !self.repackaged_pkg.is_empty() {
                return if matches!(
                    self.check_dyn(daemon, user, self.repackaged_pkg.clone().as_str()),
                    Status::Installed
                ) {
                    (
                        user * AID_USER_OFFSET + self.repackaged_app_id,
                        &self.repackaged_pkg,
                    )
                } else {
                    (-1, "")
                };
            }
            // orig APK is still the same
            let uid = daemon.get_package_uid(user, APP_PACKAGE_NAME);
            return if uid < 0 {
                (-1, "")
            } else {
                (uid, APP_PACKAGE_NAME)
            };
        }

        if !db_pkg.is_empty() {
            match self.check_stub(user, &db_pkg) {
                Status::Installed => {
                    return if matches!(self.check_dyn(daemon, user, &db_pkg), Status::Installed) {
                        (
                            user * AID_USER_OFFSET + self.repackaged_app_id,
                            &self.repackaged_pkg,
                        )
                    } else {
                        (-1, "")
                    };
                }
                Status::NotInstalled => {
                    daemon.rm_db_string(DbEntryKey::SuManager).ok();
                }
                Status::CertMismatch => {
                    install = true;
                    daemon.rm_db_string(DbEntryKey::SuManager).ok();
                }
            }
        }

        self.repackaged_pkg.clear();
        self.repackaged_cert.clear();

        match self.check_orig(user) {
            Status::Installed => {
                let uid = daemon.get_package_uid(user, APP_PACKAGE_NAME);
                return if uid < 0 {
                    (-1, "")
                } else {
                    (uid, APP_PACKAGE_NAME)
                };
            }
            Status::CertMismatch => install = true,
            Status::NotInstalled => {}
        }

        // If we cannot find any manager, track packages.xml for new package installs
        self.tracked_files
            .insert(user, TrackedFile::new(PACKAGES_XML.into()));

        if install && !daemon.is_emulator {
            self.install_stub();
        }
        (-1, "")
    }
}

impl MagiskD {
    fn get_package_uid(&self, user: i32, pkg: &str) -> i32 {
        let path = cstr::buf::default()
            .join_path(self.app_data_dir())
            .join_path_fmt(user)
            .join_path(pkg);
        path.get_attr()
            .map(|attr| attr.st.st_uid as i32)
            .unwrap_or(-1)
    }

    pub fn preserve_stub_apk(&self) {
        let mut info = self.manager_info.lock();

        let apk = cstr::buf::default()
            .join_path(get_magisk_tmp())
            .join_path("stub.apk");

        if let Ok(mut fd) = apk.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC) {
            info.trusted_cert = read_certificate(&mut fd, MAGISK_VER_CODE);
            // Seek the fd back to start
            fd.seek(SeekFrom::Start(0)).log_ok();
            info.stub_apk_fd = Some(fd);
        }

        apk.remove().log_ok();
    }

    pub fn get_manager_uid(&self, user: i32) -> i32 {
        let mut info = self.manager_info.lock();
        let (uid, _) = info.get_manager(self, user, false);
        uid
    }

    pub fn get_manager(&self, user: i32, install: bool) -> (i32, String) {
        let mut info = self.manager_info.lock();
        let (uid, pkg) = info.get_manager(self, user, install);
        (uid, pkg.to_string())
    }

    pub fn ensure_manager(&self) {
        let mut info = self.manager_info.lock();
        let _ = info.get_manager(self, 0, true);
    }

    // app_id = app_no + AID_APP_START
    // app_no range: [0, 9999]
    pub fn get_app_no_list(&self) -> BitSet {
        let mut list = BitSet::new();
        let _ = || -> LoggedResult<()> {
            let mut app_data_dir = Directory::open(self.app_data_dir())?;
            // For each user
            loop {
                let entry = match app_data_dir.read()? {
                    None => break,
                    Some(e) => e,
                };
                let mut user_dir = match entry.open_as_dir() {
                    Err(_) => continue,
                    Ok(dir) => dir,
                };
                // For each package
                loop {
                    match user_dir.read()? {
                        None => break,
                        Some(e) => {
                            let mut entry_path = cstr::buf::default();
                            e.resolve_path(&mut entry_path)?;
                            let attr = entry_path.get_attr()?;
                            let app_id = to_app_id(attr.st.st_uid as i32);
                            if (AID_APP_START..=AID_APP_END).contains(&app_id) {
                                let app_no = app_id - AID_APP_START;
                                list.insert(app_no as usize);
                            }
                        }
                    }
                }
            }
            Ok(())
        }();
        list
    }
}

```

`native/src/core/resetprop/cli.rs`:

```rs
use super::persist::{
    persist_delete_prop, persist_get_all_props, persist_get_prop, persist_set_prop,
};
use super::{PropInfo, PropReader, SYS_PROP};
use argh::{EarlyExit, FromArgs, MissingRequirements};
use base::libc::PROP_VALUE_MAX;
use base::{
    BufReadExt, CmdArgs, EarlyExitExt, LogLevel, LoggedResult, ResultExt, Utf8CStr, Utf8CStrBuf,
    Utf8CString, argh, cstr, debug, log_err, set_log_level_state,
};
use nix::fcntl::OFlag;
use std::collections::BTreeMap;
use std::ffi::c_char;
use std::io::BufReader;

#[derive(FromArgs, Default)]
struct ResetProp {
    #[argh(switch, short = 'v')]
    verbose: bool,
    #[argh(switch, short = 'w', long = none)]
    wait_mode: bool,
    #[argh(switch, short = 'p', long = none)]
    persist: bool,
    #[argh(switch, short = 'P', long = none)]
    persist_only: bool,
    #[argh(switch, short = 'Z', long = none)]
    context: bool,
    #[argh(switch, short = 'n', long = none)]
    skip_svc: bool,
    #[argh(option, short = 'f')]
    file: Option<Utf8CString>,
    #[argh(option, short = 'd', long = "delete")]
    delete_key: Option<Utf8CString>,
    #[argh(positional, greedy = true)]
    args: Vec<Utf8CString>,
}

fn print_usage(cmd: &str) {
    eprintln!(
        r#"resetprop - System Property Manipulation Tool

Usage: {cmd} [flags] [arguments...]

Read mode arguments:
   (no arguments)    print all properties
   NAME              get property of NAME

Write mode arguments:
   NAME VALUE        set property NAME as VALUE
   -f,--file   FILE  load and set properties from FILE
   -d,--delete NAME  delete property

Wait mode arguments (toggled with -w):
    NAME             wait until property NAME changes
    NAME OLD_VALUE   if value of property NAME is not OLD_VALUE, get value
                     or else wait until property NAME changes

General flags:
   -h,--help         show this message
   -v,--verbose      print verbose output to stderr
   -w                switch to wait mode

Read mode flags:
   -p      also read persistent properties from storage
   -P      only read persistent properties from storage
   -Z      get property context instead of value

Write mode flags:
   -n      set properties bypassing property_service
   -p      always write persistent prop changes to storage
"#
    );
}

impl ResetProp {
    fn get(&self, key: &Utf8CStr) -> Option<String> {
        if self.context {
            return Some(SYS_PROP.get_context(key).to_string());
        }

        let mut val = if !self.persist_only {
            SYS_PROP.find(key).map(|info| {
                let mut v = String::new();
                info.read(&mut PropReader::Value(&mut v));
                debug!("resetprop: get prop [{key}]=[{v}]");
                v
            })
        } else {
            None
        };

        if val.is_none() && (self.persist || self.persist_only) && key.starts_with("persist.") {
            val = persist_get_prop(key).ok();
        }

        if val.is_none() {
            debug!("resetprop: prop [{key}] does not exist");
        }

        val
    }

    fn print_all(&self) {
        let mut map: BTreeMap<String, String> = BTreeMap::new();
        if !self.persist_only {
            SYS_PROP.for_each(&mut PropReader::List(&mut map));
        }
        if self.persist || self.persist_only {
            persist_get_all_props(&mut PropReader::List(&mut map)).log_ok();
        }
        for (mut k, v) in map.into_iter() {
            if self.context {
                println!(
                    "[{k}]: [{}]",
                    SYS_PROP.get_context(Utf8CStr::from_string(&mut k))
                );
            } else {
                println!("[{k}]: [{v}]");
            }
        }
    }

    fn set(&self, key: &Utf8CStr, val: &Utf8CStr) {
        let mut skip_svc = self.skip_svc;
        let mut info = SYS_PROP.find_mut(key);

        // Delete existing read-only properties if they are or will be long properties,
        // which cannot directly go through __system_property_update
        if key.starts_with("ro.") {
            skip_svc = true;
            if let Some(pi) = &info
                && (pi.is_long() || val.len() >= PROP_VALUE_MAX as usize)
            {
                // Skip pruning nodes as we will add it back ASAP
                SYS_PROP.delete(key, false);
                info = None;
            }
        }

        #[allow(unused_variables)]
        let msg = if skip_svc {
            "direct modification"
        } else {
            "property_service"
        };

        if let Some(pi) = info {
            if skip_svc {
                pi.update(val);
            } else {
                SYS_PROP.set(key, val);
            }
            debug!("resetprop: update prop [{key}]=[{val}] by {msg}");
        } else {
            if skip_svc {
                SYS_PROP.add(key, val);
            } else {
                SYS_PROP.set(key, val);
            }
            debug!("resetprop: create prop [{key}]=[{val}] by {msg}");
        }

        // When bypassing property_service, persistent props won't be stored in storage.
        // Explicitly handle this situation.
        if skip_svc && self.persist && key.starts_with("persist.") {
            persist_set_prop(key, val).log_ok();
        }
    }

    fn delete(&self, key: &Utf8CStr) -> bool {
        debug!("resetprop: delete prop [{key}]");
        let mut ret = false;
        ret |= SYS_PROP.delete(key, true);
        if self.persist && key.starts_with("persist.") {
            ret |= persist_delete_prop(key).is_ok()
        }
        ret
    }

    fn wait(&self) {
        let key = &self.args[0];
        let val = self.args.get(1).map(|s| &**s);

        // Find PropInfo
        let info: &PropInfo;
        loop {
            let i = SYS_PROP.find(key);
            if let Some(i) = i {
                info = i;
                break;
            } else {
                debug!("resetprop: waiting for prop [{key}] to exist");
                let mut serial = SYS_PROP.area_serial();
                SYS_PROP.wait(None, serial, &mut serial);
            }
        }

        if let Some(val) = val {
            let mut curr_val = String::new();
            let mut serial = 0;
            loop {
                let mut r = PropReader::ValueSerial(&mut curr_val, &mut serial);
                SYS_PROP.read(info, &mut r);
                if *val != *curr_val {
                    debug!("resetprop: get prop [{key}]=[{curr_val}]");
                    break;
                }
                debug!("resetprop: waiting for prop [{key}]!=[{val}]");
                SYS_PROP.wait(Some(info), serial, &mut serial);
            }
        }
    }

    fn load_file(&self, file: &Utf8CStr) -> LoggedResult<()> {
        let fd = file.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC)?;
        let mut key = cstr::buf::dynamic(128);
        let mut val = cstr::buf::dynamic(128);
        BufReader::new(fd).for_each_prop(|k, v| {
            key.clear();
            val.clear();
            key.push_str(k);
            val.push_str(v);
            self.set(&key, &val);
            true
        });
        Ok(())
    }

    fn run(self) -> LoggedResult<()> {
        if self.wait_mode {
            self.wait();
        } else if let Some(file) = &self.file {
            self.load_file(file)?;
        } else if let Some(key) = &self.delete_key {
            if !self.delete(key) {
                return log_err!();
            }
        } else {
            match self.args.len() {
                0 => self.print_all(),
                1 => {
                    if let Some(val) = self.get(&self.args[0]) {
                        println!("{val}");
                    } else {
                        return log_err!();
                    }
                }
                2 => self.set(&self.args[0], &self.args[1]),
                _ => unreachable!(),
            }
        }
        Ok(())
    }
}

pub fn resetprop_main(argc: i32, argv: *mut *mut c_char) -> i32 {
    set_log_level_state(LogLevel::Debug, false);
    let cmds = CmdArgs::new(argc, argv.cast());
    let cmds = cmds.as_slice();

    let cli = ResetProp::from_args(&[cmds[0]], &cmds[1..])
        .and_then(|cli| {
            let mut special_mode = 0;
            if cli.wait_mode {
                if cli.args.is_empty() {
                    let mut missing = MissingRequirements::default();
                    missing.missing_positional_arg("NAME");
                    missing.err_on_any()?;
                }
                special_mode += 1;
            }
            if cli.file.is_some() {
                special_mode += 1;
            }
            if cli.delete_key.is_some() {
                special_mode += 1;
            }
            if special_mode > 1 {
                return Err(EarlyExit::from(
                    "Multiple operation mode detected!\n".to_string(),
                ));
            }
            if cli.args.len() > 2 {
                return Err(EarlyExit::from(format!(
                    "Unrecognized argument: {}\n",
                    cli.args[2]
                )));
            }
            Ok(cli)
        })
        .on_early_exit(|| print_usage(cmds[0]));

    if cli.verbose {
        set_log_level_state(LogLevel::Debug, true);
    }

    if cli.run().is_ok() { 0 } else { 1 }
}

// Magisk's own helper functions

pub fn set_prop(key: &Utf8CStr, val: &Utf8CStr) {
    let prop = ResetProp {
        // All Magisk's internal usage should skip property_service
        skip_svc: true,
        ..Default::default()
    };
    prop.set(key, val);
}

pub fn load_prop_file(file: &Utf8CStr) {
    let prop = ResetProp {
        // All Magisk's internal usage should skip property_service
        skip_svc: true,
        ..Default::default()
    };
    prop.load_file(file).ok();
}

pub fn get_prop(key: &Utf8CStr) -> String {
    let prop = ResetProp {
        persist: key.starts_with("persist."),
        ..Default::default()
    };
    prop.get(key).unwrap_or_default()
}

```

`native/src/core/resetprop/mod.rs`:

```rs
use base::libc::c_char;
use base::{Utf8CStr, libc};
pub use cli::{get_prop, load_prop_file, resetprop_main, set_prop};
use libc::timespec;
use std::collections::BTreeMap;
use std::ffi::CStr;
use std::ptr;
use std::sync::LazyLock;

mod cli;
mod persist;
mod proto;

static SYS_PROP: LazyLock<SysProp> = LazyLock::new(|| unsafe { get_sys_prop() });

#[repr(C)]
struct PropInfo {
    _private: cxx::private::Opaque,
}

type CharPtr = *const c_char;
type ReadCallback = unsafe extern "C" fn(&mut PropReader, CharPtr, CharPtr, u32);
type ForEachCallback = unsafe extern "C" fn(&PropInfo, &mut PropReader);

enum PropReader<'a> {
    Value(&'a mut String),
    ValueSerial(&'a mut String, &'a mut u32),
    List(&'a mut BTreeMap<String, String>),
}

impl PropReader<'_> {
    fn put_cstr(&mut self, key: CharPtr, val: CharPtr, serial: u32) {
        let key = unsafe { CStr::from_ptr(key) };
        let val = unsafe { CStr::from_ptr(val) };
        match self {
            PropReader::Value(v) => {
                **v = String::from_utf8_lossy(val.to_bytes()).into_owned();
            }
            PropReader::ValueSerial(v, s) => {
                **v = String::from_utf8_lossy(val.to_bytes()).into_owned();
                **s = serial;
            }
            PropReader::List(map) => {
                map.insert(
                    String::from_utf8_lossy(key.to_bytes()).into_owned(),
                    String::from_utf8_lossy(val.to_bytes()).into_owned(),
                );
            }
        }
    }

    fn put_str(&mut self, key: String, val: String, serial: u32) {
        match self {
            PropReader::Value(v) => {
                **v = val;
            }
            PropReader::ValueSerial(v, s) => {
                **v = val;
                **s = serial;
            }
            PropReader::List(map) => {
                map.insert(key, val);
            }
        }
    }
}

unsafe extern "C" {
    // SAFETY: the improper_ctypes warning is about PropReader. We only pass PropReader
    // to C functions as raw pointers, and all actual usage happens on the Rust side.
    #[allow(improper_ctypes)]
    fn get_sys_prop() -> SysProp;

    fn prop_info_is_long(info: &PropInfo) -> bool;
    #[link_name = "__system_property_find2"]
    fn sys_prop_find(key: CharPtr) -> Option<&'static mut PropInfo>;
    #[link_name = "__system_property_update2"]
    fn sys_prop_update(info: &mut PropInfo, val: CharPtr, val_len: u32) -> i32;
    #[link_name = "__system_property_add2"]
    fn sys_prop_add(key: CharPtr, key_len: u32, val: CharPtr, val_len: u32) -> i32;
    #[link_name = "__system_property_delete"]
    fn sys_prop_delete(key: CharPtr, prune: bool) -> i32;
    #[link_name = "__system_property_get_context"]
    fn sys_prop_get_context(key: CharPtr) -> CharPtr;
    #[link_name = "__system_property_area_serial2"]
    fn sys_prop_area_serial() -> u32;
}

#[repr(C)]
struct SysProp {
    set: unsafe extern "C" fn(CharPtr, CharPtr) -> i32,
    find: unsafe extern "C" fn(CharPtr) -> Option<&'static PropInfo>,
    read_callback: unsafe extern "C" fn(&PropInfo, ReadCallback, &mut PropReader) -> i32,
    foreach: unsafe extern "C" fn(ForEachCallback, &mut PropReader) -> i32,
    wait: unsafe extern "C" fn(Option<&PropInfo>, u32, &mut u32, *const timespec) -> i32,
}

// Safe abstractions over raw C APIs

impl PropInfo {
    fn read(&self, reader: &mut PropReader) {
        SYS_PROP.read(self, reader);
    }

    fn update(&mut self, val: &Utf8CStr) {
        SYS_PROP.update(self, val);
    }

    fn is_long(&self) -> bool {
        unsafe { prop_info_is_long(self) }
    }
}

impl SysProp {
    fn read(&self, info: &PropInfo, reader: &mut PropReader) {
        unsafe extern "C" fn read_fn(r: &mut PropReader, key: CharPtr, val: CharPtr, serial: u32) {
            r.put_cstr(key, val, serial);
        }
        unsafe {
            (self.read_callback)(info, read_fn, reader);
        }
    }

    fn find(&self, key: &Utf8CStr) -> Option<&'static PropInfo> {
        unsafe { (self.find)(key.as_ptr()) }
    }

    fn find_mut(&self, key: &Utf8CStr) -> Option<&'static mut PropInfo> {
        unsafe { sys_prop_find(key.as_ptr()) }
    }

    fn set(&self, key: &Utf8CStr, val: &Utf8CStr) {
        unsafe {
            (self.set)(key.as_ptr(), val.as_ptr());
        }
    }

    fn add(&self, key: &Utf8CStr, val: &Utf8CStr) {
        unsafe {
            sys_prop_add(
                key.as_ptr(),
                key.len() as u32,
                val.as_ptr(),
                val.len() as u32,
            );
        }
    }

    fn update(&self, info: &mut PropInfo, val: &Utf8CStr) {
        unsafe {
            sys_prop_update(info, val.as_ptr(), val.len() as u32);
        }
    }

    fn delete(&self, key: &Utf8CStr, prune: bool) -> bool {
        unsafe { sys_prop_delete(key.as_ptr(), prune) == 0 }
    }

    fn for_each(&self, reader: &mut PropReader) {
        unsafe extern "C" fn for_each_fn(info: &PropInfo, vals: &mut PropReader) {
            SYS_PROP.read(info, vals);
        }
        unsafe {
            (self.foreach)(for_each_fn, reader);
        }
    }

    fn wait(&self, info: Option<&PropInfo>, old_serial: u32, new_serial: &mut u32) {
        unsafe {
            (self.wait)(info, old_serial, new_serial, ptr::null());
        }
    }

    fn get_context(&self, key: &Utf8CStr) -> &'static Utf8CStr {
        unsafe { Utf8CStr::from_ptr_unchecked(sys_prop_get_context(key.as_ptr())) }
    }

    fn area_serial(&self) -> u32 {
        unsafe { sys_prop_area_serial() }
    }
}

```

`native/src/core/resetprop/persist.rs`:

```rs
use nix::fcntl::OFlag;
use quick_protobuf::{BytesReader, MessageRead, MessageWrite, Writer};
use std::fs::File;
use std::io::{BufWriter, Read, Write};
use std::os::fd::FromRawFd;

use crate::resetprop::PropReader;
use crate::resetprop::proto::persistent_properties::PersistentProperties;
use crate::resetprop::proto::persistent_properties::mod_PersistentProperties::PersistentPropertyRecord;
use base::const_format::concatcp;
use base::libc::mkstemp;
use base::{
    Directory, FsPathBuilder, LibcReturn, LoggedResult, MappedFile, SilentLogExt, Utf8CStr,
    Utf8CStrBuf, WalkResult, clone_attr, cstr, debug, log_err,
};

const PERSIST_PROP_DIR: &str = "/data/property";
const PERSIST_PROP: &str = concatcp!(PERSIST_PROP_DIR, "/persistent_properties");

trait PropExt {
    fn find_index(&self, name: &Utf8CStr) -> Result<usize, usize>;
    fn find(self, name: &Utf8CStr) -> Option<PersistentPropertyRecord>;
}

impl PropExt for PersistentProperties {
    fn find_index(&self, name: &Utf8CStr) -> Result<usize, usize> {
        self.properties
            .binary_search_by(|p| p.name.as_deref().cmp(&Some(name.as_str())))
    }

    fn find(self, name: &Utf8CStr) -> Option<PersistentPropertyRecord> {
        let idx = self.find_index(name).ok()?;
        self.properties.into_iter().nth(idx)
    }
}

fn check_proto() -> bool {
    cstr!(PERSIST_PROP).exists()
}

fn file_get_prop(name: &Utf8CStr) -> LoggedResult<String> {
    let path = cstr::buf::default()
        .join_path(PERSIST_PROP_DIR)
        .join_path(name);
    let mut file = path.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC).silent()?;
    debug!("resetprop: read prop from [{}]", path);
    let mut s = String::new();
    file.read_to_string(&mut s)?;
    Ok(s)
}

fn file_set_prop(name: &Utf8CStr, value: Option<&Utf8CStr>) -> LoggedResult<()> {
    let path = cstr::buf::default()
        .join_path(PERSIST_PROP_DIR)
        .join_path(name);
    if let Some(value) = value {
        let mut tmp = cstr::buf::default()
            .join_path(PERSIST_PROP_DIR)
            .join_path("prop.XXXXXX");
        {
            let mut f = unsafe {
                mkstemp(tmp.as_mut_ptr())
                    .into_os_result("mkstemp", None, None)
                    .map(|fd| File::from_raw_fd(fd))?
            };
            f.write_all(value.as_bytes())?;
        }
        debug!("resetprop: write prop to [{}]", tmp);
        tmp.rename_to(&path)?
    } else {
        path.remove().silent()?;
        debug!("resetprop: unlink [{}]", path);
    }
    Ok(())
}

fn proto_read_props() -> LoggedResult<PersistentProperties> {
    debug!("resetprop: decode with protobuf [{}]", PERSIST_PROP);
    let m = MappedFile::open(cstr!(PERSIST_PROP))?;
    let m = m.as_ref();
    let mut r = BytesReader::from_bytes(m);
    let mut props = PersistentProperties::from_reader(&mut r, m)?;
    // Keep the list sorted for binary search
    props
        .properties
        .sort_unstable_by(|a, b| a.name.cmp(&b.name));
    Ok(props)
}

fn proto_write_props(props: &PersistentProperties) -> LoggedResult<()> {
    let mut tmp = cstr::buf::default().join_path(concatcp!(PERSIST_PROP, ".XXXXXX"));
    {
        let f = unsafe {
            mkstemp(tmp.as_mut_ptr())
                .into_os_result("mkstemp", None, None)
                .map(|fd| File::from_raw_fd(fd))?
        };
        debug!("resetprop: encode with protobuf [{}]", tmp);
        props.write_message(&mut Writer::new(BufWriter::new(f)))?;
    }
    clone_attr(cstr!(PERSIST_PROP), &tmp)?;
    tmp.rename_to(cstr!(PERSIST_PROP))?;
    Ok(())
}

pub(super) fn persist_get_prop(key: &Utf8CStr) -> LoggedResult<String> {
    if check_proto() {
        let props = proto_read_props()?;
        let prop = props.find(key).silent()?;
        if let PersistentPropertyRecord {
            name: Some(_),
            value: Some(v),
        } = prop
        {
            return Ok(v);
        }
    } else {
        let value = file_get_prop(key)?;
        debug!("resetprop: get persist prop [{}]=[{}]", key, value);
        return Ok(value);
    }
    log_err!()
}

pub(super) fn persist_get_all_props(reader: &mut PropReader) -> LoggedResult<()> {
    if check_proto() {
        let props = proto_read_props()?;
        props.properties.into_iter().for_each(|prop| {
            if let PersistentPropertyRecord {
                name: Some(n),
                value: Some(v),
            } = prop
            {
                reader.put_str(n, v, 0);
            }
        });
    } else {
        let mut dir = Directory::open(cstr!(PERSIST_PROP_DIR))?;
        dir.pre_order_walk(|e| {
            if e.is_file()
                && let Ok(value) = file_get_prop(e.name())
            {
                reader.put_str(e.name().to_string(), value, 0);
            }
            // Do not traverse recursively
            Ok(WalkResult::Skip)
        })?;
    }
    Ok(())
}

pub(super) fn persist_delete_prop(key: &Utf8CStr) -> LoggedResult<()> {
    if check_proto() {
        let mut props = proto_read_props()?;
        let idx = props.find_index(key).silent()?;
        props.properties.remove(idx);
        proto_write_props(&props)?;
    } else {
        file_set_prop(key, None)?;
    }
    Ok(())
}

pub(super) fn persist_set_prop(key: &Utf8CStr, val: &Utf8CStr) -> LoggedResult<()> {
    if check_proto() {
        let mut props = proto_read_props()?;
        match props.find_index(key) {
            Ok(idx) => props.properties[idx].value = Some(val.to_string()),
            Err(idx) => props.properties.insert(
                idx,
                PersistentPropertyRecord {
                    name: Some(key.to_string()),
                    value: Some(val.to_string()),
                },
            ),
        }
        proto_write_props(&props)?;
    } else {
        file_set_prop(key, Some(val))?;
    }
    Ok(())
}

```

`native/src/core/resetprop/proto/persistent_properties.proto`:

```proto
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
syntax = "proto2";
option optimize_for = LITE_RUNTIME;
message PersistentProperties {
  message PersistentPropertyRecord {
    optional string name = 1;
    optional string value = 2;
  }
  repeated PersistentPropertyRecord properties = 1;
}

```

`native/src/core/resetprop/sys.cpp`:

```cpp
#include <dlfcn.h>

#include <base.hpp>
#include <core.hpp>

#include <api/system_properties.h>
#include <system_properties/prop_info.h>

using namespace std;

// This has to keep in sync with SysProp in mod.rs
struct SysProp {
    int (*set)(const char*, const char*);
    const prop_info *(*find)(const char*);
    void (*read_callback)(const prop_info*, void (*)(void*, const char*, const char*, uint32_t), void*);
    int (*foreach)(void (*)(const prop_info*, void*), void*);
    bool (*wait)(const prop_info*, uint32_t, uint32_t*, const timespec*);
};

extern "C" bool prop_info_is_long(const prop_info &info) {
    return info.is_long();
}

extern "C" SysProp get_sys_prop() {
    SysProp prop{};
#ifdef APPLET_STUB_MAIN
    // Use internal implementation
    prop.set = __system_property_set;
    prop.find = __system_property_find;
    prop.read_callback = __system_property_read_callback;
    prop.foreach = __system_property_foreach;
    prop.wait = __system_property_wait;
#else
#define DLOAD(name) (*(void **) &prop.name = dlsym(RTLD_DEFAULT, "__system_property_" #name))
    // Dynamic load platform implementation
    DLOAD(set);
    DLOAD(find);
    DLOAD(read_callback);
    DLOAD(foreach);
    DLOAD(wait);
#undef DLOAD
    if (prop.wait == nullptr) {
        // This platform API only exist on API 26+
        prop.wait = __system_property_wait;
    }
    if (prop.read_callback == nullptr) {
        // This platform API only exist on API 26+
        prop.read_callback = __system_property_read_callback;
    }
#endif
    if (__system_properties_init()) {
        LOGE("resetprop: __system_properties_init error\n");
    }
    return prop;
}

```

`native/src/core/scripting.cpp`:

```cpp
#include <string>
#include <vector>
#include <sys/wait.h>

#include <consts.hpp>
#include <base.hpp>
#include <core.hpp>

using namespace std;

#define BBEXEC_CMD bbpath(), "sh"

static const char *bbpath() {
    static string path;
    path = get_magisk_tmp();
    path += "/" BBPATH "/busybox";
    if (access(path.data(), X_OK) != 0) {
        path = DATABIN "/busybox";
    }
    return path.data();
}

static void set_script_env() {
    setenv("ASH_STANDALONE", "1", 1);
    char new_path[4096];
    ssprintf(new_path, sizeof(new_path), "%s:%s", getenv("PATH"), get_magisk_tmp());
    setenv("PATH", new_path, 1);
    if (MagiskD::Get().zygisk_enabled())
        setenv("ZYGISK_ENABLED", "1", 1);
};

void exec_script(Utf8CStr script) {
    exec_t exec {
        .pre_exec = set_script_env,
        .fork = fork_no_orphan
    };
    exec_command_sync(exec, BBEXEC_CMD, script.c_str());
}

static timespec pfs_timeout;

#define PFS_SETUP() \
if (pfs) { \
    if (int pid = xfork()) { \
        if (pid < 0) \
            return; \
        /* In parent process, simply wait for child to finish */ \
        waitpid(pid, nullptr, 0); \
        return; \
    } \
    timer_pid = xfork(); \
    if (timer_pid == 0) { \
        /* In timer process, count down */ \
        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &pfs_timeout, nullptr); \
        exit(0); \
    } \
}

#define PFS_WAIT() \
if (pfs) { \
    /* If we ran out of time, don't block */ \
    if (timer_pid < 0) \
        continue; \
    if (int pid = waitpid(-1, nullptr, 0); pid == timer_pid) { \
        LOGW("* post-fs-data scripts blocking phase timeout\n"); \
        timer_pid = -1; \
    } \
}

#define PFS_DONE() \
if (pfs) { \
    if (timer_pid > 0) \
        kill(timer_pid, SIGKILL); \
    exit(0); \
}

void exec_common_scripts(Utf8CStr stage) {
    LOGI("* Running %s.d scripts\n", stage.c_str());
    char path[4096];
    char *name = path + sprintf(path, SECURE_DIR "/%s.d", stage.c_str());
    auto dir = xopen_dir(path);
    if (!dir) return;

    bool pfs = stage == "post-fs-data"sv;
    int timer_pid = -1;
    if (pfs) {
        // Setup timer
        clock_gettime(CLOCK_MONOTONIC, &pfs_timeout);
        pfs_timeout.tv_sec += POST_FS_DATA_SCRIPT_MAX_TIME;
    }
    PFS_SETUP()

    *(name++) = '/';
    int dfd = dirfd(dir.get());
    for (dirent *entry; (entry = xreaddir(dir.get()));) {
        if (entry->d_type == DT_REG) {
            if (faccessat(dfd, entry->d_name, X_OK, 0) != 0)
                continue;
            LOGI("%s.d: exec [%s]\n", stage.c_str(), entry->d_name);
            strcpy(name, entry->d_name);
            exec_t exec {
                .pre_exec = set_script_env,
                .fork = pfs ? xfork : fork_dont_care
            };
            exec_command(exec, BBEXEC_CMD, path);
            PFS_WAIT()
        }
    }

    PFS_DONE()
}

static bool operator>(const timespec &a, const timespec &b) {
    if (a.tv_sec != b.tv_sec)
        return a.tv_sec > b.tv_sec;
    return a.tv_nsec > b.tv_nsec;
}

void exec_module_scripts(Utf8CStr stage, const rust::Vec<ModuleInfo> &module_list) {
    LOGI("* Running module %s scripts\n", stage.c_str());
    if (module_list.empty())
        return;

    bool pfs = stage == "post-fs-data";
    if (pfs) {
        timespec now{};
        clock_gettime(CLOCK_MONOTONIC, &now);
        // If we had already timed out, treat it as service mode
        if (now > pfs_timeout)
            pfs = false;
    }
    int timer_pid = -1;
    PFS_SETUP()

    char path[4096];
    for (auto &m : module_list) {
        sprintf(path, MODULEROOT "/%.*s/%s.sh", (int) m.name.size(), m.name.data(), stage.c_str());
        if (access(path, F_OK) == -1)
            continue;
        LOGI("%.*s: exec [%s.sh]\n", (int) m.name.size(), m.name.data(), stage.c_str());
        exec_t exec {
            .pre_exec = set_script_env,
            .fork = pfs ? xfork : fork_dont_care
        };
        exec_command(exec, BBEXEC_CMD, path);
        PFS_WAIT()
    }

    PFS_DONE()
}

constexpr char install_script[] = R"EOF(
APK=%s
log -t Magisk "pm_install: $APK"
log -t Magisk "pm_install: $(pm install -g -r $APK 2>&1)"
appops set %s REQUEST_INSTALL_PACKAGES allow
rm -f $APK
)EOF";

void install_apk(Utf8CStr apk) {
    setfilecon(apk.c_str(), MAGISK_FILE_CON);
    char cmds[sizeof(install_script) + 4096];
    ssprintf(cmds, sizeof(cmds), install_script, apk.c_str(), JAVA_PACKAGE_NAME);
    exec_command_async("/system/bin/sh", "-c", cmds);
}

constexpr char uninstall_script[] = R"EOF(
PKG=%s
log -t Magisk "pm_uninstall: $PKG"
log -t Magisk "pm_uninstall: $(pm uninstall $PKG 2>&1)"
)EOF";

void uninstall_pkg(Utf8CStr pkg) {
    char cmds[sizeof(uninstall_script) + 256];
    ssprintf(cmds, sizeof(cmds), uninstall_script, pkg.c_str());
    exec_command_async("/system/bin/sh", "-c", cmds);
}

constexpr char clear_script[] = R"EOF(
PKG=%s
USER=%d
log -t Magisk "pm_clear: $PKG (user=$USER)"
log -t Magisk "pm_clear: $(pm clear --user $USER $PKG 2>&1)"
)EOF";

void clear_pkg(const char *pkg, int user_id) {
    char cmds[sizeof(clear_script) + 288];
    ssprintf(cmds, sizeof(cmds), clear_script, pkg, user_id);
    exec_command_async("/system/bin/sh", "-c", cmds);
}

[[noreturn]] __printflike(2, 3)
static void abort(FILE *fp, const char *fmt, ...) {
    va_list valist;
    va_start(valist, fmt);
    vfprintf(fp, fmt, valist);
    fprintf(fp, "\n\n");
    va_end(valist);
    exit(1);
}

constexpr char install_module_script[] = R"EOF(
. /data/adb/magisk/util_functions.sh
install_module
exit 0
)EOF";

void install_module(Utf8CStr file) {
    if (getuid() != 0)
        abort(stderr, "Run this command with root");
    if (access(DATABIN, F_OK) ||
        access(bbpath(), X_OK) ||
        access(DATABIN "/util_functions.sh", F_OK))
        abort(stderr, "Incomplete Magisk install");
    if (access(file.c_str(), F_OK))
        abort(stderr, "'%s' does not exist", file.c_str());

    char *zip = realpath(file.c_str(), nullptr);
    setenv("OUTFD", "1", 1);
    setenv("ZIPFILE", zip, 1);
    setenv("ASH_STANDALONE", "1", 1);
    setenv("MAGISKTMP", get_magisk_tmp(), 0);
    free(zip);

    int fd = xopen("/dev/null", O_RDONLY);
    xdup2(fd, STDERR_FILENO);
    close(fd);

    const char *argv[] = { BBEXEC_CMD, "-c", install_module_script, nullptr };
    execve(argv[0], (char **) argv, environ);
    abort(stdout, "Failed to execute BusyBox shell");
}

```

`native/src/core/selinux.rs`:

```rs
use crate::consts::{DATABIN, LOG_PIPE, MAGISK_LOG_CON, MAGISKDB, MODULEROOT, SECURE_DIR};
use crate::ffi::get_magisk_tmp;
use base::{Directory, FsPathBuilder, LoggedResult, ResultExt, Utf8CStr, Utf8CStrBuf, cstr, libc};
use nix::fcntl::OFlag;
use std::io::Write;

const UNLABEL_CON: &Utf8CStr = cstr!("u:object_r:unlabeled:s0");
const SYSTEM_CON: &Utf8CStr = cstr!("u:object_r:system_file:s0");
const ADB_CON: &Utf8CStr = cstr!("u:object_r:adb_data_file:s0");
const ROOT_CON: &Utf8CStr = cstr!("u:object_r:rootfs:s0");

fn restore_syscon_from_unlabeled(
    path: &mut dyn Utf8CStrBuf,
    con: &mut dyn Utf8CStrBuf,
) -> LoggedResult<()> {
    let dir_path_len = path.len();
    if path.get_secontext(con).log().is_ok() && con.as_str() == UNLABEL_CON {
        path.set_secontext(SYSTEM_CON)?;
    }
    let mut dir = Directory::open(path)?;
    while let Some(ref e) = dir.read()? {
        path.truncate(dir_path_len);
        path.append_path(e.name());
        if e.is_dir() {
            restore_syscon_from_unlabeled(path, con)?;
        } else if (e.is_file() || e.is_symlink())
            && path.get_secontext(con).log().is_ok()
            && con.as_str() == UNLABEL_CON
        {
            path.set_secontext(SYSTEM_CON)?;
        }
    }
    Ok(())
}

fn restore_syscon(path: &mut dyn Utf8CStrBuf) -> LoggedResult<()> {
    let dir_path_len = path.len();
    path.set_secontext(SYSTEM_CON)?;
    unsafe { libc::lchown(path.as_ptr(), 0, 0) };
    let mut dir = Directory::open(path)?;
    while let Some(ref e) = dir.read()? {
        path.truncate(dir_path_len);
        path.append_path(e.name());
        if e.is_dir() {
            restore_syscon(path)?;
        } else if e.is_file() || e.is_symlink() {
            path.set_secontext(SYSTEM_CON)?;
            unsafe { libc::lchown(path.as_ptr(), 0, 0) };
        }
    }
    Ok(())
}

pub(crate) fn restorecon() {
    if let Ok(mut file) = cstr!("/sys/fs/selinux/context")
        .open(OFlag::O_WRONLY | OFlag::O_CLOEXEC)
        .log()
        && file.write_all(ADB_CON.as_bytes_with_nul()).is_ok()
    {
        cstr!(SECURE_DIR).set_secontext(ADB_CON).log_ok();
    }

    let mut path = cstr::buf::default();
    let mut con = cstr::buf::new::<1024>();
    path.push_str(MODULEROOT);
    path.set_secontext(SYSTEM_CON).log_ok();
    restore_syscon_from_unlabeled(&mut path, &mut con).log_ok();

    path.clear();
    path.push_str(DATABIN);
    restore_syscon(&mut path).log_ok();
    unsafe { libc::chmod(cstr!(MAGISKDB).as_ptr(), 0o000) };
}

pub(crate) fn restore_tmpcon() -> LoggedResult<()> {
    let tmp = get_magisk_tmp();
    if tmp == "/sbin" {
        tmp.set_secontext(ROOT_CON)?;
    } else {
        unsafe { libc::chmod(tmp.as_ptr(), 0o711) };
    }

    let mut path = cstr::buf::default();
    let mut dir = Directory::open(tmp)?;
    while let Some(ref e) = dir.read()? {
        if !e.is_symlink() {
            e.resolve_path(&mut path)?;
            path.set_secontext(SYSTEM_CON).log_ok();
        }
    }

    path.clear();
    path.append_path(tmp).append_path(LOG_PIPE);
    path.set_secontext(cstr!(MAGISK_LOG_CON))?;

    Ok(())
}

pub(crate) fn lgetfilecon(path: &Utf8CStr, con: &mut [u8]) -> bool {
    let mut con = cstr::buf::wrap(con);
    path.get_secontext(&mut con).is_ok()
}

pub(crate) fn setfilecon(path: &Utf8CStr, con: &Utf8CStr) -> bool {
    path.follow_link().set_secontext(con).is_ok()
}

```

`native/src/core/socket.rs`:

```rs
use base::{ReadExt, ResultExt, WriteExt, libc, warn};
use bytemuck::{Zeroable, bytes_of, bytes_of_mut};
use std::io;
use std::io::{ErrorKind, IoSlice, IoSliceMut, Read, Write};
use std::mem::ManuallyDrop;
use std::os::fd::{FromRawFd, IntoRawFd, OwnedFd, RawFd};
use std::os::unix::net::{AncillaryData, SocketAncillary, UnixStream};

pub trait Encodable {
    fn encode(&self, w: &mut impl Write) -> io::Result<()>;
}

pub trait Decodable: Sized + Encodable {
    fn decode(r: &mut impl Read) -> io::Result<Self>;
}

macro_rules! impl_pod_encodable {
    ($($t:ty)*) => ($(
        impl Encodable for $t {
            #[inline(always)]
            fn encode(&self, w: &mut impl Write) -> io::Result<()> {
                w.write_pod(self)
            }
        }
        impl Decodable for $t {
            #[inline(always)]
            fn decode(r: &mut impl Read) -> io::Result<Self> {
                let mut val = Self::zeroed();
                r.read_pod(&mut val)?;
                Ok(val)
            }
        }
    )*)
}

impl_pod_encodable! { u8 u32 i32 usize }

impl Encodable for bool {
    #[inline(always)]
    fn encode(&self, w: &mut impl Write) -> io::Result<()> {
        match *self {
            true => 1u8.encode(w),
            false => 0u8.encode(w),
        }
    }
}

impl Decodable for bool {
    #[inline(always)]
    fn decode(r: &mut impl Read) -> io::Result<Self> {
        Ok(u8::decode(r)? != 0)
    }
}

// impl<E: Encodable, T: AsRef<E>> Encodable for T
macro_rules! impl_encodable_as_ref {
    ($( ($t:ty, $e:ty, $($g:tt)*) )*) => ($(
        impl<$($g)*> Encodable for $t {
            #[inline(always)]
            fn encode(&self, w: &mut impl Write) -> io::Result<()> {
                AsRef::<$e>::as_ref(self).encode(w)
            }
        }
    )*)
}

impl_encodable_as_ref! {
    (String, str,)
    (Vec<T>, [T], T: Encodable)
}

impl<T: Encodable> Encodable for [T] {
    fn encode(&self, w: &mut impl Write) -> io::Result<()> {
        (self.len() as i32).encode(w)?;
        self.iter().try_for_each(|e| e.encode(w))
    }
}

impl<T: Decodable> Decodable for Vec<T> {
    fn decode(r: &mut impl Read) -> io::Result<Self> {
        let len = i32::decode(r)?;
        let mut val = Vec::with_capacity(len as usize);
        for _ in 0..len {
            val.push(T::decode(r)?);
        }
        Ok(val)
    }
}

impl Encodable for str {
    fn encode(&self, w: &mut impl Write) -> io::Result<()> {
        (self.len() as i32).encode(w)?;
        w.write_all(self.as_bytes())
    }
}

impl Decodable for String {
    fn decode(r: &mut impl Read) -> io::Result<String> {
        let len = i32::decode(r)?;
        let mut val = String::with_capacity(len as usize);
        r.take(len as u64).read_to_string(&mut val)?;
        Ok(val)
    }
}

pub trait IpcRead {
    fn read_decodable<E: Decodable>(&mut self) -> io::Result<E>;
}

impl<T: Read> IpcRead for T {
    #[inline(always)]
    fn read_decodable<E: Decodable>(&mut self) -> io::Result<E> {
        E::decode(self)
    }
}

pub trait IpcWrite {
    fn write_encodable<E: Encodable + ?Sized>(&mut self, val: &E) -> io::Result<()>;
}

impl<T: Write> IpcWrite for T {
    #[inline(always)]
    fn write_encodable<E: Encodable + ?Sized>(&mut self, val: &E) -> io::Result<()> {
        val.encode(self)
    }
}

pub trait UnixSocketExt {
    fn send_fds(&mut self, fd: &[RawFd]) -> io::Result<()>;
    fn recv_fd(&mut self) -> io::Result<Option<OwnedFd>>;
    fn recv_fds(&mut self) -> io::Result<Vec<OwnedFd>>;
}

impl UnixSocketExt for UnixStream {
    fn send_fds(&mut self, fds: &[RawFd]) -> io::Result<()> {
        match fds.len() {
            0 => self.write_pod(&0)?,
            len => {
                // 4k buffer is reasonable enough
                let mut buf = [0u8; 4096];
                let mut ancillary = SocketAncillary::new(&mut buf);
                if !ancillary.add_fds(fds) {
                    return Err(ErrorKind::OutOfMemory.into());
                }
                let fd_count = len as i32;
                let iov = IoSlice::new(bytes_of(&fd_count));
                self.send_vectored_with_ancillary(&[iov], &mut ancillary)?;
            }
        };
        Ok(())
    }

    fn recv_fd(&mut self) -> io::Result<Option<OwnedFd>> {
        let mut fd_count = 0;
        self.peek(bytes_of_mut(&mut fd_count))?;
        if fd_count < 1 {
            // Actually consume the data
            self.read_pod(&mut fd_count)?;
            return Ok(None);
        }
        if fd_count > 1 {
            warn!(
                "Received unexpected number of fds: expected=1 actual={}",
                fd_count
            );
        }

        // 4k buffer is reasonable enough
        let mut buf = [0u8; 4096];
        let mut ancillary = SocketAncillary::new(&mut buf);
        let iov = IoSliceMut::new(bytes_of_mut(&mut fd_count));
        self.recv_vectored_with_ancillary(&mut [iov], &mut ancillary)?;
        for msg in ancillary.messages().flatten() {
            if let AncillaryData::ScmRights(mut scm_rights) = msg {
                // We only want the first one
                let fd = if let Some(fd) = scm_rights.next() {
                    unsafe { OwnedFd::from_raw_fd(fd) }
                } else {
                    return Ok(None);
                };
                // Close all others
                for fd in scm_rights {
                    unsafe { libc::close(fd) };
                }
                return Ok(Some(fd));
            }
        }
        Ok(None)
    }

    fn recv_fds(&mut self) -> io::Result<Vec<OwnedFd>> {
        let mut fd_count = 0;
        // 4k buffer is reasonable enough
        let mut buf = [0u8; 4096];
        let mut ancillary = SocketAncillary::new(&mut buf);
        let iov = IoSliceMut::new(bytes_of_mut(&mut fd_count));
        self.recv_vectored_with_ancillary(&mut [iov], &mut ancillary)?;
        let mut fds: Vec<OwnedFd> = Vec::new();
        for msg in ancillary.messages().flatten() {
            if let AncillaryData::ScmRights(scm_rights) = msg {
                fds = scm_rights
                    .map(|fd| unsafe { OwnedFd::from_raw_fd(fd) })
                    .collect();
            }
        }
        if fd_count as usize != fds.len() {
            warn!(
                "Received unexpected number of fds: expected={} actual={}",
                fd_count,
                fds.len()
            );
        }
        Ok(fds)
    }
}

pub fn send_fd(socket: RawFd, fd: RawFd) -> bool {
    let mut socket = ManuallyDrop::new(unsafe { UnixStream::from_raw_fd(socket) });
    if fd < 0 {
        socket.send_fds(&[]).log().is_ok()
    } else {
        socket.send_fds(&[fd]).log().is_ok()
    }
}

pub fn recv_fd(socket: RawFd) -> RawFd {
    let mut socket = ManuallyDrop::new(unsafe { UnixStream::from_raw_fd(socket) });
    socket
        .recv_fd()
        .log()
        .unwrap_or(None)
        .map_or(-1, IntoRawFd::into_raw_fd)
}

pub fn recv_fds(socket: RawFd) -> Vec<RawFd> {
    let mut socket = ManuallyDrop::new(unsafe { UnixStream::from_raw_fd(socket) });
    let fds = socket.recv_fds().log().unwrap_or(Vec::new());
    // SAFETY: OwnedFd and RawFd has the same layout
    unsafe { std::mem::transmute(fds) }
}

```

`native/src/core/sqlite.cpp`:

```cpp
#include <dlfcn.h>

#include <consts.hpp>
#include <base.hpp>
#include <sqlite.hpp>

using namespace std;

#define DB_VERSION     12
#define DB_VERSION_STR "12"

// SQLite APIs

static int (*sqlite3_open_v2)(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs);
static int (*sqlite3_close)(sqlite3 *db);
const char *(*sqlite3_errstr)(int);
static int (*sqlite3_prepare_v2)(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail);
static int (*sqlite3_bind_parameter_count)(sqlite3_stmt*);
static int (*sqlite3_bind_int64)(sqlite3_stmt*, int, int64_t);
static int (*sqlite3_bind_text)(sqlite3_stmt*,int,const char*,int,void(*)(void*));
static int (*sqlite3_column_count)(sqlite3_stmt *pStmt);
static const char *(*sqlite3_column_name)(sqlite3_stmt*, int N);
static const char *(*sqlite3_column_text)(sqlite3_stmt*, int iCol);
static int (*sqlite3_column_int)(sqlite3_stmt*, int iCol);
static int (*sqlite3_step)(sqlite3_stmt*);
static int (*sqlite3_finalize)(sqlite3_stmt *pStmt);

// Internal Android linker APIs

static void (*android_get_LD_LIBRARY_PATH)(char *buffer, size_t buffer_size);
static void (*android_update_LD_LIBRARY_PATH)(const char *ld_library_path);

#define DLERR(ptr) if (!(ptr)) { \
    LOGE("db: %s\n", dlerror()); \
    return false; \
}

#define DLOAD(handle, arg) {\
    auto f = dlsym(handle, #arg); \
    DLERR(f) \
    *(void **) &(arg) = f; \
}

#ifdef __LP64__
constexpr char apex_path[] = "/apex/com.android.runtime/lib64:/apex/com.android.art/lib64:/apex/com.android.i18n/lib64:";
#else
constexpr char apex_path[] = "/apex/com.android.runtime/lib:/apex/com.android.art/lib:/apex/com.android.i18n/lib:";
#endif

static bool load_sqlite() {
    static int dl_init = 0;
    if (dl_init)
        return dl_init > 0;
    dl_init = -1;

    auto sqlite = dlopen("libsqlite.so", RTLD_LAZY);
    if (!sqlite) {
        // Should only happen on Android 10+
        auto dl = dlopen("libdl_android.so", RTLD_LAZY);
        DLERR(dl);

        DLOAD(dl, android_get_LD_LIBRARY_PATH);
        DLOAD(dl, android_update_LD_LIBRARY_PATH);

        // Inject APEX into LD_LIBRARY_PATH
        char ld_path[4096];
        memcpy(ld_path, apex_path, sizeof(apex_path));
        constexpr int len = sizeof(apex_path) - 1;
        android_get_LD_LIBRARY_PATH(ld_path + len, sizeof(ld_path) - len);
        android_update_LD_LIBRARY_PATH(ld_path);
        sqlite = dlopen("libsqlite.so", RTLD_LAZY);

        // Revert LD_LIBRARY_PATH just in case
        android_update_LD_LIBRARY_PATH(ld_path + len);
    }
    DLERR(sqlite);

    DLOAD(sqlite, sqlite3_open_v2);
    DLOAD(sqlite, sqlite3_close);
    DLOAD(sqlite, sqlite3_errstr);
    DLOAD(sqlite, sqlite3_prepare_v2);
    DLOAD(sqlite, sqlite3_bind_parameter_count);
    DLOAD(sqlite, sqlite3_bind_int64);
    DLOAD(sqlite, sqlite3_bind_text);
    DLOAD(sqlite, sqlite3_step);
    DLOAD(sqlite, sqlite3_column_count);
    DLOAD(sqlite, sqlite3_column_name);
    DLOAD(sqlite, sqlite3_column_text);
    DLOAD(sqlite, sqlite3_column_int);
    DLOAD(sqlite, sqlite3_finalize);

    dl_init = 1;
    return true;
}

using StringVec = rust::Vec<rust::String>;
using sql_bind_callback_real = int(*)(void*, int, sqlite3_stmt*);
using sql_exec_callback_real = void(*)(void*, StringSlice, sqlite3_stmt*);

#define sql_chk(fn, ...) if (int rc = fn(__VA_ARGS__); rc != SQLITE_OK) return rc

// Exports to Rust
extern "C" int sql_exec_impl(
        sqlite3 *db, rust::Str zSql,
        sql_bind_callback bind_cb = nullptr, void *bind_cookie = nullptr,
        sql_exec_callback exec_cb = nullptr, void *exec_cookie = nullptr) {
    const char *sql = zSql.begin();
    unique_ptr<sqlite3_stmt, decltype(sqlite3_finalize)> stmt(nullptr, sqlite3_finalize);

    while (sql != zSql.end()) {
        // Step 1: prepare statement
        {
            sqlite3_stmt *st = nullptr;
            sql_chk(sqlite3_prepare_v2, db, sql, zSql.end() - sql, &st, &sql);
            if (st == nullptr) continue;
            stmt.reset(st);
        }

        // Step 2: bind arguments
        if (bind_cb) {
            if (int count = sqlite3_bind_parameter_count(stmt.get())) {
                auto real_cb = reinterpret_cast<sql_bind_callback_real>(bind_cb);
                for (int i = 1; i <= count; ++i) {
                    sql_chk(real_cb, bind_cookie, i, stmt.get());
                }
            }
        }

        // Step 3: execute
        bool first = true;
        StringVec columns;
        for (;;) {
            int rc = sqlite3_step(stmt.get());
            if (rc == SQLITE_DONE) break;
            if (rc != SQLITE_ROW) return rc;
            if (exec_cb == nullptr) continue;
            if (first) {
                int count = sqlite3_column_count(stmt.get());
                for (int i = 0; i < count; ++i) {
                    columns.emplace_back(sqlite3_column_name(stmt.get(), i));
                }
                first = false;
            }
            auto real_cb = reinterpret_cast<sql_exec_callback_real>(exec_cb);
            real_cb(exec_cookie, StringSlice(columns), stmt.get());
        }
    }

    return SQLITE_OK;
}

int DbValues::get_int(int index) const {
    return sqlite3_column_int((sqlite3_stmt*) this, index);
}

const char *DbValues::get_text(int index) const {
    return sqlite3_column_text((sqlite3_stmt*) this, index);
}

int DbStatement::bind_int64(int index, int64_t val) {
    return sqlite3_bind_int64(reinterpret_cast<sqlite3_stmt*>(this), index, val);
}

int DbStatement::bind_text(int index, rust::Str val) {
    return sqlite3_bind_text(reinterpret_cast<sqlite3_stmt*>(this), index, val.data(), val.size(), nullptr);
}

#define sql_chk_log_ret(ret, fn, ...) if (int rc = fn(__VA_ARGS__); rc != SQLITE_OK) { \
    LOGE("sqlite3(line:%d): %s\n", __LINE__, sqlite3_errstr(rc));                      \
    return ret;                                                                        \
}

#define sql_chk_log(fn, ...) sql_chk_log_ret(nullptr, fn, __VA_ARGS__)

sqlite3 *open_and_init_db() {
    if (!load_sqlite()) {
        LOGE("sqlite3: Cannot load libsqlite.so\n");
        return nullptr;
    }

    unique_ptr<sqlite3, decltype(sqlite3_close)> db(nullptr, sqlite3_close);
    {
        sqlite3 *sql;
        // We open the connection with SQLITE_OPEN_NOMUTEX because we are guarding it ourselves
        sql_chk_log(sqlite3_open_v2, MAGISKDB, &sql,
                    SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_NOMUTEX, nullptr);
        db.reset(sql);
    }

    int ver = 0;
    bool upgrade = false;
    auto ver_cb = [](void *ver, auto, const DbValues &values) {
        *static_cast<int *>(ver) = values.get_int(0);
    };
    sql_chk_log(sql_exec_impl, db.get(), "PRAGMA user_version", nullptr, nullptr, ver_cb, &ver);
    if (ver > DB_VERSION) {
        // Don't support downgrading database, delete and retry
        LOGE("sqlite3: Downgrading database is not supported\n");
        unlink(MAGISKDB);
        return open_and_init_db();
    }

    auto create_policy = [&] {
        return sql_exec_impl(db.get(),
                "CREATE TABLE IF NOT EXISTS policies "
                "(uid INT, policy INT, until INT, logging INT, "
                "notification INT, PRIMARY KEY(uid))");
    };
    auto create_settings = [&] {
        return sql_exec_impl(db.get(),
                "CREATE TABLE IF NOT EXISTS settings "
                "(key TEXT, value INT, PRIMARY KEY(key))");
    };
    auto create_strings = [&] {
        return sql_exec_impl(db.get(),
                "CREATE TABLE IF NOT EXISTS strings "
                "(key TEXT, value TEXT, PRIMARY KEY(key))");
    };
    auto create_denylist = [&] {
        return sql_exec_impl(db.get(),
                "CREATE TABLE IF NOT EXISTS denylist "
                "(package_name TEXT, process TEXT, PRIMARY KEY(package_name, process))");
    };

    // Database changelog:
    //
    // 0 - 6: DB stored in app private data. There are no longer any code in the project to
    //        migrate these data, so no need to take any of these versions into consideration.
    // 7 : create table `hidelist` (process TEXT, PRIMARY KEY(process))
    // 8 : add new column (package_name TEXT) to table `hidelist`
    // 9 : rebuild table `hidelist` to change primary key (PRIMARY KEY(package_name, process))
    // 10: remove table `logs`
    // 11: remove table `hidelist` and create table `denylist` (same data structure)
    // 12: rebuild table `policies` to drop column `package_name`

    if (/* 0, 1, 2, 3, 4, 5, 6 */ ver <= 6) {
        sql_chk_log(create_policy);
        sql_chk_log(create_settings);
        sql_chk_log(create_strings);
        sql_chk_log(create_denylist);

        // Directly jump to latest
        ver = DB_VERSION;
        upgrade = true;
    }
    if (ver == 7) {
        sql_chk_log(sql_exec_impl, db.get(),
                "BEGIN TRANSACTION;"
                "ALTER TABLE hidelist RENAME TO hidelist_tmp;"
                "CREATE TABLE IF NOT EXISTS hidelist "
                "(package_name TEXT, process TEXT, PRIMARY KEY(package_name, process));"
                "INSERT INTO hidelist SELECT process as package_name, process FROM hidelist_tmp;"
                "DROP TABLE hidelist_tmp;"
                "COMMIT;");
        // Directly jump to version 9
        ver = 9;
        upgrade = true;
    }
    if (ver == 8) {
        sql_chk_log(sql_exec_impl, db.get(),
                "BEGIN TRANSACTION;"
                "ALTER TABLE hidelist RENAME TO hidelist_tmp;"
                "CREATE TABLE IF NOT EXISTS hidelist "
                "(package_name TEXT, process TEXT, PRIMARY KEY(package_name, process));"
                "INSERT INTO hidelist SELECT * FROM hidelist_tmp;"
                "DROP TABLE hidelist_tmp;"
                "COMMIT;");
        ver = 9;
        upgrade = true;
    }
    if (ver == 9) {
        sql_chk_log(sql_exec_impl, db.get(), "DROP TABLE IF EXISTS logs", nullptr, nullptr);
        ver = 10;
        upgrade = true;
    }
    if (ver == 10) {
        sql_chk_log(sql_exec_impl, db.get(),
                "DROP TABLE IF EXISTS hidelist;"
                "DELETE FROM settings WHERE key='magiskhide';");
        sql_chk_log(create_denylist);
        ver = 11;
        upgrade = true;
    }
    if (ver == 11) {
        sql_chk_log(sql_exec_impl, db.get(),
                "BEGIN TRANSACTION;"
                "ALTER TABLE policies RENAME TO policies_tmp;"
                "CREATE TABLE IF NOT EXISTS policies "
                "(uid INT, policy INT, until INT, logging INT, "
                "notification INT, PRIMARY KEY(uid));"
                "INSERT INTO policies "
                "SELECT uid, policy, until, logging, notification FROM policies_tmp;"
                "DROP TABLE policies_tmp;"
                "COMMIT;");
        ver = 12;
        upgrade = true;
    }

    if (upgrade) {
        // Set version
        sql_chk_log(sql_exec_impl, db.get(), "PRAGMA user_version=" DB_VERSION_STR);
    }

    return db.release();
}

// Exported from Rust
extern "C" int sql_exec_rs(
        rust::Str zSql,
        sql_bind_callback bind_cb, void *bind_cookie,
        sql_exec_callback exec_cb, void *exec_cookie);

bool db_exec(const char *sql, DbArgs args, db_exec_callback exec_fn) {
    using db_bind_callback = std::function<int(int, DbStatement&)>;

    db_bind_callback bind_fn = {};
    sql_bind_callback bind_cb = nullptr;
    if (!args.empty()) {
        bind_fn = std::ref(args);
        bind_cb = [](void *v, int index, DbStatement &stmt) -> int {
            auto fn = static_cast<db_bind_callback*>(v);
            return fn->operator()(index, stmt);
        };
    }
    sql_exec_callback exec_cb = nullptr;
    if (exec_fn) {
        exec_cb = [](void *v, StringSlice columns, const DbValues &values) {
            auto fn = static_cast<db_exec_callback*>(v);
            fn->operator()(columns, values);
        };
    }
    sql_chk_log_ret(false, sql_exec_rs, sql, bind_cb, &bind_fn, exec_cb, &exec_fn);
    return true;
}

int DbArgs::operator()(int index, DbStatement &stmt) {
    if (curr < args.size()) {
        const auto &arg = args[curr++];
        switch (arg.type) {
            case DbArg::INT:
                return stmt.bind_int64(index, arg.int_val);
            case DbArg::TEXT:
                return stmt.bind_text(index, arg.str_val);
        }
    }
    return SQLITE_OK;
}

```

`native/src/core/su/connect.rs`:

```rs
use super::SuInfo;
use super::db::RootSettings;
use crate::consts::{INTERNAL_DIR, MAGISK_FILE_CON};
use crate::daemon::to_user_id;
use crate::ffi::{SuPolicy, SuRequest, get_magisk_tmp};
use crate::socket::IpcRead;
use ExtraVal::{Bool, Int, IntList, Str};
use base::{
    BytesExt, FileAttr, LibcReturn, LoggedResult, ResultExt, Utf8CStrBuf, cstr, fork_dont_care,
};
use nix::fcntl::OFlag;
use nix::poll::{PollFd, PollFlags, PollTimeout};
use num_traits::AsPrimitive;
use std::fmt::Write;
use std::fs::File;
use std::os::fd::AsFd;
use std::os::unix::net::UCred;
use std::process::{Command, exit};

struct Extra<'a> {
    key: &'static str,
    value: ExtraVal<'a>,
}

enum ExtraVal<'a> {
    Int(i32),
    Bool(bool),
    Str(&'a str),
    IntList(&'a [u32]),
}

impl Extra<'_> {
    fn add_intent(&self, cmd: &mut Command) {
        match self.value {
            Int(i) => {
                cmd.args(["--ei", self.key, &i.to_string()]);
            }
            Bool(b) => {
                cmd.args(["--ez", self.key, &b.to_string()]);
            }
            Str(s) => {
                cmd.args(["--es", self.key, s]);
            }
            IntList(list) => {
                cmd.args(["--es", self.key]);
                let mut tmp = String::new();
                list.iter().for_each(|i| {
                    write!(&mut tmp, "{i},").ok();
                });
                tmp.pop();
                cmd.arg(&tmp);
            }
        }
    }

    fn add_bind(&self, cmd: &mut Command) {
        let mut tmp: String;
        match self.value {
            Int(i) => {
                tmp = format!("{}:i:{}", self.key, i);
            }
            Bool(b) => {
                tmp = format!("{}:b:{}", self.key, b);
            }
            Str(s) => {
                let s = s.replace("\\", "\\\\").replace(":", "\\:");
                tmp = format!("{}:s:{}", self.key, s);
            }
            IntList(list) => {
                tmp = format!("{}:s:", self.key);
                if !list.is_empty() {
                    list.iter().for_each(|i| {
                        write!(&mut tmp, "{i},").ok();
                    });
                    tmp.pop();
                }
            }
        }
        cmd.args(["--extra", &tmp]);
    }

    fn add_bind_legacy(&self, cmd: &mut Command) {
        match self.value {
            Str(s) => {
                let tmp = format!("{}:s:{}", self.key, s);
                cmd.args(["--extra", &tmp]);
            }
            _ => self.add_bind(cmd),
        }
    }
}

pub(super) struct SuAppContext<'a> {
    pub(super) cred: UCred,
    pub(super) request: &'a SuRequest,
    pub(super) info: &'a SuInfo,
    pub(super) settings: &'a mut RootSettings,
    pub(super) sdk_int: i32,
}

impl SuAppContext<'_> {
    fn exec_cmd(&self, action: &'static str, extras: &[Extra], use_provider: bool) {
        let user = to_user_id(self.info.eval_uid);
        let user = user.to_string();

        if use_provider {
            let provider = format!("content://{}.provider", self.info.mgr_pkg);
            let mut cmd = Command::new("/system/bin/app_process");
            cmd.args([
                "/system/bin",
                "com.android.commands.content.Content",
                "call",
                "--uri",
                &provider,
                "--user",
                &user,
                "--method",
                action,
            ]);
            if self.sdk_int >= 30 {
                extras.iter().for_each(|e| e.add_bind(&mut cmd))
            } else {
                extras.iter().for_each(|e| e.add_bind_legacy(&mut cmd))
            }
            cmd.env("CLASSPATH", "/system/framework/content.jar");

            if let Ok(output) = cmd.output()
                && !output.stderr.contains(b"Error")
                && !output.stdout.contains(b"Error")
            {
                // The provider call succeed
                return;
            }
        }

        let mut cmd = Command::new("/system/bin/app_process");
        cmd.args([
            "/system/bin",
            "com.android.commands.am.Am",
            "start",
            "-p",
            &self.info.mgr_pkg,
            "--user",
            &user,
            "-a",
            "android.intent.action.VIEW",
            "-f",
            // FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_MULTIPLE_TASK|
            // FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS|FLAG_INCLUDE_STOPPED_PACKAGES
            "0x18800020",
            "--es",
            "action",
            action,
        ]);
        extras.iter().for_each(|e| e.add_intent(&mut cmd));
        cmd.env("CLASSPATH", "/system/framework/am.jar");

        // Sometimes `am start` will fail, keep trying until it works
        loop {
            if let Ok(output) = cmd.output()
                && !output.stdout.is_empty()
            {
                break;
            }
        }
    }

    fn app_request(&mut self) {
        let mut fifo = cstr::buf::new::<64>();
        fifo.write_fmt(format_args!(
            "{}/{}/su_request_{}",
            get_magisk_tmp(),
            INTERNAL_DIR,
            self.cred.pid.unwrap_or(-1)
        ))
        .ok();

        let fd = || -> LoggedResult<File> {
            let mut attr = FileAttr::new();
            attr.st.st_mode = 0o600;
            attr.st.st_uid = self.info.mgr_uid.as_();
            attr.st.st_gid = self.info.mgr_uid.as_();
            attr.con.push_str(MAGISK_FILE_CON);

            fifo.mkfifo(0o600)?;
            fifo.set_attr(&attr)?;

            let extras = [
                Extra {
                    key: "fifo",
                    value: Str(&fifo),
                },
                Extra {
                    key: "uid",
                    value: Int(self.info.eval_uid),
                },
                Extra {
                    key: "pid",
                    value: Int(self.cred.pid.unwrap_or(-1)),
                },
            ];
            self.exec_cmd("request", &extras, false);

            // Open with O_RDWR to prevent FIFO open block
            let fd = fifo.open(OFlag::O_RDWR | OFlag::O_CLOEXEC)?;
            let mut pfd = [PollFd::new(fd.as_fd(), PollFlags::POLLIN)];

            // Wait for data input for at most 70 seconds
            nix::poll::poll(
                &mut pfd,
                PollTimeout::try_from(70 * 1000).unwrap_or(PollTimeout::NONE),
            )
            .check_os_err("poll", None, None)?;
            Ok(fd)
        }();

        fifo.remove().log_ok();

        if let Ok(mut fd) = fd {
            self.settings.policy = SuPolicy {
                repr: fd
                    .read_decodable::<i32>()
                    .log()
                    .map(i32::from_be)
                    .unwrap_or(SuPolicy::Deny.repr),
            };
        } else {
            self.settings.policy = SuPolicy::Deny;
        };
    }

    fn app_notify(&self) {
        let extras = [
            Extra {
                key: "from.uid",
                value: Int(self.cred.uid.as_()),
            },
            Extra {
                key: "pid",
                value: Int(self.cred.pid.unwrap_or(-1).as_()),
            },
            Extra {
                key: "policy",
                value: Int(self.settings.policy.repr),
            },
        ];
        self.exec_cmd("notify", &extras, true);
    }

    fn app_log(&self) {
        let command = if self.request.command.is_empty() {
            &self.request.shell
        } else {
            &self.request.command
        };
        let extras = [
            Extra {
                key: "from.uid",
                value: Int(self.cred.uid.as_()),
            },
            Extra {
                key: "to.uid",
                value: Int(self.request.target_uid),
            },
            Extra {
                key: "pid",
                value: Int(self.cred.pid.unwrap_or(-1).as_()),
            },
            Extra {
                key: "policy",
                value: Int(self.settings.policy.repr),
            },
            Extra {
                key: "target",
                value: Int(self.request.target_pid),
            },
            Extra {
                key: "context",
                value: Str(&self.request.context),
            },
            Extra {
                key: "gids",
                value: IntList(&self.request.gids),
            },
            Extra {
                key: "command",
                value: Str(command),
            },
            Extra {
                key: "notify",
                value: Bool(self.settings.notify),
            },
        ];
        self.exec_cmd("log", &extras, true);
    }

    pub(super) fn connect_app(&mut self) {
        // If policy is undetermined, show dialog for user consent
        if self.settings.policy == SuPolicy::Query {
            self.app_request();
        }

        if !self.settings.log && !self.settings.notify {
            return;
        }

        if fork_dont_care() != 0 {
            return;
        }

        // Notify su usage to application
        if self.settings.log {
            self.app_log();
        } else if self.settings.notify {
            self.app_notify();
        }

        exit(0);
    }
}

```

`native/src/core/su/daemon.rs`:

```rs
use super::connect::SuAppContext;
use super::db::RootSettings;
use crate::daemon::{AID_ROOT, AID_SHELL, MagiskD, to_app_id, to_user_id};
use crate::db::{DbSettings, MultiuserMode, RootAccess};
use crate::ffi::{SuPolicy, SuRequest, exec_root_shell};
use crate::socket::IpcRead;
use base::{LoggedResult, ResultExt, WriteExt, debug, error, exit_on_error, libc, warn};
use std::os::fd::IntoRawFd;
use std::os::unix::net::{UCred, UnixStream};
use std::sync::Arc;
use std::time::{Duration, Instant};

#[allow(unused_imports)]
use std::os::fd::AsRawFd;
use std::sync::nonpoison::Mutex;

const DEFAULT_SHELL: &str = "/system/bin/sh";

impl Default for SuRequest {
    fn default() -> Self {
        SuRequest {
            target_uid: AID_ROOT,
            target_pid: -1,
            login: false,
            keep_env: false,
            drop_cap: false,
            shell: DEFAULT_SHELL.to_string(),
            command: "".to_string(),
            context: "".to_string(),
            gids: vec![],
        }
    }
}

pub struct SuInfo {
    pub(super) uid: i32,
    pub(super) eval_uid: i32,
    pub(super) mgr_pkg: String,
    pub(super) mgr_uid: i32,
    cfg: DbSettings,
    access: Mutex<AccessInfo>,
}

struct AccessInfo {
    settings: RootSettings,
    timestamp: Instant,
}

impl Default for SuInfo {
    fn default() -> Self {
        SuInfo {
            uid: -1,
            eval_uid: -1,
            cfg: Default::default(),
            mgr_pkg: Default::default(),
            mgr_uid: -1,
            access: Default::default(),
        }
    }
}

impl Default for AccessInfo {
    fn default() -> Self {
        AccessInfo {
            settings: Default::default(),
            timestamp: Instant::now(),
        }
    }
}

impl SuInfo {
    fn allow(uid: i32) -> SuInfo {
        let access = RootSettings {
            policy: SuPolicy::Allow,
            log: false,
            notify: false,
        };
        SuInfo {
            uid,
            access: Mutex::new(AccessInfo::new(access)),
            ..Default::default()
        }
    }

    fn deny(uid: i32) -> SuInfo {
        let access = RootSettings {
            policy: SuPolicy::Deny,
            log: false,
            notify: false,
        };
        SuInfo {
            uid,
            access: Mutex::new(AccessInfo::new(access)),
            ..Default::default()
        }
    }
}

impl AccessInfo {
    fn new(settings: RootSettings) -> AccessInfo {
        AccessInfo {
            settings,
            timestamp: Instant::now(),
        }
    }

    fn is_fresh(&self) -> bool {
        self.timestamp.elapsed() < Duration::from_secs(3)
    }

    fn refresh(&mut self) {
        self.timestamp = Instant::now();
    }
}

impl MagiskD {
    pub fn su_daemon_handler(&self, mut client: UnixStream, cred: UCred) {
        debug!(
            "su: request from uid=[{}], pid=[{}], client=[{}]",
            cred.uid,
            cred.pid.unwrap_or(-1),
            client.as_raw_fd()
        );

        let mut req = match client.read_decodable::<SuRequest>().log() {
            Ok(req) => req,
            Err(_) => {
                warn!("su: remote process probably died, abort");
                client.write_pod(&SuPolicy::Deny.repr).ok();
                return;
            }
        };

        let info = self.get_su_info(cred.uid as i32);
        {
            let mut access = info.access.lock();

            // Talk to su manager
            let mut app = SuAppContext {
                cred,
                request: &req,
                info: &info,
                settings: &mut access.settings,
                sdk_int: self.sdk_int(),
            };
            app.connect_app();

            // Before unlocking, refresh the timestamp
            access.refresh();

            if access.settings.policy == SuPolicy::Restrict {
                req.drop_cap = true;
            }

            if access.settings.policy == SuPolicy::Deny {
                warn!("su: request rejected ({})", info.uid);
                client.write_pod(&SuPolicy::Deny.repr).ok();
                return;
            }
        }

        // At this point, the root access is granted.
        // Fork a child root process and monitor its exit value.
        let child = unsafe { libc::fork() };
        if child == 0 {
            debug!("su: fork handler");

            // Abort upon any error occurred
            exit_on_error(true);

            // ack
            client.write_pod(&0).ok();

            exec_root_shell(
                client.into_raw_fd(),
                cred.pid.unwrap_or(-1),
                &mut req,
                info.cfg.mnt_ns,
            );
            return;
        }
        if child < 0 {
            error!("su: fork failed, abort");
            return;
        }

        // Wait result
        debug!("su: waiting child pid=[{}]", child);
        let mut status = 0;
        let code = unsafe {
            if libc::waitpid(child, &mut status, 0) > 0 {
                libc::WEXITSTATUS(status)
            } else {
                -1
            }
        };
        debug!("su: return code=[{}]", code);
        client.write_pod(&code).ok();
    }

    fn get_su_info(&self, uid: i32) -> Arc<SuInfo> {
        if uid == AID_ROOT {
            return Arc::new(SuInfo::allow(AID_ROOT));
        }

        let cached = self.cached_su_info.load();
        if cached.uid == uid && cached.access.lock().is_fresh() {
            return cached;
        }

        let info = self.build_su_info(uid);
        self.cached_su_info.store(info.clone());
        info
    }

    #[cfg(feature = "su-check-db")]
    fn build_su_info(&self, uid: i32) -> Arc<SuInfo> {
        let result = || -> LoggedResult<Arc<SuInfo>> {
            let cfg = self.get_db_settings()?;

            // Check multiuser settings
            let eval_uid = match cfg.multiuser_mode {
                MultiuserMode::OwnerOnly => {
                    if to_user_id(uid) != 0 {
                        return Ok(Arc::new(SuInfo::deny(uid)));
                    }
                    uid
                }
                MultiuserMode::OwnerManaged => to_app_id(uid),
                _ => uid,
            };

            let mut access = RootSettings::default();
            self.get_root_settings(eval_uid, &mut access)?;

            // We need to talk to the manager, get the app info
            let (mgr_uid, mgr_pkg) =
                if access.policy == SuPolicy::Query || access.log || access.notify {
                    self.get_manager(to_user_id(eval_uid), true)
                } else {
                    (-1, String::new())
                };

            // If it's the manager, allow it silently
            if to_app_id(uid) == to_app_id(mgr_uid) {
                return Ok(Arc::new(SuInfo::allow(uid)));
            }

            // Check su access settings
            match cfg.root_access {
                RootAccess::Disabled => {
                    warn!("Root access is disabled!");
                    return Ok(Arc::new(SuInfo::deny(uid)));
                }
                RootAccess::AdbOnly => {
                    if uid != AID_SHELL {
                        warn!("Root access limited to ADB only!");
                        return Ok(Arc::new(SuInfo::deny(uid)));
                    }
                }
                RootAccess::AppsOnly => {
                    if uid == AID_SHELL {
                        warn!("Root access is disabled for ADB!");
                        return Ok(Arc::new(SuInfo::deny(uid)));
                    }
                }
                _ => {}
            };

            // If still not determined, check if manager exists
            if access.policy == SuPolicy::Query && mgr_uid < 0 {
                return Ok(Arc::new(SuInfo::deny(uid)));
            }

            // Finally, the SuInfo
            Ok(Arc::new(SuInfo {
                uid,
                eval_uid,
                mgr_pkg,
                mgr_uid,
                cfg,
                access: Mutex::new(AccessInfo::new(access)),
            }))
        }();

        result.unwrap_or(Arc::new(SuInfo::deny(uid)))
    }

    #[cfg(not(feature = "su-check-db"))]
    fn build_su_info(&self, uid: i32) -> Arc<SuInfo> {
        Arc::new(SuInfo::allow(uid))
    }
}

```

`native/src/core/su/db.rs`:

```rs
use crate::daemon::{
    AID_APP_END, AID_APP_START, AID_ROOT, AID_SHELL, MagiskD, to_app_id, to_user_id,
};
use crate::db::DbArg::Integer;
use crate::db::{MultiuserMode, RootAccess, SqlTable, SqliteResult, SqliteReturn};
use crate::ffi::{DbValues, SuPolicy};
use base::ResultExt;

impl Default for SuPolicy {
    fn default() -> Self {
        SuPolicy::Query
    }
}

#[derive(Default)]
pub struct RootSettings {
    pub policy: SuPolicy,
    pub log: bool,
    pub notify: bool,
}

impl SqlTable for RootSettings {
    fn on_row(&mut self, columns: &[String], values: &DbValues) {
        for (i, column) in columns.iter().enumerate() {
            let val = values.get_int(i as i32);
            match column.as_str() {
                "policy" => self.policy.repr = val,
                "logging" => self.log = val != 0,
                "notification" => self.notify = val != 0,
                _ => {}
            }
        }
    }
}

struct UidList(Vec<i32>);

impl SqlTable for UidList {
    fn on_row(&mut self, _: &[String], values: &DbValues) {
        self.0.push(values.get_int(0));
    }
}

impl MagiskD {
    pub fn get_root_settings(&self, uid: i32, settings: &mut RootSettings) -> SqliteResult<()> {
        self.db_exec_with_rows(
            "SELECT policy, logging, notification FROM policies \
             WHERE uid=? AND (until=0 OR until>strftime('%s', 'now'))",
            &[Integer(uid as i64)],
            settings,
        )
        .sql_result()
    }

    pub fn prune_su_access(&self) {
        let mut list = UidList(Vec::new());
        if self
            .db_exec_with_rows("SELECT uid FROM policies", &[], &mut list)
            .sql_result()
            .log()
            .is_err()
        {
            return;
        }

        let app_list = self.get_app_no_list();
        let mut rm_uids = Vec::new();

        for uid in list.0 {
            let app_id = to_app_id(uid);
            if (AID_APP_START..=AID_APP_END).contains(&app_id) {
                let app_no = app_id - AID_APP_START;
                if !app_list.contains(app_no as usize) {
                    // The app_id is no longer installed
                    rm_uids.push(uid);
                }
            }
        }

        for uid in rm_uids {
            self.db_exec("DELETE FROM policies WHERE uid=?", &[Integer(uid as i64)]);
        }
    }

    pub fn uid_granted_root(&self, mut uid: i32) -> bool {
        if uid == AID_ROOT {
            return true;
        }

        let cfg = match self.get_db_settings().log() {
            Ok(cfg) => cfg,
            Err(_) => return false,
        };

        // Check user root access settings
        match cfg.root_access {
            RootAccess::Disabled => return false,
            RootAccess::AppsOnly => {
                if uid == AID_SHELL {
                    return false;
                }
            }
            RootAccess::AdbOnly => {
                if uid != AID_SHELL {
                    return false;
                }
            }
            _ => {}
        }

        // Check multiuser settings
        match cfg.multiuser_mode {
            MultiuserMode::OwnerOnly => {
                if to_user_id(uid) != 0 {
                    return false;
                }
            }
            MultiuserMode::OwnerManaged => uid = to_app_id(uid),
            _ => {}
        }

        let mut granted = false;
        let mut output_fn =
            |_: &[String], values: &DbValues| granted = values.get_int(0) == SuPolicy::Allow.repr;
        self.db_exec_with_rows(
            "SELECT policy FROM policies WHERE uid=? AND (until=0 OR until>strftime('%s', 'now'))",
            &[Integer(uid as i64)],
            &mut output_fn,
        );

        granted
    }
}

```

`native/src/core/su/mod.rs`:

```rs
mod connect;
mod daemon;
mod db;
mod pts;

pub use daemon::SuInfo;
pub use pts::{get_pty_num, pump_tty};

```

`native/src/core/su/pts.rs`:

```rs
use base::{FileOrStd, LibcReturn, LoggedResult, OsResult, ResultExt, libc, warn};
use libc::{STDIN_FILENO, TIOCGWINSZ, TIOCSWINSZ, c_int, winsize};
use nix::fcntl::{OFlag, SpliceFFlags};
use nix::poll::{PollFd, PollFlags, PollTimeout, poll};
use nix::sys::signal::{SigSet, Signal, raise};
use nix::sys::signalfd::{SfdFlags, SignalFd};
use nix::sys::termios::{SetArg, Termios, cfmakeraw, tcgetattr, tcsetattr};
use nix::unistd::pipe2;
use std::fs::File;
use std::io::{Read, Write};
use std::mem::MaybeUninit;
use std::os::fd::{AsFd, AsRawFd, FromRawFd, RawFd};
use std::sync::atomic::{AtomicBool, Ordering};

static SHOULD_USE_SPLICE: AtomicBool = AtomicBool::new(true);
const TIOCGPTN: u32 = 0x80045430;

unsafe extern "C" {
    // Don't use the declaration from the libc crate as request should be u32 not i32
    fn ioctl(fd: c_int, request: u32, ...) -> i32;
}

pub fn get_pty_num(fd: i32) -> i32 {
    let mut pty_num = -1i32;
    if unsafe { ioctl(fd, TIOCGPTN, &mut pty_num) } != 0 {
        warn!("Failed to get pty number");
    }
    pty_num
}

fn sync_winsize(ptmx: i32) {
    let mut ws: winsize = unsafe { std::mem::zeroed() };
    if unsafe { ioctl(STDIN_FILENO, TIOCGWINSZ as u32, &mut ws) } >= 0 {
        unsafe { ioctl(ptmx, TIOCSWINSZ as u32, &ws) };
    }
}

fn splice(fd_in: impl AsFd, fd_out: impl AsFd, len: usize) -> OsResult<'static, usize> {
    nix::fcntl::splice(fd_in, None, fd_out, None, len, SpliceFFlags::empty())
        .into_os_result("splice", None, None)
}

fn pump_via_copy(mut fd_in: &File, mut fd_out: &File) -> LoggedResult<()> {
    let mut buf = MaybeUninit::<[u8; 4096]>::uninit();
    let buf = unsafe { buf.assume_init_mut() };
    let len = fd_in.read(buf)?;
    fd_out.write_all(&buf[..len])?;
    Ok(())
}

fn pump_via_splice(fd_in: &File, fd_out: &File, pipe: &(File, File)) -> LoggedResult<()> {
    if !SHOULD_USE_SPLICE.load(Ordering::Relaxed) {
        return pump_via_copy(fd_in, fd_out);
    }

    // The pipe capacity is by default 16 pages, let's just use 65536
    let Ok(len) = splice(fd_in, &pipe.1, 65536) else {
        // If splice failed, stop using splice and fallback to userspace copy
        SHOULD_USE_SPLICE.store(false, Ordering::Relaxed);
        return pump_via_copy(fd_in, fd_out);
    };
    if len == 0 {
        return Ok(());
    }
    if splice(&pipe.0, fd_out, len).is_err() {
        // If splice failed, stop using splice and fallback to userspace copy
        SHOULD_USE_SPLICE.store(false, Ordering::Relaxed);
        return pump_via_copy(&pipe.0, fd_out);
    }
    Ok(())
}

fn set_stdin_raw() -> LoggedResult<Termios> {
    let mut term = tcgetattr(FileOrStd::StdIn.as_file())?;
    let old_term = term.clone();

    let old_output_flags = old_term.output_flags;
    cfmakeraw(&mut term);

    // Preserve output_flags, since we are not setting stdout raw
    term.output_flags = old_output_flags;

    tcsetattr(FileOrStd::StdIn.as_file(), SetArg::TCSAFLUSH, &term)
        .or_else(|_| tcsetattr(FileOrStd::StdIn.as_file(), SetArg::TCSADRAIN, &term))
        .check_os_err("tcsetattr", None, None)
        .log_with_msg(|w| w.write_str("Failed to set terminal attributes"))?;

    Ok(old_term)
}

fn restore_stdin(term: Termios) -> LoggedResult<()> {
    tcsetattr(FileOrStd::StdIn.as_file(), SetArg::TCSAFLUSH, &term)
        .or_else(|_| tcsetattr(FileOrStd::StdIn.as_file(), SetArg::TCSADRAIN, &term))
        .check_os_err("tcsetattr", None, None)
        .log_with_msg(|w| w.write_str("Failed to restore terminal attributes"))
}

fn pump_tty_impl(ptmx: File, pump_stdin: bool) -> LoggedResult<()> {
    let mut signal_fd: Option<SignalFd> = None;

    let raw_ptmx = ptmx.as_raw_fd();

    let mut poll_fds = Vec::with_capacity(3);
    poll_fds.push(PollFd::new(ptmx.as_fd(), PollFlags::POLLIN));
    if pump_stdin {
        // If stdin is tty, we need to monitor SIGWINCH
        let mut set = SigSet::empty();
        set.add(Signal::SIGWINCH);
        set.thread_block()
            .check_os_err("pthread_sigmask", None, None)?;
        let sig = SignalFd::with_flags(&set, SfdFlags::SFD_CLOEXEC)
            .into_os_result("signalfd", None, None)?;
        signal_fd = Some(sig);
        unsafe {
            // SAFETY: signal_fd is always Some
            poll_fds.push(PollFd::new(
                signal_fd.as_ref().unwrap_unchecked().as_fd(),
                PollFlags::POLLIN,
            ));
        }

        // We also need to pump stdin to ptmx
        poll_fds.push(PollFd::new(
            FileOrStd::StdIn.as_file().as_fd(),
            PollFlags::POLLIN,
        ));
    }

    // Any flag in this list indicates stop polling
    let stop_flags = PollFlags::POLLERR | PollFlags::POLLHUP | PollFlags::POLLNVAL;

    // Open a pipe to bypass userspace copy with splice
    let pipe_fd = pipe2(OFlag::O_CLOEXEC).into_os_result("pipe2", None, None)?;
    let pipe_fd = (File::from(pipe_fd.0), File::from(pipe_fd.1));

    'poll: loop {
        // Wait for event
        poll(&mut poll_fds, PollTimeout::NONE).check_os_err("poll", None, None)?;
        for pfd in &poll_fds {
            if pfd.all().unwrap_or(false) {
                let raw_fd = pfd.as_fd().as_raw_fd();
                if raw_fd == STDIN_FILENO {
                    pump_via_splice(FileOrStd::StdIn.as_file(), &ptmx, &pipe_fd)?;
                } else if raw_fd == raw_ptmx {
                    pump_via_splice(&ptmx, FileOrStd::StdOut.as_file(), &pipe_fd)?;
                } else if let Some(sig) = &signal_fd
                    && raw_fd == sig.as_raw_fd()
                {
                    sync_winsize(raw_ptmx);
                    sig.read_signal()?;
                }
            } else if pfd
                .revents()
                .unwrap_or(PollFlags::POLLHUP)
                .intersects(stop_flags)
            {
                // If revents is None or contains any err_flags, stop polling
                break 'poll;
            }
        }
    }
    Ok(())
}

pub fn pump_tty(ptmx: RawFd, pump_stdin: bool) {
    let old_term = if pump_stdin {
        sync_winsize(ptmx);
        set_stdin_raw().ok()
    } else {
        None
    };

    let ptmx = unsafe { File::from_raw_fd(ptmx) };
    pump_tty_impl(ptmx, pump_stdin).ok();

    if let Some(term) = old_term {
        restore_stdin(term).ok();
    }
    raise(Signal::SIGWINCH).ok();
}

```

`native/src/core/su/su.cpp`:

```cpp
/*
 * Copyright 2017 - 2025, John Wu (@topjohnwu)
 * Copyright 2015, Pierre-Hugues Husson <phh@phh.me>
 * Copyright 2010, Adam Shanks (@ChainsDD)
 * Copyright 2008, Zinx Verituse (@zinxv)
 */

#include <unistd.h>
#include <getopt.h>
#include <fcntl.h>
#include <pwd.h>
#include <linux/securebits.h>
#include <sys/capability.h>
#include <sys/prctl.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mount.h>

#include <algorithm>

#include <consts.hpp>
#include <base.hpp>
#include <flags.h>
#include <core.hpp>

using namespace std;

#define DEFAULT_SHELL "/system/bin/sh"

// Constants for atty
#define ATTY_IN    (1 << 0)
#define ATTY_OUT   (1 << 1)
#define ATTY_ERR   (1 << 2)

int quit_signals[] = { SIGALRM, SIGABRT, SIGHUP, SIGPIPE, SIGQUIT, SIGTERM, SIGINT, 0 };

[[noreturn]] static void usage(int status) {
    FILE *stream = (status == EXIT_SUCCESS) ? stdout : stderr;

    fprintf(stream,
    "MagiskSU\n\n"
    "Usage: su [options] [-] [user [argument...]]\n\n"
    "Options:\n"
    "  -c, --command COMMAND         Pass COMMAND to the invoked shell\n"
    "  -i, --interactive             Force pseudo-terminal allocation when using -c\n"
    "  -g, --group GROUP             Specify the primary group\n"
    "  -G, --supp-group GROUP        Specify a supplementary group\n"
    "                                The first specified supplementary group is also used\n"
    "                                as a primary group if the option -g is not specified\n"
    "  -Z, --context CONTEXT         Change SELinux context\n"
    "  -t, --target PID              PID to take mount namespace from\n"
    "  -d, --drop-cap                Drop all Linux capabilities\n"
    "  -h, --help                    Display this help message and exit\n"
    "  -, -l, --login                Pretend the shell to be a login shell\n"
    "  -m, -p,\n"
    "  --preserve-environment        Preserve the entire environment\n"
    "  -s, --shell SHELL             Use SHELL instead of the default " DEFAULT_SHELL "\n"
    "  -v, --version                 Display version number and exit\n"
    "  -V                            Display version code and exit\n"
    "  -mm, -M,\n"
    "  --mount-master                Force run in the global mount namespace\n\n");
    exit(status);
}

static void sighandler(int sig) {
    // Close all standard I/O to cause the pumps to exit
    // so we can continue and retrieve the exit code.
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    // Put back all the default handlers
    struct sigaction act{};
    act.sa_handler = SIG_DFL;
    for (int i = 0; quit_signals[i]; ++i) {
        sigaction(quit_signals[i], &act, nullptr);
    }
}

static void setup_sighandlers(void (*handler)(int)) {
    struct sigaction act{};
    act.sa_handler = handler;
    for (int i = 0; quit_signals[i]; ++i) {
        sigaction(quit_signals[i], &act, nullptr);
    }
}

int su_client_main(int argc, char *argv[]) {
    option long_opts[] = {
            { "command",                required_argument,  nullptr, 'c' },
            { "help",                   no_argument,        nullptr, 'h' },
            { "login",                  no_argument,        nullptr, 'l' },
            { "preserve-environment",   no_argument,        nullptr, 'p' },
            { "shell",                  required_argument,  nullptr, 's' },
            { "version",                no_argument,        nullptr, 'v' },
            { "context",                required_argument,  nullptr, 'Z' },
            { "mount-master",           no_argument,        nullptr, 'M' },
            { "target",                 required_argument,  nullptr, 't' },
            { "group",                  required_argument,  nullptr, 'g' },
            { "supp-group",             required_argument,  nullptr, 'G' },
            { "interactive",            no_argument,        nullptr, 'i' },
            { "drop-cap",               no_argument,        nullptr, 'd' },
            { nullptr, 0, nullptr, 0 },
    };

    auto req = SuRequest::New();

    for (int i = 0; i < argc; i++) {
        // Replace -cn and -z with -Z for backwards compatibility
        if (strcmp(argv[i], "-cn") == 0 || strcmp(argv[i], "-z") == 0)
            strcpy(argv[i], "-Z");
        // Replace -mm with -M for supporting getopt_long
        else if (strcmp(argv[i], "-mm") == 0)
            strcpy(argv[i], "-M");
    }

    bool interactive = false;

    int c;
    while ((c = getopt_long(argc, argv, "c:hlimpds:VvuZ:Mt:g:G:", long_opts, nullptr)) != -1) {
        switch (c) {
            case 'c': {
                string command;
                for (int i = optind - 1; i < argc; ++i) {
                    if (!command.empty())
                        command += ' ';
                    command += argv[i];
                }
                req.command = command;
                optind = argc;
                break;
            }
            case 'h':
                usage(EXIT_SUCCESS);
            case 'i':
                interactive = true;
                break;
            case 'l':
                req.login = true;
                break;
            case 'm':
            case 'p':
                req.keep_env = true;
                break;
            case 'd':
                req.drop_cap = true;
                break;
            case 's':
                req.shell = optarg;
                break;
            case 'V':
                printf("%d\n", MAGISK_VER_CODE);
                exit(EXIT_SUCCESS);
            case 'v':
                printf("%s\n", MAGISK_VERSION ":MAGISKSU");
                exit(EXIT_SUCCESS);
            case 'Z':
                req.context = optarg;
                break;
            case 'M':
            case 't':
                if (req.target_pid != -1) {
                    fprintf(stderr, "Can't use -M and -t at the same time\n");
                    usage(EXIT_FAILURE);
                }
                if (optarg == nullptr) {
                    req.target_pid = 0;
                } else {
                    req.target_pid = parse_int(optarg);
                    if (*optarg == '-' || req.target_pid == -1) {
                        fprintf(stderr, "Invalid PID: %s\n", optarg);
                        usage(EXIT_FAILURE);
                    }
                }
                break;
            case 'g':
            case 'G': {
                vector<gid_t> gids;
                if (int gid = parse_int(optarg); gid >= 0) {
                    gids.insert(c == 'g' ? gids.begin() : gids.end(), gid);
                } else {
                    fprintf(stderr, "Invalid GID: %s\n", optarg);
                    usage(EXIT_FAILURE);
                }
                ranges::copy(gids, std::back_inserter(req.gids));
                break;
            }
            default:
                /* Bionic getopt_long doesn't terminate its error output by newline */
                fprintf(stderr, "\n");
                usage(2);
        }
    }

    if (optind < argc && strcmp(argv[optind], "-") == 0) {
        req.login = true;
        optind++;
    }
    /* username or uid */
    if (optind < argc) {
        if (const passwd *pw = getpwnam(argv[optind]))
            req.target_uid = pw->pw_uid;
        else
            req.target_uid = parse_int(argv[optind]);
        optind++;
    }

    // Connect to client
    owned_fd fd = connect_daemon(RequestCode::SUPERUSER);

    // Send request
    req.write_to_fd(fd);

    // Wait for ack from daemon
    if (read_int(fd)) {
        // Fast fail
        fprintf(stderr, "%s\n", strerror(EACCES));
        return EACCES;
    }

    // Determine which one of our streams are attached to a TTY
    interactive |= req.command.empty();
    int atty = 0;
    if (isatty(STDIN_FILENO) && interactive)  atty |= ATTY_IN;
    if (isatty(STDOUT_FILENO) && interactive) atty |= ATTY_OUT;
    if (isatty(STDERR_FILENO) && interactive) atty |= ATTY_ERR;

    // Send stdin
    send_fd(fd, (atty & ATTY_IN) ? -1 : STDIN_FILENO);
    // Send stdout
    send_fd(fd, (atty & ATTY_OUT) ? -1 : STDOUT_FILENO);
    // Send stderr
    send_fd(fd, (atty & ATTY_ERR) ? -1 : STDERR_FILENO);

    if (atty) {
        // We need a PTY. Get one.
        int ptmx = recv_fd(fd);
        setup_sighandlers(sighandler);
        // If stdin is not a tty, and if we pump to ptmx, our process may intercept the input to ptmx and
        // output to stdout, which cause the target process lost input.
        pump_tty(ptmx, atty & ATTY_IN);
    }

    // Get the exit code
    return read_int(fd);
}

static void drop_caps() {
    static auto last_valid_cap = []() {
        uint32_t cap = CAP_WAKE_ALARM;
        while (prctl(PR_CAPBSET_READ, cap) >= 0) {
            cap++;
        }
        return cap - 1;
    }();
    // Drop bounding set
    for (uint32_t cap = 0; cap <= last_valid_cap; cap++) {
        if (cap != CAP_SETUID) {
            prctl(PR_CAPBSET_DROP, cap);
        }
    }
    // Clean inheritable set
    __user_cap_header_struct header = {.version = _LINUX_CAPABILITY_VERSION_3};
    __user_cap_data_struct data[_LINUX_CAPABILITY_U32S_3] = {};
    if (capget(&header, &data[0]) == 0) {
        for (size_t i = 0; i < _LINUX_CAPABILITY_U32S_3; i++) {
            data[i].inheritable = 0;
        }
        capset(&header, &data[0]);
    }
    // All capabilities will be lost after exec
    prctl(PR_SET_SECUREBITS, SECBIT_NOROOT);
    // Except CAP_SETUID in bounding set, it is a marker for restricted process
}

static bool proc_is_restricted(pid_t pid) {
    char buf[32] = {};
    auto bnd = "CapBnd:"sv;
    uint32_t data[_LINUX_CAPABILITY_U32S_3] = {};
    ssprintf(buf, sizeof(buf), "/proc/%d/status", pid);
    owned_fd status_fd = xopen(buf, O_RDONLY | O_CLOEXEC);
    file_readline(status_fd, [&](Utf8CStr s) -> bool {
        string_view line = s;
        if (line.starts_with(bnd)) {
            auto p = line.begin();
            advance(p, bnd.size());
            while (isspace(*p)) advance(p, 1);
            line.remove_prefix(distance(line.begin(), p));
            for (int i = 0; i < _LINUX_CAPABILITY_U32S_3; i++) {
                auto cap = line.substr((_LINUX_CAPABILITY_U32S_3 - 1 - i) * 8, 8);
                data[i] = parse_uint32_hex(cap);
            }
            return false;
        }
        return true;
    });

    bool equal = true;
    for (int i = 0; i < _LINUX_CAPABILITY_U32S_3; i++) {
        if (i == CAP_TO_INDEX(CAP_SETUID)) {
            if (data[i] != CAP_TO_MASK(CAP_SETUID)) equal = false;
        } else {
            if (data[i] != 0) equal = false;
        }
    }
    return equal;
}

static void set_identity(int uid, const rust::Vec<gid_t> &groups) {
    gid_t gid;
    if (!groups.empty()) {
        if (setgroups(groups.size(), groups.data())) {
            PLOGE("setgroups");
        }
        gid = groups[0];
    } else {
        gid = uid;
    }
    if (setresgid(gid, gid, gid)) {
        PLOGE("setresgid (%u)", uid);
    }
    if (setresuid(uid, uid, uid)) {
        PLOGE("setresuid (%u)", uid);
    }
}

void exec_root_shell(int client, int pid, SuRequest &req, MntNsMode mode) {
    // Become session leader
    xsetsid();

    // The FDs for each of the streams
    int infd = recv_fd(client);
    int outfd = recv_fd(client);
    int errfd = recv_fd(client);
    int ptsfd = -1;

    // App need a PTY
    if (infd < 0 || outfd < 0 || errfd < 0) {
        string pts;
        string ptmx;
        auto magiskpts = get_magisk_tmp() + "/"s SHELLPTS;
        if (access(magiskpts.data(), F_OK)) {
            pts = "/dev/pts";
            ptmx = "/dev/ptmx";
        } else {
            pts = magiskpts;
            ptmx = magiskpts + "/ptmx";
        }
        int ptmx_fd = xopen(ptmx.data(), O_RDWR);
        grantpt(ptmx_fd);
        unlockpt(ptmx_fd);
        int pty_num = get_pty_num(ptmx_fd);
        if (pty_num < 0) {
            // Kernel issue? Fallback to /dev/pts
            close(ptmx_fd);
            pts = "/dev/pts";
            ptmx_fd = xopen("/dev/ptmx", O_RDWR);
            grantpt(ptmx_fd);
            unlockpt(ptmx_fd);
            pty_num = get_pty_num(ptmx_fd);
        }
        send_fd(client, ptmx_fd);
        close(ptmx_fd);

        string pts_slave = pts + "/" + to_string(pty_num);
        LOGD("su: pts_slave=[%s]\n", pts_slave.data());

        // Opening the TTY has to occur after the
        // fork() and setsid() so that it becomes
        // our controlling TTY and not the daemon's
        ptsfd = xopen(pts_slave.data(), O_RDWR);
    }

    // Swap out stdin, stdout, stderr
    xdup2(infd < 0 ? ptsfd : infd, STDIN_FILENO);
    xdup2(outfd < 0 ? ptsfd : outfd, STDOUT_FILENO);
    xdup2(errfd < 0 ? ptsfd : errfd, STDERR_FILENO);

    close(infd);
    close(outfd);
    close(errfd);
    close(ptsfd);
    close(client);

    // Handle namespaces
    if (req.target_pid == -1)
        req.target_pid = pid;
    else if (req.target_pid == 0)
        mode = MntNsMode::Global;
    else if (mode == MntNsMode::Global)
        mode = MntNsMode::Requester;

    switch (mode) {
        case MntNsMode::Global:
            LOGD("su: use global namespace\n");
            break;
        case MntNsMode::Requester:
            LOGD("su: use namespace of pid=[%d]\n", req.target_pid);
            switch_mnt_ns(req.target_pid);
            break;
        case MntNsMode::Isolate:
            LOGD("su: use new isolated namespace\n");
            switch_mnt_ns(req.target_pid);
            xunshare(CLONE_NEWNS);
            xmount(nullptr, "/", nullptr, MS_PRIVATE | MS_REC, nullptr);
            break;
    }

    const char *argv[4] = { nullptr };

    argv[0] = req.login ? "-" : req.shell.c_str();

    if (!req.command.empty()) {
        argv[1] = "-c";
        argv[2] = req.command.c_str();
    }

    // Setup environment
    umask(022);
    char path[32];
    ssprintf(path, sizeof(path), "/proc/%d/cwd", pid);
    char cwd[4096];
    if (canonical_path(path, cwd, sizeof(cwd)) > 0)
        chdir(cwd);
    ssprintf(path, sizeof(path), "/proc/%d/environ", pid);
    auto env = full_read(path);
    clearenv();
    for (size_t pos = 0; pos < env.size(); ++pos) {
        putenv(env.data() + pos);
        pos = env.find_first_of('\0', pos);
        if (pos == std::string::npos)
            break;
    }
    if (!req.keep_env) {
        struct passwd *pw;
        pw = getpwuid(req.target_uid);
        if (pw) {
            setenv("HOME", pw->pw_dir, 1);
            setenv("USER", pw->pw_name, 1);
            setenv("LOGNAME", pw->pw_name, 1);
            setenv("SHELL", req.shell.c_str(), 1);
        }
    }

    // Config privileges
    if (!req.context.empty()) {
        auto f = xopen_file("/proc/self/attr/exec", "we");
        if (f) fprintf(f.get(), "%s", req.context.c_str());
    }
    if (req.drop_cap || proc_is_restricted(pid))
        drop_caps();
    if (req.target_uid != AID_ROOT || req.gids.size() > 0)
        set_identity(req.target_uid, req.gids);

    // Unblock all signals
    sigset_t block_set;
    sigemptyset(&block_set);
    sigprocmask(SIG_SETMASK, &block_set, nullptr);

    execvp(req.shell.c_str(), (char **) argv);
    fprintf(stderr, "Cannot execute %s: %s\n", req.shell.c_str(), strerror(errno));
    PLOGE("exec");
}

```

`native/src/core/thread.rs`:

```rs
use base::{ResultExt, new_daemon_thread};
use nix::sys::signal::SigSet;
use nix::unistd::{getpid, gettid};
use std::sync::LazyLock;
use std::sync::nonpoison::{Condvar, Mutex};
use std::time::Duration;

static THREAD_POOL: LazyLock<ThreadPool> = LazyLock::new(ThreadPool::default);

const THREAD_IDLE_MAX_SEC: u64 = 60;
const CORE_POOL_SIZE: i32 = 3;

#[derive(Default)]
pub struct ThreadPool {
    task_is_some: Condvar,
    task_is_none: Condvar,
    info: Mutex<PoolInfo>,
}

#[derive(Default)]
struct PoolInfo {
    idle_threads: i32,
    total_threads: i32,
    task: Option<Box<dyn FnOnce() + Send>>,
}

impl ThreadPool {
    fn pool_loop(&self, is_core_pool: bool) {
        let mask = SigSet::all();

        loop {
            // Always restore the sigmask to block all signals
            mask.thread_set_mask().log_ok();

            let task: Option<Box<dyn FnOnce() + Send>>;
            {
                let mut info = self.info.lock();
                info.idle_threads += 1;
                if info.task.is_none() {
                    if is_core_pool {
                        // Core pool never closes, wait forever.
                        self.task_is_some.wait(&mut info);
                    } else {
                        let dur = Duration::from_secs(THREAD_IDLE_MAX_SEC);
                        if self.task_is_some.wait_timeout(&mut info, dur).timed_out() {
                            // Terminate thread after timeout
                            info.idle_threads -= 1;
                            info.total_threads -= 1;
                            return;
                        }
                    }
                }
                task = info.task.take();
                self.task_is_none.notify_one();
                info.idle_threads -= 1;
            }
            if let Some(task) = task {
                task();
            }
            if getpid() == gettid() {
                // This meant the current thread forked and became the main thread, exit
                std::process::exit(0);
            }
        }
    }

    fn exec_task_impl(&self, f: impl FnOnce() + Send + 'static) {
        extern "C" fn pool_loop_raw(arg: usize) -> usize {
            let is_core_pool = arg != 0;
            THREAD_POOL.pool_loop(is_core_pool);
            0
        }

        let mut info = self.info.lock();
        while info.task.is_some() {
            // Wait until task is none
            self.task_is_none.wait(&mut info);
        }
        info.task = Some(Box::new(f));
        if info.idle_threads == 0 {
            info.total_threads += 1;
            let is_core_thread = if info.total_threads <= CORE_POOL_SIZE {
                1_usize
            } else {
                0_usize
            };
            unsafe {
                new_daemon_thread(pool_loop_raw, is_core_thread);
            }
        } else {
            self.task_is_some.notify_one();
        }
    }

    pub fn exec_task(f: impl FnOnce() + Send + 'static) {
        THREAD_POOL.exec_task_impl(f);
    }
}

```

`native/src/core/utils.cpp`:

```cpp
#include <csignal>
#include <libgen.h>
#include <sys/mount.h>
#include <sys/sysmacros.h>
#include <linux/input.h>
#include <map>

#include <consts.hpp>
#include <base.hpp>
#include <core.hpp>

using namespace std;

bool read_string(int fd, std::string &str) {
    str.clear();
    int len = read_int(fd);
    str.resize(len);
    return xxread(fd, str.data(), len) == len;
}

string read_string(int fd) {
    string str;
    read_string(fd, str);
    return str;
}

void write_string(int fd, string_view str) {
    if (fd < 0) return;
    write_int(fd, str.size());
    xwrite(fd, str.data(), str.size());
}

const char *get_magisk_tmp() {
    static const char *path = nullptr;
    if (path == nullptr) {
        if (access("/debug_ramdisk/" INTLROOT, F_OK) == 0) {
            path = "/debug_ramdisk";
        } else if (access("/sbin/" INTLROOT, F_OK) == 0) {
            path = "/sbin";
        } else {
            path = "";
        }
    }
    return path;
}

void unlock_blocks() {
    int fd, dev, OFF = 0;

    auto dir = xopen_dir("/dev/block");
    if (!dir)
        return;
    dev = dirfd(dir.get());

    for (dirent *entry; (entry = readdir(dir.get()));) {
        if (entry->d_type == DT_BLK) {
            if ((fd = openat(dev, entry->d_name, O_RDONLY | O_CLOEXEC)) < 0)
                continue;
            if (ioctl(fd, BLKROSET, &OFF) < 0)
                PLOGE("unlock %s", entry->d_name);
            close(fd);
        }
    }
}

#define test_bit(bit, array) (array[bit / 8] & (1 << (bit % 8)))

bool check_key_combo() {
    uint8_t bitmask[(KEY_MAX + 1) / 8];
    vector<owned_fd> events;
    constexpr char name[] = "/dev/.ev";

    // First collect candidate events that accepts volume down
    for (int minor = 64; minor < 96; ++minor) {
        if (xmknod(name, S_IFCHR | 0444, makedev(13, minor)))
            continue;
        int fd = open(name, O_RDONLY | O_CLOEXEC);
        unlink(name);
        if (fd < 0)
            continue;
        memset(bitmask, 0, sizeof(bitmask));
        ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(bitmask)), bitmask);
        if (test_bit(KEY_VOLUMEDOWN, bitmask))
            events.emplace_back(fd);
        else
            close(fd);
    }
    if (events.empty())
        return false;

    // Check if volume down key is held continuously for more than 3 seconds
    for (int i = 0; i < 300; ++i) {
        bool pressed = false;
        for (int fd : events) {
            memset(bitmask, 0, sizeof(bitmask));
            ioctl(fd, EVIOCGKEY(sizeof(bitmask)), bitmask);
            if (test_bit(KEY_VOLUMEDOWN, bitmask)) {
                pressed = true;
                break;
            }
        }
        if (!pressed)
            return false;
        // Check every 10ms
        usleep(10000);
    }
    LOGD("KEY_VOLUMEDOWN detected: enter safe mode\n");
    return true;
}

```

`native/src/core/zygisk/api.hpp`:

```hpp
/* Copyright 2022-2023 John "topjohnwu" Wu
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

// This is the public API for Zygisk modules.
// DO NOT MODIFY ANY CODE IN THIS HEADER.

// WARNING: this file may contain changes that are not finalized.
// Always use the following published header for development:
// https://github.com/topjohnwu/zygisk-module-sample/blob/master/module/jni/zygisk.hpp

#pragma once

#include <jni.h>

#define ZYGISK_API_VERSION 5

/*

***************
* Introduction
***************

On Android, all app processes are forked from a special daemon called "Zygote".
For each new app process, zygote will fork a new process and perform "specialization".
This specialization operation enforces the Android security sandbox on the newly forked
process to make sure that 3rd party application code is only loaded after it is being
restricted within a sandbox.

On Android, there is also this special process called "system_server". This single
process hosts a significant portion of system services, which controls how the
Android operating system and apps interact with each other.

The Zygisk framework provides a way to allow developers to build modules and run custom
code before and after system_server and any app processes' specialization.
This enable developers to inject code and alter the behavior of system_server and app processes.

Please note that modules will only be loaded after zygote has forked the child process.
THIS MEANS ALL OF YOUR CODE RUNS IN THE APP/SYSTEM_SERVER PROCESS, NOT THE ZYGOTE DAEMON!

*********************
* Development Guide
*********************

Define a class and inherit zygisk::ModuleBase to implement the functionality of your module.
Use the macro REGISTER_ZYGISK_MODULE(className) to register that class to Zygisk.

Example code:

static jint (*orig_logger_entry_max)(JNIEnv *env);
static jint my_logger_entry_max(JNIEnv *env) { return orig_logger_entry_max(env); }

class ExampleModule : public zygisk::ModuleBase {
public:
    void onLoad(zygisk::Api *api, JNIEnv *env) override {
        this->api = api;
        this->env = env;
    }
    void preAppSpecialize(zygisk::AppSpecializeArgs *args) override {
        JNINativeMethod methods[] = {
            { "logger_entry_max_payload_native", "()I", (void*) my_logger_entry_max },
        };
        api->hookJniNativeMethods(env, "android/util/Log", methods, 1);
        *(void **) &orig_logger_entry_max = methods[0].fnPtr;
    }
private:
    zygisk::Api *api;
    JNIEnv *env;
};

REGISTER_ZYGISK_MODULE(ExampleModule)

-----------------------------------------------------------------------------------------

Since your module class's code runs with either Zygote's privilege in pre[XXX]Specialize,
or runs in the sandbox of the target process in post[XXX]Specialize, the code in your class
never runs in a true superuser environment.

If your module require access to superuser permissions, you can create and register
a root companion handler function. This function runs in a separate root companion
daemon process, and an Unix domain socket is provided to allow you to perform IPC between
your target process and the root companion process.

Example code:

static void example_handler(int socket) { ... }

REGISTER_ZYGISK_COMPANION(example_handler)

*/

namespace zygisk {

struct Api;
struct AppSpecializeArgs;
struct ServerSpecializeArgs;

class ModuleBase {
public:

    // This method is called as soon as the module is loaded into the target process.
    // A Zygisk API handle will be passed as an argument.
    virtual void onLoad([[maybe_unused]] Api *api, [[maybe_unused]] JNIEnv *env) {}

    // This method is called before the app process is specialized.
    // At this point, the process just got forked from zygote, but no app specific specialization
    // is applied. This means that the process does not have any sandbox restrictions and
    // still runs with the same privilege of zygote.
    //
    // All the arguments that will be sent and used for app specialization is passed as a single
    // AppSpecializeArgs object. You can read and overwrite these arguments to change how the app
    // process will be specialized.
    //
    // If you need to run some operations as superuser, you can call Api::connectCompanion() to
    // get a socket to do IPC calls with a root companion process.
    // See Api::connectCompanion() for more info.
    virtual void preAppSpecialize([[maybe_unused]] AppSpecializeArgs *args) {}

    // This method is called after the app process is specialized.
    // At this point, the process has all sandbox restrictions enabled for this application.
    // This means that this method runs with the same privilege of the app's own code.
    virtual void postAppSpecialize([[maybe_unused]] const AppSpecializeArgs *args) {}

    // This method is called before the system server process is specialized.
    // See preAppSpecialize(args) for more info.
    virtual void preServerSpecialize([[maybe_unused]] ServerSpecializeArgs *args) {}

    // This method is called after the system server process is specialized.
    // At this point, the process runs with the privilege of system_server.
    virtual void postServerSpecialize([[maybe_unused]] const ServerSpecializeArgs *args) {}
};

struct AppSpecializeArgs {
    // Required arguments. These arguments are guaranteed to exist on all Android versions.
    jint &uid;
    jint &gid;
    jintArray &gids;
    jint &runtime_flags;
    jobjectArray &rlimits;
    jint &mount_external;
    jstring &se_info;
    jstring &nice_name;
    jstring &instruction_set;
    jstring &app_data_dir;

    // Optional arguments. Please check whether the pointer is null before de-referencing
    jintArray *const fds_to_ignore;
    jboolean *const is_child_zygote;
    jboolean *const is_top_app;
    jobjectArray *const pkg_data_info_list;
    jobjectArray *const whitelisted_data_info_list;
    jboolean *const mount_data_dirs;
    jboolean *const mount_storage_dirs;
    jboolean *const mount_sysprop_overrides;

    AppSpecializeArgs() = delete;
};

struct ServerSpecializeArgs {
    jint &uid;
    jint &gid;
    jintArray &gids;
    jint &runtime_flags;
    jlong &permitted_capabilities;
    jlong &effective_capabilities;

    ServerSpecializeArgs() = delete;
};

namespace internal {
struct api_table;
template <class T> void entry_impl(api_table *, JNIEnv *);
}

// These values are used in Api::setOption(Option)
enum Option : int {
    // Force Magisk's denylist unmount routines to run on this process.
    //
    // Setting this option only makes sense in preAppSpecialize.
    // The actual unmounting happens during app process specialization.
    //
    // Set this option to force all Magisk and modules' files to be unmounted from the
    // mount namespace of the process, regardless of the denylist enforcement status.
    FORCE_DENYLIST_UNMOUNT = 0,

    // When this option is set, your module's library will be dlclose-ed after post[XXX]Specialize.
    // Be aware that after dlclose-ing your module, all of your code will be unmapped from memory.
    // YOU MUST NOT ENABLE THIS OPTION AFTER HOOKING ANY FUNCTIONS IN THE PROCESS.
    DLCLOSE_MODULE_LIBRARY = 1,
};

// Bit masks of the return value of Api::getFlags()
enum StateFlag : uint32_t {
    // The user has granted root access to the current process
    PROCESS_GRANTED_ROOT = (1u << 0),

    // The current process was added on the denylist
    PROCESS_ON_DENYLIST = (1u << 1),
};

// All API methods will stop working after post[XXX]Specialize as Zygisk will be unloaded
// from the specialized process afterwards.
struct Api {

    // Connect to a root companion process and get a Unix domain socket for IPC.
    //
    // This API only works in the pre[XXX]Specialize methods due to SELinux restrictions.
    //
    // The pre[XXX]Specialize methods run with the same privilege of zygote.
    // If you would like to do some operations with superuser permissions, register a handler
    // function that would be called in the root process with REGISTER_ZYGISK_COMPANION(func).
    // Another good use case for a companion process is that if you want to share some resources
    // across multiple processes, hold the resources in the companion process and pass it over.
    //
    // The root companion process is ABI aware; that is, when calling this method from a 32-bit
    // process, you will be connected to a 32-bit companion process, and vice versa for 64-bit.
    //
    // Returns a file descriptor to a socket that is connected to the socket passed to your
    // module's companion request handler. Returns -1 if the connection attempt failed.
    int connectCompanion();

    // Get the file descriptor of the root folder of the current module.
    //
    // This API only works in the pre[XXX]Specialize methods.
    // Accessing the directory returned is only possible in the pre[XXX]Specialize methods
    // or in the root companion process (assuming that you sent the fd over the socket).
    // Both restrictions are due to SELinux and UID.
    //
    // Module should also make sure zygote is allowed to read module dir (e.g. module dir has
    // system_file context) due to SELinux restrictions on socket messages.
    //
    // Returns -1 if errors occurred.
    int getModuleDir();

    // Set various options for your module.
    // Please note that this method accepts one single option at a time.
    // Check zygisk::Option for the full list of options available.
    void setOption(Option opt);

    // Get information about the current process.
    // Returns bitwise-or'd zygisk::StateFlag values.
    uint32_t getFlags();

    // Exempt the provided file descriptor from being automatically closed.
    //
    // This API only make sense in preAppSpecialize; calling this method in any other situation
    // is either a no-op (returns true) or an error (returns false).
    //
    // When false is returned, the provided file descriptor will eventually be closed by zygote.
    bool exemptFd(int fd);

    // Hook JNI native methods for a class
    //
    // Lookup all registered JNI native methods and replace it with your own methods.
    // The original function pointer will be saved in each JNINativeMethod's fnPtr.
    // If no matching class, method name, or signature is found, that specific JNINativeMethod.fnPtr
    // will be set to nullptr.
    void hookJniNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *methods, int numMethods);

    // Hook functions in the PLT (Procedure Linkage Table) of ELFs loaded in memory.
    //
    // Parsing /proc/[PID]/maps will give you the memory map of a process. As an example:
    //
    //       <address>       <perms>  <offset>   <dev>  <inode>           <pathname>
    // 56b4346000-56b4347000  r-xp    00002000   fe:00    235       /system/bin/app_process64
    // (More details: https://man7.org/linux/man-pages/man5/proc.5.html)
    //
    // The `dev` and `inode` pair uniquely identifies a file being mapped into memory.
    // For matching ELFs loaded in memory, replace function `symbol` with `newFunc`.
    // If `oldFunc` is not nullptr, the original function pointer will be saved to `oldFunc`.
    void pltHookRegister(dev_t dev, ino_t inode, const char *symbol, void *newFunc, void **oldFunc);

    // Commit all the hooks that was previously registered.
    // Returns false if an error occurred.
    bool pltHookCommit();

private:
    internal::api_table *tbl;
    template <class T> friend void internal::entry_impl(internal::api_table *, JNIEnv *);
};

// Register a class as a Zygisk module

#define REGISTER_ZYGISK_MODULE(clazz) \
void zygisk_module_entry(zygisk::internal::api_table *table, JNIEnv *env) { \
    zygisk::internal::entry_impl<clazz>(table, env);                        \
}

// Register a root companion request handler function for your module
//
// The function runs in a superuser daemon process and handles a root companion request from
// your module running in a target process. The function has to accept an integer value,
// which is a Unix domain socket that is connected to the target process.
// See Api::connectCompanion() for more info.
//
// NOTE: the function can run concurrently on multiple threads.
// Be aware of race conditions if you have globally shared resources.

#define REGISTER_ZYGISK_COMPANION(func) \
void zygisk_companion_entry(int client) { func(client); }

/*********************************************************
 * The following is internal ABI implementation detail.
 * You do not have to understand what it is doing.
 *********************************************************/

namespace internal {

struct module_abi {
    long api_version;
    ModuleBase *impl;

    void (*preAppSpecialize)(ModuleBase *, AppSpecializeArgs *);
    void (*postAppSpecialize)(ModuleBase *, const AppSpecializeArgs *);
    void (*preServerSpecialize)(ModuleBase *, ServerSpecializeArgs *);
    void (*postServerSpecialize)(ModuleBase *, const ServerSpecializeArgs *);

    module_abi(ModuleBase *module) : api_version(ZYGISK_API_VERSION), impl(module) {
        preAppSpecialize = [](auto m, auto args) { m->preAppSpecialize(args); };
        postAppSpecialize = [](auto m, auto args) { m->postAppSpecialize(args); };
        preServerSpecialize = [](auto m, auto args) { m->preServerSpecialize(args); };
        postServerSpecialize = [](auto m, auto args) { m->postServerSpecialize(args); };
    }
};

struct api_table {
    // Base
    void *impl;
    bool (*registerModule)(api_table *, module_abi *);

    void (*hookJniNativeMethods)(JNIEnv *, const char *, JNINativeMethod *, int);
    void (*pltHookRegister)(dev_t, ino_t, const char *, void *, void **);
    bool (*exemptFd)(int);
    bool (*pltHookCommit)();
    int  (*connectCompanion)(void * /* impl */);
    void (*setOption)(void * /* impl */, Option);
    int  (*getModuleDir)(void * /* impl */);
    uint32_t (*getFlags)(void * /* impl */);
};

template <class T>
void entry_impl(api_table *table, JNIEnv *env) {
    static Api api;
    api.tbl = table;
    static T module;
    ModuleBase *m = &module;
    static module_abi abi(m);
    if (!table->registerModule(table, &abi)) return;
    m->onLoad(&api, env);
}

} // namespace internal

inline int Api::connectCompanion() {
    return tbl->connectCompanion ? tbl->connectCompanion(tbl->impl) : -1;
}
inline int Api::getModuleDir() {
    return tbl->getModuleDir ? tbl->getModuleDir(tbl->impl) : -1;
}
inline void Api::setOption(Option opt) {
    if (tbl->setOption) tbl->setOption(tbl->impl, opt);
}
inline uint32_t Api::getFlags() {
    return tbl->getFlags ? tbl->getFlags(tbl->impl) : 0;
}
inline bool Api::exemptFd(int fd) {
    return tbl->exemptFd != nullptr && tbl->exemptFd(fd);
}
inline void Api::hookJniNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *methods, int numMethods) {
    if (tbl->hookJniNativeMethods) tbl->hookJniNativeMethods(env, className, methods, numMethods);
}
inline void Api::pltHookRegister(dev_t dev, ino_t inode, const char *symbol, void *newFunc, void **oldFunc) {
    if (tbl->pltHookRegister) tbl->pltHookRegister(dev, inode, symbol, newFunc, oldFunc);
}
inline bool Api::pltHookCommit() {
    return tbl->pltHookCommit != nullptr && tbl->pltHookCommit();
}

} // namespace zygisk

extern "C" {

[[gnu::visibility("default"), maybe_unused]]
void zygisk_module_entry(zygisk::internal::api_table *, JNIEnv *);

[[gnu::visibility("default"), maybe_unused]]
void zygisk_companion_entry(int);

} // extern "C"

```

`native/src/core/zygisk/daemon.rs`:

```rs
use crate::consts::MODULEROOT;
use crate::daemon::{MagiskD, to_user_id};
use crate::ffi::{ZygiskRequest, ZygiskStateFlags, get_magisk_tmp, update_deny_flags};
use crate::resetprop::{get_prop, set_prop};
use crate::socket::{IpcRead, UnixSocketExt};
use base::libc::STDOUT_FILENO;
use base::{
    Directory, FsPathBuilder, LoggedResult, ResultExt, Utf8CStr, WriteExt, cstr, fork_dont_care,
    libc, log_err, raw_cstr, warn,
};
use nix::fcntl::OFlag;
use std::fmt::Write;
use std::os::fd::{AsRawFd, RawFd};
use std::os::unix::net::UnixStream;
use std::ptr;
use std::sync::atomic::Ordering;

const NBPROP: &Utf8CStr = cstr!("ro.dalvik.vm.native.bridge");
const ZYGISKLDR: &str = "libzygisk.so";
const UNMOUNT_MASK: u32 =
    ZygiskStateFlags::ProcessOnDenyList.repr | ZygiskStateFlags::DenyListEnforced.repr;

pub fn zygisk_should_load_module(flags: u32) -> bool {
    flags & UNMOUNT_MASK != UNMOUNT_MASK && flags & ZygiskStateFlags::ProcessIsMagiskApp.repr == 0
}

#[allow(unused_variables)]
fn exec_zygiskd(is_64_bit: bool, remote: UnixStream) {
    // This fd has to survive exec
    unsafe {
        libc::fcntl(remote.as_raw_fd(), libc::F_SETFD, 0);
    }

    // Start building the exec arguments

    #[cfg(target_pointer_width = "64")]
    let magisk = if is_64_bit { "magisk" } else { "magisk32" };

    #[cfg(target_pointer_width = "32")]
    let magisk = "magisk";

    let exe = cstr::buf::new::<64>()
        .join_path(get_magisk_tmp())
        .join_path(magisk);

    let mut fd_str = cstr::buf::new::<16>();
    write!(fd_str, "{}", remote.as_raw_fd()).ok();
    unsafe {
        libc::execl(
            exe.as_ptr(),
            raw_cstr!(""),
            raw_cstr!("zygisk"),
            raw_cstr!("companion"),
            fd_str.as_ptr(),
            ptr::null() as *const libc::c_char,
        );
        libc::exit(-1);
    }
}

#[derive(Default)]
pub struct ZygiskState {
    pub lib_name: String,
    sockets: (Option<UnixStream>, Option<UnixStream>),
    start_count: u32 = 1,
}

impl ZygiskState {
    fn connect_zygiskd(&mut self, mut client: UnixStream, daemon: &MagiskD) -> LoggedResult<()> {
        let is_64_bit: bool = client.read_decodable()?;
        let socket = if is_64_bit {
            &mut self.sockets.1
        } else {
            &mut self.sockets.0
        };

        if let Some(fd) = socket {
            // Make sure the socket is still valid
            let mut pfd = libc::pollfd {
                fd: fd.as_raw_fd(),
                events: 0,
                revents: 0,
            };
            if unsafe { libc::poll(&mut pfd, 1, 0) } != 0 || pfd.revents != 0 {
                // Any revent means error
                *socket = None;
            }
        }

        if let Some(fd) = socket {
            fd.send_fds(&[client.as_raw_fd()])?;
        } else {
            // Create a new socket pair and fork zygiskd process
            let (mut local, remote) = UnixStream::pair()?;
            if fork_dont_care() == 0 {
                exec_zygiskd(is_64_bit, remote);
            }
            if let Some(module_fds) = daemon.get_module_fds(is_64_bit) {
                local.send_fds(&module_fds)?;
            }
            if local.read_decodable::<i32>()? != 0 {
                return log_err!();
            }
            local.send_fds(&[client.as_raw_fd()])?;
            *socket = Some(local);
        }
        Ok(())
    }

    pub fn reset(&mut self, mut restore: bool) {
        if restore {
            self.start_count = 1;
        } else {
            self.sockets = (None, None);
            self.start_count += 1;
            if self.start_count > 3 {
                warn!("zygote crashed too many times, rolling-back");
                restore = true;
            }
        }

        if restore {
            self.restore_prop();
        } else {
            self.set_prop();
        }
    }

    pub fn set_prop(&mut self) {
        if !self.lib_name.is_empty() {
            return;
        }
        let orig = get_prop(NBPROP);
        self.lib_name = if orig.is_empty() || orig == "0" {
            ZYGISKLDR.to_string()
        } else {
            ZYGISKLDR.to_string() + &orig
        };
        set_prop(NBPROP, Utf8CStr::from_string(&mut self.lib_name));
        // Whether Huawei's Maple compiler is enabled.
        // If so, system server will be created by a special Zygote which ignores the native bridge
        // and make system server out of our control. Avoid it by disabling.
        if get_prop(cstr!("ro.maple.enable")) == "1" {
            set_prop(cstr!("ro.maple.enable"), cstr!("0"));
        }
    }

    pub fn restore_prop(&mut self) {
        let mut orig = "0".to_string();
        if self.lib_name.len() > ZYGISKLDR.len() {
            orig = self.lib_name[ZYGISKLDR.len()..].to_string();
        }
        set_prop(NBPROP, Utf8CStr::from_string(&mut orig));
        self.lib_name.clear();
    }
}

impl MagiskD {
    pub fn zygisk_handler(&self, mut client: UnixStream) {
        let _ = || -> LoggedResult<()> {
            let code = ZygiskRequest {
                repr: client.read_decodable()?,
            };
            match code {
                ZygiskRequest::GetInfo => self.get_process_info(client)?,
                ZygiskRequest::ConnectCompanion => self
                    .zygisk
                    .lock()
                    .connect_zygiskd(client, self)
                    .log_with_msg(|w| w.write_str("zygiskd startup error"))?,
                ZygiskRequest::GetModDir => self.get_mod_dir(client)?,
                _ => {}
            }
            Ok(())
        }();
    }

    fn get_module_fds(&self, is_64_bit: bool) -> Option<Vec<RawFd>> {
        self.module_list.get().map(|module_list| {
            module_list
                .iter()
                .map(|m| if is_64_bit { m.z64 } else { m.z32 })
                // All fds passed over sockets have to be valid file descriptors.
                // To work around this issue, send over STDOUT_FILENO as an indicator of an
                // invalid fd as it will always be /dev/null in magiskd.
                .map(|fd| if fd < 0 { STDOUT_FILENO } else { fd })
                .collect()
        })
    }

    fn get_process_info(&self, mut client: UnixStream) -> LoggedResult<()> {
        let uid: i32 = client.read_decodable()?;
        let process: String = client.read_decodable()?;
        let is_64_bit: bool = client.read_decodable()?;
        let mut flags: u32 = 0;
        update_deny_flags(uid, &process, &mut flags);
        if self.get_manager_uid(to_user_id(uid)) == uid {
            flags |= ZygiskStateFlags::ProcessIsMagiskApp.repr
        }
        if self.uid_granted_root(uid) {
            flags |= ZygiskStateFlags::ProcessGrantedRoot.repr
        }

        // First send flags
        client.write_pod(&flags)?;

        // Next send modules
        if zygisk_should_load_module(flags)
            && let Some(module_fds) = self.get_module_fds(is_64_bit)
        {
            client.send_fds(&module_fds)?;
        }

        // If we're not in system_server, we are done
        if uid != 1000 || process != "system_server" {
            return Ok(());
        }

        // Read all failed modules
        let failed_ids: Vec<i32> = client.read_decodable()?;
        if let Some(module_list) = self.module_list.get() {
            for id in failed_ids {
                let Some(module) = module_list.get(id as usize) else {
                    continue;
                };
                let path = cstr::buf::default()
                    .join_path(MODULEROOT)
                    .join_path(&module.name)
                    .join_path("zygisk");
                // Create the unloaded marker file
                if let Ok(dir) = Directory::open(&path) {
                    dir.open_as_file_at(cstr!("unloaded"), OFlag::O_CREAT | OFlag::O_RDONLY, 0o644)
                        .log()
                        .ok();
                }
            }
        }

        Ok(())
    }

    fn get_mod_dir(&self, mut client: UnixStream) -> LoggedResult<()> {
        let id: i32 = client.read_decodable()?;
        let Some(module) = self
            .module_list
            .get()
            .and_then(|list| list.get(id as usize))
        else {
            return Ok(());
        };
        let dir = cstr::buf::default()
            .join_path(MODULEROOT)
            .join_path(&module.name);
        let fd = dir.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC)?;
        client.send_fds(&[fd.as_raw_fd()])?;
        Ok(())
    }
}

// FFI to C++
impl MagiskD {
    pub fn zygisk_enabled(&self) -> bool {
        self.zygisk_enabled.load(Ordering::Acquire)
    }
}

```

`native/src/core/zygisk/entry.cpp`:

```cpp
#include <sys/mount.h>
#include <android/dlext.h>
#include <dlfcn.h>
#include <poll.h>

#include <base.hpp>
#include <core.hpp>

#include "zygisk.hpp"

using namespace std;

using comp_entry = void(*)(int);
extern "C" void exec_companion_entry(int, comp_entry);

static void zygiskd(int socket) {
    if (getuid() != 0 || fcntl(socket, F_GETFD) < 0)
        exit(-1);

#if defined(__LP64__)
    set_nice_name("zygiskd64");
    LOGI("* Launching zygiskd64\n");
#else
    set_nice_name("zygiskd32");
    LOGI("* Launching zygiskd32\n");
#endif

    // Load modules
    vector<comp_entry> modules;
    {
        auto module_fds = recv_fds(socket);
        for (int fd : module_fds) {
            comp_entry entry = nullptr;
            struct stat s{};
            if (fstat(fd, &s) == 0 && S_ISREG(s.st_mode)) {
                android_dlextinfo info {
                    .flags = ANDROID_DLEXT_USE_LIBRARY_FD,
                    .library_fd = fd,
                };
                if (void *h = android_dlopen_ext("/jit-cache", RTLD_LAZY, &info)) {
                    *(void **) &entry = dlsym(h, "zygisk_companion_entry");
                } else {
                    LOGW("Failed to dlopen zygisk module: %s\n", dlerror());
                }
            }
            modules.push_back(entry);
            close(fd);
        }
    }

    // ack
    write_int(socket, 0);

    // Start accepting requests
    pollfd pfd = { socket, POLLIN, 0 };
    for (;;) {
        poll(&pfd, 1, -1);
        if (pfd.revents && !(pfd.revents & POLLIN)) {
            // Something bad happened in magiskd, terminate zygiskd
            exit(0);
        }
        int client = recv_fd(socket);
        if (client < 0) {
            // Something bad happened in magiskd, terminate zygiskd
            exit(0);
        }
        int module_id = read_int(client);
        if (module_id >= 0 && module_id < modules.size() && modules[module_id]) {
            exec_companion_entry(client, modules[module_id]);
        } else {
            close(client);
        }
    }
}

// Entrypoint where we need to re-exec ourselves
// This should only ever be called internally
int zygisk_main(int argc, char *argv[]) {
    android_logging();
    if (argc == 3 && argv[1] == "companion"sv) {
        zygiskd(parse_int(argv[2]));
    }
    return 0;
}

// Entrypoint of code injection
extern "C" [[maybe_unused]] NativeBridgeCallbacks NativeBridgeItf {
    .version = 2,
    .padding = {},
    .isCompatibleWith = [](auto) {
        zygisk_logging();
        hook_entry();
        ZLOGD("load success\n");
        return false;
    },
};

```

`native/src/core/zygisk/gen_jni_hooks.py`:

```py
#!/usr/bin/env python3

primitives = ["jint", "jboolean", "jlong"]


class JType:
    def __init__(self, cpp: str, jni: str):
        self.cpp = cpp
        self.jni = jni


class JArray(JType):
    def __init__(self, type: JType):
        if type.cpp in primitives:
            name = type.cpp + "Array"
        else:
            name = "jobjectArray"
        super().__init__(name, "[" + type.jni)


class Argument:
    def __init__(self, name: str, type: JType, set_arg=False):
        self.name = name
        self.type = type
        self.set_arg = set_arg

    def cpp(self) -> str:
        return f"{self.type.cpp} {self.name}"


# Args we don't care, give it an auto generated name
class Anon(Argument):
    cnt = 0

    def __init__(self, type: JType):
        super().__init__(f"_{Anon.cnt}", type)
        Anon.cnt += 1


class Return:
    def __init__(self, value: str, type: JType):
        self.value = value
        self.type = type


class JNIMethod:
    def __init__(self, name: str, ret: Return, args: list[Argument]):
        self.name = name
        self.ret = ret
        self.args = args

    def arg_list_name(self) -> str:
        return "env, clazz, " + ", ".join(map(lambda x: x.name, self.args))

    def arg_list_cpp(self) -> str:
        return "JNIEnv *env, jclass clazz, " + ", ".join(
            map(lambda x: x.cpp(), self.args)
        )

    def cpp_fn_type(self) -> str:
        return f"{self.ret.type.cpp}(*)({self.arg_list_cpp()}"

    def cpp_lambda_sig(self) -> str:
        return f"[] [[clang::no_stack_protector]] ({self.arg_list_cpp()}) static -> {self.ret.type.cpp}"

    def jni_sig(self):
        args = "".join(map(lambda x: x.type.jni, self.args))
        return f"({args}){self.ret.type.jni}"


class JNIHook(JNIMethod):
    def __init__(self, ver: str, ret: Return, args: list[Argument]):
        name = f"{self.hook_target()}_{ver}"
        super().__init__(name, ret, args)

    def hook_target(self):
        return ""

    def body(self, orig_fn_ptr: str):
        return ""


def ind(i):
    return "\n" + "    " * i


# Common types
jint = JType("jint", "I")
jintArray = JArray(jint)
jstring = JType("jstring", "Ljava/lang/String;")
jboolean = JType("jboolean", "Z")
jlong = JType("jlong", "J")
void = JType("void", "V")


class ForkApp(JNIHook):
    def __init__(self, ver, args):
        super().__init__(ver, Return("ctx.pid", jint), args)

    def hook_target(self):
        return "nativeForkAndSpecialize"

    def init_args(self):
        return "AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);"

    def body(self, orig_fn_ptr: str):
        decl = ""
        decl += ind(3) + self.init_args()
        for a in self.args:
            if a.set_arg:
                decl += ind(3) + f"args.{a.name} = &{a.name};"
        decl += ind(3) + "ZygiskContext ctx(env, &args);"
        decl += ind(3) + f"ctx.{self.hook_target()}_pre();"
        decl += ind(3) + f"reinterpret_cast<{self.cpp_fn_type()})>({orig_fn_ptr})("
        decl += ind(4) + self.arg_list_name()
        decl += ind(3) + ");"
        decl += ind(3) + f"ctx.{self.hook_target()}_post();"
        if self.ret.value:
            decl += ind(3) + f"return {self.ret.value};"
        return decl


class SpecializeApp(ForkApp):
    def __init__(self, ver: str, args: list[Argument]):
        super().__init__(ver, args)
        self.ret = Return("", void)

    def hook_target(self):
        return "nativeSpecializeAppProcess"


class ForkServer(ForkApp):
    def hook_target(self):
        return "nativeForkSystemServer"

    def init_args(self):
        return "ServerSpecializeArgs_v1 args(uid, gid, gids, runtime_flags, permitted_capabilities, effective_capabilities);"


# Common args
uid = Argument("uid", jint)
gid = Argument("gid", jint)
gids = Argument("gids", jintArray)
runtime_flags = Argument("runtime_flags", jint)
rlimits = Argument("rlimits", JArray(jintArray))
mount_external = Argument("mount_external", jint)
se_info = Argument("se_info", jstring)
nice_name = Argument("nice_name", jstring)
fds_to_close = Argument("fds_to_close", jintArray)
instruction_set = Argument("instruction_set", jstring)
app_data_dir = Argument("app_data_dir", jstring)

# o
fds_to_ignore = Argument("fds_to_ignore", jintArray, True)

# p
is_child_zygote = Argument("is_child_zygote", jboolean, True)

# q_alt
is_top_app = Argument("is_top_app", jboolean, True)

# q running on xr
is_perception_app = Argument("is_perception_app", jboolean, False)

# r
pkg_data_info_list = Argument("pkg_data_info_list", JArray(jstring), True)
whitelisted_data_info_list = Argument(
    "whitelisted_data_info_list", JArray(jstring), True
)
mount_data_dirs = Argument("mount_data_dirs", jboolean, True)
mount_storage_dirs = Argument("mount_storage_dirs", jboolean, True)

# u qpr2
mount_sysprop_overrides = Argument("mount_sysprop_overrides", jboolean, True)

# b qpr2
use_fifo_ui = Argument("use_fifo_ui", jboolean, False)

# server
permitted_capabilities = Argument("permitted_capabilities", jlong)
effective_capabilities = Argument("effective_capabilities", jlong)

# Method definitions
fas_l = ForkApp(
    "l",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        fds_to_close,
        instruction_set,
        app_data_dir,
    ],
)

fas_o = ForkApp(
    "o",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        fds_to_close,
        fds_to_ignore,
        instruction_set,
        app_data_dir,
    ],
)

fas_p = ForkApp(
    "p",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        fds_to_close,
        fds_to_ignore,
        is_child_zygote,
        instruction_set,
        app_data_dir,
    ],
)

fas_q_alt = ForkApp(
    "q_alt",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        fds_to_close,
        fds_to_ignore,
        is_child_zygote,
        instruction_set,
        app_data_dir,
        is_top_app,
    ],
)

fas_r = ForkApp(
    "r",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        fds_to_close,
        fds_to_ignore,
        is_child_zygote,
        instruction_set,
        app_data_dir,
        is_top_app,
        pkg_data_info_list,
        whitelisted_data_info_list,
        mount_data_dirs,
        mount_storage_dirs,
    ],
)

fas_u = ForkApp(
    "u",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        fds_to_close,
        fds_to_ignore,
        is_child_zygote,
        instruction_set,
        app_data_dir,
        is_top_app,
        pkg_data_info_list,
        whitelisted_data_info_list,
        mount_data_dirs,
        mount_storage_dirs,
        mount_sysprop_overrides,
    ],
)

fas_b = ForkApp(
    "b",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        fds_to_close,
        fds_to_ignore,
        is_child_zygote,
        instruction_set,
        app_data_dir,
        is_top_app,
        use_fifo_ui,
        pkg_data_info_list,
        whitelisted_data_info_list,
        mount_data_dirs,
        mount_storage_dirs,
        mount_sysprop_overrides,
    ],
)

fas_samsung_m = ForkApp(
    "samsung_m",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        Anon(jint),
        Anon(jint),
        nice_name,
        fds_to_close,
        instruction_set,
        app_data_dir,
    ],
)

fas_samsung_n = ForkApp(
    "samsung_n",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        Anon(jint),
        Anon(jint),
        nice_name,
        fds_to_close,
        instruction_set,
        app_data_dir,
        Anon(jint),
    ],
)

fas_samsung_o = ForkApp(
    "samsung_o",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        Anon(jint),
        Anon(jint),
        nice_name,
        fds_to_close,
        fds_to_ignore,
        instruction_set,
        app_data_dir,
    ],
)

fas_samsung_p = ForkApp(
    "samsung_p",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        Anon(jint),
        Anon(jint),
        nice_name,
        fds_to_close,
        fds_to_ignore,
        is_child_zygote,
        instruction_set,
        app_data_dir,
    ],
)

fas_nubia_u = ForkApp(
    "nubia_u",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        fds_to_close,
        fds_to_ignore,
        is_child_zygote,
        instruction_set,
        app_data_dir,
        is_top_app,
        use_fifo_ui,
        pkg_data_info_list,
        whitelisted_data_info_list,
        mount_data_dirs,
        mount_storage_dirs,
        mount_sysprop_overrides,
        Anon(jstring),
    ],
)

spec_q = SpecializeApp(
    "q",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        is_child_zygote,
        instruction_set,
        app_data_dir,
    ],
)

spec_q_alt = SpecializeApp(
    "q_alt",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        is_child_zygote,
        instruction_set,
        app_data_dir,
        is_top_app,
    ],
)

spec_r = SpecializeApp(
    "r",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        is_child_zygote,
        instruction_set,
        app_data_dir,
        is_top_app,
        pkg_data_info_list,
        whitelisted_data_info_list,
        mount_data_dirs,
        mount_storage_dirs,
    ],
)

spec_u = SpecializeApp(
    "u",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        is_child_zygote,
        instruction_set,
        app_data_dir,
        is_top_app,
        pkg_data_info_list,
        whitelisted_data_info_list,
        mount_data_dirs,
        mount_storage_dirs,
        mount_sysprop_overrides,
    ],
)

spec_xr_u = SpecializeApp(
    "xr_u",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        is_child_zygote,
        instruction_set,
        app_data_dir,
        is_top_app,
        is_perception_app,
        pkg_data_info_list,
        whitelisted_data_info_list,
        mount_data_dirs,
        mount_storage_dirs,
    ],
)

spec_samsung_q = SpecializeApp(
    "samsung_q",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        Anon(jint),
        Anon(jint),
        nice_name,
        is_child_zygote,
        instruction_set,
        app_data_dir,
    ],
)

spec_nubia_u = SpecializeApp(
    "nubia_u",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        mount_external,
        se_info,
        nice_name,
        is_child_zygote,
        instruction_set,
        app_data_dir,
        is_top_app,
        pkg_data_info_list,
        whitelisted_data_info_list,
        mount_data_dirs,
        mount_storage_dirs,
        mount_sysprop_overrides,
        Anon(jstring),
    ],
)

server_l = ForkServer(
    "l",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        rlimits,
        permitted_capabilities,
        effective_capabilities,
    ],
)

server_samsung_q = ForkServer(
    "samsung_q",
    [
        uid,
        gid,
        gids,
        runtime_flags,
        Anon(jint),
        Anon(jint),
        rlimits,
        permitted_capabilities,
        effective_capabilities,
    ],
)


def gen_jni_def(field: str, methods: list[JNIHook]):
    decl = ""
    decl += ind(0) + f"std::array<JNINativeMethod, {len(methods)}> {field} = {{{{"
    for i, m in enumerate(methods):
        decl += ind(1) + f"// {m.name}"
        decl += ind(1) + "{"
        decl += ind(2) + f'"{m.hook_target()}",'
        decl += ind(2) + f'"{m.jni_sig()}",'
        decl += ind(2) + f"(void *) +{m.cpp_lambda_sig()} {{"
        orig_fn_ptr = f"get_defs()->{field}[{i}].fnPtr"
        decl += m.body(orig_fn_ptr)
        decl += ind(2) + "}"
        decl += ind(1) + "},"
    decl += ind(0) + "}};"
    decl += ind(0)

    return decl


with open("jni_hooks.hpp", "w") as f:
    f.write("// Generated by gen_jni_hooks.py\n")
    f.write("#pragma once\n\n")
    f.write("struct JniHookDefinitions;\n")
    f.write("static JniHookDefinitions *get_defs();\n\n")
    f.write("struct JniHookDefinitions {\n")
    f.write(
        gen_jni_def(
            "fork_app_methods",
            [
                fas_l,
                fas_o,
                fas_p,
                fas_q_alt,
                fas_r,
                fas_u,
                fas_b,
                fas_samsung_m,
                fas_samsung_n,
                fas_samsung_o,
                fas_samsung_p,
                fas_nubia_u,
            ],
        )
    )

    f.write(
        gen_jni_def(
            "specialize_app_methods",
            [spec_q, spec_q_alt, spec_r, spec_u, spec_xr_u, spec_samsung_q, spec_nubia_u],
        )
    )

    f.write(gen_jni_def("fork_server_methods", [server_l, server_samsung_q]))

    f.write("\n};\n")

```

`native/src/core/zygisk/hook.cpp`:

```cpp
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/resource.h>
#include <dlfcn.h>
#include <unwind.h>
#include <span>

#include <lsplt.hpp>

#include <base.hpp>

#include "zygisk.hpp"
#include "module.hpp"
#include "jni_hooks.hpp"

using namespace std;

// *********************
// Zygisk Bootstrapping
// *********************
//
// Zygisk's lifecycle is driven by several PLT function hooks in libandroid_runtime, libart, and
// libnative_bridge. As Zygote is starting up, these carefully selected functions will call into
// the respective lifecycle callbacks in Zygisk to drive the progress forward.
//
// The entire bootstrap process is shown in the graph below.
// Arrows represent control flow, and the blocks are sorted chronologically from top to bottom.
//
// libnative_bridge       libandroid_runtime                zygisk                 libart
//
//                            ┌───────┐
//                            │ start │
//                            └───┬─┬─┘
//                                │ │                                         ┌────────────────┐
//                                │ └────────────────────────────────────────►│LoadNativeBridge│
//                                │                                           └───────┬────────┘
// ┌────────────────┐             │                                                   │
// │LoadNativeBridge│◄────────────┼───────────────────────────────────────────────────┘
// └───────┬────┬───┘             │
//         │    │                 │                     ┌───────────────┐
//         │    └─────────────────┼────────────────────►│NativeBridgeItf│
//         │                      │                     └──────┬────────┘
//         │                      │                            │
//         │                      │                            ▼
//         │                      │                        ┌────────┐
//         │                      │                        │hook_plt│
//         ▼                      │                        └────────┘
//     ┌───────┐                  │
//     │dlclose│                  │
//     └───┬───┘                  │
//         │                      │
//         │                      │                 ┌───────────────────────┐
//         └──────────────────────┼────────────────►│post_native_bridge_load│
//                                │                 └───────────────────────┘
//                                ▼
//                    ┌──────────────────────┐
//                    │ strdup("ZygoteInit") │
//                    └───────────┬────┬─────┘
//                                │    │                ┌───────────────┐
//                                │    └───────────────►│hook_zygote_jni│
//                                │                     └───────────────┘       ┌─────────┐
//                                │                                             │         │
//                                └────────────────────────────────────────────►│   JVM   │
//                                                                              │         │
//                                                                              └──┬─┬────┘
//                      ┌───────────────────┐                                      │ │
//                      │nativeXXXSpecialize│◄─────────────────────────────────────┘ │
//                      └─────────────┬─────┘                                        │
//                                    │                 ┌─────────────┐              │
//                                    └────────────────►│ZygiskContext│              │
//                                                      └─────────────┘              ▼
//                                                                         ┌────────────────────┐
//                                                                         │pthread_attr_destroy│
//                                                                         └─────────┬──────────┘
//                                                     ┌────────────────┐            │
//                                                     │restore_plt_hook│◄───────────┘
//                                                     └────────────────┘
//
// Some notes regarding the important functions/symbols during bootstrap:
//
// * NativeBridgeItf: this symbol is the entry point for android::LoadNativeBridge
// * HookContext::hook_plt(): hook functions like |dlclose| and |strdup|
// * dlclose: the final step in android::LoadNativeBridge. In this function, we unwind the call
//   stack to load the real native bridge if necessary, and fetch NativeBridgeRuntimeCallbacks.
// * strdup: called in AndroidRuntime::start before calling ZygoteInit#main(...)
// * HookContext::hook_zygote_jni(): replace the process specialization functions registered
//   with register_jni_procs. This marks the final step of the code injection bootstrap process.
// * pthread_attr_destroy: called whenever the JVM tries to setup threads for itself. We use
//   this method to cleanup and unload Zygisk from the process.

constexpr const char *kZygoteInit = "com.android.internal.os.ZygoteInit";
constexpr const char *kZygote = "com/android/internal/os/Zygote";
constexpr const char *kForkApp = "nativeForkAndSpecialize";
constexpr const char *kSpecializeApp = "nativeSpecializeAppProcess";
constexpr const char *kForkServer = "nativeForkSystemServer";

using JNIMethods = std::span<JNINativeMethod>;
using JNIMethodsDyn = std::pair<unique_ptr<JNINativeMethod[]>, size_t>;

struct HookContext : JniHookDefinitions {

    vector<tuple<dev_t, ino_t, const char *, void **>> plt_backup;
    const NativeBridgeRuntimeCallbacks *runtime_callbacks = nullptr;
    void *self_handle = nullptr;
    bool should_unmap = false;

    void hook_plt();
    void hook_unloader();
    void restore_plt_hook();
    void hook_zygote_jni();
    void restore_zygote_hook(JNIEnv *env);
    void hook_jni_methods(JNIEnv *env, const char *clz, JNIMethods methods) const;
    void post_native_bridge_load(void *handle);

private:
    void register_hook(dev_t dev, ino_t inode, const char *symbol, void *new_func, void **old_func);
    int hook_jni_methods(JNIEnv *env, jclass clazz, JNIMethods methods) const;
    JNIMethodsDyn get_jni_methods(JNIEnv *env, jclass clazz) const;
};

// -----------------------------------------------------------------

// Global contexts:
//
// HookContext lives as long as Zygisk is loaded in memory. It tracks the process's function
// hooking state and bootstraps code injection until we replace the process specialization methods.
//
// ZygiskContext lives during the process specialization process. It implements Zygisk
// features, such as loading modules and customizing process fork/specialization.

ZygiskContext *g_ctx;
static HookContext *g_hook;

static JniHookDefinitions *get_defs() {
    return g_hook;
}

// -----------------------------------------------------------------

#define DCL_HOOK_FUNC(ret, func, ...) \
ret (*old_##func)(__VA_ARGS__);       \
ret new_##func(__VA_ARGS__)

DCL_HOOK_FUNC(static char *, strdup, const char * str) {
    if (strcmp(kZygoteInit, str) == 0) {
        g_hook->hook_zygote_jni();
    }
    return old_strdup(str);
}

// Skip actual fork and return cached result if applicable
DCL_HOOK_FUNC(int, fork) {
    return (g_ctx && g_ctx->pid >= 0) ? g_ctx->pid : old_fork();
}

// Unmount stuffs in the process's private mount namespace
DCL_HOOK_FUNC(static int, unshare, int flags) {
    int res = old_unshare(flags);
    if (g_ctx && (flags & CLONE_NEWNS) != 0 && res == 0) {
        if (g_ctx->flags & DO_REVERT_UNMOUNT) {
            revert_unmount();
        }
        // Restore errno back to 0
        errno = 0;
    }
    return res;
}

// This is the last moment before the secontext of the process changes
DCL_HOOK_FUNC(static int, selinux_android_setcontext,
              uid_t uid, bool isSystemServer, const char *seinfo, const char *pkgname) {
    // Pre-fetch logd before secontext transition
    zygisk_get_logd();
    return old_selinux_android_setcontext(uid, isSystemServer, seinfo, pkgname);
}

// Close file descriptors to prevent crashing
DCL_HOOK_FUNC(static void, android_log_close) {
    if (g_ctx == nullptr || !(g_ctx->flags & SKIP_CLOSE_LOG_PIPE)) {
        // This happens during forks like nativeForkApp, nativeForkUsap,
        // nativeForkSystemServer, and nativeForkAndSpecialize.
        zygisk_close_logd();
    }
    old_android_log_close();
}

// It should be safe to assume all dlclose's in libnativebridge are for zygisk_loader
DCL_HOOK_FUNC(static int, dlclose, void *handle) {
    if (!g_hook->self_handle) {
        ZLOGV("dlclose zygisk_loader\n");
        g_hook->post_native_bridge_load(handle);
    }
    return 0;
}

// We cannot directly call `dlclose` to unload ourselves, otherwise when `dlclose` returns,
// it will return to our code which has been unmapped, causing segmentation fault.
// Instead, we hook `pthread_attr_destroy` which will be called when VM daemon threads start.
DCL_HOOK_FUNC(static int, pthread_attr_destroy, void *target) {
    int res = old_pthread_attr_destroy((pthread_attr_t *)target);

    // Only perform unloading on the main thread
    if (gettid() != getpid())
        return res;

    ZLOGV("pthread_attr_destroy\n");
    if (g_hook->should_unmap) {
        g_hook->restore_plt_hook();
        if (g_hook->should_unmap) {
            ZLOGV("dlclosing self\n");
            void *self_handle = g_hook->self_handle;
            delete g_hook;

            // Because both `pthread_attr_destroy` and `dlclose` have the same function signature,
            // we can use `musttail` to let the compiler reuse our stack frame and thus
            // `dlclose` will directly return to the caller of `pthread_attr_destroy`.
            [[clang::musttail]] return dlclose(self_handle);
        }
    }

    delete g_hook;
    return res;
}

#undef DCL_HOOK_FUNC

// -----------------------------------------------------------------

static size_t get_fd_max() {
    rlimit r{32768, 32768};
    getrlimit(RLIMIT_NOFILE, &r);
    return r.rlim_max;
}

ZygiskContext::ZygiskContext(JNIEnv *env, void *args) :
    env(env), args{args}, process(nullptr), pid(-1), flags(0), info_flags(0),
    allowed_fds(get_fd_max()), hook_info_lock(PTHREAD_MUTEX_INITIALIZER) { g_ctx = this; }

ZygiskContext::~ZygiskContext() {
    // This global pointer points to a variable on the stack.
    // Set this to nullptr to prevent leaking local variable.
    // This also disables most plt hooked functions.
    g_ctx = nullptr;

    if (!is_child())
        return;

    zygisk_close_logd();
    android_logging();

    // Strip out all API function pointers
    for (auto &m : modules) {
        m.clearApi();
    }

    // Cleanup
    g_hook->should_unmap = true;
    g_hook->restore_zygote_hook(env);
    g_hook->hook_unloader();
}

// -----------------------------------------------------------------

inline void *unwind_get_region_start(_Unwind_Context *ctx) {
    auto fp = _Unwind_GetRegionStart(ctx);
#if defined(__arm__)
    // On arm32, we need to check if the pc is in thumb mode,
    // if so, we need to set the lowest bit of fp to 1
    auto pc = _Unwind_GetGR(ctx, 15); // r15 is pc
    if (pc & 1) {
        // Thumb mode
        fp |= 1;
    }
#endif
    return reinterpret_cast<void *>(fp);
}

// As we use NativeBridgeRuntimeCallbacks to reload native bridge and to hook jni functions,
// we need to find it by the native bridge's unwind context.
// For abis that use registers to pass arguments, i.e. arm32, arm64, x86_64, the registers are
// caller-saved, and they are not preserved in the unwind context. However, they will be saved
// into the callee-saved registers, so we will search the callee-saved registers for the second
// argument, which is the pointer to NativeBridgeRuntimeCallbacks.
// For x86, whose abi uses stack to pass arguments, we can directly get the pointer to
// NativeBridgeRuntimeCallbacks from the stack.
static const NativeBridgeRuntimeCallbacks* find_runtime_callbacks(struct _Unwind_Context *ctx) {
    // Find the writable memory region of libart.so, where the NativeBridgeRuntimeCallbacks is located.
    auto [start, end] = []()-> tuple<uintptr_t, uintptr_t> {
        for (const auto &map : lsplt::MapInfo::Scan()) {
            if (map.path.ends_with("/libart.so") && map.perms == (PROT_WRITE | PROT_READ)) {
                ZLOGV("libart.so: start=%p, end=%p\n",
                      reinterpret_cast<void *>(map.start), reinterpret_cast<void *>(map.end));
                return {map.start, map.end};
            }
        }
        return {0, 0};
    }();
#if defined(__aarch64__)
    // r19-r28 are callee-saved registers
    for (int i = 19; i <= 28; ++i) {
        auto val = static_cast<uintptr_t>(_Unwind_GetGR(ctx, i));
        ZLOGV("r%d = %p\n", i, reinterpret_cast<void *>(val));
        if (val >= start && val < end)
            return reinterpret_cast<const NativeBridgeRuntimeCallbacks*>(val);
    }
#elif defined(__arm__)
    // r4-r10 are callee-saved registers
    for (int i = 4; i <= 10; ++i) {
        auto val = static_cast<uintptr_t>(_Unwind_GetGR(ctx, i));
        ZLOGV("r%d = %p\n", i, reinterpret_cast<void *>(val));
        if (val >= start && val < end)
            return reinterpret_cast<const NativeBridgeRuntimeCallbacks*>(val);
    }
#elif defined(__i386__)
    // get ebp, which points to the bottom of the stack frame
    auto ebp = static_cast<uintptr_t>(_Unwind_GetGR(ctx, 5));
    // 1 pointer size above ebp is the old ebp
    // 2 pointer sizes above ebp is the return address
    // 3 pointer sizes above ebp is the 2nd arg
    auto val = *reinterpret_cast<uintptr_t *>(ebp + 3 * sizeof(void *));
    ZLOGV("ebp + 3 * ptr_size = %p\n", reinterpret_cast<void *>(val));
    if (val >= start && val < end)
        return reinterpret_cast<const NativeBridgeRuntimeCallbacks*>(val);
#elif defined(__x86_64__)
    // r12-r15 and rbx are callee-saved registers, but the compiler is likely to use them reversely
    for (int i : {3, 15, 14, 13, 12}) {
        auto val = static_cast<uintptr_t>(_Unwind_GetGR(ctx, i));
        ZLOGV("r%d = %p\n", i, reinterpret_cast<void *>(val));
        if (val >= start && val < end)
            return reinterpret_cast<const NativeBridgeRuntimeCallbacks*>(val);
    }
#elif defined(__riscv)
    // x8-x9, x18-x27 callee-saved registers
    for (int i : {8, 9, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27}) {
        auto val = static_cast<uintptr_t>(_Unwind_GetGR(ctx, i));
        ZLOGV("x%d = %p\n", i, reinterpret_cast<void *>(val));
        if (val >= start && val < end)
            return reinterpret_cast<const NativeBridgeRuntimeCallbacks*>(val);
    }
#else
#error "Unsupported architecture"
#endif
    return nullptr;
}

void HookContext::post_native_bridge_load(void *handle) {
    self_handle = handle;
    using method_sig = const bool (*)(const char *, const NativeBridgeRuntimeCallbacks *);
    struct trace_arg {
        method_sig load_native_bridge;
        const NativeBridgeRuntimeCallbacks *callbacks;
    };
    trace_arg arg{};

    // Unwind to find the address of android::LoadNativeBridge and NativeBridgeRuntimeCallbacks
    _Unwind_Backtrace(+[](_Unwind_Context *ctx, void *arg) -> _Unwind_Reason_Code {
        void *fp = unwind_get_region_start(ctx);
        Dl_info info{};
        dladdr(fp, &info);
        ZLOGV("backtrace: %p %s\n", fp, info.dli_fname ?: "???");
        if (info.dli_fname && std::string_view(info.dli_fname).ends_with("/libnativebridge.so")) {
            auto payload = reinterpret_cast<trace_arg *>(arg);
            payload->load_native_bridge = reinterpret_cast<method_sig>(fp);
            payload->callbacks = find_runtime_callbacks(ctx);
            ZLOGV("NativeBridgeRuntimeCallbacks: %p\n", payload->callbacks);
            return _URC_END_OF_STACK;
        }
        return _URC_NO_REASON;
    }, &arg);

    if (!arg.load_native_bridge || !arg.callbacks)
        return;

    // Reload the real native bridge if necessary
    auto nb = get_prop(NBPROP);
    auto len = sizeof(ZYGISKLDR) - 1;
    if (nb.size() > len) {
        arg.load_native_bridge(nb.c_str() + len, arg.callbacks);
    }
    runtime_callbacks = arg.callbacks;
}

// -----------------------------------------------------------------

void HookContext::register_hook(
        dev_t dev, ino_t inode, const char *symbol, void *new_func, void **old_func) {
    if (!lsplt::RegisterHook(dev, inode, symbol, new_func, old_func)) {
        ZLOGE("Failed to register plt_hook \"%s\"\n", symbol);
        return;
    }
    plt_backup.emplace_back(dev, inode, symbol, old_func);
}

#define PLT_HOOK_REGISTER_SYM(DEV, INODE, SYM, NAME) \
    register_hook(DEV, INODE, SYM, \
    reinterpret_cast<void *>(new_##NAME), reinterpret_cast<void **>(&old_##NAME))

#define PLT_HOOK_REGISTER(DEV, INODE, NAME) \
    PLT_HOOK_REGISTER_SYM(DEV, INODE, #NAME, NAME)

void HookContext::hook_plt() {
    ino_t android_runtime_inode = 0;
    dev_t android_runtime_dev = 0;
    ino_t native_bridge_inode = 0;
    dev_t native_bridge_dev = 0;

    for (auto &map : lsplt::MapInfo::Scan()) {
        if (map.path.ends_with("/libandroid_runtime.so")) {
            android_runtime_inode = map.inode;
            android_runtime_dev = map.dev;
        } else if (map.path.ends_with("/libnativebridge.so")) {
            native_bridge_inode = map.inode;
            native_bridge_dev = map.dev;
        }
    }

    PLT_HOOK_REGISTER(native_bridge_dev, native_bridge_inode, dlclose);
    PLT_HOOK_REGISTER(android_runtime_dev, android_runtime_inode, fork);
    PLT_HOOK_REGISTER(android_runtime_dev, android_runtime_inode, unshare);
    PLT_HOOK_REGISTER(android_runtime_dev, android_runtime_inode, selinux_android_setcontext);
    PLT_HOOK_REGISTER(android_runtime_dev, android_runtime_inode, strdup);
    PLT_HOOK_REGISTER_SYM(android_runtime_dev, android_runtime_inode, "__android_log_close", android_log_close);

    if (!lsplt::CommitHook())
        ZLOGE("plt_hook failed\n");

    // Remove unhooked methods
    std::erase_if(plt_backup, [](auto &t) { return *std::get<3>(t) == nullptr; });
}

void HookContext::hook_unloader() {
    ino_t art_inode = 0;
    dev_t art_dev = 0;

    for (auto &map : lsplt::MapInfo::Scan()) {
        if (map.path.ends_with("/libart.so")) {
            art_inode = map.inode;
            art_dev = map.dev;
            break;
        }
    }

    PLT_HOOK_REGISTER(art_dev, art_inode, pthread_attr_destroy);
    if (!lsplt::CommitHook())
        ZLOGE("plt_hook failed\n");
}

void HookContext::restore_plt_hook() {
    // Unhook plt_hook
    for (const auto &[dev, inode, sym, old_func] : plt_backup) {
        if (!lsplt::RegisterHook(dev, inode, sym, *old_func, nullptr)) {
            ZLOGE("Failed to register plt_hook [%s]\n", sym);
            should_unmap = false;
        }
    }
    if (!lsplt::CommitHook()) {
        ZLOGE("Failed to restore plt_hook\n");
        should_unmap = false;
    }
}

// -----------------------------------------------------------------

JNIMethodsDyn HookContext::get_jni_methods(JNIEnv *env, jclass clazz) const {
    size_t total = runtime_callbacks->getNativeMethodCount(env, clazz);
    auto methods = std::make_unique_for_overwrite<JNINativeMethod[]>(total);
    runtime_callbacks->getNativeMethods(env, clazz, methods.get(), total);
    return std::make_pair(std::move(methods), total);
}

static void register_jni_methods(JNIEnv *env, jclass clazz, JNIMethods methods) {
    for (auto &method : methods) {
        // It's useful to allow nullptr function pointer for restoring hook
        if (!method.fnPtr) continue;

        // It's normal that the method is not found
        if (env->RegisterNatives(clazz, &method, 1) == JNI_ERR || env->ExceptionCheck() == JNI_TRUE) {
            env->ExceptionClear();
            method.fnPtr = nullptr;
        }
    }
}

int HookContext::hook_jni_methods(JNIEnv *env, jclass clazz, JNIMethods methods) const {
    // Backup existing methods
    auto o = get_jni_methods(env, clazz);
    const auto old_methods = span(o.first.get(), o.second);

    // WARNING: the signature field returned from getNativeMethods is in a non-standard format.
    // DO NOT TRY TO USE IT. This is the reason why we try to call RegisterNatives on every single
    // provided JNI methods directly to be 100% sure about whether a signature matches or not.

    // Replace methods
    register_jni_methods(env, clazz, methods);

    // Fetch the new set of native methods
    auto n = get_jni_methods(env, clazz);
    const auto new_methods = span(n.first.get(), n.second);

    // Find the old function pointer and return to caller
    int hook_count = 0;
    for (auto &method : methods) {
        if (!method.fnPtr) continue;
        for (const auto &new_method : new_methods) {
            if (new_method.fnPtr == method.fnPtr) {
                for (const auto &old_method : old_methods) {
                    if (strcmp(old_method.name, new_method.name) == 0 &&
                        strcmp(old_method.signature, new_method.signature) == 0) {
                        ZLOGV("replace %s %s %p -> %p\n",
                            method.name, method.signature, old_method.fnPtr, method.fnPtr);
                        method.fnPtr = old_method.fnPtr;
                        ++hook_count;
                        // Break 2 levels of for loop
                        goto next_method;
                    }
                }
            }
        }
        next_method:
    }
    return hook_count;
}


void HookContext::hook_jni_methods(JNIEnv *env, const char *clz, JNIMethods methods) const {
    jclass clazz;
    if (!runtime_callbacks || !env || !clz || !((clazz = env->FindClass(clz)))) {
        ranges::for_each(methods, [](auto &m) { m.fnPtr = nullptr; });
        return;
    }
    hook_jni_methods(env, clazz, methods);
}

void HookContext::hook_zygote_jni() {
    using method_sig = jint(*)(JavaVM **, jsize, jsize *);
    auto get_created_vms = reinterpret_cast<method_sig>(
            dlsym(RTLD_DEFAULT, "JNI_GetCreatedJavaVMs"));
    if (!get_created_vms) {
        for (auto &map: lsplt::MapInfo::Scan()) {
            if (!map.path.ends_with("/libnativehelper.so")) continue;
            void *h = dlopen(map.path.data(), RTLD_LAZY);
            if (!h) {
                ZLOGW("Cannot dlopen libnativehelper.so: %s\n", dlerror());
                break;
            }
            get_created_vms = reinterpret_cast<method_sig>(dlsym(h, "JNI_GetCreatedJavaVMs"));
            dlclose(h);
            break;
        }
        if (!get_created_vms) {
            ZLOGW("JNI_GetCreatedJavaVMs not found\n");
            return;
        }
    }

    JavaVM *vm = nullptr;
    jsize num = 0;
    jint res = get_created_vms(&vm, 1, &num);
    if (res != JNI_OK || vm == nullptr) {
        ZLOGW("JavaVM not found\n");
        return;
    }
    JNIEnv *env = nullptr;
    res = vm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_6);
    if (res != JNI_OK || env == nullptr) {
        ZLOGW("JNIEnv not found\n");
    }

    JNINativeMethod missing_method{};
    bool replaced_fork_app = false;
    bool replaced_specialize_app = false;
    bool replaced_fork_server = false;

    jclass clazz = env->FindClass(kZygote);
    auto [ptr, count] = get_jni_methods(env, clazz);
    for (const auto methods = span(ptr.get(), count); const auto &method : methods) {
        if (strcmp(method.name, kForkApp) == 0) {
            if (hook_jni_methods(env, clazz, fork_app_methods) == 0) {
                missing_method = method;
                break;
            }
            replaced_fork_app = true;
        } else if (strcmp(method.name, kSpecializeApp) == 0) {
            if (hook_jni_methods(env, clazz, specialize_app_methods) == 0) {
                missing_method = method;
                break;
            }
            replaced_specialize_app = true;
        } else if (strcmp(method.name, kForkServer) == 0) {
            if (hook_jni_methods(env, clazz, fork_server_methods) == 0) {
                missing_method = method;
                break;
            }
            replaced_fork_server = true;
        }
    }

    if (missing_method.name != nullptr) {
        ZLOGE("Cannot hook method: %s %s\n", missing_method.name, missing_method.signature);
        // Restore methods that were already replaced
        if (replaced_fork_app) register_jni_methods(env, clazz, fork_app_methods);
        if (replaced_specialize_app) register_jni_methods(env, clazz, specialize_app_methods);
        if (replaced_fork_server) register_jni_methods(env, clazz, fork_server_methods);
        // Clear the method lists just in case
        ranges::for_each(fork_app_methods, [](auto &m) { m.fnPtr = nullptr; });
        ranges::for_each(specialize_app_methods, [](auto &m) { m.fnPtr = nullptr; });
        ranges::for_each(fork_server_methods, [](auto &m) { m.fnPtr = nullptr; });
    }
}

void HookContext::restore_zygote_hook(JNIEnv *env) {
    jclass clazz = env->FindClass(kZygote);
    register_jni_methods(env, clazz, fork_app_methods);
    register_jni_methods(env, clazz, specialize_app_methods);
    register_jni_methods(env, clazz, fork_server_methods);
}

// -----------------------------------------------------------------

void hook_entry() {
    default_new(g_hook);
    g_hook->hook_plt();
}

void hookJniNativeMethods(JNIEnv *env, const char *clz, JNINativeMethod *methods, int numMethods) {
    g_hook->hook_jni_methods(env, clz, { methods, static_cast<size_t>(numMethods) });
}

```

`native/src/core/zygisk/jni_hooks.hpp`:

```hpp
// Generated by gen_jni_hooks.py
#pragma once

struct JniHookDefinitions;
static JniHookDefinitions *get_defs();

struct JniHookDefinitions {

std::array<JNINativeMethod, 12> fork_app_methods = {{
    // nativeForkAndSpecialize_l
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;[ILjava/lang/String;Ljava/lang/String;)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jstring instruction_set, jstring app_data_dir) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jstring instruction_set, jstring app_data_dir)>(get_defs()->fork_app_methods[0].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, instruction_set, app_data_dir
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
    // nativeForkAndSpecialize_o
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[ILjava/lang/String;Ljava/lang/String;)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jstring instruction_set, jstring app_data_dir) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.fds_to_ignore = &fds_to_ignore;
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jstring instruction_set, jstring app_data_dir)>(get_defs()->fork_app_methods[1].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, instruction_set, app_data_dir
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
    // nativeForkAndSpecialize_p
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.fds_to_ignore = &fds_to_ignore;
            args.is_child_zygote = &is_child_zygote;
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir)>(get_defs()->fork_app_methods[2].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
    // nativeForkAndSpecialize_q_alt
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;Z)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.fds_to_ignore = &fds_to_ignore;
            args.is_child_zygote = &is_child_zygote;
            args.is_top_app = &is_top_app;
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app)>(get_defs()->fork_app_methods[3].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
    // nativeForkAndSpecialize_r
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;[Ljava/lang/String;ZZ)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.fds_to_ignore = &fds_to_ignore;
            args.is_child_zygote = &is_child_zygote;
            args.is_top_app = &is_top_app;
            args.pkg_data_info_list = &pkg_data_info_list;
            args.whitelisted_data_info_list = &whitelisted_data_info_list;
            args.mount_data_dirs = &mount_data_dirs;
            args.mount_storage_dirs = &mount_storage_dirs;
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs)>(get_defs()->fork_app_methods[4].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
    // nativeForkAndSpecialize_u
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;[Ljava/lang/String;ZZZ)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.fds_to_ignore = &fds_to_ignore;
            args.is_child_zygote = &is_child_zygote;
            args.is_top_app = &is_top_app;
            args.pkg_data_info_list = &pkg_data_info_list;
            args.whitelisted_data_info_list = &whitelisted_data_info_list;
            args.mount_data_dirs = &mount_data_dirs;
            args.mount_storage_dirs = &mount_storage_dirs;
            args.mount_sysprop_overrides = &mount_sysprop_overrides;
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides)>(get_defs()->fork_app_methods[5].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
    // nativeForkAndSpecialize_b
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;ZZ[Ljava/lang/String;[Ljava/lang/String;ZZZ)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jboolean use_fifo_ui, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.fds_to_ignore = &fds_to_ignore;
            args.is_child_zygote = &is_child_zygote;
            args.is_top_app = &is_top_app;
            args.pkg_data_info_list = &pkg_data_info_list;
            args.whitelisted_data_info_list = &whitelisted_data_info_list;
            args.mount_data_dirs = &mount_data_dirs;
            args.mount_storage_dirs = &mount_storage_dirs;
            args.mount_sysprop_overrides = &mount_sysprop_overrides;
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jboolean use_fifo_ui, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides)>(get_defs()->fork_app_methods[6].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app, use_fifo_ui, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
    // nativeForkAndSpecialize_samsung_m
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;IILjava/lang/String;[ILjava/lang/String;Ljava/lang/String;)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _0, jint _1, jstring nice_name, jintArray fds_to_close, jstring instruction_set, jstring app_data_dir) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _0, jint _1, jstring nice_name, jintArray fds_to_close, jstring instruction_set, jstring app_data_dir)>(get_defs()->fork_app_methods[7].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, _0, _1, nice_name, fds_to_close, instruction_set, app_data_dir
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
    // nativeForkAndSpecialize_samsung_n
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;IILjava/lang/String;[ILjava/lang/String;Ljava/lang/String;I)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _2, jint _3, jstring nice_name, jintArray fds_to_close, jstring instruction_set, jstring app_data_dir, jint _4) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _2, jint _3, jstring nice_name, jintArray fds_to_close, jstring instruction_set, jstring app_data_dir, jint _4)>(get_defs()->fork_app_methods[8].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, _2, _3, nice_name, fds_to_close, instruction_set, app_data_dir, _4
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
    // nativeForkAndSpecialize_samsung_o
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;IILjava/lang/String;[I[ILjava/lang/String;Ljava/lang/String;)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _5, jint _6, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jstring instruction_set, jstring app_data_dir) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.fds_to_ignore = &fds_to_ignore;
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _5, jint _6, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jstring instruction_set, jstring app_data_dir)>(get_defs()->fork_app_methods[9].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, _5, _6, nice_name, fds_to_close, fds_to_ignore, instruction_set, app_data_dir
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
    // nativeForkAndSpecialize_samsung_p
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;IILjava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _7, jint _8, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.fds_to_ignore = &fds_to_ignore;
            args.is_child_zygote = &is_child_zygote;
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _7, jint _8, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir)>(get_defs()->fork_app_methods[10].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, _7, _8, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
    // nativeForkAndSpecialize_nubia_u
    {
        "nativeForkAndSpecialize",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;ZZ[Ljava/lang/String;[Ljava/lang/String;ZZZLjava/lang/String;)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jboolean use_fifo_ui, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides, jstring _9) static -> jint {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.fds_to_ignore = &fds_to_ignore;
            args.is_child_zygote = &is_child_zygote;
            args.is_top_app = &is_top_app;
            args.pkg_data_info_list = &pkg_data_info_list;
            args.whitelisted_data_info_list = &whitelisted_data_info_list;
            args.mount_data_dirs = &mount_data_dirs;
            args.mount_storage_dirs = &mount_storage_dirs;
            args.mount_sysprop_overrides = &mount_sysprop_overrides;
            ZygiskContext ctx(env, &args);
            ctx.nativeForkAndSpecialize_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jboolean use_fifo_ui, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides, jstring _9)>(get_defs()->fork_app_methods[11].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app, use_fifo_ui, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides, _9
            );
            ctx.nativeForkAndSpecialize_post();
            return ctx.pid;
        }
    },
}};

std::array<JNINativeMethod, 7> specialize_app_methods = {{
    // nativeSpecializeAppProcess_q
    {
        "nativeSpecializeAppProcess",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;)V",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir) static -> void {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.is_child_zygote = &is_child_zygote;
            ZygiskContext ctx(env, &args);
            ctx.nativeSpecializeAppProcess_pre();
            reinterpret_cast<void(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir)>(get_defs()->specialize_app_methods[0].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, is_child_zygote, instruction_set, app_data_dir
            );
            ctx.nativeSpecializeAppProcess_post();
        }
    },
    // nativeSpecializeAppProcess_q_alt
    {
        "nativeSpecializeAppProcess",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Z)V",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app) static -> void {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.is_child_zygote = &is_child_zygote;
            args.is_top_app = &is_top_app;
            ZygiskContext ctx(env, &args);
            ctx.nativeSpecializeAppProcess_pre();
            reinterpret_cast<void(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app)>(get_defs()->specialize_app_methods[1].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, is_child_zygote, instruction_set, app_data_dir, is_top_app
            );
            ctx.nativeSpecializeAppProcess_post();
        }
    },
    // nativeSpecializeAppProcess_r
    {
        "nativeSpecializeAppProcess",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;[Ljava/lang/String;ZZ)V",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs) static -> void {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.is_child_zygote = &is_child_zygote;
            args.is_top_app = &is_top_app;
            args.pkg_data_info_list = &pkg_data_info_list;
            args.whitelisted_data_info_list = &whitelisted_data_info_list;
            args.mount_data_dirs = &mount_data_dirs;
            args.mount_storage_dirs = &mount_storage_dirs;
            ZygiskContext ctx(env, &args);
            ctx.nativeSpecializeAppProcess_pre();
            reinterpret_cast<void(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs)>(get_defs()->specialize_app_methods[2].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs
            );
            ctx.nativeSpecializeAppProcess_post();
        }
    },
    // nativeSpecializeAppProcess_u
    {
        "nativeSpecializeAppProcess",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;[Ljava/lang/String;ZZZ)V",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides) static -> void {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.is_child_zygote = &is_child_zygote;
            args.is_top_app = &is_top_app;
            args.pkg_data_info_list = &pkg_data_info_list;
            args.whitelisted_data_info_list = &whitelisted_data_info_list;
            args.mount_data_dirs = &mount_data_dirs;
            args.mount_storage_dirs = &mount_storage_dirs;
            args.mount_sysprop_overrides = &mount_sysprop_overrides;
            ZygiskContext ctx(env, &args);
            ctx.nativeSpecializeAppProcess_pre();
            reinterpret_cast<void(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides)>(get_defs()->specialize_app_methods[3].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides
            );
            ctx.nativeSpecializeAppProcess_post();
        }
    },
    // nativeSpecializeAppProcess_xr_u
    {
        "nativeSpecializeAppProcess",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;ZZ[Ljava/lang/String;[Ljava/lang/String;ZZ)V",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jboolean is_perception_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs) static -> void {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.is_child_zygote = &is_child_zygote;
            args.is_top_app = &is_top_app;
            args.pkg_data_info_list = &pkg_data_info_list;
            args.whitelisted_data_info_list = &whitelisted_data_info_list;
            args.mount_data_dirs = &mount_data_dirs;
            args.mount_storage_dirs = &mount_storage_dirs;
            ZygiskContext ctx(env, &args);
            ctx.nativeSpecializeAppProcess_pre();
            reinterpret_cast<void(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jboolean is_perception_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs)>(get_defs()->specialize_app_methods[4].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, is_child_zygote, instruction_set, app_data_dir, is_top_app, is_perception_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs
            );
            ctx.nativeSpecializeAppProcess_post();
        }
    },
    // nativeSpecializeAppProcess_samsung_q
    {
        "nativeSpecializeAppProcess",
        "(II[II[[IILjava/lang/String;IILjava/lang/String;ZLjava/lang/String;Ljava/lang/String;)V",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _10, jint _11, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir) static -> void {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.is_child_zygote = &is_child_zygote;
            ZygiskContext ctx(env, &args);
            ctx.nativeSpecializeAppProcess_pre();
            reinterpret_cast<void(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _10, jint _11, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir)>(get_defs()->specialize_app_methods[5].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, _10, _11, nice_name, is_child_zygote, instruction_set, app_data_dir
            );
            ctx.nativeSpecializeAppProcess_post();
        }
    },
    // nativeSpecializeAppProcess_nubia_u
    {
        "nativeSpecializeAppProcess",
        "(II[II[[IILjava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;[Ljava/lang/String;ZZZLjava/lang/String;)V",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides, jstring _12) static -> void {
            AppSpecializeArgs_v5 args(uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, instruction_set, app_data_dir);
            args.is_child_zygote = &is_child_zygote;
            args.is_top_app = &is_top_app;
            args.pkg_data_info_list = &pkg_data_info_list;
            args.whitelisted_data_info_list = &whitelisted_data_info_list;
            args.mount_data_dirs = &mount_data_dirs;
            args.mount_storage_dirs = &mount_storage_dirs;
            args.mount_sysprop_overrides = &mount_sysprop_overrides;
            ZygiskContext ctx(env, &args);
            ctx.nativeSpecializeAppProcess_pre();
            reinterpret_cast<void(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides, jstring _12)>(get_defs()->specialize_app_methods[6].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides, _12
            );
            ctx.nativeSpecializeAppProcess_post();
        }
    },
}};

std::array<JNINativeMethod, 2> fork_server_methods = {{
    // nativeForkSystemServer_l
    {
        "nativeForkSystemServer",
        "(II[II[[IJJ)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities) static -> jint {
            ServerSpecializeArgs_v1 args(uid, gid, gids, runtime_flags, permitted_capabilities, effective_capabilities);
            ZygiskContext ctx(env, &args);
            ctx.nativeForkSystemServer_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities)>(get_defs()->fork_server_methods[0].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, rlimits, permitted_capabilities, effective_capabilities
            );
            ctx.nativeForkSystemServer_post();
            return ctx.pid;
        }
    },
    // nativeForkSystemServer_samsung_q
    {
        "nativeForkSystemServer",
        "(II[IIII[[IJJ)I",
        (void *) +[] [[clang::no_stack_protector]] (JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jint _13, jint _14, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities) static -> jint {
            ServerSpecializeArgs_v1 args(uid, gid, gids, runtime_flags, permitted_capabilities, effective_capabilities);
            ZygiskContext ctx(env, &args);
            ctx.nativeForkSystemServer_pre();
            reinterpret_cast<jint(*)(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jint _13, jint _14, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities)>(get_defs()->fork_server_methods[1].fnPtr)(
                env, clazz, uid, gid, gids, runtime_flags, _13, _14, rlimits, permitted_capabilities, effective_capabilities
            );
            ctx.nativeForkSystemServer_post();
            return ctx.pid;
        }
    },
}};

};

```

`native/src/core/zygisk/mod.rs`:

```rs
mod daemon;

use crate::thread::ThreadPool;
use base::{fd_get_attr, libc};
pub use daemon::{ZygiskState, zygisk_should_load_module};
use std::os::fd::RawFd;

#[unsafe(no_mangle)]
extern "C" fn exec_companion_entry(client: RawFd, companion_handler: extern "C" fn(RawFd)) {
    ThreadPool::exec_task(move || {
        let Ok(s1) = fd_get_attr(client) else {
            return;
        };

        companion_handler(client);

        // Only close client if it is the same file so we don't
        // accidentally close a re-used file descriptor.
        // This check is required because the module companion
        // handler could've closed the file descriptor already.
        if let Ok(s2) = fd_get_attr(client)
            && s1.st.st_dev == s2.st.st_dev
            && s1.st.st_ino == s2.st.st_ino
        {
            unsafe { libc::close(client) };
        }
    });
}

```

`native/src/core/zygisk/module.cpp`:

```cpp
#include <sys/mman.h>
#include <android/dlext.h>
#include <dlfcn.h>

#include <lsplt.hpp>

#include <base.hpp>

#include "zygisk.hpp"
#include "module.hpp"

using namespace std;

static int zygisk_request(int req) {
    int fd = connect_daemon(RequestCode::ZYGISK);
    if (fd < 0) return fd;
    write_int(fd, req);
    return fd;
}

ZygiskModule::ZygiskModule(int id, void *handle, void *entry)
    : id(id), handle(handle), entry{entry}, api{}, mod{nullptr} {
    // Make sure all pointers are null
    memset(&api, 0, sizeof(api));
    api.base.impl = this;
    api.base.registerModule = &ZygiskModule::RegisterModuleImpl;
}

bool ZygiskModule::RegisterModuleImpl(ApiTable *api, long *module) {
    if (api == nullptr || module == nullptr)
        return false;

    long api_version = *module;
    // Unsupported version
    if (api_version > ZYGISK_API_VERSION)
        return false;

    // Set the actual module_abi*
    api->base.impl->mod = { module };

    // Fill in API accordingly with module API version
    if (api_version >= 1) {
        api->v1.hookJniNativeMethods = hookJniNativeMethods;
        api->v1.pltHookRegister = [](auto a, auto b, auto c, auto d) {
            if (g_ctx) g_ctx->plt_hook_register(a, b, c, d);
        };
        api->v1.pltHookExclude = [](auto a, auto b) {
            if (g_ctx) g_ctx->plt_hook_exclude(a, b);
        };
        api->v1.pltHookCommit = []() { return g_ctx && g_ctx->plt_hook_commit(); };
        api->v1.connectCompanion = [](ZygiskModule *m) { return m->connectCompanion(); };
        api->v1.setOption = [](ZygiskModule *m, auto opt) { m->setOption(opt); };
    }
    if (api_version >= 2) {
        api->v2.getModuleDir = [](ZygiskModule *m) { return m->getModuleDir(); };
        api->v2.getFlags = [](auto) { return ZygiskModule::getFlags(); };
    }
    if (api_version >= 4) {
        api->v4.pltHookCommit = lsplt::CommitHook;
        api->v4.pltHookRegister = [](dev_t dev, ino_t inode, const char *symbol, void *fn, void **backup) {
            if (dev == 0 || inode == 0 || symbol == nullptr || fn == nullptr)
                return;
            lsplt::RegisterHook(dev, inode, symbol, fn, backup);
        };
        api->v4.exemptFd = [](int fd) { return g_ctx && g_ctx->exempt_fd(fd); };
    }

    return true;
}

bool ZygiskModule::valid() const {
    if (mod.api_version == nullptr)
        return false;
    switch (*mod.api_version) {
        case 5:
        case 4:
        case 3:
        case 2:
        case 1:
            return mod.v1->impl && mod.v1->preAppSpecialize && mod.v1->postAppSpecialize &&
                   mod.v1->preServerSpecialize && mod.v1->postServerSpecialize;
        default:
            return false;
    }
}

int ZygiskModule::connectCompanion() const {
    if (int fd = zygisk_request(+ZygiskRequest::ConnectCompanion); fd >= 0) {
#ifdef __LP64__
        write_any<bool>(fd, true);
#else
        write_any<bool>(fd, false);
#endif
        write_int(fd, id);
        return fd;
    }
    return -1;
}

int ZygiskModule::getModuleDir() const {
    if (owned_fd fd = zygisk_request(+ZygiskRequest::GetModDir); fd >= 0) {
        write_int(fd, id);
        return recv_fd(fd);
    }
    return -1;
}

void ZygiskModule::setOption(zygisk::Option opt) {
    if (g_ctx == nullptr)
        return;
    switch (opt) {
        case zygisk::FORCE_DENYLIST_UNMOUNT:
            g_ctx->flags |= DO_REVERT_UNMOUNT;
            break;
        case zygisk::DLCLOSE_MODULE_LIBRARY:
            unload = true;
            break;
    }
}

uint32_t ZygiskModule::getFlags() {
    return g_ctx ? (g_ctx->info_flags & ~PRIVATE_MASK) : 0;
}

void ZygiskModule::tryUnload() const {
    if (unload) dlclose(handle);
}

// -----------------------------------------------------------------

#define call_app(method)               \
switch (*mod.api_version) {            \
case 1:                                \
case 2: {                              \
    AppSpecializeArgs_v1 a(args);      \
    mod.v1->method(mod.v1->impl, &a);  \
    break;                             \
}                                      \
case 3:                                \
case 4:                                \
case 5:                                \
    mod.v1->method(mod.v1->impl, args);\
    break;                             \
}

void ZygiskModule::preAppSpecialize(AppSpecializeArgs_v5 *args) const {
    call_app(preAppSpecialize)
}

void ZygiskModule::postAppSpecialize(const AppSpecializeArgs_v5 *args) const {
    call_app(postAppSpecialize)
}

void ZygiskModule::preServerSpecialize(ServerSpecializeArgs_v1 *args) const {
    mod.v1->preServerSpecialize(mod.v1->impl, args);
}

void ZygiskModule::postServerSpecialize(const ServerSpecializeArgs_v1 *args) const {
    mod.v1->postServerSpecialize(mod.v1->impl, args);
}

// -----------------------------------------------------------------

void ZygiskContext::plt_hook_register(const char *regex, const char *symbol, void *fn, void **backup) {
    if (regex == nullptr || symbol == nullptr || fn == nullptr)
        return;
    regex_t re;
    if (regcomp(&re, regex, REG_NOSUB) != 0)
        return;
    mutex_guard lock(hook_info_lock);
    register_info.emplace_back(RegisterInfo{re, symbol, fn, backup});
}

void ZygiskContext::plt_hook_exclude(const char *regex, const char *symbol) {
    if (!regex) return;
    regex_t re;
    if (regcomp(&re, regex, REG_NOSUB) != 0)
        return;
    mutex_guard lock(hook_info_lock);
    ignore_info.emplace_back(IgnoreInfo{re, symbol ?: ""});
}

void ZygiskContext::plt_hook_process_regex() {
    if (register_info.empty())
        return;
    for (auto &map : lsplt::MapInfo::Scan()) {
        if (map.offset != 0 || !map.is_private || !(map.perms & PROT_READ)) continue;
        for (auto &reg: register_info) {
            if (regexec(&reg.regex, map.path.data(), 0, nullptr, 0) != 0)
                continue;
            bool ignored = false;
            for (auto &ign: ignore_info) {
                if (regexec(&ign.regex, map.path.data(), 0, nullptr, 0) != 0)
                    continue;
                if (ign.symbol.empty() || ign.symbol == reg.symbol) {
                    ignored = true;
                    break;
                }
            }
            if (!ignored) {
                lsplt::RegisterHook(map.dev, map.inode, reg.symbol, reg.callback, reg.backup);
            }
        }
    }
}

bool ZygiskContext::plt_hook_commit() {
    {
        mutex_guard lock(hook_info_lock);
        plt_hook_process_regex();
        for (auto& reg: register_info) {
            regfree(&reg.regex);
        }
        for (auto& ign: ignore_info) {
            regfree(&ign.regex);
        }
        register_info.clear();
        ignore_info.clear();
    }
    return lsplt::CommitHook();
}

// -----------------------------------------------------------------

int ZygiskContext::get_module_info(int uid, rust::Vec<int> &fds) {
    if (int fd = zygisk_request(+ZygiskRequest::GetInfo); fd >= 0) {
        write_int(fd, uid);
        write_string(fd, process);
#ifdef __LP64__
        write_any<bool>(fd, true);
#else
        write_any<bool>(fd, false);
#endif
        xxread(fd, &info_flags, sizeof(info_flags));
        if (zygisk_should_load_module(info_flags)) {
            fds = recv_fds(fd);
        }
        return fd;
    }
    return -1;
}

void ZygiskContext::sanitize_fds() {
    zygisk_close_logd();

    if (!is_child()) {
        return;
    }

    if (can_exempt_fd() && !exempted_fds.empty()) {
        auto update_fd_array = [&](int old_len) -> jintArray {
            jintArray array = env->NewIntArray(static_cast<int>(old_len + exempted_fds.size()));
            if (array == nullptr)
                return nullptr;

            env->SetIntArrayRegion(
                    array, old_len, static_cast<int>(exempted_fds.size()), exempted_fds.data());
            for (int fd : exempted_fds) {
                if (fd >= 0 && fd < allowed_fds.size()) {
                    allowed_fds[fd] = true;
                }
            }
            *args.app->fds_to_ignore = array;
            return array;
        };

        if (jintArray fdsToIgnore = *args.app->fds_to_ignore) {
            int *arr = env->GetIntArrayElements(fdsToIgnore, nullptr);
            int len = env->GetArrayLength(fdsToIgnore);
            for (int i = 0; i < len; ++i) {
                int fd = arr[i];
                if (fd >= 0 && fd < allowed_fds.size()) {
                    allowed_fds[fd] = true;
                }
            }
            if (jintArray newFdList = update_fd_array(len)) {
                env->SetIntArrayRegion(newFdList, 0, len, arr);
            }
            env->ReleaseIntArrayElements(fdsToIgnore, arr, JNI_ABORT);
        } else {
            update_fd_array(0);
        }
    }

    // Close all forbidden fds to prevent crashing
    auto dir = xopen_dir("/proc/self/fd");
    int dfd = dirfd(dir.get());
    for (dirent *entry; (entry = xreaddir(dir.get()));) {
        int fd = parse_int(entry->d_name);
        if ((fd < 0 || fd >= allowed_fds.size() || !allowed_fds[fd]) && fd != dfd) {
            close(fd);
        }
    }
}

bool ZygiskContext::exempt_fd(int fd) {
    if ((flags & POST_SPECIALIZE) || (flags & SKIP_CLOSE_LOG_PIPE))
        return true;
    if (!can_exempt_fd())
        return false;
    exempted_fds.push_back(fd);
    return true;
}

bool ZygiskContext::can_exempt_fd() const {
    return (flags & APP_FORK_AND_SPECIALIZE) && args.app->fds_to_ignore;
}

static int sigmask(int how, int signum) {
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, signum);
    return sigprocmask(how, &set, nullptr);
}

void ZygiskContext::fork_pre() {
    // Do our own fork before loading any 3rd party code
    // First block SIGCHLD, unblock after original fork is done
    sigmask(SIG_BLOCK, SIGCHLD);
    pid = old_fork();

    if (!is_child())
        return;

    // Record all open fds
    auto dir = xopen_dir("/proc/self/fd");
    for (dirent *entry; (entry = xreaddir(dir.get()));) {
        int fd = parse_int(entry->d_name);
        if (fd < 0 || fd >= allowed_fds.size()) {
            close(fd);
            continue;
        }
        allowed_fds[fd] = true;
    }
    // The dirfd will be closed once out of scope
    allowed_fds[dirfd(dir.get())] = false;
    // logd_fd should be handled separately
    if (int fd = zygisk_get_logd(); fd >= 0) {
        allowed_fds[fd] = false;
    }
}

void ZygiskContext::fork_post() {
    // Unblock SIGCHLD in case the original method didn't
    sigmask(SIG_UNBLOCK, SIGCHLD);
}

void ZygiskContext::run_modules_pre(rust::Vec<int> &fds) {
    for (int i = 0; i < fds.size(); ++i) {
        owned_fd fd = fds[i];
        struct stat s{};
        if (fstat(fd, &s) != 0 || !S_ISREG(s.st_mode)) {
            fds[i] = -1;
            continue;
        }
        android_dlextinfo info {
            .flags = ANDROID_DLEXT_USE_LIBRARY_FD,
            .library_fd = fd,
        };
        if (void *h = android_dlopen_ext("/jit-cache", RTLD_LAZY, &info)) {
            if (void *e = dlsym(h, "zygisk_module_entry")) {
                modules.emplace_back(i, h, e);
            }
        } else if (flags & SERVER_FORK_AND_SPECIALIZE) {
            ZLOGW("Failed to dlopen zygisk module: %s\n", dlerror());
            fds[i] = -1;
        }
    }

    for (auto it = modules.begin(); it != modules.end();) {
        it->onLoad(env);
        if (it->valid()) {
            ++it;
        } else {
            it = modules.erase(it);
        }
    }

    for (auto &m : modules) {
        if (flags & APP_SPECIALIZE) {
            m.preAppSpecialize(args.app);
        } else if (flags & SERVER_FORK_AND_SPECIALIZE) {
            m.preServerSpecialize(args.server);
        }
    }
}

void ZygiskContext::run_modules_post() {
    flags |= POST_SPECIALIZE;
    for (const auto &m : modules) {
        if (flags & APP_SPECIALIZE) {
            m.postAppSpecialize(args.app);
        } else if (flags & SERVER_FORK_AND_SPECIALIZE) {
            m.postServerSpecialize(args.server);
        }
        m.tryUnload();
    }
}

void ZygiskContext::app_specialize_pre() {
    flags |= APP_SPECIALIZE;

    rust::Vec<int> module_fds;
    owned_fd fd = get_module_info(args.app->uid, module_fds);
    if ((info_flags & UNMOUNT_MASK) == UNMOUNT_MASK) {
        ZLOGI("[%s] is on the denylist\n", process);
        flags |= DO_REVERT_UNMOUNT;
    } else if (fd >= 0) {
        run_modules_pre(module_fds);
    }
}

void ZygiskContext::app_specialize_post() {
    run_modules_post();
    if (info_flags & +ZygiskStateFlags::ProcessIsMagiskApp) {
        setenv("ZYGISK_ENABLED", "1", 1);
    }

    // Cleanups
    env->ReleaseStringUTFChars(args.app->nice_name, process);
}

void ZygiskContext::server_specialize_pre() {
    rust::Vec<int> module_fds;
    if (owned_fd fd = get_module_info(1000, module_fds); fd >= 0) {
        if (module_fds.empty()) {
            write_int(fd, 0);
        } else {
            run_modules_pre(module_fds);

            // Find all failed module ids and send it back to magiskd
            vector<int> failed_ids;
            for (int i = 0; i < module_fds.size(); ++i) {
                if (module_fds[i] < 0) {
                    failed_ids.push_back(i);
                }
            }
            write_vector(fd, failed_ids);
        }
    }
}

void ZygiskContext::server_specialize_post() {
    run_modules_post();
}

// -----------------------------------------------------------------

void ZygiskContext::nativeSpecializeAppProcess_pre() {
    process = env->GetStringUTFChars(args.app->nice_name, nullptr);
    ZLOGV("pre  specialize [%s]\n", process);
    // App specialize does not check FD
    flags |= SKIP_CLOSE_LOG_PIPE;
    app_specialize_pre();
}

void ZygiskContext::nativeSpecializeAppProcess_post() {
    ZLOGV("post specialize [%s]\n", process);
    app_specialize_post();
}

void ZygiskContext::nativeForkSystemServer_pre() {
    ZLOGV("pre  forkSystemServer\n");
    flags |= SERVER_FORK_AND_SPECIALIZE;
    process = "system_server";

    fork_pre();
    if (is_child()) {
        server_specialize_pre();
    }
    sanitize_fds();
}

void ZygiskContext::nativeForkSystemServer_post() {
    if (is_child()) {
        ZLOGV("post forkSystemServer\n");
        server_specialize_post();
    }
    fork_post();
}

void ZygiskContext::nativeForkAndSpecialize_pre() {
    process = env->GetStringUTFChars(args.app->nice_name, nullptr);
    ZLOGV("pre  forkAndSpecialize [%s]\n", process);
    flags |= APP_FORK_AND_SPECIALIZE;

    fork_pre();
    if (is_child()) {
        app_specialize_pre();
    }
    sanitize_fds();
}

void ZygiskContext::nativeForkAndSpecialize_post() {
    if (is_child()) {
        ZLOGV("post forkAndSpecialize [%s]\n", process);
        app_specialize_post();
    }
    fork_post();
}

```

`native/src/core/zygisk/module.hpp`:

```hpp
#pragma once

#include <regex.h>
#include <list>

#include "api.hpp"

struct ZygiskContext;
struct ZygiskModule;

struct AppSpecializeArgs_v1;
using  AppSpecializeArgs_v2 = AppSpecializeArgs_v1;
struct AppSpecializeArgs_v3;
using  AppSpecializeArgs_v4 = AppSpecializeArgs_v3;
struct AppSpecializeArgs_v5;

struct module_abi_v1;
using  module_abi_v2 = module_abi_v1;
using  module_abi_v3 = module_abi_v1;
using  module_abi_v4 = module_abi_v1;
using  module_abi_v5 = module_abi_v1;

struct api_abi_v1;
struct api_abi_v2;
using  api_abi_v3 = api_abi_v2;
struct api_abi_v4;
using  api_abi_v5 = api_abi_v4;

union ApiTable;

struct AppSpecializeArgs_v3 {
    jint &uid;
    jint &gid;
    jintArray &gids;
    jint &runtime_flags;
    jobjectArray &rlimits;
    jint &mount_external;
    jstring &se_info;
    jstring &nice_name;
    jstring &instruction_set;
    jstring &app_data_dir;

    jintArray *fds_to_ignore = nullptr;
    jboolean *is_child_zygote = nullptr;
    jboolean *is_top_app = nullptr;
    jobjectArray *pkg_data_info_list = nullptr;
    jobjectArray *whitelisted_data_info_list = nullptr;
    jboolean *mount_data_dirs = nullptr;
    jboolean *mount_storage_dirs = nullptr;

    AppSpecializeArgs_v3(
            jint &uid, jint &gid, jintArray &gids, jint &runtime_flags,
            jobjectArray &rlimits, jint &mount_external, jstring &se_info, jstring &nice_name,
            jstring &instruction_set, jstring &app_data_dir) :
            uid(uid), gid(gid), gids(gids), runtime_flags(runtime_flags), rlimits(rlimits),
            mount_external(mount_external), se_info(se_info), nice_name(nice_name),
            instruction_set(instruction_set), app_data_dir(app_data_dir) {}
};

struct AppSpecializeArgs_v5 : public AppSpecializeArgs_v3 {
    jboolean *mount_sysprop_overrides = nullptr;

    AppSpecializeArgs_v5(
            jint &uid, jint &gid, jintArray &gids, jint &runtime_flags,
            jobjectArray &rlimits, jint &mount_external, jstring &se_info, jstring &nice_name,
            jstring &instruction_set, jstring &app_data_dir) : AppSpecializeArgs_v3(
                    uid, gid, gids, runtime_flags, rlimits, mount_external,
                    se_info, nice_name, instruction_set, app_data_dir) {}
};

struct AppSpecializeArgs_v1 {
    jint &uid;
    jint &gid;
    jintArray &gids;
    jint &runtime_flags;
    jint &mount_external;
    jstring &se_info;
    jstring &nice_name;
    jstring &instruction_set;
    jstring &app_data_dir;

    jboolean *const is_child_zygote;
    jboolean *const is_top_app;
    jobjectArray *const pkg_data_info_list;
    jobjectArray *const whitelisted_data_info_list;
    jboolean *const mount_data_dirs;
    jboolean *const mount_storage_dirs;

    AppSpecializeArgs_v1(const AppSpecializeArgs_v5 *a) :
            uid(a->uid), gid(a->gid), gids(a->gids), runtime_flags(a->runtime_flags),
            mount_external(a->mount_external), se_info(a->se_info), nice_name(a->nice_name),
            instruction_set(a->instruction_set), app_data_dir(a->app_data_dir),
            is_child_zygote(a->is_child_zygote), is_top_app(a->is_top_app),
            pkg_data_info_list(a->pkg_data_info_list),
            whitelisted_data_info_list(a->whitelisted_data_info_list),
            mount_data_dirs(a->mount_data_dirs), mount_storage_dirs(a->mount_storage_dirs) {}
};

struct ServerSpecializeArgs_v1 {
    jint &uid;
    jint &gid;
    jintArray &gids;
    jint &runtime_flags;
    jlong &permitted_capabilities;
    jlong &effective_capabilities;

    ServerSpecializeArgs_v1(
            jint &uid, jint &gid, jintArray &gids, jint &runtime_flags,
            jlong &permitted_capabilities, jlong &effective_capabilities) :
            uid(uid), gid(gid), gids(gids), runtime_flags(runtime_flags),
            permitted_capabilities(permitted_capabilities),
            effective_capabilities(effective_capabilities) {}
};

struct module_abi_v1 {
    long api_version;
    void *impl;
    void (*preAppSpecialize)(void *, void *);
    void (*postAppSpecialize)(void *, const void *);
    void (*preServerSpecialize)(void *, void *);
    void (*postServerSpecialize)(void *, const void *);
};

// Assert the flag values to be the same as the public API
static_assert(+ZygiskStateFlags::ProcessGrantedRoot == zygisk::StateFlag::PROCESS_GRANTED_ROOT);
static_assert(+ZygiskStateFlags::ProcessOnDenyList == zygisk::StateFlag::PROCESS_ON_DENYLIST);

enum : uint32_t {
    UNMOUNT_MASK = (+ZygiskStateFlags::ProcessOnDenyList | +ZygiskStateFlags::DenyListEnforced),
    PRIVATE_MASK = (+ZygiskStateFlags::DenyListEnforced | +ZygiskStateFlags::ProcessIsMagiskApp)
};

struct api_abi_base {
    ZygiskModule *impl;
    bool (*registerModule)(ApiTable *, long *);
};

struct api_abi_v1 : public api_abi_base {
    /* 0 */ void (*hookJniNativeMethods)(JNIEnv *, const char *, JNINativeMethod *, int);
    /* 1 */ void (*pltHookRegister)(const char *, const char *, void *, void **);
    /* 2 */ void (*pltHookExclude)(const char *, const char *);
    /* 3 */ bool (*pltHookCommit)();
    /* 4 */ int (*connectCompanion)(ZygiskModule *);
    /* 5 */ void (*setOption)(ZygiskModule *, zygisk::Option);
};

struct api_abi_v2 : public api_abi_v1 {
    /* 6 */ int (*getModuleDir)(ZygiskModule *);
    /* 7 */ uint32_t (*getFlags)(ZygiskModule *);
};

struct api_abi_v4 : public api_abi_base {
    /* 0 */ void (*hookJniNativeMethods)(JNIEnv *, const char *, JNINativeMethod *, int);
    /* 1 */ void (*pltHookRegister)(dev_t, ino_t, const char *, void *, void **);
    /* 2 */ bool (*exemptFd)(int);
    /* 3 */ bool (*pltHookCommit)();
    /* 4 */ int (*connectCompanion)(ZygiskModule *);
    /* 5 */ void (*setOption)(ZygiskModule *, zygisk::Option);
    /* 6 */ int (*getModuleDir)(ZygiskModule *);
    /* 7 */ uint32_t (*getFlags)(ZygiskModule *);
};

union ApiTable {
    api_abi_base base;
    api_abi_v1 v1;
    api_abi_v2 v2;
    api_abi_v4 v4;
};

struct ZygiskModule {

    void onLoad(void *env) {
        entry.fn(&api, env);
    }

    void preAppSpecialize(AppSpecializeArgs_v5 *args) const;
    void postAppSpecialize(const AppSpecializeArgs_v5 *args) const;
    void preServerSpecialize(ServerSpecializeArgs_v1 *args) const;
    void postServerSpecialize(const ServerSpecializeArgs_v1 *args) const;

    bool valid() const;
    int connectCompanion() const;
    int getModuleDir() const;
    void setOption(zygisk::Option opt);
    static uint32_t getFlags();
    void tryUnload() const;
    void clearApi() { memset(&api, 0, sizeof(api)); }

    ZygiskModule(int id, void *handle, void *entry);

    static bool RegisterModuleImpl(ApiTable *api, long *module);

private:
    const int id;
    bool unload = false;

    void * const handle;
    union {
        void * const ptr;
        void (* const fn)(void *, void *);
    } entry;

    ApiTable api;

    union {
        long *api_version;
        module_abi_v1 *v1;
    } mod;
};

extern ZygiskContext *g_ctx;
extern int (*old_fork)(void);

enum : uint32_t {
    POST_SPECIALIZE = (1u << 0),
    APP_FORK_AND_SPECIALIZE = (1u << 1),
    APP_SPECIALIZE = (1u << 2),
    SERVER_FORK_AND_SPECIALIZE = (1u << 3),
    DO_REVERT_UNMOUNT = (1u << 4),
    SKIP_CLOSE_LOG_PIPE = (1u << 5),
};

#define DCL_PRE_POST(name) \
void name##_pre();         \
void name##_post();

struct ZygiskContext {
    JNIEnv *env;
    union {
        void *ptr;
        AppSpecializeArgs_v5 *app;
        ServerSpecializeArgs_v1 *server;
    } args;

    const char *process;
    std::list<ZygiskModule> modules;

    int pid;
    uint32_t flags;
    uint32_t info_flags;
    std::vector<bool> allowed_fds;
    std::vector<int> exempted_fds;

    struct RegisterInfo {
        regex_t regex;
        std::string symbol;
        void *callback;
        void **backup;
    };

    struct IgnoreInfo {
        regex_t regex;
        std::string symbol;
    };

    pthread_mutex_t hook_info_lock;
    std::vector<RegisterInfo> register_info;
    std::vector<IgnoreInfo> ignore_info;

    ZygiskContext(JNIEnv *env, void *args);
    ~ZygiskContext();

    void run_modules_pre(rust::Vec<int> &fds);
    void run_modules_post();
    DCL_PRE_POST(fork)
    DCL_PRE_POST(app_specialize)
    DCL_PRE_POST(server_specialize)
    DCL_PRE_POST(nativeForkAndSpecialize)
    DCL_PRE_POST(nativeSpecializeAppProcess)
    DCL_PRE_POST(nativeForkSystemServer)

    int get_module_info(int uid, rust::Vec<int> &fds);
    void sanitize_fds();
    bool exempt_fd(int fd);
    bool can_exempt_fd() const;
    bool is_child() const { return pid <= 0; }

    // Compatibility shim
    void plt_hook_register(const char *regex, const char *symbol, void *fn, void **backup);
    void plt_hook_exclude(const char *regex, const char *symbol);
    void plt_hook_process_regex();

    bool plt_hook_commit();
};

#undef DCL_PRE_POST

```

`native/src/core/zygisk/zygisk.hpp`:

```hpp
#pragma once

#include <jni.h>
#include <core.hpp>

#define ZYGISKLDR       "libzygisk.so"
#define NBPROP          "ro.dalvik.vm.native.bridge"

#if defined(__LP64__)
#define ZLOGD(...) LOGD("zygisk64: " __VA_ARGS__)
#define ZLOGE(...) LOGE("zygisk64: " __VA_ARGS__)
#define ZLOGI(...) LOGI("zygisk64: " __VA_ARGS__)
#define ZLOGW(...) LOGW("zygisk64: " __VA_ARGS__)
#else
#define ZLOGD(...) LOGD("zygisk32: " __VA_ARGS__)
#define ZLOGE(...) LOGE("zygisk32: " __VA_ARGS__)
#define ZLOGI(...) LOGI("zygisk32: " __VA_ARGS__)
#define ZLOGW(...) LOGW("zygisk32: " __VA_ARGS__)
#endif

// Extreme verbose logging
// #define ZLOGV(...) ZLOGD(__VA_ARGS__)
#define ZLOGV(...) (void*)0

void hook_entry();
void hookJniNativeMethods(JNIEnv *env, const char *clz, JNINativeMethod *methods, int numMethods);

// The reference of the following structs
// https://cs.android.com/android/platform/superproject/main/+/main:art/libnativebridge/include/nativebridge/native_bridge.h

struct NativeBridgeRuntimeCallbacks {
    const char* (*getMethodShorty)(JNIEnv* env, jmethodID mid);
    uint32_t (*getNativeMethodCount)(JNIEnv* env, jclass clazz);
    uint32_t (*getNativeMethods)(JNIEnv* env, jclass clazz, JNINativeMethod* methods,
                                 uint32_t method_count);
};

struct NativeBridgeCallbacks {
    uint32_t version;
    void *padding[5];
    bool (*isCompatibleWith)(uint32_t);
};

```

`native/src/exported_sym.txt`:

```txt
{
    NativeBridgeItf;
};

```

`native/src/external/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

# libxz.a
include $(CLEAR_VARS)
LOCAL_MODULE:= libxz
LOCAL_C_INCLUDES := $(LOCAL_PATH)/xz-embedded
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_C_INCLUDES)
LOCAL_SRC_FILES := \
    xz-embedded/xz_crc32.c \
    xz-embedded/xz_dec_lzma2.c \
    xz-embedded/xz_dec_stream.c
include $(BUILD_STATIC_LIBRARY)

# liblz4.a
include $(CLEAR_VARS)
LOCAL_MODULE := liblz4
LOCAL_C_INCLUDES := $(LOCAL_PATH)/lz4/lib
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_C_INCLUDES)
LOCAL_SRC_FILES := \
    lz4/lib/lz4.c \
    lz4/lib/lz4frame.c \
    lz4/lib/lz4hc.c \
    lz4/lib/xxhash.c
include $(BUILD_STATIC_LIBRARY)

SE_PATH := $(LOCAL_PATH)/selinux

# libsepol.a
include $(CLEAR_VARS)
LIBSEPOL := $(SE_PATH)/libsepol/include $(SE_PATH)/libsepol/cil/include
LOCAL_MODULE := libsepol
LOCAL_C_INCLUDES := $(LIBSEPOL) $(LOCAL_PATH)/selinux/libsepol/src
LOCAL_EXPORT_C_INCLUDES := $(LIBSEPOL)
LOCAL_SRC_FILES := \
    selinux/libsepol/src/assertion.c \
    selinux/libsepol/src/avrule_block.c \
    selinux/libsepol/src/avtab.c \
    selinux/libsepol/src/boolean_record.c \
    selinux/libsepol/src/booleans.c \
    selinux/libsepol/src/conditional.c \
    selinux/libsepol/src/constraint.c \
    selinux/libsepol/src/context.c \
    selinux/libsepol/src/context_record.c \
    selinux/libsepol/src/debug.c \
    selinux/libsepol/src/ebitmap.c \
    selinux/libsepol/src/expand.c \
    selinux/libsepol/src/handle.c \
    selinux/libsepol/src/hashtab.c \
    selinux/libsepol/src/hierarchy.c \
    selinux/libsepol/src/ibendport_record.c \
    selinux/libsepol/src/ibendports.c \
    selinux/libsepol/src/ibpkey_record.c \
    selinux/libsepol/src/ibpkeys.c \
    selinux/libsepol/src/iface_record.c \
    selinux/libsepol/src/interfaces.c \
    selinux/libsepol/src/kernel_to_cil.c \
    selinux/libsepol/src/kernel_to_common.c \
    selinux/libsepol/src/kernel_to_conf.c \
    selinux/libsepol/src/link.c \
    selinux/libsepol/src/mls.c \
    selinux/libsepol/src/module.c \
    selinux/libsepol/src/module_to_cil.c \
    selinux/libsepol/src/node_record.c \
    selinux/libsepol/src/nodes.c \
    selinux/libsepol/src/optimize.c \
    selinux/libsepol/src/polcaps.c \
    selinux/libsepol/src/policydb.c \
    selinux/libsepol/src/policydb_convert.c \
    selinux/libsepol/src/policydb_public.c \
    selinux/libsepol/src/policydb_validate.c \
    selinux/libsepol/src/port_record.c \
    selinux/libsepol/src/ports.c \
    selinux/libsepol/src/services.c \
    selinux/libsepol/src/sidtab.c \
    selinux/libsepol/src/symtab.c \
    selinux/libsepol/src/user_record.c \
    selinux/libsepol/src/users.c \
    selinux/libsepol/src/util.c \
    selinux/libsepol/src/write.c \
    selinux/libsepol/cil/src/cil.c \
    selinux/libsepol/cil/src/cil_binary.c \
    selinux/libsepol/cil/src/cil_build_ast.c \
    selinux/libsepol/cil/src/cil_copy_ast.c \
    selinux/libsepol/cil/src/cil_deny.c \
    selinux/libsepol/cil/src/cil_find.c \
    selinux/libsepol/cil/src/cil_fqn.c \
    selinux/libsepol/cil/src/cil_lexer.c \
    selinux/libsepol/cil/src/cil_list.c \
    selinux/libsepol/cil/src/cil_log.c \
    selinux/libsepol/cil/src/cil_mem.c \
    selinux/libsepol/cil/src/cil_parser.c \
    selinux/libsepol/cil/src/cil_policy.c \
    selinux/libsepol/cil/src/cil_post.c \
    selinux/libsepol/cil/src/cil_reset_ast.c \
    selinux/libsepol/cil/src/cil_resolve_ast.c \
    selinux/libsepol/cil/src/cil_stack.c \
    selinux/libsepol/cil/src/cil_strpool.c \
    selinux/libsepol/cil/src/cil_symtab.c \
    selinux/libsepol/cil/src/cil_tree.c \
    selinux/libsepol/cil/src/cil_verify.c \
    selinux/libsepol/cil/src/cil_write_ast.c

LOCAL_CFLAGS := -Wno-unused-but-set-variable
ifeq ($(TARGET_ARCH),riscv64)
LOCAL_CFLAGS += -DHAVE_REALLOCARRAY
endif
include $(BUILD_STATIC_LIBRARY)

# liblsplt.a
include $(CLEAR_VARS)
LOCAL_MODULE:= liblsplt
LOCAL_C_INCLUDES := $(LOCAL_PATH)/lsplt/lsplt/src/main/jni/include
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_C_INCLUDES)
LOCAL_CFLAGS := -Wall -Wextra -Werror -fvisibility=hidden -D__android_log_print=magisk_log_print
LOCAL_CPPFLAGS := -std=c++20
LOCAL_STATIC_LIBRARIES := libcxx
LOCAL_SRC_FILES := \
    lsplt/lsplt/src/main/jni/elf_util.cc \
    lsplt/lsplt/src/main/jni/lsplt.cc
include $(BUILD_STATIC_LIBRARY)

CWD := $(LOCAL_PATH)
include $(CWD)/system_properties/Android.mk
include $(CWD)/libcxx/Android.mk

ifdef B_CRT0
include $(CWD)/crt0/Android.mk
endif

```

`native/src/external/lz4-sys/Cargo.toml`:

```toml
[package]
name = "lz4-sys"
license = "MIT"
version = "1.11.1+lz4-1.10.0"
authors = [ "Jens Heyens <jens.heyens@ewetel.net>", "Artem V. Navrotskiy <bozaro@buzzsoft.ru>", "Patrick Marks <pmarks@gmail.com>"]
description = "Rust LZ4 sys package."
repository = "https://github.com/10xGenomics/lz4-rs"

[dependencies]
libc = "0.2"

```

`native/src/external/lz4-sys/src/lib.rs`:

```rs
#![allow(unexpected_cfgs)]
#![no_std]
extern crate libc;

#[cfg(not(all(
    target_arch = "wasm32",
    not(any(target_env = "wasi", target_os = "wasi"))
)))]
pub use libc::{c_char, c_int, c_uint, c_ulonglong, c_void, size_t};

#[cfg(all(
    target_arch = "wasm32",
    not(any(target_env = "wasi", target_os = "wasi"))
))]
extern crate alloc;

#[cfg(all(
    target_arch = "wasm32",
    not(any(target_env = "wasi", target_os = "wasi"))
))]
mod wasm_shim;

#[cfg(all(
    target_arch = "wasm32",
    not(any(target_env = "wasi", target_os = "wasi"))
))]
extern crate std;

#[cfg(all(
    target_arch = "wasm32",
    not(any(target_env = "wasi", target_os = "wasi"))
))]
pub use std::os::raw::{c_char, c_int, c_uint, c_ulonglong, c_void};

#[cfg(all(
    target_arch = "wasm32",
    not(any(target_env = "wasi", target_os = "wasi"))
))]
#[allow(non_camel_case_types)]
pub type size_t = usize;

#[derive(Clone, Copy, Debug)]
#[repr(C)]
pub struct LZ4FCompressionContext(pub *mut c_void);
unsafe impl Send for LZ4FCompressionContext {}

#[derive(Clone, Copy, Debug)]
#[repr(C)]
pub struct LZ4FDecompressionContext(pub *mut c_void);
unsafe impl Send for LZ4FDecompressionContext {}

pub type LZ4FErrorCode = size_t;

#[derive(Clone, Debug)]
#[repr(u32)]
pub enum BlockSize {
    Default = 0, // Default - 64KB
    Max64KB = 4,
    Max256KB = 5,
    Max1MB = 6,
    Max4MB = 7,
}

impl BlockSize {
    pub fn get_size(&self) -> usize {
        match self {
            &BlockSize::Default | &BlockSize::Max64KB => 64 * 1024,
            &BlockSize::Max256KB => 256 * 1024,
            &BlockSize::Max1MB => 1 * 1024 * 1024,
            &BlockSize::Max4MB => 4 * 1024 * 1024,
        }
    }
}

#[derive(Clone, Debug)]
#[repr(u32)]
pub enum BlockMode {
    Linked = 0,
    Independent,
}

#[derive(Clone, Debug)]
#[repr(u32)]
pub enum ContentChecksum {
    NoChecksum = 0,
    ChecksumEnabled,
}

#[derive(Clone, Debug)]
#[repr(u32)]
pub enum FrameType {
    Frame = 0,
    SkippableFrame,
}

#[derive(Clone, Debug)]
#[repr(u32)]
pub enum BlockChecksum {
    NoBlockChecksum = 0,
    BlockChecksumEnabled,
}

#[derive(Debug)]
#[repr(C)]
pub struct LZ4FFrameInfo {
    pub block_size_id: BlockSize,
    pub block_mode: BlockMode,
    pub content_checksum_flag: ContentChecksum,
    pub frame_type: FrameType,
    pub content_size: c_ulonglong,
    pub dict_id: c_uint,
    pub block_checksum_flag: BlockChecksum,
}

#[derive(Debug)]
#[repr(C)]
pub struct LZ4FPreferences {
    pub frame_info: LZ4FFrameInfo,
    pub compression_level: c_uint, // 0 == default (fast mode); values above 16 count as 16
    pub auto_flush: c_uint,        // 1 == always flush : reduce need for tmp buffer
    pub favor_dec_speed: c_uint,   // 1 == favor decompression speed over ratio, requires level 10+
    pub reserved: [c_uint; 3],
}

#[derive(Debug)]
#[repr(C)]
pub struct LZ4FCompressOptions {
    pub stable_src: c_uint, /* 1 == src content will remain available on future calls
                             * to LZ4F_compress(); avoid saving src content within tmp
                             * buffer as future dictionary */
    pub reserved: [c_uint; 3],
}

#[derive(Debug)]
#[repr(C)]
pub struct LZ4FDecompressOptions {
    pub stable_dst: c_uint, /* guarantee that decompressed data will still be there on next
                             * function calls (avoid storage into tmp buffers) */
    pub reserved: [c_uint; 3],
}

#[derive(Debug)]
#[repr(C)]
pub struct LZ4StreamEncode(c_void);

#[derive(Debug)]
#[repr(C)]
pub struct LZ4StreamDecode(c_void);

pub const LZ4F_VERSION: c_uint = 100;

extern "C" {

    // int LZ4_compress_default(const char* source, char* dest, int sourceSize, int maxDestSize);
    #[allow(non_snake_case)]
    pub fn LZ4_compress_default(
        source: *const c_char,
        dest: *mut c_char,
        sourceSize: c_int,
        maxDestSize: c_int,
    ) -> c_int;

    // int LZ4_compress_fast (const char* source, char* dest, int sourceSize, int maxDestSize, int acceleration);
    #[allow(non_snake_case)]
    pub fn LZ4_compress_fast(
        source: *const c_char,
        dest: *mut c_char,
        sourceSize: c_int,
        maxDestSize: c_int,
        acceleration: c_int,
    ) -> c_int;

    // int LZ4_compress_HC (const char* src, char* dst, int srcSize, int dstCapacity, int compressionLevel);
    #[allow(non_snake_case)]
    pub fn LZ4_compress_HC(
        src: *const c_char,
        dst: *mut c_char,
        srcSize: c_int,
        dstCapacity: c_int,
        compressionLevel: c_int,
    ) -> c_int;

    // int LZ4_decompress_safe (const char* source, char* dest, int compressedSize, int maxDecompressedSize);
    #[allow(non_snake_case)]
    pub fn LZ4_decompress_safe(
        source: *const c_char,
        dest: *mut c_char,
        compressedSize: c_int,
        maxDecompressedSize: c_int,
    ) -> c_int;

    // unsigned    LZ4F_isError(LZ4F_errorCode_t code);
    pub fn LZ4F_isError(code: size_t) -> c_uint;

    // const char* LZ4F_getErrorName(LZ4F_errorCode_t code);
    pub fn LZ4F_getErrorName(code: size_t) -> *const c_char;

    // LZ4F_createCompressionContext() :
    // The first thing to do is to create a compressionContext object, which will be used in all
    // compression operations.
    // This is achieved using LZ4F_createCompressionContext(), which takes as argument a version
    // and an LZ4F_preferences_t structure.
    // The version provided MUST be LZ4F_VERSION. It is intended to track potential version
    // differences between different binaries.
    // The function will provide a pointer to a fully allocated LZ4F_compressionContext_t object.
    // If the result LZ4F_errorCode_t is not zero, there was an error during context creation.
    // Object can release its memory using LZ4F_freeCompressionContext();
    //
    // LZ4F_errorCode_t LZ4F_createCompressionContext(
    //                                   LZ4F_compressionContext_t* LZ4F_compressionContextPtr,
    //                                   unsigned version);
    pub fn LZ4F_createCompressionContext(
        ctx: &mut LZ4FCompressionContext,
        version: c_uint,
    ) -> LZ4FErrorCode;

    // LZ4F_errorCode_t LZ4F_freeCompressionContext(
    //                                  LZ4F_compressionContext_t LZ4F_compressionContext);
    pub fn LZ4F_freeCompressionContext(ctx: LZ4FCompressionContext) -> LZ4FErrorCode;

    // LZ4F_compressBegin() :
    // will write the frame header into dstBuffer.
    // dstBuffer must be large enough to accommodate a header (dstMaxSize). Maximum header
    // size is 19 bytes.
    // The LZ4F_preferences_t structure is optional : you can provide NULL as argument, all
    // preferences will then be set to default.
    // The result of the function is the number of bytes written into dstBuffer for the header
    // or an error code (can be tested using LZ4F_isError())
    //
    // size_t LZ4F_compressBegin(LZ4F_compressionContext_t compressionContext,
    //                           void* dstBuffer,
    //                           size_t dstMaxSize,
    //                           const LZ4F_preferences_t* preferencesPtr);
    pub fn LZ4F_compressBegin(
        ctx: LZ4FCompressionContext,
        dstBuffer: *mut u8,
        dstMaxSize: size_t,
        preferencesPtr: *const LZ4FPreferences,
    ) -> LZ4FErrorCode;

    // LZ4F_compressBound() :
    // Provides the minimum size of Dst buffer given srcSize to handle worst case situations.
    // preferencesPtr is optional : you can provide NULL as argument, all preferences will then
    // be set to default.
    // Note that different preferences will produce in different results.
    //
    // size_t LZ4F_compressBound(size_t srcSize, const LZ4F_preferences_t* preferencesPtr);
    pub fn LZ4F_compressBound(
        srcSize: size_t,
        preferencesPtr: *const LZ4FPreferences,
    ) -> LZ4FErrorCode;

    // LZ4F_compressUpdate()
    // LZ4F_compressUpdate() can be called repetitively to compress as much data as necessary.
    // The most important rule is that dstBuffer MUST be large enough (dstMaxSize) to ensure
    // compression completion even in worst case.
    // If this condition is not respected, LZ4F_compress() will fail (result is an errorCode)
    // You can get the minimum value of dstMaxSize by using LZ4F_compressBound()
    // The LZ4F_compressOptions_t structure is optional : you can provide NULL as argument.
    // The result of the function is the number of bytes written into dstBuffer : it can be zero,
    // meaning input data was just buffered.
    // The function outputs an error code if it fails (can be tested using LZ4F_isError())
    //
    // size_t LZ4F_compressUpdate(LZ4F_compressionContext_t compressionContext,
    //                            void* dstBuffer,
    //                            size_t dstMaxSize,
    //                            const void* srcBuffer,
    //                            size_t srcSize,
    //                            const LZ4F_compressOptions_t* compressOptionsPtr);
    pub fn LZ4F_compressUpdate(
        ctx: LZ4FCompressionContext,
        dstBuffer: *mut u8,
        dstMaxSize: size_t,
        srcBuffer: *const u8,
        srcSize: size_t,
        compressOptionsPtr: *const LZ4FCompressOptions,
    ) -> size_t;

    // LZ4F_flush()
    // Should you need to create compressed data immediately, without waiting for a block
    // to be be filled, you can call LZ4_flush(), which will immediately compress any remaining
    // data buffered within compressionContext.
    // The LZ4F_compressOptions_t structure is optional : you can provide NULL as argument.
    // The result of the function is the number of bytes written into dstBuffer
    // (it can be zero, this means there was no data left within compressionContext)
    // The function outputs an error code if it fails (can be tested using LZ4F_isError())
    //
    // size_t LZ4F_flush(LZ4F_compressionContext_t compressionContext,
    //                   void* dstBuffer,
    //                   size_t dstMaxSize,
    //                   const LZ4F_compressOptions_t* compressOptionsPtr);
    pub fn LZ4F_flush(
        ctx: LZ4FCompressionContext,
        dstBuffer: *mut u8,
        dstMaxSize: size_t,
        compressOptionsPtr: *const LZ4FCompressOptions,
    ) -> LZ4FErrorCode;

    // LZ4F_compressEnd()
    // When you want to properly finish the compressed frame, just call LZ4F_compressEnd().
    // It will flush whatever data remained within compressionContext (like LZ4_flush())
    // but also properly finalize the frame, with an endMark and a checksum.
    // The result of the function is the number of bytes written into dstBuffer
    // (necessarily >= 4 (endMark size))
    // The function outputs an error code if it fails (can be tested using LZ4F_isError())
    // The LZ4F_compressOptions_t structure is optional : you can provide NULL as argument.
    // compressionContext can then be used again, starting with LZ4F_compressBegin().
    //
    // size_t LZ4F_compressEnd(LZ4F_compressionContext_t compressionContext,
    //                         void* dstBuffer,
    //                         size_t dstMaxSize,
    //                         const LZ4F_compressOptions_t* compressOptionsPtr);
    pub fn LZ4F_compressEnd(
        ctx: LZ4FCompressionContext,
        dstBuffer: *mut u8,
        dstMaxSize: size_t,
        compressOptionsPtr: *const LZ4FCompressOptions,
    ) -> LZ4FErrorCode;

    // LZ4F_createDecompressionContext() :
    // The first thing to do is to create a decompressionContext object, which will be used
    // in all decompression operations.
    // This is achieved using LZ4F_createDecompressionContext().
    // The version provided MUST be LZ4F_VERSION. It is intended to track potential version
    // differences between different binaries.
    // The function will provide a pointer to a fully allocated and initialized
    // LZ4F_decompressionContext_t object.
    // If the result LZ4F_errorCode_t is not OK_NoError, there was an error during
    // context creation.
    // Object can release its memory using LZ4F_freeDecompressionContext();
    //
    // LZ4F_errorCode_t LZ4F_createDecompressionContext(LZ4F_decompressionContext_t* ctxPtr,
    //                                                  unsigned version);
    pub fn LZ4F_createDecompressionContext(
        ctx: &mut LZ4FDecompressionContext,
        version: c_uint,
    ) -> LZ4FErrorCode;

    // LZ4F_errorCode_t LZ4F_freeDecompressionContext(LZ4F_decompressionContext_t ctx);
    pub fn LZ4F_freeDecompressionContext(ctx: LZ4FDecompressionContext) -> LZ4FErrorCode;

    // LZ4F_getFrameInfo()
    // This function decodes frame header information, such as blockSize.
    // It is optional : you could start by calling directly LZ4F_decompress() instead.
    // The objective is to extract header information without starting decompression, typically
    // for allocation purposes.
    // LZ4F_getFrameInfo() can also be used *after* starting decompression, on a
    // valid LZ4F_decompressionContext_t.
    // The number of bytes read from srcBuffer will be provided within *srcSizePtr
    // (necessarily <= original value).
    // You are expected to resume decompression from where it stopped (srcBuffer + *srcSizePtr)
    // The function result is an hint of how many srcSize bytes LZ4F_decompress() expects for
    // next call, or an error code which can be tested using LZ4F_isError().
    //
    // size_t LZ4F_getFrameInfo(LZ4F_decompressionContext_t ctx,
    // 					LZ4F_frameInfo_t* frameInfoPtr,
    // 					const void* srcBuffer, size_t* srcSizePtr);
    pub fn LZ4F_getFrameInfo(
        ctx: LZ4FDecompressionContext,
        frameInfoPtr: &mut LZ4FFrameInfo,
        srcBuffer: *const u8,
        srcSizePtr: &mut size_t,
    ) -> LZ4FErrorCode;

    // LZ4F_decompress()
    // Call this function repetitively to regenerate data compressed within srcBuffer.
    // The function will attempt to decode *srcSizePtr bytes from srcBuffer, into dstBuffer of
    // maximum size *dstSizePtr.
    //
    // The number of bytes regenerated into dstBuffer will be provided within *dstSizePtr
    // (necessarily <= original value).
    //
    // The number of bytes read from srcBuffer will be provided within *srcSizePtr
    // (necessarily <= original value).
    // If number of bytes read is < number of bytes provided, then decompression operation
    // is not completed. It typically happens when dstBuffer is not large enough to contain
    // all decoded data.
    // LZ4F_decompress() must be called again, starting from where it stopped
    // (srcBuffer + *srcSizePtr)
    // The function will check this condition, and refuse to continue if it is not respected.
    //
    // dstBuffer is supposed to be flushed between each call to the function, since its content
    // will be overwritten.
    // dst arguments can be changed at will with each consecutive call to the function.
    //
    // The function result is an hint of how many srcSize bytes LZ4F_decompress() expects for
    // next call.
    // Schematically, it's the size of the current (or remaining) compressed block + header of
    // next block.
    // Respecting the hint provides some boost to performance, since it does skip intermediate
    // buffers.
    // This is just a hint, you can always provide any srcSize you want.
    // When a frame is fully decoded, the function result will be 0. (no more data expected)
    // If decompression failed, function result is an error code, which can be tested
    // using LZ4F_isError().
    //
    // size_t LZ4F_decompress(LZ4F_decompressionContext_t ctx,
    //                        void* dstBuffer, size_t* dstSizePtr,
    //                        const void* srcBuffer, size_t* srcSizePtr,
    //                        const LZ4F_decompressOptions_t* optionsPtr);
    pub fn LZ4F_decompress(
        ctx: LZ4FDecompressionContext,
        dstBuffer: *mut u8,
        dstSizePtr: &mut size_t,
        srcBuffer: *const u8,
        srcSizePtr: &mut size_t,
        optionsPtr: *const LZ4FDecompressOptions,
    ) -> LZ4FErrorCode;

    // int LZ4_versionNumber(void)
    pub fn LZ4_versionNumber() -> c_int;

    // int LZ4_compressBound(int isize)
    pub fn LZ4_compressBound(size: c_int) -> c_int;

    // LZ4_stream_t* LZ4_createStream(void)
    pub fn LZ4_createStream() -> *mut LZ4StreamEncode;

    // int LZ4_compress_continue(LZ4_stream_t* LZ4_streamPtr,
    //                           const char* source,
    //                           char* dest,
    //                           int inputSize)
    pub fn LZ4_compress_continue(
        LZ4_stream: *mut LZ4StreamEncode,
        source: *const u8,
        dest: *mut u8,
        input_size: c_int,
    ) -> c_int;

    // int LZ4_freeStream(LZ4_stream_t* LZ4_streamPtr)
    pub fn LZ4_freeStream(LZ4_stream: *mut LZ4StreamEncode) -> c_int;

    // int LZ4_setStreamDecode (LZ4_streamDecode_t* LZ4_streamDecode,
    //                          const char* dictionary,
    //                          int dictSize)
    pub fn LZ4_setStreamDecode(
        LZ4_stream: *mut LZ4StreamDecode,
        dictionary: *const u8,
        dict_size: c_int,
    ) -> c_int;

    // LZ4_streamDecode_t* LZ4_createStreamDecode(void)
    pub fn LZ4_createStreamDecode() -> *mut LZ4StreamDecode;

    // int LZ4_decompress_safe_continue(LZ4_streamDecode_t* LZ4_streamDecode,
    //                                  const char* source,
    //                                  char* dest,
    //                                  int compressedSize,
    //                                  int maxDecompressedSize)
    pub fn LZ4_decompress_safe_continue(
        LZ4_stream: *mut LZ4StreamDecode,
        source: *const u8,
        dest: *mut u8,
        compressed_size: c_int,
        max_decompressed_size: c_int,
    ) -> c_int;

    // int LZ4_freeStreamDecode(LZ4_streamDecode_t* LZ4_stream)
    pub fn LZ4_freeStreamDecode(LZ4_stream: *mut LZ4StreamDecode) -> c_int;

    // LZ4F_resetDecompressionContext()
    // In case of an error, the context is left in "undefined" state.
    // In which case, it's necessary to reset it, before re-using it.
    // This method can also be used to abruptly stop any unfinished decompression,
    // and start a new one using same context resources.
    pub fn LZ4F_resetDecompressionContext(ctx: LZ4FDecompressionContext);

}

#[test]
fn test_version_number() {
    unsafe {
        LZ4_versionNumber();
    }
}

#[test]
fn test_frame_info_size() {
    assert_eq!(core::mem::size_of::<LZ4FFrameInfo>(), 32);
}

```

`native/src/external/lz4-sys/src/wasm_shim.rs`:

```rs
//! A shim for the libc functions used in lz4-rs that are not available when building for wasm
//! targets. Adapted from the shim present in the [zstd](https://github.com/gyscos/zstd-rs) crate.
//! zstd-rs license here:
//! The MIT License (MIT)
//! Copyright (c) 2016 Alexandre Bury
//!
//! Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//! and associated documentation files (the "Software"), to deal in the Software without
//! restriction, including without limitation the rights to use, copy, modify, merge, publish,
//! distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
//! Software is furnished to do so, subject to the following conditions:
//!
//! The above copyright notice and this permission notice shall be included in all copies or
//! substantial portions of the Software.
//!
//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//! BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//! NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
use alloc::alloc::{alloc, alloc_zeroed, dealloc, Layout};
use core::ffi::{c_int, c_void};

const USIZE_ALIGN: usize = core::mem::align_of::<usize>();
const USIZE_SIZE: usize = core::mem::size_of::<usize>();

#[no_mangle]
pub extern "C" fn rust_lz4_wasm_shim_malloc(size: usize) -> *mut c_void {
    wasm_shim_alloc::<false>(size)
}

#[no_mangle]
pub extern "C" fn rust_lz4_wasm_shim_memcmp(
    str1: *const c_void,
    str2: *const c_void,
    n: usize,
) -> i32 {
    // Safety: function contracts requires str1 and str2 at least `n`-long.
    unsafe {
        let str1: &[u8] = core::slice::from_raw_parts(str1 as *const u8, n);
        let str2: &[u8] = core::slice::from_raw_parts(str2 as *const u8, n);
        match str1.cmp(str2) {
            core::cmp::Ordering::Less => -1,
            core::cmp::Ordering::Equal => 0,
            core::cmp::Ordering::Greater => 1,
        }
    }
}

#[no_mangle]
pub extern "C" fn rust_lz4_wasm_shim_calloc(nmemb: usize, size: usize) -> *mut c_void {
    // note: calloc expects the allocation to be zeroed
    wasm_shim_alloc::<true>(nmemb * size)
}

#[inline]
fn wasm_shim_alloc<const ZEROED: bool>(size: usize) -> *mut c_void {
    // in order to recover the size upon free, we store the size below the allocation
    // special alignment is never requested via the malloc API,
    // so it's not stored, and usize-alignment is used
    // memory layout: [size] [allocation]

    let full_alloc_size = size + USIZE_SIZE;

    unsafe {
        let layout = Layout::from_size_align_unchecked(full_alloc_size, USIZE_ALIGN);

        let ptr = if ZEROED {
            alloc_zeroed(layout)
        } else {
            alloc(layout)
        };

        // SAFETY: ptr is usize-aligned and we've allocated sufficient memory
        ptr.cast::<usize>().write(full_alloc_size);

        ptr.add(USIZE_SIZE).cast()
    }
}

#[no_mangle]
pub unsafe extern "C" fn rust_lz4_wasm_shim_free(ptr: *mut c_void) {
    // the layout for the allocation needs to be recovered for dealloc
    // - the size must be recovered from directly below the allocation
    // - the alignment will always by USIZE_ALIGN

    let alloc_ptr = ptr.sub(USIZE_SIZE);
    // SAFETY: the allocation routines must uphold having a valid usize below the provided pointer
    let full_alloc_size = alloc_ptr.cast::<usize>().read();

    let layout = Layout::from_size_align_unchecked(full_alloc_size, USIZE_ALIGN);
    dealloc(alloc_ptr.cast(), layout);
}

#[no_mangle]
pub unsafe extern "C" fn rust_lz4_wasm_shim_memcpy(
    dest: *mut c_void,
    src: *const c_void,
    n: usize,
) -> *mut c_void {
    core::ptr::copy_nonoverlapping(src as *const u8, dest as *mut u8, n);
    dest
}

#[no_mangle]
pub unsafe extern "C" fn rust_lz4_wasm_shim_memmove(
    dest: *mut c_void,
    src: *const c_void,
    n: usize,
) -> *mut c_void {
    core::ptr::copy(src as *const u8, dest as *mut u8, n);
    dest
}

#[no_mangle]
pub unsafe extern "C" fn rust_lz4_wasm_shim_memset(
    dest: *mut c_void,
    c: c_int,
    n: usize,
) -> *mut c_void {
    core::ptr::write_bytes(dest as *mut u8, c as u8, n);
    dest
}

```

`native/src/external/xz-embedded/xz.h`:

```h
/*
 * XZ decompressor
 *
 * Authors: Lasse Collin <lasse.collin@tukaani.org>
 *          Igor Pavlov <http://7-zip.org/>
 *
 * This file has been put into the public domain.
 * You can do whatever you want with this file.
 */

#ifndef XZ_H
#define XZ_H

#ifdef __KERNEL__
#	include <linux/stddef.h>
#	include <linux/types.h>
#else
#	include <stddef.h>
#	include <stdint.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* In Linux, this is used to make extern functions static when needed. */
#ifndef XZ_EXTERN
#	define XZ_EXTERN extern
#endif

/**
 * enum xz_mode - Operation mode
 *
 * @XZ_SINGLE:              Single-call mode. This uses less RAM than
 *                          than multi-call modes, because the LZMA2
 *                          dictionary doesn't need to be allocated as
 *                          part of the decoder state. All required data
 *                          structures are allocated at initialization,
 *                          so xz_dec_run() cannot return XZ_MEM_ERROR.
 * @XZ_PREALLOC:            Multi-call mode with preallocated LZMA2
 *                          dictionary buffer. All data structures are
 *                          allocated at initialization, so xz_dec_run()
 *                          cannot return XZ_MEM_ERROR.
 * @XZ_DYNALLOC:            Multi-call mode. The LZMA2 dictionary is
 *                          allocated once the required size has been
 *                          parsed from the stream headers. If the
 *                          allocation fails, xz_dec_run() will return
 *                          XZ_MEM_ERROR.
 *
 * It is possible to enable support only for a subset of the above
 * modes at compile time by defining XZ_DEC_SINGLE, XZ_DEC_PREALLOC,
 * or XZ_DEC_DYNALLOC. The xz_dec kernel module is always compiled
 * with support for all operation modes, but the preboot code may
 * be built with fewer features to minimize code size.
 */
enum xz_mode {
    XZ_SINGLE,
    XZ_PREALLOC,
    XZ_DYNALLOC
};

/**
 * enum xz_ret - Return codes
 * @XZ_OK:                  Everything is OK so far. More input or more
 *                          output space is required to continue. This
 *                          return code is possible only in multi-call mode
 *                          (XZ_PREALLOC or XZ_DYNALLOC).
 * @XZ_STREAM_END:          Operation finished successfully.
 * @XZ_UNSUPPORTED_CHECK:   Integrity check type is not supported. Decoding
 *                          is still possible in multi-call mode by simply
 *                          calling xz_dec_run() again.
 *                          Note that this return value is used only if
 *                          XZ_DEC_ANY_CHECK was defined at build time,
 *                          which is not used in the kernel. Unsupported
 *                          check types return XZ_OPTIONS_ERROR if
 *                          XZ_DEC_ANY_CHECK was not defined at build time.
 * @XZ_MEM_ERROR:           Allocating memory failed. This return code is
 *                          possible only if the decoder was initialized
 *                          with XZ_DYNALLOC. The amount of memory that was
 *                          tried to be allocated was no more than the
 *                          dict_max argument given to xz_dec_init().
 * @XZ_MEMLIMIT_ERROR:      A bigger LZMA2 dictionary would be needed than
 *                          allowed by the dict_max argument given to
 *                          xz_dec_init(). This return value is possible
 *                          only in multi-call mode (XZ_PREALLOC or
 *                          XZ_DYNALLOC); the single-call mode (XZ_SINGLE)
 *                          ignores the dict_max argument.
 * @XZ_FORMAT_ERROR:        File format was not recognized (wrong magic
 *                          bytes).
 * @XZ_OPTIONS_ERROR:       This implementation doesn't support the requested
 *                          compression options. In the decoder this means
 *                          that the header CRC32 matches, but the header
 *                          itself specifies something that we don't support.
 * @XZ_DATA_ERROR:          Compressed data is corrupt.
 * @XZ_BUF_ERROR:           Cannot make any progress. Details are slightly
 *                          different between multi-call and single-call
 *                          mode; more information below.
 *
 * In multi-call mode, XZ_BUF_ERROR is returned when two consecutive calls
 * to XZ code cannot consume any input and cannot produce any new output.
 * This happens when there is no new input available, or the output buffer
 * is full while at least one output byte is still pending. Assuming your
 * code is not buggy, you can get this error only when decoding a compressed
 * stream that is truncated or otherwise corrupt.
 *
 * In single-call mode, XZ_BUF_ERROR is returned only when the output buffer
 * is too small or the compressed input is corrupt in a way that makes the
 * decoder produce more output than the caller expected. When it is
 * (relatively) clear that the compressed input is truncated, XZ_DATA_ERROR
 * is used instead of XZ_BUF_ERROR.
 */
enum xz_ret {
    XZ_OK,
    XZ_STREAM_END,
    XZ_UNSUPPORTED_CHECK,
    XZ_MEM_ERROR,
    XZ_MEMLIMIT_ERROR,
    XZ_FORMAT_ERROR,
    XZ_OPTIONS_ERROR,
    XZ_DATA_ERROR,
    XZ_BUF_ERROR
};

/**
 * struct xz_buf - Passing input and output buffers to XZ code
 * @in:         Beginning of the input buffer. This may be NULL if and only
 *              if in_pos is equal to in_size.
 * @in_pos:     Current position in the input buffer. This must not exceed
 *              in_size.
 * @in_size:    Size of the input buffer
 * @out:        Beginning of the output buffer. This may be NULL if and only
 *              if out_pos is equal to out_size.
 * @out_pos:    Current position in the output buffer. This must not exceed
 *              out_size.
 * @out_size:   Size of the output buffer
 *
 * Only the contents of the output buffer from out[out_pos] onward, and
 * the variables in_pos and out_pos are modified by the XZ code.
 */
struct xz_buf {
    const uint8_t *in;
    size_t in_pos;
    size_t in_size;

    uint8_t *out;
    size_t out_pos;
    size_t out_size;
};

/**
 * struct xz_dec - Opaque type to hold the XZ decoder state
 */
struct xz_dec;

/**
 * xz_dec_init() - Allocate and initialize a XZ decoder state
 * @mode:       Operation mode
 * @dict_max:   Maximum size of the LZMA2 dictionary (history buffer) for
 *              multi-call decoding. This is ignored in single-call mode
 *              (mode == XZ_SINGLE). LZMA2 dictionary is always 2^n bytes
 *              or 2^n + 2^(n-1) bytes (the latter sizes are less common
 *              in practice), so other values for dict_max don't make sense.
 *              In the kernel, dictionary sizes of 64 KiB, 128 KiB, 256 KiB,
 *              512 KiB, and 1 MiB are probably the only reasonable values,
 *              except for kernel and initramfs images where a bigger
 *              dictionary can be fine and useful.
 *
 * Single-call mode (XZ_SINGLE): xz_dec_run() decodes the whole stream at
 * once. The caller must provide enough output space or the decoding will
 * fail. The output space is used as the dictionary buffer, which is why
 * there is no need to allocate the dictionary as part of the decoder's
 * internal state.
 *
 * Because the output buffer is used as the workspace, streams encoded using
 * a big dictionary are not a problem in single-call mode. It is enough that
 * the output buffer is big enough to hold the actual uncompressed data; it
 * can be smaller than the dictionary size stored in the stream headers.
 *
 * Multi-call mode with preallocated dictionary (XZ_PREALLOC): dict_max bytes
 * of memory is preallocated for the LZMA2 dictionary. This way there is no
 * risk that xz_dec_run() could run out of memory, since xz_dec_run() will
 * never allocate any memory. Instead, if the preallocated dictionary is too
 * small for decoding the given input stream, xz_dec_run() will return
 * XZ_MEMLIMIT_ERROR. Thus, it is important to know what kind of data will be
 * decoded to avoid allocating excessive amount of memory for the dictionary.
 *
 * Multi-call mode with dynamically allocated dictionary (XZ_DYNALLOC):
 * dict_max specifies the maximum allowed dictionary size that xz_dec_run()
 * may allocate once it has parsed the dictionary size from the stream
 * headers. This way excessive allocations can be avoided while still
 * limiting the maximum memory usage to a sane value to prevent running the
 * system out of memory when decompressing streams from untrusted sources.
 *
 * On success, xz_dec_init() returns a pointer to struct xz_dec, which is
 * ready to be used with xz_dec_run(). If memory allocation fails,
 * xz_dec_init() returns NULL.
 */
XZ_EXTERN struct xz_dec *xz_dec_init(enum xz_mode mode, uint32_t dict_max);

/**
 * xz_dec_run() - Run the XZ decoder
 * @s:          Decoder state allocated using xz_dec_init()
 * @b:          Input and output buffers
 *
 * The possible return values depend on build options and operation mode.
 * See enum xz_ret for details.
 *
 * Note that if an error occurs in single-call mode (return value is not
 * XZ_STREAM_END), b->in_pos and b->out_pos are not modified and the
 * contents of the output buffer from b->out[b->out_pos] onward are
 * undefined. This is true even after XZ_BUF_ERROR, because with some filter
 * chains, there may be a second pass over the output buffer, and this pass
 * cannot be properly done if the output buffer is truncated. Thus, you
 * cannot give the single-call decoder a too small buffer and then expect to
 * get that amount valid data from the beginning of the stream. You must use
 * the multi-call decoder if you don't want to uncompress the whole stream.
 */
XZ_EXTERN enum xz_ret xz_dec_run(struct xz_dec *s, struct xz_buf *b);

/**
 * xz_dec_reset() - Reset an already allocated decoder state
 * @s:          Decoder state allocated using xz_dec_init()
 *
 * This function can be used to reset the multi-call decoder state without
 * freeing and reallocating memory with xz_dec_end() and xz_dec_init().
 *
 * In single-call mode, xz_dec_reset() is always called in the beginning of
 * xz_dec_run(). Thus, explicit call to xz_dec_reset() is useful only in
 * multi-call mode.
 */
XZ_EXTERN void xz_dec_reset(struct xz_dec *s);

/**
 * xz_dec_end() - Free the memory allocated for the decoder state
 * @s:          Decoder state allocated using xz_dec_init(). If s is NULL,
 *              this function does nothing.
 */
XZ_EXTERN void xz_dec_end(struct xz_dec *s);

/*
 * Standalone build (userspace build or in-kernel build for boot time use)
 * needs a CRC32 implementation. For normal in-kernel use, kernel's own
 * CRC32 module is used instead, and users of this module don't need to
 * care about the functions below.
 */
#ifndef XZ_INTERNAL_CRC32
#	ifdef __KERNEL__
#		define XZ_INTERNAL_CRC32 0
#	else
#		define XZ_INTERNAL_CRC32 1
#	endif
#endif

/*
 * If CRC64 support has been enabled with XZ_USE_CRC64, a CRC64
 * implementation is needed too.
 */
#ifndef XZ_USE_CRC64
#	undef XZ_INTERNAL_CRC64
#	define XZ_INTERNAL_CRC64 0
#endif
#ifndef XZ_INTERNAL_CRC64
#	ifdef __KERNEL__
#		error Using CRC64 in the kernel has not been implemented.
#	else
#		define XZ_INTERNAL_CRC64 1
#	endif
#endif

#if XZ_INTERNAL_CRC32
/*
 * This must be called before any other xz_* function to initialize
 * the CRC32 lookup table.
 */
XZ_EXTERN void xz_crc32_init(void);

/*
 * Update CRC32 value using the polynomial from IEEE-802.3. To start a new
 * calculation, the third argument must be zero. To continue the calculation,
 * the previously returned value is passed as the third argument.
 */
XZ_EXTERN uint32_t xz_crc32(const uint8_t *buf, size_t size, uint32_t crc);
#endif

#if XZ_INTERNAL_CRC64
/*
 * This must be called before any other xz_* function (except xz_crc32_init())
 * to initialize the CRC64 lookup table.
 */
XZ_EXTERN void xz_crc64_init(void);

/*
 * Update CRC64 value using the polynomial from ECMA-182. To start a new
 * calculation, the third argument must be zero. To continue the calculation,
 * the previously returned value is passed as the third argument.
 */
XZ_EXTERN uint64_t xz_crc64(const uint8_t *buf, size_t size, uint64_t crc);
#endif

#ifdef __cplusplus
}
#endif

#endif

```

`native/src/external/xz-embedded/xz_config.h`:

```h
/*
 * Private includes and definitions for userspace use of XZ Embedded
 *
 * Author: Lasse Collin <lasse.collin@tukaani.org>
 *
 * This file has been put into the public domain.
 * You can do whatever you want with this file.
 */

#ifndef XZ_CONFIG_H
#define XZ_CONFIG_H

/* Uncomment to enable CRC64 support. */
/* #define XZ_USE_CRC64 */

/* Uncomment as needed to enable BCJ filter decoders. */
/* #define XZ_DEC_X86 */
/* #define XZ_DEC_POWERPC */
/* #define XZ_DEC_IA64 */
/* #define XZ_DEC_ARM */
/* #define XZ_DEC_ARMTHUMB */
/* #define XZ_DEC_SPARC */

/*
 * MSVC doesn't support modern C but XZ Embedded is mostly C89
 * so these are enough.
 */
#ifdef _MSC_VER
typedef unsigned char bool;
#	define true 1
#	define false 0
#	define inline __inline
#else
#	include <stdbool.h>
#endif

#include <stdlib.h>
#include <string.h>

#include "xz.h"

#define kmalloc(size, flags) malloc(size)
#define kfree(ptr) free(ptr)
#define vmalloc(size) malloc(size)
#define vfree(ptr) free(ptr)

#define memeq(a, b, size) (memcmp(a, b, size) == 0)
#define memzero(buf, size) memset(buf, 0, size)

#ifndef min
#	define min(x, y) ((x) < (y) ? (x) : (y))
#endif
#define min_t(type, x, y) min(x, y)

/*
 * Some functions have been marked with __always_inline to keep the
 * performance reasonable even when the compiler is optimizing for
 * small code size. You may be able to save a few bytes by #defining
 * __always_inline to plain inline, but don't complain if the code
 * becomes slow.
 *
 * NOTE: System headers on GNU/Linux may #define this macro already,
 * so if you want to change it, you need to #undef it first.
 */
#ifndef __always_inline
#	ifdef __GNUC__
#		define __always_inline \
            inline __attribute__((__always_inline__))
#	else
#		define __always_inline inline
#	endif
#endif

/* Inline functions to access unaligned unsigned 32-bit integers */
#ifndef get_unaligned_le32
static inline uint32_t get_unaligned_le32(const uint8_t *buf)
{
    return (uint32_t)buf[0]
            | ((uint32_t)buf[1] << 8)
            | ((uint32_t)buf[2] << 16)
            | ((uint32_t)buf[3] << 24);
}
#endif

#ifndef get_unaligned_be32
static inline uint32_t get_unaligned_be32(const uint8_t *buf)
{
    return (uint32_t)(buf[0] << 24)
            | ((uint32_t)buf[1] << 16)
            | ((uint32_t)buf[2] << 8)
            | (uint32_t)buf[3];
}
#endif

#ifndef put_unaligned_le32
static inline void put_unaligned_le32(uint32_t val, uint8_t *buf)
{
    buf[0] = (uint8_t)val;
    buf[1] = (uint8_t)(val >> 8);
    buf[2] = (uint8_t)(val >> 16);
    buf[3] = (uint8_t)(val >> 24);
}
#endif

#ifndef put_unaligned_be32
static inline void put_unaligned_be32(uint32_t val, uint8_t *buf)
{
    buf[0] = (uint8_t)(val >> 24);
    buf[1] = (uint8_t)(val >> 16);
    buf[2] = (uint8_t)(val >> 8);
    buf[3] = (uint8_t)val;
}
#endif

/*
 * Use get_unaligned_le32() also for aligned access for simplicity. On
 * little endian systems, #define get_le32(ptr) (*(const uint32_t *)(ptr))
 * could save a few bytes in code size.
 */
#ifndef get_le32
#	define get_le32 get_unaligned_le32
#endif

#endif

```

`native/src/external/xz-embedded/xz_crc32.c`:

```c
/*
 * CRC32 using the polynomial from IEEE-802.3
 *
 * Authors: Lasse Collin <lasse.collin@tukaani.org>
 *          Igor Pavlov <http://7-zip.org/>
 *
 * This file has been put into the public domain.
 * You can do whatever you want with this file.
 */

/*
 * This is not the fastest implementation, but it is pretty compact.
 * The fastest versions of xz_crc32() on modern CPUs without hardware
 * accelerated CRC instruction are 3-5 times as fast as this version,
 * but they are bigger and use more memory for the lookup table.
 */

#include "xz_private.h"

/*
 * STATIC_RW_DATA is used in the pre-boot environment on some architectures.
 * See <linux/decompress/mm.h> for details.
 */
#ifndef STATIC_RW_DATA
#	define STATIC_RW_DATA static
#endif

STATIC_RW_DATA uint32_t xz_crc32_table[256];

XZ_EXTERN void xz_crc32_init(void)
{
    const uint32_t poly = 0xEDB88320;

    uint32_t i;
    uint32_t j;
    uint32_t r;

    for (i = 0; i < 256; ++i) {
        r = i;
        for (j = 0; j < 8; ++j)
            r = (r >> 1) ^ (poly & ~((r & 1) - 1));

        xz_crc32_table[i] = r;
    }

    return;
}

XZ_EXTERN uint32_t xz_crc32(const uint8_t *buf, size_t size, uint32_t crc)
{
    crc = ~crc;

    while (size != 0) {
        crc = xz_crc32_table[*buf++ ^ (crc & 0xFF)] ^ (crc >> 8);
        --size;
    }

    return ~crc;
}

```

`native/src/external/xz-embedded/xz_dec_lzma2.c`:

```c
/*
 * LZMA2 decoder
 *
 * Authors: Lasse Collin <lasse.collin@tukaani.org>
 *          Igor Pavlov <http://7-zip.org/>
 *
 * This file has been put into the public domain.
 * You can do whatever you want with this file.
 */

#include "xz_private.h"
#include "xz_lzma2.h"

/*
 * Range decoder initialization eats the first five bytes of each LZMA chunk.
 */
#define RC_INIT_BYTES 5

/*
 * Minimum number of usable input buffer to safely decode one LZMA symbol.
 * The worst case is that we decode 22 bits using probabilities and 26
 * direct bits. This may decode at maximum of 20 bytes of input. However,
 * lzma_main() does an extra normalization before returning, thus we
 * need to put 21 here.
 */
#define LZMA_IN_REQUIRED 21

/*
 * Dictionary (history buffer)
 *
 * These are always true:
 *    start <= pos <= full <= end
 *    pos <= limit <= end
 *
 * In multi-call mode, also these are true:
 *    end == size
 *    size <= size_max
 *    allocated <= size
 *
 * Most of these variables are size_t to support single-call mode,
 * in which the dictionary variables address the actual output
 * buffer directly.
 */
struct dictionary {
    /* Beginning of the history buffer */
    uint8_t *buf;

    /* Old position in buf (before decoding more data) */
    size_t start;

    /* Position in buf */
    size_t pos;

    /*
     * How full dictionary is. This is used to detect corrupt input that
     * would read beyond the beginning of the uncompressed stream.
     */
    size_t full;

    /* Write limit; we don't write to buf[limit] or later bytes. */
    size_t limit;

    /*
     * End of the dictionary buffer. In multi-call mode, this is
     * the same as the dictionary size. In single-call mode, this
     * indicates the size of the output buffer.
     */
    size_t end;

    /*
     * Size of the dictionary as specified in Block Header. This is used
     * together with "full" to detect corrupt input that would make us
     * read beyond the beginning of the uncompressed stream.
     */
    uint32_t size;

    /*
     * Maximum allowed dictionary size in multi-call mode.
     * This is ignored in single-call mode.
     */
    uint32_t size_max;

    /*
     * Amount of memory currently allocated for the dictionary.
     * This is used only with XZ_DYNALLOC. (With XZ_PREALLOC,
     * size_max is always the same as the allocated size.)
     */
    uint32_t allocated;

    /* Operation mode */
    enum xz_mode mode;
};

/* Range decoder */
struct rc_dec {
    uint32_t range;
    uint32_t code;

    /*
     * Number of initializing bytes remaining to be read
     * by rc_read_init().
     */
    uint32_t init_bytes_left;

    /*
     * Buffer from which we read our input. It can be either
     * temp.buf or the caller-provided input buffer.
     */
    const uint8_t *in;
    size_t in_pos;
    size_t in_limit;
};

/* Probabilities for a length decoder. */
struct lzma_len_dec {
    /* Probability of match length being at least 10 */
    uint16_t choice;

    /* Probability of match length being at least 18 */
    uint16_t choice2;

    /* Probabilities for match lengths 2-9 */
    uint16_t low[POS_STATES_MAX][LEN_LOW_SYMBOLS];

    /* Probabilities for match lengths 10-17 */
    uint16_t mid[POS_STATES_MAX][LEN_MID_SYMBOLS];

    /* Probabilities for match lengths 18-273 */
    uint16_t high[LEN_HIGH_SYMBOLS];
};

struct lzma_dec {
    /* Distances of latest four matches */
    uint32_t rep0;
    uint32_t rep1;
    uint32_t rep2;
    uint32_t rep3;

    /* Types of the most recently seen LZMA symbols */
    enum lzma_state state;

    /*
     * Length of a match. This is updated so that dict_repeat can
     * be called again to finish repeating the whole match.
     */
    uint32_t len;

    /*
     * LZMA properties or related bit masks (number of literal
     * context bits, a mask dervied from the number of literal
     * position bits, and a mask dervied from the number
     * position bits)
     */
    uint32_t lc;
    uint32_t literal_pos_mask; /* (1 << lp) - 1 */
    uint32_t pos_mask;         /* (1 << pb) - 1 */

    /* If 1, it's a match. Otherwise it's a single 8-bit literal. */
    uint16_t is_match[STATES][POS_STATES_MAX];

    /* If 1, it's a repeated match. The distance is one of rep0 .. rep3. */
    uint16_t is_rep[STATES];

    /*
     * If 0, distance of a repeated match is rep0.
     * Otherwise check is_rep1.
     */
    uint16_t is_rep0[STATES];

    /*
     * If 0, distance of a repeated match is rep1.
     * Otherwise check is_rep2.
     */
    uint16_t is_rep1[STATES];

    /* If 0, distance of a repeated match is rep2. Otherwise it is rep3. */
    uint16_t is_rep2[STATES];

    /*
     * If 1, the repeated match has length of one byte. Otherwise
     * the length is decoded from rep_len_decoder.
     */
    uint16_t is_rep0_long[STATES][POS_STATES_MAX];

    /*
     * Probability tree for the highest two bits of the match
     * distance. There is a separate probability tree for match
     * lengths of 2 (i.e. MATCH_LEN_MIN), 3, 4, and [5, 273].
     */
    uint16_t dist_slot[DIST_STATES][DIST_SLOTS];

    /*
     * Probility trees for additional bits for match distance
     * when the distance is in the range [4, 127].
     */
    uint16_t dist_special[FULL_DISTANCES - DIST_MODEL_END];

    /*
     * Probability tree for the lowest four bits of a match
     * distance that is equal to or greater than 128.
     */
    uint16_t dist_align[ALIGN_SIZE];

    /* Length of a normal match */
    struct lzma_len_dec match_len_dec;

    /* Length of a repeated match */
    struct lzma_len_dec rep_len_dec;

    /* Probabilities of literals */
    uint16_t literal[LITERAL_CODERS_MAX][LITERAL_CODER_SIZE];
};

struct lzma2_dec {
    /* Position in xz_dec_lzma2_run(). */
    enum lzma2_seq {
        SEQ_CONTROL,
        SEQ_UNCOMPRESSED_1,
        SEQ_UNCOMPRESSED_2,
        SEQ_COMPRESSED_0,
        SEQ_COMPRESSED_1,
        SEQ_PROPERTIES,
        SEQ_LZMA_PREPARE,
        SEQ_LZMA_RUN,
        SEQ_COPY
    } sequence;

    /* Next position after decoding the compressed size of the chunk. */
    enum lzma2_seq next_sequence;

    /* Uncompressed size of LZMA chunk (2 MiB at maximum) */
    uint32_t uncompressed;

    /*
     * Compressed size of LZMA chunk or compressed/uncompressed
     * size of uncompressed chunk (64 KiB at maximum)
     */
    uint32_t compressed;

    /*
     * True if dictionary reset is needed. This is false before
     * the first chunk (LZMA or uncompressed).
     */
    bool need_dict_reset;

    /*
     * True if new LZMA properties are needed. This is false
     * before the first LZMA chunk.
     */
    bool need_props;
};

struct xz_dec_lzma2 {
    /*
     * The order below is important on x86 to reduce code size and
     * it shouldn't hurt on other platforms. Everything up to and
     * including lzma.pos_mask are in the first 128 bytes on x86-32,
     * which allows using smaller instructions to access those
     * variables. On x86-64, fewer variables fit into the first 128
     * bytes, but this is still the best order without sacrificing
     * the readability by splitting the structures.
     */
    struct rc_dec rc;
    struct dictionary dict;
    struct lzma2_dec lzma2;
    struct lzma_dec lzma;

    /*
     * Temporary buffer which holds small number of input bytes between
     * decoder calls. See lzma2_lzma() for details.
     */
    struct {
        uint32_t size;
        uint8_t buf[3 * LZMA_IN_REQUIRED];
    } temp;
};

/**************
 * Dictionary *
 **************/

/*
 * Reset the dictionary state. When in single-call mode, set up the beginning
 * of the dictionary to point to the actual output buffer.
 */
static void dict_reset(struct dictionary *dict, struct xz_buf *b)
{
    if (DEC_IS_SINGLE(dict->mode)) {
        dict->buf = b->out + b->out_pos;
        dict->end = b->out_size - b->out_pos;
    }

    dict->start = 0;
    dict->pos = 0;
    dict->limit = 0;
    dict->full = 0;
}

/* Set dictionary write limit */
static void dict_limit(struct dictionary *dict, size_t out_max)
{
    if (dict->end - dict->pos <= out_max)
        dict->limit = dict->end;
    else
        dict->limit = dict->pos + out_max;
}

/* Return true if at least one byte can be written into the dictionary. */
static inline bool dict_has_space(const struct dictionary *dict)
{
    return dict->pos < dict->limit;
}

/*
 * Get a byte from the dictionary at the given distance. The distance is
 * assumed to valid, or as a special case, zero when the dictionary is
 * still empty. This special case is needed for single-call decoding to
 * avoid writing a '\0' to the end of the destination buffer.
 */
static inline uint32_t dict_get(const struct dictionary *dict, uint32_t dist)
{
    size_t offset = dict->pos - dist - 1;

    if (dist >= dict->pos)
        offset += dict->end;

    return dict->full > 0 ? dict->buf[offset] : 0;
}

/*
 * Put one byte into the dictionary. It is assumed that there is space for it.
 */
static inline void dict_put(struct dictionary *dict, uint8_t byte)
{
    dict->buf[dict->pos++] = byte;

    if (dict->full < dict->pos)
        dict->full = dict->pos;
}

/*
 * Repeat given number of bytes from the given distance. If the distance is
 * invalid, false is returned. On success, true is returned and *len is
 * updated to indicate how many bytes were left to be repeated.
 */
static bool dict_repeat(struct dictionary *dict, uint32_t *len, uint32_t dist)
{
    size_t back;
    uint32_t left;

    if (dist >= dict->full || dist >= dict->size)
        return false;

    left = min_t(size_t, dict->limit - dict->pos, *len);
    *len -= left;

    back = dict->pos - dist - 1;
    if (dist >= dict->pos)
        back += dict->end;

    do {
        dict->buf[dict->pos++] = dict->buf[back++];
        if (back == dict->end)
            back = 0;
    } while (--left > 0);

    if (dict->full < dict->pos)
        dict->full = dict->pos;

    return true;
}

/* Copy uncompressed data as is from input to dictionary and output buffers. */
static void dict_uncompressed(struct dictionary *dict, struct xz_buf *b,
                  uint32_t *left)
{
    size_t copy_size;

    while (*left > 0 && b->in_pos < b->in_size
            && b->out_pos < b->out_size) {
        copy_size = min(b->in_size - b->in_pos,
                b->out_size - b->out_pos);
        if (copy_size > dict->end - dict->pos)
            copy_size = dict->end - dict->pos;
        if (copy_size > *left)
            copy_size = *left;

        *left -= copy_size;

        memcpy(dict->buf + dict->pos, b->in + b->in_pos, copy_size);
        dict->pos += copy_size;

        if (dict->full < dict->pos)
            dict->full = dict->pos;

        if (DEC_IS_MULTI(dict->mode)) {
            if (dict->pos == dict->end)
                dict->pos = 0;

            memcpy(b->out + b->out_pos, b->in + b->in_pos,
                    copy_size);
        }

        dict->start = dict->pos;

        b->out_pos += copy_size;
        b->in_pos += copy_size;
    }
}

/*
 * Flush pending data from dictionary to b->out. It is assumed that there is
 * enough space in b->out. This is guaranteed because caller uses dict_limit()
 * before decoding data into the dictionary.
 */
static uint32_t dict_flush(struct dictionary *dict, struct xz_buf *b)
{
    size_t copy_size = dict->pos - dict->start;

    if (DEC_IS_MULTI(dict->mode)) {
        if (dict->pos == dict->end)
            dict->pos = 0;

        memcpy(b->out + b->out_pos, dict->buf + dict->start,
                copy_size);
    }

    dict->start = dict->pos;
    b->out_pos += copy_size;
    return copy_size;
}

/*****************
 * Range decoder *
 *****************/

/* Reset the range decoder. */
static void rc_reset(struct rc_dec *rc)
{
    rc->range = (uint32_t)-1;
    rc->code = 0;
    rc->init_bytes_left = RC_INIT_BYTES;
}

/*
 * Read the first five initial bytes into rc->code if they haven't been
 * read already. (Yes, the first byte gets completely ignored.)
 */
static bool rc_read_init(struct rc_dec *rc, struct xz_buf *b)
{
    while (rc->init_bytes_left > 0) {
        if (b->in_pos == b->in_size)
            return false;

        rc->code = (rc->code << 8) + b->in[b->in_pos++];
        --rc->init_bytes_left;
    }

    return true;
}

/* Return true if there may not be enough input for the next decoding loop. */
static inline bool rc_limit_exceeded(const struct rc_dec *rc)
{
    return rc->in_pos > rc->in_limit;
}

/*
 * Return true if it is possible (from point of view of range decoder) that
 * we have reached the end of the LZMA chunk.
 */
static inline bool rc_is_finished(const struct rc_dec *rc)
{
    return rc->code == 0;
}

/* Read the next input byte if needed. */
static __always_inline void rc_normalize(struct rc_dec *rc)
{
    if (rc->range < RC_TOP_VALUE) {
        rc->range <<= RC_SHIFT_BITS;
        rc->code = (rc->code << RC_SHIFT_BITS) + rc->in[rc->in_pos++];
    }
}

/*
 * Decode one bit. In some versions, this function has been splitted in three
 * functions so that the compiler is supposed to be able to more easily avoid
 * an extra branch. In this particular version of the LZMA decoder, this
 * doesn't seem to be a good idea (tested with GCC 3.3.6, 3.4.6, and 4.3.3
 * on x86). Using a non-splitted version results in nicer looking code too.
 *
 * NOTE: This must return an int. Do not make it return a bool or the speed
 * of the code generated by GCC 3.x decreases 10-15 %. (GCC 4.3 doesn't care,
 * and it generates 10-20 % faster code than GCC 3.x from this file anyway.)
 */
static __always_inline int rc_bit(struct rc_dec *rc, uint16_t *prob)
{
    uint32_t bound;
    int bit;

    rc_normalize(rc);
    bound = (rc->range >> RC_BIT_MODEL_TOTAL_BITS) * *prob;
    if (rc->code < bound) {
        rc->range = bound;
        *prob += (RC_BIT_MODEL_TOTAL - *prob) >> RC_MOVE_BITS;
        bit = 0;
    } else {
        rc->range -= bound;
        rc->code -= bound;
        *prob -= *prob >> RC_MOVE_BITS;
        bit = 1;
    }

    return bit;
}

/* Decode a bittree starting from the most significant bit. */
static __always_inline uint32_t rc_bittree(struct rc_dec *rc,
                       uint16_t *probs, uint32_t limit)
{
    uint32_t symbol = 1;

    do {
        if (rc_bit(rc, &probs[symbol]))
            symbol = (symbol << 1) + 1;
        else
            symbol <<= 1;
    } while (symbol < limit);

    return symbol;
}

/* Decode a bittree starting from the least significant bit. */
static __always_inline void rc_bittree_reverse(struct rc_dec *rc,
                           uint16_t *probs,
                           uint32_t *dest, uint32_t limit)
{
    uint32_t symbol = 1;
    uint32_t i = 0;

    do {
        if (rc_bit(rc, &probs[symbol])) {
            symbol = (symbol << 1) + 1;
            *dest += 1 << i;
        } else {
            symbol <<= 1;
        }
    } while (++i < limit);
}

/* Decode direct bits (fixed fifty-fifty probability) */
static inline void rc_direct(struct rc_dec *rc, uint32_t *dest, uint32_t limit)
{
    uint32_t mask;

    do {
        rc_normalize(rc);
        rc->range >>= 1;
        rc->code -= rc->range;
        mask = (uint32_t)0 - (rc->code >> 31);
        rc->code += rc->range & mask;
        *dest = (*dest << 1) + (mask + 1);
    } while (--limit > 0);
}

/********
 * LZMA *
 ********/

/* Get pointer to literal coder probability array. */
static uint16_t *lzma_literal_probs(struct xz_dec_lzma2 *s)
{
    uint32_t prev_byte = dict_get(&s->dict, 0);
    uint32_t low = prev_byte >> (8 - s->lzma.lc);
    uint32_t high = (s->dict.pos & s->lzma.literal_pos_mask) << s->lzma.lc;
    return s->lzma.literal[low + high];
}

/* Decode a literal (one 8-bit byte) */
static void lzma_literal(struct xz_dec_lzma2 *s)
{
    uint16_t *probs;
    uint32_t symbol;
    uint32_t match_byte;
    uint32_t match_bit;
    uint32_t offset;
    uint32_t i;

    probs = lzma_literal_probs(s);

    if (lzma_state_is_literal(s->lzma.state)) {
        symbol = rc_bittree(&s->rc, probs, 0x100);
    } else {
        symbol = 1;
        match_byte = dict_get(&s->dict, s->lzma.rep0) << 1;
        offset = 0x100;

        do {
            match_bit = match_byte & offset;
            match_byte <<= 1;
            i = offset + match_bit + symbol;

            if (rc_bit(&s->rc, &probs[i])) {
                symbol = (symbol << 1) + 1;
                offset &= match_bit;
            } else {
                symbol <<= 1;
                offset &= ~match_bit;
            }
        } while (symbol < 0x100);
    }

    dict_put(&s->dict, (uint8_t)symbol);
    lzma_state_literal(&s->lzma.state);
}

/* Decode the length of the match into s->lzma.len. */
static void lzma_len(struct xz_dec_lzma2 *s, struct lzma_len_dec *l,
             uint32_t pos_state)
{
    uint16_t *probs;
    uint32_t limit;

    if (!rc_bit(&s->rc, &l->choice)) {
        probs = l->low[pos_state];
        limit = LEN_LOW_SYMBOLS;
        s->lzma.len = MATCH_LEN_MIN;
    } else {
        if (!rc_bit(&s->rc, &l->choice2)) {
            probs = l->mid[pos_state];
            limit = LEN_MID_SYMBOLS;
            s->lzma.len = MATCH_LEN_MIN + LEN_LOW_SYMBOLS;
        } else {
            probs = l->high;
            limit = LEN_HIGH_SYMBOLS;
            s->lzma.len = MATCH_LEN_MIN + LEN_LOW_SYMBOLS
                    + LEN_MID_SYMBOLS;
        }
    }

    s->lzma.len += rc_bittree(&s->rc, probs, limit) - limit;
}

/* Decode a match. The distance will be stored in s->lzma.rep0. */
static void lzma_match(struct xz_dec_lzma2 *s, uint32_t pos_state)
{
    uint16_t *probs;
    uint32_t dist_slot;
    uint32_t limit;

    lzma_state_match(&s->lzma.state);

    s->lzma.rep3 = s->lzma.rep2;
    s->lzma.rep2 = s->lzma.rep1;
    s->lzma.rep1 = s->lzma.rep0;

    lzma_len(s, &s->lzma.match_len_dec, pos_state);

    probs = s->lzma.dist_slot[lzma_get_dist_state(s->lzma.len)];
    dist_slot = rc_bittree(&s->rc, probs, DIST_SLOTS) - DIST_SLOTS;

    if (dist_slot < DIST_MODEL_START) {
        s->lzma.rep0 = dist_slot;
    } else {
        limit = (dist_slot >> 1) - 1;
        s->lzma.rep0 = 2 + (dist_slot & 1);

        if (dist_slot < DIST_MODEL_END) {
            s->lzma.rep0 <<= limit;
            probs = s->lzma.dist_special + s->lzma.rep0
                    - dist_slot - 1;
            rc_bittree_reverse(&s->rc, probs,
                    &s->lzma.rep0, limit);
        } else {
            rc_direct(&s->rc, &s->lzma.rep0, limit - ALIGN_BITS);
            s->lzma.rep0 <<= ALIGN_BITS;
            rc_bittree_reverse(&s->rc, s->lzma.dist_align,
                    &s->lzma.rep0, ALIGN_BITS);
        }
    }
}

/*
 * Decode a repeated match. The distance is one of the four most recently
 * seen matches. The distance will be stored in s->lzma.rep0.
 */
static void lzma_rep_match(struct xz_dec_lzma2 *s, uint32_t pos_state)
{
    uint32_t tmp;

    if (!rc_bit(&s->rc, &s->lzma.is_rep0[s->lzma.state])) {
        if (!rc_bit(&s->rc, &s->lzma.is_rep0_long[
                s->lzma.state][pos_state])) {
            lzma_state_short_rep(&s->lzma.state);
            s->lzma.len = 1;
            return;
        }
    } else {
        if (!rc_bit(&s->rc, &s->lzma.is_rep1[s->lzma.state])) {
            tmp = s->lzma.rep1;
        } else {
            if (!rc_bit(&s->rc, &s->lzma.is_rep2[s->lzma.state])) {
                tmp = s->lzma.rep2;
            } else {
                tmp = s->lzma.rep3;
                s->lzma.rep3 = s->lzma.rep2;
            }

            s->lzma.rep2 = s->lzma.rep1;
        }

        s->lzma.rep1 = s->lzma.rep0;
        s->lzma.rep0 = tmp;
    }

    lzma_state_long_rep(&s->lzma.state);
    lzma_len(s, &s->lzma.rep_len_dec, pos_state);
}

/* LZMA decoder core */
static bool lzma_main(struct xz_dec_lzma2 *s)
{
    uint32_t pos_state;

    /*
     * If the dictionary was reached during the previous call, try to
     * finish the possibly pending repeat in the dictionary.
     */
    if (dict_has_space(&s->dict) && s->lzma.len > 0)
        dict_repeat(&s->dict, &s->lzma.len, s->lzma.rep0);

    /*
     * Decode more LZMA symbols. One iteration may consume up to
     * LZMA_IN_REQUIRED - 1 bytes.
     */
    while (dict_has_space(&s->dict) && !rc_limit_exceeded(&s->rc)) {
        pos_state = s->dict.pos & s->lzma.pos_mask;

        if (!rc_bit(&s->rc, &s->lzma.is_match[
                s->lzma.state][pos_state])) {
            lzma_literal(s);
        } else {
            if (rc_bit(&s->rc, &s->lzma.is_rep[s->lzma.state]))
                lzma_rep_match(s, pos_state);
            else
                lzma_match(s, pos_state);

            if (!dict_repeat(&s->dict, &s->lzma.len, s->lzma.rep0))
                return false;
        }
    }

    /*
     * Having the range decoder always normalized when we are outside
     * this function makes it easier to correctly handle end of the chunk.
     */
    rc_normalize(&s->rc);

    return true;
}

/*
 * Reset the LZMA decoder and range decoder state. Dictionary is nore reset
 * here, because LZMA state may be reset without resetting the dictionary.
 */
static void lzma_reset(struct xz_dec_lzma2 *s)
{
    uint16_t *probs;
    size_t i;

    s->lzma.state = STATE_LIT_LIT;
    s->lzma.rep0 = 0;
    s->lzma.rep1 = 0;
    s->lzma.rep2 = 0;
    s->lzma.rep3 = 0;

    /*
     * All probabilities are initialized to the same value. This hack
     * makes the code smaller by avoiding a separate loop for each
     * probability array.
     *
     * This could be optimized so that only that part of literal
     * probabilities that are actually required. In the common case
     * we would write 12 KiB less.
     */
    probs = s->lzma.is_match[0];
    for (i = 0; i < PROBS_TOTAL; ++i)
        probs[i] = RC_BIT_MODEL_TOTAL / 2;

    rc_reset(&s->rc);
}

/*
 * Decode and validate LZMA properties (lc/lp/pb) and calculate the bit masks
 * from the decoded lp and pb values. On success, the LZMA decoder state is
 * reset and true is returned.
 */
static bool lzma_props(struct xz_dec_lzma2 *s, uint8_t props)
{
    if (props > (4 * 5 + 4) * 9 + 8)
        return false;

    s->lzma.pos_mask = 0;
    while (props >= 9 * 5) {
        props -= 9 * 5;
        ++s->lzma.pos_mask;
    }

    s->lzma.pos_mask = (1 << s->lzma.pos_mask) - 1;

    s->lzma.literal_pos_mask = 0;
    while (props >= 9) {
        props -= 9;
        ++s->lzma.literal_pos_mask;
    }

    s->lzma.lc = props;

    if (s->lzma.lc + s->lzma.literal_pos_mask > 4)
        return false;

    s->lzma.literal_pos_mask = (1 << s->lzma.literal_pos_mask) - 1;

    lzma_reset(s);

    return true;
}

/*********
 * LZMA2 *
 *********/

/*
 * The LZMA decoder assumes that if the input limit (s->rc.in_limit) hasn't
 * been exceeded, it is safe to read up to LZMA_IN_REQUIRED bytes. This
 * wrapper function takes care of making the LZMA decoder's assumption safe.
 *
 * As long as there is plenty of input left to be decoded in the current LZMA
 * chunk, we decode directly from the caller-supplied input buffer until
 * there's LZMA_IN_REQUIRED bytes left. Those remaining bytes are copied into
 * s->temp.buf, which (hopefully) gets filled on the next call to this
 * function. We decode a few bytes from the temporary buffer so that we can
 * continue decoding from the caller-supplied input buffer again.
 */
static bool lzma2_lzma(struct xz_dec_lzma2 *s, struct xz_buf *b)
{
    size_t in_avail;
    uint32_t tmp;

    in_avail = b->in_size - b->in_pos;
    if (s->temp.size > 0 || s->lzma2.compressed == 0) {
        tmp = 2 * LZMA_IN_REQUIRED - s->temp.size;
        if (tmp > s->lzma2.compressed - s->temp.size)
            tmp = s->lzma2.compressed - s->temp.size;
        if (tmp > in_avail)
            tmp = in_avail;

        memcpy(s->temp.buf + s->temp.size, b->in + b->in_pos, tmp);

        if (s->temp.size + tmp == s->lzma2.compressed) {
            memzero(s->temp.buf + s->temp.size + tmp,
                    sizeof(s->temp.buf)
                        - s->temp.size - tmp);
            s->rc.in_limit = s->temp.size + tmp;
        } else if (s->temp.size + tmp < LZMA_IN_REQUIRED) {
            s->temp.size += tmp;
            b->in_pos += tmp;
            return true;
        } else {
            s->rc.in_limit = s->temp.size + tmp - LZMA_IN_REQUIRED;
        }

        s->rc.in = s->temp.buf;
        s->rc.in_pos = 0;

        if (!lzma_main(s) || s->rc.in_pos > s->temp.size + tmp)
            return false;

        s->lzma2.compressed -= s->rc.in_pos;

        if (s->rc.in_pos < s->temp.size) {
            s->temp.size -= s->rc.in_pos;
            memmove(s->temp.buf, s->temp.buf + s->rc.in_pos,
                    s->temp.size);
            return true;
        }

        b->in_pos += s->rc.in_pos - s->temp.size;
        s->temp.size = 0;
    }

    in_avail = b->in_size - b->in_pos;
    if (in_avail >= LZMA_IN_REQUIRED) {
        s->rc.in = b->in;
        s->rc.in_pos = b->in_pos;

        if (in_avail >= s->lzma2.compressed + LZMA_IN_REQUIRED)
            s->rc.in_limit = b->in_pos + s->lzma2.compressed;
        else
            s->rc.in_limit = b->in_size - LZMA_IN_REQUIRED;

        if (!lzma_main(s))
            return false;

        in_avail = s->rc.in_pos - b->in_pos;
        if (in_avail > s->lzma2.compressed)
            return false;

        s->lzma2.compressed -= in_avail;
        b->in_pos = s->rc.in_pos;
    }

    in_avail = b->in_size - b->in_pos;
    if (in_avail < LZMA_IN_REQUIRED) {
        if (in_avail > s->lzma2.compressed)
            in_avail = s->lzma2.compressed;

        memcpy(s->temp.buf, b->in + b->in_pos, in_avail);
        s->temp.size = in_avail;
        b->in_pos += in_avail;
    }

    return true;
}

/*
 * Take care of the LZMA2 control layer, and forward the job of actual LZMA
 * decoding or copying of uncompressed chunks to other functions.
 */
XZ_EXTERN enum xz_ret xz_dec_lzma2_run(struct xz_dec_lzma2 *s,
                       struct xz_buf *b)
{
    uint32_t tmp;

    while (b->in_pos < b->in_size || s->lzma2.sequence == SEQ_LZMA_RUN) {
        switch (s->lzma2.sequence) {
        case SEQ_CONTROL:
            /*
             * LZMA2 control byte
             *
             * Exact values:
             *   0x00   End marker
             *   0x01   Dictionary reset followed by
             *          an uncompressed chunk
             *   0x02   Uncompressed chunk (no dictionary reset)
             *
             * Highest three bits (s->control & 0xE0):
             *   0xE0   Dictionary reset, new properties and state
             *          reset, followed by LZMA compressed chunk
             *   0xC0   New properties and state reset, followed
             *          by LZMA compressed chunk (no dictionary
             *          reset)
             *   0xA0   State reset using old properties,
             *          followed by LZMA compressed chunk (no
             *          dictionary reset)
             *   0x80   LZMA chunk (no dictionary or state reset)
             *
             * For LZMA compressed chunks, the lowest five bits
             * (s->control & 1F) are the highest bits of the
             * uncompressed size (bits 16-20).
             *
             * A new LZMA2 stream must begin with a dictionary
             * reset. The first LZMA chunk must set new
             * properties and reset the LZMA state.
             *
             * Values that don't match anything described above
             * are invalid and we return XZ_DATA_ERROR.
             */
            tmp = b->in[b->in_pos++];

            if (tmp == 0x00)
                return XZ_STREAM_END;

            if (tmp >= 0xE0 || tmp == 0x01) {
                s->lzma2.need_props = true;
                s->lzma2.need_dict_reset = false;
                dict_reset(&s->dict, b);
            } else if (s->lzma2.need_dict_reset) {
                return XZ_DATA_ERROR;
            }

            if (tmp >= 0x80) {
                s->lzma2.uncompressed = (tmp & 0x1F) << 16;
                s->lzma2.sequence = SEQ_UNCOMPRESSED_1;

                if (tmp >= 0xC0) {
                    /*
                     * When there are new properties,
                     * state reset is done at
                     * SEQ_PROPERTIES.
                     */
                    s->lzma2.need_props = false;
                    s->lzma2.next_sequence
                            = SEQ_PROPERTIES;

                } else if (s->lzma2.need_props) {
                    return XZ_DATA_ERROR;

                } else {
                    s->lzma2.next_sequence
                            = SEQ_LZMA_PREPARE;
                    if (tmp >= 0xA0)
                        lzma_reset(s);
                }
            } else {
                if (tmp > 0x02)
                    return XZ_DATA_ERROR;

                s->lzma2.sequence = SEQ_COMPRESSED_0;
                s->lzma2.next_sequence = SEQ_COPY;
            }

            break;

        case SEQ_UNCOMPRESSED_1:
            s->lzma2.uncompressed
                    += (uint32_t)b->in[b->in_pos++] << 8;
            s->lzma2.sequence = SEQ_UNCOMPRESSED_2;
            break;

        case SEQ_UNCOMPRESSED_2:
            s->lzma2.uncompressed
                    += (uint32_t)b->in[b->in_pos++] + 1;
            s->lzma2.sequence = SEQ_COMPRESSED_0;
            break;

        case SEQ_COMPRESSED_0:
            s->lzma2.compressed
                    = (uint32_t)b->in[b->in_pos++] << 8;
            s->lzma2.sequence = SEQ_COMPRESSED_1;
            break;

        case SEQ_COMPRESSED_1:
            s->lzma2.compressed
                    += (uint32_t)b->in[b->in_pos++] + 1;
            s->lzma2.sequence = s->lzma2.next_sequence;
            break;

        case SEQ_PROPERTIES:
            if (!lzma_props(s, b->in[b->in_pos++]))
                return XZ_DATA_ERROR;

            s->lzma2.sequence = SEQ_LZMA_PREPARE;

        case SEQ_LZMA_PREPARE:
            if (s->lzma2.compressed < RC_INIT_BYTES)
                return XZ_DATA_ERROR;

            if (!rc_read_init(&s->rc, b))
                return XZ_OK;

            s->lzma2.compressed -= RC_INIT_BYTES;
            s->lzma2.sequence = SEQ_LZMA_RUN;

        case SEQ_LZMA_RUN:
            /*
             * Set dictionary limit to indicate how much we want
             * to be encoded at maximum. Decode new data into the
             * dictionary. Flush the new data from dictionary to
             * b->out. Check if we finished decoding this chunk.
             * In case the dictionary got full but we didn't fill
             * the output buffer yet, we may run this loop
             * multiple times without changing s->lzma2.sequence.
             */
            dict_limit(&s->dict, min_t(size_t,
                    b->out_size - b->out_pos,
                    s->lzma2.uncompressed));
            if (!lzma2_lzma(s, b))
                return XZ_DATA_ERROR;

            s->lzma2.uncompressed -= dict_flush(&s->dict, b);

            if (s->lzma2.uncompressed == 0) {
                if (s->lzma2.compressed > 0 || s->lzma.len > 0
                        || !rc_is_finished(&s->rc))
                    return XZ_DATA_ERROR;

                rc_reset(&s->rc);
                s->lzma2.sequence = SEQ_CONTROL;

            } else if (b->out_pos == b->out_size
                    || (b->in_pos == b->in_size
                        && s->temp.size
                        < s->lzma2.compressed)) {
                return XZ_OK;
            }

            break;

        case SEQ_COPY:
            dict_uncompressed(&s->dict, b, &s->lzma2.compressed);
            if (s->lzma2.compressed > 0)
                return XZ_OK;

            s->lzma2.sequence = SEQ_CONTROL;
            break;
        }
    }

    return XZ_OK;
}

XZ_EXTERN struct xz_dec_lzma2 *xz_dec_lzma2_create(enum xz_mode mode,
                           uint32_t dict_max)
{
    struct xz_dec_lzma2 *s = kmalloc(sizeof(*s), GFP_KERNEL);
    if (s == NULL)
        return NULL;

    s->dict.mode = mode;
    s->dict.size_max = dict_max;

    if (DEC_IS_PREALLOC(mode)) {
        s->dict.buf = vmalloc(dict_max);
        if (s->dict.buf == NULL) {
            kfree(s);
            return NULL;
        }
    } else if (DEC_IS_DYNALLOC(mode)) {
        s->dict.buf = NULL;
        s->dict.allocated = 0;
    }

    return s;
}

XZ_EXTERN enum xz_ret xz_dec_lzma2_reset(struct xz_dec_lzma2 *s, uint8_t props)
{
    /* This limits dictionary size to 3 GiB to keep parsing simpler. */
    if (props > 39)
        return XZ_OPTIONS_ERROR;

    s->dict.size = 2 + (props & 1);
    s->dict.size <<= (props >> 1) + 11;

    if (DEC_IS_MULTI(s->dict.mode)) {
        if (s->dict.size > s->dict.size_max)
            return XZ_MEMLIMIT_ERROR;

        s->dict.end = s->dict.size;

        if (DEC_IS_DYNALLOC(s->dict.mode)) {
            if (s->dict.allocated < s->dict.size) {
                vfree(s->dict.buf);
                s->dict.buf = vmalloc(s->dict.size);
                if (s->dict.buf == NULL) {
                    s->dict.allocated = 0;
                    return XZ_MEM_ERROR;
                }
            }
        }
    }

    s->lzma.len = 0;

    s->lzma2.sequence = SEQ_CONTROL;
    s->lzma2.need_dict_reset = true;

    s->temp.size = 0;

    return XZ_OK;
}

XZ_EXTERN void xz_dec_lzma2_end(struct xz_dec_lzma2 *s)
{
    if (DEC_IS_MULTI(s->dict.mode))
        vfree(s->dict.buf);

    kfree(s);
}

```

`native/src/external/xz-embedded/xz_dec_stream.c`:

```c
/*
 * .xz Stream decoder
 *
 * Author: Lasse Collin <lasse.collin@tukaani.org>
 *
 * This file has been put into the public domain.
 * You can do whatever you want with this file.
 */

#include "xz_private.h"
#include "xz_stream.h"

#ifdef XZ_USE_CRC64
#	define IS_CRC64(check_type) ((check_type) == XZ_CHECK_CRC64)
#else
#	define IS_CRC64(check_type) false
#endif

/* Hash used to validate the Index field */
struct xz_dec_hash {
    vli_type unpadded;
    vli_type uncompressed;
    uint32_t crc32;
};

struct xz_dec {
    /* Position in dec_main() */
    enum {
        SEQ_STREAM_HEADER,
        SEQ_BLOCK_START,
        SEQ_BLOCK_HEADER,
        SEQ_BLOCK_UNCOMPRESS,
        SEQ_BLOCK_PADDING,
        SEQ_BLOCK_CHECK,
        SEQ_INDEX,
        SEQ_INDEX_PADDING,
        SEQ_INDEX_CRC32,
        SEQ_STREAM_FOOTER
    } sequence;

    /* Position in variable-length integers and Check fields */
    uint32_t pos;

    /* Variable-length integer decoded by dec_vli() */
    vli_type vli;

    /* Saved in_pos and out_pos */
    size_t in_start;
    size_t out_start;

#ifdef XZ_USE_CRC64
    /* CRC32 or CRC64 value in Block or CRC32 value in Index */
    uint64_t crc;
#else
    /* CRC32 value in Block or Index */
    uint32_t crc;
#endif

    /* Type of the integrity check calculated from uncompressed data */
    enum xz_check check_type;

    /* Operation mode */
    enum xz_mode mode;

    /*
     * True if the next call to xz_dec_run() is allowed to return
     * XZ_BUF_ERROR.
     */
    bool allow_buf_error;

    /* Information stored in Block Header */
    struct {
        /*
         * Value stored in the Compressed Size field, or
         * VLI_UNKNOWN if Compressed Size is not present.
         */
        vli_type compressed;

        /*
         * Value stored in the Uncompressed Size field, or
         * VLI_UNKNOWN if Uncompressed Size is not present.
         */
        vli_type uncompressed;

        /* Size of the Block Header field */
        uint32_t size;
    } block_header;

    /* Information collected when decoding Blocks */
    struct {
        /* Observed compressed size of the current Block */
        vli_type compressed;

        /* Observed uncompressed size of the current Block */
        vli_type uncompressed;

        /* Number of Blocks decoded so far */
        vli_type count;

        /*
         * Hash calculated from the Block sizes. This is used to
         * validate the Index field.
         */
        struct xz_dec_hash hash;
    } block;

    /* Variables needed when verifying the Index field */
    struct {
        /* Position in dec_index() */
        enum {
            SEQ_INDEX_COUNT,
            SEQ_INDEX_UNPADDED,
            SEQ_INDEX_UNCOMPRESSED
        } sequence;

        /* Size of the Index in bytes */
        vli_type size;

        /* Number of Records (matches block.count in valid files) */
        vli_type count;

        /*
         * Hash calculated from the Records (matches block.hash in
         * valid files).
         */
        struct xz_dec_hash hash;
    } index;

    /*
     * Temporary buffer needed to hold Stream Header, Block Header,
     * and Stream Footer. The Block Header is the biggest (1 KiB)
     * so we reserve space according to that. buf[] has to be aligned
     * to a multiple of four bytes; the size_t variables before it
     * should guarantee this.
     */
    struct {
        size_t pos;
        size_t size;
        uint8_t buf[1024];
    } temp;

    struct xz_dec_lzma2 *lzma2;

#ifdef XZ_DEC_BCJ
    struct xz_dec_bcj *bcj;
    bool bcj_active;
#endif
};

#ifdef XZ_DEC_ANY_CHECK
/* Sizes of the Check field with different Check IDs */
static const uint8_t check_sizes[16] = {
    0,
    4, 4, 4,
    8, 8, 8,
    16, 16, 16,
    32, 32, 32,
    64, 64, 64
};
#endif

/*
 * Fill s->temp by copying data starting from b->in[b->in_pos]. Caller
 * must have set s->temp.pos to indicate how much data we are supposed
 * to copy into s->temp.buf. Return true once s->temp.pos has reached
 * s->temp.size.
 */
static bool fill_temp(struct xz_dec *s, struct xz_buf *b)
{
    size_t copy_size = min_t(size_t,
            b->in_size - b->in_pos, s->temp.size - s->temp.pos);

    memcpy(s->temp.buf + s->temp.pos, b->in + b->in_pos, copy_size);
    b->in_pos += copy_size;
    s->temp.pos += copy_size;

    if (s->temp.pos == s->temp.size) {
        s->temp.pos = 0;
        return true;
    }

    return false;
}

/* Decode a variable-length integer (little-endian base-128 encoding) */
static enum xz_ret dec_vli(struct xz_dec *s, const uint8_t *in,
               size_t *in_pos, size_t in_size)
{
    uint8_t byte;

    if (s->pos == 0)
        s->vli = 0;

    while (*in_pos < in_size) {
        byte = in[*in_pos];
        ++*in_pos;

        s->vli |= (vli_type)(byte & 0x7F) << s->pos;

        if ((byte & 0x80) == 0) {
            /* Don't allow non-minimal encodings. */
            if (byte == 0 && s->pos != 0)
                return XZ_DATA_ERROR;

            s->pos = 0;
            return XZ_STREAM_END;
        }

        s->pos += 7;
        if (s->pos == 7 * VLI_BYTES_MAX)
            return XZ_DATA_ERROR;
    }

    return XZ_OK;
}

/*
 * Decode the Compressed Data field from a Block. Update and validate
 * the observed compressed and uncompressed sizes of the Block so that
 * they don't exceed the values possibly stored in the Block Header
 * (validation assumes that no integer overflow occurs, since vli_type
 * is normally uint64_t). Update the CRC32 or CRC64 value if presence of
 * the CRC32 or CRC64 field was indicated in Stream Header.
 *
 * Once the decoding is finished, validate that the observed sizes match
 * the sizes possibly stored in the Block Header. Update the hash and
 * Block count, which are later used to validate the Index field.
 */
static enum xz_ret dec_block(struct xz_dec *s, struct xz_buf *b)
{
    enum xz_ret ret;

    s->in_start = b->in_pos;
    s->out_start = b->out_pos;

#ifdef XZ_DEC_BCJ
    if (s->bcj_active)
        ret = xz_dec_bcj_run(s->bcj, s->lzma2, b);
    else
#endif
        ret = xz_dec_lzma2_run(s->lzma2, b);

    s->block.compressed += b->in_pos - s->in_start;
    s->block.uncompressed += b->out_pos - s->out_start;

    /*
     * There is no need to separately check for VLI_UNKNOWN, since
     * the observed sizes are always smaller than VLI_UNKNOWN.
     */
    if (s->block.compressed > s->block_header.compressed
            || s->block.uncompressed
                > s->block_header.uncompressed)
        return XZ_DATA_ERROR;

    if (s->check_type == XZ_CHECK_CRC32)
        s->crc = xz_crc32(b->out + s->out_start,
                b->out_pos - s->out_start, s->crc);
#ifdef XZ_USE_CRC64
    else if (s->check_type == XZ_CHECK_CRC64)
        s->crc = xz_crc64(b->out + s->out_start,
                b->out_pos - s->out_start, s->crc);
#endif

    if (ret == XZ_STREAM_END) {
        if (s->block_header.compressed != VLI_UNKNOWN
                && s->block_header.compressed
                    != s->block.compressed)
            return XZ_DATA_ERROR;

        if (s->block_header.uncompressed != VLI_UNKNOWN
                && s->block_header.uncompressed
                    != s->block.uncompressed)
            return XZ_DATA_ERROR;

        s->block.hash.unpadded += s->block_header.size
                + s->block.compressed;

#ifdef XZ_DEC_ANY_CHECK
        s->block.hash.unpadded += check_sizes[s->check_type];
#else
        if (s->check_type == XZ_CHECK_CRC32)
            s->block.hash.unpadded += 4;
        else if (IS_CRC64(s->check_type))
            s->block.hash.unpadded += 8;
#endif

        s->block.hash.uncompressed += s->block.uncompressed;
        s->block.hash.crc32 = xz_crc32(
                (const uint8_t *)&s->block.hash,
                sizeof(s->block.hash), s->block.hash.crc32);

        ++s->block.count;
    }

    return ret;
}

/* Update the Index size and the CRC32 value. */
static void index_update(struct xz_dec *s, const struct xz_buf *b)
{
    size_t in_used = b->in_pos - s->in_start;
    s->index.size += in_used;
    s->crc = xz_crc32(b->in + s->in_start, in_used, s->crc);
}

/*
 * Decode the Number of Records, Unpadded Size, and Uncompressed Size
 * fields from the Index field. That is, Index Padding and CRC32 are not
 * decoded by this function.
 *
 * This can return XZ_OK (more input needed), XZ_STREAM_END (everything
 * successfully decoded), or XZ_DATA_ERROR (input is corrupt).
 */
static enum xz_ret dec_index(struct xz_dec *s, struct xz_buf *b)
{
    enum xz_ret ret;

    do {
        ret = dec_vli(s, b->in, &b->in_pos, b->in_size);
        if (ret != XZ_STREAM_END) {
            index_update(s, b);
            return ret;
        }

        switch (s->index.sequence) {
        case SEQ_INDEX_COUNT:
            s->index.count = s->vli;

            /*
             * Validate that the Number of Records field
             * indicates the same number of Records as
             * there were Blocks in the Stream.
             */
            if (s->index.count != s->block.count)
                return XZ_DATA_ERROR;

            s->index.sequence = SEQ_INDEX_UNPADDED;
            break;

        case SEQ_INDEX_UNPADDED:
            s->index.hash.unpadded += s->vli;
            s->index.sequence = SEQ_INDEX_UNCOMPRESSED;
            break;

        case SEQ_INDEX_UNCOMPRESSED:
            s->index.hash.uncompressed += s->vli;
            s->index.hash.crc32 = xz_crc32(
                    (const uint8_t *)&s->index.hash,
                    sizeof(s->index.hash),
                    s->index.hash.crc32);
            --s->index.count;
            s->index.sequence = SEQ_INDEX_UNPADDED;
            break;
        }
    } while (s->index.count > 0);

    return XZ_STREAM_END;
}

/*
 * Validate that the next four or eight input bytes match the value
 * of s->crc. s->pos must be zero when starting to validate the first byte.
 * The "bits" argument allows using the same code for both CRC32 and CRC64.
 */
static enum xz_ret crc_validate(struct xz_dec *s, struct xz_buf *b,
                uint32_t bits)
{
    do {
        if (b->in_pos == b->in_size)
            return XZ_OK;

        if (((s->crc >> s->pos) & 0xFF) != b->in[b->in_pos++])
            return XZ_DATA_ERROR;

        s->pos += 8;

    } while (s->pos < bits);

    s->crc = 0;
    s->pos = 0;

    return XZ_STREAM_END;
}

#ifdef XZ_DEC_ANY_CHECK
/*
 * Skip over the Check field when the Check ID is not supported.
 * Returns true once the whole Check field has been skipped over.
 */
static bool check_skip(struct xz_dec *s, struct xz_buf *b)
{
    while (s->pos < check_sizes[s->check_type]) {
        if (b->in_pos == b->in_size)
            return false;

        ++b->in_pos;
        ++s->pos;
    }

    s->pos = 0;

    return true;
}
#endif

/* Decode the Stream Header field (the first 12 bytes of the .xz Stream). */
static enum xz_ret dec_stream_header(struct xz_dec *s)
{
    if (!memeq(s->temp.buf, HEADER_MAGIC, HEADER_MAGIC_SIZE))
        return XZ_FORMAT_ERROR;

    if (xz_crc32(s->temp.buf + HEADER_MAGIC_SIZE, 2, 0)
            != get_le32(s->temp.buf + HEADER_MAGIC_SIZE + 2))
        return XZ_DATA_ERROR;

    if (s->temp.buf[HEADER_MAGIC_SIZE] != 0)
        return XZ_OPTIONS_ERROR;

    /*
     * Of integrity checks, we support none (Check ID = 0),
     * CRC32 (Check ID = 1), and optionally CRC64 (Check ID = 4).
     * However, if XZ_DEC_ANY_CHECK is defined, we will accept other
     * check types too, but then the check won't be verified and
     * a warning (XZ_UNSUPPORTED_CHECK) will be given.
     */
    s->check_type = s->temp.buf[HEADER_MAGIC_SIZE + 1];

#ifdef XZ_DEC_ANY_CHECK
    if (s->check_type > XZ_CHECK_MAX)
        return XZ_OPTIONS_ERROR;

    if (s->check_type > XZ_CHECK_CRC32 && !IS_CRC64(s->check_type))
        return XZ_UNSUPPORTED_CHECK;
#else
    if (s->check_type > XZ_CHECK_CRC32 && !IS_CRC64(s->check_type))
        return XZ_OPTIONS_ERROR;
#endif

    return XZ_OK;
}

/* Decode the Stream Footer field (the last 12 bytes of the .xz Stream) */
static enum xz_ret dec_stream_footer(struct xz_dec *s)
{
    if (!memeq(s->temp.buf + 10, FOOTER_MAGIC, FOOTER_MAGIC_SIZE))
        return XZ_DATA_ERROR;

    if (xz_crc32(s->temp.buf + 4, 6, 0) != get_le32(s->temp.buf))
        return XZ_DATA_ERROR;

    /*
     * Validate Backward Size. Note that we never added the size of the
     * Index CRC32 field to s->index.size, thus we use s->index.size / 4
     * instead of s->index.size / 4 - 1.
     */
    if ((s->index.size >> 2) != get_le32(s->temp.buf + 4))
        return XZ_DATA_ERROR;

    if (s->temp.buf[8] != 0 || s->temp.buf[9] != s->check_type)
        return XZ_DATA_ERROR;

    /*
     * Use XZ_STREAM_END instead of XZ_OK to be more convenient
     * for the caller.
     */
    return XZ_STREAM_END;
}

/* Decode the Block Header and initialize the filter chain. */
static enum xz_ret dec_block_header(struct xz_dec *s)
{
    enum xz_ret ret;

    /*
     * Validate the CRC32. We know that the temp buffer is at least
     * eight bytes so this is safe.
     */
    s->temp.size -= 4;
    if (xz_crc32(s->temp.buf, s->temp.size, 0)
            != get_le32(s->temp.buf + s->temp.size))
        return XZ_DATA_ERROR;

    s->temp.pos = 2;

    /*
     * Catch unsupported Block Flags. We support only one or two filters
     * in the chain, so we catch that with the same test.
     */
#ifdef XZ_DEC_BCJ
    if (s->temp.buf[1] & 0x3E)
#else
    if (s->temp.buf[1] & 0x3F)
#endif
        return XZ_OPTIONS_ERROR;

    /* Compressed Size */
    if (s->temp.buf[1] & 0x40) {
        if (dec_vli(s, s->temp.buf, &s->temp.pos, s->temp.size)
                    != XZ_STREAM_END)
            return XZ_DATA_ERROR;

        s->block_header.compressed = s->vli;
    } else {
        s->block_header.compressed = VLI_UNKNOWN;
    }

    /* Uncompressed Size */
    if (s->temp.buf[1] & 0x80) {
        if (dec_vli(s, s->temp.buf, &s->temp.pos, s->temp.size)
                != XZ_STREAM_END)
            return XZ_DATA_ERROR;

        s->block_header.uncompressed = s->vli;
    } else {
        s->block_header.uncompressed = VLI_UNKNOWN;
    }

#ifdef XZ_DEC_BCJ
    /* If there are two filters, the first one must be a BCJ filter. */
    s->bcj_active = s->temp.buf[1] & 0x01;
    if (s->bcj_active) {
        if (s->temp.size - s->temp.pos < 2)
            return XZ_OPTIONS_ERROR;

        ret = xz_dec_bcj_reset(s->bcj, s->temp.buf[s->temp.pos++]);
        if (ret != XZ_OK)
            return ret;

        /*
         * We don't support custom start offset,
         * so Size of Properties must be zero.
         */
        if (s->temp.buf[s->temp.pos++] != 0x00)
            return XZ_OPTIONS_ERROR;
    }
#endif

    /* Valid Filter Flags always take at least two bytes. */
    if (s->temp.size - s->temp.pos < 2)
        return XZ_DATA_ERROR;

    /* Filter ID = LZMA2 */
    if (s->temp.buf[s->temp.pos++] != 0x21)
        return XZ_OPTIONS_ERROR;

    /* Size of Properties = 1-byte Filter Properties */
    if (s->temp.buf[s->temp.pos++] != 0x01)
        return XZ_OPTIONS_ERROR;

    /* Filter Properties contains LZMA2 dictionary size. */
    if (s->temp.size - s->temp.pos < 1)
        return XZ_DATA_ERROR;

    ret = xz_dec_lzma2_reset(s->lzma2, s->temp.buf[s->temp.pos++]);
    if (ret != XZ_OK)
        return ret;

    /* The rest must be Header Padding. */
    while (s->temp.pos < s->temp.size)
        if (s->temp.buf[s->temp.pos++] != 0x00)
            return XZ_OPTIONS_ERROR;

    s->temp.pos = 0;
    s->block.compressed = 0;
    s->block.uncompressed = 0;

    return XZ_OK;
}

static enum xz_ret dec_main(struct xz_dec *s, struct xz_buf *b)
{
    enum xz_ret ret;

    /*
     * Store the start position for the case when we are in the middle
     * of the Index field.
     */
    s->in_start = b->in_pos;

    while (true) {
        switch (s->sequence) {
        case SEQ_STREAM_HEADER:
            /*
             * Stream Header is copied to s->temp, and then
             * decoded from there. This way if the caller
             * gives us only little input at a time, we can
             * still keep the Stream Header decoding code
             * simple. Similar approach is used in many places
             * in this file.
             */
            if (!fill_temp(s, b))
                return XZ_OK;

            /*
             * If dec_stream_header() returns
             * XZ_UNSUPPORTED_CHECK, it is still possible
             * to continue decoding if working in multi-call
             * mode. Thus, update s->sequence before calling
             * dec_stream_header().
             */
            s->sequence = SEQ_BLOCK_START;

            ret = dec_stream_header(s);
            if (ret != XZ_OK)
                return ret;

        case SEQ_BLOCK_START:
            /* We need one byte of input to continue. */
            if (b->in_pos == b->in_size)
                return XZ_OK;

            /* See if this is the beginning of the Index field. */
            if (b->in[b->in_pos] == 0) {
                s->in_start = b->in_pos++;
                s->sequence = SEQ_INDEX;
                break;
            }

            /*
             * Calculate the size of the Block Header and
             * prepare to decode it.
             */
            s->block_header.size
                = ((uint32_t)b->in[b->in_pos] + 1) * 4;

            s->temp.size = s->block_header.size;
            s->temp.pos = 0;
            s->sequence = SEQ_BLOCK_HEADER;

        case SEQ_BLOCK_HEADER:
            if (!fill_temp(s, b))
                return XZ_OK;

            ret = dec_block_header(s);
            if (ret != XZ_OK)
                return ret;

            s->sequence = SEQ_BLOCK_UNCOMPRESS;

        case SEQ_BLOCK_UNCOMPRESS:
            ret = dec_block(s, b);
            if (ret != XZ_STREAM_END)
                return ret;

            s->sequence = SEQ_BLOCK_PADDING;

        case SEQ_BLOCK_PADDING:
            /*
             * Size of Compressed Data + Block Padding
             * must be a multiple of four. We don't need
             * s->block.compressed for anything else
             * anymore, so we use it here to test the size
             * of the Block Padding field.
             */
            while (s->block.compressed & 3) {
                if (b->in_pos == b->in_size)
                    return XZ_OK;

                if (b->in[b->in_pos++] != 0)
                    return XZ_DATA_ERROR;

                ++s->block.compressed;
            }

            s->sequence = SEQ_BLOCK_CHECK;

        case SEQ_BLOCK_CHECK:
            if (s->check_type == XZ_CHECK_CRC32) {
                ret = crc_validate(s, b, 32);
                if (ret != XZ_STREAM_END)
                    return ret;
            }
            else if (IS_CRC64(s->check_type)) {
                ret = crc_validate(s, b, 64);
                if (ret != XZ_STREAM_END)
                    return ret;
            }
#ifdef XZ_DEC_ANY_CHECK
            else if (!check_skip(s, b)) {
                return XZ_OK;
            }
#endif

            s->sequence = SEQ_BLOCK_START;
            break;

        case SEQ_INDEX:
            ret = dec_index(s, b);
            if (ret != XZ_STREAM_END)
                return ret;

            s->sequence = SEQ_INDEX_PADDING;

        case SEQ_INDEX_PADDING:
            while ((s->index.size + (b->in_pos - s->in_start))
                    & 3) {
                if (b->in_pos == b->in_size) {
                    index_update(s, b);
                    return XZ_OK;
                }

                if (b->in[b->in_pos++] != 0)
                    return XZ_DATA_ERROR;
            }

            /* Finish the CRC32 value and Index size. */
            index_update(s, b);

            /* Compare the hashes to validate the Index field. */
            if (!memeq(&s->block.hash, &s->index.hash,
                    sizeof(s->block.hash)))
                return XZ_DATA_ERROR;

            s->sequence = SEQ_INDEX_CRC32;

        case SEQ_INDEX_CRC32:
            ret = crc_validate(s, b, 32);
            if (ret != XZ_STREAM_END)
                return ret;

            s->temp.size = STREAM_HEADER_SIZE;
            s->sequence = SEQ_STREAM_FOOTER;

        case SEQ_STREAM_FOOTER:
            if (!fill_temp(s, b))
                return XZ_OK;

            return dec_stream_footer(s);
        }
    }

    /* Never reached */
}

/*
 * xz_dec_run() is a wrapper for dec_main() to handle some special cases in
 * multi-call and single-call decoding.
 *
 * In multi-call mode, we must return XZ_BUF_ERROR when it seems clear that we
 * are not going to make any progress anymore. This is to prevent the caller
 * from calling us infinitely when the input file is truncated or otherwise
 * corrupt. Since zlib-style API allows that the caller fills the input buffer
 * only when the decoder doesn't produce any new output, we have to be careful
 * to avoid returning XZ_BUF_ERROR too easily: XZ_BUF_ERROR is returned only
 * after the second consecutive call to xz_dec_run() that makes no progress.
 *
 * In single-call mode, if we couldn't decode everything and no error
 * occurred, either the input is truncated or the output buffer is too small.
 * Since we know that the last input byte never produces any output, we know
 * that if all the input was consumed and decoding wasn't finished, the file
 * must be corrupt. Otherwise the output buffer has to be too small or the
 * file is corrupt in a way that decoding it produces too big output.
 *
 * If single-call decoding fails, we reset b->in_pos and b->out_pos back to
 * their original values. This is because with some filter chains there won't
 * be any valid uncompressed data in the output buffer unless the decoding
 * actually succeeds (that's the price to pay of using the output buffer as
 * the workspace).
 */
XZ_EXTERN enum xz_ret xz_dec_run(struct xz_dec *s, struct xz_buf *b)
{
    size_t in_start;
    size_t out_start;
    enum xz_ret ret;

    if (DEC_IS_SINGLE(s->mode))
        xz_dec_reset(s);

    in_start = b->in_pos;
    out_start = b->out_pos;
    ret = dec_main(s, b);

    if (DEC_IS_SINGLE(s->mode)) {
        if (ret == XZ_OK)
            ret = b->in_pos == b->in_size
                    ? XZ_DATA_ERROR : XZ_BUF_ERROR;

        if (ret != XZ_STREAM_END) {
            b->in_pos = in_start;
            b->out_pos = out_start;
        }

    } else if (ret == XZ_OK && in_start == b->in_pos
            && out_start == b->out_pos) {
        if (s->allow_buf_error)
            ret = XZ_BUF_ERROR;

        s->allow_buf_error = true;
    } else {
        s->allow_buf_error = false;
    }

    return ret;
}

XZ_EXTERN struct xz_dec *xz_dec_init(enum xz_mode mode, uint32_t dict_max)
{
    struct xz_dec *s = kmalloc(sizeof(*s), GFP_KERNEL);
    if (s == NULL)
        return NULL;

    s->mode = mode;

#ifdef XZ_DEC_BCJ
    s->bcj = xz_dec_bcj_create(DEC_IS_SINGLE(mode));
    if (s->bcj == NULL)
        goto error_bcj;
#endif

    s->lzma2 = xz_dec_lzma2_create(mode, dict_max);
    if (s->lzma2 == NULL)
        goto error_lzma2;

    xz_dec_reset(s);
    return s;

error_lzma2:
#ifdef XZ_DEC_BCJ
    xz_dec_bcj_end(s->bcj);
error_bcj:
#endif
    kfree(s);
    return NULL;
}

XZ_EXTERN void xz_dec_reset(struct xz_dec *s)
{
    s->sequence = SEQ_STREAM_HEADER;
    s->allow_buf_error = false;
    s->pos = 0;
    s->crc = 0;
    memzero(&s->block, sizeof(s->block));
    memzero(&s->index, sizeof(s->index));
    s->temp.pos = 0;
    s->temp.size = STREAM_HEADER_SIZE;
}

XZ_EXTERN void xz_dec_end(struct xz_dec *s)
{
    if (s != NULL) {
        xz_dec_lzma2_end(s->lzma2);
#ifdef XZ_DEC_BCJ
        xz_dec_bcj_end(s->bcj);
#endif
        kfree(s);
    }
}

```

`native/src/external/xz-embedded/xz_lzma2.h`:

```h
/*
 * LZMA2 definitions
 *
 * Authors: Lasse Collin <lasse.collin@tukaani.org>
 *          Igor Pavlov <http://7-zip.org/>
 *
 * This file has been put into the public domain.
 * You can do whatever you want with this file.
 */

#ifndef XZ_LZMA2_H
#define XZ_LZMA2_H

/* Range coder constants */
#define RC_SHIFT_BITS 8
#define RC_TOP_BITS 24
#define RC_TOP_VALUE (1 << RC_TOP_BITS)
#define RC_BIT_MODEL_TOTAL_BITS 11
#define RC_BIT_MODEL_TOTAL (1 << RC_BIT_MODEL_TOTAL_BITS)
#define RC_MOVE_BITS 5

/*
 * Maximum number of position states. A position state is the lowest pb
 * number of bits of the current uncompressed offset. In some places there
 * are different sets of probabilities for different position states.
 */
#define POS_STATES_MAX (1 << 4)

/*
 * This enum is used to track which LZMA symbols have occurred most recently
 * and in which order. This information is used to predict the next symbol.
 *
 * Symbols:
 *  - Literal: One 8-bit byte
 *  - Match: Repeat a chunk of data at some distance
 *  - Long repeat: Multi-byte match at a recently seen distance
 *  - Short repeat: One-byte repeat at a recently seen distance
 *
 * The symbol names are in from STATE_oldest_older_previous. REP means
 * either short or long repeated match, and NONLIT means any non-literal.
 */
enum lzma_state {
    STATE_LIT_LIT,
    STATE_MATCH_LIT_LIT,
    STATE_REP_LIT_LIT,
    STATE_SHORTREP_LIT_LIT,
    STATE_MATCH_LIT,
    STATE_REP_LIT,
    STATE_SHORTREP_LIT,
    STATE_LIT_MATCH,
    STATE_LIT_LONGREP,
    STATE_LIT_SHORTREP,
    STATE_NONLIT_MATCH,
    STATE_NONLIT_REP
};

/* Total number of states */
#define STATES 12

/* The lowest 7 states indicate that the previous state was a literal. */
#define LIT_STATES 7

/* Indicate that the latest symbol was a literal. */
static inline void lzma_state_literal(enum lzma_state *state)
{
    if (*state <= STATE_SHORTREP_LIT_LIT)
        *state = STATE_LIT_LIT;
    else if (*state <= STATE_LIT_SHORTREP)
        *state -= 3;
    else
        *state -= 6;
}

/* Indicate that the latest symbol was a match. */
static inline void lzma_state_match(enum lzma_state *state)
{
    *state = *state < LIT_STATES ? STATE_LIT_MATCH : STATE_NONLIT_MATCH;
}

/* Indicate that the latest state was a long repeated match. */
static inline void lzma_state_long_rep(enum lzma_state *state)
{
    *state = *state < LIT_STATES ? STATE_LIT_LONGREP : STATE_NONLIT_REP;
}

/* Indicate that the latest symbol was a short match. */
static inline void lzma_state_short_rep(enum lzma_state *state)
{
    *state = *state < LIT_STATES ? STATE_LIT_SHORTREP : STATE_NONLIT_REP;
}

/* Test if the previous symbol was a literal. */
static inline bool lzma_state_is_literal(enum lzma_state state)
{
    return state < LIT_STATES;
}

/* Each literal coder is divided in three sections:
 *   - 0x001-0x0FF: Without match byte
 *   - 0x101-0x1FF: With match byte; match bit is 0
 *   - 0x201-0x2FF: With match byte; match bit is 1
 *
 * Match byte is used when the previous LZMA symbol was something else than
 * a literal (that is, it was some kind of match).
 */
#define LITERAL_CODER_SIZE 0x300

/* Maximum number of literal coders */
#define LITERAL_CODERS_MAX (1 << 4)

/* Minimum length of a match is two bytes. */
#define MATCH_LEN_MIN 2

/* Match length is encoded with 4, 5, or 10 bits.
 *
 * Length   Bits
 *  2-9      4 = Choice=0 + 3 bits
 * 10-17     5 = Choice=1 + Choice2=0 + 3 bits
 * 18-273   10 = Choice=1 + Choice2=1 + 8 bits
 */
#define LEN_LOW_BITS 3
#define LEN_LOW_SYMBOLS (1 << LEN_LOW_BITS)
#define LEN_MID_BITS 3
#define LEN_MID_SYMBOLS (1 << LEN_MID_BITS)
#define LEN_HIGH_BITS 8
#define LEN_HIGH_SYMBOLS (1 << LEN_HIGH_BITS)
#define LEN_SYMBOLS (LEN_LOW_SYMBOLS + LEN_MID_SYMBOLS + LEN_HIGH_SYMBOLS)

/*
 * Maximum length of a match is 273 which is a result of the encoding
 * described above.
 */
#define MATCH_LEN_MAX (MATCH_LEN_MIN + LEN_SYMBOLS - 1)

/*
 * Different sets of probabilities are used for match distances that have
 * very short match length: Lengths of 2, 3, and 4 bytes have a separate
 * set of probabilities for each length. The matches with longer length
 * use a shared set of probabilities.
 */
#define DIST_STATES 4

/*
 * Get the index of the appropriate probability array for decoding
 * the distance slot.
 */
static inline uint32_t lzma_get_dist_state(uint32_t len)
{
    return len < DIST_STATES + MATCH_LEN_MIN
            ? len - MATCH_LEN_MIN : DIST_STATES - 1;
}

/*
 * The highest two bits of a 32-bit match distance are encoded using six bits.
 * This six-bit value is called a distance slot. This way encoding a 32-bit
 * value takes 6-36 bits, larger values taking more bits.
 */
#define DIST_SLOT_BITS 6
#define DIST_SLOTS (1 << DIST_SLOT_BITS)

/* Match distances up to 127 are fully encoded using probabilities. Since
 * the highest two bits (distance slot) are always encoded using six bits,
 * the distances 0-3 don't need any additional bits to encode, since the
 * distance slot itself is the same as the actual distance. DIST_MODEL_START
 * indicates the first distance slot where at least one additional bit is
 * needed.
 */
#define DIST_MODEL_START 4

/*
 * Match distances greater than 127 are encoded in three pieces:
 *   - distance slot: the highest two bits
 *   - direct bits: 2-26 bits below the highest two bits
 *   - alignment bits: four lowest bits
 *
 * Direct bits don't use any probabilities.
 *
 * The distance slot value of 14 is for distances 128-191.
 */
#define DIST_MODEL_END 14

/* Distance slots that indicate a distance <= 127. */
#define FULL_DISTANCES_BITS (DIST_MODEL_END / 2)
#define FULL_DISTANCES (1 << FULL_DISTANCES_BITS)

/*
 * For match distances greater than 127, only the highest two bits and the
 * lowest four bits (alignment) is encoded using probabilities.
 */
#define ALIGN_BITS 4
#define ALIGN_SIZE (1 << ALIGN_BITS)
#define ALIGN_MASK (ALIGN_SIZE - 1)

/* Total number of all probability variables */
#define PROBS_TOTAL (1846 + LITERAL_CODERS_MAX * LITERAL_CODER_SIZE)

/*
 * LZMA remembers the four most recent match distances. Reusing these
 * distances tends to take less space than re-encoding the actual
 * distance value.
 */
#define REPS 4

#endif

```

`native/src/external/xz-embedded/xz_private.h`:

```h
/*
 * Private includes and definitions
 *
 * Author: Lasse Collin <lasse.collin@tukaani.org>
 *
 * This file has been put into the public domain.
 * You can do whatever you want with this file.
 */

#ifndef XZ_PRIVATE_H
#define XZ_PRIVATE_H

#ifdef __KERNEL__
#	include <linux/xz.h>
#	include <linux/kernel.h>
#	include <asm/unaligned.h>
    /* XZ_PREBOOT may be defined only via decompress_unxz.c. */
#	ifndef XZ_PREBOOT
#		include <linux/slab.h>
#		include <linux/vmalloc.h>
#		include <linux/string.h>
#		ifdef CONFIG_XZ_DEC_X86
#			define XZ_DEC_X86
#		endif
#		ifdef CONFIG_XZ_DEC_POWERPC
#			define XZ_DEC_POWERPC
#		endif
#		ifdef CONFIG_XZ_DEC_IA64
#			define XZ_DEC_IA64
#		endif
#		ifdef CONFIG_XZ_DEC_ARM
#			define XZ_DEC_ARM
#		endif
#		ifdef CONFIG_XZ_DEC_ARMTHUMB
#			define XZ_DEC_ARMTHUMB
#		endif
#		ifdef CONFIG_XZ_DEC_SPARC
#			define XZ_DEC_SPARC
#		endif
#		define memeq(a, b, size) (memcmp(a, b, size) == 0)
#		define memzero(buf, size) memset(buf, 0, size)
#	endif
#	define get_le32(p) le32_to_cpup((const uint32_t *)(p))
#else
    /*
     * For userspace builds, use a separate header to define the required
     * macros and functions. This makes it easier to adapt the code into
     * different environments and avoids clutter in the Linux kernel tree.
     */
#	include "xz_config.h"
#endif

/* If no specific decoding mode is requested, enable support for all modes. */
#if !defined(XZ_DEC_SINGLE) && !defined(XZ_DEC_PREALLOC) \
        && !defined(XZ_DEC_DYNALLOC)
#	define XZ_DEC_SINGLE
#	define XZ_DEC_PREALLOC
#	define XZ_DEC_DYNALLOC
#endif

/*
 * The DEC_IS_foo(mode) macros are used in "if" statements. If only some
 * of the supported modes are enabled, these macros will evaluate to true or
 * false at compile time and thus allow the compiler to omit unneeded code.
 */
#ifdef XZ_DEC_SINGLE
#	define DEC_IS_SINGLE(mode) ((mode) == XZ_SINGLE)
#else
#	define DEC_IS_SINGLE(mode) (false)
#endif

#ifdef XZ_DEC_PREALLOC
#	define DEC_IS_PREALLOC(mode) ((mode) == XZ_PREALLOC)
#else
#	define DEC_IS_PREALLOC(mode) (false)
#endif

#ifdef XZ_DEC_DYNALLOC
#	define DEC_IS_DYNALLOC(mode) ((mode) == XZ_DYNALLOC)
#else
#	define DEC_IS_DYNALLOC(mode) (false)
#endif

#if !defined(XZ_DEC_SINGLE)
#	define DEC_IS_MULTI(mode) (true)
#elif defined(XZ_DEC_PREALLOC) || defined(XZ_DEC_DYNALLOC)
#	define DEC_IS_MULTI(mode) ((mode) != XZ_SINGLE)
#else
#	define DEC_IS_MULTI(mode) (false)
#endif

/*
 * If any of the BCJ filter decoders are wanted, define XZ_DEC_BCJ.
 * XZ_DEC_BCJ is used to enable generic support for BCJ decoders.
 */
#ifndef XZ_DEC_BCJ
#	if defined(XZ_DEC_X86) || defined(XZ_DEC_POWERPC) \
            || defined(XZ_DEC_IA64) || defined(XZ_DEC_ARM) \
            || defined(XZ_DEC_ARM) || defined(XZ_DEC_ARMTHUMB) \
            || defined(XZ_DEC_SPARC)
#		define XZ_DEC_BCJ
#	endif
#endif

/*
 * Allocate memory for LZMA2 decoder. xz_dec_lzma2_reset() must be used
 * before calling xz_dec_lzma2_run().
 */
XZ_EXTERN struct xz_dec_lzma2 *xz_dec_lzma2_create(enum xz_mode mode,
                           uint32_t dict_max);

/*
 * Decode the LZMA2 properties (one byte) and reset the decoder. Return
 * XZ_OK on success, XZ_MEMLIMIT_ERROR if the preallocated dictionary is not
 * big enough, and XZ_OPTIONS_ERROR if props indicates something that this
 * decoder doesn't support.
 */
XZ_EXTERN enum xz_ret xz_dec_lzma2_reset(struct xz_dec_lzma2 *s,
                     uint8_t props);

/* Decode raw LZMA2 stream from b->in to b->out. */
XZ_EXTERN enum xz_ret xz_dec_lzma2_run(struct xz_dec_lzma2 *s,
                       struct xz_buf *b);

/* Free the memory allocated for the LZMA2 decoder. */
XZ_EXTERN void xz_dec_lzma2_end(struct xz_dec_lzma2 *s);

#ifdef XZ_DEC_BCJ
/*
 * Allocate memory for BCJ decoders. xz_dec_bcj_reset() must be used before
 * calling xz_dec_bcj_run().
 */
XZ_EXTERN struct xz_dec_bcj *xz_dec_bcj_create(bool single_call);

/*
 * Decode the Filter ID of a BCJ filter. This implementation doesn't
 * support custom start offsets, so no decoding of Filter Properties
 * is needed. Returns XZ_OK if the given Filter ID is supported.
 * Otherwise XZ_OPTIONS_ERROR is returned.
 */
XZ_EXTERN enum xz_ret xz_dec_bcj_reset(struct xz_dec_bcj *s, uint8_t id);

/*
 * Decode raw BCJ + LZMA2 stream. This must be used only if there actually is
 * a BCJ filter in the chain. If the chain has only LZMA2, xz_dec_lzma2_run()
 * must be called directly.
 */
XZ_EXTERN enum xz_ret xz_dec_bcj_run(struct xz_dec_bcj *s,
                     struct xz_dec_lzma2 *lzma2,
                     struct xz_buf *b);

/* Free the memory allocated for the BCJ filters. */
#define xz_dec_bcj_end(s) kfree(s)
#endif

#endif

```

`native/src/external/xz-embedded/xz_stream.h`:

```h
/*
 * Definitions for handling the .xz file format
 *
 * Author: Lasse Collin <lasse.collin@tukaani.org>
 *
 * This file has been put into the public domain.
 * You can do whatever you want with this file.
 */

#ifndef XZ_STREAM_H
#define XZ_STREAM_H

#if defined(__KERNEL__) && !XZ_INTERNAL_CRC32
#	include <linux/crc32.h>
#	undef crc32
#	define xz_crc32(buf, size, crc) \
        (~crc32_le(~(uint32_t)(crc), buf, size))
#endif

/*
 * See the .xz file format specification at
 * http://tukaani.org/xz/xz-file-format.txt
 * to understand the container format.
 */

#define STREAM_HEADER_SIZE 12

#define HEADER_MAGIC "\3757zXZ"
#define HEADER_MAGIC_SIZE 6

#define FOOTER_MAGIC "YZ"
#define FOOTER_MAGIC_SIZE 2

/*
 * Variable-length integer can hold a 63-bit unsigned integer or a special
 * value indicating that the value is unknown.
 *
 * Experimental: vli_type can be defined to uint32_t to save a few bytes
 * in code size (no effect on speed). Doing so limits the uncompressed and
 * compressed size of the file to less than 256 MiB and may also weaken
 * error detection slightly.
 */
typedef uint64_t vli_type;

#define VLI_MAX ((vli_type)-1 / 2)
#define VLI_UNKNOWN ((vli_type)-1)

/* Maximum encoded size of a VLI */
#define VLI_BYTES_MAX (sizeof(vli_type) * 8 / 7)

/* Integrity Check types */
enum xz_check {
    XZ_CHECK_NONE = 0,
    XZ_CHECK_CRC32 = 1,
    XZ_CHECK_CRC64 = 4,
    XZ_CHECK_SHA256 = 10
};

/* Maximum possible Check ID */
#define XZ_CHECK_MAX 15

#endif

```

`native/src/external/xz_config/config.h`:

```h
/* config.h.  Generated from config.h.in by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Define if building universal (internal helper macro) */
/* #undef AC_APPLE_UNIVERSAL_BUILD */

/* How many MiB of RAM to assume if the real amount cannot be determined. */
#define ASSUME_RAM 128

/* Define to 1 if translation of program messages to the user's native
   language is requested. */
/* #undef ENABLE_NLS */

/* Define to 1 if bswap_16 is available. */
#define HAVE_BSWAP_16 1

/* Define to 1 if bswap_32 is available. */
#define HAVE_BSWAP_32 1

/* Define to 1 if bswap_64 is available. */
#define HAVE_BSWAP_64 1

/* Define to 1 if you have the <byteswap.h> header file. */
#define HAVE_BYTESWAP_H 1

/* Define to 1 if Capsicum is available. */
/* #undef HAVE_CAPSICUM */

/* Define to 1 if the system has the type `CC_SHA256_CTX'. */
/* #undef HAVE_CC_SHA256_CTX */

/* Define to 1 if you have the `CC_SHA256_Init' function. */
/* #undef HAVE_CC_SHA256_INIT */

/* Define to 1 if you have the MacOS X function CFLocaleCopyCurrent in the
   CoreFoundation framework. */
/* #undef HAVE_CFLOCALECOPYCURRENT */

/* Define to 1 if you have the MacOS X function CFPreferencesCopyAppValue in
   the CoreFoundation framework. */
/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */

/* Define to 1 if crc32 integrity check is enabled. */
#define HAVE_CHECK_CRC32 1

/* Define to 1 if crc64 integrity check is enabled. */
#define HAVE_CHECK_CRC64 1

/* Define to 1 if sha256 integrity check is enabled. */
#define HAVE_CHECK_SHA256 1

/* Define to 1 if you have the `clock_gettime' function. */
#define HAVE_CLOCK_GETTIME 1

/* Define to 1 if you have the <CommonCrypto/CommonDigest.h> header file. */
/* #undef HAVE_COMMONCRYPTO_COMMONDIGEST_H */

/* Define if the GNU dcgettext() function is already present or preinstalled.
   */
/* #undef HAVE_DCGETTEXT */

/* Define to 1 if you have the declaration of `CLOCK_MONOTONIC', and to 0 if
   you don't. */
#define HAVE_DECL_CLOCK_MONOTONIC 1

/* Define to 1 if you have the declaration of `program_invocation_name', and
   to 0 if you don't. */
#define HAVE_DECL_PROGRAM_INVOCATION_NAME 0

/* Define to 1 if any of HAVE_DECODER_foo have been defined. */
#define HAVE_DECODERS 1

/* Define to 1 if arm decoder is enabled. */
#define HAVE_DECODER_ARM 1

/* Define to 1 if armthumb decoder is enabled. */
#define HAVE_DECODER_ARMTHUMB 1

/* Define to 1 if delta decoder is enabled. */
#define HAVE_DECODER_DELTA 1

/* Define to 1 if ia64 decoder is enabled. */
#define HAVE_DECODER_IA64 1

/* Define to 1 if lzma1 decoder is enabled. */
#define HAVE_DECODER_LZMA1 1

/* Define to 1 if lzma2 decoder is enabled. */
#define HAVE_DECODER_LZMA2 1

/* Define to 1 if powerpc decoder is enabled. */
#define HAVE_DECODER_POWERPC 1

/* Define to 1 if sparc decoder is enabled. */
#define HAVE_DECODER_SPARC 1

/* Define to 1 if x86 decoder is enabled. */
#define HAVE_DECODER_X86 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if any of HAVE_ENCODER_foo have been defined. */
#define HAVE_ENCODERS 1

/* Define to 1 if arm encoder is enabled. */
#define HAVE_ENCODER_ARM 1

/* Define to 1 if armthumb encoder is enabled. */
#define HAVE_ENCODER_ARMTHUMB 1

/* Define to 1 if delta encoder is enabled. */
#define HAVE_ENCODER_DELTA 1

/* Define to 1 if ia64 encoder is enabled. */
#define HAVE_ENCODER_IA64 1

/* Define to 1 if lzma1 encoder is enabled. */
#define HAVE_ENCODER_LZMA1 1

/* Define to 1 if lzma2 encoder is enabled. */
#define HAVE_ENCODER_LZMA2 1

/* Define to 1 if powerpc encoder is enabled. */
#define HAVE_ENCODER_POWERPC 1

/* Define to 1 if sparc encoder is enabled. */
#define HAVE_ENCODER_SPARC 1

/* Define to 1 if x86 encoder is enabled. */
#define HAVE_ENCODER_X86 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
/* #undef HAVE_FUTIMES */

/* Define to 1 if you have the `futimesat' function. */
/* #undef HAVE_FUTIMESAT */

/* Define to 1 if you have the <getopt.h> header file. */
#define HAVE_GETOPT_H 1

/* Define to 1 if you have the `getopt_long' function. */
#define HAVE_GETOPT_LONG 1

/* Define if the GNU gettext() function is already present or preinstalled. */
/* #undef HAVE_GETTEXT */

/* Define if you have the iconv() function and it works. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <immintrin.h> header file. */
/* #undef HAVE_IMMINTRIN_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if mbrtowc and mbstate_t are properly declared. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 to enable bt2 match finder. */
#define HAVE_MF_BT2 1

/* Define to 1 to enable bt3 match finder. */
#define HAVE_MF_BT3 1

/* Define to 1 to enable bt4 match finder. */
#define HAVE_MF_BT4 1

/* Define to 1 to enable hc3 match finder. */
#define HAVE_MF_HC3 1

/* Define to 1 to enable hc4 match finder. */
#define HAVE_MF_HC4 1

/* Define to 1 if you have the <minix/sha2.h> header file. */
/* #undef HAVE_MINIX_SHA2_H */

/* Define to 1 if getopt.h declares extern int optreset. */
#define HAVE_OPTRESET 1

/* Define to 1 if you have the `posix_fadvise' function. */
#define HAVE_POSIX_FADVISE 1

/* Define to 1 if you have the `pthread_condattr_setclock' function. */
#define HAVE_PTHREAD_CONDATTR_SETCLOCK 1

/* Have PTHREAD_PRIO_INHERIT. */
/* #undef HAVE_PTHREAD_PRIO_INHERIT */

/* Define to 1 if you have the `SHA256Init' function. */
/* #undef HAVE_SHA256INIT */

/* Define to 1 if the system has the type `SHA256_CTX'. */
/* #undef HAVE_SHA256_CTX */

/* Define to 1 if you have the <sha256.h> header file. */
/* #undef HAVE_SHA256_H */

/* Define to 1 if you have the `SHA256_Init' function. */
/* #undef HAVE_SHA256_INIT */

/* Define to 1 if the system has the type `SHA2_CTX'. */
/* #undef HAVE_SHA2_CTX */

/* Define to 1 if you have the <sha2.h> header file. */
/* #undef HAVE_SHA2_H */

/* Define to 1 if optimizing for size. */
/* #undef HAVE_SMALL */

/* Define to 1 if stdbool.h conforms to C99. */
#define HAVE_STDBOOL_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if `st_atimensec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_ATIMENSEC 1

/* Define to 1 if `st_atimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC */

/* Define to 1 if `st_atim.st__tim.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_ATIM_ST__TIM_TV_NSEC */

/* Define to 1 if `st_atim.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC */

/* Define to 1 if `st_uatime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UATIME */

/* Define to 1 if you have the <sys/byteorder.h> header file. */
/* #undef HAVE_SYS_BYTEORDER_H */

/* Define to 1 if you have the <sys/capsicum.h> header file. */
/* #undef HAVE_SYS_CAPSICUM_H */

/* Define to 1 if you have the <sys/endian.h> header file. */
/* #undef HAVE_SYS_ENDIAN_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if the system has the type `uintptr_t'. */
#define HAVE_UINTPTR_T 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `utime' function. */
/* #undef HAVE_UTIME */

/* Define to 1 if you have the `utimes' function. */
/* #undef HAVE_UTIMES */

/* Define to 1 or 0, depending whether the compiler supports simple visibility
   declarations. */
#define HAVE_VISIBILITY 1

/* Define to 1 if you have the `wcwidth' function. */
#define HAVE_WCWIDTH 1

/* Define to 1 if the system has the type `_Bool'. */
#define HAVE__BOOL 1

/* Define to 1 if _mm_movemask_epi8 is available. */
/* #undef HAVE__MM_MOVEMASK_EPI8 */

/* Define to the sub-directory where libtool stores uninstalled libraries. */
#define LT_OBJDIR ".libs/"

/* Define to 1 when using POSIX threads (pthreads). */
#define MYTHREAD_POSIX 1

/* Define to 1 when using Windows Vista compatible threads. This uses features
   that are not available on Windows XP. */
/* #undef MYTHREAD_VISTA */

/* Define to 1 when using Windows 95 (and thus XP) compatible threads. This
   avoids use of features that were added in Windows Vista. */
/* #undef MYTHREAD_WIN95 */

/* Define to 1 to disable debugging code. */
#define NDEBUG 1

/* Name of package */
#define PACKAGE "xz"

/* Define to the address where bug reports for this package should be sent. */
#define PACKAGE_BUGREPORT "lasse.collin@tukaani.org"

/* Define to the full name of this package. */
#define PACKAGE_NAME "XZ Utils"

/* Define to the full name and version of this package. */
#define PACKAGE_STRING "XZ Utils 5.3.0alpha"

/* Define to the one symbol short name of this package. */
#define PACKAGE_TARNAME "xz"

/* Define to the home page for this package. */
#define PACKAGE_URL "http://tukaani.org/xz/"

/* Define to the version of this package. */
#define PACKAGE_VERSION "5.3.0alpha"

/* Define to necessary symbol if this constant uses a non-standard name on
   your system. */
/* #undef PTHREAD_CREATE_JOINABLE */

/* The size of `size_t', as computed by sizeof. */
#define SIZEOF_SIZE_T 4

/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* Define to 1 if the number of available CPU cores can be detected with
   cpuset(2). */
/* #undef TUKLIB_CPUCORES_CPUSET */

/* Define to 1 if the number of available CPU cores can be detected with
   pstat_getdynamic(). */
/* #undef TUKLIB_CPUCORES_PSTAT_GETDYNAMIC */

/* Define to 1 if the number of available CPU cores can be detected with
   sysconf(_SC_NPROCESSORS_ONLN) or sysconf(_SC_NPROC_ONLN). */
#define TUKLIB_CPUCORES_SYSCONF 1

/* Define to 1 if the number of available CPU cores can be detected with
   sysctl(). */
/* #undef TUKLIB_CPUCORES_SYSCTL */

/* Define to 1 if the system supports fast unaligned access to 16-bit and
   32-bit integers. */
/* #undef TUKLIB_FAST_UNALIGNED_ACCESS */

/* Define to 1 if the amount of physical memory can be detected with
   _system_configuration.physmem. */
/* #undef TUKLIB_PHYSMEM_AIX */

/* Define to 1 if the amount of physical memory can be detected with
   getinvent_r(). */
/* #undef TUKLIB_PHYSMEM_GETINVENT_R */

/* Define to 1 if the amount of physical memory can be detected with
   getsysinfo(). */
/* #undef TUKLIB_PHYSMEM_GETSYSINFO */

/* Define to 1 if the amount of physical memory can be detected with
   pstat_getstatic(). */
/* #undef TUKLIB_PHYSMEM_PSTAT_GETSTATIC */

/* Define to 1 if the amount of physical memory can be detected with
   sysconf(_SC_PAGESIZE) and sysconf(_SC_PHYS_PAGES). */
#define TUKLIB_PHYSMEM_SYSCONF 1

/* Define to 1 if the amount of physical memory can be detected with sysctl().
   */
/* #undef TUKLIB_PHYSMEM_SYSCTL */

/* Define to 1 if the amount of physical memory can be detected with Linux
   sysinfo(). */
/* #undef TUKLIB_PHYSMEM_SYSINFO */

/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif


/* Version number of package */
#define VERSION "5.3.0alpha"

/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
   significant byte first (like Motorola and SPARC, unlike Intel). */
#if defined AC_APPLE_UNIVERSAL_BUILD
# if defined __BIG_ENDIAN__
#  define WORDS_BIGENDIAN 1
# endif
#else
# ifndef WORDS_BIGENDIAN
/* #  undef WORDS_BIGENDIAN */
# endif
#endif

/* Enable large inode numbers on Mac OS X 10.5.  */
#ifndef _DARWIN_USE_64_BIT_INODE
# define _DARWIN_USE_64_BIT_INODE 1
#endif

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define to 1 if on MINIX. */
/* #undef _MINIX */

/* Define to 2 if the system does not provide POSIX.1 features except with
   this defined. */
/* #undef _POSIX_1_SOURCE */

/* Define to 1 if you need to in order for `stat' and other things to work. */
/* #undef _POSIX_SOURCE */

/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
   #define below would cause a syntax error. */
/* #undef _UINT32_T */

/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,
   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
   #define below would cause a syntax error. */
/* #undef _UINT64_T */

/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
   #define below would cause a syntax error. */
/* #undef _UINT8_T */

/* Define to rpl_ if the getopt replacement functions and variables should be
   used. */
/* #undef __GETOPT_PREFIX */

/* Define to the type of a signed integer type of width exactly 32 bits if
   such a type exists and the standard includes do not define it. */
/* #undef int32_t */

/* Define to the type of a signed integer type of width exactly 64 bits if
   such a type exists and the standard includes do not define it. */
/* #undef int64_t */

/* Define to the type of an unsigned integer type of width exactly 16 bits if
   such a type exists and the standard includes do not define it. */
/* #undef uint16_t */

/* Define to the type of an unsigned integer type of width exactly 32 bits if
   such a type exists and the standard includes do not define it. */
/* #undef uint32_t */

/* Define to the type of an unsigned integer type of width exactly 64 bits if
   such a type exists and the standard includes do not define it. */
/* #undef uint64_t */

/* Define to the type of an unsigned integer type of width exactly 8 bits if
   such a type exists and the standard includes do not define it. */
/* #undef uint8_t */

/* Define to the type of an unsigned integer type wide enough to hold a
   pointer, if such a type exists, and if the system does not define it. */
/* #undef uintptr_t */

```

`native/src/include/codegen.rs`:

```rs
// This file hosts shared build script logic

use std::fmt::Display;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::{fs, io, process};

use cxx_gen::{Include, IncludeKind, Opt};

trait ResultExt<T> {
    fn ok_or_exit(self) -> T;
}

impl<T, E: Display> ResultExt<T> for Result<T, E> {
    fn ok_or_exit(self) -> T {
        match self {
            Ok(r) => r,
            Err(e) => {
                eprintln!("error occurred: {e}");
                process::exit(1);
            }
        }
    }
}

fn write_if_diff<P: AsRef<Path>>(path: P, bytes: &[u8]) -> io::Result<()> {
    let path = path.as_ref();
    if let Ok(orig) = fs::read(path) {
        // Do not modify the file if content is the same to make incremental build more optimal
        if orig.as_slice() == bytes {
            return Ok(());
        }
    }
    let mut f = File::create(path)?;
    f.write_all(bytes)
}

pub fn gen_cxx_binding(name: &str) {
    println!("cargo:rerun-if-changed=lib.rs");
    let mut opt = Opt::default();
    opt.cxx_impl_annotations = Some("[[gnu::always_inline]]".to_string());
    opt.include.push(Include {
        path: "rust/cxx.h".to_string(),
        kind: IncludeKind::Bracketed,
    });
    let code = cxx_gen::generate_header_and_cc_with_path("lib.rs", &opt);
    write_if_diff(format!("{name}.cpp"), code.implementation.as_slice()).ok_or_exit();
    write_if_diff(format!("{name}.hpp"), code.header.as_slice()).ok_or_exit();
}

```

`native/src/include/consts.hpp`:

```hpp
#pragma once

#define JAVA_PACKAGE_NAME "com.topjohnwu.magisk"
#define SECURE_DIR      "/data/adb"
#define MODULEROOT      SECURE_DIR "/modules"
#define DATABIN         SECURE_DIR "/magisk"
#define MAGISKDB        SECURE_DIR "/magisk.db"

// tmpfs paths
#define INTLROOT      ".magisk"
#define MIRRDIR       INTLROOT "/mirror"
#define PREINITMIRR   INTLROOT "/preinit"
#define DEVICEDIR     INTLROOT "/device"
#define PREINITDEV    DEVICEDIR "/preinit"
#define WORKERDIR     INTLROOT "/worker"
#define BBPATH        INTLROOT "/busybox"
#define ROOTOVL       INTLROOT "/rootdir"
#define SHELLPTS      INTLROOT "/pts"
#define MAIN_CONFIG   INTLROOT "/config"
#define MAIN_SOCKET   DEVICEDIR "/socket"

constexpr const char *applet_names[] = { "su", "resetprop", nullptr };

#define POST_FS_DATA_WAIT_TIME       40
#define POST_FS_DATA_SCRIPT_MAX_TIME 35

// Unconstrained domain the daemon and root processes run in
#define SEPOL_PROC_DOMAIN   "magisk"
#define MAGISK_PROC_CON     "u:r:" SEPOL_PROC_DOMAIN ":s0"
// Unconstrained file type that anyone can access
#define SEPOL_FILE_TYPE     "magisk_file"
#define MAGISK_FILE_CON     "u:object_r:" SEPOL_FILE_TYPE ":s0"

```

`native/src/include/consts.rs`:

```rs
#![allow(dead_code)]
use base::const_format::concatcp;

#[path = "../../out/generated/flags.rs"]
mod flags;

pub const POST_FS_DATA_WAIT_TIME: i32 = 40;
pub const APPLET_NAMES: &[&str] = &["su", "resetprop"];

// versions
pub use flags::*;
pub const MAGISK_FULL_VER: &str = concatcp!(MAGISK_VERSION, "(", MAGISK_VER_CODE, ")");

pub const APP_PACKAGE_NAME: &str = "com.topjohnwu.magisk";

pub const LOGFILE: &str = "/cache/magisk.log";

// data paths
pub const SECURE_DIR: &str = "/data/adb";
pub const MODULEROOT: &str = concatcp!(SECURE_DIR, "/modules");
pub const MODULEUPGRADE: &str = concatcp!(SECURE_DIR, "/modules_update");
pub const DATABIN: &str = concatcp!(SECURE_DIR, "/magisk");
pub const MAGISKDB: &str = concatcp!(SECURE_DIR, "/magisk.db");

// tmpfs paths
pub const INTERNAL_DIR: &str = ".magisk";
pub const MAIN_CONFIG: &str = concatcp!(INTERNAL_DIR, "/config");
pub const PREINITMIRR: &str = concatcp!(INTERNAL_DIR, "/preinit");
pub const MODULEMNT: &str = concatcp!(INTERNAL_DIR, "/modules");
pub const WORKERDIR: &str = concatcp!(INTERNAL_DIR, "/worker");
pub const BBPATH: &str = concatcp!(INTERNAL_DIR, "/busybox");
pub const DEVICEDIR: &str = concatcp!(INTERNAL_DIR, "/device");
pub const MAIN_SOCKET: &str = concatcp!(DEVICEDIR, "/socket");
pub const PREINITDEV: &str = concatcp!(DEVICEDIR, "/preinit");
pub const LOG_PIPE: &str = concatcp!(DEVICEDIR, "/log");
pub const ROOTOVL: &str = concatcp!(INTERNAL_DIR, "/rootdir");
pub const ROOTMNT: &str = concatcp!(ROOTOVL, "/.mount_list");
pub const SELINUXMOCK: &str = concatcp!(INTERNAL_DIR, "/selinux");

// Unconstrained domain the daemon and root processes run in
pub const SEPOL_PROC_DOMAIN: &str = "magisk";
pub const MAGISK_PROC_CON: &str = concatcp!("u:r:", SEPOL_PROC_DOMAIN, ":s0");
// Unconstrained file type that anyone can access
pub const SEPOL_FILE_TYPE: &str = "magisk_file";
pub const MAGISK_FILE_CON: &str = concatcp!("u:object_r:", SEPOL_FILE_TYPE, ":s0");
// Log pipe that only root and zygote can open
pub const SEPOL_LOG_TYPE: &str = "magisk_log_file";
pub const MAGISK_LOG_CON: &str = concatcp!("u:object_r:", SEPOL_LOG_TYPE, ":s0");

```

`native/src/init/Cargo.toml`:

```toml
[package]
name = "magiskinit"
version.workspace = true
edition.workspace = true

[lib]
crate-type = ["staticlib"]
path = "lib.rs"

[lints]
workspace = true

[build-dependencies]
cxx-gen = { workspace = true }

[dependencies]
base = { workspace = true }
magiskpolicy = { workspace = true, features = ["no-main"] }
cxx = { workspace = true }
num-traits = { workspace = true }

```

`native/src/init/build.rs`:

```rs
use crate::codegen::gen_cxx_binding;

#[path = "../include/codegen.rs"]
mod codegen;

fn main() {
    gen_cxx_binding("init-rs");
}

```

`native/src/init/getinfo.cpp`:

```cpp
#include <sys/sysmacros.h>
#include <sys/types.h>
#include <linux/input.h>
#include <fcntl.h>
#include <vector>

#include <base.hpp>

#include "init.hpp"

using namespace std;

template<char... cs> using chars = integer_sequence<char, cs...>;

// If quoted, parsing ends when we find char in [breaks]
// If not quoted, parsing ends when we find char in [breaks] + [escapes]
template<char... escapes, char... breaks>
static string extract_quoted_str_until(chars<escapes...>, chars<breaks...>,
        string_view str, size_t &pos, bool &quoted) {
    string result;
    char match_array[] = {escapes..., breaks..., '"'};
    string_view match(match_array, std::size(match_array));
    for (size_t cur = pos;; ++cur) {
        cur = str.find_first_of(match, cur);
        if (cur == string_view::npos ||
            ((str[cur] == breaks) || ...) ||
            (!quoted && ((str[cur] == escapes) || ...))) {
            result.append(str.substr(pos, cur - pos));
            pos = cur;
            return result;
        }
        if (str[cur] == '"') {
            quoted = !quoted;
            result.append(str.substr(pos, cur - pos));
            pos = cur + 1;
        }
    }
}

// Parse string into key value pairs.
// The string format: [delim][key][padding][eq][padding][value][delim]
template<char delim, char eq, char... padding>
static kv_pairs parse_impl(chars<padding...>, string_view str) {
    kv_pairs kv;
    char skip_array[] = {eq, padding...};
    string_view skip(skip_array, std::size(skip_array));
    bool quoted = false;
    for (size_t pos = 0u; pos < str.size(); pos = str.find_first_not_of(delim, pos)) {
        auto key = extract_quoted_str_until(
                chars<padding..., delim>{}, chars<eq>{}, str, pos, quoted);
        pos = str.find_first_not_of(skip, pos);
        if (pos == string_view::npos || str[pos] == delim) {
            kv.emplace_back(key, "");
            continue;
        }
        auto value = extract_quoted_str_until(chars<delim>{}, chars<>{}, str, pos, quoted);
        kv.emplace_back(key, value);
    }
    return kv;
}

static kv_pairs parse_cmdline(string_view str) {
    return parse_impl<' ', '='>(chars<>{}, str);
}
static kv_pairs parse_bootconfig(string_view str) {
    return parse_impl<'\n', '='>(chars<' '>{}, str);
}
static kv_pairs parse_partition_map(std::string_view str) {
    return parse_impl<';', ','>(chars<>{}, str);
}

#define test_bit(bit, array) (array[bit / 8] & (1 << (bit % 8)))

static bool check_key_combo() {
    LOGD("Running in recovery mode, waiting for key...\n");
    uint8_t bitmask[(KEY_MAX + 1) / 8];
    vector<int> events;
    constexpr const char *name = "/event";

    for (int minor = 64; minor < 96; ++minor) {
        if (xmknod(name, S_IFCHR | 0444, makedev(13, minor)))
            continue;
        int fd = open(name, O_RDONLY | O_CLOEXEC);
        unlink(name);
        if (fd < 0)
            continue;
        memset(bitmask, 0, sizeof(bitmask));
        ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(bitmask)), bitmask);
        if (test_bit(KEY_VOLUMEUP, bitmask))
            events.push_back(fd);
        else
            close(fd);
    }
    if (events.empty())
        return false;

    run_finally fin([&] { for_each(events.begin(), events.end(), close); });

    // Return true if volume up key is held for more than 3 seconds
    int count = 0;
    for (int i = 0; i < 500; ++i) {
        for (const int &fd : events) {
            memset(bitmask, 0, sizeof(bitmask));
            ioctl(fd, EVIOCGKEY(sizeof(bitmask)), bitmask);
            if (test_bit(KEY_VOLUMEUP, bitmask)) {
                count++;
                break;
            }
        }
        if (count >= 300) {
            LOGD("KEY_VOLUMEUP detected: disable system-as-root\n");
            return true;
        }
        // Check every 10ms
        usleep(10000);
    }
    return false;
}

void BootConfig::set(const kv_pairs &kv) noexcept {
    for (const auto &[key, value] : kv) {
        if (key == "androidboot.slot_suffix") {
            // Many Amlogic devices are A-only but have slot_suffix...
            if (value == "normal") {
                LOGW("Skip invalid androidboot.slot_suffix=[normal]\n");
                continue;
            }
            strscpy(slot.data(), value.data(), slot.size());
        } else if (key == "androidboot.slot") {
            slot[0] = '_';
            strscpy(slot.data() + 1, value.data(), slot.size() - 1);
        } else if (key == "skip_initramfs") {
            skip_initramfs = true;
        } else if (key == "androidboot.force_normal_boot") {
            force_normal_boot = !value.empty() && value[0] == '1';
        } else if (key == "rootwait") {
            rootwait = true;
        } else if (key == "androidboot.android_dt_dir") {
            strscpy(dt_dir.data(), value.data(), dt_dir.size());
        } else if (key == "androidboot.hardware") {
            strscpy(hardware.data(), value.data(), hardware.size());
        } else if (key == "androidboot.hardware.platform") {
            strscpy(hardware_plat.data(), value.data(), hardware_plat.size());
        } else if (key == "androidboot.fstab_suffix") {
            strscpy(fstab_suffix.data(), value.data(), fstab_suffix.size());
        } else if (key == "androidboot.mode") {
            strscpy(boot_mode.data(), value.data(), boot_mode.size());
        } else if (key == "qemu") {
            emulator = true;
        } else if (key == "androidboot.partition_map") {
            // androidboot.partition_map allows mapping a partition name to a raw block device.
            // For example, "androidboot.partition_map=vdb,metadata;vdc,userdata" maps
            // "vdb" to "metadata", and "vdc" to "userdata".
            // https://android.googlesource.com/platform/system/core/+/refs/heads/android13-release/init/devices.cpp#191
            for (const auto &[k, v]: parse_partition_map(value)) {
                partition_map.emplace_back(k, v);
            }
        }
    }
}

#define read_dt(name, key)                                          \
ssprintf(file_name, sizeof(file_name), "%s/" name, dt_dir.data());  \
if (access(file_name, R_OK) == 0) {                                 \
    string data = full_read(file_name);                             \
    if (!data.empty()) {                                            \
        data.pop_back();                                            \
        strscpy(key.data(), data.data(), key.size());               \
    }                                                               \
}

void BootConfig::init() noexcept {
    set(parse_cmdline(full_read("/proc/cmdline")));
    set(parse_bootconfig(full_read("/proc/bootconfig")));

    parse_prop_file("/.backup/.magisk", [&](auto key, auto value) -> bool {
        if (key == "RECOVERYMODE" && value == "true") {
            skip_initramfs = emulator || !check_key_combo();
            return false;
        }
        return true;
    });

    if (dt_dir[0] == '\0')
        strscpy(dt_dir.data(), DEFAULT_DT_DIR, dt_dir.size());

    char file_name[128];
    read_dt("fstab_suffix", fstab_suffix)
    read_dt("hardware", hardware)
    read_dt("hardware.platform", hardware_plat)

    LOGD("Device config:\n");
    print();
}

```

`native/src/init/getinfo.rs`:

```rs
use crate::ffi::{BootConfig, MagiskInit, backup_init};
use base::{BytesExt, MappedFile, cstr};

impl BootConfig {
    #[allow(unused_imports, unused_unsafe)]
    pub(crate) fn print(&self) {
        use base::{Utf8CStr, debug};
        debug!("skip_initramfs=[{}]", self.skip_initramfs);
        debug!("force_normal_boot=[{}]", self.force_normal_boot);
        debug!("rootwait=[{}]", self.rootwait);
        unsafe {
            debug!(
                "boot_mode=[{}]",
                Utf8CStr::from_ptr_unchecked(self.boot_mode.as_ptr())
            );
            debug!(
                "slot=[{}]",
                Utf8CStr::from_ptr_unchecked(self.slot.as_ptr())
            );
            debug!(
                "dt_dir=[{}]",
                Utf8CStr::from_ptr_unchecked(self.dt_dir.as_ptr())
            );
            debug!(
                "fstab_suffix=[{}]",
                Utf8CStr::from_ptr_unchecked(self.fstab_suffix.as_ptr())
            );
            debug!(
                "hardware=[{}]",
                Utf8CStr::from_ptr_unchecked(self.hardware.as_ptr())
            );
            debug!(
                "hardware.platform=[{}]",
                Utf8CStr::from_ptr_unchecked(self.hardware_plat.as_ptr())
            );
        }
        debug!("emulator=[{}]", self.emulator);
        debug!("partition_map=[{:?}]", self.partition_map);
    }
}

impl MagiskInit {
    pub(crate) fn check_two_stage(&self) -> bool {
        cstr!("/first_stage_ramdisk").exists() ||
            cstr!("/second_stage_resources").exists() ||
            cstr!("/system/bin/init").exists() ||
            // Use the apex folder to determine whether 2SI (Android 10+)
            cstr!("/apex").exists() ||
            // If we still have no indication, parse the original init and see what's up
            MappedFile::open(Some(cstr!("/init.real")).take_if(|p| p.exists()).unwrap_or(backup_init()))
                .map(|data| data.contains(b"selinux_setup"))
                .unwrap_or(false)
    }
}

```

`native/src/init/init.hpp`:

```hpp
#pragma once

#define DEFAULT_DT_DIR "/proc/device-tree/firmware/android"
#define REDIR_PATH "/data/magiskinit"

#define PRELOAD_LIB    "/dev/preload.so"
#define PRELOAD_POLICY "/dev/sepolicy"
#define PRELOAD_ACK    "/dev/ack"

#ifdef __cplusplus

#include <base.hpp>
#include <sepolicy.hpp>

using kv_pairs = std::vector<std::pair<std::string, std::string>>;

#include "init-rs.hpp"

int magisk_proxy_main(int, char *argv[]);
Utf8CStr backup_init();

// Expose some constants to Rust

static inline Utf8CStr split_plat_cil() {
    return SPLIT_PLAT_CIL;
};

static inline Utf8CStr preload_lib() {
    return PRELOAD_LIB;
}

static inline Utf8CStr preload_policy() {
    return PRELOAD_POLICY;
}

static inline Utf8CStr preload_ack() {
    return PRELOAD_ACK;
}


#endif

```

`native/src/init/init.rs`:

```rs
use crate::ffi::{BootConfig, MagiskInit, backup_init, magisk_proxy_main};
use crate::logging::setup_klog;
use crate::mount::is_rootfs;
use crate::twostage::hexpatch_init_for_second_stage;
use base::libc::{basename, getpid, mount, umask};
use base::{LibcReturn, LoggedResult, ResultExt, cstr, info, raw_cstr};
use std::ffi::{CStr, c_char};
use std::ptr::null;

impl MagiskInit {
    fn new(argv: *mut *mut c_char) -> Self {
        Self {
            preinit_dev: String::new(),
            mount_list: Vec::new(),
            overlay_con: Vec::new(),
            argv,
            config: BootConfig {
                skip_initramfs: false,
                force_normal_boot: false,
                rootwait: false,
                emulator: false,
                slot: [0; 3],
                dt_dir: [0; 64],
                fstab_suffix: [0; 32],
                hardware: [0; 32],
                hardware_plat: [0; 32],
                boot_mode: [0; 16],
                partition_map: Vec::new(),
            },
        }
    }

    fn first_stage(&self) {
        info!("First Stage Init");
        self.prepare_data();

        if !cstr!("/sdcard").exists() && !cstr!("/first_stage_ramdisk/sdcard").exists() {
            self.hijack_init_with_switch_root();
            self.restore_ramdisk_init();
        } else {
            self.restore_ramdisk_init();
            // Fallback to hexpatch if /sdcard exists
            hexpatch_init_for_second_stage(true);
        }
    }

    fn second_stage(&mut self) {
        info!("Second Stage Init");

        cstr!("/init").unmount().ok();
        cstr!("/system/bin/init").unmount().ok(); // just in case
        cstr!("/data/init").remove().ok();

        unsafe {
            // Make sure init dmesg logs won't get messed up
            *self.argv = raw_cstr!("/system/bin/init") as *mut _;
        }

        // Some weird devices like meizu, uses 2SI but still have legacy rootfs
        if is_rootfs() {
            // We are still on rootfs, so make sure we will execute the init of the 2nd stage
            let init_path = cstr!("/init");
            init_path.remove().ok();
            init_path
                .create_symlink_to(cstr!("/system/bin/init"))
                .log_ok();
            self.patch_rw_root();
        } else {
            self.patch_ro_root();
        }
    }

    fn legacy_system_as_root(&mut self) {
        info!("Legacy SAR Init");
        self.prepare_data();
        let is_two_stage = self.mount_system_root();
        if is_two_stage {
            hexpatch_init_for_second_stage(false);
        } else {
            self.patch_ro_root();
        }
    }

    fn rootfs(&mut self) {
        info!("RootFS Init");
        self.prepare_data();
        self.restore_ramdisk_init();
        self.patch_rw_root();
    }

    fn recovery_or_charger(&self) {
        info!("Charger mode or ramdisk is recovery, abort");
        self.restore_ramdisk_init();
        cstr!("/.backup").remove_all().ok();
    }

    fn restore_ramdisk_init(&self) {
        cstr!("/init").remove().ok();

        let orig_init = backup_init();

        if orig_init.exists() {
            orig_init.rename_to(cstr!("/init")).log_ok();
        } else {
            // If the backup init is missing, this means that the boot ramdisk
            // was created from scratch, and the real init is in a separate CPIO,
            // which is guaranteed to be placed at /system/bin/init.
            cstr!("/init")
                .create_symlink_to(cstr!("/system/bin/init"))
                .log_ok();
        }
    }

    fn start(&mut self) -> LoggedResult<()> {
        if !cstr!("/proc/cmdline").exists() {
            cstr!("/proc").mkdir(0o755)?;
            unsafe {
                mount(
                    raw_cstr!("proc"),
                    raw_cstr!("/proc"),
                    raw_cstr!("proc"),
                    0,
                    null(),
                )
            }
            .check_err()?;
            self.mount_list.push("/proc".to_string());
        }
        if !cstr!("/sys/block").exists() {
            cstr!("/sys").mkdir(0o755)?;
            unsafe {
                mount(
                    raw_cstr!("sysfs"),
                    raw_cstr!("/sys"),
                    raw_cstr!("sysfs"),
                    0,
                    null(),
                )
            }
            .check_err()?;
            self.mount_list.push("/sys".to_string());
        }

        setup_klog();

        self.config.init();

        let argv1 = unsafe { *self.argv.offset(1) };
        if !argv1.is_null() && unsafe { CStr::from_ptr(argv1) == c"selinux_setup" } {
            self.second_stage();
        } else if self.config.skip_initramfs {
            self.legacy_system_as_root();
        } else if self.config.force_normal_boot {
            self.first_stage();
        } else if cstr!("/sbin/recovery").exists()
            || cstr!("/system/bin/recovery").exists()
            || unsafe { CStr::from_ptr(self.config.boot_mode.as_ptr()) } == c"charger"
        {
            self.recovery_or_charger();
        } else if self.check_two_stage() {
            self.first_stage();
        } else {
            self.rootfs();
        }

        // Finally execute the original init
        self.exec_init();

        Ok(())
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn main(
    argc: i32,
    argv: *mut *mut c_char,
    _envp: *const *const c_char,
) -> i32 {
    unsafe {
        umask(0);

        let name = basename(*argv);

        if CStr::from_ptr(name) == c"magisk" {
            return magisk_proxy_main(argc, argv);
        }

        if getpid() == 1 {
            MagiskInit::new(argv).start().log_ok();
        }

        1
    }
}

```

`native/src/init/lib.rs`:

```rs
#![allow(clippy::missing_safety_doc)]

use logging::setup_klog;
// Has to be pub so all symbols in that crate is included
pub use magiskpolicy;
use mount::{is_device_mounted, switch_root};
use rootdir::{OverlayAttr, inject_magisk_rc};

#[path = "../include/consts.rs"]
mod consts;
mod getinfo;
mod init;
mod logging;
mod mount;
mod rootdir;
mod selinux;
mod twostage;

#[cxx::bridge]
pub mod ffi {
    #[derive(Debug)]
    struct KeyValue {
        key: String,
        value: String,
    }

    struct BootConfig {
        skip_initramfs: bool,
        force_normal_boot: bool,
        rootwait: bool,
        emulator: bool,
        slot: [c_char; 3],
        dt_dir: [c_char; 64],
        fstab_suffix: [c_char; 32],
        hardware: [c_char; 32],
        hardware_plat: [c_char; 32],
        boot_mode: [c_char; 16],
        partition_map: Vec<KeyValue>,
    }

    struct MagiskInit {
        preinit_dev: String,
        mount_list: Vec<String>,
        argv: *mut *mut c_char,
        config: BootConfig,
        overlay_con: Vec<OverlayAttr>,
    }

    unsafe extern "C++" {
        include!("init.hpp");

        #[cxx_name = "Utf8CStr"]
        type Utf8CStrRef<'a> = base::Utf8CStrRef<'a>;

        unsafe fn magisk_proxy_main(argc: i32, argv: *mut *mut c_char) -> i32;
        fn backup_init() -> Utf8CStrRef<'static>;

        // Constants
        fn split_plat_cil() -> Utf8CStrRef<'static>;
        fn preload_lib() -> Utf8CStrRef<'static>;
        fn preload_policy() -> Utf8CStrRef<'static>;
        fn preload_ack() -> Utf8CStrRef<'static>;
    }

    #[namespace = "rust"]
    extern "Rust" {
        fn setup_klog();
        fn inject_magisk_rc(fd: i32, tmp_dir: Utf8CStrRef);
        fn switch_root(path: Utf8CStrRef);
        fn is_device_mounted(dev: u64, target: Pin<&mut CxxString>) -> bool;
    }

    // BootConfig
    extern "Rust" {
        fn print(self: &BootConfig);
    }
    unsafe extern "C++" {
        fn init(self: &mut BootConfig);
        type kv_pairs;
        fn set(self: &mut BootConfig, config: &kv_pairs);
    }

    // MagiskInit
    extern "Rust" {
        type OverlayAttr;
        fn parse_config_file(self: &mut MagiskInit);
        fn mount_overlay(self: &mut MagiskInit, dest: Utf8CStrRef);
        fn handle_sepolicy(self: &mut MagiskInit);
        fn restore_overlay_contexts(self: &MagiskInit);
    }
    unsafe extern "C++" {
        // Used in Rust
        fn mount_system_root(self: &mut MagiskInit) -> bool;
        fn patch_rw_root(self: &mut MagiskInit);
        fn patch_ro_root(self: &mut MagiskInit);

        // Used in C++
        unsafe fn setup_tmp(self: &mut MagiskInit, path: *const c_char);
        fn collect_devices(self: &MagiskInit);
        fn mount_preinit_dir(self: &mut MagiskInit);
        unsafe fn find_block(self: &MagiskInit, partname: *const c_char) -> u64;
        unsafe fn patch_fissiond(self: &mut MagiskInit, tmp_path: *const c_char);
    }
}

```

`native/src/init/logging.rs`:

```rs
use base::nix::fcntl::OFlag;
use base::{LogLevel, SilentLogExt, Utf8CStr, cstr, libc, raw_cstr, update_logger};
use libc::{
    O_CLOEXEC, S_IFCHR, STDERR_FILENO, STDIN_FILENO, STDOUT_FILENO, SYS_dup3, makedev, mknod,
    syscall,
};
use std::fs::File;
use std::io::{IoSlice, Write};
use std::mem::ManuallyDrop;
use std::os::fd::{FromRawFd, IntoRawFd, RawFd};

// SAFETY: magiskinit is single threaded
static mut KMSG: RawFd = -1;

pub fn setup_klog() {
    unsafe {
        // Shut down first 3 fds
        let mut fd = cstr!("/dev/null")
            .open(OFlag::O_RDWR | OFlag::O_CLOEXEC)
            .silent();
        if fd.is_err() {
            mknod(raw_cstr!("/null"), S_IFCHR | 0o666, makedev(1, 3));
            fd = cstr!("/null")
                .open(OFlag::O_RDWR | OFlag::O_CLOEXEC)
                .silent();
            cstr!("/null").remove().ok();
        }
        if let Ok(ref fd) = fd {
            syscall(SYS_dup3, fd, STDIN_FILENO, O_CLOEXEC);
            syscall(SYS_dup3, fd, STDOUT_FILENO, O_CLOEXEC);
            syscall(SYS_dup3, fd, STDERR_FILENO, O_CLOEXEC);
        }

        // Then open kmsg fd
        let mut fd = cstr!("/dev/kmsg")
            .open(OFlag::O_WRONLY | OFlag::O_CLOEXEC)
            .silent();
        if fd.is_err() {
            mknod(raw_cstr!("/kmsg"), S_IFCHR | 0o666, makedev(1, 11));
            fd = cstr!("/kmsg")
                .open(OFlag::O_WRONLY | OFlag::O_CLOEXEC)
                .silent();
            cstr!("/kmsg").remove().ok();
        }
        KMSG = fd.map(|fd| fd.into_raw_fd()).unwrap_or(-1);
    }

    // Disable kmsg rate limiting
    if let Ok(mut rate) =
        cstr!("/proc/sys/kernel/printk_devkmsg").open(OFlag::O_WRONLY | OFlag::O_CLOEXEC)
    {
        writeln!(rate, "on").ok();
    }

    fn kmsg_log_write(_: LogLevel, msg: &Utf8CStr) {
        let fd = unsafe { KMSG };
        if fd >= 0 {
            let io1 = IoSlice::new("magiskinit: ".as_bytes());
            let io2 = IoSlice::new(msg.as_bytes());
            let mut kmsg = ManuallyDrop::new(unsafe { File::from_raw_fd(fd) });
            let _ = kmsg.write_vectored(&[io1, io2]).ok();
        }
    }

    update_logger(|logger| logger.write = kmsg_log_write);
}

```

`native/src/init/mount.cpp`:

```cpp
#include <set>
#include <sys/mount.h>
#include <sys/sysmacros.h>
#include <libgen.h>

#include <base.hpp>
#include <consts.hpp>

#include "init.hpp"

using namespace std;

struct devinfo {
    int major;
    int minor;
    char devname[32];
    char partname[32];
    char dmname[32];
    char devpath[PATH_MAX];
};

static vector<devinfo> dev_list;

// When this boolean is set, this means we are currently
// running magiskinit on legacy SAR AVD emulator
bool avd_hack = false;

static void parse_device(devinfo *dev, const char *uevent) {
    dev->partname[0] = '\0';
    dev->devpath[0] = '\0';
    dev->dmname[0] = '\0';
    dev->devname[0] = '\0';
    parse_prop_file(uevent, [=](Utf8CStr key, Utf8CStr value) -> bool {
        if (key == "MAJOR")
            dev->major = parse_int(value);
        else if (key == "MINOR")
            dev->minor = parse_int(value);
        else if (key == "DEVNAME")
            strscpy(dev->devname, value.c_str(), sizeof(dev->devname));
        else if (key == "PARTNAME")
            strscpy(dev->partname, value.c_str(), sizeof(dev->devname));

        return true;
    });
}

void MagiskInit::collect_devices() const noexcept {
    char path[PATH_MAX];
    devinfo dev{};
    if (auto dir = xopen_dir("/sys/dev/block"); dir) {
        for (dirent *entry; (entry = readdir(dir.get()));) {
            if (entry->d_name == "."sv || entry->d_name == ".."sv)
                continue;
            sprintf(path, "/sys/dev/block/%s/uevent", entry->d_name);
            parse_device(&dev, path);
            sprintf(path, "/sys/dev/block/%s/dm/name", entry->d_name);
            if (access(path, F_OK) == 0) {
                auto name = rtrim(full_read(path));
                strscpy(dev.dmname, name.data(), sizeof(dev.dmname));
            }
            if (auto it = std::ranges::find_if(config.partition_map, [&](const auto &i) {
                return i.key == dev.devname;
            }); dev.partname[0] == '\0' && it != config.partition_map.end()) {
                // use androidboot.partition_map as partname fallback.
                strscpy(dev.partname, it->value.data(), sizeof(dev.partname));
            }
            sprintf(path, "/sys/dev/block/%s", entry->d_name);
            xrealpath(path, dev.devpath, sizeof(dev.devpath));
            dev_list.push_back(dev);
        }
    }
}

uint64_t MagiskInit::find_block(const char *partname) const noexcept {
    if (dev_list.empty())
        collect_devices();

    for (int tries = 0; tries < 3; ++tries) {
        for (auto &dev : dev_list) {
            const char *name;
            if (strcasecmp(dev.partname, partname) == 0)
                name = dev.partname;
            else if (strcasecmp(dev.dmname, partname) == 0)
                name = dev.dmname;
            else if (strcasecmp(dev.devname, partname) == 0)
                name = dev.devname;
            else if (std::string_view(dev.devpath).ends_with("/"s + partname))
                name = dev.devpath;
            else
                continue;

            LOGD("Found %s: [%s] (%d, %d)\n", name, dev.devname, dev.major, dev.minor);
            return makedev(dev.major, dev.minor);
        }
        // Wait 10ms and try again
        usleep(10000);
        dev_list.clear();
        collect_devices();
    }

    // The requested partname does not exist
    return 0;
}

void MagiskInit::mount_preinit_dir() noexcept {
    if (preinit_dev.empty()) return;
    auto dev = find_block(preinit_dev.c_str());
    if (dev == 0) {
        LOGE("Cannot find preinit %s, abort!\n", preinit_dev.c_str());
        return;
    }
    xmknod(PREINITDEV, S_IFBLK | 0600, dev);
    xmkdir(MIRRDIR, 0);
    bool mounted = false;
    // First, find if it is already mounted
    std::string mnt_point;
    if (rust::is_device_mounted(dev, mnt_point)) {
        // Already mounted, just bind mount
        xmount(mnt_point.data(), MIRRDIR, nullptr, MS_BIND, nullptr);
        mounted = true;
    }

    // Since we are mounting the block device directly, make sure to ONLY mount the partitions
    // as read-only, or else the kernel might crash due to crappy drivers.
    // After the device boots up, magiskd will properly symlink the correct path at PREINITMIRR as writable.
    if (mounted || mount(PREINITDEV, MIRRDIR, "ext4", MS_RDONLY, nullptr) == 0 ||
        mount(PREINITDEV, MIRRDIR, "f2fs", MS_RDONLY, nullptr) == 0) {
        string preinit_dir = resolve_preinit_dir(MIRRDIR);
        // Create bind mount
        xmkdirs(PREINITMIRR, 0);
        if (access(preinit_dir.data(), F_OK)) {
            LOGW("empty preinit: %s\n", preinit_dir.data());
        } else {
            LOGD("preinit: %s\n", preinit_dir.data());
            xmount(preinit_dir.data(), PREINITMIRR, nullptr, MS_BIND, nullptr);
        }
        xumount2(MIRRDIR, MNT_DETACH);
    } else {
        PLOGE("Mount preinit %s", preinit_dev.c_str());
        // Do NOT delete the block device. Even though we cannot mount it here,
        // it might get formatted later in the boot process.
    }
}

bool MagiskInit::mount_system_root() noexcept {
    LOGD("Mounting system_root\n");

    // there's no /dev in stub cpio
    xmkdir("/dev", 0777);

    dev_t dev;
    do {
        // Try legacy SAR dm-verity
        dev = find_block("vroot");
        if (dev > 0)
            goto mount_root;

        // Try NVIDIA naming scheme
        dev = find_block("APP");
        if (dev > 0)
            goto mount_root;

        // Try normal partname
        char sys_part[32];
        sprintf(sys_part, "system%s", config.slot.data());
        dev = find_block(sys_part);
        if (dev > 0)
            goto mount_root;

        // Poll forever if rootwait was given in cmdline
    } while (config.rootwait);

    // We don't really know what to do at this point...
    LOGE("Cannot find root partition, abort\n");
    exit(1);

mount_root:
    xmknod("/dev/root", S_IFBLK | 0600, dev);
    xmkdir("/system_root", 0755);

    if (xmount("/dev/root", "/system_root", "ext4", MS_RDONLY, nullptr)) {
        if (xmount("/dev/root", "/system_root", "erofs", MS_RDONLY, nullptr)) {
            // We don't really know what to do at this point...
            LOGE("Cannot mount root partition, abort\n");
            exit(1);
        }
    }

    rust::switch_root("/system_root");

    // Make dev writable
    xmount("tmpfs", "/dev", "tmpfs", 0, "mode=755");
    mount_list.emplace_back("/dev");

    bool is_two_stage = access("/system/bin/init", F_OK) == 0;
    LOGD("is_two_stage: [%d]\n", is_two_stage);

    // For API 28 AVD, it uses legacy SAR setup that requires
    // special hacks in magiskinit to work properly.
    if (!is_two_stage && config.emulator) {
        avd_hack = true;
        // These values are hardcoded for API 28 AVD
        auto vendor_dev = find_block("vendor");
        xmkdir("/dev/block", 0755);
        xmknod("/dev/block/vde1", S_IFBLK | 0600, vendor_dev);
        xmount("/dev/block/vde1", "/vendor", "ext4", MS_RDONLY, nullptr);
    }

    return is_two_stage;
}

void MagiskInit::setup_tmp(const char *path) noexcept {
    LOGD("Setup Magisk tmp at %s\n", path);
    chdir("/data");

    xmkdir(INTLROOT, 0711);
    xmkdir(DEVICEDIR, 0711);
    xmkdir(WORKERDIR, 0);

    mount_preinit_dir();

    cp_afc(".backup/.magisk", MAIN_CONFIG);
    rm_rf(".backup");

    // Create applet symlinks
    for (int i = 0; applet_names[i]; ++i)
        xsymlink("./magisk", applet_names[i]);
    xsymlink("./magiskpolicy", "supolicy");

    xmount(".", path, nullptr, MS_BIND, nullptr);

    chdir(path);

    // Prepare worker
    xmount("magisk", WORKERDIR, "tmpfs", 0, "mode=755");

    // Use isolated devpts if kernel support
    if (access("/dev/pts/ptmx", F_OK) == 0) {
        xmkdirs(SHELLPTS, 0755);
        xmount("devpts", SHELLPTS, "devpts", MS_NOSUID | MS_NOEXEC, "newinstance");
        xmount(nullptr, SHELLPTS, nullptr, MS_PRIVATE, nullptr);
        if (access(SHELLPTS "/ptmx", F_OK)) {
            umount2(SHELLPTS, MNT_DETACH);
            rmdir(SHELLPTS);
        }
    }

    chdir("/");
}

```

`native/src/init/mount.rs`:

```rs
use crate::ffi::MagiskInit;
use base::{
    Directory, FsPathBuilder, LibcReturn, LoggedResult, ResultExt, Utf8CStr, cstr, debug, libc,
    nix, parse_mount_info, raw_cstr,
};
use cxx::CxxString;
use nix::mount::MsFlags;
use nix::sys::statfs::{FsType, TMPFS_MAGIC, statfs};
use nix::unistd::{chdir, chroot};
use num_traits::AsPrimitive;
use std::collections::BTreeSet;
use std::ops::Bound::{Excluded, Unbounded};
use std::pin::Pin;

unsafe extern "C" {
    static environ: *const *mut libc::c_char;
}

pub(crate) fn switch_root(path: &Utf8CStr) {
    || -> LoggedResult<()> {
        debug!("Switch root to {}", path);
        let mut mounts = BTreeSet::new();
        let rootfs = Directory::open(cstr!("/"))?;
        for info in parse_mount_info("self") {
            if info.target == "/" || info.target.as_str() == path.as_str() {
                continue;
            }
            if let Some(last_mount) = mounts
                .range::<String, _>((Unbounded, Excluded(&info.target)))
                .last()
                && info.target.starts_with(&format!("{}/", *last_mount))
            {
                continue;
            }

            let mut target = info.target.clone();
            let target = Utf8CStr::from_string(&mut target);
            let new_path = cstr::buf::default()
                .join_path(path)
                .join_path(info.target.trim_start_matches('/'));
            new_path.mkdirs(0o755).ok();
            target.move_mount_to(&new_path)?;
            mounts.insert(info.target);
        }
        chdir(path)?;
        path.move_mount_to(cstr!("/"))?;
        chroot(cstr!("."))?;

        debug!("Cleaning rootfs");
        rootfs.remove_all()?;
        Ok(())
    }()
    .ok();
}

pub(crate) fn is_device_mounted(dev: u64, target: Pin<&mut CxxString>) -> bool {
    for mount in parse_mount_info("self") {
        if mount.root == "/" && mount.device == dev {
            target.push_str(&mount.target);
            return true;
        }
    }
    false
}

const RAMFS_MAGIC: u32 = 0x858458f6;

pub(crate) fn is_rootfs() -> bool {
    if let Ok(s) = statfs(cstr!("/")) {
        s.filesystem_type() == FsType(RAMFS_MAGIC.as_()) || s.filesystem_type() == TMPFS_MAGIC
    } else {
        false
    }
}

impl MagiskInit {
    pub(crate) fn prepare_data(&self) {
        debug!("Setup data tmp");
        cstr!("/data").mkdir(0o755).log_ok();
        nix::mount::mount(
            Some(cstr!("magisk")),
            cstr!("/data"),
            Some(cstr!("tmpfs")),
            MsFlags::empty(),
            Some(cstr!("mode=755")),
        )
        .check_os_err("mount", Some("/data"), Some("tmpfs"))
        .log_ok();

        cstr!("/init").copy_to(cstr!("/data/magiskinit")).ok();
        cstr!("/.backup").copy_to(cstr!("/data/.backup")).ok();
        cstr!("/overlay.d").copy_to(cstr!("/data/overlay.d")).ok();
    }

    pub(crate) fn exec_init(&mut self) {
        for path in self.mount_list.iter_mut().rev() {
            let path = Utf8CStr::from_string(path);
            if path.unmount().log().is_ok() {
                debug!("Unmount [{}]", path);
            }
        }
        unsafe {
            libc::execve(raw_cstr!("/init"), self.argv.cast(), environ.cast())
                .check_err()
                .log_ok();
        }
        std::process::exit(1);
    }
}

```

`native/src/init/preload.c`:

```c
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#include "init.hpp"

__attribute__((constructor))
static void preload_init() {
    // Make sure our next exec won't get bugged
    unsetenv("LD_PRELOAD");
    unlink(PRELOAD_LIB);
}

int security_load_policy(void *data, size_t len) {
    int policy = open(PRELOAD_POLICY, O_WRONLY | O_CREAT, 0644);
    if (policy < 0) return -1;

    // Write the policy
    write(policy, data, len);
    close(policy);

    // Wait for ack
    int ack = open(PRELOAD_ACK, O_RDONLY);
    char c;
    read(ack, &c, 1);
    close(ack);

    return 0;
}

```

`native/src/init/rootdir.cpp`:

```cpp
#include <sys/mount.h>
#include <libgen.h>

#include <sepolicy.hpp>
#include <consts.hpp>
#include <base.hpp>
#include <xz.h>

#include "init.hpp"

using namespace std;

static vector<string> rc_list;

#define NEW_INITRC_DIR  "/system/etc/init/hw"
#define INIT_RC         "init.rc"

static bool unxz(int fd, rust::Slice<const uint8_t> bytes) {
    uint8_t out[8192];
    xz_crc32_init();
    size_t size = bytes.size();
    struct xz_dec *dec = xz_dec_init(XZ_DYNALLOC, 1 << 26);
    run_finally finally([&] { xz_dec_end(dec); });
    struct xz_buf b = {
        .in = bytes.data(),
        .in_pos = 0,
        .in_size = size,
        .out = out,
        .out_pos = 0,
        .out_size = sizeof(out)
    };
    enum xz_ret ret;
    do {
        ret = xz_dec_run(dec, &b);
        if (ret != XZ_OK && ret != XZ_STREAM_END)
            return false;
        write(fd, out, b.out_pos);
        b.out_pos = 0;
    } while (b.in_pos != size);
    return true;
}

// When return true, run patch_fissiond
static bool patch_rc_scripts(const char *src_path, const char *tmp_path, bool writable) {
    auto src_dir = xopen_dir(src_path);
    if (!src_dir) return false;
    int src_fd = dirfd(src_dir.get());

    // If writable, directly modify the file in src_path, or else add to rootfs overlay
    auto dest_dir = writable ? [&] {
        return xopen_dir(src_path);
    }() : [&] {
        char buf[PATH_MAX] = {};
        ssprintf(buf, sizeof(buf), ROOTOVL "%s", src_path);
        xmkdirs(buf, 0755);
        return xopen_dir(buf);
    }();
    if (!dest_dir) return false;
    int dest_fd = dirfd(dest_dir.get());

    // First patch init.rc
    {
        owned_fd src_rc = xopenat(src_fd, INIT_RC, O_RDONLY | O_CLOEXEC, 0);
        if (src_rc < 0) return false;
        if (writable) unlinkat(src_fd, INIT_RC, 0);
        auto dest_rc = xopen_file(
                xopenat(dest_fd, INIT_RC, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, 0), "we");
        if (!dest_rc) return false;
        LOGD("Patching " INIT_RC " in %s\n", src_path);
        file_readline(src_rc, [&dest_rc](Utf8CStr line) -> bool {
            // Do not start vaultkeeper
            if (line.sv().contains("start vaultkeeper")) {
                LOGD("Remove vaultkeeper\n");
                return true;
            }
            // Do not run flash_recovery
            if (line.sv().starts_with("service flash_recovery")) {
                LOGD("Remove flash_recovery\n");
                fprintf(dest_rc.get(), "service flash_recovery /system/bin/true\n");
                return true;
            }
            // Samsung's persist.sys.zygote.early will cause Zygote to start before post-fs-data
            if (line.sv().starts_with("on property:persist.sys.zygote.early=")) {
                LOGD("Invalidate persist.sys.zygote.early\n");
                fprintf(dest_rc.get(), "on property:persist.sys.zygote.early.xxxxx=true\n");
                return true;
            }
            // Else just write the line
            fprintf(dest_rc.get(), "%s", line.c_str());
            return true;
        });

        fprintf(dest_rc.get(), "\n");

        // Inject custom rc scripts
        for (auto &script : rc_list) {
            // Replace template arguments of rc scripts with dynamic paths
            replace_all(script, "${MAGISKTMP}", tmp_path);
            fprintf(dest_rc.get(), "\n%s\n", script.data());
        }
        rc_list.clear();

        // Inject Magisk rc scripts
        rust::inject_magisk_rc(fileno(dest_rc.get()), tmp_path);

        fclone_attr(src_rc, fileno(dest_rc.get()));
    }

    // Then patch init.zygote*.rc
    for (dirent *entry; (entry = readdir(src_dir.get()));) {
        {
            auto name = std::string_view(entry->d_name);
            if (!name.starts_with("init.zygote") || !name.ends_with(".rc")) continue;
        }
        owned_fd src_rc = xopenat(src_fd, entry->d_name, O_RDONLY | O_CLOEXEC, 0);
        if (src_rc < 0) continue;
        if (writable) unlinkat(src_fd, entry->d_name, 0);
        auto dest_rc = xopen_file(
                xopenat(dest_fd, entry->d_name, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, 0), "we");
        if (!dest_rc) continue;
        LOGD("Patching %s in %s\n", entry->d_name, src_path);
        file_readline(src_rc, [&dest_rc, &tmp_path](Utf8CStr line) -> bool {
            if (line.sv().starts_with("service zygote ")) {
                LOGD("Inject zygote restart\n");
                fprintf(dest_rc.get(), "%s", line.c_str());
                fprintf(dest_rc.get(),
                        "    onrestart exec " MAGISK_PROC_CON " 0 0 -- %s/magisk --zygote-restart\n", tmp_path);
                return true;
            }
            fprintf(dest_rc.get(), "%s", line.c_str());
            return true;
        });
        fclone_attr(src_rc, fileno(dest_rc.get()));
    }

    return faccessat(src_fd, "init.fission_host.rc", F_OK, 0) == 0;
}

void MagiskInit::patch_fissiond(const char *tmp_path) noexcept {
    {
        LOGD("Patching fissiond\n");
        mmap_data fissiond("/system/bin/fissiond", false);
        for (size_t off : fissiond.patch(
                "ro.build.system.fission_single_os",
                "ro.build.system.xxxxxxxxxxxxxxxxx"))
        {
            LOGD("Patch @ %08zX [ro.build.system.fission_single_os] -> "
                 "[ro.build.system.xxxxxxxxxxxxxxxxx]\n", off);
        }
        mkdirs(ROOTOVL "/system/bin", 0755);
        if (auto target_fissiond = xopen_file(ROOTOVL "/system/bin/fissiond", "we")) {
            fwrite(fissiond.data(), 1, fissiond.size(), target_fissiond.get());
            clone_attr("/system/bin/fissiond", ROOTOVL "/system/bin/fissiond");
        }
    }
    LOGD("hijack isolated\n");
    auto hijack = xopen_file("/sys/devices/system/cpu/isolated", "re");
    mkfifo(INTLROOT "/isolated", 0777);
    xmount(INTLROOT "/isolated", "/sys/devices/system/cpu/isolated", nullptr, MS_BIND, nullptr);
    if (!xfork()) {
        auto dest = xopen_file(INTLROOT "/isolated", "we");
        LOGD("hijacked isolated\n");
        xumount2("/sys/devices/system/cpu/isolated", MNT_DETACH);
        unlink(INTLROOT "/isolated");
        string content = full_read(fileno(hijack.get()));
        {
            string target = "/dev/cells/cell2"s + tmp_path;
            xmkdirs(target.data(), 0);
            xmount(tmp_path, target.data(), nullptr, MS_BIND | MS_REC, nullptr);
            mount_overlay("/dev/cells/cell2");
        }
        fprintf(dest.get(), "%s", content.data());
        exit(0);
    }
}

static void load_overlay_rc(const char *overlay) {
    auto dir = open_dir(overlay);
    if (!dir) return;

    int dfd = dirfd(dir.get());
    // Do not allow overwrite init.rc
    unlinkat(dfd, INIT_RC, 0);

    // '/' + name + '\0'
    char buf[NAME_MAX + 2];
    buf[0] = '/';
    for (dirent *entry; (entry = xreaddir(dir.get()));) {
        if (!string_view(entry->d_name).ends_with(".rc")) {
            continue;
        }
        strscpy(buf + 1, entry->d_name, sizeof(buf) - 1);
        if (access(buf, F_OK) == 0) {
            LOGD("Replace rc script [%s]\n", entry->d_name);
        } else {
            LOGD("Found rc script [%s]\n", entry->d_name);
            int rc = xopenat(dfd, entry->d_name, O_RDONLY | O_CLOEXEC);
            rc_list.push_back(full_read(rc));
            close(rc);
            unlinkat(dfd, entry->d_name, 0);
        }
    }
}

static void recreate_sbin(const char *mirror, bool use_bind_mount) {
    auto dp = xopen_dir(mirror);
    int src = dirfd(dp.get());
    char buf[4096];
    for (dirent *entry; (entry = xreaddir(dp.get()));) {
        string sbin_path = "/sbin/"s + entry->d_name;
        struct stat st;
        fstatat(src, entry->d_name, &st, AT_SYMLINK_NOFOLLOW);
        if (S_ISLNK(st.st_mode)) {
            xreadlinkat(src, entry->d_name, buf, sizeof(buf));
            xsymlink(buf, sbin_path.data());
        } else {
            sprintf(buf, "%s/%s", mirror, entry->d_name);
            if (use_bind_mount) {
                auto mode = st.st_mode & 0777;
                // Create dummy
                if (S_ISDIR(st.st_mode))
                    xmkdir(sbin_path.data(), mode);
                else
                    close(xopen(sbin_path.data(), O_CREAT | O_WRONLY | O_CLOEXEC, mode));

                xmount(buf, sbin_path.data(), nullptr, MS_BIND, nullptr);
            } else {
                xsymlink(buf, sbin_path.data());
            }
        }
    }
}

static void extract_files(bool sbin) {
    const char *magisk_xz = sbin ? "/sbin/magisk.xz" : "magisk.xz";
    const char *stub_xz = sbin ? "/sbin/stub.xz" : "stub.xz";
    const char *init_ld_xz = sbin ? "/sbin/init-ld.xz" : "init-ld.xz";

    if (access(magisk_xz, F_OK) == 0) {
        mmap_data magisk(magisk_xz);
        unlink(magisk_xz);
        int fd = xopen("magisk", O_WRONLY | O_CREAT, 0755);
        unxz(fd, magisk);
        close(fd);
    }
    if (access(stub_xz, F_OK) == 0) {
        mmap_data stub(stub_xz);
        unlink(stub_xz);
        int fd = xopen("stub.apk", O_WRONLY | O_CREAT, 0);
        unxz(fd, stub);
        close(fd);
    }
    if (access(init_ld_xz, F_OK) == 0) {
        mmap_data init_ld(init_ld_xz);
        unlink(init_ld_xz);
        int fd = xopen("init-ld", O_WRONLY | O_CREAT, 0);
        unxz(fd, init_ld);
        close(fd);
    }
}

void MagiskInit::patch_ro_root() noexcept {
    mount_list.emplace_back("/data");
    parse_config_file();

    string tmp_dir;

    if (access("/sbin", F_OK) == 0) {
        tmp_dir = "/sbin";
    } else {
        tmp_dir = "/debug_ramdisk";
        xmkdir("/data/debug_ramdisk", 0);
        xmount("/debug_ramdisk", "/data/debug_ramdisk", nullptr, MS_MOVE, nullptr);
    }

    setup_tmp(tmp_dir.data());
    chdir(tmp_dir.data());

    if (tmp_dir == "/sbin") {
        // Recreate original sbin structure
        xmkdir(MIRRDIR, 0755);
        xmount("/", MIRRDIR, nullptr, MS_BIND, nullptr);
        recreate_sbin(MIRRDIR "/sbin", true);
        xumount2(MIRRDIR, MNT_DETACH);
    } else {
        // Restore debug_ramdisk
        xmount("/data/debug_ramdisk", "/debug_ramdisk", nullptr, MS_MOVE, nullptr);
        rmdir("/data/debug_ramdisk");
    }

    xrename("overlay.d", ROOTOVL);

    extern bool avd_hack;
    // Handle avd hack
    if (avd_hack) {
        int src = xopen("/init", O_RDONLY | O_CLOEXEC);
        mmap_data init("/init");
        // Force disable early mount on original init
        for (size_t off : init.patch("android,fstab", "xxx")) {
            LOGD("Patch @ %08zX [android,fstab] -> [xxx]\n", off);
        }
        int dest = xopen(ROOTOVL "/init", O_CREAT | O_WRONLY | O_CLOEXEC, 0);
        xwrite(dest, init.data(), init.size());
        fclone_attr(src, dest);
        close(src);
        close(dest);
    }

    load_overlay_rc(ROOTOVL);
    if (access(ROOTOVL "/sbin", F_OK) == 0) {
        // Move files in overlay.d/sbin into tmp_dir
        mv_path(ROOTOVL "/sbin", ".");
    }

    // Patch init.rc
    bool p;
    if (access(NEW_INITRC_DIR "/" INIT_RC, F_OK) == 0) {
        // Android 11's new init.rc
        p = patch_rc_scripts(NEW_INITRC_DIR, tmp_dir.data(), false);
    } else {
        p = patch_rc_scripts("/", tmp_dir.data(), false);
    }
    if (p) patch_fissiond(tmp_dir.data());

    // Extract overlay archives
    extract_files(false);

    handle_sepolicy();
    unlink("init-ld");

    // Mount rootdir
    mount_overlay("/");

    chdir("/");
}

#define PRE_TMPSRC "/magisk"
#define PRE_TMPDIR PRE_TMPSRC "/tmp"

void MagiskInit::patch_rw_root() noexcept {
    mount_list.emplace_back("/data");
    parse_config_file();

    // Create hardlink mirror of /sbin to /root
    mkdir("/root", 0777);
    clone_attr("/sbin", "/root");
    link_path("/sbin", "/root");

    // Handle overlays
    load_overlay_rc("/overlay.d");
    mv_path("/overlay.d", "/");
    rm_rf("/data/overlay.d");
    rm_rf("/.backup");

    // Patch init.rc
    if (patch_rc_scripts("/", "/sbin", true))
        patch_fissiond("/sbin");

    xmkdir(PRE_TMPSRC, 0);
    xmount("tmpfs", PRE_TMPSRC, "tmpfs", 0, "mode=755");
    xmkdir(PRE_TMPDIR, 0);
    setup_tmp(PRE_TMPDIR);
    chdir(PRE_TMPDIR);

    // Extract overlay archives
    extract_files(true);

    handle_sepolicy();
    unlink("init-ld");

    chdir("/");

    // Dump magiskinit as magisk
    cp_afc(REDIR_PATH, "/sbin/magisk");
}

int magisk_proxy_main(int, char *argv[]) {
    rust::setup_klog();
    LOGD("%s\n", __FUNCTION__);

    // Mount rootfs as rw to do post-init rootfs patches
    xmount(nullptr, "/", nullptr, MS_REMOUNT, nullptr);

    unlink("/sbin/magisk");

    // Move tmpfs to /sbin
    // make parent private before MS_MOVE
    xmount(nullptr, PRE_TMPSRC, nullptr, MS_PRIVATE, nullptr);
    xmount(PRE_TMPDIR, "/sbin", nullptr, MS_MOVE, nullptr);
    xumount2(PRE_TMPSRC, MNT_DETACH);
    rmdir(PRE_TMPDIR);
    rmdir(PRE_TMPSRC);

    // Create symlinks pointing back to /root
    recreate_sbin("/root", false);

    // Tell magiskd to remount rootfs
    setenv("REMOUNT_ROOT", "1", 1);
    execve("/sbin/magisk", argv, environ);
    return 1;
}

static void unxz_init(const char *init_xz, const char *init) {
    LOGD("unxz %s -> %s\n", init_xz, init);
    int fd = xopen(init, O_WRONLY | O_CREAT, 0777);
    unxz(fd, mmap_data{init_xz});
    close(fd);
    clone_attr(init_xz, init);
    unlink(init_xz);
}

Utf8CStr backup_init() {
    if (access("/.backup/init.xz", F_OK) == 0)
        unxz_init("/.backup/init.xz", "/.backup/init");
    return "/.backup/init";
}

```

`native/src/init/rootdir.rs`:

```rs
use crate::consts::{ROOTMNT, ROOTOVL};
use crate::ffi::MagiskInit;
use base::nix::fcntl::OFlag;
use base::{
    BufReadExt, Directory, FsPathBuilder, LoggedResult, ResultExt, Utf8CStr, Utf8CString,
    clone_attr, cstr, debug,
};
use std::fs::File;
use std::io::{BufReader, Write};
use std::mem;
use std::os::fd::{FromRawFd, RawFd};

pub fn inject_magisk_rc(fd: RawFd, tmp_dir: &Utf8CStr) {
    debug!("Injecting magisk rc");

    let mut file = unsafe { File::from_raw_fd(fd) };

    write!(
        file,
        r#"
on post-fs-data
    exec {0} 0 0 -- {1}/magisk --post-fs-data

on property:vold.decrypt=trigger_restart_framework
    exec {0} 0 0 -- {1}/magisk --service

on nonencrypted
    exec {0} 0 0 -- {1}/magisk --service

on property:sys.boot_completed=1
    exec {0} 0 0 -- {1}/magisk --boot-complete
"#,
        "u:r:magisk:s0", tmp_dir
    )
    .ok();

    mem::forget(file)
}

pub struct OverlayAttr(Utf8CString, Utf8CString);

impl MagiskInit {
    pub(crate) fn parse_config_file(&mut self) {
        if let Ok(fd) = cstr!("/data/.backup/.magisk").open(OFlag::O_RDONLY) {
            let mut reader = BufReader::new(fd);
            reader.for_each_prop(|key, val| {
                if key == "PREINITDEVICE" {
                    self.preinit_dev = val.to_string();
                    return false;
                }
                true
            })
        }
    }

    fn mount_impl(
        &mut self,
        src_dir: &Utf8CStr,
        dest_dir: &Utf8CStr,
        mount_list: &mut String,
    ) -> LoggedResult<()> {
        let mut dir = Directory::open(src_dir)?;
        let mut con = cstr::buf::default();
        loop {
            match &dir.read()? {
                None => return Ok(()),
                Some(e) => {
                    let name = e.name();
                    let src = cstr::buf::dynamic(256).join_path(src_dir).join_path(name);
                    let dest = cstr::buf::dynamic(256).join_path(dest_dir).join_path(name);
                    if dest.exists() {
                        if e.is_dir() {
                            // Recursive
                            self.mount_impl(&src, &dest, mount_list)?;
                        } else {
                            debug!("Mount [{}] -> [{}]", src, dest);
                            clone_attr(&dest, &src)?;
                            dest.get_secontext(&mut con)?;
                            src.bind_mount_to(&dest, false)?;
                            self.overlay_con
                                .push(OverlayAttr(dest.to_owned(), con.to_owned()));
                            mount_list.push_str(dest.as_str());
                            mount_list.push('\n');
                        }
                    }
                }
            }
        }
    }

    pub(crate) fn mount_overlay(&mut self, dest: &Utf8CStr) {
        let mut mount_list = String::new();
        self.mount_impl(cstr!(ROOTOVL), dest, &mut mount_list)
            .log_ok();
        if let Ok(mut fd) = cstr!(ROOTMNT).create(OFlag::O_CREAT | OFlag::O_WRONLY, 0) {
            fd.write(mount_list.as_bytes()).log_ok();
        }
    }

    pub(crate) fn restore_overlay_contexts(&self) {
        self.overlay_con.iter().for_each(|attr| {
            let OverlayAttr(path, con) = attr;
            path.set_secontext(con).log_ok();
        })
    }
}

```

`native/src/init/selinux.rs`:

```rs
use crate::consts::{PREINITMIRR, SELINUXMOCK};
use crate::ffi::{MagiskInit, preload_ack, preload_lib, preload_policy, split_plat_cil};
use base::const_format::concatcp;
use base::nix::fcntl::OFlag;
use base::{
    BytesExt, LibcReturn, LoggedResult, MappedFile, ResultExt, Utf8CStr, cstr, debug, error, info,
    libc, raw_cstr,
};
use magiskpolicy::ffi::SePolicy;
use std::io::{Read, Write};
use std::ptr;
use std::thread::sleep;
use std::time::Duration;

const MOCK_VERSION: &Utf8CStr = cstr!(concatcp!(SELINUXMOCK, "/version"));
const MOCK_LOAD: &Utf8CStr = cstr!(concatcp!(SELINUXMOCK, "/load"));
const MOCK_ENFORCE: &Utf8CStr = cstr!(concatcp!(SELINUXMOCK, "/enforce"));
const MOCK_REQPROT: &Utf8CStr = cstr!(concatcp!(SELINUXMOCK, "/checkreqprot"));

const SELINUX_MNT: &str = "/sys/fs/selinux";
const SELINUX_ENFORCE: &Utf8CStr = cstr!(concatcp!(SELINUX_MNT, "/enforce"));
const SELINUX_LOAD: &Utf8CStr = cstr!(concatcp!(SELINUX_MNT, "/load"));
const SELINUX_REQPROT: &Utf8CStr = cstr!(concatcp!(SELINUX_MNT, "/checkreqprot"));

enum SePatchStrategy {
    // 2SI, Android 10+
    // On 2SI devices, the 2nd stage init is always a dynamic executable.
    // This meant that instead of going through convoluted hacks, we can just
    // LD_PRELOAD and replace security_load_policy with our own implementation.
    LdPreload,
    // Treble enabled, Android 8.0+
    // selinuxfs is mounted in init.cpp. Errors when mounting selinuxfs is ignored,
    // which means that we can directly mount selinuxfs ourselves and hijack nodes in it.
    SelinuxFs,
    // Dynamic patching, Android 6.0 - 7.1
    // selinuxfs is mounted in libselinux's selinux_android_load_policy(). Errors when
    // mounting selinuxfs is fatal, which means we need to block init's control flow after
    // it mounted selinuxfs for us, then we can hijack nodes in it.
    Legacy,
}

// Note for non-LD_PRELOAD strategy:
//
// We need to make sure the actual init process is blocked until sepolicy is loaded,
// or else restorecon will fail and re-exec won't change context, causing boot failure.
// We (ab)use the fact that init either reads the enforce node, or writes the checkreqprot
// node, and because both has been replaced with FIFO files, init will block until we
// handle it, effectively hijacking its control flow until the patched sepolicy is loaded.

fn mock_fifo(target: &Utf8CStr, mock: &Utf8CStr) -> LoggedResult<()> {
    debug!("Hijack [{}]", target);
    mock.mkfifo(0o666)?;
    mock.bind_mount_to(target, false).log()
}

fn mock_file(target: &Utf8CStr, mock: &Utf8CStr) -> LoggedResult<()> {
    debug!("Hijack [{}]", target);
    drop(mock.create(OFlag::O_RDONLY, 0o666)?);
    mock.bind_mount_to(target, false).log()
}

impl MagiskInit {
    pub(crate) fn handle_sepolicy(&mut self) {
        self.handle_sepolicy_impl().ok();
    }

    fn cleanup_and_load(&self, rules: &str) {
        // Cleanup the hijacks
        cstr!("/init").unmount().ok();
        SELINUX_LOAD.unmount().log_ok();
        SELINUX_ENFORCE.unmount().ok();
        SELINUX_REQPROT.unmount().ok();

        let mut sepol = SePolicy::from_file(MOCK_LOAD);
        sepol.magisk_rules();
        sepol.load_rules(rules);
        sepol.to_file(SELINUX_LOAD);

        // For some reason, restorecon on /init won't work in some cases
        cstr!("/init")
            .follow_link()
            .set_secontext(cstr!("u:object_r:init_exec:s0"))
            .ok();

        // restore mounted files' context after sepolicy loaded
        self.restore_overlay_contexts();
    }

    fn handle_sepolicy_impl(&mut self) -> LoggedResult<()> {
        cstr!(SELINUXMOCK).mkdir(0o711)?;

        let mut rules = String::new();
        let mut policy_ver = cstr!("/selinux_version");
        let rule_file = cstr!(concatcp!("/data/", PREINITMIRR, "/sepolicy.rule"));
        if rule_file.exists() {
            debug!("Loading custom sepolicy patch: [{}]", rule_file);
            rule_file
                .open(OFlag::O_RDONLY)?
                .read_to_string(&mut rules)?;
        }

        // Step 0: determine strategy

        let strat: SePatchStrategy;

        if cstr!("/system/bin/init").exists() {
            strat = SePatchStrategy::LdPreload;
        } else {
            let init = MappedFile::open(cstr!("/init"))?;
            if init.contains(split_plat_cil().as_str().as_bytes()) {
                // Supports split policy
                strat = SePatchStrategy::SelinuxFs;
            } else if init.contains(policy_ver.as_bytes()) {
                // Does not support split policy, hijack /selinux_version
                strat = SePatchStrategy::Legacy;
            } else if init.contains(cstr!("/sepolicy_version").as_bytes()) {
                // Samsung custom path
                policy_ver = cstr!("/sepolicy_version");
                strat = SePatchStrategy::Legacy;
            } else {
                error!("Unknown sepolicy setup, abort...");
                return Ok(());
            }
        }

        // Step 1: setup for intercepting init boot control flow

        match strat {
            SePatchStrategy::LdPreload => {
                info!("SePatchStrategy: LD_PRELOAD");

                cstr!("init-ld").copy_to(preload_lib())?;
                unsafe {
                    libc::setenv(raw_cstr!("LD_PRELOAD"), preload_lib().as_ptr(), 1);
                }
                preload_ack().mkfifo(0o666)?;
            }
            SePatchStrategy::SelinuxFs => {
                info!("SePatchStrategy: SELINUXFS");

                if !SELINUX_ENFORCE.exists() {
                    // selinuxfs was not already mounted, mount it ourselves

                    // Remount procfs with proper options
                    cstr!("/proc").remount_with_data(cstr!("hidepid=2,gid=3009"))?;

                    // Preserve sysfs and procfs
                    self.mount_list.retain(|s| s != "/proc" && s != "/sys");

                    // Mount selinuxfs
                    unsafe {
                        libc::mount(
                            raw_cstr!("selinuxfs"),
                            raw_cstr!(SELINUX_MNT),
                            raw_cstr!("selinuxfs"),
                            0,
                            ptr::null(),
                        )
                        .check_err()?;
                    }
                }

                mock_file(SELINUX_LOAD, MOCK_LOAD)?;
                mock_fifo(SELINUX_ENFORCE, MOCK_ENFORCE)?;
            }
            SePatchStrategy::Legacy => {
                info!("SePatchStrategy: LEGACY");

                if !policy_ver.exists() {
                    // The file does not exist, create one
                    drop(policy_ver.create(OFlag::O_RDONLY, 0o666)?);
                }

                // The only purpose of this is to block init's control flow after it mounts
                // selinuxfs and before it calls security_load_policy().
                // selinux_android_load_policy() -> set_policy_index() -> open(policy_ver)
                mock_fifo(policy_ver, MOCK_VERSION)?;
            }
        }

        // Create a new process waiting for init operations
        let pid = unsafe { libc::fork() };
        if pid != 0 {
            return Ok(());
        }

        // Step 2: wait for selinuxfs to be mounted (only for LEGACY)

        let wait = Duration::from_millis(100);

        if matches!(strat, SePatchStrategy::Legacy) {
            // Busy wait until selinuxfs is mounted
            while !SELINUX_ENFORCE.exists() {
                // Retry every 100ms
                sleep(wait);
            }

            // On Android 6.0, init does not call security_getenforce() first; instead it directly
            // call security_setenforce() after security_load_policy(). What's even worse, it opens
            // the enforce node with O_RDWR, which will not block when opening FIFO files.
            // As a workaround, we do not mock the enforce node, and block init with mocking
            // checkreqprot instead.
            // Android 7.0 - 7.1 doesn't have this issue, but for simplicity, let's just use the
            // same blocking strategy for both since it also works just fine.

            mock_file(SELINUX_LOAD, MOCK_LOAD)?;
            mock_fifo(SELINUX_REQPROT, MOCK_REQPROT)?;

            // This will unblock init at selinux_android_load_policy() -> set_policy_index().
            drop(MOCK_VERSION.open(OFlag::O_WRONLY)?);

            policy_ver.unmount()?;

            // libselinux does not read /selinux_version after open; instead it mmap the file,
            // which can never succeed on FIFO files. This is fine as set_policy_index() will just
            // fallback to the default index 0.
        }

        // Step 3: obtain sepolicy, patch, and load the patched sepolicy

        match strat {
            SePatchStrategy::LdPreload => {
                // This open will block until preload.so finish writing the sepolicy
                let mut ack_fd = preload_ack().open(OFlag::O_WRONLY)?;

                let mut sepol = SePolicy::from_file(preload_policy());

                // Remove the files before loading the policy
                preload_policy().remove()?;
                preload_ack().remove()?;

                sepol.magisk_rules();
                sepol.load_rules(&rules);
                sepol.to_file(SELINUX_LOAD);

                self.restore_overlay_contexts();

                // Write ack to restore preload.so's control flow
                ack_fd.write_all("0".as_bytes())?;
            }
            SePatchStrategy::SelinuxFs => {
                // This open will block until init calls security_getenforce().
                let mut mock_enforce = MOCK_ENFORCE.open(OFlag::O_WRONLY)?;

                self.cleanup_and_load(&rules);

                // security_getenforce was called, read from real and redirect to mock
                let mut data = vec![];
                SELINUX_ENFORCE
                    .open(OFlag::O_RDONLY)?
                    .read_to_end(&mut data)?;
                mock_enforce.write_all(&data)?;
            }
            SePatchStrategy::Legacy => {
                let mut sz = 0_usize;
                // Busy wait until sepolicy is fully written.
                loop {
                    let attr = MOCK_LOAD.get_attr()?;
                    if sz != 0 && sz == attr.st.st_size as usize {
                        break;
                    }
                    sz = attr.st.st_size as usize;
                    // Check every 100ms
                    sleep(wait);
                }

                self.cleanup_and_load(&rules);

                // init is blocked on checkreqprot, write to the real node first, then
                // unblock init by opening the mock FIFO.
                SELINUX_REQPROT
                    .open(OFlag::O_WRONLY)?
                    .write_all("0".as_bytes())?;
                let mut v = vec![];
                MOCK_REQPROT.open(OFlag::O_RDONLY)?.read_to_end(&mut v)?;
            }
        }

        // At this point, the init process will be unblocked
        // and continue on with restorecon + re-exec.

        // Terminate process
        std::process::exit(0);
    }
}

```

`native/src/init/twostage.rs`:

```rs
use crate::ffi::MagiskInit;
use base::nix::fcntl::OFlag;
use base::{LoggedResult, MappedFile, MutBytesExt, ResultExt, cstr, debug, error};
use std::io::Write;

pub(crate) fn hexpatch_init_for_second_stage(writable: bool) {
    let init = if writable {
        MappedFile::open_rw(cstr!("/init"))
    } else {
        MappedFile::open(cstr!("/init"))
    };

    let Ok(mut init) = init else {
        error!("Failed to open /init for hexpatch");
        return;
    };

    // Redirect original init to magiskinit
    let from = "/system/bin/init";
    let to = "/data/magiskinit";
    let v = init.patch(from.as_bytes(), to.as_bytes());
    #[allow(unused_variables)]
    for off in &v {
        debug!("Patch @ {:#010X} [{}] -> [{}]", off, from, to);
    }

    if !writable {
        // If we cannot directly modify /init, we need to bind mount a replacement on top of it
        let src = cstr!("/init");
        let dest = cstr!("/data/init");
        let _ = || -> LoggedResult<()> {
            {
                let mut fd = dest.create(OFlag::O_CREAT | OFlag::O_WRONLY, 0)?;
                fd.write_all(init.as_ref())?;
            }
            let attr = src.follow_link().get_attr()?;
            dest.set_attr(&attr)?;
            dest.bind_mount_to(src, false)?;
            Ok(())
        }();
    }
}

impl MagiskInit {
    pub(crate) fn hijack_init_with_switch_root(&self) {
        // We make use of original init's `SwitchRoot` to help us bind mount
        // magiskinit to /system/bin/init to hijack second stage init.
        //
        // Two important assumption about 2SI:
        // - The second stage init is always /system/bin/init
        // - After `SwitchRoot`, /sdcard is always a symlink to `/storage/self/primary`.
        //
        // `SwitchRoot` will perform the following:
        // - Recursive move all mounts under `/` to `/system`
        // - chroot to `/system`
        //
        // The trick here is that in Magisk's first stage init, we can mount magiskinit to /sdcard,
        // and create a symlink at /storage/self/primary pointing to /system/system/bin/init.
        //
        // During init's `SwitchRoot`, it will mount move /sdcard (which is magiskinit)
        // to /system/sdcard, which is a symlink to /storage/self/primary, which is a
        // symlink to /system/system/bin/init, which will eventually become /system/bin/init after
        // chroot to /system. The effective result is that we coerce the original init into bind
        // mounting magiskinit to /system/bin/init, successfully hijacking the second stage init.
        //
        // An edge case is that some devices (like meizu) use 2SI but does not switch root.
        // In that case, they must already have a /sdcard in ramfs, thus we can check if
        // /sdcard exists and fallback to using hexpatch.

        if self.config.force_normal_boot {
            cstr!("/first_stage_ramdisk/storage/self")
                .mkdirs(0o755)
                .log_ok();
            cstr!("/first_stage_ramdisk/storage/self/primary")
                .create_symlink_to(cstr!("/system/system/bin/init"))
                .log_ok();
            debug!("Symlink /first_stage_ramdisk/storage/self/primary -> /system/system/bin/init");
            cstr!("/first_stage_ramdisk/sdcard")
                .create(OFlag::O_RDONLY | OFlag::O_CREAT | OFlag::O_CLOEXEC, 0)
                .log_ok();
        } else {
            cstr!("/storage/self").mkdirs(0o755).log_ok();
            cstr!("/storage/self/primary")
                .create_symlink_to(cstr!("/system/system/bin/init"))
                .log_ok();
            debug!("Symlink /storage/self/primary -> /system/system/bin/init");
        }
        cstr!("/init").rename_to(cstr!("/sdcard")).log_ok();

        // First try to mount magiskinit from rootfs to workaround Samsung RKP
        if cstr!("/sdcard")
            .bind_mount_to(cstr!("/sdcard"), false)
            .is_ok()
        {
            debug!("Bind mount /sdcard -> /sdcard");
        } else {
            // Binding mounting from rootfs is not supported before Linux 3.12
            cstr!("/data/magiskinit")
                .bind_mount_to(cstr!("/sdcard"), false)
                .log_ok();
            debug!("Bind mount /data/magiskinit -> /sdcard");
        }
    }
}

```

`native/src/rustfmt.toml`:

```toml
unstable_features = true
imports_granularity = "Module"

```

`native/src/sepolicy/Cargo.toml`:

```toml
[package]
name = "magiskpolicy"
version.workspace = true
edition.workspace = true

[lib]
crate-type = ["staticlib", "rlib"]
path = "lib.rs"

[features]
no-main = []

[lints]
workspace = true

[build-dependencies]
cxx-gen = { workspace = true }

[dependencies]
base = { workspace = true }
cxx = { workspace = true }

```

`native/src/sepolicy/api.cpp`:

```cpp
#include <base.hpp>

#include "include/sepolicy.hpp"

using Str = rust::Str;
using StrVec = rust::Vec<rust::Str>;
using Xperms = rust::Vec<Xperm>;

#if 0
template<typename Arg>
std::string as_str(const Arg &arg) {
    if constexpr (std::is_same_v<Arg, Xperm>) {
        return (std::string) SePolicy::xperm_to_string(arg);
    } else if constexpr (std::is_same_v<Arg, rust::Str>) {
        return arg.empty() ? "*" : (std::string) arg;
    }
}

// Print out all rules going through public API for debugging
template<typename ...Args>
static void print_rule(const char *action, Args ...args) {
    std::string s;
    s = (... + (" " + as_str(args)));
    LOGD("%s%s\n", action, s.data());
}
#else
#define print_rule(...) ((void) 0)
#endif

template<typename F, typename ...T>
requires(std::invocable<F, T...>)
static inline void expand(F &&f, T &&...args) {
    f(std::forward<T>(args)...);
}

template<typename ...T>
static inline void expand(Str s, T &&...args) {
    expand(std::forward<T>(args)..., s);
}

template<typename ...T>
static inline void expand(const StrVec &vec, T &&...args) {
    if (vec.empty()) {
        expand(std::forward<T>(args)..., rust::Str{});
    } else {
        for (auto s : vec) {
            expand(std::forward<T>(args)..., s);
        }
    }
}

template<typename ...T>
static inline void expand(const Xperms &vec, T &&...args) {
    for (auto &p : vec) {
        expand(std::forward<T>(args)..., p);
    }
}

void SePolicy::allow(StrVec src, StrVec tgt, StrVec cls, StrVec perm) noexcept {
    expand(src, tgt, cls, perm, [this](auto ...args) {
        print_rule("allow", args...);
        impl->add_rule(args..., AVTAB_ALLOWED, false);
    });
}

void SePolicy::deny(StrVec src, StrVec tgt, StrVec cls, StrVec perm) noexcept {
    expand(src, tgt, cls, perm, [this](auto ...args) {
        print_rule("deny", args...);
        impl->add_rule(args..., AVTAB_ALLOWED, true);
    });
}

void SePolicy::auditallow(StrVec src, StrVec tgt, StrVec cls, StrVec perm) noexcept {
    expand(src, tgt, cls, perm, [this](auto ...args) {
        print_rule("auditallow", args...);
        impl->add_rule(args..., AVTAB_AUDITALLOW, false);
    });
}

void SePolicy::dontaudit(StrVec src, StrVec tgt, StrVec cls, StrVec perm) noexcept {
    expand(src, tgt, cls, perm, [this](auto ...args) {
        print_rule("dontaudit", args...);
        impl->add_rule(args..., AVTAB_AUDITDENY, true);
    });
}

void SePolicy::permissive(StrVec types) noexcept {
    expand(types, [this](auto ...args) {
        print_rule("permissive", args...);
        impl->set_type_state(args..., true);
    });
}

void SePolicy::enforce(StrVec types) noexcept {
    expand(types, [this](auto ...args) {
        print_rule("enforce", args...);
        impl->set_type_state(args..., false);
    });
}

void SePolicy::typeattribute(StrVec types, StrVec attrs) noexcept {
    expand(types, attrs, [this](auto ...args) {
        print_rule("typeattribute", args...);
        impl->add_typeattribute(args...);
    });
}

void SePolicy::type(Str type, StrVec attrs) noexcept {
    expand(type, attrs, [this](auto name, auto attr) {
        print_rule("type", name, attr);
        impl->add_type(name, TYPE_TYPE) && impl->add_typeattribute(name, attr);
    });
}

void SePolicy::attribute(Str name) noexcept {
    expand(name, [this](auto ...args) {
        print_rule("attribute", args...);
        impl->add_type(args..., TYPE_ATTRIB);
    });
}

void SePolicy::type_transition(Str src, Str tgt, Str cls, Str def, Str obj) noexcept {
    expand(src, tgt, cls, def, obj, [this](auto s, auto t, auto c, auto d, auto o) {
        if (!o.empty()) {
            print_rule("type_transition", s, t, c, d, o);
            impl->add_filename_trans(s, t, c, d, o);
        } else {
            print_rule("type_transition", s, t, c, d);
            impl->add_type_rule(s, t, c, d, AVTAB_TRANSITION);
        }
    });
}

void SePolicy::type_change(Str src, Str tgt, Str cls, Str def) noexcept {
    expand(src, tgt, cls, def, [this](auto ...args) {
        print_rule("type_change", args...);
        impl->add_type_rule(args..., AVTAB_CHANGE);
    });
}

void SePolicy::type_member(Str src, Str tgt, Str cls, Str def) noexcept {
    expand(src, tgt, cls, def, [this](auto ...args) {
        print_rule("type_member", args...);
        impl->add_type_rule(args..., AVTAB_MEMBER);
    });
}

void SePolicy::genfscon(Str fs_name, Str path, Str ctx) noexcept {
    expand(fs_name, path, ctx, [this](auto ...args) {
        print_rule("genfscon", args...);
        impl->add_genfscon(args...);
    });
}

void SePolicy::allowxperm(StrVec src, StrVec tgt, StrVec cls, Xperms xperm) noexcept {
    expand(src, tgt, cls, xperm, [this](auto ...args) {
        print_rule("allowxperm", args...);
        impl->add_xperm_rule(args..., AVTAB_XPERMS_ALLOWED);
    });
}

void SePolicy::auditallowxperm(StrVec src, StrVec tgt, StrVec cls, Xperms xperm) noexcept {
    expand(src, tgt, cls, xperm, [this](auto ...args) {
        print_rule("auditallowxperm", args...);
        impl->add_xperm_rule(args..., AVTAB_XPERMS_AUDITALLOW);
    });
}

void SePolicy::dontauditxperm(StrVec src, StrVec tgt, StrVec cls, Xperms xperm) noexcept {
    expand(src, tgt, cls, xperm, [this](auto ...args) {
        print_rule("dontauditxperm", args...);
        impl->add_xperm_rule(args..., AVTAB_XPERMS_DONTAUDIT);
    });
}

```

`native/src/sepolicy/build.rs`:

```rs
use crate::codegen::gen_cxx_binding;

#[path = "../include/codegen.rs"]
mod codegen;

fn main() {
    gen_cxx_binding("policy-rs");
}

```

`native/src/sepolicy/cli.rs`:

```rs
use crate::ffi::SePolicy;
use crate::statement::format_statement_help;
use argh::FromArgs;
use base::libc::umask;
use base::{
    CmdArgs, EarlyExitExt, FmtAdaptor, LoggedResult, Utf8CString, argh, cmdline_logging, cstr,
    log_err,
};
use std::ffi::c_char;
use std::io::stderr;

#[derive(FromArgs)]
struct Cli {
    #[argh(switch)]
    live: bool,

    #[argh(switch)]
    magisk: bool,

    #[argh(switch)]
    compile_split: bool,

    #[argh(switch)]
    load_split: bool,

    #[argh(switch)]
    print_rules: bool,

    #[argh(option)]
    load: Option<Utf8CString>,

    #[argh(option)]
    save: Option<Utf8CString>,

    #[argh(option)]
    apply: Vec<Utf8CString>,

    #[argh(positional)]
    polices: Vec<String>,
}

fn print_usage(cmd: &str) {
    eprintln!(
        r#"MagiskPolicy - SELinux Policy Patch Tool

Usage: {cmd} [--options...] [policy statements...]

Options:
   --help            show help message for policy statements
   --load FILE       load monolithic sepolicy from FILE
   --load-split      load from precompiled sepolicy or compile
                     split cil policies
   --compile-split   compile split cil policies
   --save FILE       dump monolithic sepolicy to FILE
   --live            immediately load sepolicy into the kernel
   --magisk          apply built-in Magisk sepolicy rules
   --apply FILE      apply rules from FILE, read and parsed
                     line by line as policy statements
                     (multiple --apply are allowed)
   --print-rules     print all rules in the loaded sepolicy

If neither --load, --load-split, nor --compile-split is specified,
it will load from current live policies (/sys/fs/selinux/policy)
"#
    );

    format_statement_help(&mut FmtAdaptor(&mut stderr())).ok();
    eprintln!();
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn main(
    argc: i32,
    argv: *const *const c_char,
    _envp: *const *const c_char,
) -> i32 {
    cmdline_logging();
    unsafe {
        umask(0);
    }

    let res = || -> LoggedResult<()> {
        let cmds = CmdArgs::new(argc, argv);
        let cmds = cmds.as_slice();
        if argc < 2 {
            print_usage(cmds.first().unwrap_or(&"magiskpolicy"));
            return log_err!();
        }
        let cli = Cli::from_args(&[cmds[0]], &cmds[1..]).on_early_exit(|| print_usage(cmds[0]));

        let mut sepol = match (cli.load, cli.load_split, cli.compile_split) {
            (Some(file), false, false) => SePolicy::from_file(&file),
            (None, true, false) => SePolicy::from_split(),
            (None, false, true) => SePolicy::compile_split(),
            (None, false, false) => SePolicy::from_file(cstr!("/sys/fs/selinux/policy")),
            _ => log_err!("Multiple load source supplied")?,
        };
        if sepol._impl.is_null() {
            log_err!("Cannot load policy")?;
        }

        if cli.print_rules {
            if cli.magisk
                || !cli.apply.is_empty()
                || !cli.polices.is_empty()
                || cli.live
                || cli.save.is_some()
            {
                log_err!("Cannot print rules with other options")?;
            }
            sepol.print_rules();
            return Ok(());
        }

        if cli.magisk {
            sepol.magisk_rules();
        }

        for file in cli.apply {
            sepol.load_rule_file(&file);
        }

        for statement in &cli.polices {
            sepol.load_rules(statement);
        }

        if cli.live && !sepol.to_file(cstr!("/sys/fs/selinux/load")) {
            log_err!("Cannot apply policy")?;
        }

        if let Some(file) = cli.save
            && !sepol.to_file(&file)
        {
            log_err!("Cannot dump policy to {}", file)?;
        }
        Ok(())
    }();
    if res.is_ok() { 0 } else { 1 }
}

```

`native/src/sepolicy/include/sepolicy.hpp`:

```hpp
#pragma once

#include <cstdlib>
#include <string>

#include <base.hpp>

#include "../policy-rs.hpp"

// sepolicy paths
#define PLAT_POLICY_DIR     "/system/etc/selinux/"
#define VEND_POLICY_DIR     "/vendor/etc/selinux/"
#define PROD_POLICY_DIR     "/product/etc/selinux/"
#define ODM_POLICY_DIR      "/odm/etc/selinux/"
#define SYSEXT_POLICY_DIR   "/system_ext/etc/selinux/"
#define SPLIT_PLAT_CIL      PLAT_POLICY_DIR "plat_sepolicy.cil"

// selinuxfs paths
#define SELINUX_MNT         "/sys/fs/selinux"
#define SELINUX_VERSION     SELINUX_MNT "/policyvers"

```

`native/src/sepolicy/lib.rs`:

```rs
pub use base;
use std::fmt::Write;

use crate::ffi::SePolicy;

#[path = "../include/consts.rs"]
mod consts;

#[cfg(not(feature = "no-main"))]
mod cli;
mod rules;
mod statement;

#[cxx::bridge]
pub mod ffi {
    struct Xperm {
        low: u16,
        high: u16,
        reset: bool,
    }

    struct SePolicy {
        #[cxx_name = "impl"]
        _impl: UniquePtr<sepol_impl>,
    }

    unsafe extern "C++" {
        include!("policy.hpp");
        include!("../base/include/base.hpp");

        #[cxx_name = "Utf8CStr"]
        type Utf8CStrRef<'a> = base::Utf8CStrRef<'a>;

        type sepol_impl;

        fn allow(self: &mut SePolicy, s: Vec<&str>, t: Vec<&str>, c: Vec<&str>, p: Vec<&str>);
        fn deny(self: &mut SePolicy, s: Vec<&str>, t: Vec<&str>, c: Vec<&str>, p: Vec<&str>);
        fn auditallow(self: &mut SePolicy, s: Vec<&str>, t: Vec<&str>, c: Vec<&str>, p: Vec<&str>);
        fn dontaudit(self: &mut SePolicy, s: Vec<&str>, t: Vec<&str>, c: Vec<&str>, p: Vec<&str>);
        fn allowxperm(self: &mut SePolicy, s: Vec<&str>, t: Vec<&str>, c: Vec<&str>, p: Vec<Xperm>);
        fn auditallowxperm(
            self: &mut SePolicy,
            s: Vec<&str>,
            t: Vec<&str>,
            c: Vec<&str>,
            p: Vec<Xperm>,
        );
        fn dontauditxperm(
            self: &mut SePolicy,
            s: Vec<&str>,
            t: Vec<&str>,
            c: Vec<&str>,
            p: Vec<Xperm>,
        );
        fn permissive(self: &mut SePolicy, t: Vec<&str>);
        fn enforce(self: &mut SePolicy, t: Vec<&str>);
        fn typeattribute(self: &mut SePolicy, t: Vec<&str>, a: Vec<&str>);
        #[cxx_name = "type"]
        fn type_(self: &mut SePolicy, t: &str, a: Vec<&str>);
        fn attribute(self: &mut SePolicy, t: &str);
        fn type_transition(self: &mut SePolicy, s: &str, t: &str, c: &str, d: &str, o: &str);
        fn type_change(self: &mut SePolicy, s: &str, t: &str, c: &str, d: &str);
        fn type_member(self: &mut SePolicy, s: &str, t: &str, c: &str, d: &str);
        fn genfscon(self: &mut SePolicy, s: &str, t: &str, c: &str);
        #[allow(dead_code)]
        fn strip_dontaudit(self: &mut SePolicy);

        fn print_rules(self: &SePolicy);
        fn to_file(self: &SePolicy, file: Utf8CStrRef) -> bool;

        #[Self = SePolicy]
        fn from_file(file: Utf8CStrRef) -> SePolicy;
        #[Self = SePolicy]
        fn from_split() -> SePolicy;
        #[Self = SePolicy]
        fn compile_split() -> SePolicy;
        #[Self = SePolicy]
        fn from_data(data: &[u8]) -> SePolicy;
    }

    extern "Rust" {
        #[Self = SePolicy]
        fn xperm_to_string(perm: &Xperm) -> String;
    }
}

impl SePolicy {
    fn xperm_to_string(perm: &ffi::Xperm) -> String {
        let mut s = String::new();
        if perm.reset {
            s.push('~');
        }
        if perm.low == perm.high {
            s.write_fmt(format_args!("{{ {:#06X} }}", perm.low)).ok();
        } else {
            s.write_fmt(format_args!("{{ {:#06X}-{:#06X} }}", perm.low, perm.high))
                .ok();
        }
        s
    }
}

```

`native/src/sepolicy/policy.hpp`:

```hpp
#pragma once

// Internal APIs, do not use directly

#include <map>
#include <string_view>
#include <rust/cxx.h>

#include <sepol/policydb/policydb.h>

using Str = rust::Str;

struct Xperm;

class sepol_impl {
    avtab_ptr_t find_avtab_node(avtab_key_t *key, avtab_extended_perms_t *xperms);
    avtab_ptr_t insert_avtab_node(avtab_key_t *key);
    avtab_ptr_t get_avtab_node(avtab_key_t *key, avtab_extended_perms_t *xperms);
    void print_type(FILE *fp, type_datum_t *type);
    void print_avtab(FILE *fp, avtab_ptr_t node);
    void print_filename_trans(FILE *fp, hashtab_ptr_t node);

    bool add_rule(Str s, Str t, Str c, Str p, int effect, bool invert);
    void add_rule(type_datum_t *src, type_datum_t *tgt, class_datum_t *cls, perm_datum_t *perm, int effect, bool invert);
    void add_xperm_rule(type_datum_t *src, type_datum_t *tgt, class_datum_t *cls, const Xperm &p, int effect);
    bool add_xperm_rule(Str s, Str t, Str c, const Xperm &p, int effect);
    bool add_type_rule(Str s, Str t, Str c, Str d, int effect);
    bool add_filename_trans(Str s, Str t, Str c, Str d, Str o);
    bool add_genfscon(Str fs_name, Str path, Str context);
    bool add_type(Str type_name, uint32_t flavor);
    bool set_type_state(Str type_name, bool permissive);
    void add_typeattribute(type_datum_t *type, type_datum_t *attr);
    bool add_typeattribute(Str type, Str attr);

    policydb *db;

    std::map<std::string_view, std::array<const char *, 32>> class_perm_names;

    friend struct SePolicy;

public:
    sepol_impl(policydb *db) : db(db) {}
    ~sepol_impl();
};

```

`native/src/sepolicy/policydb.cpp`:

```cpp
#include "include/sepolicy.hpp"

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include <cil/cil.h>

#include <base.hpp>
#include <flags.h>

using namespace std;

#define SHALEN 64
static bool cmp_sha256(const char *a, const char *b) {
    char id_a[SHALEN] = {0};
    char id_b[SHALEN] = {0};
    if (int fd = xopen(a, O_RDONLY | O_CLOEXEC); fd >= 0) {
        xread(fd, id_a, SHALEN);
        close(fd);
    } else {
        return false;
    }

    if (int fd = xopen(b, O_RDONLY | O_CLOEXEC); fd >= 0) {
        xread(fd, id_b, SHALEN);
        close(fd);
    } else {
        return false;
    }
    LOGD("%s=[%.*s]\n", a, SHALEN, id_a);
    LOGD("%s=[%.*s]\n", b, SHALEN, id_b);
    return memcmp(id_a, id_b, SHALEN) == 0;
}

static bool check_precompiled(const char *precompiled) {
    bool ok = false;
    const char *actual_sha;
    char compiled_sha[128];

    actual_sha = PLAT_POLICY_DIR "plat_and_mapping_sepolicy.cil.sha256";
    if (access(actual_sha, R_OK) == 0) {
        ok = true;
        sprintf(compiled_sha, "%s.plat_and_mapping.sha256", precompiled);
        if (!cmp_sha256(actual_sha, compiled_sha))
            return false;
    }

    actual_sha = PLAT_POLICY_DIR "plat_sepolicy_and_mapping.sha256";
    if (access(actual_sha, R_OK) == 0) {
        ok = true;
        sprintf(compiled_sha, "%s.plat_sepolicy_and_mapping.sha256", precompiled);
        if (!cmp_sha256(actual_sha, compiled_sha))
            return false;
    }

    actual_sha = PROD_POLICY_DIR "product_sepolicy_and_mapping.sha256";
    if (access(actual_sha, R_OK) == 0) {
        ok = true;
        sprintf(compiled_sha, "%s.product_sepolicy_and_mapping.sha256", precompiled);
        if (!cmp_sha256(actual_sha, compiled_sha) != 0)
            return false;
    }

    actual_sha = SYSEXT_POLICY_DIR "system_ext_sepolicy_and_mapping.sha256";
    if (access(actual_sha, R_OK) == 0) {
        ok = true;
        sprintf(compiled_sha, "%s.system_ext_sepolicy_and_mapping.sha256", precompiled);
        if (!cmp_sha256(actual_sha, compiled_sha) != 0)
            return false;
    }

    return ok;
}

static void load_cil(struct cil_db *db, const char *file) {
    mmap_data d(file);
    cil_add_file(db, file, (const char *) d.data(), d.size());
    LOGD("cil_add [%s]\n", file);
}

SePolicy SePolicy::from_data(rust::Slice<const uint8_t> data) noexcept {
    LOGD("Load policy from data\n");

    policy_file_t pf;
    policy_file_init(&pf);
    pf.data = (char *) data.data();
    pf.len = data.size();
    pf.type = PF_USE_MEMORY;

    auto db = static_cast<policydb_t *>(malloc(sizeof(policydb_t)));
    if (policydb_init(db) || policydb_read(db, &pf, 0)) {
        LOGE("Fail to load policy from data\n");
        free(db);
        return {};
    }

    return {std::make_unique<sepol_impl>(db)};
}

SePolicy SePolicy::from_file(::Utf8CStr file) noexcept {
    LOGD("Load policy from: %.*s\n", static_cast<int>(file.size()), file.data());

    policy_file_t pf;
    policy_file_init(&pf);
    auto fp = xopen_file(file.data(), "re");
    pf.fp = fp.get();
    pf.type = PF_USE_STDIO;

    auto db = static_cast<policydb_t *>(malloc(sizeof(policydb_t)));
    if (policydb_init(db) || policydb_read(db, &pf, 0)) {
        LOGE("Fail to load policy from %.*s\n", static_cast<int>(file.size()), file.data());
        free(db);
        return {};
    }

    return {std::make_unique<sepol_impl>(db)};
}

SePolicy SePolicy::compile_split() noexcept {
    char path[128], plat_ver[10];
    cil_db_t *db = nullptr;
    sepol_policydb_t *pdb = nullptr;
    FILE *f;
    int policy_ver;
    const char *cil_file;
#if MAGISK_DEBUG
    cil_set_log_level(CIL_INFO);
#endif
    cil_set_log_handler(+[](int lvl, const char *msg) {
        if (lvl == CIL_ERR) {
            LOGE("cil: %s", msg);
        } else if (lvl == CIL_WARN) {
            LOGW("cil: %s", msg);
        } else if (lvl == CIL_INFO) {
            LOGI("cil: %s", msg);
        } else {
            LOGD("cil: %s", msg);
        }
    });

    cil_db_init(&db);
    run_finally fin([db_ptr = &db]{ cil_db_destroy(db_ptr); });
    cil_set_mls(db, 1);
    cil_set_multiple_decls(db, 1);
    cil_set_disable_neverallow(db, 1);
    cil_set_target_platform(db, SEPOL_TARGET_SELINUX);
    cil_set_attrs_expand_generated(db, 1);

    f = xfopen(SELINUX_VERSION, "re");
    fscanf(f, "%d", &policy_ver);
    fclose(f);
    cil_set_policy_version(db, policy_ver);

    // Get mapping version
    f = xfopen(VEND_POLICY_DIR "plat_sepolicy_vers.txt", "re");
    fscanf(f, "%s", plat_ver);
    fclose(f);

    // plat
    load_cil(db, SPLIT_PLAT_CIL);

    sprintf(path, PLAT_POLICY_DIR "mapping/%s.cil", plat_ver);
    load_cil(db, path);

    sprintf(path, PLAT_POLICY_DIR "mapping/%s.compat.cil", plat_ver);
    if (access(path, R_OK) == 0)
        load_cil(db, path);

    // system_ext
    sprintf(path, SYSEXT_POLICY_DIR "mapping/%s.cil", plat_ver);
    if (access(path, R_OK) == 0)
        load_cil(db, path);

    sprintf(path, SYSEXT_POLICY_DIR "mapping/%s.compat.cil", plat_ver);
    if (access(path, R_OK) == 0)
        load_cil(db, path);

    cil_file = SYSEXT_POLICY_DIR "system_ext_sepolicy.cil";
    if (access(cil_file, R_OK) == 0)
        load_cil(db, cil_file);

    // product
    sprintf(path, PROD_POLICY_DIR "mapping/%s.cil", plat_ver);
    if (access(path, R_OK) == 0)
        load_cil(db, path);

    cil_file = PROD_POLICY_DIR "product_sepolicy.cil";
    if (access(cil_file, R_OK) == 0)
        load_cil(db, cil_file);

    // vendor
    cil_file = VEND_POLICY_DIR "nonplat_sepolicy.cil";
    if (access(cil_file, R_OK) == 0)
        load_cil(db, cil_file);

    cil_file = VEND_POLICY_DIR "plat_pub_versioned.cil";
    if (access(cil_file, R_OK) == 0)
        load_cil(db, cil_file);

    cil_file = VEND_POLICY_DIR "vendor_sepolicy.cil";
    if (access(cil_file, R_OK) == 0)
        load_cil(db, cil_file);

    // odm
    cil_file = ODM_POLICY_DIR "odm_sepolicy.cil";
    if (access(cil_file, R_OK) == 0)
        load_cil(db, cil_file);

    if (cil_compile(db))
        return {};
    if (cil_build_policydb(db, &pdb))
        return {};
    return {std::make_unique<sepol_impl>(&pdb->p)};
}

SePolicy SePolicy::from_split() noexcept {
    const char *odm_pre = ODM_POLICY_DIR "precompiled_sepolicy";
    const char *vend_pre = VEND_POLICY_DIR "precompiled_sepolicy";
    if (access(odm_pre, R_OK) == 0 && check_precompiled(odm_pre))
        return SePolicy::from_file(odm_pre);
    else if (access(vend_pre, R_OK) == 0 && check_precompiled(vend_pre))
        return SePolicy::from_file(vend_pre);
    else
        return SePolicy::compile_split();
}

sepol_impl::~sepol_impl() {
    policydb_destroy(db);
    free(db);
}

static int vec_write(void *v, const char *buf, int len) {
    auto vec = static_cast<vector<char> *>(v);
    vec->insert(vec->end(), buf, buf + len);
    return len;
}

bool SePolicy::to_file(::Utf8CStr file) const noexcept {
    // No partial writes are allowed to /sys/fs/selinux/load, thus the reason why we
    // first dump everything into memory, then directly call write system call
    vector<char> out;
    FILE *fp = funopen(&out, nullptr, vec_write, nullptr, nullptr);
    // Since we're directly writing to memory, disable buffering
    setbuf(fp, nullptr);

    policy_file_t pf;
    policy_file_init(&pf);
    pf.type = PF_USE_STDIO;
    pf.fp = fp;
    if (policydb_write(impl->db, &pf)) {
        LOGE("Fail to create policy image\n");
        fclose(fp);
        return false;
    }
    fclose(fp);

    int fd = xopen(file.data(), O_WRONLY | O_CREAT | O_CLOEXEC, 0644);
    if (fd < 0)
        return false;
    if (struct stat st{}; xfstat(fd, &st) == 0 && st.st_size > 0) {
        ftruncate(fd, 0);
    }
    xwrite(fd, out.data(), out.size());

    close(fd);
    return true;
}

```

`native/src/sepolicy/rules.rs`:

```rs
use crate::SePolicy;
use crate::consts::{SEPOL_FILE_TYPE, SEPOL_LOG_TYPE, SEPOL_PROC_DOMAIN};
use crate::ffi::Xperm;
use base::{LogLevel, set_log_level_state};

macro_rules! rules {
    (@args all) => {
        vec![]
    };
    (@args xall) => {
        vec![Xperm { low: 0x0000, high: 0xFFFF, reset: false }]
    };
    (@args svcmgr) => {
        vec!["servicemanager", "vndservicemanager", "hwservicemanager"]
    };
    (@args [proc]) => {
        vec![SEPOL_PROC_DOMAIN]
    };
    (@args [file]) => {
        vec![SEPOL_FILE_TYPE]
    };
    (@args [log]) => {
        vec![SEPOL_LOG_TYPE]
    };
    (@args proc) => {
        SEPOL_PROC_DOMAIN
    };
    (@args file) => {
        SEPOL_FILE_TYPE
    };
    (@args log) => {
        SEPOL_LOG_TYPE
    };
    (@args [$($arg:tt)*]) => {
        vec![$($arg)*]
    };
    (@args $arg:expr) => {
        $arg
    };
    (@stmt $self:ident) => {};
    (@stmt $self:ident $action:ident($($args:tt),*); $($res:tt)*) => {
        $self.$action($(rules!(@args $args)),*);
        rules!{@stmt $self $($res)* }
    };
    (use $self:ident; $($res:tt)*) => {{
        rules!{@stmt $self $($res)* }
    }};
}

impl SePolicy {
    pub fn magisk_rules(&mut self) {
        // Temp suppress warnings
        set_log_level_state(LogLevel::Warn, false);
        rules! {
            use self;
            // Prevent anything to change sepolicy except ourselves
            deny(all, ["kernel"], ["security"], ["load_policy"]);
            type_(proc, ["domain"]);
            typeattribute([proc], ["mlstrustedsubject", "netdomain", "appdomain"]);
            type_(file, ["file_type"]);
            typeattribute([file], ["mlstrustedobject"]);
            type_(log, ["file_type"]);
            typeattribute([log], ["mlstrustedobject"]);

            // Create unconstrained file type
            allow(["domain"], [file],
                ["file", "dir", "fifo_file", "chr_file", "lnk_file", "sock_file"], all);

            // Only allow zygote to open log pipe
            allow(["zygote"], [log], ["fifo_file"], ["open", "read"]);
            // Allow all processes to output logs
            allow(["domain"], [log], ["fifo_file"], ["write"]);

            // Make our root domain unconstrained
            allow([proc], [
                "fs_type", "dev_type", "file_type", "domain",
                "service_manager_type", "hwservice_manager_type", "vndservice_manager_type",
                "port_type", "node_type", "property_type"
            ], all, all);

            // Just in case, make the domain permissive
            permissive([proc]);

            // Allow us to do any ioctl
            allowxperm([proc], ["fs_type", "dev_type", "file_type", "domain"],
                ["blk_file", "fifo_file", "chr_file"], xall);
            allowxperm([proc], [proc], ["tcp_socket", "udp_socket", "rawip_socket"], xall);

            // Let binder work with our processes
            allow(svcmgr, [proc], ["dir"], ["search"]);
            allow(svcmgr, [proc], ["file"], ["open", "read", "map"]);
            allow(svcmgr, [proc], ["process"], ["getattr"]);
            allow(["domain"], [proc], ["binder"], ["call", "transfer"]);

            // Other common IPC
            allow(["domain"], [proc], ["process"], ["sigchld"]);
            allow(["domain"], [proc], ["fd"], ["use"]);
            allow(["domain"], [proc], ["fifo_file"], ["write", "read", "open", "getattr"]);

            // Allow these processes to access MagiskSU and output logs
            allow(["zygote", "shell", "platform_app",
                "system_app", "priv_app", "untrusted_app", "untrusted_app_all"],
                [proc], ["unix_stream_socket"], ["connectto", "getopt"]);

            // Let selected domains access tmpfs files
            // For tmpfs overlay on 2SI, Zygisk on lower Android versions and AVD scripts
            allow(["init", "zygote", "shell"], ["tmpfs"], ["file"], all);

            // Allow magiskinit daemon to log to kmsg
            allow(["kernel"], ["rootfs", "tmpfs"], ["chr_file"], ["write"]);

            // Allow magiskinit daemon to handle mock selinuxfs
            allow(["kernel"], ["tmpfs"], ["fifo_file"], ["open", "read", "write"]);

            // For relabelling files
            allow(["rootfs"], ["labeledfs", "tmpfs"], ["filesystem"], ["associate"]);
            allow([file], ["pipefs", "devpts"], ["filesystem"], ["associate"]);
            allow(["kernel"], all, ["file"], ["relabelto"]);
            allow(["kernel"], ["tmpfs"], ["file"], ["relabelfrom"]);

            // Let init transit to SEPOL_PROC_DOMAIN
            allow(["kernel"], ["kernel"], ["process"], ["setcurrent"]);
            allow(["kernel"], [proc], ["process"], ["dyntransition"]);

            // Let init run stuffs
            allow(["init"], [proc], ["process"], all);

            // Zygisk rules
            allow(["zygote"], ["zygote"], ["process"], ["execmem"]);
            allow(["zygote"], ["fs_type"], ["filesystem"], ["unmount"]);
            allow(["system_server"], ["system_server"], ["process"], ["execmem"]);

            // Shut llkd up
            dontaudit(["llkd"], [proc], ["process"], ["ptrace"]);

            // Keep /data/adb/* context
            deny(["init"], ["adb_data_file"], ["dir"], ["search"]);
            deny(["vendor_init"], ["adb_data_file"], ["dir"], ["search"]);
        }

        #[cfg(any())]
        self.strip_dontaudit();

        set_log_level_state(LogLevel::Warn, true);
    }
}

```

`native/src/sepolicy/sepolicy.cpp`:

```cpp
#include <base.hpp>

#include "include/sepolicy.hpp"

using namespace std;

// Invert is adding rules for auditdeny; in other cases, invert is removing rules
#define strip_av(effect, invert) ((effect == AVTAB_AUDITDENY) == !invert)

// libsepol internal APIs
__BEGIN_DECLS
int policydb_index_decls(sepol_handle_t * handle, policydb_t * p);
int avtab_hash(struct avtab_key *keyp, uint32_t mask);
int type_set_expand(type_set_t * set, ebitmap_t * t, policydb_t * p, unsigned char alwaysexpand);
int context_from_string(
        sepol_handle_t * handle,
        const policydb_t * policydb,
        context_struct_t ** cptr,
        const char *con_str, size_t con_str_len);
int context_to_string(
        sepol_handle_t * handle,
        const policydb_t * policydb,
        const context_struct_t * context,
        char **result, size_t * result_len);
__END_DECLS

template <typename T>
struct auto_cast_wrapper {
    auto_cast_wrapper(T *ptr) : ptr(ptr) {}
    template <typename U>
    operator U*() const { return static_cast<U*>(ptr); }
private:
    T *ptr;
};

template <typename T>
static auto_cast_wrapper<T> auto_cast(T *p) {
    return auto_cast_wrapper<T>(p);
}

template <size_t T>
static size_t copy_str(std::array<char, T> &dest, rust::Str src) {
    if (T == 0) return 0;
    size_t len = std::min(T - 1, src.size());
    memcpy(dest.data(), src.data(), len);
    dest[len] = '\0';
    return len;
}

static char *dup_str(rust::Str src) {
    size_t len = src.size();
    char *s = static_cast<char *>(malloc(len + 1));
    memcpy(s, src.data(), len);
    s[len] = '\0';
    return s;
}

static bool str_eq(string_view a, rust::Str b) {
    return a.size() == b.size() && memcmp(a.data(), b.data(), a.size()) == 0;
}

static auto hashtab_find(hashtab_t h, Str key) {
    array<char, 256> buf{};
    copy_str(buf, key);
    return auto_cast(hashtab_search(h, buf.data()));
}

template <class Node, class Func>
static void list_for_each(Node *node_ptr, const Func &fn) {
    auto cur = node_ptr;
    while (cur) {
        auto next = cur->next;
        fn(cur);
        cur = next;
    }
}

template <class Node, class Func>
static Node *list_find(Node *node_ptr, const Func &fn) {
    for (auto cur = node_ptr; cur; cur = cur->next) {
        if (fn(cur)) {
            return cur;
        }
    }
    return nullptr;
}

template <class Node, class Func>
static void hash_for_each(Node **node_ptr, int n_slot, const Func &fn) {
    for (int i = 0; i < n_slot; ++i) {
        list_for_each(node_ptr[i], fn);
    }
}

template <class Func>
static void hashtab_for_each(hashtab_t htab, const Func &fn) {
    hash_for_each(htab->htable, htab->size, fn);
}

template <class Func>
static void avtab_for_each(avtab_t *avtab, const Func &fn) {
    hash_for_each(avtab->htable, avtab->nslot, fn);
}

template <class Func>
static void for_each_attr(hashtab_t htab, const Func &fn) {
    hashtab_for_each(htab, [&](hashtab_ptr_t node) {
        auto type = static_cast<type_datum_t *>(node->datum);
        if (type->flavor == TYPE_ATTRIB)
            fn(type);
    });
}

static int avtab_remove_node(avtab_t *h, avtab_ptr_t node) {
    if (!h || !h->htable)
        return SEPOL_ENOMEM;
    int hvalue = avtab_hash(&node->key, h->mask);
    avtab_ptr_t prev = nullptr;
    avtab_ptr_t cur = h->htable[hvalue];
    while (cur) {
        if (cur == node)
            break;
        prev = cur;
        cur = cur->next;
    }
    if (cur == nullptr)
        return SEPOL_ENOENT;

    // Detach from link list
    if (prev)
        prev->next = node->next;
    else
        h->htable[hvalue] = node->next;
    h->nel--;

    // Free memory
    free(node->datum.xperms);
    free(node);
    return 0;
}

static bool is_redundant(avtab_ptr_t node) {
    switch (node->key.specified) {
    case AVTAB_AUDITDENY:
        return node->datum.data == ~0U;
    case AVTAB_XPERMS:
        return node->datum.xperms == nullptr;
    default:
        return node->datum.data == 0U;
    }
}

avtab_ptr_t sepol_impl::find_avtab_node(avtab_key_t *key, avtab_extended_perms_t *xperms) {
    avtab_ptr_t node;

    // AVTAB_XPERMS entries are not necessarily unique
    if (key->specified & AVTAB_XPERMS) {
        if (xperms == nullptr)
            return nullptr;
        node = avtab_search_node(&db->te_avtab, key);
        while (node) {
            if ((node->datum.xperms->specified == xperms->specified) &&
                (node->datum.xperms->driver == xperms->driver)) {
                node = nullptr;
                break;
            }
            node = avtab_search_node_next(node, key->specified);
        }
    } else {
        node = avtab_search_node(&db->te_avtab, key);
    }

    return node;
}

avtab_ptr_t sepol_impl::insert_avtab_node(avtab_key_t *key) {
    avtab_datum_t avdatum{};
    // AUDITDENY, aka DONTAUDIT, are &= assigned, versus |= for others.
    // Initialize the data accordingly.
    avdatum.data = key->specified == AVTAB_AUDITDENY ? ~0U : 0U;
    return avtab_insert_nonunique(&db->te_avtab, key, &avdatum);
}

avtab_ptr_t sepol_impl::get_avtab_node(avtab_key_t *key, avtab_extended_perms_t *xperms) {
    avtab_ptr_t node = find_avtab_node(key, xperms);
    if (!node) {
        node = insert_avtab_node(key);
    }
    return node;
}

void sepol_impl::add_rule(type_datum_t *src, type_datum_t *tgt, class_datum_t *cls, perm_datum_t *perm, int effect, bool invert) {
    if (src == nullptr) {
        if (strip_av(effect, invert)) {
            // Stripping av, have to go through all types for correct results
            hashtab_for_each(db->p_types.table, [&](hashtab_ptr_t node) {
                add_rule(auto_cast(node->datum), tgt, cls, perm, effect, invert);
            });
        } else {
            // If we are not stripping av, go through all attributes instead of types for optimization
            for_each_attr(db->p_types.table, [&](type_datum_t *type) {
                add_rule(type, tgt, cls, perm, effect, invert);
            });
        }
    } else if (tgt == nullptr) {
        if (strip_av(effect, invert)) {
            hashtab_for_each(db->p_types.table, [&](hashtab_ptr_t node) {
                add_rule(src, auto_cast(node->datum), cls, perm, effect, invert);
            });
        } else {
            for_each_attr(db->p_types.table, [&](type_datum_t *type) {
                add_rule(src, type, cls, perm, effect, invert);
            });
        }
    } else if (cls == nullptr) {
        hashtab_for_each(db->p_classes.table, [&](hashtab_ptr_t node) {
            add_rule(src, tgt, auto_cast(node->datum), perm, effect, invert);
        });
    } else {
        avtab_key_t key;
        key.source_type = src->s.value;
        key.target_type = tgt->s.value;
        key.target_class = cls->s.value;
        key.specified = effect;

        avtab_ptr_t node = get_avtab_node(&key, nullptr);
        if (invert) {
            if (perm)
                node->datum.data &= ~(1U << (perm->s.value - 1));
            else
                node->datum.data = 0U;
        } else {
            if (perm)
                node->datum.data |= 1U << (perm->s.value - 1);
            else
                node->datum.data = ~0U;
        }

        if (is_redundant(node))
            avtab_remove_node(&db->te_avtab, node);
    }
}

bool sepol_impl::add_rule(Str s, Str t, Str c, Str p, int effect, bool invert) {
    type_datum_t *src = nullptr, *tgt = nullptr;
    class_datum_t *cls = nullptr;
    perm_datum_t *perm = nullptr;

    if (!s.empty()) {
        src = hashtab_find(db->p_types.table, s);
        if (src == nullptr) {
            LOGW("source type %.*s does not exist\n", (int) s.size(), s.data());
            return false;
        }
    }

    if (!t.empty()) {
        tgt = hashtab_find(db->p_types.table, t);
        if (tgt == nullptr) {
            LOGW("target type %.*s does not exist\n", (int) t.size(), t.data());
            return false;
        }
    }

    if (!c.empty()) {
        cls = hashtab_find(db->p_classes.table, c);
        if (cls == nullptr) {
            LOGW("class %.*s does not exist\n", (int) c.size(), c.data());
            return false;
        }
    }

    if (!p.empty()) {
        if (c.empty()) {
            LOGW("No class is specified, cannot add perm [%.*s] \n", (int) p.size(), p.data());
            return false;
        }

        perm = hashtab_find(cls->permissions.table, p);
        if (perm == nullptr && cls->comdatum != nullptr) {
            perm = hashtab_find(cls->comdatum->permissions.table, p);
        }
        if (perm == nullptr) {
            LOGW("perm %.*s does not exist in class %.*s\n",
                 (int) p.size(), p.data(), (int) c.size(), c.data());
            return false;
        }
    }
    add_rule(src, tgt, cls, perm, effect, invert);
    return true;
}

#define ioctl_driver(x) (x>>8 & 0xFF)
#define ioctl_func(x) (x & 0xFF)

void sepol_impl::add_xperm_rule(type_datum_t *src, type_datum_t *tgt, class_datum_t *cls, const Xperm &p, int effect) {
    if (db->policyvers < POLICYDB_VERSION_XPERMS_IOCTL) {
        LOGW("policy version %u does not support ioctl extended permissions rules\n", db->policyvers);
        return;
    }
    if (src == nullptr) {
        for_each_attr(db->p_types.table, [&](type_datum_t *type) {
            add_xperm_rule(type, tgt, cls, p, effect);
        });
    } else if (tgt == nullptr) {
        for_each_attr(db->p_types.table, [&](type_datum_t *type) {
            add_xperm_rule(src, type, cls, p, effect);
        });
    } else if (cls == nullptr) {
        hashtab_for_each(db->p_classes.table, [&](hashtab_ptr_t node) {
            add_xperm_rule(src, tgt, auto_cast(node->datum), p, effect);
        });
    } else {
        avtab_key_t key;
        key.source_type = src->s.value;
        key.target_type = tgt->s.value;
        key.target_class = cls->s.value;
        key.specified = effect;

        // Each key may contain 1 driver node and 256 function nodes
        avtab_ptr_t node_list[257] = { nullptr };
#define driver_node (node_list[256])

        // Find all rules with key
        for (avtab_ptr_t node = avtab_search_node(&db->te_avtab, &key); node;) {
            if (node->datum.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {
                driver_node = node;
            } else if (node->datum.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {
                node_list[node->datum.xperms->driver] = node;
            }
            node = avtab_search_node_next(node, key.specified);
        }

        if (p.reset) {
            for (int i = 0; i <= 0xFF; ++i) {
                if (node_list[i]) {
                    avtab_remove_node(&db->te_avtab, node_list[i]);
                    node_list[i] = nullptr;
                }
            }
            if (driver_node) {
                memset(driver_node->datum.xperms->perms, 0, sizeof(avtab_extended_perms_t::perms));
            }
        }

        auto new_driver_node = [&]() -> avtab_ptr_t {
            auto node = insert_avtab_node(&key);
            node->datum.xperms = auto_cast(calloc(1, sizeof(avtab_extended_perms_t)));
            node->datum.xperms->specified = AVTAB_XPERMS_IOCTLDRIVER;
            node->datum.xperms->driver = 0;
            return node;
        };

        auto new_func_node = [&](uint8_t driver) -> avtab_ptr_t {
            auto node = insert_avtab_node(&key);
            node->datum.xperms = auto_cast(calloc(1, sizeof(avtab_extended_perms_t)));
            node->datum.xperms->specified = AVTAB_XPERMS_IOCTLFUNCTION;
            node->datum.xperms->driver = driver;
            return node;
        };

        if (!p.reset) {
            if (ioctl_driver(p.low) != ioctl_driver(p.high)) {
                if (driver_node == nullptr) {
                    driver_node = new_driver_node();
                }
                for (int i = ioctl_driver(p.low); i <= ioctl_driver(p.high); ++i) {
                    xperm_set(i, driver_node->datum.xperms->perms);
                }
            } else {
                uint8_t driver = ioctl_driver(p.low);
                auto node = node_list[driver];
                if (node == nullptr) {
                    node = new_func_node(driver);
                    node_list[driver] = node;
                }
                for (int i = ioctl_func(p.low); i <= ioctl_func(p.high); ++i) {
                    xperm_set(i, node->datum.xperms->perms);
                }
            }
        } else {
            if (driver_node == nullptr) {
                driver_node = new_driver_node();
            }
            // Fill the driver perms
            memset(driver_node->datum.xperms->perms, ~0, sizeof(avtab_extended_perms_t::perms));

            if (ioctl_driver(p.low) != ioctl_driver(p.high)) {
                for (int i = ioctl_driver(p.low); i <= ioctl_driver(p.high); ++i) {
                    xperm_clear(i, driver_node->datum.xperms->perms);
                }
            } else {
                uint8_t driver = ioctl_driver(p.low);
                auto node = node_list[driver];
                if (node == nullptr) {
                    node = new_func_node(driver);
                    // Fill the func perms
                    memset(node->datum.xperms->perms, ~0, sizeof(avtab_extended_perms_t::perms));
                    node_list[driver] = node;
                }
                xperm_clear(driver, driver_node->datum.xperms->perms);
                for (int i = ioctl_func(p.low); i <= ioctl_func(p.high); ++i) {
                    xperm_clear(i, node->datum.xperms->perms);
                }
            }
        }
    }
}

bool sepol_impl::add_xperm_rule(Str s, Str t, Str c, const Xperm &p, int effect) {
    type_datum_t *src = nullptr, *tgt = nullptr;
    class_datum_t *cls = nullptr;

    if (!s.empty()) {
        src = hashtab_find(db->p_types.table, s);
        if (src == nullptr) {
            LOGW("source type %.*s does not exist\n", (int) s.size(), s.data());
            return false;
        }
    }

    if (!t.empty()) {
        tgt = hashtab_find(db->p_types.table, t);
        if (tgt == nullptr) {
            LOGW("target type %.*s does not exist\n", (int) t.size(), t.data());
            return false;
        }
    }

    if (!c.empty()) {
        cls = hashtab_find(db->p_classes.table, c);
        if (cls == nullptr) {
            LOGW("class %.*s does not exist\n", (int) c.size(), c.data());
            return false;
        }
    }

    add_xperm_rule(src, tgt, cls, p, effect);
    return true;
}

bool sepol_impl::add_type_rule(Str s, Str t, Str c, Str d, int effect) {
    type_datum_t *src, *tgt, *def;
    class_datum_t *cls;

    src = hashtab_find(db->p_types.table, s);
    if (src == nullptr) {
        LOGW("source type %.*s does not exist\n", (int) s.size(), s.data());
        return false;
    }
    tgt = hashtab_find(db->p_types.table, t);
    if (tgt == nullptr) {
        LOGW("target type %.*s does not exist\n", (int) t.size(), t.data());
        return false;
    }
    cls = hashtab_find(db->p_classes.table, c);
    if (cls == nullptr) {
        LOGW("class %.*s does not exist\n", (int) c.size(), c.data());
        return false;
    }
    def = hashtab_find(db->p_types.table, d);
    if (def == nullptr) {
        LOGW("default type %.*s does not exist\n", (int) d.size(), d.data());
        return false;
    }

    avtab_key_t key;
    key.source_type = src->s.value;
    key.target_type = tgt->s.value;
    key.target_class = cls->s.value;
    key.specified = effect;

    avtab_ptr_t node = get_avtab_node(&key, nullptr);
    node->datum.data = def->s.value;

    return true;
}

bool sepol_impl::add_filename_trans(Str s, Str t, Str c, Str d, Str o) {
    type_datum_t *src, *tgt, *def;
    class_datum_t *cls;

    src = hashtab_find(db->p_types.table, s);
    if (src == nullptr) {
        LOGW("source type %.*s does not exist\n", (int) s.size(), s.data());
        return false;
    }
    tgt = hashtab_find(db->p_types.table, t);
    if (tgt == nullptr) {
        LOGW("target type %.*s does not exist\n", (int) t.size(), t.data());
        return false;
    }
    cls = hashtab_find(db->p_classes.table, c);
    if (cls == nullptr) {
        LOGW("class %.*s does not exist\n", (int) c.size(), c.data());
        return false;
    }
    def = hashtab_find(db->p_types.table, d);
    if (def == nullptr) {
        LOGW("default type %.*s does not exist\n", (int) d.size(), d.data());
        return false;
    }

    array<char, 256> key_name{};
    copy_str(key_name, o);
    filename_trans_key_t key;
    key.ttype = tgt->s.value;
    key.tclass = cls->s.value;
    key.name = key_name.data();

    filename_trans_datum_t *trans = hashtab_find(db->filename_trans, (hashtab_key_t) &key);
    filename_trans_datum_t *last = nullptr;
    while (trans) {
        if (ebitmap_get_bit(&trans->stypes, src->s.value - 1)) {
            // Duplicate, overwrite existing data and return
            trans->otype = def->s.value;
            return true;
        }
        if (trans->otype == def->s.value)
            break;
        last = trans;
        trans = trans->next;
    }
    if (trans == nullptr) {
        trans = auto_cast(calloc(sizeof(*trans), 1));
        ebitmap_init(&trans->stypes);
        trans->otype = def->s.value;
    }
    if (last) {
        last->next = trans;
    } else {
        filename_trans_key_t *new_key = auto_cast(malloc(sizeof(*new_key)));
        memcpy(new_key, &key, sizeof(key));
        new_key->name = strdup(key.name);
        hashtab_insert(db->filename_trans, (hashtab_key_t) new_key, trans);
    }

    db->filename_trans_count++;
    return ebitmap_set_bit(&trans->stypes, src->s.value - 1, 1) == 0;
}

bool sepol_impl::add_genfscon(Str fs_name, Str path, Str context) {
    // First try to create context
    context_struct_t *ctx;
    if (context_from_string(nullptr, db, &ctx, context.data(), context.size())) {
        LOGW("Failed to create context from string [%.*s]\n", (int) context.size(), context.data());
        return false;
    }

    // Find genfs node
    genfs_t *fs = list_find(db->genfs, [&](genfs_t *n) {
        return str_eq(n->fstype, fs_name);
    });
    if (fs == nullptr) {
        fs = auto_cast(calloc(sizeof(*fs), 1));
        fs->fstype = dup_str(fs_name);
        fs->next = db->genfs;
        db->genfs = fs;
    }

    // Find context node
    ocontext_t *o_ctx = list_find(fs->head, [&](ocontext_t *n) {
        return str_eq(n->u.name, path);
    });
    if (o_ctx == nullptr) {
        o_ctx = auto_cast(calloc(sizeof(*o_ctx), 1));
        o_ctx->u.name = dup_str(path);
        o_ctx->next = fs->head;
        fs->head = o_ctx;
    }
    memset(o_ctx->context, 0, sizeof(o_ctx->context));
    memcpy(&o_ctx->context[0], ctx, sizeof(*ctx));
    free(ctx);

    return true;
}

bool sepol_impl::add_type(Str type_name, uint32_t flavor) {
    type_datum_t *type = hashtab_find(db->p_types.table, type_name);
    if (type) {
        LOGW("Type %.*s already exists\n", (int) type_name.size(), type_name.data());
        return true;
    }

    type = auto_cast(malloc(sizeof(*type)));
    type_datum_init(type);
    type->primary = 1;
    type->flavor = flavor;

    uint32_t value = 0;
    auto ty_name = dup_str(type_name);
    if (symtab_insert(db, SYM_TYPES, ty_name, type, SCOPE_DECL, 1, &value)) {
        free(ty_name);
        return false;
    }
    type->s.value = value;
    ebitmap_set_bit(&db->global->branch_list->declared.p_types_scope, value - 1, 1);

    auto new_size = sizeof(ebitmap_t) * db->p_types.nprim;
    db->type_attr_map = auto_cast(realloc(db->type_attr_map, new_size));
    db->attr_type_map = auto_cast(realloc(db->attr_type_map, new_size));
    ebitmap_init(&db->type_attr_map[value - 1]);
    ebitmap_init(&db->attr_type_map[value - 1]);
    ebitmap_set_bit(&db->type_attr_map[value - 1], value - 1, 1);

    // Re-index stuffs
    if (policydb_index_decls(nullptr, db) ||
        policydb_index_classes(db) || policydb_index_others(nullptr, db, 0))
        return false;

    // Add the type to all roles
    for (int i = 0; i < db->p_roles.nprim; ++i) {
        // Not sure all those three calls are needed
        ebitmap_set_bit(&db->role_val_to_struct[i]->types.negset, value - 1, 0);
        ebitmap_set_bit(&db->role_val_to_struct[i]->types.types, value - 1, 1);
        type_set_expand(&db->role_val_to_struct[i]->types, &db->role_val_to_struct[i]->cache, db, 0);
    }

    return true;
}

bool sepol_impl::set_type_state(Str type_name, bool permissive) {
    type_datum_t *type;
    if (type_name.empty()) {
        hashtab_for_each(db->p_types.table, [&](hashtab_ptr_t node) {
            type = auto_cast(node->datum);
            if (ebitmap_set_bit(&db->permissive_map, type->s.value, permissive))
                LOGW("Could not set bit in permissive map\n");
        });
    } else {
        type = hashtab_find(db->p_types.table, type_name);
        if (type == nullptr) {
            LOGW("type %.*s does not exist\n", (int) type_name.size(), type_name.data());
            return false;
        }
        if (ebitmap_set_bit(&db->permissive_map, type->s.value, permissive)) {
            LOGW("Could not set bit in permissive map\n");
            return false;
        }
    }
    return true;
}

void sepol_impl::add_typeattribute(type_datum_t *type, type_datum_t *attr) {
    ebitmap_set_bit(&db->type_attr_map[type->s.value - 1], attr->s.value - 1, 1);
    ebitmap_set_bit(&db->attr_type_map[attr->s.value - 1], type->s.value - 1, 1);

    hashtab_for_each(db->p_classes.table, [&](hashtab_ptr_t node){
        auto cls = static_cast<class_datum_t *>(node->datum);
        list_for_each(cls->constraints, [&](constraint_node_t *n) {
            list_for_each(n->expr, [&](constraint_expr_t *e) {
                if (e->expr_type == CEXPR_NAMES &&
                    ebitmap_get_bit(&e->type_names->types, attr->s.value - 1)) {
                    ebitmap_set_bit(&e->names, type->s.value - 1, 1);
                }
            });
        });
    });
}

bool sepol_impl::add_typeattribute(Str type, Str attr) {
    type_datum_t *type_d = hashtab_find(db->p_types.table, type);
    if (type_d == nullptr) {
        LOGW("type %.*s does not exist\n", (int) type.size(), type.data());
        return false;
    } else if (type_d->flavor == TYPE_ATTRIB) {
        LOGW("type %.*s is an attribute\n", (int) type.size(), type.data());
        return false;
    }

    type_datum *attr_d = hashtab_find(db->p_types.table, attr);
    if (attr_d == nullptr) {
        LOGW("attribute %.*s does not exist\n", (int) attr.size(), attr.data());
        return false;
    } else if (attr_d->flavor != TYPE_ATTRIB) {
        LOGW("type %.*s is not an attribute \n", (int) attr.size(), attr.data());
        return false;
    }

    add_typeattribute(type_d, attr_d);
    return true;
}

void SePolicy::strip_dontaudit() noexcept {
    avtab_for_each(&impl->db->te_avtab, [this](avtab_ptr_t node) {
        if (node->key.specified == AVTAB_AUDITDENY || node->key.specified == AVTAB_XPERMS_DONTAUDIT)
            avtab_remove_node(&impl->db->te_avtab, node);
    });
}

void SePolicy::print_rules() const noexcept {
    hashtab_for_each(impl->db->p_types.table, [this](hashtab_ptr_t node) {
        type_datum_t *type = auto_cast(node->datum);
        if (type->flavor == TYPE_ATTRIB) {
            impl->print_type(stdout, type);
        }
    });
    hashtab_for_each(impl->db->p_types.table, [this](hashtab_ptr_t node) {
        type_datum_t *type = auto_cast(node->datum);
        if (type->flavor == TYPE_TYPE) {
            impl->print_type(stdout, type);
        }
    });
    avtab_for_each(&impl->db->te_avtab, [this](avtab_ptr_t node) {
        impl->print_avtab(stdout, node);
    });
    hashtab_for_each(impl->db->filename_trans, [this](hashtab_ptr_t node) {
        impl->print_filename_trans(stdout, node);
    });
    list_for_each(impl->db->genfs, [this](genfs_t *genfs) {
        list_for_each(genfs->head, [&](ocontext *context) {
            char *ctx = nullptr;
            size_t len = 0;
            if (context_to_string(nullptr, impl->db, &context->context[0], &ctx, &len) == 0) {
                fprintf(stdout, "genfscon %s %s %s\n", genfs->fstype, context->u.name, ctx);
                free(ctx);
            }
        });
    });
}

void sepol_impl::print_type(FILE *fp, type_datum_t *type) {
    const char *name = db->p_type_val_to_name[type->s.value - 1];
    if (name == nullptr)
        return;
    if (type->flavor == TYPE_ATTRIB) {
        fprintf(fp, "attribute %s\n", name);
    } else if (type->flavor == TYPE_TYPE) {
        bool first = true;
        ebitmap_t *bitmap = &db->type_attr_map[type->s.value - 1];
        for (uint32_t i = 0; i <= bitmap->highbit; ++i) {
            if (ebitmap_get_bit(bitmap, i)) {
                auto attr_type = db->type_val_to_struct[i];
                if (attr_type->flavor == TYPE_ATTRIB) {
                    if (const char *attr = db->p_type_val_to_name[i]) {
                        if (first) {
                            fprintf(fp, "type %s {", name);
                            first = false;
                        }
                        fprintf(fp, " %s", attr);
                    }
                }
            }
        }
        if (!first) {
            fprintf(fp, " }\n");
        }
    }
    if (ebitmap_get_bit(&db->permissive_map, type->s.value)) {
        fprintf(fp, "permissive %s\n", name);
    }
}

void sepol_impl::print_avtab(FILE *fp, avtab_ptr_t node) {
    const char *src = db->p_type_val_to_name[node->key.source_type - 1];
    const char *tgt = db->p_type_val_to_name[node->key.target_type - 1];
    const char *cls = db->p_class_val_to_name[node->key.target_class - 1];
    if (src == nullptr || tgt == nullptr || cls == nullptr)
        return;

    if (node->key.specified & AVTAB_AV) {
        uint32_t data = node->datum.data;
        const char *name;
        switch (node->key.specified) {
            case AVTAB_ALLOWED:
                name = "allow";
                break;
            case AVTAB_AUDITALLOW:
                name = "auditallow";
                break;
            case AVTAB_AUDITDENY:
                name = "dontaudit";
                // Invert the rules for dontaudit
                data = ~data;
                break;
            default:
                return;
        }

        class_datum_t *clz = db->class_val_to_struct[node->key.target_class - 1];
        if (clz == nullptr)
            return;

        auto it = class_perm_names.find(cls);
        if (it == class_perm_names.end()) {
            it = class_perm_names.try_emplace(cls).first;
            // Find all permission names and cache the value
            hashtab_for_each(clz->permissions.table, [&](hashtab_ptr_t node) {
                perm_datum_t *perm = auto_cast(node->datum);
                it->second[perm->s.value - 1] = node->key;
            });
            if (clz->comdatum) {
                hashtab_for_each(clz->comdatum->permissions.table, [&](hashtab_ptr_t node) {
                    perm_datum_t *perm = auto_cast(node->datum);
                    it->second[perm->s.value - 1] = node->key;
                });
            }
        }

        bool first = true;
        for (int i = 0; i < 32; ++i) {
            if (data & (1u << i)) {
                if (const char *perm = it->second[i]) {
                    if (first) {
                        fprintf(fp, "%s %s %s %s {", name, src, tgt, cls);
                        first = false;
                    }
                    fprintf(fp, " %s", perm);
                }
            }
        }
        if (!first) {
            fprintf(fp, " }\n");
        }
    } else if (node->key.specified & AVTAB_TYPE) {
        const char *name;
        switch (node->key.specified) {
            case AVTAB_TRANSITION:
                name = "type_transition";
                break;
            case AVTAB_MEMBER:
                name = "type_member";
                break;
            case AVTAB_CHANGE:
                name = "type_change";
                break;
            default:
                return;
        }
        if (const char *def = db->p_type_val_to_name[node->datum.data - 1]) {
            fprintf(fp, "%s %s %s %s %s\n", name, src, tgt, cls, def);
        }
    } else if (node->key.specified & AVTAB_XPERMS) {
        const char *name;
        switch (node->key.specified) {
            case AVTAB_XPERMS_ALLOWED:
                name = "allowxperm";
                break;
            case AVTAB_XPERMS_AUDITALLOW:
                name = "auditallowxperm";
                break;
            case AVTAB_XPERMS_DONTAUDIT:
                name = "dontauditxperm";
                break;
            default:
                return;
        }
        avtab_extended_perms_t *xperms = node->datum.xperms;
        if (xperms == nullptr)
            return;

        vector<pair<uint8_t, uint8_t>> ranges;
        {
            int low = -1;
            for (int i = 0; i < 256; ++i) {
                if (xperm_test(i, xperms->perms)) {
                    if (low < 0) {
                        low = i;
                    }
                    if (i == 255) {
                        ranges.emplace_back(low, 255);
                    }
                } else if (low >= 0) {
                    ranges.emplace_back(low, i - 1);
                    low = -1;
                }
            }
        }

        auto to_value = [&](uint8_t val) -> uint16_t {
            if (xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {
                return (((uint16_t) xperms->driver) << 8) | val;
            } else {
                return ((uint16_t) val) << 8;
            }
        };

        if (!ranges.empty()) {
            fprintf(fp, "%s %s %s %s ioctl {", name, src, tgt, cls);
            for (auto [l, h] : ranges) {
                uint16_t low = to_value(l);
                uint16_t high = to_value(h);
                if (low == high) {
                    fprintf(fp, " 0x%04X", low);
                } else {
                    fprintf(fp, " 0x%04X-0x%04X", low, high);
                }
            }
            fprintf(fp, " }\n");
        }
    }
}

void sepol_impl::print_filename_trans(FILE *fp, hashtab_ptr_t node) {
    auto key = reinterpret_cast<filename_trans_key_t *>(node->key);
    filename_trans_datum_t *trans = auto_cast(node->datum);

    const char *tgt = db->p_type_val_to_name[key->ttype - 1];
    const char *cls = db->p_class_val_to_name[key->tclass - 1];
    const char *def = db->p_type_val_to_name[trans->otype - 1];
    if (tgt == nullptr || cls == nullptr || def == nullptr || key->name == nullptr)
        return;

    for (uint32_t i = 0; i <= trans->stypes.highbit; ++i) {
        if (ebitmap_get_bit(&trans->stypes, i)) {
            if (const char *src = db->p_type_val_to_name[i]) {
                fprintf(fp, "type_transition %s %s %s %s %s\n", src, tgt, cls, def, key->name);
            }
        }
    }
}

```

`native/src/sepolicy/statement.rs`:

```rs
use std::fmt::{Display, Formatter, Write};
use std::io::{BufRead, BufReader, Cursor};
use std::iter::Peekable;
use std::vec::IntoIter;

use crate::SePolicy;
use crate::ffi::Xperm;
use base::nix::fcntl::OFlag;
use base::{BufReadExt, LoggedResult, Utf8CStr, error, warn};

pub enum Token<'a> {
    AL,
    DN,
    AA,
    DA,
    AX,
    AY,
    DX,
    PM,
    EF,
    TA,
    TY,
    AT,
    TT,
    TC,
    TM,
    GF,
    LB,
    RB,
    CM,
    ST,
    TL,
    HP,
    HX(u16),
    ID(&'a str),
}

type Tokens<'a> = Peekable<IntoIter<Token<'a>>>;
type ParseResult<'a, T> = Result<T, ParseError<'a>>;

enum ParseError<'a> {
    General,
    AvtabAv(Token<'a>),
    AvtabXperms(Token<'a>),
    AvtabType(Token<'a>),
    TypeState(Token<'a>),
    TypeAttr,
    TypeTrans,
    NewType,
    NewAttr,
    GenfsCon,
    ShowHelp,
    UnknownAction(Token<'a>),
}

macro_rules! throw {
    () => {
        Err(ParseError::General)?
    };
}

fn parse_id<'a>(tokens: &mut Tokens<'a>) -> ParseResult<'a, &'a str> {
    match tokens.next() {
        Some(Token::ID(name)) => Ok(name),
        _ => throw!(),
    }
}

// names ::= ID(n) { vec![n] };
// names ::= names(mut v) ID(n) { v.push(n); v };
// term ::= ID(n) { vec![n] }
// term ::= LB names(n) RB { n };
fn parse_term<'a>(tokens: &mut Tokens<'a>) -> ParseResult<'a, Vec<&'a str>> {
    match tokens.next() {
        Some(Token::ID(name)) => Ok(vec![name]),
        Some(Token::LB) => {
            let mut names = Vec::new();
            loop {
                match tokens.next() {
                    Some(Token::ID(name)) => names.push(name),
                    Some(Token::RB) => break,
                    _ => throw!(),
                }
            }
            Ok(names)
        }
        _ => throw!(),
    }
}

// names ::= ST { vec![] }
// names ::= ID(n) { vec![n] };
// names ::= names(mut v) ID(n) { v.push(n); v };
// names ::= names(n) ST { vec![] };
// sterm ::= ST { vec![] }
// sterm ::= ID(n) { vec![n] }
// sterm ::= LB names(n) RB { n };
fn parse_sterm<'a>(tokens: &mut Tokens<'a>) -> ParseResult<'a, Vec<&'a str>> {
    match tokens.next() {
        Some(Token::ID(name)) => Ok(vec![name]),
        Some(Token::ST) => Ok(vec![]),
        Some(Token::LB) => {
            let mut names = Some(Vec::new());
            loop {
                match tokens.next() {
                    Some(Token::ID(name)) => {
                        if let Some(ref mut names) = names {
                            names.push(name)
                        }
                    }
                    Some(Token::ST) => names = None,
                    Some(Token::RB) => break,
                    _ => throw!(),
                }
            }
            Ok(names.unwrap_or(vec![]))
        }
        _ => throw!(),
    }
}

// xperm ::= HX(low) { Xperm{low, high: low, reset: false} };
// xperm ::= HX(low) HP HX(high) { Xperm{low, high, reset: false} };
fn parse_xperm<'a>(tokens: &mut Tokens<'a>) -> ParseResult<'a, Xperm> {
    let low = match tokens.next() {
        Some(Token::HX(low)) => low,
        _ => throw!(),
    };
    let high = match tokens.peek() {
        Some(Token::HP) => {
            tokens.next();
            match tokens.next() {
                Some(Token::HX(high)) => high,
                _ => throw!(),
            }
        }
        _ => low,
    };
    Ok(Xperm {
        low,
        high,
        reset: false,
    })
}

// xperms ::= HX(low) { if low > 0 { vec![Xperm{low, high: low, reset: false}] } else { vec![Xperm{low: 0x0000, high: 0xFFFF, reset: true}] }};
// xperms ::= LB xperm_list(l) RB { l };
// xperms ::= TL LB xperm_list(mut l) RB { l.iter_mut().for_each(|x| { x.reset = true; }); l };
// xperms ::= ST { vec![Xperm{low: 0x0000, high: 0xFFFF, reset: false}] };
//
// xperm_list ::= xperm(p) { vec![p] }
// xperm_list ::= xperm_list(mut l) xperm(p) { l.push(p); l }
fn parse_xperms<'a>(tokens: &mut Tokens<'a>) -> ParseResult<'a, Vec<Xperm>> {
    let mut xperms = Vec::new();
    let reset = match tokens.peek() {
        Some(Token::TL) => {
            tokens.next();
            if !matches!(tokens.peek(), Some(Token::LB)) {
                throw!();
            }
            true
        }
        _ => false,
    };
    match tokens.next() {
        Some(Token::LB) => {
            // parse xperm_list
            loop {
                let mut xperm = parse_xperm(tokens)?;
                xperm.reset = reset;
                xperms.push(xperm);
                if matches!(tokens.peek(), Some(Token::RB)) {
                    tokens.next();
                    break;
                }
            }
        }
        Some(Token::ST) => {
            xperms.push(Xperm {
                low: 0x0000,
                high: 0xFFFF,
                reset,
            });
        }
        Some(Token::HX(low)) => {
            if low > 0 {
                xperms.push(Xperm {
                    low,
                    high: low,
                    reset,
                });
            } else {
                xperms.push(Xperm {
                    low: 0x0000,
                    high: 0xFFFF,
                    reset,
                });
            }
        }
        _ => throw!(),
    }
    Ok(xperms)
}

fn match_string<'a>(tokens: &mut Tokens<'a>, pattern: &str) -> ParseResult<'a, ()> {
    if let Some(Token::ID(s)) = tokens.next()
        && s == pattern
    {
        return Ok(());
    }
    Err(ParseError::General)
}

fn extract_token<'a>(s: &'a str, tokens: &mut Vec<Token<'a>>) {
    match s {
        "allow" => tokens.push(Token::AL),
        "deny" => tokens.push(Token::DN),
        "auditallow" => tokens.push(Token::AA),
        "dontaudit" => tokens.push(Token::DA),
        "allowxperm" => tokens.push(Token::AX),
        "auditallowxperm" => tokens.push(Token::AY),
        "dontauditxperm" => tokens.push(Token::DX),
        "permissive" => tokens.push(Token::PM),
        "enforce" => tokens.push(Token::EF),
        "typeattribute" => tokens.push(Token::TA),
        "type" => tokens.push(Token::TY),
        "attribute" => tokens.push(Token::AT),
        "type_transition" => tokens.push(Token::TT),
        "type_change" => tokens.push(Token::TC),
        "type_member" => tokens.push(Token::TM),
        "genfscon" => tokens.push(Token::GF),
        "*" => tokens.push(Token::ST),
        "" => {}
        _ => {
            if let Some(idx) = s.find('{') {
                let (a, b) = s.split_at(idx);
                extract_token(a, tokens);
                tokens.push(Token::LB);
                extract_token(&b[1..], tokens);
            } else if let Some(idx) = s.find('}') {
                let (a, b) = s.split_at(idx);
                extract_token(a, tokens);
                tokens.push(Token::RB);
                extract_token(&b[1..], tokens);
            } else if let Some(idx) = s.find(',') {
                let (a, b) = s.split_at(idx);
                extract_token(a, tokens);
                tokens.push(Token::CM);
                extract_token(&b[1..], tokens);
            } else if let Some(idx) = s.find('-') {
                let (a, b) = s.split_at(idx);
                extract_token(a, tokens);
                tokens.push(Token::HP);
                extract_token(&b[1..], tokens);
            } else if let Some(s) = s.strip_prefix('~') {
                tokens.push(Token::TL);
                extract_token(s, tokens);
            } else if let Some(s) = s.strip_prefix("0x") {
                tokens.push(Token::HX(s.parse().unwrap_or(0)));
            } else {
                tokens.push(Token::ID(s));
            }
        }
    }
}

fn tokenize_statement(statement: &str) -> Vec<Token<'_>> {
    let mut tokens = Vec::new();
    for s in statement.split_whitespace() {
        extract_token(s, &mut tokens);
    }
    tokens
}

impl SePolicy {
    pub fn load_rules(&mut self, rules: &str) {
        let mut cursor = Cursor::new(rules.as_bytes());
        self.load_rules_from_reader(&mut cursor);
    }

    pub fn load_rule_file(&mut self, filename: &Utf8CStr) {
        let result = || -> LoggedResult<()> {
            let file = filename.open(OFlag::O_RDONLY | OFlag::O_CLOEXEC)?;
            let mut reader = BufReader::new(file);
            self.load_rules_from_reader(&mut reader);
            Ok(())
        }();
        result.ok();
    }

    fn load_rules_from_reader<T: BufRead>(&mut self, reader: &mut T) {
        reader.for_each_line(|line| {
            self.parse_statement(line);
            true
        });
    }

    fn parse_statement(&mut self, statement: &str) {
        let statement = statement.trim();
        if statement.is_empty() || statement.starts_with('#') {
            return;
        }
        let mut tokens = tokenize_statement(statement).into_iter().peekable();
        let result = self.exec_statement(&mut tokens);
        if let Err(e) = result {
            warn!("Syntax error in: \"{}\"", statement);
            error!("Hint: {}", e);
        }
    }

    // statement ::= AL sterm(s) sterm(t) sterm(c) sterm(p) { sepolicy.allow(s, t, c, p); };
    // statement ::= DN sterm(s) sterm(t) sterm(c) sterm(p) { sepolicy.deny(s, t, c, p); };
    // statement ::= AA sterm(s) sterm(t) sterm(c) sterm(p) { sepolicy.auditallow(s, t, c, p); };
    // statement ::= DA sterm(s) sterm(t) sterm(c) sterm(p) { sepolicy.dontaudit(s, t, c, p); };
    // statement ::= AX sterm(s) sterm(t) sterm(c) ID(i) xperms(p) { sepolicy.allowxperm(s, t, c, p); };
    // statement ::= AY sterm(s) sterm(t) sterm(c) ID(i) xperms(p) { sepolicy.auditallowxperm(s, t, c, p); };
    // statement ::= DX sterm(s) sterm(t) sterm(c) ID(i) xperms(p) { sepolicy.dontauditxperm(s, t, c, p); };
    // statement ::= PM sterm(t) { sepolicy.permissive(t); };
    // statement ::= EF sterm(t) { sepolicy.enforce(t); };
    // statement ::= TA term(t) term(a) { sepolicy.typeattribute(t, a); };
    // statement ::= TY ID(t) { sepolicy.type_(t, vec![]);};
    // statement ::= TY ID(t) term(a) { sepolicy.type_(t, a);};
    // statement ::= AT ID(t) { sepolicy.attribute(t); };
    // statement ::= TT ID(s) ID(t) ID(c) ID(d) { sepolicy.type_transition(s, t, c, d, vec![]); };
    // statement ::= TT ID(s) ID(t) ID(c) ID(d) ID(o) { sepolicy.type_transition(s, t, c, d, vec![o]); };
    // statement ::= TC ID(s) ID(t) ID(c) ID(d) { sepolicy.type_change(s, t, c, d); };
    // statement ::= TM ID(s) ID(t) ID(c) ID(d) { sepolicy.type_member(s, t, c, d);};
    // statement ::= GF ID(s) ID(t) ID(c) { sepolicy.genfscon(s, t, c); };
    fn exec_statement<'a>(&mut self, tokens: &mut Tokens<'a>) -> ParseResult<'a, ()> {
        let action = match tokens.next() {
            Some(token) => token,
            _ => Err(ParseError::ShowHelp)?,
        };
        let check_additional_args = |tokens: &mut Tokens<'a>| {
            if tokens.peek().is_none() {
                Ok(())
            } else {
                Err(ParseError::General)
            }
        };
        match action {
            Token::AL | Token::DN | Token::AA | Token::DA => {
                let result = || -> ParseResult<()> {
                    let s = parse_sterm(tokens)?;
                    let t = parse_sterm(tokens)?;
                    let c = parse_sterm(tokens)?;
                    let p = parse_sterm(tokens)?;
                    check_additional_args(tokens)?;
                    match action {
                        Token::AL => self.allow(s, t, c, p),
                        Token::DN => self.deny(s, t, c, p),
                        Token::AA => self.auditallow(s, t, c, p),
                        Token::DA => self.dontaudit(s, t, c, p),
                        _ => unreachable!(),
                    }
                    Ok(())
                }();
                if result.is_err() {
                    Err(ParseError::AvtabAv(action))?
                }
            }
            Token::AX | Token::AY | Token::DX => {
                let result = || -> ParseResult<()> {
                    let s = parse_sterm(tokens)?;
                    let t = parse_sterm(tokens)?;
                    let c = parse_sterm(tokens)?;
                    match_string(tokens, "ioctl")?;
                    let p = parse_xperms(tokens)?;
                    check_additional_args(tokens)?;
                    match action {
                        Token::AX => self.allowxperm(s, t, c, p),
                        Token::AY => self.auditallowxperm(s, t, c, p),
                        Token::DX => self.dontauditxperm(s, t, c, p),
                        _ => unreachable!(),
                    }
                    Ok(())
                }();
                if result.is_err() {
                    Err(ParseError::AvtabXperms(action))?
                }
            }
            Token::PM | Token::EF => {
                let result = || -> ParseResult<()> {
                    let t = parse_sterm(tokens)?;
                    check_additional_args(tokens)?;
                    match action {
                        Token::PM => self.permissive(t),
                        Token::EF => self.enforce(t),
                        _ => unreachable!(),
                    }
                    Ok(())
                }();
                if result.is_err() {
                    Err(ParseError::TypeState(action))?
                }
            }
            Token::TA => {
                let result = || -> ParseResult<()> {
                    let t = parse_term(tokens)?;
                    let a = parse_term(tokens)?;
                    check_additional_args(tokens)?;
                    self.typeattribute(t, a);
                    Ok(())
                }();
                if result.is_err() {
                    Err(ParseError::TypeAttr)?
                }
            }
            Token::TY => {
                let result = || -> ParseResult<()> {
                    let t = parse_id(tokens)?;
                    let a = if tokens.peek().is_none() {
                        vec![]
                    } else {
                        parse_term(tokens)?
                    };
                    check_additional_args(tokens)?;
                    self.type_(t, a);
                    Ok(())
                }();
                if result.is_err() {
                    Err(ParseError::NewType)?
                }
            }
            Token::AT => {
                let result = || -> ParseResult<()> {
                    let t = parse_id(tokens)?;
                    check_additional_args(tokens)?;
                    self.attribute(t);
                    Ok(())
                }();
                if result.is_err() {
                    Err(ParseError::NewAttr)?
                }
            }
            Token::TC | Token::TM => {
                let result = || -> ParseResult<()> {
                    let s = parse_id(tokens)?;
                    let t = parse_id(tokens)?;
                    let c = parse_id(tokens)?;
                    let d = parse_id(tokens)?;
                    check_additional_args(tokens)?;
                    match action {
                        Token::TC => self.type_change(s, t, c, d),
                        Token::TM => self.type_member(s, t, c, d),
                        _ => unreachable!(),
                    }
                    Ok(())
                }();
                if result.is_err() {
                    Err(ParseError::AvtabType(action))?
                }
            }
            Token::TT => {
                let result = || -> ParseResult<()> {
                    let s = parse_id(tokens)?;
                    let t = parse_id(tokens)?;
                    let c = parse_id(tokens)?;
                    let d = parse_id(tokens)?;
                    let o = if tokens.peek().is_none() {
                        ""
                    } else {
                        parse_id(tokens)?
                    };
                    check_additional_args(tokens)?;
                    self.type_transition(s, t, c, d, o);
                    Ok(())
                }();
                if result.is_err() {
                    Err(ParseError::TypeTrans)?
                }
            }
            Token::GF => {
                let result = || -> ParseResult<()> {
                    let s = parse_id(tokens)?;
                    let t = parse_id(tokens)?;
                    let c = parse_id(tokens)?;
                    check_additional_args(tokens)?;
                    self.genfscon(s, t, c);
                    Ok(())
                }();
                if result.is_err() {
                    Err(ParseError::GenfsCon)?
                }
            }
            _ => Err(ParseError::UnknownAction(action))?,
        }
        Ok(())
    }
}

// Token to string
impl Display for Token<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Token::AL => f.write_str("allow"),
            Token::DN => f.write_str("deny"),
            Token::AA => f.write_str("auditallow"),
            Token::DA => f.write_str("dontaudit"),
            Token::AX => f.write_str("allowxperm"),
            Token::AY => f.write_str("auditallowxperm"),
            Token::DX => f.write_str("dontauditxperm"),
            Token::PM => f.write_str("permissive"),
            Token::EF => f.write_str("enforce"),
            Token::TA => f.write_str("typeattribute"),
            Token::TY => f.write_str("type"),
            Token::AT => f.write_str("attribute"),
            Token::TT => f.write_str("type_transition"),
            Token::TC => f.write_str("type_change"),
            Token::TM => f.write_str("type_member"),
            Token::GF => f.write_str("genfscon"),
            Token::LB => f.write_char('{'),
            Token::RB => f.write_char('}'),
            Token::CM => f.write_char(','),
            Token::ST => f.write_char('*'),
            Token::TL => f.write_char('~'),
            Token::HP => f.write_char('-'),
            Token::HX(n) => f.write_fmt(format_args!("{n:06X}")),
            Token::ID(s) => f.write_str(s),
        }
    }
}

impl Display for ParseError<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            ParseError::General => Ok(()),
            ParseError::ShowHelp => format_statement_help(f),
            ParseError::AvtabAv(action) => {
                write!(f, "{action} *source_type *target_type *class *perm_set")
            }
            ParseError::AvtabXperms(action) => {
                write!(
                    f,
                    "{action} *source_type *target_type *class operation xperm_set"
                )
            }
            ParseError::AvtabType(action) => {
                write!(f, "{action} source_type target_type class default_type")
            }
            ParseError::TypeState(action) => {
                write!(f, "{action} *type")
            }
            ParseError::TypeAttr => f.write_str("typeattribute ^type ^attribute"),
            ParseError::TypeTrans => f.write_str(
                "type_transition source_type target_type class default_type (object_name)",
            ),
            ParseError::NewType => f.write_str("type type_name ^(attribute)"),
            ParseError::NewAttr => f.write_str("attribute attribute_name"),
            ParseError::GenfsCon => f.write_str("genfscon fs_name partial_path fs_context"),
            ParseError::UnknownAction(action) => write!(f, "Unknown action: \"{action}\""),
        }
    }
}

pub(crate) fn format_statement_help(f: &mut dyn Write) -> std::fmt::Result {
    write!(
        f,
        r#"** Policy statements:

One policy statement should be treated as a single parameter;
this means each policy statement should be enclosed in quotes.
Multiple policy statements can be provided in a single command.

Statements has a format of "<rule_name> [args...]".
Arguments labeled with (^) can accept one or more entries.
Multiple entries consist of a space separated list enclosed in braces ({{}}).
Arguments labeled with (*) are the same as (^), but additionally
support the match-all operator (*).

Example: "allow {{ s1 s2 }} {{ t1 t2 }} class *"
Will be expanded to:

allow s1 t1 class {{ all-permissions-of-class }}
allow s1 t2 class {{ all-permissions-of-class }}
allow s2 t1 class {{ all-permissions-of-class }}
allow s2 t2 class {{ all-permissions-of-class }}

** Extended permissions:

The only supported operation for extended permissions right now is 'ioctl'.
xperm_set is one or multiple hexadecimal numeric values ranging from 0x0000 to 0xFFFF.
Multiple values consist of a space separated list enclosed in braces ({{}}).
Use the complement operator (~) to specify all permissions except those explicitly listed.
Use the range operator (-) to specify all permissions within the low – high range.
Use the match all operator (*) to match all ioctl commands (0x0000-0xFFFF).
The special value 0 is used to clear all rules.

Some examples:
allowxperm source target class ioctl 0x8910
allowxperm source target class ioctl {{ 0x8910-0x8926 0x892A-0x8935 }}
allowxperm source target class ioctl ~{{ 0x8910 0x892A }}
allowxperm source target class ioctl *

** Supported policy statements:

{}
{}
{}
{}
{}
{}
{}
{}
{}
{}
{}
{}
{}
{}
{}
{}
"#,
        ParseError::AvtabAv(Token::AL),
        ParseError::AvtabAv(Token::DN),
        ParseError::AvtabAv(Token::AA),
        ParseError::AvtabAv(Token::DA),
        ParseError::AvtabXperms(Token::AX),
        ParseError::AvtabXperms(Token::AY),
        ParseError::AvtabXperms(Token::DX),
        ParseError::TypeState(Token::PM),
        ParseError::TypeState(Token::EF),
        ParseError::TypeAttr,
        ParseError::NewType,
        ParseError::NewAttr,
        ParseError::TypeTrans,
        ParseError::AvtabType(Token::TC),
        ParseError::AvtabType(Token::TM),
        ParseError::GenfsCon
    )
}

```

`scripts/addon.d.sh`:

```sh
#!/sbin/sh
# ADDOND_VERSION=2
########################################################
#
# Magisk Survival Script for ROMs with addon.d support
# by topjohnwu and osm0sis
#
########################################################

trampoline() {
  mount /data 2>/dev/null
  if [ -f $MAGISKBIN/addon.d.sh ]; then
    exec sh $MAGISKBIN/addon.d.sh "$@"
    exit $?
  elif [ "$1" = post-restore ]; then
    BOOTMODE=false
    ps | grep zygote | grep -v grep >/dev/null && BOOTMODE=true
    $BOOTMODE || ps -A 2>/dev/null | grep zygote | grep -v grep >/dev/null && BOOTMODE=true

    if ! $BOOTMODE; then
      # update-binary|updater <RECOVERY_API_VERSION> <OUTFD> <ZIPFILE>
      OUTFD=$(ps | grep -v 'grep' | grep -oE 'update(.*) 3 [0-9]+' | cut -d" " -f3)
      [ -z $OUTFD ] && OUTFD=$(ps -Af | grep -v 'grep' | grep -oE 'update(.*) 3 [0-9]+' | cut -d" " -f3)
      # update_engine_sideload --payload=file://<ZIPFILE> --offset=<OFFSET> --headers=<HEADERS> --status_fd=<OUTFD>
      [ -z $OUTFD ] && OUTFD=$(ps | grep -v 'grep' | grep -oE 'status_fd=[0-9]+' | cut -d= -f2)
      [ -z $OUTFD ] && OUTFD=$(ps -Af | grep -v 'grep' | grep -oE 'status_fd=[0-9]+' | cut -d= -f2)
    fi
    ui_print() {
      if $BOOTMODE; then
        log -t Magisk -- "$1"
      else
        echo -e "ui_print $1\nui_print" >> /proc/self/fd/$OUTFD
      fi
    }

    ui_print "***********************"
    ui_print " Magisk addon.d failed"
    ui_print "***********************"
    ui_print "! Cannot find Magisk binaries - was data wiped or not decrypted?"
    ui_print "! Reflash OTA from decrypted recovery or reflash Magisk"
  fi
  exit 1
}

# Always use the script in /data
MAGISKBIN=/data/adb/magisk
[ "$0" = $MAGISKBIN/addon.d.sh ] || trampoline "$@"

V1_FUNCS=/tmp/backuptool.functions
V2_FUNCS=/postinstall/tmp/backuptool.functions

if [ -f $V1_FUNCS ]; then
  . $V1_FUNCS
  backuptool_ab=false
elif [ -f $V2_FUNCS ]; then
  . $V2_FUNCS
else
  return 1
fi

initialize() {
  # Load utility functions
  . $MAGISKBIN/util_functions.sh

  if $BOOTMODE; then
    # Override ui_print when booted
    ui_print() { log -t Magisk -- "$1"; }
  fi
  OUTFD=
  setup_flashable
}

main() {
  if ! $backuptool_ab; then
    # Restore PREINITDEVICE from previous A-only partition
    if [ -f config.orig ]; then
      PREINITDEVICE=$(grep_prop PREINITDEVICE config.orig)
      rm config.orig
    fi

    # Wait for post addon.d-v1 processes to finish
    sleep 5
  fi

  # Ensure we aren't in /tmp/addon.d anymore (since it's been deleted by addon.d)
  mkdir -p $TMPDIR
  cd $TMPDIR

  if echo $MAGISK_VER | grep -q '\.'; then
    PRETTY_VER=$MAGISK_VER
  else
    PRETTY_VER="$MAGISK_VER($MAGISK_VER_CODE)"
  fi
  print_title "Magisk $PRETTY_VER addon.d"

  mount_partitions
  check_data
  get_flags

  if $backuptool_ab; then
    # Swap the slot for addon.d-v2
    if [ ! -z $SLOT ]; then
      case $SLOT in
        _a) SLOT=_b;;
        _b) SLOT=_a;;
      esac
    fi
  fi

  find_boot_image
  [ -z $BOOTIMAGE ] && abort "! Unable to detect target image"
  ui_print "- Target image: $BOOTIMAGE"

  api_level_arch_detect
  ui_print "- Device platform: $ABI"

  remove_system_su
  install_magisk

  # Cleanups
  cd /
  $BOOTMODE || recovery_cleanup
  rm -rf $TMPDIR

  ui_print "- Done"
  exit 0
}

case "$1" in
  backup)
    # Stub
  ;;
  restore)
    # Stub
  ;;
  pre-backup)
    # Back up PREINITDEVICE from existing partition before OTA on A-only devices
    if ! $backuptool_ab; then
      initialize
      # Suppress ui_print for this stage
      ui_print() { return; }
      get_flags
      find_boot_image
      $MAGISKBIN/magiskboot unpack "$BOOTIMAGE"
      $MAGISKBIN/magiskboot cpio ramdisk.cpio "extract .backup/.magisk config.orig"
      $MAGISKBIN/magiskboot cleanup
    fi
  ;;
  post-backup)
    # Stub
  ;;
  pre-restore)
    # Stub
  ;;
  post-restore)
    initialize
    if $backuptool_ab; then
      su=sh
      $BOOTMODE && su=su
      exec $su -c "sh $0 addond-v2"
    else
      # Run in background, hack for addon.d-v1
      (main) &
    fi
  ;;
  addond-v2)
    initialize
    main
  ;;
esac

```

`scripts/app_functions.sh`:

```sh
##################################
# Magisk app internal scripts
##################################

# $1 = delay
# $2 = command
run_delay() {
  (sleep $1; $2)&
}

# $1 = version string
# $2 = version code
env_check() {
  for file in busybox magiskboot magiskinit util_functions.sh boot_patch.sh; do
    [ -f "$MAGISKBIN/$file" ] || return 1
  done
  if [ "$2" -ge 25000 ]; then
    [ -f "$MAGISKBIN/magiskpolicy" ] || return 1
  fi
  if [ "$2" -ge 25210 ]; then
    [ -b "$MAGISKTMP/.magisk/device/preinit" ] || [ -b "$MAGISKTMP/.magisk/block/preinit" ] || return 2
  fi
  grep -xqF "MAGISK_VER='$1'" "$MAGISKBIN/util_functions.sh" || return 3
  grep -xqF "MAGISK_VER_CODE=$2" "$MAGISKBIN/util_functions.sh" || return 3
  return 0
}

# $1 = dir to copy
# $2 = destination (optional)
cp_readlink() {
  if [ -z $2 ]; then
    cd $1
  else
    cp -af $1/. $2
    cd $2
  fi
  for file in *; do
    if [ -L $file ]; then
      local full=$(readlink -f $file)
      rm $file
      cp -af $full $file
    fi
  done
  chmod -R 755 .
  cd /
}

# $1 = install dir
fix_env() {
  # Cleanup and make dirs
  rm -rf $MAGISKBIN/*
  mkdir -p $MAGISKBIN 2>/dev/null
  chmod 700 /data/adb
  cp_readlink $1 $MAGISKBIN
  rm -rf $1
  chown -R 0:0 $MAGISKBIN
}

# $1 = install dir
# $2 = boot partition
direct_install() {
  echo "- Flashing new boot image"
  flash_image $1/new-boot.img $2
  case $? in
    1)
      echo "! Insufficient partition size"
      return 1
      ;;
    2)
      echo "! $2 is read only"
      return 2
      ;;
  esac

  rm -f $1/new-boot.img
  fix_env $1
  run_migrations

  return 0
}

# $1 = uninstaller zip
run_uninstaller() {
  rm -rf /dev/tmp
  mkdir -p /dev/tmp/install
  unzip -o "$1" "assets/*" "lib/*" -d /dev/tmp/install
  INSTALLER=/dev/tmp/install sh /dev/tmp/install/assets/uninstaller.sh dummy 1 "$1"
}

# $1 = boot partition
restore_imgs() {
  local SHA1=$(grep_prop SHA1 $MAGISKTMP/.magisk/config)
  local BACKUPDIR=/data/magisk_backup_$SHA1
  [ -d $BACKUPDIR ] || return 1
  [ -f $BACKUPDIR/boot.img.gz ] || return 1
  flash_image $BACKUPDIR/boot.img.gz $1
}

# $1 = path to bootctl executable
post_ota() {
  cd /data/adb
  cp -f $1 bootctl
  rm -f $1
  chmod 755 bootctl
  if ! ./bootctl hal-info; then
    rm -f bootctl
    return
  fi
  SLOT_NUM=0
  [ $(./bootctl get-current-slot) -eq 0 ] && SLOT_NUM=1
  ./bootctl set-active-boot-slot $SLOT_NUM
  cat << EOF > post-fs-data.d/post_ota.sh
/data/adb/bootctl mark-boot-successful
rm -f /data/adb/bootctl
rm -f /data/adb/post-fs-data.d/post_ota.sh
EOF
  chmod 755 post-fs-data.d/post_ota.sh
  cd /
}

# $1 = APK
# $2 = package name
adb_pm_install() {
  local tmp=/data/local/tmp/temp.apk
  cp -f "$1" $tmp
  chmod 644 $tmp
  su 2000 -c pm install -g $tmp || pm install -g $tmp || su 1000 -c pm install -g $tmp
  local res=$?
  rm -f $tmp
  if [ $res = 0 ]; then
    appops set "$2" REQUEST_INSTALL_PACKAGES allow
  fi
  return $res
}

check_boot_ramdisk() {
  # Create boolean ISAB
  ISAB=true
  [ -z $SLOT ] && ISAB=false

  # If we are A/B, then we must have ramdisk
  $ISAB && return 0

  # If we are using legacy SAR, but not A/B, assume we do not have ramdisk
  if $LEGACYSAR; then
    # Override recovery mode to true
    RECOVERYMODE=true
    return 1
  fi

  return 0
}

check_encryption() {
  if $ISENCRYPTED; then
    if [ $SDK_INT -lt 24 ]; then
      CRYPTOTYPE="block"
    else
      # First see what the system tells us
      CRYPTOTYPE=$(getprop ro.crypto.type)
      if [ -z $CRYPTOTYPE ]; then
        # If not mounting through device mapper, we are FBE
        if grep ' /data ' /proc/mounts | grep -qv 'dm-'; then
          CRYPTOTYPE="file"
        else
          # We are either FDE or metadata encryption (which is also FBE)
          CRYPTOTYPE="block"
          grep -q ' /metadata ' /proc/mounts && CRYPTOTYPE="file"
        fi
      fi
    fi
  else
    CRYPTOTYPE="N/A"
  fi
}

printvar() {
  eval echo $1=\$$1
}

run_action() {
  local MODID="$1"
  cd "/data/adb/modules/$MODID"
  sh ./action.sh
  local RES=$?
  cd /
  return $RES
}

##########################
# Non-root util_functions
##########################

mount_partitions() {
  [ "$(getprop ro.build.ab_update)" = "true" ] && SLOT=$(getprop ro.boot.slot_suffix)
  # Check whether non rootfs root dir exists
  SYSTEM_AS_ROOT=false
  grep ' / ' /proc/mounts | grep -qv 'rootfs' && SYSTEM_AS_ROOT=true

  LEGACYSAR=false
  grep ' / ' /proc/mounts | grep -q '/dev/root' && LEGACYSAR=true
}

get_flags() {
  KEEPVERITY=$SYSTEM_AS_ROOT
  ISENCRYPTED=false
  [ "$(getprop ro.crypto.state)" = "encrypted" ] && ISENCRYPTED=true
  KEEPFORCEENCRYPT=$ISENCRYPTED
  if [ -n "$(getprop ro.boot.vbmeta.device)" -o -n "$(getprop ro.boot.vbmeta.size)" ]; then
    PATCHVBMETAFLAG=false
  elif getprop ro.product.ab_ota_partitions | grep -wq vbmeta; then
    PATCHVBMETAFLAG=false
  else
    PATCHVBMETAFLAG=true
  fi
  [ -z $RECOVERYMODE ] && RECOVERYMODE=false
  [ -z $VENDORBOOT ] && VENDORBOOT=false
}

run_migrations() { return; }

grep_prop() { return; }

#############
# Initialize
#############

app_init() {
  mount_partitions >/dev/null
  RAMDISKEXIST=false
  check_boot_ramdisk && RAMDISKEXIST=true
  get_flags >/dev/null
  run_migrations >/dev/null
  check_encryption

  # Dump variables
  printvar SLOT
  printvar SYSTEM_AS_ROOT
  printvar RAMDISKEXIST
  printvar ISAB
  printvar CRYPTOTYPE
  printvar PATCHVBMETAFLAG
  printvar LEGACYSAR
  printvar RECOVERYMODE
  printvar KEEPVERITY
  printvar KEEPFORCEENCRYPT
  printvar VENDORBOOT
}

export BOOTMODE=true

```

`scripts/avd.sh`:

```sh
#!/usr/bin/env bash

set -e
shopt -s extglob
. scripts/test_common.sh

emu_args_base="-no-window -no-audio -no-boot-anim -gpu swiftshader_indirect -read-only -no-snapshot -cores $core_count"
log_args="-show-kernel -logcat '' -logcat-output logcat.log"
emu_args=
emu_pid=

atd_min_api=30
atd_max_api=36
huge_ram_min_api=26

case $(uname -m) in
  'arm64'|'aarch64')
    if [ -n "$FORCE_32_BIT" ]; then
      echo "! ARM32 is not supported"
      exit 1
    fi
    arch=arm64-v8a
    ;;
  *)
    if [ -n "$FORCE_32_BIT" ]; then
      arch=x86
    else
      arch=x86_64
    fi

    ;;
esac

cleanup() {
  rm -f magisk_*.img
  "$avd" delete avd -n test
}

test_error() {
  trap - EXIT
  print_error "! An error occurred"
  pkill -INT -P $$
  wait
  cleanup
  exit 1
}

wait_for_boot() {
  set -e
  adb wait-for-device
  while true; do
    local result="$(adb exec-out getprop sys.boot_completed)"
    if [ $? -ne 0 ]; then
      exit 1
    elif [ "$result" = "1" ]; then
      break
    fi
    sleep 2
  done
}

wait_emu() {
  local which_pid

  timeout $boot_timeout bash -c wait_for_boot &
  local wait_pid=$!

  # Handle the case when emulator dies earlier than timeout
  wait -p which_pid -n $emu_pid $wait_pid
  [ $which_pid -eq $wait_pid ]
}

dump_vars() {
  local val
  for name in $@ emu_args; do
    eval val=\$$name
    echo $name=\"$val\"\;
  done
}

resolve_vars() {
  set +x
  local arg_list="$1"
  local ver=$2
  local type=$3

  # Determine API level
  local api
  case $ver in
    +([0-9\.])) api=$ver ;;
    TiramisuPrivacySandbox) api=33 ;;
    UpsideDownCakePrivacySandbox) api=34 ;;
    VanillaIceCream) api=35 ;;
    Baklava) api=36 ;;
    CinnamonBun) api=37 ;;
    *CANARY) api=10000 ;;
    *)
      print_error "! Unknown system image version '$ver'"
      exit 1
      ;;
  esac

  # Determine default image type
  if [ -z $type ]; then
    if [ $(bc <<< "$api >= $atd_min_api && $api <= $atd_max_api") = 1 ]; then
      # Use the lightweight ATD images if possible
      type='aosp_atd'
    elif [ $(bc <<< "$api > $atd_max_api") = 1 ]; then
      # Preview/beta release, no AOSP version available
      type='google_apis'
    else
      type='default'
    fi
  fi

  # Old Linux kernels will not boot with memory larger than 3GB
  local memory
  if [ $(bc <<< "$api < $huge_ram_min_api") = 1 ]; then
    memory=3072
  else
    memory=8192
  fi

  emu_args="$emu_args_base -memory $memory"

  # System image variable and paths
  local avd_pkg="system-images;android-$ver;$type;$arch"
  local sys_img_dir="$ANDROID_HOME/system-images/android-$ver/$type/$arch"
  local ramdisk="$sys_img_dir/ramdisk.img"

  # Dump variables to output
  dump_vars $arg_list
}

dl_emu() {
  local avd_pkg=$1
  yes | "$sdk" --licenses > /dev/null 2>&1
  "$sdk" --channel=3 platform-tools emulator $avd_pkg
}

setup_emu() {
  local avd_pkg=$1
  local ver=$2
  dl_emu $avd_pkg
  echo no | "$avd" create avd -f -n test -k $avd_pkg

  # avdmanager is outdated, it might not set the proper target
  local ini=$ANDROID_AVD_HOME/test.ini
  sed "s:^target\s*=.*:target=android-$ver:g" $ini > $ini.new
  mv $ini.new $ini
}

test_emu() {
  local variant=$1

  local magisk_args="-ramdisk magisk_${variant}.img -feature -SystemAsRoot"

  if [ -n "$AVD_TEST_LOG" ]; then
    rm -f logcat.log
    "$emu" @test $emu_args $log_args $magisk_args > kernel.log 2>&1 &
  else
    "$emu" @test $emu_args $magisk_args > /dev/null 2>&1 &
  fi

  emu_pid=$!
  wait_emu

  run_setup $variant

  adb reboot
  wait_emu

  run_tests

  kill -INT $emu_pid
  wait $emu_pid
}

test_main() {
  local ver avd_pkg ramdisk
  eval $(resolve_vars "ver avd_pkg ramdisk" $1 $2)

  # Specify an explicit port so that tests can run with other emulators running at the same time
  local emu_port=5682
  emu_args="$emu_args -port $emu_port"
  export ANDROID_SERIAL="emulator-$emu_port"

  setup_emu "$avd_pkg" $ver

  # Restart ADB daemon just in case
  adb kill-server
  adb start-server

  # Launch stock emulator
  print_title "* Launching $avd_pkg"
  "$emu" @test $emu_args >/dev/null 2>&1 &
  emu_pid=$!
  wait_emu

  # Patch images
  if [ -z "$AVD_TEST_SKIP_DEBUG" ]; then
    ./build.py -v avd_patch "$ramdisk" magisk_debug.img
  fi
  if [ -z "$AVD_TEST_SKIP_RELEASE" ]; then
    ./build.py -vr avd_patch "$ramdisk" magisk_release.img
  fi

  kill -INT $emu_pid
  wait $emu_pid

  if [ -z "$AVD_TEST_SKIP_DEBUG" ]; then
    print_title "* Testing $avd_pkg (debug)"
    test_emu debug
  fi

  if [ -z "$AVD_TEST_SKIP_RELEASE" ]; then
    print_title "* Testing $avd_pkg (release)"
    test_emu release
  fi

  cleanup
}

run_main() {
  local ver avd_pkg
  eval $(resolve_vars "ver avd_pkg" $1 $2)
  setup_emu "$avd_pkg" $ver
  print_title "* Launching $avd_pkg"
  "$emu" @test $emu_args 2>/dev/null
  cleanup
}

dl_main() {
  local avd_pkg
  eval $(resolve_vars "avd_pkg" $1 $2)
  print_title "* Downloading $avd_pkg"
  dl_emu "$avd_pkg"
}

case "$1" in
  test )
    shift
    trap test_error EXIT
    export -f wait_for_boot
    set -x
    test_main "$@"
    ;;
  run )
    shift
    trap cleanup EXIT
    run_main "$@"
    ;;
  dl )
    shift
    dl_main "$@"
    ;;
  * )
    print_error "Unknown argument '$1'"
    exit 1
    ;;
esac

# Exit normally, don't run through cleanup again
trap - EXIT

```

`scripts/boot_patch.sh`:

```sh
#!/system/bin/sh
#######################################################################################
# Magisk Boot Image Patcher
#######################################################################################
#
# Usage: boot_patch.sh <bootimage>
#
# The following environment variables can configure the installation:
# KEEPVERITY, KEEPFORCEENCRYPT, PATCHVBMETAFLAG, RECOVERYMODE, LEGACYSAR
#
# This script should be placed in a directory with the following files:
#
# File name          Type      Description
#
# boot_patch.sh      script    A script to patch boot image for Magisk.
#                  (this file) The script will use files in its same
#                              directory to complete the patching process.
# util_functions.sh  script    A script which hosts all functions required
#                              for this script to work properly.
# magiskinit         binary    The binary to replace /init.
# magisk             binary    The magisk binary.
# magiskboot         binary    A tool to manipulate boot images.
# init-ld            binary    The library that will be LD_PRELOAD of /init
# stub.apk           binary    The stub Magisk app to embed into ramdisk.
# chromeos           folder    This folder includes the utility and keys to sign
#                  (optional)  chromeos boot images. Only used for Pixel C.
#
#######################################################################################

############
# Functions
############

# Pure bash dirname implementation
getdir() {
  case "$1" in
    */*)
      dir=${1%/*}
      if [ -z $dir ]; then
        echo "/"
      else
        echo $dir
      fi
    ;;
    *) echo "." ;;
  esac
}

#################
# Initialization
#################

if [ -z $SOURCEDMODE ]; then
  # Switch to the location of the script file
  cd "$(getdir "${BASH_SOURCE:-$0}")"
  # Load utility functions
  . ./util_functions.sh
  # Check if 64-bit
  api_level_arch_detect
fi

BOOTIMAGE="$1"
[ -e "$BOOTIMAGE" ] || abort "$BOOTIMAGE does not exist!"

# Dump image for MTD/NAND character device boot partitions
if [ -c "$BOOTIMAGE" ]; then
  nanddump -f boot.img "$BOOTIMAGE"
  BOOTNAND="$BOOTIMAGE"
  BOOTIMAGE=boot.img
fi

# Flags
[ -z $KEEPVERITY ] && KEEPVERITY=false
[ -z $KEEPFORCEENCRYPT ] && KEEPFORCEENCRYPT=false
[ -z $PATCHVBMETAFLAG ] && PATCHVBMETAFLAG=false
[ -z $RECOVERYMODE ] && RECOVERYMODE=false
[ -z $LEGACYSAR ] && LEGACYSAR=false
export KEEPVERITY
export KEEPFORCEENCRYPT
export PATCHVBMETAFLAG

chmod -R 755 .

#########
# Unpack
#########

CHROMEOS=false
VENDORBOOT=false

ui_print "- Unpacking boot image"
./magiskboot unpack "$BOOTIMAGE"

case $? in
  0 ) ;;
  2 )
    ui_print "- ChromeOS boot image detected"
    CHROMEOS=true
    ;;
  3 )
    ui_print "- Vendor boot image detected"
    VENDORBOOT=true
    ;;
  * )
    abort "! Unable to unpack boot image"
    ;;
esac

#################
# Ramdisk Checks
#################

unset RAMDISK
for path in ramdisk.cpio vendor_ramdisk/init_boot.cpio vendor_ramdisk/ramdisk.cpio; do
  if [ -e $path ]; then
    RAMDISK=$path
    break
  fi
done

ui_print "- Checking ramdisk status"
if [ -n "$RAMDISK" ]; then
  ./magiskboot cpio $RAMDISK test
  STATUS=$?
  SKIP_BACKUP=""
else
  # No ramdisk found, create one from scratch
  RAMDISK=ramdisk.cpio
  # Could be stock A only legacy SAR, or some Android 13 GKIs
  STATUS=0
  SKIP_BACKUP="#"
fi

case $STATUS in
  0 )
    # Stock boot
    ui_print "- Stock boot image detected"
    SHA1=$(./magiskboot sha1 "$BOOTIMAGE" 2>/dev/null)
    cat $BOOTIMAGE > stock_boot.img
    cp -af $RAMDISK ramdisk.cpio.orig 2>/dev/null
    ;;
  1 )
    # Magisk patched
    ui_print "- Magisk patched boot image detected"
    ./magiskboot cpio $RAMDISK \
    "extract .backup/.magisk config.orig" \
    "restore"
    cp -af $RAMDISK ramdisk.cpio.orig
    rm -f stock_boot.img
    ;;
  2 )
    # Unsupported
    ui_print "! Boot image patched by unsupported programs"
    abort "! Please restore back to stock boot image"
    ;;
esac

if [ -f config.orig ]; then
  # Read existing configs
  chmod 0644 config.orig
  SHA1=$(grep_prop SHA1 config.orig)
  if ! $BOOTMODE; then
    # Do not inherit config if not in recovery
    PREINITDEVICE=$(grep_prop PREINITDEVICE config.orig)
  fi
  rm config.orig
fi

##################
# Ramdisk Patches
##################

ui_print "- Patching ramdisk"

$BOOTMODE && [ -z "$PREINITDEVICE" ] && PREINITDEVICE=$(./magisk --preinit-device)

# Compress to save precious ramdisk space
./magiskboot compress=xz magisk magisk.xz
./magiskboot compress=xz stub.apk stub.xz
./magiskboot compress=xz init-ld init-ld.xz

echo "KEEPVERITY=$KEEPVERITY" > config
echo "KEEPFORCEENCRYPT=$KEEPFORCEENCRYPT" >> config
echo "RECOVERYMODE=$RECOVERYMODE" >> config
echo "VENDORBOOT=$VENDORBOOT" >> config
if [ -n "$PREINITDEVICE" ]; then
  ui_print "- Pre-init storage partition: $PREINITDEVICE"
  echo "PREINITDEVICE=$PREINITDEVICE" >> config
fi
[ -n "$SHA1" ] && echo "SHA1=$SHA1" >> config

./magiskboot cpio $RAMDISK \
"add 0750 init magiskinit" \
"mkdir 0750 overlay.d" \
"mkdir 0750 overlay.d/sbin" \
"add 0644 overlay.d/sbin/magisk.xz magisk.xz" \
"add 0644 overlay.d/sbin/stub.xz stub.xz" \
"add 0644 overlay.d/sbin/init-ld.xz init-ld.xz" \
"patch" \
"$SKIP_BACKUP backup ramdisk.cpio.orig" \
"mkdir 000 .backup" \
"add 000 .backup/.magisk config" \
|| abort "! Unable to patch ramdisk"

rm -f ramdisk.cpio.orig config *.xz

#################
# Binary Patches
#################

for dt in dtb kernel_dtb extra; do
  if [ -f $dt ]; then
    if ! ./magiskboot dtb $dt test; then
      ui_print "! Boot image $dt was patched by old (unsupported) Magisk"
      abort "! Please try again with *unpatched* boot image"
    fi
    if ./magiskboot dtb $dt patch; then
      ui_print "- Patch fstab in boot image $dt"
    fi
  fi
done

if [ -f kernel ]; then
  PATCHEDKERNEL=false
  # Remove Samsung RKP
  ./magiskboot hexpatch kernel \
  49010054011440B93FA00F71E9000054010840B93FA00F7189000054001840B91FA00F7188010054 \
  A1020054011440B93FA00F7140020054010840B93FA00F71E0010054001840B91FA00F7181010054 \
  && PATCHEDKERNEL=true

  # Remove Samsung defex
  # Before: [mov w2, #-221]   (-__NR_execve)
  # After:  [mov w2, #-32768]
  ./magiskboot hexpatch kernel 821B8012 E2FF8F12 && PATCHEDKERNEL=true

  # Disable Samsung PROCA
  # proca_config -> proca_magisk
  ./magiskboot hexpatch kernel \
  70726F63615F636F6E66696700 \
  70726F63615F6D616769736B00 \
  && PATCHEDKERNEL=true

  # Force kernel to load rootfs for legacy SAR devices
  # skip_initramfs -> want_initramfs
  $LEGACYSAR && ./magiskboot hexpatch kernel \
  736B69705F696E697472616D667300 \
  77616E745F696E697472616D667300 \
  && PATCHEDKERNEL=true

  # If the kernel doesn't need to be patched at all,
  # keep raw kernel to avoid bootloops on some weird devices
  $PATCHEDKERNEL || rm -f kernel
fi

#################
# Repack & Flash
#################

ui_print "- Repacking boot image"
./magiskboot repack "$BOOTIMAGE" || abort "! Unable to repack boot image"

# Sign chromeos boot
$CHROMEOS && sign_chromeos

# Restore the original boot partition path
[ -e "$BOOTNAND" ] && BOOTIMAGE="$BOOTNAND"

# Reset any error code
true

```

`scripts/cuttlefish.sh`:

```sh
#!/usr/bin/env bash

set -xe
. scripts/test_common.sh

cvd_args="-daemon -enable_sandbox=false -memory_mb=8192 -report_anonymous_usage_stats=n -cpus=$core_count"
magisk_args='-init_boot_image=magisk_patched.img'

cleanup() {
  print_error "! An error occurred"
  run_cvd_bin stop_cvd || true
  rm -f magisk_patched.img*
}

run_cvd_bin() {
  local exe=$1
  shift
  HOME=$CF_HOME $CF_HOME/bin/$exe "$@"
}

setup_env() {
  curl -LO https://github.com/topjohnwu/magisk-files/releases/download/files/cuttlefish-base_1.2.0_amd64.deb
  sudo apt-get update
  sudo dpkg -i ./cuttlefish-base_*_*64.deb || sudo apt-get install -f
  rm cuttlefish-base_*_*64.deb
  sudo usermod -aG kvm,cvdnetwork,render $USER
  yes | "$sdk" --licenses > /dev/null
  "$sdk" --channel=3 platform-tools
  adb kill-server
  adb start-server
}

download_cf() {
  local branch=$1
  local device=$2

  if [ -z $branch ]; then
    branch='aosp-android-latest-release'
  fi
  if [ -z $device ]; then
    device='aosp_cf_x86_64_only_phone'
  fi
  local target="${device}-userdebug"

  local build_id=$(curl -sL https://ci.android.com/builds/branches/${branch}/status.json | \
    jq -r ".targets[] | select(.name == \"$target\") | .last_known_good_build")
  local sys_img_url="https://ci.android.com/builds/submitted/${build_id}/${target}/latest/raw/${device}-img-${build_id}.zip"
  local host_pkg_url="https://ci.android.com/builds/submitted/${build_id}/${target}/latest/raw/cvd-host_package.tar.gz"

  print_title "* Download $target ($build_id) images"
  curl -L $sys_img_url -o aosp_cf_phone-img.zip
  curl -LO $host_pkg_url
  rm -rf $CF_HOME
  mkdir -p $CF_HOME
  tar xvf cvd-host_package.tar.gz -C $CF_HOME
  unzip aosp_cf_phone-img.zip -d $CF_HOME
  rm -f cvd-host_package.tar.gz aosp_cf_phone-img.zip
}

test_cf() {
  local variant=$1

  run_cvd_bin stop_cvd || true

  print_title "* Testing $variant builds"
  timeout $boot_timeout bash -c "run_cvd_bin launch_cvd $cvd_args $magisk_args -resume=false"
  adb wait-for-device
  run_setup $variant

  adb reboot
  sleep 5
  run_cvd_bin stop_cvd || true

  timeout $boot_timeout bash -c "run_cvd_bin launch_cvd $cvd_args $magisk_args"
  adb wait-for-device
  run_tests
}

test_main() {
  # Launch stock cuttlefish
  run_cvd_bin launch_cvd $cvd_args -resume=false
  adb wait-for-device

  # Patch and test debug build
  ./build.py -v avd_patch "$CF_HOME/init_boot.img" magisk_patched.img
  test_cf debug

  # Patch and test release build
  ./build.py -vr avd_patch "$CF_HOME/init_boot.img" magisk_patched.img
  test_cf release

  # Cleanup
  run_cvd_bin stop_cvd || true
  rm -f magisk_patched.img*
}

if [ -z $CF_HOME ]; then
  print_error "! Environment variable CF_HOME is required"
  exit 1
fi

case "$1" in
  setup )
    setup_env
    ;;
  download )
    download_cf $2 $3
    ;;
  test )
    trap cleanup EXIT
    export -f run_cvd_bin
    test_main
    trap - EXIT
    ;;
  * )
    exit 1
    ;;
esac

```

`scripts/flash_script.sh`:

```sh
#MAGISK
############################################
# Magisk Flash Script (updater-script)
############################################

##############
# Preparation
##############

# Default permissions
umask 022

OUTFD=$2
COMMONDIR=$INSTALLER/assets
CHROMEDIR=$INSTALLER/assets/chromeos

if [ ! -f $COMMONDIR/util_functions.sh ]; then
  echo "! Unable to extract zip file!"
  exit 1
fi

# Load utility functions
. $COMMONDIR/util_functions.sh

setup_flashable

############
# Detection
############

if echo $MAGISK_VER | grep -q '\.'; then
  PRETTY_VER=$MAGISK_VER
else
  PRETTY_VER="$MAGISK_VER($MAGISK_VER_CODE)"
fi
print_title "Magisk $PRETTY_VER Installer"

is_mounted /data || mount /data || is_mounted /cache || mount /cache
mount_partitions
check_data
get_flags
find_boot_image

[ -z $BOOTIMAGE ] && abort "! Unable to detect target image"
ui_print "- Target image: $BOOTIMAGE"

# Detect version and architecture
api_level_arch_detect

[ $API -lt 23 ] && abort "! Magisk only support Android 6.0 and above"

ui_print "- Device platform: $ABI"

BINDIR=$INSTALLER/lib/$ABI
cd $BINDIR
for file in lib*.so; do mv "$file" "${file:3:${#file}-6}"; done
cd /
cp -af $INSTALLER/lib/$ABI32/libmagisk.so $BINDIR/magisk32 2>/dev/null

# Check if system root is installed and remove
$BOOTMODE || remove_system_su

##############
# Environment
##############

ui_print "- Constructing environment"

# Copy required files
rm -rf $MAGISKBIN 2>/dev/null
mkdir -p $MAGISKBIN 2>/dev/null
cp -af $BINDIR/. $COMMONDIR/. $BBBIN $MAGISKBIN

# Remove files only used by the Magisk app
rm -f $MAGISKBIN/bootctl $MAGISKBIN/main.jar \
  $MAGISKBIN/module_installer.sh $MAGISKBIN/uninstaller.sh

chmod -R 755 $MAGISKBIN

# addon.d
if [ -d /system/addon.d ]; then
  ui_print "- Adding addon.d survival script"
  blockdev --setrw /dev/block/mapper/system$SLOT 2>/dev/null
  mount -o rw,remount /system || mount -o rw,remount /
  ADDOND=/system/addon.d/99-magisk.sh
  cp -af $COMMONDIR/addon.d.sh $ADDOND
  chmod 755 $ADDOND
fi

##################
# Image Patching
##################

install_magisk

# Cleanups
$BOOTMODE || recovery_cleanup
rm -rf $TMPDIR

ui_print "- Done"
exit 0

```

`scripts/host_patch.sh`:

```sh
#####################################################################
#   AVD MagiskInit Setup
#####################################################################
#
# Support API level: 23 - 36
#
# With an emulator booted and accessible via ADB, usage:
# ./build.py avd_patch path/to/booted/avd-image/ramdisk.img
#
# The purpose of this script is to patch AVD ramdisk.img and do a
# full integration test of magiskinit under several circumstances.
# After patching ramdisk.img, close the emulator, then select
# "Cold Boot Now" in AVD Manager to force a full reboot.
#
#####################################################################
# AVD Init Configurations:
#
# rootfs w/o early mount: API 23 - 25
# rootfs with early mount: API 26 - 27
# Legacy system-as-root: API 28
# 2 stage init: API 29 - 35
#####################################################################

if [ ! -f /system/build.prop ]; then
  # Running on PC
  echo 'Please run `./build.py avd_patch` instead of directly executing the script!'
  exit 1
fi

cd /data/local/tmp
chmod 755 busybox

if [ -z "$FIRST_STAGE" ]; then
  export FIRST_STAGE=1
  export ASH_STANDALONE=1
  # Re-exec script with busybox
  exec ./busybox sh $0 "$@"
fi

TARGET_FILE="$1"
OUTPUT_FILE="$1.magisk"

if echo "$TARGET_FILE" | grep -q 'ramdisk'; then
  IS_RAMDISK=true
else
  IS_RAMDISK=false
fi

# Extract files from APK
unzip -oj magisk.apk 'assets/util_functions.sh' 'assets/stub.apk'
. ./util_functions.sh

api_level_arch_detect

unzip -oj magisk.apk "lib/$ABI/*" -x "lib/$ABI/libbusybox.so"
for file in lib*.so; do
  chmod 755 $file
  mv "$file" "${file:3:${#file}-6}"
done

if $IS_RAMDISK; then
  ./magiskboot decompress "$TARGET_FILE" ramdisk.cpio
else
  ./magiskboot unpack "$TARGET_FILE"
fi
cp ramdisk.cpio ramdisk.cpio.orig

export KEEPVERITY=true
export KEEPFORCEENCRYPT=true

echo "KEEPVERITY=$KEEPVERITY" > config
echo "KEEPFORCEENCRYPT=$KEEPFORCEENCRYPT" >> config
echo "PREINITDEVICE=$(./magisk --preinit-device)" >> config
# For API 28, we also manually disable SystemAsRoot
# Explicitly override skip_initramfs by setting RECOVERYMODE=true
[ $API = "28" ] && echo 'RECOVERYMODE=true' >> config
cat config

./magiskboot compress=xz magisk magisk.xz
./magiskboot compress=xz stub.apk stub.xz
./magiskboot compress=xz init-ld init-ld.xz

./magiskboot cpio ramdisk.cpio \
"add 0750 init magiskinit" \
"mkdir 0750 overlay.d" \
"mkdir 0750 overlay.d/sbin" \
"add 0644 overlay.d/sbin/magisk.xz magisk.xz" \
"add 0644 overlay.d/sbin/stub.xz stub.xz" \
"add 0644 overlay.d/sbin/init-ld.xz init-ld.xz" \
"patch" \
"backup ramdisk.cpio.orig" \
"mkdir 000 .backup" \
"add 000 .backup/.magisk config"

rm -f ramdisk.cpio.orig config *.xz
if $IS_RAMDISK; then
  ./magiskboot compress=gzip ramdisk.cpio "$OUTPUT_FILE"
else
  ./magiskboot repack "$TARGET_FILE" "$OUTPUT_FILE"
  ./magiskboot cleanup
fi

```

`scripts/live_setup.sh`:

```sh
#####################################################################
#   AVD Magisk Setup
#####################################################################
#
# Support API level: 23 - 36
#
# For developing Magisk, just use:
# ./build.py emulator
#
# This script will stop zygote, simulate the Magisk start up process
# that would've happened before zygote was started, and finally
# restart zygote. This is useful for setting up the emulator for
# developing Magisk, testing modules, and developing root apps using
# the official Android emulator (AVD) instead of a real device.
#
# This only covers the "core" features of Magisk. For testing
# magiskinit, please checkout avd_patch.sh.
#
#####################################################################

mount_tmpfs() {
  # If a file name 'magisk' is in current directory, mount will fail
  mv magisk magisk.tmp
  mount -t tmpfs -o 'mode=0755' magisk $1
  mv magisk.tmp magisk
}

mount_sbin() {
  mount_tmpfs /sbin
  chcon u:object_r:rootfs:s0 /sbin
}

if [ ! -f /system/build.prop ]; then
  # Running on PC
  echo 'Please run `./build.py emulator` instead of directly executing the script!'
  exit 1
fi

cd /data/local/tmp
chmod 755 busybox

if [ -z "$FIRST_STAGE" ]; then
  export FIRST_STAGE=1
  export ASH_STANDALONE=1
  if [ $(./busybox id -u) -ne 0 ]; then
    # Re-exec script with root
    exec /system/xbin/su 0 /data/local/tmp/busybox sh $0
  else
    # Re-exec script with busybox
    exec ./busybox sh $0
  fi
fi

pm install -r -g $(pwd)/magisk.apk

# Extract files from APK
unzip -oj magisk.apk 'assets/util_functions.sh' 'assets/stub.apk'
. ./util_functions.sh

api_level_arch_detect

unzip -oj magisk.apk "lib/$ABI/*" -x "lib/$ABI/libbusybox.so"
for file in lib*.so; do
  chmod 755 $file
  mv "$file" "${file:3:${#file}-6}"
done

if $IS64BIT && [ -e "/system/bin/linker" ]; then
  unzip -oj magisk.apk "lib/$ABI32/libmagisk.so"
  mv libmagisk.so magisk32
  chmod 755 magisk32
fi

# Stop zygote (and previous setup if exists)
magisk --stop 2>/dev/null
stop
if [ -d /debug_ramdisk ]; then
  umount -l /debug_ramdisk 2>/dev/null
fi

# Make sure boot completed props are not set to 1
setprop sys.boot_completed 0

# Mount /cache if not already mounted
if ! grep -q ' /cache ' /proc/mounts; then
  mount -t tmpfs -o 'mode=0755' tmpfs /cache
fi

MAGISKTMP=/sbin

# Setup bin overlay
if mount | grep -q rootfs; then
  # Legacy rootfs
  mount -o rw,remount /
  rm -rf /root
  mkdir /root /sbin 2>/dev/null
  chmod 750 /root /sbin
  ln /sbin/* /root
  mount -o ro,remount /
  mount_sbin
  ln -s /root/* /sbin
elif [ -e /sbin ]; then
  # Legacy SAR
  mount_sbin
  mkdir -p /dev/sysroot
  block=$(mount | grep ' / ' | awk '{ print $1 }')
  [ $block = "/dev/root" ] && block=/dev/block/vda1
  mount -o ro $block /dev/sysroot
  for file in /dev/sysroot/sbin/*; do
    [ ! -e $file ] && break
    if [ -L $file ]; then
      cp -af $file /sbin
    else
      sfile=/sbin/$(basename $file)
      touch $sfile
      mount -o bind $file $sfile
    fi
  done
  umount -l /dev/sysroot
  rm -rf /dev/sysroot
else
  # Android Q+ without sbin
  MAGISKTMP=/debug_ramdisk
  mount_tmpfs /debug_ramdisk
fi

# Magisk stuff
mkdir -p $MAGISKBIN 2>/dev/null
unzip -oj magisk.apk 'assets/*.sh' -d $MAGISKBIN
mkdir /data/adb/modules 2>/dev/null
mkdir /data/adb/post-fs-data.d 2>/dev/null
mkdir /data/adb/service.d 2>/dev/null

for file in magisk magisk32 magiskpolicy stub.apk; do
  chmod 755 ./$file
  cp -af ./$file $MAGISKTMP/$file
  cp -af ./$file $MAGISKBIN/$file
done
cp -af ./magiskboot $MAGISKBIN/magiskboot
cp -af ./magiskinit $MAGISKBIN/magiskinit
cp -af ./busybox $MAGISKBIN/busybox

ln -s ./magisk $MAGISKTMP/su
ln -s ./magisk $MAGISKTMP/resetprop
ln -s ./magiskpolicy $MAGISKTMP/supolicy

mkdir -p $MAGISKTMP/.magisk/device
mkdir -p $MAGISKTMP/.magisk/worker
mount_tmpfs $MAGISKTMP/.magisk/worker
mount --make-private $MAGISKTMP/.magisk/worker
touch $MAGISKTMP/.magisk/config

export MAGISKTMP
MAKEDEV=1 $MAGISKTMP/magisk --preinit-device 2>&1

RULESCMD=""
rule="$MAGISKTMP/.magisk/preinit/sepolicy.rule"
[ -f "$rule" ] && RULESCMD="--apply $rule"

# SELinux stuffs
if [ -d /sys/fs/selinux ]; then
  if [ -f /vendor/etc/selinux/precompiled_sepolicy ]; then
    ./magiskpolicy --load /vendor/etc/selinux/precompiled_sepolicy --live --magisk $RULESCMD 2>&1
  elif [ -f /sepolicy ]; then
    ./magiskpolicy --load /sepolicy --live --magisk $RULESCMD 2>&1
  else
    ./magiskpolicy --live --magisk $RULESCMD 2>&1
  fi
fi

# Boot up
$MAGISKTMP/magisk --post-fs-data
start
$MAGISKTMP/magisk --service
# Make sure reset nb prop after zygote starts
sleep 2
$MAGISKTMP/magisk --boot-complete

```

`scripts/module_installer.sh`:

```sh
#!/sbin/sh

#################
# Initialization
#################

umask 022

# echo before loading util_functions
ui_print() { echo "$1"; }

require_new_magisk() {
  ui_print "*******************************"
  ui_print " Please install Magisk v20.4+! "
  ui_print "*******************************"
  exit 1
}

#########################
# Load util_functions.sh
#########################

OUTFD=$2
ZIPFILE=$3

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
. /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 20400 ] && require_new_magisk

install_module
exit 0

```

`scripts/release.sh`:

```sh
#!/usr/bin/env bash
set -e

# On macOS, gsed is required (brew install gnu-sed)
# Required tools: gh
# The GitHub cli (gh) has to be properly authenticated

# These variables can be modified as needed
CONFIG=config.prop
NOTES=notes.md

# These are constants, do not modify
GCONFIG=app/gradle.properties
BUILDCMD="./build.py -c $CONFIG"
CWD=$(pwd)

grep_prop() {
  local REGEX="s/^$1=//p"
  shift
  local FILES=$@
  sed -n "$REGEX" $FILES | head -n 1
}

ensure_config() {
  # Make sure version is not commented out and exists
  sed -i "s:^# version=:version=:g" $CONFIG
  if ! grep -qE '^version=' $CONFIG; then
    echo 'version=' >> $CONFIG
  fi
  # Make sure abiList is not set when building for release
  sed -i "s:^abiList=:# abiList=:g" $CONFIG
}

disable_version_config() {
  # Comment out version config
  sed -i "s:^version=:# version=:g" $CONFIG
}

# $1 = ver
set_version() {
  local ver=$1
  local code=$(echo - | awk "{ print $ver * 1000 }")
  local tag="v$ver"

  sed -i "s:versionCode=.*:versionCode=${code}:g" $GCONFIG
  sed -i "s:version=.*:version=${ver}:g" $CONFIG
  sed -i "1s:.*:## $(date +'%Y.%-m.%-d') Magisk v$ver:" $NOTES

  # Commit version code changes
  git add -u .
  git status
  git commit -m "Release Magisk v$ver" -m "[skip ci]"
}

# $1 = ver
build() {
  [ -z $1 ] && exit 1
  local ver=$1
  git pull
  set_version $ver
  $BUILDCMD clean
  $BUILDCMD all
  $BUILDCMD -r all
}

upload() {
  gh auth status

  local code=$(grep_prop magisk.versionCode $GCONFIG)
  local ver=$(echo - | awk "{ print $code / 1000 }")
  local tag="v$ver"
  local title="Magisk v$ver"

  local out=$(grep_prop outdir $CONFIG)
  if [ -z $out ]; then
    out=out
  fi

  git tag $tag
  git push origin master
  git push --tags

  # Prepare release notes
  tail -n +3 $NOTES > release.md

  # Publish release
  local release_apk="Magisk-v${ver}.apk"
  cp $out/app-release.apk $release_apk
  gh release create --verify-tag $tag -p -t "$title" -F release.md $release_apk $out/app-debug.apk $NOTES

  rm -f $release_apk release.md
}

# Use GNU sed on macOS
if command -v gsed >/dev/null; then
  function sed() { gsed "$@"; }
  export -f sed
fi

trap disable_version_config EXIT
ensure_config
case $1 in
  build ) build $2 ;;
  upload ) upload ;;
  * ) exit 1 ;;
esac

```

`scripts/test_common.sh`:

```sh
if [ -z $ANDROID_HOME ]; then
  export ANDROID_HOME=$ANDROID_SDK_ROOT
fi

# Make sure paths are consistent
export ANDROID_USER_HOME="$HOME/.android"
export ANDROID_EMULATOR_HOME="$ANDROID_USER_HOME"
export ANDROID_AVD_HOME="$ANDROID_EMULATOR_HOME/avd"
export PATH="$PATH:$ANDROID_HOME/platform-tools"

emu="$ANDROID_HOME/emulator/emulator"
sdk="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"
avd="$ANDROID_HOME/cmdline-tools/latest/bin/avdmanager"

boot_timeout=100

core_count=$(nproc)
if [ $core_count -gt 8 ]; then
  core_count=8
fi

print_title() {
  echo -e "\n\033[44;39m${1}\033[0m\n"
}

print_error() {
  echo -e "\n\033[41;39m${1}\033[0m\n" >&2
}

# $1 = TestClass#method
# $2 = component
am_instrument() {
  set +x
  local out=$(adb shell am instrument -w --user 0 -e class "$1" "$2")
  echo "$out"
  if grep -q 'OK (' <<< "$out"; then
    set -x
    return 0
  else
    set -x
    return 1
  fi
}

# $1 = pkg
wait_for_pm() {
  sleep 5
  adb shell pm uninstall $1 || true
}

run_setup() {
  local variant=$1
  adb shell 'PATH=$PATH:/debug_ramdisk magisk -v'

  # Install the Magisk app
  adb install -r -g out/app-${variant}.apk

  # Install the test app
  adb install -r -g out/test.apk

  local app='com.topjohnwu.magisk.test/com.topjohnwu.magisk.test.AppTestRunner'

  # Run setup through the test app
  am_instrument '.Environment#setupEnvironment' $app
}

run_tests() {
  local pkg='com.topjohnwu.magisk.test'
  local self="$pkg/$pkg.TestRunner"
  local app="$pkg/$pkg.AppTestRunner"
  local stub="repackaged.$pkg/$pkg.AppTestRunner"

  # Run app tests
  am_instrument '.MagiskAppTest,.AdditionalTest' $app

  # Test app hiding
  am_instrument '.AppMigrationTest#testAppHide' $self

  # Make sure it still works
  am_instrument '.MagiskAppTest' $stub

  # Test app restore
  am_instrument '.AppMigrationTest#testAppRestore' $self

  # Make sure it still works
  am_instrument '.MagiskAppTest' $app
}

```

`scripts/uninstaller.sh`:

```sh
#MAGISK
############################################
# Magisk Uninstaller (updater-script)
############################################

##############
# Preparation
##############

# Default permissions
umask 022

OUTFD=$2
COMMONDIR=$INSTALLER/assets
CHROMEDIR=$INSTALLER/assets/chromeos

if [ ! -f $COMMONDIR/util_functions.sh ]; then
  echo "! Unable to extract zip file!"
  exit 1
fi

# Load utility functions
. $COMMONDIR/util_functions.sh

setup_flashable

############
# Detection
############

if echo $MAGISK_VER | grep -q '\.'; then
  PRETTY_VER=$MAGISK_VER
else
  PRETTY_VER="$MAGISK_VER($MAGISK_VER_CODE)"
fi
print_title "Magisk $PRETTY_VER Uninstaller"

is_mounted /data || mount /data || abort "! Unable to mount /data, please uninstall with the Magisk app"
mount_partitions
check_data
$DATA_DE || abort "! Cannot access /data, please uninstall with the Magisk app"
get_flags
find_boot_image

[ -z $BOOTIMAGE ] && abort "! Unable to detect target image"
ui_print "- Target image: $BOOTIMAGE"

# Detect version and architecture
api_level_arch_detect

ui_print "- Device platform: $ABI"

BINDIR=$INSTALLER/lib/$ABI
cd $BINDIR
for file in lib*.so; do mv "$file" "${file:3:${#file}-6}"; done
cd /
cp -af $CHROMEDIR/. $BINDIR/chromeos
chmod -R 755 $BINDIR

############
# Uninstall
############

cd $BINDIR

CHROMEOS=false

ui_print "- Unpacking boot image"
# Dump image for MTD/NAND character device boot partitions
if [ -c $BOOTIMAGE ]; then
  nanddump -f boot.img $BOOTIMAGE
  BOOTNAND=$BOOTIMAGE
  BOOTIMAGE=boot.img
fi
./magiskboot unpack "$BOOTIMAGE"

case $? in
  1 )
    abort "! Unsupported/Unknown image format"
    ;;
  2 )
    ui_print "- ChromeOS boot image detected"
    CHROMEOS=true
    ;;
esac

# Restore the original boot partition path
[ "$BOOTNAND" ] && BOOTIMAGE=$BOOTNAND

# Detect boot image state
ui_print "- Checking ramdisk status"
if [ -e ramdisk.cpio ]; then
  ./magiskboot cpio ramdisk.cpio test
  STATUS=$?
else
  # Stock A only system-as-root
  STATUS=0
fi
case $((STATUS & 3)) in
  0 )  # Stock boot
    ui_print "- Stock boot image detected"
    ;;
  1 )  # Magisk patched
    ui_print "- Magisk patched image detected"
    # Find SHA1 of stock boot image
    ./magiskboot cpio ramdisk.cpio "extract .backup/.magisk config.orig"
    if [ -f config.orig ]; then
      chmod 0644 config.orig
      SHA1=$(grep_prop SHA1 config.orig)
      rm config.orig
    fi
    BACKUPDIR=/data/magisk_backup_$SHA1
    if [ -d $BACKUPDIR ]; then
      ui_print "- Restoring stock boot image"
      flash_image $BACKUPDIR/boot.img.gz $BOOTIMAGE
      for name in dtb dtbo dtbs; do
        [ -f $BACKUPDIR/${name}.img.gz ] || continue
        IMAGE=$(find_block $name$SLOT)
        [ -z $IMAGE ] && continue
        ui_print "- Restoring stock $name image"
        flash_image $BACKUPDIR/${name}.img.gz $IMAGE
      done
    else
      ui_print "! Boot image backup unavailable"
      ui_print "- Restoring ramdisk with internal backup"
      ./magiskboot cpio ramdisk.cpio restore
      if ! ./magiskboot cpio ramdisk.cpio "exists init"; then
        # A only system-as-root
        rm -f ramdisk.cpio
      fi
      ./magiskboot repack $BOOTIMAGE
      # Sign chromeos boot
      $CHROMEOS && sign_chromeos
      ui_print "- Flashing restored boot image"
      flash_image new-boot.img $BOOTIMAGE || abort "! Insufficient partition size"
    fi
    ;;
  2 )  # Unsupported
    ui_print "! Boot image patched by unsupported programs"
    abort "! Cannot uninstall"
    ;;
esac

if $BOOTMODE; then
  ui_print "- Removing modules"
  magisk --remove-modules -n
fi

ui_print "- Removing Magisk files"
rm -rf \
/cache/*magisk* /cache/unblock /data/*magisk* /data/cache/*magisk* /data/property/*magisk* \
/data/Magisk.apk /data/busybox /data/custom_ramdisk_patch.sh /data/adb/*magisk* \
/data/adb/post-fs-data.d /data/adb/service.d /data/adb/modules* \
/data/unencrypted/magisk /metadata/magisk /metadata/watchdog/magisk /persist/magisk /mnt/vendor/persist/magisk

ADDOND=/system/addon.d/99-magisk.sh
if [ -f $ADDOND ]; then
  blockdev --setrw /dev/block/mapper/system$SLOT 2>/dev/null
  mount -o rw,remount /system || mount -o rw,remount /
  rm -f $ADDOND
fi

cd /

if $BOOTMODE; then
  ui_print "********************************************"
  ui_print " The Magisk app will uninstall itself, and"
  ui_print " the device will reboot after a few seconds"
  ui_print "********************************************"
  (sleep 8; /system/bin/reboot)&
else
  ui_print "********************************************"
  ui_print " The Magisk app will not be uninstalled"
  ui_print " Please uninstall it manually after reboot"
  ui_print "********************************************"
  recovery_cleanup
  ui_print "- Done"
fi

rm -rf $TMPDIR
exit 0

```

`scripts/update_binary.sh`:

```sh
#!/sbin/sh

TMPDIR=/dev/tmp
rm -rf $TMPDIR
mkdir -p $TMPDIR 2>/dev/null

export BBBIN=$TMPDIR/busybox
for arch in "x86_64" "x86" "arm64-v8a" "armeabi-v7a"; do
  unzip -o "$3" "lib/$arch/libbusybox.so" -d $TMPDIR >&2
  libpath="$TMPDIR/lib/$arch/libbusybox.so"
  chmod 755 $libpath
  if [ -x $libpath ] && $libpath >/dev/null 2>&1; then
    mv -f $libpath $BBBIN
    break
  fi
done
$BBBIN rm -rf $TMPDIR/lib

export INSTALLER=$TMPDIR/install
$BBBIN mkdir -p $INSTALLER
$BBBIN unzip -o "$3" "assets/*" "lib/*" "META-INF/com/google/*" -x "lib/*/libbusybox.so" -d $INSTALLER >&2
export ASH_STANDALONE=1
if echo "$3" | $BBBIN grep -q "uninstall"; then
  exec $BBBIN sh "$INSTALLER/assets/uninstaller.sh" "$@"
else
  exec $BBBIN sh "$INSTALLER/META-INF/com/google/android/updater-script" "$@"
fi

```

`scripts/util_functions.sh`:

```sh
############################################
# Magisk General Utility Functions
############################################

#MAGISK_VERSION_STUB

###################
# Global Variables
###################

# True if the script is running on booted Android, not something like recovery
# BOOTMODE=

# The path to store temporary files that don't need to persist
# TMPDIR=

# The non-volatile path where magisk executables are stored
# MAGISKBIN=

###################
# Helper Functions
###################

ui_print() {
  if $BOOTMODE; then
    echo "$1"
  else
    echo -e "ui_print $1\nui_print" >> /proc/self/fd/$OUTFD
  fi
}

toupper() {
  echo "$@" | tr '[:lower:]' '[:upper:]'
}

grep_cmdline() {
  local REGEX="s/^$1=//p"
  { echo $(cat /proc/cmdline)$(sed -e 's/[^"]//g' -e 's/""//g' /proc/cmdline) | xargs -n 1; \
    sed -e 's/ = /=/g' -e 's/, /,/g' -e 's/"//g' /proc/bootconfig; \
  } 2>/dev/null | sed -n "$REGEX"
}

grep_prop() {
  local REGEX="s/^$1=//p"
  shift
  local FILES=$@
  [ -z "$FILES" ] && FILES='/system/build.prop'
  cat $FILES 2>/dev/null | dos2unix | sed -n "$REGEX" | head -n 1
}

grep_get_prop() {
  local result=$(grep_prop $@)
  if [ -z "$result" ]; then
    # Fallback to getprop
    getprop "$1"
  else
    echo $result
  fi
}

getvar() {
  local VARNAME=$1
  local VALUE
  local PROPPATH='/data/.magisk /cache/.magisk'
  [ ! -z $MAGISKTMP ] && PROPPATH="$MAGISKTMP/.magisk/config $PROPPATH"
  VALUE=$(grep_prop $VARNAME $PROPPATH)
  [ ! -z $VALUE ] && eval $VARNAME=\$VALUE
}

is_mounted() {
  grep -q " $(readlink -f $1) " /proc/mounts 2>/dev/null
  return $?
}

abort() {
  ui_print "$1"
  $BOOTMODE || recovery_cleanup
  [ ! -z $MODPATH ] && rm -rf $MODPATH
  rm -rf $TMPDIR
  exit 1
}

print_title() {
  local len line1len line2len bar
  line1len=$(echo -n $1 | wc -c)
  line2len=$(echo -n $2 | wc -c)
  len=$line2len
  [ $line1len -gt $line2len ] && len=$line1len
  len=$((len + 2))
  bar=$(printf "%${len}s" | tr ' ' '*')
  ui_print "$bar"
  ui_print " $1 "
  [ "$2" ] && ui_print " $2 "
  ui_print "$bar"
}

######################
# Environment Related
######################

setup_flashable() {
  ensure_bb
  $BOOTMODE && return
  if [ -z $OUTFD ] || readlink /proc/$$/fd/$OUTFD | grep -q /tmp; then
    # We will have to manually find out OUTFD
    for FD in $(ls /proc/$$/fd); do
      if readlink /proc/$$/fd/$FD | grep -q pipe; then
        if ps | grep -v grep | grep -qE " 3 $FD |status_fd=$FD"; then
          OUTFD=$FD
          break
        fi
      fi
    done
  fi
  recovery_actions
}

ensure_bb() {
  if set -o | grep -q standalone; then
    # We are definitely in busybox ash
    set -o standalone
    return
  fi

  # Find our busybox binary
  local bb
  if [ -f $TMPDIR/busybox ]; then
    bb=$TMPDIR/busybox
  elif [ -f $MAGISKBIN/busybox ]; then
    bb=$MAGISKBIN/busybox
  else
    abort "! Cannot find BusyBox"
  fi
  chmod 755 $bb

  # Busybox could be a script, make sure /system/bin/sh exists
  if [ ! -f /system/bin/sh ]; then
    umount -l /system 2>/dev/null
    mkdir -p /system/bin
    ln -s $(command -v sh) /system/bin/sh
  fi

  export ASH_STANDALONE=1

  # Find our current arguments
  # Run in busybox environment to ensure consistent results
  # /proc/<pid>/cmdline shall be <interpreter> <script> <arguments...>
  local cmds="$($bb sh -c "
  for arg in \$(tr '\0' '\n' < /proc/$$/cmdline); do
    if [ -z \"\$cmds\" ]; then
      # Skip the first argument as we want to change the interpreter
      cmds=\"sh\"
    else
      cmds=\"\$cmds '\$arg'\"
    fi
  done
  echo \$cmds")"

  # Re-exec our script
  echo $cmds | $bb xargs $bb
  exit
}

recovery_actions() {
  # Make sure random won't get blocked
  mount -o bind /dev/urandom /dev/random
  # Unset library paths
  OLD_LD_LIB=$LD_LIBRARY_PATH
  OLD_LD_PRE=$LD_PRELOAD
  OLD_LD_CFG=$LD_CONFIG_FILE
  unset LD_LIBRARY_PATH
  unset LD_PRELOAD
  unset LD_CONFIG_FILE
}

recovery_cleanup() {
  local DIR
  ui_print "- Unmounting partitions"
  (
  if [ ! -d /postinstall/tmp ]; then
    umount -l /system
    umount -l /system_root
  fi
  umount -l /vendor
  umount -l /persist
  umount -l /metadata
  for DIR in /apex /system /system_root; do
    if [ -L "${DIR}_link" ]; then
      rmdir $DIR
      mv -f ${DIR}_link $DIR
    fi
  done
  umount -l /dev/random
  ) 2>/dev/null
  [ -z $OLD_LD_LIB ] || export LD_LIBRARY_PATH=$OLD_LD_LIB
  [ -z $OLD_LD_PRE ] || export LD_PRELOAD=$OLD_LD_PRE
  [ -z $OLD_LD_CFG ] || export LD_CONFIG_FILE=$OLD_LD_CFG
}

#######################
# Installation Related
#######################

# find_block [partname...]
find_block() {
  local BLOCK DEV DEVICE DEVNAME PARTNAME UEVENT
  for BLOCK in "$@"; do
    DEVICE=$(find /dev/block \( -type b -o -type c -o -type l \) -iname $BLOCK | head -n 1) 2>/dev/null
    if [ ! -z $DEVICE ]; then
      echo $DEVICE
      return 0
    fi
  done
  # Fallback by parsing sysfs uevents
  for UEVENT in /sys/dev/block/*/uevent; do
    DEVNAME=$(grep_prop DEVNAME $UEVENT)
    PARTNAME=$(grep_prop PARTNAME $UEVENT)
    for BLOCK in "$@"; do
      if [ "$(toupper $BLOCK)" = "$(toupper $PARTNAME)" ]; then
        echo /dev/block/$DEVNAME
        return 0
      fi
    done
  done
  # Look just in /dev in case we're dealing with MTD/NAND without /dev/block devices/links
  for DEV in "$@"; do
    DEVICE=$(find /dev \( -type b -o -type c -o -type l \) -maxdepth 1 -iname $DEV | head -n 1) 2>/dev/null
    if [ ! -z $DEVICE ]; then
      echo $DEVICE
      return 0
    fi
  done
  return 1
}

# setup_mntpoint <mountpoint>
setup_mntpoint() {
  local POINT=$1
  [ -L $POINT ] && mv -f $POINT ${POINT}_link
  if [ ! -d $POINT ]; then
    rm -f $POINT
    mkdir -p $POINT
  fi
}

# mount_name <partname(s)> <mountpoint> <flag>
mount_name() {
  local PART=$1
  local POINT=$2
  local FLAG=$3
  setup_mntpoint $POINT
  is_mounted $POINT && return
  # First try mounting with fstab
  mount $FLAG $POINT 2>/dev/null
  if ! is_mounted $POINT; then
    local BLOCK=$(find_block $PART)
    mount $FLAG $BLOCK $POINT || return
  fi
  ui_print "- Mounting $POINT"
}

# mount_ro_ensure <partname(s)> <mountpoint>
mount_ro_ensure() {
  # We handle ro partitions only in recovery
  $BOOTMODE && return
  local PART=$1
  local POINT=$2
  mount_name "$PART" $POINT '-o ro'
  is_mounted $POINT || abort "! Cannot mount $POINT"
}

# After calling this method, the following variables will be set:
# SLOT, SYSTEM_AS_ROOT, LEGACYSAR
mount_partitions() {
  # Check A/B slot
  SLOT=$(grep_cmdline androidboot.slot_suffix)
  if [ -z $SLOT ]; then
    SLOT=$(grep_cmdline androidboot.slot)
    [ -z $SLOT ] || SLOT=_${SLOT}
  fi
  [ "$SLOT" = "normal" ] && unset SLOT
  [ -z $SLOT ] || ui_print "- Current boot slot: $SLOT"

  # Mount ro partitions
  if is_mounted /system_root; then
    umount /system 2>/dev/null
    umount /system_root 2>/dev/null
  fi
  mount_ro_ensure "system$SLOT app$SLOT" /system
  if [ -f /system/init -o -L /system/init ]; then
    SYSTEM_AS_ROOT=true
    setup_mntpoint /system_root
    if ! mount --move /system /system_root; then
      umount /system
      umount -l /system 2>/dev/null
      mount_ro_ensure "system$SLOT app$SLOT" /system_root
    fi
    mount -o bind /system_root/system /system
  else
    if grep ' / ' /proc/mounts | grep -qv 'rootfs' || grep -q ' /system_root ' /proc/mounts; then
      SYSTEM_AS_ROOT=true
    else
      SYSTEM_AS_ROOT=false
    fi
  fi
  $SYSTEM_AS_ROOT && ui_print "- Device is system-as-root"

  LEGACYSAR=false
  if $BOOTMODE; then
    grep ' / ' /proc/mounts | grep -q '/dev/root' && LEGACYSAR=true
  else
    # Recovery mode, assume devices that don't use dynamic partitions are legacy SAR
    local IS_DYNAMIC=false
    if grep -q 'androidboot.super_partition' /proc/cmdline; then
      IS_DYNAMIC=true
    elif [ -n "$(find_block super)" ]; then
      IS_DYNAMIC=true
    fi
    if $SYSTEM_AS_ROOT && ! $IS_DYNAMIC; then
      LEGACYSAR=true
      ui_print "- Legacy SAR, force kernel to load rootfs"
    fi
  fi
}

# After calling this method, the following variables will be set:
# ISENCRYPTED, PATCHVBMETAFLAG,
# KEEPVERITY, KEEPFORCEENCRYPT, RECOVERYMODE, VENDORBOOT
get_flags() {
  if grep ' /data ' /proc/mounts | grep -q 'dm-'; then
    ISENCRYPTED=true
  elif [ "$(getprop ro.crypto.state)" = "encrypted" ]; then
    ISENCRYPTED=true
  elif [ "$DATA" = "false" ]; then
    # No data access means unable to decrypt in recovery
    ISENCRYPTED=true
  else
    ISENCRYPTED=false
  fi
  if [ -n "$(find_block vbmeta vbmeta_a)" ]; then
    PATCHVBMETAFLAG=false
  else
    PATCHVBMETAFLAG=true
    ui_print "- No vbmeta partition, patch vbmeta in boot image"
  fi

  # Overridable config flags with safe defaults
  getvar KEEPVERITY
  getvar KEEPFORCEENCRYPT
  getvar RECOVERYMODE
  getvar VENDORBOOT
  if [ -z $KEEPVERITY ]; then
    if $SYSTEM_AS_ROOT; then
      KEEPVERITY=true
      ui_print "- System-as-root, keep dm-verity"
    else
      KEEPVERITY=false
    fi
  fi
  if [ -z $KEEPFORCEENCRYPT ]; then
    if $ISENCRYPTED; then
      KEEPFORCEENCRYPT=true
      ui_print "- Encrypted data, keep forceencrypt"
    else
      KEEPFORCEENCRYPT=false
    fi
  fi
  [ -z $RECOVERYMODE ] && RECOVERYMODE=false
  [ -z $VENDORBOOT ] && VENDORBOOT=false
}

# Returns whether the device is GKI 13+
is_gt_gki_13() {
  [ "$(uname -r | cut -d. -f1)" -ge 5 ] && uname -r | grep -Evq "android12-|^5\.4"
}

# Require RECOVERYMODE, VENDORBOOT, SLOT to be set.
# After calling this method, BOOTIMAGE will be set.
find_boot_image() {
  BOOTIMAGE=
  if $VENDORBOOT; then
    BOOTIMAGE="/dev/block/by-name/vendor_boot$SLOT"
  elif $RECOVERYMODE; then
    BOOTIMAGE=$(find_block "recovery$SLOT" "sos")
  elif [ -e "/dev/block/by-name/init_boot$SLOT" ] && is_gt_gki_13; then
    # init_boot is only used with GKI 13+. It is possible that some devices with init_boot
    # partition still uses Android 12 GKI or previous kernels, so we need to explicitly detect that scenario.
    BOOTIMAGE="/dev/block/by-name/init_boot$SLOT"
  elif [ -e "/dev/block/by-name/boot$SLOT" ]; then
    # Standard location since AOSP Android 10+
    BOOTIMAGE="/dev/block/by-name/boot$SLOT"
  elif [ -n "$SLOT" ]; then
    # Fallback for A/B devices running < Android 10
    BOOTIMAGE=$(find_block "ramdisk$SLOT" "boot$SLOT")
  else
    # Fallback for all legacy and non-standard devices
    BOOTIMAGE=$(find_block ramdisk kern-a android_boot kernel bootimg boot lnx boot_a)
  fi
  if [ -z $BOOTIMAGE ]; then
    # Lets see what fstabs tells me
    BOOTIMAGE=$(grep -v '#' /etc/*fstab* | grep -E '/boot(img)?[^a-zA-Z]' | grep -oE '/dev/[a-zA-Z0-9_./-]*' | head -n 1)
  fi
}

flash_image() {
  local CMD1
  case "$1" in
    *.gz) CMD1="gzip -d < '$1' 2>/dev/null";;
    *)    CMD1="cat '$1'";;
  esac
  if [ -b "$2" ]; then
    local img_sz=$(stat -c '%s' "$1")
    local blk_sz=$(blockdev --getsize64 "$2")
    [ "$img_sz" -gt "$blk_sz" ] && return 1
    blockdev --setrw "$2"
    local blk_ro=$(blockdev --getro "$2")
    [ "$blk_ro" -eq 1 ] && return 2
    eval "$CMD1" | cat - /dev/zero > "$2" 2>/dev/null
  elif [ -c "$2" ]; then
    flash_eraseall "$2" >&2
    eval "$CMD1" | nandwrite -p "$2" - >&2
  else
    ui_print "- Not block or char device, storing image"
    eval "$CMD1" > "$2" 2>/dev/null
  fi
  return 0
}

# Common installation script for flash_script.sh and addon.d.sh
install_magisk() {
  cd $MAGISKBIN

  # Source the boot patcher
  SOURCEDMODE=true
  . ./boot_patch.sh "$BOOTIMAGE"

  ui_print "- Flashing new boot image"
  flash_image new-boot.img "$BOOTIMAGE"
  case $? in
    1)
      abort "! Insufficient partition size"
      ;;
    2)
      abort "! $BOOTIMAGE is read only"
      ;;
  esac

  ./magiskboot cleanup
  rm -f new-boot.img

  run_migrations
}

sign_chromeos() {
  ui_print "- Signing ChromeOS boot image"

  echo > empty
  ./chromeos/futility vbutil_kernel --pack new-boot.img.signed \
  --keyblock ./chromeos/kernel.keyblock --signprivate ./chromeos/kernel_data_key.vbprivk \
  --version 1 --vmlinuz new-boot.img --config empty --arch arm --bootloader empty --flags 0x1

  rm -f empty new-boot.img
  mv new-boot.img.signed new-boot.img
}

remove_system_su() {
  [ -d /postinstall/tmp ] && POSTINST=/postinstall
  cd $POSTINST/system
  if [ -f bin/su -o -f xbin/su ] && [ ! -f /su/bin/su ]; then
    ui_print "- Removing system installed root"
    blockdev --setrw /dev/block/mapper/system$SLOT 2>/dev/null
    mount -o rw,remount $POSTINST/system
    # SuperSU
    cd bin
    if [ -e .ext/.su ]; then
      mv -f app_process32_original app_process32 2>/dev/null
      mv -f app_process64_original app_process64 2>/dev/null
      mv -f install-recovery_original.sh install-recovery.sh 2>/dev/null
      if [ -e app_process64 ]; then
        ln -sf app_process64 app_process
      elif [ -e app_process32 ]; then
        ln -sf app_process32 app_process
      fi
    fi
    # More SuperSU, SuperUser & ROM su
    cd ..
    rm -rf .pin bin/.ext etc/.installed_su_daemon etc/.has_su_daemon \
    xbin/daemonsu xbin/su xbin/sugote xbin/sugote-mksh xbin/supolicy \
    bin/app_process_init bin/su /cache/su lib/libsupol.so lib64/libsupol.so \
    su.d etc/init.d/99SuperSUDaemon etc/install-recovery.sh /cache/install-recovery.sh \
    .supersu /cache/.supersu /data/.supersu \
    app/Superuser.apk app/SuperSU /cache/Superuser.apk
  elif [ -f /cache/su.img -o -f /data/su.img -o -d /data/su -o -d /data/adb/su ]; then
    ui_print "- Removing systemless installed root"
    umount -l /su 2>/dev/null
    rm -rf /cache/su.img /data/su.img /data/su /data/adb/su /data/adb/suhide \
    /cache/.supersu /data/.supersu /cache/supersu_install /data/supersu_install
  fi
  cd $TMPDIR
}

api_level_arch_detect() {
  API=$(grep_get_prop ro.build.version.sdk)
  ABI=$(grep_get_prop ro.product.cpu.abi)
  if [ "$ABI" = "arm64-v8a" ]; then
    ARCH=arm64
    ABI32=armeabi-v7a
    IS64BIT=true
  elif [ "$ABI" = "x86_64" ]; then
    ARCH=x64
    ABI32=x86
    IS64BIT=true
  elif [ "$ABI" = "armeabi-v7a" ]; then
    ARCH=arm
    ABI32=armeabi-v7a
    IS64BIT=false
  elif [ "$ABI" = "x86" ]; then
    ARCH=x86
    ABI32=x86
    IS64BIT=false
  elif [ "$ABI" = "riscv64" ]; then
    ARCH=riscv64
    ABI32=riscv32
    IS64BIT=true
  fi
}

check_data() {
  DATA=false
  DATA_DE=false
  if grep ' /data ' /proc/mounts | grep -vq 'tmpfs'; then
    # Test if data is writable
    touch /data/.rw && rm /data/.rw && DATA=true
    # Test if data is decrypted
    $DATA && [ -d /data/adb ] && touch /data/adb/.rw && rm /data/adb/.rw && DATA_DE=true
    $DATA_DE && [ -d /data/adb/magisk ] || mkdir /data/adb/magisk || DATA_DE=false
  fi
  MAGISKBIN="/data/magisk"
  $DATA || MAGISKBIN="/cache/data_adb/magisk"
  $DATA_DE && MAGISKBIN="/data/adb/magisk"
}

run_migrations() {
  local SHA1
  local TARGET
  # Legacy app installation
  local BACKUP=$MAGISKBIN/stock_boot*.gz
  if [ -f $BACKUP ]; then
    cp $BACKUP /data
    rm -f $BACKUP
  fi

  # Legacy backup
  for gz in /data/stock_boot*.gz; do
    [ -f $gz ] || break
    SHA1=$(basename $gz | sed -e 's/stock_boot_//' -e 's/.img.gz//')
    [ -z $SHA1 ] && break
    mkdir /data/magisk_backup_${SHA1} 2>/dev/null
    mv $gz /data/magisk_backup_${SHA1}/boot.img.gz
  done

  # Stock backups
  SHA1=
  for name in boot dtb dtbo dtbs; do
    BACKUP=$MAGISKBIN/stock_${name}.img
    [ -f $BACKUP ] || continue
    if [ $name = 'boot' ]; then
      SHA1=$($MAGISKBIN/magiskboot sha1 $BACKUP)
      mkdir /data/magisk_backup_${SHA1} 2>/dev/null
    fi
    [ -z $SHA1 ] && break
    TARGET=/data/magisk_backup_${SHA1}/${name}.img
    cp $BACKUP $TARGET
    rm -f $BACKUP
    gzip -9f $TARGET
  done

  copy_preinit_files
}

copy_preinit_files() {
  local PREINITDIR=$MAGISKTMP/.magisk/preinit
  if [ ! -d $PREINITDIR ]; then
    ui_print "- Unable to find preinit dir"
    return 1
  fi

  # Copy all enabled sepolicy.rule
  for r in /data/adb/modules*/*/sepolicy.rule; do
    [ -f "$r" ] || continue
    local MODDIR=${r%/*}
    [ -f $MODDIR/disable ] && continue
    [ -f $MODDIR/remove ] && continue
    [ -f $MODDIR/update ] && continue
    cat $r
    echo
  done > $PREINITDIR/sepolicy.rule
}

#################
# Module Related
#################

set_perm() {
  chown $2:$3 $1 || return 1
  chmod $4 $1 || return 1
  local CON=$5
  [ -z $CON ] && CON=u:object_r:system_file:s0
  chcon $CON $1 || return 1
}

set_perm_recursive() {
  find $1 -type d 2>/dev/null | while read dir; do
    set_perm $dir $2 $3 $4 $6
  done
  find $1 -type f -o -type l 2>/dev/null | while read file; do
    set_perm $file $2 $3 $5 $6
  done
}

mktouch() {
  mkdir -p ${1%/*} 2>/dev/null
  [ -z $2 ] && touch $1 || echo $2 > $1
  chmod 644 $1
}

boot_actions() { return; }

# Require ZIPFILE to be set
is_legacy_script() {
  unzip -l "$ZIPFILE" install.sh | grep -q install.sh
  return $?
}

# $1 = MODPATH
set_default_perm() {
  set_perm_recursive $1 0 0 0755 0644
  set_perm_recursive $1/system/bin 0 2000 0755 0755
  set_perm_recursive $1/system/xbin 0 2000 0755 0755
  set_perm_recursive $1/system/system_ext/bin 0 2000 0755 0755
  set_perm_recursive $1/system/vendor/bin 0 2000 0755 0755 u:object_r:vendor_file:s0
}

# Require OUTFD, ZIPFILE to be set
install_module() {
  rm -rf $TMPDIR
  mkdir -p $TMPDIR
  chcon u:object_r:system_file:s0 $TMPDIR
  cd $TMPDIR

  setup_flashable
  mount_partitions
  api_level_arch_detect

  # Setup busybox and binaries
  if $BOOTMODE; then
    boot_actions
  else
    recovery_actions
  fi

  # Extract prop file
  unzip -o "$ZIPFILE" module.prop -d $TMPDIR >&2
  [ ! -f $TMPDIR/module.prop ] && abort "! This zip is not a Magisk module!"

  local MODDIRNAME=modules
  $BOOTMODE && MODDIRNAME=modules_update
  local MODULEROOT=/data/adb/$MODDIRNAME
  MODID=$(grep_prop id $TMPDIR/module.prop)
  MODNAME=$(grep_prop name $TMPDIR/module.prop)
  MODAUTH=$(grep_prop author $TMPDIR/module.prop)
  MODPATH=$MODULEROOT/$MODID

  # Create mod paths
  rm -rf $MODPATH
  mkdir -p $MODPATH
  chcon u:object_r:system_file:s0 $MODPATH

  if is_legacy_script; then
    unzip -oj "$ZIPFILE" module.prop install.sh uninstall.sh 'common/*' -d $TMPDIR >&2

    # Load install script
    . $TMPDIR/install.sh

    # Callbacks
    print_modname
    on_install

    [ -f $TMPDIR/uninstall.sh ] && cp -af $TMPDIR/uninstall.sh $MODPATH/uninstall.sh
    $SKIPMOUNT && touch $MODPATH/skip_mount
    $PROPFILE && cp -af $TMPDIR/system.prop $MODPATH/system.prop
    cp -af $TMPDIR/module.prop $MODPATH/module.prop
    $POSTFSDATA && cp -af $TMPDIR/post-fs-data.sh $MODPATH/post-fs-data.sh
    $LATESTARTSERVICE && cp -af $TMPDIR/service.sh $MODPATH/service.sh

    ui_print "- Setting permissions"
    set_permissions
  else
    print_title "$MODNAME" "by $MODAUTH"
    print_title "Powered by Magisk"

    unzip -o "$ZIPFILE" customize.sh -d $MODPATH >&2

    if ! grep -q '^SKIPUNZIP=1$' $MODPATH/customize.sh 2>/dev/null; then
      ui_print "- Extracting module files"
      unzip -o "$ZIPFILE" -x 'META-INF/*' -d $MODPATH >&2
      set_default_perm $MODPATH
    fi

    # Load customization script
    [ -f $MODPATH/customize.sh ] && . $MODPATH/customize.sh
  fi

  # Handle replace folders
  for TARGET in $REPLACE; do
    ui_print "- Replace target: $TARGET"
    mktouch $MODPATH$TARGET/.replace
  done

  for TARGET in $REMOVE; do
    ui_print "- Remove target: $TARGET"
    mkdir -p $(dirname $MODPATH$TARGET) 2>/dev/null
    mknod $MODPATH$TARGET c 0 0
  done

  if $BOOTMODE; then
    # Update info for Magisk app
    mktouch /data/adb/modules/$MODID/update
    rm -rf /data/adb/modules/$MODID/remove 2>/dev/null
    rm -rf /data/adb/modules/$MODID/disable 2>/dev/null
    cp -af $MODPATH/module.prop /data/adb/modules/$MODID/module.prop
  fi

  # Copy over custom sepolicy rules
  if [ -f $MODPATH/sepolicy.rule ]; then
    ui_print "- Installing custom sepolicy rules"
    copy_preinit_files
  fi

  # Remove stuff that doesn't belong to modules and clean up any empty directories
  rm -rf \
  $MODPATH/system/placeholder $MODPATH/customize.sh \
  $MODPATH/README.md $MODPATH/.git*
  rmdir -p $MODPATH 2>/dev/null

  cd /
  $BOOTMODE || recovery_cleanup
  rm -rf $TMPDIR

  ui_print "- Done"
}

##########
# Presets
##########

# Detect whether in boot mode
[ -z $BOOTMODE ] && ps | grep zygote | grep -qv grep && BOOTMODE=true
[ -z $BOOTMODE ] && ps -A 2>/dev/null | grep zygote | grep -qv grep && BOOTMODE=true
[ -z $BOOTMODE ] && BOOTMODE=false

TMPDIR=/dev/tmp
MAGISKBIN="/data/adb/magisk"

```

`tools/bootctl.patch`:

```patch
# How to build the bootctl bundled within the Magisk app:
#
# 1. Checkout and sync the AOSP tree:
#    https://source.android.com/setup/build/downloading
# 2. Build for arm64:
#    lunch aosp_arm64-eng
# 3. Apply patches:
#    cd system/extras; patch -p1 < bootctl.patch
# 4. Build the executable:
#    m bootctl

diff --git a/bootctl/Android.bp b/bootctl/Android.bp
index f63871cf..8a551bbe 100644
--- a/bootctl/Android.bp
+++ b/bootctl/Android.bp
@@ -26,11 +26,15 @@ cc_binary {
         "-Werror",
     ],

-    shared_libs: [
+    static_libs: [
         "android.hardware.boot@1.0",
         "android.hardware.boot@1.1",
         "android.hardware.boot@1.2",
+    ],
+    shared_libs: [
         "libhidlbase",
         "libutils",
+        "libcutils",
+        "liblog",
     ],
 }

```

`tools/elf-cleaner/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "adler2"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627"

[[package]]
name = "anyhow"
version = "1.0.97"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcfed56ad506cb2c684a14971b8861fdc3baaaae314b9e5f9bb532cbe3ba7a4f"

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "crc32fast"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a97769d94ddab943e4510d138150169a2758b5ef3eb191a9ee688de3e23ef7b3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "elf-cleaner"
version = "0.0.0"
dependencies = [
 "anyhow",
 "object",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "flate2"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "11faaf5a5236997af9848be0bef4db95824b1d534ebc64d0f0c6cf3e67bd38dc"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "hashbrown"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289"
dependencies = [
 "foldhash",
]

[[package]]
name = "indexmap"
version = "2.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3954d50fe15b02142bf25d3b8bdadb634ec3948f103d04ffe3031bc8fe9d7058"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "miniz_oxide"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e3e04debbb59698c15bacbb6d93584a8c0ca9cc3213cb423d31f760d8843ce5"
dependencies = [
 "adler2",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "crc32fast",
 "flate2",
 "hashbrown",
 "indexmap",
 "memchr",
 "ruzstd",
]

[[package]]
name = "ruzstd"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fad02996bfc73da3e301efe90b1837be9ed8f4a462b6ed410aa35d00381de89f"
dependencies = [
 "twox-hash",
]

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "twox-hash"
version = "1.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fee6b57c6a41524a810daee9286c02d7752c4253064d0b05472833a438f675"
dependencies = [
 "cfg-if",
 "static_assertions",
]

```

`tools/elf-cleaner/Cargo.toml`:

```toml
[package]
name = "elf-cleaner"
version = "0.0.0"
edition = "2024"

[dependencies]
object = { version = "0.36", features = ["build"] }
anyhow = "1.0"

[profile.release]
strip = true
lto = true
codegen-units = 1

```

`tools/elf-cleaner/src/main.rs`:

```rs
use object::build::elf::{Builder, Dynamic, SectionData};
use object::elf;
use std::{env, fs};

// Implementation adapted from https://github.com/termux/termux-elf-cleaner

// Missing ELF constants
const DT_AARCH64_BTI_PLT: u32 = elf::DT_LOPROC + 1;
const DT_AARCH64_PAC_PLT: u32 = elf::DT_LOPROC + 3;
const DT_AARCH64_VARIANT_PCS: u32 = elf::DT_LOPROC + 5;

const SUPPORTED_DT_FLAGS: u32 = elf::DF_1_NOW | elf::DF_1_GLOBAL;

fn print_remove_dynamic(name: &str, path: &str) {
    println!("Removing dynamic section entry {} in '{}'", name, path);
}

fn process_elf(path: &str) -> anyhow::Result<()> {
    let bytes = fs::read(path)?;
    let mut elf = Builder::read(bytes.as_slice())?;
    let is_aarch64 = elf.header.e_machine == elf::EM_AARCH64;

    elf.sections.iter_mut().for_each(|section| {
        if let SectionData::Dynamic(entries) = &mut section.data {
            // Remove unsupported entries
            entries.retain(|e| {
                let tag = e.tag();
                match tag {
                    elf::DT_RPATH => {
                        print_remove_dynamic("DT_RPATH", path);
                        return false;
                    }
                    elf::DT_RUNPATH => {
                        print_remove_dynamic("DT_RUNPATH", path);
                        return false;
                    }
                    _ => {}
                }
                if is_aarch64 {
                    match tag {
                        DT_AARCH64_BTI_PLT => {
                            print_remove_dynamic("DT_AARCH64_BTI_PLT", path);
                            return false;
                        }
                        DT_AARCH64_PAC_PLT => {
                            print_remove_dynamic("DT_AARCH64_PAC_PLT", path);
                            return false;
                        }
                        DT_AARCH64_VARIANT_PCS => {
                            print_remove_dynamic("DT_AARCH64_VARIANT_PCS", path);
                            return false;
                        }
                        _ => {}
                    }
                }
                true
            });
            // Remove unsupported flags
            for entry in entries.iter_mut() {
                if let Dynamic::Integer { tag, val } = entry {
                    if *tag == elf::DT_FLAGS_1 {
                        let new_flags = *val & SUPPORTED_DT_FLAGS as u64;
                        if new_flags != *val {
                            println!(
                                "Replacing unsupported DT_FLAGS_1 {:#x} with {:#x} in '{}'",
                                *val, new_flags, path
                            );
                            *val = new_flags;
                        }
                        break;
                    }
                }
            }
        }
    });

    let mut out_bytes = Vec::new();
    elf.write(&mut out_bytes)?;
    fs::write(path, &out_bytes)?;
    Ok(())
}

fn main() -> anyhow::Result<()> {
    env::args().skip(1).try_for_each(|s| process_elf(&s))
}

```

`tools/keys/verity.x509.pem`:

```pem
-----BEGIN CERTIFICATE-----
MIID/TCCAuWgAwIBAgIJAJcPmDkJqolJMA0GCSqGSIb3DQEBBQUAMIGUMQswCQYD
VQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4g
VmlldzEQMA4GA1UECgwHQW5kcm9pZDEQMA4GA1UECwwHQW5kcm9pZDEQMA4GA1UE
AwwHQW5kcm9pZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTAe
Fw0xNDExMDYxOTA3NDBaFw00MjAzMjQxOTA3NDBaMIGUMQswCQYDVQQGEwJVUzET
MBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEQMA4G
A1UECgwHQW5kcm9pZDEQMA4GA1UECwwHQW5kcm9pZDEQMA4GA1UEAwwHQW5kcm9p
ZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAOjreE0vTVSRenuzO9vnaWfk0eQzYab0gqpi
6xAzi6dmD+ugoEKJmbPiuE5Dwf21isZ9uhUUu0dQM46dK4ocKxMRrcnmGxydFn6o
fs3ODJMXOkv2gKXL/FdbEPdDbxzdu8z3yk+W67udM/fW7WbaQ3DO0knu+izKak/3
T41c5uoXmQ81UNtAzRGzGchNVXMmWuTGOkg6U+0I2Td7K8yvUMWhAWPPpKLtVH9r
AL5TzjYNR92izdKcz3AjRsI3CTjtpiVABGeX0TcjRSuZB7K9EK56HV+OFNS6I1NP
jdD7FIShyGlqqZdUOkAUZYanbpgeT5N7QL6uuqcGpoTOkalu6kkCAwEAAaNQME4w
HQYDVR0OBBYEFH5DM/m7oArf4O3peeKO0ZIEkrQPMB8GA1UdIwQYMBaAFH5DM/m7
oArf4O3peeKO0ZIEkrQPMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEB
AHO3NSvDE5jFvMehGGtS8BnFYdFKRIglDMc4niWSzhzOVYRH4WajxdtBWc5fx0ix
NF/+hVKVhP6AIOQa+++sk+HIi7RvioPPbhjcsVlZe7cUEGrLSSveGouQyc+j0+m6
JF84kszIl5GGNMTnx0XRPO+g8t6h5LWfnVydgZfpGRRg+WHewk1U2HlvTjIceb0N
dcoJ8WKJAFWdcuE7VIm4w+vF/DYX/A2Oyzr2+QRhmYSv1cusgAeC1tvH4ap+J1Lg
UnOu5Kh/FqPLLSwNVQp4Bu7b9QFfqK8Moj84bj88NqRGZgDyqzuTrFxn6FW7dmyA
yttuAJAEAymk1mipd9+zp38=
-----END CERTIFICATE-----

```

`tools/rustup-wrapper/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "home"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589533453244b0995c858700322199b2becb13b627df2851f64a2775d024abcf"
dependencies = [
 "windows-sys",
]

[[package]]
name = "rustup-wrapper"
version = "0.0.0"
dependencies = [
 "home",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

```

`tools/rustup-wrapper/Cargo.toml`:

```toml
[package]
name = "rustup-wrapper"
version = "0.0.0"
edition = "2024"

[dependencies]
home = "0.5"

[profile.release]
strip = true
lto = true
codegen-units = 1

```

`tools/rustup-wrapper/src/main.rs`:

```rs
use std::env;
use std::path::Path;
use std::process::{Command, Stdio};

use home::cargo_home;

/********************************
 * Why do we need this wrapper?
 ********************************
 *
 * The command `rustup component list` does not work with custom toolchains:
 * > error: toolchain 'magisk' does not support components
 *
 * However, this command is used by several IDEs to determine component
 * availability, such as clippy, rustfmt etc.
 * In this program, we use the output of the command with the nightly
 * channel if any `component` command failed.
*/

fn main() -> std::io::Result<()> {
    let exe = env::args().next().unwrap();
    let exe = Path::new(&exe).file_name().unwrap().to_str().unwrap();
    let real_exe = cargo_home()?.join("bin").join(exe);
    let argv: Vec<String> = env::args().skip(1).collect();

    if exe.starts_with("rustup") && argv.iter().any(|s| s == "component") {
        let status = Command::new(&real_exe)
            .args(&argv)
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .status()?;
        if !status.success() {
            let mut cmd = Command::new(&real_exe);
            // Hardcode to use the nightly channel
            cmd.arg("+nightly");
            // Remove any explicit channel specification
            cmd.args(argv.iter().filter(|s| !s.starts_with('+')));
            return cmd.status().map(|_| ());
        }
    }

    // Simply pass through
    Command::new(&real_exe).args(argv.iter()).status().map(|_| ())
}

```