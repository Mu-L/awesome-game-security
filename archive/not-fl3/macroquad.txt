Project Path: arc_not-fl3_macroquad_yolchw18

Source Tree:

```txt
arc_not-fl3_macroquad_yolchw18
├── Cargo.toml
├── LICENSE-APACHE
├── LICENSE-MIT
├── README.md
├── examples
│   ├── 3d.rs
│   ├── DancingScriptRegular.ttf
│   ├── OFL-1.1.txt
│   ├── arkanoid.rs
│   ├── asteroids.rs
│   ├── audio.rs
│   ├── basic_shapes.rs
│   ├── camera.rs
│   ├── camera_transformations.rs
│   ├── chess.png
│   ├── custom_material.rs
│   ├── default_font.rs
│   ├── events.rs
│   ├── exit_dialog.rs
│   ├── ferris.png
│   ├── first_person.rs
│   ├── input_keys.rs
│   ├── input_touch.rs
│   ├── letterbox.rs
│   ├── life.rs
│   ├── logs.rs
│   ├── map.json
│   ├── particles_example.rs
│   ├── particles_single_emitter.rs
│   ├── platformer.rs
│   ├── post_processing.rs
│   ├── raw_miniquad.rs
│   ├── rust.png
│   ├── rustacean_happy.png
│   ├── rustaceanmark.rs
│   ├── screen_texture.rs
│   ├── shadertoy.rs
│   ├── smoke_fire.png
│   ├── snake.rs
│   ├── sound.wav
│   ├── sound2.wav
│   ├── text.rs
│   ├── text_measures.rs
│   ├── text_wrap.rs
│   ├── texture.rs
│   ├── tileset.png
│   ├── tree.rs
│   ├── ui.rs
│   ├── ui_assets
│   │   ├── HTOWERT.TTF
│   │   ├── MinimalPixel v2.ttf
│   │   ├── button_background.png
│   │   ├── button_background_2.png
│   │   ├── button_clicked_background.png
│   │   ├── button_clicked_background_2.png
│   │   ├── button_hovered_background.png
│   │   ├── button_hovered_background_2.png
│   │   ├── checkbox_background.png
│   │   ├── checkbox_background_selected.png
│   │   ├── checkbox_clicked_background.png
│   │   ├── checkbox_hovered_background.png
│   │   ├── combobox_background.png
│   │   ├── editbox_background.png
│   │   ├── window.png
│   │   ├── window_background.png
│   │   └── window_background_2.png
│   ├── ui_skins.rs
│   └── window_conf.rs
├── js
│   ├── README.md
│   └── mq_js_bundle.js
├── macroquad_macro
│   ├── Cargo.toml
│   ├── LICENSE-APACHE
│   ├── LICENSE-MIT
│   ├── README.md
│   └── src
│       └── lib.rs
├── particles
│   ├── Cargo.toml
│   └── src
│       ├── lib.rs
│       └── particles.glsl
├── physics-platformer
│   ├── Cargo.toml
│   ├── README.md
│   └── src
│       └── lib.rs
├── profiler
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── src
│   ├── ProggyClean.ttf
│   ├── audio.rs
│   ├── camera.rs
│   ├── color.rs
│   ├── error.rs
│   ├── exec.rs
│   ├── experimental
│   │   ├── animation.rs
│   │   ├── camera
│   │   │   └── mouse.rs
│   │   ├── camera.rs
│   │   ├── collections
│   │   │   └── storage.rs
│   │   ├── collections.rs
│   │   ├── coroutines
│   │   │   └── generational_storage.rs
│   │   ├── coroutines.rs
│   │   ├── scene
│   │   │   └── arena.rs
│   │   ├── scene.rs
│   │   └── state_machine.rs
│   ├── experimental.rs
│   ├── file.rs
│   ├── font.png
│   ├── input.rs
│   ├── lib.rs
│   ├── material.rs
│   ├── math
│   │   ├── circle.rs
│   │   └── rect.rs
│   ├── math.rs
│   ├── models.rs
│   ├── prelude.rs
│   ├── quad_gl.rs
│   ├── shapes.rs
│   ├── telemetry.rs
│   ├── text
│   │   └── atlas.rs
│   ├── text.rs
│   ├── texture
│   │   └── slotmap.rs
│   ├── texture.rs
│   ├── time.rs
│   ├── tobytes.rs
│   ├── ui
│   │   ├── canvas.rs
│   │   ├── clipboard.rs
│   │   ├── combobox.img
│   │   ├── cursor.rs
│   │   ├── draw_list.rs
│   │   ├── hash.rs
│   │   ├── input.rs
│   │   ├── input_handler.rs
│   │   ├── key_repeat.rs
│   │   ├── render
│   │   │   ├── mesh_rasterizer.rs
│   │   │   └── painter.rs
│   │   ├── render.rs
│   │   ├── style.rs
│   │   ├── widgets
│   │   │   ├── button.rs
│   │   │   ├── checkbox.rs
│   │   │   ├── combobox.rs
│   │   │   ├── drag.rs
│   │   │   ├── editbox
│   │   │   │   └── text_editor.rs
│   │   │   ├── editbox.rs
│   │   │   ├── group.rs
│   │   │   ├── input.rs
│   │   │   ├── label.rs
│   │   │   ├── popup.rs
│   │   │   ├── progress_bar.rs
│   │   │   ├── separator.rs
│   │   │   ├── slider.rs
│   │   │   ├── tabbar.rs
│   │   │   ├── texture.rs
│   │   │   ├── tree_node.rs
│   │   │   └── window.rs
│   │   └── widgets.rs
│   ├── ui.rs
│   └── window.rs
├── tests
│   ├── back_to_the_future.rs
│   ├── back_to_the_future_coroutines.rs
│   ├── coroutine_pause.rs
│   └── coroutine_values.rs
└── tiled
    ├── Cargo.toml
    └── src
        ├── error.rs
        ├── lib.rs
        ├── tiled
        │   └── layer.rs
        └── tiled.rs

```

`Cargo.toml`:

```toml
[package]
name = "macroquad"
version = "0.4.14"
authors = ["not-fl3 <not.fl3@gmail.com>"]
edition = "2021"
homepage = "https://github.com/not-fl3/macroquad"
repository = "https://github.com/not-fl3/macroquad"
description = """
Simple and easy to use graphics library
"""
readme="README.md"
license = "MIT OR Apache-2.0"

[features]
audio = ["quad-snd"]
log-rs = ["log"]
glam-serde = ["glam/serde"]
default = []

[package.metadata.android]
assets = "examples/"

[profile.dev.package."*"]
opt-level = 3

[package.metadata.docs.rs]
all-features = true

[dependencies]
miniquad = { version = "=0.4.8", features = ["log-impl"] }
quad-rand = "0.2.3"
glam = { version = "0.27", features = ["scalar-math"] }
image = { version = "0.24", default-features = false, features = ["png", "tga"] }
macroquad_macro = { version = "0.1.8", path = "macroquad_macro" }
fontdue = "0.9"
backtrace = { version = "0.3.60", optional = true }
log = { version = "0.4", optional = true }
quad-snd = { version = "0.2", optional = true }

[dev-dependencies]
macroquad-particles = { path = "./particles" }
macroquad-tiled = { path = "./tiled" }
macroquad-profiler = { path = "./profiler" }
macroquad-platformer = { path = "./physics-platformer" }

# workaround to fix the examples
# this allows to use macroquad-particles in examples without two versions of macroquad
[patch.crates-io]
macroquad = { path = './' }

#quad-snd = {path = '../quad-snd'}
#miniquad = { path = '../miniquad' }
#miniquad = { git = "https://github.com/not-fl3/miniquad", branch = "msaa_render_texture" }
#quad-gl = {path = './quad-gl'}


```

`LICENSE-APACHE`:

```
                              Apache License
                        Version 2.0, January 2004
                     http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

   "License" shall mean the terms and conditions for use, reproduction,
   and distribution as defined by Sections 1 through 9 of this document.

   "Licensor" shall mean the copyright owner or entity authorized by
   the copyright owner that is granting the License.

   "Legal Entity" shall mean the union of the acting entity and all
   other entities that control, are controlled by, or are under common
   control with that entity. For the purposes of this definition,
   "control" means (i) the power, direct or indirect, to cause the
   direction or management of such entity, whether by contract or
   otherwise, or (ii) ownership of fifty percent (50%) or more of the
   outstanding shares, or (iii) beneficial ownership of such entity.

   "You" (or "Your") shall mean an individual or Legal Entity
   exercising permissions granted by this License.

   "Source" form shall mean the preferred form for making modifications,
   including but not limited to software source code, documentation
   source, and configuration files.

   "Object" form shall mean any form resulting from mechanical
   transformation or translation of a Source form, including but
   not limited to compiled object code, generated documentation,
   and conversions to other media types.

   "Work" shall mean the work of authorship, whether in Source or
   Object form, made available under the License, as indicated by a
   copyright notice that is included in or attached to the work
   (an example is provided in the Appendix below).

   "Derivative Works" shall mean any work, whether in Source or Object
   form, that is based on (or derived from) the Work and for which the
   editorial revisions, annotations, elaborations, or other modifications
   represent, as a whole, an original work of authorship. For the purposes
   of this License, Derivative Works shall not include works that remain
   separable from, or merely link (or bind by name) to the interfaces of,
   the Work and Derivative Works thereof.

   "Contribution" shall mean any work of authorship, including
   the original version of the Work and any modifications or additions
   to that Work or Derivative Works thereof, that is intentionally
   submitted to Licensor for inclusion in the Work by the copyright owner
   or by an individual or Legal Entity authorized to submit on behalf of
   the copyright owner. For the purposes of this definition, "submitted"
   means any form of electronic, verbal, or written communication sent
   to the Licensor or its representatives, including but not limited to
   communication on electronic mailing lists, source code control systems,
   and issue tracking systems that are managed by, or on behalf of, the
   Licensor for the purpose of discussing and improving the Work, but
   excluding communication that is conspicuously marked or otherwise
   designated in writing by the copyright owner as "Not a Contribution."

   "Contributor" shall mean Licensor and any individual or Legal Entity
   on behalf of whom a Contribution has been received by Licensor and
   subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   copyright license to reproduce, prepare Derivative Works of,
   publicly display, publicly perform, sublicense, and distribute the
   Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   (except as stated in this section) patent license to make, have made,
   use, offer to sell, sell, import, and otherwise transfer the Work,
   where such license applies only to those patent claims licensable
   by such Contributor that are necessarily infringed by their
   Contribution(s) alone or by combination of their Contribution(s)
   with the Work to which such Contribution(s) was submitted. If You
   institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work
   or a Contribution incorporated within the Work constitutes direct
   or contributory patent infringement, then any patent licenses
   granted to You under this License for that Work shall terminate
   as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
   Work or Derivative Works thereof in any medium, with or without
   modifications, and in Source or Object form, provided that You
   meet the following conditions:

   (a) You must give any other recipients of the Work or
       Derivative Works a copy of this License; and

   (b) You must cause any modified files to carry prominent notices
       stating that You changed the files; and

   (c) You must retain, in the Source form of any Derivative Works
       that You distribute, all copyright, patent, trademark, and
       attribution notices from the Source form of the Work,
       excluding those notices that do not pertain to any part of
       the Derivative Works; and

   (d) If the Work includes a "NOTICE" text file as part of its
       distribution, then any Derivative Works that You distribute must
       include a readable copy of the attribution notices contained
       within such NOTICE file, excluding those notices that do not
       pertain to any part of the Derivative Works, in at least one
       of the following places: within a NOTICE text file distributed
       as part of the Derivative Works; within the Source form or
       documentation, if provided along with the Derivative Works; or,
       within a display generated by the Derivative Works, if and
       wherever such third-party notices normally appear. The contents
       of the NOTICE file are for informational purposes only and
       do not modify the License. You may add Your own attribution
       notices within Derivative Works that You distribute, alongside
       or as an addendum to the NOTICE text from the Work, provided
       that such additional attribution notices cannot be construed
       as modifying the License.

   You may add Your own copyright statement to Your modifications and
   may provide additional or different license terms and conditions
   for use, reproduction, or distribution of Your modifications, or
   for any such Derivative Works as a whole, provided Your use,
   reproduction, and distribution of the Work otherwise complies with
   the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
   any Contribution intentionally submitted for inclusion in the Work
   by You to the Licensor shall be under the terms and conditions of
   this License, without any additional terms or conditions.
   Notwithstanding the above, nothing herein shall supersede or modify
   the terms of any separate license agreement you may have executed
   with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor,
   except as required for reasonable and customary use in describing the
   origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
   agreed to in writing, Licensor provides the Work (and each
   Contributor provides its Contributions) on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied, including, without limitation, any warranties or conditions
   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
   PARTICULAR PURPOSE. You are solely responsible for determining the
   appropriateness of using or redistributing the Work and assume any
   risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
   whether in tort (including negligence), contract, or otherwise,
   unless required by applicable law (such as deliberate and grossly
   negligent acts) or agreed to in writing, shall any Contributor be
   liable to You for damages, including any direct, indirect, special,
   incidental, or consequential damages of any character arising as a
   result of this License or out of the use or inability to use the
   Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all
   other commercial damages or losses), even if such Contributor
   has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
   the Work or Derivative Works thereof, You may choose to offer,
   and charge a fee for, acceptance of support, warranty, indemnity,
   or other liability obligations and/or rights consistent with this
   License. However, in accepting such obligations, You may act only
   on Your own behalf and on Your sole responsibility, not on behalf
   of any other Contributor, and only if You agree to indemnify,
   defend, and hold each Contributor harmless for any liability
   incurred by, or claims asserted against, such Contributor by reason
   of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

   To apply the Apache License to your work, attach the following
   boilerplate notice, with the fields enclosed by brackets "[]"
   replaced with your own identifying information. (Don't include
   the brackets!)  The text should be enclosed in the appropriate
   comment syntax for the file format. We also recommend that a
   file or class name and description of purpose be included on the
   same "printed page" as the copyright notice for easier
   identification within third-party archives.

Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

```

`LICENSE-MIT`:

```
MIT License

@ 2019-2021 Fedor Logachev <not.fl3@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.


```

`README.md`:

```md
# macroquad

[![Github Actions](https://github.com/not-fl3/macroquad/workflows/CI/badge.svg)](https://github.com/not-fl3/macroquad/actions?query=workflow%3A)
[![Docs](https://docs.rs/macroquad/badge.svg?version=0.4.5)](https://docs.rs/macroquad/0.4.5/macroquad/index.html)
[![Crates.io version](https://img.shields.io/crates/v/macroquad.svg)](https://crates.io/crates/macroquad)
[![Discord chat](https://img.shields.io/discord/710177966440579103.svg?label=discord%20chat)](https://discord.gg/WfEp6ut)

`macroquad` is a simple and easy to use game library for Rust programming language, heavily inspired by [raylib](https://github.com/raysan5/raylib).

## Features

* Same code for all supported platforms, no platform dependent defines required.
* Efficient 2D rendering with automatic geometry batching.
* Minimal amount of dependencies: build after `cargo clean` takes only 16s on x230(~6 years old laptop).
* Immediate mode UI library included.
* Single command deploy for both WASM and Android.

## Supported Platforms

* PC: Windows/Linux/macOS;
* HTML5;
* Android;
* IOS.

## Build Instructions

### Setting Up a Macroquad Project

Macroquad is a normal rust dependency, therefore an empty macroquad project may be created with:

```bash
# Create empty cargo project
cargo init --bin
```

Add macroquad as a dependency to Cargo.toml:
```toml

[dependencies]
macroquad = "0.4"
```

Put some macroquad code in `src/main.rs`:
```rust
use macroquad::prelude::*;

#[macroquad::main("BasicShapes")]
async fn main() {
    loop {
        clear_background(RED);

        draw_line(40.0, 40.0, 100.0, 200.0, 15.0, BLUE);
        draw_rectangle(screen_width() / 2.0 - 60.0, 100.0, 120.0, 60.0, GREEN);
        draw_circle(screen_width() - 30.0, screen_height() - 30.0, 15.0, YELLOW);

        draw_text("IT WORKS!", 20.0, 20.0, 30.0, DARKGRAY);

        next_frame().await
    }
}
```

And to run it natively:
```bash
cargo run
```

For more examples take a look at [Macroquad examples folder](https://github.com/not-fl3/macroquad/tree/master/examples)

### Linux

```bash
# ubuntu system dependencies
apt install pkg-config libx11-dev libxi-dev libgl1-mesa-dev libasound2-dev

# fedora system dependencies
dnf install libX11-devel libXi-devel mesa-libGL-devel alsa-lib-devel

# arch linux system dependencies
 pacman -S pkg-config libx11 libxi mesa-libgl alsa-lib
```

### Windows

On windows both MSVC and GNU target are supported, no additional dependencies required.

Also cross-compilation to windows from linux is supported:

```sh
rustup target add x86_64-pc-windows-gnu

cargo run --target x86_64-pc-windows-gnu
```

### WASM

```sh
rustup target add wasm32-unknown-unknown
cargo build --target wasm32-unknown-unknown
```

This will produce .wasm file in `target/debug/wasm32-unknown-unknown/CRATENAME.wasm` or in `target/release/wasm32-unknown-unknown/CRATENAME.wasm` if built with `--release`.

And then use the following .html to load it:

<details><summary>index.html</summary>

```html
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>TITLE</title>
    <style>
        html,
        body,
        canvas {
            margin: 0px;
            padding: 0px;
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: absolute;
            background: black;
            z-index: 0;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas" tabindex='1'></canvas>
    <!-- Minified and statically hosted version of https://github.com/not-fl3/macroquad/blob/master/js/mq_js_bundle.js -->
    <script src="https://not-fl3.github.io/miniquad-samples/mq_js_bundle.js"></script>
    <script>load("CRATENAME.wasm");</script> <!-- Your compiled wasm file -->
</body>

</html>
```
</details>

One of the ways to server static .wasm and .html:

```sh
cargo install basic-http-server
basic-http-server .
```

### IOS

To run on the simulator:

```
mkdir MyGame.app
cargo build --target x86_64-apple-ios --release
cp target/release/mygame MyGame.app
# only if the game have any assets
cp -r assets MyGame.app
cat > MyGame.app/Info.plist << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>CFBundleExecutable</key>
<string>mygame</string>
<key>CFBundleIdentifier</key>
<string>com.mygame</string>
<key>CFBundleName</key>
<string>mygame</string>
<key>CFBundleVersion</key>
<string>1</string>
<key>CFBundleShortVersionString</key>
<string>1.0</string>
</dict>
</plist>
EOF

xcrun simctl install booted MyGame.app/
xcrun simctl launch booted com.mygame
```

For details and instructions on provisioning for real iphone, check [https://macroquad.rs/articles/ios/](https://macroquad.rs/articles/ios/)

<details>
<summary>Tips</summary>
Adding the following snippet to your Cargo.toml ensures that all dependencies compile in release even in debug mode. In macroquad, this has the effect of making images load several times faster and your applications much more performant, while keeping compile times miraculously low.

```toml
[profile.dev.package.'*']
opt-level = 3
```
</details>

## async/await

While macroquad attempts to use as few Rust-specific concepts as possible, `.await` in all examples looks a bit scary.
Rust's `async/await` is used to solve just one problem - cross platform main loop organization.

<details>
<summary>Details</summary>


The problem: on WASM and android it's not really easy to organize the main loop like this:
```
fn main() {
    // do some initialization

    // start main loop
    loop {
        // handle input

        // update logic

        // draw frame
    }
}
```

It is fixable on Android with threads, but on web there is not way to "pause" and "resume" WASM execution, so no WASM code should block ever.
While that loop is blocking for the entire game execution!
The C++ solution for that problem: https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html

But in Rust we have async/await. Rust's `futures` are basically continuations - `future`'s stack may be stored into a variable to pause/resume execution of future's code at a later point.

async/await support in macroquad comes without any external dependencies - no runtime, no executors and futures-rs is not involved. It's just a way to preserve `main`'s stack on WASM and keep the code cross platform without any WASM-specific main loop.
</Details>

## Community

- [Quads Discord server](https://discord.gg/WfEp6ut) - a place to chat with the library's devs and other community members.
- [Awesome Quads](https://github.com/ozkriff/awesome-quads) - a curated list of links to miniquad/macroquad-related code & resources.

# Platinum sponsors

Macroquad is supported by:

[SourceGear](https://www.sourcegear.com/)

```

`examples/3d.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("3D")]
async fn main() {
    let rust_logo = load_texture("examples/rust.png").await.unwrap();
    let ferris = load_texture("examples/ferris.png").await.unwrap();

    loop {
        clear_background(LIGHTGRAY);

        // Going 3d!

        set_camera(&Camera3D {
            position: vec3(-20., 15., 0.),
            up: vec3(0., 1., 0.),
            target: vec3(0., 0., 0.),
            ..Default::default()
        });

        draw_grid(20, 1., BLACK, GRAY);

        draw_cube_wires(vec3(0., 1., -6.), vec3(2., 2., 2.), DARKGREEN);
        draw_cube_wires(vec3(0., 1., 6.), vec3(2., 2., 2.), DARKBLUE);
        draw_cube_wires(vec3(2., 1., 2.), vec3(2., 2., 2.), YELLOW);

        draw_plane(vec3(-8., 0., -8.), vec2(5., 5.), Some(&ferris), WHITE);

        draw_cube(
            vec3(-5., 1., -2.),
            vec3(2., 2., 2.),
            Some(&rust_logo),
            WHITE,
        );
        draw_cube(vec3(-5., 1., 2.), vec3(2., 2., 2.), Some(&ferris), WHITE);
        draw_cube(vec3(2., 0., -2.), vec3(0.4, 0.4, 0.4), None, BLACK);

        draw_sphere(vec3(-8., 0., 0.), 1., None, BLUE);

        // Back to screen space, render some text

        set_default_camera();
        draw_text("WELCOME TO 3D WORLD", 10.0, 20.0, 30.0, BLACK);

        next_frame().await
    }
}

```

`examples/OFL-1.1.txt`:

```txt
DancingScriptRegular.ttf is distributed under

SIL OPEN FONT LICENSE

Version 1.1 - 26 February 2007

PREAMBLE

The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded,
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS

"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting - in part or in whole - any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS

Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION

This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER

THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.

```

`examples/arkanoid.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("Arkanoid")]
async fn main() {
    const BLOCKS_W: usize = 10;
    const BLOCKS_H: usize = 10;
    const SCR_W: f32 = 20.0;
    const SCR_H: f32 = 20.0;

    let mut blocks: [[bool; BLOCKS_W]; BLOCKS_H] = [[true; BLOCKS_W]; BLOCKS_H];
    let mut ball_x = 12.;
    let mut ball_y = 7.;
    let mut dx = 3.5;
    let mut dy = -3.5;
    let mut platform_x = 10.;
    let mut stick = true;
    let platform_width = 5.;
    let platform_height = 0.2;

    // build camera with following coordinate system:
    // (0., 0)     .... (SCR_W, 0.)
    // (0., SCR_H) .... (SCR_W, SCR_H)
    set_camera(&Camera2D {
        zoom: vec2(1. / SCR_W * 2., 1. / SCR_H * 2.),
        target: vec2(SCR_W / 2., SCR_H / 2.),
        ..Default::default()
    });

    loop {
        clear_background(SKYBLUE);

        let delta = get_frame_time();

        if is_key_down(KeyCode::Right) && platform_x < SCR_W - platform_width / 2. {
            platform_x += 3.0 * delta;
        }
        if is_key_down(KeyCode::Left) && platform_x > platform_width / 2. {
            platform_x -= 3.0 * delta;
        }

        if stick == false {
            ball_x += dx * delta;
            ball_y += dy * delta;
        } else {
            let (font_size, font_scale, font_aspect) = camera_font_scale(1.);
            let text_params = TextParams {
                font_size,
                font_scale,
                font_scale_aspect: font_aspect,
                ..Default::default()
            };
            draw_text_ex(
                "Press space to start",
                SCR_W / 2. - 5.,
                SCR_H / 2.,
                text_params,
            );

            ball_x = platform_x;
            ball_y = SCR_H - 0.5;

            stick = !is_key_down(KeyCode::Space);
        }

        if ball_x <= 0. || ball_x > SCR_W {
            dx *= -1.;
        }
        if ball_y <= 0.
            || (ball_y > SCR_H - platform_height - 0.15 / 2.
                && ball_x >= platform_x - platform_width / 2.
                && ball_x <= platform_x + platform_width / 2.)
        {
            dy *= -1.;
        }
        if ball_y >= SCR_H {
            ball_y = 10.;
            dy = -dy.abs();
            stick = true;
        }

        for j in 0..BLOCKS_H {
            for i in 0..BLOCKS_W {
                if blocks[j][i] {
                    let block_w = SCR_W / BLOCKS_W as f32;
                    let block_h = 7.0 / BLOCKS_H as f32;
                    let block_x = i as f32 * block_w + 0.05;
                    let block_y = j as f32 * block_h + 0.05;

                    draw_rectangle(block_x, block_y, block_w - 0.1, block_h - 0.1, DARKBLUE);
                    if ball_x >= block_x
                        && ball_x < block_x + block_w
                        && ball_y >= block_y
                        && ball_y < block_y + block_h
                    {
                        dy *= -1.;
                        blocks[j][i] = false;
                    }
                }
            }
        }

        draw_circle(ball_x, ball_y, 0.2, RED);
        draw_rectangle(
            platform_x - platform_width / 2.,
            SCR_H - platform_height,
            platform_width,
            platform_height,
            DARKPURPLE,
        );

        next_frame().await
    }
}

```

`examples/asteroids.rs`:

```rs
use macroquad::prelude::*;

const SHIP_HEIGHT: f32 = 25.;
const SHIP_BASE: f32 = 22.;
struct Ship {
    pos: Vec2,
    rot: f32,
    vel: Vec2,
}

struct Bullet {
    pos: Vec2,
    vel: Vec2,
    shot_at: f64,
    collided: bool,
}

struct Asteroid {
    pos: Vec2,
    vel: Vec2,
    rot: f32,
    rot_speed: f32,
    size: f32,
    sides: u8,
    collided: bool,
}

fn wrap_around(v: &Vec2) -> Vec2 {
    let mut vr = Vec2::new(v.x, v.y);
    if vr.x > screen_width() {
        vr.x = 0.;
    }
    if vr.x < 0. {
        vr.x = screen_width()
    }
    if vr.y > screen_height() {
        vr.y = 0.;
    }
    if vr.y < 0. {
        vr.y = screen_height()
    }
    vr
}

#[macroquad::main("Asteroids")]
async fn main() {
    let mut ship = Ship {
        pos: Vec2::new(screen_width() / 2., screen_height() / 2.),
        rot: 0.,
        vel: Vec2::new(0., 0.),
    };

    let mut bullets = Vec::new();
    let mut last_shot = get_time();
    let mut asteroids = Vec::new();
    let mut gameover = false;

    let mut screen_center;

    loop {
        if gameover {
            clear_background(LIGHTGRAY);
            let mut text = "You Win!. Press [enter] to play again.";
            let font_size = 30.;

            if asteroids.len() > 0 {
                text = "Game Over. Press [enter] to play again.";
            }
            let text_size = measure_text(text, None, font_size as _, 1.0);
            draw_text(
                text,
                screen_width() / 2. - text_size.width / 2.,
                screen_height() / 2. - text_size.height / 2.,
                font_size,
                DARKGRAY,
            );
            if is_key_down(KeyCode::Enter) {
                ship = Ship {
                    pos: Vec2::new(screen_width() / 2., screen_height() / 2.),
                    rot: 0.,
                    vel: Vec2::new(0., 0.),
                };
                bullets = Vec::new();
                asteroids = Vec::new();
                gameover = false;
                screen_center = Vec2::new(screen_width() / 2., screen_height() / 2.);
                for _ in 0..10 {
                    asteroids.push(Asteroid {
                        pos: screen_center
                            + Vec2::new(rand::gen_range(-1., 1.), rand::gen_range(-1., 1.))
                                .normalize()
                                * screen_width().min(screen_height())
                                / 2.,
                        vel: Vec2::new(rand::gen_range(-1., 1.), rand::gen_range(-1., 1.)),
                        rot: 0.,
                        rot_speed: rand::gen_range(-2., 2.),
                        size: screen_width().min(screen_height()) / 10.,
                        sides: rand::gen_range(3, 8),
                        collided: false,
                    })
                }
            }
            next_frame().await;
            continue;
        }
        let frame_t = get_time();
        let rotation = ship.rot.to_radians();

        let mut acc = -ship.vel / 100.; // Friction

        // Forward
        if is_key_down(KeyCode::Up) {
            acc = Vec2::new(rotation.sin(), -rotation.cos()) / 3.;
        }

        // Shot
        if is_key_down(KeyCode::Space) && frame_t - last_shot > 0.5 {
            let rot_vec = Vec2::new(rotation.sin(), -rotation.cos());
            bullets.push(Bullet {
                pos: ship.pos + rot_vec * SHIP_HEIGHT / 2.,
                vel: rot_vec * 7.,
                shot_at: frame_t,
                collided: false,
            });
            last_shot = frame_t;
        }

        // Steer
        if is_key_down(KeyCode::Right) {
            ship.rot += 5.;
        } else if is_key_down(KeyCode::Left) {
            ship.rot -= 5.;
        }

        // Euler integration
        ship.vel += acc;
        if ship.vel.length() > 5. {
            ship.vel = ship.vel.normalize() * 5.;
        }
        ship.pos += ship.vel;
        ship.pos = wrap_around(&ship.pos);

        // Move each bullet
        for bullet in bullets.iter_mut() {
            bullet.pos += bullet.vel;
        }

        // Move each asteroid
        for asteroid in asteroids.iter_mut() {
            asteroid.pos += asteroid.vel;
            asteroid.pos = wrap_around(&asteroid.pos);
            asteroid.rot += asteroid.rot_speed;
        }

        // Bullet lifetime
        bullets.retain(|bullet| bullet.shot_at + 1.5 > frame_t);

        let mut new_asteroids = Vec::new();
        for asteroid in asteroids.iter_mut() {
            // Asteroid/ship collision
            if (asteroid.pos - ship.pos).length() < asteroid.size + SHIP_HEIGHT / 3. {
                gameover = true;
                break;
            }

            // Asteroid/bullet collision
            for bullet in bullets.iter_mut() {
                if (asteroid.pos - bullet.pos).length() < asteroid.size {
                    asteroid.collided = true;
                    bullet.collided = true;

                    // Break the asteroid
                    if asteroid.sides > 3 {
                        new_asteroids.push(Asteroid {
                            pos: asteroid.pos,
                            vel: Vec2::new(bullet.vel.y, -bullet.vel.x).normalize()
                                * rand::gen_range(1., 3.),
                            rot: rand::gen_range(0., 360.),
                            rot_speed: rand::gen_range(-2., 2.),
                            size: asteroid.size * 0.8,
                            sides: asteroid.sides - 1,
                            collided: false,
                        });
                        new_asteroids.push(Asteroid {
                            pos: asteroid.pos,
                            vel: Vec2::new(-bullet.vel.y, bullet.vel.x).normalize()
                                * rand::gen_range(1., 3.),
                            rot: rand::gen_range(0., 360.),
                            rot_speed: rand::gen_range(-2., 2.),
                            size: asteroid.size * 0.8,
                            sides: asteroid.sides - 1,
                            collided: false,
                        })
                    }
                    break;
                }
            }
        }

        // Remove the collided objects
        bullets.retain(|bullet| bullet.shot_at + 1.5 > frame_t && !bullet.collided);
        asteroids.retain(|asteroid| !asteroid.collided);
        asteroids.append(&mut new_asteroids);

        // You win?
        if asteroids.len() == 0 {
            gameover = true;
        }

        if gameover {
            continue;
        }

        clear_background(LIGHTGRAY);

        for bullet in bullets.iter() {
            draw_circle(bullet.pos.x, bullet.pos.y, 2., BLACK);
        }

        for asteroid in asteroids.iter() {
            draw_poly_lines(
                asteroid.pos.x,
                asteroid.pos.y,
                asteroid.sides,
                asteroid.size,
                asteroid.rot,
                2.,
                BLACK,
            )
        }

        let v1 = Vec2::new(
            ship.pos.x + rotation.sin() * SHIP_HEIGHT / 2.,
            ship.pos.y - rotation.cos() * SHIP_HEIGHT / 2.,
        );
        let v2 = Vec2::new(
            ship.pos.x - rotation.cos() * SHIP_BASE / 2. - rotation.sin() * SHIP_HEIGHT / 2.,
            ship.pos.y - rotation.sin() * SHIP_BASE / 2. + rotation.cos() * SHIP_HEIGHT / 2.,
        );
        let v3 = Vec2::new(
            ship.pos.x + rotation.cos() * SHIP_BASE / 2. - rotation.sin() * SHIP_HEIGHT / 2.,
            ship.pos.y + rotation.sin() * SHIP_BASE / 2. + rotation.cos() * SHIP_HEIGHT / 2.,
        );
        draw_triangle_lines(v1, v2, v3, 2., BLACK);

        next_frame().await
    }
}

```

`examples/audio.rs`:

```rs
use macroquad::{audio, prelude::*, ui};

#[macroquad::main("Audio")]
async fn main() {
    set_pc_assets_folder("examples");

    let sound1 = audio::load_sound("sound.wav").await.unwrap();
    let sound2 = audio::load_sound("sound2.wav").await.unwrap();

    loop {
        clear_background(LIGHTGRAY);

        if ui::root_ui().button(None, "Play sound 1") {
            warn!("play 1!");
            audio::play_sound_once(&sound1);
        }
        if ui::root_ui().button(None, "Play sound 2") {
            warn!("play 2!");
            audio::play_sound_once(&sound2);
        }
        next_frame().await
    }
}

```

`examples/basic_shapes.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("BasicShapes")]
async fn main() {
    loop {
        clear_background(LIGHTGRAY);

        draw_line(40.0, 40.0, 100.0, 200.0, 15.0, BLUE);
        draw_rectangle(screen_width() / 2.0 - 60.0, 100.0, 120.0, 60.0, GREEN);
        draw_circle(screen_width() - 30.0, screen_height() - 30.0, 15.0, YELLOW);

        draw_text("HELLO", 20.0, 20.0, 30.0, DARKGRAY);

        next_frame().await
    }
}

```

`examples/camera.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("Camera")]
async fn main() {
    loop {
        clear_background(LIGHTGRAY);

        // Render some primitives in camera space

        set_camera(&Camera2D {
            zoom: vec2(1., screen_width() / screen_height()),
            ..Default::default()
        });
        draw_line(-0.4, 0.4, -0.8, 0.9, 0.05, BLUE);
        draw_rectangle(-0.3, 0.3, 0.2, 0.2, GREEN);
        draw_circle(0., 0., 0.1, YELLOW);

        // Back to screen space, render some text

        set_default_camera();
        draw_text("HELLO", 30.0, 200.0, 30.0, BLACK);

        next_frame().await
    }
}

```

`examples/camera_transformations.rs`:

```rs
use macroquad::prelude::*;

fn short_angle_dist(a0: f32, a1: f32) -> f32 {
    let max = 360.0;
    let da = (a1 - a0) % max;
    2.0 * da % max - da
}

fn angle_lerp(a0: f32, a1: f32, t: f32) -> f32 {
    a0 + short_angle_dist(a0, a1) * t
}

fn draw_cross(x: f32, y: f32, color: Color) {
    let size = 0.1;
    let thickness = 0.005;
    draw_line(x - size, y, x + size, y, thickness, color);
    draw_line(x, y - size, x, y + size, thickness, color);
}

#[macroquad::main("Camera")]
async fn main() {
    let mut target = (0., 0.);
    let mut zoom = 1.0;
    let mut rotation = 0.0;
    let mut smooth_rotation: f32 = 0.0;
    let mut offset = (0., 0.);

    loop {
        if is_key_down(KeyCode::W) {
            target.1 -= 0.1;
        }
        if is_key_down(KeyCode::S) {
            target.1 += 0.1;
        }
        if is_key_down(KeyCode::A) {
            target.0 += 0.1;
        }
        if is_key_down(KeyCode::D) {
            target.0 -= 0.1;
        }
        if is_key_down(KeyCode::Left) {
            offset.0 -= 0.1;
        }
        if is_key_down(KeyCode::Right) {
            offset.0 += 0.1;
        }
        if is_key_down(KeyCode::Up) {
            offset.1 += 0.1;
        }
        if is_key_down(KeyCode::Down) {
            offset.1 -= 0.1;
        }
        #[cfg(not(target_arch = "wasm32"))]
        if is_key_down(KeyCode::Q) | is_key_down(KeyCode::Escape) {
            break;
        }

        match mouse_wheel() {
            (_x, y) if y != 0.0 => {
                // Normalize mouse wheel values is browser (chromium: 53, firefox: 3)
                #[cfg(target_arch = "wasm32")]
                let y = if y < 0.0 {
                    -1.0
                } else if y > 0.0 {
                    1.0
                } else {
                    0.0
                };
                if is_key_down(KeyCode::LeftControl) {
                    zoom *= 1.1f32.powf(y);
                } else {
                    rotation += 10.0 * y;
                    rotation = match rotation {
                        angle if angle >= 360.0 => angle - 360.0,
                        angle if angle < 0.0 => angle + 360.0,
                        angle => angle,
                    }
                }
            }
            _ => (),
        }

        smooth_rotation = angle_lerp(smooth_rotation, rotation, 0.1);

        clear_background(LIGHTGRAY);

        set_camera(&Camera2D {
            target: vec2(target.0, target.1),
            ..Default::default()
        });
        draw_cross(0., 0., RED);

        set_camera(&Camera2D {
            target: vec2(target.0, target.1),
            rotation: smooth_rotation,
            ..Default::default()
        });
        draw_cross(0., 0., GREEN);

        set_camera(&Camera2D {
            target: vec2(target.0, target.1),
            rotation: smooth_rotation,
            zoom: vec2(zoom, zoom * screen_width() / screen_height()),
            ..Default::default()
        });
        draw_cross(0., 0., BLUE);

        set_camera(&Camera2D {
            target: vec2(target.0, target.1),
            rotation: smooth_rotation,
            zoom: vec2(zoom, zoom * screen_width() / screen_height()),
            offset: vec2(offset.0, offset.1),
            ..Default::default()
        });

        // Render some primitives in camera space
        draw_line(-0.4, 0.4, -0.8, 0.9, 0.05, BLUE);
        draw_rectangle(-0.3, 0.3, 0.2, 0.2, GREEN);
        draw_circle(0., 0., 0.1, YELLOW);

        // Back to screen space, render some text
        set_default_camera();
        draw_text(
            format!("target (WASD keys) = ({:+.2}, {:+.2})", target.0, target.1).as_str(),
            10.0,
            10.0,
            15.0,
            BLACK,
        );
        draw_text(
            format!("rotation (mouse wheel) = {rotation} degrees").as_str(),
            10.0,
            25.0,
            15.0,
            BLACK,
        );
        draw_text(
            format!("zoom (ctrl + mouse wheel) = {zoom:.2}").as_str(),
            10.0,
            40.0,
            15.0,
            BLACK,
        );
        draw_text(
            format!("offset (arrow keys) = ({:+.2}, {:+.2})", offset.0, offset.1).as_str(),
            10.0,
            55.0,
            15.0,
            BLACK,
        );
        draw_text("HELLO", 30.0, 200.0, 30.0, BLACK);

        next_frame().await
    }
}

```

`examples/custom_material.rs`:

```rs
use macroquad::prelude::*;

use macroquad::window::miniquad::*;

const VERTEX: &str = r#"#version 100
attribute vec3 position;
attribute vec2 texcoord;

varying lowp vec2 uv;

uniform mat4 Model;
uniform mat4 Projection;

void main() {
    gl_Position = Projection * Model * vec4(position, 1);
    uv = texcoord;
}"#;

const FRAGMENT: &str = r#"#version 100
varying lowp vec2 uv;

uniform sampler2D Texture;
uniform lowp vec4 test_color;

void main() {
    gl_FragColor = test_color * texture2D(Texture, uv);
}"#;

pub const METAL: &str = r#"
#include <metal_stdlib>
using namespace metal;

struct Vertex
{
    float3 position    [[attribute(0)]];
    float2 texcoord    [[attribute(1)]];
    float4 color0      [[attribute(2)]];
};

struct RasterizerData
{
    float4 position [[position]];
    float4 color [[user(locn0)]];
    float2 uv [[user(locn1)]];
};

// Uniforms should have Model, Projection, _Time in exact order for shader to work,
// because they are laying in a single buffer
struct Uniforms
{
    float4x4 Model;
    float4x4 Projection;
    float4 _Time;

    float4 test_color;
};

vertex RasterizerData vertexShader(Vertex v [[stage_in]],
                                   constant Uniforms& u [[buffer(0)]])
{
    RasterizerData out;

    out.position = u.Projection * u.Model * float4(v.position, 1);
    out.uv = v.texcoord;

    return out;
}

fragment float4 fragmentShader(RasterizerData in [[stage_in]],
                               constant Uniforms& u [[buffer(0)]],
                               texture2d<float> Texture [[texture(0)]],
                               sampler TextureSmplr [[sampler(0)]])
{
    return u.test_color * Texture.sample(TextureSmplr, in.uv);
}"#;

const FRAGMENT_WITH_ARRAY: &str = r#"#version 100
varying lowp vec2 uv;

uniform sampler2D Texture;
uniform lowp vec4 test_color[10];

void main() {
    gl_FragColor = test_color[5] * texture2D(Texture, uv);
}"#;

pub const METAL_WITH_ARRAY: &str = r#"#include <metal_stdlib>
using namespace metal;

struct Vertex
{
    float3 position    [[attribute(0)]];
    float2 texcoord    [[attribute(1)]];
    float4 color0      [[attribute(2)]];
};

struct RasterizerData
{
    float4 position [[position]];
    float4 color [[user(locn0)]];
    float2 uv [[user(locn1)]];
};

// Uniforms should have Model, Projection, _Time for material shaders to work
struct Uniforms
{
    float4x4 Model;
    float4x4 Projection;
    float4 _Time;

    float4 test_color[10];
};

vertex RasterizerData vertexShader(Vertex v [[stage_in]],
                                   constant Uniforms& u [[buffer(0)]])
{
    RasterizerData out;

    out.position = u.Projection * u.Model * float4(v.position, 1);
    out.uv = v.texcoord;

    return out;
}

fragment float4 fragmentShader(RasterizerData in [[stage_in]],
                               constant Uniforms& u [[buffer(0)]],
                               texture2d<float> Texture [[texture(0)]],
                               sampler TextureSmplr [[sampler(0)]])
{
    return u.test_color[5] * Texture.sample(TextureSmplr, in.uv);
}"#;

fn window_conf() -> Conf {
    let metal = std::env::args().nth(1).as_deref() == Some("metal");
    let apple_gfx_api = if metal {
        conf::AppleGfxApi::Metal
    } else {
        conf::AppleGfxApi::OpenGl
    };
    Conf {
        window_title: "Shaders".to_owned(),
        platform: conf::Platform {
            apple_gfx_api,
            ..Default::default()
        },
        ..Default::default()
    }
}

#[macroquad::main(window_conf)]
async fn main() {
    let pipeline_params = PipelineParams {
        color_blend: Some(BlendState::new(
            Equation::Add,
            BlendFactor::Value(BlendValue::SourceAlpha),
            BlendFactor::OneMinusValue(BlendValue::SourceAlpha),
        )),
        ..Default::default()
    };

    let ctx = unsafe { get_internal_gl().quad_context };
    let mat = load_material(
        match ctx.info().backend {
            Backend::OpenGl => ShaderSource::Glsl {
                vertex: VERTEX,
                fragment: FRAGMENT,
            },
            Backend::Metal => ShaderSource::Msl { program: METAL },
        },
        MaterialParams {
            uniforms: vec![UniformDesc::new("test_color", UniformType::Float4)],
            pipeline_params,
            ..Default::default()
        },
    )
    .unwrap();

    let mat_with_array = load_material(
        match ctx.info().backend {
            Backend::OpenGl => ShaderSource::Glsl {
                vertex: VERTEX,
                fragment: FRAGMENT_WITH_ARRAY,
            },
            Backend::Metal => ShaderSource::Msl {
                program: METAL_WITH_ARRAY,
            },
        },
        MaterialParams {
            uniforms: vec![UniformDesc::array(
                UniformDesc::new("test_color", UniformType::Float4),
                10,
            )],
            pipeline_params,
            ..Default::default()
        },
    )
    .unwrap();

    loop {
        clear_background(GRAY);

        gl_use_material(&mat);

        mat.set_uniform("test_color", vec4(1., 0., 0., 1.));

        draw_rectangle(50.0, 50.0, 100., 100., WHITE);

        mat.set_uniform("test_color", vec4(0., 1., 0., 1.));
        draw_rectangle(160.0, 50.0, 100., 100., WHITE);

        mat.set_uniform("test_color", vec4(0., 0., 1., 1.));
        draw_rectangle(270.0, 50.0, 100., 100., WHITE);

        gl_use_material(&mat_with_array);
        let mut colors: [Vec4; 10] = [vec4(0.0, 1.0, 0.0, 0.0); 10];
        colors[5] = vec4(0.0, 1.0, 1.0, 1.0);
        mat_with_array.set_uniform_array("test_color", &colors[..]);
        draw_rectangle(50.0, 160.0, 100., 100., WHITE);

        gl_use_default_material();

        draw_rectangle(380.0, 50.0, 100., 100., YELLOW);

        next_frame().await
    }
}

```

`examples/default_font.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("DefaultFont")]
async fn main() {
    let font = load_ttf_font("./examples/DancingScriptRegular.ttf")
        .await
        .unwrap();
    set_default_font(font);

    loop {
        clear_background(WHITE);

        draw_text(
            "Hello world in a new default font!",
            100.0,
            100.0,
            40.0,
            BLACK,
        );

        draw_text_ex(
            "And with extra formatting options",
            100.0,
            230.0,
            TextParams {
                font_size: 45,
                color: RED,
                rotation: 0.27,
                ..Default::default()
            },
        );

        next_frame().await;
    }
}

```

`examples/events.rs`:

```rs
use macroquad::ui::{hash, root_ui, widgets};

use macroquad::prelude::*;

#[macroquad::main("Events")]
async fn main() {
    loop {
        clear_background(WHITE);
        root_ui().window(hash!(), Vec2::new(20., 20.), Vec2::new(450., 200.), |ui| {
            let (mouse_x, mouse_y) = mouse_position();
            ui.label(None, &format!("Mouse position: {mouse_x} {mouse_y}"));

            let (mouse_wheel_x, mouse_wheel_y) = mouse_wheel();
            ui.label(None, &format!("Mouse wheel x: {mouse_wheel_x}"));
            ui.label(None, &format!("Mouse wheel y: {mouse_wheel_y}"));

            widgets::Group::new(hash!(), Vec2::new(200., 90.))
                .position(Vec2::new(240., 0.))
                .ui(ui, |ui| {
                    ui.label(None, "Pressed kbd keys");

                    if let Some(key) = get_last_key_pressed() {
                        ui.label(None, &format!("{key:?}"))
                    }
                });

            widgets::Group::new(hash!(), Vec2::new(200., 90.))
                .position(Vec2::new(240., 92.))
                .ui(ui, |ui| {
                    ui.label(None, "Pressed mouse keys");

                    if is_mouse_button_down(MouseButton::Left) {
                        ui.label(None, "Left");
                    }
                    if is_mouse_button_down(MouseButton::Right) {
                        ui.label(None, "Right");
                    }
                    if is_mouse_button_down(MouseButton::Middle) {
                        ui.label(None, "Middle");
                    }
                });
        });
        next_frame().await;
    }
}

```

`examples/exit_dialog.rs`:

```rs
use macroquad::prelude::*;
use macroquad::ui::{hash, root_ui, widgets::Window};

#[macroquad::main("Exit dialog")]
async fn main() {
    prevent_quit();

    let mut show_exit_dialog = false;
    let mut user_decided_to_exit = false;

    loop {
        clear_background(GRAY);

        if is_quit_requested() {
            show_exit_dialog = true;
        }

        if show_exit_dialog {
            let dialog_size = vec2(200., 70.);
            let screen_size = vec2(screen_width(), screen_height());
            let dialog_position = screen_size / 2. - dialog_size / 2.;
            Window::new(hash!(), dialog_position, dialog_size).ui(&mut *root_ui(), |ui| {
                ui.label(None, "Do you really want to quit?");
                ui.separator();
                ui.same_line(60.);
                if ui.button(None, "Yes") {
                    user_decided_to_exit = true;
                }
                ui.same_line(120.);
                if ui.button(None, "No") {
                    show_exit_dialog = false;
                }
            });
        }

        if user_decided_to_exit {
            break;
        }

        next_frame().await
    }
}

```

`examples/first_person.rs`:

```rs
use macroquad::prelude::*;
// use glam::vec3;

const MOVE_SPEED: f32 = 0.1;
const LOOK_SPEED: f32 = 0.1;

fn conf() -> Conf {
    Conf {
        window_title: String::from("Macroquad"),
        window_width: 1260,
        window_height: 768,
        fullscreen: false,
        ..Default::default()
    }
}

#[macroquad::main(conf)]
async fn main() {
    let mut x = 0.0;
    let mut switch = false;
    let bounds = 8.0;

    let world_up = vec3(0.0, 1.0, 0.0);
    let mut yaw: f32 = 1.18;
    let mut pitch: f32 = 0.0;

    let mut front = vec3(
        yaw.cos() * pitch.cos(),
        pitch.sin(),
        yaw.sin() * pitch.cos(),
    )
    .normalize();
    let mut right = front.cross(world_up).normalize();
    let mut up = right.cross(front).normalize();

    let mut position = vec3(0.0, 1.0, 0.0);
    let mut last_mouse_position: Vec2 = mouse_position().into();

    let mut grabbed = true;
    set_cursor_grab(grabbed);
    show_mouse(false);

    loop {
        let delta = get_frame_time();

        if is_key_pressed(KeyCode::Escape) {
            break;
        }
        if is_key_pressed(KeyCode::Tab) {
            grabbed = !grabbed;
            set_cursor_grab(grabbed);
            show_mouse(!grabbed);
        }

        if is_key_down(KeyCode::Up) {
            position += front * MOVE_SPEED;
        }
        if is_key_down(KeyCode::Down) {
            position -= front * MOVE_SPEED;
        }
        if is_key_down(KeyCode::Left) {
            position -= right * MOVE_SPEED;
        }
        if is_key_down(KeyCode::Right) {
            position += right * MOVE_SPEED;
        }

        let mouse_position: Vec2 = mouse_position().into();
        let mouse_delta = mouse_position - last_mouse_position;

        last_mouse_position = mouse_position;

        if grabbed {
            yaw += mouse_delta.x * delta * LOOK_SPEED;
            pitch += mouse_delta.y * delta * -LOOK_SPEED;

            pitch = if pitch > 1.5 { 1.5 } else { pitch };
            pitch = if pitch < -1.5 { -1.5 } else { pitch };

            front = vec3(
                yaw.cos() * pitch.cos(),
                pitch.sin(),
                yaw.sin() * pitch.cos(),
            )
            .normalize();

            right = front.cross(world_up).normalize();
            up = right.cross(front).normalize();

            x += if switch { 0.04 } else { -0.04 };
            if x >= bounds || x <= -bounds {
                switch = !switch;
            }
        }

        clear_background(LIGHTGRAY);

        // Going 3d!

        set_camera(&Camera3D {
            position: position,
            up: up,
            target: position + front,
            ..Default::default()
        });

        draw_grid(20, 1., BLACK, GRAY);

        draw_line_3d(
            vec3(x, 0.0, x),
            vec3(5.0, 5.0, 5.0),
            Color::new(1.0, 1.0, 0.0, 1.0),
        );

        draw_cube_wires(vec3(0., 1., -6.), vec3(2., 2., 2.), GREEN);
        draw_cube_wires(vec3(0., 1., 6.), vec3(2., 2., 2.), BLUE);
        draw_cube_wires(vec3(2., 1., 2.), vec3(2., 2., 2.), RED);

        // Back to screen space, render some text

        set_default_camera();
        draw_text("First Person Camera", 10.0, 20.0, 30.0, BLACK);

        draw_text(
            format!("X: {} Y: {}", mouse_position.x, mouse_position.y).as_str(),
            10.0,
            48.0 + 18.0,
            30.0,
            BLACK,
        );
        draw_text(
            format!("Press <TAB> to toggle mouse grab: {grabbed}").as_str(),
            10.0,
            48.0 + 42.0,
            30.0,
            BLACK,
        );

        next_frame().await
    }
}

```

`examples/input_keys.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("InputKeys")]
async fn main() {
    let mut x = screen_width() / 2.0;
    let mut y = screen_height() / 2.0;

    loop {
        clear_background(LIGHTGRAY);

        if is_key_down(KeyCode::Right) {
            x += 1.0;
        }
        if is_key_down(KeyCode::Left) {
            x -= 1.0;
        }
        if is_key_down(KeyCode::Down) {
            y += 1.0;
        }
        if is_key_down(KeyCode::Up) {
            y -= 1.0;
        }

        draw_circle(x, y, 15.0, YELLOW);
        draw_text("move the ball with arrow keys", 20.0, 20.0, 20.0, DARKGRAY);
        next_frame().await
    }
}

```

`examples/input_touch.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("InputTouch")]
async fn main() {
    loop {
        clear_background(LIGHTGRAY);

        for touch in touches() {
            let (fill_color, size) = match touch.phase {
                TouchPhase::Started => (GREEN, 80.0),
                TouchPhase::Stationary => (WHITE, 60.0),
                TouchPhase::Moved => (YELLOW, 60.0),
                TouchPhase::Ended => (BLUE, 80.0),
                TouchPhase::Cancelled => (BLACK, 80.0),
            };
            draw_circle(touch.position.x, touch.position.y, size, fill_color);
        }

        draw_text("touch the screen!", 20.0, 20.0, 20.0, DARKGRAY);
        next_frame().await
    }
}

```

`examples/letterbox.rs`:

```rs
use macroquad::prelude::*;

const VIRTUAL_WIDTH: f32 = 1280.0;
const VIRTUAL_HEIGHT: f32 = 720.0;

#[macroquad::main("Letterbox")]
async fn main() {
    // Setup 'render_target', used to hold the rendering result so we can resize it
    let render_target = render_target(VIRTUAL_WIDTH as u32, VIRTUAL_HEIGHT as u32);
    render_target.texture.set_filter(FilterMode::Linear);

    // Setup camera for the virtual screen, that will render to 'render_target'
    let mut render_target_cam =
        Camera2D::from_display_rect(Rect::new(0., 0., VIRTUAL_WIDTH, VIRTUAL_HEIGHT));
    render_target_cam.render_target = Some(render_target.clone());

    loop {
        // Get required scaling value
        let scale: f32 = f32::min(
            screen_width() / VIRTUAL_WIDTH,
            screen_height() / VIRTUAL_HEIGHT,
        );

        // Mouse position in the virtual screen
        let virtual_mouse_pos = Vec2 {
            x: (mouse_position().0 - (screen_width() - (VIRTUAL_WIDTH * scale)) * 0.5) / scale,
            y: (mouse_position().1 - (screen_height() - (VIRTUAL_HEIGHT * scale)) * 0.5) / scale,
        };

        // ------------------------------------------------------------------------
        // Begin drawing the virtual screen to 'render_target'
        // ------------------------------------------------------------------------
        set_camera(&render_target_cam);

        clear_background(LIGHTGRAY);

        draw_text("Hello Letterbox", 20.0, 20.0, 30.0, DARKGRAY);
        draw_circle(VIRTUAL_WIDTH / 2.0 - 65.0, VIRTUAL_HEIGHT / 2.0, 35.0, RED);
        draw_circle(VIRTUAL_WIDTH / 2.0 + 65.0, VIRTUAL_HEIGHT / 2.0, 35.0, BLUE);
        draw_circle(
            VIRTUAL_WIDTH / 2.0,
            VIRTUAL_HEIGHT / 2.0 - 65.0,
            35.0,
            YELLOW,
        );

        draw_circle(virtual_mouse_pos.x, virtual_mouse_pos.y, 15.0, BLACK);

        // ------------------------------------------------------------------------
        // Begin drawing the window screen
        // ------------------------------------------------------------------------
        set_default_camera();

        clear_background(BLACK); // Will be the letterbox color

        // Draw 'render_target' to window screen, porperly scaled and letterboxed
        draw_texture_ex(
            &render_target.texture,
            (screen_width() - (VIRTUAL_WIDTH * scale)) * 0.5,
            (screen_height() - (VIRTUAL_HEIGHT * scale)) * 0.5,
            WHITE,
            DrawTextureParams {
                dest_size: Some(vec2(VIRTUAL_WIDTH * scale, VIRTUAL_HEIGHT * scale)),
                flip_y: true, // Must flip y otherwise 'render_target' will be upside down
                ..Default::default()
            },
        );

        next_frame().await;
    }
}

```

`examples/life.rs`:

```rs
use macroquad::prelude::*;

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
enum CellState {
    Alive,
    Dead,
}

#[macroquad::main("Life")]
async fn main() {
    let w = screen_width() as usize;
    let h = screen_height() as usize;

    let mut cells = vec![CellState::Dead; w * h];
    let mut buffer = vec![CellState::Dead; w * h];

    let mut image = Image::gen_image_color(w as u16, h as u16, WHITE);

    for cell in cells.iter_mut() {
        if rand::gen_range(0, 5) == 0 {
            *cell = CellState::Alive;
        }
    }
    let texture = Texture2D::from_image(&image);

    loop {
        clear_background(WHITE);

        let w = image.width();
        let h = image.height();

        for y in 0..h as i32 {
            for x in 0..w as i32 {
                let mut neighbors_count = 0;

                for j in -1i32..=1 {
                    for i in -1i32..=1 {
                        // out of bounds
                        if y + j < 0 || y + j >= h as i32 || x + i < 0 || x + i >= w as i32 {
                            continue;
                        }
                        // cell itself
                        if i == 0 && j == 0 {
                            continue;
                        }

                        let neighbor = cells[(y + j) as usize * w + (x + i) as usize];
                        if neighbor == CellState::Alive {
                            neighbors_count += 1;
                        }
                    }
                }

                let current_cell = cells[y as usize * w + x as usize];
                buffer[y as usize * w + x as usize] = match (current_cell, neighbors_count) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (CellState::Alive, x) if x < 2 => CellState::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (CellState::Alive, 2) | (CellState::Alive, 3) => CellState::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (CellState::Alive, x) if x > 3 => CellState::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (CellState::Dead, 3) => CellState::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) => otherwise,
                };
            }
        }

        for i in 0..buffer.len() {
            cells[i] = buffer[i];

            image.set_pixel(
                (i % w) as u32,
                (i / w) as u32,
                match buffer[i as usize] {
                    CellState::Alive => BLACK,
                    CellState::Dead => WHITE,
                },
            );
        }

        texture.update(&image);

        draw_texture(&texture, 0., 0., WHITE);

        next_frame().await
    }
}

```

`examples/logs.rs`:

```rs
//! Macroquad expose all the logging macros.
//! They will use browser console, android console or just stdout depending on the platform.
//! Those macros are the recommended way to output debug traces and logs.

use macroquad::prelude::*;

#[macroquad::main("Logs")]
async fn main() {
    debug!("This is a debug message");
    info!("and info message");
    error!("and errors, the red ones!");
    warn!("Or warnings, the yellow ones.");

    loop {
        clear_background(LIGHTGRAY);

        debug!("Still alive!");

        next_frame().await
    }
}

```

`examples/map.json`:

```json
{ "compressionlevel":-1,
 "editorsettings":
    {
     "export":
        {
         "target":"."
        }
    },
 "height":19,
 "infinite":false,
 "layers":[
        {
         "data":[4, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 5, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 25, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 25, 22, 22, 22, 23, 0, 0, 1, 2, 2, 2, 2, 2, 2, 25, 22, 22, 24, 2, 2, 2, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 22, 22, 22, 22, 22, 24, 2, 2, 25, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 24, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 25, 22, 22, 22, 22, 22],
         "height":19,
         "id":1,
         "name":"main layer",
         "opacity":1,
         "type":"tilelayer",
         "visible":true,
         "width":40,
         "x":0,
         "y":0
        }],
 "nextlayerid":2,
 "nextobjectid":1,
 "orientation":"orthogonal",
 "renderorder":"right-down",
 "tiledversion":"1.7.0",
 "tileheight":8,
 "tilesets":[
        {
         "columns":20,
         "firstgid":1,
         "image":"tileset.png",
         "imageheight":160,
         "imagewidth":160,
         "margin":0,
         "name":"tileset",
         "spacing":0,
         "tilecount":400,
         "tileheight":8,
         "tiles":[
                {
                 "id":0,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":1,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":2,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":3,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":4,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":6,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":7,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":8,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":9,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":20,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":21,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":22,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":23,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":24,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":40,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":41,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }, 
                {
                 "id":42,
                 "properties":[
                        {
                         "name":"collider",
                         "type":"string",
                         "value":""
                        }]
                }],
         "tilewidth":8
        }],
 "tilewidth":8,
 "type":"map",
 "version":"1.6",
 "width":40
}

```

`examples/particles_example.rs`:

```rs
use macroquad::prelude::*;
use macroquad_particles::{self as particles, AtlasConfig, BlendMode, Emitter, EmitterConfig};

fn explosion() -> particles::EmitterConfig {
    particles::EmitterConfig {
        one_shot: true,
        emitting: false,
        lifetime: 0.3,
        lifetime_randomness: 0.7,
        explosiveness: 0.95,
        amount: 30,
        initial_direction_spread: 2.0 * std::f32::consts::PI,
        initial_velocity: 200.0,
        size: 30.0,
        gravity: vec2(0.0, -1000.0),
        atlas: Some(AtlasConfig::new(4, 4, 8..)),
        blend_mode: BlendMode::Additive,
        ..Default::default()
    }
}

fn smoke() -> particles::EmitterConfig {
    particles::EmitterConfig {
        lifetime: 0.8,
        amount: 20,
        initial_direction_spread: 0.2,
        atlas: Some(AtlasConfig::new(4, 4, 0..8)),
        ..Default::default()
    }
}

fn fire() -> particles::EmitterConfig {
    particles::EmitterConfig {
        lifetime: 0.4,
        lifetime_randomness: 0.1,
        amount: 10,
        initial_direction_spread: 0.5,
        initial_velocity: 300.0,
        atlas: Some(AtlasConfig::new(4, 4, 8..)),
        size: 20.0,
        blend_mode: BlendMode::Additive,
        ..Default::default()
    }
}

#[macroquad::main("Fountain")]
async fn main() {
    let texture = load_texture("examples/smoke_fire.png").await.unwrap();

    let mut one_shot_emitter = particles::Emitter::new(EmitterConfig {
        texture: Some(texture.clone()),
        ..explosion()
    });

    let mut flying_emitter_local = Emitter::new(EmitterConfig {
        local_coords: true,
        texture: Some(texture.clone()),
        ..smoke()
    });
    let mut flying_emitter_world = Emitter::new(EmitterConfig {
        local_coords: false,
        texture: Some(texture.clone()),
        ..fire()
    });

    loop {
        clear_background(BLACK);

        draw_text("Local coord emitter", 20.0, 30.0, 30.0, RED);

        draw_text("World coord emitter", 20.0, 60.0, 30.0, GREEN);

        draw_text(
            "One shot emitter, press Space to emit",
            20.0,
            90.0,
            30.0,
            YELLOW,
        );
        one_shot_emitter.draw(vec2(650.0, 82.0));
        draw_circle(650.0, 82.0, 15.0, YELLOW);

        if is_key_pressed(KeyCode::Space) {
            one_shot_emitter.config.emitting = true;
        }

        let local_emitter_pos = vec2(
            (get_time() * 0.3).sin() as f32 * screen_width() / 2.5 + screen_width() / 2.0,
            (get_time() * 0.5).cos() as f32 * screen_height() / 2.5 + screen_height() / 2.0,
        );
        flying_emitter_local.draw(local_emitter_pos);
        draw_circle(local_emitter_pos.x, local_emitter_pos.y, 15.0, RED);

        let world_emitter_pos = vec2(
            (get_time() * 0.6 + 1.0).sin() as f32 * screen_width() / 2.5 + screen_width() / 2.0,
            (get_time() * 0.4 + 1.0).cos() as f32 * screen_height() / 2.5 + screen_height() / 2.0,
        );

        flying_emitter_world.draw(world_emitter_pos);
        draw_circle(world_emitter_pos.x, world_emitter_pos.y, 15.0, GREEN);

        next_frame().await
    }
}

```

`examples/particles_single_emitter.rs`:

```rs
use macroquad::prelude::*;

use macroquad_particles::{BlendMode, Curve, Emitter, EmitterConfig};

#[macroquad::main("Fountain")]
async fn main() {
    let mut emitter = Emitter::new(EmitterConfig {
        lifetime: 0.5,
        amount: 5,
        initial_direction_spread: 0.0,
        initial_velocity: -50.0,
        size: 2.0,
        size_curve: Some(Curve {
            points: vec![(0.0, 0.5), (0.5, 1.0), (1.0, 0.0)],
            ..Default::default()
        }),

        blend_mode: BlendMode::Additive,
        ..Default::default()
    });

    loop {
        clear_background(BLACK);

        let camera = Camera2D::from_display_rect(Rect::new(0.0, 0.0, 100.0, 100.0));

        set_camera(&camera);

        emitter.draw(vec2(50., 50.));

        next_frame().await
    }
}

```

`examples/platformer.rs`:

```rs
use macroquad::prelude::*;

use macroquad_tiled as tiled;

use macroquad_platformer::*;

struct Player {
    collider: Actor,
    speed: Vec2,
}

struct Platform {
    collider: Solid,
    speed: f32,
}

#[macroquad::main("Platformer")]
async fn main() {
    let tileset = load_texture("examples/tileset.png").await.unwrap();
    tileset.set_filter(FilterMode::Nearest);

    let tiled_map_json = load_string("examples/map.json").await.unwrap();
    let tiled_map = tiled::load_map(&tiled_map_json, &[("tileset.png", tileset)], &[]).unwrap();

    let mut static_colliders = vec![];
    for (_x, _y, tile) in tiled_map.tiles("main layer", None) {
        static_colliders.push(if tile.is_some() {
            Tile::Solid
        } else {
            Tile::Empty
        });
    }

    let mut world = World::new();
    world.add_static_tiled_layer(static_colliders, 8., 8., 40, 1);

    let mut player = Player {
        collider: world.add_actor(vec2(50.0, 80.0), 8, 8),
        speed: vec2(0., 0.),
    };

    let mut platform = Platform {
        collider: world.add_solid(vec2(170.0, 130.0), 32, 8),
        speed: 50.,
    };

    let camera = Camera2D::from_display_rect(Rect::new(0.0, 152.0, 320.0, -152.0));

    loop {
        clear_background(BLACK);

        set_camera(&camera);

        tiled_map.draw_tiles("main layer", Rect::new(0.0, 0.0, 320.0, 152.0), None);

        // draw platform
        {
            let pos = world.solid_pos(platform.collider);
            tiled_map.spr_ex(
                "tileset",
                Rect::new(6.0 * 8.0, 0.0, 32.0, 8.0),
                Rect::new(pos.x, pos.y, 32.0, 8.0),
            )
        }

        // draw player
        {
            // sprite id from tiled
            const PLAYER_SPRITE: u32 = 120;

            let pos = world.actor_pos(player.collider);
            if player.speed.x >= 0.0 {
                tiled_map.spr("tileset", PLAYER_SPRITE, Rect::new(pos.x, pos.y, 8.0, 8.0));
            } else {
                tiled_map.spr(
                    "tileset",
                    PLAYER_SPRITE,
                    Rect::new(pos.x + 8.0, pos.y, -8.0, 8.0),
                );
            }
        }

        // player movement control
        {
            let pos = world.actor_pos(player.collider);
            let on_ground = world.collide_check(player.collider, pos + vec2(0., 1.));

            if on_ground == false {
                player.speed.y += 500. * get_frame_time();
            }

            if is_key_down(KeyCode::Right) {
                player.speed.x = 100.0;
            } else if is_key_down(KeyCode::Left) {
                player.speed.x = -100.0;
            } else {
                player.speed.x = 0.;
            }

            if is_key_pressed(KeyCode::Space) {
                if on_ground {
                    player.speed.y = -120.;
                }
            }

            world.move_h(player.collider, player.speed.x * get_frame_time());
            world.move_v(player.collider, player.speed.y * get_frame_time());
        }

        // platform movement
        {
            world.solid_move(platform.collider, platform.speed * get_frame_time(), 0.0);
            let pos = world.solid_pos(platform.collider);
            if platform.speed > 1. && pos.x >= 220. {
                platform.speed *= -1.;
            }
            if platform.speed < -1. && pos.x <= 150. {
                platform.speed *= -1.;
            }
        }

        next_frame().await
    }
}

```

`examples/post_processing.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("Post processing")]
async fn main() {
    let render_target = render_target(320, 150);
    render_target.texture.set_filter(FilterMode::Nearest);

    let material = load_material(
        ShaderSource::Glsl {
            vertex: CRT_VERTEX_SHADER,
            fragment: CRT_FRAGMENT_SHADER,
        },
        Default::default(),
    )
    .unwrap();

    loop {
        // drawing to the texture

        // 0..100, 0..100 camera
        set_camera(&Camera2D {
            zoom: vec2(0.01, 0.01),
            target: vec2(0.0, 0.0),
            render_target: Some(render_target.clone()),
            ..Default::default()
        });

        clear_background(LIGHTGRAY);
        draw_line(-30.0, 45.0, 30.0, 45.0, 3.0, BLUE);
        draw_circle(-45.0, -35.0, 20.0, YELLOW);
        draw_circle(45.0, -35.0, 20.0, GREEN);

        // drawing to the screen

        set_default_camera();

        clear_background(WHITE);
        gl_use_material(&material);
        draw_texture_ex(
            &render_target.texture,
            0.,
            0.,
            WHITE,
            DrawTextureParams {
                dest_size: Some(vec2(screen_width(), screen_height())),
                ..Default::default()
            },
        );
        gl_use_default_material();

        next_frame().await;
    }
}

const CRT_FRAGMENT_SHADER: &'static str = r#"#version 100
precision lowp float;

varying vec4 color;
varying vec2 uv;

uniform sampler2D Texture;

// https://www.shadertoy.com/view/XtlSD7

vec2 CRTCurveUV(vec2 uv)
{
    uv = uv * 2.0 - 1.0;
    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );
    uv = uv + uv * offset * offset;
    uv = uv * 0.5 + 0.5;
    return uv;
}

void DrawVignette( inout vec3 color, vec2 uv )
{
    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );
    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );
    color *= vignette;
}


void DrawScanline( inout vec3 color, vec2 uv )
{
    float iTime = 0.1;
    float scanline 	= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );
    float grille 	= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );
    color *= scanline * grille * 1.2;
}

void main() {
    vec2 crtUV = CRTCurveUV(uv);
    vec3 res = texture2D(Texture, uv).rgb * color.rgb;
    if (crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0)
    {
        res = vec3(0.0, 0.0, 0.0);
    }
    DrawVignette(res, crtUV);
    DrawScanline(res, uv);
    gl_FragColor = vec4(res, 1.0);

}
"#;

const CRT_VERTEX_SHADER: &'static str = "#version 100
attribute vec3 position;
attribute vec2 texcoord;
attribute vec4 color0;

varying lowp vec2 uv;
varying lowp vec4 color;

uniform mat4 Model;
uniform mat4 Projection;

void main() {
    gl_Position = Projection * Model * vec4(position, 1);
    color = color0 / 255.0;
    uv = texcoord;
}
";

```

`examples/raw_miniquad.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("Raw miniquad")]
async fn main() {
    let stage = {
        let InternalGlContext {
            quad_context: ctx, ..
        } = unsafe { get_internal_gl() };

        raw_miniquad::Stage::new(ctx)
    };

    loop {
        clear_background(LIGHTGRAY);

        // Render some primitives in camera space

        set_camera(&Camera2D {
            zoom: vec2(1., screen_width() / screen_height()),
            ..Default::default()
        });
        draw_line(-0.4, 0.4, -0.8, 0.9, 0.05, BLUE);
        draw_rectangle(-0.3, 0.3, 0.2, 0.2, GREEN);
        draw_circle(0., 0., 0.1, YELLOW);

        {
            let mut gl = unsafe { get_internal_gl() };

            // Ensure that macroquad's shapes are not going to be lost
            gl.flush();

            let t = get_time();

            gl.quad_context.apply_pipeline(&stage.pipeline);

            gl.quad_context
                .begin_default_pass(miniquad::PassAction::Nothing);
            gl.quad_context.apply_bindings(&stage.bindings);

            for i in 0..10 {
                let t = t + i as f64 * 0.3;

                gl.quad_context
                    .apply_uniforms(miniquad::UniformsSource::table(
                        &raw_miniquad::shader::Uniforms {
                            offset: (t.sin() as f32 * 0.5, (t * 3.).cos() as f32 * 0.5),
                        },
                    ));
                gl.quad_context.draw(0, 6, 1);
            }
            gl.quad_context.end_render_pass();
        }

        // Back to screen space, render some text

        set_default_camera();
        draw_text("HELLO", 30.0, 200.0, 30.0, BLACK);

        next_frame().await
    }
}

mod raw_miniquad {
    use miniquad::*;

    #[repr(C)]
    struct Vec2 {
        x: f32,
        y: f32,
    }
    #[repr(C)]
    struct Vertex {
        pos: Vec2,
        uv: Vec2,
    }

    pub struct Stage {
        pub pipeline: Pipeline,
        pub bindings: Bindings,
    }

    impl Stage {
        pub fn new(ctx: &mut dyn RenderingBackend) -> Stage {
            #[rustfmt::skip]
            let vertices: [Vertex; 4] = [
                Vertex { pos : Vec2 { x: -0.5, y: -0.5 }, uv: Vec2 { x: 0., y: 0. } },
                Vertex { pos : Vec2 { x:  0.5, y: -0.5 }, uv: Vec2 { x: 1., y: 0. } },
                Vertex { pos : Vec2 { x:  0.5, y:  0.5 }, uv: Vec2 { x: 1., y: 1. } },
                Vertex { pos : Vec2 { x: -0.5, y:  0.5 }, uv: Vec2 { x: 0., y: 1. } },
            ];
            let vertex_buffer = ctx.new_buffer(
                BufferType::VertexBuffer,
                BufferUsage::Immutable,
                BufferSource::slice(&vertices),
            );

            let indices: [u16; 6] = [0, 1, 2, 0, 2, 3];
            let index_buffer = ctx.new_buffer(
                BufferType::IndexBuffer,
                BufferUsage::Immutable,
                BufferSource::slice(&indices[..]),
            );

            let pixels: [u8; 4 * 4 * 4] = [
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
                0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            ];
            let texture = ctx.new_texture_from_rgba8(4, 4, &pixels);

            let bindings = Bindings {
                vertex_buffers: vec![vertex_buffer],
                index_buffer,
                images: vec![texture],
            };

            let shader = ctx
                .new_shader(
                    miniquad::ShaderSource::Glsl {
                        vertex: shader::VERTEX,
                        fragment: shader::FRAGMENT,
                    },
                    shader::meta(),
                )
                .unwrap();

            let pipeline = ctx.new_pipeline(
                &[BufferLayout::default()],
                &[
                    VertexAttribute::new("pos", VertexFormat::Float2),
                    VertexAttribute::new("uv", VertexFormat::Float2),
                ],
                shader,
                Default::default(),
            );

            Stage { pipeline, bindings }
        }
    }

    pub mod shader {
        use miniquad::*;

        pub const VERTEX: &str = r#"#version 100
attribute vec2 pos;
attribute vec2 uv;

uniform vec2 offset;

varying lowp vec2 texcoord;

void main() {
    gl_Position = vec4(pos + offset, 0, 1);
    texcoord = uv;
}"#;

        pub const FRAGMENT: &str = r#"#version 100
varying lowp vec2 texcoord;

uniform sampler2D tex;

void main() {
    gl_FragColor = texture2D(tex, texcoord);
}"#;

        pub fn meta() -> ShaderMeta {
            ShaderMeta {
                images: vec!["tex".to_string()],
                uniforms: UniformBlockLayout {
                    uniforms: vec![UniformDesc::new("offset", UniformType::Float2)],
                },
            }
        }

        #[repr(C)]
        pub struct Uniforms {
            pub offset: (f32, f32),
        }
    }
}

```

`examples/rustaceanmark.rs`:

```rs
use macroquad::prelude::*;

struct Rustaceane {
    pos: Vec2,
    speed: Vec2,
    color: Color,
}

#[macroquad::main("Rustaceanmark")]
async fn main() {
    let mut rustaceanes: Vec<Rustaceane> = Vec::new();
    let rustacean_tex = load_texture("examples/rustacean_happy.png").await.unwrap();
    rustacean_tex.set_filter(FilterMode::Nearest);

    loop {
        clear_background(Color::default());

        if macroquad::input::is_mouse_button_down(MouseButton::Left) {
            for _i in 0..100 {
                rustaceanes.push(Rustaceane {
                    pos: Vec2::from(macroquad::input::mouse_position()),
                    speed: Vec2::new(
                        rand::gen_range(-250., 250.) / 60.,
                        rand::gen_range(-250., 250.) / 60.,
                    ),
                    color: Color::from_rgba(
                        rand::gen_range(50, 240),
                        rand::gen_range(80, 240),
                        rand::gen_range(100, 240),
                        255,
                    ),
                })
            }
        }

        for rustaceane in &mut rustaceanes {
            rustaceane.pos += rustaceane.speed;

            if ((rustaceane.pos.x + rustacean_tex.width() / 2.) > screen_width())
                || ((rustaceane.pos.x + rustacean_tex.width() / 2.) < 0.)
            {
                rustaceane.speed.x *= -1.;
            }
            if ((rustaceane.pos.y + rustacean_tex.height() / 2.) > screen_height())
                || ((rustaceane.pos.y + rustacean_tex.height() / 2.) < 0.)
            {
                rustaceane.speed.y *= -1.;
            }

            draw_texture(
                &rustacean_tex,
                rustaceane.pos.x,
                rustaceane.pos.y,
                rustaceane.color,
            );
        }

        draw_fps();
        draw_text(
            format!("Rustaceanes: {}", rustaceanes.len()).as_str(),
            0.,
            32.,
            32.,
            WHITE,
        );

        next_frame().await
    }
}

```

`examples/screen_texture.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("Texture")]
async fn main() {
    let texture: Texture2D = load_texture("examples/chess.png").await.unwrap();

    let lens_material = load_material(
        ShaderSource::Glsl {
            vertex: LENS_VERTEX_SHADER,
            fragment: LENS_FRAGMENT_SHADER,
        },
        MaterialParams {
            uniforms: vec![UniformDesc::new("Center", UniformType::Float2)],
            ..Default::default()
        },
    )
    .unwrap();

    loop {
        clear_background(WHITE);
        draw_texture_ex(
            &texture,
            0.0,
            0.0,
            WHITE,
            DrawTextureParams {
                dest_size: Some(vec2(screen_width(), screen_height())),
                ..Default::default()
            },
        );

        let lens_center = mouse_position();

        lens_material.set_uniform("Center", lens_center);

        gl_use_material(&lens_material);
        draw_circle(lens_center.0, lens_center.1, 250.0, RED);
        gl_use_default_material();

        next_frame().await
    }
}

const LENS_FRAGMENT_SHADER: &'static str = r#"#version 100
precision lowp float;

varying vec2 uv;
varying vec2 uv_screen;
varying vec2 center;

uniform sampler2D _ScreenTexture;

void main() {
    float gradient = length(uv);
    vec2 uv_zoom = (uv_screen - center) * gradient + center;

    gl_FragColor = texture2D(_ScreenTexture, uv_zoom);
}
"#;

const LENS_VERTEX_SHADER: &'static str = "#version 100
attribute vec3 position;
attribute vec2 texcoord;

varying lowp vec2 center;
varying lowp vec2 uv;
varying lowp vec2 uv_screen;

uniform mat4 Model;
uniform mat4 Projection;

uniform vec2 Center;

void main() {
    vec4 res = Projection * Model * vec4(position, 1);
    vec4 c = Projection * Model * vec4(Center, 0, 1);

    uv_screen = res.xy / 2.0 + vec2(0.5, 0.5);
    center = c.xy / 2.0 + vec2(0.5, 0.5);
    uv = texcoord;

    gl_Position = res;
}
";

```

`examples/shadertoy.rs`:

```rs
use macroquad::prelude::*;

use macroquad::ui::{
    hash, root_ui,
    widgets::{self, Label, TreeNode},
};

use macroquad::color;

enum Uniform {
    Float1(String),
    Float2(String, String),
    Float3(String, String, String),
    Color(Vec3),
}

impl Uniform {
    fn uniform_type(&self) -> UniformType {
        match self {
            Uniform::Float1(_) => UniformType::Float1,
            Uniform::Float2(_, _) => UniformType::Float2,
            Uniform::Float3(_, _, _) => UniformType::Float3,
            Uniform::Color(_) => UniformType::Float3,
        }
    }
}

fn color_picker_texture(w: usize, h: usize) -> (Texture2D, Image) {
    let ratio = 1.0 / h as f32;

    let mut image = Image::gen_image_color(w as u16, h as u16, WHITE);
    let image_data = image.get_image_data_mut();

    for j in 0..h {
        for i in 0..w {
            let lightness = 1.0 - i as f32 * ratio;
            let hue = j as f32 * ratio;

            image_data[i + j * w] = color::hsl_to_rgb(hue, 1.0, lightness).into();
        }
    }

    (Texture2D::from_image(&image), image)
}

#[macroquad::main("Shadertoy")]
async fn main() {
    let ferris = load_texture("examples/rust.png").await.unwrap();
    let (color_picker_texture, color_picker_image) = color_picker_texture(200, 200);

    let mut fragment_shader = DEFAULT_FRAGMENT_SHADER.to_string();
    let mut vertex_shader = DEFAULT_VERTEX_SHADER.to_string();

    let pipeline_params = PipelineParams {
        depth_write: true,
        depth_test: Comparison::LessOrEqual,
        ..Default::default()
    };

    let mut material = load_material(
        ShaderSource::Glsl {
            vertex: &vertex_shader,
            fragment: &fragment_shader,
        },
        MaterialParams {
            pipeline_params,
            ..Default::default()
        },
    )
    .unwrap();
    let mut error: Option<String> = None;

    enum Mesh {
        Sphere,
        Cube,
        Plane,
    }
    let mut mesh = Mesh::Sphere;

    let mut camera = Camera3D {
        position: vec3(-15., 15., -5.),
        up: vec3(0., 1., 0.),
        target: vec3(0., 5., -5.),
        ..Default::default()
    };

    let mut colorpicker_window = false;
    let mut color_picking_uniform = None;

    let mut new_uniform_window = false;
    let mut new_uniform_name = String::new();
    let mut uniforms: Vec<(String, Uniform)> = vec![];

    loop {
        clear_background(WHITE);

        set_camera(&camera);

        draw_grid(
            20,
            1.,
            Color::new(0.55, 0.55, 0.55, 0.75),
            Color::new(0.75, 0.75, 0.75, 0.75),
        );

        gl_use_material(&material);
        match mesh {
            Mesh::Plane => draw_plane(vec3(0., 2., 0.), vec2(5., 5.), Some(&ferris), WHITE),
            Mesh::Sphere => draw_sphere(vec3(0., 6., 0.), 5., Some(&ferris), WHITE),
            Mesh::Cube => draw_cube(vec3(0., 5., 0.), vec3(10., 10., 10.), Some(&ferris), WHITE),
        }
        gl_use_default_material();

        set_default_camera();

        let mut need_update = false;

        widgets::Window::new(hash!(), vec2(20., 20.), vec2(470., 650.))
            .label("Shader")
            .ui(&mut *root_ui(), |ui| {
                ui.label(None, "Camera: ");
                ui.same_line(0.0);
                if ui.button(None, "Ortho") {
                    camera.projection = Projection::Orthographics;
                }
                ui.same_line(0.0);
                if ui.button(None, "Perspective") {
                    camera.projection = Projection::Perspective;
                }
                ui.label(None, "Mesh: ");
                ui.same_line(0.0);
                if ui.button(None, "Sphere") {
                    mesh = Mesh::Sphere;
                }
                ui.same_line(0.0);
                if ui.button(None, "Cube") {
                    mesh = Mesh::Cube;
                }
                ui.same_line(0.0);
                if ui.button(None, "Plane") {
                    mesh = Mesh::Plane;
                }

                ui.label(None, "Uniforms:");
                ui.separator();

                for (i, (name, uniform)) in uniforms.iter_mut().enumerate() {
                    ui.label(None, &format!("{name}"));
                    ui.same_line(120.0);

                    match uniform {
                        Uniform::Float1(x) => {
                            widgets::InputText::new(hash!(hash!(), i))
                                .size(vec2(200.0, 19.0))
                                .filter_numbers()
                                .ui(ui, x);

                            if let Ok(x) = x.parse::<f32>() {
                                material.set_uniform(name, x);
                            }
                        }
                        Uniform::Float2(x, y) => {
                            widgets::InputText::new(hash!(hash!(), i))
                                .size(vec2(99.0, 19.0))
                                .filter_numbers()
                                .ui(ui, x);

                            ui.same_line(0.0);

                            widgets::InputText::new(hash!(hash!(), i))
                                .size(vec2(99.0, 19.0))
                                .filter_numbers()
                                .ui(ui, y);

                            if let (Ok(x), Ok(y)) = (x.parse::<f32>(), y.parse::<f32>()) {
                                material.set_uniform(name, (x, y));
                            }
                        }
                        Uniform::Float3(x, y, z) => {
                            widgets::InputText::new(hash!(hash!(), i))
                                .size(vec2(65.0, 19.0))
                                .filter_numbers()
                                .ui(ui, x);

                            ui.same_line(0.0);

                            widgets::InputText::new(hash!(hash!(), i))
                                .size(vec2(65.0, 19.0))
                                .filter_numbers()
                                .ui(ui, y);

                            ui.same_line(0.0);

                            widgets::InputText::new(hash!(hash!(), i))
                                .size(vec2(65.0, 19.0))
                                .filter_numbers()
                                .ui(ui, z);

                            if let (Ok(x), Ok(y), Ok(z)) =
                                (x.parse::<f32>(), y.parse::<f32>(), z.parse::<f32>())
                            {
                                material.set_uniform(name, (x, y, z));
                            }
                        }

                        Uniform::Color(color) => {
                            let mut canvas = ui.canvas();

                            let cursor = canvas.cursor();

                            canvas.rect(
                                Rect::new(cursor.x + 20.0, cursor.y, 50.0, 18.0),
                                Color::new(0.2, 0.2, 0.2, 1.0),
                                Color::new(color.x, color.y, color.z, 1.0),
                            );

                            if ui.button(None, "change") {
                                colorpicker_window = true;
                                color_picking_uniform = Some(name.to_owned());
                            }
                            material.set_uniform(name, (color.x, color.y, color.z));
                        }
                    }
                }
                ui.separator();
                if ui.button(None, "New uniform") {
                    new_uniform_window = true;
                }
                TreeNode::new(hash!(), "Fragment shader")
                    .init_unfolded()
                    .ui(ui, |ui| {
                        if ui.editbox(hash!(), vec2(440., 200.), &mut fragment_shader) {
                            need_update = true;
                        };
                    });
                ui.tree_node(hash!(), "Vertex shader", |ui| {
                    if ui.editbox(hash!(), vec2(440., 300.), &mut vertex_shader) {
                        need_update = true;
                    };
                });

                if let Some(ref error) = error {
                    Label::new(error).multiline(14.0).ui(ui);
                }
            });

        if new_uniform_window {
            widgets::Window::new(hash!(), vec2(100., 100.), vec2(200., 80.))
                .label("New uniform")
                .ui(&mut *root_ui(), |ui| {
                    if ui.active_window_focused() == false {
                        new_uniform_window = false;
                    }
                    ui.input_text(hash!(), "Name", &mut new_uniform_name);
                    let uniform_type = ui.combo_box(
                        hash!(),
                        "Type",
                        &["Float1", "Float2", "Float3", "Color"],
                        None,
                    );

                    if ui.button(None, "Add") {
                        if new_uniform_name.is_empty() == false {
                            let uniform = match uniform_type {
                                0 => Uniform::Float1("0".to_string()),
                                1 => Uniform::Float2("0".to_string(), "0".to_string()),
                                2 => Uniform::Float3(
                                    "0".to_string(),
                                    "0".to_string(),
                                    "0".to_string(),
                                ),
                                3 => Uniform::Color(vec3(0.0, 0.0, 0.0)),
                                _ => unreachable!(),
                            };
                            uniforms.push((new_uniform_name.clone(), uniform));
                            new_uniform_name.clear();
                            need_update = true;
                        }
                        new_uniform_window = false;
                    }

                    ui.same_line(0.0);
                    if ui.button(None, "Cancel") {
                        new_uniform_window = false;
                    }
                });
        }

        if colorpicker_window {
            colorpicker_window &= widgets::Window::new(hash!(), vec2(140., 100.), vec2(210., 240.))
                .label("Colorpicker")
                .ui(&mut *root_ui(), |ui| {
                    if ui.active_window_focused() == false {
                        colorpicker_window = false;
                    }

                    let mut canvas = ui.canvas();
                    let cursor = canvas.cursor();
                    let mouse = mouse_position();
                    let x = mouse.0 as i32 - cursor.x as i32;
                    let y = mouse.1 as i32 - (cursor.y as i32 + 20);

                    let color = color_picker_image
                        .get_pixel(x.max(0).min(199) as u32, y.max(0).min(199) as u32);

                    canvas.rect(
                        Rect::new(cursor.x, cursor.y, 200.0, 18.0),
                        Color::new(0.0, 0.0, 0.0, 1.0),
                        Color::new(color.r, color.g, color.b, 1.0),
                    );
                    canvas.image(
                        Rect::new(cursor.x, cursor.y + 20.0, 200.0, 200.0),
                        &color_picker_texture,
                    );

                    if x >= 0 && x < 200 && y >= 0 && y < 200 {
                        canvas.rect(
                            Rect::new(mouse.0 - 3.5, mouse.1 - 3.5, 7.0, 7.0),
                            Color::new(0.3, 0.3, 0.3, 1.0),
                            Color::new(1.0, 1.0, 1.0, 1.0),
                        );

                        if is_mouse_button_down(MouseButton::Left) {
                            colorpicker_window = false;
                            let uniform_name = color_picking_uniform.take().unwrap();

                            uniforms
                                .iter_mut()
                                .find(|(name, _)| name == &uniform_name)
                                .unwrap()
                                .1 = Uniform::Color(vec3(color.r, color.g, color.b));
                        }
                    }
                });
        }

        if need_update {
            let uniforms = uniforms
                .iter()
                .map(|(name, uniform)| UniformDesc::new(name, uniform.uniform_type()))
                .collect::<Vec<_>>();

            match load_material(
                ShaderSource::Glsl {
                    vertex: &vertex_shader,
                    fragment: &fragment_shader,
                },
                MaterialParams {
                    pipeline_params,
                    uniforms,
                    textures: vec![],
                },
            ) {
                Ok(new_material) => {
                    material = new_material;
                    error = None;
                }
                Err(err) => {
                    error = Some(format!("{err:#?}"));
                }
            }
        }

        next_frame().await
    }
}

const DEFAULT_FRAGMENT_SHADER: &'static str = "#version 100
precision lowp float;

varying vec2 uv;

uniform sampler2D Texture;

void main() {
    gl_FragColor = texture2D(Texture, uv);
}
";

const DEFAULT_VERTEX_SHADER: &'static str = "#version 100
precision lowp float;

attribute vec3 position;
attribute vec2 texcoord;

varying vec2 uv;

uniform mat4 Model;
uniform mat4 Projection;

void main() {
    gl_Position = Projection * Model * vec4(position, 1);
    uv = texcoord;
}
";

```

`examples/snake.rs`:

```rs
use macroquad::prelude::*;

use std::collections::LinkedList;

const SQUARES: i16 = 16;

type Point = (i16, i16);

struct Snake {
    head: Point,
    body: LinkedList<Point>,
    dir: Point,
}

#[macroquad::main("Snake")]
async fn main() {
    let mut snake = Snake {
        head: (0, 0),
        dir: (1, 0),
        body: LinkedList::new(),
    };
    let mut fruit: Point = (rand::gen_range(0, SQUARES), rand::gen_range(0, SQUARES));
    let mut score = 0;
    let mut speed = 0.3;
    let mut last_update = get_time();
    let mut navigation_lock = false;
    let mut game_over = false;

    let up = (0, -1);
    let down = (0, 1);
    let right = (1, 0);
    let left = (-1, 0);

    loop {
        if !game_over {
            if is_key_down(KeyCode::Right) && snake.dir != left && !navigation_lock {
                snake.dir = right;
                navigation_lock = true;
            } else if is_key_down(KeyCode::Left) && snake.dir != right && !navigation_lock {
                snake.dir = left;
                navigation_lock = true;
            } else if is_key_down(KeyCode::Up) && snake.dir != down && !navigation_lock {
                snake.dir = up;
                navigation_lock = true;
            } else if is_key_down(KeyCode::Down) && snake.dir != up && !navigation_lock {
                snake.dir = down;
                navigation_lock = true;
            }

            if get_time() - last_update > speed {
                last_update = get_time();
                snake.body.push_front(snake.head);
                snake.head = (snake.head.0 + snake.dir.0, snake.head.1 + snake.dir.1);
                if snake.head == fruit {
                    fruit = (rand::gen_range(0, SQUARES), rand::gen_range(0, SQUARES));
                    score += 100;
                    speed *= 0.9;
                } else {
                    snake.body.pop_back();
                }
                if snake.head.0 < 0
                    || snake.head.1 < 0
                    || snake.head.0 >= SQUARES
                    || snake.head.1 >= SQUARES
                {
                    game_over = true;
                }
                for (x, y) in &snake.body {
                    if *x == snake.head.0 && *y == snake.head.1 {
                        game_over = true;
                    }
                }
                navigation_lock = false;
            }
        }
        if !game_over {
            clear_background(LIGHTGRAY);

            let game_size = screen_width().min(screen_height());
            let offset_x = (screen_width() - game_size) / 2. + 10.;
            let offset_y = (screen_height() - game_size) / 2. + 10.;
            let sq_size = (screen_height() - offset_y * 2.) / SQUARES as f32;

            draw_rectangle(offset_x, offset_y, game_size - 20., game_size - 20., WHITE);

            for i in 1..SQUARES {
                draw_line(
                    offset_x,
                    offset_y + sq_size * i as f32,
                    screen_width() - offset_x,
                    offset_y + sq_size * i as f32,
                    2.,
                    LIGHTGRAY,
                );
            }

            for i in 1..SQUARES {
                draw_line(
                    offset_x + sq_size * i as f32,
                    offset_y,
                    offset_x + sq_size * i as f32,
                    screen_height() - offset_y,
                    2.,
                    LIGHTGRAY,
                );
            }

            draw_rectangle(
                offset_x + snake.head.0 as f32 * sq_size,
                offset_y + snake.head.1 as f32 * sq_size,
                sq_size,
                sq_size,
                DARKGREEN,
            );

            for (x, y) in &snake.body {
                draw_rectangle(
                    offset_x + *x as f32 * sq_size,
                    offset_y + *y as f32 * sq_size,
                    sq_size,
                    sq_size,
                    LIME,
                );
            }

            draw_rectangle(
                offset_x + fruit.0 as f32 * sq_size,
                offset_y + fruit.1 as f32 * sq_size,
                sq_size,
                sq_size,
                GOLD,
            );

            draw_text(format!("SCORE: {score}").as_str(), 10., 20., 20., DARKGRAY);
        } else {
            clear_background(WHITE);
            let text = "Game Over. Press [enter] to play again.";
            let font_size = 30.;
            let text_size = measure_text(text, None, font_size as _, 1.0);

            draw_text(
                text,
                screen_width() / 2. - text_size.width / 2.,
                screen_height() / 2. + text_size.height / 2.,
                font_size,
                DARKGRAY,
            );

            if is_key_down(KeyCode::Enter) {
                snake = Snake {
                    head: (0, 0),
                    dir: (1, 0),
                    body: LinkedList::new(),
                };
                fruit = (rand::gen_range(0, SQUARES), rand::gen_range(0, SQUARES));
                score = 0;
                speed = 0.3;
                last_update = get_time();
                game_over = false;
            }
        }
        next_frame().await;
    }
}

```

`examples/text.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("Text")]
async fn main() {
    let font = load_ttf_font("./examples/DancingScriptRegular.ttf")
        .await
        .unwrap();

    let mut angle = 0.0;

    loop {
        clear_background(BLACK);

        draw_text_ex("Custom font size:", 20.0, 20.0, TextParams::default());
        let mut y = 20.0;

        for font_size in (30..100).step_by(20) {
            let text = "abcdef";
            let params = TextParams {
                font_size,
                ..Default::default()
            };

            y += font_size as f32;
            draw_text_ex(text, 20.0, y, params);
        }

        draw_text_ex("Dynamic font scale:", 20.0, 400.0, TextParams::default());
        draw_text_ex(
            "abcd",
            20.0,
            450.0,
            TextParams {
                font_size: 50,
                font_scale: get_time().sin() as f32 / 2.0 + 1.0,
                ..Default::default()
            },
        );

        draw_text_ex("Custom font:", 400.0, 20.0, TextParams::default());
        draw_text_ex(
            "abcd",
            400.0,
            70.0,
            TextParams {
                font_size: 50,
                font: Some(&font),
                ..Default::default()
            },
        );

        draw_text_ex(
            "abcd",
            400.0,
            160.0,
            TextParams {
                font_size: 100,
                font: Some(&font),
                ..Default::default()
            },
        );

        draw_text_ex(
            "abcd",
            screen_width() / 4.0 * 2.0,
            screen_height() / 3.0 * 2.0,
            TextParams {
                font_size: 70,
                font: Some(&font),
                rotation: angle,
                ..Default::default()
            },
        );

        let center = get_text_center("abcd", Option::None, 70, 1.0, angle * 2.0);
        draw_text_ex(
            "abcd",
            screen_width() / 4.0 * 3.0 - center.x,
            screen_height() / 3.0 * 2.0 - center.y,
            TextParams {
                font_size: 70,
                rotation: angle * 2.0,
                ..Default::default()
            },
        );

        angle -= 0.030;

        next_frame().await
    }
}

```

`examples/text_measures.rs`:

```rs
use macroquad::prelude::*;

fn draw_text_annotated(text: &str, font: Option<&Font>, x: f32, baseline: f32) {
    let size = measure_text(text, font, 100, 1.0);

    // Full background rect
    draw_rectangle(x, baseline - size.offset_y, size.width, size.height, BLUE);

    // Base line
    draw_rectangle(x, baseline - 2.0, size.width, 4.0, RED);

    // Base line annotation
    draw_rectangle(x + size.width, baseline - 1.0, 120.0, 1.0, GRAY);
    draw_text(
        "baseline",
        x + size.width + 10.0,
        baseline - 5.0,
        30.0,
        WHITE,
    );

    // Top line
    draw_rectangle(x, baseline - 2.0 - size.offset_y, size.width, 4.0, RED);

    // Top line annotation
    draw_rectangle(
        x + size.width,
        baseline - size.offset_y - 1.0,
        120.0,
        1.0,
        GRAY,
    );
    draw_text(
        "topline",
        x + size.width + 10.0,
        baseline - size.offset_y - 5.0,
        30.0,
        WHITE,
    );

    // Bottom line
    draw_rectangle(
        x,
        baseline - 2.0 - size.offset_y + size.height,
        size.width,
        4.0,
        RED,
    );

    // Bottom line annotation
    draw_rectangle(
        x + size.width,
        baseline - size.offset_y + size.height - 1.0,
        120.0,
        1.0,
        GRAY,
    );
    draw_text(
        "bottomline",
        x + size.width + 10.0,
        baseline - size.offset_y + size.height - 5.0,
        30.0,
        WHITE,
    );

    draw_text_ex(
        text,
        x,
        baseline,
        TextParams {
            font_size: 100,
            font,
            ..Default::default()
        },
    );
}

#[macroquad::main("Text")]
async fn main() {
    let font = load_ttf_font("./examples/DancingScriptRegular.ttf")
        .await
        .unwrap();

    loop {
        clear_background(BLACK);

        let text = "abcdIj";

        draw_text_annotated(text, None, 40.0, 200.0);
        draw_text_annotated(text, Some(&font), 400.0, 400.0);

        next_frame().await
    }
}

```

`examples/text_wrap.rs`:

```rs
use macroquad::prelude::*;

static LOREM: &str = "Lorem ipsum odor amet, consectetuer adipiscing elit. Ultrices nostra volutpat facilisis magna mus. Rhoncus tempor feugiat netus maecenas pretium leo vitae. Eros aliquet maecenas eu diam aliquet varius hac elementum. Sociosqu platea per ultricies vitae praesent mauris nostra ridiculus. Est cursus pulvinar efficitur mus vel leo. Integer et nec eleifend non leo. Lorem rutrum ultrices potenti facilisis hendrerit facilisi metus sit. AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Intentional newlines
are preserved.";

#[macroquad::main("Text Wrap")]
async fn main() {
    let font_size = 24;
    loop {
        clear_background(BLACK);

        let maximum_line_length = f32::max(20.0, mouse_position().0 - 20.0);
        let text = wrap_text(LOREM, None, font_size, 1.0, maximum_line_length);
        let dimensions = measure_multiline_text(&text, None, font_size, 1.0, Some(1.0));

        draw_multiline_text(
            &text,
            20.0,
            20.0 + dimensions.offset_y,
            font_size as f32,
            Some(1.0),
            WHITE,
        );
        draw_rectangle_lines(20.0, 20.0, dimensions.width, dimensions.height, 2.0, BLUE);
        draw_line(
            20.0 + maximum_line_length,
            0.0,
            20.0 + maximum_line_length,
            screen_height(),
            1.0,
            RED,
        );

        next_frame().await
    }
}

```

`examples/texture.rs`:

```rs
use macroquad::prelude::*;

#[macroquad::main("Texture")]
async fn main() {
    let texture: Texture2D = load_texture("examples/ferris.png").await.unwrap();

    loop {
        clear_background(LIGHTGRAY);
        draw_texture(&texture, 0., 0., WHITE);
        next_frame().await
    }
}

```

`examples/tree.rs`:

```rs
use macroquad::prelude::*;

fn tree(gl: &mut QuadGl, time: f64, deep: u32, angle: f32, tall: f32) {
    if deep >= 8 {
        return;
    }

    // we can use normal macroquad drawing API here
    draw_rectangle(-0.01 / 2., 0., 0.01, tall, DARKGRAY);

    // and we can also modify internal macroquad render state with "gl" reference
    gl.push_model_matrix(glam::Mat4::from_translation(glam::vec3(0., tall, 0.)));

    // right leaf
    gl.push_model_matrix(glam::Mat4::from_rotation_z(angle + time.sin() as f32 * 0.1));
    tree(gl, time, deep + 1, angle * 0.7, tall * 0.8);
    gl.pop_model_matrix();

    // left leaf
    gl.push_model_matrix(glam::Mat4::from_rotation_z(
        -angle - time.cos() as f32 * 0.1,
    ));
    tree(gl, time, deep + 1, angle * 0.7, tall * 0.8);
    gl.pop_model_matrix();

    gl.pop_model_matrix();
}

#[macroquad::main("Tree")]
async fn main() {
    let camera = Camera2D {
        zoom: vec2(1., 1.),
        target: vec2(0.0, 0.5),
        ..Default::default()
    };

    set_camera(&camera);
    loop {
        clear_background(LIGHTGRAY);

        draw_circle(0., 0., 0.03, DARKGRAY);
        tree(unsafe { get_internal_gl().quad_gl }, get_time(), 0, 1., 0.3);

        next_frame().await
    }
}

```

`examples/ui.rs`:

```rs
use macroquad::prelude::*;

use macroquad::ui::widgets::{ProgressBar, Slider};
use macroquad::ui::{
    hash, root_ui,
    widgets::{self, Group},
    Drag, Ui,
};

pub struct Slot {
    id: u64,
    item: Option<String>,
}
impl Slot {
    fn new(id: u64) -> Slot {
        Slot { id, item: None }
    }
}

pub enum FittingCommand {
    /// Remove item from this slot
    Unfit { target_slot: u64 },
    /// Fit item from inventory to slot
    Fit { target_slot: u64, item: String },
    /// Move item from one slot to another
    Refit { target_slot: u64, origin_slot: u64 },
}

pub struct Data {
    inventory: Vec<String>,
    item_dragging: bool,
    slots: Vec<(&'static str, Slot)>,
    fit_command: Option<FittingCommand>,
}
impl Data {
    pub fn new() -> Data {
        Data {
            inventory: vec![],
            item_dragging: false,
            slots: vec![
                ("Left Mouse Button", Slot::new(hash!())),
                ("Right Mouse Button", Slot::new(hash!())),
                ("Middle Mouse Button", Slot::new(hash!())),
                ("Space", Slot::new(hash!())),
                ("\"1\"", Slot::new(hash!())),
                ("\"2\"", Slot::new(hash!())),
                ("\"3\"", Slot::new(hash!())),
            ],
            fit_command: None,
        }
    }

    fn slots(&mut self, ui: &mut Ui) {
        let item_dragging = &mut self.item_dragging;

        let fit_command = &mut self.fit_command;
        for (label, slot) in self.slots.iter_mut() {
            Group::new(hash!("grp", slot.id, &label), Vec2::new(210., 55.)).ui(ui, |ui| {
                let drag = Group::new(slot.id, Vec2::new(50., 50.))
                    // slot without item is not draggable
                    .draggable(slot.item.is_some())
                    // but could be a target of drag
                    .hoverable(*item_dragging)
                    // and is highlighted with other color when some item is dragging
                    .highlight(*item_dragging)
                    .ui(ui, |ui| {
                        if let Some(ref item) = slot.item {
                            ui.label(Vec2::new(5., 10.), &item);
                        }
                    });

                match drag {
                    // there is some item in this slot and it was dragged to another slot
                    Drag::Dropped(_, Some(id)) if slot.item.is_some() => {
                        *fit_command = Some(FittingCommand::Refit {
                            target_slot: id,
                            origin_slot: slot.id,
                        });
                    }
                    // there is some item in this slot and it was dragged out - unfit it
                    Drag::Dropped(_, None) if slot.item.is_some() => {
                        *fit_command = Some(FittingCommand::Unfit {
                            target_slot: slot.id,
                        });
                    }
                    // there is no item in this slot
                    // this is impossible - slots without items are non-draggable
                    Drag::Dropped(_, _) => unreachable!(),
                    Drag::Dragging(pos, id) => {
                        debug!("slots: pos: {:?}, id {:?}", pos, id);
                        *item_dragging = true;
                    }
                    Drag::No => {}
                }
                ui.label(Vec2::new(60., 20.), label);
            });
        }
    }

    fn inventory(&mut self, ui: &mut Ui) {
        let item_dragging = &mut self.item_dragging;
        for (n, item) in self.inventory.iter().enumerate() {
            let drag = Group::new(hash!("inventory", n), Vec2::new(50., 50.))
                .draggable(true)
                .ui(ui, |ui| {
                    ui.label(Vec2::new(5., 10.), &item);
                });

            match drag {
                Drag::Dropped(_, Some(id)) => {
                    self.fit_command = Some(FittingCommand::Fit {
                        target_slot: id,
                        item: item.clone(),
                    });
                    *item_dragging = false;
                }
                Drag::Dropped(_, _) => {
                    *item_dragging = false;
                }
                Drag::Dragging(pos, id) => {
                    debug!("inventory: pos: {:?}, id {:?}", pos, id);
                    *item_dragging = true;
                }
                _ => {}
            }
        }
    }

    fn set_item(&mut self, id: u64, item: Option<String>) {
        if let Some(slot) = self.slots.iter_mut().find(|(_, slot)| slot.id == id) {
            slot.1.item = item;
        }
    }
}

#[macroquad::main("UI showcase")]
async fn main() {
    let mut data = Data::new();

    let mut data0 = String::new();
    let mut data1 = String::new();

    let mut text0 = String::new();
    let mut text1 = String::new();

    let mut number0 = 0.;
    let mut number1 = 0.;
    let mut number2 = 0.;

    let texture: Texture2D = load_texture("examples/ferris.png").await.unwrap();

    loop {
        clear_background(WHITE);

        widgets::Window::new(hash!(), vec2(400., 200.), vec2(320., 400.))
            .label("Shop")
            .titlebar(true)
            .ui(&mut *root_ui(), |ui| {
                for i in 0..30 {
                    Group::new(hash!("shop", i), Vec2::new(300., 80.)).ui(ui, |ui| {
                        ui.label(Vec2::new(10., 10.), &format!("Item N {i}"));
                        ui.label(Vec2::new(260., 40.), "10/10");
                        ui.label(Vec2::new(200., 58.), &format!("{} kr", 800));
                        if ui.button(Vec2::new(260., 55.), "buy") {
                            data.inventory.push(format!("Item {i}"));
                        }
                    });
                }
            });

        widgets::Window::new(hash!(), vec2(100., 220.), vec2(542., 430.))
            .label("Fitting window")
            .titlebar(true)
            .ui(&mut *root_ui(), |ui| {
                Group::new(hash!(), Vec2::new(230., 400.)).ui(ui, |ui| {
                    data.slots(ui);
                });
                Group::new(hash!(), Vec2::new(280., 400.)).ui(ui, |ui| {
                    data.inventory(ui);
                });
            });

        widgets::Window::new(hash!(), vec2(470., 50.), vec2(300., 300.))
            .label("Megaui Showcase Window")
            .ui(&mut *root_ui(), |ui| {
                ui.tree_node(hash!(), "input", |ui| {
                    ui.label(None, "Some random text");
                    if ui.button(None, "click me") {
                        println!("hi");
                    }

                    ui.separator();

                    ui.label(None, "Some other random text");
                    if ui.button(None, "other button") {
                        println!("hi2");
                    }

                    ui.separator();

                    ui.input_text(hash!(), "<- input text 1", &mut data0);
                    ui.input_text(hash!(), "<- input text 2", &mut data1);
                    ui.label(None, &format!("Text entered: \"{data0}\" and \"{data1}\""));

                    ui.separator();
                });
                ui.tree_node(hash!(), "buttons", |ui| {
                    widgets::Button::new(texture.clone())
                        .size(vec2(120., 70.))
                        .ui(ui);
                    ui.same_line(0.);
                    widgets::Button::new("Button").size(vec2(120., 70.)).ui(ui);
                    widgets::Button::new("Button").size(vec2(120., 70.)).ui(ui);
                    ui.same_line(0.);
                    widgets::Button::new(texture.clone())
                        .size(vec2(120., 70.))
                        .ui(ui);
                });
                ui.tree_node(hash!(), "sliders and bars", |ui| {
                    let range0 = -10f32..10f32;
                    ui.slider(hash!(), "[-10 .. 10]", range0.clone(), &mut number0);
                    let progress0 = number0.remap(range0.start, range0.end, 0., 1.);
                    ProgressBar::new().label("first bar").ui(
                        ui,
                        progress0,
                        format!("{:.0}%", progress0 * 100.).as_str(),
                    );

                    let range1 = 0f32..100f32;
                    ui.slider(hash!(), "[0 .. 100]", range1.clone(), &mut number1);
                    let progress1 = number1.remap(range1.start, range1.end, 0., 1.);
                    ProgressBar::new().label("second bar").ui(
                        ui,
                        progress1,
                        format!("{:.1}/{:.0}", number1, range1.end).as_str(),
                    );

                    let range2 = 0f32..1f32;
                    Slider::new(hash!(), range2.clone())
                        .label_width(200.)
                        .label("slider with a long label")
                        .ui(ui, &mut number2);
                    let progress2 = number2;
                    ProgressBar::new()
                        .label("bar with a really long label")
                        .label_width(240.)
                        .ui(ui, progress2, "");
                });
                ui.tree_node(hash!(), "editbox 1", |ui| {
                    ui.label(None, "This is editbox!");
                    ui.editbox(hash!(), vec2(285., 165.), &mut text0);
                });
                ui.tree_node(hash!(), "editbox 2", |ui| {
                    ui.label(None, "This is editbox!");
                    ui.editbox(hash!(), vec2(285., 165.), &mut text1);
                });
            });

        match data.fit_command.take() {
            Some(FittingCommand::Unfit { target_slot }) => data.set_item(target_slot, None),
            Some(FittingCommand::Fit { target_slot, item }) => {
                data.set_item(target_slot, Some(item));
            }
            Some(FittingCommand::Refit {
                target_slot,
                origin_slot,
            }) => {
                let origin_item = data
                    .slots
                    .iter()
                    .find_map(|(_, slot)| {
                        if slot.id == origin_slot {
                            Some(slot.item.clone())
                        } else {
                            None
                        }
                    })
                    .flatten();
                data.set_item(target_slot, origin_item);
                data.set_item(origin_slot, None);
            }
            None => {}
        };

        next_frame().await;
    }
}

```

`examples/ui_skins.rs`:

```rs
use macroquad::prelude::*;

use macroquad::ui::{hash, root_ui, widgets, Skin};

#[macroquad::main("UI showcase")]
async fn main() {
    let skin1 = {
        let font = load_ttf_font("examples/ui_assets/HTOWERT.TTF")
            .await
            .unwrap();
        let label_style = root_ui()
            .style_builder()
            .with_font(&font)
            .unwrap()
            .text_color(Color::from_rgba(180, 180, 120, 255))
            .font_size(30)
            .build();

        let window_style = root_ui()
            .style_builder()
            .background(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/window_background.png"),
                    None,
                )
                .unwrap(),
            )
            .background_margin(RectOffset::new(20.0, 20.0, 10.0, 10.0))
            .margin(RectOffset::new(-20.0, -30.0, 0.0, 0.0))
            .build();

        let button_style = root_ui()
            .style_builder()
            .background(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/button_background.png"),
                    None,
                )
                .unwrap(),
            )
            .background_margin(RectOffset::new(37.0, 37.0, 5.0, 5.0))
            .margin(RectOffset::new(10.0, 10.0, 0.0, 0.0))
            .background_hovered(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/button_hovered_background.png"),
                    None,
                )
                .unwrap(),
            )
            .background_clicked(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/button_clicked_background.png"),
                    None,
                )
                .unwrap(),
            )
            .with_font(&font)
            .unwrap()
            .text_color(Color::from_rgba(180, 180, 100, 255))
            .font_size(40)
            .build();

        let editbox_style = root_ui()
            .style_builder()
            .background_margin(RectOffset::new(0., 0., 0., 0.))
            .with_font(&font)
            .unwrap()
            .text_color(Color::from_rgba(120, 120, 120, 255))
            .color_selected(Color::from_rgba(190, 190, 190, 255))
            .font_size(50)
            .build();

        Skin {
            editbox_style,
            window_style,
            button_style,
            label_style,
            ..root_ui().default_skin()
        }
    };

    let skin2 = {
        let font = load_ttf_font("examples/ui_assets/MinimalPixel v2.ttf")
            .await
            .unwrap();
        let label_style = root_ui()
            .style_builder()
            .with_font(&font)
            .unwrap()
            .text_color(Color::from_rgba(120, 120, 120, 255))
            .font_size(25)
            .build();

        let window_style = root_ui()
            .style_builder()
            .background(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/window_background_2.png"),
                    None,
                )
                .unwrap(),
            )
            .background_margin(RectOffset::new(52.0, 52.0, 52.0, 52.0))
            .margin(RectOffset::new(-30.0, 0.0, -30.0, 0.0))
            .build();

        let button_style = root_ui()
            .style_builder()
            .background(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/button_background_2.png"),
                    None,
                )
                .unwrap(),
            )
            .background_margin(RectOffset::new(8.0, 8.0, 8.0, 8.0))
            .background_hovered(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/button_hovered_background_2.png"),
                    None,
                )
                .unwrap(),
            )
            .background_clicked(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/button_clicked_background_2.png"),
                    None,
                )
                .unwrap(),
            )
            .with_font(&font)
            .unwrap()
            .text_color(Color::from_rgba(180, 180, 100, 255))
            .font_size(40)
            .build();

        let checkbox_style = root_ui()
            .style_builder()
            .background(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/checkbox_background.png"),
                    None,
                )
                .unwrap(),
            )
            .background_hovered(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/checkbox_hovered_background.png"),
                    None,
                )
                .unwrap(),
            )
            .background_clicked(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/checkbox_clicked_background.png"),
                    None,
                )
                .unwrap(),
            )
            .build();

        let editbox_style = root_ui()
            .style_builder()
            .background(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/editbox_background.png"),
                    None,
                )
                .unwrap(),
            )
            .background_margin(RectOffset::new(2., 2., 2., 2.))
            .with_font(&font)
            .unwrap()
            .text_color(Color::from_rgba(120, 120, 120, 255))
            .font_size(25)
            .build();

        let combobox_style = root_ui()
            .style_builder()
            .background(
                Image::from_file_with_format(
                    include_bytes!("../examples/ui_assets/combobox_background.png"),
                    None,
                )
                .unwrap(),
            )
            .background_margin(RectOffset::new(4., 25., 6., 6.))
            .with_font(&font)
            .unwrap()
            .text_color(Color::from_rgba(120, 120, 120, 255))
            .color(Color::from_rgba(210, 210, 210, 255))
            .font_size(25)
            .build();

        Skin {
            window_style,
            button_style,
            label_style,
            checkbox_style,
            editbox_style,
            combobox_style,
            ..root_ui().default_skin()
        }
    };
    let default_skin = root_ui().default_skin().clone();

    let mut window1_skin = skin1.clone();
    let mut window2_skin = skin2.clone();

    let mut checkbox = false;
    let mut text = String::new();
    let mut number = 0.0f32;
    let mut combobox = 0;

    loop {
        clear_background(GRAY);

        root_ui().group(hash!(), vec2(70.0, 100.0), |ui| {
            ui.label(None, "Window 1");

            if ui.button(None, "Skin 1") {
                window1_skin = skin1.clone();
            }
            if ui.button(None, "Skin 2") {
                window1_skin = skin2.clone();
            }
            if ui.button(None, "No Skin") {
                window1_skin = default_skin.clone();
            }
        });
        root_ui().same_line(0.);
        root_ui().group(hash!(), vec2(70.0, 100.0), |ui| {
            ui.label(None, "Window 2");
            if ui.button(None, "Skin 1") {
                window2_skin = skin1.clone();
            }
            if ui.button(None, "Skin 2") {
                window2_skin = skin2.clone();
            }
            if ui.button(None, "No Skin") {
                window2_skin = default_skin.clone();
            }
        });

        root_ui().push_skin(&window1_skin);

        root_ui().window(hash!(), vec2(20., 250.), vec2(300., 300.), |ui| {
            widgets::Button::new("Play")
                .position(vec2(65.0, 15.0))
                .ui(ui);
            widgets::Button::new("Options")
                .position(vec2(40.0, 75.0))
                .ui(ui);

            widgets::Button::new("Quit")
                .position(vec2(65.0, 195.0))
                .ui(ui);
        });
        root_ui().pop_skin();

        root_ui().push_skin(&window2_skin);
        root_ui().window(hash!(), vec2(250., 20.), vec2(500., 250.), |ui| {
            ui.checkbox(hash!(), "Checkbox 1", &mut checkbox);
            ui.combo_box(
                hash!(),
                "Combobox",
                &["First option", "Second option"],
                &mut combobox,
            );
            ui.input_text(hash!(), "Text", &mut text);
            ui.drag(hash!(), "Drag", None, &mut number);

            widgets::Button::new("Apply")
                .position(vec2(80.0, 150.0))
                .ui(ui);
            widgets::Button::new("Cancel")
                .position(vec2(280.0, 150.0))
                .ui(ui);
        });
        root_ui().pop_skin();

        next_frame().await;
    }
}

```

`examples/window_conf.rs`:

```rs
use macroquad::prelude::*;

fn window_conf() -> Conf {
    Conf {
        window_title: "Window Conf".to_owned(),
        fullscreen: true,
        platform: miniquad::conf::Platform {
            linux_backend: miniquad::conf::LinuxBackend::WaylandOnly,
            ..Default::default()
        },
        ..Default::default()
    }
}

#[macroquad::main(window_conf)]
async fn main() {
    loop {
        clear_background(WHITE);
        next_frame().await
    }
}

```

`js/README.md`:

```md
mq_js_bundle.js contains most common macroquad's dependencies JS code in one JS file.

`mq_js_bundle.js` was made by:

```bash
#!/bin/bash

function wrap_js {
    echo "(function () {" >> mq_js_bundle.js
    cat $1 >> mq_js_bundle.js
    echo "}());" >> mq_js_bundle.js
}
cat ../../miniquad/js/gl.js > mq_js_bundle.js
wrap_js ../../quad-snd/js/audio.js
wrap_js ../../sapp-jsutils/js/sapp_jsutils.js
wrap_js ../../quad-net/js/quad-net.js 
minify mq_js_bundle.js > mq_js_bundle2.js
```

```

`js/mq_js_bundle.js`:

```js
"use strict";const version=2,canvas=document.querySelector("#glcanvas");var gl,wasm_memory,animation_frame_timeout,FS,GL,Module,wasm_exports,emscripten_shaders_hack,importObject,clipboard=null,plugins=[],high_dpi=!1,blocking_event_loop=!1;function init_webgl(e){if(e==1){gl=canvas.getContext("webgl");function t(e){var t=e.getExtension("OES_vertex_array_object");t?(e.createVertexArray=function(){return t.createVertexArrayOES()},e.deleteVertexArray=function(e){t.deleteVertexArrayOES(e)},e.bindVertexArray=function(e){t.bindVertexArrayOES(e)},e.isVertexArray=function(e){return t.isVertexArrayOES(e)}):alert("Unable to get OES_vertex_array_object extension")}function n(e){var t=e.getExtension("ANGLE_instanced_arrays");t&&(e.vertexAttribDivisor=function(e,n){t.vertexAttribDivisorANGLE(e,n)},e.drawArraysInstanced=function(e,n,s,o){t.drawArraysInstancedANGLE(e,n,s,o)},e.drawElementsInstanced=function(e,n,s,o,i){t.drawElementsInstancedANGLE(e,n,s,o,i)})}function s(e){var t=e.getExtension("EXT_disjoint_timer_query");t&&(e.createQuery=function(){return t.createQueryEXT()},e.beginQuery=function(e,n){return t.beginQueryEXT(e,n)},e.endQuery=function(e){return t.endQueryEXT(e)},e.deleteQuery=function(e){t.deleteQueryEXT(e)},e.getQueryObject=function(e,n){return t.getQueryObjectEXT(e,n)})}function o(e){var t=e.getExtension("WEBGL_draw_buffers");t&&(e.drawBuffers=function(e){return t.drawBuffersWEBGL(e)})}try{gl.getExtension("EXT_shader_texture_lod"),gl.getExtension("OES_standard_derivatives")}catch(e){console.warn(e)}t(gl),n(gl),s(gl),o(gl),gl.getExtension("WEBGL_depth_texture")==null&&alert("Cant initialize WEBGL_depth_texture extension")}else gl=canvas.getContext("webgl2");gl===null&&alert("Unable to initialize WebGL. Your browser or machine may not support it.")}canvas.focus(),canvas.requestPointerLock=canvas.requestPointerLock||canvas.mozRequestPointerLock||function(){},document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock||function(){};function assert(e,t){e==!1&&alert(t)}function getArray(e,t,n){return new t(wasm_memory.buffer,e,n)}function UTF8ToString(e,t){let i=new Uint8Array(wasm_memory.buffer,e);for(var n,a,r,c,s=0,l=s+t,o="";!(s>=l);){if(n=i[s++],!n)return o;if(!(n&128)){o+=String.fromCharCode(n);continue}if(a=i[s++]&63,(n&224)==192){o+=String.fromCharCode((n&31)<<6|a);continue}r=i[s++]&63,(n&240)==224?n=(n&15)<<12|a<<6|r:((n&248)!=240&&console.warn("Invalid UTF-8 leading byte 0x"+n.toString(16)+" encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!"),n=(n&7)<<18|a<<12|r<<6|i[s++]&63),n<65536?o+=String.fromCharCode(n):(c=n-65536,o+=String.fromCharCode(55296|c>>10,56320|c&1023))}return o}function stringToUTF8(e,t,n,s){for(var o,r,c=n,i=n+s,a=0;a<e.length;++a)if(o=e.charCodeAt(a),o>=55296&&o<=57343&&(r=e.charCodeAt(++a),o=65536+((o&1023)<<10)|r&1023),o<=127){if(n>=i)break;t[n++]=o}else if(o<=2047){if(n+1>=i)break;t[n++]=192|o>>6,t[n++]=128|o&63}else if(o<=65535){if(n+2>=i)break;t[n++]=224|o>>12,t[n++]=128|o>>6&63,t[n++]=128|o&63}else{if(n+3>=i)break;o>=2097152&&console.warn("Invalid Unicode code point 0x"+o.toString(16)+" encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF)."),t[n++]=240|o>>18,t[n++]=128|o>>12&63,t[n++]=128|o>>6&63,t[n++]=128|o&63}return n-c}FS={loaded_files:[],unique_id:0},GL={counter:1,buffers:[],mappedBuffers:{},programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],timerQueries:[],contexts:{},programInfos:{},getNewId:function(e){for(var n=GL.counter++,t=e.length;t<n;t++)e[t]=null;return n},validateGLObjectID:function(e,t,n,s){t!=0&&(e[t]===null?console.error(n+" called with an already deleted "+s+" ID "+t+"!"):e[t]||console.error(n+" called with an invalid "+s+" ID "+t+"!"))},getSource:function(e,t,n,s){for(var a,i="",o=0;o<t;++o)a=s==0?0[0]:getArray(s+o*4,Uint32Array,1)[0],i+=UTF8ToString(getArray(n+o*4,Uint32Array,1)[0],a);return i},populateUniformTable:function(e){GL.validateGLObjectID(GL.programs,e,"populateUniformTable","program");for(var t,n,s,i,a,l,o=GL.programs[e],r=GL.programInfos[e]={uniforms:{},maxUniformLength:0,maxAttributeLength:-1,maxUniformBlockNameLength:-1},d=r.uniforms,u=gl.getProgramParameter(o,35718),c=0;c<u;++c)if(i=gl.getActiveUniform(o,c),t=i.name,r.maxUniformLength=Math.max(r.maxUniformLength,t.length+1),t.slice(-1)=="]"&&(t=t.slice(0,t.lastIndexOf("["))),n=gl.getUniformLocation(o,t),n){s=GL.getNewId(GL.uniforms),d[t]=[i.size,s],GL.uniforms[s]=n;for(a=1;a<i.size;++a)l=t+"["+a+"]",n=gl.getUniformLocation(o,l),s=GL.getNewId(GL.uniforms),GL.uniforms[s]=n}}};function _glGenObject(e,t,n,s,o){for(var i,a,r=0;r<e;r++)i=gl[n](),a=i&&GL.getNewId(s),i?(i.name=a,s[a]=i):(console.error("GL_INVALID_OPERATION"),GL.recordError(1282),alert("GL_INVALID_OPERATION in "+o+": GLctx."+n+" returned null - most likely GL context is lost!")),getArray(t+r*4,Int32Array,1)[0]=a}function _webglGet(e,t,n){if(!t){console.error("GL_INVALID_VALUE in glGet"+n+"v(name="+e+": Function called with null out pointer!"),GL.recordError(1281);return}var s,i,a,o=0[0];switch(e){case 36346:o=1;break;case 36344:n!="EM_FUNC_SIG_PARAM_I"&&n!="EM_FUNC_SIG_PARAM_I64"&&(GL.recordError(1280),err("GL_INVALID_ENUM in glGet"+n+"v(GL_SHADER_BINARY_FORMATS): Invalid parameter type!"));return;case 34814:case 36345:o=0;break;case 34466:i=gl.getParameter(34467),o=i?i.length:0;break;case 33309:assert(!1,"unimplemented");break;case 33307:case 33308:assert(!1,"unimplemented");break}if(o===0[0])switch(s=gl.getParameter(e),typeof s){case"number":o=s;break;case"boolean":o=s?1:0;break;case"string":GL.recordError(1280),console.error("GL_INVALID_ENUM in glGet"+n+"v("+e+") on a name which returns a string!");return;case"object":if(s===null)switch(e){case 34964:case 35725:case 34965:case 36006:case 36007:case 32873:case 34229:case 35097:case 36389:case 34068:{o=0;break}default:{GL.recordError(1280),console.error("GL_INVALID_ENUM in glGet"+n+"v("+e+") and it returns null!");return}}else if(s instanceof Float32Array||s instanceof Uint32Array||s instanceof Int32Array||s instanceof Array){for(a=0;a<s.length;++a)assert(!1,"unimplemented");return}else try{o=s.name|0}catch(t){GL.recordError(1280),console.error("GL_INVALID_ENUM in glGet"+n+"v: Unknown object returned from WebGL getParameter("+e+")! (error: "+t+")");return}break;default:GL.recordError(1280),console.error("GL_INVALID_ENUM in glGet"+n+"v: Native code calling glGet"+n+"v("+e+") and it returns "+s+" of type "+typeof s+"!");return}switch(n){case"EM_FUNC_SIG_PARAM_I64":getArray(t,Int32Array,1)[0]=o;case"EM_FUNC_SIG_PARAM_I":getArray(t,Int32Array,1)[0]=o;break;case"EM_FUNC_SIG_PARAM_F":getArray(t,Float32Array,1)[0]=o;break;case"EM_FUNC_SIG_PARAM_B":getArray(t,Int8Array,1)[0]=o?1:0;break;default:throw"internal glGet error, bad type: "+n}}function resize(e,t){var o=dpi_scale(),n=e.clientWidth*o,s=e.clientHeight*o;(e.width!=n||e.height!=s)&&(e.width=n,e.height=s,t!=null&&t(Math.floor(n),Math.floor(s)))}function animation(){wasm_exports.frame(),window.blocking_event_loop||(animation_frame_timeout&&window.cancelAnimationFrame(animation_frame_timeout),animation_frame_timeout=window.requestAnimationFrame(animation))}const SAPP_EVENTTYPE_TOUCHES_BEGAN=10,SAPP_EVENTTYPE_TOUCHES_MOVED=11,SAPP_EVENTTYPE_TOUCHES_ENDED=12,SAPP_EVENTTYPE_TOUCHES_CANCELED=13,SAPP_MODIFIER_SHIFT=1,SAPP_MODIFIER_CTRL=2,SAPP_MODIFIER_ALT=4,SAPP_MODIFIER_SUPER=8;function into_sapp_mousebutton(e){switch(e){case 0:return 0;case 1:return 2;case 2:return 1;default:return e}}function into_sapp_keycode(e){switch(e){case"Space":return 32;case"Quote":return 222;case"Comma":return 44;case"Minus":return 45;case"Period":return 46;case"Slash":return 189;case"Digit0":return 48;case"Digit1":return 49;case"Digit2":return 50;case"Digit3":return 51;case"Digit4":return 52;case"Digit5":return 53;case"Digit6":return 54;case"Digit7":return 55;case"Digit8":return 56;case"Digit9":return 57;case"Semicolon":return 59;case"Equal":return 61;case"KeyA":return 65;case"KeyB":return 66;case"KeyC":return 67;case"KeyD":return 68;case"KeyE":return 69;case"KeyF":return 70;case"KeyG":return 71;case"KeyH":return 72;case"KeyI":return 73;case"KeyJ":return 74;case"KeyK":return 75;case"KeyL":return 76;case"KeyM":return 77;case"KeyN":return 78;case"KeyO":return 79;case"KeyP":return 80;case"KeyQ":return 81;case"KeyR":return 82;case"KeyS":return 83;case"KeyT":return 84;case"KeyU":return 85;case"KeyV":return 86;case"KeyW":return 87;case"KeyX":return 88;case"KeyY":return 89;case"KeyZ":return 90;case"BracketLeft":return 91;case"Backslash":return 92;case"BracketRight":return 93;case"Backquote":return 96;case"Escape":return 256;case"Enter":return 257;case"Tab":return 258;case"Backspace":return 259;case"Insert":return 260;case"Delete":return 261;case"ArrowRight":return 262;case"ArrowLeft":return 263;case"ArrowDown":return 264;case"ArrowUp":return 265;case"PageUp":return 266;case"PageDown":return 267;case"Home":return 268;case"End":return 269;case"CapsLock":return 280;case"ScrollLock":return 281;case"NumLock":return 282;case"PrintScreen":return 283;case"Pause":return 284;case"F1":return 290;case"F2":return 291;case"F3":return 292;case"F4":return 293;case"F5":return 294;case"F6":return 295;case"F7":return 296;case"F8":return 297;case"F9":return 298;case"F10":return 299;case"F11":return 300;case"F12":return 301;case"F13":return 302;case"F14":return 303;case"F15":return 304;case"F16":return 305;case"F17":return 306;case"F18":return 307;case"F19":return 308;case"F20":return 309;case"F21":return 310;case"F22":return 311;case"F23":return 312;case"F24":return 313;case"Numpad0":return 320;case"Numpad1":return 321;case"Numpad2":return 322;case"Numpad3":return 323;case"Numpad4":return 324;case"Numpad5":return 325;case"Numpad6":return 326;case"Numpad7":return 327;case"Numpad8":return 328;case"Numpad9":return 329;case"NumpadDecimal":return 330;case"NumpadDivide":return 331;case"NumpadMultiply":return 332;case"NumpadSubtract":return 333;case"NumpadAdd":return 334;case"NumpadEnter":return 335;case"NumpadEqual":return 336;case"ShiftLeft":return 340;case"ControlLeft":return 341;case"AltLeft":return 342;case"OSLeft":return 343;case"ShiftRight":return 344;case"ControlRight":return 345;case"AltRight":return 346;case"OSRight":return 347;case"ContextMenu":return 348}console.log("Unsupported keyboard key: ",e)}function dpi_scale(){return high_dpi?window.devicePixelRatio||1:1}function texture_size(e,t,n){return e==gl.ALPHA?t*n:e==gl.RGB?t*n*3:e==gl.RGBA?t*n*4:t*n*3}function mouse_relative_position(e,t){var n=canvas.getBoundingClientRect(),s=(e-n.left)*dpi_scale(),o=(t-n.top)*dpi_scale();return{x:s,y:o}}emscripten_shaders_hack=!1,importObject={env:{console_debug:function(e){console.debug(UTF8ToString(e))},console_log:function(e){console.log(UTF8ToString(e))},console_info:function(e){console.info(UTF8ToString(e))},console_warn:function(e){console.warn(UTF8ToString(e))},console_error:function(e){console.error(UTF8ToString(e))},set_emscripten_shader_hack:function(e){emscripten_shaders_hack=e},sapp_set_clipboard:function(e,t){clipboard=UTF8ToString(e,t)},dpi_scale,rand:function(){return Math.floor(Math.random()*2147483647)},now:function(){return Date.now()/1e3},canvas_width:function(){return Math.floor(canvas.width)},canvas_height:function(){return Math.floor(canvas.height)},glClearDepthf:function(e){gl.clearDepth(e)},glClearColor:function(e,t,n,s){gl.clearColor(e,t,n,s)},glClearStencil:function(e){gl.clearStencil(e)},glColorMask:function(e,t,n,s){gl.colorMask(e,t,n,s)},glScissor:function(e,t,n,s){gl.scissor(e,t,n,s)},glClear:function(e){gl.clear(e)},glGenTextures:function(e,t){_glGenObject(e,t,"createTexture",GL.textures,"glGenTextures")},glActiveTexture:function(e){gl.activeTexture(e)},glBindTexture:function(e,t){GL.validateGLObjectID(GL.textures,t,"glBindTexture","texture"),gl.bindTexture(e,GL.textures[t])},glTexImage2D:function(e,t,n,s,o,i,a,r,c){gl.texImage2D(e,t,n,s,o,i,a,r,c?getArray(c,Uint8Array,texture_size(n,s,o)):null)},glTexSubImage2D:function(e,t,n,s,o,i,a,r,c){gl.texSubImage2D(e,t,n,s,o,i,a,r,c?getArray(c,Uint8Array,texture_size(a,o,i)):null)},glReadPixels:function(e,t,n,s,o,i,a){var r=getArray(a,Uint8Array,texture_size(o,n,s));gl.readPixels(e,t,n,s,o,i,r)},glTexParameteri:function(e,t,n){gl.texParameteri(e,t,n)},glUniform1fv:function(e,t,n){GL.validateGLObjectID(GL.uniforms,e,"glUniform1fv","location"),assert((n&3)==0,"Pointer to float data passed to glUniform1fv must be aligned to four bytes!");var s=getArray(n,Float32Array,1*t);gl.uniform1fv(GL.uniforms[e],s)},glUniform2fv:function(e,t,n){GL.validateGLObjectID(GL.uniforms,e,"glUniform2fv","location"),assert((n&3)==0,"Pointer to float data passed to glUniform2fv must be aligned to four bytes!");var s=getArray(n,Float32Array,2*t);gl.uniform2fv(GL.uniforms[e],s)},glUniform3fv:function(e,t,n){GL.validateGLObjectID(GL.uniforms,e,"glUniform3fv","location"),assert((n&3)==0,"Pointer to float data passed to glUniform3fv must be aligned to four bytes!");var s=getArray(n,Float32Array,3*t);gl.uniform3fv(GL.uniforms[e],s)},glUniform4fv:function(e,t,n){GL.validateGLObjectID(GL.uniforms,e,"glUniform4fv","location"),assert((n&3)==0,"Pointer to float data passed to glUniform4fv must be aligned to four bytes!");var s=getArray(n,Float32Array,4*t);gl.uniform4fv(GL.uniforms[e],s)},glUniform1iv:function(e,t,n){GL.validateGLObjectID(GL.uniforms,e,"glUniform1fv","location"),assert((n&3)==0,"Pointer to i32 data passed to glUniform1iv must be aligned to four bytes!");var s=getArray(n,Int32Array,1*t);gl.uniform1iv(GL.uniforms[e],s)},glUniform2iv:function(e,t,n){GL.validateGLObjectID(GL.uniforms,e,"glUniform2fv","location"),assert((n&3)==0,"Pointer to i32 data passed to glUniform2iv must be aligned to four bytes!");var s=getArray(n,Int32Array,2*t);gl.uniform2iv(GL.uniforms[e],s)},glUniform3iv:function(e,t,n){GL.validateGLObjectID(GL.uniforms,e,"glUniform3fv","location"),assert((n&3)==0,"Pointer to i32 data passed to glUniform3iv must be aligned to four bytes!");var s=getArray(n,Int32Array,3*t);gl.uniform3iv(GL.uniforms[e],s)},glUniform4iv:function(e,t,n){GL.validateGLObjectID(GL.uniforms,e,"glUniform4fv","location"),assert((n&3)==0,"Pointer to i32 data passed to glUniform4iv must be aligned to four bytes!");var s=getArray(n,Int32Array,4*t);gl.uniform4iv(GL.uniforms[e],s)},glBlendFunc:function(e,t){gl.blendFunc(e,t)},glBlendEquationSeparate:function(e,t){gl.blendEquationSeparate(e,t)},glDisable:function(e){gl.disable(e)},glDrawElements:function(e,t,n,s){gl.drawElements(e,t,n,s)},glGetIntegerv:function(e,t){_webglGet(e,t,"EM_FUNC_SIG_PARAM_I")},glUniform1f:function(e,t){GL.validateGLObjectID(GL.uniforms,e,"glUniform1f","location"),gl.uniform1f(GL.uniforms[e],t)},glUniform1i:function(e,t){GL.validateGLObjectID(GL.uniforms,e,"glUniform1i","location"),gl.uniform1i(GL.uniforms[e],t)},glGetAttribLocation:function(e,t){return gl.getAttribLocation(GL.programs[e],UTF8ToString(t))},glEnableVertexAttribArray:function(e){gl.enableVertexAttribArray(e)},glDisableVertexAttribArray:function(e){gl.disableVertexAttribArray(e)},glVertexAttribPointer:function(e,t,n,s,o,i){gl.vertexAttribPointer(e,t,n,!!s,o,i)},glVertexAttribIPointer:function(e,t,n,s,o){gl.vertexAttribIPointer(e,t,n,s,o)},glGetUniformLocation:function(e,t){GL.validateGLObjectID(GL.programs,e,"glGetUniformLocation","program"),t=UTF8ToString(t);var s,o,n=0;return t[t.length-1]=="]"&&(s=t.lastIndexOf("["),n=t[s+1]!="]"?parseInt(t.slice(s+1)):0,t=t.slice(0,s)),o=GL.programInfos[e]&&GL.programInfos[e].uniforms[t],o&&n>=0&&n<o[0]?o[1]+n:-1},glUniformMatrix4fv:function(e,t,n,s){GL.validateGLObjectID(GL.uniforms,e,"glUniformMatrix4fv","location"),assert((s&3)==0,"Pointer to float data passed to glUniformMatrix4fv must be aligned to four bytes!");var o=getArray(s,Float32Array,16);gl.uniformMatrix4fv(GL.uniforms[e],!!n,o)},glUseProgram:function(e){GL.validateGLObjectID(GL.programs,e,"glUseProgram","program"),gl.useProgram(GL.programs[e])},glGenVertexArrays:function(e,t){_glGenObject(e,t,"createVertexArray",GL.vaos,"glGenVertexArrays")},glGenFramebuffers:function(e,t){_glGenObject(e,t,"createFramebuffer",GL.framebuffers,"glGenFramebuffers")},glGenRenderbuffers:function(e,t){_glGenObject(e,t,"createRenderbuffer",GL.renderbuffers,"glGenRenderbuffers")},glBindVertexArray:function(e){gl.bindVertexArray(GL.vaos[e])},glBindFramebuffer:function(e,t){GL.validateGLObjectID(GL.framebuffers,t,"glBindFramebuffer","framebuffer"),gl.bindFramebuffer(e,GL.framebuffers[t])},glBindRenderbuffer:function(e,t){GL.validateGLObjectID(GL.renderbuffers,t,"glBindRenderbuffer","renderbuffer"),gl.bindRenderbuffer(e,GL.renderbuffers[t])},glGenBuffers:function(e,t){_glGenObject(e,t,"createBuffer",GL.buffers,"glGenBuffers")},glBindBuffer:function(e,t){GL.validateGLObjectID(GL.buffers,t,"glBindBuffer","buffer"),gl.bindBuffer(e,GL.buffers[t])},glBufferData:function(e,t,n,s){gl.bufferData(e,n?getArray(n,Uint8Array,t):t,s)},glBufferSubData:function(e,t,n,s){gl.bufferSubData(e,t,s?getArray(s,Uint8Array,n):n)},glEnable:function(e){gl.enable(e)},glFlush:function(){gl.flush()},glFinish:function(){gl.finish()},glDepthFunc:function(e){gl.depthFunc(e)},glBlendFuncSeparate:function(e,t,n,s){gl.blendFuncSeparate(e,t,n,s)},glViewport:function(e,t,n,s){gl.viewport(e,t,n,s)},glDrawArrays:function(e,t,n){gl.drawArrays(e,t,n)},glDrawBuffers:function(e,t){gl.drawBuffers(getArray(t,Int32Array,e))},glCreateProgram:function(){var e=GL.getNewId(GL.programs),t=gl.createProgram();return t.name=e,GL.programs[e]=t,e},glAttachShader:function(e,t){GL.validateGLObjectID(GL.programs,e,"glAttachShader","program"),GL.validateGLObjectID(GL.shaders,t,"glAttachShader","shader"),gl.attachShader(GL.programs[e],GL.shaders[t])},glDetachShader:function(e,t){GL.validateGLObjectID(GL.programs,e,"glDetachShader","program"),GL.validateGLObjectID(GL.shaders,t,"glDetachShader","shader"),gl.detachShader(GL.programs[e],GL.shaders[t])},glLinkProgram:function(e){GL.validateGLObjectID(GL.programs,e,"glLinkProgram","program"),gl.linkProgram(GL.programs[e]),GL.populateUniformTable(e)},glPixelStorei:function(e,t){gl.pixelStorei(e,t)},glFramebufferTexture2D:function(e,t,n,s,o){GL.validateGLObjectID(GL.textures,s,"glFramebufferTexture2D","texture"),gl.framebufferTexture2D(e,t,n,GL.textures[s],o)},glGetProgramiv:function(e,t,n){if(assert(n),GL.validateGLObjectID(GL.programs,e,"glGetProgramiv","program"),e>=GL.counter){console.error("GL_INVALID_VALUE in glGetProgramiv");return}var s,o=GL.programInfos[e];if(!o){console.error("GL_INVALID_OPERATION in glGetProgramiv(program="+e+", pname="+t+", p=0x"+n.toString(16)+"): The specified GL object name does not refer to a program object!");return}if(t==35716)s=gl.getProgramInfoLog(GL.programs[e]),assert(s!==null),getArray(n,Int32Array,1)[0]=s.length+1;else if(t==35719){console.error("unsupported operation");return}else if(t==35722){console.error("unsupported operation");return}else if(t==35381){console.error("unsupported operation");return}else getArray(n,Int32Array,1)[0]=gl.getProgramParameter(GL.programs[e],t)},glCreateShader:function(e){var t=GL.getNewId(GL.shaders);return GL.shaders[t]=gl.createShader(e),t},glStencilFuncSeparate:function(e,t,n,s){gl.stencilFuncSeparate(e,t,n,s)},glStencilMaskSeparate:function(e,t){gl.stencilMaskSeparate(e,t)},glStencilOpSeparate:function(e,t,n,s){gl.stencilOpSeparate(e,t,n,s)},glFrontFace:function(e){gl.frontFace(e)},glCullFace:function(e){gl.cullFace(e)},glCopyTexImage2D:function(e,t,n,s,o,i,a,r){gl.copyTexImage2D(e,t,n,s,o,i,a,r)},glShaderSource:function(e,t,n,s){GL.validateGLObjectID(GL.shaders,e,"glShaderSource","shader");var i,o=GL.getSource(e,t,n,s);emscripten_shaders_hack&&(o=o.replace(/#extension GL_OES_standard_derivatives : enable/g,""),o=o.replace(/#extension GL_EXT_shader_texture_lod : enable/g,""),i="",o.indexOf("gl_FragColor")!=-1&&(i+=`out mediump vec4 GL_FragColor;
`,o=o.replace(/gl_FragColor/g,"GL_FragColor")),o.indexOf("attribute")!=-1?(o=o.replace(/attribute/g,"in"),o=o.replace(/varying/g,"out")):o=o.replace(/varying/g,"in"),o=o.replace(/textureCubeLodEXT/g,"textureCubeLod"),o=o.replace(/texture2DLodEXT/g,"texture2DLod"),o=o.replace(/texture2DProjLodEXT/g,"texture2DProjLod"),o=o.replace(/texture2DGradEXT/g,"texture2DGrad"),o=o.replace(/texture2DProjGradEXT/g,"texture2DProjGrad"),o=o.replace(/textureCubeGradEXT/g,"textureCubeGrad"),o=o.replace(/textureCube/g,"texture"),o=o.replace(/texture1D/g,"texture"),o=o.replace(/texture2D/g,"texture"),o=o.replace(/texture3D/g,"texture"),o=o.replace(/#version 100/g,`#version 300 es
`+i)),gl.shaderSource(GL.shaders[e],o)},glGetProgramInfoLog:function(e,t,n,s){GL.validateGLObjectID(GL.programs,e,"glGetProgramInfoLog","program");var o,i=gl.getProgramInfoLog(GL.programs[e]);assert(i!==null);let a=getArray(s,Uint8Array,t);for(o=0;o<t;o++)a[o]=i.charCodeAt(o)},glGetString:function(e){var t=gl.getParameter(e).toString(),n=t.length+1,s=wasm_exports.allocate_vec_u8(n),o=new Uint8Array(wasm_memory.buffer,s,n);return o[t.length]=0,stringToUTF8(t,o,0,n),s},glCompileShader:function(e){GL.validateGLObjectID(GL.shaders,e,"glCompileShader","shader"),gl.compileShader(GL.shaders[e])},glGetShaderiv:function(e,t,n){if(assert(n),GL.validateGLObjectID(GL.shaders,e,"glGetShaderiv","shader"),t==35716){var s,i,o=gl.getShaderInfoLog(GL.shaders[e]);assert(o!==null),getArray(n,Int32Array,1)[0]=o.length+1}else t==35720?(s=gl.getShaderSource(GL.shaders[e]),i=s===null||s.length==0?0:s.length+1,getArray(n,Int32Array,1)[0]=i):getArray(n,Int32Array,1)[0]=gl.getShaderParameter(GL.shaders[e],t)},glGetShaderInfoLog:function(e,t,n,s){GL.validateGLObjectID(GL.shaders,e,"glGetShaderInfoLog","shader");var o,i=gl.getShaderInfoLog(GL.shaders[e]);assert(i!==null);let a=getArray(s,Uint8Array,t);for(o=0;o<t;o++)a[o]=i.charCodeAt(o)},glVertexAttribDivisor:function(e,t){gl.vertexAttribDivisor(e,t)},glDrawArraysInstanced:function(e,t,n,s){gl.drawArraysInstanced(e,t,n,s)},glDrawElementsInstanced:function(e,t,n,s,o){gl.drawElementsInstanced(e,t,n,s,o)},glDeleteShader:function(e){var t=GL.shaders[e];if(t==null)return;gl.deleteShader(t),GL.shaders[e]=null},glDeleteProgram:function(e){var t=GL.programs[e];if(t==null)return;gl.deleteProgram(t),GL.programs[e]=null},glDeleteBuffers:function(e,t){for(var n,o,s=0;s<e;s++){if(o=getArray(t+s*4,Uint32Array,1)[0],n=GL.buffers[o],!n)continue;gl.deleteBuffer(n),n.name=0,GL.buffers[o]=null}},glDeleteFramebuffers:function(e,t){for(var n,o,s=0;s<e;s++){if(o=getArray(t+s*4,Uint32Array,1)[0],n=GL.framebuffers[o],!n)continue;gl.deleteFramebuffer(n),n.name=0,GL.framebuffers[o]=null}},glDeleteRenderbuffers:function(e,t){for(var n,o,s=0;s<e;s++){if(o=getArray(t+s*4,Uint32Array,1)[0],n=GL.renderbuffers[o],!n)continue;gl.deleteRenderbuffer(n),n.name=0,GL.renderbuffers[o]=null}},glDeleteTextures:function(e,t){for(var n,o,s=0;s<e;s++){if(o=getArray(t+s*4,Uint32Array,1)[0],n=GL.textures[o],!n)continue;gl.deleteTexture(n),n.name=0,GL.textures[o]=null}},glGenQueries:function(e,t){_glGenObject(e,t,"createQuery",GL.timerQueries,"glGenQueries")},glDeleteQueries:function(e){for(var n,o,s=0;s<e;s++){if(o=getArray(textures+s*4,Uint32Array,1)[0],n=GL.timerQueries[o],!n)continue;gl.deleteQuery(n),n.name=0,GL.timerQueries[o]=null}},glBeginQuery:function(e,t){GL.validateGLObjectID(GL.timerQueries,t,"glBeginQuery","id"),gl.beginQuery(e,GL.timerQueries[t])},glEndQuery:function(e){gl.endQuery(e)},glGetQueryObjectiv:function(e,t,n){GL.validateGLObjectID(GL.timerQueries,e,"glGetQueryObjectiv","id");let s=gl.getQueryObject(GL.timerQueries[e],t);getArray(n,Uint32Array,1)[0]=s},glGetQueryObjectui64v:function(e,t,n){GL.validateGLObjectID(GL.timerQueries,e,"glGetQueryObjectui64v","id");let o=gl.getQueryObject(GL.timerQueries[e],t),s=getArray(n,Uint32Array,2);s[0]=o,s[1]=(o-s[0])/4294967296},glGenerateMipmap:function(e){gl.generateMipmap(e)},glRenderbufferStorageMultisample:function(e,t,n,s,o){gl.renderbufferStorageMultisample(e,t,n,s,o)},glFramebufferRenderbuffer:function(e,t,n,s){GL.validateGLObjectID(GL.renderbuffers,s,"glFramebufferRenderbuffer","renderbuffer"),gl.framebufferRenderbuffer(e,t,n,GL.renderbuffers[s])},glCheckFramebufferStatus:function(e){return gl.checkFramebufferStatus(e)},glReadBuffer:function(e){gl.readBuffer(e)},glBlitFramebuffer:function(e,t,n,s,o,i,a,r,c,l){gl.blitFramebuffer(e,t,n,s,o,i,a,r,c,l)},setup_canvas_size:function(e){window.high_dpi=e,resize(canvas)},run_animation_loop:function(e){canvas.onmousemove=function(e){var t=mouse_relative_position(e.clientX,e.clientY),n=t.x,s=t.y;wasm_exports.mouse_move(Math.floor(n),Math.floor(s)),(e.movementX!=0||e.movementY!=0)&&wasm_exports.raw_mouse_move(Math.floor(e.movementX),Math.floor(e.movementY))},canvas.onmousedown=function(e){var t=mouse_relative_position(e.clientX,e.clientY),n=t.x,s=t.y,o=into_sapp_mousebutton(e.button);wasm_exports.mouse_down(n,s,o)},canvas.addEventListener("wheel",function(e){e.preventDefault(),wasm_exports.mouse_wheel(-e.deltaX,-e.deltaY)}),canvas.onmouseup=function(e){var t=mouse_relative_position(e.clientX,e.clientY),n=t.x,s=t.y,o=into_sapp_mousebutton(e.button);wasm_exports.mouse_up(n,s,o)},canvas.onkeydown=function(e){var n,t=into_sapp_keycode(e.code);switch(t){case 32:case 262:case 263:case 264:case 265:case 290:case 291:case 292:case 293:case 294:case 295:case 296:case 297:case 298:case 299:case 259:case 258:case 39:case 47:e.preventDefault();break}n=0,e.ctrlKey&&(n|=SAPP_MODIFIER_CTRL),e.shiftKey&&(n|=SAPP_MODIFIER_SHIFT),e.altKey&&(n|=SAPP_MODIFIER_ALT),wasm_exports.key_down(t,n,e.repeat),(t==32||t==39||t==47)&&wasm_exports.key_press(t)},canvas.onkeyup=function(e){var n=into_sapp_keycode(e.code),t=0;e.ctrlKey&&(t|=SAPP_MODIFIER_CTRL),e.shiftKey&&(t|=SAPP_MODIFIER_SHIFT),e.altKey&&(t|=SAPP_MODIFIER_ALT),wasm_exports.key_up(n,t)},canvas.onkeypress=function(e){var t=into_sapp_keycode(e.code);let n=t==261||e.ctrlKey;n==!1&&wasm_exports.key_press(e.charCode)},canvas.addEventListener("touchstart",function(e){e.preventDefault();for(const t of e.changedTouches){let n=mouse_relative_position(t.clientX,t.clientY);wasm_exports.touch(SAPP_EVENTTYPE_TOUCHES_BEGAN,t.identifier,n.x,n.y)}}),canvas.addEventListener("touchend",function(e){e.preventDefault();for(const t of e.changedTouches){let n=mouse_relative_position(t.clientX,t.clientY);wasm_exports.touch(SAPP_EVENTTYPE_TOUCHES_ENDED,t.identifier,n.x,n.y)}}),canvas.addEventListener("touchcancel",function(e){e.preventDefault();for(const t of e.changedTouches){let n=mouse_relative_position(t.clientX,t.clientY);wasm_exports.touch(SAPP_EVENTTYPE_TOUCHES_CANCELED,t.identifier,n.x,n.y)}}),canvas.addEventListener("touchmove",function(e){e.preventDefault();for(const t of e.changedTouches){let n=mouse_relative_position(t.clientX,t.clientY);wasm_exports.touch(SAPP_EVENTTYPE_TOUCHES_MOVED,t.identifier,n.x,n.y)}}),window.onresize=function(){resize(canvas,wasm_exports.resize)},window.addEventListener("copy",function(){clipboard!=null&&(event.clipboardData.setData("text/plain",clipboard),event.preventDefault())}),window.addEventListener("cut",function(){clipboard!=null&&(event.clipboardData.setData("text/plain",clipboard),event.preventDefault())}),window.addEventListener("paste",function(e){e.stopPropagation(),e.preventDefault();var n,s,o,i=e.clipboardData||window.clipboardData,t=i.getData("Text");t!=null&&t.length!=0&&(n=(new TextEncoder).encode(t).length,s=wasm_exports.allocate_vec_u8(n),o=new Uint8Array(wasm_memory.buffer,s,n),stringToUTF8(t,o,0,n),wasm_exports.on_clipboard_paste(s,n))}),window.ondragover=function(e){e.preventDefault()},window.ondrop=async function(e){e.preventDefault(),wasm_exports.on_files_dropped_start();for(let n of e.dataTransfer.files){const t=n.name.length,o=wasm_exports.allocate_vec_u8(t),r=new Uint8Array(wasm_memory.buffer,o,t);stringToUTF8(n.name,r,0,t);const i=await n.arrayBuffer(),s=i.byteLength,a=wasm_exports.allocate_vec_u8(s),c=new Uint8Array(wasm_memory.buffer,a,s);c.set(new Uint8Array(i),0),wasm_exports.on_file_dropped(o,t,a,s)}wasm_exports.on_files_dropped_finish()};let n=document.hasFocus();var t=function(){let e=document.hasFocus()&&document.visibilityState=="visible";n!=e&&(wasm_exports.focus(e),n=e)};document.addEventListener("visibilitychange",t),window.addEventListener("focus",t),window.addEventListener("blur",t),window.blocking_event_loop=e,window.requestAnimationFrame(animation)},fs_load_file:function(e,t){var s,o=UTF8ToString(e,t),n=FS.unique_id;return FS.unique_id+=1,s=new XMLHttpRequest,s.open("GET",o,!0),s.responseType="arraybuffer",s.onreadystatechange=function(){if(this.readyState===4)if(this.status===200){var e=new Uint8Array(this.response);FS.loaded_files[n]=e,wasm_exports.file_loaded(n)}else FS.loaded_files[n]=null,wasm_exports.file_loaded(n)},s.send(),n},fs_get_buffer_size:function(e){return FS.loaded_files[e]==null?-1:FS.loaded_files[e].length},fs_take_buffer:function(e,t,n){var s,i,o=FS.loaded_files[e];console.assert(o.length<=n);for(i=new Uint8Array(wasm_memory.buffer,t,n),s=0;s<o.length;s++)i[s]=o[s];delete FS.loaded_files[e]},sapp_set_cursor_grab:function(e){e?canvas.requestPointerLock():document.exitPointerLock()},sapp_set_cursor:function(e,t){canvas.style.cursor=UTF8ToString(e,t)},sapp_is_fullscreen:function(){let e=document.fullscreenElement;return e!=null&&e.id==canvas.id},sapp_set_fullscreen:function(e){e?canvas.requestFullscreen():document.exitFullscreen()},sapp_set_window_size:function(e,t){canvas.width=e,canvas.height=t,resize(canvas,wasm_exports.resize)},sapp_schedule_update:function(){animation_frame_timeout&&window.cancelAnimationFrame(animation_frame_timeout),animation_frame_timeout=window.requestAnimationFrame(animation)},init_webgl}};function register_plugins(e){if(e==null)return;for(var t=0;t<e.length;t++)e[t].register_plugin!=0[0]&&e[t].register_plugin!=null&&e[t].register_plugin(importObject)}function init_plugins(e){if(e==null)return;for(var n,s,t=0;t<e.length;t++)e[t].on_init!=0[0]&&e[t].on_init!=null&&e[t].on_init(),e[t].name==0[0]||e[t].name==null||e[t].version==0[0]||e[t].version==null?(console.warn("Some of the registred plugins do not have name or version"),console.warn("Probably old version of the plugin used")):(n=e[t].name+"_crate_version",wasm_exports[n]==0[0]?console.log("Plugin "+e[t].name+" is present in JS bundle, but is not used in the rust code."):(s=wasm_exports[n](),e[t].version!=s&&console.error("Plugin "+e[t].name+" version mismatchjs version: "+e[t].version+", crate version: "+s)))}function miniquad_add_plugin(e){plugins.push(e)}function add_missing_functions_stabs(e){var t=WebAssembly.Module.imports(e);for(const e in t)importObject.env[t[e].name]==0[0]&&(console.warn("No "+t[e].name+" function in gl.js"),importObject.env[t[e].name]=function(){console.warn("Missed function: "+t[e].name)})}function load(e){var t=fetch(e);register_plugins(plugins),typeof WebAssembly.compileStreaming=="function"?WebAssembly.compileStreaming(t).then(e=>(add_missing_functions_stabs(e),WebAssembly.instantiate(e,importObject))).then(e=>{wasm_memory=e.exports.memory,wasm_exports=e.exports;var t=wasm_exports.crate_version();version!=t&&console.error("Version mismatch: gl.js version is: "+version+", miniquad crate version is: "+t),init_plugins(plugins),e.exports.main()}).catch(e=>{console.error(e)}):t.then(function(e){return e.arrayBuffer()}).then(function(e){return WebAssembly.compile(e)}).then(function(e){return add_missing_functions_stabs(e),WebAssembly.instantiate(e,importObject)}).then(function(e){wasm_memory=e.exports.memory,wasm_exports=e.exports;var t=wasm_exports.crate_version();version!=t&&console.error("Version mismatch: gl.js version is: "+version+", rust sapp-wasm crate version is: "+t),init_plugins(plugins),e.exports.main()}).catch(e=>{console.error("WASM failed to load, probably incompatible gl.js version"),console.error(e)})}(function(){"use strict";const c=window.AudioContext||window.webkitAudioContext;let e,n=new Map,t=[],o=1,m=1;function d(){if(e==null){e=new c;let n=e.listener;{let s=window.AudioContext||window.webkitAudioContext,n=new s;var t=function(){console.log("fix"),e.resume();var i=n.createBuffer(1,1,22050),o=n.createBufferSource();o.buffer=i,o.connect(n.destination),o.start?o.start(0):o.play?o.play(0):o.noteOn&&o.noteOn(0),document.removeEventListener("touchstart",t),document.removeEventListener("touchend",t),document.removeEventListener("mousedown",t),document.removeEventListener("keydown",t)};document.addEventListener("touchstart",t),document.addEventListener("touchend",t),document.addEventListener("mousedown",t),document.addEventListener("keydown",t)}}}function r(t,s){let a=wasm_memory.buffer.slice(t,t+s),i=o;return o+=1,e.decodeAudioData(a,function(e){n.set(i,e)},function(e){console.error("Failed to decode audio buffer",e)}),i}function a(e){return n.has(e)&&n.get(e)!=0[0]}function l(){let n=t.find(e=>e.sound_key===0);return n!=null?n.source=e.createBufferSource():(n={sound_key:0,playback_key:0,source:e.createBufferSource(),gain_node:e.createGain(),ended:null},t.push(n)),n}function s(e){try{e.source.removeEventListener("ended",e.ended),e.source.disconnect(),e.gain_node.disconnect(),e.sound_key=0,e.playback_key=0}catch(e){console.error("Error stopping sound",e)}}function u(t,o,i){let r=m++,a=l();a.sound_key=t,a.playback_key=r,a.source.connect(a.gain_node),a.gain_node.connect(e.destination),a.gain_node.gain.value=o,a.source.loop=i,a.ended=function(){s(a)},a.source.addEventListener("ended",a.ended);try{a.source.buffer=n.get(t),a.source.start(0)}catch(e){console.error("Error starting sound",e)}return r}function h(e,n){t.forEach(t=>{t.sound_key===e&&(t.gain_node.gain.value=n)})}function i(e){t.forEach(t=>{t.sound_key===e&&s(t)})}function f(e){i(e),n.delete(e)}function p(e){let n=t.find(t=>t.playback_key===e);n!=null&&s(n)}function g(e,n){let s=t.find(t=>t.playback_key===e);s!=null&&(s.gain_node.gain.value=n)}miniquad_add_plugin({register_plugin:function(e){e.env.audio_init=d,e.env.audio_add_buffer=r,e.env.audio_play_buffer=u,e.env.audio_source_is_loaded=a,e.env.audio_source_set_volume=h,e.env.audio_source_stop=i,e.env.audio_source_delete=f,e.env.audio_playback_stop=p,e.env.audio_playback_set_volume=g},version:1,name:"macroquad_audio"})})(),function(){"use strict";var n,i=null,e={};e[-1]=null,e[-2]=0[0],n=0;function o(n){n.env.js_create_string=function(e,n){var s=UTF8ToString(e,n);return t(s)},n.env.js_create_buffer=function(e,n){var s=new Uint8Array(wasm_memory.buffer,e,n),o=new Uint8Array(new ArrayBuffer(s.byteLength));return o.set(new Uint8Array(s)),t(o)},n.env.js_create_object=function(){var e={};return t(e)},n.env.js_set_field_f32=function(t,n,s,o){var i=UTF8ToString(n,s);e[t][i]=o},n.env.js_set_field_u32=function(t,n,s,o){var i=UTF8ToString(n,s);e[t][i]=o},n.env.js_set_field_string=function(t,n,s,o,i){var a=UTF8ToString(n,s),r=UTF8ToString(o,i);e[t][a]=r},n.env.js_unwrap_to_str=function(t,n,o){for(var r=e[t],a=s(r),c=a.length,l=new Uint8Array(wasm_memory.buffer,n,o),i=0;i<c;i++)l[i]=a[i]},n.env.js_unwrap_to_buf=function(t,n,s){for(var i=e[t],a=i.length,r=new Uint8Array(wasm_memory.buffer,n,s),o=0;o<a;o++)r[o]=i[o]},n.env.js_string_length=function(t){var n=e[t];return s(n).length},n.env.js_buf_length=function(t){var n=e[t];return n.length},n.env.js_free_object=function(t){delete e[t]},n.env.js_have_field=function(t,n,s){var o=UTF8ToString(n,s);return e[t][o]!==0[0]},n.env.js_field_f32=function(t,n,s){var o=UTF8ToString(n,s);return e[t][o]},n.env.js_field_u32=function(t,n,s){var o=UTF8ToString(n,s);return e[t][o]},n.env.js_field=function(n,s,o){var i=UTF8ToString(s,o),a=e[n][i];return t(a)},n.env.js_field_num=function(t,n,s){var o=UTF8ToString(n,s);return e[t][o]}}miniquad_add_plugin({register_plugin:o,version:1,name:"sapp_jsutils"});function s(e){for(var t,n=[],s=0;s<e.length;s++)t=e.charCodeAt(s),t<128?n.push(t):t<2048?n.push(192|t>>6,128|t&63):t<55296||t>=57344?n.push(224|t>>12,128|t>>6&63,128|t&63):(s++,t=65536+((t&1023)<<10|e.charCodeAt(s)&1023),n.push(240|t>>18,128|t>>12&63,128|t>>6&63,128|t&63));return n}function t(t){if(t==null)return-2;if(t===null)return-1;var s=n;return e[s]=t,n+=1,s}function a(t){var n=e[t];return delete e[t],n}function r(t){return e[t]}}(),function(){function i(){}register_plugin=function(e){e.env.ws_connect=r,e.env.ws_is_connected=a,e.env.ws_send=c,e.env.ws_try_recv=l,e.env.http_make_request=u,e.env.http_try_recv=d},miniquad_add_plugin({register_plugin,on_init:i,version:1,name:"quad_net"});var e,t,s,o=0,n=[];function a(){return o}function r(t){e=new WebSocket(consume_js_object(t)),e.binaryType="arraybuffer",e.onopen=function(){o=1},e.onmessage=function(e){if(typeof e.data=="string")n.push({text:1,data:e.data});else{var t=new Uint8Array(e.data);n.push({text:0,data:t})}}}function c(t){var n=consume_js_object(t);n.buffer!=0[0]?e.send(n.buffer):e.send(n)}function l(){return n.length!=0?js_object(n.shift()):-1}s=0,t={};function d(e){if(t[e]!=0[0]&&t[e]!=null){var n=t[e];return t[e]=null,js_object(n)}return-1}function u(e,n,o,i){var a,r,c,d,u,l=s;s+=1,e==0&&(r="POST"),e==1&&(r="PUT"),e==2&&(r="GET"),e==3&&(r="DELETE"),d=consume_js_object(n),u=consume_js_object(o),c=consume_js_object(i),a=new XMLHttpRequest,a.open(r,d,!0),a.responseType="arraybuffer";for(const e in c)a.setRequestHeader(e,c[e]);return a.onload=function(){if(this.status==200){var n=new Uint8Array(this.response);t[l]=n}},a.onerror=function(e){console.error("Failed to make a request"),console.error(e)},a.send(u),l}}()
```

`macroquad_macro/Cargo.toml`:

```toml
[package]
name = "macroquad_macro"
version = "0.1.8"
authors = ["not-fl3 <not.fl3@gmail.com>"]
edition = "2018"
license = "MIT/Apache-2.0"
repository = "https://github.com/not-fl3/macroquad"
description = """
Proc macro for macroquad
"""
include = ["Cargo.toml", "src/", "README.md", "LICENSE-*"]

[lib]
proc-macro = true

[dependencies]

```

`macroquad_macro/LICENSE-APACHE`:

```
                              Apache License
                        Version 2.0, January 2004
                     http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

   "License" shall mean the terms and conditions for use, reproduction,
   and distribution as defined by Sections 1 through 9 of this document.

   "Licensor" shall mean the copyright owner or entity authorized by
   the copyright owner that is granting the License.

   "Legal Entity" shall mean the union of the acting entity and all
   other entities that control, are controlled by, or are under common
   control with that entity. For the purposes of this definition,
   "control" means (i) the power, direct or indirect, to cause the
   direction or management of such entity, whether by contract or
   otherwise, or (ii) ownership of fifty percent (50%) or more of the
   outstanding shares, or (iii) beneficial ownership of such entity.

   "You" (or "Your") shall mean an individual or Legal Entity
   exercising permissions granted by this License.

   "Source" form shall mean the preferred form for making modifications,
   including but not limited to software source code, documentation
   source, and configuration files.

   "Object" form shall mean any form resulting from mechanical
   transformation or translation of a Source form, including but
   not limited to compiled object code, generated documentation,
   and conversions to other media types.

   "Work" shall mean the work of authorship, whether in Source or
   Object form, made available under the License, as indicated by a
   copyright notice that is included in or attached to the work
   (an example is provided in the Appendix below).

   "Derivative Works" shall mean any work, whether in Source or Object
   form, that is based on (or derived from) the Work and for which the
   editorial revisions, annotations, elaborations, or other modifications
   represent, as a whole, an original work of authorship. For the purposes
   of this License, Derivative Works shall not include works that remain
   separable from, or merely link (or bind by name) to the interfaces of,
   the Work and Derivative Works thereof.

   "Contribution" shall mean any work of authorship, including
   the original version of the Work and any modifications or additions
   to that Work or Derivative Works thereof, that is intentionally
   submitted to Licensor for inclusion in the Work by the copyright owner
   or by an individual or Legal Entity authorized to submit on behalf of
   the copyright owner. For the purposes of this definition, "submitted"
   means any form of electronic, verbal, or written communication sent
   to the Licensor or its representatives, including but not limited to
   communication on electronic mailing lists, source code control systems,
   and issue tracking systems that are managed by, or on behalf of, the
   Licensor for the purpose of discussing and improving the Work, but
   excluding communication that is conspicuously marked or otherwise
   designated in writing by the copyright owner as "Not a Contribution."

   "Contributor" shall mean Licensor and any individual or Legal Entity
   on behalf of whom a Contribution has been received by Licensor and
   subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   copyright license to reproduce, prepare Derivative Works of,
   publicly display, publicly perform, sublicense, and distribute the
   Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   (except as stated in this section) patent license to make, have made,
   use, offer to sell, sell, import, and otherwise transfer the Work,
   where such license applies only to those patent claims licensable
   by such Contributor that are necessarily infringed by their
   Contribution(s) alone or by combination of their Contribution(s)
   with the Work to which such Contribution(s) was submitted. If You
   institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work
   or a Contribution incorporated within the Work constitutes direct
   or contributory patent infringement, then any patent licenses
   granted to You under this License for that Work shall terminate
   as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
   Work or Derivative Works thereof in any medium, with or without
   modifications, and in Source or Object form, provided that You
   meet the following conditions:

   (a) You must give any other recipients of the Work or
       Derivative Works a copy of this License; and

   (b) You must cause any modified files to carry prominent notices
       stating that You changed the files; and

   (c) You must retain, in the Source form of any Derivative Works
       that You distribute, all copyright, patent, trademark, and
       attribution notices from the Source form of the Work,
       excluding those notices that do not pertain to any part of
       the Derivative Works; and

   (d) If the Work includes a "NOTICE" text file as part of its
       distribution, then any Derivative Works that You distribute must
       include a readable copy of the attribution notices contained
       within such NOTICE file, excluding those notices that do not
       pertain to any part of the Derivative Works, in at least one
       of the following places: within a NOTICE text file distributed
       as part of the Derivative Works; within the Source form or
       documentation, if provided along with the Derivative Works; or,
       within a display generated by the Derivative Works, if and
       wherever such third-party notices normally appear. The contents
       of the NOTICE file are for informational purposes only and
       do not modify the License. You may add Your own attribution
       notices within Derivative Works that You distribute, alongside
       or as an addendum to the NOTICE text from the Work, provided
       that such additional attribution notices cannot be construed
       as modifying the License.

   You may add Your own copyright statement to Your modifications and
   may provide additional or different license terms and conditions
   for use, reproduction, or distribution of Your modifications, or
   for any such Derivative Works as a whole, provided Your use,
   reproduction, and distribution of the Work otherwise complies with
   the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
   any Contribution intentionally submitted for inclusion in the Work
   by You to the Licensor shall be under the terms and conditions of
   this License, without any additional terms or conditions.
   Notwithstanding the above, nothing herein shall supersede or modify
   the terms of any separate license agreement you may have executed
   with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor,
   except as required for reasonable and customary use in describing the
   origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
   agreed to in writing, Licensor provides the Work (and each
   Contributor provides its Contributions) on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied, including, without limitation, any warranties or conditions
   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
   PARTICULAR PURPOSE. You are solely responsible for determining the
   appropriateness of using or redistributing the Work and assume any
   risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
   whether in tort (including negligence), contract, or otherwise,
   unless required by applicable law (such as deliberate and grossly
   negligent acts) or agreed to in writing, shall any Contributor be
   liable to You for damages, including any direct, indirect, special,
   incidental, or consequential damages of any character arising as a
   result of this License or out of the use or inability to use the
   Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all
   other commercial damages or losses), even if such Contributor
   has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
   the Work or Derivative Works thereof, You may choose to offer,
   and charge a fee for, acceptance of support, warranty, indemnity,
   or other liability obligations and/or rights consistent with this
   License. However, in accepting such obligations, You may act only
   on Your own behalf and on Your sole responsibility, not on behalf
   of any other Contributor, and only if You agree to indemnify,
   defend, and hold each Contributor harmless for any liability
   incurred by, or claims asserted against, such Contributor by reason
   of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

   To apply the Apache License to your work, attach the following
   boilerplate notice, with the fields enclosed by brackets "[]"
   replaced with your own identifying information. (Don't include
   the brackets!)  The text should be enclosed in the appropriate
   comment syntax for the file format. We also recommend that a
   file or class name and description of purpose be included on the
   same "printed page" as the copyright notice for easier
   identification within third-party archives.

Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

```

`macroquad_macro/LICENSE-MIT`:

```
MIT/X Consortium License

@ 2019-2021 Fedor Logachev <not.fl3@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.


```

`macroquad_macro/README.md`:

```md
Internal crate for macroquad

```

`macroquad_macro/src/lib.rs`:

```rs
extern crate proc_macro;
use proc_macro::{Ident, TokenStream, TokenTree};

use std::iter::Peekable;

fn next_group(source: &mut Peekable<impl Iterator<Item = TokenTree>>) -> Option<proc_macro::Group> {
    if let Some(TokenTree::Group(_)) = source.peek() {
        let group = match source.next().unwrap() {
            TokenTree::Group(group) => group,
            _ => unreachable!("just checked with peek()!"),
        };
        Some(group)
    } else {
        None
    }
}

fn next_literal(source: &mut Peekable<impl Iterator<Item = TokenTree>>) -> Option<String> {
    if let Some(TokenTree::Literal(lit)) = source.peek() {
        let mut literal = lit.to_string();

        // the only way to check that literal is string :/
        if literal.starts_with("\"") {
            literal.remove(0);
            literal.remove(literal.len() - 1);
        }
        source.next();
        return Some(literal);
    }

    return None;
}

#[proc_macro_attribute]
pub fn main(attr: TokenStream, item: TokenStream) -> TokenStream {
    let mut modified = TokenStream::new();
    let mut source = item.into_iter().peekable();

    let mut crate_rename = None;

    while let Some(TokenTree::Punct(punct)) = source.peek() {
        assert_eq!(format!("{}", punct), "#");

        // skip '#'
        let _ = source.next().unwrap();

        let group = next_group(&mut source);
        let mut group = group.unwrap().stream().into_iter().peekable();
        let attribute_name = format!("{}", group.next().unwrap());

        // skipping non-relevant attributes
        if attribute_name == "macroquad" {
            let group = next_group(&mut group);
            let mut group = group.unwrap().stream().into_iter().peekable();
            let config_name = format!("{}", group.next().unwrap());

            if group.peek().is_some() {
                // skip '='
                let _ = group.next();

                let config_value = Some(next_literal(&mut group).unwrap());

                if config_name == "crate_rename" {
                    crate_rename = config_value;
                }
            }
        }
    }

    let is_pub = if let TokenTree::Ident(ident) = source.peek().unwrap() {
        if ident.to_string() == "pub" {
            // skip 'pub'
            let _ = source.next().unwrap();
            true
        } else {
            false
        }
    } else {
        false
    };

    if let TokenTree::Ident(ident) = source.next().unwrap() {
        assert_eq!(
            format!("{}", ident),
            "async",
            "[macroquad::main] is allowed only for async functions"
        );

        modified.extend(std::iter::once(TokenTree::Ident(ident)));
    } else {
        panic!("[macroquad::main] is allowed only for async functions");
    }

    if let TokenTree::Ident(ident) = source.next().unwrap() {
        assert_eq!(format!("{}", ident), "fn");

        modified.extend(std::iter::once(TokenTree::Ident(ident)));
    } else {
        panic!("[macroquad::main] is allowed only for functions");
    }

    if let TokenTree::Ident(ident) = source.next().unwrap() {
        assert_eq!(format!("{}", ident), "main");

        modified.extend(std::iter::once(TokenTree::Ident(Ident::new(
            "amain",
            ident.span(),
        ))));
    } else {
        panic!("[macroquad::main] expecting main function");
    }

    modified.extend(std::iter::once(source.next().unwrap()));

    let next = source.next().unwrap();
    let use_result = if let TokenTree::Punct(punct) = &next {
        format!("{}", punct) == "-" // Start of `-> Result<(), ...>`
    } else {
        false
    };
    modified.extend(std::iter::once(next));
    modified.extend(source);

    let (method, ident) = match attr.into_iter().next() {
        Some(TokenTree::Ident(ident)) => ("from_config", format!("{}()", ident)),
        Some(TokenTree::Literal(literal)) => ("new", literal.to_string()),
        Some(wrong_ident) => panic!(
            "Wrong argument: {:?}. Place function returned `Conf`",
            wrong_ident
        ),
        None => panic!("No argument! Place function returned `Conf`"),
    };

    let crate_name = crate_rename.unwrap_or_else(|| "macroquad".to_string());
    let mut prelude: TokenStream = format!(
        "
    {pub_main} fn main() {{
        {crate_name}::Window::{method}({ident}, {main});
    }}
    ",
        pub_main = if is_pub { "pub" } else { "" },
        crate_name = crate_name,
        method = method,
        ident = ident,
        main = if use_result {
            format!(
                "async {{
                if let Err(err) = amain().await {{
                    {}::logging::error!(\"Error: {{:?}}\", err);
                }}
            }}",
                crate_name
            )
        } else {
            "amain()".to_string()
        }
    )
    .parse()
    .unwrap();
    prelude.extend(modified);

    prelude
}

// Right now it is a copy-paste from "main"
// maybe it is worth it to move reuse the code from main (it would be easy -
// test is pretty much the same thing, but adding #[test] and not panicing when
// function is not called "main")
// But for now I am not really sure what exactly #[macroquad::test] should do,
// so for easier modifications - it is decoupled from #[macroquad::main]
#[proc_macro_attribute]
pub fn test(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let mut modified = TokenStream::new();
    let mut source = item.into_iter().peekable();

    while let Some(TokenTree::Punct(punct)) = source.peek() {
        assert_eq!(format!("{}", punct), "#");
        // skip '#'
        let _ = source.next().unwrap();
        let _group = next_group(&mut source);
    }

    if let TokenTree::Ident(ident) = source.next().unwrap() {
        assert_eq!(format!("{}", ident), "async");

        modified.extend(std::iter::once(TokenTree::Ident(ident)));
    } else {
        panic!("[macroquad::test] is allowed only for async functions");
    }

    if let TokenTree::Ident(ident) = source.next().unwrap() {
        assert_eq!(format!("{}", ident), "fn");

        modified.extend(std::iter::once(TokenTree::Ident(ident)));
    } else {
        panic!("[macroquad::test] is allowed only for functions");
    }

    let test_name = if let TokenTree::Ident(ident) = source.next().unwrap() {
        let test_name = format!("{}", ident);

        modified.extend(std::iter::once(TokenTree::Ident(Ident::new(
            &format!("{}_async", test_name),
            ident.span(),
        ))));
        test_name
    } else {
        panic!("[macroquad::test] expecting main function");
    };

    modified.extend(std::iter::once(source.next().unwrap()));

    modified.extend(source);

    let mut prelude: TokenStream = format!(
        "
    #[test]
    fn {test_name}() {{
        let _lock = unsafe {{
          let mutex = macroquad::test::ONCE.call_once(|| {{
            macroquad::test::MUTEX = Some(std::sync::Mutex::new(()));
          }});
          macroquad::test::MUTEX.as_mut().unwrap().lock()
        }};
        macroquad::Window::new(\"test\", {test_name}_async());
    }}
    ",
        test_name = test_name,
    )
    .parse()
    .unwrap();
    prelude.extend(modified);

    prelude
}

/// Very experimental thing for macroquad::experimantal::scene
/// Maybe will go away in future versions
#[doc(hidden)]
#[proc_macro_derive(CapabilityTrait)]
pub fn capability_trait_macro(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let mut source = input.into_iter().peekable();

    while let Some(TokenTree::Punct(_)) = source.peek() {
        let _ = source.next();
        let _ = next_group(&mut source);
    }
    assert_eq!("pub", &format!("{}", source.next().unwrap()));
    assert_eq!("struct", &format!("{}", source.next().unwrap()));
    let struct_name = format!("{}", source.next().unwrap());

    let mut group = next_group(&mut source)
        .unwrap()
        .stream()
        .into_iter()
        .peekable();

    let mut trait_decl = format!("pub trait {}Trait {{", struct_name);
    let mut trait_impl = format!("impl {}Trait for NodeWith<{}> {{", struct_name, struct_name);

    fn next_str(group: &mut Peekable<impl Iterator<Item = TokenTree>>) -> Option<String> {
        group.next().map(|tok| format!("{}", tok))
    }

    loop {
        // skip doc comments
        while let Some(TokenTree::Punct(_)) = group.peek() {
            let _ = group.next();
            let _ = next_group(&mut group);
        }

        let _pub = next_str(&mut group);
        if _pub.is_none() {
            break;
        }
        assert_eq!("pub", _pub.unwrap());
        let fn_name = next_str(&mut group).unwrap();
        let mut fn_res = "()".to_string();
        assert_eq!(":", &next_str(&mut group).unwrap());
        assert_eq!("fn", &next_str(&mut group).unwrap());
        let fn_args_decl = next_str(&mut group).unwrap();
        let mut fn_args_impl = String::new();

        let args = fn_args_decl.split(":").collect::<Vec<&str>>();
        for arg in &args[1..args.len() - 1] {
            fn_args_impl.push_str(&format!(", {}", arg.split(", ").last().unwrap()));
        }
        let p = next_str(&mut group);
        match p.as_deref() {
            Some("-") => {
                assert_eq!(">", next_str(&mut group).unwrap());
                fn_res = next_str(&mut group).unwrap();
                let _ = next_str(&mut group);
            }
            Some(",") => {}
            None => break,
            _ => panic!(),
        };

        trait_decl.push_str(&format!(
            "fn {} {} -> {};",
            fn_name,
            fn_args_decl
                .replace("node : HandleUntyped", "&self")
                .replace("node: HandleUntyped", "&self"),
            fn_res
        ));

        let args = fn_args_impl
            .replace("node : HandleUntyped", "")
            .replace("node: HandleUntyped", "")
            .replace("(", "")
            .replace(")", "");

        trait_impl.push_str(&format!(
            "fn {} {} -> {} {{",
            fn_name,
            fn_args_decl
                .replace("node : HandleUntyped", "&self")
                .replace("node: HandleUntyped", "&self"),
            fn_res
        ));
        trait_impl.push_str(&format!(
            "(self.capability.{})(self.node {})",
            fn_name, args
        ));
        trait_impl.push_str("}");
    }
    trait_decl.push_str("}");
    trait_impl.push_str("}");

    let res = format!(
        "{} 
{}",
        trait_decl, trait_impl
    );
    res.parse().unwrap()
}

```

`particles/Cargo.toml`:

```toml
[package]
name = "macroquad-particles"
version = "0.2.2"
authors = ["Fedor Logachev <not.fl3@gmail.com>"]
edition = "2018"
license = "MIT/Apache-2.0"
description = """
Visual effects editor based on macroquad and megaui.
"""

[dependencies]
macroquad = { path = "../", version = "0.4.0", default-features = false }
nanoserde = { version = "0.1", optional = true }

```

`particles/src/lib.rs`:

```rs
use macroquad::prelude::*;
use macroquad::window::miniquad::*;
use miniquad::graphics::RenderPass;

#[cfg(feature = "nanoserde")]
use nanoserde::{DeJson, SerJson};

#[derive(Debug, Clone, Copy, PartialEq)]
#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub enum Interpolation {
    Linear,
    Bezier,
}

#[derive(Debug, Clone)]
#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub struct Curve {
    /// Key points for building a curve
    pub points: Vec<(f32, f32)>,
    /// The way middle points is interpolated during building a curve
    /// Only Linear is implemented now
    pub interpolation: Interpolation,
    /// Interpolation steps used to build the curve from the key points
    pub resolution: usize,
}

impl Curve {
    fn batch(&self) -> BatchedCurve {
        if self.interpolation == Interpolation::Bezier {
            unimplemented!()
        }

        let step_f32 = 1.0 / self.resolution as f32;
        let mut x = 0.0;
        let mut points = Vec::with_capacity(self.resolution);

        for curve_part in self.points.windows(2) {
            let start = curve_part[0];
            let end = curve_part[1];

            while x <= end.0 {
                let t = (x - start.0) / (end.0 - start.0);
                let point = start.1 + (end.1 - start.1) * t;
                points.push(point);
                x += step_f32;
            }
        }

        BatchedCurve { points }
    }
}

#[derive(Debug, Clone)]
pub struct BatchedCurve {
    pub points: Vec<f32>,
}

impl BatchedCurve {
    fn get(&self, t: f32) -> f32 {
        let t_scaled = t * self.points.len() as f32;
        let previous_ix = (t_scaled as usize).min(self.points.len() - 1);
        let next_ix = (previous_ix + 1).min(self.points.len() - 1);
        let previous = self.points[previous_ix];
        let next = self.points[next_ix];

        previous + (next - previous) * (t_scaled - previous_ix as f32)
    }
}
impl Default for Curve {
    fn default() -> Curve {
        Curve {
            points: vec![],
            interpolation: Interpolation::Linear,
            resolution: 20,
        }
    }
}

#[derive(Copy, Clone, PartialEq, Debug)]
#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub enum EmissionShape {
    Point,
    Rect { width: f32, height: f32 },
    Sphere { radius: f32 },
}

#[derive(Copy, Clone, PartialEq, Debug)]
#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub struct ColorSerializable {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}

impl From<&Color> for ColorSerializable {
    fn from(color: &Color) -> ColorSerializable {
        ColorSerializable {
            r: color.r,
            g: color.g,
            b: color.b,
            a: color.a,
        }
    }
}

impl From<&ColorSerializable> for Color {
    fn from(color: &ColorSerializable) -> Color {
        Color {
            r: color.r,
            g: color.g,
            b: color.b,
            a: color.a,
        }
    }
}

#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub struct Vec2Serializable {
    x: f32,
    y: f32,
}

impl From<&Vec2> for Vec2Serializable {
    fn from(vec: &Vec2) -> Vec2Serializable {
        Vec2Serializable { x: vec.x, y: vec.y }
    }
}

impl From<&Vec2Serializable> for Vec2 {
    fn from(vec: &Vec2Serializable) -> Vec2 {
        vec2(vec.x, vec.y)
    }
}

#[derive(Copy, Clone, PartialEq, Debug)]
#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub struct ColorCurve {
    #[cfg_attr(feature = "nanoserde", nserde(proxy = "ColorSerializable"))]
    pub start: Color,
    #[cfg_attr(feature = "nanoserde", nserde(proxy = "ColorSerializable"))]
    pub mid: Color,
    #[cfg_attr(feature = "nanoserde", nserde(proxy = "ColorSerializable"))]
    pub end: Color,
}

impl Default for ColorCurve {
    fn default() -> ColorCurve {
        ColorCurve {
            start: WHITE,
            mid: WHITE,
            end: WHITE,
        }
    }
}

#[derive(Debug, Clone)]
#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub struct EmitterConfig {
    /// If false - particles spawns at position supplied to .draw(), but afterwards lives in current camera coordinate system.
    /// If false particles use coordinate system originated to the emitter draw position
    pub local_coords: bool,
    /// Particles will be emitted inside that region.
    pub emission_shape: EmissionShape,
    /// If true only one emission cycle occurs. May be re-emitted by .emit() call.
    pub one_shot: bool,
    /// Lifespan of individual particle.
    pub lifetime: f32,
    /// Particle lifetime randomness ratio.
    /// Each particle will spawned with "lifetime = lifetime - lifetime * rand::gen_range(0.0, lifetime_randomness)".
    pub lifetime_randomness: f32,
    /// 0..1 value, how rapidly particles in emission cycle are emitted.
    /// With 0 particles will be emitted with equal gap.
    /// With 1 all the particles will be emitted at the beginning of the cycle.
    pub explosiveness: f32,
    /// Amount of particles emitted in one emission cycle.
    pub amount: u32,
    /// Shape of each individual particle mesh.
    pub shape: ParticleShape,
    /// Particles are emitting when "emitting" is true.
    /// If its a "one-shot" emitter, emitting will switch to false after active emission cycle.
    pub emitting: bool,
    /// Unit vector specifying emission direction.
    #[cfg_attr(feature = "nanoserde", nserde(proxy = "Vec2Serializable"))]
    pub initial_direction: Vec2,
    /// Angle from 0 to "2 * Pi" for random fluctuation for direction vector.
    pub initial_direction_spread: f32,
    /// Initial speed for each emitted particle.
    /// Direction of the initial speed vector is affected by "direction" and "spread"
    pub initial_velocity: f32,
    /// Initial velocity randomness ratio.
    /// Each particle will spawned with "initial_velocity = initial_velocity - initial_velocity * rand::gen_range(0.0, initial_velocity_randomness)".
    pub initial_velocity_randomness: f32,
    /// Velocity acceleration applied to each particle in the direction of motion.
    pub linear_accel: f32,

    // Initial rotation for each emitted particle.
    #[cfg_attr(feature = "nanoserde", nserde(default = "0.0"))]
    pub initial_rotation: f32,
    /// Initial rotation randomness.
    /// Each particle will spawned with "initial_rotation = initial_rotation - initial_rotation * rand::gen_range(0.0, initial_rotation_randomness)"
    #[cfg_attr(feature = "nanoserde", nserde(default = "0.0"))]
    pub initial_rotation_randomness: f32,
    // Initial rotational speed
    #[cfg_attr(feature = "nanoserde", nserde(default = "0.0"))]
    pub initial_angular_velocity: f32,
    /// Initial angular velocity randomness.
    /// Each particle will spawned with "initial_angular_velocity = initial_angular_velocity - initial_angular_velocity * rand::gen_range(0.0, initial_angular_velocity_randomness)".
    #[cfg_attr(feature = "nanoserde", nserde(default = "0.0"))]
    pub initial_angular_velocity_randomness: f32,
    /// Angular velocity acceleration applied to each particle .'
    #[cfg_attr(feature = "nanoserde", nserde(default = "0.0"))]
    pub angular_accel: f32,
    /// Angluar velocity damping
    /// Each frame angular velocity will be transformed "angular_velocity *= (1.0 - angular_damping)".
    #[cfg_attr(feature = "nanoserde", nserde(default = "0.0"))]
    pub angular_damping: f32,
    /// Each particle is a "size x size" square.
    pub size: f32,
    /// Each particle will spawned with "size = size - size * rand::gen_range(0.0, size_randomness)".
    pub size_randomness: f32,
    /// If curve is present in each moment of particle lifetime size would be multiplied by the value from the curve
    pub size_curve: Option<Curve>,

    /// Particles rendering mode.
    pub blend_mode: BlendMode,

    /// How particles should change base color along the lifetime.
    pub colors_curve: ColorCurve,

    /// Gravity applied to each individual particle.
    #[cfg_attr(feature = "nanoserde", nserde(proxy = "Vec2Serializable"))]
    pub gravity: Vec2,

    /// Particle texture. If none particles going to be white squares.
    #[cfg_attr(feature = "nanoserde", nserde(skip))]
    pub texture: Option<Texture2D>,

    /// For animated texture specify spritesheet layout.
    /// If none the whole texture will be used.
    pub atlas: Option<AtlasConfig>,

    /// Custom material used to shade each particle.
    pub material: Option<ParticleMaterial>,

    /// If none particles will be rendered directly to the screen.
    /// If not none all the particles will be rendered to a rectangle and than this rectangle
    /// will be rendered to the screen.
    /// This will allows some effects affecting particles as a whole.
    /// NOTE: this is not really implemented and now Some will just make hardcoded downscaling
    pub post_processing: Option<PostProcessing>,
}

impl EmissionShape {
    fn gen_random_point(&self) -> Vec2 {
        match self {
            EmissionShape::Point => vec2(0., 0.),
            EmissionShape::Rect { width, height } => vec2(
                rand::gen_range(-width / 2., width / 2.0),
                rand::gen_range(-height / 2., height / 2.0),
            ),
            EmissionShape::Sphere { radius } => {
                let ro = rand::gen_range(0., radius * radius).sqrt();
                let phi = rand::gen_range(0., std::f32::consts::PI * 2.);

                macroquad::math::polar_to_cartesian(ro, phi)
            }
        }
    }
}

#[derive(Copy, Clone, PartialEq, Debug)]
#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub struct PostProcessing;

#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub enum ParticleShape {
    Rectangle {
        aspect_ratio: f32,
    },
    Circle {
        subdivisions: u32,
    },
    CustomMesh {
        vertices: Vec<f32>,
        indices: Vec<u16>,
    },
}

impl ParticleShape {
    fn build_bindings(
        &self,
        ctx: &mut dyn miniquad::RenderingBackend,
        positions_vertex_buffer: BufferId,
        texture: Option<Texture2D>,
    ) -> Bindings {
        let (geometry_vertex_buffer, index_buffer) = match self {
            ParticleShape::Rectangle { aspect_ratio } => {
                #[rustfmt::skip]
                let vertices: &[f32] = &[
                    // positions          uv          colors
                    -1.0 * aspect_ratio, -1.0, 0.0,   0.0, 0.0,  1.0, 1.0, 1.0, 1.0,
                     1.0 * aspect_ratio, -1.0, 0.0,   1.0, 0.0,  1.0, 1.0, 1.0, 1.0,
                     1.0 * aspect_ratio,  1.0, 0.0,   1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
                    -1.0 * aspect_ratio,  1.0, 0.0,   0.0, 1.0,  1.0, 1.0, 1.0, 1.0,
                ];

                let vertex_buffer = ctx.new_buffer(
                    BufferType::VertexBuffer,
                    BufferUsage::Immutable,
                    BufferSource::slice(&vertices),
                );

                #[rustfmt::skip]
                let indices: &[u16] = &[
                    0, 1, 2, 0, 2, 3
                ];
                let index_buffer = ctx.new_buffer(
                    BufferType::IndexBuffer,
                    BufferUsage::Immutable,
                    BufferSource::slice(&indices),
                );

                (vertex_buffer, index_buffer)
            }
            ParticleShape::Circle { subdivisions } => {
                let mut vertices = Vec::<f32>::new();
                let mut indices = Vec::<u16>::new();

                let rot = 0.0;
                vertices.extend_from_slice(&[0., 0., 0., 0., 0., 1.0, 1.0, 1.0, 1.0]);
                for i in 0..subdivisions + 1 {
                    let rx =
                        (i as f32 / *subdivisions as f32 * std::f32::consts::PI * 2. + rot).cos();
                    let ry =
                        (i as f32 / *subdivisions as f32 * std::f32::consts::PI * 2. + rot).sin();
                    vertices.extend_from_slice(&[rx, ry, 0., rx, ry, 1., 1., 1., 1.]);

                    if i != *subdivisions {
                        indices.extend_from_slice(&[0, i as u16 + 1, i as u16 + 2]);
                    }
                }

                let vertex_buffer = ctx.new_buffer(
                    BufferType::VertexBuffer,
                    BufferUsage::Immutable,
                    BufferSource::slice(&vertices),
                );
                let index_buffer = ctx.new_buffer(
                    BufferType::IndexBuffer,
                    BufferUsage::Immutable,
                    BufferSource::slice(&indices),
                );
                (vertex_buffer, index_buffer)
            }
            ParticleShape::CustomMesh { vertices, indices } => {
                let vertex_buffer = ctx.new_buffer(
                    BufferType::VertexBuffer,
                    BufferUsage::Immutable,
                    BufferSource::slice(&vertices),
                );
                let index_buffer = ctx.new_buffer(
                    BufferType::IndexBuffer,
                    BufferUsage::Immutable,
                    BufferSource::slice(&indices),
                );
                (vertex_buffer, index_buffer)
            }
        };

        Bindings {
            vertex_buffers: vec![geometry_vertex_buffer, positions_vertex_buffer],
            index_buffer,
            images: vec![texture.map_or_else(
                || ctx.new_texture_from_rgba8(1, 1, &[255, 255, 255, 255]),
                |texture| texture.raw_miniquad_id(),
            )],
        }
    }
}

#[derive(Debug, Clone)]
#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub struct ParticleMaterial {
    vertex: String,
    fragment: String,
}

impl ParticleMaterial {
    pub fn new(vertex: &str, fragment: &str) -> ParticleMaterial {
        ParticleMaterial {
            vertex: vertex.to_owned(),
            fragment: fragment.to_owned(),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub enum BlendMode {
    /// Colors of overlapped particles will be blended by alpha channel.
    Alpha,
    /// Colors of overlapped particles will be added to each other.
    Additive,
}

impl BlendMode {
    fn blend_state(&self) -> BlendState {
        match self {
            BlendMode::Alpha => BlendState::new(
                Equation::Add,
                BlendFactor::Value(BlendValue::SourceAlpha),
                BlendFactor::OneMinusValue(BlendValue::SourceAlpha),
            ),
            BlendMode::Additive => BlendState::new(
                Equation::Add,
                BlendFactor::Value(BlendValue::SourceAlpha),
                BlendFactor::One,
            ),
        }
    }
}

#[derive(Debug, Clone)]
#[cfg_attr(feature = "nanoserde", derive(DeJson, SerJson))]
pub struct AtlasConfig {
    n: u16,
    m: u16,
    start_index: u16,
    end_index: u16,
}

impl AtlasConfig {
    pub fn new<T: std::ops::RangeBounds<u16>>(n: u16, m: u16, range: T) -> AtlasConfig {
        let start_index = match range.start_bound() {
            std::ops::Bound::Unbounded => 0,
            std::ops::Bound::Included(i) => *i,
            std::ops::Bound::Excluded(i) => i + 1,
        };
        let end_index = match range.end_bound() {
            std::ops::Bound::Unbounded => n * m,
            std::ops::Bound::Included(i) => i - 1,
            std::ops::Bound::Excluded(i) => *i,
        };

        AtlasConfig {
            n,
            m,
            start_index,
            end_index,
        }
    }
}

impl Default for EmitterConfig {
    fn default() -> EmitterConfig {
        EmitterConfig {
            local_coords: false,
            emission_shape: EmissionShape::Point,
            one_shot: false,
            lifetime: 1.0,
            lifetime_randomness: 0.0,
            amount: 8,
            shape: ParticleShape::Rectangle { aspect_ratio: 1.0 },
            explosiveness: 0.0,
            emitting: true,
            initial_direction: vec2(0., -1.),
            initial_direction_spread: 0.,
            initial_velocity: 50.0,
            initial_velocity_randomness: 0.0,
            linear_accel: 0.0,
            initial_rotation: 0.0,
            initial_rotation_randomness: 0.0,
            initial_angular_velocity: 0.0,
            initial_angular_velocity_randomness: 0.0,
            angular_accel: 0.0,
            angular_damping: 0.0,
            size: 10.0,
            size_randomness: 0.0,
            size_curve: None,
            blend_mode: BlendMode::Alpha,
            colors_curve: ColorCurve::default(),
            gravity: vec2(0.0, 0.0),
            texture: None,
            atlas: None,
            material: None,
            post_processing: None,
        }
    }
}

#[repr(C)]
struct GpuParticle {
    pos: Vec4,
    uv: Vec4,
    data: Vec4,
    color: Vec4,
}

struct CpuParticle {
    velocity: Vec2,
    angular_velocity: f32,
    lived: f32,
    lifetime: f32,
    frame: u16,
    initial_size: f32,
}

pub struct Emitter {
    pipeline: Pipeline,
    bindings: Bindings,
    post_processing_pass: RenderPass,
    post_processing_pipeline: Pipeline,
    post_processing_bindings: Bindings,

    gpu_particles: Vec<GpuParticle>,
    cpu_counterpart: Vec<CpuParticle>,

    last_emit_time: f32,
    time_passed: f32,
    particles_current_cycle: u32,

    particles_spawned: u64,
    position: Vec2,

    batched_size_curve: Option<BatchedCurve>,

    blend_mode: BlendMode,
    mesh_dirty: bool,

    pub config: EmitterConfig,
}

impl Emitter {
    const MAX_PARTICLES: usize = 10000;

    pub fn new(config: EmitterConfig) -> Emitter {
        let InternalGlContext {
            quad_context: ctx, ..
        } = unsafe { get_internal_gl() };

        // empty, dynamic instance-data vertex buffer
        let positions_vertex_buffer = ctx.new_buffer(
            BufferType::VertexBuffer,
            BufferUsage::Stream,
            BufferSource::empty::<GpuParticle>(Self::MAX_PARTICLES),
        );

        let bindings =
            config
                .shape
                .build_bindings(ctx, positions_vertex_buffer, config.texture.clone());

        let (vertex, fragment) = config.material.as_ref().map_or_else(
            || (shader::VERTEX, shader::FRAGMENT),
            |material| (&material.vertex, &material.fragment),
        );

        let shader = {
            use macroquad::material::shaders::{preprocess_shader, PreprocessorConfig};

            let config = PreprocessorConfig {
                includes: vec![(
                    "particles.glsl".to_string(),
                    include_str!("particles.glsl").to_owned(),
                )],
                ..Default::default()
            };

            let vertex = preprocess_shader(&vertex, &config);
            let fragment = preprocess_shader(&fragment, &config);

            ctx.new_shader(
                ShaderSource::Glsl {
                    vertex: &vertex,
                    fragment: &fragment,
                },
                shader::meta(),
            )
            .unwrap()
        };

        let blend_mode = config.blend_mode.blend_state();
        let pipeline = ctx.new_pipeline(
            &[
                BufferLayout::default(),
                BufferLayout {
                    step_func: VertexStep::PerInstance,
                    ..Default::default()
                },
            ],
            &[
                VertexAttribute::with_buffer("in_attr_pos", VertexFormat::Float3, 0),
                VertexAttribute::with_buffer("in_attr_uv", VertexFormat::Float2, 0),
                VertexAttribute::with_buffer("in_attr_color", VertexFormat::Float4, 0),
                VertexAttribute::with_buffer("in_attr_inst_pos", VertexFormat::Float4, 1),
                VertexAttribute::with_buffer("in_attr_inst_uv", VertexFormat::Float4, 1),
                VertexAttribute::with_buffer("in_attr_inst_data", VertexFormat::Float4, 1),
                VertexAttribute::with_buffer("in_attr_inst_color", VertexFormat::Float4, 1),
            ],
            shader,
            PipelineParams {
                color_blend: Some(blend_mode),
                alpha_blend: Some(BlendState::new(
                    Equation::Add,
                    BlendFactor::Zero,
                    BlendFactor::One,
                )),
                ..Default::default()
            },
        );

        let post_processing_shader = ctx
            .new_shader(
                ShaderSource::Glsl {
                    vertex: &post_processing_shader::VERTEX,
                    fragment: &post_processing_shader::FRAGMENT,
                },
                post_processing_shader::meta(),
            )
            .unwrap();

        let post_processing_pipeline = ctx.new_pipeline(
            &[BufferLayout::default(), BufferLayout::default()],
            &[
                VertexAttribute::with_buffer("pos", VertexFormat::Float2, 0),
                VertexAttribute::with_buffer("uv", VertexFormat::Float2, 0),
            ],
            post_processing_shader,
            PipelineParams {
                color_blend: Some(BlendState::new(
                    Equation::Add,
                    BlendFactor::Value(BlendValue::SourceAlpha),
                    BlendFactor::OneMinusValue(BlendValue::SourceAlpha),
                )),
                ..Default::default()
            },
        );
        let post_processing_pass = {
            let color_img = ctx.new_render_texture(TextureParams {
                width: 320,
                height: 200,
                format: TextureFormat::RGBA8,
                ..Default::default()
            });
            ctx.texture_set_filter(color_img, FilterMode::Nearest, MipmapFilterMode::None);

            ctx.new_render_pass(color_img, None)
        };

        let post_processing_bindings = {
            #[rustfmt::skip]
            let vertices: &[f32] = &[
                // positions   uv
                -1.0, -1.0,    0.0, 0.0,
                 1.0, -1.0,    1.0, 0.0,
                 1.0,  1.0,    1.0, 1.0,
                -1.0,  1.0,    0.0, 1.0,
            ];

            let vertex_buffer = ctx.new_buffer(
                BufferType::VertexBuffer,
                BufferUsage::Immutable,
                BufferSource::slice(&vertices),
            );

            #[rustfmt::skip]
            let indices: &[u16] = &[
                0, 1, 2, 0, 2, 3
            ];
            let index_buffer = ctx.new_buffer(
                BufferType::IndexBuffer,
                BufferUsage::Immutable,
                BufferSource::slice(&indices),
            );
            Bindings {
                vertex_buffers: vec![vertex_buffer],
                index_buffer,
                images: vec![ctx.render_pass_texture(post_processing_pass)],
            }
        };

        Emitter {
            blend_mode: config.blend_mode.clone(),
            batched_size_curve: config.size_curve.as_ref().map(|curve| curve.batch()),
            post_processing_pass,
            post_processing_pipeline,
            post_processing_bindings,
            config,
            pipeline,
            bindings,
            position: vec2(0.0, 0.0),
            gpu_particles: Vec::with_capacity(Self::MAX_PARTICLES),
            cpu_counterpart: Vec::with_capacity(Self::MAX_PARTICLES),
            particles_spawned: 0,
            last_emit_time: 0.0,
            time_passed: 0.0,
            particles_current_cycle: 0,
            mesh_dirty: false,
        }
    }

    fn reset(&mut self) {
        self.gpu_particles.clear();
        self.cpu_counterpart.clear();
        self.last_emit_time = 0.0;
        self.time_passed = 0.0;
        self.particles_spawned = 0;
        self.particles_current_cycle = 0;
    }
    pub fn rebuild_size_curve(&mut self) {
        self.batched_size_curve = self.config.size_curve.as_ref().map(|curve| curve.batch());
    }

    pub fn update_particle_mesh(&mut self) {
        self.mesh_dirty = true;
    }

    fn emit_particle(&mut self, offset: Vec2) {
        let offset = offset + self.config.emission_shape.gen_random_point();

        fn random_initial_vector(dir: Vec2, spread: f32, velocity: f32) -> Vec2 {
            let angle = rand::gen_range(-spread / 2.0, spread / 2.0);

            let quat = glam::Quat::from_rotation_z(angle);
            let dir = quat * vec3(dir.x, dir.y, 0.0);
            let res = dir * velocity;

            vec2(res.x, res.y)
        }

        let r =
            self.config.size - self.config.size * rand::gen_range(0.0, self.config.size_randomness);

        let rotation = self.config.initial_rotation
            - self.config.initial_rotation
                * rand::gen_range(0.0, self.config.initial_rotation_randomness);

        let particle = if self.config.local_coords {
            GpuParticle {
                pos: vec4(offset.x, offset.y, rotation, r),
                uv: vec4(1.0, 1.0, 0.0, 0.0),
                data: vec4(self.particles_spawned as f32, 0.0, 0.0, 0.0),
                color: self.config.colors_curve.start.to_vec(),
            }
        } else {
            GpuParticle {
                pos: vec4(
                    self.position.x + offset.x,
                    self.position.y + offset.y,
                    rotation,
                    r,
                ),
                uv: vec4(1.0, 1.0, 0.0, 0.0),
                data: vec4(self.particles_spawned as f32, 0.0, 0.0, 0.0),
                color: self.config.colors_curve.start.to_vec(),
            }
        };

        self.particles_spawned += 1;
        self.particles_current_cycle += 1;
        self.gpu_particles.push(particle);
        self.cpu_counterpart.push(CpuParticle {
            velocity: random_initial_vector(
                vec2(
                    self.config.initial_direction.x,
                    self.config.initial_direction.y,
                ),
                self.config.initial_direction_spread,
                self.config.initial_velocity
                    - self.config.initial_velocity
                        * rand::gen_range(0.0, self.config.initial_velocity_randomness),
            ),
            angular_velocity: self.config.initial_angular_velocity
                - self.config.initial_angular_velocity
                    * rand::gen_range(0.0, self.config.initial_angular_velocity_randomness),
            lived: 0.0,
            lifetime: self.config.lifetime
                - self.config.lifetime * rand::gen_range(0.0, self.config.lifetime_randomness),
            frame: 0,
            initial_size: r,
        });
    }

    fn update(&mut self, ctx: &mut dyn miniquad::RenderingBackend, dt: f32) {
        if self.mesh_dirty {
            self.bindings = self.config.shape.build_bindings(
                ctx,
                self.bindings.vertex_buffers[1],
                self.config.texture.clone(),
            );
            self.mesh_dirty = false;
        }
        if self.config.emitting {
            self.time_passed += dt;

            let gap = (self.config.lifetime / self.config.amount as f32)
                * (1.0 - self.config.explosiveness);

            let spawn_amount = if gap < 0.001 {
                // to prevent division by 0 problems
                self.config.amount as usize
            } else {
                // how many particles fits into this delta time
                ((self.time_passed - self.last_emit_time) / gap) as usize
            };

            for _ in 0..spawn_amount {
                self.last_emit_time = self.time_passed;

                if self.particles_spawned < self.config.amount as u64 {
                    self.emit_particle(vec2(0.0, 0.0));
                }

                if self.gpu_particles.len() >= self.config.amount as usize {
                    break;
                }
            }
        }

        if self.config.one_shot && self.particles_current_cycle >= self.config.amount {
            self.time_passed = 0.0;
            self.last_emit_time = 0.0;
            self.particles_current_cycle = 0;
            self.config.emitting = false;
        }

        for (gpu, cpu) in self.gpu_particles.iter_mut().zip(&mut self.cpu_counterpart) {
            // TODO: this is not quite the way to apply acceleration, this is not
            // fps independent and just wrong
            cpu.velocity += cpu.velocity * self.config.linear_accel * dt;
            cpu.angular_velocity += cpu.angular_velocity * self.config.angular_accel * dt;
            cpu.angular_velocity *= 1.0 - self.config.angular_damping;

            gpu.color = {
                let t = cpu.lived / cpu.lifetime;
                if t < 0.5 {
                    let t = t * 2.;
                    self.config.colors_curve.start.to_vec() * (1.0 - t)
                        + self.config.colors_curve.mid.to_vec() * t
                } else {
                    let t = (t - 0.5) * 2.;
                    self.config.colors_curve.mid.to_vec() * (1.0 - t)
                        + self.config.colors_curve.end.to_vec() * t
                }
            };
            gpu.pos += vec4(cpu.velocity.x, cpu.velocity.y, cpu.angular_velocity, 0.0) * dt;

            gpu.pos.w = cpu.initial_size
                * self
                    .batched_size_curve
                    .as_ref()
                    .map_or(1.0, |curve| curve.get(cpu.lived / cpu.lifetime));

            if cpu.lifetime != 0.0 {
                gpu.data.y = cpu.lived / cpu.lifetime;
            }

            //cpu.lived = f32::min(cpu.lived + dt, cpu.lifetime);
            cpu.lived += dt;
            cpu.velocity += self.config.gravity * dt;

            if let Some(atlas) = &self.config.atlas {
                if cpu.lifetime != 0.0 {
                    cpu.frame = (cpu.lived / cpu.lifetime
                        * (atlas.end_index - atlas.start_index) as f32)
                        as u16
                        + atlas.start_index;
                }

                let x = cpu.frame % atlas.n;
                let y = cpu.frame / atlas.n;

                gpu.uv = vec4(
                    x as f32 / atlas.n as f32,
                    y as f32 / atlas.m as f32,
                    1.0 / atlas.n as f32,
                    1.0 / atlas.m as f32,
                );
            } else {
                gpu.uv = vec4(0.0, 0.0, 1.0, 1.0);
            }
        }

        for i in (0..self.gpu_particles.len()).rev() {
            // second if clause is just for the case when lifetime was changed in the editor
            // normally particle lifetime is always less or equal config lifetime
            if self.cpu_counterpart[i].lived >= self.cpu_counterpart[i].lifetime
                || self.cpu_counterpart[i].lived > self.config.lifetime
            {
                if self.cpu_counterpart[i].lived != self.cpu_counterpart[i].lifetime {
                    self.particles_spawned -= 1;
                }
                self.gpu_particles.remove(i);
                self.cpu_counterpart.remove(i);
            }
        }

        ctx.buffer_update(
            self.bindings.vertex_buffers[1],
            BufferSource::slice(&self.gpu_particles[..]),
        );
    }

    /// Immediately emit N particles, ignoring "emitting" and "amount" params of EmitterConfig
    pub fn emit(&mut self, pos: Vec2, n: usize) {
        for _ in 0..n {
            self.emit_particle(pos);
            self.particles_spawned += 1;
        }
    }

    fn perform_render_pass(&mut self, quad_gl: &QuadGl, ctx: &mut dyn miniquad::RenderingBackend) {
        ctx.apply_bindings(&self.bindings);
        ctx.apply_uniforms(UniformsSource::table(&shader::Uniforms {
            mvp: quad_gl.get_projection_matrix(),
            emitter_position: vec3(self.position.x, self.position.y, 0.0),
            local_coords: if self.config.local_coords { 1.0 } else { 0.0 },
        }));

        let index_buffer_size = ctx.buffer_size(self.bindings.index_buffer);
        ctx.draw(
            0,
            (index_buffer_size / 2) as i32,
            self.gpu_particles.len() as i32,
        );
    }

    pub fn setup_render_pass(
        &mut self,
        quad_gl: &QuadGl,
        ctx: &mut dyn miniquad::RenderingBackend,
    ) {
        if self.config.blend_mode != self.blend_mode {
            // TODO: recreate pipeline
            //self.pipeline
            //    .set_blend(ctx, Some(self.config.blend_mode.blend_state()));
            self.blend_mode = self.config.blend_mode.clone();
        }

        if self.config.post_processing.is_none() {
            let pass = quad_gl.get_active_render_pass();
            if let Some(pass) = pass {
                ctx.begin_pass(Some(pass), PassAction::Nothing);
            } else {
                ctx.begin_default_pass(PassAction::Nothing);
            }
        } else {
            ctx.begin_pass(
                Some(self.post_processing_pass),
                PassAction::clear_color(0.0, 0.0, 0.0, 0.0),
            );
        };

        ctx.apply_pipeline(&self.pipeline);
    }

    pub fn end_render_pass(&mut self, quad_gl: &QuadGl, ctx: &mut dyn miniquad::RenderingBackend) {
        ctx.end_render_pass();

        if self.config.post_processing.is_some() {
            let pass = quad_gl.get_active_render_pass();
            if let Some(pass) = pass {
                ctx.begin_pass(Some(pass), PassAction::Nothing);
            } else {
                ctx.begin_default_pass(PassAction::Nothing);
            }

            ctx.apply_pipeline(&self.post_processing_pipeline);
            let (x, y, w, h) = quad_gl.get_viewport();
            ctx.apply_viewport(x, y, w, h);

            ctx.apply_bindings(&self.post_processing_bindings);

            ctx.draw(0, 6, 1);

            ctx.end_render_pass();
        }
    }

    pub fn draw(&mut self, pos: Vec2) {
        let mut gl = unsafe { get_internal_gl() };

        gl.flush();

        let InternalGlContext {
            quad_context: ctx,
            quad_gl,
        } = gl;

        self.position = pos;

        self.update(ctx, get_frame_time());

        self.setup_render_pass(quad_gl, ctx);
        self.perform_render_pass(quad_gl, ctx);
        self.end_render_pass(quad_gl, ctx);
    }
}

/// Multiple emitters drawn simultaneously.
/// Will reuse as much GPU resources as possible, so should be more efficient than
/// just Vec<Emitter>
pub struct EmittersCache {
    emitter: Emitter,
    emitters_cache: Vec<Emitter>,
    active_emitters: Vec<Option<(Emitter, Vec2)>>,
    config: EmitterConfig,
}

impl EmittersCache {
    const CACHE_DEFAULT_SIZE: usize = 10;

    pub fn new(config: EmitterConfig) -> EmittersCache {
        let mut emitters_cache = vec![];
        // prepopulate cache
        for _ in 0..Self::CACHE_DEFAULT_SIZE {
            emitters_cache.push(Emitter::new(EmitterConfig {
                emitting: false,
                ..config.clone()
            }));
        }
        EmittersCache {
            emitter: Emitter::new(config.clone()),
            emitters_cache,
            active_emitters: vec![],
            config,
        }
    }

    pub fn spawn(&mut self, pos: Vec2) {
        let mut emitter = if let Some(emitter) = self.emitters_cache.pop() {
            emitter
        } else {
            Emitter::new(self.config.clone())
        };

        emitter.mesh_dirty = true;
        emitter.config.emitting = true;
        emitter.reset();

        self.active_emitters.push(Some((emitter, pos)));
    }

    pub fn draw(&mut self) {
        let mut gl = unsafe { get_internal_gl() };

        gl.flush();

        let InternalGlContext {
            quad_context: ctx,
            quad_gl,
        } = gl;

        if self.active_emitters.len() > 0 {
            self.emitter.setup_render_pass(quad_gl, ctx);
        }
        for i in &mut self.active_emitters {
            if let Some((emitter, pos)) = i {
                emitter.position = *pos;

                emitter.update(ctx, get_frame_time());

                emitter.perform_render_pass(quad_gl, ctx);

                if emitter.config.emitting == false {
                    self.emitters_cache.push(i.take().unwrap().0);
                }
            }
        }
        if self.active_emitters.len() > 0 {
            self.emitter.end_render_pass(quad_gl, ctx);
        }

        self.active_emitters.retain(|emitter| emitter.is_some())
    }
}

mod shader {
    use super::*;

    pub const VERTEX: &str = r#"#version 100
    #define DEF_VERTEX_ATTRIBUTES
    #include "particles.glsl"

    varying lowp vec2 texcoord;
    varying lowp vec4 color;

    void main() {
        gl_Position = particle_transform_vertex();
        color = in_attr_inst_color;
        texcoord = particle_transform_uv();
    }
    "#;

    pub const FRAGMENT: &str = r#"#version 100
    varying lowp vec2 texcoord;
    varying lowp vec4 color;

    uniform sampler2D texture;

    void main() {
        gl_FragColor = texture2D(texture, texcoord) * color;
    }
    "#;

    pub fn meta() -> ShaderMeta {
        ShaderMeta {
            images: vec!["texture".to_string()],
            uniforms: UniformBlockLayout {
                uniforms: vec![
                    UniformDesc::new("_mvp", UniformType::Mat4),
                    UniformDesc::new("_local_coords", UniformType::Float1),
                    UniformDesc::new("_emitter_position", UniformType::Float3),
                ],
            },
        }
    }

    #[repr(C)]
    pub struct Uniforms {
        pub mvp: Mat4,
        pub local_coords: f32,
        pub emitter_position: Vec3,
    }
}

mod post_processing_shader {
    use super::*;

    pub const VERTEX: &str = r#"#version 100
    attribute vec2 pos;
    attribute vec2 uv;

    varying lowp vec2 texcoord;

    void main() {
        gl_Position = vec4(pos, 0, 1);
        texcoord = uv;
    }
    "#;

    pub const FRAGMENT: &str = r#"#version 100
    precision lowp float;

    varying vec2 texcoord;
    uniform sampler2D tex;

    void main() {
        gl_FragColor = texture2D(tex, texcoord);
    }
    "#;

    pub fn meta() -> ShaderMeta {
        ShaderMeta {
            images: vec!["tex".to_string()],
            uniforms: UniformBlockLayout { uniforms: vec![] },
        }
    }
}

```

`particles/src/particles.glsl`:

```glsl
#ifdef DEF_VERTEX_ATTRIBUTES
attribute vec3 in_attr_pos;
attribute vec2 in_attr_uv;
attribute vec4 in_attr_color;
attribute vec4 in_attr_inst_pos;
attribute vec4 in_attr_inst_uv;
attribute vec4 in_attr_inst_data;
attribute vec4 in_attr_inst_color;
uniform mat4 _mvp;
uniform float _local_coords;
uniform vec3 _emitter_position;

lowp mat2 rotate2d(float angle){
    return mat2(cos(angle),-sin(angle),
                sin(angle),cos(angle));
}
vec4 particle_transform_vertex() {
     vec4 transformed = vec4(0.0, 0.0, 0.0, 0.0);
     mat2 rot = rotate2d(in_attr_inst_pos.z);
     vec4 in_attr_inst_pos = vec4(in_attr_inst_pos.xy, 0.0, in_attr_inst_pos.w);
     if (_local_coords == 0.0) {
        transformed = vec4(vec3(rot * in_attr_pos.xy, in_attr_pos.z) * in_attr_inst_pos.w + in_attr_inst_pos.xyz, 1.0);
     } else {
        transformed = vec4(vec3(rot * in_attr_pos.xy, in_attr_pos.z) * in_attr_inst_pos.w + in_attr_inst_pos.xyz +
                        _emitter_position.xyz, 1.0);
     }
     return _mvp * transformed;
}

vec2 particle_transform_uv() {
    return in_attr_uv * in_attr_inst_uv.zw + in_attr_inst_uv.xy;
}
#endif

highp float rand(lowp vec2 co) {
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}

lowp float particle_ix(lowp vec4 particle_data) {
    return particle_data.x;
}

lowp float particle_lifetime(lowp vec4 particle_data) {
    return particle_data.y;
}

```

`physics-platformer/Cargo.toml`:

```toml
[package]
name = "macroquad-platformer"
version = "0.2.0"
authors = ["Fedor Logachev <not.fl3@gmail.com>"]
edition = "2018"
license = "MIT/Apache-2.0"
description = """
Platformer physics for macroquad
"""

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
macroquad = { path = "../", version = "0.4.0" }

```

`physics-platformer/README.md`:

```md
# Platformer physics

Physics based on Maddy Thorson's blogpost https://maddythorson.medium.com/celeste-and-towerfall-physics-d24bd2ae0fc5

The library will suit the best platformer games with rectangular colliders. 

Very, very, very WIP, API is going to change on daily basis. But it works!

```

`physics-platformer/src/lib.rs`:

```rs
use macroquad::math::{vec2, Rect, Vec2};

use std::collections::HashSet;

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum Tile {
    Empty,
    Solid,
    JumpThrough,
    Collider,
}

impl Tile {
    fn or(self, other: Tile) -> Tile {
        match (self, other) {
            (Tile::Empty, Tile::Empty) => Tile::Empty,
            (Tile::JumpThrough, Tile::JumpThrough) => Tile::JumpThrough,
            (Tile::JumpThrough, Tile::Empty) => Tile::JumpThrough,
            (Tile::Empty, Tile::JumpThrough) => Tile::JumpThrough,
            _ => Tile::Solid,
        }
    }
}
pub struct StaticTiledLayer {
    static_colliders: Vec<Tile>,
    tile_width: f32,
    tile_height: f32,
    width: usize,
    tag: u8,
}

pub struct World {
    static_tiled_layers: Vec<StaticTiledLayer>,
    solids: Vec<(Solid, Collider)>,
    actors: Vec<(Actor, Collider)>,
}

#[derive(Clone, Debug)]
struct Collider {
    collidable: bool,
    squished: bool,
    pos: Vec2,
    width: i32,
    height: i32,
    x_remainder: f32,
    y_remainder: f32,
    squishers: HashSet<Solid>,
    descent: bool,
    seen_wood: bool,
}

impl Collider {
    pub fn rect(&self) -> Rect {
        Rect::new(
            self.pos.x,
            self.pos.y,
            self.width as f32,
            self.height as f32,
        )
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub struct Actor(usize);

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub struct Solid(usize);

impl World {
    pub fn new() -> World {
        World {
            static_tiled_layers: vec![],
            actors: vec![],
            solids: vec![],
        }
    }

    pub fn add_static_tiled_layer(
        &mut self,
        static_colliders: Vec<Tile>,
        tile_width: f32,
        tile_height: f32,
        width: usize,
        tag: u8,
    ) {
        self.static_tiled_layers.push(StaticTiledLayer {
            static_colliders,
            tile_width,
            tile_height,
            width,
            tag,
        });
    }
    pub fn add_actor(&mut self, pos: Vec2, width: i32, height: i32) -> Actor {
        let actor = Actor(self.actors.len());

        let mut descent = false;
        let mut seen_wood = false;
        let tile = self.collide_solids(pos, width, height);
        if tile == Tile::JumpThrough {
            descent = true;
            seen_wood = true;
        }
        self.actors.push((
            actor,
            Collider {
                collidable: true,
                squished: false,
                pos,
                width,
                height,
                x_remainder: 0.,
                y_remainder: 0.,
                squishers: HashSet::new(),
                descent,
                seen_wood,
            },
        ));

        actor
    }

    pub fn add_solid(&mut self, pos: Vec2, width: i32, height: i32) -> Solid {
        let solid = Solid(self.solids.len());

        self.solids.push((
            solid,
            Collider {
                collidable: true,
                squished: false,
                pos,
                width,
                height,
                x_remainder: 0.,
                y_remainder: 0.,
                squishers: HashSet::new(),
                descent: false,
                seen_wood: false,
            },
        ));

        solid
    }

    pub fn set_actor_size(&mut self, actor: Actor, width: i32, height: i32) {
        let collider = &mut self.actors[actor.0].1;

        let height_diff = collider.height - height;
        let width_diff = collider.width - width;
        let new_x = collider.pos.x + width_diff as f32 / 2.0;
        let new_y = collider.pos.y + height_diff as f32;

        let pos = Vec2 { x: new_x, y: new_y };

        collider.height = height;
        collider.width = width;

        // need to offset the collider based on the new size
        collider.x_remainder = 0.0;
        collider.y_remainder = 0.0;
        collider.pos = pos;
    }

    pub fn set_actor_position(&mut self, actor: Actor, pos: Vec2) {
        let collider = &mut self.actors[actor.0].1;

        collider.x_remainder = 0.0;
        collider.y_remainder = 0.0;
        collider.pos = pos;
    }

    pub fn descent(&mut self, actor: Actor) {
        let collider = &mut self.actors[actor.0].1;
        collider.descent = true;
    }

    pub fn move_v(&mut self, actor: Actor, dy: f32) -> bool {
        let id = actor.0;
        let mut collider = self.actors[id].1.clone();

        collider.y_remainder += dy;

        let mut move_ = collider.y_remainder.round() as i32;
        if move_ != 0 {
            collider.y_remainder -= move_ as f32;
            let sign = move_.signum();

            while move_ != 0 {
                let tile = self.collide_solids(
                    collider.pos + vec2(0., sign as f32),
                    collider.width,
                    collider.height,
                );

                // collider wants to go down and collided with jumpthrough tile
                if tile == Tile::JumpThrough && collider.descent {
                    collider.seen_wood = true;
                }
                // collider wants to go up and encoutered jumpthrough obstace
                if tile == Tile::JumpThrough && sign < 0 {
                    collider.seen_wood = true;
                    collider.descent = true;
                }
                if tile == Tile::Empty || (tile == Tile::JumpThrough && collider.descent) {
                    collider.pos.y += sign as f32;
                    move_ -= sign;
                } else {
                    self.actors[id].1 = collider;

                    return false;
                }
            }
        }

        // Final check, if we are out of woods after the move - reset wood flags
        let tile = self.collide_solids(collider.pos, collider.width, collider.height);
        if tile != Tile::JumpThrough {
            collider.seen_wood = false;
            collider.descent = false;
        }

        self.actors[id].1 = collider;
        true
    }

    pub fn move_h(&mut self, actor: Actor, dx: f32) -> bool {
        let id = actor.0;
        let mut collider = self.actors[id].1.clone();
        collider.x_remainder += dx;

        let mut move_ = collider.x_remainder.round() as i32;
        if move_ != 0 {
            collider.x_remainder -= move_ as f32;
            let sign = move_.signum();

            while move_ != 0 {
                let tile = self.collide_solids(
                    collider.pos + vec2(sign as f32, 0.),
                    collider.width,
                    collider.height,
                );
                if tile == Tile::JumpThrough {
                    collider.descent = true;
                    collider.seen_wood = true;
                }
                if tile == Tile::Empty || tile == Tile::JumpThrough {
                    collider.pos.x += sign as f32;
                    move_ -= sign;
                } else {
                    self.actors[id].1 = collider;
                    return false;
                }
            }
        }
        self.actors[id].1 = collider;
        true
    }

    pub fn solid_move(&mut self, solid: Solid, dx: f32, dy: f32) {
        let collider = &mut self.solids[solid.0].1;

        collider.x_remainder += dx;
        collider.y_remainder += dy;
        let move_x = collider.x_remainder.round() as i32;
        let move_y = collider.y_remainder.round() as i32;

        let mut riding_actors = vec![];
        let mut pushing_actors = vec![];

        let riding_rect = Rect::new(
            collider.pos.x,
            collider.pos.y - 1.0,
            collider.width as f32,
            1.0,
        );
        let pushing_rect = Rect::new(
            collider.pos.x + move_x as f32,
            collider.pos.y,
            collider.width as f32,
            collider.height as f32,
        );

        for (actor, actor_collider) in &mut self.actors {
            let rider_rect = Rect::new(
                actor_collider.pos.x,
                actor_collider.pos.y + actor_collider.height as f32 - 1.0,
                actor_collider.width as f32,
                1.0,
            );

            if riding_rect.overlaps(&rider_rect) {
                riding_actors.push(*actor);
            } else if pushing_rect.overlaps(&actor_collider.rect())
                && actor_collider.squished == false
            {
                pushing_actors.push(*actor);
            }

            if pushing_rect.overlaps(&actor_collider.rect()) == false {
                actor_collider.squishers.remove(&solid);
                if actor_collider.squishers.len() == 0 {
                    actor_collider.squished = false;
                }
            }
        }

        self.solids[solid.0].1.collidable = false;
        for actor in riding_actors {
            self.move_h(actor, move_x as f32);
        }
        for actor in pushing_actors {
            let squished = !self.move_h(actor, move_x as f32);
            if squished {
                self.actors[actor.0].1.squished = true;
                self.actors[actor.0].1.squishers.insert(solid);
            }
        }
        self.solids[solid.0].1.collidable = true;

        let collider = &mut self.solids[solid.0].1;
        if move_x != 0 {
            collider.x_remainder -= move_x as f32;
            collider.pos.x += move_x as f32;
        }
        if move_y != 0 {
            collider.y_remainder -= move_y as f32;
            collider.pos.y += move_y as f32;
        }
    }

    pub fn solid_at(&self, pos: Vec2) -> bool {
        self.tag_at(pos, 1)
    }

    pub fn tag_at(&self, pos: Vec2, tag: u8) -> bool {
        for StaticTiledLayer {
            tile_width,
            tile_height,
            width,
            static_colliders,
            tag: layer_tag,
        } in &self.static_tiled_layers
        {
            let y = (pos.y / tile_width) as i32;
            let x = (pos.x / tile_height) as i32;
            let ix = y * (*width as i32) + x;

            if ix >= 0
                && ix < static_colliders.len() as i32
                && static_colliders[ix as usize] != Tile::Empty
            {
                return *layer_tag == tag;
            }
        }

        self.solids
            .iter()
            .any(|solid| solid.1.collidable && solid.1.rect().contains(pos))
    }

    pub fn collide_solids(&self, pos: Vec2, width: i32, height: i32) -> Tile {
        let tile = self.collide_tag(1, pos, width, height);
        if tile != Tile::Empty {
            return tile;
        }

        self.solids
            .iter()
            .find(|solid| {
                solid.1.collidable
                    && solid.1.rect().overlaps(&Rect::new(
                        pos.x,
                        pos.y,
                        width as f32,
                        height as f32,
                    ))
            })
            .map_or(Tile::Empty, |_| Tile::Collider)
    }

    pub fn collide_tag(&self, tag: u8, pos: Vec2, width: i32, height: i32) -> Tile {
        for StaticTiledLayer {
            tile_width,
            tile_height,
            width: layer_width,
            static_colliders,
            tag: layer_tag,
        } in &self.static_tiled_layers
        {
            let layer_height = static_colliders.len() / layer_width + 1;
            let check = |pos: Vec2| {
                let y = (pos.y / tile_width) as i32;
                let x = (pos.x / tile_height) as i32;
                let ix = y * (*layer_width as i32) + x;
                if y >= 0
                    && y < layer_height as i32
                    && x >= 0
                    && x < *layer_width as i32
                    && ix >= 0
                    && ix < static_colliders.len() as i32
                    && *layer_tag == tag
                    && static_colliders[ix as usize] != Tile::Empty
                {
                    return static_colliders[ix as usize];
                }
                return Tile::Empty;
            };

            let tile = check(pos)
                .or(check(pos + vec2(width as f32 - 1.0, 0.0)))
                .or(check(pos + vec2(width as f32 - 1.0, height as f32 - 1.0)))
                .or(check(pos + vec2(0.0, height as f32 - 1.0)));

            if tile != Tile::Empty {
                return tile;
            }

            if width > *tile_width as i32 {
                let mut x = pos.x;

                while {
                    x += tile_width;
                    x < pos.x + width as f32 - 1.
                } {
                    let tile =
                        check(vec2(x, pos.y)).or(check(vec2(x, pos.y + height as f32 - 1.0)));
                    if tile != Tile::Empty {
                        return tile;
                    }
                }
            }

            if height > *tile_height as i32 {
                let mut y = pos.y;

                while {
                    y += tile_height;
                    y < pos.y + height as f32 - 1.
                } {
                    let tile = check(vec2(pos.x, y)).or(check(vec2(pos.x + width as f32 - 1., y)));
                    if tile != Tile::Empty {
                        return tile;
                    }
                }
            }
        }
        return Tile::Empty;
    }

    pub fn squished(&self, actor: Actor) -> bool {
        self.actors[actor.0].1.squished
    }

    pub fn actor_pos(&self, actor: Actor) -> Vec2 {
        self.actors[actor.0].1.pos
    }

    pub fn actor_size(&self, actor: Actor) -> (i32, i32) {
        (self.actors[actor.0].1.width, self.actors[actor.0].1.height)
    }

    pub fn solid_pos(&self, solid: Solid) -> Vec2 {
        self.solids[solid.0].1.pos
    }

    pub fn collide_check(&self, collider: Actor, pos: Vec2) -> bool {
        let collider = &self.actors[collider.0];

        let tile = self.collide_solids(pos, collider.1.width, collider.1.height);
        if collider.1.descent {
            tile == Tile::Solid || tile == Tile::Collider
        } else {
            tile == Tile::Solid || tile == Tile::Collider || tile == Tile::JumpThrough
        }
    }
}

```

`profiler/Cargo.toml`:

```toml
[package]
name = "macroquad-profiler"
version = "0.2.0"
authors = ["Fedor Logachev <not.fl3@gmail.com>"]
edition = "2018"
description = "Profiler UI for macroquad"
license = "MIT/Apache-2.0"

[dependencies]
macroquad = { path = "../", version = "0.4" }

```

`profiler/src/lib.rs`:

```rs
use macroquad::{experimental::collections::storage, telemetry};

use macroquad::prelude::*;

use macroquad::ui::{hash, root_ui, widgets::Window, Ui};

pub struct ProfilerState {
    fps_buffer: Vec<f32>,
    frames_buffer: Vec<telemetry::Frame>,
    selected_frame: Option<telemetry::Frame>,
    profiler_window_opened: bool,
    paused: bool,
}

pub struct ProfilerParams {
    pub fps_counter_pos: Vec2,
}

impl Default for ProfilerParams {
    fn default() -> ProfilerParams {
        ProfilerParams {
            fps_counter_pos: vec2(10., 10.),
        }
    }
}

const FPS_BUFFER_CAPACITY: usize = 100;
const FRAMES_BUFFER_CAPACITY: usize = 400;

fn profiler_window(ui: &mut Ui, state: &mut ProfilerState) {
    fn zone_ui(ui: &mut Ui, zone: &telemetry::Zone, n: usize) {
        let label = format!(
            "{}: {:.4}ms {:.1}(1/t)",
            zone.name,
            zone.duration * 1000.0,
            1.0 / zone.duration
        );
        if zone.children.len() != 0 {
            ui.tree_node(hash!(hash!(), n), &label, |ui| {
                for (m, zone) in zone.children.iter().enumerate() {
                    zone_ui(ui, zone, n * 1000 + m + 1);
                }
            });
        } else {
            ui.label(None, &label);
        }
    }

    let mut canvas = ui.canvas();
    let w = 515.0;
    let h = 40.0;
    let pos = canvas.request_space(vec2(w, h));

    let rect = Rect::new(pos.x, pos.y, w, h);
    canvas.rect(rect, Color::new(0.5, 0.5, 0.5, 1.0), None);

    let (mouse_x, mouse_y) = mouse_position();

    let mut selected_frame = None;

    // select the slowest frame among the ones close to the mouse cursor
    if rect.contains(vec2(mouse_x, mouse_y)) && state.frames_buffer.len() >= 1 {
        let x = ((mouse_x - pos.x - 2.) / w * FRAMES_BUFFER_CAPACITY as f32) as i32;

        let min = clamp(x - 2, 0, state.frames_buffer.len() as i32 - 1) as usize;
        let max = clamp(x + 3, 0, state.frames_buffer.len() as i32 - 1) as usize;

        selected_frame = state.frames_buffer[min..max]
            .iter()
            .enumerate()
            .max_by(|(_, a), (_, b)| a.full_frame_time.partial_cmp(&b.full_frame_time).unwrap())
            .map(|(n, _)| n + min);
    }

    if let Some(frame) = selected_frame {
        if is_mouse_button_down(MouseButton::Left) {
            state.selected_frame = state.frames_buffer[frame].try_clone();
        }
    }
    for (n, frame) in state.frames_buffer.iter().enumerate() {
        let x = n as f32 / FRAMES_BUFFER_CAPACITY as f32 * (w - 2.);
        let selected = selected_frame.map_or(false, |selected| n == selected);
        let color = if selected {
            Color::new(1.0, 1.0, 0.0, 1.0)
        } else if frame.full_frame_time < 1.0 / 58.0 {
            Color::new(0.6, 0.6, 1.0, 1.0)
        } else if frame.full_frame_time < 1.0 / 25.0 {
            Color::new(0.3, 0.3, 0.8, 1.0)
        } else {
            Color::new(0.2, 0.2, 0.6, 1.0)
        };
        let t = macroquad::math::clamp(frame.full_frame_time * 1000.0, 0.0, h);

        canvas.line(
            vec2(pos.x + x + 2., pos.y + h - 1.0),
            vec2(pos.x + x + 2., pos.y + h - t),
            color,
        );
    }

    if let Some(frame) = state
        .selected_frame
        .as_ref()
        .or_else(|| state.frames_buffer.get(0))
    {
        ui.label(
            None,
            &format!(
                "Full frame time: {:.3}ms {:.1}(1/t)",
                frame.full_frame_time * 1000.0,
                (1.0 / frame.full_frame_time)
            ),
        );
    }

    if state.paused {
        if ui.button(None, "resume") {
            state.paused = false;
        }
    } else {
        if ui.button(None, "pause") {
            state.paused = true;
        }
    }
    if state.selected_frame.is_some() {
        ui.same_line(100.0);
        if ui.button(None, "deselect frame") {
            state.selected_frame = None;
        }
    }

    let frame = state
        .selected_frame
        .as_ref()
        .or_else(|| state.frames_buffer.get(0));

    ui.separator();
    ui.group(hash!(), vec2(355., 300.), |ui| {
        if let Some(frame) = frame {
            for (n, zone) in frame.zones.iter().enumerate() {
                zone_ui(ui, zone, n + 1);
            }
        }
    });
    ui.group(hash!(), vec2(153., 300.), |ui| {
        let queries = telemetry::gpu_queries();

        for query in queries {
            let t = query.1 as f64 / 1_000_000_000.0;
            ui.label(
                None,
                &format!("{}: {:.3}ms {:.1}(1/t)", query.0, t * 1000.0, 1.0 / t),
            );
        }
    });
    if ui.button(None, "sample gpu") {
        telemetry::sample_gpu_queries();
    }
}

pub fn profiler(params: ProfilerParams) {
    telemetry::pause_gl_capture();
    if storage::try_get::<ProfilerState>().is_none() {
        storage::store(ProfilerState {
            fps_buffer: vec![],
            frames_buffer: vec![],
            profiler_window_opened: false,
            selected_frame: None,
            paused: false,
        })
    }
    let mut state = storage::get_mut::<ProfilerState>();

    let frame = telemetry::frame();

    if state.paused == false && state.profiler_window_opened {
        state.frames_buffer.insert(0, frame);
    }
    let time = get_frame_time();
    state.fps_buffer.insert(0, time);

    state.fps_buffer.truncate(FPS_BUFFER_CAPACITY);
    state.frames_buffer.truncate(FRAMES_BUFFER_CAPACITY);

    push_camera_state();
    set_default_camera();
    let mut sum = 0.0;
    for (x, time) in state.fps_buffer.iter().enumerate() {
        draw_line(
            x as f32 + params.fps_counter_pos.x,
            params.fps_counter_pos.y + 100.0,
            x as f32 + params.fps_counter_pos.x,
            params.fps_counter_pos.y + 100.0 - (time * 2000.0).min(100.0),
            1.0,
            BLUE,
        );
        sum += time;
    }

    let selectable_rect = Rect::new(
        params.fps_counter_pos.x,
        params.fps_counter_pos.y + 40.0,
        100.0,
        100.0,
    );

    if selectable_rect.contains(mouse_position().into()) {
        draw_rectangle(
            selectable_rect.x,
            selectable_rect.y,
            100.0,
            100.0,
            Color::new(1.0, 1.0, 1.0, 0.4),
        );
        if is_mouse_button_pressed(MouseButton::Left) {
            state.profiler_window_opened ^= true;
            if state.profiler_window_opened {
                telemetry::enable();
            } else {
                telemetry::disable();
            }
        }
    }

    draw_text(
        &format!("{:.1}", 1.0 / (sum / state.fps_buffer.len() as f32)),
        params.fps_counter_pos.x,
        params.fps_counter_pos.y + 100.0,
        30.0,
        WHITE,
    );

    if state.profiler_window_opened {
        Window::new(
            hash!(),
            vec2(params.fps_counter_pos.x, params.fps_counter_pos.y + 150.0),
            vec2(525., 450.),
        )
        .ui(&mut *root_ui(), |ui| {
            let tab = ui.tabbar(
                hash!(),
                vec2(300.0, 20.0),
                &["profiler", "scene", "frame", "log"],
            );

            match tab {
                0 => profiler_window(ui, &mut state),
                1 => ui.label(
                    None,
                    &format!(
                        "scene allocated memory: {:.1} kb",
                        (telemetry::scene_allocated_memory() as f32) / 1000.0
                    ),
                ),
                2 => {
                    let drawcalls = telemetry::drawcalls();
                    ui.label(None, &format!("Draw calls: {}", drawcalls.len()));
                    for telemetry::DrawCallTelemetry { indices_count, .. } in &drawcalls {
                        ui.same_line(0.0);

                        ui.label(None, &format!("{}", indices_count));
                        ui.same_line(0.0);
                    }
                    ui.label(None, " ");

                    for telemetry::DrawCallTelemetry {
                        indices_count,
                        texture,
                    } in &drawcalls
                    {
                        ui.label(None, &format!("{}", *indices_count));
                        ui.same_line(0.0);
                        ui.texture(Texture2D::from_miniquad_texture(*texture), 100., 100.0);
                        ui.same_line(0.0);
                    }
                    ui.label(None, " ");

                    if ui.button(None, "Capture frame") {
                        telemetry::capture_frame();
                    }
                }
                3 => {
                    for label in telemetry::strings() {
                        ui.label(None, &label);
                    }
                }
                _ => unreachable!(),
            }
        });
    }
    pop_camera_state();

    telemetry::resume_gl_capture();
}

```

`src/audio.rs`:

```rs
//! Loading and playing sounds.

#![allow(dead_code)]

use crate::{file::load_file, get_context, Error};
use std::sync::Arc;

#[cfg(feature = "audio")]
use quad_snd::{AudioContext as QuadSndContext, Sound as QuadSndSound};

#[cfg(feature = "audio")]
pub use quad_snd::PlaySoundParams;

#[cfg(not(feature = "audio"))]
mod dummy_audio {
    use crate::audio::PlaySoundParams;

    pub struct AudioContext {}

    impl AudioContext {
        pub fn new() -> AudioContext {
            AudioContext {}
        }

        #[cfg(target_os = "android")]
        pub fn pause(&mut self) {}

        #[cfg(target_os = "android")]
        pub fn resume(&mut self) {}
    }

    pub struct Sound {}

    impl Sound {
        pub fn load(_ctx: &mut AudioContext, _data: &[u8]) -> Sound {
            Sound {}
        }

        pub fn play(&self, _ctx: &mut AudioContext, _params: PlaySoundParams) {
            eprintln!("warn: macroquad's \"audio\" feature disabled.");
        }

        pub fn stop(&self, _ctx: &mut AudioContext) {}

        pub fn set_volume(&self, _ctx: &mut AudioContext, _volume: f32) {}

        #[allow(dead_code)]
        pub fn is_loaded(&self) -> bool {
            true
        }

        pub fn delete(&self, _ctx: &AudioContext) {}
    }
}

#[cfg(not(feature = "audio"))]
use dummy_audio::{AudioContext as QuadSndContext, Sound as QuadSndSound};

#[cfg(not(feature = "audio"))]
pub struct PlaySoundParams {
    pub looped: bool,
    pub volume: f32,
}

pub struct AudioContext {
    native_ctx: QuadSndContext,
}

impl AudioContext {
    pub fn new() -> AudioContext {
        AudioContext {
            native_ctx: QuadSndContext::new(),
        }
    }

    #[cfg(target_os = "android")]
    pub fn pause(&mut self) {
        self.native_ctx.pause()
    }

    #[cfg(target_os = "android")]
    pub fn resume(&mut self) {
        self.native_ctx.resume()
    }
}

struct QuadSndSoundGuarded(QuadSndSound);

impl Drop for QuadSndSoundGuarded {
    fn drop(&mut self) {
        let ctx = &get_context().audio_context;
        self.0.delete(&ctx.native_ctx);
    }
}

#[derive(Clone)]
pub struct Sound(Arc<QuadSndSoundGuarded>);

impl std::fmt::Debug for Sound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Sound").finish()
    }
}

/// Load audio file.
///
/// Attempts to automatically detect the format of the source of data.

pub async fn load_sound(path: &str) -> Result<Sound, Error> {
    let data = load_file(path).await?;

    load_sound_from_bytes(&data).await
}

/// Load audio data.
///
/// Attempts to automatically detect the format of the source of data.
pub async fn load_sound_from_bytes(data: &[u8]) -> Result<Sound, Error> {
    let sound = {
        let ctx = &mut get_context().audio_context;
        QuadSndSound::load(&mut ctx.native_ctx, data)
    };

    // only on wasm the sound is not ready right away
    #[cfg(target_arch = "wasm32")]
    while sound.is_loaded() == false {
        crate::window::next_frame().await;
    }

    Ok(Sound(Arc::new(QuadSndSoundGuarded(sound))))
}

pub fn play_sound_once(sound: &Sound) {
    let ctx = &mut get_context().audio_context;

    sound.0 .0.play(
        &mut ctx.native_ctx,
        PlaySoundParams {
            looped: false,
            volume: 1.0,
        },
    );
}

pub fn play_sound(sound: &Sound, params: PlaySoundParams) {
    let ctx = &mut get_context().audio_context;
    sound.0 .0.play(&mut ctx.native_ctx, params);
}

pub fn stop_sound(sound: &Sound) {
    let ctx = &mut get_context().audio_context;
    sound.0 .0.stop(&mut ctx.native_ctx);
}

pub fn set_sound_volume(sound: &Sound, volume: f32) {
    let ctx = &mut get_context().audio_context;
    sound.0 .0.set_volume(&mut ctx.native_ctx, volume);
}

```

`src/camera.rs`:

```rs
//! 2D and 3D camera.

use crate::{
    get_context,
    math::Rect,
    prelude::RenderPass,
    texture::RenderTarget,
    window::{screen_height, screen_width},
};
use glam::{vec2, vec3, Mat4, Vec2, Vec3};

pub trait Camera {
    fn matrix(&self) -> Mat4;
    fn depth_enabled(&self) -> bool;
    fn render_pass(&self) -> Option<RenderPass>;
    fn viewport(&self) -> Option<(i32, i32, i32, i32)>;
}

#[derive(Debug)]
pub struct Camera2D {
    /// Rotation in degrees.
    pub rotation: f32,
    /// Scaling, should be (1.0, 1.0) by default.
    pub zoom: Vec2,
    /// Rotation and zoom origin.
    pub target: Vec2,
    /// Displacement from target.
    pub offset: Vec2,

    /// If "render_target" is set - camera will render to texture.
    ///
    /// Otherwise to the screen.
    pub render_target: Option<RenderTarget>,

    /// Part of the screen to render to.
    ///
    /// None means the whole screen.
    ///
    /// Viewport do not affect camera space, just the render position on the screen.
    ///
    /// Useful for things like splitscreen.
    pub viewport: Option<(i32, i32, i32, i32)>,
}

impl Camera2D {
    /// Will make camera space equals given rect.
    pub fn from_display_rect(rect: Rect) -> Camera2D {
        let target = vec2(rect.x + rect.w / 2., rect.y + rect.h / 2.);

        Camera2D {
            target,
            zoom: vec2(1. / rect.w * 2., -1. / rect.h * 2.),
            offset: vec2(0., 0.),
            rotation: 0.,

            render_target: None,
            viewport: None,
        }
    }
}

impl Default for Camera2D {
    fn default() -> Camera2D {
        Camera2D {
            zoom: vec2(1., 1.),
            offset: vec2(0., 0.),
            target: vec2(0., 0.),
            rotation: 0.,

            render_target: None,
            viewport: None,
        }
    }
}

impl Camera for Camera2D {
    fn matrix(&self) -> Mat4 {
        // gleaned from https://github.com/raysan5/raylib/blob/master/src/core.c#L1528

        // The camera in world-space is set by
        //   1. Move it to target
        //   2. Rotate by -rotation and scale by (1/zoom)
        //      When setting higher scale, it's more intuitive for the world to become bigger (= camera become smaller),
        //      not for the camera getting bigger, hence the invert. Same deal with rotation.
        //   3. Move it by (-offset);
        //      Offset defines target transform relative to screen, but since we're effectively "moving" screen (camera)
        //      we need to do it into opposite direction (inverse transform)

        // Having camera transform in world-space, inverse of it gives the modelview transform.
        // Since (A*B*C)' = C'*B'*A', the modelview is
        //   1. Move to offset
        //   2. Rotate and Scale
        //   3. Move by -target
        let mat_origin = Mat4::from_translation(vec3(-self.target.x, -self.target.y, 0.0));
        let mat_rotation = Mat4::from_axis_angle(vec3(0.0, 0.0, 1.0), self.rotation.to_radians());
        let invert_y = if self.render_target.is_some() {
            1.0
        } else {
            -1.0
        };
        let mat_scale = Mat4::from_scale(vec3(self.zoom.x, self.zoom.y * invert_y, 1.0));
        let mat_translation = Mat4::from_translation(vec3(self.offset.x, self.offset.y, 0.0));

        mat_translation * ((mat_scale * mat_rotation) * mat_origin)
    }

    fn depth_enabled(&self) -> bool {
        false
    }

    fn render_pass(&self) -> Option<RenderPass> {
        self.render_target.as_ref().map(|rt| rt.render_pass.clone())
    }

    fn viewport(&self) -> Option<(i32, i32, i32, i32)> {
        self.viewport
    }
}

impl Camera2D {
    /// Returns the screen space position for a 2d camera world space position.
    ///
    /// Screen position in window space - from (0, 0) to (screen_width, screen_height()).
    /// When a viewport is set, returns coordinates within that viewport's screen region.
    pub fn world_to_screen(&self, point: Vec2) -> Vec2 {
        let dims = self
            .viewport()
            .map(|(vx, vy, vw, vh)| Rect {
                x: vx as f32,
                y: screen_height() - (vy + vh) as f32,
                w: vw as f32,
                h: vh as f32,
            })
            .unwrap_or(Rect {
                x: 0.0,
                y: 0.0,
                w: screen_width(),
                h: screen_height(),
            });

        let mat = self.matrix();
        let transform = mat.transform_point3(vec3(point.x, point.y, 0.));

        vec2(
            (transform.x / 2. + 0.5) * dims.w + dims.x,
            (0.5 - transform.y / 2.) * dims.h + dims.y,
        )
    }

    /// Returns the world space position for a 2d camera screen space position.
    ///
    /// Point is a screen space position, often mouse x and y.
    pub fn screen_to_world(&self, point: Vec2) -> Vec2 {
        let dims = self
            .viewport()
            .map(|(vx, vy, vw, vh)| Rect {
                x: vx as f32,
                y: screen_height() - (vy + vh) as f32,
                w: vw as f32,
                h: vh as f32,
            })
            .unwrap_or(Rect {
                x: 0.0,
                y: 0.0,
                w: screen_width(),
                h: screen_height(),
            });

        let point = vec2(
            (point.x - dims.x) / dims.w * 2. - 1.,
            1. - (point.y - dims.y) / dims.h * 2.,
        );
        let inv_mat = self.matrix().inverse();
        let transform = inv_mat.transform_point3(vec3(point.x, point.y, 0.));

        vec2(transform.x, transform.y)
    }
}

#[derive(Debug, Clone, Copy)]
pub enum Projection {
    Perspective,
    Orthographics,
}

#[derive(Debug)]
pub struct Camera3D {
    /// Camera position.
    pub position: Vec3,
    /// Camera target it looks-at.
    pub target: Vec3,
    /// Camera up vector (rotation over its axis).
    pub up: Vec3,
    /// Camera field-of-view aperture in Y (radians)
    /// in perspective, used as near plane width in orthographic.
    pub fovy: f32,
    /// Screen aspect ratio.
    ///
    /// By default aspect is calculated with screen_width() / screen_height() on each frame.
    pub aspect: Option<f32>,
    /// Camera projection type, perspective or orthographics.
    pub projection: Projection,

    /// If "render_target" is set - camera will render to texture.
    ///
    /// Otherwise to the screen.
    pub render_target: Option<RenderTarget>,

    /// Part of the screen to render to.
    ///
    /// None means the whole screen.
    ///
    /// Viewport do not affect camera space, just the render position on the screen.
    ///
    /// Useful for things like splitscreen.
    pub viewport: Option<(i32, i32, i32, i32)>,

    /// Camera near plane
    pub z_near: f32,
    /// Camera far plane
    pub z_far: f32,
}

impl Default for Camera3D {
    fn default() -> Camera3D {
        Camera3D {
            position: vec3(0., -10., 0.),
            target: vec3(0., 0., 0.),
            aspect: None,
            up: vec3(0., 0., 1.),
            fovy: 45.0_f32.to_radians(),
            projection: Projection::Perspective,
            render_target: None,
            viewport: None,
            z_near: 0.01,
            z_far: 10000.0,
        }
    }
}

impl Camera for Camera3D {
    fn matrix(&self) -> Mat4 {
        let aspect = self.aspect.unwrap_or(screen_width() / screen_height());

        match self.projection {
            Projection::Perspective => {
                Mat4::perspective_rh_gl(self.fovy, aspect, self.z_near, self.z_far)
                    * Mat4::look_at_rh(self.position, self.target, self.up)
            }
            Projection::Orthographics => {
                let top = self.fovy / 2.0;
                let right = top * aspect;

                Mat4::orthographic_rh_gl(-right, right, -top, top, self.z_near, self.z_far)
                    * Mat4::look_at_rh(self.position, self.target, self.up)
            }
        }
    }

    fn depth_enabled(&self) -> bool {
        true
    }

    fn render_pass(&self) -> Option<RenderPass> {
        self.render_target.as_ref().map(|rt| rt.render_pass.clone())
    }

    fn viewport(&self) -> Option<(i32, i32, i32, i32)> {
        self.viewport
    }
}

/// Set active 2D or 3D camera.
pub fn set_camera(camera: &dyn Camera) {
    let context = get_context();

    // flush previous camera draw calls
    context.perform_render_passes();

    context
        .gl
        .render_pass(camera.render_pass().map(|rt| rt.raw_miniquad_id()));

    context.gl.viewport(camera.viewport());
    context.gl.depth_test(camera.depth_enabled());
    context.camera_matrix = Some(camera.matrix());
}

/// Reset default 2D camera mode.
pub fn set_default_camera() {
    let context = get_context();

    // flush previous camera draw calls
    context.perform_render_passes();

    context.gl.render_pass(None);
    context.gl.viewport(None);
    context.gl.depth_test(false);
    context.camera_matrix = None;
}

pub(crate) struct CameraState {
    render_pass: Option<miniquad::RenderPass>,
    depth_test: bool,
    matrix: Option<Mat4>,
}

pub fn push_camera_state() {
    let context = get_context();

    let camera_state = CameraState {
        render_pass: context.gl.get_active_render_pass(),
        depth_test: context.gl.is_depth_test_enabled(),
        matrix: context.camera_matrix,
    };
    context.camera_stack.push(camera_state);
}

pub fn pop_camera_state() {
    let context = get_context();

    if let Some(camera_state) = context.camera_stack.pop() {
        context.perform_render_passes();

        context.gl.render_pass(camera_state.render_pass);
        context.gl.depth_test(camera_state.depth_test);
        context.camera_matrix = camera_state.matrix;
    }
}

```

`src/color.rs`:

```rs
//! Color types and helpers.

pub use colors::*;

/// A color represented by 4 floats: red, green, blue and alpha.
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Color {
    /// Red channel value from 0.0 to 1.0.
    pub r: f32,
    /// Green channel value from 0.0 to 1.0.
    pub g: f32,
    /// Blue channel value from 0.0 to 1.0.
    pub b: f32,
    /// Alpha channel value from 0.0 to 1.0.
    pub a: f32,
}

/// Build a color from 4 components of 0..255 values.
/// This was a temporary solution because [Color::from_rgba] was not a const fn due to
/// [this issue](https://github.com/rust-lang/rust/issues/57241) waiting to be resolved.
/// It is not needed anymore.
#[macro_export]
macro_rules! color_u8 {
    ($r:expr, $g:expr, $b:expr, $a:expr) => {
        Color::new(
            $r as f32 / 255.,
            $g as f32 / 255.,
            $b as f32 / 255.,
            $a as f32 / 255.,
        )
    };
}

#[test]
fn color_from_bytes() {
    assert_eq!(Color::new(1.0, 0.0, 0.0, 1.0), color_u8!(255, 0, 0, 255));
    assert_eq!(
        Color::new(1.0, 0.5, 0.0, 1.0),
        color_u8!(255, 127.5, 0, 255)
    );
    assert_eq!(
        Color::new(0.0, 1.0, 0.5, 1.0),
        color_u8!(0, 255, 127.5, 255)
    );
}

impl From<Color> for [u8; 4] {
    fn from(val: Color) -> Self {
        [
            (val.r * 255.) as u8,
            (val.g * 255.) as u8,
            (val.b * 255.) as u8,
            (val.a * 255.) as u8,
        ]
    }
}

impl From<[u8; 4]> for Color {
    fn from(val: [u8; 4]) -> Self {
        Color::new(
            val[0] as f32 / 255.,
            val[1] as f32 / 255.,
            val[2] as f32 / 255.,
            val[3] as f32 / 255.,
        )
    }
}

impl From<Color> for [f32; 4] {
    fn from(val: Color) -> Self {
        [val.r, val.g, val.b, val.a]
    }
}

impl From<[f32; 4]> for Color {
    fn from(colors: [f32; 4]) -> Color {
        Color::new(colors[0], colors[1], colors[2], colors[3])
    }
}

impl Color {
    /// Creates a new `Color` with the given red, green, blue, and alpha components.
    /// Values are expected to be between 0.0 and 1.0.
    ///
    /// # Example
    ///
    /// ```
    /// use macroquad::prelude::*;
    ///
    /// let pink = Color::new(1.00, 0.43, 0.76, 1.00);
    /// assert_eq!(pink.r, 1.00);
    /// assert_eq!(pink.g, 0.43);
    /// assert_eq!(pink.b, 0.76);
    /// assert_eq!(pink.a, 1.00);
    /// ```
    ///
    /// Note that values outside of this range are effectively clamped,
    /// and do not generate an error or warning.
    pub const fn new(r: f32, g: f32, b: f32, a: f32) -> Color {
        Color { r, g, b, a }
    }

    /// Build a color from 4 components between 0 and 255.
    pub const fn from_rgba(r: u8, g: u8, b: u8, a: u8) -> Color {
        Color::new(
            r as f32 / 255.,
            g as f32 / 255.,
            b as f32 / 255.,
            a as f32 / 255.,
        )
    }

    /// Build a color from a hexadecimal u32.
    ///
    /// # Example
    ///
    /// ```
    /// use macroquad::prelude::*;
    ///
    /// let light_blue = Color::from_hex(0x3CA7D5);
    /// assert_eq!(light_blue.r, 0.23529412);
    /// assert_eq!(light_blue.g, 0.654902);
    /// assert_eq!(light_blue.b, 0.8352941);
    /// assert_eq!(light_blue.a, 1.00);
    /// ```
    pub const fn from_hex(hex: u32) -> Color {
        let bytes: [u8; 4] = hex.to_be_bytes();

        Self::from_rgba(bytes[1], bytes[2], bytes[3], 255)
    }

    /// Create a vec4 of red, green, blue, and alpha components.
    pub const fn to_vec(&self) -> glam::Vec4 {
        glam::Vec4::new(self.r, self.g, self.b, self.a)
    }

    /// Create a color from a vec4 of red, green, blue, and alpha components.
    pub const fn from_vec(vec: glam::Vec4) -> Self {
        Self::new(vec.x, vec.y, vec.z, vec.w)
    }

    /// Create a copy of the current color, but with a different alpha value.
    pub const fn with_alpha(&self, alpha: f32) -> Color {
        Color::new(self.r, self.g, self.b, alpha)
    }
}

pub mod colors {
    //! Constants for some common colors.

    use super::Color;

    pub const LIGHTGRAY: Color = Color::new(0.78, 0.78, 0.78, 1.00);
    pub const GRAY: Color = Color::new(0.51, 0.51, 0.51, 1.00);
    pub const DARKGRAY: Color = Color::new(0.31, 0.31, 0.31, 1.00);
    pub const YELLOW: Color = Color::new(0.99, 0.98, 0.00, 1.00);
    pub const GOLD: Color = Color::new(1.00, 0.80, 0.00, 1.00);
    pub const ORANGE: Color = Color::new(1.00, 0.63, 0.00, 1.00);
    pub const PINK: Color = Color::new(1.00, 0.43, 0.76, 1.00);
    pub const RED: Color = Color::new(0.90, 0.16, 0.22, 1.00);
    pub const MAROON: Color = Color::new(0.75, 0.13, 0.22, 1.00);
    pub const GREEN: Color = Color::new(0.00, 0.89, 0.19, 1.00);
    pub const LIME: Color = Color::new(0.00, 0.62, 0.18, 1.00);
    pub const DARKGREEN: Color = Color::new(0.00, 0.46, 0.17, 1.00);
    pub const SKYBLUE: Color = Color::new(0.40, 0.75, 1.00, 1.00);
    pub const BLUE: Color = Color::new(0.00, 0.47, 0.95, 1.00);
    pub const DARKBLUE: Color = Color::new(0.00, 0.32, 0.67, 1.00);
    pub const PURPLE: Color = Color::new(0.78, 0.48, 1.00, 1.00);
    pub const VIOLET: Color = Color::new(0.53, 0.24, 0.75, 1.00);
    pub const DARKPURPLE: Color = Color::new(0.44, 0.12, 0.49, 1.00);
    pub const BEIGE: Color = Color::new(0.83, 0.69, 0.51, 1.00);
    pub const BROWN: Color = Color::new(0.50, 0.42, 0.31, 1.00);
    pub const DARKBROWN: Color = Color::new(0.30, 0.25, 0.18, 1.00);
    pub const WHITE: Color = Color::new(1.00, 1.00, 1.00, 1.00);
    pub const BLACK: Color = Color::new(0.00, 0.00, 0.00, 1.00);
    pub const BLANK: Color = Color::new(0.00, 0.00, 0.00, 0.00);
    pub const MAGENTA: Color = Color::new(1.00, 0.00, 1.00, 1.00);
}

#[rustfmt::skip]
pub fn hsl_to_rgb(h: f32, s: f32, l: f32) -> Color {
    let r;
    let g;
    let b;

    if s == 0.0 {  r = l; g = l; b = l; }
    else {
        fn hue_to_rgb(p: f32, q: f32, mut t: f32) -> f32 {
            if t < 0.0 { t += 1.0 }
            if t > 1.0 { t -= 1.0 }
            if t < 1.0 / 6.0 { return p + (q - p) * 6.0 * t; }
            if t < 1.0 / 2.0 { return q; }
            if t < 2.0 / 3.0 { return p + (q - p) * (2.0 / 3.0 - t) * 6.0; }
            p
        }

        let q = if l < 0.5 {
            l * (1.0 + s)
        } else {
            l + s - l * s
        };
        let p = 2.0 * l - q;
        r = hue_to_rgb(p, q, h + 1.0 / 3.0);
        g = hue_to_rgb(p, q, h);
        b = hue_to_rgb(p, q, h - 1.0 / 3.0);
    }

    Color::new(r, g, b, 1.0)
}

pub fn rgb_to_hsl(color: Color) -> (f32, f32, f32) {
    fn max(a: f32, b: f32) -> f32 {
        if a > b {
            a
        } else {
            b
        }
    }
    fn min(a: f32, b: f32) -> f32 {
        if a < b {
            a
        } else {
            b
        }
    }

    let Color { r, g, b, .. } = color;

    let max = max(max(r, g), b);
    let min = min(min(r, g), b);

    // Luminosity is the average of the max and min rgb color intensities.
    let l = (max + min) / 2.0;

    // Saturation
    let delta: f32 = max - min;
    if delta == 0.0 {
        // it's gray
        return (0.0, 0.0, l);
    }

    // it's not gray
    let s = if l < 0.5 {
        delta / (max + min)
    } else {
        delta / (2.0 - max - min)
    };

    // Hue
    let r2 = (((max - r) / 6.0) + (delta / 2.0)) / delta;
    let g2 = (((max - g) / 6.0) + (delta / 2.0)) / delta;
    let b2 = (((max - b) / 6.0) + (delta / 2.0)) / delta;

    let mut h = match max {
        x if x == r => b2 - g2,
        x if x == g => (1.0 / 3.0) + r2 - b2,
        _ => (2.0 / 3.0) + g2 - r2,
    };

    // Fix wraparounds
    if h < 0 as f32 {
        h += 1.0;
    } else if h > 1 as f32 {
        h -= 1.0;
    }

    (h, s, l)
}

```

`src/error.rs`:

```rs
#[derive(Debug)]
pub enum Error {
    FontError(&'static str),
    FileError {
        kind: miniquad::fs::Error,
        path: String,
    },
    ShaderError(miniquad::ShaderError),
    ImageError(image::ImageError),
    UnknownError(&'static str),
}

impl From<&'static str> for Error {
    fn from(s: &'static str) -> Self {
        Error::UnknownError(s)
    }
}

impl From<miniquad::ShaderError> for Error {
    fn from(s: miniquad::ShaderError) -> Self {
        Error::ShaderError(s)
    }
}

impl From<image::ImageError> for Error {
    fn from(s: image::ImageError) -> Self {
        Error::ImageError(s)
    }
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "error: {self:?}")
    }
}

impl std::error::Error for Error {}

```

`src/exec.rs`:

```rs
use std::future::Future;
use std::pin::Pin;
use std::sync::{Arc, Mutex};
use std::task::{Context, Poll, RawWaker, RawWakerVTable, Waker};

use crate::Error;

// Returns Pending as long as its inner bool is false.
#[derive(Default)]
pub struct FrameFuture {
    done: bool,
}

impl Future for FrameFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, _context: &mut Context) -> Poll<Self::Output> {
        if self.done {
            // We were told to step, meaning this future gets destroyed and we run
            // the main future until we call next_frame again and end up in this poll
            // function again.
            Poll::Ready(())
        } else {
            self.done = true;
            Poll::Pending
        }
    }
}

pub struct FileLoadingFuture {
    pub contents: Arc<Mutex<Option<Result<Vec<u8>, Error>>>>,
}

impl Future for FileLoadingFuture {
    type Output = Result<Vec<u8>, Error>;

    fn poll(self: Pin<&mut Self>, _context: &mut Context) -> Poll<Self::Output> {
        let mut contents = self.contents.lock().unwrap();
        if let Some(contents) = contents.take() {
            Poll::Ready(contents)
        } else {
            Poll::Pending
        }
    }
}

fn waker() -> Waker {
    unsafe fn clone(data: *const ()) -> RawWaker {
        RawWaker::new(data, &VTABLE)
    }
    unsafe fn wake(_data: *const ()) {
        panic!(
            "macroquad does not support waking futures, please use coroutines, \
            otherwise your pending future will block until the next frame"
        )
    }
    unsafe fn wake_by_ref(data: *const ()) {
        wake(data);
    }
    unsafe fn drop(_data: *const ()) {
        // Nothing to do
    }
    const VTABLE: RawWakerVTable = RawWakerVTable::new(clone, wake, wake_by_ref, drop);
    let raw_waker = RawWaker::new(std::ptr::null(), &VTABLE);
    unsafe { Waker::from_raw(raw_waker) }
}

/// returns Some(T) if future is done, None if it would block
pub(crate) fn resume<T>(future: &mut Pin<Box<dyn Future<Output = T>>>) -> Option<T> {
    let waker = waker();
    let mut futures_context = std::task::Context::from_waker(&waker);
    match future.as_mut().poll(&mut futures_context) {
        Poll::Ready(v) => Some(v),
        Poll::Pending => None,
    }
}

```

`src/experimental.rs`:

```rs
//! The most unstable things in macroquad
//! Some of them will eventually move to other modules,
//! some will move into separate crates and some may just disappear.

pub mod animation;
pub mod camera;
pub mod collections;
pub mod coroutines;
pub mod scene;
pub mod state_machine;

```

`src/experimental/animation.rs`:

```rs
//! Animation management
//!
//! To create custom animation and use it you will need an image that can be represented as tiles.
//! Each tile contains specific frame of animation.
//! Every specific animation should be placed in separate row.
//!
//! # Examples
//! Let's say we have an image of our character where every frame is 15x20 rect and we have this animations:
//! - Idle animation with 20 frames at 12 fps
//! - Run animation with 15 frames at 15 fps
//!
//! ```no_run
//! use macroquad::experimental::animation::*;
//! use macroquad::prelude::*;
//!
//! #[macroquad::main("Animation")]
//! async fn main() {
//!     // Define animations
//!     let mut sprite = AnimatedSprite::new(
//!         15,
//!         20,
//!         &[
//!             Animation {
//!                 name: "idle".to_string(),
//!                 row: 0,
//!                 frames: 20,
//!                 fps: 12,
//!             },
//!             Animation {
//!                 name: "run".to_string(),
//!                 row: 1,
//!                 frames: 15,
//!                 fps: 15,
//!             },
//!         ],
//!         true,
//!     );
//!     let image = load_texture("some_path.png").await.unwrap();
//!     loop {
//!         clear_background(WHITE);
//!         // Now we can draw our character
//!         draw_texture_ex(
//!             &image,
//!             10.,
//!             10.,
//!             WHITE,
//!             DrawTextureParams {
//!                 source: Some(sprite.frame().source_rect),
//!                 dest_size: Some(sprite.frame().dest_size),
//!                 ..Default::default()
//!             }
//!         );
//!         // Update frame
//!         sprite.update();
//!         next_frame().await;
//!     }
//! }

use crate::{
    math::{vec2, Rect, Vec2},
    time::get_frame_time,
};

/// Specification of animation
#[derive(Clone, Debug)]
pub struct Animation {
    pub name: String,
    pub row: u32,
    pub frames: u32,
    pub fps: u32,
}

/// Specific animation frame
pub struct AnimationFrame {
    /// Area of current frame in source image
    pub source_rect: Rect,
    /// Size of frame
    pub dest_size: Vec2,
}

/// Main definition of all animations for specific image
#[derive(Clone)]
pub struct AnimatedSprite {
    tile_width: f32,
    tile_height: f32,
    animations: Vec<Animation>,

    current_animation: usize,
    time: f32,
    frame: u32,
    /// Controls if frame should be updated on [update][Self::update]
    pub playing: bool,
}

impl AnimatedSprite {
    pub fn new(
        tile_width: u32,
        tile_height: u32,
        animations: &[Animation],
        playing: bool,
    ) -> AnimatedSprite {
        AnimatedSprite {
            tile_width: tile_width as f32,
            tile_height: tile_height as f32,
            animations: animations.to_vec(),
            current_animation: 0,
            time: 0.0,
            frame: 0,
            playing,
        }
    }

    /// Choose animation to display
    ///
    /// **Note:** the animations is not reset when switching, for this use [set_frame][Self::set_frame]
    pub fn set_animation(&mut self, animation: usize) {
        self.current_animation = animation;

        let animation = &self.animations[self.current_animation];
        self.frame %= animation.frames;
    }

    /// Currently chosen animation
    pub const fn current_animation(&self) -> usize {
        self.current_animation
    }

    /// Set specific frame for animation
    pub fn set_frame(&mut self, frame: u32) {
        self.frame = frame;
    }

    /// Returns whether the last frame is being displayed
    pub fn is_last_frame(&self) -> bool {
        let animation = &self.animations[self.current_animation];
        self.frame == animation.frames - 1
    }

    /// Update current frame
    ///
    /// Switches to the next frame every `1. / current_animation.fps` seconds
    pub fn update(&mut self) {
        let animation = &self.animations[self.current_animation];

        if self.playing {
            self.time += get_frame_time();
            if self.time > 1. / animation.fps as f32 {
                self.frame += 1;
                self.time = 0.0;
            }
        }
        self.frame %= animation.frames;
    }

    /// Get current frame
    pub fn frame(&self) -> AnimationFrame {
        let animation = &self.animations[self.current_animation];

        AnimationFrame {
            source_rect: Rect::new(
                self.tile_width * self.frame as f32,
                self.tile_height * animation.row as f32,
                self.tile_width,
                self.tile_height,
            ),
            dest_size: vec2(self.tile_width, self.tile_height),
        }
    }
}

```

`src/experimental/camera.rs`:

```rs
pub mod mouse;

```

`src/experimental/camera/mouse.rs`:

```rs
use crate::prelude::screen_width;
use crate::prelude::*;
use crate::Vec2;

/// 2D camera that can be controlled by mouse. Offset and scale can be changed.
///
/// Note: You can get a [`Camera2D`] using `let cam2d: Camera2D = (&cam).into();
#[derive(Debug, Copy, Clone)]
pub struct Camera {
    pub offset: Vec2,
    pub scale: f32,

    last_mouse_pos: Vec2,
}

impl Default for Camera {
    fn default() -> Self {
        Self::new(Vec2::ZERO, 1.0)
    }
}

impl Camera {
    pub const fn new(offset: Vec2, scale: f32) -> Self {
        Self {
            offset,
            scale,

            last_mouse_pos: Vec2::new(0., 0.),
        }
    }

    /// If `wheel_value` has positive value, scale cam around point `center` by factor `scale_factor`.
    /// If `wheel_value` is negative, then scale by `1.0/scale_factor`. If `wheel_value` equals `0.0` or `scale_factor` equals `1.0`, nothing happens.
    pub fn scale_wheel(&mut self, center: Vec2, wheel_value: f32, scale_factor: f32) {
        if wheel_value > 0. {
            self.scale_mul(center, scale_factor);
        } else if wheel_value < 0. {
            self.scale_mul(center, 1.0 / scale_factor);
        }
    }

    /// Adds `mul_to_scale` to current scale of cam. Scale is changed around point `center`.
    pub fn scale_mul(&mut self, center: Vec2, mul_to_scale: f32) {
        self.scale_new(center, self.scale * mul_to_scale);
    }

    /// Replace current scale of camera with `new_scale`. Scale is changed around point `center`.
    pub fn scale_new(&mut self, center: Vec2, new_scale: f32) {
        self.offset = (self.offset - center) * (new_scale / self.scale) + center;
        self.scale = new_scale;
    }

    /// Update camera position by new mouse position. This method must be run at every frame. `should_offset` controls if the camera should actually move or not.
    ///
    /// Note: It's better to use [`mouse_position_local`] with this method, otherwise if you use [`mouse_position`] the movement is way too big.
    pub fn update(&mut self, mouse_pos: Vec2, should_offset: bool) {
        if should_offset {
            self.offset += mouse_pos - self.last_mouse_pos;
        }
        self.last_mouse_pos = mouse_pos;
    }
}

impl From<&Camera> for Camera2D {
    fn from(val: &Camera) -> Self {
        let aspect = screen_width() / screen_height();
        Camera2D {
            zoom: vec2(val.scale, -val.scale * aspect),
            offset: vec2(val.offset.x, -val.offset.y),
            target: vec2(0., 0.),
            rotation: 0.,

            render_target: None,
            viewport: None,
        }
    }
}

```

`src/experimental/collections.rs`:

```rs
//! Special macroquad-friendly collections.
//! The datatypes from this module may help to organize game code.

/// Global persistent storage. Nice for some global game configs available everywhere.
/// Yes, singletons available right here, with a nice API and some safety.
pub mod storage;

```

`src/experimental/collections/storage.rs`:

```rs
//! Global read-only storage
//!
//! ```
//! use macroquad::experimental::collections::storage;
//!
//! struct WorldBoundaries(i32);
//!
//! fn draw_player() {
//!   let boundaries: i32 = storage::get::<WorldBoundaries>().0;
//!   assert_eq!(boundaries, 23);
//! }
//!
//! storage::store(WorldBoundaries(23));
//! draw_player();
//! ```

use std::any::{Any, TypeId};

use std::collections::HashMap;
use std::{
    cell::RefCell,
    ops::{Deref, DerefMut},
    rc::Rc,
};

static mut STORAGE: Option<HashMap<TypeId, Box<dyn Any>>> = None;

/// Store data in global storage.
/// Will silently overwrite an old value if any.
pub fn store<T: Any>(data: T) {
    unsafe {
        if STORAGE.is_none() {
            STORAGE = Some(HashMap::new());
        }

        STORAGE
            .as_mut()
            .unwrap()
            .insert(TypeId::of::<T>(), Box::new(Rc::new(RefCell::new(data))))
    };
}

/// Get reference to data from global storage.
/// Will panic if there is no data available with this type.
pub fn get<T: Any>() -> impl Deref<Target = T> {
    try_get::<T>().unwrap()
}

/// Get reference to data from global storage.
/// Will return None if there is no data available with this type.
pub fn try_get<T: Any>() -> Option<impl Deref<Target = T>> {
    unsafe {
        if STORAGE.is_none() {
            STORAGE = Some(HashMap::new());
        }

        STORAGE.as_mut().unwrap().get(&TypeId::of::<T>()).as_ref()
    }
    .and_then(|data| {
        data.downcast_ref::<Rc<RefCell<T>>>()
            .map(|data| data.borrow())
    })
}

/// Get mutable reference to data from global storage.
/// Will return None if there is no data available with this type.
pub fn try_get_mut<T: Any>() -> Option<impl DerefMut<Target = T>> {
    unsafe {
        if STORAGE.is_none() {
            STORAGE = Some(HashMap::new());
        }

        STORAGE.as_mut().unwrap().get(&TypeId::of::<T>()).as_ref()
    }
    .and_then(|data| {
        data.downcast_ref::<Rc<RefCell<T>>>()
            .map(|data| data.borrow_mut())
    })
}

/// Get mutable reference to data from global storage.
/// Will panic if there is no data available with this type.
pub fn get_mut<T: Any>() -> impl DerefMut<Target = T> {
    try_get_mut::<T>().unwrap()
}

```

`src/experimental/coroutines.rs`:

```rs
//! The way to emulate multitasking with macroquad's `.await`.
//! Useful for organizing state machines, animation cutscenes and other stuff that require
//! some evaluation over time.
//!

use std::any::{Any, TypeId};
use std::future::Future;
use std::marker::PhantomData;
use std::pin::Pin;
use std::task::{Context, Poll};

use crate::exec::resume;
use crate::get_context;

mod generational_storage;

use generational_storage::{GenerationalId, GenerationalStorage};

struct CoroutineInternal {
    future: Pin<Box<dyn Future<Output = Box<dyn Any>>>>,
    manual_poll: bool,
    manual_time: Option<f64>,
    // if return value of a coroutine is () there is no need to
    // keep coroutine's memory allocated until the user retrieves the data
    // we can free the memory right away, and just return () on retrieve
    has_value: bool,
}

enum CoroutineState {
    Running(CoroutineInternal),
    Value(Box<dyn Any>),
    Nothing,
}

impl CoroutineState {
    pub const fn is_value(&self) -> bool {
        matches!(self, CoroutineState::Value(_))
    }

    pub const fn is_nothing(&self) -> bool {
        matches!(self, CoroutineState::Nothing)
    }

    pub fn take_value(&mut self) -> Option<Box<dyn Any>> {
        if self.is_value() {
            let state = std::mem::replace(self, CoroutineState::Nothing);
            if let CoroutineState::Value(v) = state {
                return Some(v);
            }
        }

        None
    }
}

pub(crate) struct CoroutinesContext {
    coroutines: GenerationalStorage<CoroutineState>,
    active_coroutine_now: Option<f64>,
    active_coroutine_delta: Option<f64>,
}

impl CoroutinesContext {
    pub fn new() -> CoroutinesContext {
        CoroutinesContext {
            coroutines: GenerationalStorage::new(),
            active_coroutine_now: None,
            active_coroutine_delta: None,
        }
    }

    pub fn update(&mut self) {
        self.coroutines.retain(|coroutine| {
            if let CoroutineState::Running(ref mut f) = coroutine {
                if f.manual_poll == false {
                    if let Some(v) = resume(&mut f.future) {
                        if f.has_value {
                            *coroutine = CoroutineState::Value(v);
                        } else {
                            return false;
                        }
                    }
                }
            }

            true
        });
    }

    pub(crate) fn allocated_memory(&self) -> usize {
        self.coroutines.allocated_memory()
    }

    pub(crate) fn active_coroutines_count(&self) -> usize {
        self.coroutines.count()
    }
}
#[derive(Clone, Copy, Debug)]
pub struct Coroutine<T = ()> {
    id: GenerationalId,
    _phantom: PhantomData<T>,
}

impl<T: 'static + Any> Coroutine<T> {
    /// Returns true if the coroutine finished or was stopped.
    pub fn is_done(&self) -> bool {
        let context = &get_context().coroutines_context;

        let coroutine = context.coroutines.get(self.id);

        if let Some(coroutine) = coroutine {
            return coroutine.is_value() || coroutine.is_nothing();
        }

        return true;
    }

    pub fn retrieve(&self) -> Option<T> {
        let context = &mut get_context().coroutines_context;

        // () is a special case. Futures with () as a return type do not keep
        // their state after finish, so just return ()
        if self.is_done() && TypeId::of::<()>() == TypeId::of::<T>() {
            // well, I wish tehre was a better way to do this..
            let res = Box::new(()) as Box<dyn Any>;
            return Some(*res.downcast().unwrap());
        }

        let coroutine = context.coroutines.get_mut(self.id);
        if let Some(v) = coroutine.and_then(|c| c.take_value()) {
            let res = Some(*v.downcast().unwrap());
            context.coroutines.free(self.id);
            return res;
        }

        None
    }

    /// By default coroutines are being polled each frame, inside the "next_frame()"
    ///
    /// ```skip
    /// start_coroutine(async move {
    ///    println!("a");
    ///    next_frame().await;
    ///    println!("b");
    /// }); // <- coroutine is created, but not yet polled
    /// println!("c"); // <- first print, "c"
    /// next_frame().await; // coroutine will be polled for the first time
    ///                     // will print "a"
    /// println!("d");      // "d"
    /// next_frame().await; // coroutine will be polled second time, pass next_frame().await and will print "b"
    /// ```
    /// will print "cadb" (there is a test for it, "tests/coroutine.rs:coroutine_execution_order" )
    ///
    /// But, sometimes, automatic polling is not nice
    /// good example - game pause. Imagine a player that have some "update" function
    /// and some coroutines runned. During the pause "update" just early quit, but
    /// what with the coroutines?
    ///
    /// "set_manual_poll" allows to control how coroutine is beng polled
    /// after set_manual_poll() coroutine will never be polled automatically
    /// so player will need to poll all its coroutines inside "update" function
    pub fn set_manual_poll(&mut self) {
        let context = &mut get_context().coroutines_context;

        if let Some(CoroutineState::Running(coroutine)) = context.coroutines.get_mut(self.id) {
            coroutine.manual_time = Some(0.);
            coroutine.manual_poll = true;
        }
    }

    /// Poll coroutine once and advance coroutine's timeline by `delta_time`
    /// Things like `wait_for_seconds` will wait for time in this local timeline`
    /// Will panic if coroutine.manual_poll == false
    pub fn poll(&mut self, delta_time: f64) {
        let context = &mut get_context().coroutines_context;

        let coroutine = context.coroutines.get_mut(self.id);

        // coroutine was finished already
        if coroutine.is_none() {
            return;
        }

        let coroutine = coroutine.unwrap();
        if let CoroutineState::Running(f) = coroutine {
            context.active_coroutine_now = f.manual_time;
            context.active_coroutine_delta = Some(delta_time);
            *f.manual_time.as_mut().unwrap() += delta_time;
            if let Some(v) = resume(&mut f.future) {
                if f.has_value {
                    *coroutine = CoroutineState::Value(v);
                } else {
                    context.coroutines.free(self.id);
                }
            }
            context.active_coroutine_now = None;
            context.active_coroutine_delta = None;
        }
    }
}

pub fn start_coroutine<T: 'static + Any>(
    future: impl Future<Output = T> + 'static + Send,
) -> Coroutine<T> {
    let context = &mut get_context().coroutines_context;

    let has_value = TypeId::of::<()>() != TypeId::of::<T>();

    let id = context
        .coroutines
        .push(CoroutineState::Running(CoroutineInternal {
            future: Box::pin(async { Box::new(future.await) as _ }),
            has_value,
            manual_poll: false,
            manual_time: None,
        }));

    Coroutine {
        id,
        _phantom: PhantomData,
    }
}

pub fn stop_all_coroutines() {
    let context = &mut get_context().coroutines_context;

    context.coroutines.clear();
}

pub fn stop_coroutine<T: 'static + Any>(coroutine: Coroutine<T>) {
    let context = &mut get_context().coroutines_context;

    context.coroutines.free(coroutine.id);
}

pub struct TimerDelayFuture {
    pub(crate) remaining_time: f32,
}

impl Future for TimerDelayFuture {
    type Output = Option<()>;

    fn poll(mut self: Pin<&mut Self>, _: &mut Context) -> Poll<Self::Output> {
        let delta = get_context()
            .coroutines_context
            .active_coroutine_delta
            .unwrap_or(crate::time::get_frame_time() as _);

        self.remaining_time -= delta as f32;

        if self.remaining_time <= 0.0 {
            Poll::Ready(Some(()))
        } else {
            Poll::Pending
        }
    }
}

pub const fn wait_seconds(time: f32) -> TimerDelayFuture {
    TimerDelayFuture {
        remaining_time: time,
    }
}

/// Special built-in coroutines for modifying values over time.
pub mod tweens {
    use crate::experimental::scene::{Handle, Lens, Node};
    use std::future::Future;
    use std::pin::Pin;
    use std::{
        ops::{Add, Mul, Sub},
        task::{Context, Poll},
    };

    pub struct LinearTweenFuture<T>
    where
        T: Copy + Add<Output = T> + Sub<Output = T> + Mul<f32, Output = T>,
    {
        from: T,
        to: T,
        lens: Lens<T>,
        start_time: f64,
        time: f32,
    }
    impl<T> Unpin for LinearTweenFuture<T> where
        T: Copy + Add<Output = T> + Sub<Output = T> + Mul<f32, Output = T>
    {
    }

    impl<T> Future for LinearTweenFuture<T>
    where
        T: Copy + Add<Output = T> + Sub<Output = T> + Mul<f32, Output = T>,
    {
        type Output = ();

        fn poll(self: Pin<&mut Self>, _: &mut Context) -> Poll<Self::Output> {
            let t = (miniquad::date::now() - self.start_time) / self.time as f64;
            let this = self.get_mut();
            let var = this.lens.get();

            // node with value was deleted
            if var.is_none() {
                return Poll::Ready(());
            }
            let var = var.unwrap();

            if t <= 1. {
                *var = this.from + (this.to - this.from) * t as f32;

                Poll::Pending
            } else {
                *var = this.to;

                Poll::Ready(())
            }
        }
    }

    pub fn linear<T, T1, F>(
        handle: Handle<T1>,
        lens: F,
        from: T,
        to: T,
        time: f32,
    ) -> LinearTweenFuture<T>
    where
        T: Copy + Add<Output = T> + Sub<Output = T> + Mul<f32, Output = T>,
        T1: Node,
        F: for<'r> FnMut(&'r mut T1) -> &'r mut T,
    {
        LinearTweenFuture {
            to,
            from,
            lens: handle.lens(lens),
            time,
            start_time: miniquad::date::now(),
        }
    }

    pub async fn follow_path<T, T1, F>(handle: Handle<T1>, mut lens: F, path: Vec<T>, time: f32)
    where
        T: Copy + Add<Output = T> + Sub<Output = T> + Mul<f32, Output = T>,
        T1: Node,
        F: for<'r> FnMut(&'r mut T1) -> &'r mut T,
    {
        for point in path.windows(2) {
            linear(
                handle,
                &mut lens,
                point[0],
                point[1],
                time / path.len() as f32,
            )
            .await
        }
    }
}

```

`src/experimental/coroutines/generational_storage.rs`:

```rs
#[derive(Clone, Copy, Debug)]
pub struct GenerationalId {
    id: usize,
    generation: usize,
}

struct GenerationalCell<T> {
    generation: usize,
    state: T,
}

pub(crate) struct GenerationalStorage<T> {
    vec: Vec<Option<GenerationalCell<T>>>,
    free_indices: Vec<(usize, usize)>,
}

impl<T> GenerationalStorage<T> {
    pub fn new() -> GenerationalStorage<T> {
        GenerationalStorage {
            vec: Vec::with_capacity(1000),
            free_indices: Vec::with_capacity(100),
        }
    }

    pub fn push(&mut self, data: T) -> GenerationalId {
        let generation;

        let id = if let Some((free_id, old_generation)) = self.free_indices.pop() {
            assert!(self.vec[free_id].is_none());

            generation = old_generation + 1;
            self.vec[free_id] = Some(GenerationalCell {
                state: data,
                generation,
            });
            free_id
        } else {
            generation = 0;
            self.vec.push(Some(GenerationalCell {
                state: data,
                generation,
            }));
            self.vec.len() - 1
        };

        GenerationalId { id, generation }
    }

    pub fn get(&self, id: GenerationalId) -> Option<&T> {
        if id.id > self.vec.len() {
            return None;
        }

        let cell = self.vec[id.id].as_ref()?;
        if cell.generation != id.generation {
            return None;
        }

        Some(&cell.state)
    }

    pub fn get_mut(&mut self, id: GenerationalId) -> Option<&mut T> {
        if id.id > self.vec.len() {
            return None;
        }

        let cell = self.vec[id.id].as_mut()?;
        if cell.generation != id.generation {
            return None;
        }

        Some(&mut cell.state)
    }

    /// Retains only the elements specified by the predicate, passing a mutable reference to it.
    /// In other words, remove all elements e such that f(&mut e) returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.
    pub fn retain<F>(&mut self, mut f: F)
    where
        F: FnMut(&mut T) -> bool,
    {
        for (id, cell) in self.vec.iter_mut().enumerate() {
            if cell.is_none() {
                continue;
            }

            let c = cell.as_mut().unwrap();
            let pred = f(&mut c.state);
            let old_generation = c.generation;

            if !pred {
                self.free_indices.push((id, old_generation));
                *cell = None;
            }
        }
    }

    pub fn count(&self) -> usize {
        self.vec.iter().filter(|c| c.is_some()).count()
    }

    pub fn clear(&mut self) {
        self.vec.clear();
        self.free_indices.clear();
    }

    pub fn free(&mut self, id: GenerationalId) {
        // an attempt to free a cell by an outdated ID
        // this is a legit request, no need to panic or anything, just
        // dont ruin the data that lives there now
        if let Some(cell) = &self.vec[id.id] {
            if cell.generation != id.generation {
                return;
            }
        }

        self.free_indices.push((id.id, id.generation));
        self.vec[id.id] = None;
    }

    pub(crate) fn allocated_memory(&self) -> usize {
        self.vec.capacity() * size_of::<GenerationalCell<T>>()
    }
}

```

`src/experimental/scene.rs`:

```rs
use std::{any::Any, marker::PhantomData, ops::Drop};

use crate::camera::Camera2D;

pub use macroquad_macro::CapabilityTrait;

mod arena;

#[rustfmt::skip]
pub trait Node {
    fn ready(_node: RefMut<Self>) where Self: Sized {}
    fn update(_node: RefMut<Self>) where Self: Sized  {}
    fn fixed_update(_node: RefMut<Self>) where Self: Sized  {}
    fn draw(_node: RefMut<Self>) where Self: Sized  {}
}

trait NodeAny: Any + Node {
    fn as_any(&self) -> &dyn Any;
    fn as_any_mut(&mut self) -> &mut dyn Any;
}

impl<T: Node + 'static> NodeAny for T {
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
}

#[derive(Clone, Copy, Debug, PartialEq)]
struct Id {
    id: usize,
    generation: u64,
}

pub struct Handle<T: 'static> {
    id: Option<Id>,
    _marker: PhantomData<T>,
}

unsafe impl<T: 'static> Send for Handle<T> {}

#[derive(Clone, Copy, Debug)]
pub struct HandleUntyped(Id);

impl<T: 'static> std::fmt::Debug for Handle<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self.id)?;

        Ok(())
    }
}

impl<T: 'static> Clone for Handle<T> {
    fn clone(&self) -> Handle<T> {
        Handle {
            id: self.id,
            _marker: PhantomData,
        }
    }
}

impl<T: 'static> Copy for Handle<T> {}

impl<T> Handle<T> {
    pub const fn null() -> Handle<T> {
        Handle {
            id: None,
            _marker: PhantomData,
        }
    }

    pub fn untyped(&self) -> HandleUntyped {
        HandleUntyped(self.id.unwrap())
    }

    pub const fn as_trait<T1: ?Sized>(&self) {}
}

pub(crate) struct Lens<T> {
    handle: HandleUntyped,
    offset: isize,
    _marker: PhantomData<T>,
}

impl<T> Lens<T> {
    pub fn get(&mut self) -> Option<&mut T> {
        let node = get_untyped_node(self.handle)?;

        Some(unsafe { &mut *((node.data as *mut u8).offset(self.offset) as *mut T) })
    }
}

impl<T> Handle<T> {
    pub(crate) fn lens<F, T1>(&self, f: F) -> Lens<T1>
    where
        F: for<'r> FnOnce(&'r mut T) -> &'r mut T1,
    {
        assert!(self.id.is_some());

        let offset = unsafe {
            let mut base = std::mem::MaybeUninit::<T>::uninit();
            let field = f(std::mem::transmute(base.as_mut_ptr())) as *mut _ as *mut u8;

            (field as *mut u8).offset_from(base.as_mut_ptr() as *mut u8)
        };

        Lens {
            handle: HandleUntyped(self.id.unwrap()),
            offset,
            _marker: PhantomData,
        }
    }
}

pub struct NodeWith<T> {
    pub node: HandleUntyped,
    pub capability: T,
}

pub struct RefMut<T: 'static> {
    data: *mut T,
    handle: Handle<T>,
    capabilities: *mut Vec<Box<dyn Any>>,
    used: *mut bool,
}

impl<T: 'static> RefMut<T> {
    pub const fn handle(&self) -> Handle<T> {
        Handle {
            id: self.handle.id,
            _marker: PhantomData,
        }
    }

    pub fn persist(&self) {
        unsafe { get_scene() }.nodes[self.handle.id.unwrap().id]
            .as_mut()
            .unwrap()
            .permanent = true;
    }

    pub fn provides<S: std::any::Any + Copy>(&mut self, x: S) {
        unsafe { (*self.capabilities).push(Box::new(x)) };
    }

    pub fn delete(self) {
        assert!(self.handle.id.is_some());

        unsafe {
            *self.used = false;
        }
        unsafe { get_scene() }.delete(self.handle.id.unwrap());
        std::mem::forget(self);
    }
}

impl<T> std::ops::Deref for RefMut<T> {
    type Target = T;

    fn deref(&self) -> &T {
        unsafe { &*self.data }
    }
}

impl<T> std::ops::DerefMut for RefMut<T> {
    fn deref_mut(&mut self) -> &mut T {
        unsafe { &mut *self.data }
    }
}

impl<T: 'static> Drop for RefMut<T> {
    fn drop(&mut self) {
        assert_eq!(unsafe { *self.used }, true);
        unsafe {
            *self.used = false;
        }
    }
}

pub struct RefMutAny<'a> {
    data: *mut (),
    used: *mut bool,
    vtable: *mut (),
    capabilities: *mut Vec<Box<dyn Any>>,
    handle: HandleUntyped,

    _marker: PhantomData<&'a ()>,
}

impl<'a> RefMutAny<'a> {
    pub const fn handle<T>(&self) -> Handle<T> {
        Handle {
            id: Some(self.handle.0),
            _marker: PhantomData,
        }
    }

    pub fn delete(self) {
        unsafe {
            *self.used = false;
        }
        unsafe { get_scene() }.delete(self.handle.0);
        std::mem::forget(self);
    }

    pub fn to_typed<T>(self) -> RefMut<T> {
        let res = RefMut {
            data: self.data as *mut T,
            handle: Handle {
                id: Some(self.handle.0),
                _marker: PhantomData::<T>,
            },
            capabilities: self.capabilities,
            used: self.used,
        };

        // "used" is now moved to RefMut and will be invalidated by RefMut's drop
        // no need for RefMutAny's drop than
        std::mem::forget(self);

        res
    }
}

impl<'a> std::ops::Deref for RefMutAny<'a> {
    type Target = dyn Any;

    fn deref(&self) -> &Self::Target {
        let trait_obj: &dyn NodeAny = unsafe { std::mem::transmute((self.data, self.vtable)) };

        trait_obj.as_any()
    }
}

impl<'a> std::ops::DerefMut for RefMutAny<'a> {
    fn deref_mut(&mut self) -> &mut dyn Any {
        let trait_obj: &mut dyn NodeAny = unsafe { std::mem::transmute((self.data, self.vtable)) };

        trait_obj.as_any_mut()
    }
}

impl<'a> Drop for RefMutAny<'a> {
    fn drop(&mut self) {
        assert_eq!(unsafe { *self.used }, true);

        unsafe {
            *self.used = false;
        }
    }
}

struct Cell {
    id: Id,
    data: *mut (),
    vtable: *mut (),
    capabilities: Vec<Box<dyn Any>>,
    ready: *const fn(RefMut<()>),
    update: *const fn(RefMut<()>),
    fixed_update: *const fn(RefMut<()>),
    draw: *const fn(RefMut<()>),
    virtual_drop: *const fn(*mut ()),
    data_len: usize,
    permanent: bool,
    initialized: bool,
    used: *mut bool,
}

unsafe impl Sync for Scene {}

fn virtual_drop<T: Node + 'static>(data: *mut ()) {
    unsafe {
        std::ptr::drop_in_place(data as *mut T);
    }
}

impl Cell {
    fn new<T: Node + 'static>(id: Id, data: *mut (), vtable: *mut (), used: *mut bool) -> Self {
        Cell {
            id,
            data,
            vtable,
            capabilities: vec![],
            used,
            permanent: false,
            ready: (&(Node::ready as fn(RefMut<T>)) as *const fn(RefMut<T>)).cast(),
            update: (&(Node::update as fn(RefMut<T>)) as *const fn(RefMut<T>)).cast(),
            fixed_update: (&(Node::fixed_update as fn(RefMut<T>)) as *const fn(RefMut<T>)).cast(),
            draw: (&(Node::draw as fn(RefMut<T>)) as *const fn(RefMut<T>)).cast(),
            virtual_drop: &(virtual_drop::<T> as fn(*mut ())) as *const fn(*mut ()),
            data_len: size_of::<T>(),
            initialized: false,
        }
    }

    fn update<T: Node + 'static>(&mut self, data: T) {
        assert!(size_of::<T>() <= self.data_len);

        let trait_obj = &data as &dyn NodeAny;
        let (_, vtable) = unsafe { std::mem::transmute::<_, (*mut (), *mut ())>(trait_obj) };

        self.vtable = vtable;
        self.ready = (&(Node::ready as fn(RefMut<T>)) as *const fn(RefMut<T>)).cast();
        self.update = (&(Node::update as fn(RefMut<T>)) as *const fn(RefMut<T>)).cast();
        self.fixed_update = (&(Node::fixed_update as fn(RefMut<T>)) as *const fn(RefMut<T>)).cast();
        self.draw = (&(Node::draw as fn(RefMut<T>)) as *const fn(RefMut<T>)).cast();
        self.virtual_drop = &(virtual_drop::<T> as fn(*mut ())) as *const fn(*mut ());

        unsafe {
            std::ptr::copy_nonoverlapping::<T>(&data as *const _ as *mut _, self.data as *mut _, 1);
        }
        self.id.generation += 1;
        self.initialized = false;
        self.permanent = false;

        self.capabilities.clear();

        std::mem::forget(data);
    }
}

struct Scene {
    dense: Vec<Id>,
    dense_ongoing: Vec<Result<Id, Id>>,
    nodes: Vec<Option<Cell>>,
    arena: arena::Arena,
    camera: [Option<Camera2D>; 4],
    camera_pos: crate::Vec2,

    acc: f64,
    current_time: f64,
    in_fixed_update: bool,

    any_map: std::collections::HashMap<std::any::TypeId, Vec<(HandleUntyped, *mut u8)>>,
    free_nodes: Vec<Cell>,
}

impl Scene {
    pub fn new() -> Self {
        Scene {
            dense: vec![],
            dense_ongoing: vec![],
            nodes: Vec::new(),
            arena: arena::Arena::new(),
            free_nodes: Vec::new(),
            camera: [Some(Camera2D::default()), None, None, None],
            camera_pos: crate::vec2(0., 0.),
            acc: 0.0,
            current_time: crate::time::get_time(),
            in_fixed_update: false,
            any_map: std::collections::HashMap::new(),
        }
    }

    pub fn clear(&mut self) {
        self.any_map.clear();

        for cell in &mut self.nodes {
            if let Some(Cell {
                permanent: false, ..
            }) = cell
            {
                if let Some(cell) = cell.take() {
                    assert!(unsafe { *cell.used == false });

                    unsafe {
                        (*cell.virtual_drop)(cell.data);
                    }
                    let ix = self.dense.iter().position(|i| *i == cell.id).unwrap();
                    self.dense.remove(ix);

                    self.free_nodes.push(cell);
                }
            }
        }
    }

    pub fn get_any(&mut self, handle: HandleUntyped) -> Option<RefMutAny> {
        let handle = handle.0;
        let cell = self.nodes.get_mut(handle.id)?;

        if cell.is_none() {
            return None;
        }
        let cell = cell.as_mut().unwrap();

        if cell.id.generation != handle.generation {
            return None;
        }

        if unsafe { *cell.used } {
            return None;
        }

        unsafe { *cell.used = true };

        Some(RefMutAny {
            data: cell.data,
            vtable: cell.vtable,
            capabilities: &mut cell.capabilities as _,
            handle: HandleUntyped(cell.id),
            used: cell.used,

            _marker: PhantomData,
        })
    }

    pub fn get<T>(&mut self, handle: Handle<T>) -> Option<RefMut<T>> {
        let ref_mut_any = self.get_any(HandleUntyped(handle.id?))?;
        Some(ref_mut_any.to_typed())
    }

    fn iter(&self) -> MagicVecIterator {
        MagicVecIterator {
            n: 0,
            len: self.dense.len(),
        }
    }

    fn add_node<T: Node + 'static>(&mut self, data: T) -> Handle<T> {
        let id;

        if let Some(i) = self
            .free_nodes
            .iter()
            .position(|free_node| free_node.data_len >= size_of::<T>())
        {
            let mut free_node = self.free_nodes.remove(i);

            free_node.update::<T>(data);

            id = free_node.id;

            self.nodes[id.id] = Some(free_node);
        } else {
            let trait_obj = &data as &dyn NodeAny;
            let (_, vtable) = unsafe { std::mem::transmute::<_, (*mut (), *mut ())>(trait_obj) };

            let ptr = self.arena.alloc(size_of::<T>()) as *mut _ as *mut T;
            unsafe {
                std::ptr::write(ptr, data);
            }
            let ptr = ptr as *mut ();
            let used = self.arena.alloc(1) as *mut _ as *mut bool;
            unsafe {
                std::ptr::write(used, false);
            }
            let used = used as *mut _ as *mut bool;

            id = Id {
                id: self.nodes.len(),
                generation: 0,
            };
            self.nodes.push(Some(Cell::new::<T>(id, ptr, vtable, used)));
        }

        self.dense.push(id);

        Handle {
            id: Some(id),
            _marker: PhantomData,
        }
    }

    pub fn delete(&mut self, id: Id) {
        if let Some(node) = self.nodes[id.id].take() {
            assert_eq!(node.id.generation, id.generation);

            self.dense_ongoing.push(Err(id));

            unsafe {
                (*node.virtual_drop)(node.data);
            }
            self.free_nodes.push(node);
        }
    }

    pub fn update(&mut self) {
        for node in &mut self.iter() {
            let cell = self.nodes[node.handle.0.id].as_mut().unwrap();
            if cell.initialized == false {
                cell.initialized = true;

                let node: RefMut<()> = node.to_typed::<()>();
                unsafe { (*cell.ready)(node) };
            }
        }

        let new_time = crate::time::get_time();

        let mut frame_time = new_time - self.current_time;

        // https://medium.com/@tglaiel/how-to-make-your-game-run-at-60fps-24c61210fe75x
        if (frame_time - 1.0 / 120.0).abs() < 0.0002 {
            frame_time = 1.0 / 120.0;
        } else if (frame_time - 1.0 / 60.0).abs() < 0.0002 {
            frame_time = 1.0 / 60.0;
        } else if (frame_time - 1.0 / 30.0).abs() < 0.0002 {
            frame_time = 1.0 / 30.0;
        }

        self.current_time = new_time;
        self.acc += frame_time;

        for node in &mut self.iter() {
            let cell = self.nodes[node.handle.0.id].as_mut().unwrap();
            let node: RefMut<()> = node.to_typed::<()>();
            unsafe { (*cell.update)(node) };
        }

        while self.acc > CONST_FPS {
            self.acc -= CONST_FPS;
            for node in &mut self.iter() {
                let cell = self.nodes[node.handle.0.id].as_mut().unwrap();
                let node: RefMut<()> = node.to_typed::<()>();

                self.in_fixed_update = true;
                unsafe { (*cell.fixed_update)(node) };
                self.in_fixed_update = false;
            }
        }

        for camera in self.camera.iter() {
            if let Some(camera) = camera {
                self.camera_pos = camera.target;
                crate::prelude::push_camera_state();
                crate::prelude::set_camera(&*camera);

                for node in &mut self.iter() {
                    let cell = self.nodes[node.handle.0.id].as_mut().unwrap();
                    let node: RefMut<()> = node.to_typed::<()>();
                    unsafe { (*cell.draw)(node) };
                }

                crate::prelude::pop_camera_state();
            }
        }

        for id in self.dense_ongoing.drain(0..) {
            match id {
                Ok(id) => {
                    self.dense.push(id);
                }
                Err(id) => {
                    let ix = self.dense.iter().position(|i| *i == id).unwrap();
                    self.dense.remove(ix);
                }
            }
        }
    }
}

pub struct MagicVecIterator {
    n: usize,
    len: usize,
}

impl Iterator for MagicVecIterator {
    type Item = RefMutAny<'static>;

    fn next(&mut self) -> Option<RefMutAny<'static>> {
        let scene = unsafe { get_scene() };
        let nodes = &mut scene.nodes;
        let dense = &scene.dense;
        if self.n >= self.len {
            return None;
        }
        let ix = dense[self.n];
        let cell = &mut nodes[ix.id];
        self.n += 1;

        if cell.is_none() {
            return self.next();
        }
        let cell = cell.as_mut().unwrap();

        if unsafe { *cell.used } {
            return self.next();
        }

        unsafe { *cell.used = true };

        Some(RefMutAny {
            data: cell.data,
            vtable: cell.vtable,
            capabilities: &mut cell.capabilities as _,
            handle: HandleUntyped(cell.id),
            used: cell.used,
            _marker: PhantomData,
        })
    }
}

static mut SCENE: Option<Scene> = None;

unsafe fn get_scene() -> &'static mut Scene {
    SCENE.get_or_insert_with(|| Scene::new())
}

pub(crate) fn allocated_memory() -> usize {
    unsafe { get_scene().arena.offset() }
}

pub fn clear() {
    crate::experimental::coroutines::stop_all_coroutines();

    unsafe { get_scene() }.clear()
}

/// Get node and panic if the node is borrowed or deleted
pub fn get_node<T: Node>(handle: Handle<T>) -> RefMut<T> {
    unsafe { get_scene() }
        .get(handle)
        .expect(&format!("No such node: {:?}", handle.id))
}

pub fn try_get_node<T: Node>(handle: Handle<T>) -> Option<RefMut<T>> {
    unsafe { get_scene() }.get(handle)
}

pub fn get_untyped_node(handle: HandleUntyped) -> Option<RefMutAny<'static>> {
    unsafe { get_scene() }.get_any(handle)
}

pub fn camera_pos() -> crate::Vec2 {
    unsafe { get_scene() }.camera_pos
}

pub fn set_camera(n: usize, camera: Option<Camera2D>) {
    assert!(n <= 4);
    unsafe { get_scene() }.camera[n] = camera;
}

pub fn add_node<T: Node>(node: T) -> Handle<T> {
    unsafe { get_scene() }.add_node(node)
}

pub(crate) fn update() {
    unsafe { get_scene() }.update()
}

pub fn all_nodes() -> MagicVecIterator {
    unsafe { get_scene() }.iter()
}

pub fn find_node_by_type<T: Any>() -> Option<RefMut<T>> {
    unsafe { get_scene() }
        .iter()
        .find(|node| node.is::<T>())
        .map(|node| node.to_typed())
}

pub fn find_nodes_with<T: Any + Copy>() -> impl Iterator<Item = NodeWith<T>> {
    unsafe {
        get_scene().iter().filter_map(|node| {
            (*node.capabilities)
                .iter()
                .find(|capability| capability.is::<T>())
                .map(|capability| NodeWith {
                    node: node.handle,
                    capability: *capability.downcast_ref::<T>().unwrap(),
                })
        })
    }
}

pub fn find_nodes_by_type<T: Any>() -> impl Iterator<Item = RefMut<T>> {
    unsafe { get_scene() }
        .iter()
        .filter(|node| node.is::<T>())
        .map(|node| node.to_typed())
}

const CONST_FPS: f64 = 1.0 / 60.;

pub(crate) fn in_fixed_update() -> bool {
    unsafe { get_scene() }.in_fixed_update
}

pub(crate) const fn fixed_frame_time() -> f32 {
    CONST_FPS as _
}

```

`src/experimental/scene/arena.rs`:

```rs
//! Gleaned from https://github.com/ratel-rust/toolshed/blob/master/src/arena.rs
//! and than modified a lot.
//!
//! Module containing the `Arena` and `Uninitialized` structs. For convenience the
//! `Arena` is exported at the root of the crate.

use std::cell::Cell;

const ARENA_BLOCK: usize = 64 * 1024;

/// An arena implementation that uses preallocated 64KiB pages for all allocations.
/// If a new allocation were to be pushed over the the boundaries of the page, a
/// new page is internally allocated first, thus this version of the arena can never
/// run out of memory unless the process runs out of heap altogether.
///
/// Allocating a type larger than the page size will result in a new heap allocation
/// just for that type separate from the page mechanism.
pub struct Arena {
    store: Cell<Vec<Vec<u8>>>,
    ptr: Cell<*mut u8>,
    offset: Cell<usize>,
}

impl Arena {
    /// Create a new arena with a single preallocated 64KiB page.
    pub fn new() -> Self {
        let mut store = vec![Vec::with_capacity(ARENA_BLOCK)];
        let ptr = store[0].as_mut_ptr();

        Arena {
            store: Cell::new(store),
            ptr: Cell::new(ptr),
            offset: Cell::new(0),
        }
    }

    pub fn alloc(&self, size: usize) -> *mut u8 {
        // This should be optimized away for size known at compile time.
        if size > ARENA_BLOCK {
            return self.alloc_bytes(size);
        }

        let size = match size % size_of::<usize>() {
            0 => size,
            n => size + (size_of::<usize>() - n),
        };

        let offset = self.offset.get();
        let cap = offset + size;

        if cap > ARENA_BLOCK {
            self.grow();

            self.offset.set(size);
            self.ptr.get()
        } else {
            self.offset.set(cap);
            unsafe { self.ptr.get().add(offset) }
        }
    }

    #[inline]
    fn alloc_byte_vec(&self, mut val: Vec<u8>) -> *mut u8 {
        let ptr = val.as_mut_ptr();

        let mut temp = self.store.replace(Vec::new());
        temp.push(val);
        self.store.replace(temp);

        ptr
    }

    pub fn grow(&self) {
        let ptr = self.alloc_byte_vec(Vec::with_capacity(ARENA_BLOCK));
        self.ptr.set(ptr);
    }

    fn alloc_bytes(&self, size: usize) -> *mut u8 {
        self.alloc_byte_vec(Vec::with_capacity(size))
    }

    #[doc(hidden)]
    #[inline]
    pub unsafe fn offset(&self) -> usize {
        self.offset.get()
    }
}

/// Akin to `CopyCell`: `Sync` is unsafe but `Send` is totally fine!
unsafe impl Send for Arena {}

```

`src/experimental/state_machine.rs`:

```rs
use crate::experimental::coroutines::Coroutine;

use crate::experimental::scene;

type UpdateFn<T> = Box<dyn FnMut(&mut scene::RefMut<T>, f32)>;
type CoroutineFn<T> = Box<dyn FnMut(&mut scene::RefMut<T>) -> Coroutine>;
type OnEndFn<T> = Box<dyn FnMut(&mut scene::RefMut<T>)>;

pub struct State<T: 'static> {
    update: Option<UpdateFn<T>>,
    coroutine: Option<CoroutineFn<T>>,
    on_end: Option<OnEndFn<T>>,
}

impl<T> State<T> {
    pub fn new() -> Self {
        State {
            update: None,
            coroutine: None,
            on_end: None,
        }
    }

    pub fn update(self, update: impl FnMut(&mut scene::RefMut<T>, f32) + 'static) -> Self {
        State {
            update: Some(Box::new(update)),
            ..self
        }
    }

    pub fn coroutine(
        self,
        coroutine: impl FnMut(&mut scene::RefMut<T>) -> Coroutine + 'static,
    ) -> Self {
        State {
            coroutine: Some(Box::new(coroutine)),
            ..self
        }
    }

    pub fn on_end(self, on_end: impl FnMut(&mut scene::RefMut<T>) + 'static) -> Self {
        State {
            on_end: Some(Box::new(on_end)),
            ..self
        }
    }
}

pub enum StateMachine<T: 'static> {
    Ready(StateMachineOwned<T>),
    InUse {
        next_state: Option<usize>,
        current_state: usize,
    },
}

impl<T: scene::Node + 'static> StateMachine<T> {
    pub fn new() -> StateMachine<T> {
        StateMachine::Ready(StateMachineOwned::new())
    }

    pub fn add_state(&mut self, id: usize, state: State<T>) {
        match self {
            StateMachine::Ready(state_machine) => state_machine.insert(id, state),
            _ => panic!(),
        }
    }

    pub fn take(&mut self) -> StateMachineOwned<T> {
        let current_state = self.state();
        match std::mem::replace(
            self,
            StateMachine::InUse {
                next_state: None,
                current_state,
            },
        ) {
            StateMachine::InUse { .. } => panic!(),
            StateMachine::Ready(state_machine) => state_machine,
        }
    }

    fn put_back(&mut self, mut state_machine: StateMachineOwned<T>) {
        match self {
            StateMachine::Ready(_) => panic!(),
            StateMachine::InUse { next_state, .. } => {
                if let Some(next_state) = next_state {
                    state_machine.set_state(*next_state);
                }
            }
        }
        *self = StateMachine::Ready(state_machine);
    }

    pub fn set_state(&mut self, state: usize) {
        match self {
            StateMachine::Ready(state_machine) => {
                state_machine.set_state(state);
            }
            StateMachine::InUse {
                ref mut next_state, ..
            } => {
                *next_state = Some(state);
            }
        }
    }

    pub const fn state(&self) -> usize {
        match self {
            StateMachine::Ready(state_machine) => state_machine.state(),
            StateMachine::InUse {
                ref current_state, ..
            } => *current_state,
        }
    }

    /// A hack to update a state machine being part of an updating struct
    pub fn update_detached<'a, F>(mut t: scene::RefMut<T>, mut f: F)
    where
        F: FnMut(&mut scene::RefMut<T>) -> &mut StateMachine<T>,
    {
        let mut state_machine = f(&mut t).take();
        state_machine.update(&mut t, crate::time::get_frame_time());

        // coroutine may want to access this node by its handle
        // but while we have borrowed t to RefMut - it will fail this attempt
        // so here we drop t, poll the coroutine and than getting t back by its handle
        let handle = t.handle();
        drop(t);
        if let Some(ref mut coroutine) = state_machine.active_coroutine {
            coroutine.poll(crate::time::get_frame_time() as _);
        }
        let mut t = crate::experimental::scene::get_node(handle);

        f(&mut t).put_back(state_machine);
    }

    pub fn update<'a>(&mut self, t: &'a mut scene::RefMut<T>) {
        match self {
            StateMachine::Ready(state_machine) => {
                state_machine.update(t, crate::time::get_frame_time())
            }
            _ => panic!(),
        }
    }
}

pub struct StateMachineOwned<T: 'static> {
    states: Vec<State<T>>,
    active_coroutine: Option<Coroutine>,
    next_state: Option<usize>,
    current_state: usize,
}

impl<T: 'static> StateMachineOwned<T> {
    const MAX_STATE: usize = 32;

    pub fn new() -> Self {
        let mut states = vec![];
        for _ in 0..Self::MAX_STATE {
            states.push(State::new());
        }
        StateMachineOwned {
            states,
            active_coroutine: None,
            next_state: None,
            current_state: 0,
        }
    }

    pub fn insert(&mut self, id: usize, state: State<T>) {
        assert!(id < Self::MAX_STATE);

        self.states[id] = state;
    }

    pub fn set_state(&mut self, state: usize) {
        self.next_state = Some(state);
    }

    pub const fn state(&self) -> usize {
        self.current_state
    }

    fn update(&mut self, player: &mut scene::RefMut<T>, dt: f32) {
        if let Some(next_state) = self.next_state {
            if next_state != self.current_state {
                if let Some(on_end) = &mut self.states[self.current_state].on_end {
                    on_end(player);
                }
                if let Some(coroutine) = &mut self.states[next_state].coroutine {
                    let mut coroutine = coroutine(player);
                    coroutine.set_manual_poll();
                    self.active_coroutine = Some(coroutine);
                }
            }
            self.current_state = next_state;
            self.next_state = None;
        }

        if let Some(update) = self.states[self.current_state].update.as_mut() {
            (update)(player, dt);
        }
    }
}

```

`src/file.rs`:

```rs
//! Cross platform file management functions.

use crate::{exec, Error};

/// Load file from the path and block until its loaded
/// Will use filesystem on PC and do http request on web
pub async fn load_file(path: &str) -> Result<Vec<u8>, Error> {
    fn load_file_inner(path: &str) -> exec::FileLoadingFuture {
        use std::sync::{Arc, Mutex};

        let contents = Arc::new(Mutex::new(None));
        let path = path.to_owned();

        {
            let contents = contents.clone();
            let err_path = path.clone();

            miniquad::fs::load_file(&path, move |bytes| {
                *contents.lock().unwrap() = Some(bytes.map_err(|kind| Error::FileError {
                    kind,
                    path: err_path.clone(),
                }));
            });
        }

        exec::FileLoadingFuture { contents }
    }

    #[cfg(target_os = "ios")]
    let _ = std::env::set_current_dir(std::env::current_exe().unwrap().parent().unwrap());

    #[cfg(not(target_os = "android"))]
    let path = if let Some(ref pc_assets) = crate::get_context().pc_assets_folder {
        format!("{pc_assets}/{path}")
    } else {
        path.to_string()
    };

    load_file_inner(&path).await
}

/// Load string from the path and block until its loaded.
/// Right now this will use load_file and `from_utf8_lossy` internally, but
/// implementation details may change in the future
pub async fn load_string(path: &str) -> Result<String, Error> {
    let data = load_file(path).await?;

    Ok(String::from_utf8_lossy(&data).to_string())
}

/// There are super common project layout like this:
/// ```skip
///    .
///    ├── assets
///    ├── └── nice_texture.png
///    ├── src
///    ├── └── main.rs
///    └── Cargo.toml
/// ```
/// when such a project being run on desktop assets should be referenced as
/// "assets/nice_texture.png".
/// While on web or android it usually is just "nice_texture.png".
/// The reason: on PC assets are being referenced relative to current active directory/executable path. In most IDEs its the root of the project.
/// While on, say, android it is:
/// ```skip
/// [package.metadata.android]
/// assets = "assets"
/// ```
/// And therefore on android assets are referenced from the root of "assets" folder.
///
/// In the future there going to be some sort of meta-data file for PC as well.
/// But right now to resolve this situation and keep pathes consistent across platforms
/// `set_pc_assets_folder("assets");`call before first `load_file`/`load_texture` will allow using same pathes on PC and Android.
pub fn set_pc_assets_folder(path: &str) {
    crate::get_context().pc_assets_folder = Some(path.to_string());
}

```

`src/input.rs`:

```rs
//! Cross-platform mouse, keyboard (and gamepads soon) module.

use std::collections::HashSet;

use crate::prelude::screen_height;
use crate::prelude::screen_width;
use crate::Vec2;
use crate::{get_context, DroppedFile};
pub use miniquad::{KeyCode, MouseButton};

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum TouchPhase {
    Started,
    Stationary,
    Moved,
    Ended,
    Cancelled,
}

impl From<miniquad::TouchPhase> for TouchPhase {
    fn from(miniquad_phase: miniquad::TouchPhase) -> TouchPhase {
        match miniquad_phase {
            miniquad::TouchPhase::Started => TouchPhase::Started,
            miniquad::TouchPhase::Moved => TouchPhase::Moved,
            miniquad::TouchPhase::Ended => TouchPhase::Ended,
            miniquad::TouchPhase::Cancelled => TouchPhase::Cancelled,
        }
    }
}

#[derive(Clone, Debug)]
pub struct Touch {
    pub id: u64,
    pub phase: TouchPhase,
    pub position: Vec2,
}

/// Constrain mouse to window
pub fn set_cursor_grab(grab: bool) {
    let context = get_context();
    context.cursor_grabbed = grab;
    miniquad::window::set_cursor_grab(grab);
}

/// Set mouse cursor visibility
pub fn show_mouse(shown: bool) {
    miniquad::window::show_mouse(shown);
}

/// Return mouse position in pixels.
pub fn mouse_position() -> (f32, f32) {
    let context = get_context();

    (
        context.mouse_position.x / miniquad::window::dpi_scale(),
        context.mouse_position.y / miniquad::window::dpi_scale(),
    )
}

/// Return mouse position in range [-1; 1].
pub fn mouse_position_local() -> Vec2 {
    let (pixels_x, pixels_y) = mouse_position();

    convert_to_local(Vec2::new(pixels_x, pixels_y))
}

/// Returns the difference between the current mouse position and the mouse position on the previous frame.
pub fn mouse_delta_position() -> Vec2 {
    let context = get_context();

    let current_position = mouse_position_local();
    let last_position = context.last_mouse_position.unwrap_or(current_position);

    // Calculate the delta
    last_position - current_position
}

/// This is set to true by default, meaning touches will raise mouse events in addition to raising touch events.
/// If set to false, touches won't affect mouse events.
pub fn is_simulating_mouse_with_touch() -> bool {
    get_context().simulate_mouse_with_touch
}

/// This is set to true by default, meaning touches will raise mouse events in addition to raising touch events.
/// If set to false, touches won't affect mouse events.
pub fn simulate_mouse_with_touch(option: bool) {
    get_context().simulate_mouse_with_touch = option;
}

/// Return touches with positions in pixels.
pub fn touches() -> Vec<Touch> {
    get_context().touches.values().cloned().collect()
}

/// Return touches with positions in range [-1; 1].
pub fn touches_local() -> Vec<Touch> {
    get_context()
        .touches
        .values()
        .map(|touch| {
            let mut touch = touch.clone();
            touch.position = convert_to_local(touch.position);
            touch
        })
        .collect()
}

pub fn mouse_wheel() -> (f32, f32) {
    let context = get_context();

    (context.mouse_wheel.x, context.mouse_wheel.y)
}

/// Detect if the key has been pressed once
pub fn is_key_pressed(key_code: KeyCode) -> bool {
    let context = get_context();

    context.keys_pressed.contains(&key_code)
}

/// Detect if the key is being pressed
pub fn is_key_down(key_code: KeyCode) -> bool {
    let context = get_context();

    context.keys_down.contains(&key_code)
}

/// Detect if the key has been released this frame
pub fn is_key_released(key_code: KeyCode) -> bool {
    let context = get_context();

    context.keys_released.contains(&key_code)
}

/// Detect if any key is being preseed
pub fn is_any_key_down() -> bool {
    let context = get_context();
    context.keys_down.len() > 0
}

/// Return the last pressed char.
/// Each "get_char_pressed" call will consume a character from the input queue.
pub fn get_char_pressed() -> Option<char> {
    let context = get_context();

    context.chars_pressed_queue.pop()
}

pub(crate) fn get_char_pressed_ui() -> Option<char> {
    let context = get_context();

    context.chars_pressed_ui_queue.pop()
}

/// Return the last pressed key.
pub fn get_last_key_pressed() -> Option<KeyCode> {
    let context = get_context();
    // TODO: this will return a random key from keys_pressed HashMap instead of the last one, fix me later
    context.keys_pressed.iter().next().cloned()
}

pub fn get_keys_pressed() -> HashSet<KeyCode> {
    let context = get_context();
    context.keys_pressed.clone()
}

pub fn get_keys_down() -> HashSet<KeyCode> {
    let context = get_context();
    context.keys_down.clone()
}

pub fn get_keys_released() -> HashSet<KeyCode> {
    let context = get_context();
    context.keys_released.clone()
}

/// Clears input queue
pub fn clear_input_queue() {
    let context = get_context();
    context.chars_pressed_queue.clear();
    context.chars_pressed_ui_queue.clear();
}

/// Detect if the button is being pressed
pub fn is_mouse_button_down(btn: MouseButton) -> bool {
    let context = get_context();

    context.mouse_down.contains(&btn)
}

/// Detect if the button has been pressed once
pub fn is_mouse_button_pressed(btn: MouseButton) -> bool {
    let context = get_context();

    context.mouse_pressed.contains(&btn)
}

/// Detect if the button has been released this frame
pub fn is_mouse_button_released(btn: MouseButton) -> bool {
    let context = get_context();

    context.mouse_released.contains(&btn)
}

/// Convert a position in pixels to a position in the range [-1; 1].
fn convert_to_local(pixel_pos: Vec2) -> Vec2 {
    Vec2::new(pixel_pos.x / screen_width(), pixel_pos.y / screen_height()) * 2.0
        - Vec2::new(1.0, 1.0)
}

/// Prevents quit
pub fn prevent_quit() {
    get_context().prevent_quit_event = true;
}

/// Detect if quit has been requested
pub fn is_quit_requested() -> bool {
    get_context().quit_requested
}

/// Gets the files which have been dropped on the window.
pub fn get_dropped_files() -> Vec<DroppedFile> {
    get_context().dropped_files()
}

/// Functions for advanced input processing.
///
/// Functions in this module should be used by external tools that uses miniquad system, like different UI libraries. User shouldn't use this function.
pub mod utils {
    use crate::get_context;

    /// Register input subscriber. Returns subscriber identifier that must be used in `repeat_all_miniquad_input`.
    pub fn register_input_subscriber() -> usize {
        let context = get_context();

        context.input_events.push(vec![]);

        context.input_events.len() - 1
    }

    /// Repeats all events that came since last call of this function with current value of `subscriber`. This function must be called at each frame.
    pub fn repeat_all_miniquad_input<T: miniquad::EventHandler>(t: &mut T, subscriber: usize) {
        let context = get_context();

        for event in &context.input_events[subscriber] {
            event.repeat(t);
        }
        context.input_events[subscriber].clear();
    }
}

```

`src/lib.rs`:

```rs
//!
//! `macroquad` is a simple and easy to use game library for Rust programming language.
//!
//! `macroquad` attempts to avoid any rust-specific programming concepts like lifetimes/borrowing, making it very friendly for rust beginners.
//!
//! ## Supported platforms
//!
//! * PC: Windows/Linux/MacOS
//! * HTML5
//! * Android
//! * IOS
//!
//! ## Features
//!
//! * Same code for all supported platforms, no platform dependent defines required
//! * Efficient 2D rendering with automatic geometry batching
//! * Minimal amount of dependencies: build after `cargo clean` takes only 16s on x230(~6years old laptop)
//! * Immediate mode UI library included
//! * Single command deploy for both WASM and Android [build instructions](https://github.com/not-fl3/miniquad/#building-examples)
//! # Example
//! ```no_run
//! use macroquad::prelude::*;
//!
//! #[macroquad::main("BasicShapes")]
//! async fn main() {
//!     loop {
//!         clear_background(RED);
//!
//!         draw_line(40.0, 40.0, 100.0, 200.0, 15.0, BLUE);
//!         draw_rectangle(screen_width() / 2.0 - 60.0, 100.0, 120.0, 60.0, GREEN);
//!         draw_circle(screen_width() - 30.0, screen_height() - 30.0, 15.0, YELLOW);
//!         draw_text("HELLO", 20.0, 20.0, 20.0, DARKGRAY);
//!
//!         next_frame().await
//!     }
//! }
//!```

use miniquad::*;

use std::collections::{HashMap, HashSet};
use std::future::Future;
use std::panic::AssertUnwindSafe;
use std::pin::Pin;

mod exec;
mod quad_gl;
mod tobytes;

pub mod audio;
pub mod camera;
pub mod color;
pub mod file;
pub mod input;
pub mod material;
pub mod math;
pub mod models;
pub mod shapes;
pub mod text;
pub mod texture;
pub mod time;
pub mod ui;
pub mod window;

pub mod experimental;

pub mod prelude;

pub mod telemetry;

mod error;

pub use error::Error;

/// Macroquad entry point.
///
/// ```skip
/// #[main("Window name")]
/// async fn main() {
/// }
/// ```
///
/// ```skip
/// fn window_conf() -> Conf {
///     Conf {
///         window_title: "Window name".to_owned(),
///         fullscreen: true,
///         ..Default::default()
///     }
/// }
/// #[macroquad::main(window_conf)]
/// async fn main() {
/// }
/// ```
///
/// ## Error handling
///
/// `async fn main()` can have the same signature as a normal `main` in Rust.
/// The most typical use cases are:
/// * `async fn main() {}`
/// * `async fn main() -> Result<(), Error> {}` (note that `Error` should implement `Debug`)
///
/// When a lot of third party crates are involved and very different errors may happens, `anyhow` crate may help:
/// * `async fn main() -> anyhow::Result<()> {}`
///
/// For better control over game errors custom error type may be introduced:
/// ```skip
/// #[derive(Debug)]
/// enum GameError {
///     FileError(macroquad::FileError),
///     SomeThirdPartyCrateError(somecrate::Error)
/// }
/// impl From<macroquad::file::FileError> for GameError {
///     fn from(error: macroquad::file::FileError) -> GameError {
///         GameError::FileError(error)
///     }
/// }
/// impl From<somecrate::Error> for GameError {
///     fn from(error: somecrate::Error) -> GameError {
///         GameError::SomeThirdPartyCrateError(error)
///     }
/// }
/// ```
pub use macroquad_macro::main;

/// #[macroquad::test] fn test() {}
///
/// Very similar to macroquad::main
/// Right now it will still spawn a window, just like ::main, therefore
/// is not really useful for anything than developping macroquad itself
#[doc(hidden)]
pub use macroquad_macro::test;

/// Cross platform random generator.
pub mod rand {
    pub use quad_rand::*;
}

#[cfg(not(feature = "log-rs"))]
/// Logging macros, available with miniquad "log-impl" feature.
pub mod logging {
    pub use miniquad::{debug, error, info, trace, warn};
}
#[cfg(feature = "log-rs")]
// Use logging facade
pub use ::log as logging;
pub use miniquad;

use crate::{
    color::{colors::*, Color},
    quad_gl::QuadGl,
    texture::TextureHandle,
    ui::ui_context::UiContext,
};

use glam::{vec2, Mat4, Vec2};

pub(crate) mod thread_assert {
    static mut THREAD_ID: Option<std::thread::ThreadId> = None;

    pub fn set_thread_id() {
        unsafe {
            THREAD_ID = Some(std::thread::current().id());
        }
    }

    pub fn same_thread() {
        unsafe {
            thread_local! {
                static CURRENT_THREAD_ID: std::thread::ThreadId = std::thread::current().id();
            }
            assert!(THREAD_ID.is_some());
            assert!(THREAD_ID.unwrap() == CURRENT_THREAD_ID.with(|id| *id));
        }
    }
}
struct Context {
    audio_context: audio::AudioContext,

    screen_width: f32,
    screen_height: f32,

    simulate_mouse_with_touch: bool,

    keys_down: HashSet<KeyCode>,
    keys_pressed: HashSet<KeyCode>,
    keys_released: HashSet<KeyCode>,
    mouse_down: HashSet<MouseButton>,
    mouse_pressed: HashSet<MouseButton>,
    mouse_released: HashSet<MouseButton>,
    touches: HashMap<u64, input::Touch>,
    chars_pressed_queue: Vec<char>,
    chars_pressed_ui_queue: Vec<char>,
    mouse_position: Vec2,
    last_mouse_position: Option<Vec2>,
    mouse_wheel: Vec2,

    prevent_quit_event: bool,
    quit_requested: bool,

    cursor_grabbed: bool,

    input_events: Vec<Vec<MiniquadInputEvent>>,

    gl: QuadGl,
    camera_matrix: Option<Mat4>,

    ui_context: UiContext,
    coroutines_context: experimental::coroutines::CoroutinesContext,
    fonts_storage: text::FontsStorage,

    pc_assets_folder: Option<String>,

    start_time: f64,
    last_frame_time: f64,
    frame_time: f64,

    #[cfg(one_screenshot)]
    counter: usize,

    camera_stack: Vec<camera::CameraState>,
    texture_batcher: texture::Batcher,
    unwind: bool,
    recovery_future: Option<Pin<Box<dyn Future<Output = ()>>>>,

    quad_context: Box<dyn miniquad::RenderingBackend>,

    default_filter_mode: crate::quad_gl::FilterMode,
    textures: crate::texture::TexturesContext,

    update_on: conf::UpdateTrigger,

    dropped_files: Vec<DroppedFile>,
}

#[derive(Clone)]
enum MiniquadInputEvent {
    MouseMotion {
        x: f32,
        y: f32,
    },
    MouseWheel {
        x: f32,
        y: f32,
    },
    MouseButtonDown {
        x: f32,
        y: f32,
        btn: MouseButton,
    },
    MouseButtonUp {
        x: f32,
        y: f32,
        btn: MouseButton,
    },
    Char {
        character: char,
        modifiers: KeyMods,
        repeat: bool,
    },
    KeyDown {
        keycode: KeyCode,
        modifiers: KeyMods,
        repeat: bool,
    },
    KeyUp {
        keycode: KeyCode,
        modifiers: KeyMods,
    },
    Touch {
        phase: TouchPhase,
        id: u64,
        x: f32,
        y: f32,
    },
    WindowMinimized,
    WindowRestored,
}

impl MiniquadInputEvent {
    fn repeat<T: miniquad::EventHandler>(&self, t: &mut T) {
        use crate::MiniquadInputEvent::*;
        match self {
            MouseMotion { x, y } => t.mouse_motion_event(*x, *y),
            MouseWheel { x, y } => t.mouse_wheel_event(*x, *y),
            MouseButtonDown { x, y, btn } => t.mouse_button_down_event(*btn, *x, *y),
            MouseButtonUp { x, y, btn } => t.mouse_button_up_event(*btn, *x, *y),
            Char {
                character,
                modifiers,
                repeat,
            } => t.char_event(*character, *modifiers, *repeat),
            KeyDown {
                keycode,
                modifiers,
                repeat,
            } => t.key_down_event(*keycode, *modifiers, *repeat),
            KeyUp { keycode, modifiers } => t.key_up_event(*keycode, *modifiers),
            Touch { phase, id, x, y } => t.touch_event(*phase, *id, *x, *y),
            WindowMinimized => t.window_minimized_event(),
            WindowRestored => t.window_restored_event(),
        }
    }
}

impl Context {
    const DEFAULT_BG_COLOR: Color = BLACK;

    fn new(
        update_on: conf::UpdateTrigger,
        default_filter_mode: crate::FilterMode,
        draw_call_vertex_capacity: usize,
        draw_call_index_capacity: usize,
    ) -> Context {
        let mut ctx: Box<dyn miniquad::RenderingBackend> =
            miniquad::window::new_rendering_backend();
        let (screen_width, screen_height) = miniquad::window::screen_size();

        Context {
            screen_width,
            screen_height,

            simulate_mouse_with_touch: true,

            keys_down: HashSet::new(),
            keys_pressed: HashSet::new(),
            keys_released: HashSet::new(),
            chars_pressed_queue: Vec::new(),
            chars_pressed_ui_queue: Vec::new(),
            mouse_down: HashSet::new(),
            mouse_pressed: HashSet::new(),
            mouse_released: HashSet::new(),
            touches: HashMap::new(),
            mouse_position: vec2(0., 0.),
            last_mouse_position: None,
            mouse_wheel: vec2(0., 0.),

            prevent_quit_event: false,
            quit_requested: false,

            cursor_grabbed: false,

            input_events: Vec::new(),

            camera_matrix: None,
            gl: QuadGl::new(
                &mut *ctx,
                draw_call_vertex_capacity,
                draw_call_index_capacity,
            ),

            ui_context: UiContext::new(&mut *ctx, screen_width, screen_height),
            fonts_storage: text::FontsStorage::new(&mut *ctx),
            texture_batcher: texture::Batcher::new(&mut *ctx),
            camera_stack: vec![],

            audio_context: audio::AudioContext::new(),
            coroutines_context: experimental::coroutines::CoroutinesContext::new(),

            pc_assets_folder: None,

            start_time: miniquad::date::now(),
            last_frame_time: miniquad::date::now(),
            frame_time: 1. / 60.,

            #[cfg(one_screenshot)]
            counter: 0,
            unwind: false,
            recovery_future: None,

            quad_context: ctx,

            default_filter_mode,
            textures: crate::texture::TexturesContext::new(),
            update_on,

            dropped_files: Vec::new(),
        }
    }

    /// Returns the handle for this texture.
    pub fn raw_miniquad_id(&self, handle: &TextureHandle) -> miniquad::TextureId {
        match handle {
            TextureHandle::Unmanaged(texture) => *texture,
            TextureHandle::Managed(texture) => self
                .textures
                .texture(texture.0)
                .unwrap_or(self.gl.white_texture),
            TextureHandle::ManagedWeak(texture) => self
                .textures
                .texture(*texture)
                .unwrap_or(self.gl.white_texture),
        }
    }

    /// Returns the files which have been dropped onto the window.
    pub fn dropped_files(&mut self) -> Vec<DroppedFile> {
        std::mem::take(&mut self.dropped_files)
    }

    fn begin_frame(&mut self) {
        telemetry::begin_gpu_query("GPU");

        self.ui_context.process_input();

        let color = Self::DEFAULT_BG_COLOR;

        get_quad_context().clear(Some((color.r, color.g, color.b, color.a)), None, None);
        self.gl.reset();
    }

    fn end_frame(&mut self) {
        crate::experimental::scene::update();

        self.perform_render_passes();

        self.ui_context.draw(get_quad_context(), &mut self.gl);
        let screen_mat = self.pixel_perfect_projection_matrix();
        self.gl.draw(get_quad_context(), screen_mat);

        get_quad_context().commit_frame();

        #[cfg(one_screenshot)]
        {
            get_context().counter += 1;
            if get_context().counter == 3 {
                crate::prelude::get_screen_data().export_png("screenshot.png");
                panic!("screenshot successfully saved to `screenshot.png`");
            }
        }

        telemetry::end_gpu_query();

        self.mouse_wheel = Vec2::new(0., 0.);
        self.keys_pressed.clear();
        self.keys_released.clear();
        self.mouse_pressed.clear();
        self.mouse_released.clear();
        self.last_mouse_position = Some(crate::prelude::mouse_position_local());

        self.quit_requested = false;

        self.textures.garbage_collect(get_quad_context());

        // remove all touches that were Ended or Cancelled
        self.touches.retain(|_, touch| {
            touch.phase != input::TouchPhase::Ended && touch.phase != input::TouchPhase::Cancelled
        });

        // change all Started or Moved touches to Stationary
        for touch in self.touches.values_mut() {
            if touch.phase == input::TouchPhase::Started || touch.phase == input::TouchPhase::Moved
            {
                touch.phase = input::TouchPhase::Stationary;
            }
        }

        self.dropped_files.clear();
    }

    pub(crate) fn pixel_perfect_projection_matrix(&self) -> glam::Mat4 {
        let (width, height) = miniquad::window::screen_size();

        let dpi = miniquad::window::dpi_scale();

        glam::Mat4::orthographic_rh_gl(0., width / dpi, height / dpi, 0., -1., 1.)
    }

    pub(crate) fn projection_matrix(&self) -> glam::Mat4 {
        if let Some(matrix) = self.camera_matrix {
            matrix
        } else {
            self.pixel_perfect_projection_matrix()
        }
    }

    pub(crate) fn perform_render_passes(&mut self) {
        let matrix = self.projection_matrix();

        self.gl.draw(get_quad_context(), matrix);
    }
}

#[no_mangle]
static mut CONTEXT: Option<Context> = None;

// This is required for #[macroquad::test]
//
// unfortunately #[cfg(test)] do not work with integration tests
// so this module should be publicly available
#[doc(hidden)]
pub mod test {
    pub static mut MUTEX: Option<std::sync::Mutex<()>> = None;
    pub static ONCE: std::sync::Once = std::sync::Once::new();
}

fn get_context() -> &'static mut Context {
    thread_assert::same_thread();

    unsafe { CONTEXT.as_mut().unwrap_or_else(|| panic!()) }
}

fn get_quad_context() -> &'static mut dyn miniquad::RenderingBackend {
    thread_assert::same_thread();

    unsafe {
        assert!(CONTEXT.is_some());
    }

    unsafe { &mut *CONTEXT.as_mut().unwrap().quad_context }
}

struct Stage {
    main_future: Pin<Box<dyn Future<Output = ()>>>,
}

impl EventHandler for Stage {
    fn resize_event(&mut self, width: f32, height: f32) {
        let _z = telemetry::ZoneGuard::new("Event::resize_event");
        get_context().screen_width = width;
        get_context().screen_height = height;

        if miniquad::window::blocking_event_loop() {
            miniquad::window::schedule_update();
        }
    }

    fn raw_mouse_motion(&mut self, x: f32, y: f32) {
        let context = get_context();

        if context.cursor_grabbed {
            context.mouse_position += Vec2::new(x, y);

            let event = MiniquadInputEvent::MouseMotion {
                x: context.mouse_position.x,
                y: context.mouse_position.y,
            };
            context
                .input_events
                .iter_mut()
                .for_each(|arr| arr.push(event.clone()));
        }
    }

    fn mouse_motion_event(&mut self, x: f32, y: f32) {
        let context = get_context();

        if !context.cursor_grabbed {
            context.mouse_position = Vec2::new(x, y);

            context
                .input_events
                .iter_mut()
                .for_each(|arr| arr.push(MiniquadInputEvent::MouseMotion { x, y }));
        }

        if context.update_on.mouse_motion {
            miniquad::window::schedule_update();
        }
    }

    fn mouse_wheel_event(&mut self, x: f32, y: f32) {
        let context = get_context();

        context.mouse_wheel.x = x;
        context.mouse_wheel.y = y;

        context
            .input_events
            .iter_mut()
            .for_each(|arr| arr.push(MiniquadInputEvent::MouseWheel { x, y }));

        if context.update_on.mouse_wheel {
            miniquad::window::schedule_update();
        }
    }

    fn mouse_button_down_event(&mut self, btn: MouseButton, x: f32, y: f32) {
        let context = get_context();

        context.mouse_down.insert(btn);
        context.mouse_pressed.insert(btn);

        context
            .input_events
            .iter_mut()
            .for_each(|arr| arr.push(MiniquadInputEvent::MouseButtonDown { x, y, btn }));

        if !context.cursor_grabbed {
            context.mouse_position = Vec2::new(x, y);
        }

        if context.update_on.mouse_down {
            miniquad::window::schedule_update();
        }
    }

    fn mouse_button_up_event(&mut self, btn: MouseButton, x: f32, y: f32) {
        let context = get_context();

        context.mouse_down.remove(&btn);
        context.mouse_released.insert(btn);

        context
            .input_events
            .iter_mut()
            .for_each(|arr| arr.push(MiniquadInputEvent::MouseButtonUp { x, y, btn }));

        if !context.cursor_grabbed {
            context.mouse_position = Vec2::new(x, y);
        }
        if context.update_on.mouse_up {
            miniquad::window::schedule_update();
        }
    }

    fn touch_event(&mut self, phase: TouchPhase, id: u64, x: f32, y: f32) {
        let context = get_context();

        context.touches.insert(
            id,
            input::Touch {
                id,
                phase: phase.into(),
                position: Vec2::new(x, y),
            },
        );

        if context.simulate_mouse_with_touch {
            if phase == TouchPhase::Started {
                self.mouse_button_down_event(MouseButton::Left, x, y);
            }

            if phase == TouchPhase::Ended {
                self.mouse_button_up_event(MouseButton::Left, x, y);
            }

            if phase == TouchPhase::Moved {
                self.mouse_motion_event(x, y);
            }
        } else if context.update_on.touch {
            miniquad::window::schedule_update();
        };

        context
            .input_events
            .iter_mut()
            .for_each(|arr| arr.push(MiniquadInputEvent::Touch { phase, id, x, y }));
    }

    fn char_event(&mut self, character: char, modifiers: KeyMods, repeat: bool) {
        let context = get_context();

        context.chars_pressed_queue.push(character);
        context.chars_pressed_ui_queue.push(character);

        context.input_events.iter_mut().for_each(|arr| {
            arr.push(MiniquadInputEvent::Char {
                character,
                modifiers,
                repeat,
            });
        });
    }

    fn key_down_event(&mut self, keycode: KeyCode, modifiers: KeyMods, repeat: bool) {
        let context = get_context();
        context.keys_down.insert(keycode);
        if repeat == false {
            context.keys_pressed.insert(keycode);
        }

        context.input_events.iter_mut().for_each(|arr| {
            arr.push(MiniquadInputEvent::KeyDown {
                keycode,
                modifiers,
                repeat,
            });
        });
        if context
            .update_on
            .specific_key
            .as_ref()
            .map_or(context.update_on.key_down, |keys| keys.contains(&keycode))
        {
            miniquad::window::schedule_update();
        }
    }

    fn key_up_event(&mut self, keycode: KeyCode, modifiers: KeyMods) {
        let context = get_context();
        context.keys_down.remove(&keycode);
        context.keys_released.insert(keycode);

        context
            .input_events
            .iter_mut()
            .for_each(|arr| arr.push(MiniquadInputEvent::KeyUp { keycode, modifiers }));

        if miniquad::window::blocking_event_loop() {
            //miniquad::window::schedule_update();
        }
    }

    fn update(&mut self) {
        let _z = telemetry::ZoneGuard::new("Event::update");

        // Unless called every frame, cursor will not remain grabbed
        miniquad::window::set_cursor_grab(get_context().cursor_grabbed);

        #[cfg(not(target_arch = "wasm32"))]
        {
            // TODO: consider making it a part of miniquad?
            std::thread::yield_now();
        }
    }

    fn files_dropped_event(&mut self) {
        let context = get_context();
        for i in 0..miniquad::window::dropped_file_count() {
            context.dropped_files.push(DroppedFile {
                path: miniquad::window::dropped_file_path(i),
                bytes: miniquad::window::dropped_file_bytes(i),
            });
        }
    }

    fn draw(&mut self) {
        {
            let _z = telemetry::ZoneGuard::new("Event::draw");

            use std::panic;

            {
                let _z = telemetry::ZoneGuard::new("Event::draw begin_frame");
                get_context().begin_frame();
            }

            fn maybe_unwind(unwind: bool, f: impl FnOnce() + Sized + panic::UnwindSafe) -> bool {
                if unwind {
                    panic::catch_unwind(f).is_ok()
                } else {
                    f();
                    true
                }
            }

            let result = maybe_unwind(
                get_context().unwind,
                AssertUnwindSafe(|| {
                    let _z = telemetry::ZoneGuard::new("Event::draw user code");

                    if exec::resume(&mut self.main_future).is_some() {
                        self.main_future = Box::pin(async move {});
                        miniquad::window::quit();
                        return;
                    }
                    get_context().coroutines_context.update();
                }),
            );

            if result == false {
                if let Some(recovery_future) = get_context().recovery_future.take() {
                    self.main_future = recovery_future;
                }
            }

            {
                let _z = telemetry::ZoneGuard::new("Event::draw end_frame");
                get_context().end_frame();
            }
            get_context().frame_time = date::now() - get_context().last_frame_time;
            get_context().last_frame_time = date::now();

            #[cfg(any(target_arch = "wasm32", target_os = "linux"))]
            {
                let _z = telemetry::ZoneGuard::new("glFinish/glFLush");

                unsafe {
                    miniquad::gl::glFlush();
                    miniquad::gl::glFinish();
                }
            }
        }

        telemetry::reset();
    }

    fn window_restored_event(&mut self) {
        let context = get_context();

        #[cfg(target_os = "android")]
        context.audio_context.resume();
        #[cfg(target_os = "android")]
        if miniquad::window::blocking_event_loop() {
            miniquad::window::schedule_update();
        }

        context
            .input_events
            .iter_mut()
            .for_each(|arr| arr.push(MiniquadInputEvent::WindowRestored));
    }

    fn window_minimized_event(&mut self) {
        let context = get_context();

        #[cfg(target_os = "android")]
        context.audio_context.pause();

        // Clear held down keys and button and announce them as released
        context.mouse_released.extend(context.mouse_down.drain());
        context.keys_released.extend(context.keys_down.drain());

        // Announce all touches as released
        for (_, touch) in context.touches.iter_mut() {
            touch.phase = input::TouchPhase::Ended;
        }

        context
            .input_events
            .iter_mut()
            .for_each(|arr| arr.push(MiniquadInputEvent::WindowMinimized));
    }

    fn quit_requested_event(&mut self) {
        let context = get_context();
        if context.prevent_quit_event {
            miniquad::window::cancel_quit();
            context.quit_requested = true;
        }
    }
}

pub mod conf {
    #[derive(Default, Debug)]
    pub struct UpdateTrigger {
        pub key_down: bool,
        pub mouse_down: bool,
        pub mouse_up: bool,
        pub mouse_motion: bool,
        pub mouse_wheel: bool,
        pub specific_key: Option<Vec<crate::KeyCode>>,
        pub touch: bool,
    }

    #[derive(Debug)]
    pub struct Conf {
        pub miniquad_conf: miniquad::conf::Conf,
        /// With miniquad_conf.platform.blocking_event_loop = true,
        /// next_frame().await will never finish and will wait forever with
        /// zero CPU usage.
        /// update_on will tell macroquad when to proceed with the event loop.
        pub update_on: Option<UpdateTrigger>,
        pub default_filter_mode: crate::FilterMode,
        /// Macroquad performs automatic and static batching for each
        /// draw_* call. For each draw call, it pre-allocate a huge cpu/gpu
        /// buffer to add vertices to. When it exceeds the buffer, it allocates the
        /// new one, marking the new draw call.
        ///
        /// Some examples when altering those values migh be convinient:
        /// - for huge 3d models that do not fit into a single draw call, increasing
        ///     the buffer size might be easier than splitting the model.
        /// - when each draw_* call got its own material,
        ///     buffer size might be reduced to save some memory
        pub draw_call_vertex_capacity: usize,
        pub draw_call_index_capacity: usize,
    }

    impl Default for Conf {
        fn default() -> Self {
            Self {
                miniquad_conf: miniquad::conf::Conf::default(),
                update_on: Some(UpdateTrigger::default()),
                default_filter_mode: crate::FilterMode::Linear,
                draw_call_vertex_capacity: 10000,
                draw_call_index_capacity: 5000,
            }
        }
    }
}

impl From<miniquad::conf::Conf> for conf::Conf {
    fn from(conf: miniquad::conf::Conf) -> conf::Conf {
        conf::Conf {
            miniquad_conf: conf,
            update_on: None,
            default_filter_mode: crate::FilterMode::Linear,
            draw_call_vertex_capacity: 10000,
            draw_call_index_capacity: 5000,
        }
    }
}

/// Not meant to be used directly, only from the macro.
#[doc(hidden)]
pub struct Window {}

impl Window {
    pub fn new(label: &str, future: impl Future<Output = ()> + 'static) {
        Window::from_config(
            conf::Conf {
                miniquad_conf: miniquad::conf::Conf {
                    window_title: label.to_string(),
                    ..Default::default()
                },
                ..Default::default()
            },
            future,
        );
    }

    pub fn from_config(config: impl Into<conf::Conf>, future: impl Future<Output = ()> + 'static) {
        let conf::Conf {
            miniquad_conf,
            update_on,
            default_filter_mode,
            draw_call_vertex_capacity,
            draw_call_index_capacity,
        } = config.into();
        miniquad::start(miniquad_conf, move || {
            thread_assert::set_thread_id();
            let context = Context::new(
                update_on.unwrap_or_default(),
                default_filter_mode,
                draw_call_vertex_capacity,
                draw_call_index_capacity,
            );
            unsafe { CONTEXT = Some(context) };

            Box::new(Stage {
                main_future: Box::pin(async {
                    future.await;
                    unsafe {
                        if let Some(ctx) = CONTEXT.as_mut() {
                            ctx.gl.reset();
                        }
                    }
                }),
            })
        });
    }
}

/// Information about a dropped file.
pub struct DroppedFile {
    pub path: Option<std::path::PathBuf>,
    pub bytes: Option<Vec<u8>>,
}

```

`src/material.rs`:

```rs
//! Custom materials - shaders, uniforms.

use crate::{get_context, quad_gl::GlPipeline, texture::Texture2D, tobytes::ToBytes, Error};
use miniquad::{PipelineParams, UniformDesc};
use std::sync::Arc;

#[derive(PartialEq)]
struct GlPipelineGuarded(GlPipeline);

impl Drop for GlPipelineGuarded {
    fn drop(&mut self) {
        get_context().gl.delete_pipeline(self.0);
    }
}

/// Material instance loaded on GPU.
#[derive(Clone, PartialEq)]
pub struct Material {
    pipeline: Arc<GlPipelineGuarded>,
}

impl std::fmt::Debug for Material {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Material").finish()
    }
}

impl Material {
    /// Set GPU uniform value for this material.
    /// "name" should be from "uniforms" list used for material creation.
    /// Otherwise uniform value would be silently ignored.
    pub fn set_uniform<T>(&self, name: &str, uniform: T) {
        get_context().gl.set_uniform(self.pipeline.0, name, uniform);
    }

    pub fn set_uniform_array<T: ToBytes>(&self, name: &str, uniform: &[T]) {
        get_context()
            .gl
            .set_uniform_array(self.pipeline.0, name, uniform);
    }

    pub fn set_texture(&self, name: &str, texture: Texture2D) {
        get_context().gl.set_texture(self.pipeline.0, name, texture);
    }
}

/// Params used for material loading.
/// It is not possible to change material params at runtime, so this
/// struct is used only once - at "load_material".
#[derive(Default)]
pub struct MaterialParams {
    /// miniquad pipeline configuration for this material.
    /// Things like blending, culling, depth dest
    pub pipeline_params: PipelineParams,

    /// List of custom uniforms used in this material
    pub uniforms: Vec<UniformDesc>,

    /// List of textures used in this material
    pub textures: Vec<String>,
}

/// Creates custom material
///
/// For OpenGL and Metal examples check examples/custom_material.rs.
///
/// # Default variables for OpenGL backend:
/// ## Attributes (order doesn't matter, any could be skipped):
/// ```glsl
/// attribute vec3 position;
/// attribute vec4 color0;
/// attribute vec2 texcoord;
/// ```
/// ## Uniforms (order doesn't matter, any could be skipped):
/// ```glsl
/// uniform mat4 Model;
/// uniform mat4 Projection;
/// uniform float4 _Time;
/// ```
/// ## Textures (order doesn't matter, any could be skipped):
/// ```glsl
/// uniform sampler2D Texture;
/// uniform sampler2D _ScreenTexture; // check examples/screen_texture.rs to see how it works
/// ```
///
/// # Default variables for Metal backend:
/// ## Attributes (order doesn't matter, any could be skipped, should have exact index in attribute()):
/// ```msl
/// struct Vertex
/// {
///     float3 position    [[attribute(0)]];
///     float2 texcoord    [[attribute(1)]];
///     float4 color0      [[attribute(2)]];
/// };
/// ```
/// ## Uniforms (**order matters, all fields before needed one should present**):
/// **All uniforms are in the same buffer, so order matters also for custom additional uniforms**
/// ```msl
/// struct Uniforms
/// {
///     float4x4 Model;
///     float4x4 Projection;
///     float4 _Time;
///     ...
///     additional uniforms
/// };
/// // same for vertexShader
/// // Only buffer(0) is correct here
/// fragment float4 fragmentShader(..., constant Uniforms& u [[buffer(0)]], ...) {...}
/// ```
/// ## Textures (order doesn't matter, any could be skipped, should have exact indices in `texture()` and `sampler()`):
/// ```msl
/// // same for vertexShader
/// fragment float4 fragmentShader(...,
///     texture2d<float> Texture [[texture(0)]],
///     sampler TextureSmplr [[sampler(0)]],
///     _ScreenTexture is not working for metal for now
///     ...
/// ) {...}
/// ```
///
pub fn load_material(
    shader: crate::ShaderSource,
    params: MaterialParams,
) -> Result<Material, Error> {
    let context = &mut get_context();

    let pipeline = context.gl.make_pipeline(
        &mut *context.quad_context,
        shader,
        params.pipeline_params,
        params.uniforms,
        params.textures,
    )?;

    Ok(Material {
        pipeline: Arc::new(GlPipelineGuarded(pipeline)),
    })
}

/// All following macroquad rendering calls will use the given material.
pub fn gl_use_material(material: &Material) {
    get_context().gl.pipeline(Some(material.pipeline.0));
}

/// Use default macroquad material.
pub fn gl_use_default_material() {
    get_context().gl.pipeline(None);
}

#[doc(hidden)]
pub mod shaders {
    type IncludeFilename = String;
    type IncludeContent = String;

    #[derive(Debug, Clone)]
    pub struct PreprocessorConfig {
        pub includes: Vec<(IncludeFilename, IncludeContent)>,
    }
    impl Default for PreprocessorConfig {
        fn default() -> PreprocessorConfig {
            PreprocessorConfig { includes: vec![] }
        }
    }

    impl PreprocessorConfig {}

    pub fn preprocess_shader(source: &str, config: &PreprocessorConfig) -> String {
        let mut res = source.chars().collect::<Vec<_>>();

        fn find(data: &[char], n: &mut usize, target: &str) -> bool {
            if *n >= data.len() {
                return false;
            }
            let target = target.chars().collect::<Vec<_>>();

            'outer: for i in *n..data.len() {
                for j in 0..target.len() {
                    if data[i + j] != target[j] {
                        *n += 1;
                        continue 'outer;
                    }
                }
                return true;
            }
            false
        }

        fn skip_character(data: &[char], n: &mut usize, target: char) {
            while *n < data.len() && data[*n] == target {
                *n += 1;
            }
        }

        let mut i = 0;
        while find(&res, &mut i, "#include") {
            let directive_start_ix = i;
            i += "#include".len();
            skip_character(&res, &mut i, ' ');
            assert!(res[i] == '\"');
            i += 1;
            let filename_start_ix = i;
            find(&res, &mut i, "\"");
            let filename_end_ix = i;
            let filename = res[filename_start_ix..filename_end_ix]
                .iter()
                .cloned()
                .collect::<String>();

            let include_content = config
                .includes
                .iter()
                .find(|(name, _)| name == &filename)
                .expect(&format!(
                    "Include file {filename} in not on \"includes\" list"
                ));

            let _ = res
                .splice(
                    directive_start_ix..filename_end_ix + 1,
                    include_content.1.chars(),
                )
                .collect::<Vec<_>>();
        }

        res.into_iter().collect()
    }

    #[test]
    fn preprocessor_test() {
        let shader_string = r#"
#version blah blah

asd
asd

#include "hello.glsl"

qwe
"#;

        let preprocessed = r#"
#version blah blah

asd
asd

iii
jjj

qwe
"#;

        let result = preprocess_shader(
            shader_string,
            &PreprocessorConfig {
                includes: vec![("hello.glsl".to_string(), "iii\njjj".to_string())],
                ..Default::default()
            },
        );

        assert_eq!(result, preprocessed);
    }
}

```

`src/math.rs`:

```rs
//! Math types and helpers.
//!
//! Consists of re-exported `glam` types with some additions.

pub use glam::*;

mod circle;
mod rect;

pub use circle::Circle;
pub use rect::{Rect, RectOffset};

/// Converts 2d polar coordinates to 2d cartesian coordinates.
pub fn polar_to_cartesian(rho: f32, theta: f32) -> Vec2 {
    vec2(rho * theta.cos(), rho * theta.sin())
}

/// Converts 2d cartesian coordinates to 2d polar coordinates.
pub fn cartesian_to_polar(cartesian: Vec2) -> Vec2 {
    vec2(
        (cartesian.x.powi(2) + cartesian.y.powi(2)).sqrt(),
        cartesian.y.atan2(cartesian.x),
    )
}

/// Returns value, bounded in range [min, max].
pub fn clamp<T: PartialOrd>(value: T, min: T, max: T) -> T {
    if value < min {
        min
    } else if value > max {
        max
    } else {
        value
    }
}

```

`src/math/circle.rs`:

```rs
use crate::math::{vec2, Rect, Vec2};

#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Circle {
    pub x: f32,
    pub y: f32,
    pub r: f32,
}

impl Circle {
    /// Constructs a new `Circle` with the center `(x, y)` and radius `r`.
    pub const fn new(x: f32, y: f32, r: f32) -> Self {
        Circle { x, y, r }
    }

    /// Returns the center point of the `Circle`.
    pub const fn point(&self) -> Vec2 {
        vec2(self.x, self.y)
    }

    /// Returns the radius of the `Circle`.
    pub const fn radius(&self) -> f32 {
        self.r
    }

    /// Moves the `Circle`'s origin to (x, y).
    pub const fn move_to(&mut self, destination: Vec2) {
        self.x = destination.x;
        self.y = destination.y;
    }

    /// Scales the `Circle` by a factor of `sr`.
    pub const fn scale(&mut self, sr: f32) {
        self.r *= sr;
    }

    /// Checks whether the `Circle` contains a `Point`.
    pub fn contains(&self, pos: &Vec2) -> bool {
        pos.distance(vec2(self.x, self.y)) < self.r
    }

    /// Checks whether the `Circle` overlaps a `Circle`.
    pub fn overlaps(&self, other: &Circle) -> bool {
        self.point().distance(other.point()) < self.r + other.r
    }

    /// Checks whether the `Circle` overlaps a `Rect`.
    pub const fn overlaps_rect(&self, rect: &Rect) -> bool {
        let dist_x = (self.x - rect.center().x).abs();
        let dist_y = (self.y - rect.center().y).abs();
        if dist_x > rect.w / 2.0 + self.r || dist_y > rect.h / 2.0 + self.r {
            return false;
        }
        if dist_x <= rect.w / 2.0 || dist_y <= rect.h / 2.0 {
            return true;
        }
        let lhs = dist_x - rect.w / 2.0;
        let rhs = dist_y - rect.h / 2.0;
        let dist_sq = (lhs * lhs) + (rhs * rhs);
        dist_sq <= self.r * self.r
    }

    /// Translate `Circle` origin by `offset` vector.
    pub const fn offset(self, offset: Vec2) -> Circle {
        Circle::new(self.x + offset.x, self.y + offset.y, self.r)
    }
}

```

`src/math/rect.rs`:

```rs
use glam::*;

/// A 2D rectangle, defined by its top-left corner, width and height.
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Rect {
    /// The x-coordinate of the top-left corner.
    pub x: f32,
    /// The y-coordinate of the top-left corner.
    pub y: f32,
    /// The width of the `Rect`, going to the right.
    pub w: f32,
    /// The height of the `Rect`, going down.
    pub h: f32,
}

impl Rect {
    /// Creates a new rectangle from its top-left corner, width and height.
    ///
    /// # Arguments:
    ///   * `x` - x-coordinate of the top-left corner.
    ///   * `y` - y-coordinate of the top-left corner.
    ///   * `w` - width of the `Rect`, going to the right.
    ///   * `h` - height of the `Rect`, going down.
    pub const fn new(x: f32, y: f32, w: f32, h: f32) -> Rect {
        Rect { x, y, w, h }
    }

    /// Returns the top-left corner of the `Rect`.
    pub const fn point(&self) -> Vec2 {
        vec2(self.x, self.y)
    }

    /// Returns the size (width and height) of the `Rect`.
    pub const fn size(&self) -> Vec2 {
        vec2(self.w, self.h)
    }

    /// Returns the center position of the `Rect`.
    pub const fn center(&self) -> Vec2 {
        vec2(self.x + self.w * 0.5f32, self.y + self.h * 0.5f32)
    }

    /// Returns the left edge of the `Rect`.
    pub const fn left(&self) -> f32 {
        self.x
    }

    /// Returns the right edge of the `Rect`.
    pub const fn right(&self) -> f32 {
        self.x + self.w
    }

    /// Returns the top edge of the `Rect`.
    pub const fn top(&self) -> f32 {
        self.y
    }

    /// Returns the bottom edge of the `Rect`.
    pub const fn bottom(&self) -> f32 {
        self.y + self.h
    }

    /// Moves the `Rect`'s origin to (x, y).
    pub const fn move_to(&mut self, destination: Vec2) {
        self.x = destination.x;
        self.y = destination.y;
    }

    /// Scales the `Rect` by a factor of (sx, sy),
    /// growing towards the bottom-left.
    pub const fn scale(&mut self, sx: f32, sy: f32) {
        self.w *= sx;
        self.h *= sy;
    }

    /// Checks whether the `Rect` contains a `Point`.
    pub const fn contains(&self, point: Vec2) -> bool {
        point.x >= self.left()
            && point.x <= self.right()
            && point.y <= self.bottom()
            && point.y >= self.top()
    }

    /// Checks whether the `Rect` overlaps another `Rect`.
    pub const fn overlaps(&self, other: &Rect) -> bool {
        self.left() <= other.right()
            && self.right() >= other.left()
            && self.top() <= other.bottom()
            && self.bottom() >= other.top()
    }

    /// Returns a new `Rect` that includes all points of these two `Rect`s.
    pub const fn combine_with(self, other: Rect) -> Rect {
        let x = f32::min(self.x, other.x);
        let y = f32::min(self.y, other.y);
        let w = f32::max(self.right(), other.right()) - x;
        let h = f32::max(self.bottom(), other.bottom()) - y;
        Rect { x, y, w, h }
    }

    /// Returns an intersection rect if there is any intersection.
    pub const fn intersect(&self, other: Rect) -> Option<Rect> {
        let left = self.x.max(other.x);
        let top = self.y.max(other.y);
        let right = self.right().min(other.right());
        let bottom = self.bottom().min(other.bottom());

        if right < left || bottom < top {
            return None;
        }

        Some(Rect {
            x: left,
            y: top,
            w: right - left,
            h: bottom - top,
        })
    }

    /// Translate rect origin by `offset` vector.
    pub const fn offset(self, offset: Vec2) -> Rect {
        Rect::new(self.x + offset.x, self.y + offset.y, self.w, self.h)
    }

    /// Returns a normalized rect where width and height are guaranteed to be positive.
    pub fn normalized(&self) -> Rect {
        let x = self.x.min(self.x + self.w);
        let y = self.y.min(self.y + self.h);
        let w = self.w.abs();
        let h = self.h.abs();
        Rect { x, y, w, h }
    }
}

#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct RectOffset {
    pub left: f32,
    pub right: f32,
    pub bottom: f32,
    pub top: f32,
}

impl RectOffset {
    pub const fn new(left: f32, right: f32, top: f32, bottom: f32) -> RectOffset {
        RectOffset {
            left,
            right,
            top,
            bottom,
        }
    }
}

#[test]
fn rect_contains_border() {
    let rect = Rect::new(1.0, 1.0, 2.0, 2.0);
    assert!(rect.contains(vec2(1.0, 1.0)));
    assert!(rect.contains(vec2(3.0, 1.0)));
    assert!(rect.contains(vec2(1.0, 3.0)));
    assert!(rect.contains(vec2(3.0, 3.0)));
    assert!(rect.contains(vec2(2.0, 2.0)));
}

```

`src/models.rs`:

```rs
//! 3D shapes and models, loading 3d models from files, drawing 3D primitives.

use crate::{color::Color, get_context};

use crate::{quad_gl::DrawMode, texture::Texture2D};
use glam::{vec2, vec3, vec4, Quat, Vec2, Vec3, Vec4};

#[repr(C)]
#[derive(Clone, Debug, Copy)]
pub struct Vertex {
    pub position: Vec3,
    pub uv: Vec2,
    pub color: [u8; 4],
    /// Normal is not used by macroquad and is completely optional.
    /// Might be usefull for custom shaders.
    /// While normal is not used by macroquad, it is completely safe to use it
    /// to pass arbitary user data, hence Vec4.
    pub normal: Vec4,
}

impl Vertex {
    pub fn new(x: f32, y: f32, z: f32, u: f32, v: f32, color: Color) -> Vertex {
        Vertex {
            position: vec3(x, y, z),
            uv: vec2(u, v),
            color: color.into(),
            normal: vec4(0.0, 0.0, 0.0, 0.0),
        }
    }

    pub fn new2(position: Vec3, uv: Vec2, color: Color) -> Vertex {
        Vertex {
            position,
            uv,
            color: color.into(),
            normal: vec4(0.0, 0.0, 0.0, 0.0),
        }
    }
}

pub struct Mesh {
    pub vertices: Vec<Vertex>,
    pub indices: Vec<u16>,
    pub texture: Option<Texture2D>,
}

pub fn draw_mesh(mesh: &Mesh) {
    let context = get_context();

    context.gl.texture(mesh.texture.as_ref());
    context.gl.draw_mode(DrawMode::Triangles);
    context.gl.geometry(&mesh.vertices[..], &mesh.indices[..]);
}

fn draw_quad(vertices: [Vertex; 4]) {
    let context = get_context();
    let indices = [0, 1, 2, 0, 2, 3];
    context.gl.draw_mode(DrawMode::Triangles);
    context.gl.geometry(&vertices, &indices);
}

pub fn draw_line_3d(start: Vec3, end: Vec3, color: Color) {
    let context = get_context();
    let uv = vec2(0., 0.);
    let indices = [0, 1];

    let line = [Vertex::new2(start, uv, color), Vertex::new2(end, uv, color)];

    context.gl.texture(None);
    context.gl.draw_mode(DrawMode::Lines);
    context.gl.geometry(&line, &indices);
}

/// Draw a grid centered at (0, 0, 0)
pub fn draw_grid(slices: u32, spacing: f32, axes_color: Color, other_color: Color) {
    draw_grid_ex(
        slices,
        spacing,
        axes_color,
        other_color,
        vec3(0., 0., 0.),
        Quat::IDENTITY,
    );
}

/// Draw a rotated grid centered at a specified point
pub fn draw_grid_ex(
    slices: u32,
    spacing: f32,
    axes_color: Color,
    other_color: Color,
    center: Vec3,
    rotation: Quat,
) {
    let half_slices = (slices as i32) / 2;
    for i in -half_slices..half_slices + 1 {
        let color = if i == 0 { axes_color } else { other_color };

        let start = vec3(i as f32 * spacing, 0., -half_slices as f32 * spacing);
        let end = vec3(i as f32 * spacing, 0., half_slices as f32 * spacing);

        draw_line_3d(
            rotation.mul_vec3(start) + center,
            rotation.mul_vec3(end) + center,
            color,
        );

        let start = vec3(-half_slices as f32 * spacing, 0., i as f32 * spacing);
        let end = vec3(half_slices as f32 * spacing, 0., i as f32 * spacing);

        draw_line_3d(
            rotation.mul_vec3(start) + center,
            rotation.mul_vec3(end) + center,
            color,
        );
    }
}

pub fn draw_plane(center: Vec3, size: Vec2, texture: Option<&Texture2D>, color: Color) {
    let v1 = Vertex::new2(center + vec3(-size.x, 0., -size.y), vec2(0., 0.), color);
    let v2 = Vertex::new2(center + vec3(-size.x, 0., size.y), vec2(0., 1.), color);
    let v3 = Vertex::new2(center + vec3(size.x, 0., size.y), vec2(1., 1.), color);
    let v4 = Vertex::new2(center + vec3(size.x, 0., -size.y), vec2(1., 0.), color);

    {
        let context = get_context();
        context.gl.texture(texture);
    }
    draw_quad([v1, v2, v3, v4]);
}

/// Draw an affine (2D) parallelogram at given position, as two triangles.
///
/// The drawn parallelogram will have the vertices: `offset`, `offset + e1`, `offset + e2` and `offset + e1 + e2`
///
/// # Arguments
///
/// * `offset` - Offset of the first point from the origin
/// * `e1`, `e2` - Base vectors for the parallelogram
/// * `texture` - Optional [Texture2D] to apply, which will be streched on the entire shape (todo!
/// support custom uv values per vertex)
/// * `color` - The [Color] to draw the parallelogram
///
/// # Examples
///
/// Draw an axis aligned rectangle
/// ```no_run
/// # use macroquad::prelude::*;
/// draw_affine_parallelogram(Vec3::ZERO, 3. * Vec3::X, 5. * Vec3::Z, None, RED);
/// ```
pub fn draw_affine_parallelogram(
    offset: Vec3,
    e1: Vec3,
    e2: Vec3,
    texture: Option<&Texture2D>,
    color: Color,
) {
    let v1 = Vertex::new2(offset, vec2(0., 0.), color);
    let v2 = Vertex::new2(offset + e1, vec2(0., 1.), color);
    let v3 = Vertex::new2(offset + e1 + e2, vec2(1., 1.), color);
    let v4 = Vertex::new2(offset + e2, vec2(1., 0.), color);

    {
        let context = get_context();
        context.gl.texture(texture);
    }
    draw_quad([v1, v2, v3, v4]);
}

/// Draw an affine (3D) parallelepiped at given position, using six parallelograms.
///
/// The drawn parallelepiped will be built from the followwing parallelograms:
///
/// * `offset, offset + e1, offset + e2`
/// * `offset, offset + e2, offset + e3`
/// * `offset, offset + e1, offset + e3`
/// * `offset, offset + e1 + e2, offset + e1 + e3`
/// * `offset, offset + e2 + e1, offset + e2 + e3`
/// * `offset, offset + e3 + e1, offset + e3 + e2`
///
/// # Arguments
///
/// * `offset` - Offset of the first point from the origin
/// * `e1`, `e2`, `e3` - Base vectors for the parallelepiped
/// * `texture` - Optional [Texture2D] to apply, which will repeat on each face (todo!
/// support custom uv values per vertex, multiple textures?)
/// * `color` - The [Color] to draw the parallelepiped (todo! support color per face?)
///
/// # Examples
///
/// Draw an axis aligned cube
/// ```no_run
/// # use macroquad::prelude::*;
/// draw_affine_parallelepiped(Vec3::ZERO, 3. * Vec3::X, 2. * Vec3::Y, 5. * Vec3::Z, None, RED);
/// ```
pub fn draw_affine_parallelepiped(
    offset: Vec3,
    e1: Vec3,
    e2: Vec3,
    e3: Vec3,
    texture: Option<&Texture2D>,
    color: Color,
) {
    draw_affine_parallelogram(offset, e1, e2, texture, color);
    draw_affine_parallelogram(offset, e1, e3, texture, color);
    draw_affine_parallelogram(offset, e2, e3, texture, color);

    draw_affine_parallelogram(offset + e1, e2, e3, texture, color);
    draw_affine_parallelogram(offset + e2, e1, e3, texture, color);
    draw_affine_parallelogram(offset + e3, e1, e2, texture, color);
}

pub fn draw_cube(position: Vec3, size: Vec3, texture: Option<&Texture2D>, color: Color) {
    let context = get_context();
    context.gl.texture(texture);

    let (x, y, z) = (position.x, position.y, position.z);
    let (width, height, length) = (size.x, size.y, size.z);

    // Front face
    let bl_pos = vec3(x - width / 2., y - height / 2., z + length / 2.);
    let bl_uv = vec2(0., 0.);
    let br_pos = vec3(x + width / 2., y - height / 2., z + length / 2.);
    let br_uv = vec2(1., 0.);

    let tr_pos = vec3(x + width / 2., y + height / 2., z + length / 2.);
    let tr_uv = vec2(1., 1.);

    let tl_pos = vec3(x - width / 2., y + height / 2., z + length / 2.);
    let tl_uv = vec2(0., 1.);

    draw_quad([
        Vertex::new2(bl_pos, bl_uv, color),
        Vertex::new2(br_pos, br_uv, color),
        Vertex::new2(tr_pos, tr_uv, color),
        Vertex::new2(tl_pos, tl_uv, color),
    ]);

    // Back face
    let bl_pos = vec3(x - width / 2., y - height / 2., z - length / 2.);
    let bl_uv = vec2(0., 0.);
    let br_pos = vec3(x + width / 2., y - height / 2., z - length / 2.);
    let br_uv = vec2(1., 0.);

    let tr_pos = vec3(x + width / 2., y + height / 2., z - length / 2.);
    let tr_uv = vec2(1., 1.);

    let tl_pos = vec3(x - width / 2., y + height / 2., z - length / 2.);
    let tl_uv = vec2(0., 1.);

    draw_quad([
        Vertex::new2(bl_pos, bl_uv, color),
        Vertex::new2(br_pos, br_uv, color),
        Vertex::new2(tr_pos, tr_uv, color),
        Vertex::new2(tl_pos, tl_uv, color),
    ]);

    // Top face
    let bl_pos = vec3(x - width / 2., y + height / 2., z - length / 2.);
    let bl_uv = vec2(0., 1.);
    let br_pos = vec3(x - width / 2., y + height / 2., z + length / 2.);
    let br_uv = vec2(0., 0.);

    let tr_pos = vec3(x + width / 2., y + height / 2., z + length / 2.);
    let tr_uv = vec2(1., 0.);

    let tl_pos = vec3(x + width / 2., y + height / 2., z - length / 2.);
    let tl_uv = vec2(1., 1.);

    draw_quad([
        Vertex::new2(bl_pos, bl_uv, color),
        Vertex::new2(br_pos, br_uv, color),
        Vertex::new2(tr_pos, tr_uv, color),
        Vertex::new2(tl_pos, tl_uv, color),
    ]);

    // Bottom face
    let bl_pos = vec3(x - width / 2., y - height / 2., z - length / 2.);
    let bl_uv = vec2(0., 1.);
    let br_pos = vec3(x - width / 2., y - height / 2., z + length / 2.);
    let br_uv = vec2(0., 0.);

    let tr_pos = vec3(x + width / 2., y - height / 2., z + length / 2.);
    let tr_uv = vec2(1., 0.);

    let tl_pos = vec3(x + width / 2., y - height / 2., z - length / 2.);
    let tl_uv = vec2(1., 1.);

    draw_quad([
        Vertex::new2(bl_pos, bl_uv, color),
        Vertex::new2(br_pos, br_uv, color),
        Vertex::new2(tr_pos, tr_uv, color),
        Vertex::new2(tl_pos, tl_uv, color),
    ]);

    // Right face
    let bl_pos = vec3(x + width / 2., y - height / 2., z - length / 2.);
    let bl_uv = vec2(0., 1.);
    let br_pos = vec3(x + width / 2., y + height / 2., z - length / 2.);
    let br_uv = vec2(0., 0.);

    let tr_pos = vec3(x + width / 2., y + height / 2., z + length / 2.);
    let tr_uv = vec2(1., 0.);

    let tl_pos = vec3(x + width / 2., y - height / 2., z + length / 2.);
    let tl_uv = vec2(1., 1.);

    draw_quad([
        Vertex::new2(bl_pos, bl_uv, color),
        Vertex::new2(br_pos, br_uv, color),
        Vertex::new2(tr_pos, tr_uv, color),
        Vertex::new2(tl_pos, tl_uv, color),
    ]);

    // Left face
    let bl_pos = vec3(x - width / 2., y - height / 2., z - length / 2.);
    let bl_uv = vec2(0., 1.);
    let br_pos = vec3(x - width / 2., y + height / 2., z - length / 2.);
    let br_uv = vec2(0., 0.);

    let tr_pos = vec3(x - width / 2., y + height / 2., z + length / 2.);
    let tr_uv = vec2(1., 0.);

    let tl_pos = vec3(x - width / 2., y - height / 2., z + length / 2.);
    let tl_uv = vec2(1., 1.);

    draw_quad([
        Vertex::new2(bl_pos, bl_uv, color),
        Vertex::new2(br_pos, br_uv, color),
        Vertex::new2(tr_pos, tr_uv, color),
        Vertex::new2(tl_pos, tl_uv, color),
    ]);
}

pub fn draw_cube_wires(position: Vec3, size: Vec3, color: Color) {
    let (x, y, z) = (position.x, position.y, position.z);
    let (width, height, length) = (size.x, size.y, size.z);

    // Front Face

    // Bottom Line
    draw_line_3d(
        vec3(x - width / 2., y - height / 2., z + length / 2.),
        vec3(x + width / 2., y - height / 2., z + length / 2.),
        color,
    );

    // Left Line
    draw_line_3d(
        vec3(x + width / 2., y - height / 2., z + length / 2.),
        vec3(x + width / 2., y + height / 2., z + length / 2.),
        color,
    );

    // Top Line
    draw_line_3d(
        vec3(x + width / 2., y + height / 2., z + length / 2.),
        vec3(x - width / 2., y + height / 2., z + length / 2.),
        color,
    );

    // Right Line
    draw_line_3d(
        vec3(x - width / 2., y + height / 2., z + length / 2.),
        vec3(x - width / 2., y - height / 2., z + length / 2.),
        color,
    );

    // Back Face
    // Bottom Line
    draw_line_3d(
        vec3(x - width / 2., y - height / 2., z - length / 2.),
        vec3(x + width / 2., y - height / 2., z - length / 2.),
        color,
    );

    // Left Line
    draw_line_3d(
        vec3(x + width / 2., y - height / 2., z - length / 2.),
        vec3(x + width / 2., y + height / 2., z - length / 2.),
        color,
    );

    // Top Line
    draw_line_3d(
        vec3(x + width / 2., y + height / 2., z - length / 2.),
        vec3(x - width / 2., y + height / 2., z - length / 2.),
        color,
    );

    // Right Line
    draw_line_3d(
        vec3(x - width / 2., y + height / 2., z - length / 2.),
        vec3(x - width / 2., y - height / 2., z - length / 2.),
        color,
    );

    // Top Face
    // Left Line
    draw_line_3d(
        vec3(x - width / 2., y + height / 2., z + length / 2.),
        vec3(x - width / 2., y + height / 2., z - length / 2.),
        color,
    );

    // Right Line
    draw_line_3d(
        vec3(x + width / 2., y + height / 2., z + length / 2.),
        vec3(x + width / 2., y + height / 2., z - length / 2.),
        color,
    );

    // Bottom Face
    // Left Line
    draw_line_3d(
        vec3(x - width / 2., y - height / 2., z + length / 2.),
        vec3(x - width / 2., y - height / 2., z - length / 2.),
        color,
    );

    // Right Line
    draw_line_3d(
        vec3(x + width / 2., y - height / 2., z + length / 2.),
        vec3(x + width / 2., y - height / 2., z - length / 2.),
        color,
    );
}

#[derive(Debug, Clone)]
pub struct DrawSphereParams {
    pub rings: usize,
    pub slices: usize,
    pub draw_mode: DrawMode,
}

impl Default for DrawSphereParams {
    fn default() -> DrawSphereParams {
        DrawSphereParams {
            rings: 16,
            slices: 16,
            draw_mode: DrawMode::Triangles,
        }
    }
}

pub fn draw_sphere(center: Vec3, radius: f32, texture: Option<&Texture2D>, color: Color) {
    draw_sphere_ex(center, radius, texture, color, Default::default());
}

pub fn draw_sphere_wires(center: Vec3, radius: f32, texture: Option<&Texture2D>, color: Color) {
    let params = DrawSphereParams {
        draw_mode: DrawMode::Lines,
        ..Default::default()
    };
    draw_sphere_ex(center, radius, texture, color, params);
}

pub fn draw_sphere_ex(
    center: Vec3,
    radius: f32,
    texture: Option<&Texture2D>,
    color: Color,
    params: DrawSphereParams,
) {
    let context = get_context();

    let rings = params.rings;
    let slices = params.slices;

    let scale = vec3(radius, radius, radius);

    context.gl.texture(texture);
    context.gl.draw_mode(params.draw_mode);

    for i in 0..rings + 1 {
        for j in 0..slices {
            use std::f32::consts::PI;

            let pi34 = PI / 2. * 3.;
            let pi2 = PI * 2.;
            let i = i as f32;
            let j = j as f32;
            let rings: f32 = rings as _;
            let slices: f32 = slices as _;

            let v1 = vec3(
                (pi34 + (PI / (rings + 1.)) * i).cos() * (j * pi2 / slices).sin(),
                (pi34 + (PI / (rings + 1.)) * i).sin(),
                (pi34 + (PI / (rings + 1.)) * i).cos() * (j * pi2 / slices).cos(),
            );
            let uv1 = vec2(i / rings, j / slices);
            let v2 = vec3(
                (pi34 + (PI / (rings + 1.)) * (i + 1.)).cos() * ((j + 1.) * pi2 / slices).sin(),
                (pi34 + (PI / (rings + 1.)) * (i + 1.)).sin(),
                (pi34 + (PI / (rings + 1.)) * (i + 1.)).cos() * ((j + 1.) * pi2 / slices).cos(),
            );
            let uv2 = vec2((i + 1.) / rings, (j + 1.) / slices);
            let v3 = vec3(
                (pi34 + (PI / (rings + 1.)) * (i + 1.)).cos() * (j * pi2 / slices).sin(),
                (pi34 + (PI / (rings + 1.)) * (i + 1.)).sin(),
                (pi34 + (PI / (rings + 1.)) * (i + 1.)).cos() * (j * pi2 / slices).cos(),
            );
            let uv3 = vec2((i + 1.) / rings, j / slices);

            context.gl.geometry(
                &[
                    Vertex::new2(v1 * scale + center, uv1, color),
                    Vertex::new2(v2 * scale + center, uv2, color),
                    Vertex::new2(v3 * scale + center, uv3, color),
                ],
                &[0, 1, 2],
            );

            let v1 = vec3(
                (pi34 + (PI / (rings + 1.)) * i).cos() * (j * pi2 / slices).sin(),
                (pi34 + (PI / (rings + 1.)) * i).sin(),
                (pi34 + (PI / (rings + 1.)) * i).cos() * (j * pi2 / slices).cos(),
            );
            let uv1 = vec2(i / rings, j / slices);
            let v2 = vec3(
                (pi34 + (PI / (rings + 1.)) * (i)).cos() * ((j + 1.) * pi2 / slices).sin(),
                (pi34 + (PI / (rings + 1.)) * (i)).sin(),
                (pi34 + (PI / (rings + 1.)) * (i)).cos() * ((j + 1.) * pi2 / slices).cos(),
            );
            let uv2 = vec2(i / rings, (j + 1.) / slices);
            let v3 = vec3(
                (pi34 + (PI / (rings + 1.)) * (i + 1.)).cos() * ((j + 1.) * pi2 / slices).sin(),
                (pi34 + (PI / (rings + 1.)) * (i + 1.)).sin(),
                (pi34 + (PI / (rings + 1.)) * (i + 1.)).cos() * ((j + 1.) * pi2 / slices).cos(),
            );
            let uv3 = vec2((i + 1.) / rings, (j + 1.) / slices);

            context.gl.geometry(
                &[
                    Vertex::new2(v1 * scale + center, uv1, color),
                    Vertex::new2(v2 * scale + center, uv2, color),
                    Vertex::new2(v3 * scale + center, uv3, color),
                ],
                &[0, 1, 2],
            );
        }
    }
}

#[derive(Debug, Clone)]
pub struct DrawCylinderParams {
    pub sides: usize,
    pub draw_mode: DrawMode,
}

impl Default for DrawCylinderParams {
    fn default() -> DrawCylinderParams {
        DrawCylinderParams {
            sides: 16,
            draw_mode: DrawMode::Triangles,
        }
    }
}

pub fn draw_cylinder(
    position: Vec3,
    radius_top: f32,
    radius_bottom: f32,
    height: f32,
    texture: Option<&Texture2D>,
    color: Color,
) {
    draw_cylinder_ex(
        position,
        radius_top,
        radius_bottom,
        height,
        texture,
        color,
        Default::default(),
    );
}

pub fn draw_cylinder_wires(
    position: Vec3,
    radius_top: f32,
    radius_bottom: f32,
    height: f32,
    texture: Option<&Texture2D>,
    color: Color,
) {
    let params = DrawCylinderParams {
        draw_mode: DrawMode::Lines,
        ..Default::default()
    };
    draw_cylinder_ex(
        position,
        radius_top,
        radius_bottom,
        height,
        texture,
        color,
        params,
    );
}

//Note: can also be used to draw a cone by setting radius_top or radius_bottom to 0
pub fn draw_cylinder_ex(
    position: Vec3,
    radius_top: f32,
    radius_bottom: f32,
    height: f32,
    texture: Option<&Texture2D>,
    color: Color,
    params: DrawCylinderParams,
) {
    let context = get_context();

    let sides = params.sides;

    context.gl.texture(texture);
    context.gl.draw_mode(params.draw_mode);

    use std::f32::consts::PI;
    let angle_step = PI * 2.0 / sides as f32;
    //draw body
    for i in 0..sides + 1 {
        let i = i as f32;
        //bottom left
        let v1 = vec3(
            (i * angle_step).sin() * radius_bottom,
            0.0,
            (i * angle_step).cos() * radius_bottom,
        );
        //bottom right
        let v2 = vec3(
            ((i + 1.0) * angle_step).sin() * radius_bottom,
            0.0,
            ((i + 1.0) * angle_step).cos() * radius_bottom,
        );
        //top right
        let v3 = vec3(
            ((i + 1.0) * angle_step).sin() * radius_top,
            height,
            ((i + 1.0) * angle_step).cos() * radius_top,
        );

        context.gl.geometry(
            &[
                Vertex::new2(v1 + position, vec2(0.0, 0.0), color),
                Vertex::new2(v2 + position, vec2(1.0, 0.0), color),
                Vertex::new2(v3 + position, vec2(1.0, 1.0), color),
            ],
            &[0, 1, 2],
        );

        //top left
        let v1 = vec3(
            (i * angle_step).sin() * radius_top,
            height,
            (i * angle_step).cos() * radius_top,
        );
        //bottom left
        let v2 = vec3(
            (i * angle_step).sin() * radius_bottom,
            0.0,
            (i * angle_step).cos() * radius_bottom,
        );
        //top right
        let v3 = vec3(
            ((i + 1.0) * angle_step).sin() * radius_top,
            height,
            ((i + 1.0) * angle_step).cos() * radius_top,
        );

        context.gl.geometry(
            &[
                Vertex::new2(v1 + position, vec2(0.0, 0.0), color),
                Vertex::new2(v2 + position, vec2(1.0, 0.0), color),
                Vertex::new2(v3 + position, vec2(1.0, 1.0), color),
            ],
            &[0, 1, 2],
        );
    }

    //draw cap
    for i in 0..sides + 1 {
        let i = i as f32;
        let v1 = vec3(0.0, height, 0.0);
        let v2 = vec3(
            (i * angle_step).sin() * radius_top,
            height,
            (i * angle_step).cos() * radius_top,
        );
        let v3 = vec3(
            ((i + 1.0) * angle_step).sin() * radius_top,
            height,
            ((i + 1.0) * angle_step).cos() * radius_top,
        );

        context.gl.geometry(
            &[
                Vertex::new2(v1 + position, vec2(0.0, 0.0), color),
                Vertex::new2(v2 + position, vec2(1.0, 0.0), color),
                Vertex::new2(v3 + position, vec2(1.0, 1.0), color),
            ],
            &[0, 1, 2],
        );
    }

    //draw base
    for i in 0..sides + 1 {
        let i = i as f32;
        let v1 = vec3(0.0, 0.0, 0.0);
        let v2 = vec3(
            (i * angle_step).sin() * radius_bottom,
            0.0,
            (i * angle_step).cos() * radius_bottom,
        );
        let v3 = vec3(
            ((i + 1.0) * angle_step).sin() * radius_bottom,
            0.0,
            ((i + 1.0) * angle_step).cos() * radius_bottom,
        );

        context.gl.geometry(
            &[
                Vertex::new2(v1 + position, vec2(0.0, 0.0), color),
                Vertex::new2(v2 + position, vec2(1.0, 0.0), color),
                Vertex::new2(v3 + position, vec2(1.0, 1.0), color),
            ],
            &[0, 1, 2],
        );
    }
}

```

`src/prelude.rs`:

```rs
//! Most common types that can be glob-imported `use macroquad::prelude::*` for convenience.

pub use crate::camera::*;
pub use crate::file::*;
pub use crate::input::*;
pub use crate::material::*;
pub use crate::math::*;
pub use crate::models::*;
pub use crate::shapes::*;
pub use crate::text::*;
pub use crate::texture::*;
pub use crate::time::*;
pub use crate::window::*;

pub use crate::color::{colors::*, Color};
pub use crate::quad_gl::{DrawMode, GlPipeline, QuadGl};
pub use glam;
pub use miniquad::{
    conf::Conf, Comparison, PipelineParams, ShaderError, ShaderSource, UniformDesc, UniformType,
};
pub use quad_rand as rand;

pub use crate::experimental::*;

pub use crate::logging::*;

pub use crate::{color_u8, DroppedFile};

pub use image::ImageFormat;

```

`src/quad_gl.rs`:

```rs
//! Legacy module, code should be either removed or moved to different modules

use miniquad::*;

pub use miniquad::{FilterMode, TextureId as MiniquadTexture, UniformDesc};

use crate::{color::Color, logging::warn, telemetry, texture::Texture2D, tobytes::ToBytes, Error};

use std::collections::BTreeMap;

pub(crate) use crate::models::Vertex;

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum DrawMode {
    Triangles,
    Lines,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct GlPipeline(usize);

struct DrawCall {
    vertices_count: usize,
    indices_count: usize,
    vertices_start: usize,
    indices_start: usize,

    clip: Option<(i32, i32, i32, i32)>,
    viewport: Option<(i32, i32, i32, i32)>,
    texture: Option<miniquad::TextureId>,

    model: glam::Mat4,

    draw_mode: DrawMode,
    pipeline: GlPipeline,
    uniforms: Option<Vec<u8>>,
    render_pass: Option<RenderPass>,
    capture: bool,
}

impl DrawCall {
    const fn new(
        texture: Option<miniquad::TextureId>,
        model: glam::Mat4,
        draw_mode: DrawMode,
        pipeline: GlPipeline,
        uniforms: Option<Vec<u8>>,
        render_pass: Option<RenderPass>,
    ) -> DrawCall {
        DrawCall {
            vertices_start: 0,
            indices_start: 0,
            vertices_count: 0,
            indices_count: 0,
            viewport: None,
            clip: None,
            texture,
            model,
            draw_mode,
            pipeline,
            uniforms,
            render_pass,
            capture: false,
        }
    }
}

struct MagicSnapshotter {
    pipeline: Pipeline,
    bindings: Bindings,
    pass: Option<RenderPass>,

    screen_texture: Option<miniquad::TextureId>,
}

mod snapshotter_shader {
    use miniquad::{ShaderMeta, UniformBlockLayout};

    pub const VERTEX: &str = r#"#version 100
    attribute vec2 position;
    attribute vec2 texcoord;

    varying lowp vec2 uv;

    void main() {
        gl_Position = vec4(position, 0, 1);
        uv = texcoord;
    }"#;

    pub const FRAGMENT: &str = r#"#version 100
    varying lowp vec2 uv;

    uniform sampler2D Texture;

    void main() {
        gl_FragColor = texture2D(Texture, uv);
    }"#;

    pub const METAL: &str = r#"#include <metal_stdlib>
    using namespace metal;

    struct Vertex
    {
        float2 position    [[attribute(0)]];
        float2 texcoord    [[attribute(1)]];
    };

    struct RasterizerData
    {
        float4 position [[position]];
        float2 uv [[user(locn1)]];
    };

    vertex RasterizerData vertexShader(Vertex v [[stage_in]])
    {
        RasterizerData out;

        out.position = float4(v.position, 0, 1);
        out.uv = v.texcoord;

        return out;
    }

    fragment float4 fragmentShader(RasterizerData in [[stage_in]], texture2d<float> tex [[texture(0)]], sampler texSmplr [[sampler(0)]])
    {
        return tex.sample(texSmplr, in.uv);
    }"#;

    pub fn meta() -> ShaderMeta {
        ShaderMeta {
            images: vec!["Texture".to_string()],
            uniforms: UniformBlockLayout { uniforms: vec![] },
        }
    }
}

impl MagicSnapshotter {
    fn new(ctx: &mut dyn RenderingBackend) -> MagicSnapshotter {
        let shader = ctx
            .new_shader(
                match ctx.info().backend {
                    Backend::OpenGl => ShaderSource::Glsl {
                        vertex: snapshotter_shader::VERTEX,
                        fragment: snapshotter_shader::FRAGMENT,
                    },
                    Backend::Metal => ShaderSource::Msl {
                        program: snapshotter_shader::METAL,
                    },
                },
                snapshotter_shader::meta(),
            )
            .unwrap_or_else(|e| panic!("Failed to load shader: {e}"));

        let pipeline = ctx.new_pipeline(
            &[BufferLayout::default()],
            &[
                VertexAttribute::new("position", VertexFormat::Float2),
                VertexAttribute::new("texcoord", VertexFormat::Float2),
            ],
            shader,
            PipelineParams::default(),
        );

        #[rustfmt::skip]
        let vertices: [f32; 16] = [
             -1.0, -1.0, 0., 0.,
             1.0, -1.0, 1., 0. ,
             1.0,  1.0, 1., 1. ,
            -1.0,  1.0, 0., 1. ,
        ];
        let vertex_buffer = ctx.new_buffer(
            BufferType::VertexBuffer,
            BufferUsage::Immutable,
            BufferSource::slice(&vertices),
        );

        let indices: [u16; 6] = [0, 1, 2, 0, 2, 3];
        let index_buffer = ctx.new_buffer(
            BufferType::IndexBuffer,
            BufferUsage::Immutable,
            BufferSource::slice(&indices),
        );

        let bindings = Bindings {
            vertex_buffers: vec![vertex_buffer],
            index_buffer,
            images: vec![ctx.new_texture_from_rgba8(1, 1, &[0, 0, 0, 0])],
        };

        MagicSnapshotter {
            pipeline,
            bindings,
            pass: None,
            screen_texture: None,
        }
    }

    fn snapshot(&mut self, ctx: &mut dyn RenderingBackend, camera_render_pass: Option<RenderPass>) {
        if let Some(camera_render_pass) = camera_render_pass {
            let texture = ctx.render_pass_texture(camera_render_pass);
            if self.pass.is_none() {
                let miniquad::TextureParams {
                    width,
                    height,
                    format,
                    ..
                } = ctx.texture_params(texture);
                let color_img = ctx.new_render_texture(TextureParams {
                    width,
                    height,
                    format,
                    ..Default::default()
                });

                self.pass = Some(ctx.new_render_pass(color_img, None));
                self.screen_texture = Some(color_img);
            }

            if self.bindings.images.len() == 0 {
                self.bindings.images.push(texture);
            } else {
                self.bindings.images[0] = texture;
            }
            ctx.begin_pass(
                Some(self.pass.unwrap()),
                PassAction::clear_color(1.0, 0.0, 1.0, 1.),
            );
            ctx.apply_pipeline(&self.pipeline);
            ctx.apply_bindings(&self.bindings);
            ctx.draw(0, 6, 1);
            ctx.end_render_pass();
        } else {
            let (screen_width, screen_height) = miniquad::window::screen_size();
            if self.screen_texture.is_none()
                || self
                    .screen_texture
                    .map(|t| {
                        let (w, h) = ctx.texture_size(t);
                        w != screen_width as _ || h != screen_height as _
                    })
                    .unwrap_or(false)
            {
                self.screen_texture = Some(ctx.new_render_texture(TextureParams {
                    width: screen_width as _,
                    height: screen_height as _,
                    ..Default::default()
                }));
            }

            let texture = self.screen_texture.unwrap();
            Texture2D::unmanaged(texture).grab_screen();
        }
    }
}

struct GlState {
    texture: Option<miniquad::TextureId>,
    draw_mode: DrawMode,
    clip: Option<(i32, i32, i32, i32)>,
    viewport: Option<(i32, i32, i32, i32)>,
    model_stack: Vec<glam::Mat4>,
    pipeline: Option<GlPipeline>,
    depth_test_enable: bool,

    break_batching: bool,
    snapshotter: MagicSnapshotter,

    render_pass: Option<RenderPass>,
    capture: bool,
}

impl GlState {
    fn model(&self) -> glam::Mat4 {
        *self.model_stack.last().unwrap()
    }
}

#[derive(Clone, Debug)]
struct Uniform {
    name: String,
    uniform_type: UniformType,
    byte_offset: usize,
    byte_size: usize,
}

#[derive(Clone)]
struct PipelineExt {
    pipeline: miniquad::Pipeline,
    wants_screen_texture: bool,
    uniforms: Vec<Uniform>,
    uniforms_data: Vec<u8>,
    textures: Vec<String>,
    textures_data: BTreeMap<String, MiniquadTexture>,
}

impl PipelineExt {
    fn set_uniform<T>(&mut self, name: &str, uniform: T) {
        let uniform_meta = self.uniforms.iter().find(
            |Uniform {
                 name: uniform_name, ..
             }| uniform_name == name,
        );
        if uniform_meta.is_none() {
            warn!("Trying to set non-existing uniform: {}", name);
            return;
        }
        let uniform_meta = uniform_meta.unwrap();
        let uniform_format = uniform_meta.uniform_type;
        let uniform_byte_size = uniform_format.size();
        let uniform_byte_offset = uniform_meta.byte_offset;

        if size_of::<T>() != uniform_byte_size {
            warn!(
                "Trying to set uniform {} sized {} bytes value of {} bytes",
                name,
                uniform_byte_size,
                size_of::<T>()
            );
            return;
        }
        if uniform_byte_size != uniform_meta.byte_size {
            warn!("set_uniform do not support uniform arrays");
            return;
        }
        macro_rules! transmute_uniform {
            ($uniform_size:expr, $byte_offset:expr, $n:expr) => {
                if $uniform_size == $n {
                    let data: [u8; $n] = unsafe { std::mem::transmute_copy(&uniform) };

                    for i in 0..$uniform_size {
                        self.uniforms_data[$byte_offset + i] = data[i];
                    }
                }
            };
        }
        transmute_uniform!(uniform_byte_size, uniform_byte_offset, 4);
        transmute_uniform!(uniform_byte_size, uniform_byte_offset, 8);
        transmute_uniform!(uniform_byte_size, uniform_byte_offset, 12);
        transmute_uniform!(uniform_byte_size, uniform_byte_offset, 16);
        transmute_uniform!(uniform_byte_size, uniform_byte_offset, 64);
    }

    fn set_uniform_array<T: ToBytes>(&mut self, name: &str, uniform: &[T]) {
        let uniform_meta = self.uniforms.iter().find(
            |Uniform {
                 name: uniform_name, ..
             }| uniform_name == name,
        );
        if uniform_meta.is_none() {
            warn!("Trying to set non-existing uniform: {}", name);
            return;
        }
        let uniform_meta = uniform_meta.unwrap();
        let uniform_byte_size = uniform_meta.byte_size;
        let uniform_byte_offset = uniform_meta.byte_offset;

        let data = uniform.to_bytes();
        if data.len() != uniform_byte_size {
            warn!(
                "Trying to set uniform {} sized {} bytes value of {} bytes",
                name,
                uniform_byte_size,
                size_of::<T>()
            );
            return;
        }
        for i in 0..uniform_byte_size {
            self.uniforms_data[uniform_byte_offset + i] = data[i];
        }
    }
}

struct PipelinesStorage {
    pipelines: [Option<PipelineExt>; Self::MAX_PIPELINES],
    pipelines_amount: usize,
}

impl PipelinesStorage {
    const MAX_PIPELINES: usize = 32;
    const TRIANGLES_PIPELINE: GlPipeline = GlPipeline(0);
    const LINES_PIPELINE: GlPipeline = GlPipeline(1);
    const TRIANGLES_DEPTH_PIPELINE: GlPipeline = GlPipeline(2);
    const LINES_DEPTH_PIPELINE: GlPipeline = GlPipeline(3);

    fn new(ctx: &mut dyn RenderingBackend) -> PipelinesStorage {
        let shader = ctx
            .new_shader(
                match ctx.info().backend {
                    Backend::OpenGl => ShaderSource::Glsl {
                        vertex: shader::VERTEX,
                        fragment: shader::FRAGMENT,
                    },
                    Backend::Metal => ShaderSource::Msl {
                        program: shader::METAL,
                    },
                },
                shader::meta(),
            )
            .unwrap_or_else(|e| panic!("Failed to load shader: {e}"));

        let params = PipelineParams {
            color_blend: Some(BlendState::new(
                Equation::Add,
                BlendFactor::Value(BlendValue::SourceAlpha),
                BlendFactor::OneMinusValue(BlendValue::SourceAlpha),
            )),
            ..Default::default()
        };

        let mut storage = PipelinesStorage {
            pipelines: Default::default(),
            pipelines_amount: 0,
        };

        let triangles_pipeline = storage.make_pipeline(
            ctx,
            shader,
            PipelineParams {
                primitive_type: PrimitiveType::Triangles,
                ..params
            },
            false,
            vec![],
            vec![],
        );
        assert_eq!(triangles_pipeline, Self::TRIANGLES_PIPELINE);

        let lines_pipeline = storage.make_pipeline(
            ctx,
            shader,
            PipelineParams {
                primitive_type: PrimitiveType::Lines,
                ..params
            },
            false,
            vec![],
            vec![],
        );
        assert_eq!(lines_pipeline, Self::LINES_PIPELINE);

        let triangles_depth_pipeline = storage.make_pipeline(
            ctx,
            shader,
            PipelineParams {
                depth_write: true,
                depth_test: Comparison::LessOrEqual,
                primitive_type: PrimitiveType::Triangles,
                ..params
            },
            false,
            vec![],
            vec![],
        );
        assert_eq!(triangles_depth_pipeline, Self::TRIANGLES_DEPTH_PIPELINE);

        let lines_depth_pipeline = storage.make_pipeline(
            ctx,
            shader,
            PipelineParams {
                depth_write: true,
                depth_test: Comparison::LessOrEqual,
                primitive_type: PrimitiveType::Lines,
                ..params
            },
            false,
            vec![],
            vec![],
        );
        assert_eq!(lines_depth_pipeline, Self::LINES_DEPTH_PIPELINE);

        storage
    }

    fn make_pipeline(
        &mut self,
        ctx: &mut dyn RenderingBackend,
        shader: ShaderId,
        params: PipelineParams,
        wants_screen_texture: bool,
        mut uniforms: Vec<UniformDesc>,
        textures: Vec<String>,
    ) -> GlPipeline {
        let pipeline = ctx.new_pipeline(
            &[BufferLayout::default()],
            &[
                VertexAttribute::new("position", VertexFormat::Float3),
                VertexAttribute::new("texcoord", VertexFormat::Float2),
                VertexAttribute::new("color0", VertexFormat::Byte4),
                VertexAttribute::new("normal", VertexFormat::Float4),
            ],
            shader,
            params,
        );

        let id = self
            .pipelines
            .iter()
            .position(|p| p.is_none())
            .unwrap_or_else(|| panic!("Pipelines amount exceeded"));

        let mut max_offset = 0;

        for (name, kind) in shader::uniforms().into_iter().rev() {
            uniforms.insert(0, UniformDesc::new(name, kind));
        }

        let uniforms = uniforms
            .iter()
            .scan(0, |offset, uniform| {
                let byte_size = uniform.uniform_type.size() * uniform.array_count;
                let uniform = Uniform {
                    name: uniform.name.clone(),
                    uniform_type: uniform.uniform_type,
                    byte_size,
                    byte_offset: *offset,
                };
                *offset += byte_size;
                max_offset = *offset;

                Some(uniform)
            })
            .collect();

        self.pipelines[id] = Some(PipelineExt {
            pipeline,
            wants_screen_texture,
            uniforms,
            uniforms_data: vec![0; max_offset],
            textures,
            textures_data: BTreeMap::new(),
        });
        self.pipelines_amount += 1;

        GlPipeline(id)
    }

    const fn get(&self, draw_mode: DrawMode, depth_enabled: bool) -> GlPipeline {
        match (draw_mode, depth_enabled) {
            (DrawMode::Triangles, false) => Self::TRIANGLES_PIPELINE,
            (DrawMode::Triangles, true) => Self::TRIANGLES_DEPTH_PIPELINE,
            (DrawMode::Lines, false) => Self::LINES_PIPELINE,
            (DrawMode::Lines, true) => Self::LINES_DEPTH_PIPELINE,
        }
    }

    fn get_quad_pipeline_mut(&mut self, pip: GlPipeline) -> &mut PipelineExt {
        self.pipelines[pip.0].as_mut().unwrap()
    }

    fn delete_pipeline(&mut self, pip: GlPipeline) {
        self.pipelines[pip.0] = None;
    }
}

pub struct QuadGl {
    pipelines: PipelinesStorage,

    draw_calls: Vec<DrawCall>,
    draw_calls_bindings: Vec<Bindings>,
    draw_calls_count: usize,
    state: GlState,
    start_time: f64,

    pub(crate) white_texture: miniquad::TextureId,
    max_vertices: usize,
    max_indices: usize,

    batch_vertex_buffer: Vec<Vertex>,
    batch_index_buffer: Vec<u16>,
}

impl QuadGl {
    pub fn new(
        ctx: &mut dyn miniquad::RenderingBackend,
        max_vertices: usize,
        max_indices: usize,
    ) -> QuadGl {
        let white_texture = ctx.new_texture_from_rgba8(1, 1, &[255, 255, 255, 255]);

        QuadGl {
            pipelines: PipelinesStorage::new(ctx),
            state: GlState {
                clip: None,
                viewport: None,
                texture: None,
                model_stack: vec![glam::Mat4::IDENTITY],
                draw_mode: DrawMode::Triangles,
                pipeline: None,
                break_batching: false,
                depth_test_enable: false,
                snapshotter: MagicSnapshotter::new(ctx),
                render_pass: None,
                capture: false,
            },
            draw_calls: Vec::with_capacity(200),
            draw_calls_bindings: Vec::with_capacity(200),
            draw_calls_count: 0,
            start_time: miniquad::date::now(),

            white_texture,
            batch_vertex_buffer: Vec::with_capacity(max_vertices),
            batch_index_buffer: Vec::with_capacity(max_indices),
            max_vertices,
            max_indices,
        }
    }

    pub fn make_pipeline(
        &mut self,
        ctx: &mut dyn miniquad::RenderingBackend,
        shader: miniquad::ShaderSource,
        params: PipelineParams,
        uniforms: Vec<UniformDesc>,
        textures: Vec<String>,
    ) -> Result<GlPipeline, Error> {
        let mut shader_meta: ShaderMeta = shader::meta();

        for uniform in &uniforms {
            shader_meta.uniforms.uniforms.push(uniform.clone());
        }

        for texture in &textures {
            if texture == "Texture" {
                panic!(
                    "you can't use name `Texture` for your texture. This name is reserved for the texture that will be drawn with that material"
                );
            }
            if texture == "_ScreenTexture" {
                panic!(
                    "you can't use name `_ScreenTexture` for your texture in shaders. This name is reserved for screen texture"
                );
            }
            shader_meta.images.push(texture.clone());
        }

        let source = match shader {
            ShaderSource::Glsl { fragment, .. } => fragment,
            ShaderSource::Msl { program } => program,
        };
        let wants_screen_texture = source.contains("_ScreenTexture");
        let shader = ctx.new_shader(shader, shader_meta)?;
        Ok(self.pipelines.make_pipeline(
            ctx,
            shader,
            params,
            wants_screen_texture,
            uniforms,
            textures,
        ))
    }

    pub(crate) fn clear(&mut self, ctx: &mut dyn miniquad::RenderingBackend, color: Color) {
        let clear = PassAction::clear_color(color.r, color.g, color.b, color.a);

        if let Some(current_pass) = self.state.render_pass {
            ctx.begin_pass(Some(current_pass), clear);
        } else {
            ctx.begin_default_pass(clear);
        }
        ctx.end_render_pass();

        self.clear_draw_calls();
    }

    /// Reset only draw calls state
    pub fn clear_draw_calls(&mut self) {
        self.draw_calls_count = 0;
    }

    /// Reset internal state to known default
    pub fn reset(&mut self) {
        self.state.clip = None;
        self.state.texture = None;
        self.state.model_stack = vec![glam::Mat4::IDENTITY];

        self.draw_calls_count = 0;
    }

    pub fn draw(&mut self, ctx: &mut dyn miniquad::RenderingBackend, projection: glam::Mat4) {
        let white_texture = self.white_texture;

        for _ in 0..self.draw_calls.len() - self.draw_calls_bindings.len() {
            let vertex_buffer = ctx.new_buffer(
                BufferType::VertexBuffer,
                BufferUsage::Stream,
                BufferSource::empty::<Vertex>(self.max_vertices),
            );
            let index_buffer = ctx.new_buffer(
                BufferType::IndexBuffer,
                BufferUsage::Stream,
                BufferSource::empty::<u16>(self.max_indices),
            );
            let bindings = Bindings {
                vertex_buffers: vec![vertex_buffer],
                index_buffer,
                images: vec![white_texture, white_texture],
            };

            self.draw_calls_bindings.push(bindings);
        }
        assert_eq!(self.draw_calls_bindings.len(), self.draw_calls.len());

        let (screen_width, screen_height) = miniquad::window::screen_size();
        let time = (miniquad::date::now() - self.start_time) as f32;
        let time = glam::vec4(time, time.sin(), time.cos(), 0.);

        for (dc, bindings) in self.draw_calls[0..self.draw_calls_count]
            .iter_mut()
            .zip(self.draw_calls_bindings.iter_mut())
        {
            let pipeline = self.pipelines.get_quad_pipeline_mut(dc.pipeline);

            let (width, height) = if let Some(render_pass) = dc.render_pass {
                let render_texture = ctx.render_pass_texture(render_pass);
                let (width, height) = ctx.texture_size(render_texture);
                (width, height)
            } else {
                (screen_width as u32, screen_height as u32)
            };

            if pipeline.wants_screen_texture {
                self.state.snapshotter.snapshot(ctx, dc.render_pass);
            }

            if let Some(render_pass) = dc.render_pass {
                ctx.begin_pass(Some(render_pass), PassAction::Nothing);
            } else {
                ctx.begin_default_pass(PassAction::Nothing);
            }

            ctx.buffer_update(
                bindings.vertex_buffers[0],
                BufferSource::slice(
                    &self.batch_vertex_buffer
                        [dc.vertices_start..(dc.vertices_start + dc.vertices_count)],
                ),
            );
            ctx.buffer_update(
                bindings.index_buffer,
                BufferSource::slice(
                    &self.batch_index_buffer
                        [dc.indices_start..(dc.indices_start + dc.indices_count)],
                ),
            );

            bindings.images[0] = dc.texture.unwrap_or(white_texture);
            bindings.images[1] = self
                .state
                .snapshotter
                .screen_texture
                .unwrap_or(white_texture);
            bindings
                .images
                .resize(2 + pipeline.textures.len(), white_texture);

            for (pos, name) in pipeline.textures.iter().enumerate() {
                if let Some(texture) = pipeline.textures_data.get(name).copied() {
                    bindings.images[2 + pos] = texture;
                }
            }

            ctx.apply_pipeline(&pipeline.pipeline);
            if let Some((x, y, w, h)) = dc.viewport {
                ctx.apply_viewport(x, y, w, h);
            } else {
                ctx.apply_viewport(0, 0, width as i32, height as i32);
            }
            if let Some(clip) = dc.clip {
                ctx.apply_scissor_rect(clip.0, height as i32 - (clip.1 + clip.3), clip.2, clip.3);
            } else {
                ctx.apply_scissor_rect(0, 0, width as i32, height as i32);
            }
            ctx.apply_bindings(bindings);

            if let Some(ref uniforms) = dc.uniforms {
                for i in 0..uniforms.len() {
                    pipeline.uniforms_data[i] = uniforms[i];
                }
            }
            pipeline.set_uniform("Projection", projection);
            pipeline.set_uniform("Model", dc.model);
            pipeline.set_uniform("_Time", time);
            ctx.apply_uniforms_from_bytes(
                pipeline.uniforms_data.as_ptr(),
                pipeline.uniforms_data.len(),
            );
            ctx.draw(0, dc.indices_count as i32, 1);
            ctx.end_render_pass();

            if dc.capture {
                telemetry::track_drawcall(&pipeline.pipeline, bindings, dc.indices_count);
            }

            dc.vertices_count = 0;
            dc.indices_count = 0;
            dc.vertices_start = 0;
            dc.indices_start = 0;
        }

        self.draw_calls_count = 0;
        self.batch_index_buffer.clear();
        self.batch_vertex_buffer.clear();
    }

    pub(crate) fn capture(&mut self, capture: bool) {
        self.state.capture = capture;
    }

    pub fn get_projection_matrix(&self) -> glam::Mat4 {
        // get_projection_matrix is a way plugins used to get macroquad's current projection
        // back in the days when projection was a part of static batcher
        // now it is not, so here we go with this hack

        crate::get_context().projection_matrix()
    }

    pub const fn get_active_render_pass(&self) -> Option<RenderPass> {
        self.state.render_pass
    }

    pub const fn is_depth_test_enabled(&self) -> bool {
        self.state.depth_test_enable
    }

    pub fn render_pass(&mut self, render_pass: Option<RenderPass>) {
        self.state.render_pass = render_pass;
    }

    pub fn depth_test(&mut self, enable: bool) {
        self.state.depth_test_enable = enable;
    }

    pub fn texture(&mut self, texture: Option<&Texture2D>) {
        let ctx = crate::get_context();
        self.state.texture = texture.map(|t| ctx.raw_miniquad_id(&t.texture));
    }

    pub fn scissor(&mut self, clip: Option<(i32, i32, i32, i32)>) {
        self.state.clip = clip;
    }

    pub fn viewport(&mut self, viewport: Option<(i32, i32, i32, i32)>) {
        self.state.viewport = viewport;
    }

    pub fn get_viewport(&self) -> (i32, i32, i32, i32) {
        self.state.viewport.unwrap_or((
            0,
            0,
            crate::window::screen_width() as _,
            crate::window::screen_height() as _,
        ))
    }

    pub fn push_model_matrix(&mut self, matrix: glam::Mat4) {
        self.state.model_stack.push(self.state.model() * matrix);
    }

    pub fn pop_model_matrix(&mut self) {
        if self.state.model_stack.len() > 1 {
            self.state.model_stack.pop();
        }
    }

    pub fn pipeline(&mut self, pipeline: Option<GlPipeline>) {
        if self.state.pipeline == pipeline {
            return;
        }

        self.state.break_batching = true;
        self.state.pipeline = pipeline;
    }

    pub fn draw_mode(&mut self, mode: DrawMode) {
        self.state.draw_mode = mode;
    }

    pub fn geometry(&mut self, vertices: &[Vertex], indices: &[u16]) {
        if vertices.len() >= self.max_vertices || indices.len() >= self.max_indices {
            warn!("geometry() exceeded max drawcall size, clamping");
        }

        let vertices = &vertices[0..self.max_vertices.min(vertices.len())];
        let indices = &indices[0..self.max_indices.min(indices.len())];

        let pip = self.state.pipeline.unwrap_or(
            self.pipelines
                .get(self.state.draw_mode, self.state.depth_test_enable),
        );

        let previous_dc_ix = if self.draw_calls_count == 0 {
            None
        } else {
            Some(self.draw_calls_count - 1)
        };
        let previous_dc = previous_dc_ix.and_then(|ix| self.draw_calls.get(ix));

        if previous_dc.map_or(true, |draw_call| {
            draw_call.texture != self.state.texture
                || draw_call.clip != self.state.clip
                || draw_call.viewport != self.state.viewport
                || draw_call.model != self.state.model()
                || draw_call.pipeline != pip
                || draw_call.render_pass != self.state.render_pass
                || draw_call.draw_mode != self.state.draw_mode
                || draw_call.vertices_count >= self.max_vertices - vertices.len()
                || draw_call.indices_count >= self.max_indices - indices.len()
                || draw_call.capture != self.state.capture
                || self.state.break_batching
        }) {
            let uniforms = self.state.pipeline.map_or(None, |pipeline| {
                Some(
                    self.pipelines
                        .get_quad_pipeline_mut(pipeline)
                        .uniforms_data
                        .clone(),
                )
            });

            if self.draw_calls_count >= self.draw_calls.len() {
                self.draw_calls.push(DrawCall::new(
                    self.state.texture,
                    self.state.model(),
                    self.state.draw_mode,
                    pip,
                    uniforms.clone(),
                    self.state.render_pass,
                ));
            }
            self.draw_calls[self.draw_calls_count].texture = self.state.texture;
            self.draw_calls[self.draw_calls_count].uniforms = uniforms;
            self.draw_calls[self.draw_calls_count].vertices_count = 0;
            self.draw_calls[self.draw_calls_count].indices_count = 0;
            self.draw_calls[self.draw_calls_count].clip = self.state.clip;
            self.draw_calls[self.draw_calls_count].viewport = self.state.viewport;
            self.draw_calls[self.draw_calls_count].model = self.state.model();
            self.draw_calls[self.draw_calls_count].pipeline = pip;
            self.draw_calls[self.draw_calls_count].render_pass = self.state.render_pass;
            self.draw_calls[self.draw_calls_count].capture = self.state.capture;
            self.draw_calls[self.draw_calls_count].indices_start = self.batch_index_buffer.len();
            self.draw_calls[self.draw_calls_count].vertices_start = self.batch_vertex_buffer.len();

            self.draw_calls_count += 1;
            self.state.break_batching = false;
        };
        let dc = &mut self.draw_calls[self.draw_calls_count - 1];

        self.batch_vertex_buffer.extend(vertices);
        self.batch_index_buffer
            .extend(indices.iter().map(|x| *x + dc.vertices_count as u16));

        dc.vertices_count += vertices.len();
        dc.indices_count += indices.len();

        dc.texture = self.state.texture;
    }

    pub fn delete_pipeline(&mut self, pipeline: GlPipeline) {
        self.pipelines.delete_pipeline(pipeline);
    }

    pub fn set_uniform<T>(&mut self, pipeline: GlPipeline, name: &str, uniform: T) {
        self.state.break_batching = true;

        self.pipelines
            .get_quad_pipeline_mut(pipeline)
            .set_uniform(name, uniform);
    }
    pub fn set_uniform_array<T: ToBytes>(
        &mut self,
        pipeline: GlPipeline,
        name: &str,
        uniform: &[T],
    ) {
        self.state.break_batching = true;

        self.pipelines
            .get_quad_pipeline_mut(pipeline)
            .set_uniform_array(name, uniform);
    }

    pub fn set_texture(&mut self, pipeline: GlPipeline, name: &str, texture: Texture2D) {
        let pipeline = self.pipelines.get_quad_pipeline_mut(pipeline);
        pipeline
            .textures
            .iter()
            .find(|x| *x == name)
            .unwrap_or_else(|| {
                panic!(
                    "can't find texture with name '{}', there is only this names: {:?}",
                    name, pipeline.textures
                )
            });
        let quad_texture = texture.raw_miniquad_id();
        *pipeline
            .textures_data
            .entry(name.to_owned())
            .or_insert(quad_texture) = quad_texture;
    }

    pub(crate) fn update_drawcall_capacity(
        &mut self,
        ctx: &mut dyn miniquad::RenderingBackend,
        max_vertices: usize,
        max_indices: usize,
    ) {
        self.max_vertices = max_vertices;
        self.max_indices = max_indices;
        self.draw_calls_count = 0;

        for draw_call in &mut self.draw_calls {
            draw_call.indices_start = 0;
            draw_call.vertices_start = 0;
        }
        for binding in &mut self.draw_calls_bindings {
            ctx.delete_buffer(binding.index_buffer);
            for vertex_buffer in &binding.vertex_buffers {
                ctx.delete_buffer(*vertex_buffer);
            }
            let vertex_buffer = ctx.new_buffer(
                BufferType::VertexBuffer,
                BufferUsage::Stream,
                BufferSource::empty::<Vertex>(self.max_vertices),
            );
            let index_buffer = ctx.new_buffer(
                BufferType::IndexBuffer,
                BufferUsage::Stream,
                BufferSource::empty::<u16>(self.max_indices),
            );
            *binding = Bindings {
                vertex_buffers: vec![vertex_buffer],
                index_buffer,
                images: vec![self.white_texture, self.white_texture],
            };
        }
    }
}

mod shader {
    use miniquad::{ShaderMeta, UniformBlockLayout, UniformDesc, UniformType};

    pub const VERTEX: &str = r#"#version 100
    attribute vec3 position;
    attribute vec2 texcoord;
    attribute vec4 color0;
    attribute vec4 normal;

    varying lowp vec2 uv;
    varying lowp vec4 color;

    uniform mat4 Model;
    uniform mat4 Projection;

    void main() {
        gl_Position = Projection * Model * vec4(position, 1);
        color = color0 / 255.0;
        uv = texcoord;
    }"#;

    pub const FRAGMENT: &str = r#"#version 100
    varying lowp vec4 color;
    varying lowp vec2 uv;

    uniform sampler2D Texture;

    void main() {
        gl_FragColor = color * texture2D(Texture, uv) ;
    }"#;

    pub const METAL: &str = r#"
#include <metal_stdlib>
    using namespace metal;

    struct Uniforms
    {
        float4x4 Model;
        float4x4 Projection;
    };

    struct Vertex
    {
        float3 position    [[attribute(0)]];
        float2 texcoord    [[attribute(1)]];
        float4 color0      [[attribute(2)]];
    };

    struct RasterizerData
    {
        float4 position [[position]];
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
    };

    vertex RasterizerData vertexShader(Vertex v [[stage_in]], constant Uniforms& uniforms [[buffer(0)]])
    {
        RasterizerData out;

        out.position = uniforms.Model * uniforms.Projection * float4(v.position, 1);
        out.color = v.color0 / 255.0;
        out.uv = v.texcoord;

        return out;
    }

    fragment float4 fragmentShader(RasterizerData in [[stage_in]], texture2d<float> tex [[texture(0)]], sampler texSmplr [[sampler(0)]])
    {
        return in.color * tex.sample(texSmplr, in.uv);
    }
    "#;
    pub fn uniforms() -> Vec<(&'static str, UniformType)> {
        vec![
            ("Projection", UniformType::Mat4),
            ("Model", UniformType::Mat4),
            ("_Time", UniformType::Float4),
        ]
    }

    pub fn meta() -> ShaderMeta {
        ShaderMeta {
            images: vec!["Texture".to_string(), "_ScreenTexture".to_string()],
            uniforms: UniformBlockLayout {
                uniforms: uniforms()
                    .into_iter()
                    .map(|(name, kind)| UniformDesc::new(name, kind))
                    .collect(),
            },
        }
    }
}

```

`src/shapes.rs`:

```rs
//! 2D shapes rendering.

use crate::{color::Color, get_context};

use crate::quad_gl::{DrawMode, Vertex};
use glam::{vec2, vec3, vec4, Mat4, Vec2};

/// Draws a solid triangle between points `v1`, `v2`, and `v3` with a given `color`.
pub fn draw_triangle(v1: Vec2, v2: Vec2, v3: Vec2, color: Color) {
    let context = get_context();

    let vertices = [
        Vertex::new(v1.x, v1.y, 0., 0., 0., color),
        Vertex::new(v2.x, v2.y, 0., 0., 0., color),
        Vertex::new(v3.x, v3.y, 0., 0., 0., color),
    ];

    let indices: [u16; 3] = [0, 1, 2];

    context.gl.texture(None);
    context.gl.draw_mode(DrawMode::Triangles);
    context.gl.geometry(&vertices, &indices);
}

/// Draws a triangle outline between points `v1`, `v2`, and `v3` with a given line `thickness` and `color`.
pub fn draw_triangle_lines(v1: Vec2, v2: Vec2, v3: Vec2, thickness: f32, color: Color) {
    draw_line(v1.x, v1.y, v2.x, v2.y, thickness, color);
    draw_line(v2.x, v2.y, v3.x, v3.y, thickness, color);
    draw_line(v3.x, v3.y, v1.x, v1.y, thickness, color);
}

/// Draws a solid rectangle with its top-left corner at `[x, y]` with size `[w, h]` (width going to
/// the right, height going down), with a given `color`.
pub fn draw_rectangle(x: f32, y: f32, w: f32, h: f32, color: Color) {
    let context = get_context();

    #[rustfmt::skip]
    let vertices = [
        Vertex::new(x    , y    , 0., 0.0, 0.0, color),
        Vertex::new(x + w, y    , 0., 1.0, 0.0, color),
        Vertex::new(x + w, y + h, 0., 1.0, 1.0, color),
        Vertex::new(x    , y + h, 0., 0.0, 1.0, color),
    ];
    let indices: [u16; 6] = [0, 1, 2, 0, 2, 3];

    context.gl.texture(None);
    context.gl.draw_mode(DrawMode::Triangles);
    context.gl.geometry(&vertices, &indices);
}

/// Draws a rectangle outline with its top-left corner at `[x, y]` with size `[w, h]` (width going to
/// the right, height going down), with a given line `thickness` and `color`.
pub fn draw_rectangle_lines(x: f32, y: f32, w: f32, h: f32, thickness: f32, color: Color) {
    let context = get_context();
    let t = thickness / 2.;

    #[rustfmt::skip]
    let vertices = [
        Vertex::new(x    , y    , 0., 0.0, 1.0, color),
        Vertex::new(x + w, y    , 0., 1.0, 0.0, color),
        Vertex::new(x + w, y + h, 0., 1.0, 1.0, color),
        Vertex::new(x    , y + h, 0., 0.0, 0.0, color),
        //inner rectangle
        Vertex::new(x + t    , y + t    , 0., 0.0, 0.0, color),
        Vertex::new(x + w - t, y + t    , 0., 0.0, 0.0, color),
        Vertex::new(x + w - t, y + h - t, 0., 0.0, 0.0, color),
        Vertex::new(x + t    , y + h - t, 0., 0.0, 0.0, color),
    ];
    let indices: [u16; 24] = [
        0, 1, 4, 1, 4, 5, 1, 5, 6, 1, 2, 6, 3, 7, 2, 2, 7, 6, 0, 4, 3, 3, 4, 7,
    ];

    context.gl.texture(None);
    context.gl.draw_mode(DrawMode::Triangles);
    context.gl.geometry(&vertices, &indices);
}

pub fn draw_rectangle_lines_ex(
    x: f32,
    y: f32,
    w: f32,
    h: f32,
    thickness: f32,
    params: DrawRectangleParams,
) {
    let context = get_context();
    let tx = thickness / w;
    let ty = thickness / h;

    let transform_matrix = Mat4::from_translation(vec3(x, y, 0.0))
        * Mat4::from_axis_angle(vec3(0.0, 0.0, 1.0), params.rotation)
        * Mat4::from_scale(vec3(w, h, 1.0));

    #[rustfmt::skip]
    let v = [
        transform_matrix * vec4( 0.0 - params.offset.x,  0.0 - params.offset.y, 0.0, 1.0),
        transform_matrix * vec4( 0.0 - params.offset.x,  1.0 - params.offset.y, 0.0, 1.0),
        transform_matrix * vec4( 1.0 - params.offset.x,  1.0 - params.offset.y, 0.0, 1.0),
        transform_matrix * vec4( 1.0 - params.offset.x,  0.0 - params.offset.y, 0.0, 1.0),

        transform_matrix * vec4( 0.0 - params.offset.x + tx,  0.0 - params.offset.y + ty, 0.0, 1.0),
        transform_matrix * vec4( 0.0 - params.offset.x + tx,  1.0 - params.offset.y - ty, 0.0, 1.0),
        transform_matrix * vec4( 1.0 - params.offset.x - tx,  1.0 - params.offset.y - ty, 0.0, 1.0),
        transform_matrix * vec4( 1.0 - params.offset.x - tx,  0.0 - params.offset.y + ty, 0.0, 1.0),
    ];

    // TODO: fix UVs
    #[rustfmt::skip]
    let vertices = [
        Vertex::new(v[0].x, v[0].y, v[0].z, 0.0, 1.0, params.color),
        Vertex::new(v[1].x, v[1].y, v[1].z, 1.0, 0.0, params.color),
        Vertex::new(v[2].x, v[2].y, v[2].z, 1.0, 1.0, params.color),
        Vertex::new(v[3].x, v[3].y, v[3].z, 1.0, 0.0, params.color),

        Vertex::new(v[4].x, v[4].y, v[4].z, 0.0, 0.0, params.color),
        Vertex::new(v[5].x, v[5].y, v[5].z, 0.0, 0.0, params.color),
        Vertex::new(v[6].x, v[6].y, v[6].z, 0.0, 0.0, params.color),
        Vertex::new(v[7].x, v[7].y, v[7].z, 0.0, 0.0, params.color),
    ];
    #[rustfmt::skip]
    let indices: [u16; 24] = [
        0, 4, 3,
        4, 3, 7,
        4, 0, 1,
        4, 5, 1,
        1, 5, 6,
        1, 6, 2,
        2, 3, 6,
        3, 6, 7,
    ];

    context.gl.texture(None);
    context.gl.draw_mode(DrawMode::Triangles);
    context.gl.geometry(&vertices, &indices);
}

#[derive(Debug, Clone)]
pub struct DrawRectangleParams {
    /// Adds an offset to the position
    /// E.g. offset (0,0) positions the rectangle at the top left corner of the screen, while offset
    /// (0.5, 0.5) centers it
    pub offset: Vec2,

    /// Rotation in radians
    pub rotation: f32,

    pub color: Color,
}

impl Default for DrawRectangleParams {
    fn default() -> Self {
        Self {
            offset: vec2(0.0, 0.0),
            rotation: 0.0,
            color: Color::from_rgba(255, 255, 255, 255),
        }
    }
}

/// Draws a solid rectangle with its position at `[x, y]` with size `[w, h]`,
/// with parameters.
pub fn draw_rectangle_ex(x: f32, y: f32, w: f32, h: f32, params: DrawRectangleParams) {
    let context = get_context();
    let transform_matrix = Mat4::from_translation(vec3(x, y, 0.0))
        * Mat4::from_axis_angle(vec3(0.0, 0.0, 1.0), params.rotation)
        * Mat4::from_scale(vec3(w, h, 1.0));

    #[rustfmt::skip]
    let v = [
        transform_matrix * vec4( 0.0 - params.offset.x,  0.0 - params.offset.y, 0.0, 1.0),
        transform_matrix * vec4( 0.0 - params.offset.x,  1.0 - params.offset.y, 0.0, 1.0),
        transform_matrix * vec4( 1.0 - params.offset.x,  1.0 - params.offset.y, 0.0, 1.0),
        transform_matrix * vec4( 1.0 - params.offset.x,  0.0 - params.offset.y, 0.0, 1.0),
    ];

    #[rustfmt::skip]
    let vertices = [
        Vertex::new(v[0].x, v[0].y, v[0].z, 0.0, 0.0, params.color),
        Vertex::new(v[1].x, v[1].y, v[1].z, 1.0, 0.0, params.color),
        Vertex::new(v[2].x, v[2].y, v[2].z, 1.0, 1.0, params.color),
        Vertex::new(v[3].x, v[3].y, v[3].z, 0.0, 1.0, params.color),
    ];
    let indices: [u16; 6] = [0, 1, 2, 0, 2, 3];

    context.gl.texture(None);
    context.gl.draw_mode(DrawMode::Triangles);
    context.gl.geometry(&vertices, &indices);
}

/// Draws an outlined solid hexagon centered at `[x, y]` with a radius `size`, outline thickness
/// defined by `border`, orientation defined by `vertical` (when `true`, the hexagon points along
/// the `y` axis), and colors for outline given by `border_color` and fill by `fill_color`.
pub fn draw_hexagon(
    x: f32,
    y: f32,
    size: f32,
    border: f32,
    vertical: bool,
    border_color: Color,
    fill_color: Color,
) {
    let rotation = if vertical { 90. } else { 0. };
    draw_poly(x, y, 6, size, rotation, fill_color);
    if border > 0. {
        draw_poly_lines(x, y, 6, size, rotation, border, border_color);
    }
}

/// Draws a solid regular polygon centered at `[x, y]` with a given number of `sides`, `radius`,
/// clockwise `rotation` (in degrees) and `color`.
pub fn draw_poly(x: f32, y: f32, sides: u8, radius: f32, rotation: f32, color: Color) {
    let context = get_context();

    let mut vertices = Vec::<Vertex>::with_capacity(sides as usize + 2);
    let mut indices = Vec::<u16>::with_capacity(sides as usize * 3);

    let rot = rotation.to_radians();
    vertices.push(Vertex::new(x, y, 0., 0., 0., color));
    for i in 0..=sides {
        let rx = (i as f32 / sides as f32 * std::f32::consts::PI * 2. + rot).cos();
        let ry = (i as f32 / sides as f32 * std::f32::consts::PI * 2. + rot).sin();

        let vertex = Vertex::new(x + radius * rx, y + radius * ry, 0., rx, ry, color);

        vertices.push(vertex);

        if i != sides {
            indices.extend_from_slice(&[0, i as u16 + 1, i as u16 + 2]);
        }
    }

    context.gl.texture(None);
    context.gl.draw_mode(DrawMode::Triangles);
    context.gl.geometry(&vertices, &indices);
}

/// Draws a regular polygon outline centered at `[x, y]` with a given number of `sides`, `radius`,
/// clockwise `rotation` (in degrees), line `thickness`, and `color`.
pub fn draw_poly_lines(
    x: f32,
    y: f32,
    sides: u8,
    radius: f32,
    rotation: f32,
    thickness: f32,
    color: Color,
) {
    draw_arc(x, y, sides, radius, rotation, thickness, 360.0, color);
}

/// Draws a solid circle centered at `[x, y]` with a given radius `r` and `color`.
///
/// This is not a perfect circle, but only a polygon approximation.
/// If this is an issue for you, consider using `draw_poly(x, y, 255, r, 0., color)` instead.
pub fn draw_circle(x: f32, y: f32, r: f32, color: Color) {
    draw_poly(x, y, 20, r, 0., color);
}

/// Draws a circle outline centered at `[x, y]` with a given radius, line `thickness` and `color`.
///
/// This is not a perfect circle, but only a polygon approximation.
/// If this is an issue for you, consider using `draw_poly_lines(x, y, 255, r, 0., thickness, color)` instead.
pub fn draw_circle_lines(x: f32, y: f32, r: f32, thickness: f32, color: Color) {
    draw_poly_lines(x, y, 30, r, 0., thickness, color);
}

/// Draws a solid ellipse centered at `[x, y]` with a given size `[w, h]`,
/// clockwise `rotation` (in degrees) and `color`.
pub fn draw_ellipse(x: f32, y: f32, w: f32, h: f32, rotation: f32, color: Color) {
    let sides = 20;
    let context = get_context();

    let mut vertices = Vec::<Vertex>::with_capacity(sides as usize + 2);
    let mut indices = Vec::<u16>::with_capacity(sides as usize * 3);

    let rot = rotation.to_radians();
    let sr = rot.sin();
    let cr = rot.cos();
    vertices.push(Vertex::new(x, y, 0., 0., 0., color));
    for i in 0..=sides {
        let rx = (i as f32 / sides as f32 * std::f32::consts::PI * 2.).cos();
        let ry = (i as f32 / sides as f32 * std::f32::consts::PI * 2.).sin();

        let px = w * rx;
        let py = h * ry;
        let rotated_x = px * cr - py * sr;
        let rotated_y = py * cr + px * sr;
        let vertex = Vertex::new(x + rotated_x, y + rotated_y, 0., rx, ry, color);

        vertices.push(vertex);

        if i != sides {
            indices.extend_from_slice(&[0, i as u16 + 1, i as u16 + 2]);
        }
    }

    context.gl.texture(None);
    context.gl.draw_mode(DrawMode::Triangles);
    context.gl.geometry(&vertices, &indices);
}

/// Draws an ellipse outline centered at `[x, y]` with a given size `[w, h]`,
/// clockwise `rotation` (in degrees), line `thickness` and `color`.
pub fn draw_ellipse_lines(
    x: f32,
    y: f32,
    w: f32,
    h: f32,
    rotation: f32,
    thickness: f32,
    color: Color,
) {
    let sides = 20;

    let rot = rotation.to_radians();
    let sr = rot.sin();
    let cr = rot.cos();
    for i in 0..sides {
        let rx = (i as f32 / sides as f32 * std::f32::consts::PI * 2.).cos();
        let ry = (i as f32 / sides as f32 * std::f32::consts::PI * 2.).sin();
        let px = w * rx;
        let py = h * ry;
        let rotated_x = px * cr - py * sr;
        let rotated_y = py * cr + px * sr;

        let p0 = vec2(x + rotated_x, y + rotated_y);

        let rx = ((i + 1) as f32 / sides as f32 * std::f32::consts::PI * 2.).cos();
        let ry = ((i + 1) as f32 / sides as f32 * std::f32::consts::PI * 2.).sin();
        let px = w * rx;
        let py = h * ry;
        let rotated_x = px * cr - py * sr;
        let rotated_y = py * cr + px * sr;

        let p1 = vec2(x + rotated_x, y + rotated_y);

        draw_line(p0.x, p0.y, p1.x, p1.y, thickness, color);
    }
}

/// Draws a line between points `[x1, y1]` and `[x2, y2]` with a given `thickness` and `color`.
pub fn draw_line(x1: f32, y1: f32, x2: f32, y2: f32, thickness: f32, color: Color) {
    let context = get_context();
    let dx = x2 - x1;
    let dy = y2 - y1;

    // https://stackoverflow.com/questions/1243614/how-do-i-calculate-the-normal-vector-of-a-line-segment

    let nx = -dy;
    let ny = dx;

    let tlen = (nx * nx + ny * ny).sqrt() / (thickness * 0.5);
    if tlen < f32::EPSILON {
        return;
    }
    let tx = nx / tlen;
    let ty = ny / tlen;

    context.gl.texture(None);
    context.gl.draw_mode(DrawMode::Triangles);
    context.gl.geometry(
        &[
            Vertex::new(x1 + tx, y1 + ty, 0., 0., 0., color),
            Vertex::new(x1 - tx, y1 - ty, 0., 0., 0., color),
            Vertex::new(x2 + tx, y2 + ty, 0., 0., 0., color),
            Vertex::new(x2 - tx, y2 - ty, 0., 0., 0., color),
        ],
        &[0, 1, 2, 2, 1, 3],
    );
}

/// Draw arc from `rotation`(in degrees) to `arc + rotation` (`arc` in degrees),
/// centered at `[x, y]` with a given number of `sides`, `radius`, line `thickness`, and `color`.
pub fn draw_arc(
    x: f32,
    y: f32,
    sides: u8,
    radius: f32,
    rotation: f32,
    thickness: f32,
    arc: f32,
    color: Color,
) {
    let rot = rotation.to_radians();
    let part = arc.to_radians();

    let sides = (sides as f32 * part / std::f32::consts::TAU)
        .ceil()
        .max(1.0);
    let span = part / sides;
    let sides = sides as usize;

    let context = get_context();
    context.gl.texture(None);
    context.gl.draw_mode(DrawMode::Triangles);

    let mut verticies = Vec::<Vertex>::with_capacity(sides * 2);
    let mut indicies = Vec::<u16>::with_capacity(sides * 2);

    for i in 0..sides {
        let start_angle = i as f32 * span + rot;
        let end_angle = start_angle + span;

        indicies.extend([0, 1, 2, 2, 1, 3].map(|k| k + (verticies.len() as u16)));

        for (angle, radius) in [
            (start_angle, radius),
            (start_angle, radius + thickness),
            (end_angle, radius),
            (end_angle, radius + thickness),
        ] {
            let point = Vec2::new(x, y) + radius * Vec2::from_angle(angle);
            verticies.push(Vertex::new(point.x, point.y, 0., 0., 0., color));
        }
    }

    context.gl.geometry(&verticies, &indicies);
}

```

`src/telemetry.rs`:

```rs
use crate::{get_context, get_quad_context, time::get_time};

use std::collections::HashMap;

static mut PROFILER: Option<Profiler> = None;

fn get_profiler() -> &'static mut Profiler {
    unsafe {
        PROFILER.get_or_insert_with(|| Profiler {
            frame: Frame::new(),
            queries: HashMap::new(),
            active_query: None,
            prev_frame: Frame::new(),
            enabled: false,
            enable_request: None,
            capture_request: false,
            capture: false,
            drawcalls: vec![],
            strings: vec![],
        })
    }
}

#[derive(Debug, Clone)]
pub struct Zone {
    pub name: String,
    pub start_time: f64,
    pub duration: f64,
    pub children: Vec<Zone>,

    parent: *mut Zone,
}

impl Zone {
    fn clone(&self, parent: *mut Zone) -> Zone {
        Zone {
            name: self.name.clone(),
            start_time: self.start_time,
            duration: self.duration,
            children: self
                .children
                .iter()
                .map(|zone| zone.clone(self as *const _ as *mut _))
                .collect(),
            parent,
        }
    }
}

pub struct ZoneGuard {
    _marker: (),
}

impl ZoneGuard {
    pub fn new(name: &str) -> ZoneGuard {
        begin_zone(name);
        ZoneGuard { _marker: () }
    }
}

impl Drop for ZoneGuard {
    fn drop(&mut self) {
        end_zone();
    }
}

pub fn enable() {
    get_profiler().enable_request = Some(true);
}

pub fn disable() {
    get_profiler().enable_request = Some(false);
}

pub fn begin_zone(name: &str) {
    if get_profiler().enabled {
        get_profiler().begin_zone(name);
    }
}

pub fn end_zone() {
    if get_profiler().enabled {
        get_profiler().end_zone();
    }
}

pub fn begin_gpu_query(name: &str) {
    get_profiler().begin_gpu_query(name);
}

pub fn end_gpu_query() {
    get_profiler().end_gpu_query();
}

/// Workaround to stop gl capture on debug rendering
#[doc(hidden)]
pub fn pause_gl_capture() {
    if get_profiler().capture {
        crate::get_context().gl.capture(false);
    }
}

/// Workaround to stop gl capture on debug rendering
pub fn resume_gl_capture() {
    if get_profiler().capture {
        crate::get_context().gl.capture(false);
    }
}

pub(crate) fn reset() {
    let profiler = get_profiler();

    assert!(
        get_profiler().frame.active_zone.is_null(),
        "New frame started with unpaired begin/end zones."
    );

    profiler.frame.full_frame_time = crate::time::get_frame_time();

    std::mem::swap(&mut profiler.prev_frame, &mut profiler.frame);
    profiler.frame = Frame::new();

    if let Some(enable) = profiler.enable_request.take() {
        profiler.enabled = enable;
    }

    if profiler.capture {
        profiler.capture = false;
        crate::get_context().gl.capture(false);
    }

    if profiler.capture_request {
        profiler.drawcalls.clear();
        profiler.capture = true;
        crate::get_context().gl.capture(true);
        profiler.capture_request = false;
    }
}

#[derive(Debug, Clone)]
pub struct Frame {
    pub full_frame_time: f32,
    pub zones: Vec<Zone>,
    active_zone: *mut Zone,
}

impl Frame {
    const fn new() -> Frame {
        Frame {
            full_frame_time: 0.0,
            zones: vec![],
            active_zone: std::ptr::null_mut(),
        }
    }

    pub fn try_clone(&self) -> Option<Frame> {
        if self.active_zone.is_null() == false {
            return None;
        }

        Some(Frame {
            full_frame_time: self.full_frame_time,
            zones: self
                .zones
                .iter()
                .map(|zone| zone.clone(std::ptr::null_mut()))
                .collect(),
            active_zone: std::ptr::null_mut(),
        })
    }
}

pub fn frame() -> Frame {
    get_profiler().prev_frame.clone()
}

pub fn gpu_queries() -> Vec<(String, u64)> {
    get_profiler()
        .queries
        .iter()
        .map(|(name, query)| (name.to_owned(), query.value))
        .collect()
}

pub fn sample_gpu_queries() {
    for query in &mut get_profiler().queries {
        query.1.force_resume = true;
    }
}

struct Profiler {
    frame: Frame,
    prev_frame: Frame,
    queries: HashMap<String, GpuQuery>,
    active_query: Option<String>,
    enabled: bool,
    capture_request: bool,
    capture: bool,
    enable_request: Option<bool>,
    drawcalls: Vec<DrawCallTelemetry>,
    strings: Vec<String>,
}

impl Profiler {
    fn begin_gpu_query(&mut self, name: &str) {
        assert!(
            self.active_query.is_none(),
            "Only one active query is allowed by OpenGL"
        );

        let name = name.to_string();
        let query = self
            .queries
            .entry(name.clone())
            .or_insert_with(|| GpuQuery {
                query: miniquad::graphics::ElapsedQuery::new(),
                in_progress: false,
                value: 0,
                force_resume: false,
            });
        self.active_query = Some(name);
        if query.force_resume {
            query.in_progress = true;
            query.query.begin_query();
        }
    }

    fn end_gpu_query(&mut self) {
        let name = self
            .active_query
            .take()
            .expect("End query without begin query");
        let query = self.queries.get_mut(&name).unwrap();
        if query.in_progress {
            query.force_resume = false;
            query.in_progress = false;
            query.query.end_query();
        }
        if query.query.is_available() {
            query.value = query.query.get_result();
        }
    }

    fn begin_zone(&mut self, name: &str) {
        let zones = if self.frame.active_zone.is_null() {
            &mut self.frame.zones
        } else {
            unsafe { &mut (&mut *self.frame.active_zone).children }
        };

        zones.push(Zone {
            name: name.to_string(),
            start_time: get_time(),
            duration: 0.0,
            parent: self.frame.active_zone,
            children: vec![],
        });
        self.frame.active_zone = zones.last_mut().unwrap() as _;
    }

    fn end_zone(&mut self) {
        assert!(
            self.frame.active_zone.is_null() == false,
            "end_zone called without begin_zone"
        );

        let start_time = unsafe { (&mut *self.frame.active_zone).start_time };
        let duration = get_time() - start_time;

        unsafe { (&mut *self.frame.active_zone).duration = duration };
        self.frame.active_zone = unsafe { (&mut *self.frame.active_zone).parent };
    }
}

pub struct GpuQuery {
    pub query: miniquad::graphics::ElapsedQuery,
    pub in_progress: bool,
    pub value: u64,
    pub force_resume: bool,
}

pub fn scene_allocated_memory() -> usize {
    use crate::experimental::scene;

    scene::allocated_memory()
}

/// ```skip
/// {
///    let _t = telemetry::LogTimeGuard::new("Atlas build time");
///     mq::texture::build_textures_atlas();
/// }
/// ```
/// Will add "Time query: Atlas build time, 0.5s" string to
/// `telemetry::strings()`
pub struct LogTimeGuard<'a> {
    name: &'a str,
    start_time: f64,
}

impl<'a> LogTimeGuard<'a> {
    pub fn new(name: &'a str) -> LogTimeGuard<'a> {
        LogTimeGuard {
            name,
            start_time: get_time(),
        }
    }
}

impl<'a> Drop for LogTimeGuard<'a> {
    fn drop(&mut self) {
        log_string(&format!(
            "Time query: {}, {:.1}s",
            self.name,
            get_time() - self.start_time
        ));
    }
}

pub fn log_string(string: &str) {
    get_profiler().strings.push(string.to_owned());
}

pub fn drawcalls() -> Vec<DrawCallTelemetry> {
    get_profiler().drawcalls.clone()
}

pub fn strings() -> Vec<String> {
    get_profiler().strings.clone()
}

/// Note that coroutines pre-allocate 56Kb, so 56000 as a result doesnt mean a leak
pub fn coroutines_allocated_memory() -> usize {
    get_context().coroutines_context.allocated_memory()
}

pub fn active_coroutines_count() -> usize {
    get_context().coroutines_context.active_coroutines_count()
}

pub fn capture_frame() {
    get_profiler().capture_request = true;
}

#[derive(Clone, Debug)]
pub struct DrawCallTelemetry {
    pub indices_count: usize,
    pub texture: miniquad::TextureId,
}

pub(crate) fn track_drawcall(
    pipeline: &miniquad::Pipeline,
    bindings: &miniquad::Bindings,
    indices_count: usize,
) {
    let texture = get_quad_context().new_render_texture(miniquad::TextureParams {
        width: 128,
        height: 128,
        ..Default::default()
    });

    let pass = Some(get_quad_context().new_render_pass(texture, None));
    get_quad_context().begin_pass(pass, miniquad::PassAction::clear_color(0.4, 0.8, 0.4, 1.));
    get_quad_context().apply_pipeline(pipeline);
    get_quad_context().apply_bindings(bindings);
    get_quad_context().draw(0, indices_count as _, 1);
    get_quad_context().end_render_pass();

    get_profiler().drawcalls.push(DrawCallTelemetry {
        indices_count,
        texture,
    });
}

pub fn textures_count() -> usize {
    get_context().textures.len()
}

```

`src/text.rs`:

```rs
//! Functions to load fonts and draw text.

use std::collections::HashMap;

use crate::{
    color::Color,
    get_context, get_quad_context,
    math::{vec3, Rect},
    texture::{Image, TextureHandle},
    Error,
};

use crate::color::WHITE;
use glam::vec2;

use std::sync::{Arc, Mutex};
pub(crate) mod atlas;

use atlas::{Atlas, SpriteKey};

#[derive(Debug, Clone)]
pub(crate) struct CharacterInfo {
    pub offset_x: i32,
    pub offset_y: i32,
    pub advance: f32,
    pub sprite: SpriteKey,
}

/// TTF font loaded to GPU
#[derive(Clone)]
pub struct Font {
    font: Arc<fontdue::Font>,
    atlas: Arc<Mutex<Atlas>>,
    characters: Arc<Mutex<HashMap<(char, u16), CharacterInfo>>>,
}

/// World space dimensions of the text, measured by "measure_text" function
#[derive(Debug, Default, Clone, Copy)]
pub struct TextDimensions {
    /// Distance from very left to very right of the rasterized text
    pub width: f32,
    /// Distance from the bottom to the top of the text.
    pub height: f32,
    /// Height offset from the baseline of the text.
    /// "draw_text(.., X, Y, ..)" will be rendered in a "Rect::new(X, Y - dimensions.offset_y, dimensions.width, dimensions.height)"
    /// For reference check "text_measures" example.
    pub offset_y: f32,
}

#[allow(dead_code)]
fn require_fn_to_be_send() {
    fn require_send<T: Send>() {}
    require_send::<Font>();
}

impl std::fmt::Debug for Font {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Font")
            .field("font", &"fontdue::Font")
            .finish()
    }
}

impl Font {
    pub(crate) fn load_from_bytes(atlas: Arc<Mutex<Atlas>>, bytes: &[u8]) -> Result<Font, Error> {
        Ok(Font {
            font: Arc::new(fontdue::Font::from_bytes(
                bytes,
                fontdue::FontSettings::default(),
            )?),
            characters: Arc::new(Mutex::new(HashMap::new())),
            atlas,
        })
    }

    pub(crate) fn set_atlas(&mut self, atlas: Arc<Mutex<Atlas>>) {
        self.atlas = atlas;
    }

    pub(crate) fn set_characters(
        &mut self,
        characters: Arc<Mutex<HashMap<(char, u16), CharacterInfo>>>,
    ) {
        self.characters = characters;
    }

    pub(crate) fn ascent(&self, font_size: f32) -> f32 {
        self.font.horizontal_line_metrics(font_size).unwrap().ascent
    }

    pub(crate) fn descent(&self, font_size: f32) -> f32 {
        self.font
            .horizontal_line_metrics(font_size)
            .unwrap()
            .descent
    }

    pub(crate) fn cache_glyph(&self, character: char, size: u16) {
        if self.contains(character, size) {
            return;
        }

        let (metrics, bitmap) = self.font.rasterize(character, size as f32);

        let (width, height) = (metrics.width as u16, metrics.height as u16);

        let sprite = self.atlas.lock().unwrap().new_unique_id();
        self.atlas.lock().unwrap().cache_sprite(
            sprite,
            Image {
                bytes: bitmap
                    .iter()
                    .flat_map(|coverage| vec![255, 255, 255, *coverage])
                    .collect(),
                width,
                height,
            },
        );
        let advance = metrics.advance_width;

        let (offset_x, offset_y) = (metrics.xmin, metrics.ymin);

        let character_info = CharacterInfo {
            advance,
            offset_x,
            offset_y,
            sprite,
        };

        self.characters
            .lock()
            .unwrap()
            .insert((character, size), character_info);
    }

    pub(crate) fn get(&self, character: char, size: u16) -> Option<CharacterInfo> {
        self.characters
            .lock()
            .unwrap()
            .get(&(character, size))
            .cloned()
    }
    /// Returns whether the character has been cached
    pub(crate) fn contains(&self, character: char, size: u16) -> bool {
        self.characters
            .lock()
            .unwrap()
            .contains_key(&(character, size))
    }

    pub(crate) fn measure_text(
        &self,
        text: impl AsRef<str>,
        font_size: u16,
        font_scale_x: f32,
        font_scale_y: f32,
        mut glyph_callback: impl FnMut(f32),
    ) -> TextDimensions {
        let text = text.as_ref();

        let dpi_scaling = miniquad::window::dpi_scale();
        let font_size = (font_size as f32 * dpi_scaling).ceil() as u16;

        let mut width = 0.0;
        let mut min_y = f32::MAX;
        let mut max_y = f32::MIN;

        for character in text.chars() {
            if !self.contains(character, font_size) {
                self.cache_glyph(character, font_size);
            }

            let font_data = &self.characters.lock().unwrap()[&(character, font_size)];
            let offset_y = font_data.offset_y as f32 * font_scale_y;

            let atlas = self.atlas.lock().unwrap();
            let glyph = atlas.get(font_data.sprite).unwrap().rect;
            let advance = font_data.advance * font_scale_x;
            glyph_callback(advance);
            width += advance;
            min_y = min_y.min(offset_y);
            max_y = max_y.max(glyph.h * font_scale_y + offset_y);
        }

        TextDimensions {
            width: width / dpi_scaling,
            height: (max_y - min_y) / dpi_scaling,
            offset_y: max_y / dpi_scaling,
        }
    }
}

impl Font {
    /// List of ascii characters, may be helpful in combination with "populate_font_cache"
    pub fn ascii_character_list() -> Vec<char> {
        (0..255).filter_map(::std::char::from_u32).collect()
    }

    /// List of latin characters
    pub fn latin_character_list() -> Vec<char> {
        "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890!@#$%^&*(){}[].,:"
            .chars()
            .collect()
    }

    pub fn populate_font_cache(&self, characters: &[char], size: u16) {
        for character in characters {
            self.cache_glyph(*character, size);
        }
    }

    /// Sets the [FilterMode](https://docs.rs/miniquad/latest/miniquad/graphics/enum.FilterMode.html#) of this font's texture atlas.
    ///
    /// Use Nearest if you need integer-ratio scaling for pixel art, for example.
    ///
    /// # Example
    /// ```
    /// # use macroquad::prelude::*;
    /// # #[macroquad::main("test")]
    /// # async fn main() {
    /// let mut font = get_default_font();
    /// font.set_filter(FilterMode::Linear);
    /// # }
    /// ```
    pub fn set_filter(&mut self, filter_mode: miniquad::FilterMode) {
        self.atlas.lock().unwrap().set_filter(filter_mode);
    }

    // pub fn texture(&self) -> Texture2D {
    //     let font = get_context().fonts_storage.get_font(*self);

    //     font.font_texture
    // }
}

impl Default for Font {
    fn default() -> Self {
        get_default_font()
    }
}

/// Arguments for "draw_text_ex" function such as font, font_size etc
#[derive(Debug, Clone)]
pub struct TextParams<'a> {
    pub font: Option<&'a Font>,
    /// Base size for character height. The size in pixel used during font rasterizing.
    pub font_size: u16,
    /// The glyphs sizes actually drawn on the screen will be font_size * font_scale
    /// However with font_scale too different from 1.0 letters may be blurry
    pub font_scale: f32,
    /// Font X axis would be scaled by font_scale * font_scale_aspect
    /// and Y axis would be scaled by font_scale
    /// Default is 1.0
    pub font_scale_aspect: f32,
    /// Text rotation in radian
    /// Default is 0.0
    pub rotation: f32,
    pub color: Color,
}

impl<'a> Default for TextParams<'a> {
    fn default() -> TextParams<'a> {
        TextParams {
            font: None,
            font_size: 20,
            font_scale: 1.0,
            font_scale_aspect: 1.0,
            color: WHITE,
            rotation: 0.0,
        }
    }
}

/// Load font from file with "path"
pub async fn load_ttf_font(path: &str) -> Result<Font, Error> {
    let bytes = crate::file::load_file(path)
        .await
        .map_err(|_| Error::FontError("The Font file couldn't be loaded"))?;

    load_ttf_font_from_bytes(&bytes[..])
}

/// Load font from bytes array, may be use in combination with include_bytes!
/// ```ignore
/// let font = load_ttf_font_from_bytes(include_bytes!("font.ttf"));
/// ```
pub fn load_ttf_font_from_bytes(bytes: &[u8]) -> Result<Font, Error> {
    let atlas = Arc::new(Mutex::new(Atlas::new(
        get_quad_context(),
        miniquad::FilterMode::Linear,
    )));

    let mut font = Font::load_from_bytes(atlas.clone(), bytes)?;

    font.populate_font_cache(&Font::ascii_character_list(), 15);

    let ctx = get_context();

    font.set_filter(ctx.default_filter_mode);

    Ok(font)
}

/// Draw text with given font_size
/// Returns text size
pub fn draw_text(
    text: impl AsRef<str>,
    x: f32,
    y: f32,
    font_size: f32,
    color: Color,
) -> TextDimensions {
    draw_text_ex(
        text,
        x,
        y,
        TextParams {
            font_size: font_size as u16,
            font_scale: 1.0,
            color,
            ..Default::default()
        },
    )
}

/// Draw text with custom params such as font, font size and font scale
/// Returns text size
pub fn draw_text_ex(text: impl AsRef<str>, x: f32, y: f32, params: TextParams) -> TextDimensions {
    let text = text.as_ref();

    if text.is_empty() {
        return TextDimensions::default();
    }

    let font = params
        .font
        .unwrap_or(&get_context().fonts_storage.default_font);

    let dpi_scaling = miniquad::window::dpi_scale();

    let rot = params.rotation;
    let font_scale_x = params.font_scale * params.font_scale_aspect;
    let font_scale_y = params.font_scale;
    let font_size = (params.font_size as f32 * dpi_scaling).ceil() as u16;

    let mut total_width = 0.0;
    let mut max_offset_y = f32::MIN;
    let mut min_offset_y = f32::MAX;

    for character in text.chars() {
        if !font.contains(character, font_size) {
            font.cache_glyph(character, font_size);
        }

        let char_data = &font.characters.lock().unwrap()[&(character, font_size)];
        let offset_x = char_data.offset_x as f32 * font_scale_x;
        let offset_y = char_data.offset_y as f32 * font_scale_y;

        let mut atlas = font.atlas.lock().unwrap();
        let glyph = atlas.get(char_data.sprite).unwrap().rect;
        let glyph_scaled_h = glyph.h * font_scale_y;

        min_offset_y = min_offset_y.min(offset_y);
        max_offset_y = max_offset_y.max(glyph_scaled_h + offset_y);

        let rot_cos = rot.cos();
        let rot_sin = rot.sin();
        let dest_x = (offset_x + total_width) * rot_cos + (glyph_scaled_h + offset_y) * rot_sin;
        let dest_y = (offset_x + total_width) * rot_sin + (-glyph_scaled_h - offset_y) * rot_cos;

        let dest = Rect::new(
            dest_x / dpi_scaling + x,
            dest_y / dpi_scaling + y,
            glyph.w / dpi_scaling * font_scale_x,
            glyph.h / dpi_scaling * font_scale_y,
        );

        total_width += char_data.advance * font_scale_x;

        crate::texture::draw_texture_ex(
            &crate::texture::Texture2D {
                texture: TextureHandle::Unmanaged(atlas.texture()),
            },
            dest.x,
            dest.y,
            params.color,
            crate::texture::DrawTextureParams {
                dest_size: Some(vec2(dest.w, dest.h)),
                source: Some(glyph),
                rotation: rot,
                pivot: Some(vec2(dest.x, dest.y)),
                ..Default::default()
            },
        );
    }

    TextDimensions {
        width: total_width / dpi_scaling,
        height: (max_offset_y - min_offset_y) / dpi_scaling,
        offset_y: max_offset_y / dpi_scaling,
    }
}

/// Draw multiline text with the given font_size, line_distance_factor and color.
/// If no line distance but a custom font is given, the fonts line gap will be used as line distance factor if it exists.
pub fn draw_multiline_text(
    text: impl AsRef<str>,
    x: f32,
    y: f32,
    font_size: f32,
    line_distance_factor: Option<f32>,
    color: Color,
) -> TextDimensions {
    draw_multiline_text_ex(
        text,
        x,
        y,
        line_distance_factor,
        TextParams {
            font_size: font_size as u16,
            font_scale: 1.0,
            color,
            ..Default::default()
        },
    )
}

/// Draw multiline text with the given line distance and custom params such as font, font size and font scale.
/// If no line distance but a custom font is given, the fonts newline size will be used as line distance factor if it exists, else default to font size.
pub fn draw_multiline_text_ex(
    text: impl AsRef<str>,
    mut x: f32,
    mut y: f32,
    line_distance_factor: Option<f32>,
    params: TextParams,
) -> TextDimensions {
    let line_distance = match line_distance_factor {
        Some(distance) => distance,
        None => {
            let mut font_line_distance = 0.0;
            let font = if let Some(font) = params.font {
                font
            } else {
                &get_default_font()
            };
            if let Some(metrics) = font.font.horizontal_line_metrics(1.0) {
                font_line_distance = metrics.new_line_size;
            }

            font_line_distance
        }
    };

    let mut dimensions = TextDimensions::default();
    let y_step = line_distance * params.font_size as f32 * params.font_scale;

    for line in text.as_ref().lines() {
        let line_dimensions = draw_text_ex(line, x, y, params.clone());
        x -= (line_distance * params.font_size as f32 * params.font_scale) * params.rotation.sin();
        y += (line_distance * params.font_size as f32 * params.font_scale) * params.rotation.cos();

        dimensions.width = f32::max(dimensions.width, line_dimensions.width);
        dimensions.height += y_step;

        if dimensions.offset_y == 0.0 {
            dimensions.offset_y = line_dimensions.offset_y;
        }
    }

    dimensions
}

/// Get the text center.
pub fn get_text_center(
    text: impl AsRef<str>,
    font: Option<&Font>,
    font_size: u16,
    font_scale: f32,
    rotation: f32,
) -> crate::Vec2 {
    let measure = measure_text(text, font, font_size, font_scale);

    let x_center = measure.width / 2.0 * rotation.cos() + measure.height / 2.0 * rotation.sin();
    let y_center = measure.width / 2.0 * rotation.sin() - measure.height / 2.0 * rotation.cos();

    crate::Vec2::new(x_center, y_center)
}

pub fn measure_text(
    text: impl AsRef<str>,
    font: Option<&Font>,
    font_size: u16,
    font_scale: f32,
) -> TextDimensions {
    let font = font.unwrap_or_else(|| &get_context().fonts_storage.default_font);

    font.measure_text(text, font_size, font_scale, font_scale, |_| {})
}

pub fn measure_multiline_text(
    text: &str,
    font: Option<&Font>,
    font_size: u16,
    font_scale: f32,
    line_distance_factor: Option<f32>,
) -> TextDimensions {
    let font = font.unwrap_or_else(|| &get_context().fonts_storage.default_font);
    let line_distance = match line_distance_factor {
        Some(distance) => distance,
        None => match font.font.horizontal_line_metrics(1.0) {
            Some(metrics) => metrics.new_line_size,
            None => 1.0,
        },
    };

    let mut dimensions = TextDimensions::default();
    let y_step = line_distance * font_size as f32 * font_scale;

    for line in text.lines() {
        let line_dimensions = font.measure_text(line, font_size, font_scale, font_scale, |_| {});

        dimensions.width = f32::max(dimensions.width, line_dimensions.width);
        dimensions.height += y_step;
        if dimensions.offset_y == 0.0 {
            dimensions.offset_y = line_dimensions.offset_y;
        }
    }

    dimensions
}

/// Converts word breaks to newlines wherever the text would otherwise exceed the given length.
pub fn wrap_text(
    text: &str,
    font: Option<&Font>,
    font_size: u16,
    font_scale: f32,
    maximum_line_length: f32,
) -> String {
    let font = font.unwrap_or_else(|| &get_context().fonts_storage.default_font);

    // This is always a bit too much memory, but it saves a lot of reallocations.
    let mut new_text =
        String::with_capacity(text.len() + text.chars().filter(|c| c.is_whitespace()).count());

    let mut current_word_start = 0usize;
    let mut current_word_end = 0usize;
    let mut characters = text.char_indices();
    let mut total_width = 0.0;
    let mut word_width = 0.0;

    font.measure_text(text, font_size, font_scale, font_scale, |mut width| {
        // It's impossible this is called more often than the text has characters.
        let (idx, c) = characters.next().unwrap();
        let mut keep_char = true;

        if c.is_whitespace() {
            new_text.push_str(&text[current_word_start..idx + c.len_utf8()]);
            current_word_start = idx + c.len_utf8();
            word_width = 0.0;
            keep_char = false;

            // If we would wrap, ignore the whitespace.
            if total_width + width > maximum_line_length {
                width = 0.0;
            }
        }

        // If a single word expands past the length limit, just break it up.
        if word_width + width > maximum_line_length {
            new_text.push_str(&text[current_word_start..current_word_end]);
            new_text.push('\n');
            current_word_start = current_word_end;
            total_width = 0.0;
            word_width = 0.0;
        }

        current_word_end = idx + c.len_utf8();
        if keep_char {
            word_width += width;
        }

        if c == '\n' {
            total_width = 0.0;
            word_width = 0.0;
            return;
        }

        total_width += width;

        if total_width > maximum_line_length {
            new_text.push('\n');
            total_width = word_width;
        }
    });

    new_text.push_str(&text[current_word_start..current_word_end]);

    new_text
}

pub(crate) struct FontsStorage {
    default_font: Font,
}

impl FontsStorage {
    pub(crate) fn new(ctx: &mut dyn miniquad::RenderingBackend) -> FontsStorage {
        let atlas = Arc::new(Mutex::new(Atlas::new(ctx, miniquad::FilterMode::Linear)));

        let default_font = Font::load_from_bytes(atlas, include_bytes!("ProggyClean.ttf")).unwrap();
        FontsStorage { default_font }
    }
}

/// Returns macroquads default font.
pub fn get_default_font() -> Font {
    let context = get_context();
    context.fonts_storage.default_font.clone()
}

/// Replaces macroquads default font with `font`.
pub fn set_default_font(font: Font) {
    let context = get_context();
    context.fonts_storage.default_font = font;
}

/// From given font size in world space gives
/// (font_size, font_scale and font_aspect) params to make rasterized font
/// looks good in currently active camera
pub fn camera_font_scale(world_font_size: f32) -> (u16, f32, f32) {
    let context = get_context();
    let (scr_w, scr_h) = miniquad::window::screen_size();
    let cam_space = context
        .projection_matrix()
        .inverse()
        .transform_vector3(vec3(2., 2., 0.));
    let (cam_w, cam_h) = (cam_space.x.abs(), cam_space.y.abs());

    let screen_font_size = world_font_size * scr_h / cam_h;

    let font_size = screen_font_size as u16;

    (font_size, cam_h / scr_h, scr_h / scr_w * cam_w / cam_h)
}

```

`src/text/atlas.rs`:

```rs
use crate::{get_context, get_quad_context, math::Rect, texture::Image, Color};

use std::collections::HashMap;

#[derive(Debug, Clone, Copy)]
pub struct Sprite {
    pub rect: Rect,
}

#[derive(Debug, Eq, PartialEq, Hash, Clone, Copy)]
pub enum SpriteKey {
    Texture(miniquad::TextureId),
    Id(u64),
}
pub struct Atlas {
    texture: miniquad::TextureId,
    image: Image,
    pub sprites: HashMap<SpriteKey, Sprite>,
    cursor_x: u16,
    cursor_y: u16,
    max_line_height: u16,

    pub dirty: bool,

    filter: miniquad::FilterMode,

    unique_id: u64,
}

impl Drop for Atlas {
    fn drop(&mut self) {
        let ctx = &mut get_context().quad_context;
        ctx.delete_texture(self.texture);
    }
}

impl Atlas {
    // pixel gap between glyphs in the atlas
    const GAP: u16 = 2;
    // well..
    const UNIQUENESS_OFFSET: u64 = 100000;

    pub fn new(ctx: &mut dyn miniquad::RenderingBackend, filter: miniquad::FilterMode) -> Atlas {
        let image = Image::gen_image_color(512, 512, Color::new(0.0, 0.0, 0.0, 0.0));
        let texture = ctx.new_texture_from_rgba8(image.width, image.height, &image.bytes);
        ctx.texture_set_filter(
            texture,
            miniquad::FilterMode::Nearest,
            miniquad::MipmapFilterMode::None,
        );

        Atlas {
            image,
            texture,
            cursor_x: 0,
            cursor_y: 0,
            dirty: false,
            max_line_height: 0,
            sprites: HashMap::new(),
            filter,
            unique_id: Self::UNIQUENESS_OFFSET,
        }
    }

    pub fn new_unique_id(&mut self) -> SpriteKey {
        self.unique_id += 1;

        SpriteKey::Id(self.unique_id)
    }

    pub fn set_filter(&mut self, filter_mode: miniquad::FilterMode) {
        let ctx = get_quad_context();
        self.filter = filter_mode;
        ctx.texture_set_filter(self.texture, filter_mode, miniquad::MipmapFilterMode::None);
    }

    pub fn get(&self, key: SpriteKey) -> Option<Sprite> {
        self.sprites.get(&key).cloned()
    }

    pub const fn width(&self) -> u16 {
        self.image.width
    }

    pub const fn height(&self) -> u16 {
        self.image.height
    }

    pub fn texture(&mut self) -> miniquad::TextureId {
        let ctx = get_quad_context();
        if self.dirty {
            self.dirty = false;
            let (texture_width, texture_height) = ctx.texture_size(self.texture);
            if texture_width != self.image.width as _ || texture_height != self.image.height as _ {
                ctx.delete_texture(self.texture);

                self.texture = ctx.new_texture_from_rgba8(
                    self.image.width,
                    self.image.height,
                    &self.image.bytes[..],
                );
                ctx.texture_set_filter(self.texture, self.filter, miniquad::MipmapFilterMode::None);
            }

            ctx.texture_update(self.texture, &self.image.bytes);
        }

        self.texture
    }

    pub fn get_uv_rect(&self, key: SpriteKey) -> Option<Rect> {
        let ctx = get_quad_context();
        self.get(key).map(|sprite| {
            let (w, h) = ctx.texture_size(self.texture);

            Rect::new(
                sprite.rect.x / w as f32,
                sprite.rect.y / h as f32,
                sprite.rect.w / w as f32,
                sprite.rect.h / h as f32,
            )
        })
    }

    pub fn cache_sprite(&mut self, key: SpriteKey, sprite: Image) {
        let (width, height) = (sprite.width as usize, sprite.height as usize);

        let x = if self.cursor_x + (width as u16) < self.image.width {
            if height as u16 > self.max_line_height {
                self.max_line_height = height as u16;
            }
            let res = self.cursor_x + Self::GAP;
            self.cursor_x += width as u16 + Self::GAP * 2;
            res
        } else {
            self.cursor_y += self.max_line_height + Self::GAP * 2;
            self.cursor_x = width as u16 + Self::GAP;
            self.max_line_height = height as u16;
            Self::GAP
        };
        let y = self.cursor_y;

        // texture bounds exceeded
        if y + sprite.height > self.image.height || x + sprite.width > self.image.width {
            // reset glyph cache state
            let sprites = self.sprites.drain().collect::<Vec<_>>();
            self.cursor_x = 0;
            self.cursor_y = 0;
            self.max_line_height = 0;

            let old_image = self.image.clone();

            // increase font texture size
            // note: if we tried to fit gigantic texture into a small atlas,
            // new_width will still be not enough. But its fine, it will
            // be regenerated on the recursion call.
            let new_width = self.image.width * 2;
            let new_height = self.image.height * 2;

            self.image =
                Image::gen_image_color(new_width, new_height, Color::new(0.0, 0.0, 0.0, 0.0));

            // recache all previously cached symbols
            for (key, sprite) in sprites {
                let image = old_image.sub_image(sprite.rect);
                self.cache_sprite(key, image);
            }

            // cache the new sprite
            self.cache_sprite(key, sprite);
        } else {
            self.dirty = true;

            for j in 0..height {
                for i in 0..width {
                    self.image.set_pixel(
                        x as u32 + i as u32,
                        y as u32 + j as u32,
                        sprite.get_pixel(i as u32, j as u32),
                    );
                }
            }

            self.sprites.insert(
                key,
                Sprite {
                    rect: Rect::new(x as f32, y as f32, width as f32, height as f32),
                },
            );
        }
    }
}

```

`src/texture.rs`:

```rs
//! Loading and rendering textures. Also render textures, per-pixel image manipulations.

use crate::{
    color::Color, file::load_file, get_context, get_quad_context, math::Rect,
    text::atlas::SpriteKey, Error,
};

pub use crate::quad_gl::FilterMode;
use crate::quad_gl::{DrawMode, Vertex};
use glam::{vec2, Vec2};
use slotmap::{TextureIdSlotMap, TextureSlotId};
use std::sync::Arc;

mod slotmap;

#[derive(Debug, Clone, PartialEq)]
pub(crate) struct TextureSlotGuarded(pub TextureSlotId);

#[derive(Debug, Clone, PartialEq)]
pub(crate) enum TextureHandle {
    // texture that belongs to macroquad and follows normal garbage collection rules
    Managed(Arc<TextureSlotGuarded>),
    ManagedWeak(TextureSlotId),
    // raw miniquad texture, there are no guarantees that this texture is not yet deleted
    Unmanaged(miniquad::TextureId),
}

pub(crate) struct TexturesContext {
    textures: TextureIdSlotMap,
    removed: Vec<TextureSlotId>,
    removed_render_passes: Vec<miniquad::RenderPass>,
}
impl TexturesContext {
    pub fn new() -> TexturesContext {
        TexturesContext {
            textures: TextureIdSlotMap::new(),
            removed: Vec::with_capacity(200),
            removed_render_passes: Vec::with_capacity(10),
        }
    }
    fn schedule_removed(&mut self, texture: TextureSlotId) {
        self.removed.push(texture);
    }
    fn schedule_render_pass_removed(&mut self, pass: miniquad::RenderPass) {
        self.removed_render_passes.push(pass);
    }
    fn store_texture(&mut self, texture: miniquad::TextureId) -> TextureHandle {
        TextureHandle::Managed(Arc::new(TextureSlotGuarded(self.textures.insert(texture))))
    }
    pub fn texture(&self, texture: TextureSlotId) -> Option<miniquad::TextureId> {
        self.textures.get(texture)
    }
    // fn remove(&mut self, texture: TextureSlotId) {
    //     self.textures.remove(texture);
    // }
    pub const fn len(&self) -> usize {
        self.textures.len()
    }
    pub fn garbage_collect(&mut self, ctx: &mut miniquad::Context) {
        // Delete RenderPasses first, then textures (safer for attachments/FBOs)
        for pass in self.removed_render_passes.drain(0..) {
            ctx.delete_render_pass(pass);
        }

        for texture in self.removed.drain(0..) {
            if let Some(texture) = self.textures.get(texture) {
                ctx.delete_texture(texture);
            }
            self.textures.remove(texture);
        }
    }
}

/// Image, data stored in CPU memory
#[derive(Clone)]
pub struct Image {
    pub bytes: Vec<u8>,
    pub width: u16,
    pub height: u16,
}

impl std::fmt::Debug for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Image")
            .field("width", &self.width)
            .field("height", &self.height)
            .field("bytes.len()", &self.bytes.len())
            .finish()
    }
}

impl Image {
    /// Creates an empty Image.
    ///
    /// ```
    /// # use macroquad::prelude::*;
    /// let image = Image::empty();
    /// ```
    pub const fn empty() -> Image {
        Image {
            width: 0,
            height: 0,
            bytes: vec![],
        }
    }

    /// Creates an Image from a slice of bytes that contains an encoded image.
    ///
    /// If `format` is None, it will make an educated guess on the
    /// [ImageFormat][image::ImageFormat].
    ///
    /// # Example
    ///
    /// ```
    /// # use macroquad::prelude::*;
    /// let icon = Image::from_file_with_format(
    ///     include_bytes!("../examples/rust.png"),
    ///     Some(ImageFormat::Png),
    ///     );
    /// ```
    pub fn from_file_with_format(
        bytes: &[u8],
        format: Option<image::ImageFormat>,
    ) -> Result<Image, Error> {
        let img = if let Some(fmt) = format {
            image::load_from_memory_with_format(bytes, fmt)?.to_rgba8()
        } else {
            image::load_from_memory(bytes)?.to_rgba8()
        };
        let width = img.width() as u16;
        let height = img.height() as u16;
        let bytes = img.into_raw();

        Ok(Image {
            width,
            height,
            bytes,
        })
    }

    /// Creates an Image filled with the provided [Color].
    pub fn gen_image_color(width: u16, height: u16, color: Color) -> Image {
        let mut bytes = vec![0; width as usize * height as usize * 4];
        for i in 0..width as usize * height as usize {
            bytes[i * 4 + 0] = (color.r * 255.) as u8;
            bytes[i * 4 + 1] = (color.g * 255.) as u8;
            bytes[i * 4 + 2] = (color.b * 255.) as u8;
            bytes[i * 4 + 3] = (color.a * 255.) as u8;
        }
        Image {
            width,
            height,
            bytes,
        }
    }

    /// Updates this image from a slice of [Color]s.
    pub fn update(&mut self, colors: &[Color]) {
        assert!(self.width as usize * self.height as usize == colors.len());

        for i in 0..colors.len() {
            self.bytes[i * 4] = (colors[i].r * 255.) as u8;
            self.bytes[i * 4 + 1] = (colors[i].g * 255.) as u8;
            self.bytes[i * 4 + 2] = (colors[i].b * 255.) as u8;
            self.bytes[i * 4 + 3] = (colors[i].a * 255.) as u8;
        }
    }

    /// Returns the width of this image.
    pub const fn width(&self) -> usize {
        self.width as usize
    }

    /// Returns the height of this image.
    pub const fn height(&self) -> usize {
        self.height as usize
    }

    /// Returns this image's data as a slice of 4-byte arrays.
    pub fn get_image_data(&self) -> &[[u8; 4]] {
        use std::slice;
        assert!(self.width as usize * self.height as usize * 4 == self.bytes.len());

        unsafe {
            slice::from_raw_parts(
                self.bytes.as_ptr() as *const [u8; 4],
                self.width as usize * self.height as usize,
            )
        }
    }

    /// Returns this image's data as a mutable slice of 4-byte arrays.
    pub fn get_image_data_mut(&mut self) -> &mut [[u8; 4]] {
        use std::slice;
        assert!(self.width as usize * self.height as usize * 4 == self.bytes.len());

        unsafe {
            slice::from_raw_parts_mut(
                self.bytes.as_mut_ptr() as *mut [u8; 4],
                self.width as usize * self.height as usize,
            )
        }
    }

    /// Modifies a pixel [Color] in this image.
    pub fn set_pixel(&mut self, x: u32, y: u32, color: Color) {
        assert!(x < self.width as u32);
        assert!(y < self.height as u32);

        let width = self.width;

        self.get_image_data_mut()[(y * width as u32 + x) as usize] = color.into();
    }

    /// Returns a pixel [Color] from this image.
    pub fn get_pixel(&self, x: u32, y: u32) -> Color {
        self.get_image_data()[(y * self.width as u32 + x) as usize].into()
    }

    /// Returns an Image from a rect inside this image.
    pub fn sub_image(&self, rect: Rect) -> Image {
        let width = rect.w as usize;
        let height = rect.h as usize;
        let mut bytes = vec![0; width * height * 4];

        let x = rect.x as usize;
        let y = rect.y as usize;
        let mut n = 0;
        for y in y..y + height {
            for x in x..x + width {
                bytes[n] = self.bytes[y * self.width as usize * 4 + x * 4 + 0];
                bytes[n + 1] = self.bytes[y * self.width as usize * 4 + x * 4 + 1];
                bytes[n + 2] = self.bytes[y * self.width as usize * 4 + x * 4 + 2];
                bytes[n + 3] = self.bytes[y * self.width as usize * 4 + x * 4 + 3];
                n += 4;
            }
        }
        Image {
            width: width as u16,
            height: height as u16,
            bytes,
        }
    }

    /// Blends this image with another image (of identical dimensions)
    /// Inspired by  OpenCV saturated blending
    pub fn blend(&mut self, other: &Image) {
        assert!(
            self.width as usize * self.height as usize
                == other.width as usize * other.height as usize
        );

        for i in 0..self.bytes.len() / 4 {
            let c1: Color = Color {
                r: self.bytes[i * 4] as f32 / 255.,
                g: self.bytes[i * 4 + 1] as f32 / 255.,
                b: self.bytes[i * 4 + 2] as f32 / 255.,
                a: self.bytes[i * 4 + 3] as f32 / 255.,
            };
            let c2: Color = Color {
                r: other.bytes[i * 4] as f32 / 255.,
                g: other.bytes[i * 4 + 1] as f32 / 255.,
                b: other.bytes[i * 4 + 2] as f32 / 255.,
                a: other.bytes[i * 4 + 3] as f32 / 255.,
            };
            let new_color: Color = Color {
                r: f32::min(c1.r * c1.a + c2.r * c2.a, 1.),
                g: f32::min(c1.g * c1.a + c2.g * c2.a, 1.),
                b: f32::min(c1.b * c1.a + c2.b * c2.a, 1.),
                a: f32::max(c1.a, c2.a) + (1. - f32::max(c1.a, c2.a)) * f32::min(c1.a, c2.a),
            };
            self.bytes[i * 4] = (new_color.r * 255.) as u8;
            self.bytes[i * 4 + 1] = (new_color.g * 255.) as u8;
            self.bytes[i * 4 + 2] = (new_color.b * 255.) as u8;
            self.bytes[i * 4 + 3] = (new_color.a * 255.) as u8;
        }
    }

    /// Overlays an image on top of this one.
    /// Slightly different from blending two images,
    /// overlaying a completely transparent image has no effect
    /// on the original image, though blending them would.
    pub fn overlay(&mut self, other: &Image) {
        assert!(
            self.width as usize * self.height as usize
                == other.width as usize * other.height as usize
        );

        for i in 0..self.bytes.len() / 4 {
            let c1: Color = Color {
                r: self.bytes[i * 4] as f32 / 255.,
                g: self.bytes[i * 4 + 1] as f32 / 255.,
                b: self.bytes[i * 4 + 2] as f32 / 255.,
                a: self.bytes[i * 4 + 3] as f32 / 255.,
            };
            let c2: Color = Color {
                r: other.bytes[i * 4] as f32 / 255.,
                g: other.bytes[i * 4 + 1] as f32 / 255.,
                b: other.bytes[i * 4 + 2] as f32 / 255.,
                a: other.bytes[i * 4 + 3] as f32 / 255.,
            };
            let new_color: Color = Color {
                r: f32::min(c1.r * (1. - c2.a) + c2.r * c2.a, 1.),
                g: f32::min(c1.g * (1. - c2.a) + c2.g * c2.a, 1.),
                b: f32::min(c1.b * (1. - c2.a) + c2.b * c2.a, 1.),
                a: f32::min(c1.a + c2.a, 1.),
            };

            self.bytes[i * 4] = (new_color.r * 255.) as u8;
            self.bytes[i * 4 + 1] = (new_color.g * 255.) as u8;
            self.bytes[i * 4 + 2] = (new_color.b * 255.) as u8;
            self.bytes[i * 4 + 3] = (new_color.a * 255.) as u8;
        }
    }

    /// Saves this image as a PNG file.
    /// This method is not supported on web and will panic.
    pub fn export_png(&self, path: &str) {
        let mut bytes = vec![0; self.width as usize * self.height as usize * 4];

        // flip the image before saving
        for y in 0..self.height as usize {
            for x in 0..self.width as usize * 4 {
                bytes[y * self.width as usize * 4 + x] =
                    self.bytes[(self.height as usize - y - 1) * self.width as usize * 4 + x];
            }
        }

        image::save_buffer(
            path,
            &bytes[..],
            self.width as _,
            self.height as _,
            image::ColorType::Rgba8,
        )
        .unwrap();
    }
}

/// Loads an [Image] from a file into CPU memory.
pub async fn load_image(path: &str) -> Result<Image, Error> {
    let bytes = load_file(path).await?;

    Image::from_file_with_format(&bytes, None)
}

/// Loads a [Texture2D] from a file into GPU memory.
pub async fn load_texture(path: &str) -> Result<Texture2D, Error> {
    let bytes = load_file(path).await?;

    Ok(Texture2D::from_file_with_format(&bytes[..], None))
}

#[derive(Debug, Clone)]
pub struct RenderPass {
    pub color_texture: Texture2D,
    pub depth_texture: Option<Texture2D>,
    pub(crate) render_pass: Arc<miniquad::RenderPass>,
}

#[derive(Debug, Clone)]
pub struct RenderTargetParams {
    /// 1 means no multi sampling.
    /// Note that sample_count > 1 is not supported on GL2, GLES2 and WebGL1
    pub sample_count: i32,

    /// depth: true creates a depth render target attachment and allows
    /// such a render target being used for a depth-testing cameras
    pub depth: bool,
}
impl Default for RenderTargetParams {
    fn default() -> RenderTargetParams {
        RenderTargetParams {
            sample_count: 1,
            depth: false,
        }
    }
}

impl RenderPass {
    /// Returns the miniquad handle for this render pass.
    pub fn raw_miniquad_id(&self) -> miniquad::RenderPass {
        *self.render_pass
    }
}

impl Drop for RenderPass {
    fn drop(&mut self) {
        // Safety: if strong_count < 2, this is the last strong ref.
        // No new strong references can be created after this point.
        if Arc::strong_count(&self.render_pass) < 2 {
            let ctx = get_context();
            ctx.textures.schedule_render_pass_removed(*self.render_pass);
        }
    }
}

#[derive(Clone, Debug)]
pub struct RenderTarget {
    pub texture: Texture2D,
    pub render_pass: RenderPass,
}

/// A shortcut to create a render target with sample_count: 1 and no depth buffer
pub fn render_target(width: u32, height: u32) -> RenderTarget {
    render_target_ex(width, height, RenderTargetParams::default())
}

/// A shortcut to create a render target with no depth buffer and `sample_count: 4`
pub fn render_target_msaa(width: u32, height: u32) -> RenderTarget {
    render_target_ex(
        width,
        height,
        RenderTargetParams {
            sample_count: 4,
            ..Default::default()
        },
    )
}

pub fn render_target_ex(width: u32, height: u32, params: RenderTargetParams) -> RenderTarget {
    let context = get_context();

    let color_texture = get_quad_context().new_render_texture(miniquad::TextureParams {
        width,
        height,
        sample_count: params.sample_count,
        ..Default::default()
    });
    let depth_texture = if params.depth {
        Some(
            get_quad_context().new_render_texture(miniquad::TextureParams {
                width,
                height,
                format: miniquad::TextureFormat::Depth,
                sample_count: params.sample_count,
                ..Default::default()
            }),
        )
    } else {
        None
    };
    let render_pass;
    let texture;
    if params.sample_count != 0 {
        let color_resolve_texture =
            get_quad_context().new_render_texture(miniquad::TextureParams {
                width,
                height,
                ..Default::default()
            });
        render_pass = get_quad_context().new_render_pass_mrt(
            &[color_texture],
            Some(&[color_resolve_texture]),
            depth_texture,
        );
        texture = color_resolve_texture;
    } else {
        render_pass = get_quad_context().new_render_pass_mrt(&[color_texture], None, depth_texture);
        texture = color_texture;
    }

    let texture = Texture2D {
        texture: context.textures.store_texture(texture),
    };

    let render_pass = RenderPass {
        color_texture: texture.clone(),
        depth_texture: None,
        render_pass: Arc::new(render_pass),
    };
    RenderTarget {
        texture,
        render_pass,
    }
}

#[derive(Debug, Clone)]
pub struct DrawTextureParams {
    pub dest_size: Option<Vec2>,

    /// Part of texture to draw. If None - draw the whole texture.
    /// Good use example: drawing an image from texture atlas.
    /// Is None by default
    pub source: Option<Rect>,

    /// Rotation in radians
    pub rotation: f32,

    /// Mirror on the X axis
    pub flip_x: bool,

    /// Mirror on the Y axis
    pub flip_y: bool,

    /// Rotate around this point.
    /// When `None`, rotate around the texture's center.
    /// When `Some`, the coordinates are in screen-space.
    /// E.g. pivot (0,0) rotates around the top left corner of the screen, not of the
    /// texture.
    pub pivot: Option<Vec2>,
}

impl Default for DrawTextureParams {
    fn default() -> DrawTextureParams {
        DrawTextureParams {
            dest_size: None,
            source: None,
            rotation: 0.,
            pivot: None,
            flip_x: false,
            flip_y: false,
        }
    }
}

pub fn draw_texture(texture: &Texture2D, x: f32, y: f32, color: Color) {
    draw_texture_ex(texture, x, y, color, Default::default());
}

pub fn draw_texture_ex(
    texture: &Texture2D,
    x: f32,
    y: f32,
    color: Color,
    params: DrawTextureParams,
) {
    let context = get_context();

    let [mut width, mut height] = texture.size().to_array();

    let Rect {
        x: mut sx,
        y: mut sy,
        w: mut sw,
        h: mut sh,
    } = params.source.unwrap_or(Rect {
        x: 0.,
        y: 0.,
        w: width,
        h: height,
    });

    let texture_opt = context
        .texture_batcher
        .get(texture)
        .map(|(batched_texture, uv)| {
            let [batched_width, batched_height] = batched_texture.size().to_array();
            sx = ((sx / width) * uv.w + uv.x) * batched_width;
            sy = ((sy / height) * uv.h + uv.y) * batched_height;
            sw = (sw / width) * uv.w * batched_width;
            sh = (sh / height) * uv.h * batched_height;

            width = batched_width;
            height = batched_height;

            batched_texture
        });
    let texture = texture_opt.as_ref().unwrap_or(texture);

    let (mut w, mut h) = match params.dest_size {
        Some(dst) => (dst.x, dst.y),
        _ => (sw, sh),
    };
    let mut x = x;
    let mut y = y;
    if params.flip_x {
        x += w;
        w = -w;
    }
    if params.flip_y {
        y += h;
        h = -h;
    }

    let pivot = params.pivot.unwrap_or(vec2(x + w / 2., y + h / 2.));
    let m = pivot;
    let p = [
        vec2(x, y) - pivot,
        vec2(x + w, y) - pivot,
        vec2(x + w, y + h) - pivot,
        vec2(x, y + h) - pivot,
    ];
    let r = params.rotation;
    let p = [
        vec2(
            p[0].x * r.cos() - p[0].y * r.sin(),
            p[0].x * r.sin() + p[0].y * r.cos(),
        ) + m,
        vec2(
            p[1].x * r.cos() - p[1].y * r.sin(),
            p[1].x * r.sin() + p[1].y * r.cos(),
        ) + m,
        vec2(
            p[2].x * r.cos() - p[2].y * r.sin(),
            p[2].x * r.sin() + p[2].y * r.cos(),
        ) + m,
        vec2(
            p[3].x * r.cos() - p[3].y * r.sin(),
            p[3].x * r.sin() + p[3].y * r.cos(),
        ) + m,
    ];
    #[rustfmt::skip]
    let vertices = [
        Vertex::new(p[0].x, p[0].y, 0.,  sx      /width,  sy      /height, color),
        Vertex::new(p[1].x, p[1].y, 0., (sx + sw)/width,  sy      /height, color),
        Vertex::new(p[2].x, p[2].y, 0., (sx + sw)/width, (sy + sh)/height, color),
        Vertex::new(p[3].x, p[3].y, 0.,  sx      /width, (sy + sh)/height, color),
    ];
    let indices: [u16; 6] = [0, 1, 2, 0, 2, 3];

    context.gl.texture(Some(texture));
    context.gl.draw_mode(DrawMode::Triangles);
    context.gl.geometry(&vertices, &indices);
}

/// Get pixel data from screen buffer and return an Image (screenshot)
pub fn get_screen_data() -> Image {
    unsafe {
        crate::window::get_internal_gl().flush();
    }

    let context = get_context();

    let texture_id = get_quad_context().new_render_texture(miniquad::TextureParams {
        width: context.screen_width as _,
        height: context.screen_height as _,
        ..Default::default()
    });

    let texture = Texture2D {
        texture: context.textures.store_texture(texture_id),
    };

    texture.grab_screen();

    texture.get_texture_data()
}

/// Texture, data stored in GPU memory
#[derive(Clone, Debug, PartialEq)]
pub struct Texture2D {
    pub(crate) texture: TextureHandle,
}

impl Drop for TextureSlotGuarded {
    fn drop(&mut self) {
        let ctx = get_context();
        ctx.textures.schedule_removed(self.0);
    }
}

impl Texture2D {
    pub fn weak_clone(&self) -> Texture2D {
        match &self.texture {
            TextureHandle::Unmanaged(id) => Texture2D::unmanaged(*id),
            TextureHandle::Managed(t) => Texture2D {
                texture: TextureHandle::ManagedWeak(t.0),
            },
            TextureHandle::ManagedWeak(t) => Texture2D {
                texture: TextureHandle::ManagedWeak(*t),
            },
        }
    }
    pub(crate) const fn unmanaged(texture: miniquad::TextureId) -> Texture2D {
        Texture2D {
            texture: TextureHandle::Unmanaged(texture),
        }
    }
    /// Creates an empty Texture2D.
    ///
    /// # Example
    /// ```
    /// # use macroquad::prelude::*;
    /// # #[macroquad::main("test")]
    /// # async fn main() {
    /// let texture = Texture2D::empty();
    /// # }
    /// ```
    pub fn empty() -> Texture2D {
        let ctx = get_context();

        Texture2D::unmanaged(ctx.gl.white_texture)
    }

    /// Creates a Texture2D from a slice of bytes that contains an encoded image.
    ///
    /// If `format` is None, it will make an educated guess on the
    /// [ImageFormat][image::ImageFormat].
    ///
    /// # Example
    /// ```
    /// # use macroquad::prelude::*;
    /// # #[macroquad::main("test")]
    /// # async fn main() {
    /// let texture = Texture2D::from_file_with_format(
    ///     include_bytes!("../examples/rust.png"),
    ///     None,
    ///     );
    /// # }
    /// ```
    pub fn from_file_with_format(bytes: &[u8], format: Option<image::ImageFormat>) -> Texture2D {
        let img = if let Some(fmt) = format {
            image::load_from_memory_with_format(bytes, fmt)
                .unwrap_or_else(|e| panic!("{}", e))
                .to_rgba8()
        } else {
            image::load_from_memory(bytes)
                .unwrap_or_else(|e| panic!("{}", e))
                .to_rgba8()
        };
        let width = img.width() as u16;
        let height = img.height() as u16;
        let bytes = img.into_raw();

        Self::from_rgba8(width, height, &bytes)
    }

    /// Creates a Texture2D from an [Image].
    pub fn from_image(image: &Image) -> Texture2D {
        Texture2D::from_rgba8(image.width, image.height, &image.bytes)
    }

    /// Creates a Texture2D from a miniquad
    /// [Texture](https://docs.rs/miniquad/0.3.0-alpha/miniquad/graphics/struct.Texture.html)
    pub const fn from_miniquad_texture(texture: miniquad::TextureId) -> Texture2D {
        Texture2D {
            texture: TextureHandle::Unmanaged(texture),
        }
    }

    /// Creates a Texture2D from a slice of bytes in an R,G,B,A sequence,
    /// with the given width and height.
    ///
    /// # Example
    ///
    /// ```
    /// # use macroquad::prelude::*;
    /// # #[macroquad::main("test")]
    /// # async fn main() {
    /// // Create a 2x2 texture from a byte slice with 4 rgba pixels
    /// let bytes: Vec<u8> = vec![255, 0, 0, 192, 0, 255, 0, 192, 0, 0, 255, 192, 255, 255, 255, 192];
    /// let texture = Texture2D::from_rgba8(2, 2, &bytes);
    /// # }
    /// ```
    pub fn from_rgba8(width: u16, height: u16, bytes: &[u8]) -> Texture2D {
        let texture = get_quad_context().new_texture_from_rgba8(width, height, bytes);
        let ctx = get_context();
        let texture = ctx.textures.store_texture(texture);
        let texture = Texture2D { texture };
        texture.set_filter(ctx.default_filter_mode);

        ctx.texture_batcher.add_unbatched(&texture);

        texture
    }

    /// Uploads [Image] data to this texture.
    pub fn update(&self, image: &Image) {
        let ctx = get_quad_context();
        let (width, height) = ctx.texture_size(self.raw_miniquad_id());

        assert_eq!(width, image.width as u32);
        assert_eq!(height, image.height as u32);

        ctx.texture_update(self.raw_miniquad_id(), &image.bytes);
    }

    // Updates the texture from an array of bytes.
    pub fn update_from_bytes(&self, width: u32, height: u32, bytes: &[u8]) {
        let ctx = get_quad_context();
        let (texture_width, texture_height) = ctx.texture_size(self.raw_miniquad_id());

        assert_eq!(texture_width, width);
        assert_eq!(texture_height, height);

        ctx.texture_update(self.raw_miniquad_id(), bytes);
    }

    /// Uploads [Image] data to part of this texture.
    pub fn update_part(
        &self,
        image: &Image,
        x_offset: i32,
        y_offset: i32,
        width: i32,
        height: i32,
    ) {
        let ctx = get_quad_context();

        ctx.texture_update_part(
            self.raw_miniquad_id(),
            x_offset,
            y_offset,
            width,
            height,
            &image.bytes,
        );
    }

    /// Returns the width of this texture.
    pub fn width(&self) -> f32 {
        let ctx = get_quad_context();
        let (width, _) = ctx.texture_size(self.raw_miniquad_id());

        width as f32
    }

    /// Returns the height of this texture.
    pub fn height(&self) -> f32 {
        let ctx = get_quad_context();
        let (_, height) = ctx.texture_size(self.raw_miniquad_id());

        height as f32
    }

    pub fn size(&self) -> Vec2 {
        let ctx = get_quad_context();
        let (width, height) = ctx.texture_size(self.raw_miniquad_id());

        vec2(width as f32, height as f32)
    }

    /// Sets the [FilterMode] of this texture.
    ///
    /// Use Nearest if you need integer-ratio scaling for pixel art, for example.
    ///
    /// # Example
    /// ```
    /// # use macroquad::prelude::*;
    /// # #[macroquad::main("test")]
    /// # async fn main() {
    /// let texture = Texture2D::empty();
    /// texture.set_filter(FilterMode::Linear);
    /// # }
    /// ```
    pub fn set_filter(&self, filter_mode: FilterMode) {
        let ctx = get_quad_context();

        ctx.texture_set_filter(
            self.raw_miniquad_id(),
            filter_mode,
            miniquad::MipmapFilterMode::None,
        );
    }

    /// Returns the handle for this texture.
    pub fn raw_miniquad_id(&self) -> miniquad::TextureId {
        let ctx = get_context();

        ctx.raw_miniquad_id(&self.texture)
    }

    /// Updates this texture from the screen.
    #[allow(unreachable_patterns)]
    pub fn grab_screen(&self) {
        use miniquad::*;
        let texture = self.raw_miniquad_id();
        let ctx = get_quad_context();
        let params = ctx.texture_params(texture);
        let raw_id = match unsafe { ctx.texture_raw_id(texture) } {
            miniquad::RawId::OpenGl(id) => id,
            _ => unimplemented!(),
        };
        let internal_format = match params.format {
            TextureFormat::RGB8 => miniquad::gl::GL_RGB,
            TextureFormat::RGBA8 => miniquad::gl::GL_RGBA,
            TextureFormat::RGBA16F => miniquad::gl::GL_RGBA,
            TextureFormat::Depth => miniquad::gl::GL_DEPTH_COMPONENT,
            TextureFormat::Depth32 => miniquad::gl::GL_DEPTH_COMPONENT,
            #[cfg(target_arch = "wasm32")]
            TextureFormat::Alpha => miniquad::gl::GL_ALPHA,
            #[cfg(not(target_arch = "wasm32"))]
            TextureFormat::Alpha => miniquad::gl::GL_R8,
        };
        unsafe {
            gl::glBindTexture(gl::GL_TEXTURE_2D, raw_id);
            gl::glCopyTexImage2D(
                gl::GL_TEXTURE_2D,
                0,
                internal_format,
                0,
                0,
                params.width as _,
                params.height as _,
                0,
            );
        }
    }

    /// Returns an [Image] from the pixel data in this texture.
    ///
    /// This operation can be expensive.
    pub fn get_texture_data(&self) -> Image {
        let ctx = get_quad_context();
        let (width, height) = ctx.texture_size(self.raw_miniquad_id());
        let mut image = Image {
            width: width as _,
            height: height as _,
            bytes: vec![0; width as usize * height as usize * 4],
        };
        ctx.texture_read_pixels(self.raw_miniquad_id(), &mut image.bytes);
        image
    }
}

pub(crate) struct Batcher {
    unbatched: Vec<Texture2D>,
    atlas: crate::text::atlas::Atlas,
}

impl Batcher {
    pub fn new(ctx: &mut dyn miniquad::RenderingBackend) -> Batcher {
        Batcher {
            unbatched: vec![],
            atlas: crate::text::atlas::Atlas::new(ctx, miniquad::FilterMode::Linear),
        }
    }

    pub fn add_unbatched(&mut self, texture: &Texture2D) {
        self.unbatched.push(texture.weak_clone());
    }

    pub fn get(&mut self, texture: &Texture2D) -> Option<(Texture2D, Rect)> {
        let id = SpriteKey::Texture(texture.raw_miniquad_id());
        let uv_rect = self.atlas.get_uv_rect(id)?;
        Some((Texture2D::unmanaged(self.atlas.texture()), uv_rect))
    }
}

/// Build an atlas out of all currently loaded texture
/// Later on all draw_texture calls with texture available in the atlas will use
/// the one from the atlas
/// NOTE: the GPU memory and texture itself in Texture2D will still be allocated
/// and Texture->Image conversions will work with Texture2D content, not the atlas
pub fn build_textures_atlas() {
    let context = get_context();

    for texture in context.texture_batcher.unbatched.drain(0..) {
        let sprite: Image = texture.get_texture_data();
        let id = SpriteKey::Texture(texture.raw_miniquad_id());

        context.texture_batcher.atlas.cache_sprite(id, sprite);
    }

    let texture = context.texture_batcher.atlas.texture();
    let (w, h) = get_quad_context().texture_size(texture);
    crate::telemetry::log_string(&format!("Atlas: {w} {h}"));
}

#[doc(hidden)]
/// Macroquad do not have track of all loaded fonts.
/// Fonts store their characters as ID's in the atlas.
/// There fore resetting the atlas will render all fonts unusable.
pub unsafe fn reset_textures_atlas() {
    let context = get_context();
    context.fonts_storage = crate::text::FontsStorage::new(&mut *context.quad_context);
    context.texture_batcher = Batcher::new(&mut *context.quad_context);
}

pub fn set_default_filter_mode(filter: FilterMode) {
    let context = get_context();

    context.default_filter_mode = filter;
    context.texture_batcher.atlas.set_filter(filter);
}

```

`src/texture/slotmap.rs`:

```rs
// Heavily reduced version of the `slotmap` crate: https://github.com/orlp/slotmap
use miniquad::TextureId;
use std::fmt;
use std::num::NonZeroU32;

#[derive(Copy, Clone, PartialEq)]
pub(crate) struct TextureSlotId {
    idx: u32,
    version: NonZeroU32,
}

impl fmt::Debug for TextureSlotId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}v{}", self.idx, self.version.get())
    }
}

impl TextureSlotId {
    fn new(idx: u32, version: u32) -> Self {
        debug_assert!(version > 0);

        Self {
            idx,
            version: unsafe { NonZeroU32::new_unchecked(version | 1) },
        }
    }
}

// Storage inside a slot or metadata for the freelist when vacant.
union SlotUnion {
    value: TextureId,
    next_free: u32,
}

// A slot, which represents storage for a value and a current version.
// Can be occupied or vacant.
struct Slot {
    u: SlotUnion,
    version: u32, // Even = vacant, odd = occupied.
}

/// Slot map, storage with stable unique keys.
pub(crate) struct TextureIdSlotMap {
    slots: Vec<Slot>,
    free_head: u32,
    num_elems: u32,
}

impl TextureIdSlotMap {
    /// Constructs a new, empty [`TextureIdSlotMap`].
    pub fn new() -> Self {
        let slots = vec![Slot {
            u: SlotUnion { next_free: 0 },
            version: 0,
        }];

        Self {
            slots,
            free_head: 1,
            num_elems: 0,
        }
    }

    /// Returns the number of elements in the slot map.
    pub const fn len(&self) -> usize {
        self.num_elems as usize
    }

    /// Returns [`true`] if the slot map contains `key`.
    #[inline(always)]
    fn contains_key(&self, key: TextureSlotId) -> bool {
        self.slots
            .get(key.idx as usize)
            .map_or(false, |slot| slot.version == key.version.get())
    }

    /// Inserts a value into the slot map. Returns a unique key that can be used
    /// to access this value.
    ///
    /// # Panics
    ///
    /// Panics if the number of elements in the slot map equals
    /// 2<sup>32</sup> - 2.
    pub fn insert(&mut self, value: TextureId) -> TextureSlotId {
        let new_num_elems = self.num_elems + 1;
        if new_num_elems == u32::MAX {
            panic!("SlotMap number of elements overflow");
        }

        if let Some(slot) = self.slots.get_mut(self.free_head as usize) {
            let occupied_version = slot.version | 1;
            let kd = TextureSlotId::new(self.free_head, occupied_version);

            // Update.
            unsafe {
                self.free_head = slot.u.next_free;
                slot.u.value = value;
                slot.version = occupied_version;
            }
            self.num_elems = new_num_elems;
            return kd;
        }

        let version = 1;
        let kd = TextureSlotId::new(self.slots.len() as u32, version);

        // Create new slot before adjusting freelist in case f or the allocation panics or errors.
        self.slots.push(Slot {
            u: SlotUnion { value },
            version,
        });

        self.free_head = kd.idx + 1;
        self.num_elems = new_num_elems;
        kd
    }

    /// Removes a key from the slot map if it is present.
    pub fn remove(&mut self, key: TextureSlotId) {
        if self.contains_key(key) {
            let idx = key.idx as usize;

            // This is safe because we know that the slot is occupied.
            let slot = unsafe { self.slots.get_unchecked_mut(idx) };

            // Maintain freelist.
            slot.u.next_free = self.free_head;
            self.free_head = idx as u32;
            self.num_elems -= 1;
            slot.version = slot.version.wrapping_add(1);
        }
    }

    /// Returns a reference to the value corresponding to the key.
    pub fn get(&self, key: TextureSlotId) -> Option<TextureId> {
        self.slots
            .get(key.idx as usize)
            .filter(|slot| slot.version == key.version.get())
            .map(|slot| unsafe { slot.u.value })
    }
}

```

`src/time.rs`:

```rs
//! Cross platform system time access and FPS counters.

use crate::{get_context, text::draw_text};

/// Draws the current FPS on the screen. For extra customization, please use `draw_text` instead.
pub fn draw_fps() {
    draw_text(&format!("FPS: {}", get_fps()), 0., 16., 32., crate::WHITE);
}

/// Returns current FPS
pub fn get_fps() -> i32 {
    let context = get_context();

    (1. / context.frame_time) as i32
}

/// Returns duration in seconds of the last frame drawn
pub fn get_frame_time() -> f32 {
    let context = get_context();

    if crate::experimental::scene::in_fixed_update() {
        crate::experimental::scene::fixed_frame_time()
    } else {
        context.frame_time as f32
    }
}

/// Returns elapsed wall-clock time in seconds since start
///
/// Note that as real world time progresses during computation,
/// the value returned will change. Therefore if you want
/// your game logic update to happen at the same *in-game* time
/// for all game objects, you should call this function once
/// save the value and reuse it throughout your code.
pub fn get_time() -> f64 {
    let context = get_context();

    miniquad::date::now() - context.start_time
}

```

`src/tobytes.rs`:

```rs
use crate::math::{Mat4, Vec2, Vec3, Vec4};

pub trait ToBytes {
    fn to_bytes(&self) -> &[u8];
}
macro_rules! impl_tobytes {
    ($t:tt) => {
        impl ToBytes for $t {
            fn to_bytes(&self) -> &[u8] {
                unsafe {
                    std::slice::from_raw_parts(self as *const _ as *const u8, size_of::<$t>())
                }
            }
        }
    };
}

impl_tobytes!(i32);
impl_tobytes!(f32);
impl_tobytes!(Vec2);
impl_tobytes!(Vec3);
impl_tobytes!(Vec4);
impl_tobytes!(Mat4);

impl<T: ToBytes, const N: usize> ToBytes for &[T; N] {
    fn to_bytes(&self) -> &[u8] {
        unsafe { std::slice::from_raw_parts(*self as *const _ as *const u8, size_of::<T>() * N) }
    }
}

impl<T: ToBytes> ToBytes for &[T] {
    fn to_bytes(&self) -> &[u8] {
        unsafe {
            std::slice::from_raw_parts(
                self.as_ptr() as *const _ as *const u8,
                size_of::<T>() * self.len(),
            )
        }
    }
}

```

`src/ui.rs`:

```rs
//! Immediate mode UI.
//!
//! Spiritual successor of megaui library, but fully skinnable and configurable.
//!
//! The UI entrypoint is `root_ui()` call.
//! ```ignore
//! root_ui().label(None, "hello megaui");
//! if root_ui().button(None, "Push me") {
//!    println!("pushed");
//! }
//! ```
//! This will draw a label and a button one after each other right on top of the
//! screen.

pub mod canvas;
mod clipboard;
#[macro_use]
mod hash;
mod input_handler;
mod render;
mod style;

pub mod widgets;

pub use clipboard::ClipboardObject;
pub use input_handler::{InputHandler, KeyCode};
pub use render::{DrawList, Vertex};
pub use style::{Skin, Style, StyleBuilder};

pub use crate::hash;

pub(crate) use render::ElementState;

use std::{
    borrow::Cow,
    ops::DerefMut,
    sync::{Arc, Mutex},
};

/// Root UI. Widgets drawn with the root ui will be always presented at the end of the frame with a "default" camera.
/// UI space would be a "default" screen space (0..screen_width(), 0..screen_height())
pub fn root_ui() -> impl DerefMut<Target = Ui> {
    crate::get_context().ui_context.ui.borrow_mut()
}

/// Current camera world space UI.
/// Widgets will be drawn either at the end of the frame or just before next "set_camera" clal
/// UI space would be equal to the camera space, widgets will be drawn at the plane with Y up X right and Z = 0.
/// Note that windows focus queue, input focus etc is shared across all cameras.
/// So this:
///
/// ```skip
/// camera_ui().draw_window();
/// set_camera(..);
/// camera_ui().draw_window();
/// root_ui().draw_window();
/// ```
/// Will result 3 windows on the screen, all in different cameras and probably looking differently,
/// but only one of them would be focused.
#[doc(hidden)]
#[allow(unreachable_code)]
pub fn camera_ui() -> impl DerefMut<Target = Ui> {
    unimplemented!() as &'static mut Ui
}

use crate::{
    math::{Rect, RectOffset, Vec2},
    text::{
        atlas::{Atlas, SpriteKey},
        Font,
    },
    texture::Image,
    ui::{canvas::DrawCanvas, render::Painter},
};

use std::collections::HashMap;
mod cursor;
mod input;
mod key_repeat;

use cursor::Cursor;
use input::Input;

pub use cursor::Layout;
use input::{InputCharacter, Key};

/// Is used to keep track of internal state of various widgets like [widgets::Window](macroquad::ui::widgets::Window)
/// These should be unique per window and ideally not change in between frames.
pub type Id = u64;

pub enum UiContent<'a> {
    Label(Cow<'a, str>),
    Texture(crate::texture::Texture2D),
}

impl<'a> From<&'a str> for UiContent<'a> {
    fn from(data: &'a str) -> UiContent<'a> {
        UiContent::Label(data.into())
    }
}

impl From<String> for UiContent<'static> {
    fn from(data: String) -> UiContent<'static> {
        UiContent::Label(data.into())
    }
}

impl From<crate::texture::Texture2D> for UiContent<'static> {
    fn from(data: crate::texture::Texture2D) -> UiContent<'static> {
        UiContent::Texture(data)
    }
}

pub(crate) struct Window {
    pub id: Id,
    pub parent: Option<Id>,
    // active is set to true when the begin_window is called on this window
    // and is going to be set to false at the end of each frame
    pub active: bool,
    // was the window "active" during the last frame
    // the way to find out which windows should be rendered after end of the frame and during next frame, before begin_window of the next frame will be called on each window
    pub was_active: bool,
    pub title_height: f32,
    pub position: Vec2,
    pub size: Vec2,
    pub vertical_scroll_bar_width: f32,
    pub movable: bool,
    pub painter: Painter,
    pub cursor: Cursor,
    pub childs: Vec<Id>,
    pub want_close: bool,
    pub force_focus: bool,

    margin: f32,
    window_margin: RectOffset,
}

impl Window {
    pub fn new(
        id: Id,
        parent: Option<Id>,
        position: Vec2,
        size: Vec2,
        title_height: f32,
        window_margin: RectOffset,
        margin: f32,
        movable: bool,
        force_focus: bool,
        atlas: Arc<Mutex<Atlas>>,
    ) -> Window {
        Window {
            id,
            position,
            size,
            vertical_scroll_bar_width: 0.,
            title_height,
            parent,
            was_active: false,
            active: false,
            painter: Painter::new(atlas),
            cursor: Cursor::new(
                Rect::new(
                    position.x + window_margin.left,
                    position.y + title_height + window_margin.top,
                    size.x - window_margin.left - window_margin.right,
                    size.y - title_height - window_margin.top - window_margin.bottom,
                ),
                margin,
            ),
            margin,
            window_margin,
            childs: vec![],
            want_close: false,
            movable,
            force_focus,
        }
    }

    pub fn resize(&mut self, size: Vec2) {
        self.size = size;
        self.cursor = Cursor::new(
            Rect::new(
                self.position.x + self.window_margin.left,
                self.position.y + self.title_height + self.window_margin.top,
                self.size.x - self.window_margin.left - self.window_margin.right,
                self.size.y
                    - self.title_height
                    - self.window_margin.top
                    - self.window_margin.bottom,
            ),
            self.margin,
        );
    }

    pub const fn top_level(&self) -> bool {
        self.parent.is_none()
    }

    pub const fn full_rect(&self) -> Rect {
        Rect::new(self.position.x, self.position.y, self.size.x, self.size.y)
    }

    pub fn content_rect(&self) -> Rect {
        Rect::new(
            self.position.x,
            self.position.y + self.title_height,
            self.size.x - self.vertical_scroll_bar_width,
            self.size.y - self.title_height,
        )
    }

    pub fn set_position(&mut self, position: Vec2) {
        self.position = position;
        self.cursor.area.x = position.x + self.window_margin.left;
        self.cursor.area.y = position.y + self.title_height + self.window_margin.top;
    }

    pub const fn title_rect(&self) -> Rect {
        Rect::new(
            self.position.x,
            self.position.y,
            self.size.x,
            self.title_height,
        )
    }

    pub fn same_line(&mut self, x: f32) {
        self.cursor.next_same_line = Some(x);
    }
}

#[derive(Copy, Clone, Debug)]
pub enum DragState {
    Clicked(Vec2),
    Dragging(Vec2),
}

#[derive(Copy, Clone, Debug)]
pub enum Drag {
    No,
    Dragging(Vec2, Option<Id>),
    Dropped(Vec2, Option<Id>),
}

struct StyleStack {
    default_skin: Skin,
    custom_skin_stack: Vec<Skin>,
}

impl StyleStack {
    fn new(atlas: Arc<Mutex<Atlas>>, default_font: Arc<Mutex<Font>>) -> StyleStack {
        StyleStack {
            default_skin: Skin::new(atlas, default_font),
            custom_skin_stack: vec![],
        }
    }

    fn top(&self) -> &Skin {
        self.custom_skin_stack.last().unwrap_or(&self.default_skin)
    }
}

pub(crate) struct TabSelector {
    counter: isize,
    wants: Option<isize>,
    to_change: Option<isize>,
}

impl TabSelector {
    const fn new() -> Self {
        TabSelector {
            counter: 0,
            wants: None,
            to_change: None,
        }
    }

    fn new_frame(&mut self) {
        self.to_change = if self.wants == Some(-1) {
            Some(self.counter - 1)
        } else if self.wants == Some(self.counter) {
            Some(0)
        } else {
            self.wants
        };
        self.wants = None;
        self.counter = 0;
    }

    /// Returns true if this widget should gain focus, because user pressed `Tab` or `Shift + Tab`.
    pub(crate) fn register_selectable_widget(&mut self, has_focus: bool, input: &Input) -> bool {
        if has_focus {
            enum PressedTabKey {
                Tab,
                ShiftTab,
                Other,
            }

            let key = if input
                .input_buffer
                .iter()
                .any(|inp| inp.key == Key::KeyCode(KeyCode::Tab) && inp.modifier_shift)
            {
                PressedTabKey::ShiftTab
            } else if input
                .input_buffer
                .iter()
                .any(|inp| inp.key == Key::KeyCode(KeyCode::Tab))
            {
                PressedTabKey::Tab
            } else {
                PressedTabKey::Other
            };

            match key {
                PressedTabKey::Tab => self.wants = Some(self.counter + 1),
                PressedTabKey::ShiftTab => self.wants = Some(self.counter - 1),
                PressedTabKey::Other => {}
            }
        }

        let result = if self.to_change.map(|id| id == self.counter).unwrap_or(false) {
            self.to_change = None;
            true
        } else {
            false
        };

        self.counter += 1;

        result
    }
}

pub struct Ui {
    input: Input,
    skin_stack: StyleStack,
    /// Returns the number of frames that have elapsed since the program started.
    pub frame: u64,
    pub(crate) time: f32,

    moving: Option<(Id, Vec2)>,
    windows: HashMap<Id, Window>,
    // special window that is always rendered on top of anything
    // TODO: maybe make modal windows stack instead
    modal: Option<Window>,
    // another special window
    // always rendered behind everything and do not have borders or scrolls
    // helps using window-less uis
    root_window: Window,
    windows_focus_order: Vec<Id>,

    storage_u32: HashMap<Id, u32>,
    storage_any: AnyStorage,

    dragging: Option<(Id, DragState)>,
    drag_hovered: Option<Id>,
    drag_hovered_previous_frame: Option<Id>,
    active_window: Option<Id>,
    hovered_window: Id,
    in_modal: bool,
    child_window_stack: Vec<Id>,

    last_item_clicked: bool,
    last_item_hovered: bool,

    pub(crate) atlas: Arc<Mutex<Atlas>>,
    pub(crate) default_font: Arc<Mutex<Font>>,

    clipboard_selection: String,
    clipboard: Box<dyn crate::ui::ClipboardObject>,

    key_repeat: key_repeat::KeyRepeat,

    tab_selector: TabSelector,
    input_focus: Option<Id>,
}

#[derive(Default)]
pub(crate) struct AnyStorage {
    storage: HashMap<Id, Box<dyn std::any::Any>>,
}

impl AnyStorage {
    pub(crate) fn get_or_insert_with<T: Default + 'static, F: Fn() -> T>(
        &mut self,
        id: Id,
        f: F,
    ) -> &mut T {
        self.storage
            .entry(id)
            .or_insert_with(|| Box::new(f()))
            .downcast_mut::<T>()
            .unwrap()
    }

    pub(crate) fn get_or_default<T: Default + 'static>(&mut self, id: Id) -> &mut T {
        self.storage
            .entry(id)
            .or_insert_with(|| Box::new(T::default()))
            .downcast_mut::<T>()
            .unwrap()
    }
}

pub(crate) struct WindowContext<'a> {
    pub window: &'a mut Window,
    pub dragging: &'a mut Option<(Id, DragState)>,
    pub drag_hovered: &'a mut Option<Id>,
    pub drag_hovered_previous_frame: &'a mut Option<Id>,
    pub storage_u32: &'a mut HashMap<Id, u32>,
    pub storage_any: &'a mut AnyStorage,
    pub style: &'a Skin,
    pub input: &'a mut Input,
    pub clipboard_selection: &'a mut String,
    pub clipboard: &'a mut dyn crate::ui::ClipboardObject,
    pub focused: bool,
    pub last_item_clicked: &'a mut bool,
    pub last_item_hovered: &'a mut bool,
    pub tab_selector: &'a mut TabSelector,
    pub input_focus: &'a mut Option<Id>,
}

impl<'a> WindowContext<'a> {
    pub(crate) fn scroll_area(&mut self) {
        let inner_rect = self.window.cursor.scroll.inner_rect_previous_frame;
        let rect = self.window.content_rect();
        let rect = Rect {
            w: rect.w + self.window.vertical_scroll_bar_width,
            ..rect
        };

        self.window.cursor.scroll.scroll = Vec2::new(
            -self.window.cursor.scroll.rect.x,
            -self.window.cursor.scroll.rect.y,
        );

        if inner_rect.h > rect.h {
            self.window.vertical_scroll_bar_width = self.style.scroll_width;
            self.draw_vertical_scroll_bar(
                rect,
                Rect::new(
                    rect.x + rect.w - self.style.scroll_width,
                    rect.y,
                    self.style.scroll_width,
                    rect.h,
                ),
            );
        } else {
            self.window.vertical_scroll_bar_width = 0.;
        }

        self.window.cursor.scroll.update();
    }

    pub(crate) fn close(&mut self) {
        self.window.want_close = true;
    }

    fn draw_vertical_scroll_bar(&mut self, area: Rect, rect: Rect) {
        let scroll = &mut self.window.cursor.scroll;
        let inner_rect = scroll.inner_rect_previous_frame;
        let size = scroll.rect.h / inner_rect.h * rect.h;
        let pos = (scroll.rect.y - inner_rect.y) / inner_rect.h * rect.h;

        self.window.painter.draw_line(
            Vec2::new(rect.x, rect.y),
            Vec2::new(rect.x, rect.y + rect.h),
            self.style.scrollbar_style.color(ElementState {
                focused: self.focused,
                ..Default::default()
            }),
        );

        let mut clicked = false;
        let mut hovered = false;
        let bar = Rect::new(rect.x + 1., rect.y + pos, rect.w - 1., size);
        let k = inner_rect.h / scroll.rect.h;
        if bar.contains(self.input.mouse_position) {
            hovered = true;
        }
        if hovered && self.input.is_mouse_down() {
            self.input.cursor_grabbed = true;
            scroll.dragging_y = true;
            scroll.initial_scroll.y = scroll.rect.y - self.input.mouse_position.y * k;
        }
        if scroll.dragging_y && self.input.is_mouse_down == false {
            self.input.cursor_grabbed = false;
            scroll.dragging_y = false;
        }
        if scroll.dragging_y {
            clicked = true;
            scroll.scroll_to(self.input.mouse_position.y * k + scroll.initial_scroll.y);
        }

        if self.focused
            && area.contains(self.input.mouse_position)
            && self.input.mouse_wheel.y != 0.
        {
            scroll.scroll_to(
                scroll.rect.y + self.input.mouse_wheel.y * k * self.style.scroll_multiplier,
            );
        }

        self.window.painter.draw_rect(
            bar,
            None,
            self.style.scrollbar_handle_style.color(ElementState {
                focused: self.focused,
                hovered,
                clicked,
                selected: false,
            }),
        );
    }

    pub fn register_click_intention(&mut self, rect: Rect) -> (bool, bool) {
        *self.last_item_hovered =
            self.input.window_active && rect.contains(self.input.mouse_position);
        *self.last_item_clicked = *self.last_item_hovered && self.input.click_down();

        (*self.last_item_hovered, *self.last_item_clicked)
    }

    pub fn input_focused(&self, id: Id) -> bool {
        self.input_focus
            .map_or(false, |input_focus| input_focus == id)
    }
}

impl InputHandler for Ui {
    fn mouse_down(&mut self, position: (f32, f32)) {
        let position = Vec2::new(position.0, position.1);

        self.input.is_mouse_down = true;
        self.input.click_down = true;
        self.input.mouse_position = position;

        if let Some(ref window) = self.modal {
            let rect = Rect::new(
                window.position.x,
                window.position.y,
                window.size.x,
                window.size.y,
            );
            if window.was_active && rect.contains(position) {
                return;
            }
        }

        for (n, window) in self.windows_focus_order.iter().enumerate() {
            let window = &self.windows[window];

            if window.was_active == false {
                continue;
            }

            if window.top_level() && window.title_rect().contains(position) && window.movable {
                self.moving = Some((
                    window.id,
                    position - Vec2::new(window.position.x, window.position.y),
                ));
            }

            if window.top_level() && window.full_rect().contains(position) {
                let window = self.windows_focus_order.remove(n);
                self.windows_focus_order.insert(0, window);
                return;
            }
        }
    }

    fn mouse_up(&mut self, _: (f32, f32)) {
        self.input.is_mouse_down = false;
        self.input.click_up = true;
        self.moving = None;
    }

    fn mouse_wheel(&mut self, x: f32, y: f32) {
        self.input.mouse_wheel = Vec2::new(x, y);
    }

    fn mouse_move(&mut self, position: (f32, f32)) {
        let position = Vec2::new(position.0, position.1);

        // assuming that the click was to the root window
        // if it is not - hovered_window will be set a little later in that function
        self.hovered_window = 0;
        for window in self.windows_focus_order.iter() {
            let window = &self.windows[window];

            if window.top_level() && window.was_active && window.full_rect().contains(position) {
                self.hovered_window = window.id;
                break;
            }
        }

        match &self.modal {
            Some(modal) if modal.was_active || modal.active => {
                if modal.full_rect().contains(position) {
                    self.hovered_window = modal.id;
                }
            }
            _ => {}
        }

        self.input.mouse_position = position;
        if let Some((id, orig)) = self.moving.as_ref() {
            self.windows
                .get_mut(id)
                .unwrap()
                .set_position(Vec2::new(position.x - orig.x, position.y - orig.y));
        }
    }

    fn char_event(&mut self, character: char, shift: bool, ctrl: bool) {
        self.input.modifier_ctrl = ctrl;
        self.input.input_buffer.push(input::InputCharacter {
            key: input::Key::Char(character),
            modifier_shift: shift,
            modifier_ctrl: ctrl,
        });
    }

    fn key_down(&mut self, key: KeyCode, shift: bool, ctrl: bool) {
        self.input.modifier_ctrl = ctrl;

        if key == KeyCode::Escape {
            self.input.escape = true;
        }
        if key == KeyCode::Enter {
            self.input.enter = true;
        }

        if ctrl && (key == KeyCode::C || key == KeyCode::X) {
            self.clipboard.set(&self.clipboard_selection);
        }

        if key != KeyCode::Control && self.key_repeat.add_repeat_gap(key, self.time) {
            self.input.input_buffer.push(input::InputCharacter {
                key: input::Key::KeyCode(key),
                modifier_shift: shift,
                modifier_ctrl: ctrl,
            });
        }
    }
}

impl Ui {
    pub fn new(
        ctx: &mut dyn miniquad::RenderingBackend,
        screen_width: f32,
        screen_height: f32,
    ) -> Ui {
        let atlas = Arc::new(Mutex::new(Atlas::new(ctx, miniquad::FilterMode::Nearest)));
        let font =
            crate::text::Font::load_from_bytes(atlas.clone(), include_bytes!("ProggyClean.ttf"))
                .unwrap();

        for character in crate::text::Font::ascii_character_list() {
            font.cache_glyph(character, 13);
        }

        atlas
            .lock()
            .unwrap()
            .cache_sprite(SpriteKey::Id(0), Image::gen_image_color(1, 1, crate::WHITE));

        let font = Arc::new(Mutex::new(font));
        Ui {
            input: Input::default(),
            default_font: font.clone(),
            skin_stack: StyleStack::new(atlas.clone(), font),
            frame: 0,
            moving: None,
            windows: HashMap::default(),
            modal: None,
            root_window: {
                let mut window = Window::new(
                    0,
                    None,
                    Vec2::new(0., 0.),
                    Vec2::new(screen_width, screen_height),
                    0.0,
                    RectOffset::new(0.0, 0.0, 0.0, 0.0),
                    0.0,
                    false,
                    true,
                    atlas.clone(),
                );
                window.active = true;
                window.was_active = true;
                window
            },
            windows_focus_order: vec![],
            dragging: None,
            active_window: None,
            hovered_window: 0,
            in_modal: false,
            child_window_stack: vec![],
            drag_hovered: None,
            drag_hovered_previous_frame: None,
            storage_u32: HashMap::default(),
            storage_any: AnyStorage::default(),
            atlas,
            clipboard_selection: String::new(),
            clipboard: Box::new(ui_context::ClipboardObject),
            time: 0.0,
            key_repeat: key_repeat::KeyRepeat::new(),
            last_item_clicked: false,
            last_item_hovered: false,
            tab_selector: TabSelector::new(),
            input_focus: None,
        }
    }

    pub fn set_default_skin(&mut self, _skin: Skin) {
        unimplemented!()
    }

    pub fn style_builder(&self) -> StyleBuilder {
        StyleBuilder::new(self.default_font.clone(), self.atlas.clone())
    }

    pub fn default_skin(&self) -> Skin {
        self.skin_stack.top().clone()
    }

    pub(crate) fn begin_window(
        &mut self,
        id: Id,
        parent: Option<Id>,
        position: Vec2,
        size: Vec2,
        titlebar: bool,
        movable: bool,
    ) -> WindowContext {
        if parent.is_some() {
            self.child_window_stack
                .push(self.active_window.unwrap_or(0));
        }
        self.input.window_active = self.is_input_hovered(id);

        self.active_window = Some(id);

        let focused = self.is_focused(id);
        let margin = self.skin_stack.top().margin;
        let margin_window = self.skin_stack.top().window_style.border_margin();

        let title_height = if titlebar {
            self.skin_stack.top().title_height
        } else {
            0.
        };
        let atlas = self.atlas.clone();
        let windows_focus_order = &mut self.windows_focus_order;

        let parent_force_focus = match parent {
            // childs of root window are always force_focused
            Some(0) => true,
            // childs of force_focused windows are always force_focused as well
            Some(parent) => self
                .windows
                .get(&parent)
                .map_or(false, |window| window.force_focus),
            _ => false,
        };
        let parent_clip_rect = if let Some(parent) = parent {
            self.windows
                .get(&parent)
                .and_then(|window| window.painter.clipping_zone)
        } else {
            None
        };

        let window = &mut *self.windows.entry(id).or_insert_with(|| {
            if parent.is_none() {
                windows_focus_order.push(id);
            }

            Window::new(
                id,
                parent,
                position,
                size,
                title_height,
                margin_window,
                margin,
                movable,
                parent_force_focus,
                atlas,
            )
        });
        if !window.movable {
            window.set_position(position);
        }
        window.size = size;
        window.want_close = false;
        window.active = true;
        window.painter.clipping_zone = parent_clip_rect;

        // top level windows are movable, so we update their position only on the first frame
        // while the child windows are not movable and should update their position each frame
        if parent.is_some() {
            window.set_position(position);
        }

        WindowContext {
            focused,
            window,
            input: &mut self.input,
            style: self.skin_stack.top(),
            dragging: &mut self.dragging,
            drag_hovered: &mut self.drag_hovered,
            drag_hovered_previous_frame: &mut self.drag_hovered_previous_frame,
            storage_u32: &mut self.storage_u32,
            storage_any: &mut self.storage_any,
            clipboard_selection: &mut self.clipboard_selection,
            clipboard: &mut *self.clipboard,
            last_item_clicked: &mut self.last_item_clicked,
            last_item_hovered: &mut self.last_item_hovered,
            tab_selector: &mut self.tab_selector,
            input_focus: &mut self.input_focus,
        }
    }

    pub(crate) fn begin_modal(&mut self, id: Id, position: Vec2, size: Vec2) -> WindowContext {
        self.input.window_active = true;
        self.in_modal = true;

        let atlas = self.atlas.clone();

        let window = self.modal.get_or_insert_with(|| {
            Window::new(
                id,
                None,
                position,
                size,
                0.0,
                RectOffset::new(0.0, 0.0, 0.0, 0.0),
                0.0,
                false,
                true,
                atlas,
            )
        });

        window.parent = self.active_window;
        window.size = size;
        window.want_close = false;
        window.active = true;
        window.painter.clipping_zone = Some(Rect::new(position.x, position.y, size.x, size.y));
        window.set_position(position);

        WindowContext {
            focused: true,
            window,
            input: &mut self.input,
            style: self.skin_stack.top(),
            dragging: &mut self.dragging,
            drag_hovered: &mut self.drag_hovered,
            drag_hovered_previous_frame: &mut self.drag_hovered_previous_frame,
            storage_u32: &mut self.storage_u32,
            storage_any: &mut self.storage_any,
            clipboard_selection: &mut self.clipboard_selection,
            clipboard: &mut *self.clipboard,
            last_item_clicked: &mut self.last_item_clicked,
            last_item_hovered: &mut self.last_item_hovered,
            tab_selector: &mut self.tab_selector,
            input_focus: &mut self.input_focus,
        }
    }

    pub(crate) fn end_modal(&mut self) {
        self.in_modal = false;
        self.input.window_active = self.is_input_hovered(self.active_window.unwrap_or(0));
    }

    pub(crate) fn end_window(&mut self) {
        self.active_window = self.child_window_stack.pop();
        self.input.window_active = self.is_input_hovered(self.active_window.unwrap_or(0));
    }

    pub(crate) fn get_active_window_context(&mut self) -> WindowContext {
        let focused;
        let window = if self.in_modal == false {
            match self.active_window {
                None | Some(0) => {
                    focused = true;
                    &mut self.root_window
                }
                Some(active_window) => {
                    focused = self.is_focused(active_window);
                    self.windows.get_mut(&active_window).unwrap()
                }
            }
        } else {
            focused = true;
            self.modal.as_mut().unwrap()
        };

        WindowContext {
            window,
            focused,
            input: &mut self.input,
            style: self.skin_stack.top(),
            dragging: &mut self.dragging,
            drag_hovered: &mut self.drag_hovered,
            drag_hovered_previous_frame: &mut self.drag_hovered_previous_frame,
            storage_u32: &mut self.storage_u32,
            storage_any: &mut self.storage_any,
            clipboard_selection: &mut self.clipboard_selection,
            clipboard: &mut *self.clipboard,
            last_item_clicked: &mut self.last_item_clicked,
            last_item_hovered: &mut self.last_item_hovered,
            tab_selector: &mut self.tab_selector,
            input_focus: &mut self.input_focus,
        }
    }

    /// Returns true if the last widget which had `.ui` called on it is being clicked.
    pub fn last_item_clicked(&mut self) -> bool {
        self.last_item_clicked
    }

    /// Returns true if the mouse is over the last widget which had `.ui` called on it.
    pub fn last_item_hovered(&mut self) -> bool {
        self.last_item_hovered
    }

    /// Scrolls the middle of the active GUI window to its GUI cursor
    ///
    /// Note that this does not work on the first frame of the GUI application.
    /// If you want your widget to start with its scrollbar in a particular location,
    /// consider `if ui.frame == 1 { ui.scroll_here() }`.
    pub fn scroll_here(&mut self) {
        self.scroll_here_ratio(0.5);
    }

    /// Scrolls the active GUI window to its GUI cursor.
    ///
    /// 1.0 puts the bottom of the window at the GUI cursor,
    /// 0.0 puts the top of the window there.
    ///
    /// 0.5 as the ratio puts the middle of the window at the GUI cursor,
    /// and is equivalent to `Ui::scroll_here`.
    pub fn scroll_here_ratio(&mut self, ratio: f32) {
        let context = self.get_active_window_context();
        let cursor = &mut context.window.cursor;
        cursor.scroll.scroll_to(cursor.y - cursor.area.h * ratio);
    }

    /// How far the active gui window has been scrolled down on the y axis.
    ///
    /// Note that for these purposes, a Group widget is still considered a Window
    /// because it can have its own scrollbar.
    pub fn scroll(&mut self) -> Vec2 {
        self.get_active_window_context().window.cursor.scroll.scroll
    }

    /// The farthest down a scrollbar may go given the constraints of its window.
    ///
    /// Note that for these purposes, a Group widget is still considered a Window
    /// because it can have its own scrollbar.
    pub fn scroll_max(&mut self) -> Vec2 {
        let cursor = &self.get_active_window_context().window.cursor;
        Vec2::new(
            cursor.scroll.inner_rect.w - cursor.area.w,
            cursor.scroll.inner_rect.h - cursor.area.h,
        )
    }

    pub const fn is_mouse_captured(&self) -> bool {
        self.input.cursor_grabbed
    }

    pub fn is_mouse_over(&self, mouse_position: Vec2) -> bool {
        for window in self.windows_focus_order.iter() {
            let window = &self.windows[window];
            if window.was_active == false {
                continue;
            }
            if window.full_rect().contains(mouse_position) {
                return true;
            }
        }
        if let Some(window) = &self.modal {
            if window.was_active {
                if window.full_rect().contains(mouse_position) {
                    return true;
                }
            }
        }
        false
    }

    pub fn active_window_focused(&self) -> bool {
        self.active_window.map_or(false, |wnd| self.is_focused(wnd))
    }

    pub const fn is_dragging(&self) -> bool {
        self.dragging.is_some()
    }

    pub fn close_current_window(&mut self) {
        let mut context = self.get_active_window_context();
        context.close();
    }

    fn is_input_hovered(&self, id: Id) -> bool {
        // if thats exactly the clicked window - it's always the hovered one
        if id == self.hovered_window {
            return true;
        }

        // hovered window is always the root window and the given id may be the child
        // window id
        // so need to figure the root id

        if self.in_modal {
            true
        } else {
            self.child_window_stack
                .get(0)
                .map_or(false, |root| *root == self.hovered_window)
        }
    }

    fn is_focused(&self, id: Id) -> bool {
        if self
            .windows
            .get(&id)
            .map_or(false, |window| window.force_focus)
        {
            return true;
        }

        if let Some(focused_window) = self
            .windows_focus_order
            .iter()
            .find(|window| self.windows[window].was_active || self.windows[window].active)
        {
            if id == *focused_window {
                return true;
            }
            if let Some(parent) = self.child_window_stack.get(0) {
                return *parent == *focused_window;
            }
        }

        false
    }

    pub fn new_frame(&mut self, delta: f32) {
        self.root_window.resize(crate::math::vec2(
            crate::window::screen_width(),
            crate::window::screen_height(),
        ));

        self.frame += 1;
        self.time += delta;

        self.last_item_clicked = false;
        self.last_item_hovered = false;

        self.drag_hovered_previous_frame = self.drag_hovered;
        self.drag_hovered = None;
        self.input.reset();
        self.input.window_active = self.hovered_window == 0;

        self.tab_selector.new_frame();

        self.key_repeat.new_frame(self.time);

        for (_, window) in &mut self.windows {
            window.painter.clear();
            window.cursor.reset();
            window.was_active = window.active;
            window.active = false;
            window.childs.clear();
        }

        if let Some(window) = &mut self.modal {
            window.painter.clear();
            window.cursor.reset();
            window.was_active = window.active;
            window.active = false;
            window.childs.clear();
        }

        {
            self.root_window.painter.clear();
            self.root_window.cursor.reset();
            self.root_window.childs.clear();
        }
    }

    pub fn render(&mut self, draw_list: &mut Vec<DrawList>) {
        self.render_window(&self.root_window, Vec2::new(0., 0.), draw_list);

        for window in self.windows_focus_order.iter().rev() {
            let window = &self.windows[window];
            if window.was_active {
                self.render_window(window, Vec2::new(0., 0.), draw_list);
            }
        }

        if let Some(modal) = self.modal.as_ref() {
            if modal.was_active {
                self.render_window(modal, Vec2::new(0., 0.), draw_list);
            }
        }

        if let Some((id, DragState::Dragging(orig))) = self.dragging {
            let window = &self.windows[&id];

            self.render_window(window, self.input.mouse_position - orig, draw_list);
        }
    }

    fn render_window(&self, window: &Window, offset: Vec2, draw_list: &mut Vec<DrawList>) {
        for cmd in &window.painter.commands {
            crate::ui::render::render_command(draw_list, cmd.offset(offset));
        }

        for child in &window.childs {
            let child_window = &self.windows[child];
            if window.content_rect().overlaps(&child_window.full_rect()) {
                self.render_window(child_window, offset, draw_list);
            }
        }
    }

    pub fn focus_window(&mut self, id: Id) {
        if let Some(n) = self.windows_focus_order.iter().position(|win| *win == id) {
            let window = self.windows_focus_order.remove(n);
            self.windows_focus_order.insert(0, window);
        }
    }

    pub fn set_input_focus(&mut self, id: Id) {
        self.input_focus = Some(id);
    }

    pub fn clear_input_focus(&mut self) {
        self.input_focus = None;
    }

    pub fn move_window(&mut self, id: Id, position: Vec2) {
        if let Some(window) = self.windows.get_mut(&id) {
            window.set_position(position);
        }
    }

    pub fn same_line(&mut self, x: f32) {
        let context = self.get_active_window_context();
        context.window.same_line(x);
    }

    pub fn canvas(&mut self) -> DrawCanvas {
        let context = self.get_active_window_context();

        DrawCanvas { context }
    }

    /// small hack to keep some internal state
    /// used like this:
    /// ```skip
    /// if ui.last_item_clicked() {
    ///     *ui.get_bool(hash!("color picker opened")) ^= true;
    /// }
    /// if *ui.get_bool(hash!("color picker opened"))  {
    /// }
    /// ```
    pub fn get_bool(&mut self, id: Id) -> &mut bool {
        self.storage_any.get_or_default(id)
    }

    pub fn get_any<T: std::any::Any + Default>(&mut self, id: Id) -> &mut T {
        self.storage_any.get_or_default(id)
    }

    pub fn push_skin(&mut self, skin: &Skin) {
        self.skin_stack.custom_skin_stack.push(skin.clone());
    }

    pub fn pop_skin(&mut self) {
        self.skin_stack.custom_skin_stack.pop();
    }
}

pub(crate) mod ui_context {
    use crate::prelude::*;
    use crate::window::miniquad::*;

    use crate::ui as megaui;

    use std::cell::RefCell;
    use std::rc::Rc;

    pub(crate) struct UiContext {
        pub ui: Rc<RefCell<megaui::Ui>>,
        ui_draw_list: Vec<megaui::DrawList>,
        material: Option<Material>,
    }

    impl UiContext {
        pub(crate) fn new(
            ctx: &mut dyn miniquad::RenderingBackend,
            screen_width: f32,
            screen_height: f32,
        ) -> UiContext {
            let ui = megaui::Ui::new(ctx, screen_width, screen_height);

            UiContext {
                ui: Rc::new(RefCell::new(ui)),
                ui_draw_list: vec![],
                material: None,
            }
        }

        pub(crate) fn process_input(&mut self) {
            use megaui::InputHandler;

            let mouse_position = mouse_position();

            let mut ui = self.ui.borrow_mut();
            ui.mouse_move(mouse_position);

            if is_mouse_button_pressed(MouseButton::Left) {
                ui.mouse_down(mouse_position);
            }
            if is_mouse_button_released(MouseButton::Left) {
                ui.mouse_up(mouse_position);
            }

            let shift = is_key_down(KeyCode::LeftShift) || is_key_down(KeyCode::RightShift);
            let ctrl = is_key_down(KeyCode::LeftControl) || is_key_down(KeyCode::RightControl);

            while let Some(c) = get_char_pressed_ui() {
                if ctrl == false {
                    ui.char_event(c, false, false);
                }
            }

            macro_rules! process {
                ($code:tt) => {
                    if is_key_pressed(KeyCode::$code) || is_key_down(KeyCode::$code) {
                        ui.key_down(megaui::KeyCode::$code, shift, ctrl);
                    }
                };
            }

            process!(Up);
            process!(Down);
            process!(Right);
            process!(Left);
            process!(Home);
            process!(End);
            process!(Delete);
            process!(Backspace);
            process!(Tab);
            process!(Z);
            process!(Y);
            process!(C);
            process!(X);
            process!(V);
            process!(A);
            process!(Escape);
            process!(Enter);

            if is_key_down(KeyCode::LeftControl)
                || is_key_down(KeyCode::RightControl)
                || is_key_pressed(KeyCode::LeftControl)
                || is_key_pressed(KeyCode::RightControl)
            {
                ui.key_down(megaui::KeyCode::Control, shift, ctrl);
            }
            let (wheel_x, wheel_y) = mouse_wheel();
            ui.mouse_wheel(wheel_x, -wheel_y);
        }

        pub(crate) fn draw(
            &mut self,
            ctx: &mut dyn miniquad::RenderingBackend,
            quad_gl: &mut QuadGl,
        ) {
            // TODO: this belongs to new and waits for cleaning up context initialization mess
            let material = self.material.get_or_insert_with(|| {
                load_material(
                    match ctx.info().backend {
                        Backend::OpenGl => ShaderSource::Glsl {
                            vertex: VERTEX_SHADER,
                            fragment: FRAGMENT_SHADER,
                        },
                        Backend::Metal => ShaderSource::Msl {
                            program: METAL_SHADER,
                        },
                    },
                    MaterialParams {
                        pipeline_params: PipelineParams {
                            color_blend: Some(BlendState::new(
                                Equation::Add,
                                BlendFactor::Value(BlendValue::SourceAlpha),
                                BlendFactor::OneMinusValue(BlendValue::SourceAlpha),
                            )),
                            ..Default::default()
                        },
                        ..Default::default()
                    },
                )
                .unwrap()
            });

            let mut ui = self.ui.borrow_mut();
            self.ui_draw_list.clear();
            ui.render(&mut self.ui_draw_list);
            let mut ui_draw_list = vec![];

            std::mem::swap(&mut ui_draw_list, &mut self.ui_draw_list);

            let mut atlas = ui.atlas.lock().unwrap();
            let font_texture = atlas.texture();
            quad_gl.texture(Some(&Texture2D::unmanaged(font_texture)));

            gl_use_material(material);

            for draw_command in &ui_draw_list {
                if let Some(ref texture) = draw_command.texture {
                    quad_gl.texture(Some(texture));
                } else {
                    quad_gl.texture(Some(&Texture2D::unmanaged(font_texture)));
                }

                quad_gl.scissor(
                    draw_command
                        .clipping_zone
                        .map(|rect| (rect.x as i32, rect.y as i32, rect.w as i32, rect.h as i32)),
                );
                quad_gl.draw_mode(DrawMode::Triangles);
                quad_gl.geometry(&draw_command.vertices[..], &draw_command.indices);
            }
            quad_gl.texture(None);

            gl_use_default_material();

            std::mem::swap(&mut ui_draw_list, &mut self.ui_draw_list);

            drop(atlas);
            ui.new_frame(get_frame_time());
        }
    }

    pub struct ClipboardObject;

    impl megaui::ClipboardObject for ClipboardObject {
        fn get(&self) -> Option<String> {
            miniquad::window::clipboard_get()
        }

        fn set(&mut self, data: &str) {
            miniquad::window::clipboard_set(data);
        }
    }

    const VERTEX_SHADER: &'static str = "#version 100
attribute vec3 position;
attribute vec4 color0;
attribute vec2 texcoord;

varying lowp vec2 uv;
varying lowp vec2 pos;
varying lowp vec4 color;

uniform mat4 Model;
uniform mat4 Projection;

void main() {
    gl_Position = Projection * Model * vec4(position, 1);
    uv = texcoord;
    color = color0 / 255.0;
}
";
    const FRAGMENT_SHADER: &'static str = "#version 100
varying lowp vec2 uv;
varying lowp vec4 color;

uniform sampler2D Texture;

void main() {
    gl_FragColor = texture2D(Texture, uv) * color;
}
";
    pub const METAL_SHADER: &str = r#"
#include <metal_stdlib>
    using namespace metal;

    struct Uniforms
    {
        float4x4 Model;
        float4x4 Projection;
    };

    struct Vertex
    {
        float3 position    [[attribute(0)]];
        float2 texcoord    [[attribute(1)]];
        float4 color0      [[attribute(2)]];
    };

    struct RasterizerData
    {
        float4 position [[position]];
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
    };

    vertex RasterizerData vertexShader(Vertex v [[stage_in]], constant Uniforms& uniforms [[buffer(0)]])
    {
        RasterizerData out;

        out.position = uniforms.Model * uniforms.Projection * float4(v.position, 1);
        out.color = v.color0 / 255.0;
        out.uv = v.texcoord;

        return out;
    }

    fragment float4 fragmentShader(RasterizerData in [[stage_in]], texture2d<float> tex [[texture(0)]], sampler texSmplr [[sampler(0)]])
    {
        return in.color * tex.sample(texSmplr, in.uv);
    }"#;
}

```

`src/ui/canvas.rs`:

```rs
//! In-window drawing canvas for custom primitives like lines, rect and textures

use super::Layout;
use super::WindowContext;
use crate::{
    color::Color,
    math::{Rect, Vec2},
    texture::Texture2D,
};

pub struct DrawCanvas<'a> {
    pub(crate) context: WindowContext<'a>,
}

impl<'a> DrawCanvas<'a> {
    pub fn cursor(&self) -> Vec2 {
        let cursor = &self.context.window.cursor;
        Vec2::new(cursor.x, cursor.y)
            + Vec2::new(cursor.area.x, cursor.area.y)
            + cursor.scroll.scroll
    }

    pub fn request_space(&mut self, space: Vec2) -> Vec2 {
        let cursor = &mut self.context.window.cursor;

        cursor.fit(space, Layout::Vertical)
    }

    pub fn rect<S, T>(&mut self, rect: Rect, stroke: S, fill: T)
    where
        S: Into<Option<Color>>,
        T: Into<Option<Color>>,
    {
        self.context.register_click_intention(rect);

        self.context.window.painter.draw_rect(rect, stroke, fill);
    }

    pub fn line(&mut self, start: Vec2, end: Vec2, color: Color) {
        self.context.window.painter.draw_line(start, end, color);
    }

    pub fn image(&mut self, rect: Rect, texture: &Texture2D) {
        self.context.register_click_intention(rect);

        self.context.window.painter.draw_raw_texture(rect, texture);
    }
}

```

`src/ui/clipboard.rs`:

```rs
pub trait ClipboardObject {
    fn get(&self) -> Option<String>;
    fn set(&mut self, data: &str);
}

```

`src/ui/cursor.rs`:

```rs
//! Several methods in megaui, such as `Ui::scroll_here`, implicitly rely on the concept of a GUI cursor.
//! This gui cursor is not to be confused with the mouse cursor.
//! Instead it describes where the next widget will be placed
//! if you do not explicitly set its position with Layout::Free.

use crate::math::{Rect, Vec2};

#[derive(Clone, Debug)]
pub struct Scroll {
    pub scroll: Vec2,
    #[allow(dead_code)]
    pub dragging_x: bool,
    pub dragging_y: bool,
    pub rect: Rect,
    pub inner_rect: Rect,
    pub inner_rect_previous_frame: Rect,
    pub initial_scroll: Vec2,
}

impl Scroll {
    pub fn scroll_to(&mut self, y: f32) {
        self.rect.y = y
            .max(self.inner_rect_previous_frame.y)
            .min(self.inner_rect_previous_frame.h - self.rect.h + self.inner_rect_previous_frame.y);
    }

    pub fn update(&mut self) {
        self.rect.y =
            self.rect.y.max(self.inner_rect_previous_frame.y).min(
                self.inner_rect_previous_frame.h - self.rect.h + self.inner_rect_previous_frame.y,
            );
    }
}

#[derive(Debug, Clone)]
pub enum Layout {
    Vertical,
    Horizontal,
    Free(Vec2),
}

#[derive(Debug)]
pub struct Cursor {
    pub x: f32,
    pub y: f32,
    pub start_x: f32,
    pub start_y: f32,
    pub ident: f32,
    pub scroll: Scroll,
    pub area: Rect,
    pub margin: f32,
    pub next_same_line: Option<f32>,
    pub max_row_y: f32,
}

impl Cursor {
    pub const fn new(area: Rect, margin: f32) -> Cursor {
        Cursor {
            margin,
            x: margin,
            y: margin,
            ident: 0.,
            start_x: margin,
            start_y: margin,
            scroll: Scroll {
                rect: Rect::new(0., 0., area.w, area.h),
                inner_rect: Rect::new(0., 0., area.w, area.h),
                inner_rect_previous_frame: Rect::new(0., 0., area.w, area.h),
                scroll: Vec2::new(0., 0.),
                dragging_x: false,
                dragging_y: false,
                initial_scroll: Vec2::new(0., 0.),
            },
            area,
            next_same_line: None,
            max_row_y: 0.,
        }
    }

    pub fn reset(&mut self) {
        self.x = self.start_x;
        self.y = self.start_y;
        self.max_row_y = 0.;
        self.ident = 0.;
        self.scroll.inner_rect_previous_frame = self.scroll.inner_rect;
        self.scroll.inner_rect = Rect::new(0., 0., self.area.w, self.area.h);
    }

    pub fn current_position(&self) -> Vec2 {
        Vec2::new(self.x, self.y)
            + Vec2::new(self.area.x, self.area.y)
            + self.scroll.scroll
            + Vec2::new(self.ident, 0.)
    }

    pub fn fit(&mut self, size: Vec2, mut layout: Layout) -> Vec2 {
        let res;

        if let Some(x) = self.next_same_line {
            self.next_same_line = None;
            if x != 0.0 {
                self.x = x;
            }
            layout = Layout::Horizontal;
        }
        match layout {
            Layout::Horizontal => {
                self.max_row_y = self.max_row_y.max(size.y);

                if self.x + size.x < self.area.w - self.margin * 2. {
                    res = Vec2::new(self.x, self.y);
                } else {
                    self.x = self.margin + 1.; // +1. is a hack to make next vertical thing correctly jump to the next row
                    self.y += self.max_row_y + self.margin;
                    self.max_row_y = 0.;
                    res = Vec2::new(self.x, self.y);
                }
                self.x += size.x + self.margin;
            }
            Layout::Vertical => {
                if self.x != self.margin {
                    self.x = self.margin;
                    self.y += self.max_row_y;
                }
                res = Vec2::new(self.x, self.y);
                self.x += size.x + self.margin;
                self.max_row_y = size.y + self.margin;
            }
            Layout::Free(point) => {
                res = point;
            }
        }
        self.scroll.inner_rect = self
            .scroll
            .inner_rect
            .combine_with(Rect::new(res.x, res.y, size.x, size.y));

        res + Vec2::new(self.area.x, self.area.y) + self.scroll.scroll + Vec2::new(self.ident, 0.)
    }
}

```

`src/ui/hash.rs`:

```rs
#[macro_export]
#[doc(hidden)]
macro_rules! hash {
    ($s:expr) => {{
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let id = $s;

        let mut s = DefaultHasher::new();
        id.hash(&mut s);
        s.finish()
    }};
    () => {{
        let id = concat!(file!(), line!(), column!());
        hash!(id)
    }};
    ($($s:expr),*) => {{
        let mut s: u128 = 0;
        $(s += $crate::hash!($s) as u128;)*
        $crate::hash!(s)
    }};
}

```

`src/ui/input.rs`:

```rs
use crate::math::Vec2;

pub use crate::ui::input_handler::KeyCode;

#[derive(Clone, Debug, PartialEq)]
pub enum Key {
    Char(char),
    KeyCode(KeyCode),
}

#[derive(Clone, Debug)]
pub struct InputCharacter {
    pub key: Key,
    pub modifier_shift: bool,
    pub modifier_ctrl: bool,
}

#[derive(Default, Clone)]
pub struct Input {
    pub(crate) mouse_position: Vec2,
    pub(crate) is_mouse_down: bool,
    pub(crate) click_down: bool,
    pub(crate) click_up: bool,
    pub(crate) mouse_wheel: Vec2,
    pub(crate) input_buffer: Vec<InputCharacter>,
    pub(crate) modifier_ctrl: bool,
    pub(crate) escape: bool,
    pub(crate) enter: bool,
    pub(crate) cursor_grabbed: bool,
    pub(crate) window_active: bool,
}

impl Input {
    pub const fn is_mouse_down(&self) -> bool {
        self.is_mouse_down && self.cursor_grabbed == false && self.window_active
    }

    pub const fn click_down(&self) -> bool {
        self.click_down && self.cursor_grabbed == false && self.window_active
    }

    pub const fn click_up(&self) -> bool {
        self.click_up && self.cursor_grabbed == false && self.window_active
    }

    pub fn reset(&mut self) {
        self.modifier_ctrl = false;
        self.escape = false;
        self.enter = false;
        self.click_down = false;
        self.click_up = false;
        self.mouse_wheel = Vec2::new(0., 0.);
        self.input_buffer = vec![];
        self.window_active = false;
    }
}

```

`src/ui/input_handler.rs`:

```rs
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum KeyCode {
    Up,
    Down,
    Right,
    Left,
    Backspace,
    Delete,
    Enter,
    Tab,
    Home,
    End,
    Control,
    Escape,
    A, // select all
    Z, // undo
    Y, // redo
    C, // copy
    V, // paste
    X, // cut
}

pub trait InputHandler {
    fn mouse_down(&mut self, position: (f32, f32));
    fn mouse_up(&mut self, _: (f32, f32));
    fn mouse_wheel(&mut self, x: f32, y: f32);
    fn mouse_move(&mut self, position: (f32, f32));
    fn char_event(&mut self, character: char, shift: bool, ctrl: bool);
    fn key_down(&mut self, key_down: KeyCode, shift: bool, ctrl: bool);
}

```

`src/ui/key_repeat.rs`:

```rs
//! Some hacks to emulate repeating flag from OS key events

use crate::ui::KeyCode;

#[derive(Default)]
pub(crate) struct KeyRepeat {
    character_this_frame: Option<KeyCode>,
    active_character: Option<KeyCode>,
    repeating_character: Option<KeyCode>,
    pressed_time: f32,
}

impl KeyRepeat {
    pub fn new() -> KeyRepeat {
        KeyRepeat::default()
    }

    // allow the key to be pressed once and than to be pressed all the time but only after some delay
    pub(crate) fn add_repeat_gap(&mut self, character: KeyCode, _time: f32) -> bool {
        self.character_this_frame = Some(character);

        self.active_character.is_none()
            || self.active_character != self.character_this_frame
            || self.repeating_character == self.character_this_frame
    }

    pub(crate) fn new_frame(&mut self, time: f32) {
        let character_this_frame = self.character_this_frame.take();

        if character_this_frame == self.active_character && time - self.pressed_time > 0.5 {
            self.repeating_character = self.active_character;
        }

        if character_this_frame != self.active_character {
            self.active_character = character_this_frame;
            self.pressed_time = time;
            self.repeating_character = None;
        }
    }
}

```

`src/ui/render.rs`:

```rs
mod mesh_rasterizer;
mod painter;

pub(crate) use mesh_rasterizer::render_command;
pub use mesh_rasterizer::{DrawList, Vertex};
pub(crate) use painter::{DrawCommand, ElementState, Painter};

```

`src/ui/render/mesh_rasterizer.rs`:

```rs
//! Rasterize DrawCommand into GPU drawable mesh

use crate::{
    color::Color,
    math::{vec2, vec3, Rect, RectOffset, Vec2},
    texture::Texture2D,
    ui::render::DrawCommand,
};

pub use crate::models::Vertex;

const MAX_VERTICES: usize = 8000;
const MAX_INDICES: usize = 4000;

#[derive(Debug)]
pub struct DrawList {
    pub vertices: Vec<Vertex>,
    pub indices: Vec<u16>,
    pub clipping_zone: Option<Rect>,
    pub texture: Option<Texture2D>,
}

impl DrawList {
    pub const fn new() -> DrawList {
        DrawList {
            vertices: vec![],
            indices: vec![],
            clipping_zone: None,
            texture: None,
        }
    }

    pub fn clear(&mut self) {
        self.vertices.clear();
        self.indices.clear();
        self.clipping_zone = None;
    }

    pub fn draw_rectangle_lines(&mut self, rect: Rect, source: Rect, color: Color) {
        let Rect { x, y, w, h } = rect;

        self.draw_rectangle(Rect { x, y, w, h: 1. }, source, color);
        self.draw_rectangle(
            Rect {
                x: x + w - 1.,
                y: y + 1.,
                w: 1.,
                h: h - 2.,
            },
            source,
            color,
        );
        self.draw_rectangle(
            Rect {
                x,
                y: y + h - 1.,
                w,
                h: 1.,
            },
            source,
            color,
        );
        self.draw_rectangle(
            Rect {
                x,
                y: y + 1.,
                w: 1.,
                h: h - 2.,
            },
            source,
            color,
        );
    }

    fn draw_sprite(
        &mut self,
        rect: Rect,
        src: Rect,
        offsets: RectOffset,
        uv_offsets: RectOffset,
        color: Color,
    ) {
        let Rect { x, y, w, h } = rect;

        let RectOffset {
            left, right, top, ..
        } = offsets;

        let RectOffset {
            left: left0,
            right: right0,
            top: top0,
            bottom: bottom0,
        } = uv_offsets;

        let xs = [x, x + left, x + w - right, x + w];
        let ys = [y, y + top, y + h - top, y + h];

        let us = [src.x, src.x + left0, src.x + src.w - right0, src.x + src.w];
        let vs = [src.y, src.y + top0, src.y + src.h - bottom0, src.y + src.h];

        let mut n = 0;
        let mut vertices =
            [Vertex::new(0.0, 0.0, 0.0, 0.0, 0.0, Color::new(0.0, 0.0, 0.0, 0.0)); 16];

        for (x, u) in xs.iter().zip(us.iter()) {
            for (y, v) in ys.iter().zip(vs.iter()) {
                vertices[n].position = vec3(*x, *y, 0.);
                vertices[n].uv = vec2(*u, *v);
                vertices[n].color = color.into();
                n += 1;
            }
        }
        assert!(n == 16);

        let mut indices: [u16; 54] = [0; 54];
        n = 0;
        for row in 0..3 {
            for column in 0..3 {
                indices[n] = row * 4 + column;
                indices[n + 1] = row * 4 + column + 1;
                indices[n + 2] = (row + 1) * 4 + column;
                n += 3;
                indices[n] = row * 4 + column + 1;
                indices[n + 1] = (row + 1) * 4 + column;
                indices[n + 2] = (row + 1) * 4 + (column + 1);
                n += 3;
            }
        }
        assert!(n == 54);

        let indices_offset = self.vertices.len() as u16;
        self.vertices.extend_from_slice(&vertices[..]);
        self.indices
            .extend(indices.iter().map(|i| i + indices_offset));
    }

    fn draw_rectangle(&mut self, rect: Rect, src: Rect, color: Color) {
        let Rect { x, y, w, h } = rect;

        #[rustfmt::skip]
        let vertices = [
            Vertex::new(x    , y    , 0.0, src.x        , src.y        , color),
            Vertex::new(x + w, y    , 0.0, src.x + src.w, src.y        , color),
            Vertex::new(x + w, y + h, 0.0, src.x + src.w, src.y + src.h, color),
            Vertex::new(x    , y + h, 0.0, src.x        , src.y + src.h, color),
        ];
        let indices: [u16; 6] = [0, 1, 2, 0, 2, 3];

        let indices_offset = self.vertices.len() as u16;
        self.vertices.extend_from_slice(&vertices[..]);
        self.indices
            .extend(indices.iter().map(|i| i + indices_offset));
    }

    fn draw_triangle(&mut self, p0: Vec2, p1: Vec2, p2: Vec2, source: Rect, color: Color) {
        let vertices = [
            Vertex::new(p0.x, p0.y, 0.0, source.x, source.y, color),
            Vertex::new(p1.x, p1.y, 0.0, source.x, source.y, color),
            Vertex::new(p2.x, p2.y, 0.0, source.x, source.y, color),
        ];
        let indices: [u16; 3] = [0, 1, 2];

        let indices_offset = self.vertices.len() as u16;
        self.vertices.extend_from_slice(&vertices[..]);
        self.indices
            .extend(indices.iter().map(|i| i + indices_offset));
    }

    pub fn draw_line(
        &mut self,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
        thickness: f32,
        source: Rect,
        color: Color,
    ) {
        let dx = x2 - x1;
        let dy = y2 - y1;
        let nx = -dy; // https://stackoverflow.com/questions/1243614/how-do-i-calculate-the-normal-vector-of-a-line-segment
        let ny = dx;

        let tlen = (nx * nx + ny * ny).sqrt() / (thickness * 0.5);
        if tlen < f32::EPSILON {
            return;
        }
        let tx = nx / tlen;
        let ty = ny / tlen;

        let vertices = &[
            Vertex::new(x1 + tx, y1 + ty, 0.0, source.x, source.y, color),
            Vertex::new(x1 - tx, y1 - ty, 0.0, source.x, source.y, color),
            Vertex::new(x2 + tx, y2 + ty, 0.0, source.x, source.y, color),
            Vertex::new(x2 - tx, y2 - ty, 0.0, source.x, source.y, color),
        ];
        let indices = &[0, 1, 2, 2, 1, 3];

        let indices_offset = self.vertices.len() as u16;
        self.vertices.extend_from_slice(&vertices[..]);
        self.indices
            .extend(indices.iter().map(|i| i + indices_offset));
    }
}

fn get_active_draw_list<'a, 'b>(
    draw_lists: &'a mut Vec<DrawList>,
    command: &'b DrawCommand,
) -> &'a mut DrawList {
    if draw_lists.len() == 0 {
        draw_lists.push(DrawList::new());
    }

    let last = draw_lists.last().unwrap();
    match command {
        DrawCommand::Clip { rect, .. } => {
            if last.clipping_zone != *rect {
                draw_lists.push(DrawList::new());
            }
        }
        DrawCommand::DrawRawTexture { texture, .. } => {
            if !last
                .texture
                .as_ref()
                .map_or(false, |t| t.texture == texture.texture)
            {
                let clipping_zone = last.clipping_zone;

                draw_lists.push(DrawList {
                    texture: Some(texture.clone()),
                    clipping_zone,
                    ..DrawList::new()
                });
            }
        }
        DrawCommand::DrawCharacter { .. }
        | DrawCommand::DrawLine { .. }
        | DrawCommand::DrawRect { .. }
        | DrawCommand::DrawSprite { .. }
        | DrawCommand::DrawTriangle { .. } => {
            let (vertices, indices) = command.estimate_triangles_budget();

            if last.texture != None
                || last.vertices.len() + vertices >= MAX_VERTICES
                || last.indices.len() + indices >= MAX_INDICES
            {
                let clipping_zone = last.clipping_zone;

                draw_lists.push(DrawList {
                    clipping_zone,
                    ..DrawList::new()
                });
            }
        }
    }
    draw_lists.last_mut().unwrap()
}

pub(crate) fn render_command(draw_lists: &mut Vec<DrawList>, command: DrawCommand) {
    let active_draw_list = get_active_draw_list(draw_lists, &command);

    match command {
        DrawCommand::Clip { rect, .. } => {
            active_draw_list.clipping_zone = rect;
        }
        DrawCommand::DrawRect {
            rect,
            source,
            stroke,
            fill,
        } => {
            if let Some(fill) = fill {
                active_draw_list.draw_rectangle(rect, source, fill);
            }
            if let Some(stroke) = stroke {
                active_draw_list.draw_rectangle_lines(rect, source, stroke);
            }
        }
        DrawCommand::DrawSprite {
            rect,
            source,
            color,
            offsets,
            offsets_uv,
        } => {
            active_draw_list.draw_sprite(
                rect,
                source,
                offsets.unwrap_or_default(),
                offsets_uv.unwrap_or_default(),
                color,
            );
        }
        DrawCommand::DrawLine {
            start,
            end,
            source,
            color,
        } => {
            active_draw_list.draw_line(start.x, start.y, end.x, end.y, 1., source, color);
        }
        DrawCommand::DrawCharacter {
            dest,
            source,
            color,
        } => {
            active_draw_list.draw_rectangle(dest, source, color);
        }
        DrawCommand::DrawRawTexture { rect, .. } => {
            active_draw_list.draw_rectangle(
                rect,
                Rect::new(0., 0., 1., 1.),
                Color::new(1., 1., 1., 1.),
            );
        }
        DrawCommand::DrawTriangle {
            p0,
            p1,
            p2,
            source,
            color,
        } => {
            active_draw_list.draw_triangle(p0, p1, p2, source, color);
        }
    }
}

```

`src/ui/render/painter.rs`:

```rs
//! Resolve high-level drawing primitive + given style into DrawCommand
//! DrawCommand will later rasterized into mesh in mesh_rasterizer.rs

use crate::{
    color::Color,
    math::{vec2, Rect, RectOffset, Vec2},
    text::{
        atlas::{Atlas, SpriteKey},
        Font, TextDimensions,
    },
    texture::Texture2D,
    ui::{style::Style, UiContent},
};

use std::sync::{Arc, Mutex};

#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct ElementState {
    pub focused: bool,
    pub hovered: bool,
    pub clicked: bool,
    pub selected: bool,
}

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub(crate) enum DrawCommand {
    DrawCharacter {
        dest: Rect,
        source: Rect,
        color: Color,
    },
    DrawRect {
        rect: Rect,
        source: Rect,
        fill: Option<Color>,
        stroke: Option<Color>,
    },
    DrawSprite {
        rect: Rect,
        source: Rect,
        color: Color,
        offsets: Option<RectOffset>,
        offsets_uv: Option<RectOffset>,
    },
    DrawTriangle {
        p0: Vec2,
        p1: Vec2,
        p2: Vec2,
        source: Rect,
        color: Color,
    },
    DrawLine {
        start: Vec2,
        end: Vec2,
        source: Rect,
        color: Color,
    },
    DrawRawTexture {
        rect: Rect,
        texture: Texture2D,
    },
    Clip {
        rect: Option<Rect>,
    },
}

impl DrawCommand {
    pub fn offset(&self, offset: Vec2) -> DrawCommand {
        match self.clone() {
            DrawCommand::DrawCharacter {
                dest,
                source,
                color,
            } => DrawCommand::DrawCharacter {
                dest: dest.offset(offset),
                source,
                color,
            },
            DrawCommand::DrawRawTexture { rect, texture } => DrawCommand::DrawRawTexture {
                rect: rect.offset(offset),
                texture,
            },
            DrawCommand::DrawRect {
                rect,
                source,
                fill,
                stroke,
            } => DrawCommand::DrawRect {
                rect: rect.offset(offset),
                source,
                fill,
                stroke,
            },
            DrawCommand::DrawSprite {
                rect,
                source,
                color,
                offsets,
                offsets_uv,
            } => DrawCommand::DrawSprite {
                rect: rect.offset(offset),
                source,
                color,
                offsets,
                offsets_uv,
            },
            DrawCommand::DrawLine {
                start,
                end,
                source,
                color,
            } => DrawCommand::DrawLine {
                start: start + offset,
                end: end + offset,
                source,
                color,
            },
            DrawCommand::DrawTriangle {
                p0,
                p1,
                p2,
                source,
                color,
            } => DrawCommand::DrawTriangle {
                p0: p0 + offset,
                p1: p1 + offset,
                p2: p2 + offset,
                source,
                color,
            },
            DrawCommand::Clip { rect } => DrawCommand::Clip {
                rect: rect.map(|rect| rect.offset(offset)),
            },
        }
    }

    pub(crate) const fn estimate_triangles_budget(&self) -> (usize, usize) {
        match self {
            DrawCommand::DrawCharacter { .. } => (10, 10),
            DrawCommand::DrawRawTexture { .. } => (10, 10),
            DrawCommand::DrawRect { .. } => (10, 10),
            DrawCommand::DrawLine { .. } => (10, 10),
            DrawCommand::DrawTriangle { .. } => (10, 10),
            _ => (0, 0),
        }
    }
}

pub(crate) struct Painter {
    pub commands: Vec<DrawCommand>,
    pub clipping_zone: Option<Rect>,
    font_atlas: Arc<Mutex<Atlas>>,
}

impl Painter {
    pub const fn new(font_atlas: Arc<Mutex<Atlas>>) -> Painter {
        Painter {
            commands: vec![],
            clipping_zone: None,
            font_atlas,
        }
    }

    pub fn clear(&mut self) {
        self.commands.clear();
        self.clipping_zone = None;
    }

    fn add_command(&mut self, cmd: DrawCommand) {
        self.commands.push(cmd);
    }

    /// calculate character horizontal size,
    /// usually used as an advance between current cursor position
    /// and next potential character
    pub fn character_advance(&self, character: char, font: &Font, font_size: u16) -> f32 {
        if let Some(font_data) = font.get(character, font_size) {
            return font_data.advance;
        }

        0.
    }

    pub fn content_with_margins_size(&self, style: &Style, content: &UiContent) -> Vec2 {
        let font = &mut *style.font.lock().unwrap();
        let font_size = style.font_size;

        let background_margin = style.background_margin.unwrap_or_default();
        let margin = style.margin.unwrap_or_default();

        let size = match content {
            UiContent::Label(label) => {
                let text_measures = self.label_size(label, None, font, font_size);
                (text_measures.width, font_size as f32)
            }
            UiContent::Texture(texture) => (texture.width(), texture.height()),
        };

        vec2(size.0, size.1)
            + Vec2::new(
                margin.left + margin.right + background_margin.left + background_margin.right,
                margin.top + margin.bottom + background_margin.top + background_margin.bottom,
            )
    }

    pub fn draw_element_background(
        &mut self,
        style: &Style,
        pos: Vec2,
        size: Vec2,
        element_state: ElementState,
    ) {
        let color = style.color(element_state);

        let background_margin = style.background_margin.unwrap_or_default();
        if let Some(background) = style.background_sprite(element_state) {
            self.draw_sprite(
                Rect::new(pos.x, pos.y, size.x, size.y),
                background,
                color,
                Some(background_margin),
            );
        } else {
            self.draw_rect(Rect::new(pos.x, pos.y, size.x, size.y), None, color);
        }
    }

    // mostly legacy, technically everything should use `draw_element_content`
    // but draw_element_label had a slightly different margins resolver, so..
    pub fn draw_element_label(
        &mut self,
        style: &Style,
        pos: Vec2,
        label: &str,
        element_state: ElementState,
    ) {
        let font = &mut *style.font.lock().unwrap();
        let font_size = style.font_size;

        let text_measures = self.label_size(label, None, font, font_size);
        let background_margin = style.background_margin.unwrap_or_default();
        let margin = style.margin.unwrap_or_default();

        let top_coord = (font_size as f32) / 2. - (text_measures.height / 2.).trunc()
            + margin.top
            + background_margin.top;

        self.draw_label(
            label,
            pos + Vec2::new(
                margin.left + background_margin.left,
                top_coord + text_measures.offset_y,
            ),
            Some(style.text_color(element_state)),
            font,
            font_size,
        );
    }

    pub fn draw_element_content(
        &mut self,
        style: &Style,
        element_pos: Vec2,
        element_size: Vec2,
        content: &UiContent,
        element_state: ElementState,
    ) {
        match content {
            UiContent::Label(data) => {
                let font = &mut *style.font.lock().unwrap();
                let font_size = style.font_size;
                let text_color = style.text_color(element_state);
                let text_measures = self.label_size(data, None, font, font_size);

                let left_coord = (element_size.x - text_measures.width) / 2.;
                let top_coord =
                    element_size.y / 2. - text_measures.height / 2. + text_measures.offset_y;

                self.draw_label(
                    data,
                    element_pos + Vec2::new(left_coord, top_coord),
                    Some(text_color),
                    font,
                    font_size,
                );
            }
            UiContent::Texture(texture) => {
                let background_margin = style.background_margin.unwrap_or_default();
                let margin = style.margin.unwrap_or_default();

                let top_coord = margin.top + background_margin.top;

                let pos = element_pos + Vec2::new(margin.left + background_margin.left, top_coord);
                let size = element_size
                    - vec2(
                        background_margin.left + background_margin.right,
                        background_margin.top + background_margin.bottom,
                    )
                    - vec2(margin.left + margin.right, margin.top + margin.bottom);

                self.draw_raw_texture(Rect::new(pos.x, pos.y, size.x, size.y), texture);
            }
        }
    }

    pub fn label_size(
        &self,
        label: &str,
        _multiline: Option<f32>,
        font: &mut Font,
        font_size: u16,
    ) -> TextDimensions {
        font.measure_text(label, font_size, 1.0, 1.0, |_| {})
    }

    /// If character is in font atlas - will return x advance from position to potential next character position
    pub fn draw_character(
        &mut self,
        character: char,
        position: Vec2,
        color: Color,
        font: &mut Font,
        font_size: u16,
    ) -> Option<f32> {
        if font.get(character, font_size).is_none() {
            font.cache_glyph(character, font_size);
        }

        if let Some(font_data) = font.get(character, font_size) {
            let glyph = self
                .font_atlas
                .lock()
                .unwrap()
                .get(font_data.sprite)
                .unwrap();
            let left_coord = font_data.offset_x as f32;
            let top_coord = -glyph.rect.h - font_data.offset_y as f32;
            let dest = Rect::new(
                left_coord + position.x,
                top_coord + position.y,
                glyph.rect.w,
                glyph.rect.h,
            );
            if self
                .clipping_zone
                .map_or(false, |clip| !clip.overlaps(&dest))
            {
                let advance = font_data.advance;
                return Some(advance);
            }

            let source = self
                .font_atlas
                .lock()
                .unwrap()
                .get_uv_rect(font_data.sprite);

            if let Some(source) = source {
                let cmd = DrawCommand::DrawCharacter {
                    dest,
                    source,
                    color,
                };
                self.add_command(cmd);
                return Some(font_data.advance);
            }
        }

        None
    }

    pub fn draw_label<T: Into<LabelParams>>(
        &mut self,
        label: &str,
        position: Vec2,
        params: T,
        font: &mut Font,
        font_size: u16,
    ) {
        if self.clipping_zone.map_or(false, |clip| {
            !clip.overlaps(&Rect::new(position.x - 150., position.y - 25., 200., 50.))
        }) {
            return;
        }

        let params = params.into();

        let mut total_width = 0.;
        let position = vec2(position.x.trunc(), position.y.trunc());
        for character in label.chars() {
            if let Some(advance) = self.draw_character(
                character,
                position + Vec2::new(total_width, 0.),
                params.color,
                font,
                font_size,
            ) {
                total_width += advance;
            }
        }
    }

    pub fn draw_raw_texture(&mut self, rect: Rect, texture: &Texture2D) {
        if self
            .clipping_zone
            .map_or(false, |clip| !clip.overlaps(&rect))
        {
            return;
        }

        self.add_command(DrawCommand::DrawRawTexture {
            rect,
            texture: texture.clone(),
        });
    }

    pub fn draw_rect<S, T>(&mut self, rect: Rect, stroke: S, fill: T)
    where
        S: Into<Option<Color>>,
        T: Into<Option<Color>>,
    {
        if self
            .clipping_zone
            .map_or(false, |clip| !clip.overlaps(&rect))
        {
            return;
        }

        let source = self
            .font_atlas
            .lock()
            .unwrap()
            .get_uv_rect(SpriteKey::Id(0))
            .unwrap();
        self.add_command(DrawCommand::DrawRect {
            rect,
            source,
            stroke: stroke.into(),
            fill: fill.into(),
        });
    }

    pub fn draw_sprite(
        &mut self,
        rect: Rect,
        sprite: SpriteKey,
        color: Color,
        margin: Option<RectOffset>,
    ) {
        if self
            .clipping_zone
            .map_or(false, |clip| !clip.overlaps(&rect))
        {
            return;
        }

        let atlas = self.font_atlas.lock().unwrap();
        let source_uv = atlas.get_uv_rect(sprite).unwrap();
        let (w, h) = (atlas.width(), atlas.height());
        drop(atlas);
        self.add_command(DrawCommand::DrawSprite {
            rect,
            source: source_uv,
            color,
            offsets: margin,
            offsets_uv: margin.map(|margin| RectOffset {
                left: margin.left / w as f32,
                right: margin.right / w as f32,
                top: margin.top / h as f32,
                bottom: margin.bottom / h as f32,
            }),
        });
    }

    #[allow(dead_code)]
    pub fn draw_triangle<T>(&mut self, p0: Vec2, p1: Vec2, p2: Vec2, color: T)
    where
        T: Into<Color>,
    {
        if self.clipping_zone.map_or(false, |clip| {
            !clip.contains(p0) && !clip.contains(p1) && !clip.contains(p2)
        }) {
            return;
        }

        let source = self
            .font_atlas
            .lock()
            .unwrap()
            .get_uv_rect(SpriteKey::Id(0))
            .unwrap();

        self.add_command(DrawCommand::DrawTriangle {
            p0,
            p1,
            p2,
            source,
            color: color.into(),
        });
    }

    pub fn draw_line<T: Into<Color>>(&mut self, start: Vec2, end: Vec2, color: T) {
        if self
            .clipping_zone
            .map_or(false, |clip| !clip.contains(start) && !clip.contains(end))
        {
            return;
        }

        let source = self
            .font_atlas
            .lock()
            .unwrap()
            .get_uv_rect(SpriteKey::Id(0))
            .unwrap();
        self.add_command(DrawCommand::DrawLine {
            start,
            end,
            source,
            color: color.into(),
        });
    }

    #[rustfmt::skip]
    pub fn clip<T: Into<Option<Rect>>>(&mut self, rect: T) {
        let rect = rect.into();

        self.clipping_zone = if let Some(rect) = rect {
            Some(self.clipping_zone.and_then(|old_rect| old_rect.intersect(rect)).unwrap_or(rect))
        } else {
            None
        };

        let scaled_clipping_zone = self.clipping_zone.map(|rect| {
            let dpi = miniquad::window::dpi_scale();
            Rect::new(rect.x * dpi, rect.y * dpi, rect.w * dpi, rect.h * dpi)
        });
        self.add_command(DrawCommand::Clip { rect: scaled_clipping_zone });
    }
}

#[derive(Clone, Debug)]
#[allow(dead_code)]
pub enum Alignment {
    Left,
    Center,
}

impl Default for Alignment {
    fn default() -> Alignment {
        Alignment::Left
    }
}

#[derive(Clone, Debug)]
pub struct LabelParams {
    pub color: Color,
    #[allow(dead_code)]
    pub alignment: Alignment,
}

impl Default for LabelParams {
    fn default() -> LabelParams {
        LabelParams {
            color: Color::new(0., 0., 0., 1.),
            alignment: Alignment::default(),
        }
    }
}

impl From<Option<Color>> for LabelParams {
    fn from(color: Option<Color>) -> LabelParams {
        LabelParams {
            color: color.unwrap_or(Color::new(0., 0., 0., 1.)),
            ..Default::default()
        }
    }
}
impl From<Color> for LabelParams {
    fn from(color: Color) -> LabelParams {
        LabelParams {
            color,
            ..Default::default()
        }
    }
}
impl From<(Color, Alignment)> for LabelParams {
    fn from((color, alignment): (Color, Alignment)) -> LabelParams {
        LabelParams { color, alignment }
    }
}

```

`src/ui/style.rs`:

```rs
use crate::{
    color::Color,
    math::RectOffset,
    text::{
        atlas::{Atlas, SpriteKey},
        Font,
    },
    texture::Image,
    ui::ElementState,
    Error,
};

use std::{
    collections::HashMap,
    sync::{Arc, Mutex},
};

pub struct StyleBuilder {
    atlas: Arc<Mutex<Atlas>>,
    font: Arc<Mutex<Font>>,
    font_size: u16,
    text_color: Color,
    text_color_hovered: Color,
    text_color_clicked: Color,
    background_margin: Option<RectOffset>,
    margin: Option<RectOffset>,
    background: Option<Image>,
    background_hovered: Option<Image>,
    background_clicked: Option<Image>,
    color: Color,
    color_inactive: Option<Color>,
    color_hovered: Color,
    color_selected: Color,
    color_selected_hovered: Color,
    color_clicked: Color,
    reverse_background_z: bool,
}

impl StyleBuilder {
    pub(crate) fn new(default_font: Arc<Mutex<Font>>, atlas: Arc<Mutex<Atlas>>) -> StyleBuilder {
        StyleBuilder {
            atlas,
            font: default_font,
            font_size: 16,
            text_color: Color::from_rgba(0, 0, 0, 255),
            text_color_hovered: Color::from_rgba(0, 0, 0, 255),
            text_color_clicked: Color::from_rgba(0, 0, 0, 255),
            color: Color::from_rgba(255, 255, 255, 255),
            color_hovered: Color::from_rgba(255, 255, 255, 255),
            color_clicked: Color::from_rgba(255, 255, 255, 255),
            color_selected: Color::from_rgba(255, 255, 255, 255),
            color_selected_hovered: Color::from_rgba(255, 255, 255, 255),
            color_inactive: None,
            background: None,
            background_margin: None,
            margin: None,
            background_hovered: None,
            background_clicked: None,
            reverse_background_z: false,
        }
    }

    pub fn with_font(self, font: &Font) -> Result<StyleBuilder, Error> {
        let mut font = font.clone();
        font.set_atlas(self.atlas.clone());
        font.set_characters(Arc::new(Mutex::new(HashMap::new())));
        Ok(StyleBuilder {
            font: Arc::new(Mutex::new(font)),
            ..self
        })
    }

    pub fn font(self, ttf_bytes: &[u8]) -> Result<StyleBuilder, Error> {
        let font = Font::load_from_bytes(self.atlas.clone(), ttf_bytes)?;

        Ok(StyleBuilder {
            font: Arc::new(Mutex::new(font)),
            ..self
        })
    }

    pub fn background(self, background: Image) -> StyleBuilder {
        StyleBuilder {
            background: Some(background),
            ..self
        }
    }

    pub fn margin(self, margin: RectOffset) -> StyleBuilder {
        StyleBuilder {
            margin: Some(margin),
            ..self
        }
    }

    pub fn background_margin(self, margin: RectOffset) -> StyleBuilder {
        StyleBuilder {
            background_margin: Some(margin),
            ..self
        }
    }

    pub fn background_hovered(self, background_hovered: Image) -> StyleBuilder {
        StyleBuilder {
            background_hovered: Some(background_hovered),
            ..self
        }
    }

    pub fn background_clicked(self, background_clicked: Image) -> StyleBuilder {
        StyleBuilder {
            background_clicked: Some(background_clicked),
            ..self
        }
    }

    pub fn text_color(self, color: Color) -> StyleBuilder {
        StyleBuilder {
            text_color: color,
            ..self
        }
    }

    pub fn text_color_hovered(self, color_hovered: Color) -> StyleBuilder {
        StyleBuilder {
            text_color_hovered: color_hovered,
            ..self
        }
    }

    pub fn text_color_clicked(self, color_clicked: Color) -> StyleBuilder {
        StyleBuilder {
            text_color_clicked: color_clicked,
            ..self
        }
    }

    pub fn font_size(self, font_size: u16) -> StyleBuilder {
        StyleBuilder { font_size, ..self }
    }

    pub fn color(self, color: Color) -> StyleBuilder {
        StyleBuilder { color, ..self }
    }

    pub fn color_hovered(self, color_hovered: Color) -> StyleBuilder {
        StyleBuilder {
            color_hovered,
            ..self
        }
    }

    pub fn color_clicked(self, color_clicked: Color) -> StyleBuilder {
        StyleBuilder {
            color_clicked,
            ..self
        }
    }

    pub fn color_selected(self, color_selected: Color) -> StyleBuilder {
        StyleBuilder {
            color_selected,
            ..self
        }
    }

    pub fn color_selected_hovered(self, color_selected_hovered: Color) -> StyleBuilder {
        StyleBuilder {
            color_selected_hovered,
            ..self
        }
    }

    pub fn color_inactive(self, color_inactive: Color) -> StyleBuilder {
        StyleBuilder {
            color_inactive: Some(color_inactive),
            ..self
        }
    }

    pub fn reverse_background_z(self, reverse_background_z: bool) -> StyleBuilder {
        StyleBuilder {
            reverse_background_z,
            ..self
        }
    }

    pub fn build(self) -> Style {
        let mut atlas = self.atlas.lock().unwrap();

        let background = self.background.map(|image| {
            let id = atlas.new_unique_id();
            atlas.cache_sprite(id, image);
            id
        });

        let background_hovered = self.background_hovered.map(|image| {
            let id = atlas.new_unique_id();
            atlas.cache_sprite(id, image);
            id
        });

        let background_clicked = self.background_clicked.map(|image| {
            let id = atlas.new_unique_id();
            atlas.cache_sprite(id, image);
            id
        });

        Style {
            background_margin: self.background_margin,
            margin: self.margin,
            background,
            background_hovered,
            background_clicked,
            color: self.color,
            color_hovered: self.color_hovered,
            color_clicked: self.color_clicked,
            color_inactive: self.color_inactive,
            color_selected: self.color_selected,
            color_selected_hovered: self.color_selected_hovered,
            font: self.font,
            text_color: self.text_color,
            text_color_hovered: self.text_color_hovered,
            text_color_clicked: self.text_color_clicked,
            font_size: self.font_size,
            reverse_background_z: self.reverse_background_z,
        }
    }
}

#[derive(Debug, Clone)]
pub struct Style {
    pub(crate) background: Option<SpriteKey>,
    pub(crate) background_hovered: Option<SpriteKey>,
    pub(crate) background_clicked: Option<SpriteKey>,
    pub(crate) color: Color,
    pub(crate) color_inactive: Option<Color>,
    pub(crate) color_hovered: Color,
    pub(crate) color_clicked: Color,
    pub(crate) color_selected: Color,
    pub(crate) color_selected_hovered: Color,
    /// Margins of background image
    /// Applies to background/background_hovered/background_clicked etc
    /// Part of the texture within the margin would not be scaled, which is useful
    /// for things like element borders
    pub(crate) background_margin: Option<RectOffset>,
    /// Margin that do not affect textures
    /// Useful to leave some empty space between element border and element content
    /// Maybe be negative to compensate background_margin when content should overlap the
    /// borders
    pub(crate) margin: Option<RectOffset>,
    pub(crate) font: Arc<Mutex<Font>>,
    pub(crate) text_color: Color,
    pub(crate) text_color_hovered: Color,
    pub(crate) text_color_clicked: Color,
    pub(crate) font_size: u16,
    pub(crate) reverse_background_z: bool,
}

impl Style {
    fn default(font: Arc<Mutex<Font>>) -> Style {
        Style {
            background: None,
            background_margin: None,
            margin: None,
            background_hovered: None,
            background_clicked: None,
            font,
            text_color: Color::from_rgba(0, 0, 0, 255),
            text_color_hovered: Color::from_rgba(0, 0, 0, 255),
            text_color_clicked: Color::from_rgba(0, 0, 0, 255),
            font_size: 16,
            color: Color::from_rgba(255, 255, 255, 255),
            color_hovered: Color::from_rgba(255, 255, 255, 255),
            color_clicked: Color::from_rgba(255, 255, 255, 255),
            color_selected: Color::from_rgba(255, 255, 255, 255),
            color_selected_hovered: Color::from_rgba(255, 255, 255, 255),
            color_inactive: None,
            reverse_background_z: false,
        }
    }

    pub(crate) fn border_margin(&self) -> RectOffset {
        let background_offset = self.background_margin.unwrap_or_default();
        let background = self.margin.unwrap_or_default();

        RectOffset {
            left: background_offset.left + background.left,
            right: background_offset.right + background.right,
            top: background_offset.top + background.top,
            bottom: background_offset.bottom + background.bottom,
        }
    }

    pub(crate) fn text_color(&self, element_state: ElementState) -> Color {
        let ElementState {
            focused,
            hovered,
            clicked,
            ..
        } = element_state;

        if clicked {
            self.text_color_clicked
        } else if hovered {
            self.text_color_hovered
        } else if focused {
            self.text_color
        } else {
            Color::new(
                self.text_color.r * 0.6,
                self.text_color.g * 0.6,
                self.text_color.b * 0.6,
                self.text_color.a * 0.6,
            )
        }
    }

    pub(crate) fn color(&self, element_state: ElementState) -> Color {
        let ElementState {
            clicked,
            hovered,
            focused,
            selected,
        } = element_state;

        if focused == false {
            return self.color_inactive.unwrap_or(Color::from_rgba(
                (self.color.r * 255.) as u8,
                (self.color.g * 255.) as u8,
                (self.color.b * 255.) as u8,
                (self.color.a * 255. * 0.8) as u8,
            ));
        }
        if clicked {
            return self.color_clicked;
        }
        if selected && hovered {
            return self.color_selected_hovered;
        }

        if selected {
            return self.color_selected;
        }
        if hovered {
            return self.color_hovered;
        }

        self.color
    }

    pub(crate) const fn background_sprite(&self, element_state: ElementState) -> Option<SpriteKey> {
        let ElementState {
            clicked, hovered, ..
        } = element_state;

        if clicked && self.background_clicked.is_some() {
            return self.background_clicked;
        }

        if hovered && self.background_hovered.is_some() {
            return self.background_hovered;
        }

        self.background
    }
}

#[derive(Debug, Clone)]
pub struct Skin {
    pub label_style: Style,
    pub button_style: Style,
    pub tabbar_style: Style,
    pub combobox_style: Style,
    pub window_style: Style,
    pub editbox_style: Style,
    pub window_titlebar_style: Style,
    pub scrollbar_style: Style,
    pub scrollbar_handle_style: Style,
    pub checkbox_style: Style,
    pub group_style: Style,
    pub progress_bar_style: Style,

    pub margin: f32,
    pub title_height: f32,

    pub scroll_width: f32,
    pub scroll_multiplier: f32,
}

impl Skin {
    pub(crate) fn new(atlas: Arc<Mutex<Atlas>>, default_font: Arc<Mutex<Font>>) -> Self {
        Skin {
            label_style: Style {
                margin: Some(RectOffset::new(2., 2., 2., 2.)),
                text_color: Color::from_rgba(0, 0, 0, 255),
                color_inactive: Some(Color::from_rgba(0, 0, 0, 128)),
                ..Style::default(default_font.clone())
            },
            button_style: Style {
                margin: Some(RectOffset::new(2., 2., 2., 2.)),
                color: Color::from_rgba(204, 204, 204, 235),
                color_clicked: Color::from_rgba(187, 187, 187, 255),
                color_hovered: Color::from_rgba(170, 170, 170, 235),
                text_color: Color::from_rgba(0, 0, 0, 255),
                ..Style::default(default_font.clone())
            },
            combobox_style: StyleBuilder::new(default_font.clone(), atlas.clone())
                .background_margin(RectOffset::new(1., 14., 1., 1.))
                .color_inactive(Color::from_rgba(238, 238, 238, 128))
                .text_color(Color::from_rgba(0, 0, 0, 255))
                .color(Color::from_rgba(220, 220, 220, 255))
                .background(Image {
                    width: 16,
                    height: 30,
                    bytes: include_bytes!("combobox.img").to_vec(),
                })
                .build(),
            tabbar_style: Style {
                margin: Some(RectOffset::new(2., 2., 2., 2.)),
                color: Color::from_rgba(220, 220, 220, 235),
                color_clicked: Color::from_rgba(187, 187, 187, 235),
                color_hovered: Color::from_rgba(170, 170, 170, 235),
                color_selected_hovered: Color::from_rgba(180, 180, 180, 235),
                color_selected: Color::from_rgba(204, 204, 204, 235),
                text_color: Color::from_rgba(0, 0, 0, 255),
                ..Style::default(default_font.clone())
            },
            window_style: StyleBuilder::new(default_font.clone(), atlas.clone())
                .background_margin(RectOffset::new(1., 1., 1., 1.))
                .color_inactive(Color::from_rgba(238, 238, 238, 128))
                .text_color(Color::from_rgba(0, 0, 0, 255))
                .background(Image {
                    width: 3,
                    height: 3,
                    bytes: vec![
                        68, 68, 68, 255, 68, 68, 68, 255, 68, 68, 68, 255, 68, 68, 68, 255, 238,
                        238, 238, 255, 68, 68, 68, 255, 68, 68, 68, 255, 68, 68, 68, 255, 68, 68,
                        68, 255,
                    ],
                })
                .build(),
            window_titlebar_style: Style {
                color: Color::from_rgba(68, 68, 68, 255),
                color_inactive: Some(Color::from_rgba(102, 102, 102, 127)),
                text_color: Color::from_rgba(0, 0, 0, 255),
                ..Style::default(default_font.clone())
            },
            scrollbar_style: Style {
                color: Color::from_rgba(68, 68, 68, 255),
                ..Style::default(default_font.clone())
            },
            editbox_style: Style {
                text_color: Color::from_rgba(0, 0, 0, 255),
                color_selected: Color::from_rgba(200, 200, 200, 255),
                ..Style::default(default_font.clone())
            },

            scrollbar_handle_style: Style {
                color: Color::from_rgba(204, 204, 204, 235),
                color_inactive: Some(Color::from_rgba(204, 204, 204, 128)),
                color_hovered: Color::from_rgba(180, 180, 180, 235),
                color_clicked: Color::from_rgba(170, 170, 170, 235),
                ..Style::default(default_font.clone())
            },
            checkbox_style: Style {
                text_color: Color::from_rgba(0, 0, 0, 255),
                font_size: 16,
                color: Color::from_rgba(200, 200, 200, 255),
                color_hovered: Color::from_rgba(210, 210, 210, 255),
                color_clicked: Color::from_rgba(150, 150, 150, 255),
                color_selected: Color::from_rgba(128, 128, 128, 255),
                color_selected_hovered: Color::from_rgba(140, 140, 140, 255),
                ..Style::default(default_font.clone())
            },
            group_style: Style {
                color: Color::from_rgba(34, 34, 34, 68),
                color_hovered: Color::from_rgba(34, 153, 34, 68),
                color_selected: Color::from_rgba(34, 34, 255, 255),
                color_selected_hovered: Color::from_rgba(55, 55, 55, 68),
                ..Style::default(default_font.clone())
            },
            progress_bar_style: Style {
                margin: Some(RectOffset::new(2., 2., 2., 2.)),
                color: Color::from_rgba(204, 204, 204, 235),
                color_hovered: Color::from_rgba(170, 170, 170, 235),
                text_color: Color::from_rgba(0, 0, 0, 255),
                ..Style::default(default_font.clone())
            },

            margin: 2.0,
            title_height: 14.0,
            scroll_width: 10.0,
            scroll_multiplier: 3.,
        }
    }
}

```

`src/ui/widgets.rs`:

```rs
mod button;
mod checkbox;
mod combobox;
mod drag;
mod editbox;
mod group;
mod input;
mod label;
mod popup;
mod progress_bar;
mod separator;
mod slider;
mod tabbar;
mod texture;
mod tree_node;
mod window;

pub use button::Button;
pub use checkbox::Checkbox;
pub use combobox::ComboBox;
pub use editbox::Editbox;
pub use group::{Group, GroupToken};
pub use input::InputText;
pub use label::Label;
pub use popup::Popup;
pub use progress_bar::ProgressBar;
pub use slider::Slider;
pub use tabbar::Tabbar;
pub use texture::Texture;
pub use tree_node::{TreeNode, TreeNodeToken};
pub use window::{Window, WindowToken};

```

`src/ui/widgets/button.rs`:

```rs
use crate::{
    math::{Rect, Vec2},
    ui::{ElementState, Layout, Ui, UiContent},
};

pub struct Button<'a> {
    position: Option<Vec2>,
    size: Option<Vec2>,
    content: UiContent<'a>,
    selected: bool,
}

impl<'a> Button<'a> {
    pub fn new<S>(content: S) -> Button<'a>
    where
        S: Into<UiContent<'a>>,
    {
        Button {
            position: None,
            size: None,
            content: content.into(),
            selected: false,
        }
    }

    pub fn position<P: Into<Option<Vec2>>>(self, position: P) -> Self {
        let position = position.into();

        Button { position, ..self }
    }

    pub fn size(self, size: Vec2) -> Self {
        Button {
            size: Some(size),
            ..self
        }
    }

    pub fn selected(self, selected: bool) -> Self {
        Button { selected, ..self }
    }

    pub fn ui(self, ui: &mut Ui) -> bool {
        let mut context = ui.get_active_window_context();

        let size = self.size.unwrap_or_else(|| {
            context
                .window
                .painter
                .content_with_margins_size(&context.style.button_style, &self.content)
        });

        let pos = context
            .window
            .cursor
            .fit(size, self.position.map_or(Layout::Vertical, Layout::Free));
        let rect = Rect::new(pos.x, pos.y, size.x, size.y);
        let (hovered, clicked) = context.register_click_intention(rect);

        if !context.style.button_style.reverse_background_z {
            context.window.painter.draw_element_background(
                &context.style.button_style,
                pos,
                size,
                ElementState {
                    focused: context.focused,
                    hovered,
                    clicked: hovered && context.input.is_mouse_down,
                    selected: self.selected,
                },
            );
        }

        context.window.painter.draw_element_content(
            &context.style.button_style,
            pos,
            size,
            &self.content,
            ElementState {
                focused: context.focused,
                hovered,
                clicked: hovered && context.input.is_mouse_down,
                selected: self.selected,
            },
        );

        if context.style.button_style.reverse_background_z {
            context.window.painter.draw_element_background(
                &context.style.button_style,
                pos,
                size,
                ElementState {
                    focused: context.focused,
                    hovered,
                    clicked: hovered && context.input.is_mouse_down,
                    selected: false,
                },
            );
        }

        clicked
    }
}

impl Ui {
    pub fn button<'a, P: Into<Option<Vec2>>, S: Into<UiContent<'a>>>(
        &mut self,
        position: P,
        label: S,
    ) -> bool {
        Button::new(label).position(position).ui(self)
    }
}

```

`src/ui/widgets/checkbox.rs`:

```rs
use crate::{
    math::{vec2, Rect, Vec2},
    ui::{ElementState, Id, Layout, Ui, UiContent},
};

pub struct Checkbox<'a> {
    id: Id,
    label: &'a str,
    ratio: f32,
    pos: Option<Vec2>,
    size: Option<Vec2>,
}

impl<'a> Checkbox<'a> {
    pub const fn new(id: Id) -> Checkbox<'a> {
        Checkbox {
            id,
            label: "",
            ratio: 0.5,
            pos: None,
            size: None,
        }
    }

    pub const fn ratio(self, ratio: f32) -> Self {
        Self { ratio, ..self }
    }

    pub const fn label<'b>(self, label: &'b str) -> Checkbox<'b> {
        Checkbox {
            id: self.id,
            label,
            ratio: self.ratio,
            pos: self.pos,
            size: self.size,
        }
    }

    pub const fn pos(self, pos: Vec2) -> Self {
        Self {
            pos: Some(pos),
            ..self
        }
    }

    pub const fn size(self, size: Vec2) -> Self {
        Self {
            size: Some(size),
            ..self
        }
    }

    pub fn ui(self, ui: &mut Ui, data: &mut bool) {
        let context = ui.get_active_window_context();

        let label_size = context.window.painter.content_with_margins_size(
            &context.style.label_style,
            &UiContent::Label(self.label.into()),
        );
        let size = self.size.unwrap_or(vec2(
            context.window.cursor.area.w - context.style.margin * 2. - context.window.cursor.ident,
            label_size.y.max(22.),
        ));

        let pos = self
            .pos
            .map(|pos| pos + context.window.cursor.fit(size, Layout::Vertical))
            .unwrap_or_else(|| context.window.cursor.fit(size, Layout::Vertical));

        let whole_area = Vec2::new(
            if self.label.is_empty() {
                size.x
            } else {
                size.x * self.ratio
            },
            size.y,
        );
        let checkbox_area = Vec2::new(19., 19.);
        let checkbox_pos = Vec2::new(
            pos.x + whole_area.x - 19. - 15.,
            pos.y + context.style.margin,
        );

        let hovered = Rect::new(
            checkbox_pos.x,
            checkbox_pos.y,
            checkbox_area.x,
            checkbox_area.y,
        )
        .contains(context.input.mouse_position);

        let background = context
            .style
            .checkbox_style
            .background_sprite(ElementState {
                focused: context.focused,
                hovered,
                clicked: *data,
                selected: false,
            });

        let color = context.style.checkbox_style.color(ElementState {
            focused: context.focused,
            hovered,
            clicked: hovered && context.input.is_mouse_down,
            selected: *data,
        });

        if let Some(background) = background {
            let background_margin = context
                .style
                .checkbox_style
                .background_margin
                .unwrap_or_default();

            context.window.painter.draw_sprite(
                Rect::new(checkbox_pos.x, checkbox_pos.y, 19., 19.),
                background,
                color,
                Some(background_margin),
            );
        } else {
            context.window.painter.draw_rect(
                Rect::new(
                    checkbox_pos.x,
                    checkbox_pos.y,
                    checkbox_area.x,
                    checkbox_area.y,
                ),
                None,
                color,
            );
        }

        if hovered && context.input.click_up() {
            *data ^= true;
        }

        let context = ui.get_active_window_context();

        if self.label.is_empty() == false {
            context.window.painter.draw_element_label(
                &context.style.label_style,
                Vec2::new(pos.x + size.x * self.ratio, pos.y),
                self.label,
                ElementState {
                    focused: context.focused,
                    hovered: false,
                    clicked: false,
                    selected: false,
                },
            );
        }
    }
}

impl Ui {
    pub fn checkbox(&mut self, id: Id, label: &str, data: &mut bool) {
        Checkbox::new(id).label(label).ui(self, data);
    }
}

```

`src/ui/widgets/combobox.rs`:

```rs
use crate::{
    math::{vec2, Rect, Vec2},
    ui::{ElementState, Id, Layout, Ui, UiContent},
};

pub struct ComboBox<'a, 'b, 'c> {
    id: Id,
    label: &'a str,
    variants: &'b [&'c str],
    ratio: f32,
}

impl<'a, 'b, 'c> ComboBox<'a, 'b, 'c> {
    pub const fn new(id: Id, variants: &'b [&'c str]) -> ComboBox<'a, 'b, 'c> {
        ComboBox {
            id,
            label: "",
            variants,
            ratio: 0.5,
        }
    }

    pub const fn label<'x>(self, label: &'x str) -> ComboBox<'x, 'b, 'c> {
        ComboBox {
            id: self.id,
            variants: self.variants,
            label,
            ratio: self.ratio,
        }
    }

    pub const fn ratio(self, ratio: f32) -> Self {
        Self { ratio, ..self }
    }
    pub fn ui(self, ui: &mut Ui, data: &mut usize) -> usize {
        let mut context = ui.get_active_window_context();

        let line_height = context.style.label_style.font_size;

        let size = vec2(
            context.window.cursor.area.w - context.style.margin * 2. - context.window.cursor.ident,
            (line_height as f32 + 4.).max(19.),
        );

        let combobox_area_w = size.x * self.ratio - 15.;

        let pos = context.window.cursor.fit(size, Layout::Vertical);

        let active_area_w = size.x * self.ratio;

        let text_measures = {
            let font = &mut *context.style.label_style.font.lock().unwrap();
            let font_size = context.style.label_style.font_size;

            context
                .window
                .painter
                .label_size(self.label, None, font, font_size)
        };

        let clickable_rect = Rect::new(pos.x, pos.y, active_area_w, size.y);

        let (hovered, _) = context.register_click_intention(clickable_rect);

        let state = context
            .storage_any
            .get_or_default::<bool>(hash!(self.id, "combobox_state"));

        if context.window.was_active == false {
            *state = false;
        }

        context.window.painter.draw_element_background(
            &context.style.combobox_style,
            pos,
            vec2(combobox_area_w, size.y),
            ElementState {
                focused: context.focused,
                hovered,
                clicked: hovered && context.input.is_mouse_down,
                ..Default::default()
            },
        );

        context.window.painter.draw_element_content(
            &context.style.label_style,
            pos,
            vec2(combobox_area_w, size.y),
            &UiContent::Label(self.variants[*data].into()),
            ElementState {
                focused: context.focused,
                hovered,
                clicked: hovered && context.input.is_mouse_down,
                selected: false,
            },
        );

        {
            context.window.painter.draw_element_label(
                &context.style.label_style,
                Vec2::new(pos.x + size.x * self.ratio, pos.y),
                self.label,
                ElementState {
                    focused: context.focused,
                    ..Default::default()
                },
            );
        }

        let modal_size = Vec2::new(active_area_w, self.variants.len() as f32 * size.y);
        let modal_rect = Rect::new(pos.x, pos.y + size.y, modal_size.x, modal_size.y);

        if *state == false && context.focused && hovered && context.input.click_down {
            *state = true;
        } else if *state
            && (context.input.escape
                || context.input.enter
                || (modal_rect.contains(context.input.mouse_position) == false
                    && context.input.click_down))
        {
            *state = false;
        }

        if *state {
            let context = ui.begin_modal(
                hash!("combobox", self.id),
                pos + Vec2::new(0., 20.),
                modal_size,
            );

            let state = context
                .storage_any
                .get_or_default::<bool>(hash!(self.id, "combobox_state"));

            for (i, variant) in self.variants.iter().enumerate() {
                let rect = Rect::new(
                    pos.x + 5.0,
                    pos.y + i as f32 * size.y + size.y,
                    active_area_w - 5.0,
                    size.y,
                );
                let hovered = rect.contains(context.input.mouse_position);

                let color = context.style.combobox_style.color(ElementState {
                    focused: context.focused,
                    hovered,
                    clicked: hovered && context.input.is_mouse_down,
                    selected: false,
                });

                context.window.painter.draw_rect(
                    rect, //context.style.combobox_variant_border(hovered, *data == i),
                    color,
                    // context
                    //     .style
                    //     .combobox_variant_background(hovered, *data == i),
                    color,
                );

                let font = &mut *context.style.label_style.font.lock().unwrap();
                let font_size = context.style.label_style.font_size;

                context.window.painter.draw_label(
                    variant,
                    Vec2::new(
                        pos.x + 7.,
                        pos.y + i as f32 * size.y + size.y + 2.0 + text_measures.offset_y,
                    ),
                    context.style.combobox_style.text_color,
                    font,
                    font_size,
                );

                if hovered && context.input.click_up {
                    *data = i;
                    *state = false;
                }
            }
            ui.end_modal();
        }

        *data
    }
}

impl Ui {
    pub fn combo_box<'a>(
        &mut self,
        id: Id,
        label: &str,
        variants: &[&str],
        data: impl Into<Option<&'a mut usize>>,
    ) -> usize {
        if let Some(r) = data.into() {
            ComboBox::new(id, variants).label(label).ui(self, r)
        } else {
            let data_id = hash!(id, "selected_variant");
            let mut selected_variant = { *self.get_any(data_id) };

            ComboBox::new(id, variants)
                .label(label)
                .ui(self, &mut selected_variant);

            *self.get_any(data_id) = selected_variant;

            selected_variant
        }
    }
}

```

`src/ui/widgets/drag.rs`:

```rs
use crate::{
    math::{vec2, Rect, Vec2},
    ui::{widgets::Editbox, ElementState, Id, Layout, Ui, UiContent},
};

use std::any::Any;

pub trait Num:
    Copy + std::string::ToString + std::str::FromStr + Into<f64> + 'static + Default + std::fmt::Display
{
}

#[derive(Clone, Copy)]
struct DragState {
    start_value: f64,
    start_mouse: f32,
}

struct State {
    string_represents: f64,
    string: String,
    before: String,
    drag: Option<DragState>,
    in_editbox: bool,
}

impl Default for State {
    fn default() -> Self {
        Self {
            string_represents: 0.0,
            string: String::new(),
            before: String::new(),
            drag: None,
            in_editbox: false,
        }
    }
}

pub struct Drag<'a> {
    id: Id,
    label: &'a str,
    range: Option<(f64, f64)>,
    size: Option<Vec2>,
    step: f32,
}

impl<'a> Drag<'a> {
    pub const fn new(id: Id) -> Drag<'a> {
        Drag {
            id,
            size: None,
            range: None,
            label: "",
            step: 0.1,
        }
    }

    pub const fn label<'b>(self, label: &'b str) -> Drag<'b> {
        Drag {
            label,
            id: self.id,
            range: self.range,
            size: self.size,
            step: self.step,
        }
    }

    pub fn range<T: Num>(self, range: Option<(T, T)>) -> Drag<'a> {
        Drag {
            range: range.map(|(start, end)| (start.into(), end.into())),
            ..self
        }
    }
    // /// Ratio of pixels on the x-axis dragged to how much the value should be changed.
    // /// Default for floating point numbers is `0.1`, for integers it's `1`.
    // pub fn step(self, step: f32) -> Self {
    //     Self { step, ..self }
    // }

    pub fn ui<T>(self, ui: &mut Ui, data: &mut T)
    where
        T: std::any::Any + Num,
    {
        let context = ui.get_active_window_context();
        let state_hash = hash!(self.id, "input_float_state");
        let mut s: State = std::mem::take(context.storage_any.get_or_default(state_hash));

        let label_size = context.window.painter.content_with_margins_size(
            &context.style.label_style,
            &UiContent::Label(self.label.into()),
        );
        let size = vec2(
            context.window.cursor.area.w - context.style.margin * 2. - context.window.cursor.ident,
            label_size.y.max(22.),
        );

        let pos = context.window.cursor.fit(size, Layout::Vertical);
        let editbox_area = Vec2::new(
            if self.label.is_empty() {
                size.x
            } else {
                size.x / 2.0
            },
            size.y,
        );
        let hovered = Rect::new(pos.x, pos.y, editbox_area.x, editbox_area.y)
            .contains(context.input.mouse_position);

        // state transition between editbox and dragbox
        if s.in_editbox == false {
            if hovered && context.input.is_mouse_down() && context.input.modifier_ctrl {
                s.in_editbox = true;
            }
        } else {
            if context.input.escape
                || context.input.enter
                || (hovered == false && context.input.is_mouse_down())
            {
                s.in_editbox = false;
            }
        }

        if s.in_editbox == false {
            let context = ui.get_active_window_context();

            // context.window.painter.draw_rect(
            //     Rect::new(pos.x, pos.y, editbox_area.x, editbox_area.y),
            //     None,
            //     context.style.drag_background(context.focused),
            // );

            let label = format!("{:.2}", (*data));
            let value_size = context.window.painter.content_with_margins_size(
                &context.style.label_style,
                &UiContent::Label((&label).into()),
            );

            context.window.painter.draw_element_label(
                &context.style.label_style,
                pos + Vec2::new(size.x / 2. - value_size.x - 15., 0.),
                &label,
                ElementState {
                    focused: context.focused,
                    hovered: false,
                    clicked: false,
                    selected: false,
                },
            );

            if let Some(drag) = s.drag {
                if context.input.is_mouse_down == false {
                    s.drag = None;
                    context.input.cursor_grabbed = false;
                    if !hovered {
                        *context.input_focus = None;
                    }
                } else {
                    let mouse_delta =
                        (context.input.mouse_position.x - drag.start_mouse) * self.step;

                    if (data as &mut dyn Any).is::<f32>() {
                        let data = (data as &mut dyn Any).downcast_mut::<f32>().unwrap();
                        *data = drag.start_value as f32 + mouse_delta;
                        if let Some((start, end)) = self.range {
                            *data = data.max(start as f32).min(end as f32);
                        }
                    }
                    if (data as &mut dyn Any).is::<u32>() {
                        let data = (data as &mut dyn Any).downcast_mut::<u32>().unwrap();
                        *data = (drag.start_value as i32 + mouse_delta as i32).max(0) as u32;
                        if let Some((start, end)) = self.range {
                            *data = (*data).max(start as u32).min(end as u32);
                        }
                    }
                }
            } else {
                if hovered && context.input.is_mouse_down() {
                    s.drag = Some(DragState {
                        start_mouse: context.input.mouse_position.x,
                        start_value: (*data).into(),
                    });
                    *context.input_focus = Some(self.id);
                    context.input.cursor_grabbed = true;
                }
            }
        } else {
            if s.string_represents != (*data).into() {
                s.string = data.to_string();
            }

            Editbox::new(self.id, editbox_area)
                .position(pos)
                .multiline(false)
                .ui(ui, &mut s.string);

            if let Ok(n) = s.string.parse() {
                *data = n;
                s.string_represents = n.into();
                s.before = s.string.clone();
            } else if s.string.is_empty() {
                *data = T::default();
                s.string_represents = 0.0;
                s.before = s.string.clone();
            } else {
                s.string = s.before.clone();
            }
        }

        let context = ui.get_active_window_context();

        if self.label.is_empty() == false {
            context.window.painter.draw_element_label(
                &context.style.label_style,
                Vec2::new(pos.x + size.x / 2. + 5., pos.y),
                self.label,
                ElementState {
                    focused: context.focused,
                    hovered: false,
                    clicked: false,
                    selected: false,
                },
            );
        }

        *context.storage_any.get_or_default(state_hash) = s;
    }
}

impl Num for u32 {}
impl Num for f32 {}

impl Ui {
    pub fn drag<T: Num, T1: Into<Option<(T, T)>>>(
        &mut self,
        id: Id,
        label: &str,
        range: T1,
        data: &mut T,
    ) {
        let range = range.into();

        Drag::new(id).label(label).range(range).ui(self, data);
    }
}

```

`src/ui/widgets/editbox.rs`:

```rs
#[cfg(target_os = "android")]
use crate::get_quad_context;
use crate::{
    math::{vec2, Rect, Vec2},
    ui::{ElementState, Id, InputCharacter, Key, KeyCode, Layout, Ui},
};

pub struct Editbox<'a> {
    id: Id,
    size: Vec2,
    multiline: bool,
    select_all: bool,
    filter: Option<&'a dyn Fn(char) -> bool>,
    pos: Option<Vec2>,
    password: bool,
    margin: Option<Vec2>,
}

mod text_editor;

use text_editor::EditboxState;

const LEFT_MARGIN: f32 = 2.;

impl<'a> Editbox<'a> {
    pub fn new(id: Id, size: Vec2) -> Editbox<'a> {
        Editbox {
            id,
            size,
            filter: None,
            select_all: false,
            multiline: true,
            pos: None,
            password: false,
            margin: None,
        }
    }

    pub const fn multiline(self, multiline: bool) -> Self {
        Editbox { multiline, ..self }
    }

    pub const fn select_all(self) -> Self {
        Editbox {
            select_all: true,
            ..self
        }
    }

    pub const fn position(self, pos: Vec2) -> Self {
        Editbox {
            pos: Some(pos),
            ..self
        }
    }

    pub const fn password(self, password: bool) -> Self {
        Editbox { password, ..self }
    }

    pub fn filter<'b>(self, filter: &'b dyn Fn(char) -> bool) -> Editbox<'b> {
        Editbox {
            id: self.id,
            pos: self.pos,
            multiline: self.multiline,
            select_all: self.select_all,
            size: self.size,
            password: self.password,
            filter: Some(filter),
            margin: self.margin,
        }
    }

    pub const fn margin(self, margin: Vec2) -> Self {
        Editbox {
            margin: Some(margin),
            ..self
        }
    }

    fn apply_keyboard_input(
        &self,
        input_buffer: &mut Vec<InputCharacter>,
        clipboard: &mut dyn crate::ui::ClipboardObject,
        text: &mut Vec<char>,
        state: &mut EditboxState,
    ) {
        for character in input_buffer.drain(0..) {
            use KeyCode::*;

            match character {
                InputCharacter {
                    key: Key::Char(_),
                    modifier_ctrl: true,
                    ..
                } => {}
                InputCharacter {
                    key: Key::Char(character),
                    modifier_ctrl: false,
                    ..
                } => {
                    // Don't insert spaces for control characters
                    if character.is_ascii()
                        && !character.is_ascii_control()
                        && self.filter.as_ref().map_or(true, |f| f(character))
                    {
                        if state.selection.is_some() {
                            state.delete_selected(text);
                        }
                        state.insert_character(text, character);
                    }
                }
                InputCharacter {
                    key: Key::KeyCode(Z),
                    modifier_ctrl: true,
                    ..
                } => {
                    state.undo(text);
                }
                InputCharacter {
                    key: Key::KeyCode(Y),
                    modifier_ctrl: true,
                    ..
                } => {
                    state.redo(text);
                }
                InputCharacter {
                    key: Key::KeyCode(X),
                    modifier_ctrl: true,
                    ..
                } => {
                    state.delete_selected(text);
                }
                InputCharacter {
                    key: Key::KeyCode(V),
                    modifier_ctrl: true,
                    ..
                } => {
                    if let Some(clipboard) = clipboard.get() {
                        if clipboard.len() != 0 {
                            if state.selection.is_some() {
                                state.delete_selected(text);
                            }

                            if let Some(filter) = &self.filter {
                                for character in clipboard.chars() {
                                    if filter(character) {
                                        state.insert_character(text, character);
                                    }
                                }
                            } else {
                                state.insert_string(text, clipboard.chars().collect());
                            }
                        }
                    }
                }
                InputCharacter {
                    key: Key::KeyCode(A),
                    modifier_ctrl: true,
                    ..
                } => {
                    state.select_all(text);
                }
                InputCharacter {
                    key: Key::KeyCode(Enter),
                    ..
                } => {
                    if self.multiline {
                        state.insert_character(text, '\n');
                    }
                }
                InputCharacter {
                    key: Key::KeyCode(Backspace),
                    ..
                } => {
                    if state.selection.is_none() {
                        state.delete_current_character(text);
                    } else {
                        state.delete_selected(text);
                    }
                }
                InputCharacter {
                    key: Key::KeyCode(Delete),
                    ..
                } => {
                    if state.selection.is_none() {
                        state.delete_next_character(text);
                    } else {
                        state.delete_selected(text);
                    }
                }
                InputCharacter {
                    key: Key::KeyCode(Right),
                    modifier_shift,
                    modifier_ctrl,
                } => {
                    if modifier_ctrl {
                        state.move_cursor_next_word(text, modifier_shift);
                    } else {
                        state.move_cursor(text, 1, modifier_shift);
                    }
                }
                InputCharacter {
                    key: Key::KeyCode(Left),
                    modifier_shift,
                    modifier_ctrl,
                } => {
                    if modifier_ctrl {
                        state.move_cursor_prev_word(text, modifier_shift);
                    } else {
                        state.move_cursor(text, -1, modifier_shift);
                    }
                }
                InputCharacter {
                    key: Key::KeyCode(Home),
                    modifier_ctrl: false,
                    modifier_shift,
                    ..
                } => {
                    let to_line_begin = state.find_line_begin(text) as i32;
                    state.move_cursor(text, -to_line_begin, modifier_shift);
                }
                InputCharacter {
                    key: Key::KeyCode(Home),
                    modifier_ctrl: true,
                    modifier_shift,
                    ..
                } => {
                    let to_text_being = state.cursor as i32;
                    state.move_cursor(text, -to_text_being, modifier_shift);
                }
                InputCharacter {
                    key: Key::KeyCode(End),
                    modifier_ctrl: false,
                    modifier_shift,
                    ..
                } => {
                    let to_line_end = state.find_line_end(text) as i32;
                    state.move_cursor(text, to_line_end, modifier_shift);
                }
                InputCharacter {
                    key: Key::KeyCode(End),
                    modifier_ctrl: true,
                    modifier_shift,
                    ..
                } => {
                    let to_text_end = (text.len() as u32 - state.cursor) as i32;
                    state.move_cursor(text, to_text_end, modifier_shift);
                }
                InputCharacter {
                    key: Key::KeyCode(Up),
                    modifier_shift,
                    ..
                } => {
                    let to_line_begin = state.find_line_begin(text) as i32;
                    state.move_cursor(text, -to_line_begin, modifier_shift);
                    if state.cursor != 0 {
                        state.move_cursor(text, -1, modifier_shift);
                        let new_to_line_begin = state.find_line_begin(text) as i32;
                        let offset = to_line_begin.min(new_to_line_begin) - new_to_line_begin;
                        state.move_cursor(text, offset, modifier_shift);
                    }
                }
                InputCharacter {
                    key: Key::KeyCode(Down),
                    modifier_shift,
                    ..
                } => {
                    let to_line_begin = state.find_line_begin(text) as i32;
                    let to_line_end = state.find_line_end(text) as i32;

                    state.move_cursor(text, to_line_end, modifier_shift);
                    if text.len() != 0 && state.cursor < text.len() as u32 - 1 {
                        state.move_cursor(text, 1, modifier_shift);
                        state.move_cursor_within_line(text, to_line_begin, modifier_shift);
                    }
                }
                _ => {}
            }
        }
    }

    pub fn ui(self, ui: &mut Ui, text: &mut String) -> bool {
        let mut text_vec = text.chars().collect::<Vec<_>>();
        let time = ui.time;

        let context = ui.get_active_window_context();

        let pos = self
            .pos
            .unwrap_or_else(|| context.window.cursor.fit(self.size, Layout::Vertical));

        let rect = Rect::new(pos.x, pos.y, self.size.x, self.size.y);

        let hovered = rect.contains(context.input.mouse_position);

        if context.input.click_down() && hovered {
            #[cfg(target_os = "android")]
            miniquad::window::show_keyboard(true);
            *context.input_focus = Some(self.id);
        }
        if context.input_focused(self.id) && context.input.click_down() && hovered == false {
            #[cfg(target_os = "android")]
            miniquad::window::show_keyboard(false);
            *context.input_focus = None;
        }

        let state = context
            .storage_any
            .get_or_default::<EditboxState>(hash!(self.id, "cursor"));

        // if text changed outside, than the selection range should be clamped
        state.clamp_selection(&text_vec);

        if self.select_all {
            state.select_all(&text_vec);
        }

        if let Some(selected) = state.selected_text(&text_vec) {
            *context.clipboard_selection = selected.iter().collect();
        }
        // in case the string was updated outside of editbox
        if state.cursor > text_vec.len() as u32 {
            state.cursor = text_vec.len() as u32;
        }

        let input_focused =
            context.input_focus.map_or(false, |id| id == self.id) && context.focused;

        let is_tab_selected = context
            .tab_selector
            .register_selectable_widget(input_focused, context.input);
        if is_tab_selected {
            *context.input_focus = Some(self.id);
        }

        // reset selection state when lost focus
        if context.focused == false || input_focused == false {
            state.deselect();
            state.clicks_counter = 0;
        }
        if time - state.last_click_time > 3. * text_editor::DOUBLE_CLICK_TIME {
            state.clicks_counter = 0;
        }

        let mut edited = false;
        if context.focused && input_focused {
            edited = context.input.input_buffer.len() != 0;
            self.apply_keyboard_input(
                &mut context.input.input_buffer,
                &mut *context.clipboard,
                &mut text_vec,
                state,
            );
        }
        // draw rect in parent window

        let text_color = context.style.editbox_style.text_color;

        context.window.painter.draw_element_background(
            &context.style.editbox_style,
            pos,
            self.size,
            ElementState {
                focused: context.focused,
                clicked: input_focused,
                ..Default::default()
            },
        );

        // start child window for nice scroll inside the rect

        let parent = ui.get_active_window_context();

        let parent_rect = parent.window.content_rect();

        parent.window.childs.push(self.id);
        let parent_id = Some(parent.window.id);

        let mut context = ui.begin_window(
            self.id,
            parent_id,
            pos,
            self.size + vec2(2., 2.),
            false,
            false,
        );

        let line_height = context.style.editbox_style.font_size as f32;

        let size = vec2(
            150.,
            line_height * text_vec.iter().filter(|c| **c == '\n').count() as f32,
        );

        let margin = self.margin.unwrap_or(vec2(2., 2.));
        let pos = context.window.cursor.fit(size, Layout::Free(margin));

        context.window.painter.clip(parent_rect);

        context.scroll_area();

        context.window.painter.clip(context.window.content_rect());

        let state = context
            .storage_any
            .get_or_default::<EditboxState>(hash!(self.id, "cursor"));

        let mut x = LEFT_MARGIN;
        let mut y = 0.;
        let mut clicked = false;

        for (n, character) in text_vec
            .iter()
            .copied()
            .chain(std::iter::once(' '))
            .enumerate()
        {
            let character = if character != '\n' && self.password {
                '*'
            } else {
                character
            };

            let font_size = context.style.editbox_style.font_size;
            if n == state.cursor as usize && input_focused {
                // caret
                context.window.painter.draw_rect(
                    Rect::new(pos.x + x, pos.y + y + 2., 2., font_size as f32 - 5.),
                    text_color,
                    None,
                );
            }

            let mut font = context.style.editbox_style.font.lock().unwrap();
            let font_size = context.style.editbox_style.font_size;

            let mut advance = 1.5; // 1.5 - hack to make cursor on newlines visible

            if state.in_selected_range(n as u32) {
                let pos = pos + vec2(x, y);

                context.window.painter.draw_rect(
                    Rect::new(
                        pos.x,
                        pos.y,
                        context
                            .window
                            .painter
                            .character_advance(character, &font, font_size)
                            + 1.0,
                        font_size as f32 - 1.,
                    ),
                    None,
                    context.style.editbox_style.color_selected,
                );
            }

            if character != '\n' {
                let descent = font.descent(font_size as f32) as f32;
                let ascent = font.ascent(font_size as f32) as f32;
                let baseline = (ascent + descent) / 2.;

                advance = context
                    .window
                    .painter
                    .draw_character(
                        character,
                        pos + vec2(x, y + font_size as f32 - baseline),
                        text_color,
                        &mut font,
                        font_size,
                    )
                    .unwrap_or(0.);
            }

            if clicked == false && hovered && context.input.is_mouse_down() && input_focused {
                let cursor_on_current_line =
                    (context.input.mouse_position.y - (pos.y + y + line_height / 2.)).abs()
                        < line_height / 2. + 0.1;
                let line_end = character == '\n' || n == text_vec.len();
                let cursor_after_line_end = context.input.mouse_position.x > (pos.x + x);
                let clickable_character = character != '\n';
                let cursor_on_character =
                    (context.input.mouse_position.x - (pos.x + x)).abs() < advance / 2.;
                let last_character = n == text_vec.len();
                let cursor_below_line =
                    (context.input.mouse_position.y - (pos.y + y + line_height)) > 0.;

                if (cursor_on_current_line && line_end && cursor_after_line_end)
                    || (cursor_on_current_line && clickable_character && cursor_on_character)
                    || (last_character && cursor_below_line)
                {
                    clicked = true;

                    if context.input.click_down() {
                        state.click_down(time, &text_vec, n as u32);
                    } else {
                        state.click_move(&text_vec, n as u32);
                    }
                }
            }

            x += advance;
            if character == '\n' && self.multiline {
                y += line_height;
                x = LEFT_MARGIN;
            }
        }

        if context.input.click_up() && input_focused {
            state.click_up(&text_vec);
        }

        let context = ui.get_active_window_context();

        context.window.painter.clip(None);

        ui.end_window();

        *text = text_vec.iter().collect();
        edited
    }
}

impl Ui {
    pub fn editbox(&mut self, id: Id, size: Vec2, text: &mut String) -> bool {
        Editbox::new(id, size).ui(self, text)
    }
}

```

`src/ui/widgets/editbox/text_editor.rs`:

```rs
trait Command {
    fn apply(&self, text_cursor: &mut u32, text: &mut Vec<char>);
    fn unapply(&self, text_cursor: &mut u32, text: &mut Vec<char>);
}

struct InsertCharacter {
    character: char,
    cursor: u32,
}

impl InsertCharacter {
    fn new(editor: &EditboxState, _text: &mut Vec<char>, character: char) -> InsertCharacter {
        InsertCharacter {
            cursor: editor.cursor,
            character,
        }
    }
}

impl Command for InsertCharacter {
    fn apply(&self, text_cursor: &mut u32, text: &mut Vec<char>) {
        *text_cursor = self.cursor;
        if self.cursor <= text.len() as u32 {
            text.insert(self.cursor as usize, self.character);
        }
        *text_cursor += 1;
    }
    fn unapply(&self, text_cursor: &mut u32, text: &mut Vec<char>) {
        *text_cursor = self.cursor;
        if self.cursor < text.len() as u32 {
            text.remove(self.cursor as usize);
        }
    }
}

struct InsertString {
    data: Vec<char>,
    cursor: u32,
}

impl InsertString {
    fn new(editor: &EditboxState, _text: &mut Vec<char>, data: Vec<char>) -> InsertString {
        InsertString {
            cursor: editor.cursor,
            data,
        }
    }
}

impl Command for InsertString {
    fn apply(&self, text_cursor: &mut u32, text: &mut Vec<char>) {
        *text_cursor = self.cursor;
        if self.cursor <= text.len() as u32 {
            text.splice(
                self.cursor as usize..self.cursor as usize,
                self.data.clone(),
            );
        }
        *text_cursor += self.data.len() as u32;
    }

    fn unapply(&self, text_cursor: &mut u32, text: &mut Vec<char>) {
        *text_cursor = self.cursor;
        if self.cursor < text.len() as u32 {
            let end = (self.cursor as usize + self.data.len()).min(text.len());
            text.drain(self.cursor as usize..end);
        }
    }
}

struct DeleteCharacter {
    character: char,
    cursor: u32,
}

impl DeleteCharacter {
    fn new(editor: &EditboxState, text: &mut Vec<char>) -> Option<DeleteCharacter> {
        let character = text.get(editor.cursor as usize).copied();

        character.map(|character| DeleteCharacter {
            cursor: editor.cursor,
            character,
        })
    }
}

impl Command for DeleteCharacter {
    fn apply(&self, text_cursor: &mut u32, text: &mut Vec<char>) {
        *text_cursor = self.cursor;
        if self.cursor < text.len() as u32 {
            text.remove(self.cursor as usize);
        }
    }

    fn unapply(&self, text_cursor: &mut u32, text: &mut Vec<char>) {
        *text_cursor = self.cursor + 1;
        if self.cursor <= text.len() as u32 {
            text.insert(self.cursor as usize, self.character);
        }
    }
}

struct DeleteRange {
    range: (u32, u32),
    data: Vec<char>,
}

impl DeleteRange {
    fn new(text: &mut Vec<char>, (start, end): (u32, u32)) -> DeleteRange {
        let min = start.min(end) as usize;
        let max = start.max(end) as usize;

        DeleteRange {
            data: text[min..max].to_vec(),
            range: (start, end),
        }
    }
}

impl Command for DeleteRange {
    fn apply(&self, text_cursor: &mut u32, text: &mut Vec<char>) {
        let (start, end) = self.range;
        let min = start.min(end) as usize;
        let max = start.max(end) as usize;

        text.drain(min..max);

        *text_cursor = min as u32;
    }

    fn unapply(&self, text_cursor: &mut u32, text: &mut Vec<char>) {
        let (start, end) = self.range;
        let start = start.min(end) as usize;
        text.splice(start..start, self.data.clone());
        *text_cursor = start as u32;
    }
}

#[derive(Debug)]
pub enum ClickState {
    None,
    SelectingChars { selection_begin: u32 },
    SelectingWords { selected_word: (u32, u32) },
    SelectingLines { selected_line: (u32, u32) },
    Selected,
}
impl Default for ClickState {
    fn default() -> ClickState {
        ClickState::None
    }
}
pub const DOUBLE_CLICK_TIME: f32 = 0.5;

#[derive(Default)]
pub struct EditboxState {
    pub cursor: u32,
    pub click_state: ClickState,
    pub clicks_counter: u32,
    pub current_click: u32,
    pub last_click_time: f32,
    pub last_click: u32,
    pub selection: Option<(u32, u32)>,
    undo_stack: Vec<Box<dyn Command>>,
    redo_stack: Vec<Box<dyn Command>>,
}

impl EditboxState {
    pub fn clamp_selection<'a>(&mut self, text: &'a Vec<char>) {
        if let Some((ref mut start, ref mut end)) = &mut self.selection {
            if *start >= text.len() as u32 {
                *start = text.len() as _;
            }
            if *end >= text.len() as u32 {
                *end = text.len() as _;
            }
        }
    }

    pub fn selected_text<'a>(&self, text: &'a Vec<char>) -> Option<&'a [char]> {
        if let Some((start, end)) = self.selection {
            let min = start.min(end) as usize;
            let max = start.max(end) as usize;

            assert!(min <= max);
            assert!(max <= text.len());

            Some(&text[min..max])
        } else {
            None
        }
    }
    pub const fn in_selected_range(&self, cursor: u32) -> bool {
        match self.selection {
            Some((start, end)) if start < end => cursor >= start && cursor < end,
            Some((end, start)) => cursor >= start && cursor < end,
            _ => false,
        }
    }
    pub fn find_line_begin(&self, text: &Vec<char>) -> u32 {
        let mut line_position = 0;
        let mut cursor_tmp = self.cursor;

        while cursor_tmp > 0 && text.get(cursor_tmp as usize - 1).copied().unwrap_or('x') != '\n' {
            cursor_tmp -= 1;
            line_position += 1;
        }
        line_position
    }

    pub fn find_line_end(&self, text: &Vec<char>) -> u32 {
        let mut cursor_tmp = self.cursor;
        while cursor_tmp < text.len() as u32
            && text.get(cursor_tmp as usize).copied().unwrap_or('x') != '\n'
        {
            cursor_tmp += 1;
        }

        cursor_tmp - self.cursor
    }

    pub const fn word_delimiter(character: char) -> bool {
        character == ' '
            || character == '('
            || character == ')'
            || character == ';'
            || character == '\"'
    }

    pub fn find_word_begin(&self, text: &Vec<char>, cursor: u32) -> u32 {
        let mut cursor_tmp = cursor;
        let mut offset = 0;

        while cursor_tmp > 0 {
            let current_char = text.get(cursor_tmp as usize - 1).copied().unwrap_or(' ');
            if Self::word_delimiter(current_char) || current_char == '\n' {
                break;
            }
            offset += 1;
            cursor_tmp -= 1;
        }
        offset
    }

    pub fn find_word_end(&self, text: &Vec<char>, cursor: u32) -> u32 {
        let mut cursor_tmp = cursor;
        let mut offset = 0;
        let mut space_skipping = false;

        while cursor_tmp < text.len() as u32 {
            let current_char = text.get(cursor_tmp as usize).copied().unwrap_or(' ');
            if Self::word_delimiter(current_char) || current_char == '\n' {
                space_skipping = true;
            }
            if space_skipping && Self::word_delimiter(current_char) == false {
                break;
            }
            cursor_tmp += 1;
            offset += 1;
        }
        offset
    }

    pub fn insert_character(&mut self, text: &mut Vec<char>, character: char) {
        self.redo_stack.clear();

        self.selection = None;

        let insert_command = InsertCharacter::new(self, text, character);
        insert_command.apply(&mut self.cursor, text);
        self.undo_stack.push(Box::new(insert_command));
    }

    pub fn insert_string(&mut self, text: &mut Vec<char>, string: Vec<char>) {
        self.redo_stack.clear();

        self.selection = None;

        let insert_command = InsertString::new(self, text, string.to_owned());
        insert_command.apply(&mut self.cursor, text);
        self.undo_stack.push(Box::new(insert_command));
    }

    pub fn delete_selected(&mut self, text: &mut Vec<char>) {
        self.redo_stack.clear();

        if let Some(range) = self.selection {
            let delete_command = DeleteRange::new(text, range);
            delete_command.apply(&mut self.cursor, text);
            self.undo_stack.push(Box::new(delete_command));
        }
        self.selection = None;
    }

    pub fn delete_next_character(&mut self, text: &mut Vec<char>) {
        self.redo_stack.clear();

        if let Some(delete_command) = DeleteCharacter::new(self, text) {
            delete_command.apply(&mut self.cursor, text);
            self.undo_stack.push(Box::new(delete_command));
        }
    }

    pub fn delete_current_character(&mut self, text: &mut Vec<char>) {
        if self.cursor > 0 {
            self.cursor -= 1;
            self.delete_next_character(text);
        }
    }

    pub fn move_cursor_next_word(&mut self, text: &Vec<char>, shift: bool) {
        let next_word = self.find_word_end(text, self.cursor + 1) + 1;
        self.move_cursor(text, next_word as i32, shift);
    }

    pub fn move_cursor_prev_word(&mut self, text: &Vec<char>, shift: bool) {
        if self.cursor > 1 {
            let prev_word = self.find_word_begin(text, self.cursor - 1) + 1;
            self.move_cursor(text, -(prev_word as i32), shift);
        }
    }

    pub fn move_cursor(&mut self, text: &Vec<char>, dx: i32, shift: bool) {
        let start_cursor = self.cursor;
        let mut end_cursor = start_cursor;

        if self.cursor as i32 + dx <= text.len() as i32 && self.cursor as i32 + dx >= 0 {
            end_cursor = (self.cursor as i32 + dx) as u32;
            self.cursor = end_cursor;
        }

        if shift == false {
            self.selection = None;
        }
        if shift {
            match &mut self.selection {
                None => self.selection = Some((start_cursor, end_cursor)),
                Some((_, ref mut end)) => {
                    *end = end_cursor;
                }
            }
        }
    }

    pub fn move_cursor_within_line(&mut self, text: &Vec<char>, dx: i32, shift: bool) {
        assert!(dx >= 0, "not implemented");

        for _ in 0..dx {
            if text.get(self.cursor as usize).copied().unwrap_or('x') == '\n'
                || self.cursor == text.len() as u32
            {
                break;
            }
            self.move_cursor(text, 1, shift);
        }
    }

    pub fn select_all(&mut self, text: &Vec<char>) {
        self.selection = Some((0, text.len() as u32));
        self.click_state = ClickState::None;
    }

    pub fn deselect(&mut self) {
        self.click_state = ClickState::None;
        self.selection = None;
    }

    pub fn select_word(&mut self, text: &Vec<char>) -> (u32, u32) {
        let to_word_begin = self.find_word_begin(text, self.cursor);
        let to_word_end = self.find_word_end(text, self.cursor);
        let new_selection = (self.cursor - to_word_begin, self.cursor + to_word_end);

        self.selection = Some(new_selection);
        new_selection
    }

    pub fn select_line(&mut self, text: &Vec<char>) -> (u32, u32) {
        let to_line_begin = self.find_line_begin(text);
        let to_line_end = self.find_line_end(text);
        let new_selection = (self.cursor - to_line_begin, self.cursor + to_line_end);

        self.selection = Some(new_selection);
        new_selection
    }

    pub fn click_down(&mut self, time: f32, text: &Vec<char>, cursor: u32) {
        self.current_click = cursor;

        if self.last_click == self.current_click && time - self.last_click_time < DOUBLE_CLICK_TIME
        {
            self.clicks_counter += 1;
            match self.clicks_counter % 3 {
                0 => {
                    self.deselect();
                    self.click_state = ClickState::None;
                }
                1 => {
                    let selected_word = self.select_word(text);
                    self.click_state = ClickState::SelectingWords { selected_word };
                }
                2 => {
                    let selected_line = self.select_line(text);
                    self.click_state = ClickState::SelectingLines { selected_line }
                }
                _ => unreachable!(),
            }
        } else {
            self.clicks_counter = 0;
            if let ClickState::None | ClickState::Selected = self.click_state {
                self.click_state = ClickState::SelectingChars {
                    selection_begin: cursor,
                };
                self.selection = Some((cursor, cursor));
            } else {
                self.click_state = ClickState::None;
                self.selection = None;
                self.cursor = cursor;
            }
        }

        self.last_click_time = time;
    }

    pub fn click_move(&mut self, text: &Vec<char>, cursor: u32) {
        self.cursor = cursor;

        if self.cursor != self.last_click {
            self.clicks_counter = 0;
        }

        match self.click_state {
            ClickState::SelectingChars { selection_begin } => {
                self.selection = Some((selection_begin, cursor));
            }
            ClickState::SelectingWords {
                selected_word: (from, to),
            } => {
                if cursor < from {
                    let word_begin = self.cursor - self.find_word_begin(text, self.cursor);
                    self.selection = Some((word_begin, to));
                    self.cursor = word_begin;
                } else if cursor > to {
                    let word_end = self.cursor + self.find_word_end(text, self.cursor);
                    self.selection = Some((from, word_end));
                    self.cursor = word_end;
                } else {
                    self.selection = Some((from, to));
                    self.cursor = to;
                }
            }
            ClickState::SelectingLines {
                selected_line: (from, to),
            } => {
                if cursor < from {
                    let line_begin = self.cursor - self.find_line_begin(text);
                    let line_end = self.cursor + self.find_line_end(text);
                    self.selection = Some((line_begin, to));
                    self.cursor = line_end;
                } else if cursor > to {
                    let line_end = self.cursor + self.find_line_end(text);
                    self.selection = Some((from, line_end));
                    self.cursor = line_end;
                } else {
                    self.selection = Some((from, to));
                    self.cursor = to;
                }
            }
            _ => {}
        }

        self.last_click = cursor;
    }

    pub fn click_up(&mut self, _text: &Vec<char>) {
        self.click_state = ClickState::None;
        if let Some((from, to)) = self.selection {
            if from != to {
                self.click_state = ClickState::Selected;
            } else {
                self.selection = None;
            }
        }
    }

    pub fn undo(&mut self, text: &mut Vec<char>) {
        let command = self.undo_stack.pop();

        if let Some(command) = command {
            command.unapply(&mut self.cursor, text);
            self.redo_stack.push(command);
        }
    }

    pub fn redo(&mut self, text: &mut Vec<char>) {
        let command = self.redo_stack.pop();

        if let Some(command) = command {
            command.apply(&mut self.cursor, text);
            self.undo_stack.push(command);
        }
    }
}

```

`src/ui/widgets/group.rs`:

```rs
use crate::{
    math::{Rect, Vec2},
    ui::{Drag, DragState, ElementState, Id, Layout, Ui},
};

#[derive(Debug, Clone)]
pub struct Group {
    id: Id,
    position: Option<Vec2>,
    layout: Layout,
    size: Vec2,
    draggable: bool,
    highlight: bool,
    hoverable: bool,
}

impl Group {
    pub const fn new(id: Id, size: Vec2) -> Group {
        Group {
            id,
            size,
            position: None,
            layout: Layout::Horizontal,
            draggable: false,
            highlight: false,
            hoverable: false,
        }
    }

    pub const fn position(self, position: Vec2) -> Group {
        Group {
            position: Some(position),
            ..self
        }
    }

    pub const fn layout(self, layout: Layout) -> Group {
        Group { layout, ..self }
    }

    pub const fn draggable(self, draggable: bool) -> Group {
        Group { draggable, ..self }
    }

    pub const fn hoverable(self, hoverable: bool) -> Group {
        Group { hoverable, ..self }
    }

    pub const fn highlight(self, highlight: bool) -> Group {
        Group { highlight, ..self }
    }

    pub fn ui<F: FnOnce(&mut Ui)>(self, ui: &mut Ui, f: F) -> Drag {
        let token = self.begin(ui);
        f(ui);
        token.end(ui)
    }

    pub fn begin(self, ui: &mut Ui) -> GroupToken {
        let mut drag = Drag::No;

        let parent = ui.get_active_window_context();

        let parent_rect = parent.window.content_rect();

        parent.window.childs.push(self.id);

        let pos = parent
            .window
            .cursor
            .fit(self.size, self.position.map_or(self.layout, Layout::Free));
        let rect = Rect::new(pos.x, pos.y, self.size.x, self.size.y);
        let parent_id = Some(parent.window.id);

        let mut context = ui.begin_window(self.id, parent_id, pos, self.size, false, true);

        let hovered =
            (self.hoverable || self.draggable) && rect.contains(context.input.mouse_position);

        if self.draggable && context.dragging.is_none() && hovered && context.input.click_down {
            *context.dragging = Some((self.id, DragState::Clicked(context.input.mouse_position)));
        }

        if let Some((id, DragState::Clicked(orig))) = context.dragging {
            if *id == self.id
                && context.input.is_mouse_down
                && context.input.mouse_position.distance(*orig) > 5.
            {
                *context.dragging = Some((self.id, DragState::Dragging(*orig)));
            }
            if context.input.is_mouse_down == false {
                *context.dragging = None;
            }
        }

        if let Some((id, DragState::Dragging(_))) = context.dragging {
            let id = *id;

            if id == self.id {
                drag = Drag::Dragging(
                    context.input.mouse_position,
                    *context.drag_hovered_previous_frame,
                );

                if context.input.is_mouse_down == false {
                    *context.dragging = None;
                    drag = Drag::Dropped(
                        context.input.mouse_position,
                        *context.drag_hovered_previous_frame,
                    );
                }
            }

            if id != self.id && hovered {
                *context.drag_hovered = Some(self.id);
            }
        }

        context.window.painter.clip(parent_rect);

        context.scroll_area();

        let clip_rect = context.window.content_rect();
        context.window.painter.clip(clip_rect);
        context.window.painter.draw_rect(
            rect,
            context.style.group_style.color(ElementState {
                focused: context.focused,
                hovered,
                clicked: false,
                selected: self.highlight,
            }),
            None,
        );

        GroupToken {
            draggable: self.draggable,
            drag,
            pos,
            size: self.size,
        }
    }
}

#[must_use = "Must call `.end()` to finish Group"]
pub struct GroupToken {
    draggable: bool,
    drag: Drag,
    pos: Vec2,
    size: Vec2,
}

impl GroupToken {
    pub fn end(self, ui: &mut Ui) -> Drag {
        let context = ui.get_active_window_context();

        context.window.painter.clip(None);

        if context.focused && self.draggable {
            if
            //parent.dragging.is_none()
            context.input.is_mouse_down
                && Rect::new(self.pos.x, self.pos.y, self.size.x, self.size.y)
                    .contains(context.input.mouse_position)
            {
                // *context.dragging = Some((
                //     id,
                //     DragState::Clicked(context.input.mouse_position, Vec2::new(rect.x, rect.y)),
                // ));
            }
        }

        ui.end_window();

        self.drag
    }
}

impl Ui {
    pub fn group<F: FnOnce(&mut Ui)>(&mut self, id: Id, size: Vec2, f: F) -> Drag {
        Group::new(id, size).ui(self, f)
    }
}

```

`src/ui/widgets/input.rs`:

```rs
use crate::{
    math::{vec2, Vec2},
    ui::{widgets::Editbox, ElementState, Id, Layout, Ui, UiContent},
};

pub struct InputText<'a> {
    id: Id,
    label: &'a str,
    size: Option<Vec2>,
    password: bool,
    numbers: bool,
    ratio: f32,
    pos: Option<Vec2>,
    margin: Option<Vec2>,
}

impl<'a> InputText<'a> {
    pub const fn new(id: Id) -> InputText<'a> {
        InputText {
            id,
            size: None,
            label: "",
            numbers: false,
            password: false,
            ratio: 0.5,
            pos: None,
            margin: None,
        }
    }

    pub const fn label<'b>(self, label: &'b str) -> InputText<'b> {
        InputText {
            id: self.id,
            size: self.size,
            label,
            numbers: self.numbers,
            password: self.password,
            ratio: self.ratio,
            pos: self.pos,
            margin: self.margin,
        }
    }

    pub const fn size(self, size: Vec2) -> Self {
        Self {
            size: Some(size),
            ..self
        }
    }

    pub const fn position(self, pos: Vec2) -> Self {
        Self {
            pos: Some(pos),
            ..self
        }
    }

    pub const fn password(self, password: bool) -> Self {
        Self { password, ..self }
    }

    pub const fn ratio(self, ratio: f32) -> Self {
        Self { ratio, ..self }
    }

    pub const fn filter_numbers(self) -> Self {
        Self {
            numbers: true,
            ..self
        }
    }

    pub const fn margin(self, margin: Vec2) -> Self {
        Self {
            margin: Some(margin),
            ..self
        }
    }

    pub fn ui(self, ui: &mut Ui, data: &mut String) {
        let context = ui.get_active_window_context();

        let label_size = context.window.painter.content_with_margins_size(
            &context.style.editbox_style,
            &UiContent::Label((&*data).into()),
        );

        let size = self.size.unwrap_or(vec2(
            context.window.cursor.area.w - context.style.margin * 2. - context.window.cursor.ident,
            label_size.y.max(19.),
        ));

        let pos = self
            .pos
            .map(|pos| pos + context.window.cursor.fit(size, Layout::Vertical))
            .unwrap_or_else(|| context.window.cursor.fit(size, Layout::Vertical));

        let editbox_area_w = if self.label.is_empty() {
            size.x
        } else {
            size.x * self.ratio - 15.
        };
        let mut editbox = Editbox::new(self.id, Vec2::new(editbox_area_w, size.y))
            .password(self.password)
            .position(pos)
            .multiline(false);

        if let Some(margin) = self.margin {
            editbox = editbox.margin(margin);
        }

        if self.numbers {
            editbox = editbox.filter(&|character| {
                character.is_digit(10) || character == '.' || character == '-'
            });
        }
        editbox.ui(ui, data);

        let context = ui.get_active_window_context();

        if self.label.is_empty() == false {
            context.window.painter.draw_element_label(
                &context.style.label_style,
                Vec2::new(pos.x + size.x * self.ratio, pos.y),
                self.label,
                ElementState {
                    focused: context.focused,
                    ..Default::default()
                },
            );
        }
    }
}

impl Ui {
    pub fn input_text(&mut self, id: Id, label: &str, data: &mut String) {
        InputText::new(id).label(label).ui(self, data);
    }

    pub fn input_password(&mut self, id: Id, label: &str, data: &mut String) {
        InputText::new(id)
            .label(label)
            .password(true)
            .ui(self, data);
    }
}

```

`src/ui/widgets/label.rs`:

```rs
use crate::{
    math::Vec2,
    ui::{ElementState, Layout, Ui, UiContent},
};

use std::borrow::Cow;

pub struct Label<'a> {
    position: Option<Vec2>,
    _multiline: Option<f32>,
    size: Option<Vec2>,
    label: Cow<'a, str>,
}

impl<'a> Label<'a> {
    pub fn new<S>(label: S) -> Label<'a>
    where
        S: Into<Cow<'a, str>>,
    {
        Label {
            position: None,
            _multiline: None,
            size: None,
            label: label.into(),
        }
    }

    pub fn multiline(self, line_height: f32) -> Self {
        Label {
            _multiline: Some(line_height),
            ..self
        }
    }

    pub fn position<P: Into<Option<Vec2>>>(self, position: P) -> Self {
        let position = position.into();

        Label { position, ..self }
    }

    pub fn size(self, size: Vec2) -> Self {
        Label {
            size: Some(size),
            ..self
        }
    }

    pub fn ui(self, ui: &mut Ui) {
        let context = ui.get_active_window_context();

        let size = self.size.unwrap_or_else(|| {
            context.window.painter.content_with_margins_size(
                &context.style.label_style,
                &UiContent::Label(self.label.clone()),
            )
        });

        let pos = context
            .window
            .cursor
            .fit(size, self.position.map_or(Layout::Vertical, Layout::Free));

        context.window.painter.draw_element_content(
            &context.style.label_style,
            pos,
            size,
            &UiContent::Label(self.label),
            ElementState {
                focused: context.focused,
                hovered: false,
                clicked: false,
                selected: false,
            },
        );
    }
}

impl Ui {
    pub fn label<P: Into<Option<Vec2>>>(&mut self, position: P, label: &str) {
        Label::new(label).position(position).ui(self);
    }

    pub fn calc_size(&mut self, label: &str) -> Vec2 {
        let context = self.get_active_window_context();

        context
            .window
            .painter
            .content_with_margins_size(&context.style.label_style, &UiContent::Label(label.into()))
    }
}

```

`src/ui/widgets/popup.rs`:

```rs
use crate::{
    math::Vec2,
    ui::{Id, Ui},
};

/// Borderless subwindow drawn on top of everything
pub struct Popup {
    id: Id,
    size: Vec2,
}

impl Popup {
    pub const fn new(id: Id, size: Vec2) -> Popup {
        Popup { id, size }
    }

    pub fn ui<F: FnOnce(&mut Ui)>(self, ui: &mut Ui, f: F) {
        let pos = {
            let context = ui.get_active_window_context();
            context.window.cursor.current_position()
        };

        let _context = ui.begin_modal(self.id, pos, self.size);
        f(ui);
        ui.end_modal();
    }
}

impl Ui {
    pub fn popup<F: FnOnce(&mut Ui)>(&mut self, id: Id, size: Vec2, f: F) {
        Popup::new(id, size).ui(self, f);
    }
}

```

`src/ui/widgets/progress_bar.rs`:

```rs
use crate::{
    math::{vec2, Rect},
    ui::{ElementState, Layout, Ui},
};

pub struct ProgressBar<'a> {
    label: &'a str,
    label_width: Option<f32>,
}

impl<'a> ProgressBar<'a> {
    pub const fn new() -> Self {
        ProgressBar {
            label: "",
            label_width: None,
        }
    }

    pub const fn label<'b>(self, label: &'b str) -> ProgressBar<'b> {
        ProgressBar { label, ..self }
    }

    pub const fn label_width(self, width: f32) -> Self {
        Self {
            label_width: Some(width),
            ..self
        }
    }

    pub fn ui(self, ui: &mut Ui, progress: f32, bar_text: &str) {
        let mut context = ui.get_active_window_context();

        let size = vec2(
            context.window.cursor.area.w - context.style.margin * 3. - context.window.cursor.ident,
            19.,
        );

        let pos = context.window.cursor.fit(size, Layout::Vertical);
        let label_width = self.label_width.unwrap_or(100.);
        let bar_width = size.x - label_width;
        let bar_progress_width = progress.clamp(0., 1.) * bar_width;

        let bar_background = Rect::new(pos.x, pos.y, bar_width, 20.);
        let bar_progress = Rect::new(pos.x, pos.y, bar_progress_width, 20.);

        context.register_click_intention(bar_background);

        // background bar
        context.window.painter.draw_rect(
            bar_background,
            None,
            context.style.progress_bar_style.color(ElementState {
                focused: context.focused,
                hovered: false,
                clicked: false,
                selected: false,
            }),
        );
        // progress bar
        context.window.painter.draw_rect(
            bar_progress,
            None,
            context.style.progress_bar_style.color(ElementState {
                focused: context.focused,
                hovered: true,
                clicked: false,
                selected: false,
            }),
        );
        // label
        context.window.painter.draw_element_label(
            &context.style.label_style,
            vec2(pos.x + bar_width + 10., pos.y + 2.),
            self.label,
            ElementState {
                focused: context.focused,
                ..Default::default()
            },
        );
        // bar text
        context.window.painter.draw_element_content(
            &context.style.label_style,
            vec2(pos.x, pos.y),
            vec2(bar_width, 20.),
            &bar_text.into(),
            ElementState {
                focused: context.focused,
                ..Default::default()
            },
        );
    }
}

impl Ui {
    pub fn progress_bar(&mut self, label: &str, progress: f32) {
        ProgressBar::new().label(label).ui(self, progress, "");
    }
}

```

`src/ui/widgets/separator.rs`:

```rs
use crate::{
    math::Vec2,
    ui::{Layout, Ui},
};

impl Ui {
    pub fn separator(&mut self) {
        let context = self.get_active_window_context();

        // hack: to move cursor to the beginning of next line
        context
            .window
            .cursor
            .fit(Vec2::new(0., 1.), Layout::Vertical);

        // let _size = Vec2::new(
        //     context.window.cursor.area.w - context.style.margin * 2. - context.window.cursor.ident,
        //     5.,
        // );
        // let pos = context.window.cursor.fit(size, Layout::Vertical);
        // context.window.painter.draw_line(
        //     Vec2::new(pos.x, pos.y + 2.),
        //     Vec2::new(pos.x + size.x, pos.y + 2.),
        //     context.style.separator(context.focused),
        // );
    }
}

```

`src/ui/widgets/slider.rs`:

```rs
use crate::{
    math::{vec2, Rect},
    ui::{widgets::Editbox, ElementState, Id, Layout, Ui},
};

use std::ops::Range;

pub struct Slider<'a> {
    id: Id,
    label: &'a str,
    range: Range<f32>,
    label_width: Option<f32>,
}

impl<'a> Slider<'a> {
    pub const fn new(id: Id, range: Range<f32>) -> Slider<'a> {
        Slider {
            id,
            range,
            label: "",
            label_width: None,
        }
    }

    pub const fn label<'b>(self, label: &'b str) -> Slider<'b> {
        Slider { label, ..self }
    }

    pub const fn label_width(self, width: f32) -> Self {
        Slider {
            label_width: Some(width),
            ..self
        }
    }

    pub fn ui(self, ui: &mut Ui, data: &mut f32) {
        let context = ui.get_active_window_context();

        let size = vec2(
            context.window.cursor.area.w - context.style.margin * 3. - context.window.cursor.ident,
            19.,
        );
        let pos = context.window.cursor.fit(size, Layout::Vertical);

        let editbox_width = 50.;

        let label_width = self.label_width.unwrap_or(100.);
        let slider_width = size.x - editbox_width - label_width;
        let margin = 5.;

        let mut temp_string = context
            .storage_any
            .get_or_insert_with::<String, _>(self.id, || format!("{:.2}", *data))
            .clone();

        let editbox_id = hash!(self.id, "editbox");
        if context.input_focused(editbox_id) == false {
            use std::fmt::Write;

            temp_string.clear();
            let _ = write!(&mut temp_string, "{:.2}", *data);
        }

        Editbox::new(editbox_id, vec2(50., size.y))
            .position(pos)
            .multiline(false)
            .filter(&|character| character.is_digit(10) || character == '.' || character == '-')
            .ui(ui, &mut temp_string);

        let context = ui.get_active_window_context();
        let old_string = context.storage_any.get_or_default::<String>(self.id);
        if *old_string != temp_string {
            if let Ok(num) = temp_string.parse::<f32>() {
                if num > self.range.end {
                    *data = self.range.end;
                } else if num < self.range.start {
                    *data = self.range.start;
                } else {
                    *data = num;
                }
            }
        }

        let dragging = context
            .storage_u32
            .entry(hash!(self.id, "dragging"))
            .or_insert(0);

        let slider_start_x = editbox_width + pos.x + margin;
        let data_pos = (*data - self.range.start) / (self.range.end - self.range.start)
            * slider_width
            + slider_start_x;

        let bar_rect = Rect::new(data_pos - 4., pos.y, 8., 20.);
        let hovered = bar_rect.contains(context.input.mouse_position);

        if hovered && context.input.is_mouse_down() {
            *dragging = 1;
            *context.input_focus = Some(self.id);
            context.input.cursor_grabbed = true;
        }

        if *dragging == 1 && context.input.is_mouse_down == false {
            context.input.cursor_grabbed = false;
            *dragging = 0;
            *context.input_focus = None;
        }

        if *dragging == 1 {
            let mouse_position = ((context.input.mouse_position.x - slider_start_x) / slider_width)
                .min(1.)
                .max(0.);
            let old_data = *data;
            *data = self.range.start + (self.range.end - self.range.start) * mouse_position;

            if old_data != *data {
                use std::fmt::Write;

                temp_string.clear();
                let _ = write!(&mut temp_string, "{:.2}", *data);
            }
        }

        // static horizontal line in the middle of the slider
        context.window.painter.draw_line(
            vec2(pos.x + editbox_width + margin, pos.y + size.y / 2.),
            vec2(
                pos.x + editbox_width + slider_width + margin,
                pos.y + size.y / 2.,
            ),
            // TODO: introduce separate slider_style
            context.style.checkbox_style.color(ElementState {
                focused: context.focused,
                hovered: true,
                clicked: true,
                selected: false,
            }),
        );

        // slider bar
        context.window.painter.draw_rect(
            bar_rect,
            None,
            context.style.checkbox_style.color(ElementState {
                focused: context.focused,
                hovered,
                clicked: hovered && context.input.is_mouse_down,
                selected: false,
            }),
        );

        context.window.painter.draw_element_label(
            &context.style.label_style,
            vec2(
                pos.x + editbox_width + slider_width + margin * 2.,
                pos.y + 2.,
            ),
            self.label,
            ElementState {
                focused: context.focused,
                ..Default::default()
            },
        );

        *old_string = temp_string;
    }
}

impl Ui {
    pub fn slider(&mut self, id: Id, label: &str, range: Range<f32>, data: &mut f32) {
        Slider::new(id, range).label(label).ui(self, data);
    }
}

```

`src/ui/widgets/tabbar.rs`:

```rs
use crate::{
    math::{vec2, Rect, Vec2},
    ui::{ElementState, Id, Layout, Ui, UiContent},
};

pub struct Tabbar<'a, 'b> {
    id: Id,
    size: Vec2,
    selected_tab: Option<&'b mut u32>,
    tabs: &'a [&'a str],
}

impl<'a, 'b> Tabbar<'a, 'b> {
    pub fn new(id: Id, size: Vec2, tabs: &'a [&'a str]) -> Tabbar<'a, 'b> {
        Tabbar {
            id,
            size,
            tabs,
            selected_tab: None,
        }
    }

    pub fn selected_tab<'c>(self, selected_tab: Option<&'c mut u32>) -> Tabbar<'a, 'c> {
        Tabbar {
            id: self.id,
            selected_tab,
            size: self.size,
            tabs: self.tabs,
        }
    }

    pub fn ui(mut self, ui: &mut Ui) -> u32 {
        let context = ui.get_active_window_context();

        let pos = context.window.cursor.fit(self.size, Layout::Vertical);

        let width = self.size.x as f32 / self.tabs.len() as f32;

        let selected = *self
            .selected_tab
            .as_deref()
            .unwrap_or_else(|| context.storage_u32.entry(self.id).or_insert(0));

        for (n, label) in self.tabs.iter().enumerate() {
            let rect = Rect::new(
                pos.x + width * n as f32 + 1.,
                pos.y,
                width - 2.,
                self.size.y,
            );
            let hovered = rect.contains(context.input.mouse_position);
            let selected = n as u32 == selected;

            if context.focused && hovered && context.input.click_up {
                let id = self.id;
                let selected_mut = self
                    .selected_tab
                    .as_deref_mut()
                    .unwrap_or_else(|| context.storage_u32.entry(id).or_insert(0));

                *selected_mut = n as u32;
            }

            context.window.painter.draw_element_background(
                &context.style.tabbar_style,
                rect.point(),
                rect.size(),
                ElementState {
                    focused: context.focused,
                    hovered,
                    clicked: hovered && context.input.is_mouse_down,
                    selected,
                },
            );

            context.window.painter.draw_element_content(
                &context.style.tabbar_style,
                pos + vec2(width * n as f32, 0.0),
                vec2(width, self.size.y),
                &UiContent::Label((*label).into()),
                ElementState {
                    focused: context.focused,
                    hovered,
                    clicked: hovered && context.input.is_mouse_down,
                    selected,
                },
            );
        }

        *self
            .selected_tab
            .as_deref()
            .unwrap_or_else(|| context.storage_u32.entry(self.id).or_insert(0))
    }
}

impl Ui {
    pub fn tabbar<'a>(&mut self, id: Id, size: Vec2, tabs: &'a [&'a str]) -> u32 {
        Tabbar::new(id, size, tabs).ui(self)
    }
}

```

`src/ui/widgets/texture.rs`:

```rs
use crate::{
    math::{Rect, Vec2},
    texture::Texture2D,
    ui::{Layout, Ui},
};

pub struct Texture {
    position: Option<Vec2>,
    w: f32,
    h: f32,
    texture: Texture2D,
}

impl Texture {
    pub const fn new(texture: Texture2D) -> Texture {
        Texture {
            position: None,
            w: 100.,
            h: 100.,
            texture,
        }
    }

    pub fn size(self, w: f32, h: f32) -> Self {
        Texture { w, h, ..self }
    }

    pub fn position<P: Into<Option<Vec2>>>(self, position: P) -> Self {
        let position = position.into();

        Texture { position, ..self }
    }

    pub fn ui(self, ui: &mut Ui) -> bool {
        let context = ui.get_active_window_context();

        let size = Vec2::new(self.w, self.h);

        let pos = context
            .window
            .cursor
            .fit(size, self.position.map_or(Layout::Vertical, Layout::Free));
        context
            .window
            .painter
            .draw_raw_texture(Rect::new(pos.x, pos.y, self.w, self.h), &self.texture);

        let rect = Rect::new(pos.x, pos.y, size.x, size.y);
        let hovered = rect.contains(context.input.mouse_position);

        context.focused && hovered && context.input.click_up
    }
}

impl Ui {
    pub fn texture(&mut self, texture: Texture2D, w: f32, h: f32) -> bool {
        Texture::new(texture).size(w, h).ui(self)
    }
}

```

`src/ui/widgets/tree_node.rs`:

```rs
use crate::{
    math::{vec2, Rect},
    ui::{ElementState, Id, Layout, Ui},
};

use std::borrow::Cow;

pub struct TreeNode<'a> {
    id: Id,
    label: Cow<'a, str>,
    init_unfolded: bool,
}

impl<'a> TreeNode<'a> {
    pub fn new<S>(id: Id, label: S) -> TreeNode<'a>
    where
        S: Into<Cow<'a, str>>,
    {
        TreeNode {
            id,
            label: label.into(),
            init_unfolded: false,
        }
    }

    pub const fn init_unfolded(mut self) -> TreeNode<'a> {
        self.init_unfolded = true;
        self
    }

    pub fn ui<F: FnOnce(&mut Ui)>(self, ui: &mut Ui, f: F) -> bool {
        if let Some(token) = self.begin(ui) {
            f(ui);
            token.end(ui)
        } else {
            false
        }
    }

    pub fn begin(self, ui: &mut Ui) -> Option<TreeNodeToken> {
        let context = ui.get_active_window_context();

        let size = vec2(300., 14.);

        let pos = context.window.cursor.fit(size, Layout::Vertical);

        let rect = Rect::new(pos.x, pos.y, size.x as f32, size.y as f32);
        let hovered = rect.contains(context.input.mouse_position);

        let clicked = context.focused && hovered && context.input.click_down();

        let opened = context
            .storage_u32
            .entry(self.id)
            .or_insert(if self.init_unfolded { 1 } else { 0 });

        if clicked {
            *opened ^= 1;
        }

        context.window.painter.draw_element_label(
            &context.style.label_style,
            pos,
            if *opened == 0 { "+" } else { "-" },
            ElementState {
                focused: context.focused,
                ..Default::default()
            },
        );
        context.window.painter.draw_element_label(
            &context.style.label_style,
            pos + vec2(10., 0.),
            &self.label,
            ElementState {
                focused: context.focused,
                ..Default::default()
            },
        );

        if *opened == 1 {
            context.window.cursor.ident += 5.;

            Some(TreeNodeToken { clicked })
        } else {
            None
        }
    }
}

#[must_use = "Must call `.end()` to finish TreeNode"]
pub struct TreeNodeToken {
    clicked: bool,
}

impl TreeNodeToken {
    pub fn end(self, ui: &mut Ui) -> bool {
        let context = ui.get_active_window_context();
        context.window.cursor.ident -= 5.;

        self.clicked
    }
}

impl Ui {
    pub fn tree_node<F: FnOnce(&mut Ui)>(&mut self, id: Id, label: &str, f: F) -> bool {
        TreeNode::new(id, label).ui(self, f)
    }
}

```

`src/ui/widgets/window.rs`:

```rs
use crate::{
    math::{vec2, Rect, Vec2},
    ui::{ElementState, Id, Ui, UiContent, WindowContext},
};

#[derive(Debug, Clone)]
pub struct Window {
    id: Id,
    position: Vec2,
    size: Vec2,
    close_button: bool,
    movable: bool,
    titlebar: bool,
    label: Option<String>,
}

impl Window {
    pub const fn new(id: Id, position: Vec2, size: Vec2) -> Window {
        Window {
            id,
            position,
            size,
            close_button: false,
            movable: true,
            titlebar: true,
            label: None,
        }
    }

    pub fn label(self, label: &str) -> Window {
        Window {
            label: Some(label.to_string()),
            ..self
        }
    }

    /// If moveable is set to true then it means that the user
    /// can drag the window (default).
    ///
    /// After the first frame the window got drawn it will stop looking at the position given
    /// to it and instead will have its position be fully in control by the user.
    ///
    ///
    /// If on the other hand it is false then the position of this window will
    /// always be equal to the value given.
    pub fn movable(self, movable: bool) -> Window {
        Window { movable, ..self }
    }

    pub fn close_button(self, close_button: bool) -> Window {
        Window {
            close_button,
            ..self
        }
    }

    pub fn titlebar(self, titlebar: bool) -> Window {
        Window { titlebar, ..self }
    }

    pub fn ui<F: FnOnce(&mut Ui)>(self, ui: &mut Ui, f: F) -> bool {
        let token = self.begin(ui);
        f(ui);
        token.end(ui)
    }

    pub fn begin(self, ui: &mut Ui) -> WindowToken {
        let context = ui.begin_window(
            self.id,
            None,
            self.position,
            self.size,
            self.titlebar,
            self.movable,
        );

        // TODO: this will make each new window focused(appeared on the top) always
        // consider adding some configuration to be able to spawn background windows
        if context.window.was_active == false {
            ui.focus_window(self.id);
        }

        let mut context = ui.get_active_window_context();

        self.draw_window_frame(&mut context);
        if self.close_button && self.draw_close_button(&mut context) {
            context.close();
        }

        let clip_rect = context.window.content_rect();
        context.scroll_area();

        context.window.painter.clip(clip_rect);

        WindowToken
    }

    fn draw_close_button(&self, context: &mut WindowContext) -> bool {
        let style = context.style;
        let size = Vec2::new(style.title_height - 4., style.title_height - 4.);
        let pos = Vec2::new(
            context.window.position.x + context.window.size.x - style.title_height + 1.,
            context.window.position.y + 2.,
        );
        let rect = Rect::new(pos.x, pos.y, size.x, size.y);
        let (hovered, clicked) = context.register_click_intention(rect);

        context.window.painter.draw_element_background(
            &context.style.button_style,
            pos,
            size,
            ElementState {
                focused: context.focused,
                hovered,
                clicked: hovered && context.input.is_mouse_down,
                selected: false,
            },
        );

        clicked
    }

    fn draw_window_frame(&self, context: &mut WindowContext) {
        let focused = context.focused;
        let style = context.style;
        let position = context.window.position;
        let size = context.window.size;

        context.window.painter.draw_element_background(
            &style.window_style,
            position,
            size,
            ElementState {
                focused,
                hovered: false,
                clicked: false,
                selected: false,
            },
        );

        // TODO: figure what does title bar mean with windows with background
        if self.titlebar {
            if let Some(label) = &self.label {
                context.window.painter.draw_element_content(
                    &context.style.window_titlebar_style,
                    position,
                    vec2(size.x, style.title_height),
                    &UiContent::Label(label.into()),
                    ElementState {
                        focused,
                        clicked: false,
                        hovered: false,
                        selected: false,
                    },
                );
            }
            context.window.painter.draw_line(
                vec2(position.x, position.y + style.title_height),
                vec2(position.x + size.x, position.y + style.title_height),
                style.window_titlebar_style.color(ElementState {
                    focused,
                    clicked: false,
                    hovered: false,
                    selected: false,
                }),
            );
        }
    }
}

#[must_use = "Must call `.end()` to finish Window"]
pub struct WindowToken;

impl WindowToken {
    pub fn end(self, ui: &mut Ui) -> bool {
        let context = ui.get_active_window_context();
        context.window.painter.clip(None);

        let opened = context.window.want_close == false;

        ui.end_window();

        opened
    }
}

impl Ui {
    pub fn window<F: FnOnce(&mut Ui)>(&mut self, id: Id, position: Vec2, size: Vec2, f: F) -> bool {
        Window::new(id, position, size).titlebar(false).ui(self, f)
    }
}

```

`src/window.rs`:

```rs
//! Window and associated to window rendering context related functions.

use crate::{get_context, get_quad_context};

use crate::color::Color;

// miniquad is re-exported for the use in combination with `get_internal_gl`
pub use miniquad;

pub use miniquad::conf::Conf;

/// Block execution until the next frame.
#[must_use = "use `next_frame().await` to advance to the next frame"]
pub fn next_frame() -> crate::exec::FrameFuture {
    crate::thread_assert::same_thread();
    crate::exec::FrameFuture::default()
}

/// Fill window background with solid color.
/// Note: even when "clear_background" is not called explicitly,
/// the screen will be cleared at the beginning of the frame.
pub fn clear_background(color: Color) {
    let context = get_context();

    context.gl.clear(get_quad_context(), color);
}

#[doc(hidden)]
pub fn gl_set_drawcall_buffer_capacity(max_vertices: usize, max_indices: usize) {
    let context = get_context();
    context
        .gl
        .update_drawcall_capacity(get_quad_context(), max_vertices, max_indices);
}

pub struct InternalGlContext<'a> {
    pub quad_context: &'a mut dyn miniquad::RenderingBackend,
    pub quad_gl: &'a mut crate::quad_gl::QuadGl,
}

impl<'a> InternalGlContext<'a> {
    /// Draw all the batched stuff and reset the internal state cache.
    /// May be helpful for combining macroquad's drawing with raw miniquad/opengl calls.
    pub fn flush(&mut self) {
        get_context().perform_render_passes();
    }
}

pub unsafe fn get_internal_gl<'a>() -> InternalGlContext<'a> {
    let context = get_context();

    InternalGlContext {
        quad_context: get_quad_context(),
        quad_gl: &mut context.gl,
    }
}

pub fn screen_width() -> f32 {
    let context = get_context();
    context.screen_width / miniquad::window::dpi_scale()
}

pub fn screen_height() -> f32 {
    let context = get_context();

    context.screen_height / miniquad::window::dpi_scale()
}

pub fn screen_dpi_scale() -> f32 {
    miniquad::window::dpi_scale()
}

/// Request the window size to be the given value. This takes DPI into account.
///
/// Note that the OS might decide to give a different size. Additionally, the size in macroquad won't be updated until the next `next_frame().await`.
pub fn request_new_screen_size(width: f32, height: f32) {
    miniquad::window::set_window_size(
        (width * miniquad::window::dpi_scale()) as u32,
        (height * miniquad::window::dpi_scale()) as u32,
    );
    // We do not set the context.screen_width and context.screen_height here.
    // After `set_window_size` is called, EventHandlerFree::resize will be invoked, setting the size correctly.
    // Because the OS might decide to give a different screen dimension, setting the context.screen_* here would be confusing.
}

/// Toggle whether the window is fullscreen.
pub fn set_fullscreen(fullscreen: bool) {
    miniquad::window::set_fullscreen(fullscreen);
}

/// With `set_panic_handler` set to a handler code, macroquad will use
/// `std::panic::catch_unwind` on user code to catch some panics.
///
/// Sometimes it is nice to let player send a bug report with a screenshot of an
/// error. It is way easier to ask for a screenshot than ask to connect to a phone
/// with adb and post a log.
///
/// For this very case "set_panic_handler" exists.
/// ```ignore
/// set_panic_handler(|msg, backtrace| async move {
///     loop {
///         clear_background(RED);
///         ui::root_ui().label(None, &msg);
///         for line in backtrace.split('\n') {
///             root_ui().label(None, line);
///         }
///         next_frame().await;
///      }
/// });
/// ```
///
/// `set_panic_handler` acts as a second app entry-point, that will be used
/// after a panic in user code will happen. Macroquad will also try to catch some OS
/// panics, but not all of them - some compatibility bugs may end up crashing the app.
///
/// Without `set_panic_handler` macroquad will not use `catch_unwind` at all,
/// therefore `panic_handler` is completely optional.
/// NOTE: only with "backtrace" macroquad feature `backtrace` string will contain an
/// actual backtrace. Otherwise only panic location and message will be available.
/// NOTE: on android, even with "backtrace" nice backtrace is available only if the game is compiled with sdk >= 21.
/// To use sdk >= 21 add "min_sdk_version = 21" to Cargo.toml
pub fn set_panic_handler<T, F>(future: F)
where
    T: std::future::Future<Output = ()> + 'static,
    F: Fn(String, String) -> T + Send + Sync + 'static,
{
    std::panic::set_hook(Box::new(move |info| {
        let message = format!("{info:?}");
        #[cfg(feature = "backtrace")]
        let backtrace_string = format!("{:?}", backtrace::Backtrace::new());
        #[cfg(not(feature = "backtrace"))]
        let backtrace_string = format!("Macroquad compiled without \"backtrace\" feature");
        crate::logging::error!("{}", message);
        crate::logging::error!("{}", backtrace_string);

        crate::get_context().recovery_future = Some(Box::pin(future(message, backtrace_string)));
    }));

    crate::get_context().unwind = true;
}

```

`tests/back_to_the_future.rs`:

```rs
use std::{future::Future, task::Poll};

#[macroquad::test]
async fn back_to_the_future() {
    struct Kaboom;
    impl Future for Kaboom {
        type Output = ();

        fn poll(
            self: std::pin::Pin<&mut Self>,
            cx: &mut std::task::Context<'_>,
        ) -> Poll<Self::Output> {
            let cloned = cx.waker().clone(); // segmentation fault
            drop(cloned);
            Poll::Ready(())
        }
    }
    Kaboom.await;
}

```

`tests/back_to_the_future_coroutines.rs`:

```rs
use std::sync::{Arc, Mutex};

use macroquad::prelude::{
    coroutines::{start_coroutine, wait_seconds},
    next_frame,
};

#[macroquad::test]
async fn back_to_the_future_coroutine() {
    struct Player {
        on_ground: bool,
        allow_movement: bool,
    }
    let player = Arc::new(Mutex::new(Player {
        on_ground: false,
        allow_movement: false,
    }));
    let player2 = player.clone();
    start_coroutine(async move {
        loop {
            if player.lock().unwrap().on_ground {
                break;
            }
            next_frame().await;
        }
        println!("before wait");
        wait_seconds(1.0).await;
        println!("after wait");
        player.lock().unwrap().allow_movement = true;
    });
    let mut i = 10;
    loop {
        println!("{i}");
        if player2.lock().unwrap().allow_movement {
            break;
        }
        if i == 0 {
            player2.lock().unwrap().on_ground = true;
        }
        i -= 1;
        next_frame().await;
    }
    assert!(i < -1, "coroutine blocked main thread");
}

```

`tests/coroutine_pause.rs`:

```rs
use macroquad::{
    experimental::{
        coroutines::{start_coroutine, wait_seconds},
        scene,
    },
    window::next_frame,
};

#[macroquad::test]
async fn coroutine_execution_order() {
    start_coroutine(async move {
        println!("a");
        next_frame().await;
        println!("b");
    });
    println!("c");
    next_frame().await;
    println!("d");
    next_frame().await;
}

#[macroquad::test]
async fn coroutine_manual_poll() {
    struct Player {
        state: i32,
    }
    impl scene::Node for Player {}

    let player = scene::add_node(Player { state: 0 });

    let mut coroutine = start_coroutine(async move {
        loop {
            scene::get_node(player).state += 1;
            next_frame().await;
        }
    });

    // make sure that coroutine is not yet polled
    assert_eq!(scene::get_node(player).state, 0);

    coroutine.set_manual_poll();

    // still not polled
    assert_eq!(scene::get_node(player).state, 0);

    coroutine.poll(0.1);
    assert_eq!(scene::get_node(player).state, 1);

    next_frame().await;
    next_frame().await;

    // make sure that after main loop's next_frame coroutine was not polled
    assert_eq!(scene::get_node(player).state, 1);

    // and that we still can poll
    coroutine.poll(0.1);
    assert_eq!(scene::get_node(player).state, 2);
}

#[macroquad::test]
async fn coroutine_manual_poll_delay() {
    struct Player {
        state: i32,
    }
    impl scene::Node for Player {}

    let player = scene::add_node(Player { state: 0 });

    let mut coroutine = start_coroutine(async move {
        wait_seconds(1.).await;
        scene::get_node(player).state = 1;
    });

    coroutine.set_manual_poll();

    assert_eq!(scene::get_node(player).state, 0);

    // not 1 second yet, coroutine will have "now": 0.0, "delta": 0.9, (0.0 + 0.9) < 1.0
    coroutine.poll(0.9);

    assert_eq!(scene::get_node(player).state, 0);

    // coroutine will have "now": 0.1, delta: 0.11, (0.9 + 0.11) > 1.0, wait_for_seconds pass
    coroutine.poll(0.11);

    assert_eq!(scene::get_node(player).state, 1);
}

```

`tests/coroutine_values.rs`:

```rs
use macroquad::{experimental::coroutines::start_coroutine, telemetry, window::next_frame};

#[macroquad::test]
async fn coroutine_value() {
    let mut coroutine = start_coroutine(async move {
        next_frame().await;
        1
    });

    coroutine.set_manual_poll();

    assert_eq!(coroutine.retrieve(), None);

    coroutine.poll(0.0);
    coroutine.poll(0.0);

    assert_eq!(coroutine.retrieve(), Some(1));
}

#[macroquad::test]
async fn coroutine_memory() {
    use macroquad::prelude::*;

    for _ in 0..20 {
        start_coroutine(async move {
            next_frame().await;
        });

        next_frame().await;
    }

    // wait for the last one to finish
    next_frame().await;

    assert_eq!(telemetry::active_coroutines_count(), 0);
}

```

`tiled/Cargo.toml`:

```toml
[package]
name = "macroquad-tiled"
version = "0.2.1"
authors = ["Fedor Logachev <not.fl3@gmail.com>"]
edition = "2018"
license = "MIT/Apache-2.0"
description = """
Tiled editor macroquad intergration
"""

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
nanoserde = "0.1"
macroquad = { path = "../", version = "0.4.0" }

```

`tiled/src/error.rs`:

```rs
#[derive(Debug)]
pub enum Error {
    DeJsonErr {
        msg: String,
        line: usize,
        col: usize,
    },
    NonUniqueLayerName {
        layer: String,
    },
    TextureNotFound {
        texture: String,
    },
    LayerTypeNotFound {
        layer_type: String,
    },
}

impl From<nanoserde::DeJsonErr> for Error {
    fn from(error: nanoserde::DeJsonErr) -> Error {
        Error::DeJsonErr {
            msg: error.msg.clone(),
            line: error.line,
            col: error.col,
        }
    }
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::DeJsonErr { .. } | Error::TextureNotFound {..} => std::fmt::Debug::fmt(self, f),
            Error::NonUniqueLayerName { layer } => write!(
                f,
                "Layer name should be unique to load tiled level in macroquad, non-unique layer name: {}", layer
            ),
            Error::LayerTypeNotFound{layer_type} => write!(
                f,
                "{} type layer not found.", layer_type
            ),

        }
    }
}

impl std::error::Error for Error {}

```

`tiled/src/lib.rs`:

```rs
use nanoserde::DeJson;

use macroquad::prelude::*;

use std::collections::HashMap;

mod error;
mod tiled;

use core::f32::consts::PI;
pub use error::Error;
pub use tiled::{Property, PropertyVal};

#[derive(Debug, Clone)]
pub struct Object {
    /// If not null - the object is (probably) a tile
    pub gid: Option<u32>,

    pub world_x: f32,
    pub world_y: f32,
    pub world_w: f32,
    pub world_h: f32,

    pub tile_x: u32,
    pub tile_y: u32,
    pub tile_w: u32,
    pub tile_h: u32,

    pub name: String,

    pub properties: HashMap<String, String>,
}

/// Flip operation application order:
/// 1. flip diagonally
/// 2. flip horizontally
/// 3. flip vertically
#[derive(Debug)]
pub struct Tile {
    /// id in the tileset
    pub id: u32,
    /// Each tile belongs to one tileset
    pub tileset: String,
    /// "type" from tiled
    pub attrs: String,
    /// Whether the tile is horizontally flipped
    pub flip_x: bool,
    /// Whether the tile is vertically flipped
    pub flip_y: bool,
    /// Whether the tile is anti-diagonally flipped
    /// (equivalent to a 90 degree clockwise rotation followed by a horizontal flip)
    pub flip_d: bool,
}

#[derive(Debug, Default)]
pub struct Layer {
    pub objects: Vec<Object>,
    pub width: u32,
    pub height: u32,
    pub data: Vec<Option<Tile>>,
    /// imagelayer
    pub opacity: f32,
    pub image: Option<Texture2D>,
    pub offsetx: Option<f32>,
    pub offsety: Option<f32>,
}

#[derive(Debug)]
pub struct TileSet {
    pub texture: Texture2D,

    pub tilewidth: i32,
    pub tileheight: i32,
    pub columns: u32,
    pub spacing: i32,
    pub margin: i32,
}

impl TileSet {
    fn sprite_rect(&self, ix: u32) -> Rect {
        let sw = self.tilewidth as f32;
        let sh = self.tileheight as f32;
        let sx = (ix % self.columns) as f32 * (sw + self.spacing as f32) + self.margin as f32;
        let sy = (ix / self.columns) as f32 * (sh + self.spacing as f32) + self.margin as f32;

        // TODO: configure tiles margin
        Rect::new(sx + 1.1, sy + 1.1, sw - 2.2, sh - 2.2)
    }
}

#[derive(Debug)]
pub struct Map {
    pub layers: HashMap<String, Layer>,
    pub tilesets: HashMap<String, TileSet>,

    /// Deserialized json as is
    pub raw_tiled_map: tiled::Map,
}

pub struct TileFlippedParams {
    flip_x: bool,
    flip_y: bool,
    flip_d: bool,
}

impl Default for TileFlippedParams {
    fn default() -> Self {
        TileFlippedParams {
            flip_x: false,
            flip_y: false,
            flip_d: false,
        }
    }
}

impl Map {
    pub fn spr(&self, tileset: &str, sprite: u32, dest: Rect) {
        self.spr_flip(tileset, sprite, dest, TileFlippedParams::default())
    }

    pub fn spr_flip(&self, tileset: &str, sprite: u32, dest: Rect, flip: TileFlippedParams) {
        if self.tilesets.contains_key(tileset) == false {
            panic!(
                "No such tileset: {}, tilesets available: {:?}",
                tileset,
                self.tilesets.keys()
            )
        }
        let tileset = &self.tilesets[tileset];
        let spr_rect = tileset.sprite_rect(sprite);

        let rotation = if flip.flip_d {
            // diagonal flip
            -PI / 2.0
        } else {
            0.0
        };

        draw_texture_ex(
            &tileset.texture,
            dest.x,
            dest.y,
            WHITE,
            DrawTextureParams {
                dest_size: Some(vec2(dest.w, dest.h)),
                source: Some(Rect::new(
                    spr_rect.x - 1.0,
                    spr_rect.y - 1.0,
                    spr_rect.w + 2.0,
                    spr_rect.h + 2.0,
                )),
                flip_x: flip.flip_x,
                flip_y: flip.flip_y ^ flip.flip_d,
                rotation: rotation,
                ..Default::default()
            },
        );
    }

    pub fn spr_ex(&self, tileset: &str, source: Rect, dest: Rect) {
        let tileset = &self.tilesets[tileset];

        draw_texture_ex(
            &tileset.texture,
            dest.x,
            dest.y,
            WHITE,
            DrawTextureParams {
                dest_size: Some(vec2(dest.w, dest.h)),
                source: Some(source),
                ..Default::default()
            },
        );
    }

    pub fn contains_layer(&self, layer: &str) -> bool {
        self.layers.contains_key(layer)
    }

    pub fn draw_tiles(&self, layer: &str, dest: Rect, source: impl Into<Option<Rect>>) {
        assert!(self.layers.contains_key(layer), "No such layer: {}", layer);

        let source = source.into().unwrap_or(Rect::new(
            0.,
            0.,
            self.raw_tiled_map.width as f32,
            self.raw_tiled_map.height as f32,
        ));
        let layer = &self.layers[layer];

        let spr_width = dest.w / source.w;
        let spr_height = dest.h / source.h;

        let mut separated_by_ts: HashMap<&str, Vec<(&Tile, Rect)>> = HashMap::new();

        for y in source.y as u32..source.y as u32 + source.h as u32 {
            for x in source.x as u32..source.x as u32 + source.w as u32 {
                if let Some(tile) = &layer
                    .data
                    .get((y * layer.width + x) as usize)
                    .unwrap_or(&None)
                {
                    if !separated_by_ts.contains_key(tile.tileset.as_str()) {
                        separated_by_ts.insert(&tile.tileset, vec![]);
                    }

                    let pos = vec2(
                        (x - source.x as u32) as f32 / source.w * dest.w + dest.x,
                        (y - source.y as u32) as f32 / source.h * dest.h + dest.y,
                    );
                    separated_by_ts
                        .get_mut(tile.tileset.as_str())
                        .unwrap()
                        .push((&tile, Rect::new(pos.x, pos.y, spr_width, spr_height)));
                }
            }
        }

        for (tileset, tileset_layer) in &separated_by_ts {
            for (tile, rect) in tileset_layer {
                self.spr_flip(
                    tileset,
                    tile.id,
                    *rect,
                    TileFlippedParams {
                        flip_x: tile.flip_x,
                        flip_y: tile.flip_y,
                        flip_d: tile.flip_d,
                    },
                );
            }
        }
    }

    pub fn draw_imglayer(&self, layer: &str, dest: Rect, source: Option<Rect>) {
        assert!(self.layers.contains_key(layer), "No such layer: {}", layer);
        let layer = &self.layers[layer];
        assert!(layer.image.is_some(), "No texture found.");
        let img_texture = layer.image.clone().unwrap();
        let dest_width_frac =
            img_texture.width() / (self.raw_tiled_map.width * self.raw_tiled_map.tilewidth) as f32;
        let dest_height_frac =
            img_texture.height() / (self.raw_tiled_map.height * self.raw_tiled_map.height) as f32;

        let source = source.unwrap_or(Rect::new(0., 0., img_texture.width(), img_texture.height()));
        draw_texture_ex(
            &img_texture,
            (layer.offsetx.unwrap() - source.x) / source.w * dest.w + dest.x,
            (layer.offsety.unwrap() - source.y) / source.h * dest.h + dest.y,
            Color {
                r: 255.,
                g: 255.,
                b: 255.,
                a: layer.opacity,
            },
            DrawTextureParams {
                dest_size: Some(vec2(dest.w * dest_width_frac, dest.h * dest_height_frac)),
                source: Some(source),
                ..Default::default()
            },
        );
    }

    pub fn tiles(&self, layer: &str, rect: impl Into<Option<Rect>>) -> TilesIterator {
        assert!(self.layers.contains_key(layer), "No such layer: {}", layer);

        let rect = rect.into().unwrap_or(Rect::new(
            0.,
            0.,
            self.raw_tiled_map.width as f32,
            self.raw_tiled_map.height as f32,
        ));
        TilesIterator::new(&self.layers[layer], rect)
    }

    pub fn get_tile(&self, layer: &str, x: u32, y: u32) -> &Option<Tile> {
        assert!(self.layers.contains_key(layer), "No such layer: {}", layer);

        let layer = &self.layers[layer];

        if x >= layer.width || y >= layer.height {
            return &None;
        }

        &layer.data[(y * layer.width + x) as usize]
    }
}

pub struct TilesIterator<'a> {
    rect: Rect,
    current: (u32, u32),
    layer: &'a Layer,
}

impl<'a> TilesIterator<'a> {
    fn new(layer: &'a Layer, rect: Rect) -> Self {
        let current = (rect.x as u32, rect.y as u32);

        TilesIterator {
            layer,
            rect,
            current,
        }
    }
}

impl<'a> Iterator for TilesIterator<'a> {
    type Item = (u32, u32, &'a Option<Tile>);

    fn next(&mut self) -> Option<Self::Item> {
        let next_x;
        let next_y;

        if self.current.0 + 1 >= self.rect.x as u32 + self.rect.w as u32 {
            next_x = self.rect.x as u32;
            next_y = self.current.1 + 1;
        } else {
            next_x = self.current.0 + 1;
            next_y = self.current.1;
        }

        if next_y >= self.rect.y as u32 + self.rect.h as u32 {
            return None;
        }

        let res = Some((
            self.current.0,
            self.current.1,
            &self.layer.data[(self.current.1 * self.layer.width + self.current.0) as usize],
        ));
        self.current = (next_x, next_y);
        res
    }
}

/// Load Tiled tile map from given json string.
/// "data" is a tiled json content.
/// "textures" is a map from the name used in the json to macroquad texture.
/// "external_tilesets" is a map of tileset name to tileset json content.
/// "external_tilesets" is used when in tiled the "source" field is used instead of embedded tileset.
pub fn load_map(
    data: &str,
    textures: &[(&str, Texture2D)],
    external_tilesets: &[(&str, &str)],
) -> Result<Map, error::Error> {
    // Tiled reserves 4 high bits for flip flags
    const TILE_FLIP_FLAGS: u32 = 0b11110000000000000000000000000000;

    let map: tiled::Map = DeJson::deserialize_json(data)?;

    let mut layers = HashMap::new();
    let mut tilesets = HashMap::new();
    let mut map_tilesets = vec![];

    for tileset in &map.tilesets {
        let tileset = if tileset.source.is_empty() {
            tileset.clone()
        } else {
            let tileset_data = external_tilesets
                .iter()
                .find(|(name, _)| *name == &tileset.source)
                .unwrap();
            let mut map_tileset: tiled::Tileset = DeJson::deserialize_json(&tileset_data.1)?;
            map_tileset.firstgid = tileset.firstgid;
            map_tileset
        };

        let texture = &textures
            .iter()
            .find(|(name, _)| *name == tileset.image)
            .ok_or(error::Error::TextureNotFound {
                texture: tileset.image.clone(),
            })?
            .1;

        tilesets.insert(
            tileset.name.clone(),
            TileSet {
                texture: texture.clone(),
                columns: tileset.columns as _,
                margin: tileset.margin,
                spacing: tileset.spacing,
                tilewidth: tileset.tilewidth,
                tileheight: tileset.tileheight,
            },
        );

        map_tilesets.push(tileset);
    }

    for layer in &map.layers {
        if layers.contains_key(&layer.name) {
            return Err(error::Error::NonUniqueLayerName {
                layer: layer.name.clone(),
            });
        }

        let tile_width = map.tilewidth as f32;
        let tile_height = map.tileheight as f32;

        let mut objects = vec![];
        for object in &layer.objects {
            objects.push(Object {
                gid: object.gid,
                world_x: object.x,
                world_y: object.y,
                world_w: object.width,
                world_h: object.height,

                tile_x: (object.x / tile_width) as u32,
                tile_y: (object.y / tile_height) as u32,
                tile_w: (object.width / tile_width) as u32,
                tile_h: (object.height / tile_height) as u32,
                name: object.name.clone(),
                properties: object
                    .properties
                    .iter()
                    .map(|property| (property.name.to_string(), property.value.to_string()))
                    .collect(),
            });
        }

        let find_tileset = |tile: u32| {
            // Discard flip flags
            let tile = tile & !TILE_FLIP_FLAGS;
            map_tilesets.iter().find(|tileset| {
                tile >= tileset.firstgid && tile < tileset.firstgid + tileset.tilecount
            })
        };

        layers.insert(
            layer.name.clone(),
            match layer.ty.as_str() {
                "tilelayer" | "objectgroup" => Layer {
                    objects,
                    width: layer.width,
                    height: layer.height,
                    data: layer
                        .data
                        .iter()
                        .map(|tile| {
                            find_tileset(*tile).map(|tileset| {
                                let flip_flags = (*tile & TILE_FLIP_FLAGS) >> 28;
                                let tile = *tile & !TILE_FLIP_FLAGS;

                                let attrs = tileset
                                    .tiles
                                    .iter()
                                    .find(|t| t.id as u32 == tile - tileset.firstgid)
                                    .and_then(|tile| tile.ty.clone())
                                    .unwrap_or("".to_owned());

                                Tile {
                                    id: tile - tileset.firstgid,
                                    tileset: tileset.name.clone(),
                                    attrs,
                                    flip_x: (flip_flags & 0b1000) != 0,
                                    flip_y: (flip_flags & 0b0100) != 0,
                                    flip_d: (flip_flags & 0b0010) != 0,
                                }
                            })
                        })
                        .collect::<Vec<_>>(),
                    opacity: layer.opacity,
                    ..Default::default()
                },
                "imagelayer" => {
                    let img_name = layer.image.clone().unwrap();
                    if img_name == "" {
                        continue;
                    }
                    let offsetx = match layer.offsetx {
                        Some(x) => Some(x as f32),
                        None => Some(0f32),
                    };
                    let offsety = match layer.offsety {
                        Some(y) => Some(y as f32),
                        None => Some(0f32),
                    };
                    let img_texture = &textures
                        .iter()
                        .find(|(name, _)| *name == img_name)
                        .ok_or(error::Error::TextureNotFound { texture: img_name })?
                        .1;

                    Layer {
                        image: Some(img_texture.clone()),
                        opacity: layer.opacity,
                        offsetx,
                        offsety,
                        ..Default::default()
                    }
                }
                layer_type => {
                    return Err(error::Error::LayerTypeNotFound {
                        layer_type: layer_type.to_string(),
                    })
                }
            },
        );
    }

    // Some external tilesets could be resolved, so we
    // include the new "map_tilesets"
    Ok(Map {
        layers,
        tilesets,
        raw_tiled_map: tiled::Map {
            tilesets: map_tilesets,
            ..map
        },
    })
}

```

`tiled/src/tiled.rs`:

```rs
use layer::Layer;
use nanoserde::DeJson;

pub mod layer;

#[derive(Debug, Clone)]
pub enum PropertyVal {
    String(String),
    UInt(u64),
    Integer(i64),
    Float(f64),
    Boolean(bool),
}

impl Default for PropertyVal {
    fn default() -> Self {
        PropertyVal::Boolean(false)
    }
}

impl std::fmt::Display for PropertyVal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PropertyVal::String(x) => write!(f, "{}", x),
            PropertyVal::UInt(x) => write!(f, "{}", x),
            PropertyVal::Integer(x) => write!(f, "{}", x),
            PropertyVal::Float(x) => write!(f, "{}", x),
            PropertyVal::Boolean(x) => write!(f, "{}", x),
        }
    }
}

impl DeJson for PropertyVal {
    fn de_json(
        s: &mut nanoserde::DeJsonState,
        i: &mut std::str::Chars,
    ) -> Result<Self, nanoserde::DeJsonErr> {
        use nanoserde::DeJsonTok;

        let v = match s.tok {
            DeJsonTok::Bool(b) => PropertyVal::Boolean(b),
            DeJsonTok::U64(x) => PropertyVal::UInt(x),
            DeJsonTok::I64(x) => PropertyVal::Integer(x),
            DeJsonTok::F64(x) => PropertyVal::Float(x),
            DeJsonTok::Str => PropertyVal::String(core::mem::replace(&mut s.strbuf, String::new())),
            _ => {
                return Err(s.err_token(
                    "Incorrect property value. Must be either string, number or boolean",
                ))
            }
        };

        s.next_tok(i)?;

        Ok(v)
    }
}

/// https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tmx-grid
#[derive(Clone, Debug, Default, DeJson)]
pub struct Grid {
    pub width: i32,
    pub height: i32,
}

#[derive(Clone, Debug, Default, DeJson)]
pub struct Property {
    pub name: String,
    pub value: PropertyVal,
    #[nserde(rename = "type")]
    pub ty: String,
}

/// https://doc.mapeditor.org/en/stable/reference/json-map-format/#json-frame
#[derive(Clone, Debug, Default, DeJson)]
pub struct Frame {
    pub duration: i32,
    pub tileid: i32,
}

/// https://doc.mapeditor.org/en/stable/reference/json-map-format/#json-tile
#[derive(Clone, Debug, Default, DeJson)]
#[nserde(default)]
pub struct Tile {
    /// Array of Frames
    pub animation: Vec<Frame>,
    /// Local ID of the tile
    pub id: usize,
    /// Image representing this tile (optional)
    pub image: Option<String>,
    /// Height of the tile image in pixels
    pub imagewidth: i32,
    /// Width of the tile image in pixels
    pub imageheight: i32,
    /// Layer with type objectgroup (optional)
    pub objectgroup: Option<Layer>,
    /// A list of properties (name, value, type)
    pub properties: Vec<Property>,
    /// Index of terrain for each corner of tile
    pub terrain: Vec<i32>,
    /// The type of the tile (optional)
    #[nserde(rename = "type")]
    pub ty: Option<String>,
}

/// https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tmx-tileoffset
#[derive(Clone, Debug, Default, DeJson)]
pub struct Tileoffset {
    pub x: i32,
    pub y: i32,
}

/// https://doc.mapeditor.org/en/stable/reference/json-map-format/#json-terrain
#[derive(Clone, Debug, Default, DeJson)]
pub struct Terrain {
    pub name: String,
    pub tile: i32,
}

/// https://doc.mapeditor.org/en/stable/reference/json-map-format/#tileset
#[derive(Clone, Debug, Default, DeJson)]
#[nserde(default)]
pub struct Tileset {
    /// The number of tile columns in the tileset
    pub columns: i32,
    /// GID corresponding to the first tile in the set
    pub firstgid: u32,
    /// See <grid> (optional)
    pub grid: Option<Grid>,
    /// Image used for tiles in this set
    pub image: String,
    /// Width of source image in pixels
    pub imagewidth: i32,
    /// Height of source image in pixels
    pub imageheight: i32,
    /// Buffer between image edge and first tile (pixels)
    pub margin: i32,
    /// Name given to this tileset
    pub name: String,
    /// A list of properties (name, value, type).
    pub properties: Vec<Property>,
    /// Spacing between adjacent tiles in image (pixels)
    pub spacing: i32,
    /// Array of Terrains (optional)
    pub terrains: Option<Vec<Terrain>>,
    /// The number of tiles in this tileset
    pub tilecount: u32,
    /// Maximum height of tiles in this set
    pub tileheight: i32,
    /// See <tileoffset> (optional)
    pub tileoffset: Option<Tileoffset>,
    /// Array of Tiles (optional)
    #[nserde(default)]
    pub tiles: Vec<Tile>,
    /// Maximum width of tiles in this set
    pub tilewidth: i32,
    /// Hex-formatted color (#RRGGBB) (optional)
    pub transparentcolor: Option<String>,
    /// The external file that contains this tilesets data
    pub source: String,
}

/// https://doc.mapeditor.org/en/stable/reference/json-map-format/#map
#[derive(Clone, Debug, Default, DeJson)]
#[nserde(default)]
pub struct Map {
    /// Hex-formatted color (#RRGGBB or #AARRGGBB) (optional)
    pub backgroundcolor: String,
    /// Number of tile rows
    pub height: u32,

    pub properties: Vec<Property>,

    pub orientation: String,
    pub renderorder: String,

    pub tileheight: u32,
    pub tilewidth: u32,

    pub layers: Vec<layer::Layer>,
    pub tilesets: Vec<Tileset>,

    /// The JSON format version
    pub version: String,
    /// Number of tile columns
    pub width: u32,

    #[nserde(rename = "type")]
    pub ty: String,
}

```

`tiled/src/tiled/layer.rs`:

```rs
use super::Property;
use nanoserde::DeJson;

/// https://doc.mapeditor.org/en/stable/reference/json-map-format/#json-chunk
#[derive(Clone, Debug, Default, DeJson)]
#[nserde(default)]
pub struct Chunk {
    /// Array of unsigned int (GIDs) or base64-encoded data
    pub data: Vec<u32>,
    /// Height in tiles
    pub height: usize,
    /// Width in tiles
    pub width: usize,
    /// X coordinate in tiles
    pub x: i32,
    /// Y coordinate in tiles
    pub y: i32,
}

/// https://doc.mapeditor.org/en/stable/reference/json-map-format/#json-layer
#[derive(Clone, Debug, Default, DeJson)]
#[nserde(default)]
pub struct Layer {
    /// Array of chunks (optional). tilelayer only.
    pub chunks: Option<Vec<Chunk>>,
    pub name: String,
    pub opacity: f32,
    pub properties: Vec<Property>,
    pub visible: bool,
    pub width: u32,
    pub height: u32,
    #[nserde(rename = "type")]
    pub ty: String,

    /// for type = "tilelayer"
    pub data: Vec<u32>,

    /// for type = "objectlayer"
    pub draworder: Option<String>,
    #[nserde(default)]
    pub objects: Vec<Object>,
    /// Horizontal layer offset in pixels (default: 0)
    pub offsetx: Option<i32>,
    /// Vertical layer offset in pixels (default: 0)
    pub offsety: Option<i32>,
    /// Horizontal layer offset in tiles. Always 0.
    pub x: Option<f32>,
    /// Vertical layer offset in tiles. Always 0.
    pub y: Option<f32>,

    /// for type = "imagelayer"
    pub image: Option<String>,
}

#[derive(Clone, Debug, Default, DeJson)]
#[nserde(default)]
pub struct Object {
    pub id: u32,
    pub name: String,

    #[nserde(rename = "type")]
    pub ty: String,
    pub gid: Option<u32>,
    pub ellipse: Option<bool>,
    pub polygon: Option<Vec<PolyPoint>>,

    pub properties: Vec<Property>,
    pub rotation: f32,
    pub visible: bool,

    pub height: f32,
    pub width: f32,

    pub x: f32,
    pub y: f32,
}

#[derive(Copy, Clone, Debug, DeJson)]
pub struct PolyPoint {
    pub x: f32,
    pub y: f32,
}

```