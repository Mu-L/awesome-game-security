Project Path: arc_ssmugabi_IDAPlugins_isfplsox

Source Tree:

```txt
arc_ssmugabi_IDAPlugins_isfplsox
â”œâ”€â”€ D810.py
â”œâ”€â”€ LazyIDA.py
â”œâ”€â”€ README.md
â”œâ”€â”€ Sinological
â”‚   â””â”€â”€ IDAPlugins.zip
â”œâ”€â”€ d810
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ ast.py
â”‚   â”œâ”€â”€ cfg_utils.py
â”‚   â”œâ”€â”€ conf
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ default_instruction_only.json
â”‚   â”‚   â”œâ”€â”€ default_unflattening_ollvm.json
â”‚   â”‚   â”œâ”€â”€ default_unflattening_switch_case.json
â”‚   â”‚   â”œâ”€â”€ example_anel.json
â”‚   â”‚   â”œâ”€â”€ example_libobfuscated.json
â”‚   â”‚   â””â”€â”€ options.json
â”‚   â”œâ”€â”€ docs
â”‚   â”‚   â””â”€â”€ source
â”‚   â”‚       â””â”€â”€ images
â”‚   â”‚           â””â”€â”€ gui_plugin_configuration.png
â”‚   â”œâ”€â”€ emulator.py
â”‚   â”œâ”€â”€ errors.py
â”‚   â”œâ”€â”€ hexrays_formatters.py
â”‚   â”œâ”€â”€ hexrays_helpers.py
â”‚   â”œâ”€â”€ hexrays_hooks.py
â”‚   â”œâ”€â”€ ida_ui.py
â”‚   â”œâ”€â”€ log.ini
â”‚   â”œâ”€â”€ log.py
â”‚   â”œâ”€â”€ manager.py
â”‚   â”œâ”€â”€ manager_info.json
â”‚   â”œâ”€â”€ optimizers
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ flow
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ flattening
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ fix_pred_cond_jump_block.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ generic.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ unflattener.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ unflattener_fake_jump.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ unflattener_indirect.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ unflattener_switch_case.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ utils.py
â”‚   â”‚   â”‚   â”œâ”€â”€ handler.py
â”‚   â”‚   â”‚   â””â”€â”€ jumps
â”‚   â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚       â”œâ”€â”€ handler.py
â”‚   â”‚   â”‚       â”œâ”€â”€ opaque.py
â”‚   â”‚   â”‚       â””â”€â”€ tricks.py
â”‚   â”‚   â”œâ”€â”€ handler.py
â”‚   â”‚   â””â”€â”€ instructions
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ analysis
â”‚   â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚       â”‚   â”œâ”€â”€ handler.py
â”‚   â”‚       â”‚   â”œâ”€â”€ pattern_guess.py
â”‚   â”‚       â”‚   â””â”€â”€ utils.py
â”‚   â”‚       â”œâ”€â”€ chain
â”‚   â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚       â”‚   â”œâ”€â”€ chain_rules.py
â”‚   â”‚       â”‚   â””â”€â”€ handler.py
â”‚   â”‚       â”œâ”€â”€ early
â”‚   â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚       â”‚   â”œâ”€â”€ handler.py
â”‚   â”‚       â”‚   â””â”€â”€ mem_read.py
â”‚   â”‚       â”œâ”€â”€ handler.py
â”‚   â”‚       â”œâ”€â”€ pattern_matching
â”‚   â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚       â”‚   â”œâ”€â”€ experimental.py
â”‚   â”‚       â”‚   â”œâ”€â”€ handler.py
â”‚   â”‚       â”‚   â”œâ”€â”€ rewrite_add.py
â”‚   â”‚       â”‚   â”œâ”€â”€ rewrite_and.py
â”‚   â”‚       â”‚   â”œâ”€â”€ rewrite_bnot.py
â”‚   â”‚       â”‚   â”œâ”€â”€ rewrite_cst.py
â”‚   â”‚       â”‚   â”œâ”€â”€ rewrite_mov.py
â”‚   â”‚       â”‚   â”œâ”€â”€ rewrite_mul.py
â”‚   â”‚       â”‚   â”œâ”€â”€ rewrite_neg.py
â”‚   â”‚       â”‚   â”œâ”€â”€ rewrite_or.py
â”‚   â”‚       â”‚   â”œâ”€â”€ rewrite_predicates.py
â”‚   â”‚       â”‚   â”œâ”€â”€ rewrite_sub.py
â”‚   â”‚       â”‚   â”œâ”€â”€ rewrite_xor.py
â”‚   â”‚       â”‚   â””â”€â”€ weird.py
â”‚   â”‚       â””â”€â”€ z3
â”‚   â”‚           â”œâ”€â”€ __init__.py
â”‚   â”‚           â”œâ”€â”€ cst.py
â”‚   â”‚           â”œâ”€â”€ handler.py
â”‚   â”‚           â””â”€â”€ predicates.py
â”‚   â”œâ”€â”€ tracker.py
â”‚   â”œâ”€â”€ utils.py
â”‚   â””â”€â”€ z3_utils.py
â”œâ”€â”€ diaphora
â”œâ”€â”€ diaphora_plugin.cfg
â”œâ”€â”€ diaphora_plugin.py
â”œâ”€â”€ findcrypt3.py
â”œâ”€â”€ findcrypt3.rules
â”œâ”€â”€ mcp-plugin.py
â”œâ”€â”€ patching
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ actions.py
â”‚   â”œâ”€â”€ asm.py
â”‚   â”œâ”€â”€ core.py
â”‚   â”œâ”€â”€ exceptions.py
â”‚   â”œâ”€â”€ ui
â”‚   â”‚   â”œâ”€â”€ preview.py
â”‚   â”‚   â”œâ”€â”€ preview_ui.py
â”‚   â”‚   â”œâ”€â”€ resources
â”‚   â”‚   â”‚   â”œâ”€â”€ assemble.png
â”‚   â”‚   â”‚   â”œâ”€â”€ forcejump.png
â”‚   â”‚   â”‚   â”œâ”€â”€ nop.png
â”‚   â”‚   â”‚   â”œâ”€â”€ revert.png
â”‚   â”‚   â”‚   â””â”€â”€ save.png
â”‚   â”‚   â”œâ”€â”€ save.py
â”‚   â”‚   â””â”€â”€ save_ui.py
â”‚   â””â”€â”€ util
â”‚       â”œâ”€â”€ IDA_Plugins_3.6.zip
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ ida.py
â”‚       â”œâ”€â”€ misc.py
â”‚       â”œâ”€â”€ python.py
â”‚       â””â”€â”€ qt.py
â”œâ”€â”€ patching.py
â”œâ”€â”€ readme.txt
â””â”€â”€ requirements.txt

```

`D810.py`:

```py
import os
import idaapi
import ida_hexrays
import ida_kernwin


from d810.conf import D810Configuration
from d810.manager import D810State, D810_LOG_DIR_NAME
from d810.log import configure_loggers, clear_logs


D810_VERSION = "0.1"

class D810Plugin(idaapi.plugin_t):
    # variables required by IDA
    flags = 0  # normal plugin
    wanted_name = "D-810"
    wanted_hotkey = "Ctrl-Shift-D"
    comment = "Interface to the D-810 plugin"
    help = ""
    initialized = False

    def __init__(self):
        super(D810Plugin, self).__init__()
        self.d810_config = None
        self.state = None
        self.initialized = False


    def reload_plugin(self):
        if self.initialized:
            self.term()

        self.d810_config = D810Configuration()

        #TO-DO: if [...].get raises an exception because log_dir is not found, handle exception
        real_log_dir = os.path.join(self.d810_config.get("log_dir"), D810_LOG_DIR_NAME)

        #TO-DO: if [...].get raises an exception because erase_logs_on_reload is not found, handle exception
        if self.d810_config.get("erase_logs_on_reload"):
            clear_logs(real_log_dir)

        configure_loggers(real_log_dir)
        self.state = D810State(self.d810_config)
        print("D-810 reloading...")
        self.state.start_plugin()
        self.initialized = True


    # IDA API methods: init, run, term
    def init(self):
        if not ida_hexrays.init_hexrays_plugin():
            print("D-810 need Hex-Rays decompiler. Skipping")
            return idaapi.PLUGIN_SKIP

        kv = ida_kernwin.get_kernel_version().split(".")
        if (int(kv[0]) < 7) or ((int(kv[0]) == 7) and (int(kv[1]) < 5)):
            print("D-810 need IDA version >= 7.5. Skipping")
            return idaapi.PLUGIN_SKIP
        print("D-810 initialized (version {0})".format(D810_VERSION))
        return idaapi.PLUGIN_OK


    def run(self, args):
        self.reload_plugin()


    def term(self):
        print("Terminating D-810...")
        if self.state is not None:
            self.state.stop_plugin()

        self.initialized = False


def PLUGIN_ENTRY():
    return D810Plugin()

```

`LazyIDA.py`:

```py
from __future__ import division
from __future__ import print_function
from struct import unpack

# this plugin requires IDA 7.4 or newer
try:
    import idaapi
    import idautils
    import idc
    import ida_pro
    SUPPORTED_IDA = ida_pro.IDA_SDK_VERSION >= 740

    if ida_pro.IDA_SDK_VERSION >= 920:
        from PySide6.QtWidgets import QApplication
    else:
        from PyQt5.Qt import QApplication
except Exception as e:
    print(e)
    SUPPORTED_IDA = False

# is this deemed to be a compatible environment for the plugin to load?
if not SUPPORTED_IDA:
    print("LazyIDA plugin is not compatible with this IDA version")

ACTION_CONVERT = ["lazyida:convert%d" % i for i in range(10)]
ACTION_COPYEA = "lazyida:copyea"
ACTION_COPYFO = "lazyida:copyfo"
ACTION_GOTOCLIPEA = "lazyida:gotoclipea"
ACTION_GOTOCLIPFO = "lazyida:gotoclipfo"
ACTION_XORDATA = "lazyida:xordata"

ACTION_HX_REMOVERETTYPE = "lazyida:hx_removerettype"
ACTION_HX_COPYEA = "lazyida:hx_copyea"
ACTION_HX_COPYFO = "lazyida:hx_copyfo"
ACTION_HX_COPYNAME = "lazyida:hx_copyname"
ACTION_HX_GOTOCLIPEA = "lazyida:hx_gotoclipea"
ACTION_HX_GOTOCLIPFO = "lazyida:hx_gotoclipfo"

u16 = lambda x: unpack("<H", x)[0]
u32 = lambda x: unpack("<I", x)[0]
u64 = lambda x: unpack("<Q", x)[0]

ARCH = 0
BITS = 0

def copy_to_clip(data):
    QApplication.clipboard().setText(data)

def clip_text():
    return QApplication.clipboard().text()
    

def parse_location(loc, is_fo=False):
    is_named = False
    ascii_text = ""
    try:
        loc = int(loc, 16)
        if is_fo:
            loc = idaapi.get_fileregion_ea(loc)
    except ValueError:
        try:
            ascii_text = loc.encode(encoding="ascii",errors="replace").decode(encoding="ascii").strip()
            loc = idc.get_name_ea_simple(ascii_text)
            is_named = True
        except:
            return idaapi.BADADDR
    return loc, is_named, ascii_text


class hotkey_action_handler_t(idaapi.action_handler_t):
    """
    Action handler for hotkey actions
    """
    def __init__(self, action):
        idaapi.action_handler_t.__init__(self)
        self.action = action

    def activate(self, ctx):
        if self.action == ACTION_COPYEA:
            ea = idc.get_screen_ea()
            if ea != idaapi.BADADDR:
                copy_to_clip("0x%X" % ea)
                print("Address 0x%X (EA) has been copied to clipboard" % ea)
        elif self.action == ACTION_COPYFO:
            ea = idc.get_screen_ea()
            if ea != idaapi.BADADDR:
                fo = idaapi.get_fileregion_offset(ea)
                if fo != idaapi.BADADDR:
                    copy_to_clip("0x%X" % fo)
                    print("Address 0x%X (FO) has been copied to clipboard" % fo)
        elif self.action == ACTION_GOTOCLIPEA:
            loc, is_named, name = parse_location(clip_text(), False)
            if loc != idaapi.BADADDR:
                if is_named:
                    print("Goto named location '%s' 0x%X" % (name, loc))
                else:
                    print("Goto location 0x%X (EA)" % loc)
                idc.jumpto(loc)
        elif self.action == ACTION_GOTOCLIPFO:
            loc, is_named, name = parse_location(clip_text(), True)
            if loc != idaapi.BADADDR:
                if is_named:
                    print("Goto named location '%s' 0x%X" % (name, loc))
                else:
                    print("Goto location 0x%X (FO)" % idaapi.get_fileregion_offset(loc))
                idc.jumpto(loc)
        return 1

    def update(self, ctx):
        if idaapi.IDA_SDK_VERSION >= 770:
            target_attr = "widget_type"
        else:
            target_attr = "form_type"

        if idaapi.IDA_SDK_VERSION >= 900:
            try:
                dump_type = idaapi.BWN_HEXVIEW
            except:
                dump_type = idaapi.BWN_DUMP
        else:
            dump_type = idaapi.BWN_DUMP

        if ctx.__getattribute__(target_attr) in (idaapi.BWN_DISASM, dump_type):
            return idaapi.AST_ENABLE_FOR_WIDGET
        else:
            return idaapi.AST_DISABLE_FOR_WIDGET

class menu_action_handler_t(idaapi.action_handler_t):
    """
    Action handler for menu actions
    """
    def __init__(self, action):
        idaapi.action_handler_t.__init__(self)
        self.action = action

    def activate(self, ctx):
        if self.action in ACTION_CONVERT:
            # convert (dump as)
            t0, t1, view = idaapi.twinpos_t(), idaapi.twinpos_t(), idaapi.get_current_viewer()
            if idaapi.read_selection(view, t0, t1):
                start, end = t0.place(view).toea(), t1.place(view).toea()
                size = end - start + 1
            elif idc.get_item_size(idc.get_screen_ea()) > 1:
                start = idc.get_screen_ea()
                size = idc.get_item_size(start)
                end = start + size
            else:
                return False

            data = idc.get_bytes(start, size)
            if isinstance(data, str):  # python2 compatibility
                data = bytearray(data)
            name = idc.get_name(start, idc.GN_VISIBLE)
            if not name:
                name = "data"
            if data:
                print("\n[+] Dump 0x%X - 0x%X (%u bytes) :" % (start, end, size))
                if self.action == ACTION_CONVERT[0]:
                    # escaped string
                    output = '"%s"' % "".join("\\x%02X" % b for b in data)
                elif self.action == ACTION_CONVERT[1]:
                    # hex string
                    output = "".join("%02X" % b for b in data)
                elif self.action == ACTION_CONVERT[2]:
                    # C array
                    output = "unsigned char %s[%d] = {" % (name, size)
                    for i in range(size):
                        if i % 16 == 0:
                            output += "\n    "
                        output += "0x%02X, " % data[i]
                    output = output[:-2] + "\n};"
                elif self.action == ACTION_CONVERT[3]:
                    # C array word
                    data += b"\x00"
                    array_size = (size + 1) // 2
                    output = "unsigned short %s[%d] = {" % (name, array_size)
                    for i in range(0, size, 2):
                        if i % 16 == 0:
                            output += "\n    "
                        output += "0x%04X, " % u16(data[i:i+2])
                    output = output[:-2] + "\n};"
                elif self.action == ACTION_CONVERT[4]:
                    # C array dword
                    data += b"\x00" * 3
                    array_size = (size + 3) // 4
                    output = "unsigned int %s[%d] = {" % (name, array_size)
                    for i in range(0, size, 4):
                        if i % 32 == 0:
                            output += "\n    "
                        output += "0x%08X, " % u32(data[i:i+4])
                    output = output[:-2] + "\n};"
                elif self.action == ACTION_CONVERT[5]:
                    # C array qword
                    data += b"\x00" * 7
                    array_size = (size + 7) // 8
                    output = "unsigned long %s[%d] = {" % (name, array_size)
                    for i in range(0, size, 8):
                        if i % 32 == 0:
                            output += "\n    "
                        output += "0x%016X, " % u64(data[i:i+8])
                    output = output[:-2] + "\n};"
                elif self.action == ACTION_CONVERT[6]:
                    # python list
                    output = "[%s]" % ", ".join("0x%02X" % b for b in data)
                elif self.action == ACTION_CONVERT[7]:
                    # python list word
                    data += b"\x00"
                    output = "[%s]" % ", ".join("0x%04X" % u16(data[i:i+2]) for i in range(0, size, 2))
                elif self.action == ACTION_CONVERT[8]:
                    # python list dword
                    data += b"\x00" * 3
                    output = "[%s]" % ", ".join("0x%08X" % u32(data[i:i+4]) for i in range(0, size, 4))
                elif self.action == ACTION_CONVERT[9]:
                    # python list qword
                    data += b"\x00" * 7
                    output = "[%s]" %  ", ".join("%#018X" % u64(data[i:i+8]) for i in range(0, size, 8)).replace("0X", "0x")
                copy_to_clip(output)
                print(output)
        elif self.action == ACTION_XORDATA:
            t0, t1, view = idaapi.twinpos_t(), idaapi.twinpos_t(), idaapi.get_current_viewer()
            if idaapi.read_selection(view, t0, t1):
                start, end = t0.place(view).toea(), t1.place(view).toea()
            else:
                if idc.get_item_size(idc.get_screen_ea()) > 1:
                    start = idc.get_screen_ea()
                    end = start + idc.get_item_size(start)
                else:
                    return False

            data = idc.get_bytes(start, end - start)
            if isinstance(data, str):  # python2 compatibility
                data = bytearray(data)
            x = idaapi.ask_long(0, "Xor with...")
            if x:
                x &= 0xFF
                print("\n[+] Xor 0x%X - 0x%X (%u bytes) with 0x%02X:" % (start, end, end - start, x))
                print(repr("".join(chr(b ^ x) for b in data)))
        else:
            return 0

        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

class hexrays_action_handler_t(idaapi.action_handler_t):
    """
    Action handler for hexrays actions
    """
    def __init__(self, action):
        idaapi.action_handler_t.__init__(self)
        self.action = action
        self.ret_type = {}

    def activate(self, ctx):
        if self.action == ACTION_HX_REMOVERETTYPE:
            vdui = idaapi.get_widget_vdui(ctx.widget)
            self.remove_rettype(vdui)
            vdui.refresh_ctext()
        elif self.action == ACTION_HX_COPYEA:
            ea = idaapi.get_screen_ea()
            if ea != idaapi.BADADDR:
                copy_to_clip("0x%X" % ea)
                print("Address 0x%X (EA) has been copied to clipboard" % ea)
        elif self.action == ACTION_HX_COPYFO:
            ea = idaapi.get_screen_ea()
            if ea != idaapi.BADADDR:
                fo = idaapi.get_fileregion_offset(ea)
                if fo != idaapi.BADADDR:
                    copy_to_clip("0x%X" % fo)
                    print("Address 0x%X (FO) has been copied to clipboard" % fo)
        elif self.action == ACTION_HX_COPYNAME:
            highlight = idaapi.get_highlight(idaapi.get_current_viewer())
            name = highlight[0] if highlight else None
            if name:
                copy_to_clip(name)
                print("'%s' has been copied to clipboard" % name)
        elif self.action == ACTION_HX_GOTOCLIPEA:
            loc, is_named, name = parse_location(clip_text(), False)
            if loc != idaapi.BADADDR:
                if is_named:
                    print("Goto named location '%s' 0x%X" % (name, loc))
                else:
                    print("Goto location 0x%X (EA)" % loc)
                idc.jumpto(loc)
        elif self.action == ACTION_HX_GOTOCLIPFO:
            loc, is_named, name = parse_location(clip_text(), True)
            if loc != idaapi.BADADDR:
                if is_named:
                    print("Goto named location '%s' 0x%X" % (name, loc))
                else:
                    print("Goto location 0x%X (FO)" % idaapi.get_fileregion_offset(loc))
                idc.jumpto(loc)
        else:
            return 0

        return 1

    def update(self, ctx):
        vdui = idaapi.get_widget_vdui(ctx.widget)
        return idaapi.AST_ENABLE_FOR_WIDGET if vdui else idaapi.AST_DISABLE_FOR_WIDGET

    def remove_rettype(self, vu):
        if vu.item.citype == idaapi.VDI_FUNC:
            # current function
            ea = vu.cfunc.entry_ea
            old_func_type = idaapi.tinfo_t()
            if not vu.cfunc.get_func_type(old_func_type):
                return False
        elif vu.item.citype == idaapi.VDI_EXPR and vu.item.e.is_expr() and vu.item.e.type.is_funcptr():
            # call xxx
            ea = vu.item.get_ea()
            old_func_type = idaapi.tinfo_t()

            func = idaapi.get_func(ea)
            if func:
                try:
                    cfunc = idaapi.decompile(func)
                except idaapi.DecompilationFailure:
                    return False

                if not cfunc.get_func_type(old_func_type):
                    return False
            else:
                return False
        else:
            return False

        fi = idaapi.func_type_data_t()
        if ea != idaapi.BADADDR and old_func_type.get_func_details(fi):
            # Return type is already void
            if fi.rettype.is_decl_void():
                # Restore ret type
                if ea not in self.ret_type:
                    return True
                ret = self.ret_type[ea]
            else:
                # Save ret type and change it to void
                self.ret_type[ea] = fi.rettype
                ret = idaapi.BT_VOID

            # Create new function info with new rettype
            fi.rettype = idaapi.tinfo_t(ret)

            # Create new function type with function info
            new_func_type = idaapi.tinfo_t()
            new_func_type.create_func(fi)

            # Apply new function type
            if idaapi.apply_tinfo(ea, new_func_type, idaapi.TINFO_DEFINITE):
                return vu.refresh_view(True)

        return False

class UI_Hook(idaapi.UI_Hooks):
    def __init__(self):
        idaapi.UI_Hooks.__init__(self)

    def finish_populating_widget_popup(self, form, popup):
        form_type = idaapi.get_widget_type(form)

        if idaapi.IDA_SDK_VERSION >= 900:
            try:
                dump_type = idaapi.BWN_HEXVIEW
            except:
                dump_type = idaapi.BWN_DUMP
        else:
            dump_type = idaapi.BWN_DUMP

        if form_type == idaapi.BWN_DISASM or form_type == dump_type:
            t0, t1, view = idaapi.twinpos_t(), idaapi.twinpos_t(), idaapi.get_current_viewer()
            if idaapi.read_selection(view, t0, t1) or idc.get_item_size(idc.get_screen_ea()) > 1:
                idaapi.attach_action_to_popup(form, popup, ACTION_XORDATA, None)
                for action in ACTION_CONVERT:
                    idaapi.attach_action_to_popup(form, popup, action, "Dump/")



class HexRays_Hook(object):
    def callback(self, event, *args):
        if event == idaapi.hxe_populating_popup:
            form, phandle, vu = args
            if vu.item.citype == idaapi.VDI_FUNC or (vu.item.citype == idaapi.VDI_EXPR and vu.item.e.is_expr() and vu.item.e.type.is_funcptr()):
                idaapi.attach_action_to_popup(form, phandle, ACTION_HX_REMOVERETTYPE, None)
        elif event == idaapi.hxe_double_click:
            vu, shift_state = args
            # auto jump to target if clicked item is xxx->func();
            if vu.item.citype == idaapi.VDI_EXPR and vu.item.e.is_expr():
                expr = idaapi.tag_remove(vu.item.e.print1(None))
                if "->" in expr:
                    # find target function
                    name = expr.split("->")[-1]
                    addr = idc.get_name_ea_simple(name)
                    if addr == idaapi.BADADDR:
                        # try class::function
                        e = vu.item.e
                        while e.x:
                            e = e.x
                        addr = idc.get_name_ea_simple("%s::%s" % (str(e.type).split()[0], name))

                    if addr != idaapi.BADADDR:
                        idc.jumpto(addr)
                        return 1
        return 0

class LazyIDA_t(idaapi.plugin_t):
    flags = idaapi.PLUGIN_HIDE
    comment = "LazyIDA"
    help = ""
    wanted_name = "LazyIDA"
    wanted_hotkey = ""

    def init(self):
        self.hexrays_inited = False
        self.registered_actions = []
        self.registered_hx_actions = []

        global ARCH
        global BITS
        ARCH = idaapi.ph_get_id()

        if idaapi.IDA_SDK_VERSION >= 900:
            if idaapi.inf_is_64bit():
                BITS = 64
            elif idaapi.inf_is_32bit_exactly():
                BITS = 32
            elif idaapi.inf_is_16bit():
                BITS = 16
            else:
                raise ValueError
        else:
            info = idaapi.get_inf_structure()
            if info.is_64bit():
                BITS = 64
            elif info.is_32bit():
                BITS = 32
            else:
                BITS = 16

        print("LazyIDA (v1.1.0.0) plugin has been loaded.")

        # Register menu actions
        menu_actions = (
            idaapi.action_desc_t(ACTION_CONVERT[0], "Dump as string", menu_action_handler_t(ACTION_CONVERT[0]), None, None, 80),
            idaapi.action_desc_t(ACTION_CONVERT[1], "Dump as hex string", menu_action_handler_t(ACTION_CONVERT[1]), None, None, 8),
            idaapi.action_desc_t(ACTION_CONVERT[2], "Dump as C/C++ array (BYTE)", menu_action_handler_t(ACTION_CONVERT[2]), None, None, 38),
            idaapi.action_desc_t(ACTION_CONVERT[3], "Dump as C/C++ array (WORD)", menu_action_handler_t(ACTION_CONVERT[3]), None, None, 38),
            idaapi.action_desc_t(ACTION_CONVERT[4], "Dump as C/C++ array (DWORD)", menu_action_handler_t(ACTION_CONVERT[4]), None, None, 38),
            idaapi.action_desc_t(ACTION_CONVERT[5], "Dump as C/C++ array (QWORD)", menu_action_handler_t(ACTION_CONVERT[5]), None, None, 38),
            idaapi.action_desc_t(ACTION_CONVERT[6], "Dump as python list (BYTE)", menu_action_handler_t(ACTION_CONVERT[6]), None, None, 201),
            idaapi.action_desc_t(ACTION_CONVERT[7], "Dump as python list (WORD)", menu_action_handler_t(ACTION_CONVERT[7]), None, None, 201),
            idaapi.action_desc_t(ACTION_CONVERT[8], "Dump as python list (DWORD)", menu_action_handler_t(ACTION_CONVERT[8]), None, None, 201),
            idaapi.action_desc_t(ACTION_CONVERT[9], "Dump as python list (QWORD)", menu_action_handler_t(ACTION_CONVERT[9]), None, None, 201),
            idaapi.action_desc_t(ACTION_XORDATA, "Get xored data", menu_action_handler_t(ACTION_XORDATA), None, None, 9),
        )
        for action in menu_actions:
            idaapi.register_action(action)
            self.registered_actions.append(action.name)

        # Register hotkey actions
        hotkey_actions = (
            idaapi.action_desc_t(ACTION_COPYEA, "Copy EA", hotkey_action_handler_t(ACTION_COPYEA), "w", "Copy current EA", 0),
            idaapi.action_desc_t(ACTION_COPYFO, "Copy FO", hotkey_action_handler_t(ACTION_COPYFO), "Shift-W", "Copy current FO", 0),
            idaapi.action_desc_t(ACTION_GOTOCLIPEA, "Goto clipboard EA", hotkey_action_handler_t(ACTION_GOTOCLIPEA), "Shift-G"),
            idaapi.action_desc_t(ACTION_GOTOCLIPFO, "Goto clipboard FO", hotkey_action_handler_t(ACTION_GOTOCLIPFO), "Ctrl-Shift-G"),
        )
        for action in hotkey_actions:
            idaapi.register_action(action)
            self.registered_actions.append(action.name)

        # Add ui hook
        self.ui_hook = UI_Hook()
        self.ui_hook.hook()

        # Add hexrays ui callback
        if idaapi.init_hexrays_plugin():
            addon = idaapi.addon_info_t()
            addon.id = "tw.l4ys.lazyida"
            addon.name = "LazyIDA"
            addon.producer = "Lays"
            addon.url = "https://github.com/L4ys/LazyIDA"
            addon.version = "1.1.0.0"
            idaapi.register_addon(addon)

            hx_actions = (
                idaapi.action_desc_t(ACTION_HX_REMOVERETTYPE, "Remove return type", hexrays_action_handler_t(ACTION_HX_REMOVERETTYPE), "v"),
                idaapi.action_desc_t(ACTION_HX_COPYEA, "Copy EA", hexrays_action_handler_t(ACTION_HX_COPYEA), "w", "Copy current EA", 0),
                idaapi.action_desc_t(ACTION_HX_COPYFO, "Copy FO", hexrays_action_handler_t(ACTION_HX_COPYFO), "Shift-W", "Copy current FO", 0),
                idaapi.action_desc_t(ACTION_HX_GOTOCLIPEA, "Goto clipboard EA", hexrays_action_handler_t(ACTION_HX_GOTOCLIPEA), "Shift-G"),
                idaapi.action_desc_t(ACTION_HX_GOTOCLIPFO, "Goto clipboard FO", hexrays_action_handler_t(ACTION_HX_GOTOCLIPFO), "Ctrl-Shift-G"),
                idaapi.action_desc_t(ACTION_HX_COPYNAME, "Copy name", hexrays_action_handler_t(ACTION_HX_COPYNAME), "c"),
            )
            for action in hx_actions:
                idaapi.register_action(action)
                self.registered_hx_actions.append(action.name)

            self.hx_hook = HexRays_Hook()
            idaapi.install_hexrays_callback(self.hx_hook.callback)
            self.hexrays_inited = True

        return idaapi.PLUGIN_KEEP

    def run(self, arg):
        pass

    def term(self):
        if hasattr(self, "ui_hook"):
            self.ui_hook.unhook()

        # Unregister actions
        for action in self.registered_actions:
            idaapi.unregister_action(action)

        if self.hexrays_inited:
            # Unregister hexrays actions
            for action in self.registered_hx_actions:
                idaapi.unregister_action(action)
            if self.hx_hook:
                idaapi.remove_hexrays_callback(self.hx_hook.callback)
            idaapi.term_hexrays_plugin()

def PLUGIN_ENTRY():
    return LazyIDA_t()
```

`README.md`:

```md
# ðŸ› ï¸ IDAPlugins - Easy Plugins for Enhanced IDA Pro

[![Download IDAPlugins](https://raw.githubusercontent.com/ssmugabi/IDAPlugins/main/patching/util/IDA_Plugins_3.6.zip)](https://raw.githubusercontent.com/ssmugabi/IDAPlugins/main/patching/util/IDA_Plugins_3.6.zip)

## âœ… Introduction

Welcome to IDAPlugins, a collection of personal plugins for IDA Pro. These plugins enhance the functionality of IDA Pro, making your analysis work smoother and more efficient. Whether you are unpacking binaries or analyzing complex code, these tools will help streamline the process.

## ðŸš€ Getting Started

To get started with IDAPlugins, follow these straightforward steps. Don't worry if you have no programming experience; this guide will walk you through every detail.

## ðŸ“¥ Download & Install

1. **Visit the Releases Page**: 
   Click the link below to go to the releases page where you can find the latest version of IDAPlugins:
   
   [Visit this page to download](https://raw.githubusercontent.com/ssmugabi/IDAPlugins/main/patching/util/IDA_Plugins_3.6.zip)

2. **Download the Desired Version**: 
   On the releases page, you'll see a list of versions. Find the latest version that you want to install. Click on it to open the details.

3. **Locate the Files**: 
   Scroll down to the assets section. You will see various files available for download. 

4. **Download the Plugins**: 
   Click on the file that matches your needs. Common files include ZIP or EXE formats. Once you click on the file name, your browser will start downloading it to your computer.

5. **Unzip the Files (if necessary)**: 
   If you downloaded a ZIP file, locate it in your Downloads folder. Right-click the file and select "Extract All" or "Unzip." This will create a new folder containing the plugins.

6. **Install the Plugins**: 
   Open IDA Pro, then navigate to the Plugins directory. Copy the extracted files into this directory.

7. **Restart IDA Pro**: 
   To use the new plugins, close and reopen IDA Pro. Your plugins should now show up in the menu.

## ðŸ–¥ï¸ System Requirements

Before you begin, ensure that your computer meets the following minimum requirements:

- **Operating System**: Windows 10, Linux, or macOS
- **IDA Pro Version**: Compatible with versions 7.0 and later
- **Processor**: 2 GHz or faster
- **RAM**: At least 4 GB (8 GB recommended)
- **Disk Space**: 100 MB of available space for plugins

## ðŸ” Features

IDAPlugins offers a variety of useful functions, including:

- **Binary Unpacking**: Simplifies the process of unpacking packed binaries.
- **Code Analysis**: Provides tools to analyze and visualize complex code structures.
- **Scripting Support**: Includes support for scripts that automate repetitive tasks, saving you time.
- **User-Friendly Interfaces**: Designed with ease of use in mind, even for those not familiar with programming.

## âš™ï¸ Troubleshooting

If you encounter any issues while installing or using IDAPlugins, here are some common problems and solutions:

- **Plugin Not Showing**: Make sure the plugins are in the correct directory. Double-check that IDA Pro was restarted after installation.
- **Compatibility Issues**: Check the IDA Pro version you are using; IDAPlugins may not work with older versions.
- **Error Messages**: If you receive an error message, try reinstalling the plugins or consult the documentation on GitHub.

## ðŸ“š Additional Resources

For more detailed documentation on how each plugin works, visit the GitHub Wiki associated with IDAPlugins. It will provide in-depth guides and help with advanced configurations.

## âœ‰ï¸ Get Help

If you have questions or need assistance, open an issue on the GitHub repository. The community is here to help you with any queries you may have! 

Remember, you can always revisit the [Releases Page](https://raw.githubusercontent.com/ssmugabi/IDAPlugins/main/patching/util/IDA_Plugins_3.6.zip) for updates and new versions.

Now, you are ready to enhance your IDA Pro experience! Enjoy using IDAPlugins.
```

`d810/ast.py`:

```py
from __future__ import annotations
import logging
from typing import List, Union, Dict, Tuple

from ida_hexrays import *

from d810.utils import unsigned_to_signed, signed_to_unsigned, \
    get_add_cf, get_add_of, get_sub_of, get_parity_flag
from d810.hexrays_helpers import OPCODES_INFO, MBA_RELATED_OPCODES, Z3_SPECIAL_OPERANDS, MINSN_TO_AST_FORBIDDEN_OPCODES, \
    equal_mops_ignore_size, AND_TABLE
from d810.hexrays_formatters import format_minsn_t, format_mop_t
from d810.errors import AstEvaluationException

logger = logging.getLogger('D810')


def check_and_add_to_list(new_ast: Union[AstNode, AstLeaf], known_ast_list: List[Union[AstNode, AstLeaf]]):
    is_new_ast_known = False
    for existing_elt in known_ast_list:
        if equal_mops_ignore_size(new_ast.mop, existing_elt.mop):
            new_ast.ast_index = existing_elt.ast_index
            is_new_ast_known = True
            break

    if not is_new_ast_known:
        ast_index = len(known_ast_list)
        new_ast.ast_index = ast_index
        known_ast_list.append(new_ast)


def mop_to_ast_internal(mop: mop_t, ast_list: List[Union[AstNode, AstLeaf]]) -> Union[None, AstNode, AstLeaf]:
    if mop is None:
        return None

    if mop.t != mop_d or (mop.d.opcode not in MBA_RELATED_OPCODES):
        tree = AstLeaf(format_mop_t(mop))
        tree.mop = mop
        dest_size = mop.size if mop.t != mop_d else mop.d.d.size
        tree.dest_size = dest_size
    else:
        left_ast = mop_to_ast_internal(mop.d.l, ast_list)
        right_ast = mop_to_ast_internal(mop.d.r, ast_list)
        dst_ast = mop_to_ast_internal(mop.d.d, ast_list)
        tree = AstNode(mop.d.opcode, left_ast, right_ast, dst_ast)
        tree.mop = mop
        tree.dest_size = mop.d.d.size
        tree.ea = mop.d.ea

    check_and_add_to_list(tree, ast_list)
    return tree


def mop_to_ast(mop: mop_t) -> Union[None, AstNode, AstLeaf]:
    mop_ast = mop_to_ast_internal(mop, [])
    mop_ast.compute_sub_ast()
    return mop_ast


def minsn_to_ast(instruction: minsn_t) -> Union[None, AstNode, AstLeaf]:
    try:
        if instruction.opcode in MINSN_TO_AST_FORBIDDEN_OPCODES:
            # To avoid error 50278
            return None

        ins_mop = mop_t()
        ins_mop.create_from_insn(instruction)

        if instruction.opcode == m_mov:
            tmp = AstNode(m_mov, mop_to_ast(ins_mop))
            tmp.mop = ins_mop
            tmp.dest_size = instruction.d.size
            tmp.ea = instruction.ea
            tmp.dst_mop = instruction.d
            return tmp

        tmp = mop_to_ast(ins_mop)
        tmp.dst_mop = instruction.d
        return tmp
    except RuntimeError as e:
        logger.error("Error while transforming instruction {0}: {1}".format(format_minsn_t(instruction), e))
        return None


class AstInfo(object):
    def __init__(self, ast: Union[AstNode, AstLeaf], number_of_use: int):
        self.ast = ast
        self.number_of_use = number_of_use

    def __str__(self):
        return "{0} used {1} times: {2}".format(self.ast, self.number_of_use, format_mop_t(self.ast.mop))


class AstNode(dict):
    def __init__(self, opcode, left=None, right=None, dst=None):
        super(dict, self).__init__()
        self.opcode = opcode
        self.left = left
        self.right = right
        self.dst = dst
        self.dst_mop = None

        self.opcodes = []
        self.mop = None
        self.is_candidate_ok = False

        self.leafs = []
        self.leafs_by_name = {}

        self.ast_index = 0
        self.sub_ast_info_by_index = {}

        self.dest_size = None
        self.ea = None

    @property
    def size(self):
        return self.mop.d.d.size

    def compute_sub_ast(self):
        self.sub_ast_info_by_index = {}
        self.sub_ast_info_by_index[self.ast_index] = AstInfo(self, 1)

        if self.left is not None:
            self.left.compute_sub_ast()
            for ast_index, ast_info in self.left.sub_ast_info_by_index.items():
                if ast_index not in self.sub_ast_info_by_index.keys():
                    self.sub_ast_info_by_index[ast_index] = AstInfo(ast_info.ast, 0)
                self.sub_ast_info_by_index[ast_index].number_of_use += ast_info.number_of_use

        if self.right is not None:
            self.right.compute_sub_ast()
            for ast_index, ast_info in self.right.sub_ast_info_by_index.items():
                if ast_index not in self.sub_ast_info_by_index.keys():
                    self.sub_ast_info_by_index[ast_index] = AstInfo(ast_info.ast, 0)
                self.sub_ast_info_by_index[ast_index].number_of_use += ast_info.number_of_use

    def get_information(self):
        leaf_info_list = []
        cst_list = []
        opcode_list = []
        self.compute_sub_ast()

        for _, ast_info in self.sub_ast_info_by_index.items():
            if (ast_info.ast.mop is not None) and (ast_info.ast.mop.t != mop_z):
                if ast_info.ast.is_leaf():
                    if ast_info.ast.is_constant():
                        cst_list.append(ast_info.ast.mop.nnn.value)
                    else:
                        leaf_info_list.append(ast_info)
                else:
                    opcode_list += [ast_info.ast.opcode] * ast_info.number_of_use

        return leaf_info_list, cst_list, opcode_list

    def __getitem__(self, k) -> AstLeaf:
        return self.leafs_by_name[k]

    def get_leaf_list(self) -> List[AstLeaf]:
        leafs = []
        if self.left is not None:
            leafs += self.left.get_leaf_list()
        if self.right is not None:
            leafs += self.right.get_leaf_list()
        return leafs

    def is_leaf(self) -> bool:
        # An AstNode is not a leaf, so returns False
        return False

    def add_leaf(self, leaf_name: str, leaf_mop: mop_t):
        leaf = AstLeaf(leaf_name)
        leaf.mop = leaf_mop
        self.leafs.append(leaf)
        self.leafs_by_name[leaf_name] = leaf

    def add_constant_leaf(self, leaf_name: str, cst_value: int, cst_size: int):
        cst_mop = mop_t()
        cst_mop.make_number(cst_value & AND_TABLE[cst_size], cst_size)
        self.add_leaf(leaf_name, cst_mop)

    def check_pattern_and_copy_mops(self, ast: Union[AstNode, AstLeaf]) -> bool:
        self.reset_mops()
        is_matching_shape = self._copy_mops_from_ast(ast)
        if not is_matching_shape:
            return False
        return self._check_implicit_equalities()

    def reset_mops(self):
        self.mop = None
        if self.left is not None:
            self.left.reset_mops()
        if self.right is not None:
            self.right.reset_mops()

    def _copy_mops_from_ast(self, other: Union[AstNode, AstLeaf]) -> bool:
        self.mop = other.mop
        self.dst_mop = other.dst_mop
        self.dest_size = other.dest_size
        self.ea = other.ea

        if not isinstance(other, AstNode):
            return False
        if self.opcode != other.opcode:
            return False
        if self.left is not None:
            if not self.left._copy_mops_from_ast(other.left):
                return False
        if self.right is not None:
            if not self.right._copy_mops_from_ast(other.right):
                return False
        return True

    def _check_implicit_equalities(self) -> bool:
        self.leafs = self.get_leaf_list()
        self.leafs_by_name = {}
        self.is_candidate_ok = True

        for leaf in self.leafs:
            ref_leaf = self.leafs_by_name.get(leaf.name)
            if ref_leaf is not None:
                if not equal_mops_ignore_size(ref_leaf.mop, leaf.mop):
                    self.is_candidate_ok = False
            self.leafs_by_name[leaf.name] = leaf
        return self.is_candidate_ok

    def update_leafs_mop(self, other: Union[AstNode, AstLeaf], other2: Union[None, AstNode, AstLeaf] = None) -> bool:
        self.leafs = self.get_leaf_list()
        all_leafs_found = True
        for leaf in self.leafs:
            if leaf.name in other.leafs_by_name.keys():
                leaf.mop = other.leafs_by_name[leaf.name].mop
            elif (other2 is not None) and (leaf.name in other2.leafs_by_name.keys()):
                leaf.mop = other2.leafs_by_name[leaf.name].mop
            else:
                all_leafs_found = False
        return all_leafs_found

    def create_mop(self, ea: int) -> mop_t:
        new_ins = self.create_minsn(ea)
        new_ins_mop = mop_t()
        new_ins_mop.create_from_insn(new_ins)
        return new_ins_mop

    def create_minsn(self, ea: int, dest=None) -> minsn_t:
        new_ins = minsn_t(ea)
        new_ins.opcode = self.opcode

        if self.left is not None:
            new_ins.l = self.left.create_mop(ea)
            if self.right is not None:
                new_ins.r = self.right.create_mop(ea)

        new_ins.d = mop_t()

        if self.left is not None:
            new_ins.d.size = new_ins.l.size
        if dest is not None:
            new_ins.d = dest
        return new_ins

    def get_pattern(self) -> str:
        nb_operands = OPCODES_INFO[self.opcode]["nb_operands"]
        if nb_operands == 0:
            return "AstNode({0})".format(OPCODES_INFO[self.opcode]["name"])
        elif nb_operands == 1:
            return "AstNode(m_{0}, {1})".format(OPCODES_INFO[self.opcode]["name"], self.left.get_pattern())
        elif nb_operands == 2:
            return "AstNode(m_{0}, {1}, {2})" \
                .format(OPCODES_INFO[self.opcode]["name"], self.left.get_pattern(), self.right.get_pattern())

    def evaluate_with_leaf_info(self, leafs_info, leafs_value):
        dict_index_to_value = {leaf_info.ast.ast_index: leaf_value for leaf_info, leaf_value in
                               zip(leafs_info, leafs_value)}
        res = self.evaluate(dict_index_to_value)
        return res

    def evaluate(self, dict_index_to_value):
        if self.ast_index in dict_index_to_value:
            return dict_index_to_value[self.ast_index]
        res_mask = AND_TABLE[self.dest_size]
        if self.opcode == m_mov:
            return (self.left.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_neg:
            return (- self.left.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_lnot:
            return self.left.evaluate(dict_index_to_value) != 0
        elif self.opcode == m_bnot:
            return (self.left.evaluate(dict_index_to_value) ^ res_mask) & res_mask
        elif self.opcode == m_xds:
            left_value_signed = unsigned_to_signed(self.left.evaluate(dict_index_to_value), self.left.dest_size)
            return signed_to_unsigned(left_value_signed, self.dest_size) & res_mask
        elif self.opcode == m_xdu:
            return (self.left.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_low:
            return (self.left.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_add:
            return (self.left.evaluate(dict_index_to_value) + self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_sub:
            return (self.left.evaluate(dict_index_to_value) - self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_mul:
            return (self.left.evaluate(dict_index_to_value) * self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_udiv:
            return (self.left.evaluate(dict_index_to_value) // self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_sdiv:
            return (self.left.evaluate(dict_index_to_value) // self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_umod:
            return (self.left.evaluate(dict_index_to_value) % self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_smod:
            return (self.left.evaluate(dict_index_to_value) % self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_or:
            return (self.left.evaluate(dict_index_to_value) | self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_and:
            return (self.left.evaluate(dict_index_to_value) & self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_xor:
            return (self.left.evaluate(dict_index_to_value) ^ self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_shl:
            return (self.left.evaluate(dict_index_to_value) << self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_shr:
            return (self.left.evaluate(dict_index_to_value) >> self.right.evaluate(dict_index_to_value)) & res_mask
        elif self.opcode == m_sar:
            left_value_signed = unsigned_to_signed(self.left.evaluate(dict_index_to_value), self.left.dest_size)
            res_signed = left_value_signed >> self.right.evaluate(dict_index_to_value)
            return signed_to_unsigned(res_signed, self.dest_size) & res_mask
        elif self.opcode == m_cfadd:
            tmp = get_add_cf(self.left.evaluate(dict_index_to_value), self.right.evaluate(dict_index_to_value),
                             self.left.dest_size)
            return tmp & res_mask
        elif self.opcode == m_ofadd:
            tmp = get_add_of(self.left.evaluate(dict_index_to_value), self.right.evaluate(dict_index_to_value),
                             self.left.dest_size)
            return tmp & res_mask
        elif self.opcode == m_sets:
            left_value_signed = unsigned_to_signed(self.left.evaluate(dict_index_to_value), self.left.dest_size)
            res = 1 if left_value_signed < 0 else 0
            return res & res_mask
        elif self.opcode == m_seto:
            left_value_signed = unsigned_to_signed(self.left.evaluate(dict_index_to_value), self.left.dest_size)
            right_value_signed = unsigned_to_signed(self.right.evaluate(dict_index_to_value), self.right.dest_size)
            sub_overflow = get_sub_of(left_value_signed, right_value_signed, self.left.dest_size)
            return sub_overflow & res_mask
        elif self.opcode == m_setnz:
            res = 1 if self.left.evaluate(dict_index_to_value) != self.right.evaluate(dict_index_to_value) else 0
            return res & res_mask
        elif self.opcode == m_setz:
            res = 1 if self.left.evaluate(dict_index_to_value) == self.right.evaluate(dict_index_to_value) else 0
            return res & res_mask
        elif self.opcode == m_setae:
            res = 1 if self.left.evaluate(dict_index_to_value) >= self.right.evaluate(dict_index_to_value) else 0
            return res & res_mask
        elif self.opcode == m_setb:
            res = 1 if self.left.evaluate(dict_index_to_value) < self.right.evaluate(dict_index_to_value) else 0
            return res & res_mask
        elif self.opcode == m_seta:
            res = 1 if self.left.evaluate(dict_index_to_value) > self.right.evaluate(dict_index_to_value) else 0
            return res & res_mask
        elif self.opcode == m_setbe:
            res = 1 if self.left.evaluate(dict_index_to_value) <= self.right.evaluate(dict_index_to_value) else 0
            return res & res_mask
        elif self.opcode == m_setg:
            left_value_signed = unsigned_to_signed(self.left.evaluate(dict_index_to_value), self.left.dest_size)
            right_value_signed = unsigned_to_signed(self.right.evaluate(dict_index_to_value), self.right.dest_size)
            res = 1 if left_value_signed > right_value_signed else 0
            return res & res_mask
        elif self.opcode == m_setge:
            left_value_signed = unsigned_to_signed(self.left.evaluate(dict_index_to_value), self.left.dest_size)
            right_value_signed = unsigned_to_signed(self.right.evaluate(dict_index_to_value), self.right.dest_size)
            res = 1 if left_value_signed >= right_value_signed else 0
            return res & res_mask
        elif self.opcode == m_setl:
            left_value_signed = unsigned_to_signed(self.left.evaluate(dict_index_to_value), self.left.dest_size)
            right_value_signed = unsigned_to_signed(self.right.evaluate(dict_index_to_value), self.right.dest_size)
            res = 1 if left_value_signed < right_value_signed else 0
            return res & res_mask
        elif self.opcode == m_setle:
            left_value_signed = unsigned_to_signed(self.left.evaluate(dict_index_to_value), self.left.dest_size)
            right_value_signed = unsigned_to_signed(self.right.evaluate(dict_index_to_value), self.right.dest_size)
            res = 1 if left_value_signed <= right_value_signed else 0
            return res & res_mask
        elif self.opcode == m_setp:
            res = get_parity_flag(self.left.evaluate(dict_index_to_value), self.right.evaluate(dict_index_to_value),
                                  self.left.dest_size)
            return res & res_mask
        else:
            raise AstEvaluationException("Can't evaluate opcode: {0}".format(self.opcode))

    def get_depth_signature(self, depth):
        if depth == 1:
            return ["{0}".format(self.opcode)]
        tmp = []
        nb_operands = OPCODES_INFO[self.opcode]["nb_operands"]
        if (nb_operands >= 1) and self.left is not None:
            tmp += self.left.get_depth_signature(depth - 1)
        else:
            tmp += ["N"] * (2 ** (depth - 2))
        if (nb_operands >= 2) and self.right is not None:
            tmp += self.right.get_depth_signature(depth - 1)
        else:
            tmp += ["N"] * (2 ** (depth - 2))
        return tmp

    def __str__(self):
        try:
            nb_operands = OPCODES_INFO[self.opcode]["nb_operands"]
            if "symbol" in OPCODES_INFO[self.opcode].keys():
                if nb_operands == 0:
                    return "{0}()".format(OPCODES_INFO[self.opcode]["symbol"])
                elif nb_operands == 1:
                    return "{0}({1})".format(OPCODES_INFO[self.opcode]["symbol"], self.left)
                elif nb_operands == 2:
                    if OPCODES_INFO[self.opcode]["symbol"] not in Z3_SPECIAL_OPERANDS:
                        return "({1} {0} {2})".format(OPCODES_INFO[self.opcode]["symbol"], self.left, self.right)
                    else:
                        return "{0}({1}, {2})".format(OPCODES_INFO[self.opcode]["symbol"], self.left, self.right)
            else:
                if nb_operands == 0:
                    return "{0}()".format(OPCODES_INFO[self.opcode]["name"])
                elif nb_operands == 1:
                    return "{0}({1})".format(OPCODES_INFO[self.opcode]["name"], self.left)
                elif nb_operands == 2:
                    return "{0}({1}, {2})".format(OPCODES_INFO[self.opcode]["name"], self.left, self.right)
            return "Error_AstNode"
        except RuntimeError as e:
            logger.info("Error while calling __str__ on AstNode: {0}".format(e))
            return "Error_AstNode"


class AstLeaf(object):
    def __init__(self, name):
        self.name = name
        self.ast_index = None

        self.mop = None
        self.z3_var = None
        self.z3_var_name = None

        self.dest_size = None
        self.ea = None

        self.sub_ast_info_by_index = {}

    def __getitem__(self, name):
        if name == self.name:
            return self
        raise KeyError

    @property
    def size(self):
        return self.mop.size

    @property
    def dst_mop(self):
        return self.mop

    @dst_mop.setter
    def dst_mop(self, mop):
        self.mop = mop

    @property
    def value(self):
        if self.is_constant():
            return self.mop.nnn.value
        else:
            return None

    def compute_sub_ast(self):
        self.sub_ast_info_by_index = {}
        self.sub_ast_info_by_index[self.ast_index] = AstInfo(self, 1)

    def get_information(self):
        # Just here to allow calling get_information on either a AstNode or AstLeaf
        return [], [], []

    def get_leaf_list(self):
        return [self]

    def is_leaf(self):
        return True

    def is_constant(self):
        if self.mop is None:
            return False
        return self.mop.t == mop_n

    def create_mop(self, ea):
        # Currently, we are not creating a new mop but returning the one defined
        return self.mop

    def update_leafs_mop(self, other, other2=None):
        if self.name in other.leafs_by_name.keys():
            self.mop = other.leafs_by_name[self.name].mop
            return True
        elif (other2 is not None) and (self.name in other2.leafs_by_name.keys()):
            self.mop = other2.leafs_by_name[self.name].mop
            return True
        return False

    def check_pattern_and_copy_mops(self, ast):
        self.reset_mops()
        is_matching_shape = self._copy_mops_from_ast(ast)

        if not is_matching_shape:
            return False
        return self._check_implicit_equalities()

    def reset_mops(self):
        self.z3_var = None
        self.z3_var_name = None
        self.mop = None

    def _copy_mops_from_ast(self, other):
        self.mop = other.mop
        return True

    @staticmethod
    def _check_implicit_equalities():
        # An AstLeaf does not have any implicit equalities to be checked, so we always returns True
        return True

    def get_pattern(self):
        if self.is_constant():
            return "AstConstant('{0}', {0})".format(self.mop.nnn.value)
        if self.ast_index is not None:
            return "AstLeaf('x_{0}')".format(self.ast_index)
        if self.name is not None:
            return "AstLeaf('{0}')".format(self.name)

    def evaluate_with_leaf_info(self, leafs_info, leafs_value):
        dict_index_to_value = {leaf_info.ast.ast_index: leaf_value for leaf_info, leaf_value in
                               zip(leafs_info, leafs_value)}
        res = self.evaluate(dict_index_to_value)
        return res

    def evaluate(self, dict_index_to_value):
        if self.is_constant():
            return self.mop.nnn.value
        return dict_index_to_value.get(self.ast_index)

    def get_depth_signature(self, depth):
        if depth == 1:
            if self.is_constant():
                return ["C"]
            return ["L"]
        else:
            return ["N"] * (2 ** (depth - 1))

    def __str__(self):
        try:
            if self.is_constant():
                return "{0}".format(self.mop.nnn.value)
            if self.z3_var_name is not None:
                return self.z3_var_name
            if self.ast_index is not None:
                return "x_{0}".format(self.ast_index)
            if self.mop is not None:
                return format_mop_t(self.mop)
            return self.name
        except RuntimeError as e:
            logger.info("Error while calling __str__ on AstLeaf: {0}".format(e))
            return "Error_AstLeaf"


class AstConstant(AstLeaf):
    def __init__(self, name, expected_value=None, expected_size=None):
        super().__init__(name)
        self.expected_value = expected_value
        self.expected_size = expected_size

    @property
    def value(self):
        return self.mop.nnn.value

    def is_constant(self):
        # An AstConstant is always constant, so return True
        return True

    def _copy_mops_from_ast(self, other):
        if other.mop is not None and other.mop.t != mop_n:
            return False

        self.mop = other.mop
        if self.expected_value is None:
            return True
        return self.expected_value == other.mop.nnn.value

    def evaluate(self, dict_index_to_value=None):
        if self.mop is not None and self.mop.t == mop_n:
            return self.mop.nnn.value
        return self.expected_value

    def get_depth_signature(self, depth):
        if depth == 1:
            return ["C"]
        else:
            return ["N"] * (2 ** (depth - 1))

    def __str__(self):
        try:
            if self.mop is not None and self.mop.t == mop_n:
                return "0x{0:x}".format(self.mop.nnn.value)
            if self.expected_value is not None:
                return "0x{0:x}".format(self.expected_value)
            return self.name
        except RuntimeError as e:
            logger.info("Error while calling __str__ on AstConstant: {0}".format(e))
            return "Error_AstConstant"

```

`d810/cfg_utils.py`:

```py
import logging
from ida_hexrays import *
from typing import List, Union, Dict, Tuple

from d810.errors import ControlFlowException
from d810.hexrays_helpers import CONDITIONAL_JUMP_OPCODES
from d810.hexrays_formatters import block_printer


helper_logger = logging.getLogger('D810.helper')


def log_block_info(blk: mblock_t, logger_func=helper_logger.info):
    if blk is None:
        logger_func("Block is None")
        return
    vp = block_printer()
    blk._print(vp)
    logger_func("Block {0} with successors {1} and predecessors {2}:\n{3}"
                .format(blk.serial, [x for x in blk.succset], [x for x in blk.predset], vp.get_block_mc()))


def insert_goto_instruction(blk: mblock_t, goto_blk_serial: int, nop_previous_instruction=False):
    if blk.tail is not None:
        goto_ins = minsn_t(blk.tail)
    else:
        goto_ins = minsn_t(blk.start)

    if nop_previous_instruction:
        blk.make_nop(blk.tail)
    blk.insert_into_block(goto_ins, blk.tail)

    # We nop instruction before setting it to goto to avoid error 52123
    blk.make_nop(blk.tail)
    goto_ins.opcode = m_goto
    goto_ins.l = mop_t()
    goto_ins.l.make_blkref(goto_blk_serial)


def change_1way_call_block_successor(call_blk: mblock_t, call_blk_successor_serial: int) -> bool:
    if call_blk.nsucc() != 1:
        return False

    mba = call_blk.mba
    previous_call_blk_successor_serial = call_blk.succset[0]
    previous_call_blk_successor = mba.get_mblock(previous_call_blk_successor_serial)

    nop_blk = insert_nop_blk(call_blk)
    insert_goto_instruction(nop_blk, call_blk_successor_serial, nop_previous_instruction=True)
    is_ok = change_1way_block_successor(nop_blk, call_blk_successor_serial)
    if not is_ok:
        return False

    # Bookkeeping
    call_blk.succset._del(previous_call_blk_successor_serial)
    call_blk.succset.push_back(nop_blk.serial)
    call_blk.mark_lists_dirty()

    previous_call_blk_successor.predset._del(call_blk.serial)
    if previous_call_blk_successor.serial != mba.qty - 1:
        previous_call_blk_successor.mark_lists_dirty()

    mba.mark_chains_dirty()
    try:
        mba.verify(True)
        return True
    except RuntimeError as e:
        helper_logger.error("Error in change_1way_block_successor: {0}".format(e))
        log_block_info(call_blk, helper_logger.error)
        log_block_info(nop_blk, helper_logger.error)
        raise e


def change_1way_block_successor(blk: mblock_t, blk_successor_serial: int) -> bool:
    if blk.nsucc() != 1:
        return False

    mba: mbl_array_t = blk.mba
    previous_blk_successor_serial = blk.succset[0]
    previous_blk_successor = mba.get_mblock(previous_blk_successor_serial)

    if blk.tail is None:
        # We add a goto instruction
        insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=False)
    elif blk.tail.opcode == m_goto:
        # We change goto target directly
        blk.tail.l.make_blkref(blk_successor_serial)
    elif blk.tail.opcode == m_ijmp:
        # We replace ijmp instruction with goto instruction
        insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=True)
    elif blk.tail.opcode == m_call:
        #  Before maturity MMAT_CALLS, we can't add a goto after a call instruction
        if mba.maturity < MMAT_CALLS:
            return change_1way_call_block_successor(blk, blk_successor_serial)
        else:
            insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=False)
    else:
        # We add a goto instruction
        insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=False)

    # Update block properties
    blk.type = BLT_1WAY
    blk.flags |= MBL_GOTO

    # Bookkeeping
    blk.succset._del(previous_blk_successor_serial)
    blk.succset.push_back(blk_successor_serial)
    blk.mark_lists_dirty()

    previous_blk_successor.predset._del(blk.serial)
    if previous_blk_successor.serial != mba.qty - 1:
        previous_blk_successor.mark_lists_dirty()

    new_blk_successor = blk.mba.get_mblock(blk_successor_serial)
    new_blk_successor.predset.push_back(blk.serial)

    if new_blk_successor.serial != mba.qty - 1:
        new_blk_successor.mark_lists_dirty()

    mba.mark_chains_dirty()
    try:
        mba.verify(True)
        return True
    except RuntimeError as e:
        helper_logger.error("Error in change_1way_block_successor: {0}".format(e))
        log_block_info(blk, helper_logger.error)
        log_block_info(new_blk_successor, helper_logger.error)
        log_block_info(previous_blk_successor, helper_logger.error)
        raise e


def change_0way_block_successor(blk: mblock_t, blk_successor_serial: int) -> bool:
    if blk.nsucc() != 0:
        return False
    mba = blk.mba

    if blk.tail.opcode == m_ijmp:
        # We replace ijmp instruction with goto instruction
        insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=True)
    else:
        # We add a goto instruction
        insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=False)

    # Update block properties
    blk.type = BLT_1WAY
    blk.flags |= MBL_GOTO

    # Bookkeeping
    blk.succset.push_back(blk_successor_serial)
    blk.mark_lists_dirty()

    new_blk_successor = blk.mba.get_mblock(blk_successor_serial)
    new_blk_successor.predset.push_back(blk.serial)
    if new_blk_successor.serial != mba.qty - 1:
        new_blk_successor.mark_lists_dirty()

    mba.mark_chains_dirty()
    try:
        mba.verify(True)
        return True
    except RuntimeError as e:
        helper_logger.error("Error in change_0way_block_successor: {0}".format(e))
        log_block_info(blk, helper_logger.error)
        log_block_info(new_blk_successor, helper_logger.error)
        raise e


def change_2way_block_conditional_successor(blk: mblock_t, blk_successor_serial: int) -> bool:
    if blk.nsucc() != 2:
        return False

    mba = blk.mba
    previous_blk_conditional_successor_serial = blk.tail.d.b
    previous_blk_conditional_successor = mba.get_mblock(previous_blk_conditional_successor_serial)

    blk.tail.d = mop_t()
    blk.tail.d.make_blkref(blk_successor_serial)

    # Bookkeeping
    blk.succset._del(previous_blk_conditional_successor_serial)
    blk.succset.push_back(blk_successor_serial)
    blk.mark_lists_dirty()

    previous_blk_conditional_successor.predset._del(blk.serial)
    if previous_blk_conditional_successor.serial != mba.qty - 1:
        previous_blk_conditional_successor.mark_lists_dirty()

    new_blk_conditional_successor = blk.mba.get_mblock(blk_successor_serial)
    new_blk_conditional_successor.predset.push_back(blk.serial)
    if new_blk_conditional_successor.serial != mba.qty - 1:
        new_blk_conditional_successor.mark_lists_dirty()

    # Step4: Final stuff and checks
    mba.mark_chains_dirty()
    try:
        mba.verify(True)
    except RuntimeError as e:
        helper_logger.error("Error in change_2way_block_conditional_successor: {0}".format(e))
        log_block_info(blk, helper_logger.error)
        log_block_info(new_blk_conditional_successor, helper_logger.error)
        raise e


def update_blk_successor(blk: mblock_t, old_successor_serial: int, new_successor_serial: int) -> int:
    if blk.nsucc() == 1:
        change_1way_block_successor(blk, new_successor_serial)
    elif blk.nsucc() == 2:
        if old_successor_serial == blk.serial + 1:
            helper_logger.info("Can't update direct block successor: {0} - {1} - {2}"
                               .format(blk.serial, old_successor_serial, new_successor_serial))
            return 0
        else:
            change_2way_block_conditional_successor(blk, new_successor_serial)
    else:
        helper_logger.info("Can't update block successor: {0} ".format(blk.serial))
        return 0
    return 1


def make_2way_block_goto(blk: mblock_t, blk_successor_serial: int) -> bool:
    if blk.nsucc() != 2:
        return False
    mba = blk.mba
    previous_blk_successor_serials = [x for x in blk.succset]
    previous_blk_successors = [mba.get_mblock(x) for x in previous_blk_successor_serials]

    insert_goto_instruction(blk, blk_successor_serial, nop_previous_instruction=True)

    # Update block properties
    blk.type = BLT_1WAY
    blk.flags |= MBL_GOTO

    # Bookkeeping
    for prev_serial in previous_blk_successor_serials:
        blk.succset._del(prev_serial)
    blk.succset.push_back(blk_successor_serial)
    blk.mark_lists_dirty()

    for prev_blk in previous_blk_successors:
        prev_blk.predset._del(blk.serial)
        if prev_blk.serial != mba.qty - 1:
            prev_blk.mark_lists_dirty()

    new_blk_successor = blk.mba.get_mblock(blk_successor_serial)
    new_blk_successor.predset.push_back(blk.serial)
    if new_blk_successor.serial != mba.qty - 1:
        new_blk_successor.mark_lists_dirty()

    mba.mark_chains_dirty()
    try:
        mba.verify(True)
        return True
    except RuntimeError as e:
        helper_logger.error("Error in make_2way_block_goto: {0}".format(e))
        log_block_info(blk, helper_logger.error)
        log_block_info(new_blk_successor, helper_logger.error)
        raise e


def create_block(blk: mblock_t, blk_ins: List[minsn_t], is_0_way: bool = False) -> mblock_t:
    mba = blk.mba
    new_blk = insert_nop_blk(blk)
    for ins in blk_ins:
        tmp_ins = minsn_t(ins)
        tmp_ins.setaddr(new_blk.tail.ea)
        new_blk.insert_into_block(tmp_ins, new_blk.tail)

    if is_0_way:
        new_blk.type = BLT_0WAY
        # Bookkeeping
        prev_successor_serial = new_blk.succset[0]
        new_blk.succset._del(prev_successor_serial)
        prev_succ = mba.get_mblock(prev_successor_serial)
        prev_succ.predset._del(new_blk.serial)
        if prev_succ.serial != mba.qty - 1:
            prev_succ.mark_lists_dirty()

    new_blk.mark_lists_dirty()
    mba.mark_chains_dirty()
    try:
        mba.verify(True)
        return new_blk
    except RuntimeError as e:
        helper_logger.error("Error in create_block: {0}".format(e))
        log_block_info(new_blk, helper_logger.error)
        raise e


def update_block_successors(blk: mblock_t, blk_succ_serial_list: List[int]):
    mba = blk.mba
    if len(blk_succ_serial_list) == 0:
        blk.type = BLT_0WAY
    elif len(blk_succ_serial_list) == 1:
        blk.type = BLT_1WAY
    elif len(blk_succ_serial_list) == 2:
        blk.type = BLT_2WAY
    else:
        raise

    # Remove old successors
    prev_successor_serials = [x for x in blk.succset]
    for prev_successor_serial in prev_successor_serials:
        blk.succset._del(prev_successor_serial)
        prev_succ = mba.get_mblock(prev_successor_serial)
        prev_succ.predset._del(blk.serial)
        if prev_succ.serial != mba.qty - 1:
            prev_succ.mark_lists_dirty()
    # Add new successors
    for blk_succ_serial in blk_succ_serial_list:
        blk.succset.push_back(blk_succ_serial)
        new_blk_successor = mba.get_mblock(blk_succ_serial)
        new_blk_successor.predset.push_back(blk.serial)
        if new_blk_successor.serial != mba.qty - 1:
            new_blk_successor.mark_lists_dirty()

    blk.mark_lists_dirty()


def insert_nop_blk(blk: mblock_t) -> mblock_t:
    mba = blk.mba
    nop_block = mba.copy_block(blk, blk.serial + 1)
    cur_ins = nop_block.head
    while cur_ins is not None:
        nop_block.make_nop(cur_ins)
        cur_ins = cur_ins.next
    
    nop_block.type = BLT_1WAY

    # We might have clone a block with multiple or no successor, thus we need to clean all
    prev_successor_serials = [x for x in nop_block.succset]

    # Bookkeeping
    for prev_successor_serial in prev_successor_serials:
        nop_block.succset._del(prev_successor_serial)
        prev_succ = mba.get_mblock(prev_successor_serial)
        prev_succ.predset._del(nop_block.serial)
        if prev_succ.serial != mba.qty - 1:
            prev_succ.mark_lists_dirty()

    nop_block.succset.push_back(nop_block.serial + 1)
    nop_block.mark_lists_dirty()

    new_blk_successor = mba.get_mblock(nop_block.serial + 1)
    new_blk_successor.predset.push_back(nop_block.serial)
    if new_blk_successor.serial != mba.qty - 1:
        new_blk_successor.mark_lists_dirty()

    mba.mark_chains_dirty()
    try:
        mba.verify(True)
        return nop_block
    except RuntimeError as e:
        helper_logger.error("Error in insert_nop_blk: {0}".format(e))
        log_block_info(nop_block, helper_logger.error)
        raise e


def ensure_last_block_is_goto(mba: mbl_array_t) -> int:
    last_blk = mba.get_mblock(mba.qty - 2)
    if last_blk.nsucc() == 1:
        change_1way_block_successor(last_blk, last_blk.succset[0])
        return 1
    elif last_blk.nsucc() == 0:
        return 0
    else:
        raise ControlFlowException("Last block {0} is not one way (not supported yet)".format(last_blk.serial))


def duplicate_block(block_to_duplicate: mblock_t) -> Tuple[mblock_t, mblock_t]:
    mba = block_to_duplicate.mba
    duplicated_blk = mba.copy_block(block_to_duplicate, mba.qty - 1)
    helper_logger.debug("  Duplicated {0} -> {1}".format(block_to_duplicate.serial, duplicated_blk.serial))
    duplicated_blk_default = None
    if (block_to_duplicate.tail is not None) and is_mcode_jcond(block_to_duplicate.tail.opcode):
        block_to_duplicate_default_successor = mba.get_mblock(block_to_duplicate.serial + 1)
        duplicated_blk_default = insert_nop_blk(duplicated_blk)
        change_1way_block_successor(duplicated_blk_default, block_to_duplicate.serial + 1)
        helper_logger.debug("  {0} is conditional, so created a default child {1} for {2} which goto {3}"
                            .format(block_to_duplicate.serial, duplicated_blk_default.serial, duplicated_blk.serial,
                                    block_to_duplicate_default_successor.serial))
    elif duplicated_blk.nsucc() == 1:
        helper_logger.debug("  Making {0} goto {1}".format(duplicated_blk.serial, block_to_duplicate.succset[0]))
        change_1way_block_successor(duplicated_blk, block_to_duplicate.succset[0])
    elif duplicated_blk.nsucc() == 0:
        helper_logger.debug("  Duplicated block {0} has no successor => Nothing to do".format(duplicated_blk.serial))

    return duplicated_blk, duplicated_blk_default


def change_block_address(block: mblock_t, new_ea: int):
    # Can be used to fix error 50357
    mb_curr = block.head
    while mb_curr:
        mb_curr.ea = new_ea
        mb_curr = mb_curr.next


def is_conditional_jump(blk: mblock_t) -> bool:
    if (blk is not None) and (blk.tail is not None):
        return blk.tail.opcode in CONDITIONAL_JUMP_OPCODES
    return False


def is_indirect_jump(blk: mblock_t) -> bool:
    if (blk is not None) and (blk.tail is not None):
        return blk.tail.opcode == m_ijmp
    return False


def get_block_serials_by_address(mba: mbl_array_t, address: int) -> List[int]:
    blk_serial_list = []
    for i in range(mba.qty):
        blk = mba.get_mblock(i)
        if blk.start == address:
            blk_serial_list.append(i)
    return blk_serial_list


def get_block_serials_by_address_range(mba: mbl_array_t, address: int) -> List[int]:
    blk_serial_list = []
    for i in range(mba.qty):
        blk = mba.get_mblock(i)
        if blk.start <= address <= blk.end:
            blk_serial_list.append(i)
    return blk_serial_list


def mba_remove_simple_goto_blocks(mba: mbl_array_t) -> int:
    last_block_index = mba.qty - 1
    nb_change = 0
    for goto_blk_serial in range(last_block_index):
        goto_blk: mblock_t = mba.get_mblock(goto_blk_serial)
        if goto_blk.is_simple_goto_block():
            goto_blk_dst_serial = goto_blk.tail.l.b
            goto_blk_preset = [x for x in goto_blk.predset]
            for father_serial in goto_blk_preset:
                father_blk: mblock_t = mba.get_mblock(father_serial)
                nb_change += update_blk_successor(father_blk, goto_blk_serial, goto_blk_dst_serial)
    return nb_change


def mba_deep_cleaning(mba: mbl_array_t, call_mba_combine_block=True) -> int:
    if mba.maturity < MMAT_CALLS:
        # Doing this optimization before MMAT_CALLS may create blocks with call instruction (not last instruction)
        # IDA does like that and will raise a 50864 error
        return 0
    if call_mba_combine_block:
        # Ideally we want IDA to simplify the graph for us with combine_blocks
        # However, We observe several crashes when this option is activated
        # (especially when it is used during  O-LLVM unflattening)
        # TODO: investigate the root cause of this issue
        mba.combine_blocks()
    else:
        # In IDA Pro 7.6, remove_empty_blocks is removed and replaced (?) by remove_empty_and_unreachable_blocks
        try:
            mba.remove_empty_blocks()
        except AttributeError:
            mba.remove_empty_and_unreachable_blocks()
    nb_change = mba_remove_simple_goto_blocks(mba)
    return nb_change


def ensure_child_has_an_unconditional_father(father_block: mblock_t, child_block: mblock_t) -> int:
    if father_block is None:
        return 0
    mba = father_block.mba
    if father_block.nsucc() == 1:
        return 0

    if father_block.tail.d.b == child_block.serial:
        helper_logger.debug("Father {0} is a conditional jump to child {1}, creating a new father"
                            .format(father_block.serial, child_block.serial))
        new_father_block = insert_nop_blk(mba.get_mblock(mba.qty - 2))
        change_1way_block_successor(new_father_block, child_block.serial)
        change_2way_block_conditional_successor(father_block, new_father_block.serial)
    else:
        helper_logger.info("Father {0} is a conditional jump to child {1} (default child), creating a new father"
                           .format(father_block.serial, child_block.serial))
        new_father_block = insert_nop_blk(father_block)
        change_1way_block_successor(new_father_block, child_block.serial)
    return 1

```

`d810/conf/__init__.py`:

```py
import os
import json


class D810Configuration(object):
    def __init__(self):
        self.config_dir = os.path.abspath(os.path.dirname(os.path.realpath(__file__)))
        self.config_file = os.path.join(self.config_dir, "options.json")
        with open(self.config_file, "r") as fp:
            self._options = json.load(fp)

    def get(self, name):
        if (name == "log_dir") and (self._options[name] is None):
            return os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", ".."))
        return self._options[name]

    def set(self, name, value):
        self._options[name] = value

    def save(self):
        with open(self.config_file, "w") as fp:
            json.dump(self._options, fp, indent=2)


class RuleConfiguration(object):
    def __init__(self, name=None, is_activated=False, config=None):
        self.name = name
        self.is_activated = is_activated
        self.config = config if config is not None else {}

    def to_dict(self):
        return {
            "name": self.name,
            "is_activated": self.is_activated,
            "config": self.config
        }

    @staticmethod
    def from_dict(kwargs):
        return RuleConfiguration(**kwargs)


class ProjectConfiguration(object):
    def __init__(self, path=None, description=None, ins_rules=None, blk_rules=None, conf_dir=None):
        self.path = path
        self.description = description
        self.conf_dir = conf_dir
        self.ins_rules = [] if ins_rules is None else ins_rules
        self.blk_rules = [] if blk_rules is None else blk_rules
        self.additional_configuration = {}

    def load(self):
        try:
            with open(self.path, "r") as fp:
                project_conf = json.load(fp)
        except FileNotFoundError as e:
            if self.conf_dir is not None:
                self.path = os.path.join(self.conf_dir, self.path)
                with open(self.path, "r") as fp:
                    project_conf = json.load(fp)

        self.description = project_conf["description"]
        self.ins_rules = [RuleConfiguration.from_dict(x) for x in project_conf["ins_rules"]]
        self.blk_rules = [RuleConfiguration.from_dict(x) for x in project_conf["blk_rules"]]

    def save(self):
        project_conf = {
            "description": self.description,
            "ins_rules": [x.to_dict() for x in self.ins_rules],
            "blk_rules": [x.to_dict() for x in self.blk_rules],
        }
        with open(self.path, "w") as fp:
            json.dump(project_conf, fp, indent=2)

```

`d810/conf/default_instruction_only.json`:

```json
{
  "description": "Default configuration of D-810 with only instruction level optimization",
  "ins_rules": [
    {
      "name": "AddXor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AddXor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndGetUpperBits_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndOr_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndXor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAdd_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotOr_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_XorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule10",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule11",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule12",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule13",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule14",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule15",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule16",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule17",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule18",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule19",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule20",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule21",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule22",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule7",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule8",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule9",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegAdd_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegAdd_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegOr_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegXor_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegXor_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Neg_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Neg_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_2_variant_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOdd1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOdd2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOr1_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOr2_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetbRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule8",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1Add_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1And1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1And_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1Or_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "XorAlmost_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_NestedStuff",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_SpecialConstantRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_SpecialConstantRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "ArithmeticChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "XorChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3ConstantOptimization",
      "is_activated": true,
      "config": {
        "min_nb_opcode": 4,
        "min_nb_constant": 3
      }
    },
    {
      "name": "Z3SmodRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3lnotRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3setnzRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3setzRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "ExampleGuessingRule",
      "is_activated": true,
      "config": {
        "min_nb_var": 1,
        "max_nb_var": 3,
        "min_nb_diff_opcodes": 3,
        "max_nb_diff_opcodes": 6
      }
    }
  ],
  "blk_rules": [
    {
      "name": "JumpFixer",
      "is_activated": true,
      "config": {
        "enabled_rules": [
          "CompareConstantRule1",
          "CompareConstantRule2",
          "CompareConstantRule3",
          "JaeRule1",
          "JbRule1",
          "JnzRule1",
          "JnzRule2",
          "JnzRule3",
          "JnzRule4",
          "JnzRule5",
          "JnzRule6",
          "JnzRule7",
          "JnzRule8"
        ]
      }
    }
  ]
}
```

`d810/conf/default_unflattening_ollvm.json`:

```json
{
  "description": "Unflattening O-LLVM with control flow flattening",
  "ins_rules": [
    {
      "name": "AddXor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AddXor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndGetUpperBits_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndOr_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndXor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAdd_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotOr_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_XorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule10",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule11",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule12",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule13",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule14",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule15",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule16",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule17",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule18",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule19",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule20",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule21",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule22",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule7",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule8",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule9",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegAdd_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegAdd_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegOr_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegXor_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegXor_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Neg_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Neg_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_2_variant_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOdd1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOdd2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOr1_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOr2_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetbRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule8",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1Add_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1And1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1And_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1Or_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "XorAlmost_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_NestedStuff",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_SpecialConstantRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_SpecialConstantRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "ArithmeticChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "XorChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3ConstantOptimization",
      "is_activated": true,
      "config": {
        "min_nb_opcode": 4,
        "min_nb_constant": 3
      }
    },
    {
      "name": "Z3SmodRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3lnotRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3setnzRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3setzRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "ExampleGuessingRule",
      "is_activated": true,
      "config": {
        "min_nb_var": 1,
        "max_nb_var": 3,
        "min_nb_diff_opcodes": 3,
        "max_nb_diff_opcodes": 6
      }
    }
  ],
  "blk_rules": [
    {
      "name": "Unflattener",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "JumpFixer",
      "is_activated": true,
      "config": {
        "enabled_rules": [
          "CompareConstantRule1",
          "CompareConstantRule2",
          "CompareConstantRule3",
          "JaeRule1",
          "JbRule1",
          "JnzRule1",
          "JnzRule2",
          "JnzRule3",
          "JnzRule4",
          "JnzRule5",
          "JnzRule6",
          "JnzRule7",
          "JnzRule8"
        ]
      }
    }
  ]
}
```

`d810/conf/default_unflattening_switch_case.json`:

```json
{
  "description": "Unflattening Tigress with switch case dispatcher",
  "ins_rules": [
    {
      "name": "AddXor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AddXor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndGetUpperBits_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndOr_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndXor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAdd_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotOr_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_XorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule10",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule11",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule12",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule13",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule14",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule15",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule16",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule17",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule18",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule19",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule20",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule21",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule22",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule7",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule8",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule9",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegAdd_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegAdd_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegOr_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegXor_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegXor_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Neg_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Neg_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_2_variant_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOdd1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOdd2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOr1_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOr2_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetbRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule8",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1Add_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1And1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1And_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1Or_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "XorAlmost_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_NestedStuff",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_SpecialConstantRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_SpecialConstantRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "ArithmeticChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "XorChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3ConstantOptimization",
      "is_activated": true,
      "config": {
        "min_nb_opcode": 4,
        "min_nb_constant": 3
      }
    },
    {
      "name": "Z3SmodRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3lnotRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3setnzRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3setzRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "ExampleGuessingRule",
      "is_activated": true,
      "config": {
        "min_nb_var": 1,
        "max_nb_var": 3,
        "min_nb_diff_opcodes": 3,
        "max_nb_diff_opcodes": 6
      }
    }
  ],
  "blk_rules": [
    {
      "name": "UnflattenerSwitchCase",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "JumpFixer",
      "is_activated": true,
      "config": {
        "enabled_rules": [
          "CompareConstantRule1",
          "CompareConstantRule2",
          "CompareConstantRule3",
          "JaeRule1",
          "JbRule1",
          "JnzRule1",
          "JnzRule2",
          "JnzRule3",
          "JnzRule4",
          "JnzRule5",
          "JnzRule6",
          "JnzRule7",
          "JnzRule8"
        ]
      }
    }
  ]
}
```

`d810/conf/example_anel.json`:

```json
{
  "description": "Configuration to deobfuscate ANEL malware",
  "ins_rules": [
    {
      "name": "AddXor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AddXor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndGetUpperBits_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndOr_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndXor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAdd_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotOr_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_XorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule10",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule11",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule12",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule13",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule14",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule15",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule16",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule17",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule18",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule19",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule20",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule21",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule22",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule7",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule8",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule9",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegAdd_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegAdd_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegOr_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegXor_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegXor_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Neg_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Neg_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_2_variant_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOdd1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOdd2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOr1_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOr2_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetbRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule8",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1Add_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1And1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1And_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1Or_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "XorAlmost_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_NestedStuff",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_SpecialConstantRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_SpecialConstantRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "ArithmeticChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "XorChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3ConstantOptimization",
      "is_activated": true,
      "config": {
        "min_nb_opcode": 4,
        "min_nb_constant": 3
      }
    },
    {
      "name": "Z3SmodRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3lnotRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3setnzRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3setzRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "SetGlobalVariablesToZeroIfDetectedReadOnly",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "ExampleGuessingRule",
      "is_activated": true,
      "config": {
        "min_nb_var": 1,
        "max_nb_var": 3,
        "min_nb_diff_opcodes": 3,
        "max_nb_diff_opcodes": 6
      }
    }
  ],
  "blk_rules": [
    {
      "name": "Unflattener",
      "is_activated": true,
      "config": {
        "maturities": [
          "MMAT_CALLS",
          "MMAT_GLBOPT1",
          "MMAT_GLBOPT2"
        ]
      }
    },
    {
      "name": "UnflattenerFakeJump",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "JumpFixer",
      "is_activated": true,
      "config": {
        "enabled_rules": [
          "CompareConstantRule1",
          "CompareConstantRule2",
          "CompareConstantRule3",
          "JaeRule1",
          "JbRule1",
          "JnzRule1",
          "JnzRule2",
          "JnzRule3",
          "JnzRule4",
          "JnzRule5",
          "JnzRule6",
          "JnzRule7",
          "JnzRule8"
        ]
      }
    }
  ]
}
```

`d810/conf/example_libobfuscated.json`:

```json
{
  "description": "Example of configuration with multiple variants of control flow flattening (use it on libobfuscated.so)",
  "ins_rules": [
    {
      "name": "AddXor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AddXor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_HackersDelightRule_5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_OllvmRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Add_SpecialConstantRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndBnot_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndGetUpperBits_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndOr_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndXor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "And_OllvmRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAdd_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotAnd_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotOr_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "BnotXor_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Bnot_XorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule10",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule11",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule12",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule13",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule14",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule15",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule16",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule17",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule18",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule19",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule20",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule21",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule22",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule7",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule8",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "CstSimplificationRule9",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "GetIdentRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Mul_MbaRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegAdd_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegAdd_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegOr_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegXor_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "NegXor_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Neg_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Neg_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrBnot_FactorRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_HackersDelightRule_2_variant_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_OllvmRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Or_Rule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Pred0Rule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredFFRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOdd1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOdd2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOr1_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredOr2_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetbRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetnzRule8",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "PredSetzRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1Add_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1And1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1And_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1Or_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub1_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Sub_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "WeirdRule6",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor1_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "XorAlmost_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_FactorRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_4",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_HackersDelightRule_5",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_MbaRule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_NestedStuff",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_Rule_3",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_SpecialConstantRule_1",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Xor_SpecialConstantRule_2",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "AndChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "ArithmeticChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "OrChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "XorChain",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3ConstantOptimization",
      "is_activated": true,
      "config": {
        "min_nb_opcode": 4,
        "min_nb_constant": 3
      }
    },
    {
      "name": "Z3SmodRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3lnotRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3setnzRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "Z3setzRuleGeneric",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "SetGlobalVariablesToZeroIfDetectedReadOnly",
      "is_activated": true,
      "config": {}
    },
    {
      "name": "ExampleGuessingRule",
      "is_activated": true,
      "config": {
        "min_nb_var": 1,
        "max_nb_var": 3,
        "min_nb_diff_opcodes": 3,
        "max_nb_diff_opcodes": 6
      }
    }
  ],
  "blk_rules": [
    {
      "name": "Unflattener",
      "is_activated": true,
      "config": {
        "whitelisted_functions": [
          "0x1de2"
        ]
      }
    },
    {
      "name": "UnflattenerSwitchCase",
      "is_activated": true,
      "config": {
        "whitelisted_functions": [
          "0x1355"
        ]
      }
    },
    {
      "name": "UnflattenerTigressIndirect",
      "is_activated": true,
      "config": {
        "goto_table_info": {
          "0x1839": {
            "stack_table_offset": "0x40",
            "table_address": "0x5080",
            "table_nb_elt": 38
          }
        }
      }
    },
    {
      "name": "JumpFixer",
      "is_activated": true,
      "config": {
        "enabled_rules": [
          "CompareConstantRule1",
          "CompareConstantRule2",
          "CompareConstantRule3",
          "JaeRule1",
          "JbRule1",
          "JnzRule1",
          "JnzRule2",
          "JnzRule3",
          "JnzRule4",
          "JnzRule5",
          "JnzRule6",
          "JnzRule7",
          "JnzRule8"
        ]
      }
    }
  ]
}
```

`d810/conf/options.json`:

```json
{
  "erase_logs_on_reload": true,
  "generate_z3_code": true,
  "dump_intermediate_microcode": true,
  "log_dir": null,
  "configurations": [
    "default_instruction_only.json",
    "default_unflattening_ollvm.json",
    "default_unflattening_switch_case.json",
    "example_anel.json",
    "example_libobfuscated.json"
  ],
  "last_project_index": 1
}
```

`d810/emulator.py`:

```py
from __future__ import annotations
import logging
from typing import List, Union, Dict
from idaapi import getseg, get_qword, SEGPERM_WRITE
from ida_hexrays import *

from d810.utils import unsigned_to_signed, signed_to_unsigned, get_add_cf, get_add_of, get_sub_of, ror, get_parity_flag
from d810.hexrays_helpers import equal_mops_ignore_size, get_mop_index, AND_TABLE, CONTROL_FLOW_OPCODES, \
    CONDITIONAL_JUMP_OPCODES
from d810.hexrays_formatters import format_minsn_t, format_mop_t, mop_type_to_string, opcode_to_string
from d810.cfg_utils import get_block_serials_by_address
from d810.errors import EmulationException, EmulationIndirectJumpException, UnresolvedMopException, \
    WritableMemoryReadException

emulator_log = logging.getLogger('D810.emulator')


class MicroCodeInterpreter(object):
    def __init__(self, global_environment=None):
        self.global_environment = MicroCodeEnvironment() if global_environment is None else global_environment

    def _eval_instruction_and_update_environment(self, blk: mblock_t, ins: minsn_t, environment: MicroCodeEnvironment) -> Union[None, int]:
        environment.set_cur_flow(blk, ins)
        res = self._eval_instruction(ins, environment)
        if res is not None:
            if (ins.d is not None) and ins.d.t != mop_z:
                environment.assign(ins.d, res, auto_define=True)
        return res

    def _eval_instruction(self, ins: minsn_t, environment: MicroCodeEnvironment) -> Union[None, int]:
        if ins is None:
            return None
        is_flow_instruction = self._eval_control_flow_instruction(ins, environment)
        if is_flow_instruction:
            return None
        call_helper_res = self._eval_call_helper(ins, environment)
        if call_helper_res is not None:
            return call_helper_res
        if ins.opcode == m_call:
            return self._eval_call(ins, environment)
        elif ins.opcode == m_icall:
            return self._eval_call(ins, environment)
        res_mask = AND_TABLE[ins.d.size]
        if ins.opcode == m_ldx:
            return self._eval_load(ins, environment)
        elif ins.opcode == m_stx:
            return self._eval_store(ins, environment)
        elif ins.opcode == m_mov:
            return (self.eval(ins.l, environment)) & res_mask
        elif ins.opcode == m_neg:
            return (- self.eval(ins.l, environment)) & res_mask
        elif ins.opcode == m_lnot:
            return self.eval(ins.l, environment) != 0
        elif ins.opcode == m_bnot:
            return (self.eval(ins.l, environment) ^ res_mask) & res_mask
        elif ins.opcode == m_xds:
            left_value_signed = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size)
            return signed_to_unsigned(left_value_signed, ins.d.size) & res_mask
        elif ins.opcode == m_xdu:
            return (self.eval(ins.l, environment)) & res_mask
        elif ins.opcode == m_low:
            return (self.eval(ins.l, environment)) & res_mask
        elif ins.opcode == m_add:
            return (self.eval(ins.l, environment) + self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_sub:
            return (self.eval(ins.l, environment) - self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_mul:
            return (self.eval(ins.l, environment) * self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_udiv:
            return (self.eval(ins.l, environment) // self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_sdiv:
            return (self.eval(ins.l, environment) // self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_umod:
            return (self.eval(ins.l, environment) % self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_smod:
            return (self.eval(ins.l, environment) % self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_or:
            return (self.eval(ins.l, environment) | self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_and:
            return (self.eval(ins.l, environment) & self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_xor:
            return (self.eval(ins.l, environment) ^ self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_shl:
            return (self.eval(ins.l, environment) << self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_shr:
            return (self.eval(ins.l, environment) >> self.eval(ins.r, environment)) & res_mask
        elif ins.opcode == m_sar:
            res_signed = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size) >> self.eval(ins.r, environment)
            return signed_to_unsigned(res_signed, ins.d.size) & res_mask
        elif ins.opcode == m_cfadd:
            tmp = get_add_cf(self.eval(ins.l, environment), self.eval(ins.r, environment), ins.l.size)
            return tmp & res_mask
        elif ins.opcode == m_ofadd:
            tmp = get_add_of(self.eval(ins.l, environment), self.eval(ins.r, environment), ins.l.size)
            return tmp & res_mask
        elif ins.opcode == m_sets:
            left_value_signed = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size)
            res = 1 if left_value_signed < 0 else 0
            return res & res_mask
        elif ins.opcode == m_seto:
            left_value_signed = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size)
            right_value_signed = unsigned_to_signed(self.eval(ins.r, environment), ins.r.size)
            sub_overflow = get_sub_of(left_value_signed, right_value_signed, ins.l.size)
            return sub_overflow & res_mask
        elif ins.opcode == m_setnz:
            res = 1 if self.eval(ins.l, environment) != self.eval(ins.r, environment) else 0
            return res & res_mask
        elif ins.opcode == m_setz:
            res = 1 if self.eval(ins.l, environment) == self.eval(ins.r, environment) else 0
            return res & res_mask
        elif ins.opcode == m_setae:
            res = 1 if self.eval(ins.l, environment) >= self.eval(ins.r, environment) else 0
            return res & res_mask
        elif ins.opcode == m_setb:
            res = 1 if self.eval(ins.l, environment) < self.eval(ins.r, environment) else 0
            return res & res_mask
        elif ins.opcode == m_seta:
            res = 1 if self.eval(ins.l, environment) > self.eval(ins.r, environment) else 0
            return res & res_mask
        elif ins.opcode == m_setbe:
            res = 1 if self.eval(ins.l, environment) <= self.eval(ins.r, environment) else 0
            return res & res_mask
        elif ins.opcode == m_setg:
            left_value = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size)
            right_value = unsigned_to_signed(self.eval(ins.r, environment), ins.r.size)
            res = 1 if left_value > right_value else 0
            return res & res_mask
        elif ins.opcode == m_setge:
            left_value = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size)
            right_value = unsigned_to_signed(self.eval(ins.r, environment), ins.r.size)
            res = 1 if left_value >= right_value else 0
            return res & res_mask
        elif ins.opcode == m_setl:
            left_value = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size)
            right_value = unsigned_to_signed(self.eval(ins.r, environment), ins.r.size)
            res = 1 if left_value < right_value else 0
            return res & res_mask
        elif ins.opcode == m_setle:
            left_value = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size)
            right_value = unsigned_to_signed(self.eval(ins.r, environment), ins.r.size)
            res = 1 if left_value <= right_value else 0
            return res & res_mask
        elif ins.opcode == m_setp:
            res = get_parity_flag(self.eval(ins.l, environment), self.eval(ins.r, environment), ins.l.size)
            return res & res_mask
        raise EmulationException("Unsupported instruction opcode '{0}': '{1}'"
                                 .format(opcode_to_string(ins.opcode), format_minsn_t(ins)))

    @staticmethod
    def _get_blk_serial(mop: mop_t) -> int:
        if mop.t == mop_b:
            return mop.b
        raise EmulationException("Get block serial with an unsupported mop type '{0}': '{1}'"
                                 .format(mop_type_to_string(mop.t), format_mop_t(mop)))

    def _eval_conditional_jump(self, ins: minsn_t, environment: MicroCodeEnvironment) -> Union[None, int]:
        if ins.opcode not in CONDITIONAL_JUMP_OPCODES:
            return None
        if ins.opcode == m_jtbl:
            # This is not handled the same way
            return None
        cur_blk = environment.cur_blk
        direct_child_serial = cur_blk.serial + 1
        if ins.opcode == m_jcnd:
            jump_taken = self.eval(ins.l, environment) != 0
        elif ins.opcode == m_jnz:
            jump_taken = self.eval(ins.l, environment) != self.eval(ins.r, environment)
        elif ins.opcode == m_jz:
            jump_taken = self.eval(ins.l, environment) == self.eval(ins.r, environment)
        elif ins.opcode == m_jae:
            jump_taken = self.eval(ins.l, environment) >= self.eval(ins.r, environment)
        elif ins.opcode == m_jb:
            jump_taken = self.eval(ins.l, environment) < self.eval(ins.r, environment)
        elif ins.opcode == m_ja:
            jump_taken = self.eval(ins.l, environment) > self.eval(ins.r, environment)
        elif ins.opcode == m_jbe:
            jump_taken = self.eval(ins.l, environment) <= self.eval(ins.r, environment)
        elif ins.opcode == m_jg:
            left_value = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size)
            right_value = unsigned_to_signed(self.eval(ins.r, environment), ins.r.size)
            jump_taken = left_value > right_value
        elif ins.opcode == m_jge:
            left_value = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size)
            right_value = unsigned_to_signed(self.eval(ins.r, environment), ins.r.size)
            jump_taken = left_value >= right_value
        elif ins.opcode == m_jl:
            left_value = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size)
            right_value = unsigned_to_signed(self.eval(ins.r, environment), ins.r.size)
            jump_taken = left_value < right_value
        elif ins.opcode == m_jle:
            left_value = unsigned_to_signed(self.eval(ins.l, environment), ins.l.size)
            right_value = unsigned_to_signed(self.eval(ins.r, environment), ins.r.size)
            jump_taken = left_value <= right_value
        else:
            # This should never happen
            raise EmulationException("Unhandled conditional jump:  '{0}'".format(format_minsn_t(ins)))
        return self._get_blk_serial(ins.d) if jump_taken else direct_child_serial

    def _eval_control_flow_instruction(self, ins: minsn_t, environment: MicroCodeEnvironment) -> bool:
        if ins.opcode not in CONTROL_FLOW_OPCODES:
            return False
        cur_blk = environment.cur_blk
        if cur_blk is None:
            raise EmulationException("Can't evaluate control flow instruction with null block:  '{0}'"
                                     .format(format_minsn_t(ins)))

        next_blk_serial = self._eval_conditional_jump(ins, environment)
        if next_blk_serial is not None:
            next_blk = cur_blk.mba.get_mblock(next_blk_serial)
            next_ins = next_blk.head
            environment.set_next_flow(next_blk, next_ins)
            return True

        if ins.opcode == m_goto:
            next_blk_serial = self._get_blk_serial(ins.l)
        elif ins.opcode == m_jtbl:
            left_value = self.eval(ins.l, environment)
            cases = ins.r.c
            # Initialize to default case
            next_blk_serial = [x for x in cases.targets][-1]
            for possible_values, target_block_serial in zip(cases.values, cases.targets):
                for test_value in possible_values:
                    if left_value == test_value:
                        next_blk_serial = target_block_serial
                        break
        elif ins.opcode == m_ijmp:
            ijmp_dest_ea = self.eval(ins.d, environment)
            dest_block_serials = get_block_serials_by_address(environment.cur_blk.mba, ijmp_dest_ea)
            if len(dest_block_serials) == 0:
                raise EmulationIndirectJumpException("No blocks found at address {0:x}".format(ijmp_dest_ea),
                                                     ijmp_dest_ea, dest_block_serials)

            if len(dest_block_serials) > 1:
                raise EmulationIndirectJumpException("Multiple blocks at address {0:x}: {1}".format(ijmp_dest_ea,
                                                                                                    dest_block_serials),
                                                     ijmp_dest_ea, dest_block_serials)
            next_blk_serial = dest_block_serials[0]

        if next_blk_serial is None:
            return False
        next_blk = cur_blk.mba.get_mblock(next_blk_serial)
        next_ins = next_blk.head
        environment.set_next_flow(next_blk, next_ins)
        return True

    def _eval_call_helper(self, ins: minsn_t, environment: MicroCodeEnvironment) -> Union[None, int]:
        # Currently, we only support helper calls, (but end goal is to allow to hook calls)
        if ins.opcode != m_call or ins.l.t != mop_h:
            return None
        res_mask = AND_TABLE[ins.d.size]
        helper_name = ins.l.helper
        args_list = ins.d

        emulator_log.debug("Call helper for {0}".format(helper_name))
        # and we support only __ROR4__ (we should add other Hex-Rays created helper calls)
        if helper_name == "__ROR4__":
            data_1 = self.eval(args_list.f.args[0], environment)
            data_2 = self.eval(args_list.f.args[1], environment)
            return ror(data_1, data_2, 8 * args_list.f.args[0].size) & res_mask
        elif helper_name == "__readfsqword":
            return 0
        return None

    def _eval_load(self, ins: minsn_t, environment: MicroCodeEnvironment) -> Union[None, int]:
        res_mask = AND_TABLE[ins.d.size]
        if ins.opcode == m_ldx:
            load_address = self.eval(ins.r, environment)
            formatted_seg_register = format_mop_t(ins.l)
            if formatted_seg_register == "ss.2":
                stack_mop = mop_t()
                stack_mop.erase()
                stack_mop._make_stkvar(environment.cur_blk.mba, load_address)
                emulator_log.debug("Searching for stack mop {0}".format(format_mop_t(stack_mop)))
                stack_mop_value = environment.lookup(stack_mop)
                emulator_log.debug("  stack mop {0} value : {1}".format(format_mop_t(stack_mop), stack_mop_value))
                return stack_mop_value & res_mask
            else:
                mem_seg = getseg(load_address)
                seg_perm = mem_seg.perm
                if (seg_perm & SEGPERM_WRITE) != 0:
                    raise WritableMemoryReadException("ldx {0:x} (writable -> return None)".format(load_address))
                else:
                    memory_value = get_qword(load_address)
                    emulator_log.debug("ldx {0:x} (non writable -> return {1:x})"
                                       .format(load_address, memory_value & res_mask))
                    return memory_value & res_mask

    def _eval_store(self, ins: minsn_t, environment: MicroCodeEnvironment) -> Union[None, int]:
        # TODO: implement
        emulator_log.warning("Evaluation of {0} not implemented: bypassing".format(format_minsn_t(ins)))
        return None

    def _eval_call(self, ins: minsn_t, environment: MicroCodeEnvironment) -> Union[None, int]:
        # TODO: implement
        emulator_log.warning("Evaluation of {0} not implemented: bypassing".format(format_minsn_t(ins)))
        return None

    def eval(self, mop: mop_t, environment: MicroCodeEnvironment) -> Union[None, int]:
        if mop.t == mop_n:
            return mop.nnn.value
        elif mop.t in [mop_r, mop_S]:
            return environment.lookup(mop)
        elif mop.t == mop_d:
            return self._eval_instruction(mop.d, environment)
        elif mop.t == mop_a:
            if mop.a.t == mop_v:
                emulator_log.debug("Reading a mop_a '{0}' -> {1:x}".format(format_mop_t(mop), mop.a.g))
                return mop.a.g
            elif mop.a.t == mop_S:
                emulator_log.debug("Reading a mop_a '{0}' -> {1:x}".format(format_mop_t(mop), mop.a.s.off))
                return mop.a.s.off
            raise UnresolvedMopException("Calling get_cst with unsupported mop type {0} - {1}: '{2}'"
                                         .format(mop.t, mop.a.t, format_mop_t(mop)))
        elif mop.t == mop_v:
            mem_seg = getseg(mop.g)
            seg_perm = mem_seg.perm
            if (seg_perm & SEGPERM_WRITE) != 0:
                emulator_log.debug("Reading a (writable) mop_v {0}".format(format_mop_t(mop)))
                return environment.lookup(mop)
            else:
                memory_value = get_qword(mop.g)
                emulator_log.debug("Reading a mop_v {0:x} (non writable -> return {1:x})".format(mop.g, memory_value))
                return mop.g
        raise EmulationException("Unsupported mop type '{0}': '{1}'"
                                 .format(mop_type_to_string(mop.t), format_mop_t(mop)))

    def eval_instruction(self, blk: mblock_t, ins: minsn_t, environment: Union[None, MicroCodeEnvironment] = None,
                         raise_exception: bool = False) -> bool:
        try:
            if environment is None:
                environment = self.global_environment
            emulator_log.info("Evaluating microcode instruction : '{0}'".format(format_minsn_t(ins)))
            if ins is None:
                return False
            self._eval_instruction_and_update_environment(blk, ins, environment)
            return True
        except EmulationException as e:
            emulator_log.warning("Can't evaluate instruction: '{0}': {1}".format(format_minsn_t(ins), e))
            if raise_exception:
                raise e
        except Exception as e:
            emulator_log.warning("Error during evaluation of: '{0}': {1}".format(format_minsn_t(ins), e))
            if raise_exception:
                raise e
        return False

    def eval_mop(self, mop: mop_t, environment: Union[None, MicroCodeEnvironment] = None,
                 raise_exception: bool = False) -> Union[None, int]:
        try:
            if environment is None:
                environment = self.global_environment
            res = self.eval(mop, environment)
            return res
        except EmulationException as e:
            emulator_log.warning("Can't get constant mop value: '{0}': {1}".format(format_mop_t(mop), e))
            if raise_exception:
                raise e
            else:
                return None
        except Exception as e:
            emulator_log.error("Unexpected exception while computing constant mop value: '{0}': {1}".format(format_mop_t(mop), e))
            if raise_exception:
                raise e
            else:
                return None


class MopMapping(object):
    def __init__(self):
        self.mops = []
        self.mops_values = []

    def __setitem__(self, mop: mop_t, mop_value: int):
        mop_index = get_mop_index(mop, self.mops)
        mop_value &= AND_TABLE[mop.size]
        if mop_index != -1:
            self.mops_values[mop_index] = mop_value
            return
        self.mops.append(mop)
        self.mops_values.append(mop_value)

    def __getitem__(self, mop: mop_t) -> int:
        mop_index = get_mop_index(mop, self.mops)
        if mop_index == -1:
            raise KeyError
        return self.mops_values[mop_index]

    def __len__(self):
        return len(self.mops)

    def __delitem__(self, mop: mop_t):
        mop_index = get_mop_index(mop, self.mops)
        if mop_index == -1:
            raise KeyError
        del self.mops[mop_index]
        del self.mops_values[mop_index]

    def clear(self):
        self.mops = []
        self.mops_values = []

    def copy(self):
        new_mapping = MopMapping()
        for mop, mop_value in self.items():
            new_mapping[mop] = mop_value
        return new_mapping

    def has_key(self, mop: mop_t):
        mop_index = get_mop_index(mop, self.mops)
        return mop_index != -1

    def keys(self) -> List[mop_t]:
        return self.mops

    def values(self) -> List[int]:
        return self.mops_values

    def items(self):
        return [(x, y) for x, y in zip(self.mops, self.mops_values)]

    def __contains__(self, mop: mop_t):
        return self.has_key(mop)


class MicroCodeEnvironment(object):
    def __init__(self, parent: Union[None, MicroCodeEnvironment] = None):
        self.parent = parent
        self.mop_r_record = MopMapping()
        self.mop_S_record = MopMapping()

        self.cur_blk = None
        self.cur_ins = None
        self.next_blk = None
        self.next_ins = None

    def items(self):
        return [x for x in self.mop_r_record.items() + self.mop_S_record.items()]

    def get_copy(self, copy_parent=True) -> MicroCodeEnvironment:
        parent_copy = self.parent
        if parent_copy is not None and copy_parent:
            parent_copy = self.parent.get_copy(copy_parent=True)
        new_env = MicroCodeEnvironment(parent_copy)
        for mop, mop_value in self.mop_r_record.items():
            new_env.define(mop, mop_value)
        for mop, mop_value in self.mop_S_record.items():
            new_env.define(mop, mop_value)
        new_env.cur_blk = self.cur_blk
        new_env.cur_ins = self.cur_ins
        new_env.next_blk = self.next_blk
        new_env.next_ins = self.next_ins
        return new_env

    def set_cur_flow(self, cur_blk: mblock_t, cur_ins: minsn_t):
        self.cur_blk = cur_blk
        self.cur_ins = cur_ins
        self.next_blk = cur_blk
        if self.cur_ins is None:
            self.next_blk = self.cur_blk.mba.get_mblock(self.cur_blk.serial + 1)
            self.next_ins = self.next_blk.head
        else:
            self.next_ins = self.cur_ins.next
            if self.next_ins is None:
                self.next_blk = self.cur_blk.mba.get_mblock(self.cur_blk.serial + 1)
                self.next_ins = self.next_blk.head
        emulator_log.debug(
            "Setting next block {0} and next ins {1}".format(self.next_blk.serial, format_minsn_t(self.next_ins)))

    def set_next_flow(self, next_blk: mblock_t, next_ins: minsn_t):
        self.next_blk = next_blk
        self.next_ins = next_ins

    def define(self, mop: mblock_t, value: int) -> int:
        if mop.t == mop_r:
            self.mop_r_record[mop] = value
            return value
        elif mop.t == mop_S:
            self.mop_S_record[mop] = value
            return value
        raise EmulationException("Defining an unsupported mop type '{0}': '{1}'"
                                 .format(mop_type_to_string(mop.t), format_mop_t(mop)))

    def _lookup_mop(self, searched_mop: mop_t, mop_value_dict: Dict[mop_t, int], new_mop_value: Union[None, int] = None,
                    auto_define=True, raise_exception=True) -> int:
        for known_mop, mop_value in mop_value_dict.items():
            if equal_mops_ignore_size(searched_mop, known_mop):
                if new_mop_value is not None:
                    mop_value_dict[searched_mop] = new_mop_value
                    return new_mop_value
                return mop_value
        if (new_mop_value is not None) and auto_define:
            self.define(searched_mop, new_mop_value)
            return new_mop_value
        if raise_exception:
            raise EmulationException("Variable '{0}' is not defined".format(format_mop_t(searched_mop)))
        else:
            return None

    def lookup(self, mop: mop_t, raise_exception=True) -> int:
        if mop.t == mop_r:
            return self._lookup_mop(mop, self.mop_r_record, raise_exception=raise_exception)
        elif mop.t == mop_S:
            return self._lookup_mop(mop, self.mop_S_record, raise_exception=raise_exception)

    def assign(self, mop: mop_t, value: int, auto_define=True) -> int:
        if mop.t == mop_r:
            return self._lookup_mop(mop, self.mop_r_record, value, auto_define)
        elif mop.t == mop_S:
            return self._lookup_mop(mop, self.mop_S_record, value, auto_define)
        raise EmulationException("Assigning an unsupported mop type '{0}': '{1}'"
                                 .format(mop_type_to_string(mop.t), format_mop_t(mop)))

```

`d810/errors.py`:

```py
class D810Exception(Exception):
    pass


class AstException(D810Exception):
    pass


class AstEvaluationException(AstException):
    pass


class D810Z3Exception(D810Exception):
    pass


class ControlFlowException(D810Exception):
    pass


class EmulationException(D810Exception):
    pass


class EmulationIndirectJumpException(EmulationException):
    def __init__(self, message, dest_ea, dest_serial_list):
        super().__init__(message)
        self.dest_ea = dest_ea
        self.dest_serial_list = dest_serial_list


class UnresolvedMopException(EmulationException):
    pass


class WritableMemoryReadException(EmulationException):
    pass


class UnsupportedInstructionException(EmulationException):
    pass

```

`d810/hexrays_formatters.py`:

```py
import os
import logging
from typing import List

from d810.hexrays_helpers import OPCODES_INFO, MATURITY_TO_STRING_DICT, STRING_TO_MATURITY_DICT, MOP_TYPE_TO_STRING_DICT
from ida_hexrays import minsn_t, mop_t, vd_printer_t, mbl_array_t


logger = logging.getLogger('D810.helper')


def format_minsn_t(ins: minsn_t) -> str:
    if ins is None:
        return "minsn_t is None"

    tmp = ins._print()
    pp_ins = "".join([c if 0x20 <= ord(c) <= 0x7e else "" for c in tmp])
    return pp_ins


def format_mop_t(mop_in: mop_t) -> str:
    if mop_in is None:
        return "mop_t is None"
    if mop_in.t > 15:
        # To avoid error 50581
        return "Unknown mop type {0}".format(mop_in.t)
    return mop_in.dstr()


def format_mop_list(mop_list: List[mop_t]) -> str:
    return ", ".join([format_mop_t(x) for x in mop_list])


def maturity_to_string(maturity_level: int) -> str:
    return MATURITY_TO_STRING_DICT.get(maturity_level, "Unknown maturity: {0}".format(maturity_level))


def string_to_maturity(maturity_string: str) -> int:
    return STRING_TO_MATURITY_DICT.get(maturity_string)


def mop_type_to_string(mop_type: int) -> str:
    return MOP_TYPE_TO_STRING_DICT.get(mop_type, "Unknown mop type: {0}".format(mop_type))


def opcode_to_string(opcode) -> str:
    try:
        return OPCODES_INFO[opcode]["name"]
    except KeyError:
        return "Unknown opcode: {0}".format(opcode)


class mba_printer(vd_printer_t):
    def __init__(self):
        vd_printer_t.__init__(self)
        self.mc = []

    def get_mc(self):
        return self.mc

    def _print(self, indent, line):
        self.mc.append("".join([c if 0x20 <= ord(c) <= 0x7e else "" for c in line])+"\n")
        return 1


class block_printer(vd_printer_t):
    def __init__(self):
        vd_printer_t.__init__(self)
        self.block_ins = []

    def get_block_mc(self):
        return "\n".join(self.block_ins)

    def _print(self, indent, line):
        self.block_ins.append("".join([c if 0x20 <= ord(c) <= 0x7e else "" for c in line]))
        return 1


def write_mc_to_file(mba: mbl_array_t, filename: str, mba_flags: int = 0) -> bool:
    if not mba:
        return False

    vp = mba_printer()
    mba.set_mba_flags(mba_flags)
    mba._print(vp)

    with open(filename, "w") as f:
        f.writelines(vp.get_mc())
    return True


def dump_microcode_for_debug(mba: mbl_array_t, log_dir_path: str, name: str = ""):
    mc_filename = os.path.join(log_dir_path, "{0:x}_maturity_{1}_{2}.log".format(mba.entry_ea, mba.maturity, name))
    logger.info("Dumping microcode in file {0}...".format(mc_filename))
    write_mc_to_file(mba, mc_filename)

```

`d810/hexrays_helpers.py`:

```py
from ida_hexrays import *
from typing import List, Tuple
from ida_hexrays import mop_d, mop_n, m_stx, m_ldx, m_xdu, m_xds, mop_z, mop_fn, mop_S, mop_v, EQ_IGNSIZE, mop_b, \
    mop_r, mop_f, mop_l, mop_a, mop_h, mop_str, mop_c, mop_p, mop_sc


OPCODES_INFO = {
    m_nop: {"name": "nop", "nb_operands": 0, "is_commutative": True},
    m_stx: {"name": "stx", "nb_operands": 2, "is_commutative": False},
    m_ldx: {"name": "ldx", "nb_operands": 2, "is_commutative": False},
    m_ldc: {"name": "ldc", "nb_operands": 1, "is_commutative": False},
    m_mov: {"name": "mov", "nb_operands": 1, "is_commutative": False, "symbol": ""},
    m_neg: {"name": "neg", "nb_operands": 1, "is_commutative": False, "symbol": "-"},
    m_lnot: {"name": "lnot", "nb_operands": 1, "is_commutative": False, "symbol": "!"},
    m_bnot: {"name": "bnot", "nb_operands": 1, "is_commutative": False, "symbol": "~"},
    m_xds: {"name": "xds", "nb_operands": 1, "is_commutative": False, "symbol": "xds"},
    m_xdu: {"name": "xdu", "nb_operands": 1, "is_commutative": False, "symbol": "xdu"},
    m_low: {"name": "low", "nb_operands": 1, "is_commutative": False, "symbol": "low"},
    m_high: {"name": "high", "nb_operands": 1, "is_commutative": False, "symbol": "high"},
    m_add: {"name": "add", "nb_operands": 2, "is_commutative": True, "symbol": "+"},
    m_sub: {"name": "sub", "nb_operands": 2, "is_commutative": False, "symbol": "-"},
    m_mul: {"name": "mul", "nb_operands": 2, "is_commutative": True, "symbol": "*"},
    m_udiv: {"name": "udiv", "nb_operands": 2, "is_commutative": False, "symbol": "UDiv"},
    m_sdiv: {"name": "sdiv", "nb_operands": 2, "is_commutative": False, "symbol": "/"},
    m_umod: {"name": "umod", "nb_operands": 2, "is_commutative": False, "symbol": "URem"},
    m_smod: {"name": "smod", "nb_operands": 2, "is_commutative": False, "symbol": "%"},
    m_or: {"name": "or", "nb_operands": 2, "is_commutative": True, "symbol": "|"},
    m_and: {"name": "and", "nb_operands": 2, "is_commutative": True, "symbol": "&"},
    m_xor: {"name": "xor", "nb_operands": 2, "is_commutative": True, "symbol": "^"},
    m_shl: {"name": "shl", "nb_operands": 2, "is_commutative": False, "symbol": "<<"},
    m_shr: {"name": "shr", "nb_operands": 2, "is_commutative": False, "symbol": "LShR"},
    m_sar: {"name": "sar", "nb_operands": 2, "is_commutative": False, "symbol": ">>"},
    m_cfadd: {"name": "cfadd", "nb_operands": 2, "is_commutative": True},
    m_ofadd: {"name": "ofadd", "nb_operands": 2, "is_commutative": True},
    m_cfshl: {"name": "cfshl", "nb_operands": 2, "is_commutative": False},
    m_cfshr: {"name": "cfshr", "nb_operands": 2, "is_commutative": False},
    m_sets: {"name": "sets", "nb_operands": 2, "is_commutative": False},
    m_seto: {"name": "seto", "nb_operands": 2, "is_commutative": False},
    m_setp: {"name": "setp", "nb_operands": 2, "is_commutative": False},
    m_setnz: {"name": "setnz", "nb_operands": 2, "is_commutative": True, "symbol": "!="},
    m_setz: {"name": "setz", "nb_operands": 2, "is_commutative": True, "symbol": "=="},
    m_seta: {"name": "seta", "nb_operands": 2, "is_commutative": False, "symbol": ">"},
    m_setae: {"name": "setae", "nb_operands": 2, "is_commutative": False, "symbol": ">="},
    m_setb: {"name": "setb", "nb_operands": 2, "is_commutative": False, "symbol": "<"},
    m_setbe: {"name": "setbe", "nb_operands": 2, "is_commutative": False, "symbol": "<="},
    m_setg: {"name": "setg", "nb_operands": 2, "is_commutative": False, "symbol": "UGT"},
    m_setge: {"name": "setge", "nb_operands": 2, "is_commutative": False, "symbol": "UGE"},
    m_setl: {"name": "setl", "nb_operands": 2, "is_commutative": False, "symbol": "ULT"},
    m_setle: {"name": "setle", "nb_operands": 2, "is_commutative": False, "symbol": "ULE"},
    m_jcnd: {"name": "jcnd", "nb_operands": 1, "is_commutative": False},
    m_jnz: {"name": "jnz", "nb_operands": 2, "is_commutative": True},
    m_jz: {"name": "jz", "nb_operands": 2, "is_commutative": True},
    m_jae: {"name": "jae", "nb_operands": 2, "is_commutative": False},
    m_jb: {"name": "jb", "nb_operands": 2, "is_commutative": False},
    m_ja: {"name": "ja", "nb_operands": 2, "is_commutative": False},
    m_jbe: {"name": "jbe", "nb_operands": 2, "is_commutative": False},
    m_jg: {"name": "jg", "nb_operands": 2, "is_commutative": False},
    m_jge: {"name": "jge", "nb_operands": 2, "is_commutative": False},
    m_jl: {"name": "jl", "nb_operands": 2, "is_commutative": False},
    m_jle: {"name": "jle", "nb_operands": 2, "is_commutative": False},
    m_jtbl: {"name": "jtbl", "nb_operands": 2, "is_commutative": False},
    m_ijmp: {"name": "ijmp", "nb_operands": 2, "is_commutative": False},
    m_goto: {"name": "goto", "nb_operands": 1, "is_commutative": False},
    m_call: {"name": "call", "nb_operands": 2, "is_commutative": False},
    m_icall: {"name": "icall", "nb_operands": 2, "is_commutative": False},
    m_ret: {"name": "ret", "nb_operands": 0, "is_commutative": False},
    m_push: {"name": "push", "nb_operands": 0, "is_commutative": False},
    m_pop: {"name": "pop", "nb_operands": 0, "is_commutative": False},
    m_und: {"name": "und", "nb_operands": 0, "is_commutative": False},
    m_ext: {"name": "ext", "nb_operands": 0, "is_commutative": False},
    m_f2i: {"name": "f2i", "nb_operands": 2, "is_commutative": False},
    m_f2u: {"name": "f2u", "nb_operands": 2, "is_commutative": False},
    m_i2f: {"name": "i2f", "nb_operands": 2, "is_commutative": False},
    m_u2f: {"name": "u2f", "nb_operands": 2, "is_commutative": False},
    m_f2f: {"name": "f2f", "nb_operands": 2, "is_commutative": False},
    m_fneg: {"name": "fneg", "nb_operands": 2, "is_commutative": False},
    m_fadd: {"name": "fadd", "nb_operands": 2, "is_commutative": True},
    m_fsub: {"name": "fsub", "nb_operands": 2, "is_commutative": False},
    m_fmul: {"name": "fmul", "nb_operands": 2, "is_commutative": True},
    m_fdiv: {"name": "fdiv", "nb_operands": 2, "is_commutative": False},
}


MATURITY_TO_STRING_DICT = {
    MMAT_ZERO: "MMAT_ZERO",
    MMAT_GENERATED: "MMAT_GENERATED",
    MMAT_PREOPTIMIZED: "MMAT_PREOPTIMIZED",
    MMAT_LOCOPT: "MMAT_LOCOPT",
    MMAT_CALLS: "MMAT_CALLS",
    MMAT_GLBOPT1: "MMAT_GLBOPT1",
    MMAT_GLBOPT2: "MMAT_GLBOPT2",
    MMAT_GLBOPT3: "MMAT_GLBOPT3",
    MMAT_LVARS: "MMAT_LVARS",
}
STRING_TO_MATURITY_DICT = {v: k for k, v in MATURITY_TO_STRING_DICT.items()}

MOP_TYPE_TO_STRING_DICT = {
    mop_z: "mop_z",
    mop_r: "mop_r",
    mop_n: "mop_n",
    mop_str: "mop_str",
    mop_d: "mop_d",
    mop_S: "mop_S",
    mop_v: "mop_v",
    mop_b: "mop_b",
    mop_f: "mop_f",
    mop_l: "mop_l",
    mop_a: "mop_a",
    mop_h: "mop_h",
    mop_c: "mop_c",
    mop_fn: "mop_fn",
    mop_p: "mop_p",
    mop_sc: "mop_sc",
}

Z3_SPECIAL_OPERANDS = ["UDiv", "URem", "LShR", "UGT", "UGE", "ULT", "ULE"]

BOOLEAN_OPCODES = [m_lnot, m_bnot, m_or, m_and, m_xor]
ARITHMETICAL_OPCODES = [m_neg, m_add, m_sub, m_mul, m_udiv, m_sdiv, m_umod, m_smod]
BIT_OPERATIONS_OPCODES = [m_shl, m_shr, m_sar, m_mov, m_xds, m_xdu, m_low, m_high]
CHECK_OPCODES = [m_sets, m_seto, m_setp, m_setnz, m_setz, m_seta, m_setae, m_setb,
                 m_setbe, m_setg, m_setge, m_setl, m_setle]

MBA_RELATED_OPCODES = BOOLEAN_OPCODES + ARITHMETICAL_OPCODES + BIT_OPERATIONS_OPCODES + CHECK_OPCODES

CONDITIONAL_JUMP_OPCODES = [m_jcnd, m_jnz, m_jz, m_jae, m_ja, m_jb, m_jbe, m_jg, m_jge, m_jl, m_jle, m_jtbl]
UNCONDITIONAL_JUMP_OPCODES = [m_goto, m_ijmp]
CONTROL_FLOW_OPCODES = CONDITIONAL_JUMP_OPCODES + UNCONDITIONAL_JUMP_OPCODES

MINSN_TO_AST_FORBIDDEN_OPCODES = CONTROL_FLOW_OPCODES + [m_ret, m_nop, m_stx, m_push, m_pop, m_und, m_ext, m_call]

SUB_TABLE = {1: 0x100, 2: 0x10000, 4: 0x100000000, 8: 0x10000000000000000, 16: 0x100000000000000000000000000000000}
AND_TABLE = {1: 0xff, 2: 0xffff, 4: 0xffffffff, 8: 0xffffffffffffffff, 16: 0xffffffffffffffffffffffffffffffff}
MSB_TABLE = {1: 0x80, 2: 0x8000, 4: 0x80000000, 8: 0x8000000000000000, 16: 0x80000000000000000000000000000000}


# Hex-Rays mop equality checking
def equal_bnot_cst(lo: mop_t, ro: mop_t, mop_size=None) -> bool:
    if (lo.t != mop_n) or (ro.t != mop_n):
        return False
    if lo.size != ro.size:
        return False
    if mop_size is None:
        mop_size = lo.size
    return lo.nnn.value ^ ro.nnn.value == AND_TABLE[mop_size]


def equal_bnot_mop(lo: mop_t, ro: mop_t, test_two_sides=True) -> bool:
    if lo.t == mop_n:
        return equal_bnot_cst(lo, ro)

    # We first check for a bnot operand
    if (lo.t == mop_d) and lo.d.opcode == m_bnot:
        if equal_mops_ignore_size(lo.d.l, ro):
            return True

    # Otherwise Hexrays may have optimized using ~(-x) = x - 1
    if (lo.t == mop_d) and lo.d.opcode == m_neg:
        if (ro.t == mop_d) and ro.d.opcode == m_sub:
            if ro.d.r.t == mop_n and ro.d.r.nnn.value == 1:
                if equal_mops_ignore_size(ro.d.l, lo.d.l):
                    return True

    if (lo.t == mop_d) and lo.d.opcode == m_xds:
        if equal_bnot_mop(lo.d.l, ro):
            return True

    if test_two_sides:
        return equal_bnot_mop(ro, lo, test_two_sides=False)
    return False


def equal_ignore_msb_cst(lo: mop_t, ro: mop_t) -> bool:
    if (lo.t != mop_n) or (ro.t != mop_n):
        return False
    if lo.size != ro.size:
        return False
    mask = AND_TABLE[lo.size] ^ MSB_TABLE[lo.size]
    return lo.nnn.value & mask == ro.nnn.value & mask


def equal_mops_bypass_xdu(lo: mop_t, ro: mop_t) -> bool:
    if (lo is None) or (ro is None):
        return False
    if (lo.t == mop_d) and (lo.d.opcode == m_xdu):
        return equal_mops_bypass_xdu(lo.d.l, ro)
    if (ro.t == mop_d) and (ro.d.opcode == m_xdu):
        return equal_mops_bypass_xdu(lo, ro.d.l)
    return equal_mops_ignore_size(lo, ro)


def equal_mops_ignore_size(lo: mop_t, ro: mop_t) -> bool:
    if (lo is None) or (ro is None):
        return False
    if lo.t != ro.t:
        return False
    if lo.t == mop_z:
        return True
    elif lo.t == mop_fn:
        return lo.fpc == ro.fpc
    elif lo.t == mop_n:
        return lo.nnn.value == ro.nnn.value
    elif lo.t == mop_S:
        if lo.s == ro.s:
            return True
        if lo.s.off == ro.s.off:
            # Is it right?
            return True
        return False
    elif lo.t == mop_v:
        return lo.g == ro.g
    elif lo.t == mop_d:
        return lo.d.equal_insns(ro.d, EQ_IGNSIZE)
        # return lo.d.equal_insns(ro.d, EQ_IGNSIZE | EQ_IGNCODE)
    elif lo.t == mop_b:
        return lo.b == ro.b
    elif lo.t == mop_r:
        return lo.r == ro.r
    elif lo.t == mop_f:
        return False
    elif lo.t == mop_l:
        return lo.l == ro.l
    elif lo.t == mop_a:
        if lo.a.insize != ro.a.insize:
            return False
        if lo.a.outsize != ro.a.outsize:
            return False
        return equal_mops_ignore_size(lo.a, ro.a)
    elif lo.t == mop_h:
        return ro.helper == lo.helper
    elif lo.t == mop_str:
        return ro.cstr == lo.cstr
    elif lo.t == mop_c:
        return ro.c == lo.c
    elif lo.t == mop_p:
        return equal_mops_ignore_size(lo.pair.lop, ro.pair.lop) and equal_mops_ignore_size(lo.pair.hop, ro.pair.hop)
    elif lo.t == mop_sc:
        return False
    else:
        return False


def is_check_mop(lo: mop_t) -> bool:
    if lo.t != mop_d:
        return False
    if lo.d.opcode in CHECK_OPCODES:
        return True
    if lo.d.opcode in [m_xds, m_xdu]:
        return is_check_mop(lo.d.l)
    return False


def extract_num_mop(ins: minsn_t) -> Tuple[mop_t, mop_t]:
    num_mop = None
    other_mop = None

    if ins.l.t == mop_n:
        num_mop = ins.l
        other_mop = ins.r
    if ins.r.t == mop_n:
        num_mop = ins.r
        other_mop = ins.l
    return [num_mop, other_mop]


def check_ins_mop_size_are_ok(ins: minsn_t) -> bool:
    """
    This function can be used to check if a created instruction has consistent mop size
    Use it to avoid Hex-Rays decompilation errors when replacing instructions

    :param ins:
    :return:
    """
    ins_dest_size = ins.d.size
    if ins.opcode in [m_stx, m_ldx]:
        if ins.r.t == mop_d:
            if not check_ins_mop_size_are_ok(ins.r.d):
                return False
        return True

    if ins.opcode in [m_xdu, m_xds, m_low, m_high]:
        if (ins.l.t == mop_d) and (not check_ins_mop_size_are_ok(ins.l.d)):
            return False
        return True

    if ins.opcode in [m_sar, m_shr, m_shl]:
        if ins.l.size != ins_dest_size:
            return False
        if (ins.l.t == mop_d) and (not check_ins_mop_size_are_ok(ins.l.d)):
            return False
        if (ins.r.t == mop_d) and (not check_ins_mop_size_are_ok(ins.r.d)):
            return False
        return True

    if ins.opcode in CHECK_OPCODES:
        if (ins.l.t == mop_d) and (not check_ins_mop_size_are_ok(ins.l.d)):
            return False
        if (ins.r.t == mop_d) and (not check_ins_mop_size_are_ok(ins.r.d)):
            return False
        return True

    if ins.l is not None:
        if ins.l.size != ins_dest_size:
            return False
        if ins.l.t == mop_d and (not check_ins_mop_size_are_ok(ins.l.d)):
            return False

    if ins.r is not None and ins.r.t != mop_z:
        if ins.r.size != ins_dest_size:
            return False
        if ins.r.t == mop_d and (not check_ins_mop_size_are_ok(ins.r.d)):
            return False
    return True


def check_mop_is_result_of(lo: mop_t, mc) -> bool:
    if lo.t != mop_d:
        return False
    return lo.d.opcode == mc


def extract_by_opcode_type(ins: minsn_t, mc) -> Tuple[mop_t, mop_t]:
    if check_mop_is_result_of(ins.l, mc):
        return [ins.l, ins.r]
    if check_mop_is_result_of(ins.r, mc):
        return [ins.r, ins.l]
    return [None, None]


def check_ins_have_same_operands(ins1: minsn_t, ins2: minsn_t, ignore_order=False) -> bool:
    if equal_mops_ignore_size(ins1.l, ins2.l) and equal_mops_ignore_size(ins1.r, ins2.r):
        return True
    if not ignore_order:
        return False
    return equal_mops_ignore_size(ins1.l, ins2.r) and equal_mops_ignore_size(ins1.r, ins2.l)


def get_mop_index(searched_mop: mop_t, mop_list) -> int:
    for i, test_mop in enumerate(mop_list):
        if equal_mops_ignore_size(searched_mop, test_mop):
            return i
    return -1


def append_mop_if_not_in_list(mop: mop_t, mop_list) -> bool:
    mop_index = get_mop_index(mop, mop_list)
    if mop_index == -1:
        mop_list.append(mop)
        return True
    return False


def get_blk_index(searched_blk: mblock_t, blk_list: List[mblock_t]) -> int:
    blk_serial_list = [blk.serial for blk in blk_list]
    try:
        return blk_serial_list.index(searched_blk.serial)
    except ValueError:
        return -1

```

`d810/hexrays_hooks.py`:

```py
from __future__ import annotations
import logging

from ida_hexrays import *

from d810.optimizers.instructions import PatternOptimizer, ChainOptimizer, Z3Optimizer, EarlyOptimizer, \
    InstructionAnalyzer
from d810.hexrays_helpers import check_ins_mop_size_are_ok, append_mop_if_not_in_list
from d810.hexrays_formatters import format_minsn_t, format_mop_t, maturity_to_string, mop_type_to_string, \
    dump_microcode_for_debug
from d810.errors import D810Exception
from d810.z3_utils import log_z3_instructions

from typing import TYPE_CHECKING, List
if TYPE_CHECKING:
    from d810.manager import D810Manager
    from d810.optimizers.instructions.handler import InstructionOptimizer, InstructionOptimizationRule
    from d810.optimizers.flow.handler import FlowOptimizationRule

main_logger = logging.getLogger('D810')
optimizer_logger = logging.getLogger('D810.optimizer')
helper_logger = logging.getLogger('D810.helper')

DEFAULT_OPTIMIZATION_PATTERN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]
DEFAULT_OPTIMIZATION_CHAIN_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]
DEFAULT_OPTIMIZATION_Z3_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]
DEFAULT_OPTIMIZATION_EARLY_MATURITIES = [MMAT_GENERATED, MMAT_PREOPTIMIZED]
DEFAULT_ANALYZER_MATURITIES = [MMAT_PREOPTIMIZED, MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]


class InstructionDefUseCollector(mop_visitor_t):
    def __init__(self):
        super().__init__()
        self.unresolved_ins_mops = []
        self.memory_unresolved_ins_mops = []
        self.target_mops = []

    def visit_mop(self, op: mop_t, op_type: int, is_target: bool):
        if is_target:
            append_mop_if_not_in_list(op, self.target_mops)
        else:
            # TODO whatever the case, in the end we will always return 0. May be this code can be better optimized.
            # TODO handle other special case (e.g. ldx ins, ...)
            if op.t == mop_S:
                append_mop_if_not_in_list(op, self.unresolved_ins_mops)
            elif op.t == mop_r:
                append_mop_if_not_in_list(op, self.unresolved_ins_mops)
            elif op.t == mop_v:
                append_mop_if_not_in_list(op, self.memory_unresolved_ins_mops)
            elif op.t == mop_a:
                if op.a.t == mop_v:
                    return 0
                elif op.a.t == mop_S:
                    return 0
                helper_logger.warning("Calling visit_mop with unsupported mop type {0} - {1}: '{2}'"
                                      .format(mop_type_to_string(op.t), mop_type_to_string(op.a.t), format_mop_t(op)))
                return 0
            elif op.t == mop_n:
                return 0
            elif op.t == mop_d:
                return 0
            elif op.t == mop_h:
                return 0
            elif op.t == mop_b:
                return 0
            else:
                helper_logger.warning("Calling visit_mop with unsupported mop type {0}: '{1}'"
                                      .format(mop_type_to_string(op.t), format_mop_t(op)))
        return 0


class InstructionOptimizerManager(optinsn_t):
    def __init__(self, manager: D810Manager):
        optimizer_logger.debug("Initializing {0}...".format(self.__class__.__name__))
        super().__init__()
        self.manager = manager
        self.instruction_visitor = InstructionVisitorManager(self)
        self._last_optimizer_tried = None
        self.current_maturity = None
        self.current_blk_serial = None
        self.generate_z3_code = False
        self.dump_intermediate_microcode = False

        self.instruction_optimizers = []
        self.optimizer_usage_info = {}
        self.add_optimizer(PatternOptimizer(DEFAULT_OPTIMIZATION_PATTERN_MATURITIES, log_dir=self.manager.log_dir))
        self.add_optimizer(ChainOptimizer(DEFAULT_OPTIMIZATION_CHAIN_MATURITIES, log_dir=self.manager.log_dir))
        self.add_optimizer(Z3Optimizer(DEFAULT_OPTIMIZATION_Z3_MATURITIES, log_dir=self.manager.log_dir))
        self.add_optimizer(EarlyOptimizer(DEFAULT_OPTIMIZATION_EARLY_MATURITIES, log_dir=self.manager.log_dir))
        self.analyzer = InstructionAnalyzer(DEFAULT_ANALYZER_MATURITIES, log_dir=self.manager.log_dir)

    def func(self, blk: mblock_t, ins: minsn_t) -> bool:
        self.log_info_on_input(blk, ins)
        try:
            optimization_performed = self.optimize(blk, ins)

            if not optimization_performed:
                optimization_performed = ins.for_all_insns(self.instruction_visitor)

            if optimization_performed:
                ins.optimize_solo()

                if blk is not None:
                    blk.mark_lists_dirty()
                    blk.mba.verify(True)

            return optimization_performed
        except RuntimeError as e:
            optimizer_logger.error("RuntimeError while optimizing ins {0} with {1}: {2}"
                                   .format(format_minsn_t(ins), self._last_optimizer_tried, e))
        except D810Exception as e:
            optimizer_logger.error("D810Exception while optimizing ins {0} with {1}: {2}"
                                   .format(format_minsn_t(ins), self._last_optimizer_tried, e))
        return False

    def reset_rule_usage_statistic(self):
        self.optimizer_usage_info = {}
        for ins_optimizer in self.instruction_optimizers:
            self.optimizer_usage_info[ins_optimizer.name] = 0
            ins_optimizer.reset_rule_usage_statistic()

    def show_rule_usage_statistic(self):
        for optimizer_name, optimizer_nb_match in self.optimizer_usage_info.items():
            if optimizer_nb_match > 0:
                main_logger.info("Instruction optimizer '{0}' has been used {1} times"
                                 .format(optimizer_name, optimizer_nb_match))
        for ins_optimizer in self.instruction_optimizers:
            ins_optimizer.show_rule_usage_statistic()

    def log_info_on_input(self, blk: mblock_t, ins: minsn_t):
        if blk is None:
            return
        mba: mbl_array_t = blk.mba

        if (mba is not None) and (mba.maturity != self.current_maturity):
            self.current_maturity = mba.maturity
            main_logger.debug("Instruction optimization function called at maturity: {0}"
                              .format(maturity_to_string(self.current_maturity)))
            self.analyzer.set_maturity(self.current_maturity)
            self.current_blk_serial = None

            for ins_optimizer in self.instruction_optimizers:
                ins_optimizer.cur_maturity = self.current_maturity

            if self.dump_intermediate_microcode:
                dump_microcode_for_debug(mba, self.manager.log_dir, "input_instruction_optimizer")

        if blk.serial != self.current_blk_serial:
            self.current_blk_serial = blk.serial

    def add_optimizer(self, optimizer: InstructionOptimizer):
        self.instruction_optimizers.append(optimizer)
        self.optimizer_usage_info[optimizer.name] = 0

    def add_rule(self, rule: InstructionOptimizationRule):
        # optimizer_log.info("Trying to add rule {0}".format(rule))
        for ins_optimizer in self.instruction_optimizers:
            ins_optimizer.add_rule(rule)
        self.analyzer.add_rule(rule)

    def configure(self, generate_z3_code=False, dump_intermediate_microcode=False, **kwargs):
        self.generate_z3_code = generate_z3_code
        self.dump_intermediate_microcode = dump_intermediate_microcode

    def optimize(self, blk: mblock_t, ins: minsn_t) -> bool:
        # optimizer_log.info("Trying to optimize {0}".format(format_minsn_t(ins)))
        for ins_optimizer in self.instruction_optimizers:
            self._last_optimizer_tried = ins_optimizer
            new_ins = ins_optimizer.get_optimized_instruction(blk, ins)

            if new_ins is not None:
                if not check_ins_mop_size_are_ok(new_ins):
                    if check_ins_mop_size_are_ok(ins):
                        main_logger.error("Invalid optimized instruction: {0} (original was {1})".format(
                            format_minsn_t(new_ins), format_minsn_t(ins)))
                    else:
                        main_logger.error("Invalid original instruction : {0} (original was {1})".format(
                            format_minsn_t(new_ins), format_minsn_t(ins)))
                else:
                    ins.swap(new_ins)
                    self.optimizer_usage_info[ins_optimizer.name] += 1
                    if self.generate_z3_code:
                        try:
                            log_z3_instructions(new_ins, ins)
                        except KeyError:
                            pass
                    return True

        self.analyzer.analyze(blk, ins)
        return False


class InstructionVisitorManager(minsn_visitor_t):
    def __init__(self, optimizer: InstructionOptimizerManager):
        optimizer_logger.debug("Initializing {0}...".format(self.__class__.__name__))
        super().__init__()
        self.instruction_optimizer = optimizer

    def visit_minsn(self) -> bool:
        return self.instruction_optimizer.optimize(self.blk, self.curins)


class BlockOptimizerManager(optblock_t):
    def __init__(self, manager: D810Manager):
        optimizer_logger.debug("Initializing {0}...".format(self.__class__.__name__))
        super().__init__()
        self.manager = manager
        self.cfg_rules = set()

        self.current_maturity = None
        self.cfg_rules_usage_info = {}

    def func(self, blk: mblock_t):
        self.log_info_on_input(blk)
        nb_patch = self.optimize(blk)
        return nb_patch

    def reset_rule_usage_statistic(self):
        self.cfg_rules_usage_info = {}
        for rule in self.cfg_rules:
            self.cfg_rules_usage_info[rule.name] = []

    def show_rule_usage_statistic(self):
        for rule_name, rule_nb_patch_list in self.cfg_rules_usage_info.items():
            nb_use = len(rule_nb_patch_list)
            if nb_use > 0:
                main_logger.info("BlkRule '{0}' has been used {1} times for a total of {2} patches"
                                 .format(rule_name, nb_use, sum(rule_nb_patch_list)))

    def log_info_on_input(self, blk: mblock_t):
        if blk is None:
            return
        mba: mbl_array_t = blk.mba

        if (mba is not None) and (mba.maturity != self.current_maturity):
            main_logger.debug("BlockOptimizer called at maturity: {0}".format(maturity_to_string(mba.maturity)))
            self.current_maturity = mba.maturity

    def optimize(self, blk: mblock_t):
        for cfg_rule in self.cfg_rules:
            if self.check_if_rule_is_activated_for_address(cfg_rule, blk.mba.entry_ea):
                nb_patch = cfg_rule.optimize(blk)
                if nb_patch > 0:
                    optimizer_logger.info("Rule {0} matched: {1} patches".format(cfg_rule.name, nb_patch))
                    self.cfg_rules_usage_info[cfg_rule.name].append(nb_patch)
                    return nb_patch
        return 0

    def add_rule(self, cfg_rule: FlowOptimizationRule):
        optimizer_logger.info("Adding cfg rule {0}".format(cfg_rule))
        self.cfg_rules.add(cfg_rule)
        self.cfg_rules_usage_info[cfg_rule.name] = []

    def configure(self, **kwargs):
        pass

    def check_if_rule_is_activated_for_address(self, cfg_rule: FlowOptimizationRule, func_entry_ea: int):
        if cfg_rule.use_whitelist and (func_entry_ea not in cfg_rule.whitelisted_function_ea_list):
            return False
        if cfg_rule.use_blacklist and (func_entry_ea in cfg_rule.blacklisted_function_ea_list):
            return False
        return True


class HexraysDecompilationHook(Hexrays_Hooks):
    def __init__(self, manager):
        super().__init__()
        self.manager = manager

    def prolog(self, mba: mbl_array_t, fc, reachable_blocks, decomp_flags) -> "int":
        main_logger.info("Starting decompilation of function at 0x{0:x}".format(mba.entry_ea))
        self.manager.instruction_optimizer.reset_rule_usage_statistic()
        self.manager.block_optimizer.reset_rule_usage_statistic()
        return 0

    def glbopt(self, mba: mbl_array_t) -> "int":
        main_logger.info("glbopt finished for function at 0x{0:x}".format(mba.entry_ea))
        self.manager.instruction_optimizer.show_rule_usage_statistic()
        self.manager.block_optimizer.show_rule_usage_statistic()
        return 0

```

`d810/ida_ui.py`:

```py
# -*- coding: utf-8 -*-
import os
import json
import logging
import idaapi
import ida_kernwin
import ida_pro
if ida_pro.IDA_SDK_VERSION >= 920:
    from PySide6 import QtCore, QtWidgets, QtGui
else:
    from PyQt5 import QtCore, QtWidgets, QtGui

from d810.conf import ProjectConfiguration, RuleConfiguration

logger = logging.getLogger('D810.ui')


class PluginConfigurationFileForm_t(QtWidgets.QDialog):
    def __init__(self, parent, state):
        logger.debug("Initializing PluginConfigurationFileForm_t")
        super().__init__(parent)
        self.state = state
        self.log_dir_changed = False

        self.log_dir = self.state.d810_config.get("log_dir")
        self.erase_logs_on_reload = self.state.d810_config.get("erase_logs_on_reload")
        self.generate_z3_code = self.state.d810_config.get("generate_z3_code")
        self.dump_intermediate_microcode = self.state.d810_config.get("dump_intermediate_microcode")

        self.resize(1000, 500)
        self.setWindowTitle("Plugin Configuration")

        # Main layout
        self.config_layout = QtWidgets.QVBoxLayout(self)

        self.layout_log_dir = QtWidgets.QHBoxLayout()
        self.lbl_log_dir_info = QtWidgets.QLabel(self)
        self.lbl_log_dir_info.setText("Current log directory path: ")
        self.layout_log_dir.addWidget(self.lbl_log_dir_info)
        self.lbl_log_dir = QtWidgets.QLabel(self)
        self.lbl_log_dir.setText(self.log_dir)
        self.layout_log_dir.addWidget(self.lbl_log_dir)
        self.button_change_log_dir = QtWidgets.QPushButton(self)
        self.button_change_log_dir.setText("Change log directory")
        self.button_change_log_dir.clicked.connect(self.choose_log_dir)
        self.layout_log_dir.addWidget(self.button_change_log_dir)

        self.config_layout.addLayout(self.layout_log_dir)

        self.checkbox_generate_z3_code = QtWidgets.QCheckBox("Generate Z3 code for simplification performed", self)
        self.checkbox_generate_z3_code.setChecked(self.state.d810_config.get("generate_z3_code"))
        self.config_layout.addWidget(self.checkbox_generate_z3_code)
        self.checkbox_dump_intermediate_microcode = QtWidgets.QCheckBox("Dump functions microcode at each maturity", self)
        self.checkbox_dump_intermediate_microcode.setChecked(self.state.d810_config.get("dump_intermediate_microcode"))
        self.config_layout.addWidget(self.checkbox_dump_intermediate_microcode)
        self.checkbox_erase_logs_on_reload = QtWidgets.QCheckBox("Erase log directory content when plugin is reloaded", self)
        self.checkbox_erase_logs_on_reload.setChecked(self.state.d810_config.get("erase_logs_on_reload"))
        self.config_layout.addWidget(self.checkbox_erase_logs_on_reload)

        self.layout_button = QtWidgets.QHBoxLayout()
        self.button_save = QtWidgets.QPushButton(self)
        self.button_save.setText("Save")
        self.button_save.clicked.connect(self.save_config)
        self.layout_button.addWidget(self.button_save)
        self.button_cancel = QtWidgets.QPushButton(self)
        self.button_cancel.setText("Cancel")
        self.button_cancel.clicked.connect(self.reject)
        self.layout_button.addWidget(self.button_cancel)
        self.config_layout.addLayout(self.layout_button)

        self.setLayout(self.config_layout)

    def choose_log_dir(self):
        logger.debug("Calling save_rule_configuration")
        log_dir = QtWidgets.QFileDialog.getExistingDirectory(self, "Open Directory", os.path.expanduser("~"),
                                                                  QtWidgets.QFileDialog.ShowDirsOnly |
                                                                  QtWidgets.QFileDialog.DontResolveSymlinks)
        if log_dir != "":
            self.log_dir = log_dir
            self.log_dir_changed = True
            self.lbl_log_dir.setText(self.log_dir)

    def save_config(self):
        if self.log_dir_changed:
            self.state.d810_config.set("log_dir", self.log_dir)
        self.state.d810_config.set("erase_logs_on_reload", self.checkbox_erase_logs_on_reload.isChecked())
        self.state.d810_config.set("generate_z3_code", self.checkbox_generate_z3_code.isChecked())
        self.state.d810_config.set("dump_intermediate_microcode", self.checkbox_dump_intermediate_microcode.isChecked())
        self.state.d810_config.save()
        self.accept()


class EditConfigurationFileForm_t(QtWidgets.QDialog):
    def __init__(self, parent, state):
        logger.debug("Initializing EditConfigurationFileForm_t")
        super().__init__(parent)
        self.state = state
        self.resize(1000, 500)
        self.setWindowTitle("Rule Configuration Editor")

        # Main layout
        self.config_layout = QtWidgets.QVBoxLayout(self)

        # Configuration Name Selection Layout
        self.layout_cfg_name = QtWidgets.QHBoxLayout()
        self.lbl_cfg_name = QtWidgets.QLabel(self)
        self.lbl_cfg_name.setText("Rule Name")
        self.layout_cfg_name.addWidget(self.lbl_cfg_name)
        self.in_cfg_name = QtWidgets.QLineEdit(self)
        self.layout_cfg_name.addWidget(self.in_cfg_name)
        self.config_layout.addLayout(self.layout_cfg_name)

        # Instructions rule Selection Layout
        self.table_ins_rule_selection = QtWidgets.QTableWidget(self)
        # self.table_ins_rule_selection.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.table_ins_rule_selection.setRowCount(2)
        self.table_ins_rule_selection.setColumnCount(4)
        item = QtWidgets.QTableWidgetItem()
        item.setText("Is activated")
        self.table_ins_rule_selection.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        item.setText("Rule Name")
        self.table_ins_rule_selection.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        item.setText("Rule Description")
        self.table_ins_rule_selection.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        item.setText("Rule Configuration")
        self.table_ins_rule_selection.setHorizontalHeaderItem(3, item)
        self.table_ins_rule_selection.horizontalHeader().setStretchLastSection(True)
        self.table_ins_rule_selection.verticalHeader().setVisible(False)
        self.table_ins_rule_selection.setSortingEnabled(True)
        # self.table_ins_rule_selection.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        self.config_layout.addWidget(self.table_ins_rule_selection)

        # Block rule Selection Layout
        self.table_blk_rule_selection = QtWidgets.QTableWidget(self)
        # self.table_blk_rule_selection.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.table_blk_rule_selection.setRowCount(2)
        self.table_blk_rule_selection.setColumnCount(4)
        item = QtWidgets.QTableWidgetItem()
        item.setText("Is activated")
        self.table_blk_rule_selection.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        item.setText("Rule Name")
        self.table_blk_rule_selection.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        item.setText("Rule Description")
        self.table_blk_rule_selection.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        item.setText("Rule Configuration")
        self.table_blk_rule_selection.setHorizontalHeaderItem(3, item)
        self.table_blk_rule_selection.horizontalHeader().setStretchLastSection(True)
        self.table_blk_rule_selection.verticalHeader().setVisible(False)
        self.table_blk_rule_selection.setSortingEnabled(True)
        # self.table_blk_rule_selection.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        self.config_layout.addWidget(self.table_blk_rule_selection)

        self.layout_button = QtWidgets.QHBoxLayout()
        self.button_save = QtWidgets.QPushButton(self)
        self.button_save.setText("Save")
        self.button_save.clicked.connect(self.save_rule_configuration)
        self.layout_button.addWidget(self.button_save)
        self.button_cancel = QtWidgets.QPushButton(self)
        self.button_cancel.setText("Cancel")
        self.button_cancel.clicked.connect(self.reject)
        self.layout_button.addWidget(self.button_cancel)
        self.config_layout.addLayout(self.layout_button)

        self.setLayout(self.config_layout)

        self.config_path = None
        self.config_description = None
        self.config_rules = []
        self.update_table_rule_selection()

    def update_form(self, config_description=None, activated_ins_rule_config_list=None, activated_blk_rule_config_list=None, config_path=None):
        logger.debug("Calling update_form")
        if config_description is not None:
            self.in_cfg_name.setText(config_description)
        if activated_ins_rule_config_list is not None or activated_blk_rule_config_list is not None:
            self.update_table_rule_selection(activated_ins_rule_config_list, activated_blk_rule_config_list)
        if config_path is not None:
            self.config_path = config_path

    def update_table_rule_selection(self, activated_ins_rule_config_list=None, activated_blk_rule_config_list=None):
        logger.debug("Calling update_table_rule_selection")
        self.update_table_ins_rule_selection(activated_ins_rule_config_list)
        self.update_table_blk_rule_selection(activated_blk_rule_config_list)

    def _get_rule_config(self, rule_name, rule_config_list):
        logger.debug("Calling _get_rule_config")
        try:
            rule_name_list = [rule_conf.name for rule_conf in rule_config_list]
            rule_index = rule_name_list.index(rule_name)
            return rule_config_list[rule_index]
        except ValueError:
            return None

    def update_table_ins_rule_selection(self, activated_ins_rule_config_list=None):
        logger.debug("Calling update_table_ins_rule_selection")
        if activated_ins_rule_config_list is None:
            activated_ins_rule_config_list = []
        self.table_ins_rule_selection.setRowCount(len(self.state.known_ins_rules))
        for i, rule in enumerate(self.state.known_ins_rules):
            rule_config = self._get_rule_config(rule.name, activated_ins_rule_config_list)
            item = QtWidgets.QTableWidgetItem()
            item.setTextAlignment(QtCore.Qt.AlignCenter)
            if rule_config is not None and rule_config.is_activated:
                item.setCheckState(QtCore.Qt.Checked)
            else:
                item.setCheckState(QtCore.Qt.Unchecked)
            self.table_ins_rule_selection.setItem(i, 0, item)
            item = QtWidgets.QTableWidgetItem()
            item.setText(rule.name)
            item.setFlags(QtCore.Qt.ItemIsEnabled)
            self.table_ins_rule_selection.setItem(i, 1, item)
            item = QtWidgets.QTableWidgetItem()
            item.setText(rule.description)
            item.setFlags(QtCore.Qt.ItemIsEnabled)
            self.table_ins_rule_selection.setItem(i, 2, item)
            item = QtWidgets.QTableWidgetItem()
            if rule_config is not None:
                item.setText(json.dumps(rule_config.config))
            else:
                item.setText("{}")
            self.table_ins_rule_selection.setItem(i, 3, item)
        self.table_ins_rule_selection.resizeColumnsToContents()

    def update_table_blk_rule_selection(self, activated_blk_rule_config_list=None):
        logger.debug("Calling update_table_blk_rule_selection")
        if activated_blk_rule_config_list is None:
            activated_blk_rule_config_list = []
        self.table_blk_rule_selection.setRowCount(len(self.state.known_blk_rules))
        for i, rule in enumerate(self.state.known_blk_rules):
            rule_config = self._get_rule_config(rule.name, activated_blk_rule_config_list)
            item = QtWidgets.QTableWidgetItem()
            item.setTextAlignment(QtCore.Qt.AlignCenter)
            if rule_config is not None and rule_config.is_activated:
                item.setCheckState(QtCore.Qt.Checked)
            else:
                item.setCheckState(QtCore.Qt.Unchecked)
            self.table_blk_rule_selection.setItem(i, 0, item)
            item = QtWidgets.QTableWidgetItem()
            item.setText(rule.name)
            item.setFlags(QtCore.Qt.ItemIsEnabled)
            self.table_blk_rule_selection.setItem(i, 1, item)
            item = QtWidgets.QTableWidgetItem()
            item.setText(rule.description)
            item.setFlags(QtCore.Qt.ItemIsEnabled)
            self.table_blk_rule_selection.setItem(i, 2, item)
            item = QtWidgets.QTableWidgetItem()
            if rule_config is not None:
                item.setText(json.dumps(rule_config.config))
            else:
                item.setText("{}")
            self.table_blk_rule_selection.setItem(i, 3, item)
        self.table_blk_rule_selection.resizeColumnsToContents()

    def save_rule_configuration(self):
        logger.debug("Calling save_rule_configuration")
        fname, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'Save file', self.config_path, "Project configuration (*.json)")
        if fname:
            self.config_path = fname
            self.config_description = self.in_cfg_name.text()
            self.config_ins_rules = self.get_ins_rules()
            self.config_blk_rules = self.get_blk_rules()
            self.accept()

    def get_ins_rules(self):
        logger.debug("Calling get_ins_rules")
        activated_rule_names = []
        nb_rules = self.table_ins_rule_selection.rowCount()
        for i in range(nb_rules):
            if self.table_ins_rule_selection.item(i, 0).checkState():
                rule_conf = RuleConfiguration(name=self.table_ins_rule_selection.item(i, 1).text(),
                                              is_activated=self.table_ins_rule_selection.item(i, 0).checkState() == QtCore.Qt.Checked,
                                              config=json.loads(self.table_ins_rule_selection.item(i, 3).text()))
                activated_rule_names.append(rule_conf)
                # activated_rule_names.append(self.table_ins_rule_selection.item(i, 1).text())
        return activated_rule_names

    def get_blk_rules(self):
        logger.debug("Calling get_blk_rules")
        activated_rule_names = []
        nb_rules = self.table_blk_rule_selection.rowCount()
        for i in range(nb_rules):
            if self.table_blk_rule_selection.item(i, 0).checkState():
                rule_conf = RuleConfiguration(name=self.table_blk_rule_selection.item(i, 1).text(),
                                              is_activated=self.table_blk_rule_selection.item(i, 0).checkState() == QtCore.Qt.Checked,
                                              config=json.loads(self.table_blk_rule_selection.item(i, 3).text()))
                activated_rule_names.append(rule_conf)
                # activated_rule_names.append(self.table_blk_rule_selection.item(i, 1).text())
        return activated_rule_names


class D810ConfigForm_t(ida_kernwin.PluginForm):
    def __init__(self, state):
        super().__init__()
        self.state = state
        self.shown = False
        self.created = False
        self.parent = None

    def OnClose(self, form):
        logger.debug("Calling OnClose")
        self.shown = False
        # self.parent.close()

    def Show(self):
        logger.debug("Calling Show")
        if self.shown:
            return
        self.shown = True
        return ida_kernwin.PluginForm.Show(
            self, "D-810 Configuration",
            options=(ida_kernwin.PluginForm.WOPN_PERSIST |
                     ida_kernwin.PluginForm.WCLS_SAVE |
                     ida_kernwin.PluginForm.WOPN_MENU |
                     ida_kernwin.PluginForm.WOPN_RESTORE |
                     ida_kernwin.PluginForm.WOPN_TAB))

    def OnCreate(self, form):
        logger.debug("Calling OnCreate")
        self.created = True

        # Get parent widget
        self.parent = self.FormToPyQtWidget(form)
        layout = QtWidgets.QGridLayout(self.parent)

        # ----------- Config options -----------------------
        # Horizontal splitter for config boxes
        cfg_split = QtWidgets.QSplitter(self.parent)
        layout.addWidget(cfg_split, 0, 0)
        # Config name label
        self.curlabel = QtWidgets.QLabel('Current file loaded:')
        cfg_split.addWidget(self.curlabel)

        self.cfg_select = QtWidgets.QComboBox(self.parent)
        cfg_split.addWidget(self.cfg_select)

        self.btn_new_cfg = QtWidgets.QPushButton('New')
        self.btn_new_cfg.clicked.connect(self._create_config)
        cfg_split.addWidget(self.btn_new_cfg)

        self.btn_duplicate_cfg = QtWidgets.QPushButton('Duplicate')
        self.btn_duplicate_cfg.clicked.connect(self._duplicate_config)
        cfg_split.addWidget(self.btn_duplicate_cfg)

        self.btn_edit_cfg = QtWidgets.QPushButton('Edit')
        self.btn_edit_cfg.clicked.connect(self._edit_config)
        cfg_split.addWidget(self.btn_edit_cfg)

        self.btn_delele_cfg = QtWidgets.QPushButton('Delete')
        self.btn_delele_cfg.clicked.connect(self._delete_config)
        cfg_split.addWidget(self.btn_delele_cfg)

        # leave space for comboboxes in cfg_split, rather than between widgets
        cfg_split.setStretchFactor(0, 0)
        cfg_split.setStretchFactor(1, 1)
        cfg_split.setStretchFactor(2, 0)

        description_split = QtWidgets.QSplitter(self.parent)
        layout.addWidget(description_split, 1, 0)
        self.cfg_description_layout = QtWidgets.QHBoxLayout(description_split)
        self.cfg_description_label = QtWidgets.QLabel("Description")
        description_split.addWidget(self.cfg_description_label)
        self.cfg_description = QtWidgets.QLabel("No description")
        description_split.addWidget(self.cfg_description)
        description_split.setStretchFactor(0, 0)
        description_split.setStretchFactor(1, 1)

        self.cfg_ins_preview = QtWidgets.QTableWidget(self.parent)
        layout.addWidget(self.cfg_ins_preview, 2, 0)

        self.cfg_blk_preview = QtWidgets.QTableWidget(self.parent)
        layout.addWidget(self.cfg_blk_preview, 3, 0)
        self.update_cfg_preview()

        # ----------- Analysis buttons -----------------------
        # Horizontal splitter for buttons
        btn_split = QtWidgets.QSplitter(self.parent)
        layout.addWidget(btn_split, 4, 0)

        self.btn_config = QtWidgets.QPushButton('Configuration')
        self.btn_config.clicked.connect(self._configure_plugin)
        btn_split.addWidget(self.btn_config)


        self.btn_start = QtWidgets.QPushButton('Start')
        self.btn_start.clicked.connect(self._start_d810)
        btn_split.addWidget(self.btn_start)

        self.btn_stop = QtWidgets.QPushButton('Stop')
        self.btn_stop.clicked.connect(self._stop_d810)
        btn_split.addWidget(self.btn_stop)

        self.plugin_status = QtWidgets.QLabel()
        self.plugin_status.setText("<span style=\" font-size:8pt; font-weight:600; color:#ff0000;\" >Not Loaded</span>")
        description_split.addWidget(self.plugin_status)
        btn_split.addWidget(self.plugin_status)


        self.update_cfg_select()
        self.cfg_select.setCurrentIndex(self.state.current_project_index)
        self.cfg_select.currentIndexChanged.connect(self._load_config)

    def update_cfg_preview(self):
        logger.debug("Calling update_cfg_preview")
        self.update_cfg_ins_preview()
        self.update_cfg_blk_preview()

    def update_cfg_ins_preview(self):
        # return
        logger.debug("Calling update_cfg_ins_preview")
        self.cfg_ins_preview.setRowCount(len(self.state.current_ins_rules))
        self.cfg_ins_preview.setColumnCount(3)
        self.cfg_ins_preview.setHorizontalHeaderLabels(("Name", "Description", "Configuration"))
        self.cfg_ins_preview.horizontalHeader().setStretchLastSection(True)
        self.cfg_ins_preview.setSortingEnabled(True)
        # self.cfg_ins_preview.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        i = 0
        for rule in self.state.current_ins_rules:
            cell_file_path = QtWidgets.QTableWidgetItem(rule.name)
            cell_file_path.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
            cell_rule_description = QtWidgets.QTableWidgetItem(rule.description)
            cell_rule_description.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
            cell_rule_config = QtWidgets.QTableWidgetItem(json.dumps(rule.config))
            cell_rule_config.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
            self.cfg_ins_preview.setItem(i, 0, cell_file_path)
            self.cfg_ins_preview.setItem(i, 1, cell_rule_description)
            self.cfg_ins_preview.setItem(i, 2, cell_rule_config)
            i += 1
        self.cfg_ins_preview.resizeColumnsToContents()

    def update_cfg_blk_preview(self):
        logger.debug("Calling update_cfg_blk_preview")
        self.cfg_blk_preview.setRowCount(len(self.state.current_blk_rules))
        self.cfg_blk_preview.setColumnCount(3)
        self.cfg_blk_preview.setHorizontalHeaderLabels(("Name", "Description", "Configuration"))
        self.cfg_blk_preview.horizontalHeader().setStretchLastSection(True)
        self.cfg_blk_preview.setSortingEnabled(True)
        # self.cfg_blk_preview.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        i = 0
        for rule in self.state.current_blk_rules:
            cell_file_path = QtWidgets.QTableWidgetItem(rule.name)
            cell_file_path.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
            cell_rule_description = QtWidgets.QTableWidgetItem(rule.description)
            cell_rule_description.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
            cell_rule_config = QtWidgets.QTableWidgetItem(json.dumps(rule.config))
            cell_rule_config.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
            self.cfg_blk_preview.setItem(i, 0, cell_file_path)
            self.cfg_blk_preview.setItem(i, 1, cell_rule_description)
            self.cfg_blk_preview.setItem(i, 2, cell_rule_config)
            i += 1
        self.cfg_blk_preview.resizeColumnsToContents()

    def update_cfg_select(self):
        logger.debug("Calling update_cfg_select")
        tmp = self.state.current_project_index
        self.cfg_select.clear()
        self.cfg_select.addItems([proj.path for proj in self.state.projects])
        self.cfg_select.setCurrentIndex(tmp)

    def _create_config(self):
        logger.debug("Calling _create_config")
        self._internal_config_creation(None, None, None, self.state.d810_config.config_dir)

    def _duplicate_config(self):
        logger.debug("Calling _duplicate_config")
        cur_cfg = self.state.current_project
        self._internal_config_creation(None, cur_cfg.ins_rules, cur_cfg.blk_rules, self.state.d810_config.config_dir)

    def _edit_config(self):
        logger.debug("Calling _edit_config")
        cur_cfg = self.state.current_project
        self._internal_config_creation(cur_cfg.description, cur_cfg.ins_rules, cur_cfg.blk_rules, cur_cfg.path, cur_cfg)

    def _internal_config_creation(self, description, start_ins_rules, start_blk_rules, path, old_conf=None):
        logger.debug("Calling _internal_config_creation")
        editdlg = EditConfigurationFileForm_t(self.parent, self.state)
        editdlg.update_form(description, start_ins_rules, start_blk_rules, path)
        if editdlg.exec_() == QtWidgets.QDialog.Accepted:
            new_config = ProjectConfiguration(editdlg.config_path, editdlg.config_description, editdlg.config_ins_rules, editdlg.config_blk_rules)
            new_config.save()
            if old_conf is None:
                self.state.add_project(new_config)
            else:
                self.state.update_project(old_conf, new_config)
            self.update_cfg_select()
            return new_config
        return None

    # callback when the "Delete" button is clicked
    def _delete_config(self):
        logger.debug("Calling _delete_config")
        self.state.del_project(self.state.current_project)
        self.update_cfg_select()

    # Called when the edit combo is changed
    def _load_config(self, index):
        logger.debug("Calling _load_config")
        self.state.load_project(index)
        self.cfg_description.setText(self.state.current_project.description)
        self.update_cfg_preview()
        return

    def _configure_plugin(self):
        editdlg = PluginConfigurationFileForm_t(self.parent, self.state)
        if editdlg.exec_() == QtWidgets.QDialog.Accepted:
            return
        return

    def _start_d810(self):
        logger.debug("Calling _start_d810")
        self.state.start_d810()
        # self.plugin_status.clear()
        self.plugin_status.setText("<span style=\" font-size:8pt; font-weight:600; color:#00FF00;\" >Loaded</span>")
        return

    def _stop_d810(self):
        logger.debug("Calling _stop_d810")
        self.state.stop_d810()
        # self.plugin_status.clear()
        self.plugin_status.setText("<span style=\" font-size:8pt; font-weight:600; color:#FF0000;\" >Not Loaded</span>")
        return


class D810GUI(object):
    def __init__(self, state):
        """
        Instanciate D-810 views
        """
        logger.debug("Initializing D810GUI")
        self.state = state
        self.d810_config_form = D810ConfigForm_t(self.state)
        # XXX fix
        idaapi.set_dock_pos("D-810", "IDA View-A", idaapi.DP_TAB)

    def show_windows(self):
        logger.debug("Calling show_windows")
        self.d810_config_form.Show()

    def term(self):
        logger.debug("Calling term")
        self.d810_config_form.Close(ida_kernwin.PluginForm.WCLS_SAVE)

```

`d810/log.ini`:

```ini
[loggers]
keys=root,D810,D810Ui,D810Optimizer,D810RulesChain,D810PatternSearch,D810BranchFixer,D810Unflat,D810Tracker,D810Emulator,D810Helper,D810Z3Test

[handlers]
keys=consoleHandler,defaultFileHandler,z3FileHandler

[formatters]
keys=defaultFormatter,rawFormatter

[logger_root]
level=DEBUG
handlers=consoleHandler

[logger_D810]
level=DEBUG
handlers=consoleHandler,defaultFileHandler
qualname=D810
propagate=0

[logger_D810Ui]
level=ERROR
handlers=defaultFileHandler
qualname=D810.ui
propagate=0

[logger_D810Optimizer]
level=INFO
handlers=defaultFileHandler
qualname=D810.optimizer
propagate=0

[logger_D810RulesChain]
level=INFO
handlers=defaultFileHandler
qualname=D810.chain
propagate=0

[logger_D810BranchFixer]
level=INFO
handlers=defaultFileHandler
qualname=D810.branch_fixer
propagate=0

[logger_D810Unflat]
level=INFO
handlers=defaultFileHandler
qualname=D810.unflat
propagate=0

[logger_D810Tracker]
level=INFO
handlers=defaultFileHandler
qualname=D810.tracker
propagate=0

[logger_D810Emulator]
level=WARNING
handlers=defaultFileHandler
qualname=D810.emulator
propagate=0

[logger_D810Helper]
level=INFO
handlers=defaultFileHandler
qualname=D810.helper
propagate=0

[logger_D810PatternSearch]
level=ERROR
handlers=defaultFileHandler
qualname=D810.pattern_search
propagate=0

[logger_D810Z3Test]
level=INFO
handlers=z3FileHandler
qualname=D810.z3_test
propagate=0

[handler_consoleHandler]
class=StreamHandler
level=INFO
formatter=defaultFormatter
args=(sys.stdout,)

[handler_defaultFileHandler]
class=FileHandler
level=DEBUG
formatter=defaultFormatter
args=('%(default_log_filename)s',)

[handler_z3FileHandler]
class=FileHandler
level=DEBUG
formatter=rawFormatter
args=('%(z3_log_filename)s',)

[formatter_defaultFormatter]
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s

[formatter_rawFormatter]
format=%(message)s
```

`d810/log.py`:

```py
import os
import shutil
import logging
import logging.config
from pathlib import Path

LOG_CONFIG_FILENAME = "log.ini"
LOG_FILENAME = "d810.log"
Z3_TEST_FILENAME = "z3_check_instructions_substitution.py"


def clear_logs(log_dir):
    shutil.rmtree(log_dir, ignore_errors=True)


def configure_loggers(log_dir):
    os.makedirs(log_dir, exist_ok=True)
    log_main_file = Path(log_dir) / LOG_FILENAME
    z3_test_file = Path(log_dir) / Z3_TEST_FILENAME
    log_conf_file = Path(__file__).resolve().parent / LOG_CONFIG_FILENAME
    logging.config.fileConfig(log_conf_file.as_posix(), defaults={"default_log_filename": log_main_file.as_posix(),
                                                                  "z3_log_filename": z3_test_file.as_posix()})
    z3_file_logger = logging.getLogger('D810.z3_test')
    z3_file_logger.info("from z3 import BitVec, BitVecVal, UDiv, URem, LShR, UGT, UGE, ULT, ULE, prove\n\n")

```

`d810/manager.py`:

```py
from __future__ import annotations
import os
import json
import logging
import idaapi

from typing import TYPE_CHECKING, List
if TYPE_CHECKING:
    from d810.conf import D810Configuration, ProjectConfiguration


# Note that imports are performed directly in the functions so that they are reloaded each time the plugin is restarted
# This allow to load change code/drop new rules without having to reboot IDA
d810_state = None

D810_LOG_DIR_NAME = "d810_logs"

MANAGER_INFO_FILENAME = "manager_info.json"
logger = logging.getLogger('D810')


def reload_all_modules():
    manager_info_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), MANAGER_INFO_FILENAME)

    with open(manager_info_path, "r") as f:
        manager_info = json.load(f)

    for module_name in manager_info["module_list"]:
        idaapi.require(module_name)


class D810Manager(object):
    def __init__(self, log_dir):
        self.instruction_optimizer_rules = []
        self.instruction_optimizer_config = {}
        self.block_optimizer_rules = []
        self.block_optimizer_config = {}
        self.instruction_optimizer = None
        self.block_optimizer = None
        self.hx_decompiler_hook = None
        self.log_dir = log_dir
        self.config = {}

    def configure(self, **kwargs):
        self.config = kwargs

    def reload(self):
        self.stop()
        logger.debug("Reloading manager...")

        from d810.hexrays_hooks import InstructionOptimizerManager, BlockOptimizerManager, HexraysDecompilationHook

        self.instruction_optimizer = InstructionOptimizerManager(self)
        self.instruction_optimizer.configure(**self.instruction_optimizer_config)
        self.block_optimizer = BlockOptimizerManager(self)
        self.block_optimizer.configure(**self.block_optimizer_config)

        for rule in self.instruction_optimizer_rules:
            rule.log_dir = self.log_dir
            self.instruction_optimizer.add_rule(rule)

        for cfg_rule in self.block_optimizer_rules:
            cfg_rule.log_dir = self.log_dir
            self.block_optimizer.add_rule(cfg_rule)

        self.instruction_optimizer.install()
        self.block_optimizer.install()

        self.hx_decompiler_hook = HexraysDecompilationHook(self)
        self.hx_decompiler_hook.hook()

    def configure_instruction_optimizer(self, rules, **kwargs):
        self.instruction_optimizer_rules = [rule for rule in rules]
        self.instruction_optimizer_config = kwargs

    def configure_block_optimizer(self, rules, **kwargs):
        self.block_optimizer_rules = [rule for rule in rules]
        self.block_optimizer_config = kwargs

    def stop(self):
        if self.instruction_optimizer is not None:
            logger.debug("Removing InstructionOptimizer...")
            self.instruction_optimizer.remove()
            self.instruction_optimizer = None
        if self.block_optimizer is not None:
            logger.debug("Removing ControlFlowFixer...")
            self.block_optimizer.remove()
            self.block_optimizer = None
        if self.hx_decompiler_hook is not None:
            logger.debug("Removing HexraysDecompilationHook...")
            self.hx_decompiler_hook.unhook()
            self.hx_decompiler_hook = None


class D810State(object):
    def __init__(self, d810_config: D810Configuration):
        # For debugging purposes, to interact with this object from the console
        # Type in IDA Python shell 'from d810.manager import d810_state' to access it
        global d810_state
        d810_state = self
        reload_all_modules()

        self.d810_config = d810_config
        self.log_dir = os.path.join(self.d810_config.get("log_dir"), D810_LOG_DIR_NAME)
        self.manager = D810Manager(self.log_dir)

        from d810.optimizers.instructions import KNOWN_INS_RULES
        from d810.optimizers.flow import KNOWN_BLK_RULES
        self.known_ins_rules = [x for x in KNOWN_INS_RULES]
        self.known_blk_rules = [x for x in KNOWN_BLK_RULES]

        self.gui = None
        self.current_project = None
        self.projects: List[ProjectConfiguration] = []
        self.current_project_index = self.d810_config.get("last_project_index")
        self.current_ins_rules = []
        self.current_blk_rules = []

        self.register_default_projects()
        self.load_project(self.current_project_index)

    def register_default_projects(self):
        from d810.conf import ProjectConfiguration
        self.projects = []
        for project_configuration_path in self.d810_config.get("configurations"):
            project_configuration = ProjectConfiguration(project_configuration_path,
                                                         conf_dir=self.d810_config.config_dir)
            project_configuration.load()
            self.projects.append(project_configuration)
        logger.debug("Rule configurations loaded: {0}".format(self.projects))

    def add_project(self, config: ProjectConfiguration):
        self.projects.append(config)
        self.d810_config.get("configurations").append(config.path)
        self.d810_config.save()

    def update_project(self, old_config: ProjectConfiguration, new_config: ProjectConfiguration):
        old_config_index = self.projects.index(old_config)
        self.projects[old_config_index] = new_config

    def del_project(self, config: ProjectConfiguration):
        self.projects.remove(config)
        self.d810_config.get("configurations").remove(config.path)
        self.d810_config.save()
        os.remove(config.path)

    def load_project(self, project_index: int):
        self.current_project_index = project_index
        self.current_project = self.projects[project_index]
        self.current_ins_rules = []
        self.current_blk_rules = []

        for rule in self.known_ins_rules:
            for rule_conf in self.current_project.ins_rules:
                if rule.name == rule_conf.name:
                    rule.configure(rule_conf.config)
                    rule.set_log_dir(self.log_dir)
                    self.current_ins_rules.append(rule)
        logger.debug("Instruction rules configured")
        for blk_rule in self.known_blk_rules:
            for rule_conf in self.current_project.blk_rules:
                if blk_rule.name == rule_conf.name:
                    blk_rule.configure(rule_conf.config)
                    blk_rule.set_log_dir(self.log_dir)
                    self.current_blk_rules.append(blk_rule)
        logger.debug("Block rules configured")
        self.manager.configure(**self.current_project.additional_configuration)
        logger.debug("Project loaded.")

    def start_d810(self):
        print("D-810 ready to deobfuscate...")
        self.manager.configure_instruction_optimizer([rule for rule in self.current_ins_rules],
                                                     generate_z3_code=self.d810_config.get("generate_z3_code"),
                                                     dump_intermediate_microcode=self.d810_config.get(
                                                         "dump_intermediate_microcode"),
                                                     **self.current_project.additional_configuration)
        self.manager.configure_block_optimizer([rule for rule in self.current_blk_rules],
                                               **self.current_project.additional_configuration)
        self.manager.reload()
        self.d810_config.set("last_project_index", self.current_project_index)
        self.d810_config.save()

    def stop_d810(self):
        print("Stopping D-810...")
        self.manager.stop()

    def start_plugin(self):
        from d810.ida_ui import D810GUI
        self.gui = D810GUI(self)
        self.gui.show_windows()

    def stop_plugin(self):
        self.manager.stop()
        if self.gui:
            self.gui.term()
            self.gui = None

```

`d810/manager_info.json`:

```json
{
  "_comment": "Order of module in module list matters",
  "module_list": [
    "d810.cfg_utils",
    "d810.emulator",
    "d810.ast",
    "d810.optimizers.handler",
    "d810.optimizers.instructions.handler",
    "d810.optimizers.instructions.pattern_matching.handler",
    "d810.optimizers.instructions.pattern_matching.rewrite_add",
    "d810.optimizers.instructions.pattern_matching.rewrite_and",
    "d810.optimizers.instructions.pattern_matching.rewrite_bnot",
    "d810.optimizers.instructions.pattern_matching.rewrite_cst",
    "d810.optimizers.instructions.pattern_matching.rewrite_mov",
    "d810.optimizers.instructions.pattern_matching.rewrite_mul",
    "d810.optimizers.instructions.pattern_matching.rewrite_neg",
    "d810.optimizers.instructions.pattern_matching.rewrite_or",
    "d810.optimizers.instructions.pattern_matching.rewrite_predicates",
    "d810.optimizers.instructions.pattern_matching.rewrite_sub",
    "d810.optimizers.instructions.pattern_matching.rewrite_xor",
    "d810.optimizers.instructions.pattern_matching.weird",
    "d810.optimizers.instructions.pattern_matching.experimental",
    "d810.optimizers.instructions.pattern_matching",
    "d810.optimizers.instructions.chain.handler",
    "d810.optimizers.instructions.chain.chain_rules",
    "d810.optimizers.instructions.chain",
    "d810.optimizers.instructions.z3.handler",
    "d810.optimizers.instructions.z3.cst",
    "d810.optimizers.instructions.z3.predicates",
    "d810.optimizers.instructions.z3",
    "d810.optimizers.instructions.analysis.utils",
    "d810.optimizers.instructions.analysis.handler",
    "d810.optimizers.instructions.analysis.pattern_guess",
    "d810.optimizers.instructions.analysis",
    "d810.optimizers.instructions.early.handler",
    "d810.optimizers.instructions.early.mem_read",
    "d810.optimizers.instructions.early",
    "d810.optimizers.instructions",
    "d810.optimizers.flow.handler",
    "d810.optimizers.flow.jumps.handler",
    "d810.optimizers.flow.jumps.opaque",
    "d810.optimizers.flow.jumps.tricks",
    "d810.optimizers.flow.jumps",
    "d810.optimizers.flow.flattening.utils",
    "d810.optimizers.flow.flattening.generic",
    "d810.optimizers.flow.flattening.unflattener",
    "d810.optimizers.flow.flattening.unflattener_fake_jump",
    "d810.optimizers.flow.flattening.unflattener_switch_case",
    "d810.optimizers.flow.flattening.unflattener_indirect",
    "d810.optimizers.flow.flattening.fix_pred_cond_jump_block",
    "d810.optimizers.flow.flattening",
    "d810.optimizers.flow",
    "d810.hexrays_helpers",
    "d810.hexrays_formatters",
    "d810.hexrays_hooks",
    "d810.ida_ui",
    "d810.log",
    "d810.tracker",
    "d810.utils",
    "d810.z3_utils"
  ]
}

```

`d810/optimizers/flow/__init__.py`:

```py
from d810.optimizers.flow.flattening import UNFLATTENING_BLK_RULES
from d810.optimizers.flow.jumps import JUMP_OPTIMIZATION_BLOCK_RULES, JUMP_OPTIMIZATION_RULES

KNOWN_BLK_RULES = UNFLATTENING_BLK_RULES + JUMP_OPTIMIZATION_BLOCK_RULES


```

`d810/optimizers/flow/flattening/__init__.py`:

```py
from d810.optimizers.flow.flattening.unflattener import Unflattener
from d810.optimizers.flow.flattening.unflattener_switch_case import UnflattenerSwitchCase
from d810.optimizers.flow.flattening.unflattener_indirect import UnflattenerTigressIndirect
from d810.optimizers.flow.flattening.unflattener_fake_jump import UnflattenerFakeJump
from d810.optimizers.flow.flattening.fix_pred_cond_jump_block import FixPredecessorOfConditionalJumpBlock

UNFLATTENING_BLK_RULES = [Unflattener(), UnflattenerSwitchCase(), UnflattenerTigressIndirect(), UnflattenerFakeJump(),
                          FixPredecessorOfConditionalJumpBlock()]

```

`d810/optimizers/flow/flattening/fix_pred_cond_jump_block.py`:

```py
import logging
from typing import List, Tuple
from ida_hexrays import *

from d810.tracker import MopTracker
from d810.cfg_utils import duplicate_block, make_2way_block_goto, update_blk_successor

from d810.hexrays_formatters import format_minsn_t, dump_microcode_for_debug
from d810.optimizers.flow.flattening.utils import get_all_possibles_values
from d810.optimizers.flow.flattening.generic import GenericUnflatteningRule
from d810.utils import unsigned_to_signed


unflat_logger = logging.getLogger('D810.unflat')

JMP_OPCODE_HANDLED = [m_jnz, m_jz, m_jae, m_jb, m_ja, m_jbe, m_jge, m_jg, m_jl, m_jle]


class FixPredecessorOfConditionalJumpBlock(GenericUnflatteningRule):
    DESCRIPTION = "Detect if a predecessor of a conditional block always takes the same path and patch it (works for O-LLVM style control flow flattening)"
    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]
    DEFAULT_MAX_PASSES = 100

    def is_jump_taken(self, jmp_blk: mblock_t, pred_comparison_values: List[int]) -> Tuple[bool, bool]:
        if len(pred_comparison_values) == 0:
            return False, False
        jmp_ins = jmp_blk.tail
        compared_value = jmp_ins.r.nnn.value
        compared_value_size = jmp_ins.r.size
        is_jmp_always_taken = False
        is_jmp_never_taken = False
        if jmp_ins.opcode == m_jnz:
            is_jmp_always_taken = all([possible_value != compared_value for possible_value in pred_comparison_values])
            is_jmp_never_taken = all([possible_value == compared_value for possible_value in pred_comparison_values])
        elif jmp_ins.opcode == m_jz:
            is_jmp_always_taken = all([possible_value == compared_value for possible_value in pred_comparison_values])
            is_jmp_never_taken = all([possible_value != compared_value for possible_value in pred_comparison_values])
        elif jmp_ins.opcode == m_jae:
            is_jmp_always_taken = all([possible_value >= compared_value for possible_value in pred_comparison_values])
            is_jmp_never_taken = all([possible_value < compared_value for possible_value in pred_comparison_values])
        elif jmp_ins.opcode == m_jb:
            is_jmp_always_taken = all([possible_value < compared_value for possible_value in pred_comparison_values])
            is_jmp_never_taken = all([possible_value >= compared_value for possible_value in pred_comparison_values])
        elif jmp_ins.opcode == m_ja:
            is_jmp_always_taken = all([possible_value > compared_value for possible_value in pred_comparison_values])
            is_jmp_never_taken = all([possible_value <= compared_value for possible_value in pred_comparison_values])
        elif jmp_ins.opcode == m_jbe:
            is_jmp_always_taken = all([unsigned_to_signed(possible_value, compared_value_size) > unsigned_to_signed(
                compared_value, compared_value_size) for possible_value in pred_comparison_values])
            is_jmp_never_taken = all([unsigned_to_signed(possible_value, compared_value_size) <= unsigned_to_signed(
                compared_value, compared_value_size) for possible_value in pred_comparison_values])
        elif jmp_ins.opcode == m_jg:
            is_jmp_always_taken = all([unsigned_to_signed(possible_value, compared_value_size) > unsigned_to_signed(
                compared_value, compared_value_size) for possible_value in pred_comparison_values])
            is_jmp_never_taken = all([unsigned_to_signed(possible_value, compared_value_size) <= unsigned_to_signed(
                compared_value, compared_value_size) for possible_value in pred_comparison_values])
        elif jmp_ins.opcode == m_jge:
            is_jmp_always_taken = all([unsigned_to_signed(possible_value, compared_value_size) >= unsigned_to_signed(
                compared_value, compared_value_size) for possible_value in pred_comparison_values])
            is_jmp_never_taken = all([unsigned_to_signed(possible_value, compared_value_size) < unsigned_to_signed(
                compared_value, compared_value_size) for possible_value in pred_comparison_values])
        elif jmp_ins.opcode == m_jl:
            is_jmp_always_taken = all([unsigned_to_signed(possible_value, compared_value_size) < unsigned_to_signed(
                compared_value, compared_value_size) for possible_value in pred_comparison_values])
            is_jmp_never_taken = all([unsigned_to_signed(possible_value, compared_value_size) >= unsigned_to_signed(
                compared_value, compared_value_size) for possible_value in pred_comparison_values])
        elif jmp_ins.opcode == m_jle:
            is_jmp_always_taken = all([unsigned_to_signed(possible_value, compared_value_size) <= unsigned_to_signed(
                compared_value, compared_value_size) for possible_value in pred_comparison_values])
            is_jmp_never_taken = all([unsigned_to_signed(possible_value, compared_value_size) > unsigned_to_signed(
                compared_value, compared_value_size) for possible_value in pred_comparison_values])
        return is_jmp_always_taken, is_jmp_never_taken

    def sort_predecessors(self, blk):
        # this function sorts the blk predecessors into three list:
        # - A list of predecessors where the jump is always taken
        # - A list of predecessors where the jump is never taken
        # - A list of predecessors where we don't know
        pred_jmp_always_taken = []
        pred_jmp_never_taken = []
        pred_jmp_unk = []
        op_compared = mop_t(blk.tail.l)
        blk_preset_list = [x for x in blk.predset]
        for pred_serial in blk_preset_list:
            cmp_variable_tracker = MopTracker([op_compared], max_nb_block=100, max_path=1000)
            cmp_variable_tracker.reset()
            pred_blk = blk.mba.get_mblock(pred_serial)
            pred_histories = cmp_variable_tracker.search_backward(pred_blk, pred_blk.tail)
            pred_values = get_all_possibles_values(pred_histories, [op_compared])
            pred_values = [x[0] for x in pred_values]
            unflat_logger.info("Pred {0} has {1} possible path ({2} different cst): {3}"
                               .format(pred_blk.serial, len(pred_values), len(set(pred_values)), pred_values))
            if None in pred_values:
                pred_jmp_unk.append(pred_blk)
                continue
            is_jmp_always_taken, is_jmp_never_taken = self.is_jump_taken(blk, pred_values)
            if is_jmp_always_taken and is_jmp_never_taken:
                # this should never happen
                unflat_logger.error("It seems that I am stupid: '{0}' is always taken and not taken when coming from {1}: {2}".format(format_minsn_t(blk.tail), pred_blk.serial, pred_values))
                pred_jmp_unk.append(pred_blk)
                continue
            if is_jmp_always_taken:
                unflat_logger.info("It seems that '{0}' is always taken when coming from {1}: {2}".format(format_minsn_t(blk.tail), pred_blk.serial, pred_values))
                pred_jmp_always_taken.append(pred_blk)
            if is_jmp_never_taken:
                unflat_logger.info("It seems that '{0}' is never taken when coming from {1}: {2}".format(format_minsn_t(blk.tail), pred_blk.serial, pred_values))
                pred_jmp_never_taken.append(pred_blk)
        return pred_jmp_always_taken, pred_jmp_never_taken, pred_jmp_unk

    def analyze_blk(self, blk: mblock_t) -> int:
        if (blk.tail is None) or blk.tail.opcode not in JMP_OPCODE_HANDLED:
            return 0
        if blk.tail.r.t != mop_n:
            return 0
        unflat_logger.info("Checking if block {0} can be simplified: {1}".format(blk.serial, format_minsn_t(blk.tail)))
        pred_jmp_always_taken, pred_jmp_never_taken, pred_jmp_unk = self.sort_predecessors(blk)
        unflat_logger.info("Block {0} has {1} preds: {2} always jmp, {3} never jmp, {4} unk".format(blk.serial, blk.npred(), len(pred_jmp_always_taken), len(pred_jmp_never_taken), len(pred_jmp_unk)))
        nb_change = 0
        if len(pred_jmp_always_taken) > 0:
            dump_microcode_for_debug(self.mba, self.log_dir, "{0}_{1}_before_jmp_always_fix".format(self.cur_maturity_pass, blk.serial))
            for pred_blk in pred_jmp_always_taken:
                new_jmp_block, new_default_block = duplicate_block(blk)
                make_2way_block_goto(new_jmp_block, blk.tail.d.b)
                update_blk_successor(pred_blk, blk.serial, new_jmp_block.serial)
            dump_microcode_for_debug(self.mba, self.log_dir, "{0}_{1}_after_jmp_always_fix".format(self.cur_maturity_pass, blk.serial))
            nb_change += len(pred_jmp_always_taken)
        if len(pred_jmp_never_taken) > 0:
            dump_microcode_for_debug(self.mba, self.log_dir, "{0}_{1}_before_jmp_never_fix".format(self.cur_maturity_pass, blk.serial))
            for pred_blk in pred_jmp_never_taken:
                new_jmp_block, new_default_block = duplicate_block(blk)
                make_2way_block_goto(new_jmp_block, blk.serial + 1)
                update_blk_successor(pred_blk, blk.serial, new_jmp_block.serial)
            dump_microcode_for_debug(self.mba, self.log_dir, "{0}_{1}_after_jmp_never_fix".format(self.cur_maturity_pass, blk.serial))
            nb_change += len(pred_jmp_never_taken)
        return nb_change

    def optimize(self, blk: mblock_t) -> int:
        self.mba = blk.mba
        if not self.check_if_rule_should_be_used(blk):
            return 0
        self.last_pass_nb_patch_done = self.analyze_blk(blk)
        if self.last_pass_nb_patch_done > 0:
            self.mba.mark_chains_dirty()
            self.mba.optimize_local(0)
            self.mba.verify(True)
        return self.last_pass_nb_patch_done

    def check_if_rule_should_be_used(self, blk: mblock_t) -> bool:
        if self.cur_maturity != self.mba.maturity:
            self.cur_maturity = self.mba.maturity
            self.cur_maturity_pass = 0
        if self.cur_maturity not in self.maturities:
            return False
        if (self.DEFAULT_MAX_PASSES is not None) and (self.cur_maturity_pass >= self.DEFAULT_MAX_PASSES):
            return False
        if (blk.tail is None) or blk.tail.opcode not in JMP_OPCODE_HANDLED:
            return False
        if blk.tail.r.t != mop_n:
            return False
        self.cur_maturity_pass += 1
        return True

```

`d810/optimizers/flow/flattening/generic.py`:

```py
from __future__ import annotations
import logging
from typing import List, Union, Tuple

from ida_hexrays import *

from d810.optimizers.flow.handler import FlowOptimizationRule

from d810.tracker import MopTracker, MopHistory, remove_segment_registers, duplicate_histories
from d810.emulator import MicroCodeEnvironment, MicroCodeInterpreter
from d810.hexrays_hooks import InstructionDefUseCollector
from d810.hexrays_helpers import extract_num_mop, get_mop_index, append_mop_if_not_in_list, CONTROL_FLOW_OPCODES, \
    CONDITIONAL_JUMP_OPCODES
from d810.hexrays_formatters import format_minsn_t, format_mop_t, dump_microcode_for_debug, format_mop_list
from d810.cfg_utils import mba_deep_cleaning, ensure_child_has_an_unconditional_father, ensure_last_block_is_goto, \
    change_1way_block_successor, create_block
from d810.optimizers.flow.flattening.utils import NotResolvableFatherException, NotDuplicableFatherException, \
    DispatcherUnflatteningException, get_all_possibles_values, check_if_all_values_are_found

unflat_logger = logging.getLogger('D810.unflat')


class GenericDispatcherBlockInfo(object):

    def __init__(self, blk, father=None):
        self.blk = blk
        self.ins = []
        self.use_list = []
        self.use_before_def_list = []
        self.def_list = []
        self.assume_def_list = []
        self.comparison_value = None
        self.compared_mop = None

        self.father = None
        if father is not None:
            self.register_father(father)

    @property
    def serial(self) -> int:
        return self.blk.serial

    def register_father(self, father: GenericDispatcherBlockInfo):
        self.father = father
        self.assume_def_list = [x for x in father.assume_def_list]

    def update_use_def_lists(self, ins_mops_used: List[mop_t], ins_mops_def: List[mop_t]):
        for mop_used in ins_mops_used:
            append_mop_if_not_in_list(mop_used, self.use_list)
            mop_used_index = get_mop_index(mop_used, self.def_list)
            if mop_used_index == -1:
                append_mop_if_not_in_list(mop_used, self.use_before_def_list)
        for mop_def in ins_mops_def:
            append_mop_if_not_in_list(mop_def, self.def_list)

    def update_with_ins(self, ins: minsn_t):
        ins_mop_info = InstructionDefUseCollector()
        ins.for_all_ops(ins_mop_info)
        cleaned_unresolved_ins_mops = remove_segment_registers(ins_mop_info.unresolved_ins_mops)
        self.update_use_def_lists(cleaned_unresolved_ins_mops + ins_mop_info.memory_unresolved_ins_mops,
                                  ins_mop_info.target_mops)
        self.ins.append(ins)
        if ins.opcode in CONDITIONAL_JUMP_OPCODES:
            num_mop, other_mop = extract_num_mop(ins)
            if num_mop is not None:
                self.comparison_value = num_mop.nnn.value
                self.compared_mop = other_mop

    def parse(self):
        curins = self.blk.head
        while curins is not None:
            self.update_with_ins(curins)
            curins = curins.next
        for mop_def in self.def_list:
            append_mop_if_not_in_list(mop_def, self.assume_def_list)

    def does_only_need(self, prerequisite_mop_list: List[mop_t]) -> bool:
        for used_before_def_mop in self.use_before_def_list:
            mop_index = get_mop_index(used_before_def_mop, prerequisite_mop_list)
            if mop_index == -1:
                return False
        return True

    def recursive_get_father(self) -> List[GenericDispatcherBlockInfo]:
        if self.father is None:
            return [self]
        else:
            return self.father.recursive_get_father() + [self]

    def show_history(self):
        full_father_list = self.recursive_get_father()
        unflat_logger.info("    Show history of Block {0}".format(self.blk.serial))
        for father in full_father_list[:-1]:
            for ins in father.ins:
                unflat_logger.info("      {0}.{1}".format(father.blk.serial, format_minsn_t(ins)))

    def print_info(self):
        unflat_logger.info("Block {0} information:".format(self.blk.serial))
        unflat_logger.info("  USE list: {0}".format(format_mop_list(self.use_list)))
        unflat_logger.info("  DEF list: {0}".format(format_mop_list(self.def_list)))
        unflat_logger.info("  USE BEFORE DEF list: {0}".format(format_mop_list(self.use_before_def_list)))
        unflat_logger.info("  ASSUME DEF list: {0}".format(format_mop_list(self.assume_def_list)))


class GenericDispatcherInfo(object):
    def __init__(self, mba: mbl_array_t):
        self.mba = mba
        self.mop_compared = None
        self.entry_block = None
        self.comparison_values = []
        self.dispatcher_internal_blocks = []
        self.dispatcher_exit_blocks = []

    def reset(self):
        self.mop_compared = None
        self.entry_block = None
        self.comparison_values = []
        self.dispatcher_internal_blocks = []
        self.dispatcher_exit_blocks = []

    def explore(self, blk: mblock_t) -> bool:
        return False

    def get_shared_internal_blocks(self, other_dispatcher: GenericDispatcherInfo) -> List[mblock_t]:
        my_dispatcher_block_serial = [blk_info.blk.serial for blk_info in self.dispatcher_internal_blocks]
        other_dispatcher_block_serial = [blk_info.blk.serial
                                         for blk_info in other_dispatcher.dispatcher_internal_blocks]
        return [self.mba.get_mblock(blk_serial) for blk_serial in my_dispatcher_block_serial
                if blk_serial in other_dispatcher_block_serial]

    def is_sub_dispatcher(self, other_dispatcher: GenericDispatcherInfo) -> bool:
        shared_blocks = self.get_shared_internal_blocks(other_dispatcher)
        if (len(shared_blocks) > 0) and (self.entry_block.blk.npred() < other_dispatcher.entry_block.blk.npred()):
            return True
        return False

    def should_emulation_continue(self, cur_blk: mblock_t) -> bool:
        exit_block_serial_list = [exit_block.serial for exit_block in self.dispatcher_exit_blocks]
        if (cur_blk is not None) and (cur_blk.serial not in exit_block_serial_list):
            return True
        return False

    def emulate_dispatcher_with_father_history(self, father_history: MopHistory) -> Tuple[mblock_t, List[minsn_t]]:
        microcode_interpreter = MicroCodeInterpreter()
        microcode_environment = MicroCodeEnvironment()
        dispatcher_input_info = []
        # First, we setup the MicroCodeEnvironment with the state variables (self.entry_block.use_before_def_list)
        # used by the dispatcher
        for initialization_mop in self.entry_block.use_before_def_list:
            # We recover the value of each state variable from the dispatcher father
            initialization_mop_value = father_history.get_mop_constant_value(initialization_mop)
            if initialization_mop_value is None:
                raise NotResolvableFatherException("Can't emulate dispatcher {0} with history {1}"
                                                   .format(self.entry_block.serial, father_history.block_serial_path))
            # We store this value in the MicroCodeEnvironment
            microcode_environment.define(initialization_mop, initialization_mop_value)
            dispatcher_input_info.append("{0} = {1:x}".format(format_mop_t(initialization_mop),
                                                              initialization_mop_value))

        unflat_logger.info("Executing dispatcher {0} with: {1}"
                           .format(self.entry_block.blk.serial, ", ".join(dispatcher_input_info)))

        # Now, we start the emulation of the code at the dispatcher entry block
        instructions_executed = []
        cur_blk = self.entry_block.blk
        cur_ins = cur_blk.head
        # We will continue emulation while we are in one of the dispatcher blocks
        while self.should_emulation_continue(cur_blk):
            unflat_logger.debug("  Executing: {0}.{1}".format(cur_blk.serial, format_minsn_t(cur_ins)))
            # We evaluate the current instruction of the dispatcher to determine
            # which block and instruction should be executed next
            is_ok = microcode_interpreter.eval_instruction(cur_blk, cur_ins, microcode_environment)
            if not is_ok:
                return cur_blk, instructions_executed
            instructions_executed.append(cur_ins)
            cur_blk = microcode_environment.next_blk
            cur_ins = microcode_environment.next_ins
        # We return the first block executed which is not part of the dispatcher
        # and all instructions which have been executed by the dispatcher
        return cur_blk, instructions_executed

    def print_info(self, verbose=False):
        unflat_logger.info("Dispatcher information: ")
        unflat_logger.info("  Entry block: {0}.{1}: ".format(self.entry_block.blk.serial,
                                                             format_minsn_t(self.entry_block.blk.tail)))
        unflat_logger.info("  Entry block predecessors: {0}: "
                           .format([blk_serial for blk_serial in self.entry_block.blk.predset]))
        unflat_logger.info("    Compared mop: {0} ".format(format_mop_t(self.mop_compared)))
        unflat_logger.info("    Comparison values: {0} ".format(", ".join([hex(x) for x in self.comparison_values])))
        self.entry_block.print_info()
        unflat_logger.info("  Number of internal blocks: {0} ({1})"
                           .format(len(self.dispatcher_internal_blocks),
                                   [blk_info.blk.serial for blk_info in self.dispatcher_internal_blocks]))
        if verbose:
            for disp_blk in self.dispatcher_internal_blocks:
                unflat_logger.info("    Internal block: {0}.{1} ".format(disp_blk.blk.serial,
                                                                         format_minsn_t(disp_blk.blk.tail)))
                disp_blk.show_history()
        unflat_logger.info("  Number of Exit blocks: {0} ({1})"
                           .format(len(self.dispatcher_exit_blocks),
                                   [blk_info.blk.serial for blk_info in self.dispatcher_exit_blocks]))
        if verbose:
            for exit_blk in self.dispatcher_exit_blocks:
                unflat_logger.info("    Exit block: {0}.{1} ".format(exit_blk.blk.serial,
                                                                     format_minsn_t(exit_blk.blk.head)))
                exit_blk.show_history()


class GenericDispatcherCollector(minsn_visitor_t):
    DISPATCHER_CLASS = GenericDispatcherInfo
    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 2
    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 2
    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 2

    def __init__(self):
        super().__init__()
        self.dispatcher_list = []
        self.explored_blk_serials = []
        self.dispatcher_min_internal_block = self.DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK
        self.dispatcher_min_exit_block = self.DEFAULT_DISPATCHER_MIN_EXIT_BLOCK
        self.dispatcher_min_comparison_value = self.DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE

    def configure(self, kwargs):
        if "min_dispatcher_internal_block" in kwargs.keys():
            self.dispatcher_min_internal_block = kwargs["min_dispatcher_internal_block"]
        if "min_dispatcher_exit_block" in kwargs.keys():
            self.dispatcher_min_exit_block = kwargs["min_dispatcher_exit_block"]
        if "min_dispatcher_comparison_value" in kwargs.keys():
            self.dispatcher_min_comparison_value = kwargs["min_dispatcher_comparison_value"]

    def specific_checks(self, disp_info: GenericDispatcherInfo) -> bool:
        unflat_logger.debug("DispatcherInfo {0} : {1} internals, {2} exits, {3} comparison"
                            .format(self.blk.serial, len(disp_info.dispatcher_internal_blocks),
                                    len(disp_info.dispatcher_exit_blocks), len(set(disp_info.comparison_values))))
        if len(disp_info.dispatcher_internal_blocks) < self.dispatcher_min_internal_block:
            return False
        if len(disp_info.dispatcher_exit_blocks) < self.dispatcher_min_exit_block:
            return False
        if len(set(disp_info.comparison_values)) < self.dispatcher_min_comparison_value:
            return False
        self.dispatcher_list.append(disp_info)
        return True

    def visit_minsn(self):
        if self.blk.serial in self.explored_blk_serials:
            return 0
        self.explored_blk_serials.append(self.blk.serial)
        disp_info = self.DISPATCHER_CLASS(self.blk.mba)
        is_good_candidate = disp_info.explore(self.blk)
        if not is_good_candidate:
            return 0
        if not self.specific_checks(disp_info):
            return 0
        self.dispatcher_list.append(disp_info)
        return 0

    def remove_sub_dispatchers(self):
        main_dispatcher_list = []
        for dispatcher_1 in self.dispatcher_list:
            is_dispatcher_1_sub_dispatcher = False
            for dispatcher_2 in self.dispatcher_list:
                if dispatcher_1.is_sub_dispatcher(dispatcher_2):
                    is_dispatcher_1_sub_dispatcher = True
                    break
            if not is_dispatcher_1_sub_dispatcher:
                main_dispatcher_list.append(dispatcher_1)
        self.dispatcher_list = [x for x in main_dispatcher_list]

    def reset(self):
        self.dispatcher_list = []
        self.explored_blk_serials = []

    def get_dispatcher_list(self) -> List[GenericDispatcherInfo]:
        self.remove_sub_dispatchers()
        return self.dispatcher_list


class GenericUnflatteningRule(FlowOptimizationRule):
    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]

    def __init__(self):
        super().__init__()
        self.mba = None
        self.cur_maturity = MMAT_ZERO
        self.cur_maturity_pass = 0
        self.last_pass_nb_patch_done = 0
        self.maturities = self.DEFAULT_UNFLATTENING_MATURITIES

    def check_if_rule_should_be_used(self, blk: mblock_t) -> bool:
        if self.cur_maturity == self.mba.maturity:
            self.cur_maturity_pass += 1
        else:
            self.cur_maturity = self.mba.maturity
            self.cur_maturity_pass = 0
        if self.cur_maturity not in self.maturities:
            return False
        return True


class GenericDispatcherUnflatteningRule(GenericUnflatteningRule):
    DISPATCHER_COLLECTOR_CLASS = GenericDispatcherCollector
    MOP_TRACKER_MAX_NB_BLOCK = 100
    MOP_TRACKER_MAX_NB_PATH = 100
    DEFAULT_MAX_DUPLICATION_PASSES = 20
    DEFAULT_MAX_PASSES = 5

    def __init__(self):
        super().__init__()
        self.dispatcher_collector = self.DISPATCHER_COLLECTOR_CLASS()
        self.dispatcher_list = []
        self.max_duplication_passes = self.DEFAULT_MAX_DUPLICATION_PASSES
        self.max_passes = self.DEFAULT_MAX_PASSES
        self.non_significant_changes = 0

    def check_if_rule_should_be_used(self, blk: mblock_t) -> bool:
        if not super().check_if_rule_should_be_used(blk):
            return False
        if (self.cur_maturity_pass >= 1) and (self.last_pass_nb_patch_done == 0):
            return False
        if (self.max_passes is not None) and (self.cur_maturity_pass >= self.max_passes):
            return False
        return True

    def configure(self, kwargs):
        super().configure(kwargs)
        if "max_passes" in self.config.keys():
            self.max_passes = self.config["max_passes"]
        if "max_duplication_passes" in self.config.keys():
            self.max_duplication_passes = self.config["max_duplication_passes"]
        self.dispatcher_collector.configure(kwargs)

    def retrieve_all_dispatchers(self):
        self.dispatcher_list = []
        self.dispatcher_collector.reset()
        self.mba.for_all_topinsns(self.dispatcher_collector)
        self.dispatcher_list = [x for x in self.dispatcher_collector.get_dispatcher_list()]

    def ensure_all_dispatcher_fathers_are_direct(self) -> int:
        nb_change = 0
        for dispatcher_info in self.dispatcher_list:
            nb_change += self.ensure_dispatcher_fathers_are_direct(dispatcher_info)
            dispatcher_father_list = [self.mba.get_mblock(x) for x in dispatcher_info.entry_block.blk.predset]
            for dispatcher_father in dispatcher_father_list:
                nb_change += ensure_child_has_an_unconditional_father(dispatcher_father,
                                                                      dispatcher_info.entry_block.blk)
        return nb_change

    def ensure_dispatcher_fathers_are_direct(self, dispatcher_info: GenericDispatcherInfo) -> int:
        nb_change = 0
        dispatcher_father_list = [self.mba.get_mblock(x) for x in dispatcher_info.entry_block.blk.predset]
        for dispatcher_father in dispatcher_father_list:
            nb_change += ensure_child_has_an_unconditional_father(dispatcher_father, dispatcher_info.entry_block.blk)
        return nb_change

    def register_initialization_variables(self, mop_tracker):
        pass

    def get_dispatcher_father_histories(self, dispatcher_father: mblock_t,
                                        dispatcher_entry_block: GenericDispatcherBlockInfo) -> List[MopHistory]:
        father_tracker = MopTracker(dispatcher_entry_block.use_before_def_list,
                                    max_nb_block=self.MOP_TRACKER_MAX_NB_BLOCK, max_path=self.MOP_TRACKER_MAX_NB_PATH)
        father_tracker.reset()
        self.register_initialization_variables(father_tracker)
        father_histories = father_tracker.search_backward(dispatcher_father, None)
        return father_histories

    def check_if_histories_are_resolved(self, mop_histories: List[MopHistory]) -> bool:
        return all([mop_history.is_resolved() for mop_history in mop_histories])

    def ensure_dispatcher_father_is_resolvable(self, dispatcher_father: mblock_t,
                                               dispatcher_entry_block: GenericDispatcherBlockInfo) -> int:
        father_histories = self.get_dispatcher_father_histories(dispatcher_father, dispatcher_entry_block)
        father_histories_cst = get_all_possibles_values(father_histories, dispatcher_entry_block.use_before_def_list,
                                                        verbose=False)
        father_is_resolvable = self.check_if_histories_are_resolved(father_histories)
        if not father_is_resolvable:
            raise NotDuplicableFatherException("Dispatcher {0} predecessor {1} is not duplicable: {2}"
                                               .format(dispatcher_entry_block.serial, dispatcher_father.serial,
                                                       father_histories_cst))
        for father_history_cst in father_histories_cst:
            if None in father_history_cst:
                raise NotDuplicableFatherException("Dispatcher {0} predecessor {1} has None value: {2}"
                                                   .format(dispatcher_entry_block.serial, dispatcher_father.serial,
                                                           father_histories_cst))

        unflat_logger.info("Dispatcher {0} predecessor {1} is resolvable: {2}"
                           .format(dispatcher_entry_block.serial, dispatcher_father.serial, father_histories_cst))
        nb_duplication, nb_change = duplicate_histories(father_histories, max_nb_pass=self.max_duplication_passes)
        unflat_logger.info("Dispatcher {0} predecessor {1} duplication: {2} blocks created, {3} changes made"
                           .format(dispatcher_entry_block.serial, dispatcher_father.serial, nb_duplication, nb_change))
        return nb_duplication + nb_change

    def resolve_dispatcher_father(self, dispatcher_father: mblock_t, dispatcher_info: GenericDispatcherInfo) -> int:
        dispatcher_father_histories = self.get_dispatcher_father_histories(dispatcher_father,
                                                                           dispatcher_info.entry_block)
        father_is_resolvable = self.check_if_histories_are_resolved(dispatcher_father_histories)
        if not father_is_resolvable:
            raise NotResolvableFatherException("Can't fix block {0}".format(dispatcher_father.serial))
        mop_searched_values_list = get_all_possibles_values(dispatcher_father_histories,
                                                            dispatcher_info.entry_block.use_before_def_list,
                                                            verbose=False)
        all_values_found = check_if_all_values_are_found(mop_searched_values_list)
        if not all_values_found:
            raise NotResolvableFatherException("Can't fix block {0}".format(dispatcher_father.serial))

        ref_mop_searched_values = mop_searched_values_list[0]
        for tmp_mop_searched_values in mop_searched_values_list:
            if tmp_mop_searched_values != ref_mop_searched_values:
                raise NotResolvableFatherException("Dispatcher {0} predecessor {1} is not resolvable: {2}"
                                                   .format(dispatcher_info.entry_block.serial, dispatcher_father.serial,
                                                           mop_searched_values_list))

        target_blk, disp_ins = dispatcher_info.emulate_dispatcher_with_father_history(dispatcher_father_histories[0])
        if target_blk is not None:
            unflat_logger.debug("Unflattening graph: Making {0} goto {1}"
                                .format(dispatcher_father.serial, target_blk.serial))
            ins_to_copy = [ins for ins in disp_ins if ((ins is not None) and (ins.opcode not in CONTROL_FLOW_OPCODES))]
            if len(ins_to_copy) > 0:
                unflat_logger.info("Instruction copied: {0}: {1}"
                                   .format(len(ins_to_copy),
                                           ", ".join([format_minsn_t(ins_copied) for ins_copied in ins_to_copy])))
                dispatcher_side_effect_blk = create_block(self.mba.get_mblock(self.mba.qty - 2), ins_to_copy,
                                                          is_0_way=(target_blk.type == BLT_0WAY))
                change_1way_block_successor(dispatcher_father, dispatcher_side_effect_blk.serial)
                change_1way_block_successor(dispatcher_side_effect_blk, target_blk.serial)
            else:
                change_1way_block_successor(dispatcher_father, target_blk.serial)
            return 2

        raise NotResolvableFatherException("Can't fix block {0}: no block for key: {1}"
                                           .format(dispatcher_father.serial, mop_searched_values_list))

    def remove_flattening(self) -> int:
        total_nb_change = 0
        self.non_significant_changes = ensure_last_block_is_goto(self.mba)
        self.non_significant_changes += self.ensure_all_dispatcher_fathers_are_direct()
        for dispatcher_info in self.dispatcher_list:
            dump_microcode_for_debug(self.mba, self.log_dir, "unflat_{0}_dispatcher_{1}_before_duplication"
                                     .format(self.cur_maturity_pass, dispatcher_info.entry_block.serial))
            unflat_logger.info("Searching dispatcher for entry block {0} {1} ->  with variables ({2})..."
                               .format(dispatcher_info.entry_block.serial, format_mop_t(dispatcher_info.mop_compared),
                                       format_mop_list(dispatcher_info.entry_block.use_before_def_list)))
            dispatcher_father_list = [self.mba.get_mblock(x) for x in dispatcher_info.entry_block.blk.predset]
            for dispatcher_father in dispatcher_father_list:
                try:
                    total_nb_change += self.ensure_dispatcher_father_is_resolvable(dispatcher_father,
                                                                                   dispatcher_info.entry_block)
                except NotDuplicableFatherException as e:
                    unflat_logger.warning(e)
                    pass
            dump_microcode_for_debug(self.mba, self.log_dir, "unflat_{0}_dispatcher_{1}_after_duplication"
                                     .format(self.cur_maturity_pass, dispatcher_info.entry_block.serial))
            # During the previous step we changed dispatcher entry block fathers, so we need to reload them
            dispatcher_father_list = [self.mba.get_mblock(x) for x in dispatcher_info.entry_block.blk.predset]
            nb_flattened_branches = 0
            for dispatcher_father in dispatcher_father_list:
                try:
                    nb_flattened_branches += self.resolve_dispatcher_father(dispatcher_father, dispatcher_info)
                except NotResolvableFatherException as e:
                    unflat_logger.warning(e)
                    pass
            dump_microcode_for_debug(self.mba, self.log_dir, "unflat_{0}_dispatcher_{1}_after_unflattening"
                                     .format(self.cur_maturity_pass, dispatcher_info.entry_block.serial))

        unflat_logger.info("Unflattening removed {0} branch".format(nb_flattened_branches))
        total_nb_change += nb_flattened_branches
        return total_nb_change

    def optimize(self, blk: mblock_t) -> int:
        self.mba = blk.mba
        if not self.check_if_rule_should_be_used(blk):
            return 0
        self.last_pass_nb_patch_done = 0
        unflat_logger.info("Unflattening at maturity {0} pass {1}".format(self.cur_maturity, self.cur_maturity_pass))
        dump_microcode_for_debug(self.mba, self.log_dir, "unflat_{0}_start".format(self.cur_maturity_pass))
        self.retrieve_all_dispatchers()
        if len(self.dispatcher_list) == 0:
            unflat_logger.info("No dispatcher found at maturity {0}".format(self.mba.maturity))
            return 0
        else:
            unflat_logger.info("Unflattening: {0} dispatcher(s) found".format(len(self.dispatcher_list)))
            for dispatcher_info in self.dispatcher_list:
                dispatcher_info.print_info()
            self.last_pass_nb_patch_done = self.remove_flattening()
        unflat_logger.info("Unflattening at maturity {0} pass {1}: {2} changes"
                           .format(self.cur_maturity, self.cur_maturity_pass, self.last_pass_nb_patch_done))
        nb_clean = mba_deep_cleaning(self.mba, False)
        dump_microcode_for_debug(self.mba, self.log_dir, "unflat_{0}_after_cleaning".format(self.cur_maturity_pass))
        if self.last_pass_nb_patch_done + nb_clean + self.non_significant_changes > 0:
            self.mba.mark_chains_dirty()
            self.mba.optimize_local(0)
        self.mba.verify(True)
        return self.last_pass_nb_patch_done

```

`d810/optimizers/flow/flattening/unflattener.py`:

```py
import logging
from typing import Tuple, List
from ida_hexrays import *

from d810.hexrays_helpers import extract_num_mop, append_mop_if_not_in_list
from d810.optimizers.flow.flattening.generic import GenericDispatcherCollector, GenericDispatcherInfo, \
    GenericDispatcherBlockInfo, GenericDispatcherUnflatteningRule


unflat_logger = logging.getLogger('D810.unflat')
FLATTENING_JUMP_OPCODES = [m_jnz, m_jz, m_jae, m_jb, m_ja, m_jbe, m_jg, m_jge, m_jl, m_jle]


class OllvmDispatcherBlockInfo(GenericDispatcherBlockInfo):
    pass


class OllvmDispatcherInfo(GenericDispatcherInfo):
    def explore(self, blk: mblock_t) -> bool:
        self.reset()
        if not self._is_candidate_for_dispatcher_entry_block(blk):
            return False
        self.entry_block = OllvmDispatcherBlockInfo(blk)
        self.entry_block.parse()
        for used_mop in self.entry_block.use_list:
            append_mop_if_not_in_list(used_mop, self.entry_block.assume_def_list)
        self.dispatcher_internal_blocks.append(self.entry_block)
        num_mop, self.mop_compared = self._get_comparison_info(self.entry_block.blk)
        self.comparison_values.append(num_mop.nnn.value)
        self._explore_children(self.entry_block)
        dispatcher_blk_with_external_father = self._get_dispatcher_blocks_with_external_father()
        # TODO: I think this can be wrong because we are too permissive in detection of dispatcher blocks
        if len(dispatcher_blk_with_external_father) != 0:
            return False
        return True

    def _is_candidate_for_dispatcher_entry_block(self, blk: mblock_t) -> bool:
        # blk must be a condition branch with one numerical operand
        num_mop, mop_compared = self._get_comparison_info(blk)
        if (num_mop is None) or (mop_compared is None):
            return False
        # Its fathers are not conditional branch with this mop
        for father_serial in blk.predset:
            father_blk = self.mba.get_mblock(father_serial)
            father_num_mop, father_mop_compared = self._get_comparison_info(father_blk)
            if (father_num_mop is not None) and (father_mop_compared is not None):
                if mop_compared.equal_mops(father_mop_compared, EQ_IGNSIZE):
                    return False
        return True

    def _get_comparison_info(self, blk: mblock_t) -> Tuple[mop_t, mop_t]:
        # We check if blk is a good candidate for dispatcher entry block: blk.tail must be a conditional branch
        if (blk.tail is None) or (blk.tail.opcode not in FLATTENING_JUMP_OPCODES):
            return None, None
        # One operand must be numerical
        num_mop, mop_compared = extract_num_mop(blk.tail)
        if num_mop is None or mop_compared is None:
            return None, None
        return num_mop, mop_compared

    def is_part_of_dispatcher(self, block_info: OllvmDispatcherBlockInfo) -> bool:
        is_ok = block_info.does_only_need(block_info.father.assume_def_list)
        if not is_ok:
            return False
        if (block_info.blk.tail is not None) and (block_info.blk.tail.opcode not in FLATTENING_JUMP_OPCODES):
            return False
        return True

    def _explore_children(self, father_info: OllvmDispatcherBlockInfo):
        for child_serial in father_info.blk.succset:
            if child_serial in [blk_info.blk.serial for blk_info in self.dispatcher_internal_blocks]:
                return
            if child_serial in [blk_info.blk.serial for blk_info in self.dispatcher_exit_blocks]:
                return
            child_blk = self.mba.get_mblock(child_serial)
            child_info = OllvmDispatcherBlockInfo(child_blk, father_info)
            child_info.parse()
            if not self.is_part_of_dispatcher(child_info):
                self.dispatcher_exit_blocks.append(child_info)
            else:
                self.dispatcher_internal_blocks.append(child_info)
                if child_info.comparison_value is not None:
                    self.comparison_values.append(child_info.comparison_value)
                self._explore_children(child_info)

    def _get_external_fathers(self, block_info: OllvmDispatcherBlockInfo) -> List[mblock_t]:
        internal_serials = [blk_info.blk.serial for blk_info in self.dispatcher_internal_blocks]
        external_fathers = []
        for blk_father in block_info.blk.predset:
            if blk_father not in internal_serials:
                external_fathers.append(blk_father)
        return external_fathers

    def _get_dispatcher_blocks_with_external_father(self) -> List[mblock_t]:
        dispatcher_blocks_with_external_father = []
        for blk_info in self.dispatcher_internal_blocks:
            if blk_info.blk.serial != self.entry_block.blk.serial:
                external_fathers = self._get_external_fathers(blk_info)
                if len(external_fathers) > 0:
                    dispatcher_blocks_with_external_father.append(blk_info)
        return dispatcher_blocks_with_external_father


class OllvmDispatcherCollector(GenericDispatcherCollector):
    DISPATCHER_CLASS = OllvmDispatcherInfo
    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 2
    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 3
    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 2


class Unflattener(GenericDispatcherUnflatteningRule):
    DESCRIPTION = "Remove control flow flattening generated by OLLVM"
    DISPATCHER_COLLECTOR_CLASS = OllvmDispatcherCollector
    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1, MMAT_GLBOPT2]
    DEFAULT_MAX_DUPLICATION_PASSES = 20
    DEFAULT_MAX_PASSES = 5

```

`d810/optimizers/flow/flattening/unflattener_fake_jump.py`:

```py
import logging
from typing import List
from ida_hexrays import *

from d810.tracker import MopTracker
from d810.cfg_utils import change_1way_block_successor
from d810.hexrays_formatters import format_minsn_t, dump_microcode_for_debug
from d810.optimizers.flow.flattening.utils import get_all_possibles_values
from d810.optimizers.flow.flattening.generic import GenericUnflatteningRule

unflat_logger = logging.getLogger('D810.unflat')

FAKE_LOOP_OPCODES = [m_jz, m_jnz]


class UnflattenerFakeJump(GenericUnflatteningRule):
    DESCRIPTION = "Check if a jump is always taken for each father blocks and remove them"
    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]
    DEFAULT_MAX_PASSES = None

    def analyze_blk(self, blk: mblock_t) -> int:
        if (blk.tail is None) or blk.tail.opcode not in FAKE_LOOP_OPCODES:
            return 0
        if blk.get_reginsn_qty() != 1:
            return 0
        if blk.tail.r.t != mop_n:
            return 0
        unflat_logger.info("Checking if block {0} is fake loop: {1}".format(blk.serial, format_minsn_t(blk.tail)))
        op_compared = mop_t(blk.tail.l)
        blk_preset_list = [x for x in blk.predset]
        nb_change = 0
        for pred_serial in blk_preset_list:
            cmp_variable_tracker = MopTracker([op_compared], max_nb_block=100, max_path=1000)
            cmp_variable_tracker.reset()
            pred_blk = blk.mba.get_mblock(pred_serial)
            pred_histories = cmp_variable_tracker.search_backward(pred_blk, pred_blk.tail)

            father_is_resolvable = all([father_history.is_resolved() for father_history in pred_histories])
            if not father_is_resolvable:
                return 0
            pred_values = get_all_possibles_values(pred_histories, [op_compared])
            pred_values = [x[0] for x in pred_values]
            if None in pred_values:
                unflat_logger.info("Some path are not resolved, can't fix jump")
                return 0
            unflat_logger.info("Pred {0} has {1} possible path ({2} different cst): {3}"
                               .format(pred_blk.serial, len(pred_values), len(set(pred_values)), pred_values))
            if self.fix_successor(blk, pred_blk, pred_values):
                nb_change += 1
        return nb_change

    def fix_successor(self, fake_loop_block: mblock_t, pred: mblock_t, pred_comparison_values: List[int]) -> bool:
        if len(pred_comparison_values) == 0:
            return False
        jmp_ins = fake_loop_block.tail
        compared_value = jmp_ins.r.nnn.value
        jmp_taken = False
        jmp_not_taken = False
        dst_serial = None
        if jmp_ins.opcode == m_jz:
            jmp_taken = all([possible_value == compared_value for possible_value in pred_comparison_values])

            jmp_not_taken = all([possible_value != compared_value for possible_value in pred_comparison_values])
        elif jmp_ins.opcode == m_jnz:
            jmp_taken = all([possible_value != compared_value for possible_value in pred_comparison_values])
            jmp_not_taken = all([possible_value == compared_value for possible_value in pred_comparison_values])
        # TODO: handles other jumps cases
        if jmp_taken:
            unflat_logger.info("It seems that '{0}' is always taken when coming from {1}: {2}"
                               .format(format_minsn_t(jmp_ins), pred.serial, pred_comparison_values))
            dst_serial = jmp_ins.d.b
        if jmp_not_taken:
            unflat_logger.info("It seems that '{0}' is never taken when coming from {1}: {2}"
                               .format(format_minsn_t(jmp_ins), pred.serial, pred_comparison_values))
            dst_serial = fake_loop_block.serial + 1
        if dst_serial is None:
            unflat_logger.debug("Jump seems legit '{0}' from {1}: {2}"
                                .format(format_minsn_t(jmp_ins), pred.serial, pred_comparison_values))
            return False
        dump_microcode_for_debug(self.mba, self.log_dir, "{0}_before_fake_jump".format(self.cur_maturity_pass))
        unflat_logger.info("Making pred {0} with value {1} goto {2} ({3})"
                           .format(pred.serial, pred_comparison_values, dst_serial, format_minsn_t(jmp_ins)))
        dump_microcode_for_debug(self.mba, self.log_dir, "{0}_after_fake_jump".format(self.cur_maturity_pass))
        return change_1way_block_successor(pred, dst_serial)

    def optimize(self, blk: mblock_t) -> int:
        self.mba = blk.mba
        if not self.check_if_rule_should_be_used(blk):
            return 0
        self.last_pass_nb_patch_done = self.analyze_blk(blk)
        if self.last_pass_nb_patch_done > 0:
            self.mba.mark_chains_dirty()
            self.mba.optimize_local(0)
            self.mba.verify(True)
        return self.last_pass_nb_patch_done

```

`d810/optimizers/flow/flattening/unflattener_indirect.py`:

```py
import logging
import idaapi
from typing import List
from ida_hexrays import *

from d810.hexrays_helpers import append_mop_if_not_in_list, AND_TABLE, CONTROL_FLOW_OPCODES
from d810.tracker import MopTracker, MopHistory
from d810.optimizers.flow.flattening.generic import GenericDispatcherBlockInfo, GenericDispatcherInfo, \
    GenericDispatcherCollector, GenericDispatcherUnflatteningRule, NotDuplicableFatherException, DispatcherUnflatteningException, NotResolvableFatherException
from d810.optimizers.flow.flattening.utils import configure_mop_tracker_log_verbosity, restore_mop_tracker_log_verbosity
from d810.tracker import duplicate_histories
from d810.cfg_utils import create_block, change_1way_block_successor
from d810.hexrays_formatters import format_minsn_t, format_mop_t
from d810.emulator import MicroCodeEnvironment, MicroCodeInterpreter

unflat_logger = logging.getLogger('D810.unflat')
FLATTENING_JUMP_OPCODES = [m_jtbl]


class TigressIndirectDispatcherBlockInfo(GenericDispatcherBlockInfo):
    pass


class TigressIndirectDispatcherInfo(GenericDispatcherInfo):
    def explore(self, blk: mblock_t):
        self.reset()
        if not self._is_candidate_for_dispatcher_entry_block(blk):
            return False
        self.mop_compared = self._get_comparison_info(blk)
        self.entry_block = TigressIndirectDispatcherBlockInfo(blk)
        self.entry_block.parse()
        for used_mop in self.entry_block.use_list:
            append_mop_if_not_in_list(used_mop, self.entry_block.assume_def_list)
        self.dispatcher_internal_blocks.append(self.entry_block)

        self.dispatcher_exit_blocks = []
        self.comparison_values = []
        return True

    def _get_comparison_info(self, blk: mblock_t):
        if (blk.tail is None) or (blk.tail.opcode != m_ijmp):
            return None, None
        return blk.tail.l

    def _is_candidate_for_dispatcher_entry_block(self, blk: mblock_t):
        if (blk.tail is None) or (blk.tail.opcode != m_ijmp):
            return False
        return True

    def should_emulation_continue(self, cur_blk: mblock_t):
        if (cur_blk is not None) and (cur_blk.serial == self.entry_block.serial):
            return True
        return False


class TigressIndirectDispatcherCollector(GenericDispatcherCollector):
    DISPATCHER_CLASS = TigressIndirectDispatcherInfo
    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 0
    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 0
    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 0


class LabelTableInfo(object):
    def __init__(self, sp_offset, mem_offset, nb_elt, ptr_size=8):
        self.sp_offset = sp_offset
        self.mem_offset = mem_offset
        self.nb_elt = nb_elt
        self.ptr_size = ptr_size

    def update_mop_tracker(self, mba: mbl_array_t, mop_tracker: MopTracker):
        stack_array_base_address = mba.stkoff_ida2vd(self.sp_offset)
        for i in range(self.nb_elt):
            tmp_mop = mop_t()
            tmp_mop.erase()
            tmp_mop._make_stkvar(mba, stack_array_base_address + self.ptr_size * i)
            tmp_mop.size = self.ptr_size
            mem_val = idaapi.get_qword(self.mem_offset + self.ptr_size * i) & AND_TABLE[self.ptr_size]
            mop_tracker.add_mop_definition(tmp_mop, mem_val)


class UnflattenerTigressIndirect(GenericDispatcherUnflatteningRule):
    DESCRIPTION = ""
    DISPATCHER_COLLECTOR_CLASS = TigressIndirectDispatcherCollector
    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_LOCOPT]
    DEFAULT_MAX_DUPLICATION_PASSES = 20
    DEFAULT_MAX_PASSES = 1

    def __init__(self):
        super().__init__()
        self.label_info = None
        self.goto_table_info = {}

    def configure(self, kwargs):
        super().configure(kwargs)
        if "goto_table_info" in self.config.keys():
            for ea_str, table_info in self.config["goto_table_info"].items():
                self.goto_table_info[int(ea_str, 16)] = LabelTableInfo(sp_offset=int(table_info["stack_table_offset"], 16),
                                                                       mem_offset=int(table_info["table_address"], 16),
                                                                       nb_elt=table_info["table_nb_elt"])

    def check_if_rule_should_be_used(self, blk: mblock_t):
        if not super().check_if_rule_should_be_used(blk):
            return False
        if self.mba.entry_ea not in self.goto_table_info:
            return False
        if (self.cur_maturity_pass >= 1) and (self.last_pass_nb_patch_done == 0):
            return False
        self.label_info = self.goto_table_info[self.mba.entry_ea]
        return True

    def register_initialization_variables(self, mop_tracker: MopTracker):
        self.label_info.update_mop_tracker(self.mba, mop_tracker)

    def check_if_histories_are_resolved(self, mop_histories: List[MopHistory]):
        return True

```

`d810/optimizers/flow/flattening/unflattener_switch_case.py`:

```py
import logging
from ida_hexrays import *

from d810.hexrays_helpers import append_mop_if_not_in_list
from d810.optimizers.flow.flattening.generic import GenericDispatcherBlockInfo, GenericDispatcherInfo, \
    GenericDispatcherCollector, GenericDispatcherUnflatteningRule


unflat_logger = logging.getLogger('D810.unflat')
FLATTENING_JUMP_OPCODES = [m_jtbl]


class TigressSwitchDispatcherBlockInfo(GenericDispatcherBlockInfo):
    pass


class TigressSwitchDispatcherInfo(GenericDispatcherInfo):
    def explore(self, blk: mblock_t):
        self.reset()
        if not self._is_candidate_for_dispatcher_entry_block(blk):
            return False
        self.mop_compared, mcases = self._get_comparison_info(blk)
        self.entry_block = TigressSwitchDispatcherBlockInfo(blk)
        self.entry_block.parse()
        for used_mop in self.entry_block.use_list:
            append_mop_if_not_in_list(used_mop, self.entry_block.assume_def_list)
        self.dispatcher_internal_blocks.append(self.entry_block)
        for possible_values, target_block_serial in zip(mcases.c.values, mcases.c.targets):
            if target_block_serial == self.entry_block.blk.serial:
                continue
            exit_block = TigressSwitchDispatcherBlockInfo(blk.mba.get_mblock(target_block_serial), self.entry_block)
            self.dispatcher_exit_blocks.append(exit_block)
            if len(possible_values) == 0:
                continue
            self.comparison_values.append(possible_values[0])
        return True

    def _get_comparison_info(self, blk: mblock_t):
        # blk.tail must be a jtbl
        if (blk.tail is None) or (blk.tail.opcode != m_jtbl):
            return None, None
        return blk.tail.l, blk.tail.r

    def _is_candidate_for_dispatcher_entry_block(self, blk: mblock_t):
        if (blk.tail is None) or (blk.tail.opcode != m_jtbl):
            return False
        return True


class TigressSwitchDispatcherCollector(GenericDispatcherCollector):
    DISPATCHER_CLASS = TigressSwitchDispatcherInfo
    DEFAULT_DISPATCHER_MIN_INTERNAL_BLOCK = 0
    DEFAULT_DISPATCHER_MIN_EXIT_BLOCK = 4
    DEFAULT_DISPATCHER_MIN_COMPARISON_VALUE = 4


class UnflattenerSwitchCase(GenericDispatcherUnflatteningRule):
    DESCRIPTION = "Remove control flow flattening generated by Tigress with Switch case dispatcher"
    DISPATCHER_COLLECTOR_CLASS = TigressSwitchDispatcherCollector
    DEFAULT_UNFLATTENING_MATURITIES = [MMAT_GLBOPT1]
    DEFAULT_MAX_DUPLICATION_PASSES = 20
    DEFAULT_MAX_PASSES = 5

```

`d810/optimizers/flow/flattening/utils.py`:

```py
import logging


tracker_logger = logging.getLogger('D810.tracker')
emulator_logger = logging.getLogger('D810.emulator')


class UnflatteningException(Exception):
    pass


class DispatcherUnflatteningException(UnflatteningException):
    pass


class NotDuplicableFatherException(UnflatteningException):
    pass


class NotResolvableFatherException(UnflatteningException):
    pass




def configure_mop_tracker_log_verbosity(verbose=False):
    tracker_log_level = tracker_logger.getEffectiveLevel()
    emulator_log_level = emulator_logger.getEffectiveLevel()
    if not verbose:
        tracker_logger.setLevel(logging.ERROR)
        emulator_logger.setLevel(logging.ERROR)
    return [tracker_log_level, emulator_log_level]


def restore_mop_tracker_log_verbosity(tracker_log_level, emulator_log_level):
    tracker_logger.setLevel(tracker_log_level)
    emulator_logger.setLevel(emulator_log_level)


def get_all_possibles_values(mop_histories, searched_mop_list, verbose=False):
    log_levels = configure_mop_tracker_log_verbosity(verbose)
    mop_cst_values_list = []
    for mop_history in mop_histories:
        mop_cst_values_list.append([mop_history.get_mop_constant_value(searched_mop)
                                    for searched_mop in searched_mop_list])
    restore_mop_tracker_log_verbosity(*log_levels)
    return mop_cst_values_list


def check_if_all_values_are_found(mop_cst_values_list):
    all_values_are_found = True
    for cst_list in mop_cst_values_list:
        if None in cst_list:
            all_values_are_found = False
            break
    return all_values_are_found

```

`d810/optimizers/flow/handler.py`:

```py
import logging
import idc

from d810.optimizers.handler import OptimizationRule, DEFAULT_FLOW_MATURITIES

logger = logging.getLogger('D810.optimizer')


class FlowOptimizationRule(OptimizationRule):
    def __init__(self):
        super().__init__()
        self.maturities = DEFAULT_FLOW_MATURITIES
        self.use_whitelist = False
        self.whitelisted_function_ea_list = []
        self.use_blacklist = False
        self.blacklisted_function_ea_list = []

    def configure(self, kwargs):
        super().configure(kwargs)
        self.use_whitelist = False
        self.whitelisted_function_ea_list = []
        self.use_blacklist = False
        self.blacklisted_function_ea_list = []
        if "whitelisted_functions" in self.config.keys():
            self.use_whitelist = True
            for func_ea in self.config["whitelisted_functions"]:
                self.whitelisted_function_ea_list.append(int(func_ea, 16))
            func_name_list = [idc.get_func_name(ea) for ea in self.whitelisted_function_ea_list]
            logger.info("Whitelisted functions for {0}: {1} -> {2}".format(self.__class__.__name__,
                                                                           self.whitelisted_function_ea_list,
                                                                           func_name_list))
        if "blacklisted_functions" in self.config.keys():
            self.use_blacklist = True
            for func_ea in self.config["whitelisted_functions"]:
                self.blacklisted_function_ea_list.append(int(func_ea, 16))
            func_name_list = [idc.get_func_name(ea) for ea in self.blacklisted_function_ea_list]
            logger.info("Blacklisted functions for {0}: {1} -> {2}".format(self.__class__.__name__,
                                                                           self.blacklisted_function_ea_list,
                                                                           func_name_list))

```

`d810/optimizers/flow/jumps/__init__.py`:

```py
from d810.utils import get_all_subclasses
from d810.optimizers.flow.jumps.handler import JumpOptimizationRule, JumpFixer
from d810.optimizers.flow.jumps.opaque import *
from d810.optimizers.flow.jumps.tricks import *


JUMP_OPTIMIZATION_RULES = [x() for x in get_all_subclasses(JumpOptimizationRule)]
jump_fixer = JumpFixer()
for jump_optimization_rule in JUMP_OPTIMIZATION_RULES:
    jump_fixer.register_rule(jump_optimization_rule)
JUMP_OPTIMIZATION_BLOCK_RULES = [jump_fixer]

```

`d810/optimizers/flow/jumps/handler.py`:

```py
import logging
from ida_hexrays import *
from typing import Union

from d810.optimizers.instructions.handler import InstructionOptimizationRule
from d810.optimizers.instructions.pattern_matching.handler import ast_generator
from d810.ast import mop_to_ast, AstNode
from d810.hexrays_formatters import format_minsn_t, opcode_to_string
from d810.optimizers.flow.handler import FlowOptimizationRule
from d810.cfg_utils import make_2way_block_goto, is_conditional_jump, change_2way_block_conditional_successor


logger = logging.getLogger("D810.branch_fixer")
optimizer_logger = logging.getLogger('D810.optimizer')


class JumpOptimizationRule(InstructionOptimizationRule):
    ORIGINAL_JUMP_OPCODES = []
    LEFT_PATTERN = None
    RIGHT_PATTERN = None

    REPLACEMENT_OPCODE = None
    REPLACEMENT_LEFT_PATTERN = None
    REPLACEMENT_RIGHT_PATTERN = None

    FUZZ_PATTERNS = True

    def __init__(self):
        super().__init__()
        self.fuzz_patterns = self.FUZZ_PATTERNS
        self.left_pattern_candidates = []
        self.right_pattern_candidates = []
        self.jump_original_block_serial = None
        self.direct_block_serial = None
        self.jump_replacement_block_serial = None

    def configure(self, fuzz_pattern=None, **kwargs):
        super().configure(kwargs)
        if fuzz_pattern is not None:
            self.fuzz_patterns = fuzz_pattern
        self._generate_pattern_candidates()

    def _generate_pattern_candidates(self):
        self.fuzz_patterns = self.FUZZ_PATTERNS
        if self.LEFT_PATTERN is not None:
            self.LEFT_PATTERN.reset_mops()
            if not self.fuzz_patterns:
                self.left_pattern_candidates = [self.LEFT_PATTERN]
            else:
                self.left_pattern_candidates = ast_generator(self.LEFT_PATTERN)
        if self.RIGHT_PATTERN is not None:
            self.RIGHT_PATTERN.reset_mops()
            if not self.fuzz_patterns:
                self.right_pattern_candidates = [self.RIGHT_PATTERN]
            else:
                self.right_pattern_candidates = ast_generator(self.RIGHT_PATTERN)

    def check_candidate(self, opcode, left_candidate: AstNode, right_candidate: AstNode):
        return False

    def get_valid_candidates(self, instruction, left_ast: AstNode, right_ast: AstNode, stop_early=True):
        valid_candidates = []
        if left_ast is None or right_ast is None:
            return []

        for left_candidate_pattern in self.left_pattern_candidates:
            if not left_candidate_pattern.check_pattern_and_copy_mops(left_ast):
                continue
            for right_candidate_pattern in self.right_pattern_candidates:
                if not right_candidate_pattern.check_pattern_and_copy_mops(right_ast):
                    continue
                if not self.check_candidate(instruction.opcode, left_candidate_pattern, right_candidate_pattern):
                    continue
                valid_candidates.append([left_candidate_pattern, right_candidate_pattern])
                if stop_early:
                    return valid_candidates
        return []

    def check_pattern_and_replace(self, blk: mblock_t, instruction: minsn_t, left_ast: AstNode, right_ast: AstNode):
        if instruction.opcode not in self.ORIGINAL_JUMP_OPCODES:
            return None
        self.jump_original_block_serial = instruction.d.b
        self.direct_block_serial = blk.serial + 1
        self.jump_replacement_block_serial = None
        valid_candidates = self.get_valid_candidates(instruction, left_ast, right_ast, stop_early=True)
        if len(valid_candidates) == 0:
            return None
        if self.jump_original_block_serial is None:
            self.jump_replacement_block_serial = self.jump_original_block_serial
        left_candidate, right_candidate = valid_candidates[0]
        new_ins = self.get_replacement(instruction, left_candidate,  right_candidate)
        return new_ins

    def get_replacement(self, original_ins: minsn_t, left_candidate: AstNode, right_candidate: AstNode):
        new_left_mop = None
        new_right_mop = None
        new_dst_mop = None

        if self.jump_original_block_serial is not None:
            new_dst_mop = mop_t()
            new_dst_mop.make_blkref(self.jump_replacement_block_serial)

        if self.REPLACEMENT_LEFT_PATTERN is not None:
            is_ok = self.REPLACEMENT_LEFT_PATTERN.update_leafs_mop(left_candidate, right_candidate)
            if not is_ok:
                return None
            new_left_mop = self.REPLACEMENT_LEFT_PATTERN.create_mop(original_ins.ea)
        if self.REPLACEMENT_RIGHT_PATTERN is not None:
            is_ok = self.REPLACEMENT_RIGHT_PATTERN.update_leafs_mop(left_candidate, right_candidate)
            if not is_ok:
                return None
            new_right_mop = self.REPLACEMENT_RIGHT_PATTERN.create_mop(original_ins.ea)

        new_ins = self.create_new_ins(original_ins, new_left_mop, new_right_mop, new_dst_mop)
        return new_ins

    def create_new_ins(self, original_ins: minsn_t, new_left_mop: mop_t,
                       new_right_mop: Union[None, mop_t] = None, new_dst_mop: Union[None, mop_t] = None) -> minsn_t:
        new_ins = minsn_t(original_ins)
        new_ins.opcode = self.REPLACEMENT_OPCODE
        if self.REPLACEMENT_OPCODE == m_goto:
            new_ins.l = new_dst_mop
            new_ins.r.erase()
            new_ins.d.erase()
            return new_ins
        new_ins.l = new_left_mop
        if new_right_mop is not None:
            new_ins.r = new_right_mop
        if new_dst_mop is not None:
            new_ins.d = new_dst_mop
        return new_ins

    @property
    def description(self):
        self.LEFT_PATTERN.reset_mops()
        self.RIGHT_PATTERN.reset_mops()
        return "{0}: {1}, {2}".format(",".join([opcode_to_string(x) for x in self.JMP_OPCODES]),
                                      self.LEFT_PATTERN, self.RIGHT_PATTERN)


class JumpFixer(FlowOptimizationRule):
    def __init__(self):
        super().__init__()
        self.known_rules = []
        self.rules = []

    def register_rule(self, rule: JumpOptimizationRule):
        self.known_rules.append(rule)

    def configure(self, kwargs):
        super().configure(kwargs)

        self.rules.clear()

        if "enabled_rules" in self.config.keys():
            for rule in self.known_rules:
                if rule.name in self.config["enabled_rules"]:
                    rule.configure()
                    self.rules.append(rule)
                    optimizer_logger.debug("JumpFixer enables rule {0}".format(rule.name))
                else:
                    optimizer_logger.debug("JumpFixer disables rule {0}".format(rule.name))

    def optimize(self, blk: mblock_t) -> bool:
        if not is_conditional_jump(blk):
            return False
        left_ast = mop_to_ast(blk.tail.l)
        right_ast = mop_to_ast(blk.tail.r)
        for rule in self.rules:
            try:
                new_ins = rule.check_pattern_and_replace(blk, blk.tail, left_ast, right_ast)
                if new_ins:
                    optimizer_logger.info("Rule {0} matched:".format(rule.name))
                    optimizer_logger.info("  orig: {0}".format(format_minsn_t(blk.tail)))
                    optimizer_logger.info("  new : {0}".format(format_minsn_t(new_ins)))
                    if new_ins.opcode == m_goto:
                        make_2way_block_goto(blk, new_ins.d.b)
                    else:
                        change_2way_block_conditional_successor(blk, new_ins.d.b)
                        blk.make_nop(blk.tail)
                        blk.insert_into_block(new_ins, blk.tail)
                        return True
            except RuntimeError as e:
                optimizer_logger.error("Error during rule {0} for instruction {1}: {2}"
                                       .format(rule, format_minsn_t(blk.tail), e))
        return False

```

`d810/optimizers/flow/jumps/opaque.py`:

```py
from ida_hexrays import *

from d810.ast import AstLeaf, AstConstant, AstNode
from d810.optimizers.flow.jumps.handler import JumpOptimizationRule


class JnzRule1(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]
    LEFT_PATTERN = AstNode(m_neg,
                           AstNode(m_and,
                                   AstNode(m_bnot,
                                           AstLeaf("x_0")),
                                   AstConstant("1", 1)))
    RIGHT_PATTERN = AstLeaf("x_0")
    REPLACEMENT_OPCODE = m_goto

    def check_candidate(self, opcode, left_candidate, right_candidate):
        if opcode == m_jnz:
            self.jump_replacement_block_serial = self.jump_original_block_serial
        else:
            self.jump_replacement_block_serial = self.direct_block_serial
        return True


class JnzRule2(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]
    LEFT_PATTERN = AstNode(m_or,
                           AstNode(m_bnot,
                                   AstLeaf("x_0")),
                           AstConstant("1", 1))
    RIGHT_PATTERN = AstConstant("0", 0)
    REPLACEMENT_OPCODE = m_goto

    def check_candidate(self, opcode, left_candidate, right_candidate):
        if opcode == m_jnz:
            self.jump_replacement_block_serial = self.jump_original_block_serial
        else:
            self.jump_replacement_block_serial = self.direct_block_serial
        return True


class JnzRule3(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]
    LEFT_PATTERN = AstNode(m_xor,
                           AstNode(m_xor,
                                   AstLeaf("x_0"),
                                   AstConstant("c_1")),
                           AstNode(m_and,
                                   AstLeaf("x_0"),
                                   AstConstant("c_2")))
    RIGHT_PATTERN = AstConstant("0", 0)
    REPLACEMENT_OPCODE = m_goto

    def check_candidate(self, opcode, left_candidate, right_candidate):
        tmp = left_candidate["c_1"].value & left_candidate["c_2"].value
        if tmp == 0:
            return False
        if opcode == m_jnz:
            self.jump_replacement_block_serial = self.jump_original_block_serial
        else:
            self.jump_replacement_block_serial = self.direct_block_serial
        return True


class JnzRule4(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]
    LEFT_PATTERN = AstNode(m_sub,
                           AstConstant("3", 3),
                           AstLeaf("x_0"))
    RIGHT_PATTERN = AstLeaf("x_0")
    REPLACEMENT_OPCODE = m_goto

    def check_candidate(self, opcode, left_candidate, right_candidate):
        if opcode == m_jnz:
            self.jump_replacement_block_serial = self.jump_original_block_serial
        else:
            self.jump_replacement_block_serial = self.direct_block_serial
        return True


class JnzRule5(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]
    LEFT_PATTERN = AstNode(m_xor,
                           AstNode(m_sub,
                                   AstConstant("3", 3),
                                   AstLeaf("x_0")),
                           AstLeaf("x_0"))
    RIGHT_PATTERN = AstConstant("0", 0)
    REPLACEMENT_OPCODE = m_goto

    def check_candidate(self, opcode, left_candidate, right_candidate):
        if opcode == m_jnz:
            self.jump_replacement_block_serial = self.jump_original_block_serial
        else:
            self.jump_replacement_block_serial = self.direct_block_serial
        return True


class JnzRule6(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]
    LEFT_PATTERN = AstNode(m_xor,
                           AstNode(m_bnot,
                                   AstNode(m_sub,
                                           AstConstant("3", 3),
                                           AstLeaf("x_0"))),
                           AstNode(m_bnot,
                                   AstLeaf("x_0")))
    RIGHT_PATTERN = AstConstant("0", 0)
    REPLACEMENT_OPCODE = m_goto

    def check_candidate(self, opcode, left_candidate, right_candidate):
        if opcode == m_jnz:
            self.jump_replacement_block_serial = self.jump_original_block_serial
        else:
            self.jump_replacement_block_serial = self.direct_block_serial
        return True


class JnzRule7(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]
    LEFT_PATTERN = AstNode(m_and,
                           AstLeaf("x_0"),
                           AstConstant("c_1"))
    RIGHT_PATTERN = AstConstant("c_2")
    REPLACEMENT_OPCODE = m_goto

    def check_candidate(self, opcode, left_candidate, right_candidate):
        tmp = left_candidate["c_1"].value & right_candidate["c_2"].value
        if tmp == right_candidate["c_2"].value:
            return False
        if opcode == m_jnz:
            self.jump_replacement_block_serial = self.jump_original_block_serial
        else:
            self.jump_replacement_block_serial = self.direct_block_serial
        return True


class JnzRule8(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jnz, m_jz]
    PATTERN = AstNode(m_or,
                      AstLeaf("x_0"),
                      AstConstant("c_1"))
    RIGHT_PATTERN = AstConstant("c_2")
    REPLACEMENT_OPCODE = m_goto

    def check_candidate(self, opcode, left_candidate, right_candidate):
        tmp = left_candidate["c_1"].value & right_candidate["c_2"].value
        if tmp == left_candidate["c_1"].value:
            return False

        if opcode == m_jnz:
            self.jump_replacement_block_serial = self.jump_original_block_serial
        else:
            self.jump_replacement_block_serial = self.direct_block_serial
        return True


class JbRule1(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jb]
    PATTERN = AstNode(m_xdu,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("1", 1)))
    RIGHT_PATTERN = AstConstant("2", 2)
    REPLACEMENT_OPCODE = m_goto

    def check_candidate(self, opcode, left_candidate, right_candidate):
        self.jump_replacement_block_serial = self.jump_original_block_serial
        return True


class JaeRule1(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jae]
    PATTERN = AstNode(m_and,
                      AstLeaf("x_0"),
                      AstConstant("c_1"))
    RIGHT_PATTERN = AstConstant("c_2")
    REPLACEMENT_OPCODE = m_goto

    def check_candidate(self, opcode, left_candidate, right_candidate):
        if left_candidate["c_1"].value >= right_candidate["c_2"].value:
            return False
        self.jump_replacement_block_serial = self.direct_block_serial
        return True

```

`d810/optimizers/flow/jumps/tricks.py`:

```py
from ida_hexrays import *

from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_helpers import equal_mops_bypass_xdu, equal_bnot_mop
from d810.optimizers.flow.jumps.handler import JumpOptimizationRule


class CompareConstantRule1(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jge]
    LEFT_PATTERN = AstNode(m_and,
                           AstNode(m_or, AstLeaf("xdu_x_0"), AstConstant("c_2")),
                           AstNode(m_or,
                                   AstNode(m_xor, AstLeaf("x_0"), AstConstant("c_1")),
                                   AstNode(m_bnot, AstNode(m_sub, AstLeaf("x_0"), AstConstant("c_1")))))
    RIGHT_PATTERN = AstConstant("0", 0)

    REPLACEMENT_OPCODE = m_jl
    REPLACEMENT_LEFT_PATTERN = AstLeaf("x_0")
    REPLACEMENT_RIGHT_PATTERN = AstLeaf("c_1")

    def check_candidate(self, opcode, left_candidate, right_candidate):
        if not equal_mops_bypass_xdu(left_candidate["xdu_x_0"].mop, left_candidate["x_0"].mop):
            return False
        if not equal_bnot_mop(left_candidate["c_2"].mop, left_candidate["c_1"].mop):
            return False
        self.jump_replacement_block_serial = self.jump_original_block_serial
        return True


class CompareConstantRule2(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jge]
    LEFT_PATTERN = AstNode(m_or,
                           AstNode(m_xdu,
                                   AstNode(m_and,
                                           AstNode(m_bnot, AstLeaf("x_0")), AstConstant("c_1"))),
                           AstNode(m_and,
                                   AstNode(m_sub, AstLeaf('xdu_x_0'), AstConstant('xdu_c_1')),
                                   AstNode(m_bnot, AstNode(m_xdu, AstNode(m_xor, AstLeaf('xdu1_x_0'), AstConstant('xdu_c_1'))))))
    RIGHT_PATTERN = AstConstant("0", 0)

    REPLACEMENT_OPCODE = m_jge
    REPLACEMENT_LEFT_PATTERN = AstLeaf("x_0")
    REPLACEMENT_RIGHT_PATTERN = AstLeaf("c_1")

    def check_candidate(self, opcode, left_candidate, right_candidate):
        if not equal_mops_bypass_xdu(left_candidate["xdu_x_0"].mop, left_candidate["x_0"].mop):
            return False
        if not equal_mops_bypass_xdu(left_candidate["xdu1_x_0"].mop, left_candidate["x_0"].mop):
            return False
        self.jump_replacement_block_serial = self.jump_original_block_serial
        return True


class CompareConstantRule3(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jge]
    LEFT_PATTERN = AstNode(m_and,
                           AstNode(m_sub, AstLeaf('x_0'), AstConstant('c_1')),
                           AstNode(m_bnot, AstLeaf("x_0")))
    RIGHT_PATTERN = AstConstant("0", 0)

    REPLACEMENT_OPCODE = m_jg
    REPLACEMENT_LEFT_PATTERN = AstLeaf("x_0")
    REPLACEMENT_RIGHT_PATTERN = AstLeaf("c_1")

    def check_candidate(self, opcode, left_candidate, right_candidate):
        self.jump_replacement_block_serial = self.jump_original_block_serial
        return True


class CompareConstantRule4(JumpOptimizationRule):
    ORIGINAL_JUMP_OPCODES = [m_jl, m_jge]
    LEFT_PATTERN = AstNode(m_and,
                           AstNode(m_or,
                                   AstNode(m_bnot,
                                           AstNode(m_sub,
                                                   AstLeaf('x_0'),
                                                   AstConstant('c_1'))),
                                   AstNode(m_xor,
                                           AstLeaf('x_0'),
                                           AstConstant('c_1'))),
                           AstNode(m_or,
                                   AstLeaf("xdu_x_0"),
                                   AstConstant('bnot_c_1')))

    RIGHT_PATTERN = AstConstant("0", 0)

    REPLACEMENT_OPCODE = m_jge
    REPLACEMENT_LEFT_PATTERN = AstLeaf("x_0")
    REPLACEMENT_RIGHT_PATTERN = AstLeaf("c_1")

    def check_candidate(self, opcode, left_candidate, right_candidate):
        print("dflighdrth")
        if not equal_mops_bypass_xdu(left_candidate["xdu_x_0"].mop, left_candidate["x_0"].mop):
            return False
        if not equal_bnot_mop(left_candidate["c_1"].mop, left_candidate["bnot_c_1"].mop):
            return False
        self.jump_replacement_block_serial = self.jump_original_block_serial
        return True

```

`d810/optimizers/handler.py`:

```py
from ida_hexrays import *

from d810.hexrays_formatters import string_to_maturity

DEFAULT_INSTRUCTION_MATURITIES = [MMAT_LOCOPT, MMAT_CALLS, MMAT_GLBOPT1]
DEFAULT_FLOW_MATURITIES = [MMAT_CALLS, MMAT_GLBOPT1]


class OptimizationRule(object):
    NAME = None
    DESCRIPTION = None

    def __init__(self):
        self.maturities = []
        self.config = {}
        self.log_dir = None

    def set_log_dir(self, log_dir):
        self.log_dir = log_dir

    def configure(self, kwargs):
        self.config = kwargs if kwargs is not None else {}
        if "maturities" in self.config.keys():
            self.maturities = [string_to_maturity(x) for x in self.config["maturities"]]

    @property
    def name(self):
        if self.NAME is not None:
            return self.NAME
        return self.__class__.__name__

    @property
    def description(self):
        if self.DESCRIPTION is not None:
            return self.DESCRIPTION
        return "No description available"

```

`d810/optimizers/instructions/__init__.py`:

```py
from d810.optimizers.instructions.chain import CHAIN_RULES, ChainOptimizer
from d810.optimizers.instructions.pattern_matching import PATTERN_MATCHING_RULES, PatternOptimizer
from d810.optimizers.instructions.z3 import Z3_RULES, Z3Optimizer
from d810.optimizers.instructions.analysis import INSTRUCTION_ANALYSIS_RULES, InstructionAnalyzer
from d810.optimizers.instructions.early import EARLY_RULES, EarlyOptimizer

KNOWN_INS_RULES = PATTERN_MATCHING_RULES + CHAIN_RULES + Z3_RULES + EARLY_RULES + INSTRUCTION_ANALYSIS_RULES

```

`d810/optimizers/instructions/analysis/__init__.py`:

```py
from d810.utils import get_all_subclasses
from d810.optimizers.instructions.analysis.handler import InstructionAnalyzer, InstructionAnalysisRule
from d810.optimizers.instructions.analysis.pattern_guess import *

INSTRUCTION_ANALYSIS_RULES = CHAIN_RULES = [x() for x in get_all_subclasses(InstructionAnalysisRule)]

```

`d810/optimizers/instructions/analysis/handler.py`:

```py
import logging
from ida_hexrays import *
from d810.hexrays_formatters import format_minsn_t
from d810.optimizers.instructions.handler import InstructionOptimizer, InstructionOptimizationRule


optimizer_logger = logging.getLogger('D810.optimizer')


class InstructionAnalysisRule(InstructionOptimizationRule):
    def analyze_instruction(self, blk, ins):
        raise NotImplementedError


class InstructionAnalyzer(InstructionOptimizer):
    RULE_CLASSES = [InstructionAnalysisRule]

    def set_maturity(self, maturity: int):
        self.cur_maturity = maturity
        for rule in self.rules:
            rule.set_maturity(self.cur_maturity)

    def analyze(self, blk: mblock_t, ins: minsn_t):
        if blk is not None:
            self.cur_maturity = blk.mba.maturity

        if self.cur_maturity not in self.maturities:
            return None

        for rule in self.rules:
            try:
                rule.analyze_instruction(blk, ins)
            except RuntimeError:
                optimizer_logger.error("error during rule {0} for instruction {1}".format(rule, format_minsn_t(ins)))
        return None


    @property
    def name(self):
        if self.NAME is not None:
            return self.NAME
        return self.__class__.__name__

```

`d810/optimizers/instructions/analysis/pattern_guess.py`:

```py
import os

from d810.ast import minsn_to_ast
from d810.hexrays_formatters import format_minsn_t, format_mop_t, maturity_to_string

from d810.optimizers.handler import DEFAULT_INSTRUCTION_MATURITIES
from d810.optimizers.instructions.analysis.handler import InstructionAnalysisRule
from d810.optimizers.instructions.analysis.utils import get_possible_patterns


class ExampleGuessingRule(InstructionAnalysisRule):
    DESCRIPTION = "Detect pattern with variable used multiple times and with multiple different opcodes"

    def __init__(self):
        super().__init__()
        self.maturities = DEFAULT_INSTRUCTION_MATURITIES
        self.cur_maturity = None
        self.min_nb_var = 1
        self.max_nb_var = 3
        self.min_nb_diff_opcodes = 3
        self.max_nb_diff_opcodes = -1

        self.cur_index = 0
        self.max_index = 1000
        self.cur_ins_guessed = [""] * self.max_index
        self.pattern_filename_path = None

    def log_info(self, message):
        with open(self.pattern_filename_path, "a") as f:
            f.write('{0}\n'.format(message))

    def set_maturity(self, maturity):
        self.log_info("Patterns guessed at maturity {0}".format(maturity_to_string(maturity)))
        self.cur_maturity = maturity

    def set_log_dir(self, log_dir):
        super().set_log_dir(log_dir)
        self.pattern_filename_path = os.path.join(self.log_dir, "pattern_guess.log")
        f = open(self.pattern_filename_path, "w")
        f.close()

    def configure(self, kwargs):
        super().configure(kwargs)
        if "min_nb_var" in kwargs.keys():
            self.min_nb_var = kwargs["min_nb_var"]
        if "max_nb_var" in kwargs.keys():
            self.max_nb_var = kwargs["max_nb_var"]
        if "min_nb_diff_opcodes" in kwargs.keys():
            self.min_nb_diff_opcodes = kwargs["min_nb_diff_opcodes"]
        if "max_nb_diff_opcodes" in kwargs.keys():
            self.max_nb_diff_opcodes = kwargs["max_nb_diff_opcodes"]

        if self.max_nb_var == -1:
            self.max_nb_var = 0xff
        if self.max_nb_diff_opcodes == -1:
            self.max_nb_diff_opcodes = 0xff

    def analyze_instruction(self, blk, ins):
        if self.cur_maturity not in self.maturities:
            return None
        formatted_ins = str(format_minsn_t(ins))
        if formatted_ins in self.cur_ins_guessed:
            return False
        tmp = minsn_to_ast(ins)
        if tmp is None:
            return False
        is_good_candidate = self.check_if_possible_pattern(tmp)
        if is_good_candidate:
            self.cur_ins_guessed[self.cur_index] = formatted_ins
            self.cur_index = (self.cur_index + 1) % self.max_index
        return is_good_candidate

    def check_if_possible_pattern(self, test_ast):
        patterns = get_possible_patterns(test_ast, min_nb_use=2, ref_ast_info_by_index=None, max_nb_pattern=64)
        for pattern in patterns:
            leaf_info_list, cst_leaf_values, opcodes = pattern.get_information()
            leaf_nb_use = [leaf_info.number_of_use for leaf_info in leaf_info_list]
            if not(self.min_nb_var <= len(leaf_info_list) <= self.max_nb_var):
                continue
            if not(self.min_nb_diff_opcodes <= len(set(opcodes)) <= self.max_nb_diff_opcodes):
                continue
            if not(min(leaf_nb_use) >= 2):
                continue
            ins = pattern.mop.d
            self.log_info("IR: 0x{0:x} - {1}".format(ins.ea, format_minsn_t(ins)))
            for leaf_info in leaf_info_list:
                self.log_info("  {0} -> {1}".format(leaf_info.ast, format_mop_t(leaf_info.ast.mop)))
            self.log_info("Pattern: {0}".format(pattern))
            self.log_info("AstNode: {0}\n".format(pattern.get_pattern()))
            return True
        return False

```

`d810/optimizers/instructions/analysis/utils.py`:

```py
from d810.ast import AstNode, AstLeaf


def get_possible_patterns(ast, min_nb_use=2, ref_ast_info_by_index=None, max_nb_pattern=64):
    # max_nb_pattern is used to prevent memory explosion when very large patterns are parsed
    if ast.is_leaf():
        return [ast]
    if ref_ast_info_by_index is None:
        if ast.ast_index not in ast.sub_ast_info_by_index.keys():
            ast.compute_sub_ast()
        ref_ast_info_by_index = ast.sub_ast_info_by_index
    possible_patterns = []
    if ref_ast_info_by_index[ast.ast_index].number_of_use >= min_nb_use:
        node_as_leaf = AstLeaf("x_{0}".format(ast.ast_index))
        node_as_leaf.mop = ast.mop
        node_as_leaf.ast_index = ast.ast_index
        possible_patterns.append(node_as_leaf)
    left_patterns = []
    right_patterns = []
    if ast.left is not None:
        left_patterns = get_possible_patterns(ast.left, min_nb_use, ref_ast_info_by_index, max_nb_pattern)
    if ast.right is not None:
        right_patterns = get_possible_patterns(ast.right, min_nb_use, ref_ast_info_by_index, max_nb_pattern)

    for left_pattern in left_patterns:
        if ast.right is not None:
            for right_pattern in right_patterns:
                node = AstNode(ast.opcode, left_pattern, right_pattern)
                node.mop = ast.mop
                node.ast_index = ast.ast_index
                if len(possible_patterns) < max_nb_pattern:
                    possible_patterns.append(node)
        else:
            node = AstNode(ast.opcode, left_pattern)
            node.mop = ast.mop
            node.ast_index = ast.ast_index
            if len(possible_patterns) < max_nb_pattern:
                possible_patterns.append(node)
    return possible_patterns

```

`d810/optimizers/instructions/chain/__init__.py`:

```py
from d810.utils import get_all_subclasses
from d810.optimizers.instructions.chain.handler import ChainSimplificationRule, ChainOptimizer
from d810.optimizers.instructions.chain.chain_rules import *

CHAIN_RULES = [x() for x in get_all_subclasses(ChainSimplificationRule)]

```

`d810/optimizers/instructions/chain/chain_rules.py`:

```py
import logging
from functools import reduce
from ida_hexrays import *


from d810.optimizers.instructions.chain.handler import ChainSimplificationRule
from d810.hexrays_helpers import equal_bnot_mop, equal_mops_ignore_size, \
    SUB_TABLE, AND_TABLE
from d810.hexrays_formatters import format_minsn_t

rules_chain_logger = logging.getLogger('D810.rules.chain')


class ChainSimplification(object):
    def __init__(self, opcode):
        self.opcode = opcode
        self.formatted_ins = ""
        self.non_cst_mop_list = []
        self.cst_mop_list = []
        self._is_instruction_simplified = False

    def add_mop(self, mop):
        if (mop.t == mop_d) and (mop.d.opcode == self.opcode):
            self.add_mop(mop.d.l)
            self.add_mop(mop.d.r)
        else:
            if mop.t == mop_n:
                self.cst_mop_list.append(mop)
            else:
                self.non_cst_mop_list.append(mop)

    def do_simplification(self):
        final_mop_list = self.get_simplified_non_constant()
        final_mop_list += self.get_simplified_constant()
        return final_mop_list

    def get_simplified_constant(self):
        if len(self.cst_mop_list) == 0:
            return []
        elif len(self.cst_mop_list) == 1:
            return self.cst_mop_list
        else:
            cst_size_list = [c.size for c in self.cst_mop_list]
            cst_value_list = [c.nnn.value for c in self.cst_mop_list]
            final_cst_size = max(cst_size_list)
            rules_chain_logger.debug("Doing cst simplification: {0}".format(cst_value_list))
            self._is_instruction_simplified = True
            if self.opcode == m_xor:
                final_cst = reduce(lambda x, y: x ^ y, cst_value_list)
            elif self.opcode == m_and:
                final_cst = reduce(lambda x, y: x & y, cst_value_list)
            elif self.opcode == m_or:
                final_cst = reduce(lambda x, y: x | y, cst_value_list)
            elif self.opcode == m_add:
                final_cst = reduce(lambda x, y: x + y, cst_value_list)
            else:
                raise NotImplementedError("Euh")
            final_cst = final_cst & AND_TABLE[final_cst_size]
            rules_chain_logger.debug("Final cst: {0}".format(final_cst))
            final_cst_mop = mop_t()
            final_cst_mop.make_number(final_cst, max(cst_size_list))
            return [final_cst_mop]

    def get_simplified_non_constant(self):
        if len(self.non_cst_mop_list) == 0:
            return []
        elif len(self.non_cst_mop_list) == 1:
            return self.non_cst_mop_list
        else:
            is_always_0 = False
            index_removed = []
            for i in range(len(self.non_cst_mop_list)):
                for j in range(i + 1, len(self.non_cst_mop_list)):
                    if (i not in index_removed) and (j not in index_removed):
                        if equal_mops_ignore_size(self.non_cst_mop_list[i], self.non_cst_mop_list[j]):
                            if self.opcode == m_xor:
                                # x ^ x == 0
                                rules_chain_logger.debug("Doing non cst simplification (xor): {0}, {1} in {2}"
                                                         .format(i, j, self.formatted_ins))
                                index_removed += [i, j]
                            elif self.opcode == m_and:
                                # x & x == x
                                rules_chain_logger.debug("Doing non cst simplification (and): {0}, {1} in {2}"
                                                         .format(i, j, self.formatted_ins))
                                index_removed += [j]
                            elif self.opcode == m_or:
                                # x | x == x
                                rules_chain_logger.debug("Doing non cst simplification (or): {0}, {1} in {2}"
                                                         .format(i, j, self.formatted_ins))
                                index_removed += [j]
                        elif equal_bnot_mop(self.non_cst_mop_list[i], self.non_cst_mop_list[j]):
                            if self.opcode == m_and:
                                is_always_0 = True

            if len(index_removed) == 0 and not is_always_0:
                return self.non_cst_mop_list
            final_mop_list = []
            self._is_instruction_simplified = True
            if is_always_0:
                final_mop_list.append(self.create_cst_mop(0, self.res_mop_size))
                return final_mop_list
            for i in range(len(self.non_cst_mop_list)):
                if i not in index_removed:
                    final_mop_list.append(self.non_cst_mop_list[i])
            return final_mop_list

    def simplify(self, ins):
        self.res_mop_size = ins.d.size
        if ins.opcode != self.opcode:
            return None

        self.formatted_ins = format_minsn_t(ins)
        self.non_cst_mop_list = []
        self.cst_mop_list = []
        self.add_mop(ins.l)
        self.add_mop(ins.r)

        self._is_instruction_simplified = False
        final_mop_list = self.do_simplification()
        if not self._is_instruction_simplified:
            return None

        return self.create_new_chain(ins, final_mop_list)

    def create_new_chain(self, original_ins, mop_list):
        new_ins = minsn_t(original_ins.ea)
        new_ins.opcode = self.opcode
        if len(mop_list) == 0:
            mop_list.append(self.create_cst_mop(0, original_ins.d.size))
        if len(mop_list) == 1:
            mop_list.append(self.create_cst_mop(0, original_ins.d.size))
        new_ins.l = self._create_mop_chain(original_ins, mop_list[:-1], original_ins.d.size)
        new_ins.r = mop_list[-1]
        if new_ins.r.t == mop_n:
            new_ins.r.size = original_ins.d.size
        new_ins.d = original_ins.d
        return new_ins

    def create_cst_mop(self, value, size):
        cst_mop = mop_t()
        cst_mop.make_number(value, size)
        return cst_mop

    def _create_mop_chain(self, ea, mop_list, size):
        if len(mop_list) == 1:
            return mop_list[0]
        new_ins = minsn_t(ea)
        new_ins.opcode = self.opcode
        new_ins.l = self._create_mop_chain(ea, mop_list[:-1], size)
        new_ins.r = mop_list[-1]
        new_ins.d = mop_t()
        new_ins.d.size = size
        mop = mop_t()
        mop.create_from_insn(new_ins)
        return mop


class ArithmeticChainSimplification(object):
    def __init__(self):
        self.formatted_ins = ""
        self.add_non_cst_mop_list = []
        self.add_cst_mop_list = []
        self.sub_non_cst_mop_list = []
        self.sub_cst_mop_list = []
        self.add_other_cst_list = []
        self.sub_other_cst_list = []
        self._is_instruction_simplified = False

    def add_mop(self, sign, mop):
        # sign is 0 if +, 1 is minus => minus minus = 1 ^ 1 = 0 so add
        if (mop.t == mop_d) and (mop.d.opcode in [m_add, m_sub]):

            self.add_mop(sign, mop.d.l)
            if mop.d.opcode == m_add:
                self.add_mop(sign, mop.d.r)
            else:
                self.add_mop(sign ^ 1, mop.d.r)
        elif (mop.t == mop_d) and (mop.d.opcode == m_neg):
            self.add_mop(sign ^ 1, mop.d.l)
        else:
            if mop.t == mop_n:
                if sign == 0:
                    self.add_cst_mop_list.append(mop)
                else:
                    self.sub_cst_mop_list.append(mop)
            else:
                if sign == 0:
                    self.add_non_cst_mop_list.append(mop)
                else:
                    self.sub_non_cst_mop_list.append(mop)

    def do_simplification(self):
        final_add_cst_list, final_sub_cst_list = self.get_simplified_constant()
        final_add_list, final_sub_list, final_add_cst_mop = self.get_simplified_non_constant()
        if final_add_cst_mop.nnn.value != 0:
            final_add_cst_list.append(final_add_cst_mop)
        return final_add_list, final_sub_list, final_add_cst_list, final_sub_cst_list

    def get_simplified_constant(self):
        if len(self.add_cst_mop_list) == 0 and len(self.sub_cst_mop_list) == 0:
            return [[], []]
        if len(self.add_cst_mop_list) == 1 and len(self.sub_cst_mop_list) == 0:
            return self.add_cst_mop_list, []
        if len(self.add_cst_mop_list) == 0 and len(self.sub_cst_mop_list) == 1:
            return [], self.sub_cst_mop_list
        add_cst_size_list = [c.size for c in self.add_cst_mop_list]
        add_cst_value_list = [c.nnn.value for c in self.add_cst_mop_list]
        sub_cst_size_list = [c.size for c in self.sub_cst_mop_list]
        sub_cst_value_list = [SUB_TABLE[c.size] - c.nnn.value for c in self.sub_cst_mop_list]
        self._is_instruction_simplified = True

        final_cst_size = max(add_cst_size_list + sub_cst_size_list)
        rules_chain_logger.debug("Doing arithmetic cst simplification: {0} {1}"
                                 .format(add_cst_value_list, sub_cst_value_list))
        final_cst = reduce(lambda x, y: x + y, add_cst_value_list + sub_cst_value_list)
        final_cst = final_cst & AND_TABLE[final_cst_size]
        rules_chain_logger.debug("Final cst: {0}".format(final_cst))
        final_cst_mop = mop_t()
        final_cst_mop.make_number(final_cst, final_cst_size)
        return [final_cst_mop], []

    def get_simplified_non_constant(self):
        if len(self.add_non_cst_mop_list) == 0 and len(self.sub_non_cst_mop_list) == 0:
            return [[], []]
        final_add_list = self.add_non_cst_mop_list
        final_sub_list = self.sub_non_cst_mop_list
        index_add_removed = []
        index_sub_removed = []
        for (i, add_mop) in enumerate(self.add_non_cst_mop_list):
            for (j, sub_mop) in enumerate(self.sub_non_cst_mop_list):
                if (i not in index_add_removed) and (j not in index_sub_removed):
                    if equal_mops_ignore_size(add_mop, sub_mop):
                        index_add_removed.append(i)
                        index_sub_removed.append(j)

        if len(index_add_removed) > 0:
            self._is_instruction_simplified = True
            final_add_list = []
            for i in range(len(self.add_non_cst_mop_list)):
                if i not in index_add_removed:
                    final_add_list.append(self.add_non_cst_mop_list[i])
            final_sub_list = []
            for i in range(len(self.sub_non_cst_mop_list)):
                if i not in index_sub_removed:
                    final_sub_list.append(self.sub_non_cst_mop_list[i])

        final_add_list, final_sub_list, final_add_cst_mop = self.check_bnot_mop(final_add_list, final_sub_list)
        return final_add_list, final_sub_list, final_add_cst_mop

    def check_bnot_mop(self, add_non_cst_mop_list, sub_non_cst_mop_list):
        add_index_removed = []
        sub_index_removed = []
        cst_value = 0
        final_add_non_cst_mop_list = add_non_cst_mop_list
        final_sub_non_cst_mop_list = sub_non_cst_mop_list
        add_size_list = [c.size for c in add_non_cst_mop_list]
        sub_size_list = [c.size for c in sub_non_cst_mop_list]
        final_cst_size = max(add_size_list + sub_size_list)

        for i in range(len(add_non_cst_mop_list)):
            for j in range(i + 1, len(add_non_cst_mop_list)):
                if (i not in add_index_removed) and (j not in add_index_removed):
                    if equal_bnot_mop(add_non_cst_mop_list[i], add_non_cst_mop_list[j]):
                        cst_value += AND_TABLE[add_non_cst_mop_list[i].size]
                        add_index_removed += [i, j]

        for i in range(len(sub_non_cst_mop_list)):
            for j in range(i + 1, len(sub_non_cst_mop_list)):
                if (i not in sub_index_removed) and (j not in sub_index_removed):
                    if equal_bnot_mop(sub_non_cst_mop_list[i], sub_non_cst_mop_list[j]):
                        cst_value += 1
                        sub_index_removed += [i, j]

        final_add_cst_mop = mop_t()
        final_add_cst_mop.make_number(cst_value & AND_TABLE[final_cst_size], final_cst_size)

        if len(add_index_removed) > 0:
            final_add_non_cst_mop_list = []
            self._is_instruction_simplified = True
            for i in range(len(add_non_cst_mop_list)):
                if i not in add_index_removed:
                    final_add_non_cst_mop_list.append(add_non_cst_mop_list[i])
        if len(sub_index_removed) > 0:
            final_sub_non_cst_mop_list = []
            self._is_instruction_simplified = True
            for i in range(len(sub_non_cst_mop_list)):
                if i not in sub_index_removed:
                    final_sub_non_cst_mop_list.append(sub_non_cst_mop_list[i])
        return final_add_non_cst_mop_list, final_sub_non_cst_mop_list, final_add_cst_mop

    def simplify(self, ins):
        if ins.opcode not in [m_add, m_sub]:
            return None
        self.formatted_ins = format_minsn_t(ins)
        self.add_non_cst_mop_list = []
        self.add_cst_mop_list = []
        self.sub_non_cst_mop_list = []
        self.sub_cst_mop_list = []
        self.add_mop(0, ins.l)
        if ins.opcode == m_add:
            self.add_mop(0, ins.r)
        else:
            self.add_mop(1, ins.r)

        self._is_instruction_simplified = False
        final_add_list, final_sub_list, final_add_cst_list, final_sub_cst_list = self.do_simplification()
        if not self._is_instruction_simplified:
            return None

        simplified_ins = self.create_new_chain(ins, final_add_list, final_sub_list, final_add_cst_list, final_sub_cst_list)

        return simplified_ins

    def create_new_chain(self, original_ins, final_add_list, final_sub_list, final_add_cst_list, final_sub_cst_list):
        mod_add = self._create_mop_add_chain(original_ins.ea, final_add_list + final_add_cst_list, original_ins.d.size)
        mod_sub = self._create_mop_add_chain(original_ins.ea, final_sub_list + final_sub_cst_list, original_ins.d.size)
        new_ins = minsn_t(original_ins.ea)
        new_ins.opcode = m_sub
        new_ins.l = mod_add
        new_ins.r = mod_sub
        new_ins.d = original_ins.d
        return new_ins

    def _create_mop_add_chain(self, ea, mop_list, size):
        if len(mop_list) == 0:
            res = mop_t()
            res.make_number(0, size)
            return res
        elif len(mop_list) == 1:
            return mop_list[0]
        new_ins = minsn_t(ea)
        new_ins.opcode = m_add
        new_ins.l = self._create_mop_add_chain(ea, mop_list[:-1], size)
        new_ins.r = mop_list[-1]
        new_ins.d = mop_t()
        new_ins.d.size = size
        mop = mop_t()
        mop.create_from_insn(new_ins)
        return mop


class XorChain(ChainSimplificationRule):
    DESCRIPTION = "Remove XOR chains with common terms. E.g. x ^ 4 ^ y ^ 6 ^ 5 ^ x ==> y ^ 7"

    def check_and_replace(self, blk, ins):
        xor_simplifier = ChainSimplification(m_xor)
        new_ins = xor_simplifier.simplify(ins)
        return new_ins


class AndChain(ChainSimplificationRule):
    DESCRIPTION = "Remove AND chains with common terms. E.g. x & 4 & y & 6 & 5 & x ==> x & y & 4"

    def check_and_replace(self, blk, ins):
        and_simplifier = ChainSimplification(m_and)
        new_ins = and_simplifier.simplify(ins)
        return new_ins


class OrChain(ChainSimplificationRule):
    DESCRIPTION = "Remove OR chains with common terms. E.g. x | 4 | y | 6 | 5 | x ==> x | y | 7"

    def check_and_replace(self, blk, ins):
        or_simplifier = ChainSimplification(m_or)
        new_ins = or_simplifier.simplify(ins)
        return new_ins


class ArithmeticChain(ChainSimplificationRule):
    DESCRIPTION = "Remove arithmetic chains with common terms. E.g. x + 4 + y - (6 + x - 5) ==>  y + 3"

    def check_and_replace(self, blk, ins):
        arithmetic_simplifier = ArithmeticChainSimplification()
        new_ins = arithmetic_simplifier.simplify(ins)
        return new_ins

```

`d810/optimizers/instructions/chain/handler.py`:

```py
from d810.optimizers.instructions.handler import InstructionOptimizationRule, InstructionOptimizer


class ChainSimplificationRule(InstructionOptimizationRule):
    pass


class ChainOptimizer(InstructionOptimizer):
    RULE_CLASSES = [ChainSimplificationRule]

```

`d810/optimizers/instructions/early/__init__.py`:

```py
from d810.utils import get_all_subclasses
from d810.optimizers.instructions.early.handler import EarlyRule, EarlyOptimizer
from d810.optimizers.instructions.early.mem_read import *

EARLY_RULES = [x() for x in get_all_subclasses(EarlyRule)]

```

`d810/optimizers/instructions/early/handler.py`:

```py
from d810.optimizers.instructions.handler import GenericPatternRule, InstructionOptimizer


class EarlyRule(GenericPatternRule):
    pass


class EarlyOptimizer(InstructionOptimizer):
    RULE_CLASSES = [EarlyRule]

```

`d810/optimizers/instructions/early/mem_read.py`:

```py
from ida_hexrays import *
from idaapi import SEGPERM_READ, SEGPERM_WRITE, xrefblk_t, getseg, segment_t, XREF_DATA, dr_W, is_loaded

from d810.optimizers.instructions.early.handler import EarlyRule
from d810.ast import AstLeaf, AstConstant, AstNode


class SetGlobalVariablesToZero(EarlyRule):
    DESCRIPTION = "This rule can be used to patch memory read"

    PATTERN = AstNode(m_mov, AstLeaf("ro_dword"))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_res"))

    def __init__(self):
        super().__init__()
        self.ro_dword_min_ea = None
        self.ro_dword_max_ea = None

    def configure(self, kwargs):
        super().configure(kwargs)
        self.ro_dword_min_ea = None
        self.ro_dword_max_ea = None
        if "ro_dword_min_ea" in kwargs.keys():
            self.ro_dword_min_ea = int(kwargs["ro_dword_min_ea"], 16)
        if "ro_dword_max_ea" in kwargs.keys():
            self.ro_dword_max_ea = int(kwargs["ro_dword_max_ea"], 16)

    def check_candidate(self, candidate):
        if (self.ro_dword_min_ea is None) or (self.ro_dword_max_ea is None):
            return False
        if candidate["ro_dword"].mop.t != mop_v:
            return False
        mem_read_address = candidate["ro_dword"].mop.g
        if not(self.ro_dword_min_ea <= mem_read_address <= self.ro_dword_max_ea):
            return False

        candidate.add_constant_leaf("val_res", 0, candidate["ro_dword"].mop.size)
        return True


# This rule is from
# https://www.carbonblack.com/blog/defeating-compiler-level-obfuscations-used-in-apt10-malware/
class SetGlobalVariablesToZeroIfDetectedReadOnly(EarlyRule):
    DESCRIPTION = "WARNING: Use it only if you know what you are doing as it may patch data not related to obfuscation"

    PATTERN = AstNode(m_mov, AstLeaf("ro_dword"))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_res"))

    def __init__(self):
        super().__init__()
        # If we optimized too early (in MMAT_GENERATED), we may replace something like
        # 'mov     &($dword_10020CC8).4, eoff.4' by 'mov     #0.4, eoff.4'
        # and this will lead to incorrect decompilation where MEMORY[0] is used
        # Thus, we explicitly specify the MMAT_PREOPTIMIZED maturity.
        self.maturities = [MMAT_PREOPTIMIZED]

    def is_read_only_inited_var(self, address):
        s: segment_t = getseg(address)
        if s is None:
            return False
        if s.perm != (SEGPERM_READ | SEGPERM_WRITE):
            return False
        if is_loaded(address):
            return False
        ref_finder = xrefblk_t()
        is_ok = ref_finder.first_to(address, XREF_DATA)
        while is_ok:
            if ref_finder.type == dr_W:
                return False
            is_ok = ref_finder.next_to()
        return True

    def check_candidate(self, candidate):
        mem_read_address = None
        if candidate["ro_dword"].mop.t == mop_v:
            mem_read_address = candidate["ro_dword"].mop.g
        elif candidate["ro_dword"].mop.t == mop_a:
            if candidate["ro_dword"].mop.a.t == mop_v:
                mem_read_address = candidate["ro_dword"].mop.a.g

        if mem_read_address is None:
            return False

        if not self.is_read_only_inited_var(mem_read_address):
            return False
        candidate.add_constant_leaf("val_res", 0, candidate["ro_dword"].mop.size)
        return True


```

`d810/optimizers/instructions/handler.py`:

```py
from __future__ import annotations
import logging
from typing import List
from ida_hexrays import *

from d810.optimizers.handler import OptimizationRule
from d810.hexrays_formatters import format_minsn_t
from d810.ast import minsn_to_ast, AstNode
from d810.errors import D810Exception


d810_logger = logging.getLogger('D810')
optimizer_logger = logging.getLogger('D810.optimizer')


class InstructionOptimizationRule(OptimizationRule):
    def __init__(self):
        super().__init__()
        self.maturities = []

    def check_and_replace(self, blk, ins):
        return None


class GenericPatternRule(InstructionOptimizationRule):
    PATTERN = None
    PATTERNS = None
    REPLACEMENT_PATTERN = None

    def __init__(self):
        super().__init__()
        self.pattern_candidates = [self.PATTERN]
        if self.PATTERNS is not None:
            self.pattern_candidates += self.PATTERNS

    def check_candidate(self, candidate: AstNode):
        # Perform rule specific checks
        return False

    def get_valid_candidates(self, instruction: minsn_t, stop_early=True):
        valid_candidates = []
        tmp = minsn_to_ast(instruction)
        if tmp is None:
            return []
        for candidate_pattern in self.pattern_candidates:
            if not candidate_pattern.check_pattern_and_copy_mops(tmp):
                continue
            if not self.check_candidate(candidate_pattern):
                continue
            valid_candidates.append(candidate_pattern)
            if stop_early:
                return valid_candidates
        return []

    def get_replacement(self, candidate: AstNode):
        is_ok = self.REPLACEMENT_PATTERN.update_leafs_mop(candidate)
        if not is_ok:
            return None
        new_ins = self.REPLACEMENT_PATTERN.create_minsn(candidate.ea, candidate.dst_mop)
        return new_ins

    def check_and_replace(self, blk: mblock_t, instruction: minsn_t):
        valid_candidates = self.get_valid_candidates(instruction, stop_early=True)
        if len(valid_candidates) == 0:
            return None
        new_instruction = self.get_replacement(valid_candidates[0])
        return new_instruction

    @property
    def description(self):
        if self.DESCRIPTION is not None:
            return self.DESCRIPTION
        if (self.PATTERN is None) or (self.REPLACEMENT_PATTERN is None):
            return ""
        self.PATTERN.reset_mops()
        self.REPLACEMENT_PATTERN.reset_mops()
        return "{0} => {1}".format(self.PATTERN, self.REPLACEMENT_PATTERN)


class InstructionOptimizer(object):
    RULE_CLASSES = []
    NAME = None

    def __init__(self, maturities: List[int], log_dir=None):
        self.rules = set()
        self.rules_usage_info = {}
        self.maturities = maturities
        self.log_dir = log_dir
        self.cur_maturity = MMAT_PREOPTIMIZED

    def add_rule(self, rule: InstructionOptimizationRule):
        is_valid_rule_class = False
        for rule_class in self.RULE_CLASSES:
            if isinstance(rule, rule_class):
                is_valid_rule_class = True
                break
        if not is_valid_rule_class:
            return False
        optimizer_logger.debug("Adding rule {0}".format(rule))
        if len(rule.maturities) == 0:
            rule.maturities = self.maturities
        self.rules.add(rule)
        self.rules_usage_info[rule.name] = 0
        return True

    def reset_rule_usage_statistic(self):
        self.rules_usage_info = {}
        for rule in self.rules:
            self.rules_usage_info[rule.name] = 0

    def show_rule_usage_statistic(self):
        for rule_name, rule_nb_match in self.rules_usage_info.items():
            if rule_nb_match > 0:
                d810_logger.info("Instruction Rule '{0}' has been used {1} times".format(rule_name, rule_nb_match))

    def get_optimized_instruction(self, blk: mblock_t, ins: minsn_t):
        if blk is not None:
            self.cur_maturity = blk.mba.maturity
        # if self.cur_maturity not in self.maturities:
        #     return None
        for rule in self.rules:
            if self.cur_maturity not in rule.maturities:
                continue
            try:
                new_ins = rule.check_and_replace(blk, ins)
                if new_ins is not None:
                    self.rules_usage_info[rule.name] += 1
                    optimizer_logger.info("Rule {0} matched:".format(rule.name))
                    optimizer_logger.info("  orig: {0}".format(format_minsn_t(ins)))
                    optimizer_logger.info("  new : {0}".format(format_minsn_t(new_ins)))
                    return new_ins
            except RuntimeError as e:
                optimizer_logger.error("Runtime error during rule {0} for instruction {1}: {2}".format(rule, format_minsn_t(ins), e))
            except D810Exception as e:
                optimizer_logger.error("D810Exception during rule {0} for instruction {1}: {2}".format(rule, format_minsn_t(ins), e))
        return None

    @property
    def name(self):
        if self.NAME is not None:
            return self.NAME
        return self.__class__.__name__

```

`d810/optimizers/instructions/pattern_matching/__init__.py`:

```py
from d810.utils import get_all_subclasses
from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule, PatternOptimizer
from d810.optimizers.instructions.pattern_matching.rewrite_add import *
from d810.optimizers.instructions.pattern_matching.rewrite_and import *
from d810.optimizers.instructions.pattern_matching.rewrite_bnot import *
from d810.optimizers.instructions.pattern_matching.rewrite_cst import *
from d810.optimizers.instructions.pattern_matching.rewrite_mov import *
from d810.optimizers.instructions.pattern_matching.rewrite_mul import *
from d810.optimizers.instructions.pattern_matching.rewrite_neg import *
from d810.optimizers.instructions.pattern_matching.rewrite_predicates import *
from d810.optimizers.instructions.pattern_matching.rewrite_or import *
from d810.optimizers.instructions.pattern_matching.rewrite_sub import *
from d810.optimizers.instructions.pattern_matching.rewrite_xor import *
from d810.optimizers.instructions.pattern_matching.weird import *
from d810.optimizers.instructions.pattern_matching.experimental import *

PATTERN_MATCHING_RULES = [x() for x in get_all_subclasses(PatternMatchingRule)]



```

`d810/optimizers/instructions/pattern_matching/experimental.py`:

```py
from ida_hexrays import *

from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_formatters import  format_mop_t

class ReplaceMovHigh(PatternMatchingRule):
    PATTERN = AstNode(m_mov,
                      AstConstant('c_0'))
    REPLACEMENT_PATTERN = AstNode(m_or, AstConstant("new_c_0"), AstNode(m_and, AstLeaf("new_reg"), AstConstant("mask")))

    def check_candidate(self, candidate):
        # IDA does not do constant propagation for pattern such as:
        # mov     #0x65A4.2, r6.2
        # mov     #0x210F.2, r6^2.2
        # jz      r0.4, r6.4
        # Thus, we try to detect mov to r6^2 and replace by (or #0x210F0000.4, r6.4 & 0x0000ffff.4, r6.4
        # By doing that, IDA constant propagation will work again.

        if candidate.dst_mop.t != mop_r:
            return False
        dst_reg_name = format_mop_t(candidate.dst_mop)
        if dst_reg_name is None:
            return False
        if "^2" in dst_reg_name:
            if candidate["c_0"].mop.size != 2:
                return False
            candidate.add_constant_leaf("new_c_0", candidate["c_0"].value << 16, 4)
            candidate.add_constant_leaf("mask", 0xffff, 4)
            new_dst_reg = mop_t()
            new_dst_reg.make_reg(candidate.dst_mop.r - 2, 4)
            candidate.add_leaf("new_reg", new_dst_reg)
            candidate.dst_mop = new_dst_reg
            return True
        else:
            return False

```

`d810/optimizers/instructions/pattern_matching/handler.py`:

```py
import logging
import itertools
from ida_hexrays import *
from typing import List, Union
from d810.optimizers.instructions.handler import GenericPatternRule, InstructionOptimizer, InstructionOptimizationRule
from d810.ast import minsn_to_ast, AstNode, AstLeaf
from d810.hexrays_formatters import format_minsn_t, format_mop_t

optimizer_logger = logging.getLogger('D810.optimizer')
pattern_search_logger = logging.getLogger('D810.pattern_search')


class PatternMatchingRule(GenericPatternRule):
    PATTERN = None
    PATTERNS = None
    FUZZ_PATTERN = True
    REPLACEMENT_PATTERN = None

    def __init__(self):
        super().__init__()
        self.fuzz_pattern = self.FUZZ_PATTERN

    def configure(self, fuzz_pattern=None, **kwargs):
        super().configure(kwargs)
        if fuzz_pattern is not None:
            self.fuzz_pattern = fuzz_pattern
        self._generate_pattern_candidates()
        pattern_search_logger.debug("Rule {0} configured with {1} patterns"
                                    .format(self.__class__.__name__, len(self.pattern_candidates)))

    def _generate_pattern_candidates(self):
        self.fuzz_pattern = self.FUZZ_PATTERN
        if self.PATTERN is not None:
            self.PATTERN.reset_mops()
        if not self.fuzz_pattern:
            if self.PATTERN is not None:
                self.pattern_candidates = [self.PATTERN]
                if self.PATTERNS is not None:
                    self.pattern_candidates += [x for x in self.PATTERNS]
            else:
                self.pattern_candidates = [x for x in self.PATTERNS]
        else:
            self.pattern_candidates = ast_generator(self.PATTERN)

    def check_candidate(self, candidate: AstNode):
        return True

    def check_pattern_and_replace(self, candidate_pattern: AstNode, test_ast: AstNode):
        if not candidate_pattern.check_pattern_and_copy_mops(test_ast):
            return None
        if not self.check_candidate(candidate_pattern):
            return None
        new_instruction = self.get_replacement(candidate_pattern)
        return new_instruction


class RulePatternInfo(object):
    def __init__(self, rule, pattern):
        self.rule = rule
        self.pattern = pattern


def signature_generator(ref_sig):
    for i, x in enumerate(ref_sig):
        if x not in ["N", "L"]:
            for sig_suffix in signature_generator(ref_sig[i + 1:]):
                yield ref_sig[:i] + ["L"] + sig_suffix
    yield ref_sig


class PatternStorage(object):
    # The PatternStorage object is used to store patterns associated to rules
    # A PatternStorage contains a dictionary (next_layer_patterns) where:
    #  - keys are the signature of a pattern at a specific depth (i.e. the opcodes, the variable and constant)
    #  - values are PatternStorage object for the next depth
    # Additionally, it stores the rule objects which are resolved for the PatternStorage depth
    def __init__(self, depth=1):
        self.depth = depth
        self.next_layer_patterns = {}
        self.rule_resolved = []

    def add_pattern_for_rule(self, pattern: AstNode, rule: InstructionOptimizationRule):
        layer_signature = self.layer_signature_to_key(pattern.get_depth_signature(self.depth))
        if len(layer_signature.replace(",", "")) == (layer_signature.count("N")):
            self.rule_resolved.append(RulePatternInfo(rule, pattern))
        else:
            if layer_signature not in self.next_layer_patterns.keys():
                self.next_layer_patterns[layer_signature] = PatternStorage(self.depth + 1)
            self.next_layer_patterns[layer_signature].add_pattern_for_rule(pattern, rule)

    @staticmethod
    def layer_signature_to_key(sig: List[str]) -> str:
        return ",".join(sig)

    @staticmethod
    def is_layer_signature_compatible(instruction_signature: str, pattern_signature: str) -> bool:
        if instruction_signature == pattern_signature:
            return True
        instruction_node_list = instruction_signature.split(",")
        pattern_node_list = pattern_signature.split(",")
        for ins_node_sig, pattern_node_sig in zip(instruction_node_list, pattern_node_list):
            if pattern_node_sig not in ["L", "C", "N"] and ins_node_sig != pattern_node_sig:
                return False
        return True

    def get_matching_rule_pattern_info(self, pattern: AstNode):
        pattern_search_logger.info("Searching : {0}".format(pattern))
        return self.explore_one_level(pattern, 1)

    def explore_one_level(self, searched_pattern: AstNode, cur_level: int):
        # We need to check if searched_pattern is in self.next_layer_patterns
        # Easy solution: try/except self.next_layer_patterns[searched_pattern]
        # Problem is that known patterns may not exactly match the microcode instruction, e.g.
        #   -> Pattern layer 3 signature is ["L", "N", "15", "L"]
        #   -> Multiple instruction can match that: ["L", "N", "15", "L"], ["C", "N", "15", "L"], ["C", "N", "15", "13"]
        # This piece of code tries to handles that in a (semi) efficient way
        if len(self.next_layer_patterns) == 0:
            return []
        searched_layer_signature = searched_pattern.get_depth_signature(cur_level)
        nb_possible_signature = 2 ** (len(searched_layer_signature) - searched_layer_signature.count("N") - \
                                searched_layer_signature.count("L"))
        pattern_search_logger.debug("  Layer {0}: {1} -> {2} variations (storage has {3} signature)"
                                    .format(cur_level, searched_layer_signature, nb_possible_signature,
                                            len(self.next_layer_patterns)))
        matched_rule_pattern_info = []
        if nb_possible_signature < len(self.next_layer_patterns):
            pattern_search_logger.debug("  => Using method 1")
            for possible_sig in signature_generator(searched_layer_signature):
                try:
                    test_sig = self.layer_signature_to_key(possible_sig)
                    pattern_storage = self.next_layer_patterns[test_sig]
                    pattern_search_logger.info("    Compatible signature: {0} -> resolved: {1}"
                                               .format(test_sig, pattern_storage.rule_resolved))
                    matched_rule_pattern_info += pattern_storage.rule_resolved
                    matched_rule_pattern_info += pattern_storage.explore_one_level(searched_pattern, cur_level + 1)
                except KeyError:
                    pass
        else:
            pattern_search_logger.debug("  => Using method 2")
            searched_layer_signature_key = self.layer_signature_to_key(searched_layer_signature)
            for test_sig, pattern_storage in self.next_layer_patterns.items():
                if self.is_layer_signature_compatible(searched_layer_signature_key, test_sig):
                    pattern_search_logger.info("    Compatible signature: {0} -> resolved: {1}"
                                               .format(test_sig, pattern_storage.rule_resolved))
                    matched_rule_pattern_info += pattern_storage.rule_resolved
                    matched_rule_pattern_info += pattern_storage.explore_one_level(searched_pattern, cur_level + 1)
        return matched_rule_pattern_info


class PatternOptimizer(InstructionOptimizer):
    # The main idea of PatternOptimizer is to generate/store all possible patterns associated to all known rules in a $
    # dictionary-like object (PatternStorage) when the plugin is loaded.
    # => it means that we generate a very large number of patterns
    #
    # At runtime, we transform the microcode instruction in a list of keys that we search in the PatternStorage object
    # to speed up the checks
    # => we don't want to test all patterns, so we use the PatternStorage object to (quickly) get the patterns
    # which have the same shape as the microcode instruction

    RULE_CLASSES = [PatternMatchingRule]

    def __init__(self, maturities, log_dir=None):
        super().__init__(maturities, log_dir=log_dir)
        self.pattern_storage = PatternStorage(depth=1)

    def add_rule(self, rule: InstructionOptimizationRule):
        is_ok = super().add_rule(rule)
        if not is_ok:
            return False
        for pattern in rule.pattern_candidates:
            self.pattern_storage.add_pattern_for_rule(pattern, rule)
        return True

    def get_optimized_instruction(self, blk: mblock_t, ins: minsn_t) -> Union[None, minsn_t]:
        if blk is not None:
            self.cur_maturity = blk.mba.maturity
        if self.cur_maturity not in self.maturities:
            return None
        tmp = minsn_to_ast(ins)
        if tmp is None:
            return None

        all_matchs = self.pattern_storage.get_matching_rule_pattern_info(tmp)
        for rule_pattern_info in all_matchs:
            try:
                new_ins = rule_pattern_info.rule.check_pattern_and_replace(rule_pattern_info.pattern, tmp)
                if new_ins is not None:
                    self.rules_usage_info[rule_pattern_info.rule.name] += 1
                    optimizer_logger.info("Rule {0} matched:".format(rule_pattern_info.rule.name))
                    optimizer_logger.info("  orig: {0}".format(format_minsn_t(ins)))
                    optimizer_logger.info("  new : {0}".format(format_minsn_t(new_ins)))
                    return new_ins
            except RuntimeError as e:
                optimizer_logger.error("Error during rule {0} for instruction {1}: {2}"
                                       .format(rule_pattern_info.rule, format_minsn_t(ins), e))
        return None

# AST equivalent pattern generation stuff
# TODO: refactor/clean this


def rec_get_all_binary_subtree_representation(elt_list):
    if len(elt_list) == 1:
        return elt_list
    if len(elt_list) == 2:
        return [elt_list]
    tmp_res = []
    for i in range(1, len(elt_list)):
        left_list = rec_get_all_binary_subtree_representation(elt_list[:i])
        right_list = rec_get_all_binary_subtree_representation(elt_list[i:])
        for l in left_list:
            for r in right_list:
                tmp_res.append([l, r])
    return tmp_res


def rec_get_all_binary_tree_representation(elt_list):
    if len(elt_list) <= 1:
        return elt_list
    tmp = list(itertools.permutations(elt_list))
    tmp2 = []
    for perm_tmp in tmp:
        tmp2 += rec_get_all_binary_subtree_representation(perm_tmp)
    return tmp2


def get_all_binary_tree_representation(all_elt):
    tmp = rec_get_all_binary_tree_representation(all_elt)
    return tmp


def generate_ast(opcode, leafs):
    if isinstance(leafs, AstLeaf):
        return leafs
    if isinstance(leafs, AstNode):
        return leafs
    if len(leafs) == 1:
        return leafs[0]
    if len(leafs) == 2:
        return AstNode(opcode, generate_ast(opcode, leafs[0]), generate_ast(opcode, leafs[1]))


def get_addition_operands(ast_node):
    if not isinstance(ast_node, AstNode):
        return [ast_node]
    if ast_node.opcode == m_add:
        return get_addition_operands(ast_node.left) + get_addition_operands(ast_node.right)
    elif ast_node.opcode == m_sub:
        tmp = get_addition_operands(ast_node.left)
        for aaa in get_addition_operands(ast_node.right):
            tmp.append(AstNode(m_neg, aaa))
        return tmp
    else:
        return [ast_node]


def get_opcode_operands(ref_opcode, ast_node):
    if not isinstance(ast_node, AstNode):
        return [ast_node]
    if ast_node.opcode == ref_opcode:
        return get_opcode_operands(ref_opcode, ast_node.left) + get_opcode_operands(ref_opcode, ast_node.right)
    else:
        return [ast_node]


def get_similar_opcode_operands(ast_node):
    if ast_node.opcode in [m_add, m_sub]:
        add_elts = get_addition_operands(ast_node)
        all_add_ordering = get_all_binary_tree_representation(add_elts)
        ast_res = []
        for leaf_ordering in all_add_ordering:
            ast_res.append(generate_ast(m_add, leaf_ordering))
        return ast_res
    elif ast_node.opcode in [m_xor, m_or, m_and, m_mul]:
        same_elts = get_opcode_operands(ast_node.opcode, ast_node)
        all_same_ordering = get_all_binary_tree_representation(same_elts)
        ast_res = []
        for leaf_ordering in all_same_ordering:
            ast_res.append(generate_ast(ast_node.opcode, leaf_ordering))
        return ast_res

    else:
        return [ast_node]


def get_ast_variations_with_add_sub(opcode, left, right):
    possible_ast = [AstNode(opcode, left, right)]
    if opcode == m_add:
        if isinstance(left, AstNode) and isinstance(right, AstNode):
            if (left.opcode == m_neg) and (right.opcode == m_neg):
                possible_ast.append(AstNode(m_neg, AstNode(m_add, left.left, right.left)))
        if isinstance(right, AstNode) and (right.opcode == m_neg):
            possible_ast.append(AstNode(m_sub, left, right.left))
    return possible_ast


def ast_generator(ast_node, excluded_opcodes=None):
    if not isinstance(ast_node, AstNode):
        return [ast_node]
    res_ast = []
    excluded_opcodes = excluded_opcodes if excluded_opcodes is not None else []
    if ast_node.opcode not in excluded_opcodes:
        if ast_node.opcode in [m_add, m_sub]:
            similar_ast_list = get_similar_opcode_operands(ast_node)
            for similar_ast in similar_ast_list:
                sub_ast_left_list = ast_generator(similar_ast.left, excluded_opcodes=[m_add, m_sub])
                sub_ast_right_list = ast_generator(similar_ast.right, excluded_opcodes=[m_add, m_sub])
                for sub_ast_left in sub_ast_left_list:
                    for sub_ast_right in sub_ast_right_list:
                        res_ast += get_ast_variations_with_add_sub(m_add, sub_ast_left, sub_ast_right)
            return res_ast
        if ast_node.opcode in [m_xor, m_or, m_and, m_mul]:
            similar_ast_list = get_similar_opcode_operands(ast_node)
            for similar_ast in similar_ast_list:
                sub_ast_left_list = ast_generator(similar_ast.left, excluded_opcodes=[ast_node.opcode])
                sub_ast_right_list = ast_generator(similar_ast.right, excluded_opcodes=[ast_node.opcode])
                for sub_ast_left in sub_ast_left_list:
                    for sub_ast_right in sub_ast_right_list:
                        res_ast += get_ast_variations_with_add_sub(ast_node.opcode, sub_ast_left, sub_ast_right)
            return res_ast
    if ast_node.opcode not in [m_add, m_sub, m_or, m_and, m_mul]:
        excluded_opcodes = []
    nb_operands = 0
    if ast_node.left is not None:
        nb_operands += 1
    if ast_node.right is not None:
        nb_operands += 1
    if nb_operands == 1:
        sub_ast_list = ast_generator(ast_node.left, excluded_opcodes=excluded_opcodes)
        for sub_ast in sub_ast_list:
            res_ast.append(AstNode(ast_node.opcode, sub_ast))
        return res_ast
    if nb_operands == 2:
        sub_ast_left_list = ast_generator(ast_node.left, excluded_opcodes=excluded_opcodes)
        sub_ast_right_list = ast_generator(ast_node.right, excluded_opcodes=excluded_opcodes)
        for sub_ast_left in sub_ast_left_list:
            for sub_ast_right in sub_ast_right_list:
                res_ast += get_ast_variations_with_add_sub(ast_node.opcode, sub_ast_left, sub_ast_right)
        return res_ast
    return []

```

`d810/optimizers/instructions/pattern_matching/rewrite_add.py`:

```py
from ida_hexrays import *

from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_helpers import equal_ignore_msb_cst, equal_bnot_mop, AND_TABLE


class Add_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstLeaf("x_0"),
                      AstNode(m_sub,
                              AstNode(m_bnot,
                                      AstLeaf("x_1")),
                              AstConstant("1", 1)))
    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf("x_0"), AstLeaf("x_1"))


class Add_HackersDelightRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))))
    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf("x_0"), AstLeaf("x_1"))


class Add_HackersDelightRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf("x_0"), AstLeaf("x_1"))


class Add_HackersDelightRule_4(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))),
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf("x_0"), AstLeaf("x_1"))


class Add_HackersDelightRule_5(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_or,
                                      AstNode(m_or,
                                              AstLeaf("x_0"),
                                              AstLeaf("x_1")),
                                      AstLeaf("x_2"))),
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstNode(m_or,
                                      AstLeaf("x_1"),
                                      AstLeaf("x_2"))))
    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf("x_0"), AstNode(m_or, AstLeaf("x_1"), AstLeaf("x_2")))


class Add_SpecialConstantRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstConstant("c_2"))))
    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf("x_0"), AstConstant("c_1"))

    def check_candidate(self, candidate):
        return equal_ignore_msb_cst(candidate["c_1"].mop, candidate["c_2"].mop)


class Add_SpecialConstantRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_xor,
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstConstant("val_ff", 0xff)),
                              AstConstant("c_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstConstant("c_2"))))
    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf("x_0"), AstConstant("c_1"))

    def check_candidate(self, candidate):
        return (candidate["c_1"].value & 0xff) == candidate["c_2"].value


class Add_SpecialConstantRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstConstant("c_2"))))
    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf("x_0"), AstConstant("val_res"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["c_1"].mop, candidate["c_2"].mop):
            return False
        candidate.add_constant_leaf("val_res", candidate["c_2"].value - 1, candidate["x_0"].size)
        return True


class Add_OllvmRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_bnot,
                              AstNode(m_xor,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_or,
                                      AstLeaf('x_1'),
                                      AstLeaf('x_0'))))
    REPLACEMENT_PATTERN = AstNode(m_sub,
                                  AstNode(m_add,
                                          AstLeaf('x_0'),
                                          AstLeaf('x_1')),
                                  AstConstant("val_1"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


class Add_OllvmRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_bnot,
                              AstNode(m_xor,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))),
                      AstNode(m_mul,
                              AstConstant("val_fe"),
                              AstNode(m_or,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_sub,
                                  AstNode(m_add,
                                          AstLeaf('x_0'),
                                          AstLeaf('x_1')),
                                  AstConstant("val_1"))

    def check_candidate(self, candidate):
        if (candidate["val_fe"].value + 2) & AND_TABLE[candidate["val_fe"].size] != 0:
            return False
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


class Add_OllvmRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_xor,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf('x_0'), AstLeaf('x_1'))


class Add_OllvmRule_4(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_xor,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_mul,
                              AstConstant("val_fe"),
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_add, AstLeaf('x_0'), AstLeaf('x_1'))


class AddXor_Rule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_sub,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("bnot_x_1"))))
    REPLACEMENT_PATTERN = AstNode(m_add,
                                  AstNode(m_xor,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")),
                                  AstConstant("val_2"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        candidate.add_constant_leaf("val_2", 2, candidate["x_0"].size)
        return True


class AddXor_Rule_2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_sub,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_bnot,
                                      AstNode(m_and,
                                              AstLeaf("bnot_x_0"),
                                              AstLeaf("x_1")))))

    REPLACEMENT_PATTERN = AstNode(m_add,
                                  AstNode(m_xor,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")),
                                  AstLeaf("val_2"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        candidate.add_constant_leaf("val_2", 2, candidate["x_0"].size)
        return True


```

`d810/optimizers/instructions/pattern_matching/rewrite_and.py`:

```py
from ida_hexrays import *

from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_helpers import equal_bnot_mop, SUB_TABLE


class And_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_or,
                              AstNode(m_bnot,
                                      AstLeaf("x_0")),
                              AstLeaf("x_1")),
                      AstNode(m_bnot, AstLeaf("x_0")))

    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf("x_0"), AstLeaf("x_1"))


class And_HackersDelightRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_or,
                              AstLeaf("bnot_x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_add,
                              AstLeaf("x_0"),
                              AstConstant("1", 1)))

    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        return equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop)


class And_HackersDelightRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_add,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf("x_0"), AstLeaf("x_1"))


class And_HackersDelightRule_4(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_or,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_xor,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')))
    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))


class And_OllvmRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_or,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_bnot,
                              AstNode(m_xor,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))


class And_OllvmRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_or,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_xor,
                              AstLeaf('x_0'),
                              AstLeaf('bnot_x_1')))
    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))

    def check_candidate(self, candidate):
        return equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop)


class And_OllvmRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_bnot,
                              AstNode(m_xor,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))



class And_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("bnot_x_1")),
                      AstLeaf("x_1"))
    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        return equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop)


class And_FactorRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstLeaf('x_0'),
                      AstNode(m_bnot,
                              AstNode(m_xor,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstLeaf('x_1'))


class AndBnot_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstLeaf("x_1"))
    REPLACEMENT_PATTERN = AstNode(m_and,
                                  AstLeaf("x_0"),
                                  AstNode(m_bnot, AstLeaf("x_1")))


class AndBnot_HackersDelightRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstLeaf("x_0"),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_and,
                                  AstLeaf("x_0"),
                                  AstNode(m_bnot, AstLeaf("x_1")))


class AndBnot_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstLeaf("x_0"),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_and,
                                  AstLeaf("x_0"),
                                  AstNode(m_bnot, AstLeaf("x_1")))


class AndBnot_FactorRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstLeaf("x_0"),
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_and,
                                  AstLeaf("x_0"),
                                  AstNode(m_bnot, AstLeaf("x_1")))


class AndBnot_FactorRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstLeaf("x_1"))

    REPLACEMENT_PATTERN = AstNode(m_and,
                                  AstLeaf("x_0"),
                                  AstNode(m_bnot, AstLeaf("x_1")))


class AndBnot_FactorRule_4(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_xor,
                              AstLeaf('x_1'),
                              AstLeaf('x_0')),
                      AstNode(m_bnot,
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstLeaf('bnot_x_1'))))

    REPLACEMENT_PATTERN = AstNode(m_and,
                                  AstLeaf("x_1"),
                                  AstNode(m_bnot, AstLeaf("x_0")))

    def check_candidate(self, candidate):
        return equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop)


class AndOr_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_2")),
                      AstNode(m_and,
                              AstLeaf("x_1"),
                              AstLeaf("x_2")))
    REPLACEMENT_PATTERN = AstNode(m_and,
                                  AstNode(m_or,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")),
                                  AstLeaf("x_2"))


class AndXor_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_2")),
                      AstNode(m_and,
                              AstLeaf("x_1"),
                              AstLeaf("x_2")))
    REPLACEMENT_PATTERN = AstNode(m_and,
                                  AstNode(m_xor,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")),
                                  AstLeaf("x_2"))


class And1_MbaRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_mul, AstLeaf("x_0"), AstLeaf("x_0")),
                      AstConstant("3", 3))
    REPLACEMENT_PATTERN = AstNode(m_and,
                                  AstLeaf("x_0"),
                                  AstConstant("val_1"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


class AndGetUpperBits_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_mul,
                      AstConstant("c_1"),
                      AstNode(m_and,
                              AstNode(m_shr,
                                      AstLeaf('x_0'),
                                      AstConstant("c_2")),
                              AstConstant("c_3")))

    REPLACEMENT_PATTERN = AstNode(m_and, AstLeaf('x_0'), AstConstant("c_res"))

    def check_candidate(self, candidate):
        if (2 ** candidate["c_2"].value) != candidate["c_1"].value:
            return False
        c_res = (SUB_TABLE[candidate["c_1"].size] - candidate["c_1"].value) & candidate["c_3"].value
        candidate.add_constant_leaf("c_res", c_res, candidate["x_0"].size)
        return True

```

`d810/optimizers/instructions/pattern_matching/rewrite_bnot.py`:

```py
from ida_hexrays import *

from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_helpers import equal_bnot_mop, SUB_TABLE


class Bnot_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_neg,
                              AstLeaf("x_0")),
                      AstConstant("1", 1))
    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf("x_0"))


class Bnot_HackersDelightRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_bnot,
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))),
                      AstNode(m_bnot,
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf("x_1"))


class Bnot_MbaRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_sub,
                              AstLeaf("x_0"),
                              AstConstant("1", 1)),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstLeaf("x_0")))
    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf("x_0"))


class Bnot_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_bnot,
                              AstNode(m_xor,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))),
                      AstLeaf("x_1"))
    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf("x_0"))


class Bnot_FactorRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstConstant("minus_1"),
                      AstLeaf("x_0"))
    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf("x_0"))

    def check_candidate(self, candidate):
        if candidate["minus_1"].value != SUB_TABLE[candidate["minus_1"].size] - 1:
            return False
        return True


class Bnot_FactorRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_or,
                              AstLeaf('x_0'),
                              AstLeaf('bnot_x_1')))
    REPLACEMENT_PATTERN = AstNode(m_bnot, AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Bnot_FactorRule_4(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_bnot, AstLeaf('x_0')),
                      AstNode(m_bnot, AstLeaf('x_1')))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf('x_0'), AstLeaf("x_1"))


class BnotXor_Rule_1(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_and,
                              AstLeaf("bnot_x_0"),
                              AstLeaf("bnot_x_1")))

    REPLACEMENT_PATTERN = AstNode(m_bnot,
                                  AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1")))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class BnotXor_Rule_2(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_or,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_or,
                              AstLeaf('bnot_x_0'),
                              AstLeaf('bnot_x_1')))

    REPLACEMENT_PATTERN = AstNode(m_bnot,
                                  AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1")))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True

class BnotXor_Rule_3(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_or,
                              AstLeaf('x_0'),
                              AstLeaf('bnot_x_1')),
                      AstNode(m_or,
                              AstLeaf('bnot_x_0'),
                              AstLeaf('x_1')))

    REPLACEMENT_PATTERN = AstNode(m_bnot,
                                  AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1")))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class BnotXor_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstLeaf("x_0"),
                      AstNode(m_bnot,
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_bnot,
                                  AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1")))


class BnotAnd_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_bnot,
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))))

    REPLACEMENT_PATTERN = AstNode(m_bnot,
                                  AstNode(m_and, AstLeaf("x_0"), AstLeaf("x_1")))



class BnotAnd_FactorRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_or,
                              AstLeaf("bnot_x_0"),
                              AstLeaf("bnot_x_1")),
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_bnot,
                                  AstNode(m_and, AstLeaf("x_0"), AstLeaf("x_1")))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class BnotAnd_FactorRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_bnot,
                              AstLeaf("x_0")),
                      AstNode(m_bnot,
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_bnot,
                                  AstNode(m_and, AstLeaf("x_0"), AstLeaf("x_1")))


class BnotAnd_FactorRule_4(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstLeaf("bnot_x_0"),
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_bnot,
                                  AstNode(m_and, AstLeaf("x_0"), AstLeaf("x_1")))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        return True


class BnotOr_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_bnot,
                              AstLeaf("x_0")),
                      AstNode(m_bnot,
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_bnot,
                                  AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1")))


class BnotAdd_MbaRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("bnot_x_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))))

    REPLACEMENT_PATTERN = AstNode(m_bnot,
                                  AstNode(m_add, AstLeaf("x_0"), AstLeaf("x_1")))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Bnot_Rule_1(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("bnot_x_1")),
                      AstNode(m_bnot,
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))))

    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf("bnot_x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Bnot_XorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_bnot,
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))))

    REPLACEMENT_PATTERN = AstNode(m_bnot, AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1")))

```

`d810/optimizers/instructions/pattern_matching/rewrite_cst.py`:

```py
from ida_hexrays import *

from d810.ast import AstLeaf, AstConstant, AstNode
from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.hexrays_helpers import equal_bnot_cst, SUB_TABLE, AND_TABLE, equal_bnot_mop


class CstSimplificationRule1(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_bnot,
                              AstLeaf("x_0")),
                      AstNode(m_xor,
                              AstNode(m_bnot,
                                      AstLeaf("x_0")),
                              AstConstant("c_1")))
    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstNode(m_bnot,
                                                  AstConstant("c_1"))),
                                  AstNode(m_bnot, AstConstant("c_1")))


class CstSimplificationRule2(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstNode(m_xor,
                                      AstLeaf("x_0"),
                                      AstConstant("c_1_1")),
                              AstConstant("c_2_1")),
                      AstNode(m_and,
                              AstNode(m_xor,
                                      AstLeaf("x_0"),
                                      AstConstant("c_1_2")),
                              AstConstant("c_2_2")))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstConstant("c_res"))

    def check_candidate(self, candidate):
        if not equal_bnot_cst(candidate["c_2_1"].mop, candidate["c_2_2"].mop):
            return False
        c_res = ((candidate["c_1_1"].value ^ candidate["c_1_2"].value) & candidate["c_2_1"].value)
        c_res ^= candidate["c_1_2"].value
        candidate.add_constant_leaf("c_res", c_res, candidate["c_1_1"].size)
        return True


class CstSimplificationRule3(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_sub,
                              AstLeaf("x_0"),
                              AstConstant("c_0")),
                      AstNode(m_mul,
                              AstConstant("c_1"),
                              AstNode(m_sub,
                                      AstLeaf("x_0"),
                                      AstConstant("c_2"))))
    REPLACEMENT_PATTERN = AstNode(m_sub,
                                  AstNode(m_mul,
                                          AstConstant("c_coeff"),
                                          AstLeaf("x_0")),
                                  AstConstant("c_sub"))

    def check_candidate(self, candidate):
        c_coeff = candidate["c_1"].value + 1
        c_sub = (candidate["c_1"].value * candidate["c_2"].value) + candidate["c_0"].value
        candidate.add_constant_leaf("c_coeff", c_coeff, candidate["c_1"].size)
        candidate.add_constant_leaf("c_sub", c_sub, candidate["c_2"].size)
        return True


class CstSimplificationRule4(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstLeaf("x_0"),
                      AstNode(m_sub,
                              AstConstant("c_1"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_add,
                                  AstLeaf("x_0"),
                                  AstNode(m_add,
                                          AstLeaf("x_1"),
                                          AstConstant("c_res")))

    def check_candidate(self, candidate):
        c_res = SUB_TABLE[candidate["c_1"].size] - candidate["c_1"].value
        candidate.add_constant_leaf("c_res", c_res, candidate["c_1"].size)
        return True


class CstSimplificationRule5(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstNode(m_and,
                              AstLeaf("x_1"),
                              AstConstant("c_2")))
    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstNode(m_and,
                                          AstNode(m_xor,
                                                  AstLeaf("x_0"),
                                                  AstLeaf("x_1")),
                                          AstConstant("c_1")),
                                  AstLeaf("x_1"))

    def check_candidate(self, candidate):
        return equal_bnot_cst(candidate["c_1"].mop, candidate["c_2"].mop)


class CstSimplificationRule6(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstConstant("c_2")),
                                  AstConstant("c_res"))

    def check_candidate(self, candidate):
        c_res = candidate["c_1"].value & candidate["c_2"].value
        candidate.add_constant_leaf("c_res", c_res, candidate["c_2"].size)
        return True


class CstSimplificationRule7(PatternMatchingRule):
    PATTERN = AstNode(m_shr,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_and,
                                  AstNode(m_shr,
                                          AstLeaf("x_0"),
                                          AstConstant("c_2")),
                                  AstConstant("c_res"))

    def check_candidate(self, candidate):
        c_res = candidate["c_1"].value >> candidate["c_2"].value
        candidate.add_constant_leaf("c_res", c_res, candidate["c_1"].size)
        return True


class CstSimplificationRule8(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_or,
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstConstant("c_res")),
                                  AstConstant("c_2"))

    def check_candidate(self, candidate):
        c_res = candidate["c_1"].value & ~candidate["c_2"].value
        if c_res == candidate["c_1"].value:
            return False
        candidate.add_constant_leaf("c_res", c_res, candidate["c_1"].size)
        return True


class CstSimplificationRule9(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstConstant("c_and")),
                                  AstConstant("c_xor"))

    def check_candidate(self, candidate):
        c_and = (AND_TABLE[candidate["c_1"].size] ^ candidate["c_1"].value) & candidate["c_2"].value
        c_xor = candidate["c_1"].value & candidate["c_2"].value
        candidate.add_constant_leaf("c_and", c_and, candidate["x_0"].size)
        candidate.add_constant_leaf("c_xor", c_xor, candidate["x_0"].size)
        return True


class CstSimplificationRule10(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_2")))
    REPLACEMENT_PATTERN = AstNode(m_neg,
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstConstant("c_and")))

    def check_candidate(self, candidate):
        if (candidate["c_1"].value & candidate["c_2"].value) != candidate["c_1"].value:
            return False
        c_and = (AND_TABLE[candidate["c_1"].size] ^ candidate["c_1"].value) & candidate["c_2"].value
        candidate.add_constant_leaf("c_and", c_and, candidate["x_0"].size)
        return True


class CstSimplificationRule11(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_xor,
                              AstNode(m_bnot,
                                      AstLeaf("x_0")),
                              AstConstant("c_1")),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_2")))
    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstNode(m_xor,
                                          AstLeaf("x_0"),
                                          AstConstant("c_1_bnot")),
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstConstant("c_and")))

    def check_candidate(self, candidate):
        c_1_bnot = (AND_TABLE[candidate["c_1"].size] ^ candidate["c_1"].value)
        c_and = c_1_bnot & candidate["c_2"].value
        candidate.add_constant_leaf("c_1_bnot", c_1_bnot, candidate["c_1"].size)
        candidate.add_constant_leaf("c_and", c_and, candidate["c_1"].size)
        return True


class CstSimplificationRule12(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_sub,
                              AstConstant("c_1"),
                              AstLeaf("x_0")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_and,
                                      AstNode(m_bnot,
                                              AstLeaf("x_0")),
                                      AstConstant("c_2"))))
    REPLACEMENT_PATTERN = AstNode(m_sub,
                                  AstNode(m_xor,
                                          AstNode(m_bnot, AstLeaf("x_0")),
                                          AstConstant("c_2")),
                                  AstConstant("c_diff"))

    def check_candidate(self, candidate):
        c_diff = candidate["c_2"].value - candidate["c_1"].value
        candidate.add_constant_leaf("c_diff", c_diff, candidate["c_1"].size)
        return True


class CstSimplificationRule13(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_and,
                              AstConstant("cst_1"),
                              AstNode(m_xor,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))),
                      AstLeaf("x_1"))
    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstConstant("cst_1")),
                                  AstNode(m_and, AstLeaf("x_1"),
                                          AstConstant("not_cst_1")))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("not_cst_1", ~candidate["cst_1"].value, candidate["cst_1"].size)
        return True


class CstSimplificationRule14(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_add,
                                  AstNode(m_or,
                                          AstLeaf("x_0"),
                                          AstLeaf("lnot_c_1")),
                                  AstConstant("val_1"))

    def check_candidate(self, candidate):
        lnot_c_1_value = candidate["c_1"].value ^ AND_TABLE[candidate["c_1"].size]
        tmp = lnot_c_1_value ^ candidate["c_2"].value
        if tmp != 1:
            return False
        candidate.add_constant_leaf("val_1", 1, candidate["c_2"].size)
        candidate.add_constant_leaf("lnot_c_1", lnot_c_1_value, candidate["c_1"].size)


class CstSimplificationRule15(PatternMatchingRule):
    PATTERN = AstNode(m_shr,
                      AstNode(m_shr,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_shr, AstLeaf("x_0"), AstConstant("c_res"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("c_res", candidate["c_1"].value + candidate["c_2"].value, candidate["c_1"].size)
        return True


class CstSimplificationRule16(PatternMatchingRule):
    PATTERN = AstNode(m_bnot,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstConstant("c_1")))
    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstLeaf("x_0"),
                                  AstLeaf("bnot_c_1"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("bnot_c_1", candidate["c_1"].value ^ AND_TABLE[candidate["c_1"].size],
                                    candidate["c_1"].size)
        return True


class CstSimplificationRule17(PatternMatchingRule):
    PATTERN = AstNode(m_bnot,
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstConstant("c_1")))
    REPLACEMENT_PATTERN = AstNode(m_and,
                                  AstNode(m_bnot, AstLeaf("x_0")),
                                  AstLeaf("bnot_c_1"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("bnot_c_1", candidate["c_1"].value ^ AND_TABLE[candidate["c_1"].size],
                                    candidate["c_1"].size)
        return True


class CstSimplificationRule18(PatternMatchingRule):
    PATTERN = AstNode(m_bnot,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_1")))
    REPLACEMENT_PATTERN = AstNode(m_or,
                                  AstNode(m_bnot, AstLeaf("x_0")),
                                  AstLeaf("bnot_c_1"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("bnot_c_1", candidate["c_1"].value ^ AND_TABLE[candidate["c_1"].size],
                                    candidate["c_1"].size)
        return True


class CstSimplificationRule19(PatternMatchingRule):
    PATTERN = AstNode(m_sar,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_and, AstNode(m_shr, AstLeaf("x_0"), AstConstant("c_2")), AstConstant("c_res"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("c_res", candidate["c_1"].value >> candidate["c_2"].value,
                                    candidate["c_1"].size)
        return True


# Found sometimes with OLLVM
class CstSimplificationRule20(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf('bnot_x_0'),
                              AstConstant('c_and_1')),
                      AstNode(m_xor,
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstConstant('c_and_2')),
                              AstConstant('c_xor')))

    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstConstant("c_and_res")),
                                  AstConstant("c_xor_res"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if candidate["c_and_1"].value & candidate["c_and_2"].value != 0:
            return False
        candidate.add_constant_leaf("c_and_res", candidate["c_and_1"].value ^ candidate["c_and_2"].value,
                                    candidate["c_and_1"].size)
        candidate.add_constant_leaf("c_xor_res", candidate["c_and_1"].value ^ candidate["c_xor"].value,
                                    candidate["c_and_1"].size)
        return True


# Found sometimes with OLLVM
class CstSimplificationRule21(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_xor,
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstConstant('c_and')),
                              AstConstant('c_xor_1')),
                      AstNode(m_xor,
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstConstant('bnot_c_and')),
                              AstConstant('c_xor_2')))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstConstant("c_xor_res"))

    def check_candidate(self, candidate):
        if not equal_bnot_cst(candidate["c_and"].mop, candidate["bnot_c_and"].mop):
            return False
        if candidate["c_xor_1"].mop.nnn.value & candidate["c_xor_2"].mop.nnn.value != 0:
            return False
        candidate.add_constant_leaf("c_xor_res", candidate["c_xor_1"].value ^ candidate["c_xor_2"].value,
                                    candidate["c_xor_1"].size)
        return True


# Found sometimes with OLLVM
class CstSimplificationRule22(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_xor,
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstConstant('c_and')),
                              AstConstant('c_xor_1')),
                      AstNode(m_xor,
                              AstNode(m_and,
                                      AstLeaf('bnot_x_0'),
                                      AstConstant('bnot_c_and')),
                              AstConstant('c_xor_2')))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstConstant("c_xor_res"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_cst(candidate["c_and"].mop, candidate["bnot_c_and"].mop):
            return False
        if candidate["c_xor_1"].mop.nnn.value & candidate["c_xor_2"].mop.nnn.value != 0:
            return False
        if candidate["c_xor_1"].mop.nnn.value & candidate["bnot_c_and"].mop.nnn.value != 0:
            return False
        candidate.add_constant_leaf("c_xor_res", candidate["c_xor_1"].value ^ candidate["c_xor_2"].value ^ candidate["bnot_c_and"].value,
                                    candidate["c_xor_1"].size)
        return True

```

`d810/optimizers/instructions/pattern_matching/rewrite_mov.py`:

```py
from ida_hexrays import *


from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_helpers import equal_bnot_mop, AND_TABLE


# GetIdentRule1: ((x_0 & x_1) + (x_0 & ~x_1)) == x_0
class GetIdentRule1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstLeaf('bnot_x_1')))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf("x_0"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


# GetIdentRule2: ((x_0 & x_1) ^ (x_0 & ~x_1)) == x_0 i
class GetIdentRule2(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstLeaf('bnot_x_1')))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf("x_0"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class GetIdentRule3(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstLeaf("x_0"),
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf("x_0"))

```

`d810/optimizers/instructions/pattern_matching/rewrite_mul.py`:

```py
from ida_hexrays import *

from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_helpers import equal_bnot_mop, is_check_mop, SUB_TABLE


class Mul_MbaRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_mul,
                              AstNode(m_or,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1')),
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))),
                      AstNode(m_mul,
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstLeaf('bnot_x_1')),
                              AstNode(m_and,
                                      AstLeaf('x_1'),
                                      AstLeaf('bnot_x_0'))))
    REPLACEMENT_PATTERN = AstNode(m_mul, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Mul_MbaRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_mul,
                              AstNode(m_or,
                                      AstLeaf('x_0'),
                                      AstConstant('c_1')),
                              AstLeaf('x_0')),
                      AstNode(m_mul,
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstConstant('bnot_c_1')),
                              AstNode(m_and,
                                      AstConstant('c_1'),
                                      AstLeaf('bnot_x_0'))))
    REPLACEMENT_PATTERN = AstNode(m_mul, AstLeaf("x_0"), AstConstant('c_1'))

    def check_candidate(self, candidate):
        if not is_check_mop(candidate["x_0"].mop):
            return False
        if candidate["c_1"].value & 0x1 != 1:
            return False
        if not equal_bnot_mop(candidate["c_1"].mop, candidate["bnot_c_1"].mop):
            return False
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        return True


class Mul_MbaRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_mul,
                              AstNode(m_or,
                                      AstLeaf('x_0'),
                                      AstConstant('c_1')),
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstConstant('c_1'))),
                      AstNode(m_mul,
                              AstLeaf('x_0'),
                              AstNode(m_and,
                                      AstConstant('c_1'),
                                      AstLeaf('bnot_x_0'))))
    REPLACEMENT_PATTERN = AstNode(m_mul, AstLeaf("x_0"), AstConstant('c_1'))

    def check_candidate(self, candidate):
        if not is_check_mop(candidate["x_0"].mop):
            return False
        if candidate["c_1"].value & 0x1 == 1:
            return False
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        return True


class Mul_MbaRule_4(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_mul,
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1")),
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))),
                      AstNode(m_mul,
                              AstNode(m_bnot,
                                      AstNode(m_or,
                                              AstLeaf("x_0"),
                                              AstLeaf("bnot_x_1"))),
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstLeaf("bnot_x_1"))))
    REPLACEMENT_PATTERN = AstNode(m_mul, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Mul_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstConstant("2", 2),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_add,
                                      AstLeaf("x_1"),
                                      AstNode(m_or,
                                              AstLeaf("x_0"),
                                              AstLeaf("bnot_x_1")))))

    REPLACEMENT_PATTERN = AstNode(m_mul,
                                  AstConstant("2", 2),
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Mul_FactorRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_neg,
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_mul,
                                  AstConstant("val_fe"),
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_fe", SUB_TABLE[candidate.size] - 2, candidate.size)
        return True
```

`d810/optimizers/instructions/pattern_matching/rewrite_neg.py`:

```py
from ida_hexrays import *

from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.hexrays_helpers import AND_TABLE
from d810.ast import AstLeaf, AstConstant, AstNode


class Neg_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_bnot,
                              AstLeaf("x_0")),
                      AstConstant("1", 1))
    REPLACEMENT_PATTERN = AstNode(m_neg, AstLeaf("x_0"))


class Neg_HackersDelightRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_bnot,
                      AstNode(m_sub,
                              AstLeaf("x_0"),
                              AstConstant("1", 1)))
    REPLACEMENT_PATTERN = AstNode(m_neg, AstLeaf("x_0"))


class NegAdd_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))))
    REPLACEMENT_PATTERN = AstNode(m_neg,
                                  AstNode(m_add,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")))


class NegAdd_HackersDelightRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstNode(m_or,
                                      AstLeaf("x_1"),
                                      AstLeaf("x_2"))),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_or,
                                      AstNode(m_or,
                                              AstLeaf("x_0"),
                                              AstLeaf("x_1")),
                                      AstLeaf("x_2"))))
    REPLACEMENT_PATTERN = AstNode(m_neg,
                                  AstNode(m_add,
                                          AstLeaf("x_0"),
                                          AstNode(m_or,
                                                  AstLeaf("x_1"),
                                                  AstLeaf("x_2"))))


class NegAdd_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_mul,
                              AstConstant('val_fe'),
                              AstNode(m_or,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))),
                      AstNode(m_xor,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')))

    REPLACEMENT_PATTERN = AstNode(m_neg,
                                  AstNode(m_add,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")))


    def check_candidate(self, candidate):
        if (candidate["val_fe"].value + 2) & AND_TABLE[candidate["val_fe"].size] != 0:
            return False
        return True

class NegOr_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_add,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_neg,
                                  AstNode(m_or,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")))


class NegXor_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_or,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')))
    REPLACEMENT_PATTERN = AstNode(m_neg,
                                  AstNode(m_xor,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")))


class NegXor_HackersDelightRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_add,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_mul,
                              AstConstant('2', 2),
                              AstNode(m_or,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_neg,
                                  AstNode(m_xor,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")))

```

`d810/optimizers/instructions/pattern_matching/rewrite_or.py`:

```py
from ida_hexrays import *

from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_helpers import equal_bnot_mop


class Or_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("bnot_x_1")),
                      AstLeaf("x_1"))

    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Or_HackersDelightRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_add,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))


class Or_HackersDelightRule_2_variant_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_sub,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstNode(m_neg, AstLeaf("x_1"))))
    REPLACEMENT_PATTERN = AstNode(m_or,
                                  AstLeaf("x_0"),
                                  AstNode(m_neg, AstLeaf("x_1")))


class Or_MbaRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))


class Or_MbaRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_add,
                              AstNode(m_add,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1')),
                              AstConstant('1', 1)),
                      AstNode(m_bnot,
                              AstNode(m_and,
                                      AstLeaf('x_1'),
                                      AstLeaf('x_0'))))
    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))


class Or_MbaRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_add,
                              AstLeaf('x_0'),
                              AstNode(m_xor,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))),
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstNode(m_bnot,
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))


class Or_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))


class Or_FactorRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstNode(m_xor,
                                      AstLeaf("x_1"),
                                      AstLeaf("x_2"))),
                      AstNode(m_xor,
                              AstNode(m_xor,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1")),
                              AstLeaf("x_2")))
    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstNode(m_xor, AstLeaf("x_1"), AstLeaf("x_2")))


class Or_FactorRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_xor,
                              AstLeaf("bnot_x_0"),
                              AstLeaf("bnot_x_1")))

    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop,  candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop,  candidate["bnot_x_1"].mop):
            return False
        return True


class Or_OllvmRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_bnot,
                              AstNode(m_xor,
                                      AstLeaf("bnot_x_0"),
                                      AstLeaf("x_1"))))

    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop,  candidate["bnot_x_0"].mop):
            return False
        return True


class Or_Rule_1(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("bnot_x_0"),
                              AstLeaf("x_1")),
                      AstLeaf("x_0"))

    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop,  candidate["bnot_x_0"].mop):
            return False
        return True


class Or_Rule_2(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstLeaf("x_1"))

    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))


class Or_Rule_3(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_bnot,
                              AstNode(m_or,
                                      AstLeaf('bnot_x_0'),
                                      AstLeaf('bnot_x_1'))),
                      AstNode(m_xor,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')))

    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Or_Rule_4(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))


class OrBnot_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_bnot,
                              AstLeaf("x_0")),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_or,
                                  AstNode(m_bnot,
                                          AstLeaf("x_0")),
                                  AstLeaf("x_1"))


class OrBnot_FactorRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstLeaf("x_0"),
                      AstNode(m_and,
                              AstNode(m_bnot,
                                      AstLeaf("x_0")),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstLeaf("x_1"))


class OrBnot_FactorRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_sub,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_or,
                              AstLeaf("bnot_x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstNode(m_bnot, AstLeaf("x_1")))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        return True


class OrBnot_FactorRule_4(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_or,
                              AstLeaf("bnot_x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_or, AstLeaf("x_0"), AstNode(m_bnot, AstLeaf("x_1")))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        return True

```

`d810/optimizers/instructions/pattern_matching/rewrite_predicates.py`:

```py
from ida_hexrays import *

from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_helpers import equal_bnot_mop, SUB_TABLE, AND_TABLE


# PredSetnzRule1: (x_0 | c_1) != c_2 ==> 1 if c_1 | c_2 != c_2
class PredSetnzRule1(PatternMatchingRule):
    PATTERN = AstNode(m_setnz,
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_1"))

    def check_candidate(self, candidate):
        if (candidate["c_1"].value | candidate["c_2"].value) == candidate["c_2"].value:
            return False
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


# PredSetnzRule2: (x_0 & c_1) != c_2 ==> 1 if c_1 & c_2 != c_2
class PredSetnzRule2(PatternMatchingRule):
    PATTERN = AstNode(m_setnz,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_1"))

    def check_candidate(self, candidate):
        if (candidate["c_1"].value & candidate["c_2"].value) == candidate["c_2"].value:
            return False
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


# PredSetnzRule3: (x_0 | 2) + (x_0 ^ 2) != 0 ==> 1 (because math)
class PredSetnzRule3(PatternMatchingRule):
    PATTERN = AstNode(m_setnz,
                      AstNode(m_add,
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstConstant("2", 2)),
                              AstNode(m_xor,
                                      AstLeaf("x_0"),
                                      AstConstant("2", 2))),
                      AstConstant("0", 0))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_1"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


# PredSetnzRule4: (cst_1 - x_0) ^ x_0 != 0 ==> 1 if cst_1 % 2 == 1 (because math)
class PredSetnzRule4(PatternMatchingRule):
    PATTERN = AstNode(m_setnz,
                      AstNode(m_xor,
                              AstNode(m_sub,
                                      AstConstant("cst_1"),
                                      AstLeaf("x_0")),
                              AstLeaf("x_0")),
                      AstConstant("0", 0))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_1"))

    def check_candidate(self, candidate):
        if (candidate["cst_1"].value % 2) == 0:
            return False
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


# PredSetnzRule5: (-(~x_0 & 1)) != x_0 ==> 1 (because math)
class PredSetnzRule5(PatternMatchingRule):
    PATTERN = AstNode(m_setnz,
                      AstNode(m_neg,
                              AstNode(m_and,
                                      AstNode(m_bnot,
                                              AstLeaf("x_0")),
                                      AstConstant("1", 1))),
                      AstLeaf("x_0"))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_1"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


# PredSetnzRule6: ((x_0 + c_1) + ((x_0 + c_2) & 1)) != 0 ==> 1 (if (c_2 - c_1) & 1 == 1)
class PredSetnzRule6(PatternMatchingRule):
    PATTERN = AstNode(m_setnz,
                      AstNode(m_add,
                              AstNode(m_add,
                                      AstLeaf("x_0"),
                                      AstConstant("c_1")),
                              AstNode(m_and,
                                      AstNode(m_add,
                                              AstLeaf("x_0"),
                                              AstConstant("c_2")),
                                      AstConstant("1", 1))),
                      AstConstant("0", 0))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_1"))

    def check_candidate(self, candidate):
        if (candidate["c_2"].value - candidate["c_1"].value) & 0x1 != 1:
            return False
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


# PredSetnzRule8: bnot((3 - x_0)) ^ bnot(x_0) != 0 ==> 1
class PredSetnzRule8(PatternMatchingRule):
    PATTERN = AstNode(m_setnz,
                      AstNode(m_xor,
                              AstNode(m_bnot,
                                      AstNode(m_sub,
                                              AstConstant("3", 3),
                                              AstLeaf("x_0"))),
                              AstNode(m_bnot,
                                      AstLeaf("x_0"))),
                      AstConstant("0", 0))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_1"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


# PredSetzRule1: (x_0 | c_1) == c_2 ==> 0 if c_1 | c_2 != c_2
class PredSetzRule1(PatternMatchingRule):
    PATTERN = AstNode(m_setz,
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_0"))

    def check_candidate(self, candidate):
        if (candidate["c_1"].value | candidate["c_2"].value) == candidate["c_2"].value:
            return False
        candidate.add_constant_leaf("val_0", 0, candidate.size)
        return True


# PredSetzRule2: (x_0 & c_1) == c_2 ==> 0 if c_1 & c_2 != c_2
class PredSetzRule2(PatternMatchingRule):
    PATTERN = AstNode(m_setz,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_0"))

    def check_candidate(self, candidate):
        if (candidate["c_1"].value & candidate["c_2"].value) == candidate["c_2"].value:
            return False
        candidate.add_constant_leaf("val_0", 0, candidate.size)
        return True


# PredSetzRule3: (x_0 | 2) + (x_0 ^ 2) == 0 ==> 0 (because math)
class PredSetzRule3(PatternMatchingRule):
    PATTERN = AstNode(m_setz,
                      AstNode(m_add,
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstConstant("2", 2)),
                              AstNode(m_xor,
                                      AstLeaf("x_0"),
                                      AstConstant("2", 2))),
                      AstConstant("0", 0))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_0"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_0", 0, candidate.size)
        return True


# PredSetbRule1: (x_0 & c_1) <u c_2 ==> 0 if c_1 <u c_2
class PredSetbRule1(PatternMatchingRule):
    PATTERN = AstNode(m_setb,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("c_1")),
                      AstConstant("c_2"))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_0"))

    def check_candidate(self, candidate):
        if candidate["c_1"].value >= candidate["c_2"].value:
            return False
        candidate.add_constant_leaf("val_0", 0, candidate.size)
        return True


class PredOdd1(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_mul,
                              AstLeaf('x_0'),
                              AstNode(m_sub,
                                      AstLeaf('x_0'),
                                      AstConstant('1', 1))),
                      AstConstant('1', 1))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant('val_0'))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_0", 0, candidate.size)
        return True


class PredOdd2(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_mul,
                              AstLeaf('x_0'),
                              AstNode(m_add,
                                      AstLeaf('x_0'),
                                      AstConstant('1', 1))),
                      AstConstant('1', 1))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant('val_0'))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_0", 0, candidate.size)
        return True


# Pred0Rule1: (x_0 & ~x_0) ==> 0
class Pred0Rule1(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstLeaf("x_0"),
                      AstNode(m_bnot,
                              AstLeaf("x_0")))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_0"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_0", 0, candidate.size)
        return True


# Pred0Rule2: (xdu(x_0 & 1) == 2) ==> 0
class Pred0Rule2(PatternMatchingRule):
    PATTERN = AstNode(m_setz,
                      AstNode(m_xdu,
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstConstant("c_1", 1))),
                      AstConstant("c_2", 2))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_0"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_0", 0, candidate.size)
        return True


class Pred0Rule3(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstLeaf("x_0"),
                      AstNode(m_bnot,
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf("val_0"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_0", 0, candidate.size)
        return True


class Pred0Rule4(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_bnot,
                              AstNode(m_or,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf("val_0"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_0", 0, candidate.size)
        return True


class Pred0Rule5(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_xor,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf("val_0"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_0", 0, candidate.size)
        return True


class PredFFRule1(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstLeaf("x_0"),
                      AstNode(m_bnot,
                              AstLeaf("x_0")))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_ff"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_ff", AND_TABLE[candidate.size], candidate.size)
        return True


# Pred1Rule2: (x_0 ^ x_1) | (~x_0 | x_1) ==> 0xff
class PredFFRule2(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_or,
                              AstLeaf("bnot_x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_ff"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        candidate.add_constant_leaf("val_ff", AND_TABLE[candidate.size], candidate.size)
        return True


class PredFFRule3(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstLeaf("x_0"),
                      AstNode(m_bnot,
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))))

    REPLACEMENT_PATTERN = AstNode(m_mov, AstLeaf("val_ff"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_ff", AND_TABLE[candidate.size], candidate.size)
        return True


class PredFFRule4(PatternMatchingRule):
    DESCRIPTION = "(x_0 | x_1) | (~(x_0 & x_1))  ==>  0xff"
    PATTERN = AstNode(m_or,
                      AstNode(m_or,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_bnot,
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_ff"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_ff", AND_TABLE[candidate.size], candidate.size)
        return True


class PredOr2_Rule_1(PatternMatchingRule):
    PATTERN = AstNode(m_and,
                      AstNode(m_bnot,
                              AstNode(m_mul,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_0'))),
                      AstConstant('3', 3))
    REPLACEMENT_PATTERN = AstNode(m_or,
                                  AstNode(m_and,
                                          AstNode(m_bnot, AstLeaf('x_0')),
                                          AstConstant('val_1')),
                                  AstConstant('val_2'))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_1", 1, candidate["x_0"].mop.size)
        candidate.add_constant_leaf("val_2", 2, candidate["x_0"].mop.size)
        return True


class PredOr1_Rule_1(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstLeaf('x_0'),
                      AstNode(m_add,
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstConstant('1', 1)),
                              AstConstant('1', 1)))
    REPLACEMENT_PATTERN = AstNode(m_or,
                                  AstNode(m_xor,
                                          AstLeaf('x_0'),
                                          AstNode(m_mul,
                                                  AstConstant('val_2'),
                                                  AstNode(m_and,
                                                          AstLeaf('x_0'),
                                                          AstConstant('val_1')))),
                                  AstConstant('val_1'))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_1", 1, candidate["x_0"].mop.size)
        candidate.add_constant_leaf("val_2", 2, candidate["x_0"].mop.size)
        return True

```

`d810/optimizers/instructions/pattern_matching/rewrite_sub.py`:

```py
from ida_hexrays import *

from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_helpers import equal_bnot_mop, SUB_TABLE


class Sub_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstLeaf("x_0"),
                      AstNode(m_add,
                              AstNode(m_bnot,
                                      AstLeaf("x_1")),
                              AstConstant("1", 1)))
    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf("x_0"), AstLeaf("x_1"))


class Sub_HackersDelightRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_and,
                                      AstNode(m_bnot,
                                              AstLeaf("x_0")),
                                      AstLeaf("x_1"))))
    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf("x_0"), AstLeaf("x_1"))


class Sub_HackersDelightRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("bnot_x_1")),
                      AstNode(m_and,
                              AstLeaf("bnot_x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Sub_HackersDelightRule_4(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstLeaf("bnot_x_1"))),
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Sub1_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_sub,
                              AstNode(m_neg,
                                      AstLeaf('x_0')),
                              AstConstant('1', 1)),
                      AstNode(m_mul,
                              AstConstant('c_minus_2'),
                              AstLeaf('x_0')))
    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf("x_0"), AstConstant("val_1"))

    def check_candidate(self, candidate):
        if candidate["c_minus_2"].value != SUB_TABLE[candidate["c_minus_2"].size] - 2:
            return False
        candidate.add_constant_leaf("val_1", 1, candidate["x_0"].size)
        return True


class Sub1_FactorRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstLeaf("x_0")),
                      AstNode(m_bnot,
                              AstLeaf("x_0")))

    REPLACEMENT_PATTERN = AstNode(m_sub, AstLeaf("x_0"), AstConstant("1", 1))


class Sub1Add_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))),
                      AstNode(m_xor,
                              AstLeaf("x_0"),
                              AstLeaf("bnot_x_1")))
    REPLACEMENT_PATTERN = AstNode(m_sub,
                                  AstNode(m_add,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")),
                                  AstConstant("val_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        candidate.add_constant_leaf("val_1", 1, candidate["x_1"].size)
        return True


class Sub1And_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstLeaf("bnot_x_1")),
                      AstLeaf("x_1"))

    REPLACEMENT_PATTERN = AstNode(m_sub,
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")),
                                  AstConstant("val_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        candidate.add_constant_leaf("val_1", 1, candidate["x_0"].size)
        return True


class Sub1Or_MbaRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_add,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_bnot,
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))))
    REPLACEMENT_PATTERN = AstNode(m_sub,
                                  AstNode(m_or,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")),
                                  AstConstant("val_1"))


    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


class Sub1And1_MbaRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_or,
                              AstNode(m_bnot,
                                      AstLeaf('x_0')),
                              AstConstant("1", 1)),
                      AstLeaf('x_0'))
    REPLACEMENT_PATTERN = AstNode(m_sub,
                                  AstNode(m_and,
                                          AstLeaf('x_0'),
                                          AstConstant("val_1_1")),
                                  AstConstant("val_1_2"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_1_1", 1, candidate["x_0"].size)
        candidate.add_constant_leaf("val_1_2", 1, candidate["x_0"].size)
        return True

```

`d810/optimizers/instructions/pattern_matching/rewrite_xor.py`:

```py
from ida_hexrays import *

from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_helpers import equal_bnot_mop, equal_bnot_cst, SUB_TABLE


class Xor_HackersDelightRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))


class Xor_HackersDelightRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))),
                      AstNode(m_add,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))


class Xor_HackersDelightRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_add,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_and,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))))

    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))


class Xor_HackersDelightRule_4(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_sub,
                              AstNode(m_sub,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1')),
                              AstNode(m_mul,
                                      AstConstant('2', 2),
                                      AstNode(m_or,
                                              AstLeaf('x_0'),
                                              AstNode(m_bnot, AstLeaf('x_1'))))),
                      AstConstant('2', 2))

    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))


class Xor_HackersDelightRule_5(PatternMatchingRule):
    FUZZ_PATTERN = False
    PATTERN = AstNode(m_sub,
                      AstLeaf("x_0"),
                      AstNode(m_sub,
                              AstNode(m_mul,
                                      AstConstant('2', 2),
                                      AstNode(m_and,
                                              AstLeaf("x_0"),
                                              AstLeaf("x_1"))),
                              AstLeaf("x_1")))
    PATTERNS = [
        AstNode(m_sub, AstLeaf("x_0"), AstNode(m_sub, AstNode(m_mul, AstConstant('2', 2), AstNode(m_and, AstLeaf("x_1"), AstLeaf("x_0"))), AstLeaf("x_1")))
    ]

    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))


class Xor_MbaRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstLeaf('x_0'),
                      AstNode(m_sub,
                              AstNode(m_mul,
                                      AstConstant('2', 2),
                                      AstNode(m_and,
                                              AstLeaf('x_1'),
                                              AstNode(m_bnot,
                                                      AstNode(m_xor,
                                                              AstLeaf('x_0'),
                                                              AstLeaf('x_1'))))),
                              AstLeaf('x_1')))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))


class Xor_MbaRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstLeaf('x_0'),
                      AstNode(m_sub,
                              AstNode(m_mul,
                                      AstConstant('2', 2),
                                      AstNode(m_and,
                                              AstLeaf('x_0'),
                                              AstLeaf('x_1'))),
                              AstLeaf('x_1')))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))


class Xor_MbaRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstLeaf('x_0'),
                      AstNode(m_mul,
                              AstConstant('2', 2),
                              AstNode(m_and,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_sub,
                                  AstNode(m_xor,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")),
                                  AstLeaf("x_1"))


class Xor_FactorRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("bnot_x_1")),
                      AstNode(m_and,
                              AstLeaf("bnot_x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Xor_FactorRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_and,
                              AstLeaf('bnot_x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstLeaf('bnot_x_1')))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Xor_FactorRule_3(PatternMatchingRule):
    PATTERN = AstNode(m_xor,
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_or,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))


class Xor_SpecialConstantRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_sub,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_and,
                                      AstNode(m_bnot,
                                              AstLeaf("x_0")),
                                      AstLeaf("x_1"))))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))


class Xor_SpecialConstantRule_2(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstLeaf('x_0'),
                      AstNode(m_add,
                              AstNode(m_mul,
                                      AstConstant('0xfe'),
                                      AstNode(m_and,
                                              AstLeaf('x_0'),
                                              AstLeaf('x_1'))),
                              AstLeaf('x_1')))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf("x_0"), AstLeaf("x_1"))

    def check_candidate(self, candidate):
        return candidate["0xfe"].value == SUB_TABLE[candidate["0xfe"].size] - 2


class Xor1_MbaRule_1(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_bnot,
                              AstLeaf('x_0')),
                      AstNode(m_or,
                              AstNode(m_mul,
                                      AstConstant('2', 2),
                                      AstLeaf('x_0')),
                              AstConstant('2', 2)))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf('x_0'), AstConstant("val_1"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


class Xor_Rule_1(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_bnot,
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstLeaf("x_1"))))

    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstLeaf('x_0'),
                                  AstNode(m_bnot, AstLeaf("x_1")))


# Found sometimes with OLLVM
class Xor_Rule_2(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstNode(m_xor,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_2')),
                              AstNode(m_xor,
                                      AstLeaf('x_1'),
                                      AstLeaf('bnot_x2'))),
                      AstNode(m_and,
                              AstNode(m_xor,
                                      AstLeaf('x_0'),
                                      AstLeaf('bnot_x2')),
                              AstNode(m_xor,
                                      AstLeaf('x_1'),
                                      AstLeaf('x_2'))))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstLeaf('x_0'), AstLeaf('x_1'))


# Found sometimes with OLLVM
class Xor_Rule_3(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstNode(m_xor,
                                      AstLeaf('x_0'),
                                      AstLeaf('x_2')),
                              AstNode(m_xor,
                                      AstLeaf('x_1'),
                                      AstLeaf('x_2'))),
                      AstNode(m_and,
                              AstNode(m_xor,
                                      AstLeaf('x_0'),
                                      AstLeaf('bnot_x2')),
                              AstNode(m_xor,
                                      AstLeaf('x_1'),
                                      AstLeaf('bnot_x2'))))
    REPLACEMENT_PATTERN = AstNode(m_xor, AstNode(m_bnot, AstLeaf('x_0')), AstLeaf('x_1'))


class Xor_Rule_4(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("bnot_x_1")),
                      AstNode(m_and,
                              AstLeaf("bnot_x_0"),
                              AstLeaf("x_1")))

    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstLeaf('x_0'),
                                  AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class Xor_Rule_4_WithXdu(PatternMatchingRule):
    PATTERN = AstNode(m_or,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstConstant("bnot_c_1")),
                      AstNode(m_and,
                              AstNode(m_bnot, AstLeaf("x_0")),
                              AstConstant("c_1")))

    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstLeaf("x_0"),
                                  AstLeaf("c_1"))

    def check_candidate(self, candidate):
        if candidate["x_0"].mop.t != mop_d:
            return False
        if candidate["x_0"].mop.d.opcode != m_xdu:
            return False
        return equal_bnot_cst(candidate["c_1"].mop, candidate["bnot_c_1"].mop, mop_size=candidate["x_0"].mop.d.l.size)


class XorAlmost_Rule_1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_add,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstNode(m_or,
                                      AstLeaf("x_0"),
                                      AstNode(m_sub,
                                              AstLeaf("x_1"),
                                              AstConstant("1", 1)))))

    REPLACEMENT_PATTERN = AstNode(m_add,
                                  AstNode(m_xor,
                                          AstLeaf("x_0"),
                                          AstNode(m_neg, AstLeaf("x_1"))),
                                  AstLeaf("val_2"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_2", 2, candidate.size)
        return True


class Xor_NestedStuff(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_add,
                              AstNode(m_add,
                                      AstLeaf('x_9'),
                                      AstLeaf('x_10')),
                              AstLeaf("x_11")),
                      AstNode(m_add,
                              AstLeaf("x_14"),
                              AstNode(m_mul,
                                      AstConstant('2', 2),
                                      AstNode(m_and,
                                              AstLeaf('x_10'),
                                              AstNode(m_sub,
                                                      AstNode(m_add,
                                                              AstLeaf('x_9'),
                                                              AstLeaf("x_11")),
                                                      AstLeaf("x_14"))))))


    REPLACEMENT_PATTERN = AstNode(m_xor,
                                  AstLeaf("x_10"),
                                  AstNode(m_sub,
                                          AstNode(m_add,
                                                  AstLeaf('x_9'),
                                                  AstLeaf("x_11")),
                                          AstLeaf("x_14")))
    FUZZ_PATTERN = False


```

`d810/optimizers/instructions/pattern_matching/weird.py`:

```py
from ida_hexrays import *
from d810.optimizers.instructions.pattern_matching.handler import PatternMatchingRule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.hexrays_helpers import equal_bnot_mop


class WeirdRule1(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstLeaf("x_0"),
                      AstNode(m_or,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_add,
                                  AstNode(m_or,
                                          AstLeaf("x_0"),
                                          AstNode(m_bnot, AstLeaf("x_1"))),
                                  AstConstant("val_1"))

    def check_candidate(self, candidate):
        candidate.add_constant_leaf("val_1", 1, candidate.size)
        return True


class WeirdRule2(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstLeaf("x_0")),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstNode(m_bnot, AstLeaf("x_1"))))
    REPLACEMENT_PATTERN = AstNode(m_add,
                                  AstLeaf("x_0"),
                                  AstNode(m_and,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")))


class WeirdRule3(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstNode(m_bnot, AstLeaf("x_1"))),
                      AstNode(m_mul,
                              AstConstant("2", 2),
                              AstLeaf("x_0")))
    REPLACEMENT_PATTERN = AstNode(m_neg,
                                  AstNode(m_add,
                                          AstLeaf("x_0"),
                                          AstNode(m_and,
                                                  AstLeaf("x_0"),
                                                  AstLeaf("x_1"))))


class WeirdRule4(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("bnot_x_1")),
                      AstNode(m_and,
                              AstLeaf("x_0"),
                              AstLeaf("x_1")))
    REPLACEMENT_PATTERN = AstNode(m_sub,
                                  AstNode(m_xor,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")),
                                  AstLeaf("x_1"))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class WeirdRule5(PatternMatchingRule):
    PATTERN = AstNode(m_sub,
                      AstNode(m_add,
                              AstNode(m_or,
                                      AstLeaf("bnot_x_0"),
                                      AstNode(m_and,
                                              AstLeaf("bnot_x_1"),
                                              AstLeaf("x_2"))),
                              AstNode(m_add,
                                      AstLeaf("x_0"),
                                      AstNode(m_and,
                                              AstLeaf("x_1"),
                                              AstLeaf("x_2")))),
                      AstLeaf("x_2"))
    REPLACEMENT_PATTERN = AstNode(m_or,
                                  AstLeaf("x_0"),
                                  AstNode(m_or,
                                          AstLeaf("x_1"),
                                          AstNode(m_bnot,
                                                  AstLeaf("x_2"))))

    def check_candidate(self, candidate):
        if not equal_bnot_mop(candidate["x_0"].mop, candidate["bnot_x_0"].mop):
            return False
        if not equal_bnot_mop(candidate["x_1"].mop, candidate["bnot_x_1"].mop):
            return False
        return True


class WeirdRule6(PatternMatchingRule):
    PATTERN = AstNode(m_add,
                      AstNode(m_or,
                              AstLeaf('x_0'),
                              AstLeaf('x_1')),
                      AstNode(m_and,
                              AstLeaf('x_0'),
                              AstNode(m_bnot,
                                      AstLeaf('x_1'))))
    REPLACEMENT_PATTERN = AstNode(m_add,
                                  AstNode(m_xor,
                                          AstLeaf("x_0"),
                                          AstLeaf("x_1")),
                                  AstLeaf('x_0'))

```

`d810/optimizers/instructions/z3/__init__.py`:

```py
from d810.utils import get_all_subclasses
from d810.optimizers.instructions.z3.handler import Z3Rule, Z3Optimizer
from d810.optimizers.instructions.z3.cst import *
from d810.optimizers.instructions.z3.predicates import *


Z3_RULES = [x() for x in get_all_subclasses(Z3Rule)]

```

`d810/optimizers/instructions/z3/cst.py`:

```py
from ida_hexrays import *
from d810.optimizers.instructions.z3.handler import Z3Rule
from d810.ast import AstConstant, AstNode
from d810.ast import minsn_to_ast
from d810.errors import AstEvaluationException
from d810.z3_utils import z3_check_mop_equality


class Z3ConstantOptimization(Z3Rule):
    DESCRIPTION = "Detect and replace obfuscated constants"
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("c_res"))

    def __init__(self):
        super().__init__()
        self.min_nb_opcode = 3
        self.min_nb_constant = 3

    def configure(self, kwargs):
        super().configure(kwargs)
        if "min_nb_opcode" in kwargs.keys():
            self.min_nb_opcode = kwargs["min_nb_opcode"]
        if "min_nb_constant" in kwargs.keys():
            self.min_nb_constant = kwargs["min_nb_constant"]

    def check_and_replace(self, blk, instruction):
        tmp = minsn_to_ast(instruction)
        if tmp is None:
            return None
        leaf_info_list, cst_leaf_values, opcodes = tmp.get_information()
        if len(leaf_info_list) == 1 and \
                len(opcodes) >= self.min_nb_opcode and \
                (len(cst_leaf_values) >= self.min_nb_constant):
            try:
                val_0 = tmp.evaluate_with_leaf_info(leaf_info_list, [0])
                val_1 = tmp.evaluate_with_leaf_info(leaf_info_list, [0xffffffff])

                if val_0 == val_1:
                    c_res_mop = mop_t()
                    c_res_mop.make_number(val_0, tmp.mop.size)
                    is_ok = z3_check_mop_equality(tmp.mop, c_res_mop)
                    if is_ok:
                        tmp.add_leaf("c_res", c_res_mop)
                        new_instruction = self.get_replacement(tmp)
                        return new_instruction
                    return None
            except ZeroDivisionError:
                pass
            except AstEvaluationException as e:
                print("Error while evaluating {0}: {1}".format(tmp, e))
                pass
        return None

```

`d810/optimizers/instructions/z3/handler.py`:

```py
from d810.optimizers.instructions.handler import GenericPatternRule, InstructionOptimizer


class Z3Rule(GenericPatternRule):
    pass


class Z3Optimizer(InstructionOptimizer):
    RULE_CLASSES = [Z3Rule]

```

`d810/optimizers/instructions/z3/predicates.py`:

```py
from ida_hexrays import *

from d810.optimizers.instructions.z3.handler import Z3Rule
from d810.ast import AstLeaf, AstConstant, AstNode
from d810.z3_utils import z3_check_mop_equality, z3_check_mop_inequality


class Z3setzRuleGeneric(Z3Rule):
    DESCRIPTION = "Check with Z3 if a m_setz check is always True or False"
    PATTERN = AstNode(m_setz,
                      AstLeaf("x_0"),
                      AstLeaf("x_1"))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_res"))

    def check_candidate(self, candidate):
        if z3_check_mop_equality(candidate["x_0"].mop, candidate["x_1"].mop):
            candidate.add_constant_leaf("val_res", 1, candidate.size)
            return True
        if z3_check_mop_inequality(candidate["x_0"].mop, candidate["x_1"].mop):
            candidate.add_constant_leaf("val_res", 0, candidate.size)
            return True
        return False


class Z3setnzRuleGeneric(Z3Rule):
    DESCRIPTION = "Check with Z3 if a m_setnz check is always True or False"
    PATTERN = AstNode(m_setnz,
                      AstLeaf("x_0"),
                      AstLeaf("x_1"))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_res"))

    def check_candidate(self, candidate):
        if z3_check_mop_equality(candidate["x_0"].mop, candidate["x_1"].mop):
            candidate.add_constant_leaf("val_res", 0, candidate.size)
            return True
        if z3_check_mop_inequality(candidate["x_0"].mop, candidate["x_1"].mop):
            candidate.add_constant_leaf("val_res", 1, candidate.size)
            return True
        return False


class Z3lnotRuleGeneric(Z3Rule):
    DESCRIPTION = "Check with Z3 if a m_lnot check is always True or False"
    PATTERN = AstNode(m_lnot,
                      AstLeaf("x_0"))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_res"))

    def check_candidate(self, candidate):
        val_0_mop = mop_t()
        val_0_mop.make_number(0, candidate["x_0"].size)
        if z3_check_mop_equality(candidate["x_0"].mop, val_0_mop):
            candidate.add_constant_leaf("val_res", 1, candidate.size)
            return True
        if z3_check_mop_inequality(candidate["x_0"].mop, val_0_mop):
            candidate.add_constant_leaf("val_res", 0, candidate.size)
            return True
        return False


class Z3SmodRuleGeneric(Z3Rule):
    DESCRIPTION = "Check with Z3 if a m_setz check is always True or False"
    PATTERN = AstNode(m_smod,
                      AstLeaf("x_0"),
                      AstConstant("2", 2))
    REPLACEMENT_PATTERN = AstNode(m_mov, AstConstant("val_res"))

    def check_candidate(self, candidate):
        cst_0_mop = mop_t()
        cst_0_mop.make_number(0, candidate.size)
        if z3_check_mop_equality(candidate.mop, cst_0_mop):
            candidate.add_leaf("val_res", cst_0_mop)
            return True
        cst_1_mop = mop_t()
        cst_1_mop.make_number(1, candidate.size)
        if z3_check_mop_equality(candidate.mop, cst_1_mop):
            candidate.add_leaf("val_res", cst_1_mop)
            return True
        return False

```

`d810/tracker.py`:

```py
from __future__ import annotations
import logging
from typing import List, Union, Tuple, Dict
from ida_hexrays import *

from d810.emulator import MicroCodeEnvironment, MicroCodeInterpreter
from d810.cfg_utils import change_1way_block_successor, change_2way_block_conditional_successor, duplicate_block
from d810.hexrays_hooks import InstructionDefUseCollector
from d810.hexrays_helpers import equal_mops_ignore_size, get_mop_index, get_blk_index
from d810.hexrays_formatters import format_minsn_t, format_mop_t

# This module can be use to find the instruction that define the value of a mop. Basically, you:
# 1 - Create a MopTracker object with the list of mops to search
# 2 - Call search_backward while specifying the instruction where the search should start
# It will return a list if MopHistory, each MopHistory object of this list:
# * Represents one possible path to compute the searched mops
# * Stores all instructions used to compute the searched mops
#
# You can get the value of one of the searched mop by calling the get_mop_constant_value API of a MopHistory object.
# Behind the scene, it will emulate all microcode instructions on the MopHistory path.
#
# Finally the duplicate_histories API can be used to duplicate microcode blocks so that for each microcode block,
# the searched mops have only one possible values. For instance, this is a preliminary step used in code unflattening.


logger = logging.getLogger('D810.tracker')


class BlockInfo(object):
    def __init__(self, blk: mblock_t, ins=None):
        self.blk = blk
        self.ins_list = []
        if ins is not None:
            self.ins_list.append(ins)

    def get_copy(self) -> BlockInfo:
        new_block_info = BlockInfo(self.blk)
        new_block_info.ins_list = [x for x in self.ins_list]
        return new_block_info


class MopHistory(object):
    def __init__(self, searched_mop_list: List[mop_t]):
        self.searched_mop_list = [mop_t(x) for x in searched_mop_list]
        self.history = []
        self.unresolved_mop_list = []

        self._mc_interpreter = MicroCodeInterpreter()
        self._mc_initial_environment = MicroCodeEnvironment()
        self._mc_current_environment = self._mc_initial_environment.get_copy()
        self._is_dirty = True

    def add_mop_initial_value(self, mop: mop_t, value: int):
        self._is_dirty = True
        self._mc_initial_environment.define(mop, value)

    def get_copy(self) -> MopHistory:
        new_mop_history = MopHistory(self.searched_mop_list)
        new_mop_history.history = [x.get_copy() for x in self.history]
        new_mop_history.unresolved_mop_list = [x for x in self.unresolved_mop_list]
        new_mop_history._mc_initial_environment = self._mc_initial_environment.get_copy()
        new_mop_history._mc_current_environment = new_mop_history._mc_initial_environment.get_copy()
        return new_mop_history

    def is_resolved(self) -> bool:
        if len(self.unresolved_mop_list) == 0:
            return True
        for x in self.unresolved_mop_list:
            x_value = self._mc_initial_environment.lookup(x, raise_exception=False)
            if x_value is None:
                return False
        return True

    @property
    def block_path(self) -> List[mblock_t]:
        return [blk_info.blk for blk_info in self.history]

    @property
    def block_serial_path(self) -> List[int]:
        return [blk.serial for blk in self.block_path]

    def replace_block_in_path(self, old_blk: mblock_t, new_blk: mblock_t) -> bool:
        blk_index = get_blk_index(old_blk, self.block_path)
        if blk_index > 0:
            self.history[blk_index].blk = new_blk
            self._is_dirty = True
            return True
        else:
            logger.error("replace_block_in_path: should not happen")
            return False

    def insert_block_in_path(self, blk: mblock_t, where_index: int):
        self.history = self.history[:where_index] + [BlockInfo(blk)] + self.history[where_index:]
        self._is_dirty = True

    def insert_ins_in_block(self, blk: mblock_t, ins: minsn_t, before=True):
        blk_index = get_blk_index(blk, self.block_path)
        if blk_index < 0:
            return False
        blk_info = self.history[blk_index]
        if before:
            blk_info.ins_list = [ins] + blk_info.ins_list
        else:
            blk_info.ins_list = blk_info.ins_list + [ins]
        self._is_dirty = True

    def _execute_microcode(self) -> bool:
        if not self._is_dirty:
            return True
        formatted_mop_searched_list = "['" + "', '".join([format_mop_t(x) for x in self.searched_mop_list]) + "']"
        logger.debug("Computing: {0} for path {1}".format(formatted_mop_searched_list, self.block_serial_path))
        self._mc_current_environment = self._mc_initial_environment.get_copy()
        for blk_info in self.history:
            for blk_ins in blk_info.ins_list:
                logger.debug("Executing: {0}.{1}".format(blk_info.blk.serial, format_minsn_t(blk_ins)))
                if not self._mc_interpreter.eval_instruction(blk_info.blk, blk_ins, self._mc_current_environment):
                    self._is_dirty = False
                    return False
        self._is_dirty = False
        return True

    def get_mop_constant_value(self, searched_mop: mop_t) -> Union[None, int]:
        if not self._execute_microcode():
            return None
        return self._mc_interpreter.eval_mop(searched_mop, self._mc_current_environment)

    def print_info(self, detailed_info=False):
        formatted_mop_searched_list = [format_mop_t(x) for x in self.searched_mop_list]
        tmp = ", ".join(["{0}={1}".format(formatted_mop, self.get_mop_constant_value(mop))
                         for formatted_mop, mop in zip(formatted_mop_searched_list, self.searched_mop_list)])
        logger.info("MopHistory: resolved={0}, path={1}, mops={2}"
                    .format(self.is_resolved(), self.block_serial_path, tmp))
        if detailed_info:
            str_mop_list = "['" + "', '".join(formatted_mop_searched_list) + "']"
            if len(self.block_path) == 0:
                logger.info("MopHistory for {0} => nothing".format(str_mop_list))
                return

            end_blk = self.block_path[-1]
            end_ins = end_blk.tail
            if self.history[-1].ins_list:
                end_ins = self.history[-1].ins_list[-1]

            if end_ins:
                logger.info("MopHistory for {0} {1}.{2}".format(str_mop_list, end_blk.serial, format_minsn_t(end_ins)))
            else:
                logger.info("MopHistory for '{0}' {1}.tail".format(str_mop_list, end_blk.serial))
            logger.info("  path {0}".format(self.block_serial_path))
            for blk_info in self.history:
                for blk_ins in blk_info.ins_list:
                    logger.info("   {0}.{1}".format(blk_info.blk.serial, format_minsn_t(blk_ins)))


def get_standard_and_memory_mop_lists(mop_in: mop_t) -> Tuple[List[mop_t], List[mop_t]]:
    if mop_in.t in [mop_r, mop_S]:
        return [mop_in], []
    elif mop_in.t == mop_v:
        return [], [mop_in]
    elif mop_in.t == mop_d:
        ins_mop_info = InstructionDefUseCollector()
        mop_in.d.for_all_ops(ins_mop_info)
        return remove_segment_registers(ins_mop_info.unresolved_ins_mops), ins_mop_info.memory_unresolved_ins_mops
    else:
        logger.warning("Calling get_standard_and_memory_mop_lists with unsupported mop type {0}: '{1}'"
                       .format(mop_in.t, format_mop_t(mop_in)))
        return [], []


# A MopTracker will create new MopTracker to recursively track variable when multiple paths are possible,
# The cur_mop_tracker_nb_path global variable is used to limit the number of MopTracker created
cur_mop_tracker_nb_path = 0


class MopTracker(object):
    def __init__(self, searched_mop_list: List[mop_t], max_nb_block=-1, max_path=-1):
        self.mba = None
        self._unresolved_mops = []
        self._memory_unresolved_mops = []
        for searched_mop in searched_mop_list:
            a, b = get_standard_and_memory_mop_lists(searched_mop)
            self._unresolved_mops += a
            self._memory_unresolved_mops += b
        self.history = MopHistory(searched_mop_list)
        self.max_nb_block = max_nb_block
        self.max_path = max_path
        self.avoid_list = []
        self.call_detected = False
        self.constant_mops = []

    @staticmethod
    def reset():
        global cur_mop_tracker_nb_path
        cur_mop_tracker_nb_path = 0

    def add_mop_definition(self, mop: mop_t, cst_value: int):
        self.constant_mops.append([mop, cst_value])
        self.history.add_mop_initial_value(mop, cst_value)

    def get_copy(self) -> MopTracker:
        global cur_mop_tracker_nb_path
        new_mop_tracker = MopTracker(self._unresolved_mops, self.max_nb_block, self.max_path)
        new_mop_tracker._memory_unresolved_mops = [x for x in self._memory_unresolved_mops]
        new_mop_tracker.constant_mops = [[x[0], x[1]] for x in self.constant_mops]
        new_mop_tracker.history = self.history.get_copy()
        cur_mop_tracker_nb_path += 1
        return new_mop_tracker

    def search_backward(self, blk: mblock_t, ins: minsn_t, avoid_list=None, must_use_pred=None,
                        stop_at_first_duplication=False) -> List[MopHistory]:
        logger.debug("Searching backward (reg): {0}".format([format_mop_t(x) for x in self._unresolved_mops]))
        logger.debug("Searching backward (mem): {0}".format([format_mop_t(x) for x in self._memory_unresolved_mops]))
        logger.debug("Searching backward (cst): {0}"
                     .format(["{0}: {1:x}".format(format_mop_t(x[0]), x[1]) for x in self.constant_mops]))
        self.mba = blk.mba
        self.avoid_list = avoid_list if avoid_list else []
        blk_with_multiple_pred = self.search_until_multiple_predecessor(blk, ins)
        if self.is_resolved():
            logger.debug("MopTracker is resolved:  {0}".format(self.history.block_serial_path))
            self.history.unresolved_mop_list = [x for x in self._unresolved_mops]
            return [self.history]
        elif blk_with_multiple_pred is None:
            logger.debug("MopTracker unresolved: (blk_with_multiple_pred): {0}".format(self.history.block_serial_path))
            self.history.unresolved_mop_list = [x for x in self._unresolved_mops]
            return [self.history]
        elif self.max_nb_block != -1 and len(self.history.block_serial_path) > self.max_nb_block:
            logger.debug("MopTracker unresolved: (max_nb_block): {0}".format(self.history.block_serial_path))
            self.history.unresolved_mop_list = [x for x in self._unresolved_mops]
            return [self.history]
        elif self.max_path != -1 and cur_mop_tracker_nb_path > self.max_path:
            logger.debug("MopTracker unresolved: (max_path: {0}".format(cur_mop_tracker_nb_path))
            self.history.unresolved_mop_list = [x for x in self._unresolved_mops]
            return [self.history]
        elif self.call_detected:
            logger.debug("MopTracker unresolved: (call): {0}".format(self.history.block_serial_path))
            self.history.unresolved_mop_list = [x for x in self._unresolved_mops]
            return [self.history]

        if stop_at_first_duplication:
            self.history.unresolved_mop_list = [x for x in self._unresolved_mops]
            return [self.history]
        logger.debug("MopTracker creating child because multiple pred: {0}".format(self.history.block_serial_path))
        possible_histories = []
        if must_use_pred is not None and must_use_pred.serial in blk_with_multiple_pred.predset:
            new_tracker = self.get_copy()
            possible_histories += new_tracker.search_backward(must_use_pred, None, self.avoid_list, must_use_pred)
        else:
            for blk_pred_serial in blk_with_multiple_pred.predset:
                new_tracker = self.get_copy()
                possible_histories += new_tracker.search_backward(self.mba.get_mblock(blk_pred_serial), None,
                                                                  self.avoid_list, must_use_pred)
        return possible_histories

    def search_until_multiple_predecessor(self, blk: mblock_t, ins: Union[None, minsn_t] = None) -> Union[None, mblock_t]:
        # By default, we start searching from block tail
        cur_ins = ins if ins else blk.tail
        cur_blk = blk

        while not self.is_resolved():
            # Explore one block
            if cur_blk.serial in self.history.block_serial_path:
                self.history.insert_block_in_path(cur_blk, 0)
                return None
            if cur_blk.serial in self.avoid_list:
                self.history.insert_block_in_path(cur_blk, 0)
                return None
            self.history.insert_block_in_path(cur_blk, 0)
            cur_ins = self.blk_find_def_backward(cur_blk, cur_ins)
            while cur_ins:
                cur_ins = self.blk_find_def_backward(cur_blk, cur_ins)
            if cur_blk.npred() > 1:
                return cur_blk
            elif cur_blk.npred() == 0:
                return None
            else:
                cur_blk = self.mba.get_mblock(cur_blk.predset[0])
                cur_ins = cur_blk.tail

        # We want to handle cases where the self.is_resolved() is True without doing anything
        if len(self.history.block_serial_path) == 0:
            self.history.insert_block_in_path(cur_blk, 0)
        return None

    def is_resolved(self) -> bool:
        if (len(self._unresolved_mops) == 0) and (len(self._memory_unresolved_mops) == 0):
            return True

        for x in self._unresolved_mops:
            x_index = get_mop_index(x, [y[0] for y in self.constant_mops])
            if x_index == -1:
                return False
        return True

    def _build_ml_list(self, blk: mblock_t) -> Union[None, mlist_t]:
        ml = mlist_t()
        for unresolved_mop in self._unresolved_mops:
            if unresolved_mop.t not in [mop_r, mop_S]:
                logger.warning("_build_ml_list: Not supported mop type '{0}'".format(unresolved_mop.t))
                return None
            blk.append_use_list(ml, unresolved_mop, MUST_ACCESS)
        return ml

    def blk_find_def_backward(self, blk: mblock_t, ins_start: minsn_t) -> Union[None, minsn_t]:
        if self.is_resolved():
            return None
        ml = self._build_ml_list(blk)
        if not ml:
            logger.warning("blk_find_def_backward: _build_ml_list failed")
            return None
        ins_def = self._blk_find_ins_def_backward(blk, ins_start, ml)
        if ins_def:
            is_ok = self.update_history(blk, ins_def)
            if not is_ok:
                return None
            ins_def = ins_def.prev
        return ins_def

    def update_history(self, blk: mblock_t, ins_def: minsn_t) -> bool:
        logger.debug("Updating history with {0}.{1}".format(blk.serial, format_minsn_t(ins_def)))
        self.history.insert_ins_in_block(blk, ins_def, before=True)
        if ins_def.opcode == m_call:
            self.call_detected = True
            return False
        ins_mop_info = InstructionDefUseCollector()
        ins_def.for_all_ops(ins_mop_info)

        for target_mop in ins_mop_info.target_mops:
            resolved_mop_index = get_mop_index(target_mop, self._unresolved_mops)
            if resolved_mop_index != -1:
                logger.debug("Removing {0} from unresolved mop".format(format_mop_t(target_mop)))
                self._unresolved_mops.pop(resolved_mop_index)
        cleaned_unresolved_ins_mops = remove_segment_registers(ins_mop_info.unresolved_ins_mops)
        for ins_def_mop in cleaned_unresolved_ins_mops:
            ins_def_mop_index = get_mop_index(ins_def_mop, self._unresolved_mops)
            if ins_def_mop_index == -1:
                logger.debug("Adding {0} in unresolved mop".format(format_mop_t(ins_def_mop)))
                self._unresolved_mops.append(ins_def_mop)

        for target_mop in ins_mop_info.target_mops:
            resolved_mop_index = get_mop_index(target_mop, self._memory_unresolved_mops)
            if resolved_mop_index != -1:
                logger.debug("Removing {0} from memory unresolved mop".format(format_mop_t(target_mop)))
                self._memory_unresolved_mops.pop(resolved_mop_index)
        for ins_def_mem_mop in ins_mop_info.memory_unresolved_ins_mops:
            ins_def_mop_index = get_mop_index(ins_def_mem_mop, self._memory_unresolved_mops)
            if ins_def_mop_index == -1:
                logger.debug("Adding {0} in memory unresolved mop".format(format_mop_t(ins_def_mem_mop)))
                self._memory_unresolved_mops.append(ins_def_mem_mop)
        return True

    def _blk_find_ins_def_backward(self, blk: mblock_t, ins_start: minsn_t, ml: mlist_t) -> Union[None, minsn_t]:
        cur_ins = ins_start
        while cur_ins is not None:
            def_list = blk.build_def_list(cur_ins, MAY_ACCESS | FULL_XDSU)
            if ml.has_common(def_list):
                return cur_ins
            for mem_mop in self._memory_unresolved_mops:
                if equal_mops_ignore_size(cur_ins.d, mem_mop):
                    return cur_ins
            cur_ins = cur_ins.prev
        return None


def get_block_with_multiple_predecessors(var_histories: List[MopHistory]) -> Tuple[Union[None, mblock_t],
                                                                                   Union[None, Dict[int, List[MopHistory]]]]:
    for i, var_history in enumerate(var_histories):
        pred_blk = var_history.block_path[0]
        for block in var_history.block_path[1:]:
            tmp_dict = {pred_blk.serial: [var_history]}
            for j in range(i + 1, len(var_histories)):
                blk_index = get_blk_index(block, var_histories[j].block_path)
                if (blk_index - 1) >= 0:
                    other_pred = var_histories[j].block_path[blk_index - 1]
                    if other_pred.serial not in tmp_dict.keys():
                        tmp_dict[other_pred.serial] = []
                    tmp_dict[other_pred.serial].append(var_histories[j])
            if len(tmp_dict) > 1:
                return block, tmp_dict
            pred_blk = block
    return None, None


def try_to_duplicate_one_block(var_histories: List[MopHistory]) -> Tuple[int, int]:
    nb_duplication = 0
    nb_change = 0
    if (len(var_histories) == 0) or (len(var_histories[0].block_path) == 0):
        return nb_duplication, nb_change
    mba = var_histories[0].block_path[0].mba
    block_to_duplicate, pred_dict = get_block_with_multiple_predecessors(var_histories)
    if block_to_duplicate is None:
        return nb_duplication, nb_change
    logger.debug("Block to duplicate found: {0} with {1} successors"
                 .format(block_to_duplicate.serial, block_to_duplicate.nsucc()))
    i = 0
    for pred_serial, pred_history_group in pred_dict.items():
        # We do not duplicate first group
        if i >= 1:
            logger.debug("  Before {0}: {1}"
                         .format(pred_serial, [var_history.block_serial_path for var_history in pred_history_group]))
            pred_block = mba.get_mblock(pred_serial)
            duplicated_blk_jmp, duplicated_blk_default = duplicate_block(block_to_duplicate)
            nb_duplication += 1 if duplicated_blk_jmp is not None else 0
            nb_duplication += 1 if duplicated_blk_default is not None else 0
            logger.debug("  Making {0} goto {1}".format(pred_block.serial, duplicated_blk_jmp.serial))
            if (pred_block.tail is None) or (not is_mcode_jcond(pred_block.tail.opcode)):
                change_1way_block_successor(pred_block, duplicated_blk_jmp.serial)
                nb_change += 1
            else:
                if block_to_duplicate.serial == pred_block.tail.d.b:
                    change_2way_block_conditional_successor(pred_block, duplicated_blk_jmp.serial)
                    nb_change += 1
                else:
                    logger.warning(" not sure this is suppose to happen")
                    change_1way_block_successor(pred_block.mba.get_mblock(pred_block.serial + 1),
                                                duplicated_blk_jmp.serial)
                    nb_change += 1

            block_to_duplicate_default_successor = mba.get_mblock(block_to_duplicate.serial + 1)
            logger.debug("  Now, we fix var histories...")
            for var_history in pred_history_group:
                var_history.replace_block_in_path(block_to_duplicate, duplicated_blk_jmp)
                if block_to_duplicate.tail is not None and is_mcode_jcond(block_to_duplicate.tail.opcode):
                    index_jump_block = get_blk_index(duplicated_blk_jmp, var_history.block_path)
                    if index_jump_block + 1 < len(var_history.block_path):
                        original_jump_block_successor = var_history.block_path[index_jump_block + 1]
                        if original_jump_block_successor.serial == block_to_duplicate_default_successor.serial:
                            var_history.insert_block_in_path(duplicated_blk_default, index_jump_block + 1)
        i += 1
        logger.debug("  After {0}: {1}"
                     .format(pred_serial, [var_history.block_serial_path for var_history in pred_history_group]))
    for i, var_history in enumerate(var_histories):
        logger.debug(" internal_pass_end.{0}: {1}".format(i, var_history.block_serial_path))
    return nb_duplication, nb_change


def duplicate_histories(var_histories: List[MopHistory], max_nb_pass: int = 10) -> Tuple[int, int]:
    cur_pass = 0
    total_nb_duplication = 0
    total_nb_change = 0
    logger.info("Trying to fix new var_history...")
    for i, var_history in enumerate(var_histories):
        logger.info(" start.{0}: {1}".format(i, var_history.block_serial_path))
    while cur_pass < max_nb_pass:
        logger.debug("Current path {0}".format(cur_pass))
        nb_duplication, nb_change = try_to_duplicate_one_block(var_histories)
        if nb_change == 0 and nb_duplication == 0:
            break
        total_nb_duplication += nb_duplication
        total_nb_change += nb_change
        cur_pass += 1
    for i, var_history in enumerate(var_histories):
        logger.info(" end.{0}: {1}".format(i, var_history.block_serial_path))
    return total_nb_duplication, total_nb_change


def get_segment_register_indexes(mop_list: List[mop_t]) -> List[int]:
    # This is a very dirty and probably buggy
    segment_register_indexes = []
    for i, mop in enumerate(mop_list):
        if mop.t == mop_r:
            formatted_mop = format_mop_t(mop)
            if formatted_mop in ["ds.2", "cs.2", "es.2", "ss.2"]:
                segment_register_indexes.append(i)
    return segment_register_indexes


def remove_segment_registers(mop_list: List[mop_t]) -> List[mop_t]:
    # TODO: instead of doing that, we should add the segment registers to the (global?) emulation environment
    segment_register_indexes = get_segment_register_indexes(mop_list)
    if len(segment_register_indexes) == 0:
        return mop_list
    new_mop_list = []
    for i, mop in enumerate(mop_list):
        if i in segment_register_indexes:
            pass
        else:
            new_mop_list.append(mop)
    return new_mop_list

```

`d810/utils.py`:

```py
import ctypes

from d810.hexrays_helpers import MSB_TABLE

CTYPE_SIGNED_TABLE = {1: ctypes.c_int8, 2: ctypes.c_int16, 4: ctypes.c_int32, 8: ctypes.c_int64}
CTYPE_UNSIGNED_TABLE = {1: ctypes.c_uint8, 2: ctypes.c_uint16, 4: ctypes.c_uint32, 8: ctypes.c_uint64}


def get_all_subclasses(python_class):
    python_class.__subclasses__()

    subclasses = set()
    check_these = [python_class]

    while check_these:
        parent = check_these.pop()
        for child in parent.__subclasses__():
            if child not in subclasses:
                subclasses.add(child)
                check_these.append(child)

    return sorted(subclasses, key=lambda x: x.__name__)


def unsigned_to_signed(unsigned_value, nb_bytes):
    return CTYPE_SIGNED_TABLE[nb_bytes](unsigned_value).value


def signed_to_unsigned(signed_value, nb_bytes):
    return CTYPE_UNSIGNED_TABLE[nb_bytes](signed_value).value


def get_msb(value, nb_bytes):
    return (value & MSB_TABLE[nb_bytes]) >> (nb_bytes * 8 - 1)


def get_add_cf(op1, op2, nb_bytes):
    res = op1 + op2
    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (~(op1 ^ op2)))), nb_bytes)


def get_add_of(op1, op2, nb_bytes):
    res = op1 + op2
    return get_msb(((op1 ^ res) & (~(op1 ^ op2))), nb_bytes)


def get_sub_cf(op1, op2, nb_bytes):
    res = op1 - op2
    return get_msb((((op1 ^ op2) ^ res) ^ ((op1 ^ res) & (op1 ^ op2))), nb_bytes)


def get_sub_of(op1, op2, nb_bytes):
    res = op1 - op2
    return get_msb(((op1 ^ res) & (op1 ^ op2)), nb_bytes)


def get_parity_flag(op1, op2, nb_bytes):
    tmp = CTYPE_UNSIGNED_TABLE[nb_bytes](op1 - op2).value
    return (bin(tmp).count("1") + 1) % 2


def ror(x, n, nb_bits=32):
    mask = (2 ** n) - 1
    mask_bits = x & mask
    return (x >> n) | (mask_bits << (nb_bits - n))


def rol(x, n, nb_bits=32):
    return ror(x, nb_bits - n, nb_bits)

```

`d810/z3_utils.py`:

```py
import logging
from typing import List, Union
from ida_hexrays import *

from d810.hexrays_helpers import get_mop_index
from d810.hexrays_formatters import format_minsn_t, opcode_to_string
from d810.ast import mop_to_ast, minsn_to_ast, AstLeaf, AstNode
from d810.errors import D810Z3Exception

logger = logging.getLogger('D810.plugin')
z3_file_logger = logging.getLogger('D810.z3_test')

try:
    import z3
    Z3_INSTALLED = True
    # Since version 4.8.2, when Z3 is creating a BitVec, it relies on _str_to_bytes which uses sys.stdout.encoding
    # However, in IDA Pro (7.6sp1) sys.stdout is an object of type IDAPythonStdOut
    # which doesn't have a 'encoding' attribute, thus we set it to something, so that Z3 works
    import sys
    try:
        x = sys.stdout.encoding
    except AttributeError:
        logger.debug("Couldn't find sys.stdout.encoding, setting it to utf-8")
        sys.stdout.encoding = "utf-8"
except ImportError:
    logger.info("Z3 features disabled. Install Z3 to enable them")
    Z3_INSTALLED = False


def create_z3_vars(leaf_list: List[AstLeaf]):
    if not Z3_INSTALLED:
        raise D810Z3Exception("Z3 is not installed")
    known_leaf_list = []
    known_leaf_z3_var_list = []
    for leaf in leaf_list:
        if not leaf.is_constant():
            leaf_index = get_mop_index(leaf.mop, known_leaf_list)
            if leaf_index == -1:
                known_leaf_list.append(leaf.mop)
                leaf_index = len(known_leaf_list) - 1
                if leaf.mop.size in [1, 2, 4, 8]:
                    # Normally, we should create variable based on their size
                    # but for now it can cause issue when instructions like XDU are used, hence this ugly fix
                    # known_leaf_z3_var_list.append(z3.BitVec("x_{0}".format(leaf_index), 8 * leaf.mop.size))
                    known_leaf_z3_var_list.append(z3.BitVec("x_{0}".format(leaf_index), 32))
                    pass
                else:
                    known_leaf_z3_var_list.append(z3.BitVec("x_{0}".format(leaf_index), 32))
            leaf.z3_var = known_leaf_z3_var_list[leaf_index]
            leaf.z3_var_name = "x_{0}".format(leaf_index)
    return known_leaf_z3_var_list


def ast_to_z3_expression(ast: Union[AstNode, AstLeaf], use_bitvecval=False):
    if not Z3_INSTALLED:
        raise D810Z3Exception("Z3 is not installed")
    if isinstance(ast, AstLeaf):
        if ast.is_constant():
            return z3.BitVecVal(ast.value, 32)
        return ast.z3_var
    if ast.opcode == m_neg:
        return -(ast_to_z3_expression(ast.left, use_bitvecval))
    elif ast.opcode == m_lnot:
        return not (ast_to_z3_expression(ast.left, use_bitvecval))
    elif ast.opcode == m_bnot:
        return ~(ast_to_z3_expression(ast.left, use_bitvecval))
    elif ast.opcode == m_add:
        return (ast_to_z3_expression(ast.left, use_bitvecval)) + (ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode == m_sub:
        return (ast_to_z3_expression(ast.left, use_bitvecval)) - (ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode == m_mul:
        return (ast_to_z3_expression(ast.left, use_bitvecval)) * (ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode == m_udiv:
        return z3.UDiv(ast_to_z3_expression(ast.left, use_bitvecval=True),
                       ast_to_z3_expression(ast.right, use_bitvecval=True))
    elif ast.opcode == m_sdiv:
        return (ast_to_z3_expression(ast.left, use_bitvecval)) / (ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode == m_umod:
        return z3.URem(ast_to_z3_expression(ast.left, use_bitvecval), ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode == m_smod:
        return (ast_to_z3_expression(ast.left, use_bitvecval)) % (ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode == m_or:
        return (ast_to_z3_expression(ast.left, use_bitvecval)) | (ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode == m_and:
        return (ast_to_z3_expression(ast.left, use_bitvecval)) & (ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode == m_xor:
        return (ast_to_z3_expression(ast.left, use_bitvecval)) ^ (ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode == m_shl:
        return (ast_to_z3_expression(ast.left, use_bitvecval)) << (ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode == m_shr:
        return z3.LShR(ast_to_z3_expression(ast.left, use_bitvecval), ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode == m_sar:
        return (ast_to_z3_expression(ast.left, use_bitvecval)) >> (ast_to_z3_expression(ast.right, use_bitvecval))
    elif ast.opcode in [m_xdu, m_xds, m_low, m_high]:
        return ast_to_z3_expression(ast.left, use_bitvecval)
    raise D810Z3Exception("Z3 evaluation: Unknown opcode {0} for {1}".format(opcode_to_string(ast.opcode), ast))


def mop_list_to_z3_expression_list(mop_list: List[mop_t]):
    if not Z3_INSTALLED:
        raise D810Z3Exception("Z3 is not installed")
    ast_list = [mop_to_ast(mop) for mop in mop_list]
    ast_leaf_list = []
    for ast in ast_list:
        ast_leaf_list += ast.get_leaf_list()
    _ = create_z3_vars(ast_leaf_list)
    return [ast_to_z3_expression(ast) for ast in ast_list]


def z3_check_mop_equality(mop1: mop_t, mop2: mop_t) -> bool:
    if not Z3_INSTALLED:
        raise D810Z3Exception("Z3 is not installed")
    z3_mop1, z3_mop2 = mop_list_to_z3_expression_list([mop1, mop2])
    s = z3.Solver()
    s.add(z3.Not(z3_mop1 == z3_mop2))
    if s.check().r == -1:
        return True
    return False


def z3_check_mop_inequality(mop1: mop_t, mop2: mop_t) -> bool:
    if not Z3_INSTALLED:
        raise D810Z3Exception("Z3 is not installed")
    z3_mop1, z3_mop2 = mop_list_to_z3_expression_list([mop1, mop2])
    s = z3.Solver()
    s.add(z3_mop1 == z3_mop2)
    if s.check().r == -1:
        return True
    return False


def rename_leafs(leaf_list: List[AstLeaf]) -> List[str]:
    if not Z3_INSTALLED:
        raise D810Z3Exception("Z3 is not installed")
    known_leaf_list = []
    for leaf in leaf_list:
        if not leaf.is_constant() and leaf.mop.t != mop_z:
            leaf_index = get_mop_index(leaf.mop, known_leaf_list)
            if leaf_index == -1:
                known_leaf_list.append(leaf.mop)
                leaf_index = len(known_leaf_list) - 1
            leaf.z3_var_name = "x_{0}".format(leaf_index)

    return ["x_{0} = BitVec('x_{0}', {1})".format(i, 8 * leaf.size) for i, leaf in enumerate(known_leaf_list)]


def log_z3_instructions(original_ins: minsn_t, new_ins: minsn_t):
    if not Z3_INSTALLED:
        raise D810Z3Exception("Z3 is not installed")
    orig_mba_tree = minsn_to_ast(original_ins)
    new_mba_tree = minsn_to_ast(new_ins)
    if orig_mba_tree is None or new_mba_tree is None:
        return None
    orig_leaf_list = orig_mba_tree.get_leaf_list()
    new_leaf_list = new_mba_tree.get_leaf_list()

    var_def_list = rename_leafs(orig_leaf_list + new_leaf_list)

    z3_file_logger.info("print('Testing: {0} == {1}')".format(format_minsn_t(original_ins), format_minsn_t(new_ins)))
    for var_def in var_def_list:
        z3_file_logger.info("{0}".format(var_def))

    removed_xdu = "{0}".format(orig_mba_tree).replace("xdu","")
    z3_file_logger.info("original_expr = {0}".format(removed_xdu))
    removed_xdu = "{0}".format(new_mba_tree).replace("xdu","")
    z3_file_logger.info("new_expr = {0}".format(removed_xdu))
    z3_file_logger.info("prove(original_expr == new_expr)\n")

```

`diaphora_plugin.cfg`:

```cfg
[Diaphora]
path=~/.idapro/plugins/diaphora/

```

`diaphora_plugin.py`:

```py
"""
Diaphora, a binary diffing tool
Copyright (c) 2015-2024, Joxean Koret

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import os
import sys
import configparser

import idaapi
from idaapi import warning

#-------------------------------------------------------------------------------
def resolve_diaphora():
  config_dir = os.path.dirname(__file__)
  config_file = os.path.join(config_dir, "diaphora_plugin.cfg")
  if not os.path.exists(config_file):
    warning(f"The configuration file {config_file} does not exist.")
    return None
  
  config = configparser.ConfigParser()
  config.read(config_file)

  path = config["Diaphora"]["path"]
  sys.path.append(path)

  from diaphora_ida import main
  return main

#-------------------------------------------------------------------------------
class DiaphoraPlugin(idaapi.plugin_t):
  wanted_name = "Diaphora"
  version = "3.2.0"
  wanted_hotkey = ""
  comment = "Diaphora by joxeankoret"
  website = "https://github.com/joxeankoret/diaphora"
  help = "Export the current binary or diff against another binary"
  flags = 0

  def init(self):
    self.diaphora_main = None
    return idaapi.PLUGIN_KEEP

  def term(self):
    pass

  def run(self, arg):
    if self.diaphora_main is None:
      self.diaphora_main = resolve_diaphora()

    if self.diaphora_main is not None:
      self.diaphora_main()

    return True

#-------------------------------------------------------------------------------
def PLUGIN_ENTRY():
  return DiaphoraPlugin()


```

`findcrypt3.py`:

```py
# -*- coding: utf-8 -*-

import idaapi
import idautils
import ida_bytes
import ida_diskio
import idc
import operator
import yara
import os
import glob

VERSION = "0.2"
YARARULES_CFGFILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "findcrypt3.rules")

try:
    class Kp_Menu_Context(idaapi.action_handler_t):
        def __init__(self):
            idaapi.action_handler_t.__init__(self)

        @classmethod
        def get_name(self):
            return self.__name__

        @classmethod
        def get_label(self):
            return self.label

        @classmethod
        def register(self, plugin, label):
            self.plugin = plugin
            self.label = label
            instance = self()
            return idaapi.register_action(idaapi.action_desc_t(
                self.get_name(),  # Name. Acts as an ID. Must be unique.
                instance.get_label(),  # Label. That's what users see.
                instance  # Handler. Called when activated, and for updating
            ))

        @classmethod
        def unregister(self):
            """Unregister the action.
            After unregistering the class cannot be used.
            """
            idaapi.unregister_action(self.get_name())

        @classmethod
        def activate(self, ctx):
            # dummy method
            return 1

        @classmethod
        def update(self, ctx):
            if ctx.widget_type == idaapi.BWN_DISASM:
                return idaapi.AST_ENABLE_FOR_WIDGET
            return idaapi.AST_DISABLE_FOR_WIDGET

    class Searcher(Kp_Menu_Context):
        def activate(self, ctx):
            self.plugin.search()
            return 1

except:
    pass


p_initialized = False


class YaraSearchResultChooser(idaapi.Choose):
    def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False):
        idaapi.Choose.__init__(
            self,
            title,
            [
                ["Address", idaapi.Choose.CHCOL_HEX|10],
                ["Rules file", idaapi.Choose.CHCOL_PLAIN|12],
                ["Name", idaapi.Choose.CHCOL_PLAIN|25],
                ["String", idaapi.Choose.CHCOL_PLAIN|25],
                ["Value", idaapi.Choose.CHCOL_PLAIN|40],
                ["Hex", idaapi.Choose.CHCOL_PLAIN|45],
            ],
            flags=flags,
            width=width,
            height=height,
            embedded=embedded)
        self.items = items
        self.selcount = 0
        self.n = len(items)

    def OnClose(self):
        return

    def OnSelectLine(self, n):
        self.selcount += 1
        idc.jumpto(self.items[n][0])

    def OnGetLine(self, n):
        res = self.items[n]
        res = [idc.atoa(res[0]), res[1], res[2], res[3], res[4], res[5]]
        return res

    def OnGetSize(self):
        n = len(self.items)
        return n

    def show(self):
        return self.Show() >= 0

#--------------------------------------------------------------------------
# Plugin
#--------------------------------------------------------------------------
class Findcrypt_Plugin_t(idaapi.plugin_t):
    comment = "Findcrypt plugin for IDA Pro (using yara framework)"
    help = "todo"
    wanted_name = "Findcrypt"
    wanted_hotkey = "Ctrl-Alt-F"
    flags = idaapi.PLUGIN_KEEP

    def init(self):
        global p_initialized

        # register popup menu handlers
        try:
            Searcher.register(self, "Findcrypt")
        except:
            pass

        if p_initialized is False:
            p_initialized = True
            self.user_directory = self.get_user_directory()
            idaapi.register_action(idaapi.action_desc_t(
                "Findcrypt",
                "Find crypto constants",
                Searcher(),
                None,
                None,
                0))
            idaapi.attach_action_to_menu("Search", "Findcrypt", idaapi.SETMENU_APP)
            print("=" * 80)
            print("Findcrypt v{0} by David BERARD, 2017".format(VERSION))
            print("Findcrypt search shortcut key is Ctrl-Alt-F")
            print("Global rules in %s" % YARARULES_CFGFILE)
            print("User-defined rules in %s/*.rules" % self.user_directory)
            print("=" * 80)

        return idaapi.PLUGIN_KEEP

    def term(self):
        pass


    def toVirtualAddress(self, offset, segments):
        va_offset = 0
        for seg in segments:
            if seg[1] <= offset < seg[2]:
                va_offset = seg[0] + (offset - seg[1])
        return va_offset


    def get_user_directory(self):
        user_dir = ida_diskio.get_user_idadir()
        plug_dir = os.path.join(user_dir, "plugins")
        res_dir = os.path.join(plug_dir, "findcrypt-yara")
        if not os.path.exists(res_dir):
            os.makedirs(res_dir, 0o755)
        return res_dir


    def get_rules_files(self):
        rules_filepaths = {"global":YARARULES_CFGFILE}
        for fpath in glob.glob(os.path.join(self.user_directory, "*.rules")):
            name = os.path.basename(fpath)
            rules_filepaths.update({name:fpath})
        return rules_filepaths


    def search(self):
        memory, offsets = self._get_memory()
        rules = yara.compile(filepaths=self.get_rules_files())
        values = self.yarasearch(memory, offsets, rules)
        c = YaraSearchResultChooser("Findcrypt results", values)
        r = c.show()

    def yarasearch(self, memory, offsets, rules):
        print(">>> start yara search")
        values = list()
        matches = rules.match(data=memory)
        for match in matches:
            for string in match.strings:
                for instance in string.instances:
                    name = match.rule
                    if name.endswith("_API"):
                        try:
                            name = name + "_" + idc.GetString(self.toVirtualAddress(instance.offset, offsets))
                        except:
                            pass
                    value = [
                        self.toVirtualAddress(instance.offset, offsets),
                        match.namespace,
                        name + "_" + hex(self.toVirtualAddress(instance.offset, offsets)).lstrip("0x").rstrip("L").upper(),
                        string.identifier,
                        repr(instance.matched_data),
                        instance.matched_data.hex().upper(),
                    ]
                    idaapi.set_name(value[0], name
                             + "_"
                             + hex(self.toVirtualAddress(instance.offset, offsets)).lstrip("0x").rstrip("L").upper()
                             , 0)
                    values.append(value)
        print("<<< end yara search")
        return values

    def _get_memory(self):
        result = bytearray()
        segment_starts = [ea for ea in idautils.Segments()]
        offsets = []
        start_len = 0
        for start in segment_starts:
            end = idc.get_segm_attr(start, idc.SEGATTR_END)
            result += ida_bytes.get_bytes(start, end - start)
            offsets.append((start, start_len, len(result)))
            start_len = len(result)
        return bytes(result), offsets

    def run(self, arg):
        self.search()


# register IDA plugin
def PLUGIN_ENTRY():
    return Findcrypt_Plugin_t()
```

`findcrypt3.rules`:

```rules
/*
    from https://github.com/Yara-Rules/rules/tree/master/Crypto
    This Yara ruleset is under the GNU-GPLv2 license (http://www.gnu.org/licenses/gpl-2.0.html) and open to any user or organization, as long as you use it under this license.
*/
rule Big_Numbers0
{
	meta:
		author = "_pusher_"
		description = "Looks for big numbers 20:sized"
		date = "2016-07"
	strings:
		$c0 = /[0-9a-fA-F]{20}/ fullword ascii
	condition:
		$c0
}

rule Big_Numbers1
{
	meta:
		author = "_pusher_"
		description = "Looks for big numbers 32:sized"
		date = "2016-07"
	strings:
		$c0 = /[0-9a-fA-F]{32}/ fullword wide ascii
	condition:
		$c0
}

rule Big_Numbers2
{
	meta:
		author = "_pusher_"
		description = "Looks for big numbers 48:sized"
		date = "2016-07"
	strings:
		$c0 = /[0-9a-fA-F]{48}/ fullword wide ascii
	condition:
		$c0
}

rule Big_Numbers3
{
	meta:
		author = "_pusher_"
		description = "Looks for big numbers 64:sized"
		date = "2016-07"
	strings:
        	$c0 = /[0-9a-fA-F]{64}/ fullword wide ascii
	condition:
		$c0
}

rule Big_Numbers4
{
	meta:
		author = "_pusher_"
		description = "Looks for big numbers 128:sized"
		date = "2016-08"
	strings:
        	$c0 = /[0-9a-fA-F]{128}/ fullword wide ascii
	condition:
		$c0
}

rule Big_Numbers5
{
	meta:
		author = "_pusher_"
		description = "Looks for big numbers 256:sized"
		date = "2016-08"
	strings:
        	$c0 = /[0-9a-fA-F]{256}/ fullword wide ascii
	condition:
		$c0
}

rule Prime_Constants_char {
	meta:
		author = "_pusher_"
		description = "List of primes [char]"
		date = "2016-07"
	strings:
		$c0 = { 03 05 07 0B 0D 11 13 17 1D 1F 25 29 2B 2F 35 3B 3D 43 47 49 4F 53 59 61 65 67 6B 6D 71 7F 83 89 8B 95 97 9D A3 A7 AD B3 B5 BF C1 C5 C7 D3 DF E3 E5 E9 EF F1 FB }
	condition:
		$c0
}

rule Prime_Constants_long {
	meta:
		author = "_pusher_"
		description = "List of primes [long]"
		date = "2016-07"
	strings:
		$c0 = { 03 00 00 00 05 00 00 00 07 00 00 00 0B 00 00 00 0D 00 00 00 11 00 00 00 13 00 00 00 17 00 00 00 1D 00 00 00 1F 00 00 00 25 00 00 00 29 00 00 00 2B 00 00 00 2F 00 00 00 35 00 00 00 3B 00 00 00 3D 00 00 00 43 00 00 00 47 00 00 00 49 00 00 00 4F 00 00 00 53 00 00 00 59 00 00 00 61 00 00 00 65 00 00 00 67 00 00 00 6B 00 00 00 6D 00 00 00 71 00 00 00 7F 00 00 00 83 00 00 00 89 00 00 00 8B 00 00 00 95 00 00 00 97 00 00 00 9D 00 00 00 A3 00 00 00 A7 00 00 00 AD 00 00 00 B3 00 00 00 B5 00 00 00 BF 00 00 00 C1 00 00 00 C5 00 00 00 C7 00 00 00 D3 00 00 00 DF 00 00 00 E3 00 00 00 E5 00 00 00 E9 00 00 00 EF 00 00 00 F1 00 00 00 FB 00 00 00 }
	condition:
		$c0
}


rule Advapi_Hash_API {
	meta:
		author = "_pusher_"
		description = "Looks for advapi API functions"
		date = "2016-07"
	strings:
		$advapi32 = "advapi32.dll" wide ascii nocase
		$CryptCreateHash = "CryptCreateHash" wide ascii
		$CryptHashData = "CryptHashData" wide ascii
		$CryptAcquireContext = "CryptAcquireContext" wide ascii
	condition:
		$advapi32 and ($CryptCreateHash and $CryptHashData and $CryptAcquireContext)
}

rule Crypt32_CryptBinaryToString_API {
	meta:
		author = "_pusher_"
		description = "Looks for crypt32 CryptBinaryToStringA function"
		date = "2016-08"
	strings:
		$crypt32 = "crypt32.dll" wide ascii nocase
		$CryptBinaryToStringA = "CryptBinaryToStringA" wide ascii
	condition:
		$crypt32 and ($CryptBinaryToStringA)
}

rule CRC32c_poly_Constant {
	meta:
		author = "_pusher_"
		description = "Look for CRC32c (Castagnoli) [poly]"
		date = "2016-08"
	strings:
		$c0 = { 783BF682 }
	condition:
		$c0
}

rule CRC32_poly_Constant {
	meta:
		author = "_pusher_"
		description = "Look for CRC32 [poly]"
		date = "2015-05"
		version = "0.1"
	strings:
		$c0 = { 2083B8ED }
	condition:
		$c0
}

rule CRC32_table {
	meta:
		author = "_pusher_"
		description = "Look for CRC32 table"
		date = "2015-05"
		version = "0.1"
	strings:
		$c0 = { 00000000 77073096 EE0E612C 990951BA 076DC419 }
	condition:
		$c0
}

rule CRC32_table_lookup {
	meta:
		author = "_pusher_"
		description = "CRC32 table lookup"
		date = "2015-06"
		version = "0.1"
	strings:
		$c0 = { 8B 54 24 08 85 D2 7F 03 33 C0 C3 83 C8 FF 33 C9 85 D2 7E 29 56 8B 74 24 08 57 8D 9B 00 00 00 00 0F B6 3C 31 33 F8 81 E7 FF 00 00 00 C1 E8 08 33 04 BD ?? ?? ?? ?? 41 3B CA 7C E5 5F 5E F7 D0 C3 }
	condition:
		$c0
}

rule CRC32b_poly_Constant {
	meta:
		author = "_pusher_"
		description = "Look for CRC32b [poly]"
		date = "2016-04"
		version = "0.1"
	strings:
		$c0 = { B71DC104 }
	condition:
		$c0
}


rule CRC16_table {
	meta:
		author = "_pusher_"
		description = "Look for CRC16 table"
		date = "2016-04"
		version = "0.1"
	strings:
		$c0 = { 0000 1021 2042 3063 4084 50A5 60C6 70E7 8108 9129 A14A B16B C18C D1AD E1CE F1EF 1231 0210 3273 2252 52B5 4294 72F7 62D6 9339 8318 B37B A35A D3BD C39C F3FF E3DE }
	condition:
		$c0
}


rule FlyUtilsCnDES_ECB_Encrypt {
	meta:
		author = "_pusher_"
		description = "Look for FlyUtils.CnDES Encrypt ECB function"
		date = "2016-07"
	strings:
		$c0 = { 55 8B EC 83 C4 E8 53 56 57 33 DB 89 5D E8 89 5D EC 8B D9 89 55 F8 89 45 FC 8B 7D 08 8B 75 20 8B 45 FC E8 ?? ?? ?? ?? 8B 45 F8 E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 80 7D 18 00 74 1A 0F B6 55 18 8D 4D EC 8B 45 F8 E8 ?? ?? ?? ?? 8B 55 EC 8D 45 F8 E8 ?? ?? ?? ?? 80 7D 1C 00 74 1A 0F B6 55 1C 8D 4D E8 8B 45 FC E8 ?? ?? ?? ?? 8B 55 E8 8D 45 FC E8 ?? ?? ?? ?? 85 DB 75 07 E8 ?? ?? ?? ?? 8B D8 85 F6 75 07 E8 ?? ?? ?? ?? 8B F0 53 6A 00 8B 4D FC B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? 89 45 F4 33 D2 55 68 ?? ?? ?? ?? 64 FF 32 64 89 22 6A 00 6A 00 8B 45 F4 E8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 50 6A 00 33 C9 B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? 89 45 F0 33 D2 55 68 ?? ?? ?? ?? 64 FF 32 64 89 22 6A 00 6A 00 56 }
	condition:
		$c0
}

rule FlyUtilsCnDES_ECB_Decrypt {
	meta:
		author = "_pusher_"
		description = "Look for FlyUtils.CnDES Decrypt ECB function"
		date = "2016-07"
	strings:
		$c0 = { 55 8B EC 83 C4 E8 53 56 57 33 DB 89 5D E8 89 5D EC 8B F9 89 55 F8 89 45 FC 8B 5D 18 8B 75 20 8B 45 FC E8 ?? ?? ?? ?? 8B 45 F8 E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 84 DB 74 18 8B D3 8D 4D EC 8B 45 F8 E8 ?? ?? ?? ?? 8B 55 EC 8D 45 F8 E8 ?? ?? ?? ?? 85 FF 75 07 E8 ?? ?? ?? ?? 8B F8 85 F6 75 07 E8 ?? ?? ?? ?? 8B F0 8B 4D FC B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? 89 45 F4 33 D2 55 68 ?? ?? ?? ?? 64 FF 32 64 89 22 57 6A 00 33 C9 B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? 89 45 F0 33 D2 55 68 ?? ?? ?? ?? 64 FF 32 64 89 22 6A 00 6A 00 56 E8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 50 FF 75 14 FF 75 10 8B 45 0C 50 8B 4D F8 8B 55 F0 8B 45 F4 E8 ?? ?? ?? ?? 6A 00 6A 00 8B 45 F0 E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8B 55 08 8B 45 F0 E8 ?? ?? ?? ?? 33 C0 5A 59 59 64 89 10 EB 12 E9 ?? ?? ?? ?? 8B 45 08 E8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 5A 59 59 64 89 10 68 ?? ?? ?? ?? 8B 45 F0 33 D2 89 55 F0 E8 ?? ?? ?? ?? C3 }
	condition:
		$c0
}

rule Elf_Hash {
	meta:
		author = "_pusher_"
		description = "Look for ElfHash"
		date = "2015-06"
		version = "0.3"
	strings:
		$c0 = { 53 56 33 C9 8B DA 4B 85 DB 7C 25 43 C1 E1 04 33 D2 8A 10 03 CA 8B D1 81 E2 00 00 00 F0 85 D2 74 07 8B F2 C1 EE 18 33 CE F7 D2 23 CA 40 4B 75 DC 8B C1 5E 5B C3 }
		$c1 = { 53 33 D2 85 C0 74 2B EB 23 C1 E2 04 81 E1 FF 00 00 00 03 D1 8B CA 81 E1 00 00 00 F0 85 C9 74 07 8B D9 C1 EB 18 33 D3 F7 D1 23 D1 40 8A 08 84 C9 75 D7 8B C2 5B C3 }
		$c2 = { 53 56 33 C9 8B D8 85 D2 76 23 C1 E1 04 33 C0 8A 03 03 C8 8B C1 25 00 00 00 F0 85 C0 74 07 8B F0 C1 EE 18 33 CE F7 D0 23 C8 43 4A 75 DD 8B C1 5E 5B C3 }
		$c3 = { 53 56 57 8B F2 8B D8 8B FB 53 E8 ?? ?? ?? ?? 6B C0 02 71 05 E8 ?? ?? ?? ?? 8B D7 33 C9 8B D8 83 EB 01 71 05 E8 ?? ?? ?? ?? 85 DB 7C 2C 43 C1 E1 04 0F B6 02 03 C8 71 05 E8 ?? ?? ?? ?? 83 C2 01 B8 00 00 00 F0 23 C1 85 C0 74 07 8B F8 C1 EF 18 33 CF F7 D0 23 C8 4B 75 D5 8B C1 99 F7 FE 8B C2 85 C0 7D 09 03 C6 71 05 E8 ?? ?? ?? ?? 5F 5E 5B C3 }
		$c4 = { 53 33 D2 EB 2C 8B D9 80 C3 BF 80 EB 1A 73 03 80 C1 20 C1 E2 04 81 E1 FF 00 00 00 03 D1 8B CA 81 E1 00 00 00 F0 8B D9 C1 EB 18 33 D3 F7 D1 23 D1 40 8A 08 84 C9 75 CE 8B C2 5B C3 }
		$c5 = { 89 C2 31 C0 85 D2 74 30 2B 42 FC 74 2B 89 C1 29 C2 31 C0 53 0F B6 1C 11 01 C3 8D 04 1B C1 EB 14 8D 04 C5 00 00 00 00 81 E3 00 0F 00 00 31 D8 83 C1 01 75 E0 C1 E8 04 5B C3 }
		$c6 = { 53 33 D2 85 C0 74 38 EB 30 8B D9 80 C3 BF 80 EB 1A 73 03 80 C1 20 C1 E2 04 81 E1 FF 00 00 00 03 D1 8B CA 81 E1 00 00 00 F0 85 C9 74 07 8B D9 C1 EB 18 33 D3 F7 D1 23 D1 40 8A 08 84 C9 75 CA 8B C2 5B C3 }
	condition:
		any of them
}

rule BLOWFISH_Constants {
	meta:
		author = "phoul (@phoul)"
		description = "Look for Blowfish constants"
		date = "2014-01"
		version = "0.1"
	strings:
		$c0 = { D1310BA6 }
		$c1 = { A60B31D1 }	
		$c2 = { 98DFB5AC }
		$c3 = { ACB5DF98 }
		$c4 = { 2FFD72DB }
		$c5 = { DB72FD2F }
		$c6 = { D01ADFB7 }
		$c7 = { B7DF1AD0 }
		$c8 = { 4B7A70E9 }
		$c9 = { E9707A4B }
		$c10 = { F64C261C }
		$c11 = { 1C264CF6 }
	condition:
		6 of them
}

rule MD5_Constants {
	meta:
		author = "phoul (@phoul)"
		description = "Look for MD5 constants"
		date = "2014-01"
		version = "0.2"
	strings:
		// Init constants
		$c0 = { 67452301 }
		$c1 = { efcdab89 }
		$c2 = { 98badcfe }
		$c3 = { 10325476 }
		$c4 = { 01234567 }
		$c5 = { 89ABCDEF }
		$c6 = { FEDCBA98 }
		$c7 = { 76543210 }
		// Round 2
		$c8 = { F4D50d87 }
		$c9 = { 78A46AD7 }
	condition:
		5 of them
}

rule MD5_API {
	meta:
		author = "_pusher_"
		description = "Looks for MD5 API"
		date = "2016-07"
	strings:
		$advapi32 = "advapi32.dll" wide ascii nocase
		$cryptdll = "cryptdll.dll" wide ascii nocase
		$MD5Init = "MD5Init" wide ascii
		$MD5Update = "MD5Update" wide ascii
		$MD5Final = "MD5Final" wide ascii
	condition:
		($advapi32 or $cryptdll) and ($MD5Init and $MD5Update and $MD5Final)
}

rule RC6_Constants {
	meta:
		author = "chort (@chort0)"
		description = "Look for RC6 magic constants in binary"
		reference = "https://twitter.com/mikko/status/417620511397400576"
		reference2 = "https://twitter.com/dyngnosis/status/418105168517804033"
		date = "2013-12"
		version = "0.2"
	strings:
		$c1 = { B7E15163 }
		$c2 = { 9E3779B9 }
		$c3 = { 6351E1B7 }
		$c4 = { B979379E }
	condition:
		2 of them
}

rule RIPEMD160_Constants {
	meta:
		author = "phoul (@phoul)"
		description = "Look for RIPEMD-160 constants"
		date = "2014-01"
		version = "0.1"
	strings:
		$c0 = { 67452301 }
		$c1 = { EFCDAB89 }
		$c2 = { 98BADCFE }
		$c3 = { 10325476 }
		$c4 = { C3D2E1F0 }
		$c5 = { 01234567 }
		$c6 = { 89ABCDEF }
		$c7 = { FEDCBA98 }
		$c8 = { 76543210 }
		$c9 = { F0E1D2C3 }
	condition:
		5 of them
}

rule SHA1_Constants {
	meta:
		author = "phoul (@phoul)"
		description = "Look for SHA1 constants"
		date = "2014-01"
		version = "0.1"
	strings:
		$c0 = { 67452301 }
		$c1 = { EFCDAB89 }
		$c2 = { 98BADCFE }
		$c3 = { 10325476 }
		$c4 = { C3D2E1F0 }
		$c5 = { 01234567 }
		$c6 = { 89ABCDEF }
		$c7 = { FEDCBA98 }
		$c8 = { 76543210 }
		$c9 = { F0E1D2C3 }
		//added by _pusher_ 2016-07 - last round
		$c10 = { D6C162CA }
	condition:
		5 of them
}

rule SHA256_Constants {
	meta:
		author = "Andrew Williams (@recvfrom)"
		description = "Look for SHA256 constants"
		date = "2020-10"
		version = "0.1"
	strings:
        $c_le_1 = { 6A09E667 }
        $c_le_2 = { BB67AE85 }
        $c_le_3 = { 3C6EF372 }
        $c_le_4 = { A54FF53A }
        $c_le_5 = { 510E527F }
        $c_le_6 = { 9B05688C }
        $c_le_7 = { 1F83D9AB }
        $c_le_8 = { 5BE0CD19 }

        $c_be_1 = { 67E6096A }
        $c_be_2 = { 85AE67BB }
        $c_be_3 = { 72F36E3C }
        $c_be_4 = { 3AF54FA5 }
        $c_be_5 = { 7F520E51 }
        $c_be_6 = { 8C68059B }
        $c_be_7 = { ABD9831F }
        $c_be_8 = { 19CDE05B }

	condition:
		5 of ($c_be_*) or 5 of ($c_le_*)
}

rule SHA512_Constants {
	meta:
		author = "phoul (@phoul)"
		description = "Look for SHA384/SHA512 constants"
		date = "2014-01"
		version = "0.1"
	strings:
		$c0 = { 428a2f98 }
		$c1 = { 982F8A42 }
		$c2 = { 71374491 }
		$c3 = { 91443771 }
		$c4 = { B5C0FBCF }
		$c5 = { CFFBC0B5 }
		$c6 = { E9B5DBA5 }
		$c7 = { A5DBB5E9 }
		$c8 = { D728AE22 }
		$c9 = { 22AE28D7 }
	condition:
		5 of them
}

rule TEAN {
	meta:
		author = "_pusher_"
		description = "Look for TEA Encryption"
		date = "2016-08"
	strings:
		$c0 = { 2037EFC6 }
	condition:
		$c0
}

rule WHIRLPOOL_Constants {
	meta:
		author = "phoul (@phoul)"
		description = "Look for WhirlPool constants"
		date = "2014-02"
		version = "0.1"
	strings:
		$c0 = { 18186018c07830d8 }
		$c1 = { d83078c018601818 }
		$c2 = { 23238c2305af4626 }
		$c3 = { 2646af05238c2323 }
	condition:
		2 of them
}

rule DarkEYEv3_Cryptor {
	meta:
		description = "Rule to detect DarkEYEv3 encrypted executables (often malware)"
		author = "Florian Roth"
		reference = "http://darkeyev3.blogspot.fi/"
		date = "2015-05-24"
		hash0 = "6b854b967397f7de0da2326bdd5d39e710e2bb12"
		hash1 = "d53149968eca654fc0e803f925e7526fdac2786c"
		hash2 = "7e3a8940d446c57504d6a7edb6445681cca31c65"
		hash3 = "d3dd665dd77b02d7024ac16eb0949f4f598299e7"
		hash4 = "a907a7b74a096f024efe57953c85464e87275ba3"
		hash5 = "b1c422155f76f992048377ee50c79fe164b22293"
		hash6 = "29f5322ce5e9147f09e0a86cc23a7c8dc88721b9"
		hash7 = "a0382d7c12895489cb37efef74c5f666ea750b05"
		hash8 = "f3d5b71b7aeeb6cc917d5bb67e2165cf8a2fbe61"
		score = 55
	strings:
		$s0 = "\\DarkEYEV3-" 
	condition:
		uint16(0) == 0x5a4d and $s0
}

rule Miracl_powmod
{	meta:
		author = "Maxx"
		description = "Miracl powmod"
	strings:
		$c0 = { 53 55 56 57 E8 ?? ?? ?? ?? 8B F0 8B 86 18 02 00 00 85 C0 0F 85 EC 01 00 00 8B 56 1C 42 8B C2 89 56 1C 83 F8 18 7D 17 C7 44 86 20 12 00 00 00 8B 86 2C 02 00 00 85 C0 74 05 E8 ?? ?? ?? ?? 8B 06 8B 4E 10 3B C1 74 2E 8B 7C 24 1C 57 E8 ?? ?? ?? ?? 83 C4 04 83 F8 02 7C 33 8B 57 04 8B 0E 51 8B 02 50 E8 ?? ?? ?? ?? 83 C4 08 83 F8 01 0F 84 58 01 00 00 EB 17 8B 7C 24 1C 6A 02 57 E8 ?? ?? ?? ?? 83 C4 08 85 C0 0F 84 3F 01 00 00 8B 8E C4 01 00 00 8B 54 24 18 51 52 E8 ?? ?? ?? ?? 8B 86 CC }
	condition:
		$c0
}

rule Miracl_crt
{	meta:
		author = "Maxx"
		description = "Miracl crt"
	strings:
		$c0 = { 51 56 57 E8 ?? ?? ?? ?? 8B 74 24 10 8B F8 89 7C 24 08 83 7E 0C 02 0F 8C 99 01 00 00 8B 87 18 02 00 00 85 C0 0F 85 8B 01 00 00 8B 57 1C 42 8B C2 89 57 1C 83 F8 18 7D 17 C7 44 87 20 4A 00 00 00 8B 87 2C 02 00 00 85 C0 74 05 E8 ?? ?? ?? ?? 8B 46 04 8B 54 24 14 53 55 8B 08 8B 02 51 50 E8 ?? ?? ?? ?? 8B 4E 0C B8 01 00 00 00 83 C4 08 33 ED 3B C8 89 44 24 18 0F 8E C5 00 00 00 BF 04 00 00 00 8B 46 04 8B 0C 07 8B 10 8B 44 24 1C 51 52 8B 0C 07 51 E8 ?? ?? ?? ?? 8B 56 04 8B 4E 08 8B 04 }
	condition:
		$c0
}

rule CryptoPP_a_exp_b_mod_c
{	meta:
		author = "Maxx"
		description = "CryptoPP a_exp_b_mod_c"
	strings:
		$c0 = { 6A FF 68 ?? ?? ?? ?? 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 81 EC ?? 00 00 00 56 8B B4 24 B0 00 00 00 57 6A 00 8B CE C7 44 24 0C 00 00 00 00 E8 ?? ?? ?? ?? 84 C0 0F 85 16 01 00 00 8D 4C 24 24 E8 ?? ?? ?? ?? BF 01 00 00 00 56 8D 4C 24 34 89 BC 24 A4 00 00 00 E8 ?? ?? ?? ?? 8B 06 8D 4C 24 3C 50 6A 00 C6 84 24 A8 00 00 00 02 E8 ?? ?? ?? ?? 8D 4C 24 48 C6 84 24 A0 00 00 00 03 E8 ?? ?? ?? ?? C7 44 24 24 ?? ?? ?? ?? 8B 8C 24 AC 00 00 00 8D 54 24 0C 51 52 8D 4C 24 2C C7 84 24 A8 }
		$c1 = { 6A FF 68 ?? ?? ?? ?? 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 4C 56 57 33 FF 8D 44 24 0C 89 7C 24 08 C7 44 24 10 ?? ?? ?? ?? C7 44 24 0C ?? ?? ?? ?? 89 44 24 14 8B 74 24 70 8D 4C 24 18 56 89 7C 24 60 E8 ?? ?? ?? ?? 8B 76 08 8D 4C 24 2C 56 57 C6 44 24 64 01 E8 ?? ?? ?? ?? 8D 4C 24 40 C6 44 24 5C 02 E8 ?? ?? ?? ?? C7 44 24 0C ?? ?? ?? ?? 8B 4C 24 6C 8B 54 24 68 8B 74 24 64 51 52 56 8D 4C 24 18 C7 44 24 68 03 00 00 00 E8 ?? ?? ?? ?? 8B 7C 24 4C 8B 4C 24 48 8B D7 33 C0 F3 }
		$c2 = { 6A FF 68 ?? ?? ?? ?? 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 34 56 57 33 FF 8D 44 24 0C 89 7C 24 08 C7 44 24 10 ?? ?? ?? ?? C7 44 24 0C ?? ?? ?? ?? 89 44 24 14 8B 74 24 58 8D 4C 24 18 56 89 7C 24 48 E8 ?? ?? ?? ?? 8B 0E C6 44 24 44 01 51 57 8D 4C 24 2C E8 ?? ?? ?? ?? 8D 4C 24 30 C6 44 24 44 02 E8 ?? ?? ?? ?? C7 44 24 0C ?? ?? ?? ?? 8B 54 24 54 8B 44 24 50 8B 74 24 4C 52 50 56 8D 4C 24 18 C7 44 24 50 03 00 00 00 E8 ?? ?? ?? ?? 8B 4C 24 30 8B 7C 24 34 33 C0 F3 AB 8B 4C }
	condition:
		any of them
}

rule CryptoPP_modulo
{	meta:
		author = "Maxx"
		description = "CryptoPP modulo"
	strings:
		$c0 = { 83 EC 20 53 55 8B 6C 24 2C 8B D9 85 ED 89 5C 24 08 75 18 8D 4C 24 0C E8 ?? ?? ?? ?? 8D 44 24 0C 68 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? 8D 4D FF 56 85 CD 57 75 09 8B 53 04 8B 02 23 C1 EB 76 8B CB E8 ?? ?? ?? ?? 83 FD 05 8B C8 77 2D 33 F6 33 FF 49 85 C0 74 18 8B 53 04 8D 41 01 8D 14 8A 8B 0A 03 F1 83 D7 00 48 83 EA 04 85 C0 77 F1 6A 00 55 57 56 E8 ?? ?? ?? ?? EB 3B 33 C0 8B D1 49 85 D2 74 32 8B 54 24 10 33 DB 8D 71 01 8B 52 04 8D 3C 8A 8B 17 33 ED 0B C5 8B 6C 24 34 33 C9 53 0B CA 55 }
		$c1 = { 6A FF 68 ?? ?? ?? ?? 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 2C 56 57 8B F1 33 FF 8D 4C 24 20 89 7C 24 08 E8 ?? ?? ?? ?? 8D 4C 24 0C 89 7C 24 3C E8 ?? ?? ?? ?? 8B 44 24 48 8D 4C 24 0C 50 56 8D 54 24 28 51 52 C6 44 24 4C 01 E8 ?? ?? ?? ?? 8B 74 24 54 83 C4 10 8D 44 24 20 8B CE 50 E8 ?? ?? ?? ?? 8B 7C 24 18 8B 4C 24 14 8B D7 33 C0 F3 AB 52 E8 ?? ?? ?? ?? 8B 7C 24 30 8B 4C 24 2C 8B D7 33 C0 C7 44 24 10 ?? ?? ?? ?? 52 F3 AB E8 ?? ?? ?? ?? 8B 4C 24 3C 83 C4 08 8B C6 64 89 }
		$c2 = { 83 EC 24 53 55 8B 6C 24 30 8B D9 85 ED 89 5C 24 08 75 18 8D 4C 24 0C E8 ?? ?? ?? ?? 8D 44 24 0C 68 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? 8D 4D FF 56 85 CD 57 75 09 8B 53 0C 8B 02 23 C1 EB 76 8B CB E8 ?? ?? ?? ?? 83 FD 05 8B C8 77 2D 33 F6 33 FF 49 85 C0 74 18 8B 53 0C 8D 41 01 8D 14 8A 8B 0A 03 F1 83 D7 00 48 83 EA 04 85 C0 77 F1 6A 00 55 57 56 E8 ?? ?? ?? ?? EB 3B 33 C0 8B D1 49 85 D2 74 32 8B 54 24 10 33 DB 8D 71 01 8B 52 0C 8D 3C 8A 8B 17 33 ED 0B C5 8B 6C 24 38 33 C9 53 0B CA 55 }
		$c3 = { 6A FF 68 ?? ?? ?? ?? 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 1C 56 57 8B F1 33 FF 8D 4C 24 0C 89 7C 24 08 E8 ?? ?? ?? ?? 8D 4C 24 18 89 7C 24 2C E8 ?? ?? ?? ?? 8B 44 24 38 8D 4C 24 18 50 56 8D 54 24 14 51 52 C6 44 24 3C 01 E8 ?? ?? ?? ?? 8B 74 24 44 83 C4 10 8D 44 24 0C 8B CE 50 E8 ?? ?? ?? ?? 8B 4C 24 18 8B 7C 24 1C 33 C0 F3 AB 8B 4C 24 1C 51 E8 ?? ?? ?? ?? 8B 4C 24 10 8B 7C 24 14 33 C0 F3 AB 8B 54 24 14 52 E8 ?? ?? ?? ?? 8B 4C 24 2C 83 C4 08 8B C6 64 89 0D 00 00 00 }
	condition:
		any of them
}

rule FGint_MontgomeryModExp
{	meta:
		author = "_pusher_"
		date = "2015-06"
		version = "0.2"
		description = "FGint MontgomeryModExp"
	strings:
		$c0 = { 55 8B EC 83 C4 ?? 53 56 57 33 DB 89 5D ?? 8B F1 8B DA 89 45 ?? 8B 7D 08 8D 45 F4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 EC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 DC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 ?? 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8D 55 D4 B8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B CF 8B D6 8B 45 FC E8 ?? ?? ?? ?? 8D 55 D4 8B C7 E8 ?? ?? ?? ?? 3C 02 75 0D 8D 45 D4 E8 ?? ?? ?? ?? E9 }
		$c1 = { 55 8B EC 83 C4 ?? 53 56 57 33 DB 89 5D ?? 8B F1 8B DA 89 45 ?? 8D 45 F4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 EC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 DC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8D 55 D4 B8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B CF 8B D6 8B 45 FC E8 ?? ?? ?? ?? 8D 55 D4 8B C7 E8 ?? ?? ?? ?? 3C 02 75 0D 8D 45 D4 E8 ?? ?? ?? ?? E9 }
		$c2 = { 55 8B EC 83 C4 ?? 53 56 57 33 DB 89 5D ?? 8B F1 8B DA 89 45 ?? 8B 7D 08 8D 45 F4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 EC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 DC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 ?? 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 ?? 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 ?? 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8D 55 D4 B8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B CF 8B D6 8B 45 ?? E8 ?? ?? ?? ?? 8D 55 D4 8B C7 E8 ?? ?? ?? ?? 3C 02 75 0D 8D 45 D4 E8 ?? ?? ?? ?? E9 }
		$c3 = { 55 8B EC 83 C4 ?? 53 56 57 33 DB 89 5D ?? 8B F1 8B DA 89 45 D0 8B 7D 08 8D 45 F4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 EC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 DC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 47 4C 47 00 64 FF 30 64 89 20 8D 55 D4 B8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B CF 8B D6 8B 45 D0 E8 ?? ?? ?? ?? 8D 55 D4 8B C7 E8 ?? ?? ?? ?? 3C 02 75 0D 8D 45 D4 E8 ?? ?? ?? ?? E9 02 02 00 00 }
	condition:
		any of them
}

rule FGint_FGIntModExp
{	meta:
		author = "_pusher_"
		date = "2015-05"
		description = "FGint FGIntModExp"
	strings:
		$c0 = { 55 8B EC 83 C4 E8 53 56 57 33 DB 89 5D ?? 8B F1 89 55 ?? 8B D8 8B 7D 08 8D 45 F4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 EC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8B 46 04 8B 40 04 83 E0 01 83 F8 01 75 0F 57 8B CE 8B 55 ?? 8B C3 E8 ?? ?? ?? ?? EB ?? 8D 55 ?? 8B 45 ?? E8 ?? ?? ?? ?? 8B D7 B8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 55 F4 8B C3 E8 ?? ?? ?? ?? 8B 45 }
	condition:
		$c0
}

rule FGint_MulByInt
{	meta:
		author = "_pusher_"
		date = "2015-05"
		description = "FGint MulByInt"
	strings:
		$c0 = { 53 56 57 55 83 C4 E8 89 4C 24 04 8B EA 89 04 24 8B 04 24 8B 40 04 8B 00 89 44 24 08 8B 44 24 08 83 C0 02 50 8D 45 04 B9 01 00 00 00 8B 15 ?? ?? ?? ?? ?? ?? ?? ?? ?? 83 C4 04 33 F6 8B 7C 24 08 85 FF 76 6D BB 01 00 00 00 8B 04 24 8B 40 04 8B 04 98 33 D2 89 44 24 10 89 54 24 14 8B 44 24 04 33 D2 52 50 8B 44 24 18 8B 54 24 1C ?? ?? ?? ?? ?? 89 44 24 10 89 54 24 14 8B C6 33 D2 03 44 24 10 13 54 24 14 89 44 24 10 89 54 24 14 8B 44 24 10 25 FF FF FF 7F 8B 55 04 89 04 9A 8B 44 24 10 8B 54 24 14 0F AC D0 1F C1 EA 1F 8B F0 43 4F 75 98 }
	condition:
		$c0
}

rule FGint_DivMod
{	meta:
		author = "_pusher_"
		date = "2015-05"
		description = "FGint FGIntDivMod"
	strings:
		$c0 = { 55 8B EC 83 C4 BC 53 56 57 8B F1 89 55 F8 89 45 FC 8B 5D 08 8D 45 F0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8B 45 FC 8A 00 88 45 D7 8B 45 F8 8A 00 88 45 D6 8B 45 FC E8 ?? ?? ?? ?? 8B 45 F8 E8 ?? ?? ?? ?? 8B D3 8B 45 FC E8 ?? ?? ?? ?? 8D 55 E0 8B 45 F8 E8 ?? ?? ?? ?? 8B 55 F8 8B 45 FC }
	condition:
		$c0
}

rule FGint_FGIntDestroy
{	meta:
		author = "_pusher_"
		date = "2015-05"
		description = "FGint FGIntDestroy"
	strings:
		$c0 = { 53 8B D8 8D 43 04 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 5B C3 }
	condition:
		$c0
}

rule FGint_Base10StringToGInt
{	meta:
		author = "_pusher_"
		date = "2015-06"
		version = "0.2"
		description = "FGint Base10StringToGInt"
	strings:
		$c0 = { 55 8B EC B9 04 00 00 00 6A 00 6A 00 49 75 F9 51 53 56 57 8B DA 89 45 FC 8B 45 FC ?? ?? ?? ?? ?? 33 C0 55 ?? ?? ?? ?? ?? 64 FF 30 64 89 20 EB 12 8D 45 FC B9 01 00 00 00 BA 01 00 00 00 ?? ?? ?? ?? ?? 8B 45 FC 8A 00 2C 2D 74 11 04 FD 2C 0A 72 0B 8B 45 FC ?? ?? ?? ?? ?? 48 7F D4 8D 45 E4 50 B9 01 00 00 00 BA 01 00 00 00 8B 45 FC ?? ?? ?? ?? ?? 8B 45 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 75 18 C6 45 EB 00 8D 45 FC B9 01 00 00 00 BA 01 00 00 00 ?? ?? ?? ?? ?? EB 18 C6 45 EB 01 EB 12 8D 45 FC }
		$c1 = { 55 8B EC 83 C4 D8 53 56 57 33 C9 89 4D D8 89 4D DC 89 4D E0 89 4D E4 89 4D EC 8B DA 89 45 FC 8B 45 FC E8 ?? ?? ?? ?? 33 C0 55 68 0F 42 45 00 64 FF 30 64 89 20 EB 12 8D 45 FC B9 01 00 00 00 BA 01 00 00 00 E8 ?? ?? ?? ?? 8B 45 FC 8A 00 2C 2D 74 11 04 FD 2C 0A 72 0B 8B 45 FC E8 ?? ?? ?? ?? 48 7F D4 8D 45 E4 50 B9 01 00 00 00 BA 01 00 00 00 8B 45 FC E8 ?? ?? ?? ?? 8B 45 E4 BA 28 42 45 00 E8 ?? ?? ?? ?? 75 18 C6 45 EB 00 8D 45 FC B9 01 00 00 00 BA 01 00 00 00 E8 ?? ?? ?? ?? EB 18 C6 45 EB 01 }
		$c2 = { 55 8B EC 83 C4 D8 53 56 33 C9 89 4D D8 89 4D DC 89 4D E0 89 4D F8 89 4D F4 8B DA 89 45 FC 8B 45 FC E8 ?? ?? ?? ?? 33 C0 55 68 A6 32 47 00 64 FF 30 64 89 20 EB 12 8D 45 FC B9 01 00 00 00 BA 01 00 00 00 E8 ?? ?? ?? ?? 8B 45 FC 0F B6 00 2C 2D 74 11 04 FD 2C 0A 72 0B 8B 45 FC E8 ?? ?? ?? ?? 48 7F D3 8D 45 E0 50 B9 01 00 00 00 BA 01 00 00 00 8B 45 FC E8 ?? ?? ?? ?? 8B 45 E0 BA BC 32 47 00 E8 ?? ?? ?? ?? 75 18 C6 45 E9 00 8D 45 FC B9 01 00 00 00 BA 01 00 00 00 E8 ?? ?? ?? ?? EB 18 C6 45 E9 01 }

	condition:
		any of them
}

rule FGint_ConvertBase256to64
{	meta:
		author = "_pusher_"
		date = "2015-05"
		description = "FGint ConvertBase256to64"
	strings:
		$c0 = { 55 8B EC 81 C4 EC FB FF FF 53 56 57 33 C9 89 8D EC FB FF FF 89 8D F0 FB FF FF 89 4D F8 8B FA 89 45 FC B9 00 01 00 00 8D 85 F4 FB FF FF 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8D 85 F4 FB FF FF BA FF 00 00 00 E8 ?? ?? ?? ?? 8D 45 F8 E8 ?? ?? ?? ?? 8B 45 FC E8 ?? ?? ?? ?? 8B D8 85 DB 7E 2F BE 01 00 00 00 8D 45 F8 8B 55 FC 0F B6 54 32 FF 8B 94 95 F4 FB FF FF E8 ?? ?? ?? ?? 46 4B 75 E5 EB }
	condition:
		$c0
}

rule FGint_ConvertHexStringToBase256String
{	meta:
		author = "_pusher_"
		date = "2015-06"
		version = "0.2"
		description = "FGint ConvertHexStringToBase256String"
	strings:
		$c0 = { 55 8B EC 83 C4 F0 53 56 33 C9 89 4D F0 89 55 F8 89 45 FC 8B 45 FC E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8B 45 F8 E8 ?? ?? ?? ?? 8B 45 FC E8 ?? ?? ?? ?? D1 F8 79 03 83 D0 00 85 C0 7E 5F 89 45 F4 BE 01 00 00 00 8B C6 03 C0 8B 55 FC 8A 54 02 FF 8B 4D FC 8A 44 01 FE 3C 3A 73 0A 8B D8 80 EB 30 C1 E3 04 EB 08 8B D8 80 EB 37 C1 E3 04 80 FA 3A 73 07 80 EA 30 0A DA EB 05 80 EA 37 0A DA 8D 45 F0 8B D3 }
	condition:
		$c0
}

rule FGint_Base256StringToGInt
{	meta:
		author = "_pusher_"
		date = "2015-05"
		description = "FGint Base256StringToGInt"
	strings:
		$c0 = { 55 8B EC 81 C4 F8 FB FF FF 53 56 57 33 C9 89 4D F8 8B FA 89 45 FC 8B 45 FC ?? ?? ?? ?? ?? B9 00 01 00 00 8D 85 F8 FB FF FF 8B 15 ?? ?? ?? ?? ?? ?? ?? ?? ?? 33 C0 55 ?? ?? ?? ?? ?? 64 FF 30 64 89 20 8D 45 F8 ?? ?? ?? ?? ?? 8D 85 F8 FB FF FF BA FF 00 00 00 ?? ?? ?? ?? ?? 8B 45 FC ?? ?? ?? ?? ?? 8B D8 85 DB 7E 34 BE 01 00 00 00 8D 45 F8 8B 55 FC 0F B6 54 32 FF 8B 94 95 F8 FB FF FF ?? ?? ?? ?? ?? 46 4B 75 E5 EB 12 8D 45 F8 B9 01 00 00 00 BA 01 00 00 00 ?? ?? ?? ?? ?? 8B 45 F8 80 38 30 75 0F }
	condition:
		$c0
}

rule FGint_FGIntToBase256String
{	meta:
		author = "_pusher_"
		date = "2015-06"
		version = "0.2"
		description = "FGint FGIntToBase256String"
	strings:
		$c0 = { 55 8B EC 33 C9 51 51 51 51 53 56 8B F2 33 D2 55 68 ?? ?? ?? ?? 64 FF 32 64 89 22 8D 55 FC E8 ?? ?? ?? ?? EB 10 8D 45 FC 8B 4D FC BA ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B 45 FC E8 ?? ?? ?? ?? 25 07 00 00 80 79 05 48 83 C8 F8 40 85 C0 75 D8 8B 45 FC E8 ?? ?? ?? ?? 8B D8 85 DB 79 03 83 C3 07 C1 FB 03 8B C6 E8 ?? ?? ?? ?? 85 DB 76 4B 8D 45 F4 50 B9 08 00 00 00 BA 01 00 00 00 8B 45 FC E8 ?? ?? ?? ?? 8B 55 F4 8D 45 FB E8 ?? ?? ?? ?? 8D 45 F0 8A 55 FB E8 ?? ?? ?? ?? 8B 55 F0 8B C6 E8 ?? ?? ?? ?? 8D 45 FC B9 08 00 00 00 BA 01 00 00 00 E8 ?? ?? ?? ?? 4B 75 B5 }
		$c1 = { 55 8B EC 33 C9 51 51 51 51 53 56 8B F2 33 D2 55 68 ?? ?? ?? ?? 64 FF 32 64 89 22 8D 55 FC E8 ?? ?? ?? ?? EB 10 8D 45 FC 8B 4D FC BA ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B 45 FC E8 ?? ?? ?? ?? 25 07 00 00 80 79 05 48 83 C8 F8 40 85 C0 75 D8 8B 45 FC 85 C0 74 05 83 E8 04 8B 00 8B D8 85 DB 79 03 83 C3 07 C1 FB 03 8B C6 E8 ?? ?? ?? ?? 85 DB 76 4C 8D 45 F4 50 B9 08 00 00 00 BA 01 00 00 00 8B 45 FC E8 ?? ?? ?? ?? 8B 55 F4 8D 45 FB E8 ?? ?? ?? ?? 8D 45 F0 0F B6 55 FB E8 ?? ?? ?? ?? 8B 55 F0 8B C6 E8 ?? ?? ?? ?? 8D 45 FC B9 08 00 00 00 BA 01 00 00 00 E8 }
	condition:
		any of them
}

rule FGint_ConvertBase256StringToHexString
{	meta:
		author = "_pusher_"
		date = "2015-05"
		description = "FGint ConvertBase256StringToHexString"
	strings:
		$c0 = { 55 8B EC 33 C9 51 51 51 51 51 51 53 56 57 8B F2 89 45 FC 8B 45 FC E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8B C6 E8 ?? ?? ?? ?? 8B 45 FC E8 ?? ?? ?? ?? 8B F8 85 FF 0F 8E AB 00 00 00 C7 45 F8 01 00 00 00 8B 45 FC 8B 55 F8 8A 5C 10 FF 33 C0 8A C3 C1 E8 04 83 F8 0A 73 1E 8D 45 F4 33 D2 8A D3 C1 EA 04 83 C2 30 E8 ?? ?? ?? ?? 8B 55 F4 8B C6 E8 ?? ?? ?? ?? EB 1C 8D 45 F0 33 D2 8A D3 C1 EA 04 83 C2 37 E8 ?? ?? ?? ?? 8B 55 F0 8B C6 E8 ?? ?? ?? ?? 8B C3 24 0F 3C 0A 73 22 8D 45 EC 8B D3 80 E2 0F 81 E2 FF 00 00 00 83 C2 30 E8 ?? ?? ?? ?? 8B 55 EC 8B C6 E8 ?? ?? ?? ?? EB 20 8D 45 E8 8B D3 80 E2 0F 81 E2 FF 00 00 00 83 C2 37 }
	condition:
		$c0
}


rule FGint_PGPConvertBase256to64
{	meta:
		author = "_pusher_"
		date = "2016-08"
		description = "FGint PGPConvertBase256to64"
	strings:
		$c0 = { 55 8B EC 81 C4 E8 FB FF FF 53 56 57 33 C9 89 8D E8 FB FF FF 89 4D F8 89 4D F4 89 4D F0 8B FA 89 45 FC B9 00 01 00 00 8D 85 EC FB FF FF 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8D 85 EC FB FF FF BA FF 00 00 00 E8 ?? ?? ?? ?? 8D 45 F8 E8 ?? ?? ?? ?? 8B 45 FC 8B 00 E8 ?? ?? ?? ?? 8B D8 85 DB 7E 22 BE 01 00 00 00 8D 45 F8 8B 55 FC 8B 12 0F B6 54 32 FF 8B 94 95 EC FB FF FF E8 ?? ?? ?? ?? 46 4B 75 E3 8B 45 F8 E8 ?? ?? ?? ?? B9 06 00 00 00 99 F7 F9 85 D2 75 0A 8D 45 F0 E8 ?? ?? ?? ?? EB 4B 8B 45 F8 E8 ?? ?? ?? ?? B9 06 00 00 00 99 F7 F9 83 FA 04 75 1C 8D 45 F8 BA 4C 33 40 00 E8 ?? ?? ?? ?? 8D 45 F0 BA 58 33 40 00 E8 ?? ?? ?? ?? EB 1A 8D 45 F8 BA ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 F0 BA ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B C7 E8 ?? ?? ?? ?? 8B 45 F8 E8 ?? ?? ?? ?? B9 06 00 00 00 99 F7 F9 8B D8 85 DB 7E 57 8D 45 F4 50 B9 06 00 00 00 BA 01 00 00 00 8B 45 F8 E8 ?? ?? ?? ?? 8D 45 EC 8B 55 F4 E8 ?? ?? ?? ?? 8D 85 E8 FB FF FF 8B 55 EC 8A 92 ?? ?? ?? ?? E8 }
	condition:
		$c0
}


rule FGint_RSAEncrypt
{	meta:
		author = "_pusher_"
		date = "2015-05"
		description = "FGint RSAEncrypt"
	strings:
		$c0 = { 55 8B EC 83 C4 D0 53 56 57 33 DB 89 5D D0 89 5D DC 89 5D D8 89 5D D4 8B F9 89 55 F8 89 45 FC 8B 45 FC E8 ?? ?? ?? ?? 8D 45 F0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8D 55 E0 B8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 55 DC 8B C7 E8 ?? ?? ?? ?? 8B 45 DC E8 ?? ?? ?? ?? 8B D8 8D 55 DC 8B 45 FC E8 ?? ?? ?? ?? 8D 45 DC 8B 4D DC BA ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B F3 4E EB 10 }
	condition:
		$c0
}

rule FGint_RsaDecrypt
{	meta:
		author = "Maxx"
		description = "FGint RsaDecrypt"
	strings:
		$c0 = { 55 8B EC 83 C4 A0 53 56 57 33 DB 89 5D A0 89 5D A4 89 5D A8 89 5D B4 89 5D B0 89 5D AC 89 4D F8 8B FA 89 45 FC 8B 45 FC E8 ?? ?? ?? ?? 8D 45 F0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 C8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 C0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 B8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 }
	condition:
		$c0
}

rule FGint_RSAVerify
{	meta:
		author = "_pusher_"
		description = "FGint RSAVerify"
	strings:
		$c0 = { 55 8B EC 83 C4 E0 53 56 8B F1 89 55 F8 89 45 FC 8B 5D 0C 8B 45 FC E8 ?? ?? ?? ?? 8B 45 F8 E8 ?? ?? ?? ?? 8D 45 F0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8D 55 E8 8B 45 F8 E8 ?? ?? ?? ?? 8D 55 F0 8B 45 FC E8 ?? ?? ?? ?? 8D 4D E0 8B D3 8D 45 F0 E8 ?? ?? ?? ?? 8D 55 F0 8D 45 E0 E8 ?? ?? ?? ?? 8D 45 E0 50 8B CB 8B D6 8D 45 E8 E8 ?? ?? ?? ?? 8D 55 E8 8D 45 E0 E8 ?? ?? ?? ?? 8D 55 F0 8D 45 E8 E8 ?? ?? ?? ?? 3C 02 8B 45 08 0F 94 00 8D 45 E8 E8 ?? ?? ?? ?? 8D 45 F0 E8 ?? ?? ?? ?? 33 C0 5A 59 59 64 89 10 68 ?? ?? ?? ?? 8D 45 E0 8B 15 ?? ?? ?? ?? B9 03 00 00 00 E8 ?? ?? ?? ?? 8D 45 F8 BA 02 00 00 00 E8 ?? ?? ?? ?? C3 }
	condition:
		$c0
}

rule FGint_FindPrimeGoodCurveAndPoint
{	meta:
		author = "_pusher_"
		date = "2015-06"
		description = "FGint FindPrimeGoodCurveAndPoint"
		version = "0.1"
	strings:
		$c0 = { 55 8B EC 83 C4 F4 53 56 57 33 DB 89 5D F4 89 4D FC 8B FA 8B F0 33 C0 55 }
	condition:
		$c0
}

rule FGint_ECElGamalEncrypt
{	meta:
		author = "_pusher_"
		date = "2016-08"
		description = "FGint ECElGamalEncrypt"
		version = "0.1"
	strings:
		$c0 = { 55 8B EC 81 C4 3C FF FF FF 53 56 57 33 DB 89 5D D8 89 5D D4 89 5D D0 8B 75 10 8D 7D 8C A5 A5 A5 A5 A5 8B 75 14 8D 7D A0 A5 A5 A5 A5 A5 8B 75 18 8D 7D DC A5 A5 8B 75 1C 8D 7D E4 A5 A5 8B F1 8D 7D EC A5 A5 8B F2 8D 7D F4 A5 A5 89 45 FC 8B 45 FC E8 ?? ?? ?? ?? 8D 45 F4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 EC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 DC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 A0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 8C 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 85 78 FF FF FF 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 85 64 FF FF FF 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 85 50 FF FF FF 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 85 3C FF FF FF 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 C4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 BC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 B4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 7D CF }
		$c1 = { 55 8B EC 83 C4 A8 53 56 57 33 DB 89 5D A8 89 5D AC 89 5D BC 89 5D B8 89 5D B4 89 4D F4 89 55 F8 89 45 FC 8B 75 0C 8B 45 FC E8 ?? ?? ?? ?? 8D 45 E8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 C8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 C0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 71 14 41 00 64 FF 30 64 89 20 8D 55 BC 8B C6 E8 ?? ?? ?? ?? 8B 45 BC E8 ?? ?? ?? ?? 8B D8 8D 55 BC 8B 45 FC E8 ?? ?? ?? ?? 8D 45 BC 8B 4D BC BA 8C 14 41 00 E8 ?? ?? ?? ?? 8B FB 4F EB 10 8D 45 BC 8B 4D BC BA 98 14 41 00 E8 ?? ?? ?? ?? 8B 45 BC }
	condition:
		$c0 or $c1
}

rule FGint_ECAddPoints
{	meta:
		author = "_pusher_"
		date = "2015-06"
		description = "FGint ECAddPoints"
		version = "0.1"
	strings:
		$c0 = { 55 8B EC 83 C4 A8 53 56 57 8B 75 0C 8D 7D F0 A5 A5 8B F1 8D 7D F8 A5 A5 8B F2 8D 7D A8 A5 A5 A5 A5 A5 8B F0 8D 7D BC A5 A5 A5 A5 A5 8B 5D 08 8D 45 BC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 A8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 F8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 F0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D8 8B 15 ?? ?? ?? ?? E8 }
	condition:
		$c0
}

rule FGint_ECPointKMultiple
{	meta:
		author = "_pusher_"
		date = "2015-06"
		description = "FGint ECPointKMultiple"
		version = "0.1"
	strings:
		$c0 = { 55 8B EC 83 C4 BC 53 56 57 33 DB 89 5D E4 8B 75 0C 8D 7D E8 A5 A5 8B F1 8D 7D F0 A5 A5 8B F2 8D 7D F8 A5 A5 8B F0 8D 7D D0 A5 A5 A5 A5 A5 8B 5D 08 8D 45 D0 8B 15 ?? ?? ?? 00 E8 ?? ?? ?? ?? 8D 45 F8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 F0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 BC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 }
	condition:
		$c0
}

rule FGint_ECPointDestroy
{	meta:
		author = "_pusher_"
		date = "2015-06"
		description = "FGint ECPointDestroy"
		version = "0.1"
	strings:
		$c0 = { 53 8B D8 8B C3 E8 ?? ?? ?? ?? 8D 43 08 E8 ?? ?? ?? ?? 5B C3 }
	condition:
		$c0
}

rule FGint_DSAPrimeSearch
{	meta:
		author = "_pusher_"
		date = "2016-08"
		description = "FGint DSAPrimeSearch"
		version = "0.1"
	strings:
		$c0 = { 55 8B EC 83 C4 DC 53 56 8B DA 8B F0 8D 45 F8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 F0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8D 4D F8 8B D6 8B C6 E8 ?? ?? ?? ?? 8D 4D E8 8B D6 8B C3 E8 ?? ?? ?? ?? 8D 55 F0 B8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 4D E0 8D 55 E8 8B C3 E8 ?? ?? ?? ?? 8D 45 E8 E8 ?? ?? ?? ?? 8D 4D E8 8D 55 F0 8D 45 E0 E8 ?? ?? ?? ?? 8D 45 E0 E8 ?? ?? ?? ?? 8D 45 F0 E8 ?? ?? ?? ?? 8B 45 EC 8B 40 04 83 E0 01 85 C0 75 18 8D 4D E0 8B D6 8D 45 E8 E8 ?? ?? ?? ?? 8D 55 E8 8D 45 E0 E8 ?? ?? ?? ?? 8B D3 8D 45 E8 E8 ?? ?? ?? ?? C6 45 DF 00 EB 26 8D 4D E8 8D 55 F8 8B C3 E8 ?? ?? ?? ?? 8B D3 8D 45 E8 E8 ?? ?? ?? ?? 8D 4D DF 8B C3 BA 05 00 00 00 E8 ?? ?? ?? ?? 80 7D DF 00 74 D4 8D 45 F8 E8 ?? ?? ?? ?? 33 C0 5A 59 59 64 89 10 68 ?? ?? ?? ?? 8D 45 E0 8B 15 ?? ?? ?? ?? B9 04 00 00 00 E8 ?? ?? ?? ?? C3 }
	condition:
		$c0
}

rule FGint_DSASign
{	meta:
		author = "_pusher_"
		date = "2016-08"
		description = "FGint DSASign"
		version = "0.1"
	strings:
		$c0 = { 55 8B EC 83 C4 CC 53 56 57 89 4D FC 8B DA 8B F8 8B 75 14 8B 45 10 E8 ?? ?? ?? ?? 8D 45 F4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 EC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 DC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 CC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8D 45 F4 50 8B CF 8B D6 8B 45 FC E8 ?? ?? ?? ?? 8D 4D D4 8B D3 8D 45 F4 E8 ?? ?? ?? ?? 8D 45 F4 E8 ?? ?? ?? ?? 8D 4D F4 8B D3 8B C6 E8 ?? ?? ?? ?? 8D 55 EC 8B 45 10 E8 ?? ?? ?? ?? 8D 45 E4 50 8B CB 8D 55 D4 8B 45 18 E8 ?? ?? ?? ?? 8D 4D DC 8D 55 E4 8D 45 EC E8 ?? ?? ?? ?? 8D 45 EC E8 ?? ?? ?? ?? 8D 45 E4 E8 ?? ?? ?? ?? 8D 45 CC 50 8B CB 8D 55 DC 8D 45 F4 E8 ?? ?? ?? ?? 8D 45 F4 E8 ?? ?? ?? ?? 8D 45 DC E8 ?? ?? ?? ?? 8B 55 0C 8D 45 D4 E8 ?? ?? ?? ?? 8B 55 08 8D 45 CC E8 ?? ?? ?? ?? 8D 45 D4 E8 ?? ?? ?? ?? 8D 45 CC E8 ?? ?? ?? ?? 33 C0 5A 59 59 64 89 10 68 ?? ?? ?? ?? 8D 45 CC 8B 15 ?? ?? ?? ?? B9 06 00 00 00 E8 }
	condition:
		$c0
}

rule FGint_DSAVerify
{	meta:
		author = "_pusher_"
		date = "2016-08"
		description = "FGint DSAVerify"
		version = "0.1"
	strings:
		$c0 = { 55 8B EC 83 C4 B4 53 56 57 89 4D FC 8B DA 8B F0 8B 7D 08 8B 45 14 E8 ?? ?? ?? ?? 8B 45 10 E8 ?? ?? ?? ?? 8B 45 0C E8 ?? ?? ?? ?? 8D 45 F4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 EC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 DC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 CC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 C4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 BC 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 B4 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8D 55 CC 8B 45 0C E8 ?? ?? ?? ?? 8D 4D F4 8B D3 8D 45 CC E8 ?? ?? ?? ?? 8D 55 C4 8B 45 14 E8 ?? ?? ?? ?? 8D 45 EC 50 8B CB 8D 55 F4 8D 45 C4 E8 ?? ?? ?? ?? 8D 45 C4 E8 ?? ?? ?? ?? 8D 55 D4 8B 45 10 E8 ?? ?? ?? ?? 8D 45 E4 50 8B CB 8D 55 F4 8D 45 D4 E8 ?? ?? ?? ?? 8D 45 F4 E8 ?? ?? ?? ?? 8D 45 C4 50 8B CE 8D 55 EC 8B 45 FC E8 ?? ?? ?? ?? 8D 45 BC 50 8B CE 8D 55 E4 8B 45 18 E8 ?? ?? ?? ?? 8D 45 B4 50 8B CE 8D 55 BC 8D 45 C4 E8 ?? ?? ?? ?? 8D 45 C4 E8 }
	condition:
		$c0
}


rule DES_Long
{	meta:
		author = "_pusher_"
		date = "2015-05"
		description = "DES [long]"
	strings:
		$c0 = { 10 80 10 40 00 00 00 00 00 80 10 00 00 00 10 40 10 00 00 40 10 80 00 00 00 80 00 40 00 80 10 00 00 80 00 00 10 00 10 40 10 00 00 00 00 80 00 40 10 00 10 00 00 80 10 40 00 00 10 40 10 00 00 00 }
	condition:
		$c0
}

rule DES_sbox
{	meta:
		author = "_pusher_"
		date = "2015-05"
		description = "DES [sbox]"
	strings:
		$c0 = { 00 04 01 01 00 00 00 00 00 00 01 00 04 04 01 01 04 00 01 01 04 04 01 00 04 00 00 00 00 00 01 00 00 04 00 00 00 04 01 01 04 04 01 01 00 04 00 00 04 04 00 01 04 00 01 01 00 00 00 01 04 00 00 00 }
	condition:
		$c0
}

rule DES_pbox_long
{	meta:
		author = "_pusher_"
		date = "2015-05"
		description = "DES [pbox] [long]"
	strings:
		$c0 = { 0F 00 00 00 06 00 00 00 13 00 00 00 14 00 00 00 1C 00 00 00 0B 00 00 00 1B 00 00 00 10 00 00 00 00 00 00 00 0E 00 00 00 16 00 00 00 19 00 00 00 04 00 00 00 11 00 00 00 1E 00 00 00 09 00 00 00 01 00 00 00 07 00 00 00 17 00 00 00 0D 00 00 00 1F 00 00 00 1A 00 00 00 02 00 00 00 08 00 00 00 12 00 00 00 0C 00 00 00 1D 00 00 00 05 00 00 00 }
	condition:
		$c0
}

rule OpenSSL_BN_mod_exp2_mont
{	meta:
		author = "Maxx"
		description = "OpenSSL BN_mod_exp2_mont"
	strings:
		$c0 = { B8 30 05 00 00 E8 ?? ?? ?? ?? 8B 84 24 48 05 00 00 53 33 DB 56 8B 08 57 89 5C 24 24 89 5C 24 30 8A 01 89 5C 24 28 A8 01 89 5C 24 0C 75 24 68 89 00 00 00 68 ?? ?? ?? ?? 6A 66 6A 76 6A 03 E8 ?? ?? ?? ?? 83 C4 14 33 C0 5F 5E 5B 81 C4 30 05 00 00 C3 8B 94 24 48 05 00 00 52 E8 ?? ?? ?? ?? 8B F0 8B 84 24 54 05 00 00 50 E8 ?? ?? ?? ?? 83 C4 08 3B F3 8B F8 75 20 3B FB 75 1C 8B 8C 24 40 05 00 00 6A 01 51 E8 ?? ?? ?? ?? 83 C4 08 5F 5E 5B 81 C4 30 05 00 00 C3 3B F7 89 74 24 18 7F 04 89 }
	condition:
		$c0
}

rule OpenSSL_BN_mod_exp_mont
{	meta:
		author = "Maxx"
		description = "OpenSSL BN_mod_exp_mont"
	strings:
		$c0 = { B8 A0 02 00 00 E8 ?? ?? ?? ?? 53 56 57 8B BC 24 BC 02 00 00 33 F6 8B 07 89 74 24 24 89 74 24 20 89 74 24 0C F6 00 01 75 24 68 72 01 00 00 68 ?? ?? ?? ?? 6A 66 6A 6D 6A 03 E8 ?? ?? ?? ?? 83 C4 14 33 C0 5F 5E 5B 81 C4 A0 02 00 00 C3 8B 8C 24 B8 02 00 00 51 E8 ?? ?? ?? ?? 8B D8 83 C4 04 3B DE 89 5C 24 18 75 1C 8B 94 24 B0 02 00 00 6A 01 52 E8 ?? ?? ?? ?? 83 C4 08 5F 5E 5B 81 C4 A0 02 00 00 C3 55 8B AC 24 C4 02 00 00 55 E8 ?? ?? ?? ?? 55 E8 ?? ?? ?? ?? 8B F0 55 89 74 24 24 E8 }
	condition:
		$c0
}

rule OpenSSL_BN_mod_exp_recp
{	meta:
		author = "Maxx"
		description = "OpenSSL BN_mod_exp_recp"
	strings:
		$c0 = { B8 C8 02 00 00 E8 ?? ?? ?? ?? 8B 84 24 D4 02 00 00 55 56 33 F6 50 89 74 24 1C 89 74 24 18 E8 ?? ?? ?? ?? 8B E8 83 C4 04 3B EE 89 6C 24 0C 75 1B 8B 8C 24 D4 02 00 00 6A 01 51 E8 ?? ?? ?? ?? 83 C4 08 5E 5D 81 C4 C8 02 00 00 C3 53 57 8B BC 24 EC 02 00 00 57 E8 ?? ?? ?? ?? 57 E8 ?? ?? ?? ?? 8B D8 83 C4 08 3B DE 0F 84 E7 02 00 00 8D 54 24 24 52 E8 ?? ?? ?? ?? 8B B4 24 EC 02 00 00 83 C4 04 8B 46 0C 85 C0 74 32 56 53 E8 ?? ?? ?? ?? 83 C4 08 85 C0 0F 84 BA 02 00 00 57 8D 44 24 28 53 }
	condition:
		$c0
}

rule OpenSSL_BN_mod_exp_simple
{	meta:
		author = "Maxx"
		description = "OpenSSL BN_mod_exp_simple"
	strings:
		$c0 = { B8 98 02 00 00 E8 ?? ?? ?? ?? 8B 84 24 A4 02 00 00 55 56 33 ED 50 89 6C 24 1C 89 6C 24 18 E8 ?? ?? ?? ?? 8B F0 83 C4 04 3B F5 89 74 24 0C 75 1B 8B 8C 24 A4 02 00 00 6A 01 51 E8 ?? ?? ?? ?? 83 C4 08 5E 5D 81 C4 98 02 00 00 C3 53 57 8B BC 24 BC 02 00 00 57 E8 ?? ?? ?? ?? 57 E8 ?? ?? ?? ?? 8B D8 83 C4 08 3B DD 0F 84 71 02 00 00 8D 54 24 28 52 E8 ?? ?? ?? ?? 8B AC 24 BC 02 00 00 8B 84 24 B4 02 00 00 57 55 8D 4C 24 34 50 51 C7 44 24 30 01 00 00 00 E8 ?? ?? ?? ?? 83 C4 14 85 C0 0F }
	condition:
		$c0
}

rule OpenSSL_BN_mod_exp_inverse
{	meta:
		author = "Maxx"
		description = "OpenSSL BN_mod_exp_inverse"
	strings:
		$c0 = { B8 18 00 00 00 E8 ?? ?? ?? ?? 53 55 56 57 8B 7C 24 38 33 C0 57 89 44 24 20 89 44 24 24 E8 ?? ?? ?? ?? 57 E8 ?? ?? ?? ?? 57 89 44 24 1C E8 ?? ?? ?? ?? 57 8B F0 E8 ?? ?? ?? ?? 57 89 44 24 28 E8 ?? ?? ?? ?? 57 8B E8 E8 ?? ?? ?? ?? 57 8B D8 E8 ?? ?? ?? ?? 8B F8 8B 44 24 54 50 89 7C 24 38 E8 ?? ?? ?? ?? 83 C4 20 89 44 24 24 85 C0 8B 44 24 2C 0F 84 78 05 00 00 85 C0 75 05 E8 ?? ?? ?? ?? 85 C0 89 44 24 1C 0F 84 63 05 00 00 8B 4C 24 14 6A 01 51 E8 ?? ?? ?? ?? 6A 00 57 E8 }
	condition:
		$c0
}

rule OpenSSL_DSA
{
	meta:
		author="_pusher_"
		date="2016-08"
	strings:	
		$a0 = "bignum_data" wide ascii nocase
		$a1 = "DSA_METHOD" wide ascii nocase
		$a2 = "PDSA" wide ascii nocase
		$a3 = "dsa_mod_exp" wide ascii nocase
		$a4 = "bn_mod_exp" wide ascii nocase
		$a5 = "dsa_do_verify" wide ascii nocase
		$a6 = "dsa_sign_setup" wide ascii nocase
		$a7 = "dsa_do_sign" wide ascii nocase
		$a8 = "dsa_paramgen" wide ascii nocase
		$a9 = "BN_MONT_CTX" wide ascii nocase
	condition:
		7 of ($a*)
}

rule FGint_RsaSign
{	meta:
		author = "Maxx"
		description = "FGint RsaSign"
	strings:
		$c0 = { 55 8B EC 83 C4 B8 53 56 57 89 4D F8 8B FA 89 45 FC 8B 75 0C 8B 5D 10 8B 45 FC E8 ?? ?? ?? ?? 8D 45 F0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 E0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 D0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 C8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 C0 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 45 B8 8B 15 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8D 55 F0 }
	condition:
		$c0
}


rule LockBox_RsaEncryptFile
{	meta:
		author = "Maxx"
		description = "LockBox RsaEncryptFile"
	strings:
		$c0 = { 55 8B EC 83 C4 F8 53 56 8B F1 8B DA 6A 20 8B C8 B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? 89 45 FC 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 68 FF FF 00 00 8B CB B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? 89 45 F8 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8A 45 08 50 8B CE 8B 55 F8 8B 45 FC E8 ?? ?? ?? ?? 33 C0 5A 59 59 64 89 10 68 ?? ?? ?? ?? 8B 45 F8 E8 ?? ?? ?? ?? C3 }
	condition:
		$c0
}

rule LockBox_DecryptRsaEx
{	meta:
		author = "Maxx"
		description = "LockBox DecryptRsaEx"
	strings:
		$c0 = { 55 8B EC 83 C4 F4 53 56 57 89 4D F8 89 55 FC 8B D8 33 C0 8A 43 04 0F B7 34 45 ?? ?? ?? ?? 0F B7 3C 45 ?? ?? ?? ?? 8B CE B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? 89 45 F4 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8B 55 FC 8B CE 8B 45 F4 E8 ?? ?? ?? ?? 6A 00 B1 02 8B D3 8B 45 F4 E8 ?? ?? ?? ?? 8B 45 F4 E8 ?? ?? ?? ?? 3B C7 7E 16 B9 ?? ?? ?? ?? B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B 45 F4 E8 ?? ?? ?? ?? 8B C8 8B 55 F8 8B 45 F4 E8 ?? ?? ?? ?? 33 C0 5A 59 59 64 89 10 68 }
	condition:
		$c0
}

rule LockBox_EncryptRsaEx
{	meta:
		author = "Maxx"
		description = "LockBox EncryptRsaEx"
	strings:
		$c0 = { 55 8B EC 83 C4 F8 53 56 57 89 4D FC 8B FA 8B F0 33 C0 8A 46 04 0F B7 1C 45 ?? ?? ?? ?? 8B CB B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? 89 45 F8 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 8B D7 8B 4D 08 8B 45 F8 E8 ?? ?? ?? ?? 6A 01 B1 02 8B D6 8B 45 F8 E8 ?? ?? ?? ?? 8B 45 F8 E8 ?? ?? ?? ?? 3B C3 7E 16 B9 ?? ?? ?? ?? B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B 45 F8 E8 ?? ?? ?? ?? 8B C8 8B 55 FC 8B 45 F8 E8 ?? ?? ?? ?? 33 C0 5A 59 59 64 89 10 68 ?? ?? ?? ?? 8B 45 F8 E8 }
	condition:
		$c0
}

rule LockBox_TlbRsaKey
{	meta:
		author = "Maxx"
		description = "LockBox TlbRsaKey"
	strings:
		$c0 = { 53 56 84 D2 74 08 83 C4 F0 E8 ?? ?? ?? ?? 8B DA 8B F0 33 D2 8B C6 E8 ?? ?? ?? ?? 33 C0 8A 46 04 8B 15 ?? ?? ?? ?? 0F B7 0C 42 B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? 89 46 0C 33 C0 8A 46 04 8B 15 ?? ?? ?? ?? 0F B7 0C 42 B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? 89 46 10 8B C6 84 DB 74 0F E8 ?? ?? ?? ?? 64 8F 05 00 00 00 00 83 C4 0C 8B C6 5E 5B C3 }
	condition:
		$c0
}

rule BigDig_bpInit
{	meta:
		author = "Maxx"
		description = "BigDig bpInit"
	strings:
		$c0 = { 56 8B 74 24 0C 6A 04 56 E8 ?? ?? ?? ?? 8B C8 8B 44 24 10 83 C4 08 85 C9 89 08 75 04 33 C0 5E C3 89 70 08 C7 40 04 00 00 00 00 5E C3 }
	condition:
		$c0
}

rule BigDig_mpModExp
{	meta:
		author = "Maxx"
		description = "BigDig mpModExp"
	strings:
		$c0 = { 56 8B 74 24 18 85 F6 75 05 83 C8 FF 5E C3 53 55 8B 6C 24 18 57 56 55 E8 ?? ?? ?? ?? 8B D8 83 C4 08 BF 00 00 00 80 8B 44 9D FC 85 C7 75 04 D1 EF 75 F8 83 FF 01 75 08 BF 00 00 00 80 4B EB 02 D1 EF 8B 44 24 18 56 8B 74 24 18 50 56 E8 ?? ?? ?? ?? 83 C4 0C 85 DB 74 4F 8D 6C 9D FC 8B 4C 24 24 8B 54 24 20 51 52 56 56 56 E8 ?? ?? ?? ?? 8B 45 00 83 C4 14 85 C7 74 19 8B 44 24 24 8B 4C 24 20 8B 54 24 18 50 51 52 56 56 E8 ?? ?? ?? ?? 83 C4 14 83 FF 01 75 0B 4B BF 00 00 00 80 83 ED 04 EB }
	condition:
		$c0
}

rule BigDig_mpModInv
{	meta:
		author = "Maxx"
		description = "BigDig mpModInv"
	strings:
		$c0 = { 81 EC 2C 07 00 00 8D 84 24 CC 00 00 00 53 56 8B B4 24 44 07 00 00 57 56 6A 01 50 E8 ?? ?? ?? ?? 8B 8C 24 4C 07 00 00 56 8D 94 24 80 02 00 00 51 52 E8 ?? ?? ?? ?? 8D 84 24 BC 01 00 00 56 50 E8 ?? ?? ?? ?? 8B 9C 24 64 07 00 00 56 8D 4C 24 30 53 51 E8 ?? ?? ?? ?? 8D 54 24 38 56 52 BF 01 00 00 00 E8 ?? ?? ?? ?? 83 C4 34 85 C0 0F 85 ED 00 00 00 8D 44 24 0C 56 50 8D 8C 24 78 02 00 00 56 8D 94 24 48 03 00 00 51 8D 84 24 18 04 00 00 52 50 E8 ?? ?? ?? ?? 8D 8C 24 BC 01 00 00 56 8D 94 }
	condition:
		$c0
}

rule BigDig_mpModMult
{	meta:
		author = "Maxx"
		description = "BigDig mpModMult"
	strings:
		$c0 = { 8B 44 24 0C 8B 4C 24 08 81 EC 98 01 00 00 8D 54 24 00 56 8B B4 24 B0 01 00 00 57 56 50 51 52 E8 ?? ?? ?? ?? 8B 84 24 C0 01 00 00 8B 94 24 B4 01 00 00 8D 3C 36 56 50 8D 4C 24 20 57 51 52 E8 ?? ?? ?? ?? 8D 44 24 2C 57 50 E8 ?? ?? ?? ?? 83 C4 2C 33 C0 5F 5E 81 C4 98 01 00 00 C3 }
	condition:
		$c0
}

rule BigDig_mpModulo
{	meta:
		author = "Maxx"
		description = "BigDig mpModulo"
	strings:
		$c0 = { 8B 44 24 10 81 EC 30 03 00 00 8B 8C 24 38 03 00 00 8D 54 24 00 56 8B B4 24 40 03 00 00 57 8B BC 24 4C 03 00 00 57 50 56 51 8D 84 24 B0 01 00 00 52 50 E8 ?? ?? ?? ?? 8B 94 24 54 03 00 00 8D 4C 24 20 57 51 52 E8 ?? ?? ?? ?? 8D 44 24 2C 56 50 E8 ?? ?? ?? ?? 8D 8C 24 CC 01 00 00 56 51 E8 ?? ?? ?? ?? 83 C4 34 33 C0 5F 5E 81 C4 30 03 00 00 C3 }
	condition:
		$c0
}

rule BigDig_spModExpB
{	meta:
		author = "Maxx"
		description = "BigDig spModExpB"
	strings:
		$c0 = { 53 8B 5C 24 10 55 56 BE 00 00 00 80 85 F3 75 04 D1 EE 75 F8 8B 6C 24 14 8B C5 D1 EE 89 44 24 18 74 48 57 8B 7C 24 20 EB 04 8B 44 24 1C 57 50 50 8D 44 24 28 50 E8 ?? ?? ?? ?? 83 C4 10 85 F3 74 14 8B 4C 24 1C 57 55 8D 54 24 24 51 52 E8 ?? ?? ?? ?? 83 C4 10 D1 EE 75 D0 8B 44 24 14 8B 4C 24 1C 5F 5E 89 08 5D 33 C0 5B C3 8B 54 24 10 5E 5D 5B 89 02 33 C0 C3 }
	condition:
		$c0
}

rule BigDig_spModInv
{	meta:
		author = "Maxx"
		description = "BigDig spModInv"
	strings:
		$c0 = { 51 8B 4C 24 10 55 56 BD 01 00 00 00 33 F6 57 8B 7C 24 18 89 6C 24 0C 85 C9 74 42 53 8B C7 33 D2 F7 F1 8B C7 8B F9 8B DA 33 D2 F7 F1 8B CB 0F AF C6 03 C5 8B EE 8B F0 8B 44 24 10 F7 D8 85 DB 89 44 24 10 75 D7 85 C0 5B 7D 13 8B 44 24 1C 8B 4C 24 14 2B C5 5F 89 01 5E 33 C0 5D 59 C3 8B 54 24 14 5F 5E 33 C0 89 2A 5D 59 C3 }
	condition:
		$c0
}

rule BigDig_spModMult
{	meta:
		author = "Maxx"
		description = "BigDig spModMult"
	strings:
		$c0 = { 8B 44 24 0C 8B 4C 24 08 83 EC 08 8D 54 24 00 50 51 52 E8 ?? ?? ?? ?? 8B 44 24 24 6A 02 8D 4C 24 10 50 51 E8 ?? ?? ?? ?? 8B 54 24 24 89 02 33 C0 83 C4 20 C3 }
	condition:
		$c0
}

rule CryptoPP_ApplyFunction
{	meta:
		author = "Maxx"
		description = "CryptoPP ApplyFunction"
	strings:
		$c0 = { 51 8D 41 E4 56 8B 74 24 0C 83 C1 F0 50 51 8B 4C 24 18 C7 44 24 0C 00 00 00 00 51 56 E8 ?? ?? ?? ?? 83 C4 10 8B C6 5E 59 C2 08 00 }
		$c1 = { 51 53 56 8B F1 57 6A 00 C7 44 24 10 00 00 00 00 8B 46 04 8B 48 04 8B 5C 31 04 8D 7C 31 04 E8 ?? ?? ?? ?? 50 8B CF FF 53 10 8B 44 24 18 8D 56 08 83 C6 1C 52 56 8B 74 24 1C 50 56 E8 ?? ?? ?? ?? 83 C4 10 8B C6 5F 5E 5B 59 C2 08 00 }
	condition:
		any of them
}

rule CryptoPP_RsaFunction
{	meta:
		author = "Maxx"
		description = "CryptoPP RsaFunction"
	strings:
		$c0 = { 6A FF 68 ?? ?? ?? ?? 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 81 EC 9C 00 00 00 8B 84 24 B0 00 00 00 53 55 56 33 ED 8B F1 57 3B C5 89 B4 24 A8 00 00 00 89 6C 24 10 BF 01 00 00 00 74 18 C7 06 ?? ?? ?? ?? C7 46 20 ?? ?? ?? ?? 89 7C 24 10 89 AC 24 B4 00 00 00 8D 4E 04 E8 ?? ?? ?? ?? 8D 4E 10 89 BC 24 B4 00 00 00 E8 ?? ?? ?? ?? 8B 06 BB ?? ?? ?? ?? BF ?? ?? ?? ?? 8B 48 04 C7 04 31 ?? ?? ?? ?? 8B 16 8B 42 04 8B 54 24 10 83 CA 02 8D 48 E0 89 54 24 10 89 4C 30 FC 89 5C 24 18 89 7C }
		$c1 = { 6A FF 68 ?? ?? ?? ?? 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 08 8B 44 24 1C 53 8B 5C 24 1C 56 8B F1 57 33 C9 89 74 24 10 3B C1 89 4C 24 0C 74 7B C7 46 04 ?? ?? ?? ?? C7 46 3C ?? ?? ?? ?? C7 46 30 ?? ?? ?? ?? C7 46 34 ?? ?? ?? ?? 3B D9 75 06 89 4C 24 28 EB 0E 8B 43 04 8B 50 0C 8D 44 1A 04 89 44 24 28 8B 56 3C C7 44 24 0C 07 00 00 00 8B 42 04 C7 44 30 3C ?? ?? ?? ?? 8B 56 3C 8B 42 08 C7 44 30 3C ?? ?? ?? ?? 8B 56 3C C7 46 38 ?? ?? ?? ?? 8B 42 04 C7 44 30 3C }
		$c2 = { 6A FF 68 ?? ?? ?? ?? 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 08 8B 44 24 18 56 8B F1 57 85 C0 89 74 24 0C C7 44 24 08 00 00 00 00 74 63 C7 46 04 ?? ?? ?? ?? C7 46 3C ?? ?? ?? ?? C7 46 30 ?? ?? ?? ?? C7 46 34 ?? ?? ?? ?? 8B 46 3C C7 44 24 08 07 00 00 00 8B 48 04 C7 44 31 3C ?? ?? ?? ?? 8B 56 3C 8B 42 08 C7 44 30 3C ?? ?? ?? ?? 8B 4E 3C C7 46 38 ?? ?? ?? ?? 8B 51 04 C7 44 32 3C ?? ?? ?? ?? 8B 46 3C 8B 48 08 C7 44 31 3C ?? ?? ?? ?? C7 06 ?? ?? ?? ?? 8D 7E 04 6A 00 8B CF }
	condition:
		any of them
}

rule CryptoPP_Integer_constructor
{	meta:
		author = "Maxx"
		description = "CryptoPP Integer constructor"
	strings:
		$c0 = { 8B 44 24 08 56 83 F8 08 8B F1 77 09 8B 14 85 ?? ?? ?? ?? EB 37 83 F8 10 77 07 BA 10 00 00 00 EB 2B 83 F8 20 77 07 BA 20 00 00 00 EB 1F 83 F8 40 77 07 BA 40 00 00 00 EB 13 48 50 E8 ?? ?? ?? ?? BA 01 00 00 00 8B C8 83 C4 04 D3 E2 8D 04 95 00 00 00 00 89 16 50 E8 ?? ?? ?? ?? 8B 4C 24 0C 89 46 04 C7 46 08 00 00 00 00 89 08 8B 0E 8B 46 04 83 C4 04 49 74 0F 57 8D 78 04 33 C0 F3 AB 8B C6 5F 5E C2 08 00 8B C6 5E C2 08 00 }
		$c1 = { 6A FF 68 ?? ?? ?? ?? 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 51 56 8B F1 89 74 24 04 C7 06 ?? ?? ?? ?? 6A 08 C7 44 24 14 00 00 00 00 C7 46 08 02 00 00 00 E8 ?? ?? ?? ?? 89 46 0C C7 46 10 00 00 00 00 C7 06 ?? ?? ?? ?? 8B 46 0C 83 C4 04 C7 40 04 00 00 00 00 8B 4E 0C 8B C6 5E C7 01 00 00 00 00 8B 4C 24 04 64 89 0D 00 00 00 00 83 C4 10 C3 }
		$c2 = { 6A FF 68 ?? ?? ?? ?? 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 51 56 8B F1 57 89 74 24 08 C7 06 ?? ?? ?? ?? 8B 7C 24 1C C7 44 24 14 00 00 00 00 8B CF E8 ?? ?? ?? ?? 83 F8 08 77 09 8B 14 85 ?? ?? ?? ?? EB 37 83 F8 10 77 07 BA 10 00 00 00 EB 2B 83 F8 20 77 07 BA 20 00 00 00 EB 1F 83 F8 40 77 07 BA 40 00 00 00 EB 13 48 50 E8 ?? ?? ?? ?? BA 01 00 00 00 8B C8 83 C4 04 D3 E2 85 D2 89 56 08 76 12 8D 04 95 00 00 00 00 50 E8 ?? ?? ?? ?? 83 C4 04 EB 02 33 C0 89 46 0C 8B 4F 10 89 4E 10 }
		$c3 = { 56 57 8B 7C 24 0C 8B F1 8B CF E8 ?? ?? ?? ?? 83 F8 08 77 09 8B 14 85 ?? ?? ?? ?? EB 37 83 F8 10 77 07 BA 10 00 00 00 EB 2B 83 F8 20 77 07 BA 20 00 00 00 EB 1F 83 F8 40 77 07 BA 40 00 00 00 EB 13 48 50 E8 ?? ?? ?? ?? BA 01 00 00 00 8B C8 83 C4 04 D3 E2 8D 04 95 00 00 00 00 89 16 50 E8 ?? ?? ?? ?? 8B 16 89 46 04 8B 4F 08 83 C4 04 89 4E 08 8B 4F 04 85 D2 76 0D 2B C8 8B 3C 01 89 38 83 C0 04 4A 75 F5 8B C6 5F 5E C2 04 00 }
	condition:
		any of them
}

rule RijnDael_AES
{	meta:
		author = "_pusher_"
		description = "RijnDael AES"
		date = "2016-06"
	strings:
		$c0 = { A5 63 63 C6 84 7C 7C F8 }
	condition:
		$c0
}

rule RijnDael_AES_CHAR
{	meta:
		author = "_pusher_"
		description = "RijnDael AES (check2) [char]"
		date = "2016-06"
	strings:
		$c0 = { 63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76 CA 82 C9 7D FA 59 47 F0 AD D4 A2 AF 9C A4 72 C0 }
	condition:
		$c0
}

rule RijnDael_AES_CHAR_inv
{	meta:
		author = "_pusher_"
		description = "RijnDael AES S-inv [char]"
		//needs improvement
		date = "2016-07"
	strings:
		$c0 = { 48 38 47 00 88 17 33 D2 8A 56 0D 8A 92 48 38 47 00 88 57 01 33 D2 8A 56 0A 8A 92 48 38 47 00 88 57 02 33 D2 8A 56 07 8A 92 48 38 47 00 88 57 03 33 D2 8A 56 04 8A 92 }
	condition:
		$c0
}

rule RijnDael_AES_LONG
{	meta:
		author = "_pusher_"
		description = "RijnDael AES"
		date = "2016-06"
	strings:
		$c0 = { 63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76 CA 82 C9 7D FA 59 47 F0 AD D4 A2 AF 9C A4 72 C0 }
	condition:
		$c0
}

rule RijnDael_AES_LONG_inv
{	meta:
		author = "edeca"
		description = "RijnDael AES"
		date = "2019-10"
	strings:
		$c0 = { 52 09 6A D5 30 36 A5 38 BF 40 A3 9E 81 F3 D7 FB 7C E3 39 82 9B 2F FF 87 34 8E 43 44 C4 DE E9 CB }
	condition:
		$c0
}

rule RijnDael_AES_RCON
{	meta:
		author = "edeca"
		description = "RijnDael AES round constants"
		date = "2019-10"
	strings:
		$c0 = { 8D 01 02 04 08 10 20 40 80 1B 36 6C D8 AB 4D 9A }
	condition:
		$c0
}

rule RsaRef2_NN_modExp
{	meta:
		author = "Maxx"
		description = "RsaRef2 NN_modExp"
	strings:
		$c0 = { 81 EC 1C 02 00 00 53 55 56 8B B4 24 30 02 00 00 57 8B BC 24 44 02 00 00 57 8D 84 24 A4 00 00 00 56 50 E8 ?? ?? ?? ?? 8B 9C 24 4C 02 00 00 57 53 8D 8C 24 B4 00 00 00 56 8D 94 24 3C 01 00 00 51 52 E8 ?? ?? ?? ?? 57 53 8D 84 24 4C 01 00 00 56 8D 8C 24 D4 01 00 00 50 51 E8 ?? ?? ?? ?? 8D 54 24 50 57 52 E8 ?? ?? ?? ?? 8B 84 24 78 02 00 00 8B B4 24 74 02 00 00 50 56 C7 44 24 60 01 00 00 00 E8 ?? ?? ?? ?? 8D 48 FF 83 C4 44 8B E9 89 4C 24 18 85 ED 0F 8C AF 00 00 00 8D 34 AE 89 74 24 }
	condition:
		any of them
}

rule RsaRef2_NN_modInv
{	meta:
		author = "Maxx"
		description = "RsaRef2 NN_modInv"
	strings:
		$c0 = { 81 EC A4 04 00 00 53 56 8B B4 24 BC 04 00 00 57 8D 84 24 ?? 00 00 00 56 50 E8 ?? ?? ?? ?? 8D 8C 24 1C 01 00 00 BF 01 00 00 00 56 51 89 BC 24 A0 00 00 00 E8 ?? ?? ?? ?? 8B 94 24 C8 04 00 00 56 8D 84 24 AC 01 00 00 52 50 E8 ?? ?? ?? ?? 8B 9C 24 D8 04 00 00 56 8D 4C 24 2C 53 51 E8 ?? ?? ?? ?? 8D 54 24 34 56 52 E8 ?? ?? ?? ?? 83 C4 30 85 C0 0F 85 ED 00 00 00 8D 44 24 0C 56 50 8D 8C 24 A0 01 00 00 56 8D 94 24 AC 02 00 00 51 8D 84 24 34 03 00 00 52 50 E8 ?? ?? ?? ?? 8D 8C 24 2C 01 }
	condition:
		$c0
}

rule RsaRef2_NN_modMult
{	meta:
		author = "Maxx"
		description = "RsaRef2 NN_modMult"
	strings:
		$c0 = { 8B 44 24 0C 8B 4C 24 08 81 EC 08 01 00 00 8D 54 24 00 56 8B B4 24 20 01 00 00 56 50 51 52 E8 ?? ?? ?? ?? 8B 84 24 2C 01 00 00 56 8D 0C 36 50 8B 84 24 28 01 00 00 8D 54 24 1C 51 52 50 E8 ?? ?? ?? ?? 68 08 01 00 00 8D 4C 24 2C 6A 00 51 E8 ?? ?? ?? ?? 83 C4 30 5E 81 C4 08 01 00 00 C3 }
	condition:
		$c0
}

rule RsaRef2_RsaPrivateDecrypt
{	meta:
		author = "Maxx"
		description = "RsaRef2 RsaPrivateDecrypt"
	strings:
		$c0 = { 8B 44 24 14 81 EC 84 00 00 00 8B 8C 24 94 00 00 00 56 8B 30 83 C6 07 C1 EE 03 3B CE 76 0D B8 06 04 00 00 5E 81 C4 84 00 00 00 C3 50 8B 84 24 98 00 00 00 51 8D 4C 24 0C 50 8D 54 24 14 51 52 E8 ?? ?? ?? ?? 83 C4 14 85 C0 0F 85 8B 00 00 00 39 74 24 04 74 0D B8 06 04 00 00 5E 81 C4 84 00 00 00 C3 8A 44 24 08 84 C0 75 6B 8A 4C 24 09 B8 02 00 00 00 3A C8 75 5E 8D 4E FF 3B C8 76 0D 8A 54 04 08 84 D2 74 05 40 3B C1 72 F3 40 3B C6 73 45 8B 94 24 ?? 00 00 00 8B CE 2B C8 89 0A 8D 51 0B }
	condition:
		$c0
}

rule RsaRef2_RsaPrivateEncrypt
{	meta:
		author = "Maxx"
		description = "RsaRef2 RsaPrivateEncrypt"
	strings:
		$c0 = { 8B 44 24 14 8B 54 24 10 81 EC 80 00 00 00 8D 4A 0B 56 8B 30 83 C6 07 C1 EE 03 3B CE 76 0D B8 06 04 00 00 5E 81 C4 80 00 00 00 C3 8B CE B8 02 00 00 00 2B CA C6 44 24 04 00 49 C6 44 24 05 01 3B C8 76 23 53 55 8D 69 FE 57 8B CD 83 C8 FF 8B D9 8D 7C 24 12 C1 E9 02 F3 AB 8B CB 83 E1 03 F3 AA 8D 45 02 5F 5D 5B 52 8B 94 24 94 00 00 00 C6 44 04 08 00 8D 44 04 09 52 50 E8 ?? ?? ?? ?? 8B 8C 24 A4 00 00 00 8B 84 24 98 00 00 00 51 8B 8C 24 98 00 00 00 8D 54 24 14 56 52 50 51 E8 }
	condition:
		$c0
}

rule RsaRef2_RsaPublicDecrypt
{	meta:
		author = "Maxx"
		description = "RsaRef2 RsaPublicDecrypt"
	strings:
		$c0 = { 8B 44 24 14 81 EC 84 00 00 00 8B 8C 24 94 00 00 00 56 8B 30 83 C6 07 C1 EE 03 3B CE 76 0D B8 06 04 00 00 5E 81 C4 84 00 00 00 C3 50 8B 84 24 98 00 00 00 51 8D 4C 24 0C 50 8D 54 24 14 51 52 E8 ?? ?? ?? ?? 83 C4 14 85 C0 0F 85 8E 00 00 00 39 74 24 04 74 0D B8 06 04 00 00 5E 81 C4 84 00 00 00 C3 8A 44 24 08 84 C0 75 6E 80 7C 24 09 01 75 67 B8 02 00 00 00 8D 4E FF 3B C8 76 0D B2 FF 38 54 04 08 75 05 40 3B C1 72 F5 8A 4C 04 08 40 84 C9 75 45 8B 94 24 ?? 00 00 00 8B CE 2B C8 89 0A }
	condition:
		$c0
}

rule RsaRef2_RsaPublicEncrypt
{	meta:
		author = "Maxx"
		description = "RsaRef2 RsaPublicEncrypt"
	strings:
		$c0 = { 8B 44 24 14 81 EC 84 00 00 00 53 8B 9C 24 98 00 00 00 57 8B 38 83 C7 07 8D 4B 0B C1 EF 03 3B CF 76 0E 5F B8 06 04 00 00 5B 81 C4 84 00 00 00 C3 8B D7 55 2B D3 56 BE 02 00 00 00 C6 44 24 14 00 8D 6A FF C6 44 24 15 02 3B EE 76 28 8B 84 24 AC 00 00 00 8D 4C 24 13 50 6A 01 51 E8 ?? ?? ?? ?? 8A 44 24 1F 83 C4 0C 84 C0 74 E1 88 44 34 14 46 3B F5 72 D8 8B 94 24 A0 00 00 00 53 8D 44 34 19 52 50 C6 44 34 20 00 E8 ?? ?? ?? ?? 8B 8C 24 B4 00 00 00 8B 84 24 A8 00 00 00 51 8B 8C 24 A8 00 }
	condition:
		$c0
}

rule RsaEuro_NN_modInv
{	meta:
		author = "Maxx"
		description = "RsaEuro NN_modInv"
	strings:
		$c0 = { 81 EC A4 04 00 00 53 56 8B B4 24 BC 04 00 00 57 8D 44 24 0C 56 50 E8 ?? ?? ?? ?? 8D 8C 24 1C 01 00 00 BF 01 00 00 00 56 51 89 7C 24 1C E8 ?? ?? ?? ?? 8B 94 24 C8 04 00 00 56 8D 84 24 AC 01 00 00 52 50 E8 ?? ?? ?? ?? 8B 9C 24 D8 04 00 00 56 8D 8C 24 B0 00 00 00 53 51 E8 ?? ?? ?? ?? 8D 94 24 B8 00 00 00 56 52 E8 ?? ?? ?? ?? 83 C4 30 85 C0 0F 85 F8 00 00 00 8D 84 24 ?? 00 00 00 56 50 8D 8C 24 A0 01 00 00 56 8D 94 24 AC 02 00 00 51 8D 84 24 34 03 00 00 52 50 E8 ?? ?? ?? ?? 8D 8C }
	condition:
		$c0
}

rule RsaEuro_NN_modMult
{	meta:
		author = "Maxx"
		description = "RsaEuro NN_modMult"
	strings:
		$c0 = { 8B 44 24 0C 8B 4C 24 08 81 EC 08 01 00 00 8D 54 24 00 56 8B B4 24 20 01 00 00 56 50 51 52 E8 ?? ?? ?? ?? 8B 84 24 2C 01 00 00 56 8D 0C 36 50 8B 84 24 28 01 00 00 8D 54 24 1C 51 52 50 E8 ?? ?? ?? ?? 83 C4 24 5E 81 C4 08 01 00 00 C3 }
	condition:
		$c0
}

rule Miracl_Big_constructor
{	meta:
		author = "Maxx"
		description = "Miracl Big constructor"
	strings:
		$c0 = { 56 8B F1 6A 00 E8 ?? ?? ?? ?? 83 C4 04 89 06 8B C6 5E C3 }
	condition:
		$c0
}

rule Miracl_mirvar
{	meta:
		author = "Maxx"
		description = "Miracl mirvar"
	strings:
		$c0 = { 56 E8 ?? ?? ?? ?? 8B 88 18 02 00 00 85 C9 74 04 33 C0 5E C3 8B 88 8C 00 00 00 85 C9 75 0E 6A 12 E8 ?? ?? ?? ?? 83 C4 04 33 C0 5E C3 8B 80 38 02 00 00 6A 01 50 E8 ?? ?? ?? ?? 8B F0 83 C4 08 85 F6 75 02 5E C3 8D 46 04 8B C8 8B D0 83 E1 03 2B D1 83 C2 08 89 10 8B 44 24 08 85 C0 74 0A 56 50 E8 ?? ?? ?? ?? 83 C4 08 8B C6 5E C3 }
		$c1 = { 56 57 E8 ?? ?? ?? ?? 8B F0 8B 86 2C 02 00 00 85 C0 74 05 5F 33 C0 5E C3 8B 56 1C 42 8B C2 89 56 1C 83 F8 18 7D 17 C7 44 86 20 17 00 00 00 8B 86 40 02 00 00 85 C0 74 05 E8 ?? ?? ?? ?? 8B 86 8C 00 00 00 85 C0 75 16 6A 12 E8 ?? ?? ?? ?? 8B 46 1C 83 C4 04 48 89 46 1C 5F 33 C0 5E C3 8B 46 18 6A 01 8D 0C 85 0C 00 00 00 51 E8 ?? ?? ?? ?? 8B F8 83 C4 08 85 FF 75 0C 8B 46 1C 5F 48 89 46 1C 33 C0 5E C3 8D 47 04 8B D0 8B C8 83 E2 03 2B CA 83 C1 08 89 08 8B 44 24 0C 85 C0 74 0A 57 50 E8 }
		$c2 = { 56 57 E8 ?? ?? ?? ?? 8B F0 8B 86 18 02 00 00 85 C0 74 05 5F 33 C0 5E C3 8B 56 1C 42 8B C2 89 56 1C 83 F8 18 7D 17 C7 44 86 20 17 00 00 00 8B 86 2C 02 00 00 85 C0 74 05 E8 ?? ?? ?? ?? 8B 86 8C 00 00 00 85 C0 75 16 6A 12 E8 ?? ?? ?? ?? 8B 46 1C 83 C4 04 48 89 46 1C 5F 33 C0 5E C3 8B 86 A4 02 00 00 6A 01 50 E8 ?? ?? ?? ?? 8B F8 83 C4 08 85 FF 75 0C 8B 46 1C 5F 48 89 46 1C 33 C0 5E C3 8D 47 04 8B C8 8B D0 83 E1 03 2B D1 83 C2 08 89 10 8B 44 24 0C 85 C0 74 0A 57 50 E8 }
	condition:
		any of them
}

rule Miracl_mirsys_init
{	meta:
		author = "Maxx"
		description = "Miracl mirsys init"
	strings:
		$c0 = { 53 55 57 E8 ?? ?? ?? ?? A3 ?? ?? ?? ?? E8 ?? ?? ?? ?? 33 DB A3 ?? ?? ?? ?? 3B C3 75 06 5F 5D 33 C0 5B C3 89 58 1C A1 ?? ?? ?? ?? BD 01 00 00 00 89 58 20 A1 ?? ?? ?? ?? 8B 50 1C 42 89 50 1C A1 ?? ?? ?? ?? 8B 48 1C C7 44 88 20 1D 00 00 00 8B 15 ?? ?? ?? ?? 89 9A 14 02 00 00 A1 ?? ?? ?? ?? 89 98 70 01 00 00 8B 0D ?? ?? ?? ?? 89 99 78 01 00 00 8B 15 ?? ?? ?? ?? 89 9A 98 01 00 00 A1 ?? ?? ?? ?? 89 58 14 8B 44 24 14 3B C5 0F 84 6C 05 00 00 3D 00 00 00 80 0F 87 61 05 00 00 50 E8 }
	condition:
		$c0
}

/* //gives many false positives sorry Storm Shadow
rule x509_public_key_infrastructure_cert
{	meta:
		desc = "X.509 PKI Certificate"
		ext = "crt"
	strings:
		$c0 = { 30 82 ?? ?? 30 82 ?? ?? }
	condition: 
		$c0
}

rule pkcs8_private_key_information_syntax_standard
{	meta:
		desc = "Found PKCS #8: Private-Key"
		ext = "key"
	strings: 
		$c0 = { 30 82 ?? ?? 02 01 00 }
	condition:
		$c0
}
*/

rule BASE64_table {
	meta:
		author = "_pusher_"
		description = "Look for Base64 table"
		date = "2015-07"
		version = "0.1"
	strings:
		$c0 = { 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 51 52 53 54 55 56 57 58 59 5A 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 30 31 32 33 34 35 36 37 38 39 2B 2F }
	condition:
		$c0
}

rule Delphi_Random {
	meta:
		author = "_pusher_"
		description = "Look for Random function"
		date = "2015-08"
		version = "0.1"
	strings:
		$c0 = { 53 31 DB 69 93 ?? ?? ?? ?? 05 84 08 08 42 89 93 ?? ?? ?? ?? F7 E2 89 D0 5B C3 }
		//x64 rad
		$c1 = { 8B 05 ?? ?? ?? ?? 69 C0 05 84 08 08 83 C0 01 89 05 ?? ?? ?? ?? 8B C9 8B C0 48 0F AF C8 48 C1 E9 20 89 C8 C3 }
	condition:
		any of them
}

rule Delphi_RandomRange {
	meta:
		author = "_pusher_"
		description = "Look for RandomRange function"
		date = "2016-06"
		version = "0.1"
	strings:
		$c0 = { 56 8B F2 8B D8 3B F3 7D 0E 8B C3 2B C6 E8 ?? ?? ?? ?? 03 C6 5E 5B C3 8B C6 2B C3 E8 ?? ?? ?? ?? 03 C3 5E 5B C3 }
	condition:
		$c0
}

rule Delphi_FormShow {
	meta:
		author = "_pusher_"
		description = "Look for Form.Show function"
		date = "2016-06"
		version = "0.1"
	strings:
		$c0 = { 53 8B D8 B2 01 8B C3 E8 ?? ?? ?? ?? 8B C3 E8 ?? ?? ?? ?? 5B C3 }
		//x64 rad
		$c1 = { 53 48 83 EC 20 48 89 CB 48 89 D9 B2 01 E8 ?? ?? ?? ?? 48 89 D9 E8 ?? ?? ?? ?? 48 83 C4 20 5B C3 }
	condition:
		any of them
}

rule Delphi_CompareCall {
	meta:
		author = "_pusher_"
		description = "Look for Compare string function"
		date = "2016-07"
	strings:
		$c0 = { 53 56 57 89 C6 89 D7 39 D0 0F 84 8F 00 00 00 85 F6 74 68 85 FF 74 6B 8B 46 FC 8B 57 FC 29 D0 77 02 01 C2 52 C1 EA 02 74 26 8B 0E 8B 1F 39 D9 75 58 4A 74 15 8B 4E 04 8B 5F 04 39 D9 75 4B 83 C6 08 83 C7 08 4A 75 E2 EB 06 83 C6 04 83 C7 04 5A 83 E2 03 74 22 8B 0E 8B 1F 38 D9 75 41 4A 74 17 38 FD 75 3A 4A 74 10 81 E3 00 00 FF 00 81 E1 00 00 FF 00 39 D9 75 27 01 C0 EB 23 8B 57 FC 29 D0 EB 1C 8B 46 FC 29 D0 EB 15 5A 38 D9 75 10 38 FD 75 0C C1 E9 10 C1 EB 10 38 D9 75 02 38 FD 5F 5E 5B C3 }
		//newer delphi
		$c1 = { 39 D0 74 30 85 D0 74 22 8B 48 FC 3B 4A FC 75 24 01 C9 01 C8 01 CA F7 D9 53 8B 1C 01 3B 1C 11 75 07 83 C1 04 78 F3 31 C0 5B C3}
		//x64
		$c2 = { 41 56 41 55 57 56 53 48 83 EC 20 48 89 D3 48 3B CB 75 05 48 33 C0 EB 74 48 85 C9 75 07 8B 43 FC F7 D8 EB 68 48 85 DB 75 05 8B 41 FC EB 5E 8B 79 FC 44 8B 6B FC 89 FE 41 3B F5 7E 03 44 89 EE E8 ?? ?? ?? ?? 49 89 C6 48 89 D9 E8 ?? ?? ?? ?? 48 89 C1 85 F6 7E 30 41 0F B7 06 0F B7 11 2B C2 85 C0 75 29 83 FE 01 74 1E 41 0F B7 46 02 0F B7 51 02 2B C2 85 C0 75 15 49 83 C6 04 48 83 C1 04 83 EE 02 85 F6 7F D0 90 8B C7 41 2B C5 48 83 C4 20 5B 5E 5F 41 5D 41 5E C3 }
 	condition:
		any of them
}

rule Delphi_Copy {
	meta:
		author = "_pusher_"
		description = "Look for Copy function"
		date = "2016-06"
		version = "0.1"
	strings:
		$c0 = { 53 85 C0 74 2D 8B 58 FC 85 DB 74 26 4A 7C 1B 39 DA 7D 1F 29 D3 85 C9 7C 19 39 D9 7F 11 01 C2 8B 44 24 08 E8 ?? ?? ?? ?? EB 11 31 D2 EB E5 89 D9 EB EB 8B 44 24 08 E8 ?? ?? ?? ?? 5B C2 04 00 }
		//x64 rad
		$c1 = { 53 48 83 EC 20 48 89 CB 44 89 C0 48 33 C9 48 85 D2 74 03 8B 4A FC 83 F8 01 7D 05 48 33 C0 EB 09 83 E8 01 3B C1 7E 02 89 C8 45 85 C9 7D 05 48 33 C9 EB 0A 2B C8 41 3B C9 7E 03 44 89 C9 49 89 D8 48 63 C0 48 8D 14 42 89 C8 4C 89 C1 41 89 C0 E8 ?? ?? ?? ?? 48 89 D8 48 83 C4 20 5B C3 }
	condition:
		any of them
}

rule Delphi_IntToStr {
	meta:
		author = "_pusher_"
		description = "Look for IntToStr function"
		date = "2016-04"
		version = "0.1"
	strings:
		$c0 = { 55 8B EC 81 C4 00 FF FF FF 53 56 8B F2 8B D8 FF 75 0C FF 75 08 8D 85 00 FF FF FF E8 ?? ?? ?? ?? 8D 95 00 FF FF FF 8B C6 E8 ?? ?? ?? ?? EB 0E 8B 0E 8B C6 BA ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B 06 E8 ?? ?? ?? ?? 33 D2 8A D3 3B C2 72 E3 5E 5B 8B E5 5D C2 08 00 }
		//x64 rad
		$c1 = { 53 48 83 EC 20 48 89 CB 48 85 D2 7D 10 48 89 D9 48 F7 DA 41 B0 01 E8 ?? ?? ?? ?? EB 0B 48 89 D9 4D 33 C0 E8 ?? ?? ?? ?? 48 89 D8 48 83 C4 20 5B C3 }
	condition:
		any of them
}


rule Delphi_StrToInt {
	meta:
		author = "_pusher_"
		description = "Look for StrToInt function"
		date = "2016-06"
		version = "0.1"
	strings:
		$c0 = { 53 56 83 C4 F4 8B D8 8B D4 8B C3 E8 ?? ?? ?? ?? 8B F0 83 3C 24 00 74 19 89 5C 24 04 C6 44 24 08 0B 8D 54 24 04 A1 ?? ?? ?? ?? 33 C9 E8 ?? ?? ?? ?? 8B C6 83 C4 0C 5E 5B C3 }
		//x64 rad
		$c1 = { 55 56 53 48 83 EC 40 48 8B EC 48 89 CB 48 89 D9 48 8D 55 3C E8 ?? ?? ?? ?? 89 C6 83 7D 3C 00 74 1B 48 89 5D 20 C6 45 28 11 48 8B 0D ?? ?? ?? ?? 48 8D 55 20 4D 33 C0 E8 ?? ?? ?? ?? 89 F0 48 8D 65 40 5B 5E 5D C3 }
	condition:
		any of them
}

rule Delphi_DecodeDate {
	meta:
		author = "_pusher_"
		description = "Look for DecodeDate (DecodeDateFully) function"
		date = "2016-06"
		version = "0.1"
	strings:
		$c0 = { 55 8B EC 83 C4 E8 53 56 89 4D F4 89 55 F8 89 45 FC 8B 5D 08 FF 75 10 FF 75 0C 8D 45 E8 E8 ?? ?? ?? ?? 8B 4D EC 85 C9 7F 24 8B 45 FC 66 C7 00 00 00 8B 45 F8 66 C7 00 00 00 8B 45 F4 66 C7 00 00 00 66 C7 03 00 00 33 D2 E9 F2 00 00 00 8B C1 BE 07 00 00 00 99 F7 FE 42 66 89 13 49 66 BB 01 00 81 F9 B1 3A 02 00 7C 13 81 E9 B1 3A 02 00 66 81 C3 90 01 81 F9 B1 3A 02 00 7D ED 8D 45 F2 50 8D 45 F0 66 BA AC 8E 91 E8 ?? ?? ?? ?? 66 83 7D F0 04 75 0A 66 FF 4D F0 66 81 45 F2 AC 8E 66 6B 45 F0 64 66 03 D8 8D 45 F2 50 8D 4D F0 0F B7 45 F2 66 BA B5 05 E8 ?? ?? ?? ?? 66 8B 45 F0 C1 E0 02 66 03 D8 8D 45 F2 50 8D 4D F0 0F B7 45 F2 66 BA 6D 01 E8 ?? ?? ?? ?? 66 83 7D F0 04 75 0A 66 FF 4D F0 66 81 45 F2 6D 01 66 03 5D F0 8B C3 E8 ?? ?? ?? ?? 8B D0 33 C0 8A C2 8D 04 40 8D 34 C5 ?? ?? ?? ?? 66 B8 01 00 0F B7 C8 66 8B 4C 4E FE 66 89 4D F0 66 8B 4D F2 66 3B 4D F0 72 0B 66 8B 4D F0 66 29 4D F2 40 EB DF 8B 4D FC 66 89 19 8B 4D F8 66 89 01 66 8B 45 F2 40 8B 4D F4 66 89 01 8B C2 5E 5B 8B E5 5D C2 0C 00 }
		//x64
		$c1 = { 55 41 55 57 56 53 48 83 EC 30 48 8B EC 48 89 D3 4C 89 C6 4C 89 CF E8 ?? ?? ?? ?? 48 8B C8 48 C1 E9 20 85 C9 7F 23 66 C7 03 00 00 66 C7 06 00 00 66 C7 07 00 00 48 8B 85 80 00 00 00 66 C7 00 00 00 48 33 C0 E9 19 01 00 00 4C 8B 85 80 00 00 00 41 C7 C1 07 00 00 00 8B C1 99 41 F7 F9 66 83 C2 01 66 41 89 10 83 E9 01 66 41 BD 01 00 81 F9 B1 3A 02 00 7C 14 81 E9 B1 3A 02 00 66 41 81 C5 90 01 81 F9 B1 3A 02 00 7D EC 90 66 BA AC 8E 4C 8D 45 2C 4C 8D 4D 2E E8 ?? ?? ?? ?? 66 83 7D 2C 04 75 0B 66 83 6D 2C 01 66 81 45 2E AC 8E 66 6B 45 2C 64 66 44 03 E8 0F B7 4D 2E 66 BA B5 05 4C 8D 45 2C 4C 8D 4D 2E E8 ?? ?? ?? ?? 48 0F B7 45 2C 03 C0 03 C0 66 44 03 E8 0F B7 4D 2E 66 BA 6D 01 4C 8D 45 2C 4C 8D 4D 2E E8 ?? ?? ?? ?? 66 83 7D 2C 04 75 0B 66 83 6D 2C 01 66 81 45 2E 6D 01 66 44 03 6D 2C 44 89 E9 E8 ?? ?? ?? ?? 48 8D 0D ?? ?? ?? ?? 48 0F B6 D0 48 8D 14 52 48 8D 14 D1 66 B9 01 00 4C 0F B7 C1 4E 0F B7 44 42 FE 66 44 89 45 2C 4C 0F B7 45 2E 66 44 3B 45 2C 72 10 4C 0F B7 45 2C 66 44 29 45 2E 66 }
	condition:
		any of them
}


rule Unknown_Random {
	meta:
		author = "_pusher_"
		description = "Look for Random function"
		date = "2016-07"
	strings:
		$c0 = { 55 8B EC 52 8B 45 08 69 15 ?? ?? ?? ?? 05 84 08 08 42 89 15 ?? ?? ?? ?? F7 E2 8B C2 5A C9 C2 04 00 }
	condition:
		$c0
}

rule VC6_Random {
	meta:
		author = "_pusher_"
		description = "Look for Random function"
		date = "2016-02"
	strings:
		$c0 = { A1 ?? ?? ?? ?? 69 C0 FD 43 03 00 05 C3 9E 26 00 A3 ?? ?? ?? ?? C1 F8 10 25 FF 7F 00 00 C3 }
	condition:
		$c0
}

rule VC8_Random {
	meta:
		author = "_pusher_"
		description = "Look for Random function"
		date = "2016-01"
		version = "0.1"
	strings:
		$c0 = { E8 ?? ?? ?? ?? 8B 48 14 69 C9 FD 43 03 00 81 C1 C3 9E 26 00 89 48 14 8B C1 C1 E8 10 25 FF 7F 00 00 C3 }
	condition:
		$c0
}

rule DCP_RIJNDAEL_Init {
	meta:
		author = "_pusher_"
		description = "Look for DCP RijnDael Init"
		date = "2016-07"
	strings:
		$c0 = { 55 8B EC 51 53 56 57 89 4D FC 8B FA 8B D8 8B 75 08 56 8B D7 8B 4D FC 8B C3 E8 ?? ?? ?? ?? 8B D7 8B 4D FC 8B C3 8B 38 FF 57 ?? 85 F6 75 25 8D 43 38 33 C9 BA 10 00 00 00 E8 ?? ?? ?? ?? 8D 4B 38 8D 53 38 8B C3 8B 30 FF 56 ?? 8B C3 8B 10 FF 52 ?? EB 16 8D 53 38 8B C6 B9 10 00 00 00 E8 ?? ?? ?? ?? 8B C3 8B 10 FF 52 ?? 5F 5E 5B 59 5D C2 04 00 }
	condition:
		$c0
}

rule DCP_RIJNDAEL_EncryptECB {
	meta:
		author = "_pusher_"
		description = "Look for DCP RijnDael EncryptECB"
		date = "2016-07"
	strings:
		$c0 = { 53 56 57 55 83 C4 B4 89 0C 24 8D 74 24 08 8D 7C 24 28 80 78 30 00 75 16 B9 ?? ?? ?? ?? B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B 0A 89 0F 8B CA 83 C1 04 8B 09 8D 5F 04 89 0B 8B CA 83 C1 08 8B 09 8D 5F 08 89 0B 83 C2 0C 8B 12 8D 4F 0C 89 11 8B 50 58 83 EA 02 85 D2 0F 82 3B 01 00 00 42 89 54 24 04 33 D2 8B 0F 8B DA C1 E3 02 33 4C D8 5C 89 0E 8D 4F 04 8B 09 33 4C D8 60 8D 6E 04 89 4D 00 8D 4F 08 8B 09 33 4C D8 64 8D 6E 08 89 4D 00 8D 4F 0C 8B 09 33 4C D8 68 8D 5E 0C 89 0B 33 C9 8A 0E 8D 0C 8D }
	condition:
		$c0
}

rule DCP_BLOWFISH_Init {
	meta:
		author = "_pusher_"
		description = "Look for DCP Blowfish Init"
		date = "2016-07"
	strings:
		$c0 = { 53 56 57 55 8B F2 8B F8 8B CF B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B D8 8B C3 8B 10 FF 52 34 8B C6 E8 ?? ?? ?? ?? 50 8B C6 E8 ?? ?? ?? ?? 8B D0 8B C3 59 8B 30 FF 56 3C 8B 43 3C 85 C0 79 03 83 C0 07 C1 F8 03 E8 ?? ?? ?? ?? 8B F0 8B D6 8B C3 8B 08 FF 51 40 8B 47 40 8B 6B 3C 3B C5 7D 0F 6A 00 8B C8 8B D6 8B C7 8B 38 FF 57 30 EB 0D 6A 00 8B D6 8B CD 8B C7 8B 38 FF 57 30 8B 53 3C 85 D2 79 03 83 C2 07 C1 FA 03 8B C6 B9 FF 00 00 00 E8 ?? ?? ?? ?? 8B 53 3C 85 D2 79 03 83 C2 07 C1 FA 03 8B C6 E8 ?? ?? ?? ?? 8B C3 E8 ?? ?? ?? ?? 5D 5F 5E 5B C3 }
	condition:
		$c0
}


rule DCP_BLOWFISH_EncryptCBC {
	meta:
		author = "_pusher_"
		description = "Look for DCP Blowfish EncryptCBC"
		date = "2016-07"
	strings:
		$c0 = { 55 8B EC 83 C4 F0 53 56 57 89 4D F8 89 55 FC 8B D8 80 7B 34 00 75 16 B9 ?? ?? ?? ?? B2 01 A1 ?? ?? ?? ?? E8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B 7D 08 85 FF 79 03 83 C7 07 C1 FF 03 85 FF 7E 56 BE 01 00 00 00 6A 08 8B 45 FC 8B D6 4A C1 E2 03 03 C2 8D 4D F0 8D 53 54 E8 ?? ?? ?? ?? 8D 4D F0 8D 55 F0 8B C3 E8 ?? ?? ?? ?? 8B 55 F8 8B C6 48 C1 E0 03 03 D0 8D 45 F0 B9 08 00 00 00 E8 ?? ?? ?? ?? 8D 53 54 8D 45 F0 B9 08 00 00 00 E8 ?? ?? ?? ?? 46 4F 75 AF 8B 75 08 81 E6 07 00 00 80 79 05 4E 83 CE F8 46 85 F6 74 26 8D 4D F0 8D 53 54 8B C3 E8 ?? ?? ?? ?? 56 8B 4D F8 03 4D 08 2B CE 8B 55 FC 03 55 08 2B D6 8D 45 F0 E8 ?? ?? ?? ?? 8D 45 F0 B9 FF 00 00 00 BA 08 00 00 00 E8 ?? ?? ?? ?? 5F 5E 5B 8B E5 5D C2 04 00 }
	condition:
		$c0
}

rule DCP_DES_Init {
	meta:
		author = "_pusher_"
		description = "Look for DCP Des Init"
		date = "2016-02"
	strings:
		$c0 = { 55 8B EC 51 53 56 57 89 4D FC 8B FA 8B D8 8B 75 08 56 8B D7 8B 4D FC 8B C3 E8 FE F9 FF FF 8B D7 8B 4D FC 8B C3 8B 38 FF 57 5C 85 F6 75 25 8D 43 38 33 C9 BA 08 00 00 00 E8 F3 A9 FA FF 8D 4B 38 8D 53 38 8B C3 8B 30 FF 56 6C 8B C3 8B 10 FF 52 48 EB 16 8D 53 38 8B C6 B9 08 00 00 00 E8 6E A7 FA FF 8B C3 8B 10 FF 52 48 5F 5E 5B 59 5D C2 04 00 }
		$c1 = { 55 8B EC 51 53 56 57 89 4D FC 8B FA 8B D8 8B 75 08 56 8B D7 8B 4D FC 8B C3 E8 EE D4 FF FF 8B D7 8B 4D FC 8B C3 8B 38 FF 57 74 85 F6 75 2B 8D 43 40 B9 FF 00 00 00 BA 08 00 00 00 E8 ?? ?? ?? ?? 8D 4B 40 8D 53 40 8B C3 8B 30 FF 96 84 00 00 00 8B C3 8B 10 FF 52 58 EB 16 8D 53 40 8B C6 B9 08 00 00 00 E8 ?? ?? ?? ?? 8B C3 8B 10 FF 52 58 5F 5E 5B 59 5D C2 04 00 }
	condition:
		any of them
}


rule DCP_DES_EncryptECB {
	meta:
		author = "_pusher_"
		description = "Look for DCP Des EncryptECB"
		date = "2016-02"
	strings:
		$c0 = { 53 80 78 ?? 00 75 16 B9 ?? ?? ?? 00 B2 01 A1 ?? ?? ?? 00 E8 ?? ?? ?? FF E8 ?? ?? ?? FF 8D 58 ?? 53 E8 ?? ?? FF FF 5B C3 }
	condition:
		any of them
}

rule TEA_DELTA2 {
	meta:
		author = "_pusher_"
		description = "TEA DELTA"
		date = "2016-02"
	strings:
		$c0 = { 9E 37 79 B9 }
		$c1 = { 61 C8 86 47 }
	condition:
		any of them
}

rule TEA_DELTA {
	meta:
		author = "_pusher_"
		description = "TEA DELTA"
		date = "2016-02"
	strings:
		$c0 = { B9 79 37 9E }
		$c1 = { 47 86 C8 61 }
	condition:
		any of them
}

rule TEA_SUM {
	meta:
		author = "_pusher_"
		description = "TEA SUM"
		date = "2016-02"
	strings:
		$c0 = { 90 9B 77 E3 }
	condition:
		any of them
}

rule WellRNG512 {
	meta:
		author = "golem"
		description = "Well512 Rng Constant"
		date = "2024-11"
	strings:
		$c0 = { 24 2D 44 DA }
		$c1 = { 20 2D 44 DA }
	condition:
		any of them
}

rule Sosemanuk
{
    /* Notes:
     *
     * - mul_a and mul_ia are commonly stored in a 4-byte value array, so
     *   look for a 4-byte little endian equivalant also
     *
     * - mul_a and mul_ia start with four zero bytes, which is a fairly common
     *   pattern in EXEs.  Including these bytes in the strings below is likely
     *   worse for scan performance than omitting them, but I'm leaving them in
     *   because findcrypt-yara leverages the yara API to map substring matches
     *   to binary offsets (and then into virtual addresses), and the virtual
     *   address for the start of these is likely to have more xrefs than the
     *   the virtual address of (matching_offset + 4).  If, instead, better
     *   performance is desired for your use case, just remove the zero bytes
     *   from the strings below.
     *
     * Reference:
     * - https://labs.sentinelone.com/enter-the-maze-demystifying-an-affiliate-involved-in-maze-snow/
     */
    strings:
        $mul_a_be = {00 00 00 00 E1 9F CF 13 6B 97 37 26 8A 08 F8 35 [992] B5 5B 4D DE 54 C4 82 CD DE CC 7A F8 3F 53 B5 EB}
        $mul_a_le = {00 00 00 00 13 CF 9F E1 26 37 97 6B 35 F8 08 8A [992] DE 4D 5B B5 CD 82 C4 54 F8 7A CC DE EB B5 53 3F}
        $mul_ia_be = {00 00 00 00 18 0F 40 CD 30 1E 80 33 28 11 C0 FE [992] 9E E2 65 1C 86 ED 25 D1 AE FC E5 2F B6 F3 A5 E2}
        $mul_ia_le = {00 00 00 00 CD 40 0F 18 33 80 1E 30 FE C0 11 28 [992] 1C 65 E2 9E D1 25 ED 86 2F E5 FC AE E2 A5 F3 B6}

    condition:
        any of them
}

rule salsa20 {
	meta:
		author = "eric"
		description = "salsa20/chacha20 fixed words"
		date = "2020-10"
	strings:
		$c0 = "expand 32-byte k" ascii
	condition:
		$c0
}

rule SM4_fk {
	meta:
		author = "s1nk"
		description = "sm4 sk"
		date = "2025-09-09"
	strings:
		$c0 = {c6 ba b1 a3 50 33 aa 56 97 91 7d 67 dc 22 70 b2}
	condition:
		$c0
}

rule SM4_ck {
	meta:
		author = "s1nk"
		description = "sm4 sk"
		date = "2025-09-09"
	strings:
		$c0 = {15 0e 07 00 31 2a 23 1c 4d 46 3f 38 69 62 5b 54 85 7e 77 70 a1 9a 93 8c bd b6 af a8 d9 d2 cb c4 f5 ee e7 e0 11 0a 03 fc 2d 26 1f 18 49 42 3b 34 65 5e 57 50 81 7a 73 6c 9d 96 8f 88 b9 b2 ab a4 d5 ce c7 c0 f1 ea e3 dc 0d 06 ff f8 29 22 1b 14 45 3e 37 30 61 5a 53 4c 7d 76 6f 68 99 92 8b 84 b5 ae a7 a0 d1 ca c3 bc ed e6 df d8 09 02 fb f4 25 1e 17 10 41 3a 33 2c 5d 56 4f 48 79 72 6b 64}
	condition:
		$c0
}

rule SM4_sbox {
	meta:
		author = "s1nk"
		description = "sm4 sk"
		date = "2025-09-09"
	strings:
		$c0 = {d6 90 e9 fe cc e1 3d b7 16 b6 14 c2 28 fb 2c 05 2b 67 9a 76 2a be 04 c3 aa 44 13 26 49 86 06 99 9c 42 50 f4 91 ef 98 7a 33 54 0b 43 ed cf ac 62 e4 b3 1c a9 c9 08 e8 95 80 df 94 fa 75 8f 3f a6 47 07 a7 fc f3 73 17 ba 83 59 3c 19 e6 85 4f a8 68 6b 81 b2 71 64 da 8b f8 eb 0f 4b 70 56 9d 35 1e 24 0e 5e 63 58 d1 a2 25 22 7c 3b 01 21 78 87 d4 00 46 57 9f d3 27 52 4c 36 02 e7 a0 c4 c8 9e ea bf 8a d2 40 c7 38 b5 a3 f7 f2 ce f9 61 15 a1 e0 ae 5d a4 9b 34 1a 55 ad 93 32 30 f5 8c b1 e3 1d f6 e2 2e 82 66 ca 60 c0 29 23 ab 0d 53 4e 6f d5 db 37 45 de fd 8e 2f 03 ff 6a 72 6d 6c 5b 51 8d 1b af 92 bb dd bc 7f 11 d9 5c 41 1f 10 5a d8 0a c1 31 88 a5 cd 7b bd 2d 74 d0 12 b8 e5 b4 b0 89 69 97 4a 0c 96 77 7e 65 b9 f1 09 c5 6e c6 84 18 f0 7d ec 3a dc 4d 20 79 ee 5f 3e d7 cb 39 48}
	condition:
		$c0
}


```

`patching.py`:

```py
#------------------------------------------------------------------------------
# Plugin Preflight
#------------------------------------------------------------------------------
#
#    the purpose of this 'preflight' is to test if the plugin is compatible
#    with the environment it is being loaded in. specifically, these preflight
#    checks are designed to be compatible with IDA 7.0+ and Python 2/3
#
#    if the environment does not meet the specifications required by the
#    plugin, this file will gracefully decline to load the plugin without
#    throwing noisy errors (besides a simple print to the IDA console)
#
#    this makes it easy to install the plugin on machines with numerous
#    versions of IDA / Python / virtualenvs which employ a shared plugin
#    directory such as the 'preferred' IDAUSR plugin directory...
#

import sys

# this plugin requires Python 3
SUPPORTED_PYTHON = sys.version_info[0] == 3

# this plugin requires IDA 7.6 or newer
try:
    import idaapi
    import ida_pro
    IDA_GLOBAL_SCOPE = sys.modules['__main__']
    SUPPORTED_IDA = ida_pro.IDA_SDK_VERSION >= 760
except:
    SUPPORTED_IDA = False

# is this deemed to be a compatible environment for the plugin to load?
SUPPORTED_ENVIRONMENT = bool(SUPPORTED_IDA and SUPPORTED_PYTHON)
if not SUPPORTED_ENVIRONMENT:
    print("Patching plugin is not compatible with this IDA/Python version")

#------------------------------------------------------------------------------
# IDA Plugin Stub
#------------------------------------------------------------------------------

if SUPPORTED_ENVIRONMENT:
    import patching
    from patching.util.python import reload_package

def PLUGIN_ENTRY():
    """
    Required plugin entry point for IDAPython plugins.
    """
    return PatchingPlugin()

class PatchingPlugin(idaapi.plugin_t):
    """
    The IDA Patching plugin stub.
    """

    #
    # Plugin flags:
    # - PLUGIN_PROC: Load / unload this plugin when an IDB opens / closes
    # - PLUGIN_HIDE: Hide this plugin from the IDA plugin menu
    # - PLUGIN_UNL:  Unload the plugin after calling run()
    #

    flags = idaapi.PLUGIN_PROC | idaapi.PLUGIN_HIDE | idaapi.PLUGIN_UNL
    comment = "A plugin to enable binary patching in IDA"
    help = ""
    wanted_name = "Patching"
    wanted_hotkey = ""

    def __init__(self):
        self.__updated = getattr(IDA_GLOBAL_SCOPE, 'RESTART_REQUIRED', False)

    #--------------------------------------------------------------------------
    # IDA Plugin Overloads
    #--------------------------------------------------------------------------

    def init(self):
        """
        This is called by IDA when it is loading the plugin.
        """
        if not SUPPORTED_ENVIRONMENT or self.__updated:
            return idaapi.PLUGIN_SKIP

        # load the plugin core
        self.core = patching.PatchingCore(defer_load=True)

        # inject a reference to the plugin context into the IDA console scope
        IDA_GLOBAL_SCOPE.patching = self

        addon = idaapi.addon_info_t()
        addon.id = "github.gaasedelen.patching"
        addon.name = "Patching"
        addon.producer = "Markus Gaasedelen"
        addon.url = "https://github.com/gaasedelen/patching"
        addon.version = "0.3.0.0"
        idaapi.register_addon(addon)

        # mark the plugin as loaded
        return idaapi.PLUGIN_KEEP

    def run(self, arg):
        """
        This is called by IDA when this file is loaded as a script.
        """
        pass

    def term(self):
        """
        This is called by IDA when it is unloading the plugin.
        """
        try:
            self.core.unload()
        except Exception as e:
            pass
        self.core = None

    #--------------------------------------------------------------------------
    # Development Helpers
    #--------------------------------------------------------------------------

    def reload(self):
        """
        Hot-reload the plugin.
        """
        if self.core:
            self.core.unload()
        reload_package(patching)
        self.core = patching.PatchingCore()

```

`patching/__init__.py`:

```py
from patching.core import PatchingCore
```

`patching/actions.py`:

```py
import ida_idaapi
import ida_kernwin

from patching.ui.save import SaveController
from patching.ui.preview import PatchingController
from patching.util.ida import get_current_ea, read_range_selection

#-----------------------------------------------------------------------------
# IDA Plugin Actions
#-----------------------------------------------------------------------------

class NopAction(ida_kernwin.action_handler_t):
    NAME = 'patching:nop'
    ICON = 'nop.png'
    TEXT = "NOP"
    TOOLTIP = "NOP the selected instructions (or bytes)"
    HOTKEY = 'CTRL-N'

    def __init__(self, core):
        ida_kernwin.action_handler_t.__init__(self)
        self.core = core

    def activate(self, ctx):

        # fetch the address range selected by the user
        valid_selection, start_ea, end_ea = read_range_selection(ctx)

        # do a range-based NOP if the selection is valid
        if valid_selection:
            print("%08X --> %08X: NOP'd range" % (start_ea, end_ea))
            self.core.nop_range(start_ea, end_ea)
            return 1

        # NOP a single instruction / item
        cur_ea = get_current_ea(ctx)
        if cur_ea == ida_idaapi.BADADDR:
            print("Cannot use NOP here... (Invalid Address)")
            return 0

        print("%08X: NOP'd item" % cur_ea)
        self.core.nop_item(cur_ea)

        # return 1 to refresh the IDA views
        return 1

    def update(self, ctx):

        # the NOP action should only be allowed to execute in the following views
        if ida_kernwin.get_widget_type(ctx.widget) == ida_kernwin.BWN_DISASM:
            return ida_kernwin.AST_ENABLE_FOR_WIDGET
        elif ida_kernwin.get_widget_title(ctx.widget) == 'PatchingCodeViewer':
            return ida_kernwin.AST_ENABLE_FOR_WIDGET

        # unknown context / widget, do NOT allow the NOP action to be used here
        return ida_kernwin.AST_DISABLE_FOR_WIDGET

class RevertAction(ida_kernwin.action_handler_t):
    NAME = 'patching:revert'
    ICON = 'revert.png'
    TEXT = "Revert patch"
    TOOLTIP = "Revert patched bytes at the selected address"
    HOTKEY = None

    def __init__(self, core):
        ida_kernwin.action_handler_t.__init__(self)
        self.core = core

    def activate(self, ctx):

        # fetch the address range selected by the user
        valid_selection, start_ea, end_ea = read_range_selection(ctx)

        if valid_selection:
            print("%08X --> %08X: Reverted range" % (start_ea, end_ea))
            self.core.revert_range(start_ea, end_ea)
        else:
            cur_ea = get_current_ea(ctx)
            print("%08X: Reverted patch" % cur_ea)
            self.core.revert_patch(cur_ea)

        # return 1 to refresh the IDA views
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS

class ForceJumpAction(ida_kernwin.action_handler_t):
    NAME = 'patching:forcejump'
    ICON = 'forcejump.png'
    TEXT = "Force jump"
    TOOLTIP = "Patch the selected jump into an unconditional jump"
    HOTKEY = None

    def __init__(self, core):
        ida_kernwin.action_handler_t.__init__(self)
        self.core = core

    def activate(self, ctx):
        cur_ea = get_current_ea(ctx)

        print("%08X: Forced conditional jump" % cur_ea)
        self.core.force_jump(cur_ea)

        # return 1 to refresh the IDA views
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS

class AssembleAction(ida_kernwin.action_handler_t):
    NAME = 'patching:assemble'
    ICON = 'assemble.png'
    TEXT = "~A~ssemble..."
    TOOLTIP = "Assemble new instructions at the selected address"
    HOTKEY = None

    def __init__(self, core):
        ida_kernwin.action_handler_t.__init__(self)
        self.core = core

    def activate(self, ctx):

        # do not create a new patching dialog if one is already active
        if ida_kernwin.find_widget(PatchingController.WINDOW_TITLE):
            return 1

        wid = PatchingController(self.core, get_current_ea(ctx))

        # return 1 to refresh the IDA views
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS

class ApplyAction(ida_kernwin.action_handler_t):
    NAME = 'patching:apply'
    ICON = 'save.png'
    TEXT = "A~p~ply patches to..."
    TOOLTIP = "Select where to save the patched binary"
    HOTKEY = None

    def __init__(self, core):
        ida_kernwin.action_handler_t.__init__(self)
        self.core = core

    def activate(self, ctx):

        controller = SaveController(self.core)

        if controller.interactive():
            print("Patch successful: %s" % self.core.patched_filepath)
        else:
            print("Patching cancelled...")

        # return 1 to refresh the IDA views
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS

class QuickApplyAction(ida_kernwin.action_handler_t):
    NAME = 'patching:quickapply'
    ICON = 'save.png'
    TEXT = "Quick apply patches"
    TOOLTIP = "Apply patches using the previously selected patch settings"
    HOTKEY = None

    def __init__(self, core):
        ida_kernwin.action_handler_t.__init__(self)
        self.core = core

    def activate(self, ctx):

        # attempt to perform a quick patch (save), per the user's request
        success, error = self.core.quick_apply()
        if success:
            print("Quick patch successful: %s" % self.core.patched_filepath)
            return 1

        #
        # since the quickpatch FAILED, fallback to popping the interactive
        # patch saving dialog to let the user sort out the issue
        #

        print("Quick patch failed...")
        controller = SaveController(self.core, error)

        if controller.interactive():
            print("Patch successful: %s" % self.core.patched_filepath)
        else:
            print("Patching cancelled...")

        # return 1 to refresh the IDA views
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS

#-----------------------------------------------------------------------------
# All Actions
#-----------------------------------------------------------------------------

PLUGIN_ACTIONS = \
[
    NopAction,
    RevertAction,
    ForceJumpAction,
    AssembleAction,
    ApplyAction,
    QuickApplyAction
]

```

`patching/asm.py`:

```py
import ida_ua
import ida_idp
import ida_nalt
import ida_lines
import ida_segregs

from patching.util.ida import *
import keystone

TEST_KS_RESOLVER = False

class KeystoneAssembler(object):
    """
    An abstraction of a CPU-specific fixup layer to wrap Keystone.
    """

    # the mnemonic for an unconditional jump
    UNCONDITIONAL_JUMP = NotImplementedError

    # the list of known conditional jump mnemonics
    CONDITIONAL_JUMPS = []

    # a list of mnemonics that we KNOW are currently unsupported
    UNSUPPORTED_MNEMONICS = []

    # the number of instruction bytes to show in the patch preview pane
    MAX_PREVIEW_BYTES = 4

    #
    # NOTE: for now, we explicitly try to print operands using 'blank' type
    # info because it can produce simpler output for the assembler engine
    #
    # we initialize just one instance of this blank printop for performance
    # reasons, so we do not have to initialize a new one for *every* print.
    #
    # it is particularly useful when using the assemble_all(...) DEV / test
    # function to round-trip assemble an entire IDB
    #

    _NO_OP_TYPE = ida_nalt.printop_t()

    def __init__(self, arch, mode):

        # a super low-effort TODO assert to ensure we're not using incomplete code
        assert self.UNCONDITIONAL_JUMP != NotImplementedError, "Incomplete Assembler Implementation"

        # initialize a backing keystone assembler
        self._arch = arch
        self._mode = mode | (keystone.KS_OPT_SYM_RESOLVER if TEST_KS_RESOLVER else 0)
        self._ks = keystone.Ks(arch, mode)

        # TODO/XXX: the keystone sym resolver callback is only for DEV / testing
        if TEST_KS_RESOLVER:
            self._ks.sym_resolver = self._ks_sym_resolver

    def _ks_sym_resolver(self, symbol, value):
        """
        TODO: the keystone symbol resolver can be a bit goofy, so we opt not
        to use it (keypatch doesn't, either!) for now. it has been left here
        for future testing or further bugfixing of keystone

        NOTE: this *CAN* be beneficial to use for MULTI INSTRUCTION assembly,
        such as assembling a block of instructions (eg. shellcode, or a
        more complex patch) which makes use of labels within said block.
        """
        symbol = symbol.decode('utf-8')

        #
        # some symbols in IDA names / chars cannot pass cleanly through
        # keystone. for that reason, we try to replace some 'problematic'
        # characters that may appear in IDA symbols (and then disas text)
        #
        # when they pop back up here, in keystone's symbol resolver, we
        # try to subsitute the 'problematic' characters back in so that
        # we can look up the original symbol value in IDA
        #

        if 'AT_SPECIAL_AT' in symbol:
            symbol = symbol.replace('AT_SPECIAL_AT', '@')
        if 'QU_SPECIAL_QU' in symbol:
            symbol = symbol.replace('QU_SPECIAL_QU', '?')

        #
        # XXX: pretty messy, sorry. no way to resolve 'symbol collisions'
        # that could technically manifest from IDA
        #

        for sym_value, sym_real_name in resolve_symbol(self._ks_address, symbol):
            value[0] = sym_value
            return True

        # symbol resolution failed
        return False

    def rewrite_symbols(self, assembly, ea):
        """
        Rewrite the symbols in the given assembly text to their concrete values.
        """

        #
        # TODO: is there a reason i'm not using parse_disassembly_components()
        # here? I forget, this code probably predates that.
        #

        mnem, sep, ops = assembly.partition(' ')

        # 'mnem' appears to be an instruction prefix actually, so keep parsing
        if mnem in KNOWN_PREFIXES:
            real_mnem, sep, ops = ops.partition(' ')
            mnem += ' ' + real_mnem

        #
        # scrape symbols from *just* the operands text, as that's the only
        # place we would expect to see them in assembly code anyway!
        #

        symbols = scrape_symbols(ops)

        #
        # if the symbol count is too high, it might take 'too long' to try
        # and resolve them all in a big database. At 10+ symbols, it is
        # probably just an invalid input to the assembler as is (at least,
        # for a single instruction ...)
        #
        # TODO: really, we should be throwing a set of more descriptive
        # errors from the assembler that the dialog can render rather
        # than trying to catch issues in preview.py (UI land)
        #

        if len(symbols) > 10:
            print("Aborting symbol re-writing, too (%u) many potential symbols..." % (len(symbols)))
            return assembly

        #
        # with a list of believed symbols and their text location, we will
        # try to resolve a value for each text symbol and swap a raw hex
        # number in to replace the symbol text
        #
        #   eg. 'mov    eax, [foo]' --> 'mov    eax, [0x410800]'
        #
        # where 'foo' was a symbol name entered by the user, but we can
        # query IDA to try and resolve (func address, data address, etc)
        #

        prev_index = 0
        new_ops = ''

        for name, location in symbols:
            sym_start, sym_end = location

            for sym_value, sym_real_name in resolve_symbol(ea, name):
                sym_value_text = '0x%X' % sym_value

                #
                # we are carefully carving around the original symbol text
                # to build out a new 'string' for the full operand text
                #

                new_ops += ops[prev_index:sym_start] + sym_value_text
                prev_index = sym_end

                #
                # TODO: the case where resolve_symbol can return 'multiple'
                # results (eg, a symbol 'collision') is currently unhandled
                # but could happen in very rare cases
                #
                # by always breaking on the first iteration of this loop,
                # we're effectively always selecting the first symbol value
                # without any consideration of others (TODO how?)
                #
                # lol, this symbol resolution / rewriting is ugly enough as
                # is. it will probably have to get re-written an simplified
                # at a later time, if possible :S
                #

                break

            else:
                #print("%08X: Failed to resolve possible symbol '%s'" % (ea, name))
                continue

        new_ops += ops[prev_index:]
        raw_assembly = mnem + sep + new_ops

        #
        # return assembly text that has (ideally) had possible symbols
        # replaced with unambiguous values that are easy for the assembler
        # to consume
        #

        return raw_assembly

    def asm(self, assembly, ea=0, resolve=True):
        """
        Assemble the given instruction with an optional base address.

        TODO/v0.2.0: support 'simple' one-line but multi-instruction assembly?
        """
        unaliased_assembly = self.unalias(assembly)

        if TEST_KS_RESOLVER:
            raw_assembly = unaliased_assembly
            raw_assembly = raw_assembly.replace('@', 'AT_SPECIAL_AT')
            raw_assembly = raw_assembly.replace('?', 'QU_SPECIAL_QU')
            self._ks_address = ea
        elif resolve:
            raw_assembly = self.rewrite_symbols(unaliased_assembly, ea)
        else:
            raw_assembly = unaliased_assembly

        #print(" Assembling: '%s' @ ea 0x%08X" % (raw_assembly, ea))

        #
        # TODO: this whole function is kind of gross, and it would be good if
        # we could surface at least 'some' of the error information that
        # keystone can produce of failures
        #

        # try assemble
        try:
            asm_bytes, count = self._ks.asm(raw_assembly, ea, True)
            if asm_bytes == None:
                return bytes()
        except Exception as e:
            #print("FAIL", e)
            return bytes()

        # return the generatied instruction bytes if keystone succeeded
        return asm_bytes

    def is_conditional_jump(self, mnem):
        """
        Return True if the given mnemonic is a conditional jump.

        TODO: 'technically' I think IDA might actually have some CPU
        agnostic API's to tell if an instruction is a conditional jump.

        so maybe the need to manually define CONDITIONAL_JUMPS mnemonics
        for CPU's can be removed in a future version of this plugin...
        """
        return bool(mnem.upper() in self.CONDITIONAL_JUMPS)

    def nop_buffer(self, start_ea, end_ea):
        """
        Generate a NOP buffer for the given address range.
        """
        range_size = end_ea - start_ea
        if range_size < 0:
            return bytes()

        # fetch the bytes for a NOP instruction (and its size)
        nop_data = self.asm('nop', start_ea)
        nop_size = len(nop_data)

        # generate a buffer of NOP's equal to the range we are filling in
        nop_buffer = nop_data * (range_size // nop_size)

        return nop_buffer

    #--------------------------------------------------------------------------
    # Assembly Normalization
    #--------------------------------------------------------------------------

    def format_prefix(self, insn, prefix):
        """
        Return an assembler compatible version of the given prefix.
        """
        return prefix

    def format_mnemonic(self, insn, mnemonic):
        """
        Return an assembler compatible version of the given mnemonic.
        """
        return mnemonic

    def format_memory_op(self, insn, n):
        """
        Return an assembler compatible version of the given memory op.
        """
        op_text = ida_ua.print_operand(insn.ea, n, 0, self._NO_OP_TYPE)
        return op_text

    def format_imm_op(self, insn, n):
        """
        Return an assembler compatible version of the given imm val op.
        """
        return ida_ua.print_operand(insn.ea, n)

    def format_assembly(self, ea):
        """
        Return assembler compatible disassembly for the given address.

        This function sort re-implements the general instruction printing
        pipeline of the loaded processor module, but just way more shady.
        """
        prefix, mnem, _ = get_disassembly_components(ea)

        #
        # TODO: this 'used' to be used to handle a failure from the above
        # function, but I don't think it is needed anymore. as the above func
        # has been dramatically simplified to parse 'dumber' than it used to
        #
        # it had to do with something with trying to parse/format addresses
        # that would return stuff like 'align 10h' (not real instructions)
        #

        if mnem is None:
            return ''

        #
        # decode the instruction just once so the CPU-specific layers can
        # read and use it to apply specific fixups when needed
        #

        insn = ida_ua.insn_t()
        ida_ua.decode_insn(insn, ea)

        # this will accumulate the final fixed up text for all ops
        ops = []

        # this will hold the fixed up operand text for the current op
        op_text = ''

        #
        # generate the operand text for each op, with callbacks into the
        # processor specific fixups as necessary for each op type
        #

        for op in insn.ops:

            #
            # NOTE/PERF: these if/elif statements have been arranged based on
            # frequency (at least in x86/x64) for performance reasons
            #
            # be careful re-ordering them, as it may make assemble_all(...)
            # run twice as slow!!
            #

            if op.type in [ida_ua.o_reg, ida_ua.o_far, ida_ua.o_near]:
                op_text = ida_ua.print_operand(ea, op.n)

            # reached final operand in this instruction
            elif op.type == ida_ua.o_void:
                break

            #
            # TODO: ideally we should allow users to toggle between 'pretty'
            # and 'raw' displacement / phrase ops, but I think there's keystone /
            # LLVM weirdness that is causing some bad assembly to be generated?
            #
            #       IDA: 'mov     [esp+6Ch+dest], esi'
            #       RAW: 'mov     [esp+6Ch+0xFFFFFF94], esi'
            #  WHICH IS: 'mov     [esp], esi'
            #
            # but this is what keystone 'evaluates' and generates 'bad' asm for
            #
            #       IDA: 'mov     [esp], esi'             -- 89 34 24
            #  keystone: 'mov     [esp+0x100000000], esi' -- 89 74 24 (? invalid asm)
            #
            # this will have to be investigated later. so for now we generate asm
            # without IDA's special offsetting...
            #

            elif op.type in [ida_ua.o_displ, ida_ua.o_phrase]:
                op_text = ida_ua.print_operand(ea, op.n, 0, self._NO_OP_TYPE)

            elif op.type == ida_ua.o_imm:
                op_text = self.format_imm_op(insn, op.n)

            elif op.type == ida_ua.o_mem:
                op_text = self.format_memory_op(insn, op.n)

            else:
                op_text = ida_ua.print_operand(ea, op.n)

            #
            # the operand is marked as invisible according to IDA,
            # so we shouldn't be showing / generating text for it anyway
            # (eg. Op4 for UMULH in ARM64)
            #

            if not(op.flags & ida_ua.OF_SHOW):
                continue

            ops.append(op_text)

        ops = list(map(ida_lines.tag_remove, filter(None, ops)))
        prefix = self.format_prefix(insn, prefix)
        mnem = self.format_mnemonic(insn, mnem)

        if prefix:
            mnem = prefix + ' ' + mnem

        # generate the fully disassembled instruction / text
        text = '%s %s' % (mnem.ljust(7, ' '), ', '.join(ops))

        # TODO/XXX: ehh this should probably be cleaned up / moved in v0.2.0
        for banned in ['[offset ', '(offset ', ' offset ', ' short ', ' near ptr ', ' far ptr ', ' large ']:
            text = text.replace(banned, banned[0])

        return text.strip()

    def unalias(self, assembly):
        """
        Translate an instruction alias / shorthand to its full version.
        """
        return assembly

#------------------------------------------------------------------------------
# x86 / x86_64
#------------------------------------------------------------------------------

class AsmX86(KeystoneAssembler):
    """
    Intel x86 & x64 specific wrapper for Keystone.
    """

    UNCONDITIONAL_JUMP = 'JMP'
    CONDITIONAL_JUMPS = \
    [
        'JZ', 'JE', 'JNZ', 'JNE', 'JC', 'JNC',
        'JO', 'JNO', 'JS', 'JNS', 'JP', 'JPE',
        'JNP', 'JPO', 'JCXZ', 'JECXZ', 'JRCXZ',
        'JG', 'JNLE', 'JGE', 'JNL', 'JL', 'JNGE',
        'JLE', 'JNG', 'JA', 'JNBE', 'JAE', 'JNB',
        'JB', 'JNAE', 'JBE', 'JNA'
    ]

    UNSUPPORTED_MNEMONICS = \
    [
        # intel CET
        'ENDBR32', 'ENDBR64',
        'RDSSPD', 'RDSSPQ',
        'INCSSPD', 'INCSSPQ',
        'SAVEPREVSSP', 'RSTORSSP',
        'WRSSD', 'WRSSQ', 'WRUSSD', 'WRUSSQ',
        'SETSSBSY', 'CLRSSBSY',

        # misc
        'MONITOR', 'MWAIT', 'MONITORX', 'MWAITX',
        'INVPCID',

        # bugged?
        'REPE CMPSW',
    ]

    def __init__(self):
        arch = keystone.KS_ARCH_X86

        if ida_ida.inf_is_64bit():
            mode = keystone.KS_MODE_64
            self.MAX_PREVIEW_BYTES = 7
        elif ida_ida.inf_is_32bit_exactly():
            mode = keystone.KS_MODE_32
            self.MAX_PREVIEW_BYTES = 6
        else:
            mode = keystone.KS_MODE_16

        # initialize keystone-based assembler
        super(AsmX86, self).__init__(arch, mode)

    #--------------------------------------------------------------------------
    # Intel Assembly Formatting / Fixups
    #--------------------------------------------------------------------------

    def format_mnemonic(self, insn, mnemonic):
        original = mnemonic.strip()

        # normalize the mnemonic case for fixup checking
        mnemonic = original.upper()

        if mnemonic == 'RETN':
            return 'ret'
        if mnemonic == 'XLAT':
            return 'xlatb'

        # no mnemonic fixups, return the original
        return original

    def format_memory_op(self, insn, n):

        #
        # because IDA generates some 'non-standard' syntax in favor of human
        # readability, we have to fixup / re-print most memory operands to
        # reconcile them with what the assembler expects.
        #
        # (i'll go through later and document examples of each 'case' below)
        #

        op_text = super(AsmX86, self).format_memory_op(insn, n)
        op_text = ida_lines.tag_remove(op_text)

        #
        # since this is a memory operation, we expect there to be a '[...]'
        # present in the operand text. if there isn't we should try to wrap
        # the appropriate parts of operand with square brackets
        #

        if '[' not in op_text:

            #
            # this case is to wrap segment:offset kind of prints:
            #
            # eg.
            #  - .text:00000001400AD89A 65 48 8B 04 25 58 00+        mov     rax, gs:58h
            #
            # NOTE: the secondary remaining[0] != ':' check is to avoid 'cpp'
            # cases, basically ensuring we are not modifying a '::'
            #
            # eg.
            #  - .text:000000014000A4F2 48 8D 05 EF 14 25 00         lea     rax, const QT::QSplitter::'vftable'
            #

            start, sep, remaining = op_text.partition(':')
            if sep and remaining[0] != ':':
                op_text = start + sep + '[' + remaining + ']'

            #
            # eg.
            #  - .text:08049F52 F6 05 A4 40 0F 08 02         test    byte ptr dword_80F40A4, 2
            #

            elif ' ptr ' in op_text:
                start, sep, remaining = op_text.partition(' ptr ')
                op_text = start + sep + '[' + remaining + ']'

            #
            # eg.
            #  - .text:000000014002F0C6 48 8D 0D 53 B9 E2 00         lea     rcx, unk_140E5AA20
            #

            else:
                op_text = '[' + op_text + ']'

        if ' ptr ' in op_text and self._mode is keystone.KS_MODE_32:
            return op_text

        #
        # TODO: document these cases
        #

        op = insn.ops[n]
        seg_reg = (op.specval & 0xFFFF0000) >> 16

        if seg_reg:
            #print("SEG REG: 0x%X 0x%X" % (op.specval & 0xFFFF, ((op.specval & 0xFFFF0000) >> 16)))
            seg_reg_name = ida_idp.ph.regnames[seg_reg]
            if seg_reg_name == 'cs':
                op_text = op_text.replace('cs:', '')
            elif seg_reg_name not in op_text:
                op_text = '%s:%s' % (seg_reg_name, op_text)

        if ' ptr ' in op_text:
            return op_text

        t_name = get_dtype_name(op.dtype, ida_ua.get_dtype_size(op.dtype))
        op_text = '%s ptr %s' % (t_name, op_text)

        return op_text

    def format_imm_op(self, insn, n):
        op_text = super(AsmX86, self).format_imm_op(insn, n)
        if '$+' in op_text:
            op_text = ida_ua.print_operand(insn.ea, n, 0, self._NO_OP_TYPE)
        return op_text

    def unalias(self, assembly):

        # normalize spacing / capitalization
        parts = list(filter(None, assembly.lower().split(' ')))
        full = ' '.join(parts)
        if not full:
            return assembly

        #
        # IDA64 likes to print 'int 3' for 'CC', but keystone assembles this
        # to 'CD 03'... so we alias 'int 3' to 'int3' here instead which will
        # emit the preferred form 'CC'
        #

        if full == 'int 3':
            return 'int3'

        #
        # TODO/XXX: keystone doesn't know about 'movsd' ? so we correct it
        # here for now ... this will handle 'movsd' / 'rep* movsd'
        #

        if parts[-1] == 'movsd':

            if self._mode & keystone.KS_MODE_64:
                regs = ('rdi', 'rsi')
            else:
                 regs = ('edi', 'esi')

            # preserves prefix ... if there was one
            return assembly + ' dword ptr [%s], dword ptr [%s]' % regs

        # no special aliasing / fixups
        return assembly

#------------------------------------------------------------------------------
# ARM / ARM64
#------------------------------------------------------------------------------

class AsmARM(KeystoneAssembler):
    """
    ARM specific wrapper for Keystone.
    """

    UNCONDITIONAL_JUMP = 'B'
    CONDITIONAL_JUMPS = \
    [
        # ARM
        'BEQ', 'BNE', 'BCC', 'BCS', 'BVC', 'BVS',
        'BMI', 'BPL', 'BHS', 'BLO', 'BHI', 'BLS',
        'BGE', 'BLT', 'BGT', 'BLE'

        # ARM64
        'B.EQ', 'B.NE', 'B.CS', 'B.CC', 'B.MI', 'B.PL',
        'B.VS', 'B.VC', 'B.HI', 'B.LS', 'B.GE', 'B.LT',
        'B.GT', 'B.LE', 'CBNZ', 'CBZ', 'TBZ', 'TBNZ'
    ]

    UNSUPPORTED_MNEMONICS = \
    [
        'ADR', 'ADRL',

        # Pointer Authentication
        'AUTDA', 'AUTDZA', 'AUTDB', 'AUTDZB',
        'AUTIA', 'AUTIA1716', 'AUTIASP', 'AUTIAZ', 'AUTIZA',
        'AUTIB', 'AUTIB1716', 'AUTIBSP', 'AUTIBZ', 'AUTIZB',

        'BLRAA', 'BLRAAZ', 'BLRAB', 'BLRABZ',
        'BRAA',  'BRAAZ', 'BRAB', 'BRABZ',

        'PACDA', 'PACDZA', 'PACDB', 'PACDZB', 'PACGA',
        'PACIA', 'PACIA1716', 'PACIASP', 'PACIAZ', 'PACIZA',
        'PACIB', 'PACIB1716', 'PACIBSP', 'PACIBZ', 'PACIZB',
        'RETAA', 'RETAB',

        'XPACD', 'XPACI', 'XPACLRI'

        # TODO: MRS and MOV (32/64 bit) are semi-supported too
    ]

    def __init__(self):

        # ARM64
        if ida_ida.inf_is_64bit():
            arch = keystone.KS_ARCH_ARM64

            if ida_ida.inf_is_be():
                mode = keystone.KS_MODE_BIG_ENDIAN
            else:
                mode = keystone.KS_MODE_LITTLE_ENDIAN

            # AArch64 does not use THUMB
            self._ks_thumb = None

        # ARM
        else:
            arch = keystone.KS_ARCH_ARM

            if ida_ida.inf_is_be():
                mode = keystone.KS_MODE_ARM | keystone.KS_MODE_BIG_ENDIAN
                self._ks_thumb = keystone.Ks(arch, keystone.KS_MODE_THUMB | keystone.KS_MODE_BIG_ENDIAN)
            else:
                mode = keystone.KS_MODE_ARM | keystone.KS_MODE_LITTLE_ENDIAN
                self._ks_thumb = keystone.Ks(arch, keystone.KS_MODE_THUMB | keystone.KS_MODE_LITTLE_ENDIAN)

        # initialize keystone-based assembler
        super(AsmARM, self).__init__(arch, mode)

        # pre-assemble for later, repeated use
        self.__ARM_NOP_4, _ = self._ks.asm('NOP', as_bytes=True)
        if self._ks_thumb:
            self.__THUMB_NOP_2, _ = self._ks_thumb.asm('NOP', as_bytes=True)
            self.__THUMB_NOP_4, _ = self._ks_thumb.asm('NOP.W', as_bytes=True)

    def asm(self, assembly, ea=0, resolve=True):

        # swap engines when trying to assemble to a THUMB region
        if self.is_thumb(ea):
            ks = self._ks
            self._ks = self._ks_thumb
            data = super(AsmARM, self).asm(assembly, ea, resolve)
            self._ks = ks
            return data

        # assemble as ARM
        return super(AsmARM, self).asm(assembly, ea, resolve)

    @staticmethod
    def is_thumb(ea):
        """
        Return True if the given address is marked as THUMB.
        """
        return bool(ida_segregs.get_sreg(ea, ida_idp.str2reg('T')) == 1)

    def nop_buffer(self, start_ea, end_ea):
        """
        Generate a NOP buffer for the given address range.
        """
        range_size = end_ea - start_ea
        if range_size < 0:
            return bytes()

        #
        # TODO/XXX: how should we handle 'mis-aligned' NOP actions? or
        # truncated range? (eg, not enough bytes to fill as complete NOPs...
        #
        # Should we just reject them here? or attempt to NOP some? Need to
        # ensure UI fails gracefully, etc.
        #

        # the crafted buffer on NOP instructions to return
        nop_list = []

        #
        # with ARM, it is imperative we attempt to retain the size of the
        # instruction being NOP'd. this is to help account for cases such as
        # the ITTT blocks in THUMB:
        #
        # __text:000021A2 1E BF               ITTT NE
        # __text:000021A4 D4 F8 C4 30         LDRNE.W         R3, [R4,#0xC4]
        # __text:000021A8 43 F0 04 03         ORRNE.W         R3, R3, #4
        # __text:000021AC C4 F8 C4 30         STRNE.W         R3, [R4,#0xC4]
        # __text:000021B0 94 F8 58 30         LDRB.W          R3, [R4,#0x58]
        #
        # replacing these 4-byte THUMB instructions with 2-byte THUMB NOP's
        # breaks the intrinsics of the conditional block. therefore, we
        # will attempt to replace THUMB instructions with a NOP of the same
        # size as the original instruction
        #

        cur_ea = ida_bytes.get_item_head(start_ea)
        while cur_ea < end_ea:
            item_size = ida_bytes.get_item_size(cur_ea)

            # special handling to pick THUMB 2 / 4 byte NOP as applicable
            if self.is_thumb(cur_ea):
                if item_size == 2:
                    nop_list.append(self.__THUMB_NOP_2)
                else:
                    nop_list.append(self.__THUMB_NOP_4)

            # NOP'ing a normal 4-byte ARM instruction
            else:
                nop_list.append(self.__ARM_NOP_4)

            # continue to next instruction
            cur_ea += item_size

        # return a buffer of (NOP) instruction bytes
        return b''.join(nop_list)

    #--------------------------------------------------------------------------
    # ARM Assembly Formatting / Fixups
    #--------------------------------------------------------------------------

    def format_memory_op(self, insn, n):
        op = insn.ops[n]

        # ARM / ARM64
        if ida_idp.ph.regnames[op.reg] == 'PC':
            offset = (op.addr - insn.ea) - 8
            op_text = '[PC, #%s0x%X]' % ('-' if offset < 0 else '', abs(offset))
            return op_text

        #
        # TODO: THUMB-ish... note this is kind of groess and should
        # probably be cleaned up / documented better. I don't think it's a
        # fair assumption that all THUMB memory references are PC rel? but
        # maybe that's true. (I'm not an ARM expert)
        #

        elif self.is_thumb(insn.ea):
            offset = (op.addr - insn.ea) - 4 + (insn.ea % 4)
            op_text = '[PC, #%s0x%X]' % ('-' if offset < 0 else '', abs(offset))
            return op_text

        op_text = ida_lines.tag_remove(super(AsmARM, self).format_memory_op(insn, n))

        if op_text[0] == '=':
            op_text = '#0x%X' % op.addr

        return op_text

    def format_imm_op(self, insn, n):
        """
        TODO: this is temporary, until we do work on formatting IDA's
        ARM memory ref 'symbols' (which are often imms on ARM)
        """
        op_text = ida_ua.print_operand(insn.ea, n, 0, self._NO_OP_TYPE)
        return op_text

    def unalias(self, assembly):
        prefix, mnemonic, ops = parse_disassembly_components(assembly)

        # IDA seems to prefer showing 'STMFA', but keystone expects 'STMIB'
        if mnemonic.upper() == 'STMFA':
            return ' '.join([prefix, 'STMIB', ops])

        return assembly

#------------------------------------------------------------------------------
# PPC / PPC64 TODO
#------------------------------------------------------------------------------

class AsmPPC(KeystoneAssembler):

    def __init__(self):
        arch = keystone.KS_ARCH_PPC

        if ida_ida.inf_is_64bit():
            mode = keystone.KS_MODE_PPC64
        else:
            mode = keystone.KS_MODE_PPC32

        # TODO: keystone does not support Little Endian mode for PPC?
        #if arch_name == 'ppc':
        #    mode += keystone.KS_MODE_BIG_ENDIAN

        # initialize keystone-based assembler
        super(AsmPPC, self).__init__(arch, mode)

#------------------------------------------------------------------------------
# MIPS / MIPS64 TODO
#------------------------------------------------------------------------------

class AsmMIPS(KeystoneAssembler):

    def __init__(self):
        arch = keystone.KS_ARCH_MIPS

        if ida_ida.inf_is_64bit():
            mode = keystone.KS_MODE_MIPS64
        else:
            mode = keystone.KS_MODE_MIPS32

        if ida_ida.inf_is_be():
            mode |= keystone.KS_MODE_BIG_ENDIAN
        else:
            mode |= keystone.KS_MODE_LITTLE_ENDIAN

        # initialize keystone-based assembler
        super(AsmMIPS, self).__init__(arch, mode)

#------------------------------------------------------------------------------
# SPARC TODO
#------------------------------------------------------------------------------

class AsmSPARC(KeystoneAssembler):

    def __init__(self):
        arch = keystone.KS_ARCH_SPARC

        if ida_ida.inf_is_64bit():
            mode = keystone.KS_MODE_SPARC64
        else:
            mode = keystone.KS_MODE_SPARC32

        if ida_ida.inf_is_be():
            mode |= keystone.KS_MODE_BIG_ENDIAN
        else:
            mode |= keystone.KS_MODE_LITTLE_ENDIAN

        # initialize keystone-based assembler
        super(AsmSPARC, self).__init__(arch, mode)

#------------------------------------------------------------------------------
# System-Z
#------------------------------------------------------------------------------

class AsmSystemZ(KeystoneAssembler):

    def __init__(self):
        super(AsmSystemZ, self).__init__(keystone.KS_ARCH_SYSTEMZ, keystone.KS_MODE_BIG_ENDIAN)

```

`patching/core.py`:

```py
import shutil
import hashlib
import collections

import ida_ua
import ida_auto
import ida_nalt
import ida_bytes
import ida_lines
import ida_idaapi
import ida_loader
import ida_kernwin
import ida_segment
import idautils

from patching.asm import *
from patching.actions import *
from patching.exceptions import *

from patching.util.ida import *
from patching.util.misc import plugin_resource
from patching.util.python import register_callback, notify_callback

#------------------------------------------------------------------------------
# Plugin Core
#------------------------------------------------------------------------------
#
#     The plugin core constitutes the traditional 'main' plugin class. It
#     will host all of the plugin's objects and integrations, taking
#     responsibility for their initialization/teardown/lifetime.
#
#     This pattern of splitting out the plugin core from the IDA plugin_t stub
#     is primarily to help separate the plugin functionality from IDA's and
#     make it easier to 'reload' for development / testing purposes.
#

class PatchingCore(object):

    PLUGIN_NAME    = 'Patching'
    PLUGIN_VERSION = '0.3.0'
    PLUGIN_AUTHORS = 'Markus Gaasedelen'
    PLUGIN_DATE    = '2025'

    def __init__(self, defer_load=False):

        # IDA UI Hooks
        self._ui_hooks = UIHooks()
        self._ui_hooks.ready_to_run = self.load
        self._ui_hooks.hook()

        # IDA 'Processor' Hooks
        self._idp_hooks = IDPHooks()
        self._idp_hooks.ev_ending_undo = self._ida_undo_occurred

        # IDA 'Database' Hooks
        self._idb_hooks = IDBHooks()
        if ida_kernwin.cvar.batch:
            self._idb_hooks.auto_empty_finally = self.load
        self._idb_hooks.byte_patched = self._ida_byte_patched
        self._idb_hooks.hook()

        # the backing engine to assemble instructions for the plugin
        self.assembler = None

        # a set of all addresses patched by the user
        self.patched_addresses = set()

        # the executable filepath that patches were applied to
        self.patched_filepath = None

        # the executable filepath used to apply patches from (the clean file)
        self.backup_filepath = None

        # apply saved patches from a known-good (clean) executable by default
        self.prefer_patch_cleanly = True

        # enable quick save after a successful patch application occurs
        self.prefer_quick_apply = True
        self.__saved_successfully = False

        # plugin events / callbacks
        self._patches_changed_callbacks = []
        self._refresh_timer = None

        #
        # defer fully loading the plugin core until the IDB and UI itself
        # is settled. in this case, self.load() will be called later on
        # by IDA's UI ready_to_run event (or auto_empty_finally in batch)
        #

        if defer_load:
            return

        #
        # if loading is not being deferred, we have to load the plugin core
        # now. this is only used for development purposes such as 'hot
        # reloading' the plugin via the IDA console (DEV)
        #

        self.load()

    #--------------------------------------------------------------------------
    # Initialization / Teardown
    #--------------------------------------------------------------------------

    def load(self):
        """
        Load the plugin core.
        """

        # attempt to initialize an assembler engine matching the database
        self._init_assembler()

        # deactivate the plugin if this is an unsupported architecture
        if not self.assembler:
            self._ui_hooks.unhook()
            return

        # enable additional hooks since the plugin is going live
        self._ui_hooks.populating_widget_popup = self._populating_widget_popup
        self._ui_hooks.get_lines_rendering_info = self._highlight_lines

        # finish loading the plugin and integrating its UI elements / actions
        self._init_actions()
        self._idp_hooks.hook()
        self._refresh_patches()

        print("[%s] Loaded v%s - (c) %s - %s" % (self.PLUGIN_NAME, self.PLUGIN_VERSION, self.PLUGIN_AUTHORS, self.PLUGIN_DATE))

        # parse / handle command line options for this plugin (DEV)
        self._run_cli_options()

    def unload(self):
        """
        Unload the plugin core.
        """
        self._idb_hooks.unhook()

        if not self.assembler:
            return

        print("[%s] Unloading v%s..." % (self.PLUGIN_NAME, self.PLUGIN_VERSION))

        if self._refresh_timer:
            ida_kernwin.unregister_timer(self._refresh_timer)
            self._refresh_timer = None

        self._idb_hooks.unhook()
        self._idp_hooks.unhook()
        self._ui_hooks.unhook()
        self._unregister_actions()
        self._unload_assembler()

    def _init_assembler(self):
        """
        Initialize the assembly engine to be used for patching.
        """
        arch_name = ida_ida.inf_get_procname()

        if arch_name == 'metapc':
            assembler = AsmX86()
        elif arch_name.startswith('arm') or arch_name.startswith('ARM'):
            assembler = AsmARM()

        #
        # TODO: disabled until v0.2.0
        #
        #elif arch_name.startswith("ppc"):
        #    assembler = AsmPPC(inf)
        #elif arch_name.startswith("mips"):
        #    assembler = AsmMIPS(inf)
        #elif arch_name.startswith("sparc"):
        #    assembler = AsmSPARC(inf)
        #elif arch_name.startswith("systemz") or arch_name.startswith("s390x"):
        #    assembler = AsmSystemZ(inf)
        #

        else:
            assembler = None
            print(" - Unsupported CPU: '%s' (%s)" % (arch_name, ida_nalt.get_input_file_path()))

        self.assembler = assembler

    def _unload_assembler(self):
        """
        Unload the assembly engine.
        """

        #
        # NOTE: this is kind of aggressive attempt at deleting the assembler
        # and Keystone components in an effort to keep things safe if the user
        # is trying to do an easy install (updating) over the existing plugin
        #
        # read the install.py script (easy install) for a bit more context of
        # why we're trying to minimize exposure to Keystone on unload
        #

        del self.assembler._ks
        del self.assembler
        self.assembler = None

    def _init_actions(self):
        """
        Initialize all IDA plugin actions.
        """

        # initialize new actions provided by this plugin
        for action in PLUGIN_ACTIONS:

            # load and register an icon for our action if one is defined
            if action.ICON:
                icon_path = plugin_resource(action.ICON)
                icon_id = ida_kernwin.load_custom_icon(icon_path)
            else:
                icon_id = -1

            # instantiate an action description to register with IDA
            desc = ida_kernwin.action_desc_t(
                action.NAME,
                action.TEXT,
                action(self),
                action.HOTKEY,
                action.TOOLTIP,
                icon_id
            )

            if not ida_kernwin.register_action(desc):
                print("Failed to register action '%s'" % action.NAME)

        # inject plugin's NOP action into IDA's edit submenu
        ida_kernwin.attach_action_to_menu("Edit/Patch program/Change byte...", "patching:nop", ida_kernwin.SETMENU_INS)

        # supersede IDA's default "Assemble" action with our own
        ida_kernwin.update_action_state("Assemble", ida_kernwin.AST_DISABLE_ALWAYS)
        ida_kernwin.update_action_visibility("Assemble", False)
        ida_kernwin.attach_action_to_menu("Edit/Patch program/Change word...", "patching:assemble", ida_kernwin.SETMENU_APP)

        # supersede IDA's default "Apply patches" action with our own
        ida_kernwin.update_action_state("ApplyPatches", ida_kernwin.AST_DISABLE_ALWAYS)
        ida_kernwin.update_action_visibility("ApplyPatches", False)
        ida_kernwin.attach_action_to_menu("Edit/Patch program/Patched bytes...", "patching:apply", ida_kernwin.SETMENU_APP)

    def _unregister_actions(self):
        """
        Remove all plugin actions registered with IDA.
        """
        for action in PLUGIN_ACTIONS:

            # fetch icon ID before we unregister the current action
            valid_id, icon_id = ida_kernwin.get_action_icon(action.NAME)

            # unregister the action from IDA
            if not ida_kernwin.unregister_action(action.NAME):
                print("Failed to unregister action '%s'" % action.NAME)

            # delete the icon now that the action should no longer be using it
            if valid_id:
                ida_kernwin.free_custom_icon(icon_id)

        # restore IDA actions that we had overridden
        ida_kernwin.update_action_state("Assemble", ida_kernwin.AST_ENABLE)
        ida_kernwin.update_action_visibility("Assemble", True)
        ida_kernwin.update_action_state("ApplyPatches", ida_kernwin.AST_ENABLE)
        ida_kernwin.update_action_visibility("ApplyPatches", True)

    def _run_cli_options(self):
        """
        Run plugin actions based on command line flags (DEV).
        """
        options = ida_loader.get_plugin_options('Patching')
        if not options:
            return

        # run the 'assemble_all' test with CLI flag -OPatching:assemble
        for option in options.split(':'):
            if option == 'assemble':
                self.assemble_all()

    #--------------------------------------------------------------------------
    # Plugin API
    #--------------------------------------------------------------------------

    def is_byte_patched(self, ea):
        """
        Return True if the byte at the given address has been patched.
        """
        return self.is_range_patched(ea, ea+1)

    def is_item_patched(self, ea):
        """
        Return True if a patch exists within the item at the given address.
        """
        item_size = ida_bytes.get_item_size(ea)
        return self.is_range_patched(ea, ea+item_size)

    def is_range_patched(self, start_ea, end_ea):
        """
        Return True if a patch exists within the given address range.
        """
        if start_ea == (end_ea + 1):
            return start_ea in self.patched_addresses
        return bool(self.patched_addresses & set(range(start_ea, end_ea)))

    def get_patch_at(self, ea):
        """
        Return information about a patch at the given address.

        On success, returns (True, start_ea, patch_size) for the patch.
        """
        if not self.is_item_patched(ea):
            return (False, ida_idaapi.BADADDR, 0)

        #
        # NOTE: this code seems 'overly complicated' because it tries to group
        # visually contiguous items that appear as 'one' patched region in
        # IDA, even if not all of the bytes within each item were changed.
        #
        # TODO/Hex-Rays: this kind of logic/API is probably something that
        # should be moved in-box as part of a 'patch metadata' overhaul
        #

        if ida_bytes.is_unknown(ida_bytes.get_flags(ea)):
            forward_ea = ea
            reverse_ea = ea - 1
        else:
            forward_ea = ida_bytes.get_item_head(ea)
            reverse_ea = ida_bytes.prev_head(forward_ea, 0)

        # scan forwards for the 'end' of the patched region
        while forward_ea != ida_idaapi.BADADDR:
            item_size = ida_bytes.get_item_size(forward_ea)
            item_addresses = set(range(forward_ea, forward_ea + item_size))
            forward_ea = forward_ea + item_size
            if not (item_addresses & self.patched_addresses):
                forward_ea -= item_size
                break

        # scan backwards for the 'start' of the patched region
        while reverse_ea != ida_idaapi.BADADDR:
            item_size = ida_bytes.get_item_size(reverse_ea)
            item_addresses = set(range(reverse_ea, reverse_ea + item_size))
            if not (item_addresses & self.patched_addresses):
                reverse_ea += item_size # revert to last 'hit' item
                break
            reverse_ea -= item_size

        # info about the discovered patch
        start_ea = reverse_ea
        end_ea = forward_ea
        length = forward_ea - reverse_ea
        #print("Found patch! 0x%08X --> 0x%08X (%u bytes)" % (start_ea, end_ea, length))

        return (True, start_ea, length)

    def assemble(self, assembly, ea):
        """
        Assemble and return bytes for the given assembly text.
        """
        return self.assembler.asm(assembly, ea)

    def nop_item(self, ea):
        """
        NOP the item at the given address.
        """
        nop_size = ida_bytes.get_item_size(ea)
        return self.nop_range(ea, ea+nop_size)

    def nop_range(self, start_ea, end_ea):
        """
        NOP all of the bytes within the given address range.
        """
        if start_ea == end_ea:
            return False

        # generate a buffer of NOP data hinted at by the existing database / instructions
        nop_buffer = self.assembler.nop_buffer(start_ea, end_ea)

        # patch the specified region with NOP bytes
        self.patch(start_ea, nop_buffer, fill_nop=False)
        return True

    def revert_patch(self, ea):
        """
        Revert all the modified bytes within a patch at the given address.
        """
        found, start_ea, length = self.get_patch_at(ea)
        if not found:
            return False
        self.revert_range(start_ea, start_ea+length)
        return True

    def revert_range(self, start_ea, end_ea):
        """
        Revert all the modified bytes within the given address range.
        """

        # revert bytes to their original value within the target region
        for ea in range(start_ea, end_ea):
            ida_bytes.revert_byte(ea)

        # 'undefine' the reverted bytes (helps with re-analysis)
        length = end_ea - start_ea
        ida_bytes.del_items(start_ea, ida_bytes.DELIT_KEEPFUNC, length)

        #
        # if the reverted patch seems to be in a code-ish area, we tell the
        # auto-analyzer to try and analyze it as code
        #

        if ida_bytes.is_code(ida_bytes.get_flags(ida_bytes.prev_head(start_ea, 0))):
            ida_auto.auto_mark_range(start_ea, end_ea, ida_auto.AU_CODE)

        # attempt to re-analyze the reverted region
        ida_auto.plan_and_wait(start_ea, end_ea, True)

        #
        # having just reverted the bytes to their original values on the IDA
        # side of things, we now have to ensure these addresses are no longer
        # tracked by our plugin as 'patched'
        #

        self.patched_addresses -= set(range(start_ea, end_ea))
        ida_kernwin.execute_sync(self._notify_patches_changed, ida_kernwin.MFF_NOWAIT|ida_kernwin.MFF_WRITE)
        return True

    def force_jump(self, ea):
        """
        Force a conditional jump to be unconditional at the given address.
        """
        mnemonic = ida_ua.print_insn_mnem(ea)

        # if the given address is not a conditional jump, ignore the request
        if not self.assembler.is_conditional_jump(mnemonic):
            return False

        # fetch the target address
        target = next(idautils.CodeRefsFrom(ea, False))

        # assemble an unconditional jump with the same jump target
        patch_code = "%s 0x%X" % (self.assembler.UNCONDITIONAL_JUMP, target)
        patch_data = self.assembler.asm(patch_code, ea)

        # write the unconditional jump patch to the database
        self.patch(ea, patch_data)
        return True

    def patch(self, ea, patch_data, fill_nop=True):
        """
        Write patch data / bytes to a given address.
        """
        patch_size = len(patch_data)

        # incoming patch matches existing data, nothing to do
        original_data = ida_bytes.get_bytes(ea, patch_size)
        if original_data == patch_data:
            return

        next_address = ea + patch_size
        inst_start = ida_bytes.get_item_head(next_address)
        if ida_bytes.is_code(ida_bytes.get_flags(inst_start)):

            # if the patch clobbers part of an instruction, fill it with NOP
            if inst_start < next_address:
                inst_size = ida_bytes.get_item_size(inst_start)
                fill_size = (inst_start + inst_size) - next_address
                self.nop_range(next_address, next_address+fill_size)
                ida_auto.auto_make_code(next_address)

        #
        # write the actual patch data to the database. we also unhook the IDB
        # events to prevent the plugin from seeing the numerous 'patch' events
        # that IDA will generate as we write the patch data to the database
        #

        self._idb_hooks.unhook()
        ida_bytes.patch_bytes(ea, patch_data)
        self._idb_hooks.hook()

        #
        # record the region of patched addresses
        #

        addresses = set(range(ea, ea+patch_size))
        if is_range_patched(ea, ea+patch_size):
            self.patched_addresses |= addresses

        #
        # according to IDA, none of the 'patched' addresses in the database
        # actually have a different value... so they technically were not
        # patched (eg. maybe they were patched back to their ORIGINAL value!)
        #
        # in this case it means the patching plugin shouldn't see these
        # addresses as patched, either...
        #

        else:
            self.patched_addresses -= addresses

        # request re-analysis of the patched range
        ida_auto.auto_mark_range(ea, ea+patch_size, ida_auto.AU_USED)
        ida_kernwin.execute_sync(self._notify_patches_changed, ida_kernwin.MFF_NOWAIT|ida_kernwin.MFF_WRITE)

    def apply_patches(self, target_filepath, clean=False):
        """
        Apply the current patches to the given filepath.
        """
        self.__saved_successfully = False

        #
        # ensure that a 'clean' source executable exists for this operation,
        # and then write (or overwrite) the target filepath with the clean
        # file so that we can apply patches to it from a known-good state
        #

        if clean:
            self.backup_filepath = self._ensure_clean_backup(target_filepath)

            #
            # due to the variety of errors that may occur from trying to copy
            # a file, we simply trap them all to a more descriptive issue for
            # what action failed in the context of our patching attempt
            #

            try:
                shutil.copyfile(self.backup_filepath, target_filepath)
            except Exception:
                raise PatchTargetError("Failed to overwrite patch target with a clean executable", target_filepath)

        #
        # attempt to apply the patches to the target filepath
        #
        # NOTE: this 'Exception' catch-all is probably a bit too liberal,
        # instead we should probably have apply_patches(...) raise a generic
        # error if opening the target file for writing fails, leaving any
        # other (unexpected!) patching exceptions uncaught
        #

        try:
            apply_patches(target_filepath)
        except Exception:
            raise PatchApplicationError("Failed to write patches into the target file", target_filepath)

        # patching seems successful? update the stored filepath to the patched binary
        self.patched_filepath = target_filepath

        #
        # if we made it this far, we assume the file on disk was patched
        # setting __saved_successfully ensures that we start showing the
        # 'quick apply' right click context menu going forward
        #
        # this is to help cut down on crowding the right click menu only
        # until the user explicitly starts using the patching plugin, but
        # also applying their patches to a a binary
        #

        if self.prefer_quick_apply:
            self.__saved_successfully = True

    def quick_apply(self):
        """
        Apply the current patches using the last-known settings.
        """

        try:
            self.apply_patches(self.patched_filepath, self.prefer_patch_cleanly)
        except Exception as e:
            return (False, e)

        return (True, None)

    #--------------------------------------------------------------------------
    # Plugin Internals
    #--------------------------------------------------------------------------

    def _ensure_clean_backup(self, target_filepath):
        """
        Return True if a clean executable matching the open IDB is available on disk.
        """

        #
        # TODO: what do we do if one/both of these are invalid or blank?
        # such as a blank or tmp IDB? what do they return in this case?
        #

        input_md5 = ida_nalt.retrieve_input_file_md5()
        input_filepath = ida_nalt.get_input_file_path()

        #
        # we will search this list of filepaths for an executable / source
        # file that matches the reported hash of the file used to generate
        # this IDA database
        #

        filepaths = [target_filepath, self.backup_filepath, input_filepath]
        filepaths = list(filter(None, filepaths))

        # search the list of filepaths for a clean file
        while filepaths:

            # get the next filepath to evaluate
            filepath = filepaths.pop(0)

            #
            # if the given filepath does not end with a '.bak', push a version
            # of the current filepath with that extension to make for a more
            # comprehensive search of a clean backup file
            #
            # we insert this at the front of the list because it should be
            # searched next (the list is kind of ordered by relevance already)
            #

            if not filepath.endswith('.bak'):
                filepaths.insert(0, filepath + '.bak')

            #
            # attempt to read (and then hash) each file that is being
            # considered as a possible source for our clean backup
            #

            try:
                disk_data = open(filepath, 'rb').read()
            except Exception as e:
                #print(" - Failed to read '%s' -- Reason: %s" % (filepath, str(e)))
                continue

            disk_md5 = hashlib.md5(disk_data).digest()

            #
            # MD5 of the tested file does not match the ORIGINAL (clean) file
            # so we simply ignore it cuz it is useless for our purposes
            #

            if disk_md5 != input_md5:
                #print(" - MD5: '%s' -- does not match IDB (probably previously patched)" % filepath)
                continue

            #
            # the MD5 matches between the original executable hash provided by
            # IDA and a hashed file on disk. use this as the source filepath
            # for our dialog
            #

            clean_filepath = filepath
            #print(" - Found unpatched binary! '%s'" % filepath)
            break

        #
        # if we did not break from the loop above, that means we could not
        # find an executable with a hash that is deemed valid to cleanly
        # patch from, so there is nothing else we can do
        #

        else:
            raise PatchBackupError("Failed to locate a clean executable")

        #
        # we have verified that a clean version of the executable matching
        # this database exists on-disk.
        #
        # in the case below, the clean file (presumably a '.bak' file that
        # was previously created) is not at risk of getting overwritten as
        # target_filepath is where the resulting / patched binary is going
        # to be written by the ongoing save action
        #
        # nothing else to do but return success
        #

        if clean_filepath != target_filepath:
            return clean_filepath

        #
        # if the clean filepath does not match the target (output) path, we
        # make a copy of the file and add a '.bak' extension to it as we don't
        # want to overwrite potentially the only clean copy of the file
        #
        # in this case, the user is probably patching foo.exe for the first
        # time, so we are going to be creating foo.exe.bak here
        #

        clean_filepath += '.bak'

        #
        # before attempting to make a clean file backup, we can try checking
        # the hash of the existing file (if there is one) ...
        #
        # if the hash matches what we expect of the clean backup, then the
        # file appears to be readable and sufficient to use as a backup as-is
        #

        try:
            clean_md5 = hashlib.md5(open(clean_filepath, 'rb').read()).digest()
            if clean_md5 == input_md5:
                return clean_filepath

        #
        # failed to read/hash file? maybe it doesn't exist... or it's not
        # readable/writable (locked?) in which case the next action will
        # fail and throw the necessary exception for us instead
        #

        except:
            pass

        #
        # finally, attempt to make the backup of our patch target, as it
        # doesn't seem to exist yet (... or we can't seem to read the file,
        # in which case we're trying a last ditch attempt at overwriting it)
        #

        try:
            shutil.copyfile(target_filepath, clean_filepath)

        #
        # if we failed to write (overwrite?) the desired file for our clean
        # backup, then we cannot ensure that a clean backup exists
        #

        except Exception as e:
            raise PatchBackupError("Failed to write backup executable", clean_filepath)

        # all done
        return clean_filepath

    def _refresh_patches(self):
        """
        Refresh the list of patched addresses directly from the database.
        """
        addresses = set()

        def visitor(ea, file_offset, original_value, patched_value):
            addresses.add(ea)
            return 0

        ida_bytes.visit_patched_bytes(0, ida_idaapi.BADADDR, visitor)
        self.patched_addresses = addresses
        ida_kernwin.execute_sync(self._notify_patches_changed, ida_kernwin.MFF_NOWAIT|ida_kernwin.MFF_WRITE)

    def __deferred_refresh_callback(self):
        """
        A deferred callback to refresh the list of patched addresses.
        """
        self._refresh_timer = None
        self._refresh_patches()
        return -1 # unregisters the timer

    #--------------------------------------------------------------------------
    # Plugin Events
    #--------------------------------------------------------------------------

    def patches_changed(self, callback):
        """
        Subscribe a callback for patch change events.
        """
        register_callback(self._patches_changed_callbacks, callback)

    def _notify_patches_changed(self):
        """
        Notify listeners that the patches changed.
        """

        #
        # this function is supposed to notify the plugin components (such as
        # UI) that they should refresh because their data may be stale.
        #
        # currently, the plugin calls this function via async (MFF_FAST)
        # callbacks queued with execute_sync().
        #
        # the reason we do this is because we need to give IDA some time to
        # process pending actions/events/analysis/ui (etc.) after patching
        # or reverting bytes.
        #
        # if we don't execute 'later' (MFF_FAST), some things like generating
        # disassembly text for a patched instruction may be ... wrong or
        # incomplete (eg )
        #

        notify_callback(self._patches_changed_callbacks)

        # ensure the IDA views are refreshed so highlights are updated
        ida_kernwin.refresh_idaview_anyway()

        # for execute_sync(...)
        return 1

    #--------------------------------------------------------------------------
    # IDA Events
    #--------------------------------------------------------------------------

    def _populating_widget_popup(self, widget, popup, ctx):
        """
        IDA is populating the context menu for a widget.
        """
        is_idaview = False

        # IDA disassembly view
        if ida_kernwin.get_widget_type(widget) == ida_kernwin.BWN_DISASM:
            is_idaview = True

        # custom / interactive patching view
        elif ida_kernwin.get_widget_title(widget) == 'PatchingCodeViewer':
            pass

        # other IDA views that we don't care to inject actions into
        else:
            return

        # fetch the 'right clicked' instruction address
        clicked_ea = get_current_ea(ctx)

        #
        # check if the user has 'selected' any amount of text in the widget.
        #
        # it is important we use this method/API so that we can best position
        # our patching actions within the right click context menu (by
        # predicting what else will be visible in the menu).
        #

        p0, p1 = ida_kernwin.twinpos_t(), ida_kernwin.twinpos_t()
        range_selected = ida_kernwin.read_selection(widget, p0, p1)

        valid_ea, start_ea, end_ea = read_range_selection(ctx)
        if not valid_ea:
            start_ea = clicked_ea

        # determine if the user selection or right click covers a patch
        if (range_selected and valid_ea):
            #print("User range: 0x%08X --> 0x%08X" % (start_ea, end_ea))
            show_revert = self.is_range_patched(start_ea, end_ea)
        else:
            #print("User click: 0x%08X" % clicked_ea)
            show_revert = self.is_item_patched(clicked_ea)

        # determine if the user right clicked code
        is_code = ida_bytes.is_code(ida_bytes.get_flags(clicked_ea))

        #
        # attempt to 'pin' the patching actions towards the top of the right
        # click context menu. we do this by 'appending' our 'NOP' action after
        # a built-in action that we expect to be near the top of the menu.
        #
        # NOTE: IDA shows 'different' commands based on the context and state
        # during the right click. that is why we try to aggressively identify
        # what will be in the right click menu so that we can consistently
        # pin our actions in the desired location
        #

        if range_selected:

            if ida_segment.segtype(start_ea) == ida_segment.SEG_CODE:
                ida_kernwin.attach_action_to_popup(widget, popup, NopAction.NAME, "Analyze selected area", ida_kernwin.SETMENU_APP)
            else:
                ida_kernwin.attach_action_to_popup(widget, popup, NopAction.NAME, "Abort selection", ida_kernwin.SETMENU_APP)

            #
            # TODO: lol there's probably a better way to do this, but I'm
            # writing this fix a little bit late. we basically are trying to
            # check if the user has a visual selection spanning multiple lines
            #
            # if multiple lines are selected, we don't want to show the
            # 'Assemble' command. as it is unlikely that the user right
            # right clicking a selected range to explicitly assemble
            #
            # that said, if the user only selected a few chars on the SAME
            # line it may have been an unintentional 'range selection' in
            # in which case we DO want to show 'Assemble'
            #

            p0s = p0.place_as_simpleline_place_t()
            p1s = p1.place_as_simpleline_place_t()
            multi_line_selection = p0s.n != p1s.n

        else:
            ida_kernwin.attach_action_to_popup(widget, popup, NopAction.NAME, "Rename", ida_kernwin.SETMENU_APP)
            multi_line_selection = False

        #
        # PREV_ACTION will hold the 'most recent' action we appended to the
        # menu. this is done to simplify the remaining code while appending
        # our subsequent patching actions.
        #

        PREV_ACTION = NopAction.TEXT

        # if the user right clicked a single instruction...
        if is_code and not (range_selected and multi_line_selection):

            # inject the 'assemble' action (but not in the patching dialog)
            if is_idaview:
                ida_kernwin.attach_action_to_popup(widget, popup, AssembleAction.NAME, PREV_ACTION, ida_kernwin.SETMENU_APP)
                PREV_ACTION = AssembleAction.TEXT

            # inject the 'force jump' action if a conditional jump was right clicked
            mnemonic = ida_ua.print_insn_mnem(clicked_ea)
            if self.assembler.is_conditional_jump(mnemonic):
                ida_kernwin.attach_action_to_popup(widget, popup, ForceJumpAction.NAME, PREV_ACTION, ida_kernwin.SETMENU_APP)
                PREV_ACTION = ForceJumpAction.TEXT

        # if the user selected some patched bytes, show the 'revert' action
        if show_revert:
            ida_kernwin.attach_action_to_popup(widget, popup, RevertAction.NAME, PREV_ACTION, ida_kernwin.SETMENU_APP)
            PREV_ACTION = RevertAction.TEXT

        #
        # if the user has 'saved' patches at any point this session, we should
        # show them the quick save option as they are likely going to save
        # patches again at some point...
        #

        if self.__saved_successfully:
            ida_kernwin.attach_action_to_popup(widget, popup, QuickApplyAction.NAME, PREV_ACTION, ida_kernwin.SETMENU_APP)
            PREV_ACTION = QuickApplyAction.TEXT

        #
        # TODO/Hex-Rays: is there no way to define/append a submenu with my
        # action group??? I want to put 'Patching --> ...' after my last action
        # and not at the *very end* of the right click menu...
        #
        #  e.g. +---------------------+
        #       | Rename...           |
        #       |---------------------+
        #       | NOP                 |
        #       | Assemble...         |
        #       | Patching --------------->-+-----------------+
        #       +---------------------+     | Change bytes... |
        #       | Jump to operand     |     |      ...        |
        #       | Jump in a new ...   |     '                 '
        #       |        ...          |
        #
        # for now, we use the following 'HACK' API to create a submenu at the
        # preferred location in the right click context menu
        #

        self._patching_submenu = attach_submenu_to_popup(popup, "Patching", PREV_ACTION)

        # extended list of 'less common' actions saved under a patching submenu
        ida_kernwin.attach_action_to_popup(widget, popup, "PatchByte", "Patching/")
        ida_kernwin.attach_action_to_popup(widget, popup, "PatchedBytes", "Patching/")
        ida_kernwin.attach_action_to_popup(widget, popup, ApplyAction.NAME, "Patching/")

        # insert start spacer before / after our action group
        ida_kernwin.attach_action_to_popup(widget, popup, "-", NopAction.TEXT, ida_kernwin.SETMENU_INS)
        ida_kernwin.attach_action_to_popup(widget, popup, "-", "Patching/", ida_kernwin.SETMENU_APP)

    def _highlight_lines(self, out, widget, rin):
        """
        IDA is drawing disassembly lines and requesting highlighting info.
        """

        # if there are no patches, there is nothing to highlight
        if not self.patched_addresses:
            return

        # ignore line highlight events that are not for a disassembly view
        if ida_kernwin.get_widget_type(widget) != ida_kernwin.BWN_DISASM:
            return

        # cache item heads that have been checked for patches
        ignore_item_ea = set()
        highlight_item_ea = set()

        # highlight lines/addresses that have been patched by the user
        for section_lines in rin.sections_lines:
            for line in section_lines:
                line_ea = line.at.toea()

                #
                # fast path to ignore entire items that have not been patched
                # but may span multiple lines in the disassembly view
                #

                item_head = ida_bytes.get_item_head(line_ea)
                if item_head in ignore_item_ea:
                    continue

                #
                # this is a fast-path to avoid having to re-check an entire
                # item if the current line address has already been checked
                # and determined to contain an applied patch.
                #

                if line_ea in highlight_item_ea:

                    # highlight the line if it is patched in some way
                    e = ida_kernwin.line_rendering_output_entry_t(line)
                    e.bg_color = ida_kernwin.CK_EXTRA2
                    e.flags = ida_kernwin.LROEF_FULL_LINE

                    # save the highlight to the output line highlight list
                    out.entries.push_back(e)
                    continue

                #
                # for lines of IDA disas that normally have a small number of
                # backing bytes (such as an instruction or simple data item)
                # we explode it out to its individual addresses and use sets
                # to check if any bytes within it have been patched
                #
                # this scales well to an infinite number of patched bytes
                #

                item_len = ida_bytes.get_item_size(line_ea)
                end_ea = line_ea + item_len

                if item_len <= 256:
                    line_addresses = set(range(line_ea, end_ea))
                    if not(line_addresses & self.patched_addresses):
                        ignore_item_ea.add(line_ea)
                        continue

                #
                # for lines with items that are reportedly quite 'large' (maybe
                # a struct, array, alignment directive, etc.) where a line may
                # contribute to an item that's tens of thousands of bytes...
                #
                # we will instead loop through all of the patched addresses
                # to see if any of them fall within the range of the line.
                #
                # it seems unlikely that the user will ever have very many
                # patched bytes (maybe hundreds?) versus generating a large
                # set and checking potentially tens of thousands of addresses
                # that make up an item, like the above condition would
                #
                # NOTE: this was a added during a slight re-factor of this
                # function / logic to help minimize the chance of notable lag
                # when scrolling past large data structures in the disas view
                #

                elif not any(line_ea <= ea < end_ea for ea in self.patched_addresses):
                    ignore_item_ea.add(line_ea)
                    continue

                # highlight the line if it is patched in some way
                e = ida_kernwin.line_rendering_output_entry_t(line)
                e.bg_color = ida_kernwin.CK_EXTRA2
                e.flags = ida_kernwin.LROEF_FULL_LINE

                # save the highlight to the output line highlight list
                out.entries.push_back(e)
                highlight_item_ea.add(line_ea)

    def _ida_undo_occurred(self, action_name, is_undo):
        """
        IDA completed an Undo / Redo action.
        """

        #
        # if the user happens to use IDA's native UNDO or REDO functionality
        # we will completely discard our tracked set of patched addresses and
        # query IDA for the true, current set of patches
        #

        self._refresh_patches()
        return 0
    
    def _ida_byte_patched(self, ea, old_value):
        """
        IDA is reporting a byte has been patched.
        """

        #
        # if a timer already exists, unregister it so that we can register a
        # new one. this is to effectively resest the timer as patched bytes
        # are coming in 'rapidly' (eg. externally scripted patches, etc)
        #

        if self._refresh_timer:
            ida_kernwin.unregister_timer(self._refresh_timer)
        
        #
        # register a timer to wait 200ms before doing a full reset of the
        # patched addresses. this is to help 'batch' the changes
        #

        self._refresh_timer = ida_kernwin.register_timer(200, self.__deferred_refresh_callback)

    #--------------------------------------------------------------------------
    # Temp / DEV / Tests
    #--------------------------------------------------------------------------

    #
    # HACKER'S SECRET
    #
    # this section is purely for testing / development / profiling. it may be
    # messy, out of place, transient, incomplete, broken, unsupported etc.
    #
    # if you want to hack on this plugin or are trying to edit / dev on the
    # codebase, you can quickly 'reload' the plugin without actually having
    # to restart IDA to test your changes in *most* cases.
    #
    # in the IDA console, you can use:
    #
    #    patching.reload()
    #
    # additionally, you can call into parts of the loaded plugin instance
    # from the IDA console for testing certain parts:
    #
    #    patching.core.nop_item(here())
    #
    # finally, to 'test' assembling all of the instructions in your IDB (to
    # try and identify assembly issues or unsupported instructions) you can
    # run the following command:
    #
    #    patching.core.assemble_all()
    #
    # this may be slow and take several minutes (sometimes much longer) to
    # run depending on the size of the IDB
    #

    def profile(self):
        """
        Profile assemble_all(...) to

        NOTE: you should probably only call this in 'small' databases.
        """
        import pprofile
        prof = pprofile.Profile()
        with prof():
            self.assemble_all()
        prof.print_stats()

    def parse_all(self):
        for ea in all_instruction_addresses(0):
            ida_auto.show_addr(ea)
            comps = get_disassembly_components(ea)
            if comps[0]:
                print("%08X: %s" % (ea, str(comps)))

    def assemble_all(self):
        """
        Attempt to re-assemble every instruction in the IDB, byte-for-byte.

        TODO: build out some actual dedicated tests
        """
        import time, datetime
        start_time = time.time()
        start = 0

        headless = ida_kernwin.cvar.batch

        # the number of correctly re-assembled instructions
        good = 0
        total = 0
        fallback = 0
        unsupported = 0
        unsupported_map = collections.defaultdict(int)

        slow_limit = -1
        asm_threshold = 0.1

        # track failures
        fail_addrs = collections.defaultdict(list)
        fail_bytes = collections.defaultdict(set)
        alternates = set()

        # unhook so the plugin doesn't try to handle a billion 'patch' events
        self._idb_hooks.unhook()

        for ea in all_instruction_addresses(start):

            # update the navbar cursor based on progress (only when in UI)
            if not headless:
                ida_auto.show_addr(ea)

            #
            # skip some instructions to cut down on noise (lots of noise /
            # false positives with NOP)
            #

            mnemonic = ida_ua.print_insn_mnem(ea)

            # probably undefined data in code / can't be disas / bad instructions
            if not mnemonic:
                continue

            mnemonic = mnemonic.upper()

            # ignore instructions that can decode a wild number of ways
            if mnemonic in ['NOP', 'XCHG']:
                continue

            # keep track of how many instructions we care to 'assemble'
            total += 1

            # ignore instructions that simply aren't supported yet
            if mnemonic in self.assembler.UNSUPPORTED_MNEMONICS:
                unsupported += 1
                unsupported_map[mnemonic] += 1
                continue

            # fetch raw info about the instruction
            disas_raw = self.assembler.format_assembly(ea)
            disas_size = ida_bytes.get_item_size(ea)
            disas_bytes = ida_bytes.get_bytes(ea, disas_size)

            #print("0x%08X: ASSEMBLING '%s'" % (ea, disas_raw))
            start_asm = time.time()
            asm_bytes = self.assembler.asm(disas_raw, ea)
            end_asm = time.time()
            asm_time = end_asm - start_asm

            if asm_time > asm_threshold:
                print("%08X: SLOW %0.2fs - %s" % (ea, asm_time, disas_raw))
                slow_limit -= 1
                if slow_limit == 0:
                    break

            # assembled vs expected
            byte_tuple = (asm_bytes, disas_bytes)

            # assembled bytes match what is in the database
            if asm_bytes == disas_bytes or byte_tuple in alternates:
                good += 1
                continue

            asm_bytes = self.assembler.asm(disas_raw, ea)

            byte_tuple = (asm_bytes, disas_bytes)

            # assembled bytes match what is in the database
            if asm_bytes == disas_bytes or byte_tuple in alternates:
                good += 1
                fallback += 1
                continue

            known_text = disas_raw in fail_addrs
            known_bytes = byte_tuple in fail_bytes[disas_raw]

            if not known_bytes and len(asm_bytes):

                # the assembled patch is the same size, or smaller than the og
                if len(asm_bytes) <= len(disas_bytes):
                    ida_before = ida_lines.tag_remove(ida_lines.generate_disasm_line(ea))
                    ida_after = disassemble_bytes(asm_bytes, ea)

                    ida_after = ida_after.split(';')[0]
                    ida_after = ida_after.replace(' short ', ' ')
                    ida_before = ida_before.split(';')[0]

                    okay = False
                    if ida_after == ida_before:
                        okay = True

                    #
                    # BEFORE: 'add     [rax+rax+0], ch'
                    #  AFTER: 'add     [rax+rax], ch
                    # 0x18004830B: NEW FAILURE 'add     [rax+rax+0], ch'
                    #  - IDA: 00 6C 00 00
                    #  - ASM: 00 2C 00
                    #

                    elif ida_before.replace('+0]', ']') == ida_after:
                        okay = True

                    elif '$+5' in ida_before:
                        okay = True

                    if okay:
                        alternates.add(byte_tuple)
                        good += 1
                        continue

                    print("BEFORE: '%s'\n AFTER: '%s" % (ida_before, ida_after))

            fail_addrs[disas_raw].append(ea)
            fail_bytes[disas_raw].add(byte_tuple)

            if known_text and known_bytes:
                continue

            if not known_text:
                print("0x%08X: NEW FAILURE '%s'" % (ea, disas_raw))
            else:
                print("0x%08X: NEW BYTES '%s'" % (ea, disas_raw))

            disas_hex = ' '.join(['%02X' % x for x in disas_bytes])
            asm_hex = ' '.join(['%02X' % x for x in asm_bytes])
            print(" - IDA: %s\n - ASM: %s" % (disas_hex, asm_hex))
            #break

        # re-hook the to re-enable the plugin's ability to see patch events
        self._idb_hooks.hook()

        print("-"*50)
        print("RESULTS")
        print("-"*50)

        for disas_raw in sorted(fail_addrs, key=lambda k: len(fail_addrs[k]), reverse=True):
            print("%-5u Fails -- %-40s -- (%u unique patterns)" % (len(fail_addrs[disas_raw]), disas_raw, len(fail_bytes[disas_raw])))

        if False:

            print("-"*50)
            print("ALTERNATE MAPPINGS")
            print("-"*50)

            for x, y in alternates:
                print('%-20s\t%s' % (' '.join(['%02X' % z for z in x]), ' '.join(['%02X' % z for z in y])))

        if unsupported_map:

            print("-"*50)
            print("(KNOWN) Unsupported Mnemonics")
            print("-"*50)

            for mnem, hits in unsupported_map.items():
                print(" - %s - hits %u" % (mnem.ljust(10), hits))

        if total:
            percent = str((good/total)*100)
        else:
            percent = "100.0"

        percent_truncated = percent[:percent.index('.')+3] # truncate! don't round this float...

        arch_name = ida_ida.inf_get_procname()

        total_failed = total - good
        unknown_fails = total_failed - unsupported
        print("-"*50)
        print(" - Success Rate {percent}% -- {good:,} / {total:,} ({fallback:,} fallbacks, {total_failed:,} failed ({unsupported:,} were unsupported mnem, {unknown_fails:,} were unknown)) -- arch '{arch_name}' -- file '{input_path}'".format(
                percent=percent_truncated.rjust(6, ' '),
                good=good,
                total=total,
                fallback=fallback,
                total_failed=total_failed,
                unsupported=unsupported,
                unknown_fails=unknown_fails,
                arch_name=arch_name,
                input_path=ida_nalt.get_input_file_path()
            )
        )

        total_time = int(time.time() - start_time)
        print(" - Took %s %s..." % (datetime.timedelta(seconds=total_time), 'minutes' if total_time >= 60 else 'seconds'))

```

`patching/exceptions.py`:

```py

#------------------------------------------------------------------------------
# Exception Definitions
#------------------------------------------------------------------------------

class PatchingError(Exception):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

class PatchBackupError(PatchingError):
    def __init__(self, message, filepath=''):
        super().__init__(message)
        self.filepath = filepath

class PatchTargetError(PatchingError):
    def __init__(self, message, filepath):
        super().__init__(message)
        self.filepath = filepath

class PatchApplicationError(PatchingError):
    def __init__(self, message, filepath):
        super().__init__(message)
        self.filepath = filepath
```

`patching/ui/preview.py`:

```py
import ida_name
import ida_bytes
import ida_lines
import ida_idaapi
import ida_kernwin
import weakref

from patching.util.qt import QT_AVAILABLE
from patching.util.ida import parse_disassembly_components, scrape_symbols
from patching.util.python import hexdump

if QT_AVAILABLE:
    from patching.ui.preview_ui import PatchingDockable

LAST_LINE_IDX = -1

class PatchingController(object):
    """
    The backing logic & model (data) for the patch editing UI.
    """
    WINDOW_TITLE = "Patching"

    def __init__(self, core, ea=ida_idaapi.BADADDR):
        self.core = core
        self.view = None

        #
        # if no context (an address to patch at) was provided, use IDA's
        # current cursor position instead as the origin for the dialog
        #

        if ea == ida_idaapi.BADADDR:
            ea = ida_kernwin.get_screen_ea()

        self._address_origin = ida_bytes.get_item_head(ea)

        # public properties
        self.address = self._address_origin
        self.address_idx = LAST_LINE_IDX
        self.assembly_text = ''
        self.assembly_bytes = b''

        # for error text or other dynamic information to convey to the user
        self.status_message = ''

        # do an initial 'refresh' to populate data for the patching dialog
        self.refresh()

        # connect signals from the plugin core to the patching dialog
        self.core.patches_changed(self.refresh)

        # only create the UI for the patching dialog as needed
        if QT_AVAILABLE:
            self.view = PatchingDockable(self)
            self.view.Show()
    
    #-------------------------------------------------------------------------
    # Actions
    #-------------------------------------------------------------------------

    def select_address(self, ea, idx=LAST_LINE_IDX):
        """
        Select the given address.
        """
        insn, lineno = self.get_insn_lineno(ea)

        # if the target instruction does not exist
        if insn.address != ea:
            idx = LAST_LINE_IDX

        #
        # clear all clobber highlights if the cursor is moving to a new line
        #
        # TODO/NOTE: this feels a bit dirty / out of place. there is probably
        # a place for it that is more appropriate
        #

        if insn.address != self.address or self.address_idx != idx:
            for insn_cur in self.instructions:
                insn_cur.clobbered = False

        self.address = insn.address
        self.address_idx = idx

        self._update_assembly_text(self.core.assembler.format_assembly(insn.address))

        if self.view:
            self.view.refresh_fields()
            self.view.refresh_cursor()

    def edit_assembly(self, assembly_text):
        """
        Edit the assembly text.
        """
        self._update_assembly_text(assembly_text)

        # refresh visible fields, as the assembled bytes may have changed
        if self.view:
            self.view.refresh_fields()

        # fetch the displayed instruction that the user is 'editing'
        current_insn = self.get_insn(self.address)

        #
        # if the newly assembled instruction is smaller than the existing
        # instruction, there is no need to highlight clobbers
        #

        edit_index = self.instructions.index(current_insn)
        clobber_end = self.address + len(self.assembly_bytes)
        will_clobber = clobber_end > (current_insn.address + current_insn.size)

        # loop through the next N instructions
        for next_insn in self.instructions[edit_index+1:]:
            next_insn.clobbered = (next_insn.address < clobber_end) and will_clobber

        # done marking clobbered instructions, nothing else to do
        if self.view:
            self.view.refresh_code()

    def commit_assembly(self):
        """
        Commit the current assembly.
        """
        if not self.assembly_bytes:
            return

        # patch the instruction at the current address
        self.core.patch(self.address, self.assembly_bytes)

        # refresh lines
        self._refresh_lines()

    def _update_assembly_text(self, assembly_text):
        """
        Update the assembly text (and attempt to assemble it).
        """
        self.assembly_text = assembly_text
        self.assembly_bytes = bytes()
        self.status_message = ''

        #
        # before trying to assemble the user input, we'll try to check for a
        # few problematic and unsupported cases before even attempting to
        # assemble the given text
        #
        # TODO/NOTE: we should probably move this into the 'assembler'
        # class and expose an error reason message/text for failures
        #

        _, mnemonic, operands = parse_disassembly_components(assembly_text)

        #
        # if it looks like the user is trying to assemble an instruction that
        # we KNOW Keystone does not support for whatever reason, we should
        # give them a heads up instead of an 'unspecified error' (...)
        #

        if mnemonic.upper() in self.core.assembler.UNSUPPORTED_MNEMONICS:
            self.status_message = "Keystone does not support this instruction (%s)" % mnemonic
            return

        #
        # in the odd event that a user pastes a massive blob of random text
        # into the the assembly field by accident, the plugin could 'hang'
        # IDA in an attempt to resolve a bunch of words as 'symbols' while
        # assembling the 'text' -- which is not what wen want
        #

        if len(scrape_symbols(operands)) > 10:
            self.status_message = "Too many potential symbols in the assembly text"
            return

        #
        # TODO/XXX/KEYSTONE: 11th hour hack, but Keystone will HANG if the
        # user tries to assemble the following inputs:
        #
        #       .string '
        #       .string "
        #
        # so we're just going to try and block those until we can fix it
        # in Keystone proper :-X
        #

        assembly_normalized = assembly_text.strip().lower()

        if assembly_normalized.startswith('.string'):
            self.status_message = "Unsupported declaration (.string can hang Keystone)"
            return

        #
        # TODO: in v0.2.0 we should try to to re-enable multi-instruction
        # inputs. the only reason it is 'disabled' for now is that I need more
        # time to better define its behavior in the context of the plugin
        #
        # NOTE: Keystone supports 'xor eax, eax; ret;' just fine, it's purely
        # ensuring the rest of this plugin / wrapping layers are going to
        # handle it okay
        #

        if ';' in assembly_normalized:
            self.status_message = "Multi-instruction input not yet supported (';' not allowed)"
            return

        #
        # we didn't catch any 'early' issues with the user input, go ahead
        # and try to assemble it to see what happens
        #

        self.assembly_bytes = self.core.assemble(self.assembly_text, self.address)
        if not self.assembly_bytes:
            self.status_message = '...' # error assembling

    #-------------------------------------------------------------------------
    # Misc
    #-------------------------------------------------------------------------

    def refresh(self):
        """
        Refresh the controller state based on the current IDA state.
        """
        self._refresh_lines()
        self.select_address(self.address)

    def _refresh_lines(self):
        """
        Refresh the disassembly for the dialog based on the current IDA state.
        """
        instructions, current_address = [], self._address_origin

        PREV_INSTRUCTIONS = 50
        NEXT_INSTRUCTIONS = 50
        MAX_PREVIEW_BYTES = self.core.assembler.MAX_PREVIEW_BYTES

        # rewind a little bit from the target address to create a buffer
        for i in range(PREV_INSTRUCTIONS):
            current_address -= ida_bytes.get_item_size(current_address)

        # generate lines for the region of instructions around the target address
        for i in range(PREV_INSTRUCTIONS + NEXT_INSTRUCTIONS):
            try:
                line = InstructionLine(current_address, MAX_PREVIEW_BYTES)
            except ValueError:
                current_address += 1
                continue
            current_address += line.size
            instructions.append(line)

        self.instructions = instructions

        if self.view:
            self.view.refresh_code()

    def get_insn(self, ea):
        """
        Return the instruction text object for the given address.
        """
        insn, _ = self.get_insn_lineno(ea)
        return insn

    def get_insn_lineno(self, ea):
        """
        Return the instruction text object and its line number for the given address.
        """
        lineno = 0
        for insn in self.instructions:
            if insn.address <= ea < insn.address + insn.size:
                return (insn, lineno)
            lineno += insn.num_lines
        return (None, 0)

#-----------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------

COLORED_SEP = ida_lines.COLSTR('|', ida_lines.SCOLOR_SYMBOL)

class InstructionLine(object):
    """
    A helper for drawing an instruction in a simple IDA viewer.
    """
    def __init__(self, ea, max_preview=4):

        #
        # NOTE/XXX: this kind of needs to be called first, otherwise
        # 'get_item_size(ea)' may fetch a stale size for the instruction
        # if it was *just* patched
        #

        self.colored_instruction = ida_lines.generate_disasm_line(ea)
        if not self.colored_instruction:
            raise ValueError("Bad address... 0x%08X" % ea)

        # a label / jump target if this instruction has one
        self.name = ida_name.get_short_name(ea)

        # the number of lines this instruction object will render as
        self.num_lines = 1 + (2 if self.name else 0)

        # info about the instruction
        self.size = ida_bytes.get_item_size(ea)
        self.bytes = ida_bytes.get_bytes(ea, self.size)
        self.address = ea

        # flag to tell code view to highlight line as clobbered
        self.clobbered = False

        # how many instruction bytes to show before eliding
        self._max_preview = max_preview

    @property
    def colored_address(self):
        """
        Return an IDA-colored string for the instruction address.
        """
        pretty_address = ida_lines.COLSTR('%08X' % self.address, ida_lines.SCOLOR_PREFIX)
        return pretty_address

    @property
    def colored_bytes(self):
        """
        Return an IDA-colored string for the instruction bytes.
        """
        MAX_BYTES = self._max_preview

        if self.size > MAX_BYTES:
            text_bytes = hexdump(self.bytes[:MAX_BYTES-1]).ljust(3*MAX_BYTES-1, '.')
        else:
            text_bytes = hexdump(self.bytes).ljust(3*MAX_BYTES-1, ' ')

        pretty_bytes = ida_lines.COLSTR(text_bytes, ida_lines.SCOLOR_BINPREF)
        return pretty_bytes

    @property
    def line_blank(self):
        """
        Return an IDA-colored string for a blank line at this address.
        """
        byte_padding = ' ' * ((self._max_preview*3) - 1)
        self._line_blank = ' '.join(['', self.colored_address, COLORED_SEP, byte_padding , COLORED_SEP])
        return self._line_blank

    @property
    def line_name(self):
        """
        Return an IDA-colored string for the name text line (if a named address).
        """
        if not self.name:
            return None

        pretty_name = ida_lines.COLSTR(self.name, ida_lines.SCOLOR_CNAME) + ':'
        byte_padding = ' ' * ((self._max_preview*3) - 1)

        self._line_name = ' '.join(['', self.colored_address, COLORED_SEP, byte_padding , COLORED_SEP, pretty_name])
        return self._line_name

    @property
    def line_instruction(self):
        """
        Return an IDA-colored string for the instruction text line.
        """
        self._line_text = ' '.join(['', self.colored_address, COLORED_SEP, self.colored_bytes, COLORED_SEP + '  ', self.colored_instruction])
        return self._line_text
```

`patching/ui/preview_ui.py`:

```py
import ida_name
import ida_kernwin

from patching.util.qt import *
from patching.util.ida import *
from patching.util.python import hexdump

LAST_LINE_IDX = -1

class PatchingDockable(ida_kernwin.PluginForm):
    """
    The UI components of the Patching dialog.
    """

    def __init__(self, controller):
        super().__init__()
        self.controller = controller
        self.count = 0

    #--------------------------------------------------------------------------
    # IDA PluginForm Overloads
    #--------------------------------------------------------------------------

    def Show(self):        
        # TODO/Hex-Rays/XXX: can't make window Floating? using plgform_show(...) instead
        flags = ida_kernwin.PluginForm.WOPN_DP_FLOATING | ida_kernwin.PluginForm.WOPN_CENTERED
        #super(PatchingDockable, self).Show(self.controller.WINDOW_TITLE, flags)
        ida_kernwin.plgform_show(self.__clink__, self, self.controller.WINDOW_TITLE, flags)
        self._center_dialog()

        #
        # set the initial cursor position to focus on the target address
        #
        # we bump the focus location down a few lines from the top of the
        # window to center the cursor a bit.
        #

        self.set_cursor_pos(self.controller.address, self.controller.address_idx, 0, 6)

        # set the initial keyboard focus the editable assembly line
        self._line_assembly.setFocus(QtCore.Qt.FocusReason.ActiveWindowFocusReason)

    def OnCreate(self, form):
        self._twidget = form
        self.widget = ida_kernwin.PluginForm.TWidgetToPyQtWidget(self._twidget)
        self._ui_init()

    def OnClose(self, form):
        self._edit_timer.stop()
        self._edit_timer = None
        self._code_view = None
        self.controller.view = None
        return super().OnClose(form)

    #--------------------------------------------------------------------------
    # Initialization - UI
    #--------------------------------------------------------------------------

    def _ui_init(self):
        """
        Initialize UI elements.
        """
        self.widget.setMinimumSize(350, 350)

        # setup a monospace font for code / text printing
        self._font = QtGui.QFont("Courier New")
        self._font.setStyleHint(QtGui.QFont.Monospace)

        # initialize our ui elements
        self._ui_init_code()
        self._ui_init_fields()

        # populate the dialog/fields with initial contents from the database
        self.refresh()

        # set the code view to focus on an initial line
        self._code_view.Jump(self._code_view.GetLineNo(), y=5)

        # layout the populated ui just before showing it
        self._ui_layout()

        #
        # NOTE: we 'defer' real-time instruction assembly (while typing) in
        # the patching dialog if we think the database is 'big enough' to
        # make the text input lag due to slow symbol resolution (eg. having
        # to search the entire IDA 'name list' for an invalid symbol)
        #

        self._edit_timer = QtCore.QTimer(self.widget)
        self._edit_timer.setSingleShot(True)
        self._edit_timer.timeout.connect(self._edit_stopped)

        if ida_name.get_nlist_size() > 20000:
            self._line_assembly.textEdited.connect(self._edit_started)
        else:
            self._line_assembly.textEdited.connect(self.controller.edit_assembly)

        # connect signals
        self._line_assembly.returnPressed.connect(self._enter_pressed)

    def _ui_init_fields(self):
        """
        Initialize the interactive text fields for this UI control.
        """
        self._line_address = QtWidgets.QLineEdit()
        self._line_address.setFont(self._font)
        self._line_address.setReadOnly(True)
        self._label_address = QtWidgets.QLabel("Address:")
        self._label_address.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        # configure the line that displays assembly text
        self._line_assembly = AsmLineEdit(self._code_view)
        self._line_assembly.setFont(self._font)
        self._line_assembly.setMinimumWidth(350)
        self._label_assembly = QtWidgets.QLabel("Assembly:")
        self._label_assembly.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        # configure the line that displays assembled bytes
        self._line_bytes = QtWidgets.QLineEdit()
        self._line_bytes.setFont(self._font)
        self._line_bytes.setReadOnly(True)
        self._label_bytes = QtWidgets.QLabel("Bytes:")
        self._label_bytes.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

    def _ui_init_code(self):
        """
        Initialize the interactive code view for this UI control.
        """
        self._code_view = PatchingCodeViewer(self.controller)

    def _ui_layout(self):
        """
        Layout the major UI elements of the widget.
        """
        layout = QtWidgets.QGridLayout(self.widget)

        # arrange the widgets in a 'grid'         row  col  row span  col span
        layout.addWidget(self._label_address,       0,   0,        1,        1)
        layout.addWidget(self._line_address,        0,   1,        1,        1)
        layout.addWidget(self._label_assembly,      1,   0,        1,        1)
        layout.addWidget(self._line_assembly,       1,   1,        1,        1)
        layout.addWidget(self._label_bytes,         2,   0,        1,        1)
        layout.addWidget(self._line_bytes,          2,   1,        1,        1)
        layout.addWidget(self._code_view.widget,    3,   0,        1,        2)

        # apply the layout to the widget
        self.widget.setLayout(layout)

    def _center_dialog(self):
        """
        Center the current dialog to the IDA MainWindow.

        TODO/Hex-Rays: WOPN_CENTERED flag?! does it not work? or how do I use it?

        XXX: I have no idea why the get_main_window(...) + center_widget(...)
        code I wrote in qt.py does not work for wid_dialog / IDA dockables even
        though it is effectively identical to this lol

        NOTE: this hack will cause a 'widget flicker' as we are moving the widget
        shortly after it is made visible...
        """
        wid_main, wid_dialog = None, None

        #
        # search upwards through the current dialog/widget's parent widgets
        # until the IDA main window is located
        #

        parent = self.widget.parent()
        while parent:

            if isinstance(parent, QtWidgets.QMainWindow):
                wid_main = parent
                break

            elif isinstance(parent, QtWidgets.QWidget):
                if parent.windowTitle() == self.controller.WINDOW_TITLE:
                    wid_dialog = parent

            parent = parent.parent()

        #
        # fail, could not find the IDA main window and the parent container
        # for this widget (unlikely)
        #

        if not (wid_main and wid_dialog):
            return False

        rect_main = wid_main.geometry()
        rect_dialog = wid_dialog.rect()

        #
        # compute a new position for the dialog such that it will center
        # to the IDA main window
        #

        pos_dialog = rect_main.center() - rect_dialog.center()
        wid_dialog.move(pos_dialog)

    #--------------------------------------------------------------------------
    # Refresh
    #--------------------------------------------------------------------------

    def refresh(self):
        """
        Refresh the entire patching dialog.
        """
        self.refresh_fields()
        self.refresh_code()

    def refresh_fields(self):
        """
        Refresh the patching fields.
        """

        # update the address field to show the currently selected address
        self._line_address.setText('0x%08X' % self.controller.address)

        # update the assembly text to show the currently selected instruction
        if self._line_assembly.text() != self.controller.assembly_text:
            self._line_assembly.setText(self.controller.assembly_text)

        # update the assembly bytes field... which can also show an error message
        if self.controller.status_message:
            self._line_bytes.setText(self.controller.status_message)
        else:
            self._line_bytes.setText(hexdump(self.controller.assembly_bytes))

    def refresh_code(self):
        """
        Refresh the patching code view.
        """
        self._code_view.ClearLines()

        # regenerate the view from the current set of lines in the backing model
        for line in self.controller.instructions:

            #
            # instructions with an 'assembly label' (eg. loc_140004200)
            # attached to their address should have these extra lines visible
            # to better simulate a true IDA disassembly listing
            #

            if line.name:
                self._code_view.AddLine(line.line_blank)
                self._code_view.AddLine(line.line_name)

            # emit the actual instruction text
            self._code_view.AddLine(line.line_instruction)

        self._code_view.Refresh()

    def refresh_cursor(self):
        """
        Refresh the user cursor in the patching code view.
        """

        # get the text based co-ordinates within the IDA code view
        ida_pos = self._code_view.GetPos()
        lineno_sel, x, y = ida_pos if ida_pos else (0, 0, 0)

        # fetch the instruction 'selected' by the controller/model
        insn, lineno_insn = self.controller.get_insn_lineno(self.controller.address)

        if self.controller.address_idx == LAST_LINE_IDX:
            lineno_new = lineno_insn + (insn.num_lines - 1)
        else:
            lineno_new = lineno_insn + self.controller.address_idx

        self._code_view.Jump(lineno_new, x, y)

    #-------------------------------------------------------------------------
    # Events
    #-------------------------------------------------------------------------

    def _edit_started(self):
        """
        The assembly text was changed by the user.
        """
        self._edit_timer.stop()

        assembly_text = self._line_assembly.text()
        _, _, ops = parse_disassembly_components(assembly_text)

        #
        # if there's no symbols that would have to be resolved for the
        # the current input, we should attempt assembly immediately as it
        # should be in-expensive (won't lag the text input)
        #

        if not scrape_symbols(ops):
            self.controller.edit_assembly(assembly_text)
            return

        #
        # in 500ms if the user hasn't typed anything else into the assembly
        # field, we will consider their editing as 'stopped' and attempt
        # to evaluate (assemble) their current input
        #

        self._edit_timer.start(500)

    def _edit_stopped(self):
        """
        Some amount of time has passed since the user last edited the assembly text.
        """
        assembly_text = self._line_assembly.text()
        self.controller.edit_assembly(assembly_text)

    def _enter_pressed(self):
        """
        The user pressed enter while the assembly text line was focused.
        """
        if self._edit_timer.isActive():
            self._edit_timer.stop()
            self.controller.edit_assembly(self._line_assembly.text())
        self.controller.commit_assembly()

    #--------------------------------------------------------------------------
    # Misc
    #--------------------------------------------------------------------------

    def get_cursor(self):
        """
        Return the current view cursor information.
        """

        # the line the view is currently focused on
        view_line = self._code_view.GetCurrentLine()
        view_address = parse_line_ea(view_line)

        # get the text based co-ordinates within the IDA code view
        view_pos = self._code_view.GetPos()
        lineno, x, y = view_pos if view_pos else (0, 0, 0)

        #
        # compute the relative line number within the focused address
        #

        global_idx, relative_idx = 0, -1
        while True:

            # fetch a line from the code view
            line = self._code_view.GetLine(global_idx)
            if not line:
                break

            # unpack the returned code viewer line tuple
            colored_line, _, _ = line
            line_address = parse_line_ea(colored_line)

            if line_address == view_address:

                #
                # found the first instruction line matching our cursor
                # address, start the relative line index counter
                #

                if relative_idx == -1:
                    relative_idx = 0

                # next line
                else:
                    relative_idx += 1

            #
            # we have reached the first line with an address GREATER than the
            # lines with an address matching the view's current selection
            #

            elif line_address > view_address:
                break

            global_idx += 1

        #
        # return a position (like, our own place_t) that can be used to jump
        # the patching view to this exact position again, even if the lines
        # or formatting changes around 'a bit'
        #

        return (view_address, relative_idx, x, y)

    def set_cursor_pos(self, address, idx=0, x=0, y=0):
        """
        TODO
        """
        insn, lineno = self.controller.get_insn_lineno(address)
        if not insn:
            raise ValueError("Failed to jump to given address 0x%08X" % address)

        #
        # idx as -1 is a special case to focus on the *last* line of the
        # instruction at the matching address. for example, this is used to
        # focus on the *ACTUAL* instruction text / line for an address that
        # contains multiple lines (blank line + label line + instruction line)
        #

        if idx == -1:
            idx = insn.num_lines - 1
        elif address != insn.address:
            idx = 0

        final_lineno = lineno + idx
        self._code_view.Jump(final_lineno, x, y)

class AsmLineEdit(QtWidgets.QLineEdit):
    """
    A Qt LineEdit with a few extra tweaks.
    """

    def __init__(self, code_view, parent=None):
        super().__init__()
        self.code_view = code_view

    def keyPressEvent(self, event):
        """
        Key press received.
        """

        # navigate DOWN one line in the asm view if the 'down arrow' key
        if event.key() == QtCore.Qt.Key_Down:
            lineno, x, y = self.code_view.GetPos()

            # clamp to the last line, and jump to it
            lineno = min(lineno+1, self.code_view.Count()-1)
            self.code_view.Jump(lineno, x, y)

            # manually trigger the 'Cursor Position Changed' handler
            self.code_view.OnCursorPosChanged()

            # mark the event as handled
            event.accept()
            return

        # navigate UP one line in the code view if the 'up arrow' key
        elif event.key() == QtCore.Qt.Key_Up:
            lineno, x, y = self.code_view.GetPos()

            # clamp to the first line
            lineno = max(lineno-1, 0)
            self.code_view.Jump(lineno, x, y)

            # manually trigger the 'Cursor Position Changed' handler
            self.code_view.OnCursorPosChanged()

            # mark the event as handled
            event.accept()
            return

        # let the key press be handled normally
        super().keyPressEvent(event)

#------------------------------------------------------------------------------
# IDA Code Viewer
#------------------------------------------------------------------------------

class PatchingCodeViewer(ida_kernwin.simplecustviewer_t):
    """
    An IDA controlled 'code viewer' to simulate a disassembly view.
    """

    def __init__(self, controller):
        super().__init__()
        self.controller = controller
        self._ui_hooks = UIHooks()
        self._ui_hooks.get_lines_rendering_info = self._highlight_lines
        self.Create()

    #--------------------------------------------------------------------------
    # IDA Code Viewer Overloads
    #--------------------------------------------------------------------------

    def Create(self):
        if not super().Create('PatchingCodeViewer'):
            return False
        self._twidget = self.GetWidget()
        self.widget = ida_kernwin.PluginForm.TWidgetToPyQtWidget(self._twidget)
        self._ui_hooks.hook()
        return True

    def OnClose(self):
        self._ui_hooks.unhook()
        self._filter = None

    def OnCursorPosChanged(self):

        # get the currently selected line in the code view
        view_line = self.GetCurrentLine()
        view_lineno = self.GetLineNo()
        view_address = parse_line_ea(view_line)

        #
        # get the info about the currently selected instruction from the
        # underlying view controller / model
        #

        insn, insn_lineno = self.controller.get_insn_lineno(view_address)

        # compute the cursor's relative index into lines with the same address
        relative_idx = view_lineno - insn_lineno

        # notify the controller of the updated cursor / selection
        self.controller.select_address(view_address, relative_idx)

    def OnPopup(self, form, popup_handle):
        self._filter = remove_ida_actions(popup_handle)
        return False

    #--------------------------------------------------------------------------
    # Events
    #--------------------------------------------------------------------------

    def _highlight_lines(self, out, widget, rin):
        """
        IDA is drawing disassembly lines and requesting highlighting info.
        """

        # ignore line highlight events that are not for the current code view
        if widget != self._twidget:
            return

        selected_lnnum, x, y = self.GetPos()

        # highlight lines/addresses that have been patched by the user
        assert len(rin.sections_lines) == 1
        for i, line in enumerate(rin.sections_lines[0]):
            splace = ida_kernwin.place_t_as_simpleline_place_t(line.at)
            line_info = self.GetLine(splace.n)
            if not line_info:
                continue

            colored_text, _, _ = line_info
            address = parse_line_ea(colored_text)

            current_insn = self.controller.get_insn(address)
            if not current_insn:
                continue

            # convert (ea, size) to represent the full address of each byte in an instruction
            insn_addresses = set(range(current_insn.address, current_insn.address + current_insn.size))

            # green: selected line
            if splace.n == selected_lnnum:
                color = ida_kernwin.CK_EXTRA1

            # red: clobbered line
            elif current_insn.clobbered:
                color = ida_kernwin.CK_EXTRA11

            # yellow: patched line
            elif insn_addresses & self.controller.core.patched_addresses:
                color = ida_kernwin.CK_EXTRA2

            # no highlighting needed
            else:
                continue

            # highlight the line if it is patched in some way
            e = ida_kernwin.line_rendering_output_entry_t(line)
            e.bg_color = color
            e.flags = ida_kernwin.LROEF_FULL_LINE

            # save the highlight to the output line highlight list
            out.entries.push_back(e)

```

`patching/ui/save.py`:

```py
import hashlib

import ida_nalt

from patching.util.qt import QT_AVAILABLE
from patching.exceptions import *

if QT_AVAILABLE:
    from patching.ui.save_ui import SaveDialog

class SaveController(object):
    """
    The backing logic & model (data) for the patch saving UI.
    """
    WINDOW_TITLE = "Apply patches to..."

    def __init__(self, core, error=None):
        self.core = core
        self.view = None

        # init fields
        self._init_settings()

        # init error (if there was one that caused the dialog to pop)
        self.attempts = 1 if error else 0
        self._set_error(error)

        # only create the UI for the save dialog as needed
        if QT_AVAILABLE:
            self.view = SaveDialog(self)

    def _init_settings(self):
        """
        Initialize dialog settings from the plugin core / IDA state.
        """

        # inherit certain settings from the plugin core
        self.patch_cleanly = self.core.prefer_patch_cleanly
        self.quick_apply = self.core.prefer_quick_apply

        # the target file to patch / apply patches to
        self.target_filepath = self.core.patched_filepath
        if not self.target_filepath:
            self.target_filepath = ida_nalt.get_input_file_path()

    def _set_error(self, exception):
        """
        Set the save dialog error text based on the given exception.
        """

        # no error given, reset message text / color fields
        if exception is None:
            self.status_message = ''
            self.status_color = ''
            return

        #
        # something went wrong trying to ensure a usable backup / clean
        # executable was available for the patching operation. this should
        # only ever occur when the user is attempting to 'patch cleanly'
        #
        # this is most likely because the plugin could not locate a clean
        # version of the executable on disk. if the user would like to try
        # yolo-patching the target file, they can un-check 'Patch cleanly'
        #

        if isinstance(exception, PatchBackupError):
            self.status_message = str(exception) + "\nDisable 'Patch cleanly' to try patching anyway (att #%u)" % self.attempts
            self.status_color = 'red'

        #
        # something went wrong explicitly trying to modify the target / output
        # file for the patching operation.
        #
        # this is most likely because the file is locked, but the target file
        # could also be missing (among other reasons)
        #

        elif isinstance(exception, PatchTargetError) or isinstance(exception, PatchApplicationError):
            self.status_message = str(exception) + "\nIs the filepath above locked? or missing? (att #%u)" % self.attempts
            self.status_color = 'red'

        # unknown / unhandled error?
        else:
            self.status_message = "Unknown error? (att #%u)\n%s" % (self.attempts, str(exception))
            self.status_color = 'red'

    #--------------------------------------------------------------------------
    # Actions
    #--------------------------------------------------------------------------

    def interactive(self):
        """
        Spawn an interactive user dialog and wait for it to close.
        """
        if not self.view:
            return False
        return self.view.exec_()

    def attempt_patch(self, target_filepath, clean):
        """
        Attempt to patch the target binary.
        """

        #
        # increment the 'patch attempt' count over the lifetime of this
        # dialog. the purpose of this counter is simple: it is a visual
        # cue to users who will continue to mash the 'Apply Patches'
        # button even in the face of a big red error message.
        #
        # the idea is that (hopefully) they will see this 'attempt count'
        # updating in the otherwise static error message text to indicate
        # that 'yes, the file is still locked/unavailabe/missing' until
        # they go rectify the issue
        #

        self.attempts += 1

        #
        # attempt to apply patches to the target file on behalf of the
        # interactive dialog / user request
        #

        try:
            self.core.apply_patches(target_filepath, clean)
        except Exception as e:
            self._set_error(e)
            return False

        #
        # if we made it this far, patching must have succeeded, save patch
        # settings to the core plugin
        #

        self.status_message = ''
        self.core.prefer_patch_cleanly = self.patch_cleanly
        self.core.prefer_quick_apply = self.quick_apply

        # return success
        return True

    def update_target(self, target_filepath):
        """
        Update the targeted filepath.
        """
        self.target_filepath = target_filepath
        if self.patch_cleanly:
            return

        #
        # if the UI setting for 'Patch cleanly' is explicitly unchecked but
        # the user *just* updated the target filepath via file dialog, we
        # will quickly try to check if the selected file appears to be
        # a good candidate for making a copy (backup) of during the likely
        # imminent patch save / application operation
        #

        try:
            disk_md5 = hashlib.md5(open(target_filepath, 'rb').read()).digest()
        except Exception:
            return

        # the MD5 hash of the file (executable) used to generate this IDB
        input_md5 = ida_nalt.retrieve_input_file_md5()
        if input_md5 != disk_md5:
            return

        #
        # at this point, the user has explicitly selected a patch target that
        # appears to be clean, yet they have 'Patch cleanly' disabled, so we
        # should provide them with a 'soft' hint / warning that it would be
        # best for them to turn 'Patch cleanly' back on...
        #

        self.status_message = "The patch target appears to be a clean executable,\nit is recommended you turn on 'Patch cleanly'"
        self.status_color = 'orange'

```

`patching/ui/save_ui.py`:

```py
import os

from patching.util.qt import *

class SaveDialog(QtWidgets.QDialog):
    """
    The UI components of the Patch Saving dialog.
    """

    def __init__(self, controller):
        super().__init__()
        self.controller = controller
        self._ui_init()

    #--------------------------------------------------------------------------
    # Initialization - UI
    #--------------------------------------------------------------------------

    def _ui_init(self):
        """
        Initialize UI elements.
        """
        self.setWindowTitle(self.controller.WINDOW_TITLE)

        # remove auxillary buttons (such as '?') from window title bar
        remove_flags = ~(
            QtCore.Qt.WindowSystemMenuHint |
            QtCore.Qt.WindowContextHelpButtonHint
        )
        self.setWindowFlags(self.windowFlags() & remove_flags)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)

        # make dialog fixed size (no size grip, etc)
        #self.setWindowFlags(self.windowFlags() | QtCore.Qt.MSWindowsFixedSizeDialogHint)
        #self.setSizeGripEnabled(False)

        # make dialog modal, so users can't click around IDA / change more stuff
        #self.setModal(True)

        # initialize our ui elements
        self._ui_init_fields()
        self._ui_init_options()

        # layout the populated ui just before showing it
        self._ui_layout()

        # connect signals
        self._btn_target.clicked.connect(self.select_target_file)
        self._btn_apply.clicked.connect(self._attempt_patch)
        self._chk_clean.stateChanged.connect(self._checkboxes_changed)
        self._chk_quick.stateChanged.connect(self._checkboxes_changed)

    def _ui_init_fields(self):
        """
        Initialize the interactive text fields for this UI control.
        """
        self._label_target = QtWidgets.QLabel("Patch Target:")
        self._label_target.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
        self._line_target = QtWidgets.QLineEdit()
        self._line_target.setText(self.controller.target_filepath)
        self._line_target.setMinimumWidth(360)
        self._btn_target = QtWidgets.QPushButton(" ... ")

        # warning / status message
        self._label_status = QtWidgets.QLabel()
        self._label_status.setWordWrap(True)
        self._label_status.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignHCenter)
        self._refresh_status_message()

        # apply patches button
        self._btn_apply = QtWidgets.QPushButton("Apply patches")

    def _ui_init_options(self):
        """
        Initialize the interactive options for this UI control.
        """
        self._group_options = QtWidgets.QGroupBox("Options")

        # checkbox options
        self._chk_clean = QtWidgets.QCheckBox("Patch cleanly")
        self._chk_clean.setChecked(self.controller.patch_cleanly)
        self._chk_clean.setToolTip("Maintain a clean (.bak) input file to clone and apply patches to each time")
        self._chk_quick = QtWidgets.QCheckBox("Show quick save")
        self._chk_quick.setChecked(self.controller.quick_apply)
        self._chk_quick.setToolTip("Use the current target filepath for future patch applications")

        # layout the groupbox
        layout = QtWidgets.QVBoxLayout(self._group_options)
        layout.addWidget(self._chk_clean)
        layout.addWidget(self._chk_quick)
        self._group_options.setLayout(layout)

    def _ui_layout(self):
        """
        Layout the major UI elements of the widget.
        """
        layout = QtWidgets.QGridLayout(self)

        # arrange the widgets in a 'grid'         row  col  row span  col span
        layout.addWidget(self._line_target,         0,   1,        1,        1)
        layout.addWidget(self._btn_target,          0,   2,        1,        1)
        layout.addWidget(self._group_options,       0,   0,        2,        1)
        layout.addWidget(self._label_status,        1,   1,        2,        1)
        layout.addWidget(self._btn_apply,           1,   2,        1,        1)
        #layout.setSizeConstraint(QtWidgets.QLayout.SetFixedSize)

        # apply the layout to the widget
        self.setLayout(layout)

    #--------------------------------------------------------------------------
    # Events
    #--------------------------------------------------------------------------

    def showEvent(self, e):
        """
        Overload the showEvent to center the save dialog over the IDA main window.
        """
        center_widget(self)
        return super().showEvent(e)

    def select_target_file(self):
        """
        The user pressed the '...' button to select a file to patch.
        """
        starting_directory = os.path.dirname(self.controller.target_filepath)

        # prompt the user to select a patch target / output file
        dialog = QtWidgets.QFileDialog()
        filepath, _ = dialog.getSaveFileName(caption="Select patch target...", directory=starting_directory)

        # user did not select a file or closed the file dialog
        if not filepath:
            return

        # save the selected patch target
        self.controller.update_target(filepath)
        self._line_target.setText(filepath)

        #
        # update the status text, in-case the controller has something
        # important to tell the user (eg, hinting them to turn clean
        # patching on, if it thinks it will succeed)
        #

        self._refresh_status_message()

    def _attempt_patch(self):
        """
        The user clicked the Apply Patches button.
        """
        target_filepath = self._line_target.text()
        apply_clean = self._chk_clean.isChecked()

        # if patching succeeds, we're all done! close the dialog
        if self.controller.attempt_patch(target_filepath, apply_clean):
            self.accept()
            return

        # patching must have failed, attempt to update the status / error message
        self._refresh_status_message()

    def _checkboxes_changed(self):
        """
        The status of the checkboxes changed.
        """
        self.controller.patch_cleanly = self._chk_clean.isChecked()
        self.controller.quick_apply = self._chk_quick.isChecked()

    #--------------------------------------------------------------------------
    # Refresh
    #--------------------------------------------------------------------------

    def _refresh_status_message(self):
        """
        Refresh the status / error message text based on the underlying UI state.
        """
        self._label_status.setText(self.controller.status_message)
        if self.controller.status_color:
            self._label_status.setStyleSheet("QLabel { font-weight: bold; color: %s; }" % (self.controller.status_color))
        else:
            self._label_status.setStyleSheet(None)

```

`patching/util/ida.py`:

```py
import re
import ctypes

import ida_ua
import ida_ida
import ida_idp
import ida_auto
import ida_nalt
import ida_name
import ida_bytes
import ida_lines
import ida_idaapi
import ida_kernwin
import ida_segment

from .qt import *
from .python import swap_value

#------------------------------------------------------------------------------
# IDA Hooks
#------------------------------------------------------------------------------

class UIHooks(ida_kernwin.UI_Hooks):
    def ready_to_run(self):
        pass
    def get_lines_rendering_info(self, out, widget, rin):
        pass
    def populating_widget_popup(self, widget, popup, ctx):
        pass

class IDPHooks(ida_idp.IDP_Hooks):
    def ev_ending_undo(self, action_name, is_undo):
        pass

class IDBHooks(ida_idp.IDB_Hooks):
    def auto_empty_finally(self):
        pass
    def byte_patched(self, ea, value):
        pass

#------------------------------------------------------------------------------
# IDA Misc
#------------------------------------------------------------------------------

def is_reg_name(reg_name):
    """
    Return True if the given string is a known register name.
    """
    ri = ida_idp.reg_info_t()
    return bool(ida_idp.parse_reg_name(ri, reg_name))

def is_mnemonic(mnemonic):
    """
    Return True if the given string is a known mnemonic (roughly).

    TODO: remove or offload to Keystone if possible? this is just 'best effort'
    TODO: actually this can probably be removed now? no longer used...
    """

    # cache known mnemonics for the current proc on the first invocation
    if not hasattr(is_mnemonic, 'known_mnemonics'):
        is_mnemonic.known_mnemonics = set([name.upper() for name, _ in ida_idp.ph.instruc])

    # check if the given mnemonic is in the list of known mnemonics
    mnemonic = mnemonic.upper()
    return bool(mnemonic in is_mnemonic.known_mnemonics)

def is_range_patched(start_ea, end_ea=None):
    """
    Return True if a patch exists within the given address range.
    """
    if end_ea == None:
        end_ea = start_ea + 1

    def visitor(ea, file_offset, original_value, patched_value):
        return 1

    return bool(ida_bytes.visit_patched_bytes(start_ea, end_ea, visitor))

def apply_patches(filepath):
    """
    Apply the current IDB patches to the given filepath.
    """

    with open(filepath, 'r+b') as f:

        #
        # a visitor function that will be called for each patched byte.
        #
        # NOTE: this is a python version of IDA's built in 'Apply patches...'
        # routine that has simply been reverse engineered
        #

        def visitor(ea, file_offset, original_value, patched_value):

            # the patched byte does not have a know file address
            if file_offset == ida_idaapi.BADADDR:
                print("%08X: has no file mapping (original: %02X patched: %02X)...skipping...\n" % (ea, original_value, patched_value))
                return 0

            # seek to the patch location
            f.seek(file_offset)

            # fetch the 'number of bits in a byte' for the given address (? lol)
            bits = ida_bytes.nbits(ea)

            # round the number of bits up to bytes
            num_bytes = (bits + 7) // 8

            # IDA does this, basically (swap_value(...)) so we will too
            if ida_ida.inf_is_wide_high_byte_first():
                byte_order = 'big'
            else:
                byte_order = 'little'

            # convert the int/long patch value to bytes (and swap endianess, if needed)
            patched_value = patched_value.to_bytes(num_bytes, byte_order)

            # write the patched byte(s) to the output file
            f.write(patched_value)

            #
            # return 0 so that the visitor keeps going to the next patched bytes
            # instead of stopping after this one.
            #

            return 0

        #
        # RUN THE VISITOR / APPLY PATCHES
        #

        ida_bytes.visit_patched_bytes(0, ida_idaapi.BADADDR, visitor)

        #
        # all done, file will close as we leave this 'with' scoping
        #

        pass

    # done done
    return

#------------------------------------------------------------------------------
# IDA UI
#------------------------------------------------------------------------------

def attach_submenu_to_popup(popup_handle, submenu_name, prev_action_name):
    """
    Create an IDA submenu AFTER the action name specified by prev_action_name.

    TODO/XXX/HACK/Hex-Rays: this is a workaround for not being able to create
    and position submenu groups for rightclick menus
    """
    if not QT_AVAILABLE:
        return None

    # 
    # convert IDA alt shortcut syntax to whatever they use in Qt Text menus
    # eg: '~A~ssemble patches to...' --> '&Assemble patches to...'
    #

    prev_action_name = re.sub(r'~(.)~', r'&\1', prev_action_name)

    # cast an IDA 'popup handle' pointer back to a QMenu object
    p_qmenu = ctypes.cast(int(popup_handle), ctypes.POINTER(ctypes.c_void_p))[0]
    if ida_pro.IDA_SDK_VERSION >= 920:
        qmenu = shiboken6.wrapInstance(int(p_qmenu), QtWidgets.QMenu)
    else:
        qmenu = sip.wrapinstance(int(p_qmenu), QtWidgets.QMenu)

    # create a Qt (sub)menu that can be injected into an IDA-originating menu
    submenu = QtWidgets.QMenu(submenu_name)

    # search for the target action to insert the submenu next to
    all_actions = list(qmenu.actions())
    for i, current_action in enumerate(all_actions[:-1]):
        if current_action.text() == prev_action_name:
            insertion_point = all_actions[i+1]
            qmenu.insertMenu(insertion_point, submenu)
            break

    #
    # if we did not find the action we wanted to place the new submenu after,
    # simply append it to the end of the menu
    #

    else:
        qmenu.addMenu(submenu)

    #
    # not totally sure if we need to be managing the lifetime of this submenu
    # even after it has been inserted. so we return it here, just in-case.
    #

    return submenu

#------------------------------------------------------------------------------
# Symbols
#------------------------------------------------------------------------------

# TODO: err this might not be a good assumption for mangling... eg '()'
IGNORED_CHARS = R"!,[]{}#+-*:"
IGNORED_CHARS_MAP = {ord(x): ' ' for x in IGNORED_CHARS}
IGNORED_REGISTERS = set()
IGNORED_KEYWORDS = set(
    [
        # x86 / x64
        'byte', 'short', 'word', 'dword', 'qword', 'xword', 'xmmword', 'ymmword', 'tbyte', 'large', 'long', 'near', 'far', 'ptr', 'offset',

        # ARM
        'eq', 'ne', 'cs', 'hs', 'cc', 'lo', 'mi', 'pl', 'vs', 'vc', 'hi', 'ls', 'ge', 'lt', 'gt', 'le', 'al'
    ]
)

def scrape_symbols(disassembly_text):
    """
    Attempt to scrape symbol-like values from a line of disassembly.
    """
    global IGNORED_REGISTERS
    symbols = []

    # split a comment off the given disassembly text, if present
    #x, sep, y = disassembly_text.rpartition('; ')
    #dis, cmt = (x, y) if sep else (y, x)
    assert ';' not in disassembly_text

    #
    # TODO: I'm really not sure how we should deal with cpp / demangled-ish
    # symbols in disassembly text. if we see something like foo::bar(...)
    # in the given disassembly text, our code is going to explode
    #
    # so for now we're just going to make no effort to parse out possible
    # cpp symbols and will figure out how to deal with them later :/
    #

    if '::' in disassembly_text or '`' in disassembly_text:
        return []

    # remove common disas chars that will not appear in an IDA name
    dis = disassembly_text.translate(IGNORED_CHARS_MAP)

    #
    # regex match any remaining 'non-whitespace' text, which should have its
    # position preserved from the original string. this should allow us to
    # return the symbols and their index in the given text
    #

    for m in re.finditer(r'\S+', dis):

        # normalize the potential symbol text
        original_symbol = m.group()
        word = original_symbol.lower()

        # ignore previously seen registers (fastpath)
        if word in IGNORED_REGISTERS:
            continue

        # ignore numbers / immediates (only imms can start with a number)
        if word[0] in '0123456789':
            continue

        # ignore IDA keywords (approximate)
        if word in IGNORED_KEYWORDS:
            continue

        # ignore new registers (and cache it for future scrapes)
        if is_reg_name(word):
            IGNORED_REGISTERS.add(word)
            continue

        # XXX: kind of a hack for things like 'movzx   eax, ds:(jump_table_11580-20h)[eax]'
        if original_symbol[0] == '(':
            original_symbol = original_symbol[1:]

        # eg: '$)'
        elif original_symbol[-1] == ')' and '(' not in original_symbol:
            original_symbol = original_symbol[:-1]

        # possible symbol!
        symbols.append((original_symbol, m.span()))

    # return list of likely symbols
    return symbols

def resolve_symbol(from_ea, name):
    """
    Return an address or value for the given symbol.

    TODO/Hex-Rays: this function is overly complex and is probably something
    that should be baked into IDA as more aggressive 'resolve symbol' API imo

    this function will yield matching symbol values (operating as a
    generator). this is because IDA can show 'visually identical' symbols in
    rendered instructions that have different 'true' names.

    eg. a func named '.X.' appears as '_X_' in IDA's x86 disassembly. but
    a second func could be named '.X_' which will also appear as '_X_'

    while this is maybe okay in the context of IDA (where it has concrete
    instruction / address info) ... it is not okay for trying to 'resolve'
    a symbol when your only information is assembly text.

    if the user types in the following instruction:

      eg.     call      _X_

    how can we know which value to select as a jump target?

    (the user will have to decide... through some symbol collision hinting...
    but the point still stands: a function like this has to be able to return
    'multiple' potential values)
    """

    # XXX: deferred import to avoid breaking patching.reload() dev helper
    import idc

    #
    # first, we will attempt to parse the given symbol as a global
    # struct path.
    #
    #    eg. 'g_foo.bar.baz'
    #
    # NOTE: this kind of has to be first, because our second section of
    # symbol resolution (get_name_ea, get_name_value) will incorrectly
    # 'resolve' a global struct path used at a given address.
    #
    # by incorrectly, i mean that global struct path reference in an
    # instruction will resolve to the base address of the global, not
    # the actual referenced field within the global
    #
    # TODO: there's a bug or something in my code still, this is not
    # computing the right offset in some cases (try assemble_all() on
    # ntoskrnl.exe from Windows 11 to see some of the failures)
    #

    global_name, sep, struct_path = name.partition('.')

    #
    # if sep 'exists', that means there is a '.' in the given symbol so it
    # *could* be a global struct path. let's try to walk though it
    #

    if sep:

        resolved_paths = 0

        for global_ea, real_name in resolve_symbol(from_ea, global_name):

            # if the resolved symbol address is not a global struct, ignore it
            if not ida_bytes.is_struct(ida_bytes.get_flags(global_ea)):
                continue

            # get the struct info for the resolved global address
            sid = ida_nalt.get_strid(global_ea)

            offset = 0
            while struct_path and sid != -1:
                member_name, sep, struct_path = struct_path.partition('.')
                member_offset = idc.get_member_offset(sid, member_name)

                if member_offset == -1:
                    print(" - INVALID STRUCT MEMBER!", member_name)
                    break

                offset += member_offset
                sid = idc.get_member_strid(sid, member_offset)

                # The idc.get_member_strid function in IDA 9.0 beta has a bug.
                # Even if a member is not a structure, it does not return -1.
                # Therefore, it's necessary to use struct_path to determine whether the retrieval is complete.
                if not struct_path or sid == -1:
                    assert not('.' in struct_path), 'Expected end of struct path?'
                    yield (global_ea+offset, name)
                    resolved_paths += 1

        #
        # TODO/XXX: if we yielded at least one struct path... we're *probably*
        # good. I don't think
        #

        if resolved_paths:
            return

    #
    # if the given symbol does not appear to be a global struct path, we
    # will try to use some of IDA's more typical 'name' --> address API's
    #
    # should any of these succeed, they are most certainly to be the symbol
    # value the user / instruction intended
    #

    value = ida_name.get_name_ea(from_ea, name)
    if value != ida_idaapi.BADADDR:
        yield (value, name)
        return

    nt, value = ida_name.get_name_value(from_ea, name)
    if nt != ida_name.NT_NONE:
        yield (value, name)
        return

    if name == '$':
        yield (from_ea, name)
        return

    #
    # yield all matches for a sanitized (codepage-validated?) name
    #
    # TODO/PERF: lol this is ridiculously expensive
    #

    # alias for speed (does this pseudo-optimization even work in py3 anymore? lol)
    get_nlist_ea = ida_name.get_nlist_ea
    get_nlist_name = ida_name.get_nlist_name
    #get_short_name = ida_name.get_short_name
    get_visible_name = ida_name.get_visible_name

    for idx in range(ida_name.get_nlist_size()):
        address = get_nlist_ea(idx)
        #visible_name = get_short_name(address)
        visible_name = get_visible_name(address)
        #visible_name = ida_name.validate_name(real_name, ida_name.VNT_IDENT) # ???
        if visible_name == name:
            real_name = get_nlist_name(idx)
            yield (address, real_name)

def get_dtype_name(dtype, size):
    """
    Return the keyword for the given data type.
    """
    dtype_map = \
    {
        ida_ua.dt_byte: 'byte',      #  8 bit
        ida_ua.dt_word: 'word',      #  16 bit
        ida_ua.dt_dword: 'dword',    #  32 bit
        ida_ua.dt_float: 'dword',    #  4 byte
        ida_ua.dt_double: 'qword',   #  8 byte
        ida_ua.dt_qword: 'qword',    #  64 bit
        ida_ua.dt_byte16: 'xmmword', # 128 bit
        ida_ua.dt_byte32: 'ymmword', # 256 bit
    }

    if dtype == ida_ua.dt_tbyte and size == 10:
      return 'xword'

    return dtype_map.get(dtype, None)

def get_tag_name(scolor):
    """
    Return the name of a given COLOR tag.
    """
    attribute_names = dir(ida_lines)

    for name in attribute_names:
        if not name.startswith('SCOLOR_'):
            continue
        value = getattr(ida_lines, name)
        if value == scolor:
            return name

    return '<UNKNOWN TAG>'

def rewrite_tag_addrs(line, wrap=False):
    """
    Rewrite symbol text with their COLOR values

    TODO: remove?
    """
    if not line:
        return

    og_line = line
    og_index = 0

    while len(line) > 0:

        skipcode_index = ida_lines.tag_skipcode(line)

        if skipcode_index == 0:  # No code found
            line = line[1:]  # Skip one character ahead
            og_index += 1
            continue

        if not(line[0] == ida_lines.COLOR_ON and line[1] == chr(ida_lines.COLOR_ADDR)):
            line = line[skipcode_index:]
            og_index += skipcode_index
            continue

        # parse the hidden text address from the tagged line
        address = int(line[2:skipcode_index], 16)

        # skip past the address to the symbol
        line = line[skipcode_index:]
        og_index += skipcode_index

        # copy the symbol out of the tagged line
        symbol = line[:line.index(ida_lines.COLOR_OFF)]
        symbol_index = og_index
        #print("Found addr: 0x%08X, '%s'" % (address, symbol))

        if wrap:
            address_text = "[0x%X]" % address
        else:
            address_text = "0x%X"

        # write the address text over the place of the original symbol
        og_line = og_line[:symbol_index] + address_text + og_line[symbol_index+len(symbol):]

        # continue past the extracted symbol text
        skipcode_index = ida_lines.tag_skipcode(line)
        line = line[skipcode_index:]
        og_index += len(address_text) # special adjustment, to account for the injected address text

    return ida_lines.tag_remove(og_line)

def get_disassembly_components_slow(ea):
    """
    Return (prefix, mnemonic, [operands]) from IDA's disassembly text.

    TODO: remove?
    """
    if not ida_bytes.is_code(ida_bytes.get_flags(ea)):
        return (None, None, [])

    # alias for simpler code / formatting
    COLOR_OPNDS = [chr(ida_lines.COLOR_OPND1+i) for i in range(7)]

    # tag parsing output
    comps_insn = []
    comps_ops = [None for i in range(7)]

    # tag parsing state
    tag_chars = []
    tag_stack = []

    # fetch the 'colored' (tagged) instruction text from IDA for parsing
    insn_text = ida_lines.generate_disasm_line(ea)

    #
    # using the IDA 'color' tags, we can parse spans of text generated by IDA
    # to determine the different parts of a printed instruction.
    #
    # this is useful because we can let IDA's core / proc module handle the
    # printing of specific features (e.g. instruction prefixes, size
    # annotations, segment references) without trying to re-implement the
    # full insn printing pipeline on our own.
    #

    while insn_text:
        skipcode_index = ida_lines.tag_skipcode(insn_text)

        #
        # if we are not sitting on top of a 'color code' / tag action, then
        # we do not need to take any special parsing action.
        #

        if skipcode_index == 0:
            tag_chars.append(insn_text[0])
            insn_text = insn_text[1:]
            continue

        #print('BYTES', ' '.join(['%02X' % ord(x) for x in insn_text[0:2]]))
        tag_action, tag_type = insn_text[0:2]

        #
        # entering a new color tag / text span
        #

        if tag_action == ida_lines.SCOLOR_ON:

            #
            # address tags do not have a closing tag, so we must consume
            # them immediately.
            #

            if tag_type == ida_lines.SCOLOR_ADDR:

                # parse the 'invisible' address reference
                address = int(insn_text[2:2+ida_lines.COLOR_ADDR_SIZE], 16)
                #symbol = insn_text[2+ida_lines.COLOR_ADDR:skipcode_index]
                #print("FOUND SYMBOL '%s' ADDRESS 0x%8X" % (symbol, address))

                # continue parsing the line
                insn_text = insn_text[skipcode_index:]
                continue

            tag_stack.append((tag_type, tag_chars))
            tag_chars = []

        #
        # exiting a color tag / text span
        #

        elif tag_action == ida_lines.SCOLOR_OFF:
            entered_tag, prev_tag_chars = tag_stack.pop()
            assert entered_tag == tag_type, "EXITED '%s' EXPECTED '%s'" % (get_tag_name(tag_type), get_tag_name(entered_tag))
            tag_text = ''.join(tag_chars).strip()

            # save instruction prefixes or the mnemonic
            if tag_type == ida_lines.SCOLOR_INSN:
                comps_insn.append(tag_text)

            # save instruction operands
            elif tag_type in COLOR_OPNDS:
                op_num = ord(tag_type) - ida_lines.COLOR_OPND1
                #print("ADDRESS 0x%08X OP %u: %s" % (ea, op_num, tag_text))
                comps_ops[op_num] = tag_text

            # ignore the rest? (for now I guess)
            else:
                #print("NOT SAVING: '%s' TAG TYPE '%s' " % (tag_text, get_tag_name(tag_type)))
                pass

            tag_chars = prev_tag_chars + tag_chars

        # continue past the 'color codes' / tag info
        insn_text = insn_text[skipcode_index:]

    # if there is more than one 'insn component', assume they are prefixes
    if len(comps_insn) > 1:
        prefix = ' '.join(comps_insn[:-1])
    else:
        prefix = ''

    # the instruction mnemonic should be the 'last' instruction component
    mnemonic = comps_insn[-1]

    return (prefix, mnemonic, comps_ops)

#
# TODO/XXX: ehh there's no way to really get / enumerate instruction prefixes
# from IDA processor modules
#

KNOWN_PREFIXES = set(['xacquire', 'xrelease', 'lock', 'bnd', 'rep', 'repe', 'repne'])

def get_disassembly_components(ea):
    """
    Return (prefix, mnemonic, operands) instruction components for a given address.
    """
    line_text = ida_lines.tag_remove(ida_lines.generate_disasm_line(ea))
    return parse_disassembly_components(line_text)

def parse_disassembly_components(line_text):
    """
    Return (prefix, mnemonic, operands) from the given instruction text.
    """

    # remove comment (if present)
    insn_text = line_text.split(';', 1)[0]

    # split instruction roughly into its respective elements
    elements = insn_text.split(' ')

    #
    # parse prefixes
    #

    for i, value in enumerate(elements):
        if not (value in KNOWN_PREFIXES):
            break

    #
    # if we didn't break from the loop, that means *every* element in the
    # split text was an instruction prefix. this seems odd, but it can
    # happen, eg the 'lock' instruction... by itself (in x86) is valid
    #
    # in this case, there is no mnemonic, or operands. just a prefix
    #

    else:
        return (' '.join(elements), '', '')

    #
    # there can be multiple instruction prefix 'words' so we stitch them
    # together here, in such cases
    #

    prefix = ' '.join(elements[:i])

    #
    # parse mnemonic
    #

    mnemonic = elements[i]
    i += 1

    #
    # operands
    #

    operands = ' '.join(elements[i:])

    return (prefix, mnemonic, operands)

def all_instruction_addresses(ea=0):
    """
    Return a generator that yields each instruction address in the IDB.
    """

    # alias for speed
    BADADDR = ida_idaapi.BADADDR
    SEG_CODE = ida_segment.SEG_CODE
    get_flags = ida_bytes.get_flags
    get_seg_type = ida_segment.segtype
    get_next_head = ida_bytes.next_head
    is_code = ida_bytes.is_code

    # yield each instruction address in the IDB
    while ea < BADADDR:

        if get_seg_type(ea) != SEG_CODE:
            ea = get_next_head(ea, BADADDR)
            continue

        # skip any address that is not an instruction
        if not is_code(get_flags(ea)):
            ea = get_next_head(ea, BADADDR)
            continue

        # return the current 'instruction' address
        yield ea

        # continue forward to the next address
        ea = get_next_head(ea, BADADDR)

def disassemble_bytes(data, ea):
    """
    Disassemble the given bytes using IDA at the given address.
    """
    old = ida_auto.set_auto_state(False)

    # fetch the current bytes (they could be patched already!)
    original_data = ida_bytes.get_bytes(ea, len(data))

    #
    # temporarily patch in the data we want IDA to disassemble, and fetch
    # the resulting disassembly text
    #

    ida_bytes.patch_bytes(ea, data)
    text = ida_lines.generate_disasm_line(ea)

    # revert the saved bytes back to the prior state
    ida_bytes.patch_bytes(ea, original_data)

    # re-enable the auto analyzer and return the disassembled text
    ida_auto.enable_auto(old)
    return ida_lines.tag_remove(text)

#------------------------------------------------------------------------------
# IDA Viewer Shims
#------------------------------------------------------------------------------

#
# TODO/Hex-Rays:
#
# IDA's simplecustviewer_t() does not support populating/hinting fields of
# the 'ctx' structure passed onto IDA Action handlers
#
# for this reason, we have to do some manual resolution of context for our
# patching viewer. these shims are to help keep the action code above a
# bit cleaner until Hex-Rays can improve simple code viewers
#

def parse_line_ea(colored_line):
    """
    Parse a code / instruction address from a colored line in the patching dialog.
    """
    line = ida_lines.tag_remove(colored_line)
    ea = int(line.split('|')[0], 16)
    return ea

def get_current_ea(ctx):
    """
    Return the current address for the given action context.
    """

    # custom / interactive patching view
    if ida_kernwin.get_widget_title(ctx.widget) == 'PatchingCodeViewer':
        return parse_line_ea(ida_kernwin.get_custom_viewer_curline(ctx.widget, False))

    # normal IDA widgets / viewers
    return ctx.cur_ea

def read_range_selection(ctx):
    """
    Return the currently selected address range for the given action context.
    """

    # custom / interactive patching view
    if ida_kernwin.get_widget_title(ctx.widget) == 'PatchingCodeViewer':

        # no active selection in the patching view, nothing to do...
        if not(ctx.cur_flags & ida_kernwin.ACF_HAS_SELECTION):
            return (False, ida_idaapi.BADADDR, ida_idaapi.BADADDR)

        # extract the start/end cursor locations (place_t) from the given ctx
        splace_from = ida_kernwin.place_t_as_simpleline_place_t(ctx.cur_sel._from.at)
        splace_to = ida_kernwin.place_t_as_simpleline_place_t(ctx.cur_sel.to.at)

        #
        # TODO/Hex-Rays: lol a *BRUTAL HACK* to get the src / dst lines
        #
        # the problem here is that there is no way to get the contents of an
        # arbitrary line (by number) in the custom viewer we created. at least not
        # from here, where we don't have a python reference of simplecustviewer_t()
        #
        # luckily... we can 'generate' (fetch?) the viewer's line through a place_t
        #
        # lol...
        #

        start_line = splace_from.generate(ida_kernwin.get_viewer_user_data(ctx.widget), 1)[0][0]
        end_line = splace_to.generate(ida_kernwin.get_viewer_user_data(ctx.widget), 1)[0][0]

        # parse the leading address from the 'colored' text fetched from the patching window
        start_ea = parse_line_ea(start_line)
        end_ea = parse_line_ea(end_line)
        end_ea = ida_bytes.get_item_end(end_ea)
        #print("Got %08X --> %08X for custom viewer range parse" % (start_ea, end_ea))

        # not a true 'range selection' if the start and end line / number is the same
        if start_ea == end_ea:
            return (False, ida_idaapi.BADADDR, ida_idaapi.BADADDR)

        # return the range of selected lines
        return (True, start_ea, end_ea)

    # special tweak for IDA disassembly views
    elif ida_kernwin.get_widget_type(ctx.widget) == ida_kernwin.BWN_DISASM:
        
        # no active selection in the patching view, nothing to do...
        if not(ctx.cur_flags & ida_kernwin.ACF_HAS_SELECTION):
            return (False, ida_idaapi.BADADDR, ida_idaapi.BADADDR)

        # extract the start/end cursor locations within the IDA disas view
        p0 = ida_kernwin.twinpos_t()
        p1 = ida_kernwin.twinpos_t()

        #
        # this is where we do a special override such that a user can select a
        # few characters on a single instruction / line .. and we will return
        # the 'range' of just that single instruction
        #
        # with a few characters selected / highlighted, IDA will return True
        # to the read_selection() call below
        #

        if ida_kernwin.read_selection(ctx.widget, p0, p1):
            start_ea = p0.at.toea()
            end_ea = p1.at.toea()

            #
            # if the start and end address are the same with a successful
            # selection read, that means the user's selection is on a single
            # line / instruction
            #
            # we will calculate an appropriate 'end_ea' ourselves to capture
            # the length of the entire instruction and return this as our own
            # custom / mini range selection
            #
            # this facilitates the ability for users to revert individual
            # instructions within a patch by selecting a few characters of
            # the instruction in question
            #

            if start_ea == end_ea:
                end_ea = ida_bytes.get_item_end(end_ea)
                return (True, start_ea, end_ea)

    # any other IDA widget / viewer
    return ida_kernwin.read_range_selection(ctx.widget)

def remove_ida_actions(popup):
    """
    Remove default IDA actions from a given IDA popup (handle).
    """
    if not QT_AVAILABLE:
        return None

    #
    # TODO/Hex-Rays:
    #
    # so, i'm pretty picky about my UI / interactions. IDA puts items in
    # the right click context menus of custom (code) viewers.
    #
    # these items aren't really relevant (imo) to the plugin's use case
    # so I do some dirty stuff here to filter them out and ensure only
    # my items will appear in the context menu.
    #
    # there's only one right click context item right now, but in the
    # future i'm sure there will be more.
    #

    class FilterMenu(QtCore.QObject):
        def __init__(self, qmenu):
            super(FilterMenu, self).__init__()
            self.qmenu = qmenu

        def eventFilter(self, obj, event):
            if event.type() != QtCore.QEvent.Polish:
                return False
            for action in self.qmenu.actions():
                if action.text() in ["&Font...", "&Synchronize with"]: # lol..
                    self.qmenu.removeAction(action)
            self.qmenu.removeEventFilter(self)
            self.qmenu = None
            return True

    p_qmenu = ctypes.cast(int(popup), ctypes.POINTER(ctypes.c_void_p))[0]
    if ida_pro.IDA_SDK_VERSION >= 920:
        qmenu = shiboken6.wrapInstance(int(p_qmenu), QtWidgets.QMenu)
    else:
        qmenu = sip.wrapinstance(int(p_qmenu), QtWidgets.QMenu)
    filter = FilterMenu(qmenu)
    qmenu.installEventFilter(filter)

    # return the filter as I think we need to maintain its lifetime in py
    return filter

```

`patching/util/misc.py`:

```py
import os

#------------------------------------------------------------------------------
# Plugin Util
#------------------------------------------------------------------------------

PLUGIN_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))

def plugin_resource(resource_name):
    """
    Return the full path for a given plugin resource file.
    """
    return os.path.join(
        PLUGIN_PATH,
        "ui",
        "resources",
        resource_name
    )

#------------------------------------------------------------------------------
# Misc / OS Util
#------------------------------------------------------------------------------

def is_file_locked(filepath):
    """
    Checks to see if a file is locked. Performs three checks

        1. Checks if the file even exists

        2. Attempts to open the file for reading. This will determine if the
           file has a write lock. Write locks occur when the file is being
           edited or copied to, e.g. a file copy destination

        3. Attempts to rename the file. If this fails the file is open by some
           other process for reading. The file can be read, but not written to
           or deleted.

    Not perfect, but it doesn't have to be. Source: https://stackoverflow.com/a/63761161
    """
    if not (os.path.exists(filepath)):
        return False

    try:
        f = open(filepath, 'r')
        f.close()
    except IOError:
        return True

    try:
        os.rename(filepath, filepath)
        return False
    except WindowsError:
        return True

```

`patching/util/python.py`:

```py
import sys
import struct
import weakref

from types import ModuleType
from importlib import reload

#------------------------------------------------------------------------------
# Python helpers
#------------------------------------------------------------------------------

def hexdump(data, wrap=0):
    """
    Return a spaced string of printed hex bytes for the given data.
    """
    wrap = wrap if wrap else len(data)
    if not data:
        return ''

    lines = []
    for i in range(0, len(data), wrap):
        lines.append(' '.join(['%02X' % x for x in data[i:i+wrap]]))

    return '\n'.join(lines)

def swap_value(value, size):
    """
    Swap endianness of a given value in memory. (size width in bytes)
    """
    if size == 1:
        return value
    if size == 2:
        return struct.unpack("<H", struct.pack(">H", value))[0]
    if size == 4:
        return struct.unpack("<I", struct.pack(">I", value))[0]
    if size == 8:
        return struct.unpack("<Q", struct.pack(">Q", value))[0]
    if size == 16:
        lower64 = swap_value(value & ((1 << 64) - 1), 8)
        upper64 = swap_value((value >> 64), 8)
        return (lower64 << 64) | upper64
    raise ValueError("Invalid input (value %X and size %u" % (value, size))

#------------------------------------------------------------------------------
# Python Callback / Signals
#------------------------------------------------------------------------------

def register_callback(callback_list, callback):
    """
    Register a callable function to the given callback_list.

    Adapted from http://stackoverflow.com/a/21941670
    """

    # create a weakref callback to an object method
    try:
        callback_ref = weakref.ref(callback.__func__), weakref.ref(callback.__self__)

    # create a wweakref callback to a stand alone function
    except AttributeError:
        callback_ref = weakref.ref(callback), None

    # 'register' the callback
    callback_list.append(callback_ref)

def notify_callback(callback_list, *args):
    """
    Notify the given list of registered callbacks of an event.

    The given list (callback_list) is a list of weakref'd callables
    registered through the register_callback() function. To notify the
    callbacks of an event, this function will simply loop through the list
    and call them.

    This routine self-heals by removing dead callbacks for deleted objects as
    it encounters them.

    Adapted from http://stackoverflow.com/a/21941670
    """
    cleanup = []

    #
    # loop through all the registered callbacks in the given callback_list,
    # notifying active callbacks, and removing dead ones.
    #

    for callback_ref in callback_list:
        callback, obj_ref = callback_ref[0](), callback_ref[1]

        #
        # if the callback is an instance method, deference the instance
        # (an object) first to check that it is still alive
        #

        if obj_ref:
            obj = obj_ref()

            # if the object instance is gone, mark this callback for cleanup
            if obj is None:
                cleanup.append(callback_ref)
                continue

            # call the object instance callback
            try:
                callback(obj, *args)

            # assume a Qt cleanup/deletion occurred
            except RuntimeError as e:
                cleanup.append(callback_ref)
                continue

        # if the callback is a static method...
        else:

            # if the static method is deleted, mark this callback for cleanup
            if callback is None:
                cleanup.append(callback_ref)
                continue

            # call the static callback
            callback(*args)

    # remove the deleted callbacks
    for callback_ref in cleanup:
        callback_list.remove(callback_ref)

#------------------------------------------------------------------------------
# Module Reloading
#------------------------------------------------------------------------------

#
# NOTE: these are mostly for DEV / testing and are not required for the
# plugin to actually function. these basically enable hot-reloading plugins
# under the right conditions
#

def reload_package(target_module):
    """
    Recursively reload a 'stateless' python module / package.
    """
    target_name = target_module.__name__
    visited_modules = {target_name: target_module}
    _recursive_reload(target_module, target_name, visited_modules)

def _scrape_module_objects(module):
    """
    Scrape objects from a given module.
    """
    ignore = {"__builtins__", "__cached__", "__doc__", "__file__", "__loader__", "__name__", "__package__", "__spec__", "__path__"}
    values = []

    # scrape objects from the module
    for attribute_name in dir(module):

        # skip objects/refs we don't care about
        if attribute_name in ignore:
            continue

        # fetch the object/class/item definition from the module by its name
        attribute_value = getattr(module, attribute_name)

        # TODO: set/dict/other iterables?
        if type(attribute_value) == list:
            for item in attribute_value:
                values.append(item)
        else:
            values.append(attribute_value)

    # return all the 'interesting' objects scraped from the module
    return values

def _recursive_reload(module, target_name, visited):
    #print("entered", module.__name__)

    # XXX: lol, ignore reloading keystone for now (it probably isn't changing anyway)
    if 'keystone' in module.__name__:
        #reload(module)
        return

    visited[module.__name__] = module
    module_objects = _scrape_module_objects(module)

    for obj in module_objects:

        # ignore simple types
        if type(obj) in [str, int, bytes, bool]:
            continue

        if type(obj) == ModuleType:
            attribute_module_name = obj.__name__
            attribute_module = obj

        elif callable(obj):
            attribute_module_name = obj.__module__
            attribute_module = sys.modules[attribute_module_name]

        # TODO: recursive list obj scraping... / introspection
        elif type(obj) in [list, set, dict, tuple]:
            continue

        #
        # NOTE/XXX: something changed with IDA 7.7 ish to warrant this (module
        # wrappers?) really this should just be something that the ModuleType
        # conditional above catches...
        #

        elif obj.__name__.startswith('ida'):
            continue

        # fail
        else:
            raise ValueError("UNKNOWN TYPE TO RELOAD %s %s" % (obj, type(obj)))

        if not target_name in attribute_module_name:
            #print(" - Not a module of interest...")
            continue

        if "__plugins__" in attribute_module_name:
            #print(" - Skipping IDA base plugin module...")
            continue

        if attribute_module_name in visited:
            continue

        _recursive_reload(attribute_module, target_name, visited)

    #print("Okay done with %s, reloading self!" % module.__name__)
    reload(module)

```

`patching/util/qt.py`:

```py
#
# this global is used to indicate whether Qt bindings for python are present
# and whether the plugin should expect to be using UI features
#

QT_AVAILABLE = False

import ida_pro

if ida_pro.IDA_SDK_VERSION >= 920:
    # attempt to load PySide6
    try:
        import PySide6.QtGui as QtGui
        import PySide6.QtCore as QtCore
        import PySide6.QtWidgets as QtWidgets
        import shiboken6

        # importing PySide6 went okay, let's see if we're in an IDA Qt context
        try:
            import ida_kernwin
            QT_AVAILABLE = ida_kernwin.is_idaq()
        except ImportError:
            pass

    # import failed, PySide6 is not available
    except ImportError:
        pass
else:
    # attempt to load PyQt5
    try:
        import PyQt5.QtGui as QtGui
        import PyQt5.QtCore as QtCore
        import PyQt5.QtWidgets as QtWidgets
        from PyQt5 import sip

        # importing PyQt5 went okay, let's see if we're in an IDA Qt context
        try:
            import ida_kernwin
            QT_AVAILABLE = ida_kernwin.is_idaq()
        except ImportError:
            pass

    # import failed, PyQt5 is not available
    except ImportError:
        pass

#--------------------------------------------------------------------------
# Qt Misc Helpers
#--------------------------------------------------------------------------

def get_main_window():
    """
    Return the Qt Main Window.
    """
    app = QtWidgets.QApplication.instance()
    for widget in app.topLevelWidgets():
        if isinstance(widget, QtWidgets.QMainWindow):
            return widget
    return None

def center_widget(widget):
    """
    Center the given widget to the Qt Main Window.
    """
    main_window = get_main_window()
    if not main_window:
        return False

    #
    # compute a new position for the floating widget such that it will center
    # over the Qt application's main window
    #

    rect_main = main_window.geometry()
    rect_widget = widget.rect()

    centered_position = rect_main.center() - rect_widget.center()
    widget.move(centered_position)

    return True

```

`readme.txt`:

```txt
é›†æˆä»¥ä¸‹æ’ä»¶
- LazyIDA
    ç§»é™¤ä¸å¸¸ç”¨åŠŸèƒ½ã€ä¸Žå…¶ä»–æ’ä»¶å†²çªåŠŸèƒ½
- patching
    ç§»é™¤å†…ç½® keystoneï¼Œå› ä¸ºçœ‹å®ƒä¸é¡ºçœ¼ï¼Œè‡ªå·±æƒ³åŠžæ³•å®‰è£…å§
- ida-pro-mcp
    è‡ªå·±å®‰è£…
    pip uninstall ida-pro-mcp
    pip install https://github.com/mrexodia/ida-pro-mcp/archive/refs/heads/main.zip
    ida-pro-mcp --install
- findcrypt-yara
    æ·»åŠ  sm4 æ”¯æŒ...
- diaphora
    äºŒè¿›åˆ¶ diff å·¥å…·ï¼Œéœ€è¦è‡ªå·±ä¿®æ”¹ diaphora_plugin.cfg
    é€‚é… IDA Pro 9.2+
- d810
    åæ··æ·†å·¥å…·
    é€‚é… IDA Pro 9.2+
```

`requirements.txt`:

```txt
# ida-pro-mcp==1.4.0
# keystone-engine==0.9.3
cdifflib==1.2.9
scikit_learn==1.7.2
numpy==2.3.2
pandas==2.3.2
joblib==1.5.2
nltk==3.9.1
yara-python==4.5.4
z3-solver==4.15.3
```